globals
trigger e=null
hashtable array o
integer array V
integer array E
integer X
integer O=-$7FFFFFFD
constant integer R=O+455
integer array I
integer array A
constant integer N=O+8192+266*8192
integer array B
unit array C
integer array D
integer f=0
constant integer F=0-1
integer G=F
string array h
integer H=F
hashtable j
integer array J
integer k=0
integer K=500
timer l=CreateTimer()
integer L=-1
string M="<StructTable>"
hashtable P
constant integer q=0+1
constant integer Q=O+8192+264*8192
integer S=0
string T="<EventResponse>"
constant integer U=1-1
constant integer w=U
integer array W
integer Y=U
constant integer Z=U-1
integer array vv
boolean array ev
boolean array xv
integer ov
trigger rv
integer iv
integer array av
integer array nv
integer array Vv
integer array Ev
integer Xv=F
integer array Ov
integer array Rv
integer Iv
integer Av
integer Nv
integer bv
boolexpr array Bv
integer array cv
integer Cv=0
trigger array dv
string Dv="<Trigger>"
integer array fv
string array Fv
string array gv
string array Gv
integer array hv
integer array Hv
integer jv
trigger Jv
integer array kv
gamecache array Kv
integer array lv
constant integer Lv=$D3
constant integer mv=O+Lv
integer array Mv
integer pv
integer Pv
trigger qv=null
constant integer Qv=-1
trigger sv=null
constant integer Sv=O+8192+20*8192
trigger tv=null
integer Tv=0
string uv="<GameMessage>"
integer array Uv
integer wv=U
integer array Wv
boolean array yv
boolean array Yv
integer zv
integer Zv=F
integer ve=0
string ee="<Timer>"
integer array xe
integer oe=U
integer array re
boolean array ie
boolean array ae
integer array ne
integer array Ve
integer Ee
integer Xe
timer array Oe
constant integer Re=$E7
integer array Ie
constant integer Ae=$E6
constant integer Ne=O+8192+Ae*8192
integer array be
string array Be
real array ce
boolean array Ce
integer array de
boolean array De
integer array fe
string array Fe
integer array ge
integer Ge
integer he=F
integer array He
integer array je
integer array Je
integer array ke
integer Ke=F
integer array le
string array Le
trigger me=null
real array Me
integer pe
trigger Pe=null
integer qe=w
integer array Qe
integer array se
constant integer Se=O+16
integer te
integer array Te
integer array ue
string array Ue
integer We
integer array ye
trigger Ye=null
integer array ze
boolean array Ze
player array vx
integer ex
playercolor array xx
playercolor array ox
integer rx
constant integer ix=O+382
trigger ax=null
boolean nx=false
real Vx
rect Ex=null
rect Xx=null
rect Ox=null
rect Rx=null
rect Ix=null
rect Ax=null
rect Nx=null
rect bx=null
rect Bx=null
rect cx=null
rect Cx=null
rect Dx=null
rect fx=null
rect Fx=null
rect gx=null
rect Gx=null
rect hx=null
rect Hx=null
rect jx=null
rect Jx=null
rect kx=null
rect Kx=null
rect lx=null
rect Lx=null
rect mx=null
rect Mx=null
rect px=null
rect Px=null
rect qx=null
rect Qx=null
rect sx=null
rect Sx=null
rect tx=null
rect Tx=null
rect ux=null
rect Ux=null
rect wx=null
rect Wx=null
rect yx=null
rect Yx=null
rect zx=null
rect Zx=null
rect vo=null
rect eo=null
rect xo=null
rect oo=null
rect ro=null
rect io=null
rect ao=null
rect no=null
rect Vo=null
rect Eo=null
rect Xo=null
rect Oo=null
rect Ro=null
rect Io=null
rect Ao=null
rect No=null
rect bo=null
rect Bo=null
rect co=null
rect Co=null
rect do=null
rect Do=null
rect fo=null
rect Fo=null
rect go=null
rect Go=null
rect ho=null
rect Ho=null
rect jo=null
camerasetup Jo=null
camerasetup ko=null
camerasetup Ko=null
camerasetup lo=null
camerasetup Lo=null
camerasetup mo=null
camerasetup Mo=null
camerasetup po=null
camerasetup Po=null
camerasetup qo=null
camerasetup Qo=null
camerasetup so=null
camerasetup So=null
camerasetup to=null
camerasetup To=null
destructable uo=null
destructable Uo=null
destructable wo=null
destructable Wo=null
destructable yo=null
destructable Yo=null
destructable zo=null
destructable Zo=null
destructable vr=null
destructable er=null
destructable xr=null
destructable rr=null
destructable ir=null
destructable ar=null
integer nr=0
unit Vr=null
unit Er=null
unit Xr=null
unit Rr=null
unit Ir=null
unit Ar=null
unit Nr=null
unit br=null
unit Br=null
unit cr=null
unit Cr=null
unit dr=null
unit Dr=null
unit fr=null
unit Fr=null
unit gr=null
unit Gr=null
unit hr=null
unit Hr=null
unit jr=null
unit Jr=null
unit kr=null
unit Kr=null
triggeraction lr=null
trigger Lr=CreateTrigger()
boolean mr=false
real Mr
sound pr
integer Pr=F
integer qr=0
integer array Qr
integer sr=U
integer array Sr
boolean array tr
boolean array Tr
integer ur
integer Ur=0
integer array wr
string array Wr
trigger array yr
integer Yr=w
integer array zr
integer array Zr
integer vi=w
trigger array ei
integer array xi
string array oi
integer ri
integer ii=0
string ai="<EffectLevel>"
integer array ni
integer Vi=U
integer array Ei
boolean array Xi
boolean array Oi
integer Ri
string array Ii
integer Ai=F
integer array Ni
integer array bi
integer Bi
integer ci
integer Ci=F
trigger array di
integer array Di
string array fi
integer Fi=F
trigger array gi
integer array Gi
string array hi
integer Hi=F
trigger array ji
integer array Ji
string array ki
integer Ki
hashtable li=null
integer Li=0
string mi="<ObjThread>"
integer array Mi
integer pi=U
integer array Pi
boolean array qi
boolean array Qi
integer si
string array Si
integer ti=F
integer array Ti
integer array ui
timer Ui=null
boolean wi=true
integer Wi
integer yi
integer Yi
hashtable zi=null
hashtable Zi=null
constant integer va=$EC
constant integer ea=O+8192+va*8192
integer xa=F
trigger array oa
integer array ra
string array ia
integer aa=F
trigger array na
integer array Va
string array Ea
integer Xa=F
trigger array Oa
integer array Ra
string array Ia
integer Aa=F
trigger array Na
integer array ba
string array Ba
integer ca=F
trigger array Ca
integer array da
string array Da
integer fa=F
trigger array Fa
integer array ga
string array Ga
constant integer ha=$82
constant integer Ha=O+8192+ha*8192
constant integer ja=O+8192+457*8192
constant integer Ja=$DF
constant integer ka=O+8192+Ja*8192
constant integer Ka=$DE
constant integer la=O+8192+Ka*8192
constant integer La=$CB
constant integer ma=O+8192+La*8192
constant integer Ma=O+8192+35*8192
constant integer pa=O+8192+39*8192
constant integer Pa=$DC
constant integer qa=O+8192+Pa*8192
constant integer Qa=$80
constant integer sa=O+8192+Qa*8192
constant integer Sa=O+8192+421*8192
integer ta=F
trigger array Ta
integer array ua
string array Ua
integer wa=F
trigger array Wa
integer array ya
string array Ya
integer za=F
trigger array Za
integer array vn
string array en
integer xn=F
trigger array on
integer array rn
string array in
integer an=F
trigger array nn
integer array Vn
string array En
integer Xn=F
trigger array On
integer array Rn
string array In
integer An=F
trigger array Nn
integer array bn
string array Bn
integer cn=F
trigger array Cn
integer array dn
string array Dn
integer fn=F
trigger array Fn
integer array gn
string array Gn
integer hn=F
trigger array Hn
integer array jn
string array Jn
integer kn=F
trigger array Kn
integer array ln
string array Ln
integer mn=F
trigger array Mn
integer array pn
string array Pn
integer qn=F
trigger array Qn
integer array sn
string array Sn
integer tn=F
trigger array Tn
integer array un
string array Un
integer wn=F
trigger array Wn
integer array yn
string array Yn
integer zn=F
trigger array Zn
integer array vV
string array eV
integer xV=F
trigger array oV
integer array rV
string array iV
integer aV=F
trigger array nV
integer array VV
string array EV
integer XV=F
trigger array OV
integer array RV
string array IV
integer AV=F
trigger array NV
integer array bV
string array BV
integer cV=F
trigger array CV
integer array dV
string array DV
integer fV=F
trigger array FV
integer array gV
string array GV
integer hV=F
trigger array HV
integer array jV
string array JV
integer kV=F
trigger array KV
integer array lV
string array LV
integer mV=F
trigger array MV
integer array pV
string array PV
integer qV=F
trigger array QV
integer array sV
string array SV
integer tV=F
trigger array TV
integer array uV
string array UV
integer wV=F
trigger array WV
integer array yV
string array YV
integer zV=F
trigger array ZV
integer array vE
string array eE
real xE
real oE
real rE
real iE
real aE
real nE
real VE
real EE
integer XE
integer OE
timer RE
trigger IE
integer AE
integer NE=F
integer array bE
integer BE
integer array cE
integer array CE
integer array dE
integer array DE
integer fE=F
integer FE=0
integer gE
integer GE=0
integer hE=F
string array HE
string jE="<Queue>"
integer JE
string kE="<StructInteger>"
integer KE
string lE="<StructHex>"
hashtable LE=null
integer mE
integer ME=0
string pE="<LightningType>"
integer array PE
integer qE=U
integer array QE
boolean array sE
boolean array SE
integer tE
string array TE
integer uE
string UE="<StructShapes>"
integer array wE
integer WE
constant integer yE=$400
integer YE
integer array zE
integer ZE
string vX="<StructBoolean>"
integer eX
string xX="<StructInteger>"
integer oX
string rX="<StructReal>"
integer iX
string aX="<StructString>"
integer nX
string VX="<GameCache>"
integer EX
string XX="<StructBoolean>"
integer OX
string RX="<StructInteger>"
integer IX
string AX="<StructReal>"
integer NX
string bX="<StructString>"
integer BX
string cX="<HashTable>"
integer CX
string DX="<StructD2>"
integer fX
string FX="<StructIntegerKeys>"
integer gX
string GX="<StructStringKeys>"
integer hX
string HX="<DataTableHead>"
integer jX
string JX="<StructTable>"
integer kX
string KX="<StructD2>"
integer lX
integer LX
string mX="<StructIntegerKeys>"
integer MX
string pX="<StructTable>"
integer PX
string qX="<StructStringKeys>"
integer QX
string sX="<StructNative>"
integer SX
string tX="<DataTable>"
integer TX
integer uX=0
integer array UX
integer wX=U
integer array WX
boolean array yX
boolean array YX
integer zX=0
integer array ZX
integer vO=U
integer array eO
boolean array xO
boolean array oO
integer rO=0
integer array iO
integer aO=U
integer array nO
boolean array VO
boolean array EO
integer array XO
integer OO=0
integer array RO
integer IO=U
integer array AO
boolean array NO
boolean array bO
integer array BO
integer array cO
integer array CO
integer array dO
integer array DO
integer array fO
hashtable array FO
integer gO
string GO="<Animation>"
integer hO
string HO="<AttachPoint>"
integer jO
string JO="<Attack>"
real array kO
integer KO
string lO="<StructAct>"
integer LO
string mO="<StructAura>"
integer MO
string pO="<StructBool>"
integer PO
string qO="<StructBuff>"
integer QO
string sO="<StructDefenderSpawnType>"
integer SO
string tO="<StructDestructable>"
integer TO
string uO="<StructDestructableType>"
integer UO
string wO="<StructDialog>"
integer WO
string yO="<StructDummyUnit>"
integer YO
string zO="<StructDynamic>"
integer ZO
string vR="<StructEvent>"
integer eR
string xR="<StructItem>"
integer oR
string rR="<StructItemType>"
integer iR
string aR="<StructLevel>"
integer nR
string VR="<StructLightning>"
integer ER
string XR="<StructMissile>"
integer OR
string RR="<StructMissileCheckpoint>"
integer IR
string AR="<StructOrder>"
integer NR
string bR="<StructReal>"
integer BR
string cR="<StructSpawnType>"
integer CR
string dR="<StructSpell>"
integer DR
string fR="<StructSpellInstance>"
integer FR
string gR="<StructSpot>"
integer GR
string hR="<StructString>"
integer HR
string jR="<StructTile>"
integer JR
string kR="<StructUbersplat>"
integer KR
string lR="<StructUnit>"
integer LR
string mR="<StructUnitEffect>"
integer MR
string pR="<StructUnitMod>"
integer PR
string qR="<StructUnitType>"
integer QR
string sR="<StructUser>"
integer SR
string tR="<EventPriority>"
integer TR
string uR="<EventType>"
integer UR
string wR="<StructId>"
integer WR
string yR="<StructBoolean>"
integer YR
string zR="<StructTable>"
integer ZR
string vI="<StructInteger>"
integer eI
string oI="<StructData>"
integer rI
string iI="<StructLimit>"
integer aI
string nI="<Event>"
integer VI
integer EI=0
integer array XI
integer OI=U
integer array RI
boolean array II
boolean array AI
integer NI
integer array bI
integer BI
integer cI=0
integer array CI
integer dI=U
integer array DI
boolean array fI
boolean array FI
string array gI
integer array GI
integer hI
integer HI
integer jI
integer JI
integer kI
integer KI
integer lI
integer LI
integer mI
integer MI
integer pI
integer PI
integer qI
string QI="<CharacterSpeech>"
integer sI=0
string SI="<CommandHeader>"
integer array tI
integer TI=U
integer array uI
boolean array UI
boolean array wI
integer WI
integer YI=0
integer array zI
integer ZI=U
integer array vA
boolean array eA
boolean array xA
integer array oA
integer array rA
integer array iA
integer array aA
integer array nA
constant integer VA=$D
constant integer EA=O+8192+VA*8192
boolean array XA
integer array OA
limitop array RA
integer IA=0
integer array AA
integer NA=U
integer array bA
boolean array BA
boolean array cA
integer array CA
integer dA
trigger array DA
trigger array fA
constant integer FA=$EA
constant integer gA=O+FA
integer array GA
constant integer hA=$E8
constant integer HA=O+8192+hA*8192
boolexpr jA
string array JA
constant integer kA=$E
constant integer KA=O+kA
constant integer lA=8190+1
integer LA
string array mA
string array MA
constant integer pA=O+17
integer array PA
integer qA
constant integer QA=$E9
constant integer sA=O+QA
integer SA
constant integer tA=O+23
integer TA=0
string uA="<BoolExpr>"
integer array UA
integer wA=U
integer array WA
boolean array yA
boolean array YA
integer zA
constant integer ZA=-1
integer vN=w
integer array eN
boolean array xN
real array oN
real array rN
real array iN
string array aN
texttag array nN
location array VN
integer EN
constant integer XN=$E3
constant integer ON=O+XN
integer RN=0
integer IN=0
string AN="<TextTag>"
integer array NN
integer bN=U
integer array BN
boolean array cN
boolean array CN
integer dN
integer array DN
real array fN
string array FN
real array gN
constant real GN=(2*1.)*1./ 32
integer array hN
boolean array HN
real array jN
integer JN=F
integer array kN
integer array KN
integer lN
boolean array LN
integer array mN
integer array MN
integer pN=F
integer PN
integer array qN
boolean array QN
integer array sN
integer array SN
integer tN=F
integer TN
integer array uN
integer array UN
integer array wN
integer WN=F
integer yN
real array YN
constant real zN=(2*1.)*1./ 32
real array ZN
integer array vb
real array eb
real array xb
real array ob
string array rb
string array ib
real ab=.023
integer nb
string Vb="<ClearSpawns>"
integer array Eb
integer array Xb
integer Ob
constant integer Rb=O+8192+'h'*8192
integer Ib
integer Ab
integer Nb
string bb="<CommandAutoCast>"
integer Bb
integer array cb
integer array Cb
constant integer db=O+8192+381*8192
integer Db=lA
integer fb=F
integer Fb=0
string gb="<Group>"
integer array Gb
integer hb=U
integer array Hb
boolean array jb
boolean array Jb
integer kb
group array Kb
integer array lb
integer array Lb
boolean array mb
integer array Mb
integer pb
integer array Pb
integer array qb
integer array Qb
integer sb
integer array Sb
integer tb
string Tb="<CommandBuff>"
constant integer ub=O+34
integer Ub
integer wb
real Wb
constant integer yb=O+8192+284*8192
integer array Yb
constant integer zb=O+8192+286*8192
integer array Zb
constant integer vB=O+290
constant integer eB=O+8192+282*8192
integer xB
integer oB
constant integer rB=O+280
boolean array iB
integer array aB
integer array nB
integer array VB
integer EB
boolean array XB
effect array OB
effect array RB
integer array IB
integer array AB
integer NB=F
integer array bB
integer array BB
string cB="<UnitEffect>"
boolean array CB
integer array dB
integer DB
constant integer fB=O+288
boolean array FB
sound array gB
integer array GB
integer array hB
boolean array HB
boolean array jB
integer array JB
string kB="<Sound>"
boolean array KB
integer lB
boolean array LB
integer array mB
integer array MB
integer array pB
string PB="<UnitSound>"
boolean array qB
integer QB
constant integer sB=O+405
integer array SB
integer array tB
integer array TB
boolean array uB
integer array UB
integer array wB
string WB="<BuffRef>"
boolean array yB
integer YB
integer array zB
integer array ZB
constant integer vc=O+8192+33*8192
constant integer ec=O+8192+294*8192
integer array xc
integer array oc
constant integer rc=O+8192+389*8192
boolean array ic
integer array ac
constant integer nc=O+8192+390*8192
constant integer Vc=O+8192+391*8192
real array Ec
constant integer Xc=O+8192+392*8192
constant integer Oc=O+8192+393*8192
constant integer Rc=O+399
constant integer Ic=$C
constant integer Ac=O+Ic
constant integer Nc=O+395
constant integer bc=O+400
constant integer Bc=O+396
constant integer cc=O+401
constant integer Cc=O+397
constant integer dc=O+402
constant integer Dc=O+398
boolean array fc
constant integer Fc=O+8192+403*8192
integer array Gc
integer array hc
integer array Hc
integer array jc
integer Jc
integer array kc
constant integer Kc=O+8192+29*8192
constant integer lc=O+292
integer array Lc
integer array mc
integer array Mc
integer pc
boolean array Pc
boolean array qc
integer array Qc
integer sc
boolean array Sc
constant integer tc=O+8192+27*8192
integer Tc=0
integer uc=U
string array Uc
boolean array wc
integer array Wc
string array yc
integer array Yc
constant integer zc=O+8192+80*8192
integer Zc
integer vC
integer eC
integer xC
constant integer oC=O+8192+76*8192
integer rC
constant integer iC=O+8192+25*8192
constant integer aC=O+8192+26*8192
constant integer nC=O+8192+28*8192
integer VC=0
integer EC=U
boolean array XC
integer OC=0
integer RC=U
string array IC
string array AC
integer array NC
integer array bC
integer array BC
integer array cC
real array CC
real array dC
real array DC
real array fC
integer array FC
integer array gC
real array GC
real array hC
real array HC
real array jC
real array JC
real array kC
boolean array KC
boolean array lC
boolean array LC
boolean array mC
boolean array MC
real array pC
real array PC
real array qC
real array QC
real array sC
real array SC
real array tC
real array TC
real array uC
real array UC
real array wC
real array WC
real array yC
real array YC
real array zC
real array ZC
real array vd
real array ed
string array xd
real array od
real rd=1.
constant integer ad=O+8192+30*8192
integer nd=0
integer Vd=U
boolean array Ed
integer array Xd
integer array Od
integer Rd
integer Id
integer Ad
integer Nd
trigger bd
integer Bd
boolean cd
trigger Cd
constant integer dd=O+274
integer Dd=0
string fd="<StructTimed>"
integer array Fd
integer gd=U
integer array Gd
boolean array hd
boolean array Hd
integer jd
integer array Jd
integer array kd
integer array Kd
constant integer ld=O+8192+272*8192
integer array Ld
integer array md
integer array Md
integer array pd
string Pd="<StructCountdown>"
boolean array qd
integer Qd
constant integer sd=O+8192+270*8192
integer Sd
integer array td
constant integer Td=O+8192+276*8192
integer ud
integer Ud
boolean array wd
constant real Wd=-1.
integer yd
boolean array Yd
integer zd=0
integer Zd=U
boolean array vD
integer array eD
boolean array xD
integer array oD
string array rD
integer iD=F
integer array aD
integer nD
string VD="<CommandCreateQuake>"
integer ED=0
string XD="<StructSeismic>"
integer array OD
integer RD=U
integer array ID
boolean array AD
boolean array ND
integer bD
integer array BD
real array cD
real array CD
real array dD
constant real DD=(4*1.)*1./ 32
real array fD
real array FD
integer array gD
integer GD=F
integer hD=0
string HD="<Force>"
integer array jD
integer JD=U
integer array kD
boolean array KD
boolean array lD
integer LD
force array mD
integer array MD
real array pD
real array PD
real array qD
integer array QD
integer array sD
integer SD=F
integer tD
trigger TD
string uD="<User>"
real array UD
real array wD
constant real WD=(2*1.)*1./ 32
integer array yD
integer YD=F
integer array ZD
integer vf
real array ef
constant real xf=(1*1.)*1./ 32
real array of
integer array rf
boolean array af
integer array nf
integer array Vf
integer Ef=F
integer Xf
boolean array Of
boolean array Rf
boolean array If
boolean array Af
code Nf
real array bf
real array Bf
real array cf
constant real Cf=2*3.141592654
constant real df=Cf
integer Df
string ff="<CommandCreateUnit>"
constant integer Ff=O+419
real gf
real Gf
real hf
integer Hf
integer jf
integer Jf
constant real kf=1.5*3.141592654
real Kf=kf
integer lf
string Lf="<CommandDebug>"
integer mf
string Mf="<CommandExp>"
real pf
real array Pf
integer qf
string Qf="<CommandHeroAttribute>"
string sf
real Sf
real array tf
integer array Tf
integer array uf
real array Uf
real array wf
real array Wf
integer yf=0
real array Yf
real array zf
real array Zf
real array vF
real array eF
real array xF
real array oF
real array rF
real array iF
real array aF
real array nF
integer VF=1
real array EF
real array XF
real array OF
boolean array RF
integer IF
integer AF=6
integer array NF
integer bF=6
integer array BF
integer array cF
integer CF=w
real array dF
real array DF
real array fF
real array FF
real array gF
real array GF
integer hF
integer array HF
integer jF=F
integer array JF
integer kF
integer array KF
integer lF=F
real array LF
real array mF
integer MF
real array pF
real array PF
real qF=.2
real array QF
integer sF=256
integer SF='TM73'
integer array tF
integer TF=256
integer uF='SM73'
integer array UF
real array wF
real array WF
integer yF=$F
real array YF
real array zF
real array ZF
real array vg
real array eg
integer xg=2
real array og
real array rg
real array ig
boolean array ag
integer ng
integer Vg=6
integer array Eg
integer Xg=6
integer array Og
integer array Rg
integer Ig=w
real array Ag
real array Ng
real array bg
real array Bg
real array cg
real array Cg
boolean array dg
integer Dg
integer fg
integer Fg
integer gg=7
integer array Gg
item array hg
integer Hg=7
item array jg
integer Jg=w
real array kg
real array Kg
real array lg
real array Lg
real array mg
real array Mg
real array pg
boolean array Pg
integer qg
integer Qg=6
integer array sg
integer Sg=6
integer array tg
integer array Tg
integer ug=w
real array Ug
real wg=.5
real array Wg
real array yg
integer Yg
integer array zg
integer Zg=F
integer array vG
integer eG
integer array xG
integer oG=F
real array rG
real array iG
boolean array aG
real array nG
real array VG
constant real EG=2*1./ 1.5*(.25+SquareRoot(.25*(.25-.0)))
constant real XG=(1*1.)*1./ 32
real array OG
constant real RG=-.5*EG*EG*1./ .25
real array IG
real array AG
real array NG
real array bG
constant real BG=2*1./ 1.5*(100.+SquareRoot(100.*(100.-25.)))
real array cG
constant real CG=-.5*BG*BG*1./ 100.
constant integer dG=O+8192+312*8192
constant real DG=.405+1.
integer fG=w
integer array FG
integer gG
integer GG
integer hG
real array HG
real array jG
real JG=.25
real array kG
integer KG=256
integer lG='TL73'
integer array LG
integer mG=256
integer MG='SL73'
integer array pG
real array PG
real array qG
integer QG=25
real array sG
real array SG
real array tG
boolean array TG
integer uG
integer UG=6
integer array wG
integer WG=6
integer array yG
integer array YG
integer zG=w
real array ZG
real array vh
integer eh
string xh="<CommandKillUnit>"
integer oh
string rh="<CommandRefreshAbility>"
integer ih
integer ah
constant integer nh=O+8192+258*8192
boolean array Vh
boolean array Eh
boolean array Xh
integer array Oh
integer array Rh
integer array Ih
integer array Ah
integer array Nh
constant real bh=3.141592654*1./ 180.
integer Bh
integer ch
integer Ch
integer dh
integer Dh
constant integer fh=O+8192+298*8192
integer array Fh
integer array gh
item array Gh
constant integer hh=O+'t'
integer array Hh
constant integer jh=O+8192+366*8192
integer Jh=F
integer array kh
integer array Kh
integer array lh
constant integer Lh=O+8192+'n'*8192
integer mh
boolean array Mh
integer array ph
integer array Ph
integer array qh
integer array Qh
integer sh
constant integer Sh=O+8192+'p'*8192
integer array Th
integer array uh
integer array Uh
real array wh
real array Wh
constant integer yh=O+8192+'r'*8192
integer Yh=0
string zh="<SpellInstance>"
integer array Zh
integer vH=U
integer array eH
boolean array xH
boolean array oH
integer rH
real array iH
integer array aH
integer array nH
real array VH
real array EH
integer array XH
integer array OH
real array RH
integer array IH
boolean array AH
integer array NH
constant integer bH=$D8
constant integer BH=O+8192+bH*8192
integer cH
real CH
integer dH
constant integer DH=$D9
constant integer fH=O+8192+DH*8192
integer FH=0
string gH="<StructCooldown>"
integer array GH
integer hH=U
integer array HH
boolean array jH
boolean array JH
integer kH
integer array KH
integer array lH
integer array LH
constant integer mH=O+8192+256*8192
integer MH
integer pH
integer PH
constant integer qH=$DA
constant integer QH=O+8192+qH*8192
string array sH
integer SH
real array tH
integer array TH
integer array uH
real array UH
real array wH
integer array WH
boolean yH=false
integer YH
integer array zH
integer array ZH
boolean array vj
integer array ej
integer array xj
string oj="<OrderInstance>"
boolean array rj
integer ij
integer aj
integer nj
constant real Vj=1.*1./ 64
constant real Ej=Vj*16
constant integer Xj=$C6
constant integer Oj=O+Xj
string Rj="<UnitList>"
string array Ij
integer Aj
integer array Nj
integer bj
integer array Bj
integer array cj
real array Cj
real array dj
integer Dj
integer array fj
integer array Fj
integer array gj
integer Gj
integer hj
integer Hj
boolean jj=false
constant integer Jj=$F
constant integer kj=O+Jj
integer Kj=-1
integer array lj
integer array Lj
integer array mj
integer Mj
integer pj
string Pj="<CommandRemoveUnit>"
integer qj
string Qj="<CommandScaleUnit>"
real sj
real Sj
real array tj
real array Tj
integer uj
integer array Uj
integer wj=-5
real Wj=.02
integer yj=0
integer Yj=500
unit array zj
integer Zj
constant real vJ=-8192
constant real eJ=8192
string xJ="<StructX>"
real array oJ
constant real rJ=-8192
constant real iJ=8192
string aJ="<StructY>"
real array nJ
integer VJ
integer EJ
constant real XJ=(2*1.)*1./ 32
integer OJ=0
string RJ="<StructTimed>"
integer array IJ
integer AJ=U
integer array NJ
boolean array bJ
boolean array BJ
integer cJ
integer array CJ
integer array dJ
real array DJ
constant integer fJ=O+8192+328*8192
integer FJ
integer gJ=F
integer array GJ
integer array hJ
integer HJ
integer jJ
string JJ="<CommandSpell>"
integer kJ
integer KJ
integer lJ=F
integer array LJ
integer mJ
string MJ="<CommandSwift>"
real pJ
integer PJ
integer qJ
integer array QJ
integer array sJ
integer SJ
string tJ="<CommandTest>"
integer TJ
string uJ="<CommandVertexColorUnit>"
real UJ
real wJ
real WJ
real yJ
real YJ
real array zJ
real array ZJ
real array vk
real array ek
boolean array xk
constant integer ok=$80
constant integer rk=O+8192+342*8192
constant integer ik=O+8192+344*8192
constant integer ak=O+8192+346*8192
constant integer nk=O+8192+348*8192
constant real Vk=Vj*16
integer Ek=0
string Xk="<StructTimed>"
integer array Ok
integer Rk=U
integer array Ik
boolean array Ak
boolean array Nk
integer bk
real array Bk
real array ck
real array Ck
real array dk
integer array Dk
integer array fk
constant integer Fk=O+8192+336*8192
integer gk
integer Gk=F
integer array hk
integer array Hk
integer jk
integer Jk
string kk="<MoveUnit>"
real Kk
real lk
string Lk="<StructX>"
string mk="<StructY>"
integer Mk
string pk="<PingSpawns>"
boolean Pk
integer qk
string Qk="<RequestEvent>"
integer sk
string Sk="<RequestKeyMacro>"
integer tk
string Tk="<RequestTimers>"
integer array uk
integer Uk=F
integer wk
string Wk="<SetDmgTest>"
real yk
integer Yk
string zk="<SetVar>"
integer Zk
string vK="<StructVotes>"
integer eK
string xK="<VoteHost>"
integer oK
boolean rK=false
boolean iK=false
integer aK
integer nK
string VK="<AIAutoCast>"
integer EK
constant integer XK=$F8
constant integer OK=O+8192+XK*8192
constant integer RK=$F6
constant integer IK=O+RK
integer AK=w
integer array NK
integer array bK
constant integer BK=O+8192+22*8192
integer cK
constant integer CK=O+88
integer dK
integer DK
integer fK
integer FK
integer gK
integer GK
integer hK
string HK="<StructId>"
integer jK
string JK="<StructBoolean>"
integer kK
string KK="<StructTable>"
integer lK
string LK="<StructInteger>"
integer mK
string MK="<StructTable>"
integer pK
string PK="<StructReal>"
integer qK
string QK="<StructTable>"
integer sK
string SK="<StructString>"
integer tK
string TK="<StructData>"
integer uK
string UK="<StructEvent>"
integer wK
string WK="<StructTargetEffects>"
integer yK
string YK="<StructLoopSounds>"
integer zK
string ZK="<StructVariants>"
integer vl
string xl="<StructUnitMods>"
integer ol
string rl="<StructUnitModSets>"
integer il
string al="<Buff>"
integer nl
string Vl="<StructTimed>"
integer El
string Xl="<CameraField>"
integer Ol
string Rl="<StructEye>"
integer Il
string Al="<StructTarget>"
integer Nl
string bl="<StructPanTimedViaBounds>"
integer Bl
string cl="<StructShake>"
integer Cl
string dl="<Camera>"
integer Dl=-1
integer array fl
integer array Fl
integer gl
integer Gl
boolean hl=false
integer Hl=F
integer array jl
string array Jl
string array kl
string array Kl
integer ll
integer Ll
integer ml=0
integer array Ml
integer pl=U
integer array Pl
boolean array ql
boolean array Ql
camerafield array sl
integer Sl
integer tl
integer Tl
integer ul
integer Ul
integer wl
integer Wl
string yl="<StructId>"
integer Yl
string zl="<StructBoolean>"
integer Zl
string vL="<StructTable>"
integer eL
string xL="<StructInteger>"
integer oL
string rL="<StructTable>"
integer iL
string aL="<StructReal>"
integer nL
string VL="<StructData>"
integer EL
string XL="<StructEvent>"
integer OL
string RL="<StructPreload>"
integer IL
integer AL=0
string NL="<DestructableType>"
integer array bL
integer BL=U
integer array cL
boolean array CL
boolean array dL
integer array DL
integer array fL
integer FL
integer array gL
constant integer GL=O+38
string array hL
integer array HL
constant integer jL=O+8192+37*8192
integer JL
integer kL
string KL="<StructId>"
integer lL
string LL="<StructBoolean>"
integer mL
string ML="<StructTable>"
integer pL
string PL="<StructInteger>"
integer qL
string QL="<StructTable>"
integer sL
string SL="<StructReal>"
integer tL
string TL="<StructData>"
integer uL
string UL="<StructNative>"
integer wL
string WL="<StructEvent>"
integer yL
string YL="<StructType>"
integer zL
string ZL="<StructTimedLife>"
integer vm
string em="<StructInRange>"
integer xm
string om="<StructEnum>"
integer rm
string im="<StructLife>"
integer am
string nm="<Destructable>"
integer Vm
integer Em
integer Xm
integer Om
integer array Rm
integer array Im
integer array Am
constant integer Nm=O+42
rect array bm
integer Bm
integer cm=0
integer array Cm
integer dm=U
integer array Dm
boolean array fm
boolean array Fm
integer array gm
destructable array Gm
real array hm
real array Hm
real array jm
constant integer Jm=O+8192+40*8192
integer array km
integer array Km
integer lm
integer Lm=0
string mm="<Rectangle>"
integer array Mm
integer pm=U
integer array Pm
boolean array qm
boolean array Qm
integer array sm
integer Sm
real array tm
real array Tm
real array um
real array Um
real array wm
real array Wm
integer array ym
constant integer Ym=$C8
constant integer zm=O+8192+Ym*8192
integer Zm
integer vM
constant integer eM=O+41
integer array xM
integer array oM
boolean array rM
integer array iM
integer aM
string nM="<StructId>"
integer VM
string EM="<StructTable>"
integer XM
string OM="<StructBoolean>"
integer RM
string IM="<StructInteger>"
integer AM
string NM="<StructReal>"
integer bM
string BM="<StructData>"
integer cM
string CM="<StructNative>"
integer dM
string DM="<StructEvent>"
integer fM
string FM="<DialogButton>"
integer gM
string GM="<StructId>"
integer hM
string HM="<StructTable>"
integer jM
string JM="<StructBoolean>"
integer kM
string KM="<StructInteger>"
integer lM
string LM="<StructReal>"
integer mM
string MM="<StructData>"
integer pM
string PM="<StructNative>"
integer qM
string QM="<StructEvent>"
integer sM
string SM="<StructButtons>"
integer tM
string TM="<Dialog>"
integer uM
integer UM
constant integer wM=O+48
constant integer WM=O+56
constant integer yM=O+8192+64*8192
integer array YM
integer array zM
constant integer ZM=O+58
constant integer vp=O+8192+60*8192
dialog array ep
integer array xp
multiboard array op
integer array rp
integer array ip
integer array ap
integer np
string Vp="<StructDestroyTimed>"
integer Ep
string Xp="<SpotEffectWithSize>"
integer Op
string Rp="<DummyUnitEffect>"
integer Ip
string Ap="<StructId>"
integer Np
string bp="<StructTable>"
integer Bp
string cp="<StructBoolean>"
integer Cp
string dp="<StructInteger>"
integer Dp
string fp="<StructData>"
integer Fp
string gp="<StructEvent>"
integer Gp
string hp="<StructDestroyTimed>"
integer Hp
string jp="<SpotEffect>"
integer Jp
string kp="<StructId>"
integer Kp
string lp="<StructTable>"
integer Lp
string mp="<StructBoolean>"
integer Mp
string pp="<StructInteger>"
integer Pp
string qp="<StructData>"
integer Qp
string sp="<StructEvent>"
integer Sp
string tp="<StructDestroyTimed>"
integer Tp
string up="<Effect>"
integer Up
integer wp
integer array Wp
integer array yp
integer array Yp
constant integer zp=O+8192+68*8192
integer array Zp
effect array vP
integer array eP
integer array xP
boolean array oP
integer array rP
integer iP
integer aP
integer nP
integer VP
integer EP
integer XP
integer OP
integer RP
string IP="<StructD2>"
integer AP
string NP="<StructIntegerKeys>"
integer bP
string BP="<StructTable>"
integer cP
string CP="<StructD2>"
integer dP
string DP="<StructTable>"
integer fP
string FP="<StructIntegerKeys>"
integer gP
integer GP
integer hP
integer HP
integer jP
integer JP
integer kP
integer KP
integer lP
integer LP
string mP="<EventPair>"
integer MP
string pP="<StructId>"
integer PP
string qP="<StructBoolean>"
integer QP
string sP="<StructTable>"
integer SP
string tP="<StructInteger>"
integer TP
string uP="<StructData>"
integer UP
string wP="<StructRemainingEventsAmount>"
integer WP
string yP="<StructEvents>"
integer YP
string zP="<StructSubjects>"
integer ZP
string vq="<StructSubjectsA>"
integer eq
string xq="<StructPeriodic>"
integer oq
string rq="<StructPairs>"
integer iq
string aq="<EventCombination>"
integer nq
string Vq="<Announcement>"
integer Eq
string Xq="<CineFilter>"
integer Oq
string Rq="<StructFloatState>"
integer Iq
string Aq="<StructTimeOfDay>"
real Nq
integer bq
integer Bq
boolean cq=false
integer Cq
integer dq
integer Dq=0
string fq="<PingColor>"
integer array Fq
integer gq=U
integer array Gq
boolean array hq
boolean array Hq
integer jq
boolean array Jq
string array kq
integer array Kq
integer array lq
integer array Lq
integer array mq
integer Mq=F
integer array pq
integer Pq
integer qq
integer Qq
integer sq
integer Sq
integer tq
string Tq="<Ping>"
integer uq
string Uq="<StructRefs>"
integer wq
string Wq="<StructCountUnits>"
integer yq
string Yq="<StructNearestUnit>"
integer zq
string Zq="<StructOrder>"
integer vQ
string eQ="<StructRandomUnit>"
integer xQ
string oQ="<StructWithCollision>"
integer rQ
string iQ="<StructInLine>"
integer aQ
string nQ="<StructWithCollision>"
integer VQ
string EQ="<StructInRange>"
integer XQ
string OQ="<StructWithCollision>"
integer RQ
string IQ="<StructInRect>"
integer AQ
string NQ="<StructEnumUnits>"
integer bQ
integer BQ
integer cQ
real CQ
real dQ
real DQ
real fQ
real FQ
real gQ
integer GQ
integer hQ
real HQ
real jQ
real JQ
real kQ
real KQ
real lQ
integer LQ
integer mQ
integer MQ
real pQ
real PQ
real qQ
integer QQ
real sQ
integer SQ
integer tQ
real TQ
real uQ
real UQ
real wQ
integer WQ
integer yQ
integer YQ
integer zQ=0
integer array ZQ
integer vs=U
integer array es
boolean array xs
boolean array os
integer rs
constant integer is=O+8192+'f'*8192
integer array as
boolean array ns
integer Vs
string Es="<StructId>"
integer Xs
string Os="<StructTable>"
integer Rs
string Is="<StructInteger>"
integer As
string Ns="<StructData>"
integer bs
string Bs="<StructRefs>"
integer cs
string Cs="<StructId>"
integer ds
string Ds="<StructTable>"
integer fs
string Fs="<StructInteger>"
integer gs
string Gs="<StructData>"
integer hs
string Hs="<ItemClass>"
integer js
string Js="<StructId>"
integer ks
string Ks="<StructBoolean>"
integer ls
string Ls="<StructTable>"
integer ms
string Ms="<StructInteger>"
integer ps
string Ps="<StructData>"
integer qs
string Qs="<StructNative>"
integer ss
string Ss="<StructEvent>"
integer ts
string Ts="<StructClasses>"
integer us
string Us="<StructType>"
integer ws
string Ws="<StructAbilities>"
integer ys
string Ys="<StructChargesAmount>"
integer zs
string Zs="<StructPosition>"
integer vS
string eS="<Item>"
integer xS=0
integer array oS
integer rS=U
integer array iS
boolean array aS
boolean array nS
integer array VS
integer ES=F
integer array XS
integer array OS
integer array RS
constant integer IS=O+8192+'j'*8192
integer AS
integer NS
integer bS
integer BS
integer cS=0
integer array CS
integer dS=U
integer array DS
boolean array fS
boolean array FS
integer array gS
integer array GS
constant integer hS=O+8192+'l'*8192
constant integer HS=$7E
constant integer jS=O+HS
integer array JS
constant integer kS=O+8192+'x'*8192
integer KS
constant integer lS=O+8192+'z'*8192
integer array LS
integer mS
integer array MS
constant integer pS=O+8192+'|'*8192
integer PS
integer qS
string QS="<StructId>"
integer sS
string SS="<StructBoolean>"
integer tS
string TS="<StructTable>"
integer uS
string US="<StructInteger>"
integer wS
string WS="<StructData>"
integer yS
string YS="<StructEvent>"
integer zS
string ZS="<StructAbilities>"
integer vt
string et="<StructChargesAmount>"
integer xt
string ot="<StructClasses>"
integer rt
string it="<StructPreload>"
integer at
string nt="<StructUsageGoldCost>"
integer Vt
string Et="<ItemType>"
integer Xt
string Ot="<StructId>"
integer Rt
string It="<StructTable>"
integer At
string Nt="<StructInteger>"
integer bt
string Bt="<StructData>"
integer ct
string Ct="<StructEvent>"
integer dt
string Dt="<StructRed>"
integer ft
string Ft="<StructGreen>"
integer gt
string Gt="<StructBlue>"
integer ht
string Ht="<StructAlpha>"
integer jt
string Jt="<StructTimed>"
integer kt
string Kt="<StructColor>"
integer lt
string Lt="<StructFromDummyUnitToUnit>"
integer mt
string Mt="<StructFromSpotToDummyUnit>"
integer pt
string Pt="<StructFromSpotToSpot>"
integer qt
string Qt="<StructFromSpotToUnit>"
integer St
string tt="<StructFromUnitToUnit>"
integer Tt
string ut="<StructDestroyTimed>"
integer Ut
string wt="<Lightning>"
integer Wt
integer yt
integer Yt
integer array zt
integer array Zt
integer array vT
constant integer eT=$88
constant integer xT=O+8192+eT*8192
integer array oT
integer array rT
boolean array iT
integer array aT
integer array nT
integer array VT
integer ET=F
integer XT
integer array OT
integer RT
constant integer IT=$9C
constant integer AT=O+IT
integer array NT
integer array bT
boolean array BT
integer array cT
integer CT
constant integer dT=$8A
constant integer DT=O+8192+dT*8192
integer array fT
integer array FT
boolean array gT
constant integer GT=$8C
constant integer hT=O+8192+GT*8192
integer HT
integer jT
integer array JT
boolean array kT
integer array KT
integer array lT
integer LT=F
integer mT
integer array MT
integer array pT
integer array PT
boolean array qT
real array QT
real array sT
real array ST
real array tT
lightning array TT
constant real uT=Vj*4
integer UT=0
integer wT=U
boolean array WT
real array yT
real array YT
real array zT
real array ZT
integer array vu
real eu=.35
integer array xu
integer array ou
boolean array ru
real array iu
real array au
real array nu
real array Vu
real array Eu
real array Xu
real array Ou
real array Ru
real array Iu
integer Au
constant integer Nu=$8E
constant integer bu=O+8192+Nu*8192
integer array Bu
integer array cu
boolean array Cu
constant integer du=$90
constant integer Du=O+8192+du*8192
integer fu
integer array Fu
integer array gu
integer Gu=F
integer hu
integer array Hu
integer array ju
integer Ju
constant integer ku=$92
constant integer Ku=O+8192+ku*8192
integer array lu
integer array Lu
boolean array mu
integer Mu
constant integer pu=$94
constant integer Pu=O+8192+pu*8192
integer array qu
integer array Qu
boolean array su
constant integer Su=$96
constant integer tu=O+8192+Su*8192
integer Tu
integer array uu
integer array Uu
integer wu=F
integer Wu
integer array yu
integer array Yu
integer zu
constant integer Zu=$98
constant integer vU=O+Zu
integer array eU
integer array xU
boolean array oU
constant integer rU=$9A
constant integer iU=O+8192+rU*8192
integer aU
integer array nU
integer array VU
integer EU=F
integer XU
integer array OU
integer array RU
integer array IU
real array AU
real array NU
real array bU
real array BU
real array cU
real array CU
integer dU
string DU="<LoadingEx>"
integer fU
string FU="<AICastSpell>"
integer gU
constant integer GU=$A0
constant integer hU=O+8192+GU*8192
integer HU
integer jU
integer JU
integer kU
integer KU=0
integer array lU
integer LU=U
integer array mU
boolean array MU
boolean array pU
constant integer PU=O+8192+24*8192
boolean array qU
integer array QU
string sU="<AILetOff>"
integer SU
integer tU=0
string TU="<UnitModSet>"
integer array uU
integer UU=U
integer array wU
boolean array WU
boolean array yU
integer YU
constant integer zU=O+8192+388*8192
integer ZU
integer vw
integer ew
integer xw
integer ow
integer rw
integer iw
integer aw
integer array nw
constant integer Vw=$A2
constant integer Ew=O+8192+Vw*8192
integer Xw
integer array Ow
integer Rw=F
integer array Iw
integer array Aw
integer Nw=F
integer bw=675
constant real Bw=bw*bw
integer array cw
boolean Cw
integer dw
integer array Dw
boolean array fw
integer array Fw
integer array gw
constant integer Gw=O+549
integer hw=w
integer array Hw
integer jw
string Jw="<CustomDrop>"
integer kw
string Kw="<StructId>"
integer lw
string Lw="<StructTable>"
integer mw
string Mw="<StructInteger>"
integer pw
string Pw="<StructData>"
integer qw
string Qw="<StructNative>"
integer sw
string Sw="<StructEvent>"
integer tw
string Tw="<StructAbilities>"
integer uw
string Uw="<StructAnimation>"
integer ww
string Ww="<StructDestroyTimed>"
integer yw
string Yw="<StructDestruction>"
integer zw
string Zw="<StructFacing>"
integer vW
string eW="<StructPlayerColor>"
integer xW
string oW="<StructOrder>"
integer rW
string iW="<StructOwner>"
integer aW
integer nW
integer VW
string EW="<StructZ>"
integer XW
string OW="<StructPosition>"
integer RW
string IW="<StructFollowDummyUnit>"
integer AW
string NW="<StructFollowUnit>"
integer bW
string BW="<StructRotate>"
integer cW
string CW="<StructTimed>"
integer dW
string DW="<StructScale>"
integer fW
string FW="<StructRed>"
integer gW
string GW="<StructGreen>"
integer hW
string HW="<StructBlue>"
integer jW
string JW="<StructAlpha>"
integer kW
string KW="<StructTimed>"
integer lW
string LW="<StructVertexColor>"
constant integer mW=$B
constant integer MW=O+8192+mW*8192
boolean pW=false
string array PW
unit qW=null
integer QW
string sW="<DummyUnit>"
integer SW
string tW="<TargetFlag>"
integer TW
string uW="<Misc>"
integer UW
constant integer wW=$AA
constant integer WW=O+wW
integer array yW
integer array YW
integer zW=F
integer ZW
integer array vy
integer ey
constant integer xy=$AC
constant integer oy=O+xy
integer array ry
integer array iy
integer ay=F
integer ny
integer array Vy
integer Ey
integer Xy
integer array Oy
integer array Ry
integer Iy=F
integer Ay
integer Ny
integer by=0
integer array By
integer cy=U
integer array Cy
boolean array Dy
boolean array fy
integer Fy
constant real gy=180.*1./ 3.141592654
integer array Gy
constant integer hy=$B6
constant integer Hy=O+hy
constant integer jy=$A4
constant integer Jy=O+8192+jy*8192
real array ky
integer array Ky
real array ly
real array Ly
real array my
real array My
real array py
integer Py
string qy="<StructId>"
integer Qy
string sy="<StructBoolean>"
integer Sy
string ty="<StructTable>"
integer Ty
string uy="<StructInteger>"
integer Uy
string wy="<StructData>"
integer Wy
string yy="<MissileCheckpoint>"
integer Yy
string zy="<StructId>"
integer Zy
string vY="<StructBoolean>"
integer eY
string xY="<StructTable>"
integer oY
string rY="<StructInteger>"
integer iY
string aY="<StructData>"
integer nY
string VY="<StructEvent>"
integer EY
string XY="<StructArc>"
integer OY
string RY="<StructImpact>"
integer IY
string AY="<StructCollisionSize>"
integer NY
string bY="<StructDummyUnit>"
integer BY
string cY="<StructAngle>"
integer CY
string DY="<StructX>"
integer fY
string FY="<StructY>"
integer gY
string GY="<StructZ>"
integer hY
string HY="<StructPosition>"
integer jY
string JY="<StructUpdateTime>"
integer kY
string KY="<StructAcceleration>"
integer lY
string LY="<StructSpeed>"
integer mY
string MY="<StructGoToSpot>"
integer pY
string PY="<StructCheckpoints>"
integer qY
string QY="<StructGoToUnit>"
integer sY
string SY="<Missile>"
integer tY
integer TY
integer uY
integer UY
integer wY
integer array WY
integer array yY
integer array YY
integer array zY
constant integer ZY=9*8192
integer array vz
constant integer ez=$A
constant integer xz=ez*8192
integer array oz
integer array rz
integer array iz
boolean array az
integer nz
constant integer Vz=$BC
constant integer Ez=O+Vz
integer array Xz
integer Oz
integer Rz=0
integer array Iz
integer Az=U
integer array Nz
boolean array bz
boolean array Bz
integer array cz
integer Cz
integer array dz
integer array Dz
integer fz=F
integer Fz
integer gz
integer array Gz
integer array hz
integer Hz
constant integer jz=$BE
constant integer Jz=O+8192+jz*8192
integer kz
integer Kz
integer array lz
integer array Lz
integer mz=F
integer Mz
integer array pz
real array Pz
real array qz
real array Qz
real array sz
real array Sz
real array tz
integer array Tz
integer uz
integer Uz
string wz="<MultiboardItem>"
integer Wz
string yz="<StructColumn>"
integer Yz
string zz="<StructColumnSpan>"
integer Zz
string vZ="<StructRow>"
integer eZ
string xZ="<StructTitle>"
integer oZ
string rZ="<StructPageSwitch>"
integer iZ
string aZ="<StructControl>"
integer nZ
string VZ="<StructShown>"
integer EZ
string XZ="<Multiboard>"
integer array OZ
integer RZ=0
integer IZ=U
boolean array AZ
integer NZ=lA
integer bZ
boolean array BZ
integer cZ=0
integer array CZ
boolean array DZ
integer array fZ
integer array FZ
integer array gZ
integer array GZ
integer array hZ
integer array HZ
integer array jZ
integer array JZ
string array kZ
multiboarditem array KZ
real array lZ
constant integer LZ=$C2
constant integer mZ=O+8192+LZ*8192
string array MZ
integer pZ=w
integer PZ
string array qZ
integer QZ
string array sZ
integer SZ
integer array tZ
integer TZ=F
integer array uZ
string array UZ
integer wZ
integer array WZ
integer array yZ
boolean array YZ
integer array zZ
integer array ZZ
integer array v0
integer array e0
integer array x0
integer o0=w
integer r0
string array i0
integer n0
string array V0
integer array E0
boolean array X0
integer array O0
integer R0
integer I0
string array A0
integer N0
integer b0=0
string B0="<StructDownArrow>"
integer array c0
integer C0=U
integer array d0
boolean array D0
boolean array f0
integer F0
real array g0
integer array G0
real array h0
integer array H0
integer array j0
constant integer J0=O+8192+439*8192
integer k0
constant integer K0=O+437
integer l0=F
integer array L0
integer m0
real array M0
integer p0
integer array P0
constant integer q0=0+8
integer Q0
integer array s0
integer array S0
constant integer t0=0+$B
real T0=2450.
integer u0
integer U0
string array w0
integer W0
constant integer y0=0+1
boolean Y0=false
integer z0='d'
integer array Z0
integer v1
integer e1='d'
integer o1=F
volumegroup array r1
integer array i1
integer n1
integer V1
integer E1=0
string X1="<StructLeftArrow>"
integer array O1
integer R1=U
integer array I1
boolean array A1
boolean array N1
integer b1
real array B1
integer array c1
real array C1
integer array d1
integer array D1
constant integer f1=O+8192+443*8192
integer F1
constant integer g1=O+441
real array G1
integer h1
integer H1=0
string j1="<StructRightArrow>"
integer array J1
integer k1=U
integer array K1
boolean array l1
boolean array L1
integer m1
real array M1
integer array p1
real array P1
integer array q1
integer array Q1
constant integer s1=O+8192+447*8192
integer S1
constant integer t1=O+445
integer T1
integer u1=0
string U1="<StructUpArrow>"
integer array w1
integer W1=U
integer array Y1
boolean array z1
boolean array Z1
integer v2
real array e2
integer array o2
real array r2
integer array i2
integer array n2
constant integer V2=O+8192+451*8192
integer E2
constant integer X2=O+449
integer O2=F
integer array R2
integer I2
integer array A2
integer array N2
integer b2
integer B2
integer c2
constant real C2=(2*1.)*1./ 32
integer D2
string f2="<StructId>"
integer F2
string g2="<StructTable>"
integer G2
string h2="<StructInteger>"
integer H2
string j2="<StructData>"
integer J2
string k2="<StructNative>"
integer K2
string l2="<StructEvent>"
integer L2
string m2="<Order>"
integer M2
integer p2=0
integer array P2
integer q2=U
integer array Q2
boolean array S2
boolean array t2
integer array T2
constant integer u2=$C4
constant integer U2=O+8192+u2*8192
string array w2
integer W2
integer Y2
integer Z2
integer v3
integer e3
integer o3
integer r3
integer i3
integer n3
integer V3
integer E3
integer X3
integer O3
integer R3
integer I3
integer A3
integer N3
integer b3
integer B3
integer c3
integer C3
integer d3
integer D3
integer f3
integer F3
integer g3
integer G3
integer h3
integer H3
integer j3
integer J3
integer k3
integer K3
integer l3
integer L3
integer m3
integer M3
integer p3
integer P3
integer q3
integer Q3
integer s3
integer S3
integer t3
integer T3
integer u3
integer U3
integer w3
integer W3
integer Y3
integer z3
integer Z3
integer v4
integer e4
integer o4
integer r4
integer i4
integer n4
integer V4
integer E4
integer X4
integer O4
integer R4
integer I4
integer A4
integer N4
integer b4
integer B4
integer c4
integer C4
integer d4
integer D4
integer f4
integer F4
integer g4
integer G4
integer h4
integer H4
integer j4
string J4="<StructRefs>"
integer k4
string K4="<StructEvent>"
integer l4
string L4="<StructColor>"
hashtable m4
integer M4
string p4="<StructId>"
integer P4
string q4="<StructTable>"
integer Q4
string s4="<StructInteger>"
integer S4
string t4="<StructData>"
integer T4
string u4="<StructId>"
integer U4
string w4="<StructTable>"
integer W4
string Y4="<StructInteger>"
integer z4
string Z4="<StructData>"
integer v5
string e5="<StructNative>"
integer x5
string o5="<StructEvent>"
integer r5
string i5="<Region>"
integer a5
string n5="<Music>"
integer V5
string E5="<SoundChannel>"
integer X5
string O5="<SoundEax>"
integer R5
string I5="<SoundType>"
integer A5
integer N5=0
integer array b5
integer B5=U
integer array c5
boolean array C5
boolean array d5
integer D5
integer f5
integer F5
integer g5
integer G5
integer h5
integer array H5
constant integer j5=$A
constant integer J5=$B
constant integer k5=$D
constant integer K5=$C
constant integer l5=$E
integer L5
integer array m5
integer M5
string p5="<HeroSpell>"
integer P5
string q5="<SpellClass>"
integer Q5
string s5="<StructId>"
integer S5
string t5="<StructTable>"
integer T5
string u5="<StructBoolean>"
integer U5
string w5="<StructInteger>"
integer W5
string y5="<StructReal>"
integer Y5
string z5="<StructData>"
integer Z5
string v6="<StructNative>"
integer e6
string x6="<StructEvent>"
integer o6
string r6="<Spell>"
integer i6
integer a6=0
integer array n6
integer V6=U
integer array E6
boolean array X6
boolean array O6
integer array R6
integer array I6
boolean array A6
integer N6
integer b6
integer B6
integer c6
integer C6
integer d6
integer D6
integer f6=5
integer F6
integer array g6
integer array G6
integer array h6
integer H6='AHS0'
integer array j6
integer J6
integer k6
integer K6
constant integer l6=$CC
constant integer L6=O+l6
integer m6
string M6="<StructRefs>"
integer p6
string P6="<StructNative>"
integer q6
string Q6="<StructEvent>"
integer s6
string S6="<StructDeformNova>"
integer t6
string T6="<Spot>"
integer u6=0
integer array U6
integer w6=U
integer array W6
boolean array y6
boolean array Y6
integer z6
integer Z6
integer v7
string e7="<StructTable>"
integer x7
string o7="<StructInteger>"
integer r7
string i7="<StructData>"
integer a7
string n7="<StructNative>"
integer V7
string E7="<StructEvent>"
integer X7
string O7="<StringData>"
integer R7
integer I7=0
string A7="<TileType>"
integer array N7
integer b7=U
integer array B7
boolean array c7
boolean array C7
integer d7
integer array D7
constant integer f7=$DD
constant integer F7=O+f7
integer g7
integer G7
integer h7
integer H7
integer j7
integer J7
integer k7
integer K7
integer l7
integer L7
integer m7
integer M7
integer p7
string P7="<StructType>"
integer q7
string Q7="<Tile>"
integer s7
integer S7
string t7="<StructDestroyTimed>"
integer T7
string u7="<TileTypeMod>"
integer U7
integer w7=0
string W7="<UbersplatType>"
integer array y7
integer Y7=U
integer array z7
boolean array Z7
boolean array v8
integer e8
string array x8
integer o8
string r8="<StructId>"
integer i8
string a8="<StructTable>"
integer n8
string V8="<StructInteger>"
integer E8
string X8="<StructData>"
integer O8
string R8="<StructEvent>"
integer I8
string A8="<StructDestroyTimed>"
integer N8
string b8="<StructRed>"
integer B8
string c8="<StructGreen>"
integer C8
string d8="<StructBlue>"
integer D8
string f8="<StructAlpha>"
integer F8
string g8="<StructTimed>"
integer G8
string h8="<StructColor>"
integer H8
string j8="<StructX>"
integer J8
string k8="<StructY>"
integer K8
string l8="<StructPosition>"
integer L8
string m8="<Ubersplat>"
integer M8
integer p8
integer array P8
integer array q8
integer array Q8
constant integer s8=$E2
constant integer S8=O+8192+s8*8192
integer array t8
integer array T8
boolean array u8
integer array U8
integer array w8
integer array W8
integer y8=F
integer Y8
integer array z8
integer Z8
string vvv="<StructPosition>"
integer vev
string vxv="<StructText>"
integer vov
string vrv="<StructCreateJumping>"
integer viv
string vav="<StructCreateMoving>"
integer vnv
string vVv="<StructCreateRising>"
integer vEv
string vXv="<StructDelay>"
integer vOv
string vRv="<StructFadingOut>"
integer vIv
string vAv="<TimerDialog>"
integer vNv
string vbv="<StructId>"
integer vBv
string vcv="<StructTable>"
integer vCv
string vdv="<StructInteger>"
integer vDv
string vfv="<StructData>"
integer vFv
string vgv="<TriggerTimer>"
integer vGv
string vhv="<StructId>"
integer vHv
string vjv="<StructTable>"
integer vJv
string vkv="<StructInteger>"
integer vKv
string vlv="<StructData>"
integer vLv
string vmv="<StructId>"
integer vMv
string vpv="<StructBoolean>"
integer vPv
string vqv="<StructTable>"
integer vQv
string vsv="<StructInteger>"
integer vSv
string vtv="<StructData>"
integer vTv
string vuv="<StructNative>"
integer vUv
string vwv="<StructEvent>"
integer vWv
string vyv="<StructRegisterEvent>"
integer array vYv
integer array vzv
integer array vZv
integer v_v
string v0v="<StructBonus>"
integer v1v
string v2v="<StructArmor>"
integer array v3v
integer array v4v
integer array v5v
integer v6v
string v7v="<StructBonusA>"
integer v8v
string v9v="<StructSpeed>"
integer evv
string eev="<StructAttack>"
integer exv
string eov="<StructBonus>"
integer array erv
integer array eiv
integer array eav
integer array env
integer eVv
string eEv="<StructDamage>"
integer eXv
string eOv="<StructMovement>"
integer eRv
string eIv="<StructBonusA>"
integer eAv
string eNv="<StructAgility>"
integer ebv
string eBv="<StructBonusA>"
integer ecv
string eCv="<StructIntelligence>"
integer edv
string eDv="<StructBonusA>"
integer efv
string eFv="<StructStrength>"
integer egv
string eGv="<StructHero>"
integer ehv
string eHv="<UnitAttackSplash>"
integer ejv
string eJv="<StructId>"
integer ekv
string eKv="<StructTable>"
integer elv
string eLv="<StructInteger>"
integer emv
string eMv="<StructData>"
integer epv
string ePv="<UnitClass>"
integer eqv
string eQv="<StructId>"
integer esv
string eSv="<StructTable>"
integer etv
string eTv="<StructInteger>"
integer euv
string eUv="<StructReal>"
integer ewv
string eWv="<StructData>"
integer eyv
string eYv="<UnitTypePool>"
integer ezv
string eZv="<StructId>"
integer e_v
string e0v="<StructBoolean>"
integer e1v
string e2v="<StructTable>"
integer e3v
string e4v="<StructInteger>"
integer e5v
string e6v="<StructTable>"
integer e7v
string e8v="<StructReal>"
integer e9v
string xvv="<StructData>"
integer xev
string xxv="<StructCombination>"
integer xov
string xrv="<StructCounted>"
integer xiv
string xav="<StructNative>"
integer xnv
string xVv="<StructEvent>"
integer xEv
string xXv="<StructBegin>"
integer xOv
integer xRv=0
integer array xIv
integer xAv=U
integer array xNv
boolean array xbv
boolean array xBv
string xcv="<StructChanneling>"
integer xCv
integer array xdv
boolean array xDv
integer array xfv
integer xFv
integer xgv
integer xGv
integer xhv
integer xHv
integer xjv
constant integer xJv=O+8192+260*8192
integer xkv
integer xKv
constant integer xlv=O+372
integer array xLv
integer array xmv
string xMv="<StructLoop>"
boolean array xpv
integer xPv
integer xqv
integer array xQv
integer array xsv
integer xSv=F
integer xtv
trigger xTv
integer array xuv
integer xUv=0
integer xwv=U
boolean array xWv
string array xyv
constant real xYv=Vj*32
string array xzv
integer xZv
integer x_v
integer array x0v
integer x1v=F
integer array x2v
integer x3v
integer array x4v
integer x5v=F
integer array x6v
integer array x7v
lightning array x8v
lightning array x9v
boolean array ovv
integer oev
integer oxv
integer oov
string orv="<StructEffect>"
integer oiv
string oav="<StructFinish>"
integer onv
string oVv="<StructLearn>"
integer oEv
string oXv="<StructUnlearn>"
integer oOv
string oRv="<StructEvents>"
integer oIv
string oAv="<StructAutoCast>"
integer oNv
string obv="<StructAbilities>"
integer oBv
string ocv="<StructEffects>"
integer oCv
string odv="<StructSounds>"
integer oDv
string ofv="<StructAttachments>"
integer oFv
string ogv="<StructChangeLevel>"
integer oGv
string ohv="<StructGain>"
integer oHv
string ojv="<StructLose>"
integer oJv
string okv="<StructEvents>"
integer oKv
string olv="<StructBuffs>"
integer oLv
string omv="<StructModSets>"
integer oMv
string opv="<StructGain>"
integer oPv
string oqv="<StructLose>"
integer oQv
string osv="<StructMoveInInventory>"
integer oSv
string otv="<StructSell>"
integer oTv
string ouv="<StructUse>"
integer oUv
string owv="<StructEvents>"
integer oWv
string oyv="<StructItems>"
integer oYv
string ozv="<StructClasses>"
integer oZv
string o_v="<StructType>"
integer o0v
string o1v="<StructColor>"
integer o2v
string o3v="<StructOwner>"
integer o4v
string o5v="<StructBase>"
integer o6v
string o7v="<StructDisplayed>"
integer o8v
string o9v="<StructBonus>"
integer rvv
string rev="<StructRelative>"
integer rxv
string rov="<StructIgnoreDamage>"
integer rrv
string riv="<StructInvisible>"
integer rav
string rnv="<StructRelative>"
integer rVv
string rEv="<StructResistance>"
integer rXv
string rOv="<StructSpell>"
integer rRv
string rIv="<StructTypeA>"
integer rAv
string rNv="<StructArmor>"
integer rbv
string rBv="<StructAcquire2>"
integer rcv
string rCv="<StructGround>"
integer rdv
string rDv="<StructEvents>"
integer rfv
string rFv="<StructSpeed>"
integer rgv
string rGv="<StructMissile>"
integer rhv
string rHv="<StructRange>"
integer rjv
string rJv="<StructBaseA>"
integer rkv
string rKv="<StructDisplayedA>"
integer rlv
string rLv="<StructBonusA>"
integer rmv
string rMv="<StructSpeed>"
integer rpv
string rPv="<StructTargetFlag>"
integer rqv
string rQv="<StructSplash>"
string rsv="<StructAttack>"
integer rSv
integer rtv
boolean array rTv
integer ruv
string rUv="<StructBlood>"
integer rwv
string rWv="<StructBloodExplosion>"
integer ryv
string rYv="<StructCollisionSize>"
integer rzv
string rZv="<StructBase>"
integer r_v
string r0v="<StructBonus>"
integer r1v
string r2v="<StructCriticalChanceDefense>"
integer r3v
string r4v="<StructBase>"
integer r5v
string r6v="<StructBonus>"
integer r7v
string r8v="<StructCriticalChance>"
integer r9v
string ivv="<StructExplosion>"
integer iev
boolean array ixv
integer iov
string irv="<StructEvents>"
integer iiv
string iav="<StructProtection>"
integer inv
integer iVv
string iEv="<StructDeath>"
integer iXv
string iOv="<StructDuration>"
integer iRv
string iIv="<StructEvents>"
integer iAv
string iNv="<StructTimed>"
integer ibv
string iBv="<StructDecay>"
integer icv
string iCv="<StructDisplay>"
integer idv
string iDv="<StructExp>"
integer ifv
string iFv="<StructSupply>"
integer igv
string iGv="<StructDrop>"
integer ihv
string iHv="<StructEvasion>"
integer ijv
string iJv="<StructBase>"
integer ikv
string iKv="<StructBonus>"
integer ilv
string iLv="<StructEvasionChanceDefense>"
integer imv
string iMv="<StructBase>"
integer ipv
string iPv="<StructBonus>"
integer iqv
string iQv="<StructEvasionChance>"
integer isv
string iSv="<StructX>"
integer itv
string iTv="<StructY>"
integer iuv
string iUv="<StructZ>"
integer iwv
string iWv="<StructImpact>"
integer iyv
string iYv="<StructExp>"
integer izv
string iZv="<StructX>"
integer i_v
string i0v="<StructY>"
integer i1v
string i2v="<StructZ>"
integer i3v
string i4v="<StructOutpact>"
integer i5v
string i6v="<StructLifeLeech>"
integer i7v
string i8v="<StructManaLeech>"
integer i9v
boolean array avv
string array aev
integer axv
string aov="<StructInvulnerability>"
integer arv
integer aiv
boolean array aav
integer anv
string aVv="<StructDisplayed>"
integer aEv
string aXv="<StructBase>"
integer aOv
string aRv="<StructDisplayed>"
integer aIv
string aAv="<StructBonus>"
integer aNv
string abv="<StructDelay>"
integer aBv
string acv="<StructDices>"
integer aCv
string adv="<StructEvents>"
integer aDv
string afv="<StructInvisible>"
integer aFv
string agv="<StructRelative>"
integer aGv
string ahv="<StructSides>"
integer aHv
string ajv="<StructSpellRelative>"
integer aJv
string akv="<StructTypeA>"
integer aKv
string alv="<StructDamage>"
integer aLv
string amv="<StructSpellShield>"
integer aMv
integer apv
boolean array aPv
constant integer aqv=O+8192+322*8192
integer aQv
string asv="<StructMagicImmunity>"
integer aSv
integer atv
boolean array aTv
integer auv
string aUv="<StructBonus>"
string awv="<StructScale>"
integer aWv
integer ayv
integer aYv
integer array azv
integer aZv
string a_v="<StructRed>"
integer a0v
string a1v="<StructGreen>"
integer a2v
string a3v="<StructBlue>"
integer a4v
string a5v="<StructAlpha>"
integer a6v
string a7v="<StructVertexColor>"
integer a8v
string a9v="<StructCold>"
integer nvv
integer nev
integer nxv
integer nov=0
string nrv="<UnitMod>"
integer array niv
integer nav=U
integer array nnv
boolean array nVv
boolean array nEv
integer nXv
integer array nOv
integer nRv
real array nIv
real array nAv
real array nNv
real array nbv
integer nBv
boolean array ncv
integer nCv
integer ndv
string nDv="<StructFrost>"
integer nfv
string array nFv
string ngv="Unit_page\\Unit_struct\\Frost\\finished\\BurstingIce.mdx"
string array nGv
integer nhv
integer nHv
string njv="<StructReveal>"
integer nJv
boolean array nkv
string nKv="Abilities\\Spells\\NightElf\\FaerieDragonInvis\\FaerieDragon_Invis.mdx"
string nlv="AttachPoint.HEAD"
integer nLv
string nmv="<StructInvisibility>"
integer nMv
integer npv
integer nPv
integer array nqv
integer nQv
integer nsv
integer nSv
boolean array ntv
integer nTv
string nuv="<StructGhost>"
integer nUv
boolean array nwv
integer nWv
string nyv="<StructHealAbility>"
integer nYv
string nzv="<StructBase>"
integer nZv
string n_v="<StructBonus>"
integer n0v
string n1v="<StructRelative>"
integer array n2v
integer array n3v
integer n4v
string n5v="<StructMaxLife>"
integer n6v
string n7v="<StructLife>"
integer n8v
string n9v="<StructBase>"
integer Vvv
string Vev="<StructBonus>"
string Vxv="<StructDisablement>"
integer Vov
boolean array Vrv
integer Viv
string Vav="<StructRelative>"
integer Vnv
string VVv="<StructLifeRegeneration>"
integer VEv
string VXv="<StructBase>"
integer VOv
string VRv="<StructBonus>"
integer VIv
string VAv="<StructRelative>"
integer array VNv
integer array Vbv
integer VBv
string Vcv="<StructMaxMana>"
integer VCv
string Vdv="<StructMana>"
integer VDv
string Vfv="<StructBase>"
integer VFv
string Vgv="<StructBonus>"
string VGv="<StructDisablement>"
integer Vhv
boolean array VHv
integer Vjv
string VJv="<StructRelative>"
integer Vkv
string VKv="<StructManaRegeneration>"
integer Vlv
string VLv="<StructEnterRegion>"
integer Vmv
string VMv="<StructInterval>"
integer Vpv
string VPv="<StructLeaveRegion>"
integer Vqv
string VQv="<StructEvents>"
integer Vsv
string VSv="<StructBaseA>"
integer Vtv
string VTv="<StructBonusA>"
integer Vuv
string VUv="<StructRelativeA>"
integer Vwv
string VWv="<StructSpeed>"
string Vyv="<StructMovement>"
integer VYv
boolean array Vzv
integer VZv
string V_v="<StructLose>"
integer V0v
string V1v="<StructImmediate>"
integer V2v
string V3v="<StructPoint>"
integer V4v
string V5v="<StructTarget>"
integer V6v
string V7v="<StructGain>"
integer V8v
string V9v="<StructIdle>"
integer Evv
string Eev="<StructEvents>"
integer Exv
string Eov="<StructOrder>"
integer Erv
string Eiv="<StructBanish>"
integer Eav
integer Env
integer EVv
boolean array EEv
integer EXv
integer EOv
string ERv="<StructMadness>"
integer EIv
integer EAv
integer ENv
integer Ebv
string EBv="<StructEclipse>"
integer Ecv
integer ECv
integer Edv
integer EDv
boolean array Efv
integer EFv
string Egv="<StructWhirl>"
integer EGv
integer Ehv
integer EHv
boolean array Ejv
integer EJv
integer Ekv
string EKv="<StructFacing>"
integer Elv
string ELv="<StructBleeding>"
integer Emv
integer EMv
boolean array Epv
integer array EPv
integer array Eqv
string array EQv
constant integer Esv=O+8192+324*8192
constant real ESv=1.*1./ 10.
real array Etv
real array ETv
boolean array Euv
real array EUv
constant integer Ewv=O+8192+318*8192
real array EWv
real array Eyv
integer array EYv
integer Ezv
integer EZv
real array E_v
constant integer E0v=O+8192+373*8192
real E1v=.01
constant real E2v=E1v*1.
real E3v=.02
constant real E4v=E3v*1.
integer E5v
integer E6v
string E7v="<StructIgnited>"
integer E8v
boolean array E9v
integer array Xvv
integer array Xev
real Xxv=.01
constant real Xov=Xxv*1.
real Xrv=.02
constant real Xiv=Xrv*1.
integer Xav
string Xnv="<StructKnockup>"
integer XVv
string XEv="<StructPathing>"
integer XXv
boolean array XOv
integer XRv
string XIv="<StructPoisoned>"
integer XAv
integer XNv
integer Xbv
boolean array XBv
integer Xcv
string XCv="<StructAble>"
integer Xdv
string XDv="<StructEvents>"
integer Xfv
string XFv="<StructRevival>"
integer Xgv
string XGv="<StructSilence>"
integer Xhv
integer XHv
integer Xjv
boolean array XJv
integer Xkv
integer XKv
string Xlv="<StructSleep>"
integer XLv
integer Xmv
integer XMv
integer Xpv
integer XPv
string Xqv="<StructCancel>"
string XQv="<StructStun>"
integer Xsv
integer XSv
integer Xtv
string XTv="<StructSpeed>"
integer Xuv
string XUv="<StructAnimation>"
integer Xwv
string XWv="<StructSkillPoints>"
integer Xyv
string XYv="<StructBase>"
integer Xzv
string XZv="<StructBonus>"
integer X_v
string X0v="<StructRelative>"
integer X1v
string X2v="<StructSpellPower>"
integer X3v
string X4v="<StructBase>"
integer X5v
string X6v="<StructBonus>"
integer X7v
string X8v="<StructRelative>"
integer X9v
string Ovv="<StructSpellVamp>"
integer Oev
string Oxv="<StructBase>"
integer Oov
string Orv="<StructBonus>"
integer Oiv
string Oav="<StructRelative>"
integer Onv
string OVv="<StructMaxRage>"
integer OEv
string OXv="<StructRage>"
integer OOv
string ORv="<StructBase>"
integer OIv
string OAv="<StructBonus>"
integer ONv
string Obv="<StructRelative>"
integer OBv
string Ocv="<StructRageRegeneration>"
integer OCv
string Odv="<StructBase>"
integer ODv
string Ofv="<StructBonus>"
integer OFv
string Ogv="<StructRelative>"
integer OGv
string Ohv="<StructMaxStamina>"
integer OHv
string Ojv="<StructExhaustion>"
integer OJv
integer Okv
string OKv="<StructStamina>"
integer Olv
string OLv="<StructBase>"
integer Omv
string OMv="<StructBonus>"
integer Opv
string OPv="<StructRelative>"
integer Oqv
string OQv="<StructStaminaRegeneration>"
integer Osv
string OSv="<StructExpiringCondition>"
integer Otv
string OTv="<StructBars>"
integer Ouv
string OUv="<StructTimedLife>"
integer Owv
integer array OWv
integer Oyv
string OYv="<StructTransport>"
integer Ozv
integer array OZv
integer array O_v
boolean array O0v
integer O1v
integer O2v
integer O3v
string O4v="<StructHero>"
integer O5v
string O6v="<StructAccelerated>"
integer O7v
string O8v="<StructTimed>"
integer O9v
integer Rvv
integer Rev
string Rxv="<StructZ>"
integer Rov
integer Rrv
string Riv="<StructPosition>"
string array Rav
integer Rnv
string RVv="<StructCircle>"
integer REv
string RXv="<StructSelection>"
integer ROv
integer RRv
string RIv="<StructBase>"
integer RAv
string RNv="<StructBonus>"
integer Rbv
string RBv="<StructRelative>"
integer array Rcv
integer array RCv
integer array Rdv
integer array RDv
integer Rfv
string RFv="<StructSightRange>"
integer Rgv
string RGv="<StructEvents>"
integer Rhv
string RHv="<StructLevel>"
integer Rjv
string RJv="<StructBase>"
integer Rkv
string RKv="<StructDisplayed>"
integer Rlv
string RLv="<StructBonus>"
integer Rmv
string RMv="<StructRelative>"
integer Rpv
string RPv="<StructAgility>"
integer Rqv
string RQv="<StructBase>"
integer Rsv
string RSv="<StructDisplayed>"
integer Rtv
string RTv="<StructBonus>"
integer Ruv
string RUv="<StructRelative>"
integer Rwv
string RWv="<StructIntelligence>"
integer Ryv
string RYv="<StructBase>"
integer Rzv
string RZv="<StructDisplayed>"
integer R_v
string R0v="<StructBonus>"
integer R1v
string R2v="<StructRelative>"
integer R3v
string R4v="<StructStrength>"
integer R5v
string R6v="<StructRefs>"
integer R7v
string R8v="<Unit>"
integer R9v
integer Ivv
integer Iev=0
integer array Ixv
integer Iov=U
integer array Irv
boolean array Iiv
boolean array Iav
integer array Inv
string array IVv
integer IEv=F
integer array IXv
integer array IOv
integer array IRv
constant integer IIv=$EE
constant integer IAv=O+8192+IIv*8192
integer INv
integer Ibv
integer IBv
integer Icv
integer ICv
integer Idv
integer IDv
integer Ifv
integer IFv
integer Igv
integer array IGv
integer Ihv=0
integer array IHv
integer Ijv=U
integer array IJv
boolean array Ikv
boolean array IKv
real array Ilv
real array ILv
real array Imv
real array IMv
real array Ipv
real array IPv
real array Iqv
real array IQv
real array Isv
constant integer ISv=O+8192+407*8192
constant integer Itv=O+8192+408*8192
integer ITv
integer Iuv
integer IUv
integer array Iwv
constant integer IWv=$CE
constant integer Iyv=O+8192+IWv*8192
constant integer IYv=$CD
constant integer Izv=O+8192+IYv*8192
integer array IZv
constant integer I_v=O+8192+409*8192
real array I0v
real array I1v
real array I2v
real array I3v
real array I4v
real array I5v
real array I6v
boolean array I7v
real array I8v
real array I9v
real array Avv
integer array Aev
integer array Axv
integer Aov
integer Arv=6
integer Aiv=6
integer Aav=w
constant integer Anv=O+8192+412*8192
constant integer AVv=O+8192+410*8192
constant integer AEv=O+8192+411*8192
integer AXv
integer AOv
integer ARv
boolean array AIv
integer AAv
integer array ANv
integer Abv=4
integer ABv
integer Acv
real array ACv
real array Adv
real array ADv
constant integer Afv=O+8192+414*8192
constant integer AFv=O+8192+310*8192
integer Agv=0
integer array AGv
integer Ahv=U
integer array AHv
boolean array Ajv
boolean array AJv
real array Akv
real array AKv
constant integer Alv=O+8192+308*8192
constant integer ALv=O+8192+415*8192
string array Amv
string array AMv
constant integer Apv=O+8192+416*8192
integer APv
real array Aqv
real array AQv
real array Asv
real array ASv
real array Atv
integer array ATv
integer array Auv
integer AUv
integer array Awv
integer array AWv
real array Ayv
integer array AYv
integer array Azv
integer AZv
real array A_v
real array A0v
integer A1v
constant integer A2v=O+8192+417*8192
constant integer A3v=O+8192+316*8192
integer A4v
integer array A5v
string array A6v
string array A7v
integer array A8v
integer array A9v
integer array Nvv
integer array Nev
integer array Nxv
integer array Nov
real array Nrv
real array Niv
real array Nav
boolean array Nnv
integer array NVv
boolean array NEv
real array NXv
real array NOv
real array NRv
real array NIv
real array NAv
real array NNv
integer Nbv=256
integer NBv='TS73'
integer Ncv=256
integer NCv='SS73'
real array Ndv
real array NDv
real array Nfv
real array NFv
real array Ngv
real array NGv
real array Nhv
real array NHv
real array Njv
real array NJv
real array Nkv
real array NKv
real array Nlv
real array NLv
real array Nmv
real array NMv
real array Npv
real array NPv
real array Nqv
real array NQv
real array Nsv
real array NSv
real array Ntv
real array NTv
real array Nuv
real array NUv
real array Nwv
real array NWv
real array Nyv
real array NYv
real Nzv=.2
constant integer NZv=O+8192+374*8192
integer N_v
constant integer N0v=O+8192+364*8192
constant integer N1v=O+362
integer N2v
integer N3v
constant real N4v=Vj*16
real array N5v
real array N6v
integer N7v
integer N8v
constant real N9v=.1*.1
real array bvv
integer bev
integer bxv
integer bov
integer brv
integer array biv
integer bav=F
integer array bnv
integer bVv
integer array bEv
integer bXv=F
real array bOv
real array bRv
real array bIv
real array bAv
real array bNv
real array bbv
real array bBv
real array bcv
integer array bCv
integer array bdv
integer array bDv
real bfv=.01
real array bFv
real array bgv
real array bGv
real array bhv
integer bHv
integer bjv
constant integer bJv=O+8192+360*8192
integer bkv=0
integer array bKv
integer blv=U
integer array bLv
boolean array bmv
boolean array bMv
real array bpv
integer array bPv
integer array bqv
integer array bQv
constant integer bsv=O+8192+358*8192
integer bSv
integer btv
integer bTv
lightning array buv
lightning array bUv
lightning array bwv
lightning array bWv
lightning array byv
lightning array bYv
integer bzv
integer bZv
integer b_v
integer b0v=F
integer array b1v
integer array b2v
integer b3v
constant real b4v=(1*1.)*1./ 32
constant real b5v=3.141592654*1./ 2
constant real b6v=b5v
real array b7v
real array b8v
constant real b9v=(.1*32)*b4v
constant real Bvv=(.15-1.)*1./(.9-.7)
constant real Bev=(1.*1./ .7-.15*1./ .9)*1./(1*1./ .7-1*1./ .9)
real array Bxv
integer Bov
integer Brv
integer Biv
integer Bav
integer Bnv
integer BVv
integer BEv
boolean BXv=true
integer array BOv
integer array BRv
integer BIv
integer BAv
integer array BNv
integer array Bbv
integer BBv
integer Bcv
integer BCv=0
string Bdv="<UnitState>"
integer array BDv
integer Bfv=U
integer array BFv
boolean array Bgv
boolean array BGv
integer Bhv
string array BHv
integer Bjv
boolean BJv=false
integer Bkv
real BKv=.6
integer array Blv
effect array BLv
integer array Bmv
integer array BMv
boolean array Bpv
integer BPv=0
integer Bqv=U
boolean array BQv
constant real Bsv=kf
string BSv="Unit_page\\Unit_struct\\Death\\Explosion\\CommonBloodExplosion.mdx"
integer array Btv
integer BTv
integer Buv
integer BUv
constant real Bwv=$80
integer BWv
integer Byv=0
integer array BYv
integer Bzv=U
integer array BZv
boolean array B_v
boolean array B0v
integer array B1v
integer B2v=0
integer array B3v
integer B4v=U
integer array B5v
boolean array B6v
boolean array B7v
integer array B8v
integer array B9v
constant integer cvv=O+314
integer cev
integer cxv
integer cov
integer crv
integer civ
constant integer cav=$FA
constant integer cnv=O+8192+cav*8192
constant integer cVv=$FC
constant integer cEv=O+8192+cVv*8192
integer cXv
boolean cOv=false
integer cRv
integer cIv
integer cAv
integer cNv
integer cbv
integer cBv
integer ccv
integer cCv
constant integer cdv=O+8192+340*8192
constant integer cDv=O+338
integer cfv
real array cFv
real array cgv
real array cGv
real array chv
real array cHv
integer cjv
unit array cJv
integer ckv=0
integer cKv=U
boolean array clv
integer array cLv
integer cmv
constant integer cMv=O+8192+368*8192
integer array cpv
integer array cPv
integer cqv=F
integer array cQv
integer array csv
integer cSv=F
integer ctv
integer cTv
integer cuv
integer cUv
integer array cwv
integer array cWv
integer cyv=F
integer cYv
constant integer czv=O+8192+378*8192
integer array cZv
integer array c_v
boolean array c0v
integer c1v
integer array c2v
integer array c3v
integer c4v=F
integer c5v
constant real c6v=Vj*4
integer c7v=0
integer array c8v
integer c9v=U
integer array Cvv
boolean array Cev
boolean array Cxv
integer array Cov
integer array Crv
real array Civ
real array Cav
real array Cnv
real array CVv
real array CEv
real array CXv
constant integer COv=O+8192+376*8192
integer CRv
integer CIv
integer CAv=F
integer array CNv
integer array Cbv
integer CBv
trigger Ccv
integer CCv=0
integer Cdv=U
boolean array CDv
boolean array Cfv
constant integer CFv=$84
constant integer Cgv=O+8192+CFv*8192
integer CGv=0
integer Chv=U
boolean array CHv
real array Cjv
real array CJv
real array Ckv
constant real CKv=(2*1.)*1./ 32
real array Clv
real array CLv
real array Cmv
integer CMv=0
integer Cpv=U
boolean array CPv
integer array Cqv
integer array CQv
integer Csv
constant integer CSv=O+8192+380*8192
integer array Ctv
constant integer CTv=O+379
integer array Cuv
integer array CUv
integer array Cwv
integer array CWv
boolean array Cyv
integer CYv
integer Czv
integer CZv
integer C_v
integer C0v
integer C1v
integer C2v=0
integer C3v=U
boolean array C4v
string C5v="origin"
integer C6v
integer C7v
integer C8v
integer C9v
integer dvv
integer dev
integer dxv
boolean array dov
integer array drv
integer div
integer dav
integer dnv
integer dVv
integer dEv
integer dXv
integer dOv
boolean dRv=false
constant integer dIv=O+8192+320*8192
string dAv="Abilities\\Spells\\Undead\\VampiricAura\\VampiricAuraTarget.mdl"
string dNv="origin"
string dbv="Abilities\\Spells\\Undead\\VampiricAura\\VampiricAuraTarget.mdl"
string dBv="origin"
constant integer dcv=O+8192+413*8192
integer dCv
boolean ddv
integer dDv
integer dfv
integer dFv
integer dgv
integer dGv
integer dhv
integer dHv
real array djv
real array dJv
integer dkv
integer dKv
integer dlv
integer dLv
real array dmv
real array dMv
constant real dpv=20.*.125
integer dPv
integer array dqv
integer array dQv
integer dsv
integer dSv
integer dtv
integer dTv
integer duv
integer dUv
constant integer dwv=O+302
integer array dWv
integer array dyv
integer array dYv
boolean array dzv
integer dZv
constant integer d_v=O+8192+304*8192
integer d0v
integer d1v
integer d2v
integer d3v
integer d4v=0
integer d5v=U
boolean array d6v
integer d7v=0
integer array d8v
integer d9v=U
integer array Dvv
boolean array Dev
boolean array Dxv
integer array Dov
real array Drv
integer Div=9
integer Dav=9
integer Dnv=w
integer DVv
integer DEv
integer DXv
boolean DOv=false
integer DRv
constant integer DIv=O+8192+300*8192
integer array DAv
integer DNv
boolean Dbv=false
integer DBv
integer Dcv
constant integer DCv=O+296
integer array Ddv
integer DDv
integer Dfv
integer DFv
integer Dgv
integer DGv
integer Dhv
integer DHv
integer Djv
integer DJv
integer Dkv
integer DKv
constant integer Dlv=O+370
integer DLv=0
integer array Dmv
integer DMv=U
integer array Dpv
boolean array DPv
boolean array Dqv
integer array DQv
integer array Dsv
integer DSv
string Dtv="<StructId>"
integer DTv
string Duv="<StructBoolean>"
integer DUv
string Dwv="<StructTable>"
integer DWv
string Dyv="<StructInteger>"
integer DYv
string Dzv="<StructTable>"
integer DZv
string D_v="<StructReal>"
integer D0v
string D1v="<StructTable>"
integer D2v
string D3v="<StructString>"
integer D4v
string D5v="<StructData>"
integer D6v
string D7v="<StructBoolMods>"
integer D8v
string D9v="<StructRealMods>"
integer fvv
string fev="<StructCustomMods>"
integer fxv
string fov="<StructMods>"
integer frv
string fiv="<StructId>"
integer fav
string fnv="<StructTable>"
integer fVv
string fEv="<StructBoolean>"
integer fXv
string fOv="<StructTable>"
integer fRv
string fIv="<StructInteger>"
integer fAv
string fNv="<StructTable>"
integer fbv
string fBv="<StructReal>"
integer fcv
string fCv="<StructTable>"
integer fdv
string fDv="<StructString>"
integer ffv
string fFv="<StructData>"
integer fgv
string fGv="<StructEvent>"
integer fhv
string fHv="<StructArrayBuild>"
integer fjv
string fJv="<StructHero>"
integer fkv
string fKv="<StructAbilities>"
integer flv
string fLv="<StructType>"
integer fmv
string fMv="<StructArmor>"
integer fpv
string fPv="<StructAttachments>"
integer fqv
string fQv="<StructSpeed>"
integer fsv
string fSv="<StructMissile>"
integer ftv
string fTv="<StructRange>"
integer fuv
string fUv="<StructSpeed>"
integer fwv
string fWv="<StructTargetFlag>"
integer fyv
string fYv="<StructSplash>"
integer fzv
string fZv="<StructAttack>"
integer f_v
string f0v="<StructBlood>"
integer f1v
string f2v="<StructBloodExplosion>"
integer f3v
string f4v="<StructClasses>"
integer f5v
string f6v="<StructCollisionSize>"
integer f7v
string f8v="<StructDelay>"
integer f9v
string Fvv="<StructDices>"
integer Fev
string Fxv="<StructSides>"
integer Fov
string Frv="<StructType>"
integer Fiv
string Fav="<StructDamage>"
integer Fnv
string FVv="<StructDuration>"
integer FEv
string FXv="<StructDecay>"
integer FOv
string FRv="<StructExp>"
integer FIv
string FAv="<StructSupply>"
integer FNv
string Fbv="<StructDrop>"
integer FBv
string Fcv="<StructZ>"
integer FCv
string Fdv="<StructImpact>"
integer FDv
string Ffv="<StructZ>"
integer FFv
string Fgv="<StructOutpact>"
integer FGv
string Fhv="<StructLife>"
integer FHv
string Fjv="<StructLifeRegeneration>"
integer FJv
string Fkv="<StructMana>"
integer FKv
string Flv="<StructManaRegeneration>"
integer FLv
string Fmv="<StructPreload>"
integer FMv
string Fpv="<StructRevivalable>"
integer FPv
string Fqv="<StructScale>"
integer FQv
string Fsv="<StructSightRange>"
integer FSv
string Ftv="<StructSpeed>"
integer FTv
string Fuv="<StructSpellPower>"
integer FUv
string Fwv="<StructSpellVamp>"
integer FWv
string Fyv="<StructRed>"
integer FYv
string Fzv="<StructGreen>"
integer FZv
string F_v="<StructBlue>"
integer F0v
string F1v="<StructAlpha>"
integer F2v
string F3v="<StructVertexColor>"
integer F4v
string F5v="<StructPrimaryAttribute>"
integer F6v
string F7v="<StructPerLevel>"
integer F8v
string F9v="<StructAgility>"
integer gvv
string gev="<StructArmorPerLevel>"
integer gxv
string gov="<StructPerLevel>"
integer grv
string giv="<StructIntelligence>"
integer gav
string gnv="<StructPerLevel>"
integer gVv
string gEv="<StructStrength>"
integer gXv
string gOv="<StructHero>"
integer gRv
integer gIv=0
string gAv="<UnitType>"
integer array gNv
integer gbv=U
integer array gBv
boolean array gcv
boolean array gCv
integer gdv
string array gDv
constant integer gfv=O+8192+406*8192
boolean array gFv
integer ggv=F
integer array gGv
integer array ghv
integer gHv=1
integer gjv
integer gJv
integer gkv
integer gKv=2
integer glv
integer gLv
integer gmv
integer gMv
integer gpv
integer gPv
integer gqv
integer gQv
integer gsv
integer gSv=3
integer gtv
integer gTv
integer guv
integer gUv
integer gwv
integer gWv
integer gyv
integer gYv
integer gzv
integer gZv
integer g_v
integer g0v
integer g1v
integer g2v
integer g3v
integer g4v
integer g5v
integer g6v
integer g7v
integer g8v
integer g9v
integer Gvv
integer Gev
integer Gxv
integer Gov
integer Grv
integer Giv
integer Gav
integer Gnv
integer GVv
integer GEv
integer GXv
integer GOv
integer GRv
integer GIv
integer GAv
integer GNv
integer Gbv
integer GBv
integer Gcv
integer GCv
integer Gdv
integer GDv
integer Gfv
integer GFv
integer Ggv
integer GGv
integer Ghv
integer GHv
integer Gjv
integer GJv
integer Gkv
integer GKv
integer Glv
integer GLv
integer Gmv
integer GMv
integer Gpv
integer GPv
integer Gqv
integer GQv
integer Gsv
integer GSv
integer Gtv
integer GTv
integer Guv
integer GUv
integer Gwv
integer GWv
integer Gyv
integer GYv
integer Gzv
integer GZv
integer G_v
integer G0v
integer G1v
integer G2v
integer G3v
integer G4v
integer G5v
integer G6v
integer G7v
integer G8v
integer G9v
integer hvv
integer hev
integer hxv
integer hov
integer hrv
integer hiv
integer hav
integer hnv
integer hVv
integer hEv
integer hXv
integer hOv
integer hRv
integer hIv
integer hAv
integer hNv
integer hbv
integer hBv
integer hcv
integer hCv
integer hdv
integer hDv
integer hfv
integer hFv
integer hgv
integer hGv
string hhv="<PlayerController>"
integer hHv
string hjv="<PlayerSlotState>"
integer hJv
string hkv="<Team>"
integer hKv
string hlv="<StructId>"
integer hLv
string hmv="<StructBoolean>"
integer hMv
string hpv="<StructTable>"
integer hPv
string hqv="<StructInteger>"
integer hQv
string hsv="<StructData>"
integer hSv
string htv="<StructNative>"
integer hTv
string huv="<StructEvent>"
integer hUv
string hwv="<StructController>"
integer hWv
string hyv="<StructHostAppointment>"
integer hYv
string hzv="<StructHero>"
integer hZv
string h_v="<StructKeyEvent>"
integer h0v
string h1v="<StructSlotState>"
integer h2v
string h3v="<StructState>"
integer h4v
string h5v="<StructTeam>"
integer h6v
integer h7v
integer h8v
integer h9v
integer Hvv=0
integer array Hev
integer Hxv=U
integer array Hov
boolean array Hrv
boolean array Hiv
mapcontrol array Hav
constant integer Hnv=O+8192+425*8192
constant integer HVv=O+423
integer HEv
integer HXv
integer HOv=0
integer array HRv
integer HIv=U
integer array HAv
boolean array HNv
boolean array Hbv
playerslotstate array HBv
constant integer Hcv=O+8192+429*8192
constant integer HCv=O+427
integer Hdv
integer HDv
integer Hfv
integer HFv=0
integer array Hgv
integer HGv=U
integer array Hhv
boolean array HHv
boolean array Hjv
integer HJv
integer Hkv=0
integer array HKv
integer Hlv=U
integer array HLv
boolean array Hmv
boolean array HMv
integer array Hpv
integer array HPv
integer Hqv=F
integer array HQv
constant integer Hsv=O+8192+435*8192
integer array HSv
constant integer Htv=O+453
constant integer HTv=O+8192+433*8192
constant integer Huv=O+8192+431*8192
string HUv="User_page\\User_struct\\lala.ai"
integer Hwv
integer HWv
integer Hyv
integer HYv
integer Hzv
gamecache HZv
integer H_v=w
integer H0v
integer H1v
integer H2v
integer H3v
integer H4v
integer H5v
integer H6v
string H7v="<WeatherType>"
integer H8v
integer H9v=0
integer array jvv
integer jev=U
integer array jxv
boolean array jov
boolean array jrv
integer array jiv
integer jav
string jnv="<WeatherEffect>"
integer jVv
integer jEv=0
integer array jXv
integer jOv=U
integer array jRv
boolean array jIv
boolean array jAv
weathereffect array jNv
integer jbv
integer jBv
string jcv="<Initialization>"
integer jCv
string jdv="<StructId>"
integer jDv
string jfv="<StructTable>"
integer jFv
string jgv="<StructInteger>"
integer jGv
string jhv="<StructData>"
integer jHv
string jjv="<StructEvent>"
integer jJv
string jkv="<StructLevelSets>"
integer jKv
string jlv="<Act>"
integer jLv
integer jmv
integer jMv
integer jpv=w
boolean jPv=false
integer jqv
integer jQv
integer jsv
string array jSv
integer jtv
integer array jTv
integer array juv
constant integer jUv=O+8192+465*8192
boolean jwv
integer jWv
integer jyv
integer jYv
integer jzv
integer jZv
integer j_v
string array j0v
integer j1v
integer j2v=0
integer array j3v
integer j4v=U
integer array j5v
boolean array j6v
boolean array j7v
integer array j8v
integer array j9v
integer Jvv=F
integer array Jev
integer array Jxv
integer array Jov
integer array Jrv
constant integer Jiv=O+8192+463*8192
boolean array Jav
string array Jnv
integer JVv
integer JEv
integer JXv
integer JOv
integer JRv
integer JIv
integer JAv
integer JNv
integer Jbv
integer array JBv
integer array Jcv
constant integer JCv=O+8192+511*8192
integer array Jdv
integer JDv
string Jfv="<ActUpgrades>"
integer JFv
string Jgv="<AfterIntro>"
integer JGv
integer Jhv
integer JHv
string Jjv="<BrazierOracle>"
real JJv
real Jkv
real JKv
real Jlv
constant integer JLv=O+541
integer Jmv=w
integer JMv=w
real array Jpv
constant real JPv=(2*1.)*1./ 32
integer array Jqv
integer JQv
integer Jsv
string JSv="<CameraQuickPosition>"
integer Jtv
integer JTv
integer Juv
integer JUv
string Jwv="<MarkOfThePaw>"
integer JWv
string Jyv="<CreepLoot>"
integer JYv
string Jzv="<Creep>"
integer JZv
string J_v="<CreepLocation>"
integer J0v
string J1v="<StructId>"
integer J2v
string J3v="<StructTable>"
integer J4v
string J5v="<StructInteger>"
integer J6v
string J7v="<StructData>"
integer J8v
string J9v="<StructEvent>"
integer kvv
string kev="<CreepSet>"
integer kxv
constant integer kov=O+467
integer array krv
integer array kiv
integer array kav
integer array knv
boolean array kVv
integer array kEv
integer array kXv
integer kOv=F
integer array kRv
integer kIv
integer kAv=0
integer array kNv
integer kbv=U
integer array kBv
boolean array kcv
boolean array kCv
integer array kdv
integer kDv
integer kfv
integer kFv
integer kgv
integer kGv
integer khv
constant integer kHv=O+8192+473*8192
integer array kjv
integer kJv=0
integer kkv=U
boolean array kKv
integer array klv
integer array kLv
integer array kmv
real array kMv
real array kpv
string array kPv
boolean array kqv
integer array kQv
integer array ksv
constant integer kSv=O+8192+471*8192
integer array ktv
real array kTv
real array kuv
real array kUv
integer array kwv
integer kWv=0
integer array kyv
integer kYv=U
integer array kzv
boolean array kZv
boolean array k_v
integer array k0v
constant integer k1v=O+8192+469*8192
integer k2v
integer k3v=0
integer array k4v
integer k5v=U
integer array k6v
boolean array k7v
boolean array k8v
integer k9v
integer Kvv
integer Kev
integer Kxv
integer Kov
integer Krv
integer Kiv
string Kav="<DefenderSpawnLocation>"
integer Knv
string KVv="<StructId>"
integer KEv
string KXv="<StructTable>"
integer KOv
string KRv="<StructInteger>"
integer KIv
string KAv="<StructData>"
integer KNv
string Kbv="<StructEvent>"
integer KBv
string Kcv="<DefenderSpawnType>"
integer KCv
string Kdv="<StructId>"
integer KDv
string Kfv="<StructTable>"
integer KFv
string Kgv="<StructInteger>"
integer KGv
string Khv="<StructData>"
integer KHv
string Kjv="<DefenderSpawnGroup>"
integer KJv
string Kkv="<StructId>"
integer KKv
string Klv="<StructTable>"
integer KLv
string Kmv="<StructInteger>"
integer KMv
string Kpv="<StructData>"
integer KPv
string Kqv="<StructGroups>"
integer KQv
string Ksv="<DefenderSpawnWave>"
integer KSv
string Ktv="<DefenderSpawn>"
integer KTv
integer Kuv
constant integer KUv=O+487
integer array Kwv
integer array KWv
constant integer Kyv=O+8192+485*8192
integer array KYv
integer array Kzv
integer array KZv
integer array K_v
integer array K0v
constant integer K1v=O+8192+481*8192
integer array K2v
integer array K3v
integer array K4v
integer array K5v
integer K6v
integer K7v=0
integer array K8v
integer K9v=U
integer array lvv
boolean array lev
boolean array lxv
integer lov=F
integer array lrv
integer array liv
integer lav
integer lnv
integer lVv
integer lEv=0
integer array lXv
integer lOv=U
integer array lRv
boolean array lIv
boolean array lAv
integer array lNv
integer lbv=F
integer array lBv
integer array lcv
constant integer lCv=O+8192+475*8192
integer ldv
integer lDv
integer lfv=F
boolean array lFv
integer lgv=0
integer array lGv
integer lhv=U
integer array lHv
boolean array ljv
boolean array lJv
integer array lkv
real array lKv
constant integer llv=O+8192+483*8192
integer lLv=0
integer array lmv
integer lMv=U
integer array lpv
boolean array lPv
boolean array lqv
constant integer lQv=O+8192+479*8192
integer lsv
string lSv="<Difficulty>"
integer ltv
string lTv="<Drop>"
integer luv
integer lUv
string lwv="Abilities\\Spells\\Items\\ResourceItems\\ResourceEffectTarget.mdx"
string lWv="origin"
constant integer lyv=O+8192+493*8192
constant integer lYv=O+8192+491*8192
real lzv=1.
integer lZv
integer l_v=0
integer array l0v
integer l1v=U
integer array l2v
boolean array l3v
boolean array l4v
boolean array l5v
constant integer l6v=$CF
constant integer l7v=O+8192+l6v*8192
integer array l8v
constant integer l9v=$DB
constant integer Lvv=O+8192+l9v*8192
integer Lev
integer Lxv=0
integer array Lov
integer Lrv=U
integer array Liv
boolean array Lav
boolean array Lnv
constant integer LVv=O+8192+'v'*8192
string array LEv
integer LXv
string LOv="<EternalVial>"
string LRv="Abilities\\Spells\\Items\\AIre\\AIreTarget.mdl"
string LIv="origin"
constant integer LAv=O+8192+384*8192
real array LNv
real Lbv=.5
constant integer LBv=O+8192+386*8192
real Lcv=.5
constant integer LCv=O+8192+387*8192
real Ldv=.5
integer LDv
string Lfv="<Explosive>"
integer LFv
integer Lgv
integer LGv=0
integer array Lhv
integer LHv=U
integer array Ljv
boolean array LJv
boolean array Lkv
real array LKv
real array Llv
effect array LLv
integer array Lmv
integer array LMv
boolean array Lpv
integer array LPv
integer array Lqv
integer array LQv
integer Lsv=0
integer LSv=U
boolean array Ltv
integer array LTv
string array Luv
real array LUv
real array Lwv
string LWv="Objects\\Spawnmodels\\Other\\NeutralBuildingExplosion\\NeutralBuildingExplosion.mdl"
integer Lyv
integer LYv
integer Lzv
integer LZv
string L_v="<GarbageCollector>"
integer L0v
integer L1v
integer L2v
string L3v="<BoomerangStone>"
integer L4v=0
integer array L5v
integer L6v=U
integer array L7v
boolean array L8v
boolean array L9v
integer array mvv
boolean array mev
real array mxv
real array mov
real array mrv
constant real miv=(1*1.)*1./ 32
real array mav
real array mnv
real array mVv
real array mEv
real array mXv
real array mOv
real array mRv
real array mIv
real array mAv
real array mNv
boolean array mbv
constant integer mBv=$BA
constant integer mcv=O+8192+mBv*8192
integer array mCv
integer array mdv
integer array mDv
integer array mfv
real array mFv
real array mgv
real array mGv
real array mhv
boolean array mHv
real array mjv
real array mJv
real array mkv
real array mKv
real array mlv
real array mLv
real array mmv
real array mMv
integer mpv=0
integer array mPv
integer mqv=U
integer array mQv
boolean array msv
boolean array mSv
integer array mtv
integer array mTv
real array muv
real array mUv
real array mwv
integer array mWv
integer myv=3
integer mYv=70
real array mzv
real array mZv
real array m_v
boolean array m0v
real array m1v
real array m2v
integer array m3v
integer m4v=F
real array m5v
real array m6v
real array m7v
real m8v
real m9v
real Mvv
trigger Mev
real array Mxv
integer Mov
integer Mrv
string Miv="<Mallet>"
integer Mav
string array Mnv
integer MVv
integer MEv
string MXv="<PenguinFeather>"
real MOv=.35
integer MRv=3
integer MIv=0
integer array MAv
integer MNv=U
integer array Mbv
boolean array MBv
boolean array Mcv
integer array MCv
string Mdv="Abilities\\Spells\\Human\\Resurrect\\ResurrectTarget.mdl"
string MDv="origin"
integer Mfv='x'
integer MFv
integer Mgv
string MGv="<RabbitsFoot>"
integer Mhv
integer MHv
string Mjv="<RamblersStick>"
integer MJv
integer Mkv
string MKv="<GruntAxe>"
integer Mlv
integer MLv
string Mmv="<RobynsHood>"
integer MMv
integer Mpv
string MPv="<ElfinDagger>"
integer Mqv
integer MQv
string Msv="<StructBuff>"
integer MSv
integer Mtv
string MTv="<SpearOfTheDefender>"
integer Muv
integer MUv
constant integer Mwv=O+497
constant real MWv=-.2
integer array Myv
integer array MYv
constant integer Mzv=$A
constant real MZv=10.*1./ Mzv
constant real M_v=50.*1./ Mzv
integer M0v
integer M1v
string M2v="<MeteoriteShard>"
integer M3v
integer M4v
integer M5v
string M6v="<GoldCoin>"
integer M7v
integer M8v
integer M9v=0
integer array pvv
integer pev=U
integer array pxv
boolean array pov
boolean array prv
integer array piv
constant integer pav=O+499
integer pnv
integer pVv
integer pEv
string pXv="<HeroRevival>"
integer pOv
integer pRv=0
integer array pIv
integer pAv=U
integer array pNv
boolean array pbv
boolean array pBv
blendmode array pcv
integer array pCv
integer array pdv
integer array pDv
integer array pfv
integer array pFv
integer array pgv
integer array pGv
integer array phv
texmapflags array pHv
string array pjv
real array pJv
real array pkv
real array pKv
real array plv
real array pLv
real array pmv
real array pMv
real array ppv
integer array pPv
integer pqv
integer pQv=0
integer psv=0
integer array pSv
integer ptv=U
integer array pTv
boolean array puv
boolean array pUv
integer array pwv
integer array pWv
string pyv="Abilities\\Spells\\Undead\\RegenerationAura\\ObsidianRegenAura.mdl"
string pYv="origin"
integer array pzv
integer array pZv
constant integer p_v=O+501
string p0v="Abilities\\Spells\\Undead\\CarrionSwarm\\CarrionSwarmDamage.mdl"
string p1v="chest"
integer p2v=$A
integer p3v='d'
integer p4v
constant real p5v=(4*1.)*1./ 32
integer p6v
string p7v="Abilities\\Spells\\Human\\ReviveHuman\\ReviveHuman.mdl"
string p8v="origin"
integer p9v=5
integer Pvv=1
real Pev=.5
integer Pxv
integer Pov
string Prv="<HeroSelection>"
integer Piv
integer Pav
integer Pnv
integer array PVv
integer PEv
constant integer PXv=O+503
integer array POv
integer array PRv
real array PIv
real array PAv
real array PNv
integer Pbv=0
integer array PBv
integer Pcv=U
integer array PCv
boolean array Pdv
boolean array PDv
integer array Pfv
string PFv="Abilities\\Spells\\NightElf\\Blink\\BlinkTarget.mdl"
string Pgv="Abilities\\Spells\\Items\\TomeOfRetraining\\TomeOfRetrainingCaster.mdl"
string PGv="origin"
string array Phv
integer array PHv
constant integer Pjv=O+8192+505*8192
real PJv
real Pkv
integer PKv
integer Plv=0
integer array PLv
integer Pmv=U
integer array PMv
boolean array Ppv
boolean array PPv
string array Pqv
integer array PQv
integer Psv
integer PSv
integer Ptv
integer PTv
integer Puv
integer PUv
integer Pwv
integer PWv
integer Pyv
integer PYv
integer Pzv
integer PZv
integer P_v
integer P0v
integer P1v
integer P2v
real P3v
real P4v
integer P5v
integer P6v
region array P7v
integer P8v=0
integer array P9v
integer qvv=U
integer array qev
boolean array qxv
boolean array qov
integer array qrv
integer array qiv
constant integer qav=$CA
constant integer qnv=O+qav
integer array qVv
constant integer qEv=$C9
constant integer qXv=O+8192+qEv*8192
integer qOv
string qRv="<Hint>"
integer qIv=0
integer array qAv
integer qNv=U
integer array qbv
boolean array qBv
boolean array qcv
string array qCv
integer qdv=F
integer array qDv
integer array qfv
integer qFv
string qgv="<StructTarget>"
integer qGv
integer qhv
integer qHv
integer qjv
string qJv="<HorseRide>"
integer qkv
group qKv
integer qlv
integer qLv
integer array qmv
integer array qMv
integer array qpv
integer array qPv
integer array qqv
integer qQv=-65
constant real qsv=(2*1.)*1./ 32
integer qSv=0
integer array qtv
integer qTv=U
integer array quv
boolean array qUv
boolean array qwv
real array qWv
real array qyv
real array qYv
real array qzv
integer array qZv
integer array q_v
constant integer q0v=$B4
constant integer q1v=O+8192+q0v*8192
integer q2v=F
integer array q3v
integer array q4v
real q5v=.5
integer array q6v
integer q7v=$C8
integer q8v
integer array q9v
integer Qvv=0
integer Qev=U
boolean array Qxv
string Qov="UI\\Feedback\\WaypointFlags\\WaypointFlag.mdl"
string Qrv="origin"
string Qiv="Abilities\\Spells\\Human\\Polymorph\\PolyMorphDoneGround.mdl"
string Qav="origin"
integer Qnv=2
string QVv="Abilities\\Spells\\Human\\Polymorph\\PolyMorphDoneGround.mdl"
string QEv="origin"
integer QXv
string QOv="<StructUser>"
integer QRv
string QIv="<Infoboard>"
integer QAv
integer array QNv
integer Qbv=w
integer QBv
integer Qcv
integer QCv
integer Qdv
integer QDv
integer Qfv
integer QFv
boolean array Qgv
integer array QGv
boolean array Qhv
boolean array QHv
boolean array Qjv
boolean array QJv
boolean array Qkv
boolean array QKv
boolean array Qlv
integer QLv
string array Qmv
integer QMv
integer Qpv=0
integer array QPv
integer Qqv=U
integer array QQv
boolean array Qsv
boolean array QSv
integer Qtv
integer QTv=0
integer array Quv
integer QUv=U
integer array Qwv
boolean array QWv
boolean array Qyv
integer array QYv
integer array Qzv
constant integer QZv=$C0
constant integer Q_v=O+QZv
integer Q0v
string Q1v="<Infocard>"
integer Q2v=0
integer array Q3v
integer Q4v=U
integer array Q5v
boolean array Q6v
boolean array Q7v
quest array Q8v
string Q9v
string svv="About month ago, two peculiarly luminescent comets draught across the sky. While one featured a blue color and immediately vanished again behind the horizont, the red one bolted right into the capital of the united species of this planet. The shock wave tore apart buildings and roads and devastated most of the town. Many lost their lives."
string sev="As if this was not enough already, the sky darkened the day after and it became bitterly cold. Only the of a strange material consisting meteorite seemed to spend some even weirder soothing warmth. Though, the sky cleared a bit within time, the cold persisted and drove us to leave this place since a reconstruction appeared impossible before we would freeze to death. We fleed to the adjacent shire of count Dracula who there possesses a big castle which is directly worked into the Crystal Mountains. We also brought the meteorite with us whose still thermal energies emitting nature easily mesmerized us."
string sxv="Since that time we try to get along with the small rations here and hope that the sun will return to us someday. Yet, the problems pile up: Besides the lack of food and the ongoing frost which we call the "+"\""+"Big Winter"+"\""+", the surrounding forest's inhabitants are becoming very anxious, too. The last three weeks, there were twenty attacks and break-ins by wolves and other confused animals. Most of us refugees do not dare to leave the castle anymore. And how long will the strange stone keep on giving us strength and hope?"
integer sov
integer srv
string siv="<Intro>"
integer sav
integer snv
integer sVv
integer sEv
integer sXv
integer sOv=0
integer array sRv
integer sIv=U
integer array sAv
boolean array sNv
boolean array sbv
constant integer sBv=O+8192+46*8192
integer scv=0
integer array sCv
integer sdv=U
integer array sDv
boolean array sfv
boolean array sFv
string array sgv
integer array sGv
integer array shv
integer array sHv
integer array sjv
integer sJv=0
integer array skv
integer sKv=U
integer array slv
boolean array sLv
boolean array smv
integer array sMv
constant integer spv=O+8192+44*8192
integer array sPv
string array sqv
constant integer sQv=O+8192+50*8192
constant integer ssv=O+8192+54*8192
constant integer sSv=O+8192+52*8192
constant integer stv=O+489
integer sTv=F
integer array suv
integer array sUv
integer swv
integer array sWv
integer syv=0
integer array sYv
integer szv=U
integer array sZv
boolean array s_v
boolean array s0v
integer array s1v
real array s2v
integer array s3v
integer s4v
constant integer s5v=O+567
integer array s6v
integer s7v
boolean s8v
integer s9v=0
string Svv="<Artifact>"
integer array Sev
integer Sxv=U
integer array Sov
boolean array Srv
boolean array Siv
integer Sav
integer Snv
integer SVv
integer SEv
integer SXv
integer SOv
integer SRv
integer SIv
integer SAv
integer SNv
integer Sbv
integer SBv
integer Scv
integer SCv
integer Sdv
integer SDv
integer Sfv
integer SFv
integer Sgv
integer SGv
integer Shv
integer SHv
integer Sjv
integer SJv
integer Skv
integer SKv
integer Slv=0
integer array SLv
integer Smv=U
integer array SMv
boolean array Spv
boolean array SPv
camerasetup array Sqv
integer SQv
integer Ssv
integer SSv
integer Stv
integer STv
integer Suv
integer SUv
integer Swv
integer SWv
integer Syv
integer SYv
integer Szv
integer SZv
integer S_v
integer S0v
integer S1v
integer S2v
integer S3v
integer S4v
integer S5v
integer S6v
integer S7v
integer S8v
integer S9v
integer tvv
integer tev
integer txv
integer tov
integer trv
integer tiv
integer tav
integer tnv
integer tVv
integer tEv
constant real tXv=.5*3.141592654
integer tOv
integer tRv
string tIv="Sound\\Ambient\\DoodadEffects\\LordaeronSummerBrazierLoop1.wav"
integer tAv
string tNv="<StructId>"
integer tbv
string tBv="<StructTable>"
integer tcv
string tCv="<StructInteger>"
integer tdv
string tDv="<StructData>"
integer tfv
string tFv="<StructLevels>"
integer tgv
string tGv="<StructQuery>"
integer thv
string tHv="<LevelSet>"
integer tjv
string tJv="<StructId>"
integer tkv
string tKv="<StructTable>"
integer tlv
string tLv="<StructInteger>"
integer tmv
string tMv="<StructReal>"
integer tpv
string tPv="<StructData>"
integer tqv
string tQv="<StructEvent>"
integer tsv
string tSv="<Level>"
integer ttv=0
integer array tTv
integer tuv=U
integer array tUv
boolean array twv
boolean array tWv
constant integer tyv=O+8192+513*8192
integer tYv
integer tzv
integer tZv
integer t_v
integer t0v
integer t1v
integer t2v
integer t3v
integer t4v
integer t5v
integer t6v
integer t7v
integer t8v
integer t9v
integer Tvv
string array Tev
integer Txv
integer array Tov
integer Trv=0
integer array Tiv
integer Tav=U
integer array Tnv
boolean array TVv
boolean array TEv
constant integer TXv=O+8192+509*8192
integer TOv
string TRv="<Library>"
integer TIv
integer TAv
integer TNv
string Tbv="<Lumber>"
integer TBv
constant integer Tcv=O+517
integer array TCv
real array Tdv
real array TDv
integer array Tfv
integer array TFv
integer Tgv=0
integer array TGv
integer Thv=U
integer array THv
boolean array Tjv
boolean array TJv
integer array Tkv
integer array TKv
integer array Tlv
constant integer TLv=$F
integer Tmv
string TMv="<StructQuestLog>"
integer Tpv
string TPv="<Nullboard>"
integer Tqv
integer TQv
integer Tsv
integer TSv
integer Ttv
integer TTv
integer Tuv
integer TUv
integer Twv
string array TWv
integer array Tyv
boolean TYv=false
quest Tzv
integer TZv
string T_v="<StructCameraSmoothing>"
integer T0v
string T1v="<StructCameraZoom>"
integer T2v
string T3v="<StructEffectLevel>"
integer T4v
string T5v="<StructHint>"
integer T6v
string T7v="<StructMusicVolume>"
integer T8v
string T9v="<StructSoundVolume>"
integer uvv
string uev="<OptionsBoard>"
integer uxv
integer uov
integer urv
integer uiv=0
integer array uav
integer unv=U
integer array uVv
boolean array uEv
boolean array uXv
integer uOv
integer uRv
string uIv="<Pharmacy>"
integer uAv
integer uNv
integer ubv
string uBv="<EmergencyProvisions>"
string ucv="Abilities\\Spells\\Human\\Heal\\HealTarget.mdl"
string uCv="origin"
integer udv='d'
integer uDv
integer ufv
integer uFv
integer ugv
integer uGv
integer uhv
string uHv="<EyeOfTheFlame>"
integer ujv=1
integer uJv=40
integer ukv
string uKv="<TorchLight>"
integer ulv
integer uLv
integer umv
integer uMv=2
integer upv=5
integer uPv
integer array uqv
integer uQv
integer usv
integer uSv
integer utv
string uTv="<HerbalOintment>"
integer uuv
integer uUv
integer uwv=$A
integer uWv=1
integer array uyv
integer array uYv
real uzv
real uZv
integer u_v=$C8
integer u0v=$C8
integer u1v
integer u2v
string u3v="<StructTarget>"
integer u4v
constant integer u5v=$D6
constant integer u6v=O+8192+u5v*8192
integer u7v
integer u8v
string u9v="<ScrollOfProtection>"
integer Uvv
integer Uev
string Uxv="Abilities\\Spells\\Items\\AIda\\AIdaCaster.mdl"
integer Uov=30
integer Urv
integer Uiv
string Uav="<StructBuff>"
integer Unv
integer UVv
integer UEv
string UXv="<FireWater>"
string UOv="Abilities\\Spells\\Items\\AIma\\AImaTarget.mdl"
string URv="origin"
integer UIv=750
integer UAv=$F
real UNv
integer Ubv=30
real UBv=.35
integer Ucv
integer UCv
real array Udv
integer array UDv
integer Ufv
integer UFv
integer Ugv
integer array UGv
integer Uhv
integer UHv
string Ujv="<IceTea>"
string UJv="Abilities\\Spells\\Items\\AIma\\AImaTarget.mdl"
string Ukv="origin"
integer UKv
integer Ulv
integer ULv
string Umv="<Meat>"
integer UMv
constant integer Upv=O+8192+519*8192
integer array UPv
integer array Uqv
integer array UQv
boolean array Usv
integer array USv
integer Utv
integer UTv=$A
integer Uuv=1
integer UUv=0
integer Uwv=U
boolean array UWv
integer array Uyv
string UYv="Abilities\\Spells\\Human\\Heal\\HealTarget.mdl"
string Uzv="origin"
real UZv
integer U_v=300
integer U0v
string U1v="<TeleportScroll>"
integer U2v
integer U3v
integer U4v
real U5v
integer U6v=$400
integer U7v
constant integer U8v=O+8192+521*8192
integer U9v
integer wvv
real wev
real wxv
integer array wov
integer array wrv
string wiv="Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTo.mdl"
string wav="origin"
real array wnv
real array wVv
string wEv="Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl"
string wXv="origin"
integer wOv
integer wRv
string wIv="<Rune>"
integer wAv
integer wNv
integer wbv
integer wBv=0
integer wcv=$C
integer wCv=0
integer array wdv
integer wDv=U
integer array wfv
boolean array wFv
boolean array wgv
integer array wGv
integer array whv
constant integer wHv=O+523
integer wjv
integer wJv=20
string wkv="Abilities\\Spells\\Other\\Andt\\Andt.mdl"
integer wKv=$C8
real wlv=.15
real wLv=.15
integer wmv
integer wMv
integer wpv
integer wPv
string wqv="<Snowmen>"
integer wQv
integer wsv=0
string wSv="Snowmen_page\\Snowmen_struct\\Possession.mdx"
string wtv="origin"
integer wTv
string wuv="<SpawnLocation>"
integer wUv
string wwv="<StructId>"
integer wWv
string wyv="<StructTable>"
integer wYv
string wzv="<StructInteger>"
integer wZv
string w_v="<StructData>"
integer w0v
string w1v="<SpawnGroup>"
integer w2v
string w3v="<StructId>"
integer w4v
string w5v="<StructTable>"
integer w6v
string w7v="<StructInteger>"
integer w8v
string w9v="<StructTable>"
integer Wvv
string Wev="<StructReal>"
integer Wxv
string Wov="<StructData>"
integer Wrv
string Wiv="<StructGroups>"
integer Wav
string Wnv="<SpawnWave>"
integer WVv
string WEv="<StructQueue>"
integer WXv
string WOv="<StructShadow>"
integer WRv
integer WIv
string WAv="<Spawn>"
integer WNv
integer Wbv
boolean array WBv
integer Wcv=F
integer WCv
integer array Wdv
integer array WDv
integer array Wfv
integer array WFv
constant integer Wgv=O+8192+537*8192
constant integer WGv=O+8192+539*8192
integer array Whv
integer WHv
timerdialog array Wjv
integer WJv
real array Wkv
real array WKv
real array Wlv
real array WLv
constant integer Wmv=O+8192+535*8192
integer array WMv
integer array Wpv
constant integer WPv=O+8192+527*8192
real array Wqv
real array WQv
real array Wsv
real array WSv
real array Wtv
constant integer WTv=O+8192+531*8192
constant integer Wuv=O+8192+529*8192
integer WUv=0
integer array Wwv
integer WWv=U
integer array Wyv
boolean array WYv
boolean array Wzv
integer array WZv
integer array W_v
real array W0v
real array W1v
real array W2v
integer W3v=w
integer array W4v
integer array W5v
integer W6v=w
integer W7v
integer array W8v
integer W9v=F
integer array yvv
integer array yev
integer array yxv
integer array yov
integer array yrv
integer array yiv
integer yav=F
integer ynv=0
integer array yVv
integer yEv=U
integer array yXv
boolean array yOv
boolean array yRv
integer yIv
constant integer yAv=O+8192+385*8192
integer yNv
constant integer ybv=O+543
integer yBv
integer ycv
integer array yCv
integer ydv
integer yDv
integer yfv=w
integer array yFv
integer array ygv
integer yGv=w
integer yhv
integer array yHv
integer yjv=F
integer yJv
constant integer ykv=O+553
integer yKv=0
integer array ylv
integer yLv=U
integer array ymv
boolean array yMv
boolean array ypv
integer yPv=0
integer yqv=F
integer array yQv
integer array ysv
integer ySv
integer ytv
integer yTv
integer yuv
integer array yUv
constant integer ywv=O+8192+547*8192
integer yWv=0
string yyv="<SpawnType>"
integer array yYv
integer yzv=U
integer array yZv
boolean array y_v
boolean array y0v
integer y1v
integer y2v=F
integer array y3v
integer array y4v
constant integer y5v=O+8192+545*8192
integer y6v
boolean array y7v
integer y8v
boolean array y9v
integer Yvv
boolean array Yev
integer Yxv
integer Yov
integer Yrv
boolean array Yiv
boolean array Yav
integer Ynv
integer YVv
integer YEv
integer YXv
integer YOv
integer YRv
integer YIv
integer YAv
integer YNv
integer Ybv
integer YBv
integer Ycv
boolean array YCv
integer Ydv
integer YDv
integer Yfv
boolean array YFv
integer Ygv
integer YGv
integer Yhv
integer YHv
integer Yjv
integer YJv
integer Ykv
integer YKv
integer Ylv=0
integer array YLv
integer Ymv=U
integer array YMv
boolean array Ypv
boolean array YPv
constant integer Yqv=O+8192+533*8192
integer array YQv
integer Ysv=0
integer array YSv
integer Ytv=U
integer array YTv
boolean array Yuv
boolean array YUv
constant integer Ywv=O+8192+525*8192
boolean array YWv
integer Yyv
string YYv="<StructId>"
integer Yzv
string YZv="<StructTable>"
integer Y_v
string Y0v="<StructInteger>"
integer Y1v
string Y2v="<StructData>"
integer Y3v
string Y4v="<StructEvent>"
integer Y5v
string Y6v="<StructChampion>"
integer Y7v
string Y8v="<StructItems>"
integer Y9v
string zvv="<StructInfo>"
integer zev
integer zxv
integer zov
string zrv="<Tavern>"
integer ziv
integer zav
integer znv
integer zVv
string zEv="<TropicalRainbow>"
integer zXv=60
integer zOv
integer zRv
string zIv="<StructAgi>"
integer zAv
integer zNv
string zbv="<StructInt>"
integer zBv
integer zcv
string zCv="<StructStr>"
integer zdv
string zDv="<Tomes>"
constant integer zfv=O+551
integer array zFv
string zgv="Abilities\\Spells\\Items\\AIam\\AIamTarget.mdl"
string zGv="origin"
string zhv="Abilities\\Spells\\Items\\AIsm\\AIsmTarget.mdl"
string zHv="origin"
string zjv="Abilities\\Spells\\Items\\AIsm\\AIsmTarget.mdl"
string zJv="origin"
integer zkv
string zKv="<UnitNameTag>"
integer zlv
integer array zLv
integer zmv
integer zMv
string zpv="<UnitStatus>"
integer zPv
integer zqv
integer zQv
integer array zsv
real zSv=.0
real ztv=.0
real zTv=.0
integer zuv
integer zUv
integer zwv
integer zWv
integer zyv
constant real zYv=(.05*32)*.125
integer zzv
integer zZv
integer z_v
integer z0v
integer z1v
integer z2v
integer z3v
integer z4v
integer z5v
integer z6v=0
integer z7v
integer z8v
integer z9v
string Zvv="<VictoryRush>"
integer Zev
string Zxv="Abilities\\Spells\\NightElf\\BattleRoar\\RoarCaster.mdx"
integer Zov
integer Zrv=400
integer Ziv
integer Zav=$F
integer Znv
string ZVv="<StructRetreat>"
integer ZEv
integer ZXv
string ZOv="<StructRegionCheck>"
integer ZRv
string ZIv="<StructSpawns>"
integer ZAv
string ZNv="<Waypoint>"
integer Zbv=0
integer array ZBv
integer Zcv=U
integer array ZCv
boolean array Zdv
boolean array ZDv
integer array Zfv
integer ZFv
integer array Zgv
integer ZGv=5
integer Zhv
integer ZHv
integer Zjv
integer ZJv
integer Zkv
integer ZKv=F
integer array Zlv
integer array ZLv
integer Zmv=F
integer ZMv
string Zpv="<Zoom>"
integer ZPv
real array Zqv
real array ZQv
integer Zsv=F
integer array ZSv
integer array Ztv
constant real ZTv=20*Vj
constant integer Zuv=O+8192+36*8192
integer array ZUv
integer array Zwv
boolean array ZWv
integer array Zyv
integer array ZYv
integer Zzv=F
integer array ZZv
integer Z_v=0
integer Z0v=U
boolean array Z1v
integer array Z2v
real array Z3v
constant real Z4v=(1*1.)*1./ 32
real array Z5v
integer array Z6v
real array Z7v
integer Z8v
string Z9v="<AxeFighter>"
integer vve
integer vee
integer vxe
string voe="<Balduir>"
integer vre
integer vie
integer vae
string vne="<StructId>"
integer vVe
string vEe="<StructBoolean>"
integer vXe
string vOe="<StructTable>"
integer vRe
string vIe="<StructInteger>"
integer vAe
string vNe="<StructData>"
integer vbe
string vBe="<StructEvent>"
integer vce
string vCe="<StructTarget>"
integer vde
string vDe="<Aura>"
integer vfe
integer vFe
integer vge
constant integer vGe=O+8192+559*8192
integer array vhe
integer array vHe
integer vje=F
integer array vJe
integer vke
integer array vKe
integer vle=F
integer array vLe
real array vme
integer array vMe
integer array vpe
integer array vPe
integer array vqe
integer vQe
integer vse
integer vSe
integer vte
string vTe="<AIBoost>"
integer vue=0
integer array vUe
integer vwe=U
integer array vWe
boolean array vye
boolean array vYe
integer array vze
constant integer vZe=O+8192+84*8192
integer array v_e
constant integer v0e=O+82
constant integer v1e=O+8192+86*8192
constant integer v2e=O+8192+96*8192
integer array v3e
integer array v4e
constant integer v5e=O+8192+94*8192
timer array v6e
real array v7e
boolean array v8e
integer v9e=0
integer array eve
integer eee=U
integer array exe
boolean array eoe
boolean array ere
integer array eie
integer array eae
integer array ene
integer eVe=lA
constant integer eEe=O+8192+98*8192
constant integer eXe=O+8192+92*8192
constant integer eOe=$9E
constant integer eRe=O+8192+eOe*8192
constant integer eIe=O+8192+90*8192
integer eAe
integer eNe
integer ebe
string eBe="<Boost>"
integer ece=3
integer eCe
string ede="<AIBurningSpirit>"
integer eDe
integer efe
integer eFe=0
integer array ege
integer eGe=U
integer array ehe
boolean array eHe
boolean array eje
constant integer eJe=$E5
constant integer eke=O+eJe
constant integer eKe=$E4
constant integer ele=O+8192+eKe*8192
integer array eLe
integer eme
string eMe="<BurningSpirit>"
integer epe
string ePe="<AIChaosBall>"
integer eqe
integer eQe
string ese="<ChaosBall>"
integer eSe
integer ete
integer eTe
boolean array eue
boolean array eUe
integer array ewe
integer array eWe
integer array eye
constant integer eYe=O+561
integer eze=80
constant real eZe=(1*1.)*1./ 32
integer e_e=0
integer array e0e
integer e1e=U
integer array e2e
boolean array e3e
boolean array e4e
real array e5e
integer array e6e
integer array e7e
constant integer e8e=$B0
constant integer e9e=O+8192+e8e*8192
integer xve=F
integer array xee
integer array xxe
real array xoe
integer array xre
string xie="Objects\\Spawnmodels\\Undead\\UCancelDeath\\UCancelDeath.mdl"
integer xae=65
integer xne=2
integer xVe=3
real array xEe
real array xXe
real array xOe
integer array xRe
integer xIe=F
integer xAe=300
integer xNe
integer xbe
string xBe="<StructTarget>"
integer xce
string xCe="<EnergyCharge>"
integer xde
integer xDe
integer array xfe
integer xFe=3
integer array xge
integer array xGe
string xhe="Abilities\\Spells\\Orc\\SpiritLink\\SpiritLinkTarget.mdx"
string xHe="chest"
string xje="Abilities\\Weapons\\WitchDoctorMissile\\WitchDoctorMissile.mdx"
string xJe="hand right"
integer xke
integer xKe=30
integer xle
string xLe="<AIFlamelet>"
integer xme
integer xMe
integer xpe
string xPe="<Flamelet>"
integer xqe
integer xQe
integer array xse
string xSe="Abilities\\Spells\\Other\\Incinerate\\IncinerateBuff.mdl"
string xte="weapon"
integer array xTe
string xue="Abilities\\Spells\\Other\\BreathOfFire\\BreathOfFireDamage.mdl"
string xUe="origin"
integer xwe=0
integer array xWe
integer xye=U
integer array xYe
boolean array xze
boolean array xZe
real array x_e
integer x0e=40
integer array x1e
real array x2e
real array x3e
real array x4e
integer x5e=900
real x6e=1.5
integer x7e=5
integer x8e
string x9e="<FuzzyAttack>"
real ove
real oee=2.5
integer oxe=7
constant integer ooe=O+8192+562*8192
integer array ore
integer array oie
integer array oae
integer array one
integer array oVe
boolean array oEe
integer oXe=0
integer oOe=U
boolean array oRe
integer array oIe
integer array oAe
integer oNe=50
integer obe
integer oBe
string oce="<StructBuff>"
integer oCe
string ode="<GreenNova>"
real oDe
real ofe=.125
integer oFe=$A
integer oge
real oGe
integer ohe=600
integer oHe
integer oje=0
integer array oJe
integer oke=U
integer array oKe
boolean array ole
boolean array oLe
real array ome
integer array oMe
integer array ope
integer array oPe
real array oqe
real array oQe
real array ose
real array oSe
integer ote=$C8
string oTe="Abilities\\Spells\\NightElf\\EntanglingRoots\\EntanglingRootsTarget.mdl"
integer oue=3
integer oUe=6
integer owe
string oWe="<AIHeal>"
integer oye
integer oYe=50
integer oze
string oZe="<Heal>"
string o_e="Abilities\\Spells\\Human\\HolyBolt\\HolyBoltSpecialArt.mdl"
string o0e="origin"
integer o1e
string o2e="<AIHealExplosion>"
integer o3e
integer o4e
integer o5e
string o6e="<HealExplosion>"
integer o7e
integer array o8e
string o9e="HealExplosion_page\\HealExplosion_struct\\Charge2.mdx"
string rve="weapon"
integer array ree
string rxe="Abilities\\Spells\\Items\\StaffOfPurification\\PurificationCaster.mdl"
string roe="chest"
string rre="Abilities\\Spells\\Human\\MarkOfChaos\\MarkOfChaosDone.mdl"
string rie="chest"
integer rae=40
integer rne=$F
string rVe="Abilities\\Spells\\Items\\StaffOfPurification\\PurificationTarget.mdl"
string rEe="chest"
integer rXe
string rOe="<IceArrows>"
integer rRe
integer rIe
integer rAe
string rNe="Abilities\\Spells\\Undead\\FrostNova\\FrostNovaTarget.mdl"
string rbe="origin"
integer rBe=3
integer rce=6
integer rCe=25
integer rde
integer rDe
string rfe="<LightningShield>"
real rFe
integer rge=20
real rGe=.5
integer rhe
integer rHe
real array rje
integer array rJe
integer array rke
integer rKe=20
integer rle
string rLe="<StructRevival>"
integer rme
integer rMe
string rpe="<LunarRestoration>"
integer rPe
integer rqe
integer rQe
integer array rse
integer array rSe
integer array rte
integer array rTe
integer array rue
boolean array rUe
integer rwe
integer array rWe
integer array rye
integer array rYe
string rze="Abilities\\Spells\\Orc\\Reincarnation\\ReincarnationTarget.mdl"
real array rZe
real array r_e
real r0e=4.5
integer r1e=1
real r2e=.3
integer r3e
string r4e="<AIPurge>"
integer r5e
integer r6e
integer r7e
string r8e="<Purge>"
integer r9e
real ive
integer array iee
integer ixe=6
integer array ioe
integer array ire
real iie=-.7
integer iae=3
integer ine=6
integer iVe
integer iEe
string iXe="<StructTarget>"
integer iOe
string iRe="<SoakingPoison>"
integer array iIe
integer array iAe
integer iNe
integer ibe
integer iBe
integer ice=2
integer iCe=4
integer ide
real iDe
integer ife=5
real iFe=.5
integer array ige
real array iGe
integer array ihe
integer iHe
string ije="<Stampede>"
integer iJe
real ike
real iKe=.2
real ile=.035
real iLe
integer ime=500
integer iMe=300
integer ipe=$514
integer iPe
real iqe
constant real iQe=(2*1.)*1./ 32
real ise
integer iSe
integer array ite
real array iTe
real array iue
integer array iUe
real array iwe
real array iWe
real array iye
real array iYe
string ize="Abilities\\Weapons\\AncientProtectorMissile\\AncientProtectorMissile.mdl"
real iZe=.5
string i_e="Abilities\\Weapons\\HydraliskImpact\\HydraliskImpact.mdl"
string i0e="chest"
integer i1e
string i2e="<AIStomp>"
integer i3e
integer i4e
integer i5e
string i6e="<Stomp>"
string i7e="Abilities\\Spells\\Orc\\WarStomp\\WarStompCaster.mdl"
integer i8e=2
integer i9e=25
integer ave
string aee="<Barrage>"
integer axe
real aoe
integer are='d'
real aie=.3
integer aae
integer ane
real array aVe
integer array aEe
integer aXe=50
integer aOe
string aRe="<AIBouncyBomb>"
integer aIe
integer aAe
string aNe="<BouncyBomb>"
integer abe
integer aBe
integer ace
integer aCe=3
constant real ade=(2*1.)*1./ 32
real aDe
integer afe=-$3E8
integer aFe=0
integer array age
integer aGe=U
integer array ahe
boolean array aHe
boolean array aje
integer aJe=1
integer array ake
integer array aKe
real array ale
real array aLe
real array ame
integer array aMe
integer array ape
real array aPe
real array aqe
real array aQe
integer ase=1
string aSe="Objects\\Spawnmodels\\Human\\FragmentationShards\\FragBoomSpawn.mdl"
integer ate='x'
integer aTe=40
integer aue
string aUe="<BurningOil>"
integer awe
real aWe
integer aye=26
real aYe=.75
integer aze
integer aZe
integer a_e=0
integer array a0e
integer a1e=U
integer array a2e
boolean array a3e
boolean array a4e
integer array a5e
integer array a6e
integer array a7e
integer array a8e
string a9e="Abilities\\Spells\\Orc\\LiquidFire\\Liquidfire.mdl"
real array nve
real array nee
integer nxe
integer noe=6
integer nre
integer nie
integer nae
string nne="<ChainLightning>"
integer nVe
integer nEe
integer nXe
integer nOe=0
integer array nRe
integer nIe=U
integer array nAe
boolean array nNe
boolean array nbe
real array nBe
integer array nce
real array nCe
integer nde='x'
real array nDe
real nfe=.1
integer array nFe
integer array nge
integer nGe=6
integer array nhe
integer array nHe
integer array nje
integer array nJe
integer nke=0
integer nKe=U
boolean array nle
constant real nLe=(2*1.)*1./ 32
string nme="Abilities\\Spells\\Items\\AIlb\\AIlbSpecialArt.mdl"
string nMe="chest"
integer npe
trigger nPe
integer nqe
string nQe="<StructId>"
integer nse
string nSe="<StructTable>"
integer nte
string nTe="<StructInteger>"
integer nue
string nUe="<StructData>"
integer nwe
string nWe="<StructWave>"
integer nye
string nYe="<Cleaver>"
boolean array nze
boolean array nZe
integer array n_e
integer array n0e
integer array n1e
integer array n2e
integer array n3e
real array n4e
integer n5e=700
integer array n6e
integer array n7e
integer array n8e
constant integer n9e=O+8192+563*8192
real Vve=.035
constant integer Vee=O+8192+564*8192
integer Vxe
real array Voe
real array Vre
integer Vie='}'
integer Vae
integer Vne=40
constant real VVe=(2*1.)*1./ 32
real array VEe
real array VXe
integer array VOe
real VRe
integer array VIe
integer array VAe
boolean array VNe
integer Vbe=0
integer VBe=U
boolean array Vce
integer VCe='}'
integer array Vde
real VDe
integer Vfe=650
integer VFe=600
integer Vge
integer VGe
string Vhe="<ColdResistance>"
integer VHe
string Vje="<DeathAxe>"
integer VJe
integer Vke=0
integer array VKe
integer Vle=U
integer array VLe
boolean array Vme
boolean array VMe
integer array Vpe
real array VPe
integer Vqe=70
integer array VQe
integer array Vse
integer VSe=1
integer Vte
integer VTe=3
string Vue="Abilities\\Weapons\\VengeanceMissile\\VengeanceMissile.mdx"
string VUe="origin"
integer Vwe
integer VWe
integer Vye
string VYe="<StructTarget>"
integer Vze
string VZe="<DrumRoll>"
integer V_e
integer V0e
integer V1e=0
integer array V2e
integer V3e=U
integer array V4e
boolean array V5e
boolean array V6e
integer array V7e
constant integer V8e=O+8192+557*8192
integer array V9e
integer array Eve
integer array Eee
integer Exe
integer Eoe
integer array Ere
integer Eie=F
integer array Eae
integer Ene
integer EVe
string EEe="<StructTarget>"
integer EXe
string EOe="<EnvenomedSpears>"
integer ERe
integer EIe
integer EAe=1
integer ENe=3
real Ebe
integer EBe=20
real Ece=.5
integer array ECe
real array Ede
integer array EDe
integer Efe
string EFe="<AIKnockout>"
integer Ege
integer EGe
integer Ehe
string EHe="<StructTarget>"
integer Eje
string EJe="<Knockout>"
boolean array Eke
boolean array EKe
integer array Ele
integer array ELe
integer array Eme
integer EMe=5
integer Epe=30
integer EPe=2
integer Eqe
string EQe="<AIMedipack>"
integer Ese=$96
integer ESe
string Ete="<Medipack>"
string ETe="Medipack_page\\Medipack_struct\\Medipack3.mdx"
string Eue="chest"
integer EUe
string Ewe="<MutingShout>"
integer EWe
integer Eye
integer EYe
string Eze="Abilities\\Spells\\NightElf\\BattleRoar\\RoarCaster.mdl"
integer EZe=4
real E_e=.05
integer E0e
string E1e="<Realplex>"
integer E2e
constant integer E3e=O+565
integer array E4e
integer array E5e
integer array E6e
boolean array E7e
integer array E8e
integer array E9e
integer Xve
integer Xee
integer Xxe='d'
integer Xoe=2
string Xre="Abilities\\Spells\\Orc\\MirrorImage\\MirrorImageCaster.mdl"
integer Xie=0
integer Xae=U
boolean array Xne
constant real XVe=Vj*4
integer XEe=0
integer XXe=U
boolean array XOe
integer array XRe
real array XIe
real array XAe
real array XNe
real Xbe=.5
integer XBe=$A
string Xce="Abilities\\Spells\\Orc\\MirrorImage\\MirrorImageDeathCaster.mdl"
integer XCe
integer Xde
string XDe="<SerpentWard>"
integer Xfe=0
integer array XFe
integer Xge=U
integer array XGe
boolean array Xhe
boolean array XHe
integer array Xje
real array XJe
real array Xke
integer XKe=3
integer Xle=20
integer XLe
integer Xme
string XMe="<SpiritWolves>"
integer Xpe
constant integer XPe=O+566
integer array Xqe
integer array XQe
integer array Xse
integer array XSe
integer array Xte
boolean array XTe
integer Xue=2
integer XUe=0
integer Xwe=U
boolean array XWe
integer Xye=70
integer XYe=40
integer Xze
string XZe="<Stormbolt>"
boolean array X_e
boolean array X0e
integer array X1e
integer array X2e
integer X3e=3
integer X4e='d'
integer X5e
integer X6e
integer X7e
string X8e="<SummonMinions>"
integer X9e
real Ove
integer Oee=6
integer array Oxe
integer array Ooe
integer Ore=500
integer Oie=2
real array Oae
integer array One
integer array OVe
constant integer OEe=$F2
constant integer OXe=O+8192+OEe*8192
constant integer OOe=$F4
constant integer ORe=O+8192+OOe*8192
integer OIe
integer OAe=20
integer ONe=0
integer array Obe
integer OBe=U
integer array Oce
boolean array OCe
boolean array Ode
constant integer ODe=$F0
constant integer Ofe=O+8192+ODe*8192
integer OFe=1
integer Oge=1
integer OGe
integer Ohe
string OHe="<StructMissile>"
integer Oje
string OJe="<BatSwarm>"
integer array Oke
integer array OKe
integer array Ole
integer array OLe
integer array Ome
integer OMe
integer Ope
integer OPe
integer Oqe=0
integer array OQe
integer Ose=U
integer array OSe
boolean array Ote
boolean array OTe
integer array Oue
real array OUe
real array Owe
integer array OWe
string Oye="Abilities\\Weapons\\LocustMissile\\LocustMissile.mdl"
string OYe="chest"
integer Oze
string OZe="<HawkEye>"
integer array O_e
real array O0e
integer array O1e
integer array O2e
integer array O3e
integer O4e
integer O5e
integer O6e
integer O7e
integer O8e=0
integer array O9e
integer Rve=U
integer array Ree
boolean array Rxe
boolean array Roe
real array Rre
integer Rie
integer Rae
string Rne="Abilities\\Spells\\Human\\Flare\\FlareCaster.mdl"
string RVe="HawkEye_page\\HawkEye_struct\\area.mdx"
integer REe
integer array RXe
real array ROe
integer RRe
string RIe="<StructBuff>"
integer array RAe
real array RNe
integer Rbe
string RBe="<MagicBottle>"
integer Rce=0
integer array RCe
integer Rde=U
integer array RDe
boolean array Rfe
boolean array RFe
integer array Rge
integer array RGe
integer array Rhe
string RHe="Abilities\\Spells\\Items\\AIil\\AIilTarget.mdl"
string Rje="origin"
integer array RJe
integer array Rke
integer RKe
string Rle="<StructAir>"
integer RLe
string Rme="<RedwoodValkyrie>"
integer RMe
integer array Rpe
real array RPe
integer array Rqe
integer array RQe
integer Rse
integer RSe
integer array Rte
integer array RTe
string Rue="Abilities\\Spells\\Other\\Incinerate\\IncinerateBuff.mdl"
string RUe="weapon"
boolean array Rwe
boolean array RWe
integer array Rye
string RYe="Abilities\\Spells\\Other\\BreathOfFire\\BreathOfFireDamage.mdl"
string Rze="origin"
integer RZe
integer R_e
integer R0e=1
integer R1e=$5DC
integer R2e=0
integer array R3e
integer R4e=U
integer array R5e
boolean array R6e
boolean array R7e
real array R8e
real array R9e
real array Ive
real array Iee
string Ixe="Abilities\\Spells\\Other\\BreathOfFire\\BreathOfFireDamage.mdl"
string Ioe="origin"
integer Ire=3
integer Iie=8
integer Iae
string Ine="<SapphireblueDagger>"
integer array IVe
integer array IEe
integer array IXe
integer array IOe
integer IRe
integer IIe
integer IAe
integer INe
integer Ibe
real array IBe
string Ice="Abilities\\Spells\\NightElf\\Blink\\BlinkCaster.mdl"
constant real ICe=$80
string Ide="Abilities\\Spells\\NightElf\\Blink\\BlinkTarget.mdl"
integer array IDe
integer array Ife
integer array IFe
integer array Ige
integer array IGe
integer Ihe
integer IHe
string Ije="<SilentBoots>"
integer IJe
integer Ike
integer array IKe
integer array Ile
integer array ILe
integer Ime=$A
integer array IMe
integer array Ipe
integer array IPe
boolean array Iqe
ubersplat array IQe
integer array Ise
integer array ISe
boolean array Ite
real array ITe
real array Iue
real array IUe
real array Iwe
real array IWe
real array Iye
integer array IYe
boolean array Ize
boolean array IZe
constant real I_e=(2*1.)*1./ 32
integer I0e=0
integer I1e=U
boolean array I2e
real array I3e
real array I4e
real array I5e
real array I6e
integer array I7e
integer I8e=0
integer I9e=U
boolean array Ave
constant integer Aee=$E0
constant integer Axe=O+8192+Aee*8192
string Aoe="Abilities\\Spells\\Items\\AIvi\\AIviTarget.mdl"
string Are="origin"
integer array Aie
integer array Aae
real array Ane
integer array AVe
integer array AEe
integer AXe
integer AOe
string ARe="<StoneShield>"
integer AIe
integer AAe
real array ANe
real array Abe
constant real ABe=(2*1.)*1./ 32
integer array Ace
real array ACe
real array Ade
constant real ADe=-500.
integer array Afe
real array AFe
integer array Age
integer array AGe
integer Ahe=$A
integer array AHe
integer array Aje
string AJe="Abilities\\Weapons\\ChimaeraLightningMissile\\ChimaeraLightningMissile.mdl"
integer Ake=32
string AKe="Abilities\\Weapons\\WingedSerpentMissile\\WingedSerpentMissile.mdl"
string Ale="chest"
integer ALe
string Ame="<TaintedLeaf>"
integer array AMe
integer array Ape
integer array APe
integer array Aqe
real array AQe
integer array Ase
integer array ASe
integer Ate
integer ATe
integer Aue
integer AUe
integer Awe
integer AWe
real Aye
real AYe
integer array Aze
integer array AZe
integer array A_e
integer array A0e
real A1e=.75
real array A2e
string A3e="TaintedLeaf_page\\TaintedLeaf_struct\\HealFinal.mdx"
real A4e=.7
integer array A5e
real array A6e
integer array A7e
integer array A8e
integer A9e
string Nve="<StructCharge>"
integer Nee
integer Nxe
integer Noe
integer Nre
integer Nie
string Nae="<StructPort>"
integer Nne
integer array NVe
integer NEe
string NXe="<VioletEarring>"
string NOe="Abilities\\Spells\\Human\\Invisibility\\InvisibilityTarget.mdl"
string NRe="chest"
integer NIe=0
integer array NAe
integer NNe=U
integer array Nbe
boolean array NBe
boolean array Nce
integer array NCe
integer Nde
string NDe="Abilities\\Spells\\Undead\\Sleep\\SleepSpecialArt.mdl"
string Nfe="origin"
integer NFe
boolean array Nge
integer array NGe
integer array Nhe
real array NHe
integer Nje
string NJe="<StructTarget>"
integer Nke
integer NKe
integer array Nle
integer NLe
string Nme="<Vomit>"
integer NMe
integer Npe
integer array NPe
integer Nqe
integer NQe=0
integer array Nse
integer NSe=U
integer array Nte
boolean array NTe
boolean array Nue
integer array NUe
integer array Nwe
real array NWe
integer array Nye
integer array NYe
real array Nze
real array NZe
integer array N_e
real N0e=.5
real array N1e
integer array N2e
integer array N3e
integer N4e
integer N5e
string N6e="<StructTarget>"
integer N7e
integer N8e
integer array N9e
integer bve
string bee="<WhiteStaff>"
boolean array bxe
integer array boe
integer array bre
integer array bie
real array bae
real array bne
integer array bVe
boolean array bEe
integer bXe=1
real bOe=.25
integer array bRe
integer bIe
string bAe="<StructKnockback>"
integer bNe
integer bbe
integer array bBe
integer bce
integer array bCe
integer array bde
real array bDe
integer bfe
string bFe="<Barrier>"
integer bge=$96
real bGe=.36*b6v
string bhe="Abilities\\Spells\\Human\\Avatar\\AvatarCaster.mdl"
string bHe="overhead"
integer bje=260
real bJe=.4
integer bke
integer bKe
integer array ble
integer array bLe
integer bme=80
integer array bMe
integer array bpe
integer bPe
string bqe="<StructWave>"
integer bQe
string bse="<Blizzard>"
integer bSe
integer bte
integer bTe
integer array bue
integer array bUe
integer array bwe
real array bWe
real array bye
real bYe=.75
integer bze=0
integer array bZe
integer b_e=U
integer array b0e
boolean array b1e
boolean array b2e
real array b3e
integer array b4e
real array b5e
real array b6e
real array b7e
string b8e="Abilities\\Spells\\Human\\Blizzard\\BlizzardTarget.mdl"
real b9e=.8
integer Bve
integer Bee
integer array Bxe
integer Boe
integer Bre
string Bie="<StructBuff>"
integer Bae
integer array Bne
integer array BVe
integer BEe
integer BXe
string BOe="<ChillyBreath>"
integer BRe
integer BIe
real array BAe
integer array BNe
real array Bbe
integer array BBe
real array Bce
real array BCe
real array Bde
integer array BDe
real array Bfe
integer array BFe
integer array Bge
integer array BGe
real array Bhe
real array BHe
constant real Bje=(2*1.)*1./ 32
integer BJe=0
integer Bke=300
integer BKe=0
integer array Ble
integer BLe=U
integer array Bme
boolean array BMe
boolean array Bpe
integer array BPe
integer array Bqe
integer array BQe
integer array Bse
integer array BSe
integer array Bte
integer array BTe
integer array Bue
integer array BUe
integer array Bwe
boolean array BWe
integer Bye=0
integer BYe=U
boolean array Bze
integer array BZe
integer array B_e
real B0e=.5
real array B1e
integer B2e
string B3e="<ElementalSpellToHero>"
integer B4e
constant integer B5e=O+569
integer array B6e
integer B7e
integer B8e=0
integer array B9e
integer cve=U
integer array cee
boolean array cxe
boolean array coe
integer cre
integer cie
integer cae
integer cne
integer cVe
integer cEe
integer cXe
string cOe="<StructShot>"
integer array cRe
integer array cIe
integer cAe
integer array cNe
integer cbe
string cBe="<Fireburst>"
integer cce
integer cCe=0
integer array cde
integer cDe=U
integer array cfe
boolean array cFe
boolean array cge
integer array cGe
boolean array che
integer array cHe
integer array cje
integer array cJe
integer array cke
integer array cKe
integer array cle
integer array cLe
real array cme
real array cMe
string cpe="Abilities\\Spells\\Human\\Polymorph\\PolyMorphTarget.mdl"
string cPe="origin"
real cqe=.75
constant integer cQe=O+8192+570*8192
real cse=.45
integer cSe=0
integer array cte
integer cTe=U
integer array cue
boolean array cUe
boolean array cwe
integer array cWe
integer cye
integer cYe
integer cze=1
integer cZe=2
integer c_e
integer c0e
real array c1e
real array c2e
integer c3e
integer c4e=50
integer c5e
integer array c6e
real array c7e
integer array c8e
integer array c9e
integer array Cve
real array Cee
integer array Cxe
integer Coe
string Cre="<FlameTongue>"
integer Cie
integer Cae
integer Cne=0
integer array CVe
integer CEe=U
integer array CXe
boolean array COe
boolean array CRe
real array CIe
real array CAe
integer array CNe
real array Cbe
integer CBe=1
real array Cce
real array CCe
real array Cde
real array CDe
real array Cfe
real array CFe
real array Cge
integer array CGe
real array Che
real array CHe
real array Cje
integer array CJe
real array Cke
integer array CKe
real array Cle
real array CLe
real array Cme
real array CMe
integer array Cpe
real CPe=.2
string Cqe="Abilities\\Spells\\Other\\Incinerate\\FireLordDeathExplode.mdl"
string CQe="Abilities\\Spells\\Human\\FlameStrike\\FlameStrikeEmbers.mdl"
real array Cse
real array CSe
integer array Cte
integer array CTe
integer Cue
integer CUe
string Cwe="<StructTarget>"
integer array CWe
integer Cye
string CYe="<StructExplosion>"
integer Cze
integer array CZe
integer array C_e
integer array C0e
integer C1e
string C2e="<FrozenStar>"
integer C3e
integer C4e
real C5e=.1
integer C6e=$A
real C7e=.25*b6v
integer C8e=0
integer array C9e
integer dve=U
integer array dee
boolean array dxe
boolean array doe
real array dre
real array die
integer array dae
real array dne
integer array dVe
real array dEe
real array dXe
real array dOe
real array dRe
real array dIe
real array dAe
real array dNe
integer array dbe
integer array dBe
integer array dce
real array dCe
real array dde
real array dDe
real array dfe
integer array dFe
constant real dge=(2*1.)*1./ 32
string dGe="Abilities\\Spells\\Undead\\FreezingBreath\\FreezingBreathMissile.mdl"
real array dhe
string dHe="Units\\NightElf\\Wisp\\WispExplode.mdl"
integer dje
integer dJe
integer dke=400
integer dKe=4
integer array dle
integer dLe
string dme="<StructSword>"
real array dMe
real array dpe
real array dPe
integer array dqe
integer dQe
integer array dse
integer array dSe
integer dte
string dTe="<GhostSword>"
integer due
integer dUe
integer array dwe
integer dWe=F
integer array dye
integer dYe
constant real dze=(1*1.)*1./ 32
integer array dZe
integer d_e=F
real array d0e
real array d1e
real d2e=1.5
constant integer d3e=O+8192+571*8192
real d4e=2.5
integer d5e
integer d6e
integer d7e
integer array d8e
integer d9e
real array Dve
string Dee="Abilities\\Spells\\Human\\Feedback\\ArcaneTowerAttack.mdl"
string Dxe="origin"
real array Doe
integer Dre
boolean array Die
integer array Dae
string Dne="Abilities\\Spells\\NightElf\\Blink\\BlinkCaster.mdl"
string DVe="weapon"
integer array DEe
integer DXe=F
integer array DOe
string DRe="Abilities\\Spells\\NightElf\\Blink\\BlinkCaster.mdl"
string DIe="weapon"
integer DAe
integer DNe
integer array Dbe
real array DBe
integer Dce
integer DCe
string Dde="<StructTarget>"
integer DDe
string Dfe="<HackNSlay>"
integer DFe
integer Dge
integer array DGe
integer array Dhe
integer array DHe
integer Dje
integer DJe
integer Dke
integer array DKe
real array Dle
integer DLe
integer Dme
string DMe="<IceBlock>"
integer Dpe
string DPe="<IceShock>"
integer Dqe
integer array DQe
integer array Dse
integer array DSe
integer array Dte
integer array DTe
integer array Due
integer DUe
integer Dwe
integer DWe
string Dye="Abilities\\Spells\\Undead\\FrostNova\\FrostNovaTarget.mdl"
integer array DYe
integer Dze
integer DZe
string D_e="<StructCrit>"
integer array D0e
integer array D1e
integer D2e
string D3e="<InnerForce>"
integer D4e
integer D5e
integer D6e
integer D7e=0
integer array D8e
integer D9e=U
integer array fve
boolean array fee
boolean array fxe
boolean array foe
integer array fre
real array fie
integer array fae
real array fne
real array fVe
integer array fEe
integer array fXe
integer array fOe
real fRe=1.25
string fIe="Abilities\\Spells\\Human\\MarkOfChaos\\MarkOfChaosTarget.mdl"
string fAe="origin"
real fNe=.75
string fbe="Abilities\\Spells\\Orc\\WarStomp\\WarStompCaster.mdl"
string fBe="origin"
integer fce=600
integer fCe=-$4B0
real fde=.5
integer fDe=3
integer array ffe
integer array fFe
integer array fge
integer fGe
integer fhe
integer fHe
string fje="<Monolith>"
integer fJe
integer fke
integer fKe=0
integer array fle
integer fLe=U
integer array fme
boolean array fMe
boolean array fpe
integer array fPe
real array fqe
integer array fQe
integer array fse
integer array fSe
real array fte
real array fTe
integer array fue
integer fUe=90
integer fwe
constant real fWe=(2*1.)*1./ 32
string fye="Monolith_page\\Monolith_struct\\TargetDust.mdx"
string fYe="chest"
integer fze
real array fZe
integer f_e
string f0e="<StructTarget>"
integer f1e
integer f2e
string f3e="<SacredAura>"
integer f4e
integer array f5e
integer array f6e
integer array f7e
integer f8e
integer f9e
integer Fve
integer array Fee
integer array Fxe
integer array Foe
integer Fre
string Fie="<StructBuff>"
integer array Fae
integer array Fne
integer FVe
string FEe="<Severance>"
integer FXe
integer FOe
integer FRe=0
integer array FIe
integer FAe=U
integer array FNe
boolean array Fbe
boolean array FBe
real array Fce
integer array FCe
real array Fde
integer array FDe
integer array Ffe
integer array FFe
integer array Fge
integer array FGe
real Fhe=.2
trigger FHe
integer array Fje
integer array FJe
integer array Fke
integer array FKe
integer Fle
string FLe="<StructParticle>"
integer Fme
integer array FMe
integer array Fpe
integer array FPe
integer array Fqe
integer FQe
string Fse="<SnowySphere>"
integer FSe=0
integer array Fte
integer FTe=U
integer array Fue
boolean array FUe
boolean array Fwe
integer array FWe
real array Fye
integer array FYe
integer array Fze
integer array FZe
real array F_e
real array F0e
real array F1e
real array F2e
integer F3e=-50
real array F4e
integer array F5e
integer array F6e
real array F7e
real array F8e
real array F9e
real array gve
integer gee=0
integer array gxe
integer goe=U
integer array gre
boolean array gie
boolean array gae
real array gne
integer array gVe
real array gEe
integer array gXe
integer array gOe
integer array gRe
real array gIe
real array gAe
real array gNe
integer array gbe
constant real gBe=(2*1.)*1./ 32
integer gce
integer gCe
real array gde
constant real gDe=(2*1.)*1./ 32
real array gfe
real array gFe
real array gge
integer array gGe
integer ghe
string gHe="<Thunderstrike>"
integer gje
integer gJe
integer gke=0
integer array gKe
integer gle=U
integer array gLe
boolean array gme
boolean array gMe
real array gpe
integer array gPe
integer array gqe
real array gQe
integer array gse
integer array gSe
real array gte
real array gTe
real array gue
integer array gUe
integer gwe=$3E8
integer gWe=3
real gye=.5
string gYe="Thunderstrike_page\\Thunderstrike_struct\\Bolt.mdx"
integer array gze
integer array gZe
integer array g_e
integer g0e
string g1e="<TwinWolves>"
integer g2e='d'
real g3e=b6v*1./ 3
integer g4e=50
integer g5e
real g6e=.5
integer g7e='}'
integer g8e
integer g9e
integer Gve
integer array Gee
integer Gxe
integer Goe
string Gre="<Brotherhood>"
integer Gie
integer array Gae
real Gne=.5
integer GVe
integer array GEe
integer array GXe
integer GOe
string GRe="<Carnivore>"
integer array GIe
integer array GAe
integer array GNe
integer Gbe
string GBe="<WolfsMark>"
integer Gce
string GCe="<StructEffects>"
integer Gde
integer array GDe
integer array Gfe
integer array GFe
real array Gge
integer GGe
string Ghe="<VividMeteor>"
integer GHe
integer Gje
integer GJe
integer Gke=0
integer array GKe
integer Gle=U
integer array GLe
boolean array Gme
boolean array GMe
real array Gpe
integer array GPe
real array Gqe
real array GQe
integer array Gse
real array GSe
real array Gte
integer GTe=0
real array Gue
real array GUe
real Gwe
real array GWe
integer Gye=$96
real array GYe
real array Gze
integer GZe=3
real G_e
constant integer G0e=O+8192+573*8192
constant integer G1e=O+8192+572*8192
real G2e=1.5
integer G3e=F
integer array G4e
integer array G5e
integer G6e
constant real G7e=(1*1.)*1./ 32
real G8e
real G9e
integer hve=3
real hee=1.43
integer hxe
integer array hoe
integer hre
integer hie
string hae="<WarmthMagnetism>"
integer hne
integer hVe
constant integer hEe=O+8192+574*8192
integer array hXe
real array hOe
real array hRe
real hIe
integer hAe=300
constant real hNe=(2*1.)*1./ 32
integer hbe
real array hBe
integer array hce
integer array hCe
integer array hde
integer array hDe
string hfe="Abilities\\Spells\\Undead\\Possession\\PossessionMissile.mdl"
string hFe="origin"
real hge=.5
integer hGe='x'
integer hhe
string hHe="<StructTarget>"
integer hje
integer hJe
string hke="<Amaterasu>"
integer hKe
integer array hle
integer array hLe
integer hme
integer hMe
integer hpe
real array hPe
real array hqe
real array hQe
integer array hse
real array hSe
real array hte
real hTe=.35
integer hue=1
real hUe=.5
integer hwe
integer hWe
real array hye
integer array hYe
real array hze
integer hZe
string h_e="<StructTarget>"
real array h0e
integer array h1e
integer array h2e
integer h3e
integer h4e
string h5e="<ArcaneAttractor>"
integer h6e
integer h7e
integer array h8e
integer array h9e
integer array Hve
integer Hee
integer Hxe=1
integer array Hoe
string Hre="Abilities\\Spells\\Human\\Polymorph\\PolyMorphTarget.mdl"
string Hie="origin"
integer Hae=350
string Hne="ArcaneAttractor_page\\ArcaneAttractor_struct\\Area3.mdx"
real HVe=.25
integer array HEe
string HXe="Abilities\\Spells\\Undead\\OrbOfDeath\\AnnihilationMissile.mdl"
string HOe="origin"
integer array HRe
integer array HIe
integer array HAe
integer array HNe
integer array Hbe
integer array HBe
integer Hce
integer HCe
string Hde="<ArcticWolf>"
integer HDe
integer Hfe
real HFe
integer Hge=400
constant real HGe=(1*1.)*1./ 32
integer Hhe
integer HHe=90
integer Hje=0
integer array HJe
integer Hke=U
integer array HKe
boolean array Hle
boolean array HLe
integer Hme=50
real array HMe
real array Hpe
integer array HPe
integer array Hqe
integer array HQe
string Hse="ArcticWolf_page\\ArcticWolf_struct\\IceVortex.mdx"
string HSe="origin"
integer array Hte
real array HTe
integer array Hue
integer array HUe
real array Hwe
integer array HWe
real array Hye
integer array HYe
real array Hze
integer array HZe
integer array H_e
real array H0e
real array H1e
real H2e=.5
string H3e="ArcticWolf_page\\ArcticWolf_struct\\Explosion.mdx"
integer H4e
string H5e="<StructVisuals>"
integer H6e
integer H7e
string H8e="<BoulderCrash>"
integer array H9e
integer array jve
integer jee
integer jxe
integer joe
integer array jre
integer array jie
real jae=.25
real array jne
integer jVe=1
real jEe=.5
integer array jXe
integer array jOe
integer array jRe
real array jIe
real array jAe
real array jNe
boolean array jbe
boolean array jBe
constant real jce=(2*1.)*1./ 32
integer array jCe
real array jde
real array jDe
real jfe=.25
real jFe=.5
integer jge
string jGe="<Conflagration>"
integer jhe
integer jHe
integer jje
real array jJe
integer array jke
integer array jKe
real array jle
real array jLe
integer jme
integer jMe
integer jpe
integer jPe
integer jqe=0
integer array jQe
integer jse=U
integer array jSe
boolean array jte
boolean array jTe
real array jue
integer array jUe
real array jwe
integer array jWe
real array jye
real array jYe
real array jze
integer array jZe
real array j_e
integer array j0e
integer array j1e
real array j2e
real array j3e
integer array j4e
integer array j5e
integer array j6e
integer array j7e
integer array j8e
integer array j9e
integer array Jve
integer array Jee
integer Jxe=0
integer Joe=300
constant real Jre=(2*1.)*1./ 32
real array Jie
integer Jae
integer Jne
string JVe="<StructRelocate>"
integer array JEe
integer array JXe
integer array JOe
integer array JRe
integer JIe
integer JAe
string JNe="<Cyclone>"
integer Jbe
integer array JBe
constant integer Jce=O+8192+576*8192
integer JCe
integer Jde
integer JDe=300
integer Jfe=0
integer array JFe
integer Jge=U
integer array JGe
boolean array Jhe
boolean array JHe
integer array Jje
real array JJe
integer array Jke
integer array JKe
integer array Jle
real array JLe
real array Jme
integer array JMe
integer Jpe=$80
integer JPe=w
integer Jqe
constant real JQe=(2*1.)*1./ 32
integer Jse
integer JSe
string Jte="<StructTarget>"
integer JTe
integer array Jue
integer JUe
string Jwe="<WindDance>"
integer JWe
integer Jye
string JYe="<DeprivingShock>"
integer Jze
integer array JZe
real array J_e
integer array J0e
integer array J1e
real array J2e
integer J3e
integer J4e
integer J5e
constant integer J6e=O+8192+578*8192
boolean array J7e
string J8e="Abilities\\Spells\\Undead\\AnimateDead\\AnimateDeadTarget.mdl"
string J9e="origin"
string kve="Objects\\Spawnmodels\\Undead\\UndeadLargeDeathExplode\\UndeadLargeDeathExplode.mdl"
integer array kee
real array kxe
real koe=.1
real array kre
real array kie
integer array kae
integer array kne
integer array kVe
real kEe=.5
string kXe="Abilities\\Weapons\\LichMissile\\LichMissile.mdx"
string kOe="chest"
integer kRe
integer array kIe
integer array kAe
integer array kNe
integer kbe
string kBe="<StructBigBoom>"
integer kce
integer kCe
integer array kde
integer array kDe
real array kfe
integer kFe
string kge="<StructFireBuff>"
integer array kGe
integer khe
integer kHe
string kje="<StructIceBuff>"
integer kJe
integer kke
real array kKe
integer array kle
integer kLe
string kme="<Doppelganger>"
integer kMe
integer kpe
integer kPe
constant integer kqe=O+580
integer array kQe
integer array kse
real array kSe
real array kte
real array kTe
integer array kue
real array kUe
real array kwe
real array kWe
real array kye
integer kYe=$C8
string kze="Abilities\\Spells\\Orc\\MirrorImage\\MirrorImageDeathCaster.mdl"
string kZe="Abilities\\Spells\\Human\\Polymorph\\PolyMorphDoneGround.mdl"
integer k_e
integer k0e
string k1e="Objects\\Spawnmodels\\Other\\ToonBoom\\ToonBoom.mdl"
string k2e="Doppelganger_page\\Doppelganger_struct\\BigBoom\\BigBoom.mdx"
integer k3e
integer array k4e
integer k5e
integer array k6e
real array k7e
integer array k8e
integer array k9e
real array Kve
real array Kee
real array Kxe
integer array Koe
integer Kre
string Kie="<EbonyShot>"
integer Kae
integer Kne
integer array KVe
integer array KEe
integer array KXe
integer array KOe
boolean array KRe
integer KIe
integer array KAe
string KNe="Abilities\\Spells\\Other\\Incinerate\\IncinerateBuff.mdl"
string Kbe="weapon"
integer KBe=0
integer Kce=U
boolean array KCe
real array Kde
string KDe="Abilities\\Spells\\Other\\BreathOfFire\\BreathOfFireDamage.mdl"
string Kfe="origin"
integer KFe=$3E8
string Kge="Abilities\\Spells\\Undead\\CarrionSwarm\\CarrionSwarmDamage.mdl"
string KGe="chest"
integer Khe
real array KHe
integer array Kje
integer KJe
string Kke="<StructBuff>"
integer KKe
string Kle="<EmphaticBite>"
integer KLe
integer array Kme
integer array KMe
integer array Kpe
integer array KPe
integer Kqe
integer KQe
real Kse
integer KSe=$3E8
constant real Kte=(1*1.)*1./ 32
real KTe=.2
integer array Kue
integer array KUe
real array Kwe
real array KWe
integer array Kye
integer array KYe
real array Kze
real array KZe
integer K_e='x'
string K0e="Abilities\\Spells\\Undead\\Possession\\PossessionMissile.mdl"
string K1e="origin"
integer array K2e
integer array K3e
integer array K4e
integer array K5e
integer K6e
string K7e="<EnchantedArrow>"
integer K8e
integer K9e
integer lve
integer array lee
integer array lxe
integer array loe
integer array lre
integer array lie
boolean array lae
integer lne
integer lVe=0
integer lEe=U
boolean array lXe
real array lOe
integer array lRe
real array lIe
integer array lAe
real array lNe
real array lbe
string lBe="Objects\\Spawnmodels\\NightElf\\NECancelDeath\\NECancelDeath.mdl"
integer lce=64
string lCe="EnchantedArrow_page\\EnchantedArrow_struct\\arrowEffect.mdx"
string lde="origin"
string lDe="EnchantedArrow_page\\EnchantedArrow_struct\\arrowEffect2.mdx"
string lfe="origin"
integer array lFe
constant real lge=(2*1.)*1./ 32
integer lGe
integer lhe
string lHe="<StructRevert>"
integer lje
integer lJe
string lke="<FairyShape>"
integer lKe
integer lle
integer lLe
real array lme
real array lMe
integer array lpe
integer array lPe
integer array lqe
real array lQe
integer array lse
integer lSe
integer lte
integer lTe
constant integer lue=O+8192+582*8192
integer lUe
real array lwe
real array lWe
real array lye
integer array lYe
integer array lze
integer array lZe
integer array l_e
integer l0e=$7FFFFFFD
string l1e="Abilities\\Spells\\NightElf\\ManaBurn\\ManaBurnTarget.mdl"
string l2e="origin"
integer l3e
real l4e
real l5e
integer array l6e
string l7e="FairyShape_page\\FairyShape_struct\\Revert\\sourceEffect.mdx"
real array l8e
real array l9e
string Lve="Abilities\\Spells\\Undead\\Possession\\PossessionMissile.mdl"
string Lee="Abilities\\Spells\\Undead\\DarkRitual\\DarkRitualTarget.mdl"
integer array Lxe
integer array Loe
integer Lre
string Lie="<StructTarget>"
integer Lae
integer Lne
integer LVe
integer LEe
string LXe="<FairysTears>"
integer LOe
integer LRe
integer LIe
real array LAe
real array LNe
integer Lbe=1
integer array LBe
integer array Lce
integer array LCe
real Lde=.25
integer LDe=2
integer array Lfe
real array LFe
integer array Lge
integer array LGe
real Lhe=.9
integer LHe
integer array Lje
integer LJe
string Lke="<FountainOfLifeAndDeath>"
integer LKe=0
integer array Lle
integer LLe=U
integer array Lme
boolean array LMe
boolean array Lpe
integer LPe=400
integer Lqe=3
integer LQe
integer Lse
integer LSe
real array Lte
integer LTe
string Lue="<StructTarget>"
integer LUe
string Lwe="<DecayAura>"
integer array LWe
integer Lye
integer LYe
integer array Lze
integer array LZe
real array L_e
real array L0e
integer array L1e
integer array L2e
integer L3e
integer L4e
real L5e=.25
integer L6e
string L7e="<AIPalingenesis>"
constant integer L8e=O+8192+21*8192
integer L9e
integer array mve
integer mee
string mxe="<Palingenesis>"
integer moe
integer mre
integer array mie
integer array mae
integer array mne
string mVe="Abilities\\Spells\\Undead\\AnimateDead\\AnimateDeadTarget.mdl"
string mEe="origin"
string mXe="Objects\\Spawnmodels\\Undead\\UndeadLargeDeathExplode\\UndeadLargeDeathExplode.mdl"
real array mOe
integer mRe
string mIe="<StructRegen>"
integer mAe
integer mNe
integer mbe
integer mBe
string mce="<GarmentsOfTheSalamander>"
integer array mCe
integer mde
integer array mDe
string mfe="Abilities\\Spells\\Orc\\FeralSpirit\\feralspiritdone.mdl"
string mFe="chest"
integer mge
integer mGe
integer array mhe
integer array mHe
real mje=.5
integer mJe
string mke="<StructId>"
integer mKe
string mle="<StructTable>"
integer mLe
string mme="<StructInteger>"
integer mMe
string mpe="<StructData>"
integer mPe
integer mqe
string mQe="<StructPrison>"
integer array mse
real array mSe
integer array mte
integer array mTe
integer mue
integer mUe
string mwe="<StructBuff>"
integer mWe
string mye="<StructRoots>"
integer mYe
string mze="<StructNova>"
integer mZe
integer array m_e
integer array m0e
integer array m1e
integer array m2e
integer m3e
string m4e="<HandOfNature>"
integer m5e
integer m6e
integer m7e
constant integer m8e=O+586
boolean array m9e
integer array Mve
integer array Mee
integer array Mxe
constant integer Moe=O+8192+588*8192
integer array Mre
integer array Mie
integer array Mae
integer array Mne
real array MVe
integer array MEe
integer array MXe
boolean array MOe
integer MRe=0
integer MIe=U
boolean array MAe
constant integer MNe=O+8192+584*8192
integer array Mbe
string MBe="Objects\\Spawnmodels\\NightElf\\EntBirthTarget\\EntBirthTarget.mdl"
integer Mce
integer MCe=0
integer array Mde
integer MDe=U
integer array Mfe
boolean array MFe
boolean array Mge
integer array MGe
integer array Mhe
integer array MHe
integer array Mje
integer array MJe
integer array Mke
real MKe=.05
string Mle="Abilities\\Weapons\\TreantMissile\\TreantMissile.mdl"
integer MLe=1
real Mme=.125
real array MMe
real array Mpe
real array MPe
real array Mqe
real array MQe
real Mse=.5
integer array MSe
real array Mte
integer array MTe
integer array Mue
integer MUe
integer array Mwe
integer array MWe
integer Mye
string MYe="<StructTarget>"
integer Mze
string MZe="<SlowPoison>"
integer M_e
integer M0e
integer M1e=2
integer M2e=4
integer M3e
real M4e
integer M5e=5
real M6e=.5
integer array M7e
real array M8e
integer array M9e
integer pve
integer pee
integer pxe
string poe="<StructMine>"
integer array pre
integer array pie
integer pae
string pne="<StructSetMines>"
integer pVe
integer pEe
string pXe="<HopNDrop>"
integer pOe
real pRe
integer pIe=1
integer pAe
constant real pNe=(1*1.)*1./ 32
real pbe
real pBe
integer array pce
real array pCe
real pde
real array pDe
real array pfe
real pFe
real array pge
real pGe
integer phe
integer pHe=1
real pje
integer pJe=900
real pke
integer pKe=500
real ple
integer pLe=3
real array pme
real array pMe
integer array ppe
integer array pPe
real array pqe
integer array pQe
real array pse
integer pSe
integer pte=40
real pTe=.5
real pue=1.5
integer pUe
integer pwe
integer pWe=2
integer array pye
integer pYe
string pze="<StructCone>"
integer pZe
integer p_e
string p0e="<StructFuniculusUmbilicalis>"
integer p1e
integer array p2e
integer array p3e
integer array p4e
integer p5e
string p6e="<StructSummon>"
integer p7e
integer p8e
integer array p9e
integer array Pve
integer array Pee
integer Pxe
string Poe="<StructTarget>"
integer array Pre
integer array Pie
integer array Pae
integer Pne
integer PVe
string PEe="<Infection>"
integer PXe
integer array POe
integer PRe
real PIe
integer PAe=500
integer PNe=650
integer Pbe
real PBe
constant real Pce=(1*1.)*1./ 32
integer PCe
integer Pde
integer array PDe
constant integer Pfe=O+592
integer PFe
integer Pge
integer array PGe
integer array Phe
real array PHe
real array Pje
integer array PJe
real Pke=.5
integer PKe
real Ple=.25
constant integer PLe=O+8192+590*8192
integer array Pme
integer array PMe
integer array Ppe
integer PPe
string Pqe="<StructRestoration>"
integer PQe
integer Pse
integer PSe
integer array Pte
integer array PTe
integer array Pue
integer array PUe
integer array Pwe
integer PWe
integer Pye
string PYe="<KhakiRecovery>"
integer Pze
integer PZe
integer P_e=0
integer array P0e
integer P1e=U
integer array P2e
boolean array P3e
boolean array P4e
real array P5e
integer array P6e
integer array P7e
real array P8e
integer array P9e
integer array qve
integer array qee
integer array qxe
integer array qoe
string qre="Abilities\\Spells\\Other\\Drain\\DrainCaster.mdl"
string qie="origin"
real qae=.35
real qne=-.15
string qVe="KhakiRecovery_page\\KhakiRecovery_struct\\Vortex2.mdx"
string qEe="origin"
string qXe="KhakiRecovery_page\\KhakiRecovery_struct\\Target.mdx"
string qOe="origin"
integer qRe
string qIe="Abilities\\Spells\\Orc\\SpiritLink\\SpiritLinkZapTarget.mdl"
string qAe="overhead"
real array qNe
real array qbe
integer array qBe
integer array qce
integer qCe
string qde="<ManaColossus>"
integer qDe=75
integer qfe
integer qFe
real array qge
real array qGe
integer qhe
string qHe="<StructTarget>"
integer qje
integer qJe
string qke="<TheurgicVessel>"
integer qKe
integer array qle
integer array qLe
integer qme
integer qMe
integer array qpe
integer qPe
string qqe="<StructRevert>"
integer qQe
integer qse
integer qSe
integer qte
integer array qTe
integer array que
integer array qUe
integer array qwe
integer qWe
string qye="<ManaLaser>"
integer qYe
integer qze
integer qZe=90
integer q_e=0
integer array q0e
integer q1e=U
integer array q2e
boolean array q3e
boolean array q4e
integer q5e=50
real array q6e
real array q7e
integer array q8e
integer array q9e
integer array Qve
integer array Qee
integer array Qxe
integer array Qoe
integer array Qre
real array Qie
real array Qae
real array Qne
constant real QVe=(1*1.)*1./ 32
integer QEe=0
integer QXe=U
boolean array QOe
constant real QRe=(2*1.)*1./ 32
string QIe="Abilities\\Spells\\NightElf\\ManaBurn\\ManaBurnTarget.mdl"
string QAe="origin"
real array QNe
real Qbe
real QBe
integer Qce=5
integer array QCe
string Qde="ManaLaser_page\\ManaLaser_struct\\Revert\\SourceEffect.mdx"
real array QDe
real array Qfe
string QFe="Abilities\\Spells\\Undead\\Possession\\PossessionMissile.mdl"
string Qge="Abilities\\Spells\\Undead\\DarkRitual\\DarkRitualTarget.mdl"
integer QGe
integer Qhe
string QHe="<StructCharm>"
integer Qje
string QJe="<StructMissile>"
integer array Qke
integer array QKe
integer Qle
string QLe="<MassMimesis>"
integer Qme
integer QMe
integer array Qpe
integer array QPe
real array Qqe
real array QQe
string Qse="Abilities\\Spells\\Items\\AIil\\AIilTarget.mdl"
string QSe="Abilities\\Spells\\Items\\AIil\\AIilTarget.mdl"
string Qte="origin"
real QTe
real Que
real array QUe
integer array Qwe
integer array QWe
integer Qye=0
integer array QYe
integer Qze=U
integer array QZe
boolean array Q_e
boolean array Q0e
integer array Q1e
integer array Q2e
real array Q3e
real array Q4e
string Q5e="Abilities\\Spells\\NightElf\\Blink\\BlinkTarget.mdl"
string Q6e="Abilities\\Spells\\NightElf\\Blink\\BlinkCaster.mdl"
real array Q7e
integer array Q8e
integer array Q9e
real array sve
real array see
real array sxe
integer soe
integer sre
integer sie
string sae="<MountainKing>"
integer array sne
real sVe=.125
integer sEe
integer array sXe
real array sOe
integer sRe
string sIe="<Thunderbringer>"
integer sAe
integer sNe
string sbe="Abilities\\Weapons\\FarseerMissile\\FarseerMissile.mdx"
string sBe="weapon"
string sce="Abilities\\Spells\\Human\\ManaFlare\\ManaFlareBoltImpact.mdl"
string sCe="Abilities\\Spells\\Other\\Monsoon\\MonsoonBoltTarget.mdl"
integer sde
integer sDe
string sfe="<NegationWave>"
integer array sFe
integer array sge
real array sGe
real array she
integer sHe
integer sje
integer sJe
string ske="Abilities\\Spells\\Other\\Drain\\DrainCaster.mdl"
string sKe="origin"
integer sle=0
integer array sLe
integer sme=U
integer array sMe
boolean array spe
boolean array sPe
real array sqe
integer array sQe
real array sse
integer array sSe
integer array ste
integer array sTe
integer array sue
integer array sUe
integer array swe
real sWe=.35
string sye="Abilities\\Weapons\\Bolt\\BoltImpact.mdl"
string sYe="chest"
constant real sze=-1.
integer array sZe
integer s_e
string s0e="<StructEgg>"
integer array s1e
integer s2e
integer array s3e
integer s4e
integer array s5e
integer array s6e
integer array s7e
integer s8e
string s9e="<NurturingGrounds>"
integer Sve=0
integer array See
integer Sxe=U
integer array Soe
boolean array Sre
boolean array Sie
integer array Sae
real array Sne
integer array SVe
real array SEe
constant real SXe=(2*1.)*1./ 32
integer array SOe
real array SRe
integer array SIe
real array SAe
real array SNe
integer array Sbe
integer array SBe
constant integer Sce=$80
integer SCe
integer array Sde
integer array SDe
integer array Sfe
integer array SFe
real array Sge
integer array SGe
integer She
string SHe="<StructTarget>"
integer Sje
real array SJe
integer Ske
string SKe="<StructArrival>"
integer Sle
string SLe="<StructLeech>"
integer array Sme
integer SMe
integer Spe
string SPe="<PandaPaw>"
integer array Sqe
integer array SQe
integer Sse
real array SSe
integer array Ste
integer array STe
real array Sue
real array SUe
real array Swe
real array SWe
integer array Sye
integer array SYe
integer array Sze
real array SZe
real array S_e
integer array S0e
integer S1e=1
real S2e=.125
constant real S3e=(2*1.)*1./ 32
integer S4e=-75
real S5e=.5
integer S6e=5
string S7e="Abilities\\Spells\\Orc\\WarStomp\\WarStompCaster.mdl"
integer S8e=-'}'
integer S9e
integer tve
real tee=.65*b6v
integer txe=0
integer array toe
integer tre=U
integer array tie
boolean array tae
boolean array tne
real array tVe
integer array tEe
real array tXe
real array tOe
real array tRe
real array tIe
real array tAe
real array tNe
real array tbe
constant integer tBe=O+8192+594*8192
integer tce
constant integer tCe=O+8192+596*8192
integer array tde
integer tDe=F
integer array tfe
integer tFe
constant real tge=(2*1.)*1./ 32
integer array tGe
integer the=F
integer tHe=$A
string tje="Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl"
string tJe="origin"
integer array tke
integer array tKe
integer array tle
integer tLe
string tme="<StructWave>"
string tMe="<PurgingRain>"
integer tpe
integer tPe
integer array tqe
integer array tQe
integer array tse
real array tSe
real array tte
real tTe=.75
integer tue=0
integer array tUe
integer twe=U
integer array tWe
boolean array tye
boolean array tYe
real array tze
integer array tZe
real array t_e
real array t0e
real array t1e
string t2e="Abilities\\Spells\\NightElf\\Starfall\\StarfallTarget.mdx"
real t3e=.8
integer t4e
integer t5e
integer t6e
integer t7e
string t8e="<StructBlade>"
integer array t9e
real array Tve
integer array Tee
integer array Txe
integer Toe
string Tre="<RazorBladeDrawBack>"
integer Tie
integer array Tae
integer array Tne
constant integer TVe=O+598
integer TEe
integer TXe
integer TOe
integer TRe
string TIe="<StructVamp>"
integer array TAe
integer TNe
integer array Tbe
integer array TBe
integer Tce
integer TCe
string Tde="<RazorBlade>"
integer TDe
integer Tfe
integer TFe=0
integer array Tge
integer TGe=U
integer array The
boolean array THe
boolean array Tje
integer array TJe
real array Tke
integer array TKe
integer array Tle
integer array TLe
integer array Tme
real array TMe
real array Tpe
integer array TPe
integer Tqe=0
integer array TQe
integer Tse=U
integer array TSe
boolean array Tte
boolean array TTe
real array Tue
integer array TUe
integer array Twe
real array TWe
integer array Tye
integer array TYe
integer array Tze
integer array TZe
real array T_e
real array T0e
real array T1e
real array T2e
integer array T3e
integer T4e=0
integer array T5e
integer T6e=U
integer array T7e
boolean array T8e
boolean array T9e
integer array uve
integer array uee
integer array uxe
integer array uoe
integer array ure
real uie=.9
integer array uae
integer array une
integer uVe=F
constant real uEe=(2*1.)*1./ 32
integer array uXe
integer uOe=F
string uRe="Objects\\Spawnmodels\\Critters\\Albatross\\CritterBloodAlbatross.mdl"
string uIe="chest"
integer uAe=0
integer array uNe
integer ube=U
integer array uBe
boolean array uce
boolean array uCe
constant integer ude=$B8
constant integer uDe=O+8192+ude*8192
integer ufe=0
integer uFe=U
boolean array uge
real array uGe
real array uhe
real array uHe
constant real uje=(2*1.)*1./ 32
real array uJe
real array uke
real array uKe
integer ule=0
integer uLe=U
boolean array ume
integer array uMe
real array upe
real array uPe
real array uqe
real array uQe
real array use
real array uSe
integer ute=$96
constant real uTe=(2*1.)*1./ 32
string uue="Abilities\\Weapons\\GlaiveMissile\\GlaiveMissileTarget.mdl"
string uUe="chest"
integer uwe
string uWe="<StructBuff>"
real array uye
integer array uYe
integer uze
integer array uZe
integer u_e
string u0e="<StructMissile>"
integer array u1e
integer u2e
integer u3e
integer array u4e
real array u5e
integer u6e
string u7e="<RelentlessShiver>"
integer u8e
integer u9e
real array Uve
integer array Uee
integer array Uxe
real array Uoe
real array Ure
real Uie=.75
integer Uae=$A
integer Une=0
integer array UVe
integer UEe=U
integer array UXe
boolean array UOe
boolean array URe
integer array UIe
integer array UAe
integer UNe
string Ube="<StructAfterBuff>"
integer UBe
real array Uce
real array UCe
integer Ude
string UDe="<RigorMortis>"
integer Ufe
integer array UFe
integer array Uge
string UGe="Abilities\\Spells\\Demon\\DarkPortal\\DarkPortalTarget.mdl"
integer array Uhe
string UHe="Abilities\\Spells\\Orc\\Reincarnation\\ReincarnationTarget.mdl"
real array Uje
real array UJe
real array Uke
real array UKe
integer Ule=2
string ULe="Abilities\\Spells\\Demon\\DarkPortal\\DarkPortalTarget.mdl"
string Ume="origin"
integer UMe=20
integer Upe
string UPe="<StructMissile>"
real array Uqe
real array UQe
integer array Use
integer USe
integer Ute
string UTe="<SakeBomb>"
integer Uue
integer UUe
integer Uwe=0
integer array UWe
integer Uye=U
integer array UYe
boolean array Uze
boolean array UZe
integer array U_e
integer array U0e
real array U1e
real array U2e
integer array U3e
integer U4e=0
integer array U5e
integer U6e=U
integer array U7e
boolean array U8e
boolean array U9e
integer array wve
real array wee
integer array wxe
real array woe
integer array wre
integer array wie
integer wae=3
real array wne
real array wVe
real array wEe
real array wXe
integer array wOe
string wRe="Abilities\\Spells\\Other\\Volcano\\VolcanoMissile.mdl"
real wIe=.5
integer wAe=1
real wNe=.3
string wbe="Abilities\\Spells\\Other\\StrongDrink\\BrewmasterTarget.mdl"
string wBe="overhead"
real array wce
integer array wCe
integer wde
integer wDe
string wfe="<SanguineEyes>"
integer wFe
integer array wge
real array wGe
integer whe
integer wHe
string wje="<StructTarget>"
integer wJe
string wke="<StructTransition>"
integer wKe
integer wle
string wLe="<ShamanicBubble>"
real array wme
integer wMe
integer wpe
integer array wPe
integer array wqe
integer wQe
integer wse
integer wSe
real wte=.5
integer array wTe
real array wue
integer array wUe
integer wwe
string wWe="<StructBuff>"
integer wye
integer array wYe
integer array wze
integer wZe
integer w_e
integer array w0e
integer array w1e
integer array w2e
integer array w3e
integer w4e
string w5e="<SleepingDraft>"
integer w6e
integer w7e
integer w8e=0
integer array w9e
integer Wve=U
integer array Wee
boolean array Wxe
boolean array Woe
integer array Wre
integer array Wie
string Wae="Abilities\\Spells\\Undead\\Sleep\\SleepSpecialArt.mdl"
string Wne="origin"
real WVe=.05
integer WEe
integer array WXe
integer WOe
string WRe="<StructHealMissile>"
integer array WIe
real array WAe
integer array WNe
integer array Wbe
integer WBe
string Wce="<SoberUp>"
integer WCe
integer Wde
integer WDe
string Wfe="Units\\NightElf\\Wisp\\WispExplode.mdx"
integer WFe=512
integer array Wge
real array WGe
real array Whe
string WHe="SoberUp_page\\SoberUp_struct\\shockwave.mdx"
integer Wje=512
boolean array WJe
boolean array Wke
integer array WKe
integer array Wle
integer array WLe
string Wme="Abilities\\Spells\\Other\\HealingSpray\\HealBottleMissile.mdl"
string WMe="chest"
string Wpe="Abilities\\Spells\\Human\\Polymorph\\PolyMorphDoneGround.mdl"
string WPe="chest"
real array Wqe
integer WQe
integer Wse
string WSe="<StructTarget>"
integer array Wte
integer array WTe
integer Wue
string WUe="<SteelImpalement>"
integer Wwe
integer WWe
integer Wye
real array WYe
real array Wze
real array WZe
real array W_e
integer array W0e
integer array W1e
integer array W2e
integer array W3e
integer W4e='d'
string W5e="Abilities\\Spells\\Undead\\Impale\\ImpaleMissTarget.mdl"
string W6e="Abilities\\Spells\\Undead\\Impale\\ImpaleHitTarget.mdl"
string W7e="origin"
integer W8e
string W9e="<StructCallback>"
integer yve
integer array yee
integer yxe
real array yoe
integer array yre
real array yie
integer array yae
integer yne
string yVe="<StructSummon>"
integer yEe
string yXe="<SummonPolarBear>"
integer yOe=0
integer array yRe
integer yIe=U
integer array yAe
boolean array yNe
boolean array ybe
integer array yBe
integer array yce
integer array yCe
constant integer yde=O+600
integer array yDe
integer array yfe
integer array yFe
integer yge=0
integer array yGe
integer yhe=U
integer array yHe
boolean array yje
boolean array yJe
integer yke
integer yKe
integer yle
integer array yLe
integer yme
string yMe="<ArcticBlink>"
integer ype=0
integer array yPe
integer yqe=U
integer array yQe
boolean array yse
boolean array ySe
integer array yte
integer array yTe
integer array yue
integer yUe=2
integer ywe
integer yWe
string yye="<Devour>"
integer yYe
integer yze
real array yZe
real array y_e
integer array y0e
integer array y1e
real array y2e
integer y3e
string y4e="<Susanoo>"
integer y5e
real array y6e
real y7e=-.3
string y8e="Abilities\\Spells\\Items\\AIil\\AIilTarget.mdl"
string y9e="origin"
string Yve="Abilities\\Spells\\Other\\HowlOfTerror\\HowlCaster.mdl"
real array Yee
integer array Yxe
integer array Yoe
string Yre="<Swiftness>"
integer Yie
integer array Yae
real array Yne
integer YVe
integer YEe
string YXe="<StructCriticalAttacks>"
integer YOe
string YRe="<TempestStrike>"
integer array YIe
integer YAe
integer YNe
integer Ybe
real array YBe
integer array Yce
integer array YCe
integer array Yde
string YDe="AttachPoint.FOOT"
real Yfe=1
real YFe=450
real Yge=$6A4
constant real YGe=(1*1.)*1./ 32
string Yhe="Abilities\\Spells\\Other\\Stampede\\StampedeMissileDeath.mdl"
string YHe="chest"
real Yje=7.5
integer YJe
string Yke="<StructMissile>"
integer YKe
integer Yle
string YLe="<StructRelocate>"
integer Yme
string YMe="<StructTarget>"
integer Ype
integer YPe
string Yqe="<Tsukuyomi>"
integer array YQe
real array Yse
integer array YSe
integer Yte
integer YTe
integer Yue
real YUe
real Ywe
integer array YWe
integer array Yye
integer array YYe
integer array Yze
integer array YZe
integer array Y_e
real array Y0e
real array Y1e
real array Y2e
real array Y3e
integer Y4e
integer Y5e
real array Y6e
real array Y7e
real array Y8e
boolean array Y9e
constant real zve=(2*1.)*1./ 32
integer zee=300
integer zxe=1
real zoe=.15
integer zre=0
integer array zie
integer zae=U
integer array zne
boolean array zVe
boolean array zEe
integer array zXe
integer array zOe
real array zRe
real array zIe
integer zAe
string zNe="<StructMissile>"
integer array zbe
integer array zBe
real array zce
integer array zCe
integer array zde
integer zDe
integer zfe
string zFe="<StructTarget>"
integer array zge
integer array zGe
integer zhe
string zHe="<WanShroud>"
integer zje
integer zJe
integer zke=0
integer array zKe
integer zle=U
integer array zLe
boolean array zme
boolean array zMe
integer array zpe
integer array zPe
real array zqe
real array zQe
integer zse=0
integer array zSe
integer zte=U
integer array zTe
boolean array zue
boolean array zUe
integer array zwe
integer array zWe
integer array zye
real array zYe
real array zze
integer array zZe
integer array z_e
real array z0e
real array z1e
integer z2e
integer z3e
real z4e=.75
string z5e="Abilities\\Spells\\Human\\Feedback\\ArcaneTowerAttack.mdl"
string z6e="origin"
integer z7e
integer z8e
integer array z9e
real array Zve
integer array Zee
integer Zxe
string Zoe="<StructTarget>"
integer array Zre
real array Zie
integer Zae
string Zne="<Warcry>"
integer ZVe
integer ZEe
string ZXe="Abilities\\Spells\\NightElf\\BattleRoar\\RoarCaster.mdl"
integer ZOe=1
real ZRe=.3
integer array ZIe
integer array ZAe
integer array ZNe
integer array Zbe
integer ZBe
string Zce="<StructSummon>"
integer ZCe
string Zde="<WaterBindings>"
integer ZDe=75
integer Zfe
real array ZFe
integer array Zge
integer ZGe
integer Zhe
integer ZHe
string Zje="<Lariat>"
real array ZJe
integer array Zke
integer ZKe
integer Zle
constant integer ZLe=O+8192+602*8192
real array Zme
real array ZMe
integer array Zpe
integer array ZPe
integer array Zqe
integer array ZQe
integer array Zse
integer array ZSe
integer array Zte
real array ZTe
integer Zue
string ZUe="<StructTarget>"
integer Zwe
integer ZWe
string Zye="<SoakingAttack>"
integer ZYe
integer Zze
integer array ZZe
integer array Z_e
real array Z0e
integer Z1e
integer Z2e
string Z3e="<StructTarget>"
real array Z4e
integer array Z5e
integer Z6e
string Z7e="<ZodiacAura>"
integer Z8e
integer Z9e
integer array vvx
integer array vex
real array vxx
real array vox
real vrx=.5
integer array vix
integer array vax
integer vnx
integer vVx
integer vEx
integer array vXx
integer vOx
string vRx="<Zodiac>"
boolean array vIx
boolean array vAx
integer vNx
integer vbx
integer vBx
integer vcx
string vCx="<BigHealingWave>"
integer vdx
integer vDx
integer vfx=0
integer array vFx
integer vgx=U
integer array vGx
boolean array vhx
boolean array vHx
real array vjx
integer array vJx
integer array vkx
integer array vKx
integer array vlx
integer array vLx
real vmx=.35
integer vMx='d'
real vpx=.75
string vPx="BigHealingWave_page\\BigHealingWave_struct\\TargetEffect.mdx"
string vqx="origin"
integer vQx
integer vsx
integer vSx
string vtx="<BurningSpiritMeteorite>"
boolean array vTx
boolean array vux
integer array vUx
integer array vwx
integer array vWx
integer vyx=20
integer vYx
integer vzx
string vZx="<BurnLumber>"
integer v_x
integer v0x=50
integer v1x=50
integer v2x
integer v3x
string v4x="<CoreFusion>"
real v5x=.2
string v6x="Abilities\\Spells\\Other\\Volcano\\VolcanoMissile.mdl"
real v7x
integer v8x
integer v9x
integer evx
integer eex
integer exx
string eox="<DarkAttack>"
integer erx
integer array eix
integer array enx
integer eVx
integer eEx
string eXx="Abilities\\Spells\\Undead\\DeathCoil\\DeathCoilSpecialArt.mdx"
string eOx="origin"
integer eRx
integer eIx
string eAx="<StructTarget>"
integer eNx
string ebx="<FountainAura>"
integer eBx
integer ecx
integer array eCx
integer array edx
integer eDx
integer efx
integer eFx
string egx="<FountainHeal>"
integer eGx
integer ehx
integer eHx
real ejx=1.5
real eJx=1.5
constant integer ekx=O+8192+604*8192
string eKx="Abilities\\Spells\\NightElf\\MoonWell\\MoonWellCasterArt.mdl"
string elx="origin"
string eLx="Abilities\\Spells\\Human\\Heal\\HealTarget.mdl"
string emx="origin"
string eMx="Abilities\\Spells\\Items\\AIma\\AImaTarget.mdl"
string epx="origin"
integer ePx
string eqx="<FrostAttack>"
integer eQx
real array esx
integer eSx
integer etx
integer eTx
integer eux
integer eUx
string ewx="<Invisibility>"
integer eWx
string eyx="<Invulnerability>"
integer eYx
integer ezx
integer eZx
integer e_x
string e0x="<StructBuff>"
integer e1x
integer e2x
string e3x="<Lapidation>"
integer e4x
integer e5x
integer e6x=$A
boolean array e7x
boolean array e8x
integer array e9x
real array xvx
integer xex='d'
integer array xxx
integer array xox
integer xrx=$A
integer array xix
integer array xax
real array xnx
real array xVx
integer array xEx
integer xXx
integer xOx
integer xRx
string xIx="<LightningAttack>"
integer xAx
integer xNx
integer xbx=0
integer array xBx
integer xcx=U
integer array xCx
boolean array xdx
boolean array xDx
real array xfx
integer array xFx
real array xgx
real array xGx
integer array xhx
integer array xHx
real array xjx
integer array xJx
integer array xkx
integer array xKx
integer array xlx
integer array xLx
string xmx="abilities\\Spells\\Orc\\LightningBolt\\LightningBolt.wav"
string xMx="Abilities\\Spells\\Items\\AIlb\\AIlbSpecialArt.mdl"
string xpx="chest"
integer xPx
integer xqx
trigger xQx
string xsx="<MagicImmunity>"
integer xSx
integer xtx
integer xTx
string xux="<MeteoriteProtection>"
integer xUx
integer xwx
string xWx="<RefreshMana>"
integer xyx
string xYx="Abilities\\Spells\\Items\\AIre\\AIreTarget.mdl"
string xzx="origin"
real xZx=.5
integer x_x
integer x0x
string x1x="<StructTarget>"
integer x2x
string x3x="<RevealAura>"
integer x4x
integer x5x
integer array x6x
integer array x7x
integer x8x
integer x9x
integer ovx
string oex="<Meteorite>"
integer oxx
string oox="<Pengu>"
integer orx
integer oix
string oax="<Sebastian>"
integer onx
group oRx=null
boolexpr oAx=null
endglobals
function oBx takes player ocx returns group
set oRx=CreateGroup()
call SyncSelections()
call GroupEnumUnitsSelected(oRx,ocx,oAx)
return oRx
endfunction
function config takes nothing returns nothing
local integer olx
local player oLx
call SetGamePlacement(MAP_PLACEMENT_USE_MAP_SETTINGS)
call SetMapDescription("blub")
call SetMapName("Defend Wintercastle")
set olx=6
call SetPlayers(olx+2)
call SetTeams(2)
loop
exitwhen(olx<0)
set oLx=Player(olx)
call SetPlayerController(oLx,MAP_CONTROL_USER)
call SetPlayerRacePreference(oLx,RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(oLx,false)
call SetPlayerTeam(oLx,0)
set olx=olx-1
endloop
set oLx=Player(7)
call SetPlayerColor(oLx,PLAYER_COLOR_PINK)
call SetPlayerController(oLx,MAP_CONTROL_COMPUTER)
call SetPlayerRacePreference(oLx,RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(oLx,false)
call SetPlayerTeam(oLx,1)
set oLx=Player($B)
call SetPlayerColor(oLx,PLAYER_COLOR_BROWN)
call SetPlayerController(oLx,MAP_CONTROL_COMPUTER)
call SetPlayerRacePreference(oLx,RACE_PREF_ORC)
call SetPlayerRaceSelectable(oLx,false)
call SetPlayerTeam(oLx,1)
set oLx=null
endfunction
function omx takes player oMx returns integer
return(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((oMx))))),((((R))))))
endfunction
function opx takes nothing returns integer
return omx(GetTriggerPlayer())
endfunction
function oPx takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((I[(oqx)]))])]))],((((A[((oqx))])))),(((oQx)))))
endfunction
function osx takes integer oQx,integer oSx returns integer
return(oSx*8192+(((oQx)-O-8192)/ 8192))
endfunction
function otx takes string s returns nothing
set G=G+1
set h[G]=s
endfunction
function oTx takes nothing returns nothing
local integer i=H
call otx("stack trace:")
loop
exitwhen(i<0)
call otx("-> "+(LoadStr(j,(J[i]),0)))
set i=i-1
endloop
endfunction
function oux takes string s returns nothing
local string s2
local integer oUx
local integer c
local integer i
set k=k+1
if((k/ K)!=((k-1)/ K))then
call PreloadGenClear()
endif
set s="#"+I2S(k)+" ("+R2S((TimerGetElapsed(l)))+"): "+s
set s2="\")"+s
if(StringLength(s2)>259)then
set oUx=StringLength(s)
set c=oUx/ 257+1
set i=1
call Preload("\")"+":cmd mergeLines="+I2S(c))
loop
exitwhen(i>c)
if(i==c)then
call Preload("\")"+SubString(s,(i-1)*257,oUx))
else
call Preload("\")"+SubString(s,(i-1)*257,i*257+1))
endif
set i=i+1
endloop
else
call Preload(s2)
endif
call PreloadGenEnd("Logs\\Defend Wintercastle\\Session"+I2S(L)+"\\DWC_Errors_"+I2S(k/ K)+".txt")
endfunction
function owx takes string s returns nothing
local boolean oWx=true
if(s==null)then
set s="null"
endif
if oWx then
endif
if not oWx then
return
endif
call oux("[DEBUG] "+s)
endfunction
function oyx takes nothing returns nothing
local integer i=G-1
local string s
set f=f-1
if(f>0)then
return
endif
if(G<0)then
return
endif
set s=h[G]
set G=F
loop
exitwhen(i<0)
set s=h[i]+"
"+"\t"+s
set i=i-1
endloop
call owx(s)
endfunction
function oYx takes string ozx,string oZx,string s returns nothing
set f=f+1
call otx("---/")
if(s!=null)then
call otx(s)
endif
call otx("")
if(ozx!=null)then
call otx("in ->"+ozx)
endif
if(oZx!=null)then
call otx("line ->"+oZx)
endif
call otx("")
call oTx()
call otx("/---")
call oyx()
endfunction
function o_x takes integer oQx returns integer
local integer o0x=(((oQx)-O-8192)/ 8192)
if(o0x>0)then
return O+8192+o0x*8192
endif
return 0
endfunction
function o1x takes integer o2x returns string
local integer o0x=(((o2x)-O-8192)/ 8192)
local integer o3x=o_x(o2x)
local string o4x
if(o0x>0)then
set o4x=LoadStr(P,0,o3x)
if(o4x==null)then
return null
endif
return((I2S((o3x)))+" (table "+(I2S((o0x)))+"; index "+(I2S((o2x-o3x)))+"): "+o4x)
endif
set o4x=LoadStr(P,0,o2x)
if(o4x==null)then
return null
endif
return((I2S((o2x)))+" (base "+(I2S((o2x-O)))+"): "+o4x)
endfunction
function o5x takes integer oqx,integer o6x,integer oQx returns nothing
local integer o7x=(0+(LoadInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx))))))
local string o8x
local string o9x
local integer olx
local integer oSx
local integer rvx
set f=f+1
call otx("print table "+I2S(o6x)+";"+I2S(oQx)+";"+I2S(o7x))
set o8x=o1x(o6x)
set o9x=o1x(oQx)
if((o8x!=null)or(o9x!=null))then
call otx(o8x+";"+o9x)
endif
call otx("--->")
set olx=o7x
loop
exitwhen(olx<q)
set oSx=(LoadInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx)+(olx)))))
set rvx=(LoadInteger(o[((D[(oqx)]))],((o6x)),(osx((oQx),((oSx))))))
call otx("\t"+I2S(oSx)+" on "+I2S(olx)+";"+I2S(rvx)+";"+I2S(osx(oQx,(oSx))))
if(olx!=rvx)then
call otx("TABLE CORRUPTED!")
endif
call otx("\t"+"\t"+o1x(rvx))
set olx=olx-1
endloop
call oyx()
endfunction
function rex takes integer oqx,integer o6x,integer oQx,integer oSx returns boolean
local integer o7x=(0+(LoadInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx))))))
local integer rxx=osx(oQx,(oSx))
local integer rox=(LoadInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx)+(o7x)))))
local integer rvx=(LoadInteger(o[((D[oqx]))],(o6x),(rxx)))
if not((LoadInteger(o[((D[((oqx))]))],(((o6x))),(osx(((oQx)),(((oSx)))))))!=0)then
call oYx("FolderDataTable_FolderIntegerKeys_StructTable_RemoveInteger","call DebugEx(FolderDataTable_FolderIntegerKeys_StructTable.NAME + \": \" + \"cannot remove \"+I2S(value) + \" from \" + I2S(missionKey) + \";\" + I2S(key) + \" reverseKey: \"+I2S(reverseKey))",M+": "+"cannot remove "+I2S(oSx)+" from "+I2S(o6x)+";"+I2S(oQx)+" reverseKey: "+I2S(rxx))
call o5x(oqx,o6x,oQx)
return false
endif
call SaveInteger(o[((D[oqx]))],(o6x),(osx(oQx,(rox))),(rvx))
call SaveInteger(o[((V[(E[(oqx)])]))],((o6x)),((oQx+rvx)),((rox)))
call SaveInteger(o[(((D[oqx])))],((o6x)),((rxx)),(0))
call SaveInteger(o[(((V[(E[(oqx)])])))],(((o6x))),(((oQx+o7x))),(0))
set o7x=o7x-1
call SaveInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx))),(((o7x)-0)))
return(o7x==0)
endfunction
function rrx takes integer oqx,integer oQx,integer oSx returns boolean
return rex(I[(oqx)],(A[((oqx))]),oQx,oSx)
endfunction
function rix takes integer oqx,integer oQx returns nothing
call SaveInteger(o[(((V[(E[((I[(oqx)]))])])))],(((((A[((oqx))]))))),((((oQx)))),(0))
endfunction
function rax takes integer okx returns nothing
set ov=okx
if not TriggerEvaluate(rv)then
call oYx("Basic_AllocInc","call DebugEx(\"AllocInc: \" + \"thread broken\")","AllocInc: thread broken")
endif
endfunction
function rnx takes integer oqx returns integer
set ev[oqx]=true
set xv[oqx]=false
call rax(iv)
return oqx
endfunction
function rVx takes nothing returns integer
local integer oqx
if(S==8190)then
call oYx("EventResponse_Allocation_allocCustom","call DebugEx(EventResponse.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",T+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(W[(w)]==w)then
set Y=Y+1
set oqx=Y
else
set oqx=W[(w)]
set W[(w)]=W[W[(w)]]
endif
set W[oqx]=Z
set vv[oqx]=1
call rnx(oqx)
return oqx
endfunction
function rEx takes integer rXx returns integer
local integer oqx=rVx()
set av[(oqx)]=(rXx)
return oqx
endfunction
function rOx takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((Rv[oqx]))])]))],((((A[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function rAx takes integer oqx returns boolean
local trigger rNx
local boolean o4x
if(oqx==w)then
return true
endif
set rNx=CreateTrigger()
call TriggerAddCondition(rNx,Bv[oqx])
set o4x=TriggerEvaluate(rNx)
call DestroyTrigger(rNx)
set rNx=null
return o4x
endfunction
function rbx takes integer rBx returns nothing
set H=H+1
set J[H]=rBx
endfunction
function rcx takes integer oqx returns nothing
set Cv=Cv+1
if(dv[oqx]==null)then
call oYx("Trigger_Run","call DebugEx(Trigger.NAME + \": no action\" + \"(\" + I2S(this) + \")\")",Dv+": no action("+I2S(oqx)+")")
return
endif
if(fv[oqx]==0)then
call oYx("Trigger_Run","call DebugEx(Trigger.NAME + \": no code\" + \"(\" + I2S(this) + \")\")",Dv+": no code("+I2S(oqx)+")")
return
endif
call rbx(fv[oqx])
if not TriggerEvaluate(dv[oqx])then
call oYx("Trigger_Run","call DebugEx(\"trigThread broken: \" + this.name + \";\" + this.nameId + \" (\" + this.codeNameString + \")\")","trigThread broken: "+Fv[oqx]+";"+gv[oqx]+" ("+Gv[oqx]+")")
endif
set H=H-1
endfunction
function rCx takes integer oqx,integer rdx returns nothing
set Nv=(oqx)
set bv=(rdx)
if rAx((cv[(oqx)]))then
call rcx((hv[(oqx)]))
endif
endfunction
function rDx takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((Rv[oqx]))])]))],((((A[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function rfx takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((Hv[oqx]))])]))],((((Ev[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function rFx takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((Hv[oqx]))])]))],((((Ev[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function rgx takes integer okx returns nothing
set jv=okx
if not TriggerEvaluate(Jv)then
call oYx("Basic_AllocDec","call DebugEx(\"AllocDec: \" + \"thread broken\")","AllocDec: thread broken")
endif
endfunction
function rGx takes integer oqx returns nothing
set ev[oqx]=false
call rgx(iv)
endfunction
function rhx takes integer oqx returns nothing
if(vv[oqx]>0)then
return
endif
if(W[oqx]!=Z)then
call oYx("EventResponse_Allocation_deallocCustom_confirm","call DebugEx(EventResponse.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",T+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set W[oqx]=W[(w)]
set W[(w)]=oqx
call rGx(oqx)
endfunction
function rHx takes integer oqx returns nothing
set vv[oqx]=vv[oqx]-1
call rhx(oqx)
endfunction
function rjx takes integer oqx,integer rJx returns nothing
local integer rkx=oqx
local integer rdx=rEx((A[(rkx)]))
local integer rKx
local integer olx
local integer rIx
local integer rlx
set nv[(rdx)]=(rJx)
set Vv[(rdx)]=(rkx)
set rKx=rEx((Ev[(rJx)]))
set nv[(rKx)]=(rJx)
set Vv[(rKx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,Av,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,Av,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set rlx=rfx(rJx,Av,rIx)
loop
exitwhen(rlx<q)
call rCx(rFx(rJx,Av,rIx,rlx),rKx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call rHx(((rKx)))
endfunction
function rLx takes integer oqx,integer rJx returns nothing
if not((oPx((((oqx))),N+((rJx))))>0)then
return
endif
if(B[rJx]!=0)then
call UnitRemoveAbility(C[((oqx))],(B[rJx]))
endif
call rrx((oqx),Q,rJx)
call rix((oqx),N+rJx)
call rjx((oqx),(rJx))
endfunction
function rmx takes integer oqx,string o6x,string oQx returns integer
if((o6x==null)or(oQx==null))then
call oYx("FolderGameCache_StructInteger_Get","call DebugEx(\"GameCache Get: \"+missionKey+\";\"+key)","GameCache Get: "+o6x+";"+oQx)
return 0
endif
return GetStoredInteger(Kv[(oqx)],o6x,oQx)
endfunction
function rMx takes string rpx,integer oQx returns integer
return(rmx(lv[(E[((X))])],((rpx)),(((I2S((oQx)))))))
endfunction
function rPx takes string rqx returns integer
return rMx(rqx,mv)
endfunction
function rQx takes integer oqx,integer rsx returns nothing
call UnitAddAbility(C[(oqx)],rsx)
call UnitMakeAbilityPermanent(C[(oqx)],true,rsx)
endfunction
function rSx takes integer oqx,integer o6x,integer oQx,integer oSx returns boolean
local integer o7x
if((LoadInteger(o[((D[((oqx))]))],(((o6x))),(osx(((oQx)),(((oSx)))))))!=0)then
call oYx("FolderDataTable_FolderIntegerKeys_StructTable_AddInteger","call DebugEx(I2S(value)+\" already in table \"+I2S(missionKey)+\";\"+I2S(key))",I2S(oSx)+" already in table "+I2S(o6x)+";"+I2S(oQx))
call o5x(oqx,o6x,oQx)
return false
endif
set o7x=(0+(LoadInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx))))))+1
call SaveInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx))),(((o7x)-0)))
call SaveInteger(o[((D[oqx]))],(o6x),(osx(oQx,(oSx))),(o7x))
call SaveInteger(o[((V[(E[(oqx)])]))],((o6x)),((oQx+o7x)),((oSx)))
return(o7x==q)
endfunction
function rtx takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(I[(oqx)],(A[((oqx))]),oQx,oSx)
endfunction
function rTx takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((I[(oqx)]))])]))],((((A[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function rux takes integer oqx,integer rJx returns integer
return oPx((oqx),N+rJx)
endfunction
function rUx takes integer oqx,integer rwx,integer rJx returns nothing
local integer rKx=rEx((Ev[(rJx)]))
local integer olx
local integer rIx
local integer rlx
set Mv[(rKx)]=(rwx)
set nv[(rKx)]=(rJx)
set Vv[(rKx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rfx(rJx,pv,rIx)
loop
exitwhen(rlx<q)
call rCx(rFx(rJx,pv,rIx,rlx),rKx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rKx)))
endfunction
function rWx takes integer oqx,integer rJx returns nothing
local integer rwx=rux((oqx),rJx)
call rUx(oqx,rwx,rJx)
endfunction
function ryx takes integer oqx,integer rsx,integer rwx returns nothing
if(rwx==0)then
call UnitRemoveAbility(C[((oqx))],(rsx))
return
endif
if((GetUnitAbilityLevel(C[((oqx))],(rsx)))==0)then
call rQx(oqx,rsx)
endif
call SetUnitAbilityLevel(C[(oqx)],rsx,rwx)
endfunction
function rYx takes integer oqx,integer rJx,integer rwx returns nothing
local integer rKx=rEx((Ev[(rJx)]))
local integer olx
local integer rIx
local integer rlx
set Mv[(rKx)]=(rwx)
set nv[(rKx)]=(rJx)
set Vv[(rKx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rfx(rJx,Pv,rIx)
loop
exitwhen(rlx<q)
call rCx(rFx(rJx,Pv,rIx,rlx),rKx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rKx)))
endfunction
function rzx takes integer oqx,integer rJx,integer rwx returns nothing
local boolean rZx
if(rwx==0)then
call rLx(oqx,rJx)
return
endif
set rZx=not((oPx((((oqx))),N+((rJx))))>0)
if rZx then
if(B[rJx]!=0)then
call rQx(oqx,B[rJx])
endif
call rtx((oqx),Q,rJx)
call rTx((oqx),N+rJx,rwx)
call rWx(oqx,rJx)
return
endif
call rTx((oqx),N+rJx,rwx)
call ryx(oqx,B[rJx],rwx)
call rYx((oqx),(rJx),(rwx))
endfunction
function r_x takes integer oqx,integer rJx returns nothing
call rzx((oqx),(rJx),(1))
endfunction
function r0x takes nothing returns nothing
local string r1x=GetEventPlayerChatString()
local integer oqx=opx()
if(SubString(r1x,0,3)=="-r ")then
call rLx((kv[(oqx)]),rPx(SubString(r1x,3,(StringLength((r1x))))))
elseif(SubString(r1x,0,3)=="-a ")then
call r_x((kv[(oqx)]),rPx(SubString(r1x,3,(StringLength((r1x))))))
endif
endfunction
function r2x takes string oMx,integer r3x,integer r4x returns string
local integer r5x=((StringLength(((oMx))))-1)
if(r4x>r5x)then
call oYx("String_Sub","call DebugEx(\"String Sub: end above upper limit (\" + self + \";\" + I2S(start) + \";\" + I2S(end) + \")\")","String Sub: end above upper limit ("+oMx+";"+I2S(r3x)+";"+I2S(r4x)+")")
set r4x=r5x
endif
if(r3x<0)then
call oYx("String_Sub","call DebugEx(\"String Sub: start below lower limit (\" + self + \";\" + I2S(start) + \";\" + I2S(end) + \")\")","String Sub: start below lower limit ("+oMx+";"+I2S(r3x)+";"+I2S(r4x)+")")
set r3x=0
elseif(r3x>r4x)then
return null
endif
return SubString(oMx,r3x,r4x+1)
endfunction
function r6x takes string oMx,string oSx,integer okx returns integer
local integer olx=0-1
local integer r7x=((StringLength(((oMx))))-1)
local integer r8x=(StringLength((oSx)))
loop
exitwhen(okx<0)
set olx=olx+1
loop
if(olx>r7x)then
return Qv
endif
exitwhen(r2x(oMx,olx,olx+r8x-1)==oSx)
set olx=olx+1
endloop
set okx=okx-1
endloop
return olx
endfunction
function r9x takes nothing returns nothing
local string o2x=GetEventPlayerChatString()
local integer ivx=r6x(o2x,";",0)
call BJDebugMsg("load "+r2x(o2x,5,ivx-1))
call BJDebugMsg("loadB "+r2x(o2x,ivx+1,StringLength(o2x)-1))
call BJDebugMsg(I2S((LoadInteger(o[((V[(E[((X))])]))],(((S2I(r2x(o2x,0,ivx-2))))),(((S2I(r2x(o2x,ivx,StringLength(o2x))))))))))
endfunction
function iex takes nothing returns nothing
local integer i=q
local integer oQx=Sv
local integer o6x=$9C40
local integer o2x=S2I(SubString(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString())))
if(SubString(GetEventPlayerChatString(),0,4)=="-add")then
call BJDebugMsg("add")
call rSx(X,o6x,oQx,o2x)
else
call BJDebugMsg("rem")
call rex(X,o6x,oQx,o2x)
endif
call BJDebugMsg("count "+I2S((0+(LoadInteger(o[((V[(E[((X))])]))],(((o6x))),(((oQx))))))))
loop
exitwhen(i>$A)
call BJDebugMsg(I2S(i)+" --> "+I2S((LoadInteger(o[((V[(E[((X))])]))],(((o6x))),(((oQx)+(i)))))))
set i=i+1
endloop
endfunction
function ixx takes integer oqx returns integer
set yv[oqx]=true
set Yv[oqx]=false
call rax(zv)
return oqx
endfunction
function iox takes nothing returns integer
local integer oqx
if(Tv==8190)then
call oYx("GameMessage_Allocation_allocCustom","call DebugEx(GameMessage.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",uv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Uv[(w)]==w)then
set wv=wv+1
set oqx=wv
else
set oqx=Uv[(w)]
set Uv[(w)]=Uv[Uv[(w)]]
endif
set Uv[oqx]=Z
set Wv[oqx]=1
call ixx(oqx)
return oqx
endfunction
function irx takes integer oqx returns integer
set ie[oqx]=true
set ae[oqx]=false
set ne[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
call rax(Xe)
return oqx
endfunction
function iix takes nothing returns integer
local integer oqx
if(ve==8190)then
call oYx("Timer_Allocation_allocCustom","call DebugEx(Timer.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",ee+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(xe[(w)]==w)then
set oe=oe+1
set oqx=oe
else
set oqx=xe[(w)]
set xe[(w)]=xe[xe[(w)]]
endif
set xe[oqx]=Z
set re[oqx]=1
call irx(oqx)
return oqx
endfunction
function iax takes integer oqx returns nothing
set Ie[(oqx)]=(Ne+oqx)
endfunction
function inx takes nothing returns integer
local integer oqx
local timer oMx
if(Zv==F)then
set oqx=iix()
set oMx=CreateTimer()
set Oe[oqx]=oMx
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oMx))))),((((Re)))),((((oqx)))))
set oMx=null
call iax(oqx)
return oqx
endif
set oqx=be[Zv]
set Zv=Zv-1
set Be[(oqx)]=(null)
set ce[(oqx)]=((.0)*1.)
return oqx
endfunction
function iVx takes integer oqx returns boolean
return(oqx==(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetLocalPlayer())))))),((((R)))))))or(oqx==Ge)
endfunction
function iEx takes integer oqx returns boolean
set he=he+1
set He[he]=oqx
set je[oqx]=he+1
return(he==0)
endfunction
function iXx takes integer oqx returns boolean
local integer olx=(je[(oqx)])-1
loop
exitwhen(olx==he)
set He[olx]=He[olx+1]
set je[He[olx]]=olx+1
set olx=olx+1
endloop
set je[oqx]=0
set he=he-1
return(he==F)
endfunction
function iOx takes real a,real b returns real
if(a>b)then
return a
endif
return b
endfunction
function iRx takes integer iIx returns nothing
local integer olx
local player p
local integer oqx
if not iVx(iIx)then
return
endif
if(he>F+4)then
set De[He[0]]=false
call iXx(He[0])
endif
set olx=(R2I(((iOx((0),(he+1-4)))*1.)))
set p=GetLocalPlayer()
call ClearTextMessages()
loop
set oqx=He[olx]
if Ce[oqx]then
call DisplayTimedTextToPlayer(p,-.1,1.2,iOx(.001,(TimerGetRemaining(Oe[(de[oqx])]))-3.),Fe[oqx])
else
call DisplayTimedTextToPlayer(p,-.1,1.2,.0,Fe[oqx])
endif
set olx=olx+1
exitwhen(olx>he)
endloop
set p=null
endfunction
function iAx takes string iNx,integer iIx returns integer
local integer oqx=iox()
local integer ibx=inx()
set Ce[oqx]=false
set de[oqx]=ibx
set De[oqx]=true
set fe[oqx]=iIx
set Fe[oqx]=iNx
set ge[(ibx)]=(oqx)
if iVx(iIx)then
call iEx(oqx)
endif
call iRx(iIx)
return oqx
endfunction
function iBx takes integer oqx returns boolean
if((ke[((oqx))])>0)then
return false
endif
set Ke=Ke+1
set le[Ke]=oqx
set ke[oqx]=Ke+1
return(Ke==0)
endfunction
function icx takes integer oqx,real iCx,boolean idx,code iDx returns nothing
set Je[(oqx)]=((GetHandleId(Condition((iDx)))))
set Be[(oqx)]=((LoadStr(j,(GetHandleId(Condition(((iDx))))),0)))
set ce[(oqx)]=((iCx)*1.)
call TimerStart(Oe[oqx],iCx,idx,iDx)
if idx then
call iBx(oqx)
endif
endfunction
function ifx takes nothing returns integer
return(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
endfunction
function iFx takes integer oqx returns nothing
set yv[oqx]=false
call rgx(zv)
endfunction
function igx takes integer oqx returns nothing
if(Wv[oqx]>0)then
return
endif
if(Uv[oqx]!=Z)then
call oYx("GameMessage_Allocation_deallocCustom_confirm","call DebugEx(GameMessage.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",uv+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set Uv[oqx]=Uv[(w)]
set Uv[(w)]=oqx
call iFx(oqx)
endfunction
function iGx takes integer oqx returns nothing
set Wv[oqx]=Wv[oqx]-1
call igx(oqx)
endfunction
function ihx takes integer oqx returns boolean
if(((ke[((oqx))])>0)==false)then
return false
endif
set ke[le[Ke]]=ke[oqx]
set le[ke[oqx]-1]=le[Ke]
set ke[oqx]=0
set Ke=Ke-1
return(Ke==F)
endfunction
function iHx takes integer oqx returns nothing
call PauseTimer(Oe[oqx])
call ihx(oqx)
endfunction
function ijx takes integer oqx returns nothing
set Zv=Zv+1
set be[Zv]=oqx
call iHx(oqx)
endfunction
function iJx takes integer oqx returns nothing
local integer ibx=de[oqx]
local integer iIx=fe[oqx]
call iGx((oqx))
call ijx(ibx)
if iVx(iIx)then
if De[oqx]then
call iXx(oqx)
endif
endif
call iRx(iIx)
endfunction
function ikx takes nothing returns nothing
local integer oqx=(ge[(ifx())])
call iJx(oqx)
endfunction
function iKx takes integer oqx,real ilx returns nothing
set Ce[oqx]=true
call icx(de[oqx],ilx,false,function ikx)
endfunction
function iLx takes integer ocx,string iNx,real ilx returns integer
local integer o4x=iAx(iNx,ocx)
call iKx(o4x,ilx)
return o4x
endfunction
function imx takes string oSx returns integer
local integer oUx=StringLength(oSx)
local integer iMx
local integer olx
local integer o4x
local string ipx
local integer iPx
if(SubString(oSx,0,1)=="-")then
return-imx(SubString(oSx,1,oUx))
endif
set iMx=1
set olx=oUx-1
set o4x=0
loop
exitwhen(olx<0)
set ipx=StringCase(SubString(oSx,olx,olx+1),true)
set iPx=$F
loop
exitwhen(ipx==Le[iPx])
set iPx=iPx-1
endloop
set o4x=o4x+iPx*iMx
set iMx=iMx*16
set olx=olx-1
endloop
return o4x
endfunction
function iqx takes string oMx,string oSx returns string
if(oSx==null)then
return oMx
endif
return("|c"+oSx+oMx+"|r")
endfunction
function iQx takes boolean isx,string oMx returns string
if isx then
return oMx
endif
return""
endfunction
function iSx takes string oSx returns string
return(iQx((StringLength((oSx)))==1,Le[0])+oSx)
endfunction
function itx takes real a,real b returns real
if(a<b)then
return a
endif
return b
endfunction
function iTx takes integer a,integer b returns integer
return(R2I(((itx(a,b))*1.)))
endfunction
function iux takes integer iUx returns string
local string o4x=""
local integer oSx
if(iUx<0)then
return "-"+iux(-iUx)
endif
loop
exitwhen(iUx<16)
set oSx=iTx(iUx/ 16,$F)
set iUx=iUx-oSx*16
set o4x=o4x+Le[oSx]
endloop
return(o4x+Le[iUx])
endfunction
function iwx takes real iWx,real iyx,real iYx,real izx returns string
local string o4x=iSx(iux((R2I(((izx*255.)*1.)))))
set o4x=o4x+iSx(iux((R2I(((iWx*255.)*1.)))))
set o4x=o4x+iSx(iux((R2I(((iyx*255.)*1.)))))
set o4x=o4x+iSx(iux((R2I(((iYx*255.)*1.)))))
return o4x
endfunction
function iZx takes string oMx,string i_x,string i0x returns string
local integer oUx=(StringLength((oMx)))
local integer i1x=(imx(SubString((i0x),2,4)))
local integer i2x=(imx(SubString((i0x),4,6)))
local integer i3x=(imx(SubString((i0x),6,8)))
local integer i4x=(imx(SubString((i0x),0,2)))
local integer i5x=i1x
local integer i6x=i2x
local integer i7x=i3x
local integer i8x=i4x
local integer i9x=((imx(SubString((i_x),2,4)))-i1x)/ oUx
local integer avx=((imx(SubString((i_x),4,6)))-i2x)/ oUx
local integer aex=((imx(SubString((i_x),6,8)))-i3x)/ oUx
local integer axx=((imx(SubString((i_x),0,2)))-i4x)/ oUx
local integer r4x=oUx-0-1
local integer olx=r4x-1
local string o4x=""
loop
exitwhen(olx<0+1)
set i5x=i5x+i9x
set i6x=i6x+avx
set i7x=i7x+aex
set i8x=i8x+axx
set o4x=iqx(r2x(oMx,olx,olx),(iwx(((i5x)*1.)*1./ 255.,((i6x)*1.)*1./ 255.,((i7x)*1.)*1./ 255.,((i8x)*1.)*1./ 255.)))+o4x
set olx=olx-1
endloop
set o4x=iqx(r2x(oMx,0,0),i_x)+o4x
set o4x=o4x+iqx(r2x(oMx,r4x,r4x),i0x)
return o4x
endfunction
function aox takes nothing returns nothing
call iLx(Ge,iZx(GetEventPlayerChatString(),"ffff0000","ffffcc00"),3.)
call iLx(omx(GetTriggerPlayer()),SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString())),3.)
endfunction
function arx takes nothing returns nothing
local real oSx=S2R(SubStringBJ(GetEventPlayerChatString(),8,StringLength(GetEventPlayerChatString())))
if(oSx>.5)then
set Me[(pe)]=((oSx)*1.)
endif
endfunction
function aix takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((Te[oqx]))])]))],((((se[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function aax takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((Te[oqx]))])]))],((((se[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function anx takes integer oqx returns nothing
local integer rdx=rEx(0)
local integer aVx
local integer olx
local integer rIx
local integer rlx
set Qe[(rdx)]=(oqx)
set aVx=rEx((se[(oqx)]))
set Qe[(aVx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((te))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((te))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set rlx=aix(oqx,te,rIx)
loop
exitwhen(rlx<q)
call rCx(aax(oqx,te,rIx,rlx),aVx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((aVx)))
call rHx(((rdx)))
endfunction
function aEx takes integer oqx returns nothing
set qe=w
call anx(oqx)
endfunction
function aXx takes integer oqx returns nothing
local integer rdx=rEx(0)
local integer aVx
local integer olx
local integer rIx
local integer rlx
set Qe[(rdx)]=(oqx)
set aVx=rEx((se[(oqx)]))
set Qe[(aVx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((We))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((We))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set rlx=aix(oqx,We,rIx)
loop
exitwhen(rlx<q)
call rCx(aax(oqx,We,rIx,rlx),aVx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((aVx)))
call rHx(((rdx)))
endfunction
function aOx takes integer oqx returns nothing
if(qe!=w)then
call aEx(qe)
endif
set qe=oqx
if((ue[(oqx)])==w)then
call iLx(Ge,"New level begins: "+iqx((Ue[(oqx)]),"ffffcc00"),15.)
else
call iLx(Ge,"New level begins: "+iqx((Ue[(oqx)]),"ffffcc00")+", next is "+iqx((Ue[((ue[(oqx)]))]),"ffffcc00"),15.)
endif
call aXx(oqx)
endfunction
function aRx takes nothing returns nothing
call aOx(ye[S2I(SubStringBJ(GetEventPlayerChatString(),4,StringLength(GetEventPlayerChatString())))])
endfunction
function aIx takes integer oqx,playercolor oSx returns nothing
set xx[oqx]=oSx
call SetUnitColor(C[(oqx)],oSx)
endfunction
function aAx takes integer oqx returns nothing
local integer rkx=oqx
local integer rdx=rEx((A[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set Vv[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,rx,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,rx,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function aNx takes integer oqx,integer oSx returns nothing
local integer abx=(ze[(oqx)])
set ze[oqx]=oSx
if(Ze[((oqx))])then
call SetUnitOwner(C[(oqx)],vx[ex],true)
else
call SetUnitOwner(C[(oqx)],vx[oSx],true)
endif
call aIx((oqx),(ox[(oSx)]))
if(oSx==abx)then
return
endif
call aAx(oqx)
endfunction
function aBx takes unit oMx returns integer
return(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((oMx))))),((((ix))))))
endfunction
function acx takes nothing returns nothing
call aNx(aBx(GetEnumUnit()),omx(GetTriggerPlayer()))
endfunction
function aCx takes nothing returns nothing
call ForGroupBJ(oBx(Player(0)),function acx)
endfunction
function adx takes nothing returns nothing
if nx then
if(GetEventPlayerChatString()=="-rpgcam")then
set nx=false
endif
else
set nx=true
set Vx=S2R(SubStringBJ(GetEventPlayerChatString(),9,StringLength(GetEventPlayerChatString())))
endif
endfunction
function aDx takes player p,integer id,real x,real y,real z returns nothing
set nr=nr+1
endfunction
function afx takes player a0,integer a1,real a2,real a3,real a4 returns unit
call aDx(a0,a1,a2,a3,a4)
return CreateUnit(a0,a1,a2,a3,a4)
endfunction
function aFx takes nothing returns nothing
local player p=Player($F)
local unit u
local integer unitID
local trigger t
local real life
set u=afx(p,'uTav',-6144.,-1984.,.0)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uTav',6272.,-1600.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uArS',4416.,-5376.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
endfunction
function agx takes nothing returns nothing
local player p
local unit u
local integer unitID
local trigger t
local real life
set p=Player(0)
set u=afx(p,'UMet',.0,5760.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set p=Player(7)
set u=afx(p,'uPha',3264.,448.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uLib',.0,1792.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uFou',2048.,1792.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uFou',-2048.,1792.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uPha',-896.,4672.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uGaC',896.,4672.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uRes',1024.,3584.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uGaC',-3264.,448.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uRiS',-3520.,2240.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uRes',3648.,2688.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uRes',-1088.,3584.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uRes',3648.,2432.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uRes',832.,-448.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uRes',-3456.,2688.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uRes',-3456.,1216.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set Vr=afx(p,'uRiS',3392.,1088.,270.)
call SetUnitColor(Vr,ConvertPlayerColor(0))
set p=Player($B)
set u=afx(p,'uTow',704.,-128.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uBTw',-928.,2528.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uBTw',928.,2528.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uBTw',-3488.,992.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uBTw',3872.,2528.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uBTw',-544.,-160.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))
endfunction
function aGx takes nothing returns nothing
local player p=Player($F)
local unit u
local integer unitID
local trigger t
local real life
set u=afx(p,'uPeL',-5590.,-7097.5,149.968)
call SetUnitColor(u,ConvertPlayerColor(0))
endfunction
function ahx takes nothing returns nothing
local player p
local unit u
local integer unitID
local trigger t
local real life
set p=Player(0)
set Er=afx(p,'uPan',-3084.7,-845.3,334.852)
call SetUnitColor(Er,ConvertPlayerColor(0))
set Xr=afx(p,'uBDS',-1596.3,-1489.6,126.718)
call SetUnitColor(Xr,ConvertPlayerColor(0))
set Rr=afx(p,'uPan',-2933.7,-710.3,296.948)
call SetUnitColor(Rr,ConvertPlayerColor(0))
set Ir=afx(p,'uWol',3092.3,-965.9,258.536)
call SetUnitColor(Ir,ConvertPlayerColor(0))
set Ar=afx(p,'uTus',-1575.4,-1256.6,151.12)
call SetUnitColor(Ar,ConvertPlayerColor(0))
set Nr=afx(p,'uKoB',1603.1,-1488.,64.906)
call SetUnitColor(Nr,ConvertPlayerColor(0))
set br=afx(p,'nogr',-2668.7,-923.6,292.411)
call SetUnitColor(br,ConvertPlayerColor(0))
set u=afx(p,'nomg',-4979.7,-1326.4,269.819)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'nrdk',-1796.3,-1132.5,175.327)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'nrdk',-1925.2,-1361.5,132.922)
call SetUnitColor(u,ConvertPlayerColor(0))
set Br=afx(p,'uFuM',-4761.1,-978.8,231.847)
call SetUnitColor(Br,ConvertPlayerColor(0))
set cr=afx(p,'nogr',-2788.8,-1018.3,314.452)
call SetUnitColor(cr,ConvertPlayerColor(0))
set Cr=afx(p,'uTus',-1691.8,-1396.2,150.663)
call SetUnitColor(Cr,ConvertPlayerColor(0))
set dr=afx(p,'uKoR',1582.4,-1361.1,54.808)
call SetUnitColor(dr,ConvertPlayerColor(0))
set Dr=afx(p,'uKoR',1774.9,-1418.2,57.589)
call SetUnitColor(Dr,ConvertPlayerColor(0))
set fr=afx(p,'uKoM',-4896.2,-1000.4,238.763)
call SetUnitColor(fr,ConvertPlayerColor(0))
set Fr=afx(p,'uKoM',-4719.2,-1132.6,216.197)
call SetUnitColor(Fr,ConvertPlayerColor(0))
set gr=afx(p,'uBDS',-1495.9,-1320.2,164.314)
call SetUnitColor(gr,ConvertPlayerColor(0))
set u=afx(p,'nsra',-5084.4,-1378.6,285.229)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'nsra',-4874.7,-1395.2,250.933)
call SetUnitColor(u,ConvertPlayerColor(0))
set Gr=afx(p,'uWoM',3244.4,-898.1,246.736)
call SetUnitColor(Gr,ConvertPlayerColor(0))
set hr=afx(p,'uWol',3295.5,-1068.4,226.954)
call SetUnitColor(hr,ConvertPlayerColor(0))
set Hr=afx(p,'uKoB',1686.5,-1549.2,59.667)
call SetUnitColor(Hr,ConvertPlayerColor(0))
set u=afx(p,'ohun',-1903.,-1144.9,146.43)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'ohun',-2026.7,-1301.4,136.268)
call SetUnitColor(u,ConvertPlayerColor(0))
set jr=afx(p,'uTrG',4715.,-2739.7,83.518)
call SetUnitColor(jr,ConvertPlayerColor(0))
set Jr=afx(p,'uTrP',4603.9,-2603.4,63.699)
call SetUnitColor(Jr,ConvertPlayerColor(0))
set kr=afx(p,'uTrP',4842.5,-2666.6,65.853)
call SetUnitColor(kr,ConvertPlayerColor(0))
set p=Player(7)
set Kr=afx(p,'uSeb',-74.1,1659.5,261.67)
call SetUnitColor(Kr,ConvertPlayerColor(0))
set p=Player(8)
set u=afx(p,'uPen',-5808.8,-6672.8,5.757)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uPen',-4436.6,-6030.5,339.21)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uPen',-5608.,-5022.6,307.313)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uPen',-3996.7,-6982.,5.757)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=afx(p,'uPen',-4690.6,-6965.2,161.488)
call SetUnitColor(u,ConvertPlayerColor(0))
endfunction
function aHx takes code oMx returns nothing
if(lr!=null)then
call TriggerRemoveAction(Lr,lr)
endif
set lr=TriggerAddAction(Lr,oMx)
call rbx((GetHandleId(Condition((oMx)))))
call TriggerExecuteWait(Lr)
set H=H-1
endfunction
function ajx takes string s returns nothing
local boolean oWx=true
if(s==null)then
set s="null"
endif
if not oWx then
return
endif
call oux("[INFO] "+s)
endfunction
function aJx takes nothing returns nothing
call SetTerrainFogEx(0,10000.,10000.,0,0,0,0)
call SetCameraField(CAMERA_FIELD_FARZ,10000.,.0)
loop
exitwhen mr
call SetCameraField(CAMERA_FIELD_ANGLE_OF_ATTACK,270.,.0)
call SetCameraField(CAMERA_FIELD_TARGET_DISTANCE,1650.,.0)
call SetCameraField(CAMERA_FIELD_ZOFFSET,10000.,.0)
call TriggerSleepAction(.035)
endloop
endfunction
function akx takes nothing returns nothing
set Mr=0
loop
exitwhen mr
call TriggerSleepAction(1)
set Mr=Mr+1
endloop
endfunction
function aKx takes nothing returns nothing
local real camX=GetCameraTargetPositionX()
local real camY=GetCameraTargetPositionY()
local real z=3900.
call EnableUserUI(false)
call ShowInterface(false,0)
call SetCineFilterBlendMode(BLEND_MODE_BLEND)
call SetCineFilterTexMapFlags(TEXMAP_FLAG_NONE)
call SetCineFilterDuration(0)
call SetCineFilterEndColor($FF,$FF,$FF,$FF)
call SetCineFilterStartColor($FF,$FF,$FF,$FF)
call SetCineFilterEndUV(0,0,1,1)
call SetCineFilterStartUV(0,0,1,1)
call SetCineFilterTexture("UI\\LoadingScreenBackground.blp")
call DisplayCineFilter(true)
call FogEnable(false)
call FogMaskEnable(false)
call ExecuteFunc("aJx")
call ExecuteFunc("akx")
endfunction
function alx takes integer oqx returns integer
set tr[oqx]=true
set Tr[oqx]=false
set oqx=null
set oqx=w
set oqx=w
set oqx=0
set oqx=null
set oqx=null
set oqx=w
call rax(ur)
return oqx
endfunction
function aLx takes nothing returns integer
local integer oqx
if(qr==8190)then
call oYx("Allocation_allocCustom","call DebugEx(Loading.NAME + \" - alloc: unable to allocCustom, reached stack limit\")","<s__Loading_Name>"+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Qr[(w)]==w)then
set sr=sr+1
set oqx=sr
else
set oqx=Qr[(w)]
set Qr[(w)]=Qr[Qr[(w)]]
endif
set Qr[oqx]=Z
set Sr[oqx]=1
call alx(oqx)
return oqx
endfunction
function amx takes integer oqx returns boolean
return(Yr==oqx)or((zr[oqx]!=w)or(Zr[oqx]!=w))
endfunction
function aMx takes integer oqx returns boolean
if amx(oqx)then
return false
endif
set Zr[oqx]=w
if(Yr==w)then
set vi=oqx
set Yr=oqx
return true
endif
set zr[oqx]=vi
set Zr[vi]=oqx
set vi=oqx
return false
endfunction
function apx takes trigger t,integer rBx,string rqx returns nothing
local integer oqx=aLx()
set Ur=Ur+1
set wr[oqx]=rBx
set Wr[oqx]=rqx
set yr[oqx]=t
call aMx(oqx)
endfunction
function aPx takes nothing returns boolean
local integer olx=Pr
loop
exitwhen(olx<0)
call apx(ei[olx],xi[olx],oi[olx])
set olx=olx-1
endloop
return true
endfunction
function aqx takes code c returns nothing
local string rqx=LoadStr(j,(GetHandleId(Condition((c)))),0)
local trigger t=CreateTrigger()
set Ur=Ur+1
call TriggerAddCondition(t,Condition(c))
if(rqx==null)then
set rqx="unknown"
endif
call apx(t,(GetHandleId(Condition((c)))),rqx)
set t=null
endfunction
function aQx takes integer oqx returns integer
set Xi[oqx]=true
set Oi[oqx]=false
call rax(Ri)
return oqx
endfunction
function asx takes nothing returns integer
local integer oqx
if(ii==8190)then
call oYx("EffectLevel_Allocation_allocCustom","call DebugEx(EffectLevel.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",ai+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(ni[(w)]==w)then
set Vi=Vi+1
set oqx=Vi
else
set oqx=ni[(w)]
set ni[(w)]=ni[ni[(w)]]
endif
set ni[oqx]=Z
set Ei[oqx]=1
call aQx(oqx)
return oqx
endfunction
function aSx takes integer oqx returns boolean
set Ai=Ai+1
set Ni[Ai]=oqx
set bi[oqx]=Ai+1
return(Ai==0)
endfunction
function atx takes string rqx returns integer
local integer oqx=asx()
set Ii[(oqx)]=(rqx)
call aSx(oqx)
return oqx
endfunction
function aTx takes nothing returns boolean
set ri=atx("low")
set Bi=atx("normal")
set ci=Bi
return true
endfunction
function aux takes nothing returns boolean
local integer olx=Ci
loop
exitwhen(olx<0)
call apx(di[olx],Di[olx],fi[olx])
set olx=olx-1
endloop
return true
endfunction
function aUx takes nothing returns boolean
local integer olx=Fi
loop
exitwhen(olx<0)
call apx(gi[olx],Gi[olx],hi[olx])
set olx=olx-1
endloop
return true
endfunction
function awx takes nothing returns boolean
local integer olx=Hi
loop
exitwhen(olx<0)
call apx(ji[olx],Ji[olx],ki[olx])
set olx=olx-1
endloop
return true
endfunction
function aWx takes integer oqx returns integer
set qi[oqx]=true
set Qi[oqx]=false
call rax(si)
return oqx
endfunction
function ayx takes nothing returns integer
local integer oqx
if(Li==8190)then
call oYx("ObjThread_Allocation_allocCustom","call DebugEx(ObjThread.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",mi+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Mi[(w)]==w)then
set pi=pi+1
set oqx=pi
else
set oqx=Mi[(w)]
set Mi[(w)]=Mi[Mi[(w)]]
endif
set Mi[oqx]=Z
set Pi[oqx]=1
call aWx(oqx)
return oqx
endfunction
function aYx takes integer oqx returns boolean
set ti=ti+1
set Ti[ti]=oqx
set ui[oqx]=ti+1
return(ti==0)
endfunction
function azx takes integer oqx returns nothing
set qi[oqx]=false
call rgx(si)
endfunction
function aZx takes integer oqx returns nothing
if(Pi[oqx]>0)then
return
endif
if(Mi[oqx]!=Z)then
call oYx("ObjThread_Allocation_deallocCustom_confirm","call DebugEx(ObjThread.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",mi+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set Mi[oqx]=Mi[(w)]
set Mi[(w)]=oqx
call azx(oqx)
endfunction
function a_x takes integer oqx returns nothing
set Pi[oqx]=Pi[oqx]-1
call aZx(oqx)
endfunction
function a0x takes integer oqx returns boolean
local integer okx=(ui[(oqx)])
set ui[Ti[ti]]=okx
set Ti[okx-1]=Ti[ti]
set ui[oqx]=0
set ti=ti-1
return(ti==F)
endfunction
function a1x takes integer oqx returns nothing
call a_x((oqx))
if a0x(oqx)then
call PauseTimer(Ui)
endif
endfunction
function a2x takes nothing returns nothing
local integer i=ti
set f=f+1
loop
exitwhen(i<0)
call otx("threadBreak (ObjThread): "+Si[Ti[i]])
set wi=false
call a1x(Ti[i])
set wi=true
set i=i-1
endloop
call oyx()
endfunction
function a3x takes string rqx returns integer
local integer oqx=ayx()
set Si[oqx]=rqx
if aYx(oqx)then
if(Ui==null)then
set Ui=CreateTimer()
endif
call TimerStart(Ui,1,true,function a2x)
endif
return oqx
endfunction
function a4x takes nothing returns nothing
local integer a5x=(R2I(((itx((Wi+Yi),(yi)))*1.)))
local integer a6x=Ki
local trigger t
local integer rBx
local string rqx
loop
exitwhen(Wi>a5x)
set t=LoadTriggerHandle(li,a6x,Wi)
set rBx=LoadInteger(zi,a6x,Wi)
set rqx=LoadStr(Zi,a6x,Wi)
call apx(t,rBx,rqx)
set Wi=Wi+1
endloop
endfunction
function a7x takes nothing returns nothing
local integer a6x=Ki
local integer o7x=LoadInteger(li,a6x,0)
local integer th=a3x("OBJECT INITS "+I2S(a6x))
set Wi=1
set yi=o7x
set Yi=$5DC
loop
exitwhen(Wi>yi)
call aHx(function a4x)
endloop
call a1x(th)
endfunction
function a8x takes integer a6x returns nothing
set Ki=a6x
call aHx(function a7x)
endfunction
function a9x takes nothing returns boolean
local integer olx=xa
loop
exitwhen(olx<0)
call apx(oa[olx],ra[olx],ia[olx])
set olx=olx-1
endloop
return true
endfunction
function nvx takes nothing returns boolean
local integer olx=aa
loop
exitwhen(olx<0)
call apx(na[olx],Va[olx],Ea[olx])
set olx=olx-1
endloop
return true
endfunction
function nex takes nothing returns boolean
local integer olx=Xa
loop
exitwhen(olx<0)
call apx(Oa[olx],Ra[olx],Ia[olx])
set olx=olx-1
endloop
return true
endfunction
function nxx takes nothing returns boolean
local integer olx=Aa
loop
exitwhen(olx<0)
call apx(Na[olx],ba[olx],Ba[olx])
set olx=olx-1
endloop
return true
endfunction
function nox takes nothing returns boolean
local integer olx=ca
loop
exitwhen(olx<0)
call apx(Ca[olx],da[olx],Da[olx])
set olx=olx-1
endloop
return true
endfunction
function nrx takes nothing returns boolean
local integer olx=fa
loop
exitwhen(olx<0)
call apx(Fa[olx],ga[olx],Ga[olx])
set olx=olx-1
endloop
return true
endfunction
function nix takes nothing returns boolean
local integer olx=ta
loop
exitwhen(olx<0)
call apx(Ta[olx],ua[olx],Ua[olx])
set olx=olx-1
endloop
return true
endfunction
function nax takes nothing returns boolean
local integer olx=wa
loop
exitwhen(olx<0)
call apx(Wa[olx],ya[olx],Ya[olx])
set olx=olx-1
endloop
return true
endfunction
function nnx takes nothing returns boolean
local integer olx=za
loop
exitwhen(olx<0)
call apx(Za[olx],vn[olx],en[olx])
set olx=olx-1
endloop
return true
endfunction
function nVx takes nothing returns boolean
local integer olx=xn
loop
exitwhen(olx<0)
call apx(on[olx],rn[olx],in[olx])
set olx=olx-1
endloop
return true
endfunction
function nEx takes nothing returns boolean
local integer olx=an
loop
exitwhen(olx<0)
call apx(nn[olx],Vn[olx],En[olx])
set olx=olx-1
endloop
return true
endfunction
function nXx takes nothing returns boolean
local integer olx=Xn
loop
exitwhen(olx<0)
call apx(On[olx],Rn[olx],In[olx])
set olx=olx-1
endloop
return true
endfunction
function nOx takes nothing returns boolean
local integer olx=An
loop
exitwhen(olx<0)
call apx(Nn[olx],bn[olx],Bn[olx])
set olx=olx-1
endloop
return true
endfunction
function nRx takes nothing returns boolean
local integer olx=cn
loop
exitwhen(olx<0)
call apx(Cn[olx],dn[olx],Dn[olx])
set olx=olx-1
endloop
return true
endfunction
function nIx takes nothing returns boolean
local integer olx=fn
loop
exitwhen(olx<0)
call apx(Fn[olx],gn[olx],Gn[olx])
set olx=olx-1
endloop
return true
endfunction
function nAx takes nothing returns boolean
local integer olx=hn
loop
exitwhen(olx<0)
call apx(Hn[olx],jn[olx],Jn[olx])
set olx=olx-1
endloop
return true
endfunction
function nNx takes nothing returns boolean
local integer olx=kn
loop
exitwhen(olx<0)
call apx(Kn[olx],ln[olx],Ln[olx])
set olx=olx-1
endloop
return true
endfunction
function nbx takes nothing returns boolean
local integer olx=mn
loop
exitwhen(olx<0)
call apx(Mn[olx],pn[olx],Pn[olx])
set olx=olx-1
endloop
return true
endfunction
function nBx takes nothing returns boolean
local integer olx=qn
loop
exitwhen(olx<0)
call apx(Qn[olx],sn[olx],Sn[olx])
set olx=olx-1
endloop
return true
endfunction
function ncx takes nothing returns boolean
local integer olx=tn
loop
exitwhen(olx<0)
call apx(Tn[olx],un[olx],Un[olx])
set olx=olx-1
endloop
return true
endfunction
function nCx takes nothing returns boolean
local integer olx=wn
loop
exitwhen(olx<0)
call apx(Wn[olx],yn[olx],Yn[olx])
set olx=olx-1
endloop
return true
endfunction
function ndx takes nothing returns boolean
local integer olx=zn
loop
exitwhen(olx<0)
call apx(Zn[olx],vV[olx],eV[olx])
set olx=olx-1
endloop
return true
endfunction
function nDx takes nothing returns boolean
local integer olx=xV
loop
exitwhen(olx<0)
call apx(oV[olx],rV[olx],iV[olx])
set olx=olx-1
endloop
return true
endfunction
function nfx takes nothing returns boolean
local integer olx=aV
loop
exitwhen(olx<0)
call apx(nV[olx],VV[olx],EV[olx])
set olx=olx-1
endloop
return true
endfunction
function nFx takes nothing returns boolean
call SetFloatGameState((GAME_STATE_TIME_OF_DAY),((12.)*1.))
return true
endfunction
function ngx takes nothing returns boolean
local integer olx=XV
loop
exitwhen(olx<0)
call apx(OV[olx],RV[olx],IV[olx])
set olx=olx-1
endloop
return true
endfunction
function nGx takes nothing returns boolean
local integer olx=AV
loop
exitwhen(olx<0)
call apx(NV[olx],bV[olx],BV[olx])
set olx=olx-1
endloop
return true
endfunction
function nhx takes nothing returns boolean
local integer olx=cV
loop
exitwhen(olx<0)
call apx(CV[olx],dV[olx],DV[olx])
set olx=olx-1
endloop
return true
endfunction
function nHx takes nothing returns boolean
local integer olx=fV
loop
exitwhen(olx<0)
call apx(FV[olx],gV[olx],GV[olx])
set olx=olx-1
endloop
return true
endfunction
function njx takes nothing returns boolean
local integer olx=hV
loop
exitwhen(olx<0)
call apx(HV[olx],jV[olx],JV[olx])
set olx=olx-1
endloop
return true
endfunction
function nJx takes nothing returns boolean
local integer olx=kV
loop
exitwhen(olx<0)
call apx(KV[olx],lV[olx],LV[olx])
set olx=olx-1
endloop
return true
endfunction
function nkx takes nothing returns boolean
local integer olx=mV
loop
exitwhen(olx<0)
call apx(MV[olx],pV[olx],PV[olx])
set olx=olx-1
endloop
return true
endfunction
function nKx takes nothing returns boolean
local integer olx=qV
loop
exitwhen(olx<0)
call apx(QV[olx],sV[olx],SV[olx])
set olx=olx-1
endloop
return true
endfunction
function nlx takes nothing returns boolean
local integer olx=tV
loop
exitwhen(olx<0)
call apx(TV[olx],uV[olx],UV[olx])
set olx=olx-1
endloop
return true
endfunction
function nLx takes nothing returns boolean
local integer olx=wV
loop
exitwhen(olx<0)
call apx(WV[olx],yV[olx],YV[olx])
set olx=olx-1
endloop
return true
endfunction
function nmx takes nothing returns boolean
local integer olx=zV
loop
exitwhen(olx<0)
call apx(ZV[olx],vE[olx],eE[olx])
set olx=olx-1
endloop
return true
endfunction
function nMx takes nothing returns nothing
call SetCameraField(CAMERA_FIELD_FARZ,.0,.0)
call SetCineFilterBlendMode(BLEND_MODE_BLEND)
call SetCineFilterTexMapFlags(TEXMAP_FLAG_NONE)
call SetCineFilterDuration(3.-1.)
call SetCineFilterEndColor($FF,$FF,$FF,0)
call SetCineFilterStartColor($FF,$FF,$FF,$FF)
call SetCineFilterEndUV(0,0,1,1)
call SetCineFilterStartUV(0,0,1,1)
call SetCineFilterTexture("UI\\LoadingScreenBackground.blp")
call DisplayCineFilter(true)
call ShowInterface(true,3.-1.)
endfunction
function npx takes nothing returns nothing
set mr=true
call FogEnable(true)
call FogMaskEnable(true)
call ResetToGameCamera(.0)
call ResetTerrainFog()
call SetCameraField(CAMERA_FIELD_FARZ,5000.,.0)
call DisplayCineFilter(false)
call EnableUserUI(true)
call ajx("finished loading in "+R2S(Mr)+" seconds")
call PauseGame(false)
endfunction
function nPx takes integer ocx,real x,real y,real x2,real y2,real x3,real y3,real x4,real y4 returns nothing
if iVx(ocx)then
set xE=x
set oE=x2
set rE=x3
set iE=x4
set aE=y
set nE=y2
set VE=y3
set EE=y4
call SetCameraBounds(x,y,x2,y2,x3,y3,x4,y4)
endif
endfunction
function nqx takes nothing returns nothing
local integer rdx=rEx(0)
local integer olx=0
local integer rIx
local integer rlx
loop
exitwhen(olx>Xv)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((XE))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((XE))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set olx=olx+1
endloop
call rHx(((rdx)))
endfunction
function nQx takes nothing returns nothing
call ajx("start game")
call nMx()
call StopSound(pr,true,false)
set pr=null
call FogMaskEnable(false)
call SetCameraField(CAMERA_FIELD_ANGLE_OF_ATTACK,315.,.0)
call SetCameraField(CAMERA_FIELD_TARGET_DISTANCE,1650.,.0)
call SetCameraField(CAMERA_FIELD_ZOFFSET,.0,.0)
call TriggerSleepAction(((3.)*1.))
call npx()
call nPx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetLocalPlayer())))))),((((R)))))),-7680.+GetCameraMargin(CAMERA_MARGIN_LEFT),-7680.+GetCameraMargin(CAMERA_MARGIN_BOTTOM),7680.-GetCameraMargin(CAMERA_MARGIN_RIGHT),7680.-GetCameraMargin(CAMERA_MARGIN_TOP),-7680.+GetCameraMargin(CAMERA_MARGIN_LEFT),7680.-GetCameraMargin(CAMERA_MARGIN_TOP),7680.-GetCameraMargin(CAMERA_MARGIN_RIGHT),-7680.+GetCameraMargin(CAMERA_MARGIN_BOTTOM))
call EnableOcclusion(true)
call aHx(function nqx)
endfunction
function nsx takes nothing returns boolean
call ajx("ingame loading finished")
call a2x()
call aHx(function nQx)
return true
endfunction
function nSx takes nothing returns integer
local integer olx=F
local integer oqx=Yr
loop
exitwhen(oqx==w)
set oqx=Zr[oqx]
set olx=olx+1
endloop
return olx
endfunction
function ntx takes nothing returns boolean
local gamecache gc=InitGameCache("singlePlayerCheck")
local boolean o4x
call StoreBoolean(gc,"blub","moo",true)
set o4x=SaveGameCache(gc)
call FlushGameCache(gc)
set gc=null
return o4x
endfunction
function nTx takes nothing returns integer
local integer oqx=Yr
if(oqx==w)then
return w
endif
set Yr=Zr[oqx]
set Zr[oqx]=w
if(Yr==w)then
set vi=w
else
set zr[Yr]=w
endif
return oqx
endfunction
function nux takes nothing returns nothing
local integer nUx
local integer i=OE
local integer nwx
local integer oqx
if(Yr==w)then
return
endif
loop
exitwhen(Yr==w)
set oqx=nTx()
call rbx(wr[oqx])
if not TriggerEvaluate(yr[oqx])then
call oYx("LoadingQueue","Queue_Exec","could not finish init: "+Wr[oqx])
endif
set H=H-1
set yr[oqx]=null
set i=i-1
exitwhen(i<1)
endloop
set nUx=Ur-(nSx()-F)
set nwx=Ur
call SetCinematicScene(0,null,"Please wait for the map to initialize...",I2S(nUx)+"/"+I2S(nwx)+" assets loaded"+"
"+I2S(R2I(nUx*100./ nwx))+"%",999,0)
if(Yr==w)then
call PauseTimer(RE)
endif
endfunction
function nWx takes nothing returns nothing
local integer nyx=(nSx()-F)
local integer userCount
if(nyx<=0)then
return
endif
set Ur=nyx
set OE=R2I(nyx/ 100.)
if ntx()then
call ajx("singlePlayer")
call PauseGame(true)
loop
exitwhen mr
call ExecuteFunc("nux")
call ExecuteFunc("nux")
call ExecuteFunc("nux")
call ExecuteFunc("nux")
call ExecuteFunc("nux")
call TriggerSleepAction(0)
endloop
else
call ajx("multiPlayer")
call TimerStart(RE,1./ $C,true,function nux)
endif
endfunction
function nYx takes nothing returns nothing
call ajx("process ingame loading...")
call aPx()
call aqx(function aTx)
call aux()
call aUx()
call awx()
call a8x(ea)
call a9x()
call nvx()
call nex()
call nxx()
call nox()
call nrx()
call a8x(Ha)
call a8x(ja)
call a8x(ka)
call a8x(la)
call a8x(ma)
call a8x(Ma)
call a8x(pa)
call a8x(qa)
call a8x(sa)
call a8x(Sa)
call nix()
call nax()
call nnx()
call nVx()
call nEx()
call nXx()
call nOx()
call nRx()
call nIx()
call nAx()
call nNx()
call nbx()
call nBx()
call ncx()
call nCx()
call ndx()
call nDx()
call nfx()
call aqx(function nFx)
call ngx()
call nGx()
call nhx()
call nHx()
call njx()
call nJx()
call nkx()
call nKx()
call nlx()
call nLx()
call nmx()
call aqx(function nsx)
call nWx()
endfunction
function nzx takes nothing returns nothing
call ajx("start loading")
call aKx()
call SetMapMusic("",false,0)
call TriggerSleepAction(.0)
set pr=CreateSound("Sound\\Music\\mp3Music\\War2IntroMusic.mp3",false,false,false,$A,$A,"DefaultEAXOn")
call SetSoundPitch(pr,.8)
call StartSound(pr)
call aHx(function nYx)
endfunction
function nZx takes nothing returns boolean
local integer n_x=AE
local integer nUx=NE
set n_x=n_x-1
loop
exitwhen(n_x<0)
set nUx=bE[nUx]
set n_x=n_x-1
endloop
set BE=nUx
return true
endfunction
function n0x takes nothing returns boolean
local integer okx=jv
local integer n1x=cE[okx]
local integer n2x=n1x-1
local integer n3x
local integer n4x
local integer n5x
local integer n6x
local integer n7x
local integer n8x
if(n2x<0)then
call oYx("Basic_AllocDec_Exec","call DebugEx(\"AllocDec: cannot fall below zero\")","AllocDec: cannot fall below zero")
return true
endif
set cE[okx]=n2x
set n3x=CE[n1x]
set n4x=dE[n1x]
set n5x=DE[okx]
set n6x=bE[okx]
if(n4x==okx)then
if(n3x==okx)then
set dE[n1x]=F
else
set dE[n1x]=n5x
endif
set n7x=F
else
set n7x=n4x
endif
if(n3x==okx)then
if(n4x==okx)then
set CE[n1x]=F
else
set CE[n1x]=n6x
endif
endif
if(n7x!=F)then
if(n6x!=F)then
set DE[n6x]=n5x
endif
if(n5x==F)then
set NE=n6x
else
set bE[n5x]=n6x
endif
set n8x=bE[n7x]
set bE[okx]=n8x
if(n8x==F)then
set fE=okx
else
set DE[n8x]=okx
endif
set bE[n7x]=okx
set DE[okx]=n7x
endif
if((okx==fE)or(cE[bE[okx]]<n2x))then
set dE[n2x]=okx
endif
set CE[n2x]=okx
set FE=FE-1
return true
endfunction
function n9x takes nothing returns boolean
local integer okx=ov
local integer n1x=cE[okx]
local integer n2x=n1x+1
local integer n3x
local integer n4x
local integer n6x
local integer n5x
local integer n8x
local integer n7x
set cE[okx]=n2x
set n3x=CE[n1x]
set n4x=dE[n1x]
set n6x=bE[okx]
set n5x=DE[okx]
if(n3x==okx)then
if(n4x==okx)then
set CE[n1x]=F
else
set CE[n1x]=n6x
endif
set n8x=F
else
set n8x=n3x
endif
if(n4x==okx)then
if(n3x==okx)then
set dE[n1x]=F
else
set dE[n1x]=n5x
endif
endif
if(n8x!=F)then
if(n5x!=F)then
set bE[n5x]=n6x
endif
if(n6x==F)then
set fE=n5x
else
set DE[n6x]=n5x
endif
set n7x=DE[n8x]
set DE[okx]=n7x
if(n7x==F)then
set NE=okx
else
set bE[n7x]=okx
endif
set DE[n8x]=okx
set bE[okx]=n8x
endif
if((okx==NE)or(cE[DE[okx]]>n2x))then
set CE[n2x]=okx
endif
set dE[n2x]=okx
set FE=FE+1
return true
endfunction
function Vvx takes nothing returns nothing
set IE=CreateTrigger()
set Jv=CreateTrigger()
set rv=CreateTrigger()
call TriggerAddCondition(IE,Condition(function nZx))
call TriggerAddCondition(Jv,Condition(function n0x))
call TriggerAddCondition(rv,Condition(function n9x))
endfunction
function Vex takes nothing returns boolean
local string Vxx=GetPlayerName(GetLocalPlayer())
call TimerStart(l,99999,true,null)
call SetPlayerName(GetLocalPlayer(),I2S(L))
call Preloader("Logs\\Defend Wintercastle\\index.ini")
set L=S2I(GetPlayerName(GetLocalPlayer()))+1
call PreloadGenClear()
call PreloadGenStart()
call Preload("\")
call SetPlayerName(GetLocalPlayer(), \""+I2S(L)+"\")
call Preload(\"")
call SetPlayerName(GetLocalPlayer(),Vxx)
call PreloadGenEnd("Logs\\Defend Wintercastle\\index.ini")
call PreloadGenEnd("Logs\\Defend Wintercastle\\signal.ini")
call PreloadGenClear()
call Preload("\")
"+("DEL \"DWC_Errors.txt\"")+"
REM (\"")
call Preload("\")
"+("DEL takeFile.bat")+"
REM (\"")
call Preload("\")
"+("echo	set file=%%~1>>takeFile.bat")+"
REM (\"")
call Preload("\")
"+("echo	echo %%file%%>>takeFile.bat")+"
REM (\"")
call Preload("\")
"+("echo	for /f \"tokens=*\" %%%%A in (%%file%%) do (call takeLine.bat \"%%%%A\")>>takeFile.bat")+"
REM (\"")
call Preload("\")
"+("REM echo	DEL %%file%%>>takeFile.bat")+"
REM (\"")
call Preload("\")
"+("DEL takeLine.bat")+"
REM (\"")
call Preload("\")
"+("echo	set txt=%%1>>takeLine.bat")+"
REM (\"")
call Preload("\")
"+("echo	set txt=%%txt:call Preload( ^\"^\")=%%>>takeLine.bat")+"
REM (\"")
call Preload("\")
"+("echo	IF %%txt%%==%%1 goto :eof>>takeLine.bat")+"
REM (\"")
call Preload("\")
"+("echo	set txt=%%txt:^\" )=%%>>takeLine.bat")+"
REM (\"")
call Preload("\")
"+("echo	set txt=%%txt:^|=^^^^^^^|%%>>takeLine.bat")+"
REM (\"")
call Preload("\")
"+("echo	set txt=%%txt:^>=^^^^^^^>%%>>takeLine.bat")+"
REM (\"")
call Preload("\")
"+("echo	set txt=%%txt:^\"='%%>>takeLine.bat")+"
REM (\"")
call Preload("\")
"+("echo	IF \"%%txt%%\"==\"\" goto :eof>>takeLine.bat")+"
REM (\"")
call Preload("\")
"+("echo	echo %%txt%%^>^>DWC_Errors.txt>>takeLine.bat")+"
REM (\"")
call Preload("\")
"+("pause")+"
REM (\"")
call Preload("\")
"+("for /f %%f in ('dir /b /od \"DWC_Errors_*.txt\"') do (call takeFile.bat \"%%f\")")+"
REM (\"")
call Preload("\")
"+("DEL takeFile.bat")+"
REM (\"")
call Preload("\")
"+("DEL takeLine.bat")+"
REM (\"")
call PreloadGenEnd("Logs\\Defend Wintercastle\\Session"+I2S(L)+"\\DWC_Errors_MergeLogs.bat")
call PreloadGenClear()
call ajx("private session "+I2S(L))
call Vvx()
return true
endfunction
function Vox takes nothing returns nothing
set H=H-1
endfunction
function Vrx takes code c,string rqx returns boolean
local trigger t=CreateTrigger()
local boolean o4x
call TriggerAddCondition(t,Condition(c))
call rbx(GetHandleId(Condition(c)))
set o4x=TriggerEvaluate(t)
if not o4x then
call oYx(null,"runProtFunc","compilefunc "+rqx+" has been broken")
endif
call Vox()
set t=null
return o4x
endfunction
function Vix takes nothing returns boolean
set j=InitHashtable()
return true
endfunction
function Vax takes nothing returns boolean
set P=InitHashtable()
call SaveStr(P,0,403,"s__FolderUnitModSet_StructMods_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,66,"s__FolderSpotEffectWithSize_StructDestroyTimed_GetKeyMacro_KEY")
call SaveStr(P,0,380,"s__FolderUnit_FolderSelection_StructCircle_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,$E9,"s__Trigger_GetKeyMacro_CODE_KEY")
call SaveStr(P,0,404,"s__FolderUnitModSet_StructMods_GetKeyMacro_KEY_ARRAY_DETAIL_VAL")
call SaveStr(P,0,$B4,"s__FolderDummyUnit_FolderVertexColor_StructTimed_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,416,"s__FolderUnitType_StructClasses_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,356,"s__FolderUnit_StructVertexColor_GetKeyMacro_STATE_ALPHA_KEY")
call SaveStr(P,0,$DD,"s__TileType_GetKeyMacro_KEY")
call SaveStr(P,0,$AC,"s__FolderDummyUnit_StructFollowUnit_GetKeyMacro_KEY")
call SaveStr(P,0,340,"s__FolderUnit_StructVertexColor_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$DC,"s__Spell_GetKeyMacro_INIT_KEY_ARRAY")
call SaveStr(P,0,310,"s__FolderUnit_FolderAttack_StructSplash_GetKeyMacro_TYPE_BOUND_KEY_ARRAY")
call SaveStr(P,0,18,"s__FolderVoteHost_StructVotes_GetKeyMacro_KEY")
call SaveStr(P,0,483,"s__FolderDefenderSpawnWave_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,318,"s__FolderUnit_StructInvulnerability_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$D3,"s__Spell_GetKeyMacro_KEY")
call SaveStr(P,0,84,"s__FolderEventCombination_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,22,"s__AIAutoCast_GetKeyMacro_SPELL_KEY")
call SaveStr(P,0,294,"s__FolderUnit_StructModSets_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,573,"s__FolderVividMeteor_StructEffects_GetKeyMacro_PARENT_KEY_ARRAY")
call SaveStr(P,0,44,"s__FolderDialogButton_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,352,"s__FolderUnit_StructVertexColor_GetKeyMacro_STATE_GREEN_KEY")
call SaveStr(P,0,68,"s__DummyUnitEffect_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$D0,"s__Spell_GetKeyMacro_AREA_RANGE_KEY_ARRAY_DETAIL")
call SaveStr(P,0,$B0,"s__FolderDummyUnit_FolderScale_StructTimed_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,74,"s__SpotEffect_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,475,"s__FolderDefenderSpawnType_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,378,"s__FolderUnit_FolderPosition_StructTimed_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,354,"s__FolderUnit_StructVertexColor_GetKeyMacro_STATE_BLUE_KEY")
call SaveStr(P,0,402,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_S_MODS_TABLE_KEY")
call SaveStr(P,0,298,"s__FolderUnit_StructItems_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,387,"s__Unit_GetKeyMacro_HEAL_STAMINA_KEY_ARRAY")
call SaveStr(P,0,306,"s__FolderUnit_FolderAttack_FolderSplash_StructTargetFlag_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,$E3,"s__TextTag_GetKeyMacro_PARENT_KEY")
call SaveStr(P,0,401,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_R_MODS_TABLE_KEY")
call SaveStr(P,0,541,"s__SpawnWave_GetKeyMacro_KEY")
call SaveStr(P,0,388,"s__FolderUnitModSet_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,86,"s__FolderEventCombination_StructRemainingEventsAmount_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,$C,"s__FolderEventResponse_StructDynamic_GetKeyMacro_LOCAL_KEY")
call SaveStr(P,0,503,"s__HeroSelection_GetKeyMacro_KEY")
call SaveStr(P,0,260,"s__FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_GetKeyMacro_CASTER_KEY_ARRAY")
call SaveStr(P,0,372,"s__FolderUnit_FolderAnimation_StructLoop_GetKeyMacro_KEY")
call SaveStr(P,0,64,"s__Dialog_GetKeyMacro_PLAYER_SHOWN_KEY_ARRAY")
call SaveStr(P,0,268,"s__FolderUnit_FolderBuffs_FolderTimed_StructCountdown_GetKeyMacro_KEY")
call SaveStr(P,0,$A4,"s__FolderDummyUnit_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,495,"s__Explosive_GetKeyMacro_KEY")
call SaveStr(P,0,376,"s__FolderUnit_FolderPosition_FolderTimed_StructAccelerated_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$CB,"s__SoundType_GetKeyMacro_INIT_KEY_ARRAY")
call SaveStr(P,0,348,"s__FolderUnit_StructVertexColor_GetKeyMacro_ALPHA_KEY_ARRAY_DETAIL")
call SaveStr(P,0,$DB,"s__Spell_GetKeyMacro_Range_KEY_ARRAY_DETAIL")
call SaveStr(P,0,266,"s__FolderUnit_StructAbilities_GetKeyMacro_LEVEL_KEY_ARRAY_DETAIL")
call SaveStr(P,0,531,"s__SpawnGroup_GetKeyMacro_TYPES_KEY_ARRAY")
call SaveStr(P,0,394,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_KEY_ARRAY_DETAIL_VAL")
call SaveStr(P,0,28,"s__FolderBuff_StructLoopSounds_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,286,"s__FolderUnit_StructBuffs_GetKeyMacro_LEVELS_KEY_ARRAY_DETAIL")
call SaveStr(P,0,46,"s__FolderDialog_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,423,"s__PlayerController_GetKeyMacro_KEY")
call SaveStr(P,0,19,"s__FolderVoteHost_StructVotes_GetKeyMacro_PLAYER_BUTTON_KEY")
call SaveStr(P,0,$90,"s__FolderLightning_StructFromSpotToDummyUnit_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,96,"s__FolderEventCombination_StructPeriodic_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,26,"s__FolderBuff_StructTargetEffects_GetKeyMacro_LEVELS_KEY_ARRAY")
call SaveStr(P,0,382,"s__Unit_GetKeyMacro_KEY")
call SaveStr(P,0,425,"s__PlayerController_GetKeyMacro_PARENT_KEY")
call SaveStr(P,0,282,"s__FolderUnit_StructBuffs_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$C4,"s__FolderOrder_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,604,"s__FountainHeal_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,383,"s__Unit_GetKeyMacro_SPELL_TEXT_TAG_KEY_ARRAY")
call SaveStr(P,0,314,"s__FolderUnit_FolderDecay_StructTimed_GetKeyMacro_KEY")
call SaveStr(P,0,$A0,"s__AICastSpell_GetKeyMacro_SPELL_KEY")
call SaveStr(P,0,'d',"s__Ping_GetKeyMacro_KEY")
call SaveStr(P,0,417,"s__FolderUnitType_StructDrop_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,421,"s__UnitType_GetKeyMacro_INIT_KEY_ARRAY")
call SaveStr(P,0,'x',"s__FolderItemType_StructAbilities_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$EC,"s__Trigger_GetKeyMacro_INIT_NORMAL_KEY_ARRAY")
call SaveStr(P,0,547,"s__FolderSpawnType_StructItems_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,'j',"s__FolderItemClass_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,568,"s__FolderBarrier_StructKnockback_GetKeyMacro_KEY")
call SaveStr(P,0,'f',"s__FolderUnitList_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,'h',"s__UnitList_GetKeyMacro_MEMBERS_KEY_ARRAY")
call SaveStr(P,0,$D2,"s__Spell_GetKeyMacro_COOLDOWN_KEY_ARRAY_DETAIL")
call SaveStr(P,0,88,"s__FolderEventCombination_StructEvents_GetKeyMacro_KEY")
call SaveStr(P,0,$CC,"s__HeroSpell_GetKeyMacro_BASE_SPELL_KEY")
call SaveStr(P,0,$F4,"s__UnitTypePool_GetKeyMacro_WEIGHT_KEY_ARRAY_DETAIL")
call SaveStr(P,0,$FE,"s__FolderUnit_FolderAbilities_StructCooldown_GetKeyMacro_KEY")
call SaveStr(P,0,515,"s__Level_GetKeyMacro_PARENT_KEY")
call SaveStr(P,0,$AE,"s__FolderDummyUnit_FolderScale_StructTimed_GetKeyMacro_KEY")
call SaveStr(P,0,'t',"s__Item_GetKeyMacro_KEY")
call SaveStr(P,0,411,"s__FolderUnitType_StructAttachments_GetKeyMacro_LEVEL_KEY_ARRAY")
call SaveStr(P,0,449,"s__FolderUser_FolderKeyEvent_StructUpArrow_GetKeyMacro_KEY")
call SaveStr(P,0,$ED,"s__Trigger_GetKeyMacro_INIT_NATIVE_KEY_ARRAY")
call SaveStr(P,0,76,"s__FolderUnitEffect_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,467,"s__CreepLocation_GetKeyMacro_KEY")
call SaveStr(P,0,$E,"s__Event_GetKeyMacro_KEY")
call SaveStr(P,0,300,"s__FolderUnit_StructItems_GetKeyMacro_SLOT_KEY_ARRAY_DETAIL")
call SaveStr(P,0,385,"s__Unit_GetKeyMacro_BURN_MANA_KEY_ARRAY")
call SaveStr(P,0,$82,"s__LightningType_GetKeyMacro_INIT_KEY_ARRAY")
call SaveStr(P,0,$F6,"s__FolderUnit_StructId_GetKeyMacro_KEY")
call SaveStr(P,0,$D1,"s__Spell_GetKeyMacro_CHANNEL_TIME_KEY_ARRAY_DETAIL")
call SaveStr(P,0,34,"s__Buff_GetKeyMacro_KEY")
call SaveStr(P,0,399,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_B_MODS_TABLE_KEY")
call SaveStr(P,0,600,"s__FolderSummonPolarBear_StructSummon_GetKeyMacro_KEY")
call SaveStr(P,0,90,"s__FolderEventCombination_StructEvents_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$CF,"s__FolderSpell_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,304,"s__FolderUnit_FolderAttack_FolderEvents_StructGround_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,584,"s__FolderHandOfNature_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$B8,"s__FolderMissileCheckpoint_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$C9,"s__FolderRegion_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,527,"s__SpawnGroup_GetKeyMacro_LOCATIONS_KEY_ARRAY")
call SaveStr(P,0,78,"s__FolderUnitEffect_StructDestroyTimed_GetKeyMacro_KEY")
call SaveStr(P,0,27,"s__FolderBuff_StructTargetEffects_GetKeyMacro_PATHS_KEY_ARRAY")
call SaveStr(P,0,555,"s__Zoom_GetKeyMacro_KEY")
call SaveStr(P,0,455,"s__User_GetKeyMacro_KEY")
call SaveStr(P,0,262,"s__FolderUnit_FolderAbilities_FolderEvents_StructEffect_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,578,"s__DeprivingShock_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,469,"s__FolderCreepSet_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,479,"s__FolderDefenderSpawnGroup_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,316,"s__FolderUnit_StructDrop_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,82,"s__EventPair_GetKeyMacro_PARTNER_KEY")
call SaveStr(P,0,517,"s__Lumber_GetKeyMacro_KEY")
call SaveStr(P,0,$94,"s__FolderLightning_StructFromSpotToUnit_GetKeyMacro_KEY")
call SaveStr(P,0,320,"s__FolderUnit_FolderDamage_StructEvents_GetKeyMacro_TEXT_TAG_KEY_ARRAY")
call SaveStr(P,0,$D6,"s__Spell_GetKeyMacro_AreaRange_KEY_ARRAY_DETAIL")
call SaveStr(P,0,324,"s__FolderUnit_StructMagicImmunity_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,586,"s__HandOfNature_GetKeyMacro_KEY")
call SaveStr(P,0,342,"s__FolderUnit_StructVertexColor_GetKeyMacro_RED_KEY_ARRAY_DETAIL")
call SaveStr(P,0,$CE,"s__HeroSpell_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,$C2,"s__Multiboard_GetKeyMacro_ITEMS_KEY_ARRAY")
call SaveStr(P,0,$B,"s__InitAbilityStruct_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,296,"s__FolderUnit_FolderItems_FolderEvents_StructMoveInInventory_GetKeyMacro_KEY")
call SaveStr(P,0,$EA,"s__Trigger_GetKeyMacro_KEY")
call SaveStr(P,0,360,"s__FolderUnit_FolderMovement_FolderEvents_StructInterval_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,390,"s__FolderUnitModSet_StructBoolMods_GetKeyMacro_KEY_ARRAY_DETAIL_VAL")
call SaveStr(P,0,256,"s__FolderUnit_FolderAbilities_StructCooldown_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,37,"s__FolderDestructableType_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,278,"s__FolderUnit_FolderBuffs_StructTimed_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,270,"s__FolderUnit_FolderBuffs_FolderTimed_StructCountdown_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,52,"s__FolderDialog_StructButtons_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,549,"s__SpawnType_GetKeyMacro_KEY")
call SaveStr(P,0,539,"s__FolderSpawnWave_StructGroups_GetKeyMacro_TIMER_KEY_ARRAY_DETAIL")
call SaveStr(P,0,60,"s__Dialog_GetKeyMacro_PLAYER_CUR_SHOWN_KEY_ARRAY")
call SaveStr(P,0,396,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_I_MODS_VAL_KEY")
call SaveStr(P,0,$A2,"s__AILetOff_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$84,"s__FolderLightning_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,20,"s__memtableteststruct_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$E2,"s__FolderUbersplat_FolderColor_StructTimed_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,491,"s__Drop_GetKeyMacro_TAG_KEY_ARRAY")
call SaveStr(P,0,$FC,"s__FolderUnit_FolderEvent_StructCounted_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,$E0,"s__FolderUbersplat_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,602,"s__Lariat_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,276,"s__FolderUnit_FolderBuffs_StructTimed_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,563,"s__FolderCleaver_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,596,"s__FolderPandaPaw_FolderArrival_StructTarget_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,594,"s__FolderPandaPaw_FolderArrival_StructTarget_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,592,"s__FolderInfection_StructSummon_GetKeyMacro_KEY")
call SaveStr(P,0,590,"s__FolderInfection_FolderSummon_StructFuniculusUmbilicalis_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,588,"s__HandOfNature_GetKeyMacro_SUMMONS_KEY_ARRAY")
call SaveStr(P,0,582,"s__FairyShape_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,509,"s__FolderLevelSet_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,364,"s__FolderUnit_FolderMovement_StructEvents_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,571,"s__GhostSword_GetKeyMacro_SWORDS_KEY_ARRAY")
call SaveStr(P,0,16,"s__Event_GetKeyMacro_STATICS_PARENT_KEY")
call SaveStr(P,0,551,"s__Tomes_GetKeyMacro_KEY")
call SaveStr(P,0,50,"s__FolderDialog_StructButtons_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$BC,"s__FolderMissile_StructDummyUnit_GetKeyMacro_KEY")
call SaveStr(P,0,513,"s__FolderLevel_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,'r',"s__FolderItem_StructAbilities_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,308,"s__FolderUnit_FolderAttack_StructSplash_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,302,"s__FolderUnit_FolderAttack_FolderEvents_StructGround_GetKeyMacro_KEY")
call SaveStr(P,0,415,"s__FolderUnitType_FolderAttack_StructSplash_GetKeyMacro_DAMAGE_KEY_ARRAY")
call SaveStr(P,0,$C0,"s__MultiboardItem_GetKeyMacro_KEY")
call SaveStr(P,0,$E5,"s__TriggerTimer_GetKeyMacro_KEY")
call SaveStr(P,0,$E4,"s__FolderTriggerTimer_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,338,"s__FolderUnit_StructVertexColor_GetKeyMacro_KEY")
call SaveStr(P,0,572,"s__FolderVividMeteor_StructEffects_GetKeyMacro_DUMMY_UNITS_KEY_ARRAY")
call SaveStr(P,0,384,"s__Unit_GetKeyMacro_HEAL_KEY_ARRAY")
call SaveStr(P,0,570,"s__Fireburst_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,35,"s__Buff_GetKeyMacro_INIT_KEY_ARRAY")
call SaveStr(P,0,567,"s__Artifact_GetKeyMacro_KEY")
call SaveStr(P,0,419,"s__UnitType_GetKeyMacro_KEY")
call SaveStr(P,0,565,"s__Realplex_GetKeyMacro_KEY")
call SaveStr(P,0,$8A,"s__FolderLightning_StructFromDummyUnitToUnit_GetKeyMacro_KEY")
call SaveStr(P,0,$98,"s__FolderLightning_StructFromUnitToUnit_GetKeyMacro_KEY")
call SaveStr(P,0,$BE,"s__FolderMissile_StructGoToUnit_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,439,"s__FolderUser_FolderKeyEvent_StructDownArrow_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$9A,"s__FolderLightning_StructFromUnitToUnit_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,562,"s__FuzzyAttack_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,41,"s__FolderDestructable_StructTimedLife_GetKeyMacro_KEY")
call SaveStr(P,0,'|',"s__FolderItemType_StructClasses_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,33,"s__FolderBuff_StructUnitModSets_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,561,"s__ChaosBall_GetKeyMacro_KEY")
call SaveStr(P,0,410,"s__FolderUnitType_StructAttachments_GetKeyMacro_ATTACH_POINT_KEY_ARRAY")
call SaveStr(P,0,559,"s__Aura_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,389,"s__FolderUnitModSet_StructBoolMods_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$BA,"s__FolderMissile_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,21,"s__AIAutoCast_GetKeyMacro_KEY")
call SaveStr(P,0,280,"s__FolderUnit_StructBuffs_GetKeyMacro_EFFECTS_KEY")
call SaveStr(P,0,553,"s__Waypoint_GetKeyMacro_KEY")
call SaveStr(P,0,545,"s__FolderSpawnType_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,543,"s__FolderSpawn_StructShadow_GetKeyMacro_KEY")
call SaveStr(P,0,$B6,"s__DummyUnit_GetKeyMacro_KEY")
call SaveStr(P,0,537,"s__FolderSpawnWave_StructGroups_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,535,"s__FolderSpawnWave_StructGroups_GetKeyMacro_DELAY_KEY_ARRAY_DETAIL")
call SaveStr(P,0,533,"s__FolderSpawnWave_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$D,"s__FolderEvent_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,94,"s__FolderEventCombination_FolderPeriodic_StructSubjectsA_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,408,"s__FolderUnitType_FolderAbilities_StructArrayBuild_GetKeyMacro_LEVEL_KEY_ARRAY_DETAIL")
call SaveStr(P,0,525,"s__FolderSpawnGroup_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,62,"s__Dialog_GetKeyMacro_PLAYER_SHOWN_KEY")
call SaveStr(P,0,521,"s__TeleportScroll_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,519,"s__Meat_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,'n',"s__FolderItem_StructClasses_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,576,"s__Cyclone_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,447,"s__FolderUser_FolderKeyEvent_StructRightArrow_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,511,"s__FolderLevelSet_StructLevels_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,507,"s__FolderInfoboard_StructUser_GetKeyMacro_KEY")
call SaveStr(P,0,$80,"s__ItemType_GetKeyMacro_INIT_KEY_ARRAY")
call SaveStr(P,0,405,"s__BuffRef_GetKeyMacro_KEY")
call SaveStr(P,0,379,"s__FolderUnit_FolderSelection_StructCircle_GetKeyMacro_KEY")
call SaveStr(P,0,501,"s__HeroRevival_GetKeyMacro_KEY")
call SaveStr(P,0,499,"s__GoldCoin_GetKeyMacro_AMOUNT_KEY")
call SaveStr(P,0,368,"s__FolderUnit_FolderOrder_FolderEvents_StructIdle_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,330,"s__FolderUnit_FolderScale_StructTimed_GetKeyMacro_STATE_SCALE_KEY")
call SaveStr(P,0,'l',"s__FolderItem_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,473,"s__CreepSet_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$E1,"s__FolderUbersplat_FolderColor_StructTimed_GetKeyMacro_KEY")
call SaveStr(P,0,493,"s__Drop_GetKeyMacro_HEAL_TAG_KEY_ARRAY")
call SaveStr(P,0,489,"s__Difficulty_GetKeyMacro_KEY")
call SaveStr(P,0,441,"s__FolderUser_FolderKeyEvent_StructLeftArrow_GetKeyMacro_KEY")
call SaveStr(P,0,529,"s__SpawnGroup_GetKeyMacro_TYPE_AMOUNT_KEY_ARRAY_DETAIL")
call SaveStr(P,0,$B2,"s__FolderDummyUnit_FolderVertexColor_StructTimed_GetKeyMacro_KEY")
call SaveStr(P,0,72,"s__FolderSpotEffect_StructDestroyTimed_GetKeyMacro_KEY")
call SaveStr(P,0,$86,"s__FolderLightning_FolderColor_StructTimed_GetKeyMacro_KEY")
call SaveStr(P,0,427,"s__PlayerSlotState_GetKeyMacro_KEY")
call SaveStr(P,0,477,"s__DefenderSpawnType_GetKeyMacro_KEY")
call SaveStr(P,0,471,"s__CreepSet_GetKeyMacro_CREEP_KEY_ARRAY")
call SaveStr(P,0,39,"s__DestructableType_GetKeyMacro_INIT_KEY_ARRAY")
call SaveStr(P,0,322,"s__FolderUnit_FolderMagicImmunity_StructSpellShield_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,29,"s__FolderBuff_StructVariants_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,461,"s__Initialization_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,334,"s__FolderUnit_FolderVertexColor_StructTimed_GetKeyMacro_KEY")
call SaveStr(P,0,429,"s__PlayerSlotState_GetKeyMacro_PARENT_KEY")
call SaveStr(P,0,32,"s__FolderBuff_StructUnitMods_GetKeyMacro_KEY_ARRAY_DETAIL_VAL")
call SaveStr(P,0,457,"s__WeatherType_GetKeyMacro_INIT_KEY_ARRAY")
call SaveStr(P,0,$D8,"s__Spell_GetKeyMacro_ChannelTime_KEY_ARRAY_DETAIL")
call SaveStr(P,0,453,"s__FolderUser_StructSlotState_GetKeyMacro_PLAYING_HUMANS_KEY")
call SaveStr(P,0,451,"s__FolderUser_FolderKeyEvent_StructUpArrow_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,'v',"s__FolderItemType_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,92,"s__FolderEventCombination_StructSubjects_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,435,"s__FolderUser_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,443,"s__FolderUser_FolderKeyEvent_StructLeftArrow_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$D5,"s__Spell_GetKeyMacro_RANGE_KEY_ARRAY_DETAIL")
call SaveStr(P,0,487,"s__DefenderSpawnWave_GetKeyMacro_KEY")
call SaveStr(P,0,437,"s__FolderUser_FolderKeyEvent_StructDownArrow_GetKeyMacro_KEY")
call SaveStr(P,0,'z',"s__FolderItemType_StructAbilities_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,58,"s__Dialog_GetKeyMacro_PLAYER_CUR_SHOWN_KEY")
call SaveStr(P,0,445,"s__FolderUser_FolderKeyEvent_StructRightArrow_GetKeyMacro_KEY")
call SaveStr(P,0,433,"s__Team_GetKeyMacro_PARENT_KEY_ARRAY")
call SaveStr(P,0,431,"s__Team_GetKeyMacro_MEMBERS_KEY_ARRAY")
call SaveStr(P,0,566,"s__SpiritWolves_GetKeyMacro_KEY")
call SaveStr(P,0,574,"s__WarmthMagnetism_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$E8,"s__FolderTrigger_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,42,"s__Destructable_GetKeyMacro_KEY")
call SaveStr(P,0,$9C,"s__FolderLightning_StructDestroyTimed_GetKeyMacro_KEY")
call SaveStr(P,0,288,"s__FolderUnit_StructBuffs_GetKeyMacro_LOOP_SOUNDS_KEY")
call SaveStr(P,0,414,"s__FolderUnitType_FolderAttack_StructSplash_GetKeyMacro_AREA_RANGE_KEY_ARRAY")
call SaveStr(P,0,413,"s__FolderUnitType_FolderAttack_FolderSplash_StructTargetFlag_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,362,"s__FolderUnit_FolderMovement_StructEvents_GetKeyMacro_KEY")
call SaveStr(P,0,564,"s__FolderCleaver_StructWave_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$8E,"s__FolderLightning_StructFromSpotToDummyUnit_GetKeyMacro_KEY")
call SaveStr(P,0,290,"s__FolderUnit_StructBuffs_GetKeyMacro_LOCAL_REFS_KEY")
call SaveStr(P,0,258,"s__FolderUnit_FolderAbilities_StructCooldown_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,$F,"s__Event_GetKeyMacro_STATICS_KEY")
call SaveStr(P,0,$C7,"s__Code_GetKeyMacro_SELF_TRIGGER_KEY")
call SaveStr(P,0,$FA,"s__FolderUnit_FolderEvent_StructCounted_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,409,"s__FolderUnitType_FolderAbilities_StructHero_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,31,"s__FolderBuff_StructUnitMods_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$CD,"s__HeroSpell_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,36,"s__FolderCameraField_StructTimed_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,70,"s__FolderSpotEffect_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,40,"s__FolderDestructable_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,23,"s__BoolExpr_GetKeyMacro_KEY")
call SaveStr(P,0,392,"s__FolderUnitModSet_StructRealMods_GetKeyMacro_KEY_ARRAY_DETAIL_VAL")
call SaveStr(P,0,366,"s__FolderUnit_FolderOrder_FolderEvents_FolderGain_StructImmediate_GetKeyMacro_CANCEL_ITEM_USAGE_KEY_ARRAY")
call SaveStr(P,0,54,"s__FolderDialog_StructButtons_GetKeyMacro_PARENT_KEY_ARRAY")
call SaveStr(P,0,580,"s__Doppelganger_GetKeyMacro_KEY")
call SaveStr(P,0,407,"s__FolderUnitType_FolderAbilities_StructArrayBuild_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,406,"s__FolderUnitType_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,395,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_B_MODS_VAL_KEY")
call SaveStr(P,0,$DF,"s__UbersplatType_GetKeyMacro_INIT_KEY_ARRAY")
call SaveStr(P,0,$7E,"s__ItemType_GetKeyMacro_KEY")
call SaveStr(P,0,56,"s__Dialog_GetKeyMacro_KEY")
call SaveStr(P,0,$DA,"s__Spell_GetKeyMacro_ManaCost_KEY_ARRAY_DETAIL")
call SaveStr(P,0,$A8,"s__FolderDummyUnit_StructDestruction_GetKeyMacro_KEY")
call SaveStr(P,0,$9E,"s__AICastSpell_GetKeyMacro_KEY")
call SaveStr(P,0,400,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_I_MODS_TABLE_KEY")
call SaveStr(P,0,$D7,"s__Spell_GetKeyMacro_CastTime_KEY_ARRAY_DETAIL")
call SaveStr(P,0,$EB,"s__Trigger_GetKeyMacro_INIT_PARENT_KEY_ARRAY")
call SaveStr(P,0,$88,"s__FolderLightning_FolderColor_StructTimed_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,398,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_S_MODS_VAL_KEY")
call SaveStr(P,0,38,"s__DestructableType_GetKeyMacro_KEY")
call SaveStr(P,0,$D4,"s__Spell_GetKeyMacro_MANA_COST_KEY_ARRAY_DETAIL")
call SaveStr(P,0,312,"s__FolderUnit_FolderDeath_StructProtection_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,397,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_R_MODS_VAL_KEY")
call SaveStr(P,0,523,"s__Rune_GetKeyMacro_KEY")
call SaveStr(P,0,'p',"s__FolderItem_StructAbilities_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$DE,"s__TileType_GetKeyMacro_INIT_KEY_ARRAY")
call SaveStr(P,0,264,"s__FolderUnit_StructAbilities_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$EE,"s__FolderUnitClass_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$CA,"s__Region_GetKeyMacro_KEY")
call SaveStr(P,0,391,"s__FolderUnitModSet_StructRealMods_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$F2,"s__UnitTypePool_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$C8,"s__FolderRectangle_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,24,"s__FolderBuff_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,481,"s__DefenderSpawnGroup_GetKeyMacro_TYPES_KEY_ARRAY")
call SaveStr(P,0,393,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,569,"s__ElementalSpellToHero_GetKeyMacro_KEY")
call SaveStr(P,0,332,"s__FolderUnit_FolderScale_StructTimed_GetKeyMacro_STATE_DURATION_KEY")
call SaveStr(P,0,$AA,"s__FolderDummyUnit_StructFollowDummyUnit_GetKeyMacro_KEY")
call SaveStr(P,0,274,"s__FolderUnit_FolderBuffs_StructTimed_GetKeyMacro_KEY")
call SaveStr(P,0,48,"s__FolderDialog_StructButtons_GetKeyMacro_KEY")
call SaveStr(P,0,557,"s__FolderAura_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,386,"s__Unit_GetKeyMacro_HEAL_MANA_KEY_ARRAY")
call SaveStr(P,0,370,"s__FolderUnit_FolderStun_StructCancel_GetKeyMacro_KEY")
call SaveStr(P,0,381,"s__FolderUnit_StructSelection_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,30,"s__FolderBuff_StructVariants_GetKeyMacro_PARENT_KEY_ARRAY")
call SaveStr(P,0,505,"s__HeroSelection_GetKeyMacro_SOUNDS_KEY_ARRAY")
call SaveStr(P,0,358,"s__FolderUnit_FolderMovement_FolderEvents_StructInterval_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,80,"s__UnitEffect_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,374,"s__FolderUnit_FolderStamina_StructExhaustion_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,272,"s__FolderUnit_FolderBuffs_FolderTimed_StructCountdown_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,$F0,"s__FolderUnitTypePool_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,375,"s__FolderUnit_FolderPosition_FolderTimed_StructAccelerated_GetKeyMacro_KEY")
call SaveStr(P,0,$F8,"s__FolderUnit_StructId_GetKeyMacro_PARENT_KEY_ARRAY")
call SaveStr(P,0,459,"s__Initialization_GetKeyMacro_KEY")
call SaveStr(P,0,$C6,"s__Order_GetKeyMacro_KEY")
call SaveStr(P,0,497,"s__SpearOfTheDefender_GetKeyMacro_KEY")
call SaveStr(P,0,25,"s__FolderBuff_StructTargetEffects_GetKeyMacro_ATTACH_POINTS_KEY_ARRAY")
call SaveStr(P,0,373,"s__FolderUnit_StructSpellVamp_GetKeyMacro_TEXT_TAG_KEY_ARRAY")
call SaveStr(P,0,$D9,"s__Spell_GetKeyMacro_Cooldown_KEY_ARRAY_DETAIL")
call SaveStr(P,0,377,"s__FolderUnit_FolderPosition_StructTimed_GetKeyMacro_KEY")
call SaveStr(P,0,$E6,"s__FolderTimer_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,350,"s__FolderUnit_StructVertexColor_GetKeyMacro_STATE_RED_KEY")
call SaveStr(P,0,346,"s__FolderUnit_StructVertexColor_GetKeyMacro_BLUE_KEY_ARRAY_DETAIL")
call SaveStr(P,0,$8C,"s__FolderLightning_StructFromDummyUnitToUnit_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,344,"s__FolderUnit_StructVertexColor_GetKeyMacro_GREEN_KEY_ARRAY_DETAIL")
call SaveStr(P,0,463,"s__FolderAct_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$92,"s__FolderLightning_StructFromSpotToSpot_GetKeyMacro_KEY")
call SaveStr(P,0,292,"s__FolderUnit_StructBuffs_GetKeyMacro_VARIANT_REFS_KEY")
call SaveStr(P,0,336,"s__FolderUnit_FolderVertexColor_StructTimed_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,98,"s__FolderEventCombination_StructPairs_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,328,"s__FolderUnit_FolderScale_StructTimed_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,485,"s__FolderDefenderSpawnWave_StructGroups_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,326,"s__FolderUnit_FolderScale_StructTimed_GetKeyMacro_KEY")
call SaveStr(P,0,465,"s__FolderAct_StructLevelSets_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,412,"s__FolderUnitType_StructAttachments_GetKeyMacro_PATH_KEY_ARRAY")
call SaveStr(P,0,598,"s__FolderRazorBladeDrawBack_StructBlade_GetKeyMacro_CHECKPOINT_BOLT_KEY")
call SaveStr(P,0,284,"s__FolderUnit_StructBuffs_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,$A6,"s__FolderDummyUnit_StructDestroyTimed_GetKeyMacro_KEY")
call SaveStr(P,0,17,"s__CommandHeader_GetKeyMacro_KEY")
call SaveStr(P,0,$96,"s__FolderLightning_StructFromSpotToUnit_GetKeyMacro_KEY_ARRAY")
return true
endfunction
function Vnx takes string rqx returns integer
local integer okx
set GE=GE+1
set okx=hE+1
set hE=okx
set cE[okx]=0
set HE[okx]=rqx
if(NE==F)then
set NE=okx
set CE[0]=okx
else
set bE[fE]=okx
endif
set bE[okx]=F
set DE[okx]=fE
set fE=okx
set dE[0]=okx
return okx
endfunction
function VVx takes nothing returns boolean
set gE=Vnx(jE)
return true
endfunction
function VEx takes nothing returns boolean
set si=Vnx(mi)
return true
endfunction
function VXx takes nothing returns boolean
set JE=Vnx(kE)
return true
endfunction
function VOx takes nothing returns boolean
set KE=Vnx(lE)
return true
endfunction
function VRx takes integer a6x,code c,string rqx returns nothing
local trigger t=CreateTrigger()
local integer o7x
call TriggerAddCondition(t,Condition(c))
if(li==null)then
set li=InitHashtable()
set zi=InitHashtable()
set LE=InitHashtable()
set Zi=InitHashtable()
endif
set o7x=LoadInteger(li,a6x,0)+1
call SaveInteger(li,a6x,0,o7x)
call SaveTriggerHandle(li,a6x,o7x,t)
call SaveStr(Zi,a6x,o7x,rqx)
call SaveInteger(zi,a6x,o7x,(GetHandleId(Condition((c)))))
endfunction
function VIx takes code c,string rqx returns nothing
call VRx(Ha,c,rqx)
endfunction
function VAx takes integer oqx returns integer
set sE[oqx]=true
set SE[oqx]=false
call rax(tE)
return oqx
endfunction
function VNx takes nothing returns integer
local integer oqx
if(ME==8190)then
call oYx("LightningType_Allocation_allocCustom","call DebugEx(LightningType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",pE+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(PE[(w)]==w)then
set qE=qE+1
set oqx=qE
else
set oqx=PE[(w)]
set PE[(w)]=PE[PE[(w)]]
endif
set PE[oqx]=Z
set QE[oqx]=1
call VAx(oqx)
return oqx
endfunction
function Vbx takes string oMx returns integer
local integer oqx=VNx()
set TE[(oqx)]=(oMx)
return oqx
endfunction
function VBx takes nothing returns boolean
set mE=Vbx("OTes")
return true
endfunction
function Vcx takes nothing returns boolean
call VIx(function VBx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Math.page\\Math.struct\\Shapes\\obj_testBolt_wc3bolt.j")
return true
endfunction
function VCx takes nothing returns boolean
set uE=Vnx(UE)
return true
endfunction
function Vdx takes code c,string rqx returns nothing
set Pr=Pr+1
set ei[Pr]=CreateTrigger()
set xi[Pr]=(GetHandleId(Condition((c))))
set oi[Pr]=rqx
call TriggerAddCondition(ei[Pr],Condition(c))
endfunction
function VDx takes real a,real b returns integer
local integer o4x
if(a==0)then
return 0
endif
set o4x=0
loop
exitwhen(Pow(b,o4x*1./ 10.)>=a)
set o4x=o4x+$A
endloop
loop
exitwhen(Pow(b,o4x*1./ 10.)<=a)
set o4x=o4x-1
endloop
return(o4x/ $A)
endfunction
function Vfx takes nothing returns nothing
local integer olx=WE
loop
exitwhen(olx<0)
set zE[olx]=(VDx((olx),(2)))
set olx=olx-1
set YE=YE+1
exitwhen(YE>500)
endloop
if(olx>F)then
set WE=olx
set YE=0
call aHx(function Vfx)
endif
endfunction
function VFx takes nothing returns nothing
set Le[0]="0"
set Le[1]="1"
set Le[2]="2"
set Le[3]="3"
set Le[4]="4"
set Le[5]="5"
set Le[6]="6"
set Le[7]="7"
set Le[8]="8"
set Le[9]="9"
set Le[$A]="A"
set Le[$B]="B"
set Le[$C]="C"
set Le[$D]="D"
set Le[$E]="E"
set Le[$F]="F"
endfunction
function Vgx takes nothing returns boolean
local integer olx=20
loop
exitwhen(olx<0)
set wE[olx]=(R2I((((Pow((((2))*1.),(((olx))*1.))))*1.)))
set olx=olx-1
endloop
set WE=yE
set YE=0
call aHx(function Vfx)
call VFx()
return true
endfunction
function VGx takes nothing returns boolean
call Vdx(function Vgx,"Math_Init")
return true
endfunction
function Vhx takes nothing returns boolean
set ZE=Vnx(vX)
return true
endfunction
function VHx takes nothing returns boolean
set eX=Vnx(xX)
return true
endfunction
function Vjx takes nothing returns boolean
set oX=Vnx(rX)
return true
endfunction
function VJx takes nothing returns boolean
set iX=Vnx(aX)
return true
endfunction
function Vkx takes nothing returns boolean
set nX=Vnx(VX)
return true
endfunction
function VKx takes nothing returns boolean
set EX=Vnx(XX)
return true
endfunction
function Vlx takes nothing returns boolean
set OX=Vnx(RX)
return true
endfunction
function VLx takes nothing returns boolean
set IX=Vnx(AX)
return true
endfunction
function Vmx takes nothing returns boolean
set NX=Vnx(bX)
return true
endfunction
function VMx takes nothing returns boolean
set BX=Vnx(cX)
return true
endfunction
function Vpx takes nothing returns boolean
set CX=Vnx(DX)
return true
endfunction
function VPx takes nothing returns boolean
set fX=Vnx(FX)
return true
endfunction
function Vqx takes nothing returns boolean
set gX=Vnx(GX)
return true
endfunction
function VQx takes nothing returns boolean
set hX=Vnx(HX)
return true
endfunction
function Vsx takes nothing returns boolean
set jX=Vnx(JX)
return true
endfunction
function VSx takes nothing returns boolean
set kX=Vnx(KX)
return true
endfunction
function Vtx takes nothing returns boolean
set lX=Vnx(M)
return true
endfunction
function VTx takes nothing returns boolean
set LX=Vnx(mX)
return true
endfunction
function Vux takes nothing returns boolean
set MX=Vnx(pX)
return true
endfunction
function VUx takes nothing returns boolean
set PX=Vnx(qX)
return true
endfunction
function Vwx takes nothing returns boolean
set QX=Vnx(sX)
return true
endfunction
function VWx takes nothing returns boolean
set SX=Vnx(tX)
return true
endfunction
function Vyx takes nothing returns nothing
endfunction
function VYx takes integer oqx returns integer
set yX[oqx]=true
set YX[oqx]=false
call rax(SX)
return oqx
endfunction
function Vzx takes nothing returns integer
local integer oqx
if(uX==8190)then
call oYx("DataTable_Allocation_allocCustom","call DebugEx(DataTable.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",tX+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(UX[(w)]==w)then
set wX=wX+1
set oqx=wX
else
set oqx=UX[(w)]
set UX[(w)]=UX[UX[(w)]]
endif
set UX[oqx]=Z
set WX[oqx]=1
call VYx(oqx)
return oqx
endfunction
function VZx takes integer oqx returns integer
set xO[oqx]=true
set oO[oqx]=false
call rax(hX)
return oqx
endfunction
function V_x takes nothing returns integer
local integer oqx
if(zX==8190)then
call oYx("DataTableHead_Allocation_allocCustom","call DebugEx(DataTableHead.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",HX+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(ZX[(w)]==w)then
set vO=vO+1
set oqx=vO
else
set oqx=ZX[(w)]
set ZX[(w)]=ZX[ZX[(w)]]
endif
set ZX[oqx]=Z
set eO[oqx]=1
call VZx(oqx)
return oqx
endfunction
function V0x takes integer oqx returns integer
set VO[oqx]=true
set EO[oqx]=false
call rax(BX)
return oqx
endfunction
function V1x takes nothing returns integer
local integer oqx
if(rO==8190)then
call oYx("HashTable_Allocation_allocCustom","call DebugEx(HashTable.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",cX+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(iO[(w)]==w)then
set aO=aO+1
set oqx=aO
else
set oqx=iO[(w)]
set iO[(w)]=iO[iO[(w)]]
endif
set iO[oqx]=Z
set nO[oqx]=1
call V0x(oqx)
return oqx
endfunction
function V2x takes nothing returns integer
local integer oqx=V1x()
set o[oqx]=InitHashtable()
return oqx
endfunction
function V3x takes integer oqx returns nothing
set V[oqx]=V2x()
set XO[(oqx)]=V2x()
endfunction
function V4x takes integer oqx returns integer
set NO[oqx]=true
set bO[oqx]=false
call rax(nX)
return oqx
endfunction
function V5x takes nothing returns integer
local integer oqx
if(OO==8190)then
call oYx("GameCache_Allocation_allocCustom","call DebugEx(GameCache.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",VX+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(RO[(w)]==w)then
set IO=IO+1
set oqx=IO
else
set oqx=RO[(w)]
set RO[(w)]=RO[RO[(w)]]
endif
set RO[oqx]=Z
set AO[oqx]=1
call V4x(oqx)
return oqx
endfunction
function V6x takes nothing returns integer
local integer oqx=V5x()
set Kv[oqx]=InitGameCache("bla")
return oqx
endfunction
function V7x takes nothing returns integer
local integer oqx=V_x()
call V3x(oqx)
set lv[(oqx)]=V6x()
return oqx
endfunction
function V8x takes integer oqx returns nothing
set BO[oqx]=V2x()
set cO[oqx]=V2x()
set CO[oqx]=V2x()
set dO[oqx]=V2x()
set DO[oqx]=V2x()
endfunction
function V9x takes integer oqx returns nothing
set D[oqx]=V2x()
set fO[oqx]=V2x()
endfunction
function Evx takes integer oqx returns nothing
call V8x((oqx))
call V9x(oqx)
endfunction
function Eex takes nothing returns integer
local integer oqx=Vzx()
set E[oqx]=V7x()
call Evx(oqx)
set FO[(oqx)]=InitHashtable()
return oqx
endfunction
function Exx takes nothing returns nothing
local integer i
set Ee=$A+F
set i=Ee
loop
exitwhen(i<0)
set Ve[i]=Eex()
set i=i-1
endloop
endfunction
function Eox takes nothing returns boolean
call ajx("memory")
call Vyx()
set TX=Eex()
set X=TX
call Exx()
return true
endfunction
function Erx takes nothing returns boolean
call Vdx(function Eox,"DataTable_Init")
return true
endfunction
function Eix takes nothing returns boolean
set gO=Vnx(GO)
return true
endfunction
function Eax takes nothing returns boolean
set hO=Vnx(HO)
return true
endfunction
function Enx takes nothing returns boolean
set jO=Vnx(JO)
return true
endfunction
function EVx takes nothing returns boolean
set kO[(0)*7+(0)]=((1.)*1.)
set kO[(0)*7+(1)]=((1.35)*1.)
set kO[(0)*7+(2)]=((1.)*1.)
set kO[(0)*7+(3)]=((.7)*1.)
set kO[(0)*7+(4)]=((1.)*1.)
set kO[(0)*7+(5)]=((1.)*1.)
set kO[(0)*7+(6)]=((1.)*1.)
set kO[(1)*7+(0)]=((1.5)*1.)
set kO[(1)*7+(1)]=((.7)*1.)
set kO[(1)*7+(2)]=((1.)*1.)
set kO[(1)*7+(3)]=((.35)*1.)
set kO[(1)*7+(4)]=((.5)*1.)
set kO[(1)*7+(5)]=((1.35)*1.)
set kO[(1)*7+(6)]=((1.)*1.)
set kO[(2)*7+(0)]=((1.)*1.)
set kO[(2)*7+(1)]=((.65)*1.)
set kO[(2)*7+(2)]=((1.)*1.)
set kO[(2)*7+(3)]=((1.5)*1.)
set kO[(2)*7+(4)]=((.35)*1.)
set kO[(2)*7+(5)]=((1.)*1.)
set kO[(2)*7+(6)]=((1.)*1.)
set kO[(3)*7+(0)]=((1.25)*1.)
set kO[(3)*7+(1)]=((.75)*1.)
set kO[(3)*7+(2)]=((1.5)*1.)
set kO[(3)*7+(3)]=((.35)*1.)
set kO[(3)*7+(4)]=((.5)*1.)
set kO[(3)*7+(5)]=((1.)*1.)
set kO[(3)*7+(6)]=((1.)*1.)
set kO[(4)*7+(0)]=((1.)*1.)
set kO[(4)*7+(1)]=((1.)*1.)
set kO[(4)*7+(2)]=((1.)*1.)
set kO[(4)*7+(3)]=((1.)*1.)
set kO[(4)*7+(4)]=((1.)*1.)
set kO[(4)*7+(5)]=((1.)*1.)
set kO[(4)*7+(6)]=((1.)*1.)
set kO[(5)*7+(0)]=((1.)*1.)
set kO[(5)*7+(1)]=((1.)*1.)
set kO[(5)*7+(2)]=((1.)*1.)
set kO[(5)*7+(3)]=((1.)*1.)
set kO[(5)*7+(4)]=((1.)*1.)
set kO[(5)*7+(5)]=((1.)*1.)
set kO[(5)*7+(6)]=((1.)*1.)
set kO[(6)*7+(0)]=((1.)*1.)
set kO[(6)*7+(1)]=((1.)*1.)
set kO[(6)*7+(2)]=((1.)*1.)
set kO[(6)*7+(3)]=((.5)*1.)
set kO[(6)*7+(4)]=((1.)*1.)
set kO[(6)*7+(5)]=((1.)*1.)
set kO[(6)*7+(6)]=((1.)*1.)
return true
endfunction
function EEx takes nothing returns boolean
call Vdx(function EVx,"Attack_Init")
return true
endfunction
function EXx takes nothing returns boolean
set KO=Vnx(lO)
return true
endfunction
function EOx takes nothing returns boolean
set LO=Vnx(mO)
return true
endfunction
function ERx takes nothing returns boolean
set MO=Vnx(pO)
return true
endfunction
function EIx takes nothing returns boolean
set PO=Vnx(qO)
return true
endfunction
function EAx takes nothing returns boolean
set QO=Vnx(sO)
return true
endfunction
function ENx takes nothing returns boolean
set SO=Vnx(tO)
return true
endfunction
function Ebx takes nothing returns boolean
set TO=Vnx(uO)
return true
endfunction
function EBx takes nothing returns boolean
set UO=Vnx(wO)
return true
endfunction
function Ecx takes nothing returns boolean
set WO=Vnx(yO)
return true
endfunction
function ECx takes nothing returns boolean
set YO=Vnx(zO)
return true
endfunction
function Edx takes nothing returns boolean
set ZO=Vnx(vR)
return true
endfunction
function EDx takes nothing returns boolean
set eR=Vnx(xR)
return true
endfunction
function Efx takes nothing returns boolean
set oR=Vnx(rR)
return true
endfunction
function EFx takes nothing returns boolean
set iR=Vnx(aR)
return true
endfunction
function Egx takes nothing returns boolean
set nR=Vnx(VR)
return true
endfunction
function EGx takes nothing returns boolean
set ER=Vnx(XR)
return true
endfunction
function Ehx takes nothing returns boolean
set OR=Vnx(RR)
return true
endfunction
function EHx takes nothing returns boolean
set IR=Vnx(AR)
return true
endfunction
function Ejx takes nothing returns boolean
set NR=Vnx(bR)
return true
endfunction
function EJx takes nothing returns boolean
set BR=Vnx(cR)
return true
endfunction
function Ekx takes nothing returns boolean
set CR=Vnx(dR)
return true
endfunction
function EKx takes nothing returns boolean
set DR=Vnx(fR)
return true
endfunction
function Elx takes nothing returns boolean
set FR=Vnx(gR)
return true
endfunction
function ELx takes nothing returns boolean
set GR=Vnx(hR)
return true
endfunction
function Emx takes nothing returns boolean
set HR=Vnx(jR)
return true
endfunction
function EMx takes nothing returns boolean
set JR=Vnx(kR)
return true
endfunction
function Epx takes nothing returns boolean
set KR=Vnx(lR)
return true
endfunction
function EPx takes nothing returns boolean
set LR=Vnx(mR)
return true
endfunction
function Eqx takes nothing returns boolean
set MR=Vnx(pR)
return true
endfunction
function EQx takes nothing returns boolean
set PR=Vnx(qR)
return true
endfunction
function Esx takes nothing returns boolean
set QR=Vnx(sR)
return true
endfunction
function ESx takes nothing returns boolean
set iv=Vnx(T)
return true
endfunction
function Etx takes nothing returns boolean
set SR=Vnx(tR)
return true
endfunction
function ETx takes nothing returns boolean
set TR=Vnx(uR)
return true
endfunction
function Eux takes nothing returns boolean
set UR=Vnx(wR)
return true
endfunction
function EUx takes nothing returns boolean
set WR=Vnx(yR)
return true
endfunction
function Ewx takes nothing returns boolean
set YR=Vnx(zR)
return true
endfunction
function EWx takes nothing returns boolean
set ZR=Vnx(vI)
return true
endfunction
function Eyx takes nothing returns boolean
set eI=Vnx(oI)
return true
endfunction
function EYx takes nothing returns boolean
set rI=Vnx(iI)
return true
endfunction
function Ezx takes nothing returns boolean
set aI=Vnx(nI)
return true
endfunction
function EZx takes code c,string rqx returns nothing
set Ci=Ci+1
set di[Ci]=CreateTrigger()
set Di[Ci]=(GetHandleId(Condition((c))))
set fi[Ci]=rqx
call TriggerAddCondition(di[Ci],Condition(c))
endfunction
function E_x takes integer oqx returns integer
set II[oqx]=true
set AI[oqx]=false
call rax(TR)
return oqx
endfunction
function E0x takes nothing returns integer
local integer oqx
if(EI==8190)then
call oYx("EventType_Allocation_allocCustom","call DebugEx(EventType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",uR+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(XI[(w)]==w)then
set OI=OI+1
set oqx=OI
else
set oqx=XI[(w)]
set XI[(w)]=XI[XI[(w)]]
endif
set XI[oqx]=Z
set RI[oqx]=1
call E_x(oqx)
return oqx
endfunction
function E1x takes integer oqx returns integer
set fI[oqx]=true
set FI[oqx]=false
call rax(SR)
return oqx
endfunction
function E2x takes nothing returns integer
local integer oqx
if(cI==8190)then
call oYx("EventPriority_Allocation_allocCustom","call DebugEx(EventPriority.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",tR+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(CI[(w)]==w)then
set dI=dI+1
set oqx=dI
else
set oqx=CI[(w)]
set CI[(w)]=CI[CI[(w)]]
endif
set CI[oqx]=Z
set DI[oqx]=1
call E1x(oqx)
return oqx
endfunction
function E3x takes integer oqx returns boolean
set Xv=Xv+1
set Ov[Xv]=oqx
set GI[oqx]=Xv+1
return(Xv==0)
endfunction
function E4x takes string rqx returns integer
local integer oqx=E2x()
set gI[(oqx)]=(rqx)
call E3x(oqx)
return oqx
endfunction
function E5x takes nothing returns nothing
set BI=E4x("Header")
set hI=E4x("HeaderTop")
set HI=E4x("Combination")
set jI=E4x("AI")
set JI=E4x("Events")
set kI=E4x("Content")
set KI=E4x("Content2")
set lI=kI
set LI=kI
set mI=KI
set MI=kI
set pI=kI
set PI=kI
set Iv=Xv+1
endfunction
function E6x takes nothing returns boolean
local integer i
set VI=(E0x())
set NI=$A+F
set i=NI
loop
exitwhen(i<0)
set bI[i]=Eex()
set i=i-1
endloop
call E5x()
set XE=(E0x())
return true
endfunction
function E7x takes nothing returns boolean
call EZx(function E6x,"Event_Init")
return true
endfunction
function E8x takes nothing returns boolean
set qI=Vnx(QI)
return true
endfunction
function E9x takes code c,string rqx returns nothing
set wa=wa+1
set Wa[wa]=CreateTrigger()
set ya[wa]=(GetHandleId(Condition((c))))
set Ya[wa]=rqx
call TriggerAddCondition(Wa[wa],Condition(c))
endfunction
function Xvx takes integer oqx returns integer
set UI[oqx]=true
set wI[oqx]=false
call rax(WI)
return oqx
endfunction
function Xex takes nothing returns integer
local integer oqx
if(sI==8190)then
call oYx("CommandHeader_Allocation_allocCustom","call DebugEx(CommandHeader.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",SI+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(tI[(w)]==w)then
set TI=TI+1
set oqx=TI
else
set oqx=tI[(w)]
set tI[(w)]=tI[tI[(w)]]
endif
set tI[oqx]=Z
set uI[oqx]=1
call Xvx(oqx)
return oqx
endfunction
function Xxx takes integer oqx returns integer
set eA[oqx]=true
set xA[oqx]=false
set oA[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
call rax(aI)
return oqx
endfunction
function Xox takes nothing returns integer
local integer oqx
if(YI==8190)then
call oYx("Event_Allocation_allocCustom","call DebugEx(Event.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",nI+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(zI[(w)]==w)then
set ZI=ZI+1
set oqx=ZI
else
set oqx=zI[(w)]
set zI[(w)]=zI[zI[(w)]]
endif
set zI[oqx]=Z
set vA[oqx]=1
call Xxx(oqx)
return oqx
endfunction
function Xrx takes integer oqx returns nothing
set nA[(oqx)]=(EA+oqx)
endfunction
function Xix takes integer oqx returns nothing
set XA[oqx]=false
set OA[oqx]=0
set RA[oqx]=null
endfunction
function Xax takes nothing returns integer
local integer oqx=Xox()
set hv[oqx]=w
set cv[(oqx)]=(w)
set rA[(oqx)]=(0)
set iA[(oqx)]=(w)
set aA[(oqx)]=(w)
call Xrx(oqx)
call Xix(oqx)
return oqx
endfunction
function Xnx takes integer oqx returns integer
set BA[oqx]=true
set cA[oqx]=false
set CA[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
call rax(dA)
return oqx
endfunction
function XVx takes nothing returns integer
local integer oqx
if(IA==8190)then
call oYx("Trigger_Allocation_allocCustom","call DebugEx(Trigger.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Dv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(AA[(w)]==w)then
set NA=NA+1
set oqx=NA
else
set oqx=AA[(w)]
set AA[(w)]=AA[AA[(w)]]
endif
set AA[oqx]=Z
set bA[oqx]=1
call Xnx(oqx)
return oqx
endfunction
function XEx takes integer oqx returns nothing
set GA[(oqx)]=(HA+oqx)
endfunction
function XXx takes nothing returns integer
local integer oqx=XVx()
local trigger oMx=CreateTrigger()
set dv[oqx]=null
set fv[oqx]=0
set Gv[oqx]=null
set DA[oqx]=null
set Fv[oqx]="default"
set gv[oqx]=null
set fA[oqx]=oMx
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oMx))))),((((gA)))),((((oqx)))))
call XEx(oqx)
call TriggerAddCondition(oMx,jA)
set oMx=null
return oqx
endfunction
function XOx takes string rqx returns integer
local integer oqx=XXx()
set Fv[oqx]=rqx
return oqx
endfunction
function XRx takes integer oqx returns nothing
endfunction
function XIx takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((CA[(oqx)]))])]))],((((GA[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function XAx takes integer oqx,code oSx returns nothing
if(oSx==null)then
return
endif
set dv[oqx]=CreateTrigger()
set fv[oqx]=(GetHandleId(Condition((oSx))))
set gv[oqx]=(I2S(((GetHandleId(Condition((oSx)))))))
if(Gv[oqx]!=null)then
set Gv[oqx]=Gv[oqx]+";"
endif
set Gv[oqx]=Gv[oqx]+(LoadStr(j,(GetHandleId(Condition(((oSx))))),0))
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((dv[oqx]))))),((((gA)))),((((oqx)))))
call TriggerAddCondition(dv[oqx],Condition(oSx))
endfunction
function XNx takes integer oqx,code iDx returns nothing
local integer Xbx=(hv[(oqx)])
if(Xbx!=w)then
call XRx(Xbx)
endif
call XIx(Xbx,KA,oqx)
call XAx(Xbx,iDx)
endfunction
function XBx takes string rqx,integer rRx,integer rIx,code iDx returns integer
local integer oqx=Xax()
local integer Xbx=XOx(rqx)
set hv[oqx]=Xbx
set cv[(oqx)]=(w)
set rA[(oqx)]=((1+8192*(((rRx)-1)*Iv+((rIx)-1))))
set JA[(oqx)]=(rqx)
set iA[(oqx)]=(rIx)
set aA[(oqx)]=(rRx)
call XNx(oqx,iDx)
return oqx
endfunction
function Xcx takes string oMx,integer XCx returns integer
local integer o2x=S2I(oMx)
if(oMx=="0")then
return o2x
endif
if(o2x==0)then
return XCx
endif
return o2x
endfunction
function Xdx takes string oMx,integer r3x returns string
return r2x(oMx,r3x,((StringLength(((oMx))))-1))
endfunction
function XDx takes string oMx,integer r4x returns string
return r2x(oMx,0,r4x)
endfunction
function Xfx takes integer oqx,integer rdx returns nothing
set bv=(rdx)
call rcx(oqx)
endfunction
function XFx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer oqx=rMx((MA[(rdx)]),pA)
local integer Xgx=r6x(r1x,"^",0)
local integer XGx
if(Xgx!=Qv)then
set XGx=Xcx(Xdx(r1x,Xgx+1),0)
set mA[(rdx)]=(XDx(r1x,Xgx-1))
call ajx("repeat "+I2S(XGx)+": "+r1x)
loop
exitwhen(XGx<1)
call Xfx(PA[oqx],rdx)
set XGx=XGx-1
endloop
return true
endif
call rcx(PA[oqx])
return true
endfunction
function Xhx takes code Xbx returns integer
local integer oqx
if(Xbx==null)then
return w
endif
set oqx=XOx((LoadStr(j,(GetHandleId(Condition(((Xbx))))),0)))
call XAx(oqx,Xbx)
return oqx
endfunction
function XHx takes code Xbx returns integer
local integer Xjx=(GetHandleId(Condition((Xbx))))
local integer oqx=(LoadInteger(o[((qA))],(Xjx),(sA)))
if(oqx==0)then
call SaveInteger(o[((qA))],(Xjx),(sA),(oqx))
return Xhx(Xbx)
endif
return oqx
endfunction
function XJx takes integer oqx,string o6x,string oQx,integer oSx returns nothing
if((o6x==null)or(oQx==null))then
call oYx("FolderGameCache_StructInteger_Set","call DebugEx(\"GameCache Set: \"+missionKey+\";\"+key)","GameCache Set: "+o6x+";"+oQx)
return
endif
call StoreInteger(Kv[(oqx)],o6x,oQx,oSx)
endfunction
function Xkx takes string rpx,integer oQx,integer oSx returns nothing
call XJx(lv[(E[((X))])],((rpx)),(((I2S((oQx))))),((oSx)))
endfunction
function XKx takes integer oqx returns integer
set yA[oqx]=true
set YA[oqx]=false
call rax(zA)
return oqx
endfunction
function Xlx takes nothing returns integer
local integer oqx
if(TA==8190)then
call oYx("BoolExpr_Allocation_allocCustom","call DebugEx(BoolExpr.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",uA+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(UA[(w)]==w)then
set wA=wA+1
set oqx=wA
else
set oqx=UA[(w)]
set UA[(w)]=UA[UA[(w)]]
endif
set UA[oqx]=Z
set WA[oqx]=1
call XKx(oqx)
return oqx
endfunction
function XLx takes code Xmx returns integer
local integer XMx=(GetHandleId(Condition((Xmx))))
local integer oqx=(LoadInteger(o[((SA))],(XMx),(tA)))
if(oqx==0)then
set oqx=Xlx()
set Bv[oqx]=Condition(Xmx)
call SaveInteger(o[((SA))],(XMx),(tA),(oqx))
endif
return oqx
endfunction
function Xpx takes string oMx,string oSx,integer okx returns integer
local integer olx=0-1
local integer r7x=((StringLength(((oMx))))-1)
local integer r8x=(StringLength((oSx)))
loop
exitwhen(okx<0)
set olx=olx+1
loop
if(olx>r7x)then
return Qv
endif
exitwhen(r2x(oMx,olx,olx+r8x-1)!=oSx)
set olx=olx+1
endloop
set okx=okx-1
endloop
return olx
endfunction
function XPx takes string oMx,integer okx returns string
local integer rvx=Xpx(oMx," ",0)
local boolean Xqx
if(rvx==Qv)then
return null
endif
set oMx=Xdx(oMx,rvx)
set rvx=r6x(oMx," ",0)
if(okx==0)then
if(rvx==Qv)then
return oMx
endif
return(r2x((oMx),0,(rvx-1)))
elseif(rvx==Qv)then
return null
endif
set Xqx=false
set okx=okx-1
loop
set oMx=Xdx(oMx,rvx)
set rvx=Xpx(oMx," ",0)
if(rvx==Qv)then
return null
endif
if(r2x(oMx,rvx,rvx)=="\"")then
set oMx=Xdx(oMx,rvx+1)
set rvx=r6x(oMx,"\"",0)
set Xqx=true
else
set oMx=Xdx(oMx,rvx)
set rvx=r6x(oMx," ",0)
endif
if(okx==0)then
if(rvx==Qv)then
return oMx
endif
return(r2x((oMx),0,(rvx-1)))
elseif(rvx==Qv)then
return null
endif
set okx=okx-1
exitwhen(okx<0)
if Xqx then
set Xqx=false
set rvx=rvx+1
endif
endloop
return null
endfunction
function XQx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local string Xsx=(MA[(rdx)])
local boolean o4x=(XPx(r1x,0)==Xsx)
local string array XSx
local integer Xtx
local string XTx
if o4x then
set Xtx=0
set XTx=null
loop
exitwhen(XPx(r1x,Xtx+1)==null)
set Xtx=Xtx+1
set XSx[F+Xtx]=XPx(r1x,Xtx)
if(Xtx==1)then
set XTx=XSx[F+Xtx]
else
set XTx=XTx+" "+XSx[F+Xtx]
endif
endloop
if(XTx==null)then
call ajx("execute "+Xsx)
else
call ajx("execute "+Xsx+" with "+XTx)
endif
endif
return o4x
return true
endfunction
function Xux takes integer oqx,string o6x,string oQx,integer oSx returns boolean
local integer o7x=(ZA+(rmx(lv[(E[((oqx))])],((o6x)),((oQx)))))+1
call XJx(lv[(E[(oqx)])],(o6x),(oQx),(o7x-ZA))
call XJx(lv[(E[(oqx)])],(o6x),(oQx+I2S(ZA+o7x+2)),(oSx))
return(o7x==0)
endfunction
function XUx takes integer oqx,string oMx,integer Xwx returns nothing
call Xux(X,(oMx),(I2S((((rA[(Xwx)]))))),(Xwx))
endfunction
function XWx takes string r1x,code Xyx returns nothing
local integer oqx=Xex()
local integer Xwx=XBx("CommandHeader_RegisterEvent: local Event whichEvent = Event.Create(User.CHAT_EVENT_TYPE, EventPriority.MISC, function CommandHeader.Event_Chat)",LA,LI,function XFx)
set PA[oqx]=XHx(Xyx)
call Xkx(r1x,pA,oqx)
set cv[(Xwx)]=(XLx(function XQx))
call XUx(vN,r1x,Xwx)
endfunction
function XYx takes real x,real y returns real
call MoveLocation(VN[(EN)],((x)*1.),((y)*1.))
return(GetLocationZ(VN[(EN)]))
endfunction
function Xzx takes integer oqx,real x,real y,real z returns nothing
if xN[oqx]then
set x=x-(StringLength((aN[(oqx)])))*1./ 2*16.5
endif
call SetTextTagPos(nN[(oqx)],x,y,z-XYx(x,y))
endfunction
function XZx takes integer oqx,real x,real y,real z returns nothing
set oN[oqx]=x
set rN[oqx]=y
set iN[oqx]=z
call Xzx(oqx,x,y,z)
endfunction
function X_x takes integer oqx returns nothing
call XZx(oqx,oN[oqx],rN[oqx],iN[oqx])
endfunction
function X0x takes integer oqx returns nothing
set xN[oqx]=true
call X_x(oqx)
endfunction
function X1x takes integer oqx returns integer
set cN[oqx]=true
set CN[oqx]=false
call rax(dN)
return oqx
endfunction
function X2x takes nothing returns integer
local integer oqx
if(IN==8190)then
call oYx("TextTag_Allocation_allocCustom","call DebugEx(TextTag.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",AN+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(NN[(w)]==w)then
set bN=bN+1
set oqx=bN
else
set oqx=NN[(w)]
set NN[(w)]=NN[NN[(w)]]
endif
set NN[oqx]=Z
set BN[oqx]=1
call X1x(oqx)
return oqx
endfunction
function X3x takes integer oqx returns nothing
set xN[oqx]=false
call XZx(oqx,.0,.0,.0)
endfunction
function X4x takes integer id returns integer
local integer oqx
if((id!=0)and((LoadInteger(o[((V[(E[((X))])]))],(((ON))),(((id)))))!=w))then
return w
endif
if(RN=='d')then
call oYx("TextTag_Create","call DebugEx(TextTag.Create.name + \": limit exceeded\")","s__TextTag_Create: limit exceeded")
return w
endif
set RN=RN+1
set oqx=X2x()
set DN[oqx]=id
set nN[oqx]=CreateTextTag()
call SaveInteger(o[((V[(E[((X))])]))],(((ON))),(((id))),(((oqx))))
set fN[oqx]=.0
set FN[(oqx)]=""
call X3x(oqx)
return oqx
endfunction
function X5x takes string oMx returns string
local integer okx=r6x(oMx,"|c",0)
if(okx!=Qv)then
return X5x((r2x((oMx),0,(okx-1)))+Xdx(oMx,okx+(StringLength(("|c")))+8))
endif
set okx=r6x(oMx,"|r",0)
if(okx!=Qv)then
return X5x((r2x((oMx),0,(okx-1)))+Xdx(oMx,okx+(StringLength(("|r")))))
endif
return oMx
endfunction
function X6x takes integer oqx,string iNx,real X7x returns nothing
set jN[oqx]=X7x
set aN[oqx]=X5x(iNx)
set FN[oqx]=iNx
call SetTextTagText(nN[(oqx)],iNx,X7x)
call X_x((oqx))
endfunction
function X8x takes integer oqx returns boolean
set JN=JN+1
set kN[JN]=oqx
set KN[oqx]=JN+1
return(JN==0)
endfunction
function X9x takes integer oqx,real z returns nothing
set iN[oqx]=z
call Xzx(oqx,oN[oqx],rN[oqx],z)
endfunction
function Ovx takes integer oqx,real z returns nothing
call X9x(oqx,(iN[(oqx)])+z)
endfunction
function Oex takes nothing returns nothing
local integer olx=JN
local integer oqx
loop
set oqx=kN[olx]
call Ovx((oqx),gN[oqx])
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function Oxx takes integer oqx returns boolean
local integer okx=(KN[(oqx)])
set KN[kN[JN]]=okx
set kN[okx-1]=kN[JN]
set KN[oqx]=0
set JN=JN-1
return(JN==F)
endfunction
function Oox takes integer oqx,integer ibx returns nothing
set HN[oqx]=false
call ijx(ibx)
if Oxx(oqx)then
call iHx(lN)
endif
endfunction
function Orx takes integer oqx returns boolean
local integer okx=(mN[(oqx)])
set mN[MN[pN]]=okx
set MN[okx-1]=MN[pN]
set mN[oqx]=0
set pN=pN-1
return(pN==F)
endfunction
function Oix takes integer oqx,integer ibx returns nothing
set LN[oqx]=false
call ijx(ibx)
if Orx(oqx)then
call iHx(PN)
endif
endfunction
function Oax takes integer oqx returns nothing
if LN[oqx]then
call Oix(oqx,qN[oqx])
endif
endfunction
function Onx takes integer oqx returns boolean
local integer okx=(sN[(oqx)])
set sN[SN[tN]]=okx
set SN[okx-1]=SN[tN]
set sN[oqx]=0
set tN=tN-1
return(tN==F)
endfunction
function OVx takes integer oqx,integer ibx returns nothing
set QN[oqx]=false
call ijx(ibx)
if Onx(oqx)then
call iHx(TN)
endif
endfunction
function OEx takes integer oqx returns nothing
if QN[oqx]then
call OVx(oqx,uN[oqx])
endif
endfunction
function OXx takes integer oqx returns nothing
if HN[oqx]then
call Oox(oqx,hN[oqx])
endif
endfunction
function OOx takes integer oqx returns boolean
local integer okx=(UN[(oqx)])
set UN[wN[WN]]=okx
set wN[okx-1]=wN[WN]
set UN[oqx]=0
set WN=WN-1
return(WN==F)
endfunction
function ORx takes integer oqx returns nothing
if OOx(oqx)then
call iHx(yN)
endif
endfunction
function OIx takes integer oqx returns nothing
if((UN[((oqx))])>0)then
call ORx(oqx)
endif
endfunction
function OAx takes integer oqx returns nothing
set cN[oqx]=false
call rgx(dN)
endfunction
function ONx takes integer oqx returns nothing
if(BN[oqx]>0)then
return
endif
if(NN[oqx]!=Z)then
call oYx("TextTag_Allocation_deallocCustom_confirm","call DebugEx(TextTag.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",AN+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set NN[oqx]=NN[(w)]
set NN[(w)]=oqx
call OAx(oqx)
endfunction
function Obx takes integer oqx returns nothing
set BN[oqx]=BN[oqx]-1
call ONx(oqx)
endfunction
function OBx takes integer oqx returns nothing
local integer id=DN[oqx]
local texttag oMx=nN[oqx]
set RN=RN-1
call Oax(oqx)
call OEx(oqx)
call OXx(oqx)
call OIx(oqx)
call Obx((oqx))
call DestroyTextTag(oMx)
call SaveInteger(o[(((V[(E[((X))])])))],((((ON)))),((((id)))),(0))
set oMx=null
endfunction
function Ocx takes nothing returns nothing
local integer ibx=ifx()
local integer oqx=(ge[(ibx)])
call Oox(oqx,ibx)
call OBx((oqx))
endfunction
function OCx takes integer oqx returns boolean
set WN=WN+1
set wN[WN]=oqx
set UN[oqx]=WN+1
return(WN==0)
endfunction
function Odx takes nothing returns nothing
local integer olx=WN
local integer oqx
local real ODx
loop
set oqx=wN[olx]
set ODx=ZN[oqx]+YN[oqx]
set ZN[oqx]=ODx
call SetTextTagColor(nN[(oqx)],$FF,$FF,$FF,(R2I(((ODx)*1.))))
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function Ofx takes integer oqx,real ilx returns nothing
set YN[oqx]=-$FF*1./ ilx*zN
set ZN[oqx]=$FF
call SetTextTagPermanent(nN[(oqx)],false)
if OCx(oqx)then
call icx(yN,zN,true,function Odx)
endif
endfunction
function OFx takes nothing returns nothing
local integer oqx=(ge[(ifx())])
call ijx(vb[(oqx)])
call Ofx((oqx),eb[oqx])
endfunction
function Ogx takes integer oqx,real OGx,real Ohx returns nothing
local integer OHx
if(OGx<=.0)then
call Ofx((oqx),Ohx)
return
endif
set OHx=inx()
set vb[oqx]=OHx
set eb[oqx]=Ohx-OGx
set ge[(OHx)]=(oqx)
call icx(OHx,OGx,false,function OFx)
endfunction
function Ojx takes integer oqx,real OGx,real Ohx returns nothing
call Ogx(oqx,OGx,Ohx)
endfunction
function OJx takes string iNx,real X7x,real x,real y,real z,real Okx,real OKx,real ilx,integer id returns integer
local integer rkx
local integer oqx
local integer ibx
if(ilx==.0)then
return w
endif
set rkx=X4x(id)
if(rkx==w)then
return w
endif
set oqx=rkx
set ibx=inx()
set gN[oqx]=Okx*GN
set hN[oqx]=ibx
set HN[oqx]=true
set ge[(ibx)]=(oqx)
call XZx(rkx,x,y,z)
call X6x(rkx,iNx,X7x)
if X8x(oqx)then
call icx(lN,GN,true,function Oex)
endif
call icx(ibx,ilx,false,function Ocx)
call Ojx(rkx,OKx,ilx)
return rkx
endfunction
function Olx takes integer oqx,real x,real y returns real
return(XYx(x,y)+(GetUnitFlyHeight(C[((oqx))])))
endfunction
function OLx takes integer oqx,boolean Omx returns real
if Omx then
return(xb[oqx]*(ob[((oqx))]))
endif
return xb[oqx]
endfunction
function OMx takes integer oqx,string iNx,real X7x,real Okx,real OKx,real ilx,integer id returns integer
local real x=(GetUnitX(C[((oqx))]))
local real y=(GetUnitY(C[((oqx))]))
return OJx(iNx,X7x,x,y,Olx(oqx,x,y)+OLx(oqx,true),Okx,OKx,ilx,id)
endfunction
function Opx takes integer oqx returns string
return("|c"+rb[oqx]+ib[oqx]+"|r")
endfunction
function OPx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
local integer Oqx=(kv[(ocx)])
set r1x=Xdx(r1x,1)
if(Oqx!=w)then
call X0x(OMx(Oqx,Opx(ocx)+": "+r1x,ab,100.,2.,3.+.1*(StringLength((r1x))),(0)))
endif
return true
endfunction
function OQx takes nothing returns boolean
call XWx("!",function OPx)
return true
endfunction
function Osx takes nothing returns boolean
call E9x(function OQx,"CharacterSpeech_Init")
return true
endfunction
function OSx takes nothing returns boolean
set nb=Vnx(Vb)
return true
endfunction
function Otx takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[(((Eb[(oqx)])))])]))],(((((Xb[((oqx))]))))),((((oQx))+(q)))))
endfunction
function OTx takes integer oqx returns nothing
set Ib=oqx
call rcx(Ab)
endfunction
function Oux takes nothing returns nothing
local integer OUx
loop
set OUx=(Otx((Ob),Rb))
exitwhen(OUx==w)
call OTx(OUx)
endloop
endfunction
function Owx takes nothing returns boolean
local integer rdx=(bv)
call Oux()
return true
endfunction
function OWx takes nothing returns boolean
call XWx("-clearSpawns",function Owx)
return true
endfunction
function Oyx takes nothing returns boolean
call E9x(function OWx,"ClearSpawns_Init")
return true
endfunction
function OYx takes nothing returns boolean
set Nb=Vnx(bb)
return true
endfunction
function Ozx takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((cb[(oqx)]))])]))],((((Cb[((oqx))])))),(((oQx))))))
endfunction
function OZx takes integer oqx,integer ocx returns integer
return Ozx(ocx,db)
endfunction
function O_x takes integer oqx returns integer
set jb[oqx]=true
set Jb[oqx]=false
call rax(kb)
return oqx
endfunction
function O0x takes nothing returns integer
local integer oqx
if(Fb==8190)then
call oYx("Group_Allocation_allocCustom","call DebugEx(Group.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",gb+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Gb[(w)]==w)then
set hb=hb+1
set oqx=hb
else
set oqx=Gb[(w)]
set Gb[(w)]=Gb[Gb[(w)]]
endif
set Gb[oqx]=Z
set Hb[oqx]=1
call O_x(oqx)
return oqx
endfunction
function O1x takes integer oqx returns nothing
set Lb[oqx]=0
set mb[oqx]=false
endfunction
function O2x takes nothing returns integer
local integer oqx
if(fb==F)then
set oqx=O0x()
set Kb[oqx]=CreateGroup()
else
set oqx=lb[fb]
set fb=fb-1
endif
call O1x(oqx)
return oqx
endfunction
function O3x takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((cb[(oqx)]))])]))],((((Cb[((oqx))])))),(((oQx)+(okx)))))
endfunction
function O4x takes integer oqx,integer ocx,integer okx returns integer
return O3x(ocx,db,okx)
endfunction
function O5x takes integer oqx returns boolean
if((Lb[(oqx)])>0)then
set mb[oqx]=true
return false
endif
return true
endfunction
function O6x takes integer oqx returns nothing
if not O5x(oqx)then
return
endif
set fb=fb+1
set lb[fb]=oqx
call GroupClear(Kb[oqx])
endfunction
function O7x takes integer oqx,code Xbx returns nothing
local integer olx=OZx(Db,oqx)
local integer O8x
if(olx<q)then
return
endif
set O8x=O2x()
loop
call GroupAddUnit(Kb[(O8x)],C[(O4x(Db,oqx,olx))])
set olx=olx-1
exitwhen(olx<q)
endloop
call ForGroup(Kb[(O8x)],(Xbx))
call O6x(O8x)
endfunction
function O9x takes integer oqx,integer Rvx returns boolean
return(IssueImmediateOrderById(C[(oqx)],Pb[Rvx]))
endfunction
function Rex takes integer oqx,integer Rvx returns boolean
local boolean o4x
call DisableTrigger(fA[(pb)])
set o4x=O9x(oqx,Rvx)
call EnableTrigger(fA[(pb)])
return o4x
endfunction
function Rxx takes integer oqx,integer Rox,integer rJx returns nothing
local integer rkx=oqx
local integer Rrx=rEx((A[(rkx)]))
local integer rKx
local integer olx
local integer rIx
local integer rlx
set Qb[(Rrx)]=(Rox)
set nv[(Rrx)]=(rJx)
set Vv[(Rrx)]=(oqx)
set rKx=rEx((Ev[(rJx)]))
set Qb[(rKx)]=(Rox)
set nv[(rKx)]=(rJx)
set Vv[(rKx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rfx(rJx,sb,rIx)
loop
exitwhen(rlx<q)
call rCx(rFx(rJx,sb,rIx,rlx),rKx)
set rlx=rlx-1
endloop
set rlx=rOx(rkx,sb,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,sb,rIx,rlx),Rrx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((Rrx)))
call rHx(((rKx)))
endfunction
function Rix takes integer oqx,integer rJx returns nothing
local integer Rax=(Mb[(oqx)])
if(rJx==Rax)then
return
endif
set Mb[oqx]=rJx
call Rxx(oqx,Rax,rJx)
endfunction
function Rnx takes integer oqx,integer rJx returns nothing
if(rJx==w)then
if((Mb[(oqx)])!=w)then
if Rex((oqx),(qb[(rJx)]))then
call Rix(oqx,w)
endif
endif
else
if Rex((oqx),(Sb[(rJx)]))then
call Rix(oqx,rJx)
endif
endif
endfunction
function RVx takes nothing returns integer
local unit oMx=GetEnumUnit()
local integer o4x
if(GetUnitAbilityLevel(oMx,'aLoc')>0)then
set oMx=null
return Z
endif
set o4x=aBx(oMx)
set oMx=null
return o4x
endfunction
function REx takes nothing returns boolean
local integer rdx=(bv)
call Rnx(RVx(),Bb)
return true
endfunction
function RXx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
local integer rJx=rPx(XPx(r1x,1))
if(rJx==w)then
call oYx("CommandAutoCast_Event_Chat","call DebugEx(\"invalid spell\")","invalid spell")
return true
endif
set Bb=rJx
call O7x(ocx,function REx)
return true
endfunction
function ROx takes nothing returns boolean
call XWx("-autocast",function RXx)
return true
endfunction
function RRx takes nothing returns boolean
call E9x(function ROx,"CommandAutoCast_Init")
return true
endfunction
function RIx takes nothing returns boolean
set tb=Vnx(Tb)
return true
endfunction
function RAx takes string rqx returns integer
return rMx(rqx,ub)
endfunction
function RNx takes integer Rbx,integer RBx,integer Rcx returns integer
local integer RCx
set Rbx=Rbx-O
set RCx=(Rbx/ 64*8192*8192+RBx*8192+Rcx)
return RCx
endfunction
function Rdx takes integer Rbx,integer RDx,integer Rfx returns integer
local integer RCx
set Rbx=Rbx-O
set RCx=((Rbx-Rbx/ 64*64)*8192*8192+RDx*8192+Rfx)
return RCx
endfunction
function RFx takes integer oqx,integer Rgx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer Rfx returns integer
return(LoadInteger(o[((Rgx))],(RNx(Rbx,RBx,Rcx)),(Rdx(Rbx,RDx,Rfx))))
endfunction
function RGx takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx returns integer
return RFx(E[(oqx)],BO[oqx],Rbx,RBx,Rcx,RDx,0)
endfunction
function Rhx takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer oSx returns integer
return RFx(E[(oqx)],CO[oqx],Rbx,RBx,Rcx,RDx,(oSx))
endfunction
function RHx takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer oSx returns integer
return RFx(E[(oqx)],dO[oqx],Rbx,RBx,Rcx,RDx,(oSx))
endfunction
function Rjx takes integer oqx,integer Rgx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer Rfx,integer oSx returns nothing
call SaveInteger(o[((Rgx))],(RNx(Rbx,RBx,Rcx)),(Rdx(Rbx,RDx,Rfx)),(oSx))
endfunction
function RJx takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer oSx returns nothing
local integer Rkx=Rhx(oqx,Rbx,RBx,Rcx,RDx,oSx)
local integer RKx=RHx(oqx,Rbx,RBx,Rcx,RDx,oSx)
if((RKx==0)and(Rkx==0))then
if(RGx(oqx,Rbx,RBx,Rcx,RDx)!=oSx)then
return
endif
endif
if(Rkx==0)then
call Rjx(E[(oqx)],cO[oqx],Rbx,RBx,Rcx,RDx,0,RKx)
else
call Rjx(E[(oqx)],dO[oqx],Rbx,RBx,Rcx,RDx,(Rkx),RKx)
endif
if(RKx==0)then
call Rjx(E[(oqx)],BO[oqx],Rbx,RBx,Rcx,RDx,0,Rkx)
else
call Rjx(E[(oqx)],CO[oqx],Rbx,RBx,Rcx,RDx,(RKx),Rkx)
endif
endfunction
function Rlx takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx returns integer
local integer oSx=RGx(oqx,Rbx,RBx,Rcx,RDx)
if(oSx==0)then
return 0
endif
call RJx(oqx,Rbx,RBx,Rcx,RDx,oSx)
return oSx
endfunction
function RLx takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx returns nothing
loop
exitwhen(Rlx(oqx,Rbx,RBx,Rcx,RDx)==0)
endloop
endfunction
function Rmx takes integer oqx,integer Xwx returns nothing
if not((LoadInteger(o[((D[((Rv[oqx]))]))],((((A[((oqx))])))),(osx((((rA[(Xwx)]))),(((Xwx)))))))!=0)then
call oYx("FolderUnit_StructEvent_Remove","call DebugEx(\"subject \"+I2S(Unit(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((A[((oqx))]))+" has not "+(JA[(Xwx)]))
return
endif
call rex(Rv[oqx],(A[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function RMx takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((VB[oqx]))])]))],((((aB[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function Rpx takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((VB[oqx]))])]))],((((aB[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function RPx takes integer oqx returns nothing
local integer rdx=rEx((aB[(oqx)]))
local integer olx
local integer rIx
local integer rlx
set nB[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=RMx(oqx,EB,rIx)
loop
exitwhen(rlx<q)
call rCx(Rpx(oqx,EB,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function Rqx takes integer oqx returns nothing
if XB[oqx]then
return
endif
set XB[oqx]=true
if(OB[oqx]==null)then
call DestroyEffect(RB[oqx])
set RB[oqx]=null
else
call DestroyEffect(OB[oqx])
set OB[oqx]=null
endif
endfunction
function RQx takes integer oqx returns boolean
local integer okx=(IB[(oqx)])
set IB[AB[NB]]=okx
set AB[okx-1]=AB[NB]
set IB[oqx]=0
set NB=NB-1
return(NB==F)
endfunction
function Rsx takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((dB[oqx]))])])],((((aB[((oqx))])))))
endfunction
function RSx takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((VB[oqx]))])])],((((aB[((oqx))])))))
endfunction
function Rtx takes integer oqx returns nothing
set CB[oqx]=false
call Rsx((oqx))
call RSx(((oqx)))
call rgx(DB)
endfunction
function RTx takes integer oqx returns nothing
if(bB[oqx]>0)then
return
endif
if(BB[oqx]!=Z)then
call oYx("UnitEffect_Allocation_deallocCustom_confirm","call DebugEx(UnitEffect.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",cB+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set BB[oqx]=BB[(w)]
set BB[(w)]=oqx
call Rtx(oqx)
endfunction
function Rux takes integer oqx returns nothing
set bB[oqx]=bB[oqx]-1
call RTx(oqx)
endfunction
function RUx takes integer oqx returns boolean
if iB[oqx]then
return true
endif
set iB[oqx]=true
call RPx(oqx)
call Rqx(oqx)
call RQx(oqx)
call Rux(oqx)
return true
endfunction
function Rwx takes integer oqx returns nothing
set hB[oqx]=hB[oqx]+1
endfunction
function RWx takes integer oqx returns nothing
set KB[oqx]=false
call rgx(lB)
endfunction
function Ryx takes integer oqx returns nothing
if(hB[oqx]>0)then
return
endif
if(JB[oqx]!=Z)then
call oYx("Sound_Allocation_deallocCustom_confirm","call DebugEx(Sound.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",kB+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set JB[oqx]=JB[(w)]
set JB[(w)]=oqx
call RWx(oqx)
endfunction
function RYx takes integer oqx returns nothing
set hB[oqx]=hB[oqx]-1
call Ryx(oqx)
endfunction
function Rzx takes nothing returns nothing
local integer OHx=ifx()
local integer oqx=(ge[(OHx)])
set GB[oqx]=w
call StopSound(gB[oqx],HB[oqx],jB[oqx])
call RYx(oqx)
endfunction
function RZx takes integer oqx,boolean R_x,boolean R0x returns nothing
local integer OHx=GB[oqx]
if(OHx==w)then
set OHx=inx()
set ge[(OHx)]=(oqx)
call Rwx(oqx)
endif
set GB[oqx]=OHx
set HB[oqx]=R_x
set jB[oqx]=R0x
call icx(OHx,.07,false,function Rzx)
endfunction
function R1x takes integer oqx,boolean R2x returns boolean
local sound oMx
if FB[oqx]then
return true
endif
set FB[oqx]=true
set oMx=gB[oqx]
if R2x then
call RZx(oqx,true,true)
else
if(LB[(oqx)])then
call RZx(oqx,true,R2x)
else
call KillSoundWhenDone(oMx)
endif
endif
set oMx=null
call RYx(oqx)
return true
endfunction
function R3x takes integer oqx returns nothing
set qB[oqx]=false
call rgx(QB)
endfunction
function R4x takes integer oqx returns nothing
if(MB[oqx]>0)then
return
endif
if(pB[oqx]!=Z)then
call oYx("UnitSound_Allocation_deallocCustom_confirm","call DebugEx(UnitSound.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",PB+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set pB[oqx]=pB[(w)]
set pB[(w)]=oqx
call R3x(oqx)
endfunction
function R5x takes integer oqx returns nothing
set MB[oqx]=MB[oqx]-1
call R4x(oqx)
endfunction
function R6x takes integer oqx returns nothing
call R1x(mB[oqx],true)
call R5x((oqx))
endfunction
function R7x takes integer oqx returns nothing
set yB[oqx]=false
call rgx(YB)
endfunction
function R8x takes integer oqx returns nothing
if(UB[oqx]>0)then
return
endif
if(wB[oqx]!=Z)then
call oYx("BuffRef_Allocation_deallocCustom_confirm","call DebugEx(BuffRef.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",WB+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set wB[oqx]=wB[(w)]
set wB[(w)]=oqx
call R7x(oqx)
endfunction
function R9x takes integer oqx returns nothing
set UB[oqx]=UB[oqx]-1
call R8x(oqx)
endfunction
function Ivx takes integer oqx returns nothing
if not uB[oqx]then
return
endif
if(SB[oqx]>0)then
return
endif
call R9x((oqx))
endfunction
function Iex takes integer oqx returns nothing
local integer Ixx=tB[oqx]
local integer Iox=TB[oqx]
if uB[oqx]then
return
endif
set uB[oqx]=true
set SB[oqx]=SB[oqx]-1
if(SB[oqx]==0)then
call Ivx(oqx)
endif
call RJx(X,sB,Ixx,Iox,w,oqx)
endfunction
function Irx takes integer Iox,integer Ixx returns nothing
local integer oqx=RGx(X,sB,Ixx,Iox,w)
loop
exitwhen(oqx==w)
set SB[oqx]=SB[oqx]+1
call Iex(oqx)
set oqx=RGx(X,sB,Ixx,Iox,w)
endloop
endfunction
function Iix takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((zB[(oqx)]))])]))],((((ZB[((oqx))])))),(((oQx)))))
endfunction
function Iax takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((xc[(oqx)]))])]))],((((oc[((oqx))])))),(((oQx))))))
endfunction
function Inx takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((xc[(oqx)]))])]))],((((oc[((oqx))])))),(((oQx)+(okx)))))
endfunction
function IVx takes integer oqx,integer Ixx,boolean o2x returns nothing
local integer rdx=rEx(0)
set ic[(rdx)]=(o2x)
set Vv[(rdx)]=(Ixx)
call Xfx((ac[(oqx)]),rdx)
call rHx(((rdx)))
endfunction
function IEx takes integer oqx,integer IXx,boolean o2x returns nothing
call IVx(IXx,oqx,o2x)
endfunction
function IOx takes integer oqx,integer oQx returns boolean
return(LoadBoolean(o[((V[(E[((xc[(oqx)]))])]))],((((oc[((oqx))])))),(((oQx)))))
endfunction
function IRx takes integer oqx,integer Ixx returns nothing
local integer olx=(Iax(((oqx)),rc))
local integer IIx
loop
exitwhen(olx<q)
set IIx=(Inx(((oqx)),rc,(olx)))
call IEx((Ixx),(IIx),not((IOx(((oqx)),nc+(IIx)))))
set olx=olx-1
endloop
endfunction
function IAx takes integer oqx,integer Ixx,real nyx returns nothing
local integer rdx=rEx(0)
set Ec[(rdx)]=((nyx)*1.)
set Vv[(rdx)]=(Ixx)
call Xfx((ac[(oqx)]),rdx)
call rHx(((rdx)))
endfunction
function INx takes integer oqx,integer IXx,real oSx returns nothing
call IAx(IXx,oqx,oSx)
endfunction
function Ibx takes integer oqx,integer oQx returns real
return(LoadReal(o[((V[(E[((xc[(oqx)]))])]))],((((oc[((oqx))])))),(((oQx)))))
endfunction
function IBx takes integer oqx,integer Ixx returns nothing
local integer olx=(Iax(((oqx)),Vc))
local integer IIx
loop
exitwhen(olx<q)
set IIx=(Inx(((oqx)),Vc,(olx)))
call INx((Ixx),(IIx),-(((Ibx(((oqx)),Xc+(IIx))))*1.))
set olx=olx-1
endloop
endfunction
function Icx takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer Rfx,boolean oSx returns nothing
call SaveBoolean(o[((XO[oqx]))],(RNx(Rbx,RBx,Rcx)),(Rdx(Rbx,RDx,Rfx)),(oSx))
endfunction
function ICx takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer Rfx returns boolean
return(LoadBoolean(o[((XO[oqx]))],(RNx(Rbx,RBx,Rcx)),(Rdx(Rbx,RDx,Rfx))))
endfunction
function Idx takes integer oqx,integer rdx,integer IIx returns nothing
local integer oQx=RGx(X,Rc,oqx,IIx,w)
loop
exitwhen(oQx==w)
call Icx(E[((X))],(Ac),((rdx)),((oQx)),(w),(w),(((ICx(E[((X))],(Nc),(oqx),(IIx),(oQx),(w))))))
set oQx=Rhx(X,Rc,oqx,IIx,w,oQx)
endloop
endfunction
function IDx takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer Rfx,integer oSx returns nothing
call SaveInteger(o[((XO[oqx]))],(RNx(Rbx,RBx,Rcx)),(Rdx(Rbx,RDx,Rfx)),(oSx))
endfunction
function Ifx takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer Rfx returns integer
return(LoadInteger(o[((XO[oqx]))],(RNx(Rbx,RBx,Rcx)),(Rdx(Rbx,RDx,Rfx))))
endfunction
function IFx takes integer oqx,integer rdx,integer IIx returns nothing
local integer oQx=RGx(X,bc,oqx,IIx,w)
loop
exitwhen(oQx==w)
call IDx(E[((X))],(Ac),((rdx)),((oQx)),(w),(w),(((Ifx(E[((X))],(Bc),(oqx),(IIx),(oQx),(w))))))
set oQx=Rhx(X,bc,oqx,IIx,w,oQx)
endloop
endfunction
function Igx takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer Rfx,real oSx returns nothing
call SaveReal(o[((XO[oqx]))],(RNx(Rbx,RBx,Rcx)),(Rdx(Rbx,RDx,Rfx)),((oSx)*1.))
endfunction
function IGx takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer Rfx returns real
return(LoadReal(o[((XO[oqx]))],(RNx(Rbx,RBx,Rcx)),(Rdx(Rbx,RDx,Rfx))))
endfunction
function Ihx takes integer oqx,integer rdx,integer IIx returns nothing
local integer oQx=RGx(X,cc,oqx,IIx,w)
loop
exitwhen(oQx==w)
call Igx(E[((X))],(Ac),((rdx)),((oQx)),(w),(w),(((((IGx(E[((X))],(Cc),(oqx),(IIx),(oQx),(w))))*1.))*1.))
set oQx=Rhx(X,cc,oqx,IIx,w,oQx)
endloop
endfunction
function IHx takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer Rfx,string oSx returns nothing
call SaveStr(o[((XO[oqx]))],(RNx(Rbx,RBx,Rcx)),(Rdx(Rbx,RDx,Rfx)),(oSx))
endfunction
function Ijx takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer Rfx returns string
return(LoadStr(o[((XO[oqx]))],(RNx(Rbx,RBx,Rcx)),(Rdx(Rbx,RDx,Rfx))))
endfunction
function IJx takes integer oqx,integer rdx,integer IIx returns nothing
local integer oQx=RGx(X,dc,oqx,IIx,w)
loop
exitwhen(oQx==w)
call IHx(E[((X))],(Ac),((rdx)),((oQx)),(w),(w),(((Ijx(E[((X))],(Dc),(oqx),(IIx),(oQx),(w))))))
set oQx=Rhx(X,dc,oqx,IIx,w,oQx)
endloop
endfunction
function Ikx takes integer oqx,integer IIx returns integer
local integer rdx=rEx((oc[((oqx))]))
call Idx(oqx,rdx,IIx)
call IFx(oqx,rdx,IIx)
call Ihx(oqx,rdx,IIx)
call IJx(oqx,rdx,IIx)
return rdx
endfunction
function IKx takes integer oqx,integer Ixx,integer rdx,boolean Ilx returns nothing
set fc[(rdx)]=(Ilx)
set Vv[(rdx)]=(Ixx)
call Xfx((ac[(oqx)]),rdx)
endfunction
function ILx takes integer oqx,integer Ixx returns nothing
local integer olx=(Iax(((oqx)),Oc))
local integer IIx
local integer rdx
loop
exitwhen(olx<q)
set IIx=(Inx(((oqx)),Oc,(olx)))
set rdx=Ikx(oqx,IIx)
call IKx(IIx,Ixx,rdx,false)
call rHx(((rdx)))
set olx=olx-1
endloop
endfunction
function Imx takes integer oqx,integer Ixx returns nothing
local integer rdx=rEx(0)
set Vv[(rdx)]=(Ixx)
set Gc[(rdx)]=(oqx)
call Xfx((hc[(oqx)]),rdx)
call rHx(((rdx)))
endfunction
function IMx takes integer oqx,integer Ixx returns nothing
local integer olx=(Iax(((oqx)),Fc))
local integer Ipx
loop
exitwhen(olx<q)
set Ipx=(Inx(((oqx)),Fc,(olx)))
call Imx(Ipx,Ixx)
set olx=olx-1
endloop
endfunction
function IPx takes integer oqx,integer Ixx returns nothing
call IRx(oqx,Ixx)
call IBx(oqx,Ixx)
call ILx(oqx,Ixx)
call IMx(oqx,Ixx)
endfunction
function Iqx takes integer oqx,integer o2x returns nothing
call rrx((oqx),ec,o2x)
call IPx(o2x,oqx)
endfunction
function IQx takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((kc[oqx]))])]))],((((ZB[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function Isx takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((kc[oqx]))])]))],((((ZB[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function ISx takes integer oqx,integer Iox,integer rwx returns nothing
local integer rkx=oqx
local integer Itx=rEx((ZB[(Iox)]))
local integer rdx
local integer olx
local integer rIx
local integer rlx
set Hc[(Itx)]=(rwx)
set jc[(Itx)]=(Iox)
set Vv[(Itx)]=(rkx)
set rdx=rEx((A[(rkx)]))
set Hc[(rdx)]=(rwx)
set jc[(rdx)]=(Iox)
set Vv[(rdx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,Jc,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,Jc,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set rlx=IQx(Iox,Jc,rIx)
loop
exitwhen(rlx<q)
call rCx(Isx(Iox,Jc,rIx,rlx),Itx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((Itx)))
call rHx(((rdx)))
endfunction
function ITx takes integer oqx,integer Iox,integer rwx returns nothing
local integer Iux=(Iix(((Iox)),vc+(rwx)))
if(Iux!=w)then
call Iqx((oqx),Iux)
endif
call ISx(oqx,Iox,rwx)
endfunction
function IUx takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((zB[(oqx)]))])]))],((((ZB[((oqx))])))),(((oQx))))))
endfunction
function Iwx takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((zB[(oqx)]))])]))],((((ZB[((oqx))])))),(((oQx)+(okx)))))
endfunction
function IWx takes integer oqx,integer Ixx returns nothing
local integer olx=(Iax(((oqx)),rc))
local integer IIx
loop
exitwhen(olx<q)
set IIx=(Inx(((oqx)),rc,(olx)))
call IEx(Ixx,IIx,(IOx(((oqx)),nc+(IIx))))
set olx=olx-1
endloop
endfunction
function Iyx takes integer oqx,integer Ixx returns nothing
local integer olx=(Iax(((oqx)),Vc))
local integer IIx
loop
exitwhen(olx<q)
set IIx=(Inx(((oqx)),Vc,(olx)))
call INx(Ixx,IIx,(Ibx(((oqx)),Xc+(IIx))))
set olx=olx-1
endloop
endfunction
function IYx takes integer oqx,integer Ixx returns nothing
local integer olx=(Iax(((oqx)),Oc))
local integer IIx
local integer rdx
loop
exitwhen(olx<q)
set IIx=(Inx(((oqx)),Oc,(olx)))
set rdx=Ikx(oqx,IIx)
call IKx(IIx,Ixx,rdx,true)
call rHx(((rdx)))
set olx=olx-1
endloop
endfunction
function Izx takes integer oqx,integer Ixx returns nothing
local integer rdx=rEx(0)
set Vv[(rdx)]=(Ixx)
set Gc[(rdx)]=(oqx)
call Xfx((Lc[(oqx)]),rdx)
call rHx(((rdx)))
endfunction
function IZx takes integer oqx,integer Ixx returns nothing
local integer olx=(Iax(((oqx)),Fc))
local integer Ipx
loop
exitwhen(olx<q)
set Ipx=(Inx(((oqx)),Fc,(olx)))
call Izx(Ipx,Ixx)
set olx=olx-1
endloop
endfunction
function I_x takes integer oqx,integer Ixx returns nothing
call IWx(oqx,Ixx)
call Iyx(oqx,Ixx)
call IYx(oqx,Ixx)
call IZx(oqx,Ixx)
endfunction
function I0x takes integer oqx,integer o2x returns nothing
call rtx((oqx),ec,o2x)
call I_x(o2x,oqx)
endfunction
function I1x takes integer oqx,integer Iox,integer I2x,integer rwx,integer I3x returns nothing
local integer Itx=rEx((ZB[(Iox)]))
local integer olx
local integer rIx
local integer rlx
set mc[(Itx)]=(I3x)
set Hc[(Itx)]=(rwx)
set Mc[(Itx)]=(I2x)
set jc[(Itx)]=(Iox)
set Vv[(Itx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=IQx(Iox,pc,rIx)
loop
exitwhen(rlx<q)
call rCx(Isx(Iox,pc,rIx,rlx),Itx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((Itx)))
endfunction
function I4x takes integer oqx,integer Iox,integer I2x,integer rwx,integer I3x returns nothing
local integer Iux=(Iix(((Iox)),vc+(I2x)))
if(Iux!=w)then
call Iqx((oqx),Iux)
endif
set Iux=(Iix(((Iox)),vc+(rwx)))
if(Iux!=w)then
call I0x((oqx),Iux)
endif
call I1x(oqx,Iox,I2x,rwx,I3x)
endfunction
function I5x takes integer oqx,integer oQx,integer oSx returns boolean
return((LoadInteger(o[((D[((Eb[(oqx)]))]))],((((Xb[((oqx))])))),(osx(((oQx)),(((oSx)))))))!=0)
endfunction
function I6x takes integer oqx,integer rRx returns boolean
return(I5x((Qc[(rRx)]),Rb,(oqx)))
endfunction
function I7x takes integer oqx,integer Xwx returns nothing
if(Rv[oqx]==w)then
call oYx("FolderUnit_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oqx)+";"+(JA[(Xwx)]))
set Rv[oqx]=X
endif
call rSx(Rv[oqx],(A[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function I8x takes integer oqx,integer oQx,integer oSx returns boolean
local integer abx=oPx(oqx,oQx)
call rTx(oqx,oQx,abx+oSx)
if(abx!=0)then
return false
endif
return(oSx!=0)
endfunction
function I9x takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((zB[(oqx)]))])]))],((((ZB[((oqx))])))),(((oQx))))))
endfunction
function Avx takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx returns integer
return RFx(E[(oqx)],cO[oqx],Rbx,RBx,Rcx,RDx,0)
endfunction
function Aex takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer oSx returns integer
return RFx(E[(oqx)],DO[oqx],Rbx,RBx,Rcx,RDx,(oSx))
endfunction
function Axx takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer RKx,integer oSx returns boolean
local integer Rkx
if(RKx==0)then
set Rkx=RGx(oqx,Rbx,RBx,Rcx,RDx)
call Rjx(E[(oqx)],BO[oqx],Rbx,RBx,Rcx,RDx,0,oSx)
else
set Rkx=Rhx(oqx,Rbx,RBx,Rcx,RDx,RKx)
call Rjx(E[(oqx)],CO[oqx],Rbx,RBx,Rcx,RDx,(RKx),oSx)
endif
if(Rkx==0)then
call Rjx(E[(oqx)],cO[oqx],Rbx,RBx,Rcx,RDx,0,oSx)
else
call Rjx(E[(oqx)],dO[oqx],Rbx,RBx,Rcx,RDx,(Rkx),oSx)
endif
call Rjx(E[(oqx)],CO[oqx],Rbx,RBx,Rcx,RDx,(oSx),Rkx)
call Rjx(E[(oqx)],dO[oqx],Rbx,RBx,Rcx,RDx,(oSx),RKx)
return true
endfunction
function Aox takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer oSx,integer Arx returns boolean
local integer Aix=Avx(oqx,Rbx,RBx,Rcx,RDx)
loop
exitwhen(Aix==0)
exitwhen(Arx<=Aex(oqx,Rbx,RBx,Rcx,RDx,Aix))
set Aix=RHx(oqx,Rbx,RBx,Rcx,RDx,Aix)
endloop
if not Axx(oqx,Rbx,RBx,Rcx,RDx,Aix,oSx)then
return false
endif
call Rjx(E[(oqx)],DO[oqx],Rbx,RBx,Rcx,RDx,(oSx),Arx)
return true
endfunction
function Aax takes integer oqx returns integer
set CB[oqx]=true
set iB[oqx]=false
set dB[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set VB[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(DB)
return oqx
endfunction
function Anx takes nothing returns integer
local integer oqx
if(Tc==8190)then
call oYx("UnitEffect_Allocation_allocCustom","call DebugEx(UnitEffect.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",cB+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(BB[(w)]==w)then
set uc=uc+1
set oqx=uc
else
set oqx=BB[(w)]
set BB[(w)]=BB[BB[(w)]]
endif
set BB[oqx]=Z
set bB[oqx]=1
call Aax(oqx)
return oqx
endfunction
function AVx takes integer oqx returns nothing
set aB[(oqx)]=(oC+oqx)
endfunction
function AEx takes integer oqx,integer Xwx returns nothing
if(VB[oqx]==w)then
call oYx("FolderUnitEffect_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oqx)+";"+(JA[(Xwx)]))
set VB[oqx]=X
endif
call rSx(VB[oqx],(aB[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function AXx takes integer oqx returns boolean
set NB=NB+1
set AB[NB]=oqx
set IB[oqx]=NB+1
return(NB==0)
endfunction
function AOx takes integer Oqx,string ARx,string AIx,integer rwx returns integer
local boolean AAx=I6x(Oqx,sc)
local integer oqx=Anx()
set Uc[oqx]=AIx
set wc[oqx]=AAx
set XB[oqx]=true
set OB[oqx]=null
set Wc[oqx]=rwx
set yc[oqx]=ARx
set RB[oqx]=null
set Yc[oqx]=Oqx
if rtx(Oqx,zc,oqx)then
if AAx then
call I7x(Oqx,Zc)
else
call I7x(Oqx,vC)
endif
call I7x(Oqx,eC)
call I7x(Oqx,xC)
endif
call AVx(oqx)
call AEx(oqx,rC)
call AXx(oqx)
return oqx
endfunction
function ANx takes integer oqx returns nothing
if not XB[oqx]then
return
endif
set XB[oqx]=false
if(ci>=Wc[oqx])then
set RB[oqx]=AddSpecialEffectTarget(yc[oqx],C[Yc[oqx]],Uc[oqx])
if(RB[oqx]==null)then
endif
else
set OB[oqx]=AddSpecialEffectTarget(null,C[Yc[oqx]],Uc[oqx])
endif
endfunction
function Abx takes integer Oqx,string ARx,string AIx,integer rwx returns integer
local boolean ABx=I6x(Oqx,sc)
local integer oqx=AOx(Oqx,ARx,AIx,rwx)
if not ABx then
call ANx(oqx)
endif
return oqx
endfunction
function Acx takes integer oqx,integer oQx,integer okx returns string
return(LoadStr(o[((V[(E[((zB[(oqx)]))])]))],((((ZB[((oqx))])))),(((oQx)+(okx)))))
endfunction
function ACx takes integer oqx returns integer
set qB[oqx]=true
set XC[oqx]=false
call rax(QB)
return oqx
endfunction
function Adx takes nothing returns integer
local integer oqx
if(VC==8190)then
call oYx("UnitSound_Allocation_allocCustom","call DebugEx(UnitSound.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",PB+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(pB[(w)]==w)then
set EC=EC+1
set oqx=EC
else
set oqx=pB[(w)]
set pB[(w)]=pB[pB[(w)]]
endif
set pB[oqx]=Z
set MB[oqx]=1
call ACx(oqx)
return oqx
endfunction
function ADx takes integer oqx returns integer
set KB[oqx]=true
set FB[oqx]=false
call rax(lB)
return oqx
endfunction
function Afx takes nothing returns integer
local integer oqx
if(OC==8190)then
call oYx("Sound_Allocation_allocCustom","call DebugEx(Sound.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",kB+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(JB[(w)]==w)then
set RC=RC+1
set oqx=RC
else
set oqx=JB[(w)]
set JB[(w)]=JB[JB[(w)]]
endif
set JB[oqx]=Z
set hB[oqx]=1
call ADx(oqx)
return oqx
endfunction
function AFx takes integer oqx,integer o2x returns nothing
set NC[(oqx)]=(o2x)
if(gB[oqx]!=null)then
call SetSoundChannel(gB[oqx],o2x)
endif
endfunction
function Agx takes integer oqx returns nothing
local string AGx=(xd[((BC[(oqx)]))])
if(AGx==null)then
set AGx=""
endif
set gB[oqx]=CreateSound((IC[(oqx)]),(LB[(oqx)]),(mC[(oqx)]),(lC[(oqx)]),(R2I((((HC[(oqx)]))*1.))),(R2I((((JC[(oqx)]))*1.))),AGx)
endfunction
function Ahx takes integer rRx returns integer
local integer oqx=Afx()
set GB[oqx]=w
set IC[(oqx)]=((AC[(rRx)]))
call AFx(oqx,(bC[(rRx)]))
set BC[(oqx)]=((cC[(rRx)]))
set CC[(oqx)]=(((dC[(rRx)]))*1.)
set DC[(oqx)]=(((fC[(rRx)]))*1.)
set FC[(oqx)]=((gC[(rRx)]))
set GC[(oqx)]=(((hC[(rRx)]))*1.)
set HC[(oqx)]=(((jC[(rRx)]))*1.)
set JC[(oqx)]=(((kC[(rRx)]))*1.)
set LB[(oqx)]=((KC[(rRx)]))
set lC[(oqx)]=((LC[(rRx)]))
set mC[(oqx)]=((MC[(rRx)]))
set pC[(oqx)]=(((PC[(rRx)]))*1.)
set qC[(oqx)]=(((QC[(rRx)]))*1.)
set sC[(oqx)]=(((SC[(rRx)]))*1.)
set tC[(oqx)]=(((TC[(rRx)]))*1.)
set uC[(oqx)]=(((UC[(rRx)]))*1.)
set wC[(oqx)]=(((WC[(rRx)]))*1.)
set yC[(oqx)]=(((YC[(rRx)]))*1.)
set zC[(oqx)]=(((ZC[(rRx)]))*1.)
set vd[(oqx)]=(((ed[(rRx)]))*1.)
call Agx(oqx)
return oqx
endfunction
function AHx takes integer oqx returns nothing
call SetSoundVolume(gB[oqx],(R2I(((GC[oqx]*(od[((NC[(oqx)]))])*rd*127.)*1.))))
call StartSound(gB[oqx])
endfunction
function Ajx takes integer oqx,integer Ixx returns nothing
call AttachSoundToUnit(gB[oqx],C[Ixx])
call AHx(oqx)
endfunction
function AJx takes integer Oqx,integer Akx returns integer
local integer oqx=Adx()
local integer AKx=Ahx(Akx)
set mB[oqx]=AKx
call Ajx(AKx,Oqx)
return oqx
endfunction
function Alx takes integer oqx returns integer
set yB[oqx]=true
set Ed[oqx]=false
call rax(YB)
return oqx
endfunction
function ALx takes nothing returns integer
local integer oqx
if(nd==8190)then
call oYx("BuffRef_Allocation_allocCustom","call DebugEx(BuffRef.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",WB+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(wB[(w)]==w)then
set Vd=Vd+1
set oqx=Vd
else
set oqx=wB[(w)]
set wB[(w)]=wB[wB[(w)]]
endif
set wB[oqx]=Z
set UB[oqx]=1
call Alx(oqx)
return oqx
endfunction
function Amx takes integer oqx,integer Iox,integer rwx,integer I3x returns nothing
set Rd=oqx
set Id=Iox
set Ad=rwx
set Nd=I3x
call TriggerEvaluate(bd)
endfunction
function AMx takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx returns integer
local integer oSx=RGx(oqx,Rbx,RBx,Rcx,RDx)
local integer o4x=0
local integer Arx
loop
exitwhen(oSx==0)
set Arx=Aex(oqx,Rbx,RBx,Rcx,RDx,oSx)
if(Arx>o4x)then
set o4x=Arx
endif
set oSx=Rhx(oqx,Rbx,RBx,Rcx,RDx,oSx)
endloop
return o4x
endfunction
function Apx takes integer Iox,integer rwx,integer Ixx,integer I3x returns integer
local integer oqx=ALx()
set Xd[oqx]=I3x
set uB[oqx]=false
set Od[oqx]=rwx
set SB[oqx]=0
set tB[oqx]=Ixx
set TB[oqx]=Iox
call Aox(X,sB,Ixx,Iox,w,oqx,rwx)
call Amx(Ixx,Iox,AMx(X,sB,Ixx,Iox,w),I3x)
return oqx
endfunction
function APx takes integer oqx,integer Iox,integer rwx,integer I3x returns integer
local integer Aqx=Apx(Iox,rwx,oqx,I3x)
return Aqx
endfunction
function AQx takes integer oqx,integer Iox,integer rwx,integer I3x returns nothing
local integer olx=(IUx(((Iox)),ad))
loop
exitwhen(olx<q)
call Aox((X),(lc),(oqx),(Iox),(w),(APx(oqx,(Iwx(((Iox)),ad,(olx))),rwx,I3x)),0)
set olx=olx-1
endloop
endfunction
function Asx takes integer oqx,integer Iox,integer rwx,integer I3x returns nothing
local integer Itx=rEx((ZB[(Iox)]))
local integer olx
local integer rIx
local integer rlx
set mc[(Itx)]=(I3x)
set Hc[(Itx)]=(rwx)
set jc[(Itx)]=(Iox)
set Vv[(Itx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=IQx(Iox,Bd,rIx)
loop
exitwhen(rlx<q)
call rCx(Isx(Iox,Bd,rIx,rlx),Itx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((Itx)))
endfunction
function ASx takes integer oqx,integer Iox,integer rwx,integer I3x returns nothing
local integer Iux=(Iix(((Iox)),vc+(rwx)))
if(Iux!=w)then
call I0x((oqx),Iux)
endif
call Asx(oqx,Iox,rwx,I3x)
endfunction
function Atx takes integer oqx,integer Iox,integer rwx,integer I3x returns boolean
local integer I2x
local integer ATx
local integer olx
if(oPx((((oqx))),(yb+(Iox)))>0)then
set I2x=(oPx(((oqx)),zb+(Iox)))
if(rwx!=I2x)then
call rTx((oqx),zb+Iox,rwx)
call I4x(oqx,Iox,I2x,rwx,I3x)
endif
return false
endif
if(Pc[((oqx))])then
return false
endif
if((qc[(Iox)])and I6x((oqx),sc))then
return false
endif
if rtx((oqx),eB,Iox)then
call I7x((oqx),xB)
call I7x((oqx),oB)
endif
call I8x((oqx),yb+Iox,1)
call rTx((oqx),zb+Iox,rwx)
set ATx=(Yb[(Iox)])
if(ATx!=0)then
call rQx((oqx),ATx)
call ryx((oqx),ATx,rwx)
endif
if(Sc[(Iox)])then
set olx=(I9x(((Iox)),tc))
loop
exitwhen(olx<q)
call Aox((X),(rB),(oqx),(Iox),(w),((Abx(((oqx)),((Acx(((Iox)),tc,(olx)))),((Acx(((Iox)),iC,(olx)))),((Iwx(((Iox)),aC,(olx))))))),0)
set olx=olx-1
endloop
endif
set olx=(I9x(((Iox)),nC))
loop
exitwhen(olx<q)
call Aox((X),(fB),(oqx),(Iox),(w),((AJx(((oqx)),((Iwx(((Iox)),nC,(olx))))))),0)
set olx=olx-1
endloop
call AQx(oqx,Iox,rwx,I3x)
call ASx(oqx,Iox,rwx,I3x)
return true
endfunction
function Aux takes integer oqx,integer Iox returns boolean
set Rd=oqx
set Id=Iox
call TriggerEvaluate(Cd)
return cd
endfunction
function AUx takes integer oqx,integer Iox,integer rwx,integer I3x returns nothing
local integer I2x=(oPx(((oqx)),zb+(Iox)))
if(I2x==rwx)then
return
endif
if(rwx>0)then
call Atx(oqx,Iox,rwx,I3x)
else
call Aux(oqx,Iox)
endif
endfunction
function Awx takes integer oqx returns nothing
if uB[oqx]then
return
endif
call Iex(oqx)
call AUx(tB[oqx],TB[oqx],AMx(X,sB,tB[oqx],TB[oqx],w),Xd[oqx])
endfunction
function AWx takes integer oqx,integer Iox returns nothing
local integer Aqx=Rlx(X,lc,oqx,Iox,w)
loop
exitwhen(Aqx==w)
call Awx(Aqx)
set Aqx=Rlx(X,lc,oqx,Iox,w)
endloop
endfunction
function Ayx takes integer oqx,integer Iox returns boolean
local integer ATx
local integer rwx
local integer AYx
local integer Azx
local integer olx
if not(oPx((((oqx))),(yb+(Iox)))>0)then
return false
endif
set ATx=(Yb[(Iox)])
set rwx=(oPx(((oqx)),zb+(Iox)))
if(ATx!=0)then
call UnitRemoveAbility(C[(((oqx)))],(ATx))
call UnitRemoveAbility(C[(((oqx)))],(Zb[Iox]))
endif
call rix((oqx),yb+Iox)
call rix((oqx),zb+Iox)
call RLx(X,vB,oqx,Iox,w)
if rrx((oqx),eB,Iox)then
call Rmx((oqx),xB)
call Rmx((oqx),oB)
endif
set AYx=Rlx(X,rB,oqx,Iox,w)
loop
exitwhen(AYx==w)
call RUx(AYx)
set AYx=Rlx(X,rB,oqx,Iox,w)
endloop
set Azx=Rlx(X,fB,oqx,Iox,w)
loop
exitwhen(Azx==w)
call R6x(Azx)
set Azx=Rlx(X,fB,oqx,Iox,w)
endloop
call Irx(Iox,oqx)
call ITx(oqx,Iox,rwx)
set olx=(IUx(((Iox)),Kc))
loop
exitwhen(olx<q)
call Ayx(oqx,(Iwx(((Iox)),Kc,(olx))))
set olx=olx-1
endloop
call AWx(oqx,Iox)
return true
endfunction
function AZx takes integer oqx returns integer
set hd[oqx]=true
set Hd[oqx]=false
call rax(jd)
return oqx
endfunction
function A_x takes nothing returns integer
local integer oqx
if(Dd==8190)then
call oYx("FolderUnit_FolderBuffs_StructTimed_Allocation_allocCustom","call DebugEx(FolderUnit_FolderBuffs_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",fd+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Fd[(w)]==w)then
set gd=gd+1
set oqx=gd
else
set oqx=Fd[(w)]
set Fd[(w)]=Fd[Fd[(w)]]
endif
set Fd[oqx]=Z
set Gd[oqx]=1
call AZx(oqx)
return oqx
endfunction
function A0x takes integer oqx returns nothing
set hd[oqx]=false
call rgx(jd)
endfunction
function A1x takes integer oqx returns nothing
if(Gd[oqx]>0)then
return
endif
if(Fd[oqx]!=Z)then
call oYx("FolderUnit_FolderBuffs_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderBuffs_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",fd+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set Fd[oqx]=Fd[(w)]
set Fd[(w)]=oqx
call A0x(oqx)
endfunction
function A2x takes integer oqx returns nothing
set Gd[oqx]=Gd[oqx]-1
call A1x(oqx)
endfunction
function A3x takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer Rfx returns nothing
call SaveInteger(o[(((XO[oqx])))],((RNx(Rbx,RBx,Rcx))),((Rdx(Rbx,RDx,Rfx))),(0))
endfunction
function A4x takes integer oqx returns nothing
set qd[oqx]=false
call rgx(Qd)
endfunction
function A5x takes integer oqx returns nothing
if(Md[oqx]>0)then
return
endif
if(pd[oqx]!=Z)then
call oYx("FolderUnit_FolderBuffs_FolderTimed_StructCountdown_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderBuffs_FolderTimed_StructCountdown.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Pd+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set pd[oqx]=pd[(w)]
set pd[(w)]=oqx
call A4x(oqx)
endfunction
function A6x takes integer oqx returns nothing
set Md[oqx]=Md[oqx]-1
call A5x(oqx)
endfunction
function A7x takes integer oqx,integer ibx,integer rkx returns nothing
local integer A8x=Ld[oqx]
local integer Iox=md[oqx]
call A6x((oqx))
call ijx(A8x)
call ijx(ibx)
if rrx(rkx,sd,oqx)then
call Rmx(rkx,Sd)
endif
call rix(rkx,ld+Iox)
endfunction
function A9x takes integer oqx,integer Iox returns nothing
local integer rkx=oqx
set oqx=oPx(rkx,ld+Iox)
if(oqx!=w)then
call A7x(oqx,td[oqx],rkx)
endif
endfunction
function Nvx takes integer oqx returns nothing
set SB[oqx]=SB[oqx]-1
endfunction
function Nex takes integer oqx returns nothing
local integer ibx=Jd[oqx]
local integer rkx=kd[oqx]
local integer Nxx=Kd[oqx]
local integer rwx=Od[Nxx]
local integer Iox=TB[Nxx]
call A2x((oqx))
call ijx(ibx)
call A3x(E[((X))],(dd),(rkx),(Iox),(rwx),(w))
call A9x((rkx),Iox)
if rrx(rkx,Td,oqx)then
call Rmx(rkx,ud)
call Rmx(rkx,Ud)
endif
call Awx(Nxx)
call Nvx(Nxx)
endfunction
function Nox takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
call Nex(oqx)
endfunction
function Nrx takes integer oqx returns nothing
set SB[oqx]=SB[oqx]+1
endfunction
function Nix takes integer oqx returns integer
set qd[oqx]=true
set vD[oqx]=false
call rax(Qd)
return oqx
endfunction
function Nax takes nothing returns integer
local integer oqx
if(zd==8190)then
call oYx("FolderUnit_FolderBuffs_FolderTimed_StructCountdown_Allocation_allocCustom","call DebugEx(FolderUnit_FolderBuffs_FolderTimed_StructCountdown.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Pd+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(pd[(w)]==w)then
set Zd=Zd+1
set oqx=Zd
else
set oqx=pd[(w)]
set pd[(w)]=pd[pd[(w)]]
endif
set pd[oqx]=Z
set Md[oqx]=1
call Nix(oqx)
return oqx
endfunction
function Nnx takes nothing returns nothing
endfunction
function NVx takes integer oqx returns nothing
local integer o7x=eD[oqx]
local boolean NEx=xD[oqx]
if NEx then
set xD[oqx]=false
call OMx(oD[oqx],iqx((rD[(md[oqx])])+" vanishes in "+"
"+(I2S((o7x))),"ff00ffff"),.022,120.,1.,2.,(0))
else
call OMx(oD[oqx],iqx((I2S((o7x))),"ff00ffff"),.022,120.,1.,2.,(0))
endif
set eD[oqx]=o7x-1
endfunction
function NXx takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
call A7x(oqx,ibx,oD[oqx])
endfunction
function NOx takes integer oqx,integer Iox,real ilx returns nothing
local integer rkx=oqx
local integer o7x
local integer A8x
local integer ibx
local real NRx
set oqx=oPx(rkx,ld+Iox)
if(oqx!=w)then
call A7x(oqx,td[oqx],rkx)
endif
set o7x=(R2I(((itx(((R2I(((ilx)*1.)))),(3)))*1.)))
set A8x=inx()
set ibx=inx()
set oqx=Nax()
set NRx=ilx-o7x-1.
set eD[oqx]=o7x
set Ld[oqx]=A8x
set td[oqx]=ibx
set xD[oqx]=true
set oD[oqx]=rkx
set md[oqx]=Iox
set ge[(A8x)]=(oqx)
set ge[(ibx)]=(oqx)
if rtx(rkx,sd,oqx)then
call I7x(rkx,Sd)
endif
call rTx(rkx,ld+Iox,oqx)
call icx(A8x,NRx,false,function Nnx)
if(NRx<.0)then
call NVx(oqx)
endif
call icx(ibx,ilx-1+.01,false,function NXx)
endfunction
function NIx takes integer oqx,integer Iox,integer rwx,integer I3x,real ilx returns integer
local integer rkx=oqx
local integer ibx
local integer Nxx
set oqx=(Ifx(E[((X))],(dd),((oqx)),((Iox)),((rwx)),(w)))
if(oqx==w)then
set Nxx=APx(rkx,Iox,rwx,I3x)
if(Nxx==w)then
return w
endif
set ibx=inx()
set oqx=A_x()
set Jd[oqx]=ibx
set kd[oqx]=rkx
set Kd[oqx]=Nxx
set ge[(ibx)]=(oqx)
call IDx(E[((X))],(dd),(rkx),(Iox),(rwx),(w),(oqx))
call icx(ibx,ilx,false,function Nox)
if rtx(rkx,Td,oqx)then
call I7x(rkx,ud)
call I7x(rkx,Ud)
endif
call Nrx(Nxx)
else
set ibx=Jd[oqx]
if(ilx>(TimerGetRemaining(Oe[(ibx)])))then
call icx(ibx,ilx,false,function Nox)
endif
return w
endif
if not(wd[(Iox)])then
if(ilx!=Wd)then
if(I6x(rkx,yd)or(Yd[(Iox)]))then
call NOx((rkx),Iox,ilx)
endif
endif
endif
return Nxx
endfunction
function NAx takes integer oqx,integer Iox,integer rwx,integer I3x,real ilx returns integer
return NIx(oqx,Iox,rwx,I3x,ilx)
endfunction
function NNx takes nothing returns boolean
local integer rdx=(bv)
if(Ub==0)then
call Ayx(RVx(),wb)
return true
endif
if(Wb==0)then
call AUx(RVx(),wb,Ub,w)
else
call NAx(RVx(),wb,Ub,w,Wb)
endif
return true
endfunction
function Nbx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
local string NBx=XPx(r1x,1)
local integer Iox=RAx(NBx)
local integer rwx=(S2I((XPx(r1x,2))))
local real ilx=(S2R((XPx(r1x,3))))
if(Iox==w)then
set Iox=Xcx(NBx,F)
if(Iox==F)then
call oYx("CommandBuff_Event_Chat","call DebugEx(\"invalid buff\")","invalid buff")
return true
endif
endif
set Ub=rwx
set wb=Iox
set Wb=ilx
call O7x(ocx,function NNx)
return true
endfunction
function Ncx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer olx=iD
local integer ocx=(eN[(rdx)])
call PreloadGenStart()
loop
exitwhen(olx<0)
call oYx("CommandBuff_Event_ListAll_Chat","call DebugEx(Buff.ALL[iteration].GetName())",(rD[(aD[olx])]))
set olx=olx-1
endloop
return true
endfunction
function NCx takes nothing returns boolean
call XWx("-buff",function Nbx)
call XWx("-buffListAll",function Ncx)
return true
endfunction
function Ndx takes nothing returns boolean
call E9x(function NCx,"CommandBuff_Init")
return true
endfunction
function NDx takes nothing returns boolean
set nD=Vnx(VD)
return true
endfunction
function Nfx takes integer oqx returns integer
set AD[oqx]=true
set ND[oqx]=false
call rax(bD)
return oqx
endfunction
function NFx takes nothing returns integer
local integer oqx
if(ED==8190)then
call oYx("FolderCamera_StructSeismic_Allocation_allocCustom","call DebugEx(FolderCamera_StructSeismic.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",XD+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(OD[(w)]==w)then
set RD=RD+1
set oqx=RD
else
set oqx=OD[(w)]
set OD[(w)]=OD[OD[(w)]]
endif
set OD[oqx]=Z
set ID[oqx]=1
call Nfx(oqx)
return oqx
endfunction
function Ngx takes integer oqx returns integer
set KD[oqx]=true
set lD[oqx]=false
call rax(LD)
return oqx
endfunction
function NGx takes nothing returns integer
local integer oqx
if(hD==8190)then
call oYx("Force_Allocation_allocCustom","call DebugEx(Force.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",HD+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(jD[(w)]==w)then
set JD=JD+1
set oqx=JD
else
set oqx=jD[(w)]
set jD[(w)]=jD[jD[(w)]]
endif
set jD[oqx]=Z
set kD[oqx]=1
call Ngx(oqx)
return oqx
endfunction
function Nhx takes nothing returns integer
local integer oqx
if(GD==F)then
set oqx=NGx()
set mD[oqx]=CreateForce()
return oqx
endif
set oqx=MD[GD]
set GD=GD-1
return oqx
endfunction
function NHx takes real Njx,real NJx,real Nkx returns real
local real o4x
if(Nkx==.0)then
if(NJx==.0)then
if(Njx==.0)then
return .0
endif
return-1.
endif
return(Njx*1./ NJx)
endif
set o4x=-NJx*1./ Nkx-(SquareRoot(((NJx*NJx*1./ Nkx*1./ Nkx+2*Njx*1./ Nkx)*1.)))
if(o4x<.0)then
return(-NJx*1./ Nkx+(SquareRoot(((NJx*NJx*1./ Nkx*1./ Nkx+2*Njx*1./ Nkx)*1.))))
endif
return o4x
endfunction
function NKx takes integer oqx returns nothing
set GD=GD+1
set MD[GD]=oqx
call ForceClear(mD[oqx])
endfunction
function Nlx takes integer oqx returns nothing
set AD[oqx]=false
call rgx(bD)
endfunction
function NLx takes integer oqx returns nothing
if(ID[oqx]>0)then
return
endif
if(OD[oqx]!=Z)then
call oYx("FolderCamera_StructSeismic_Allocation_deallocCustom_confirm","call DebugEx(FolderCamera_StructSeismic.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",XD+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set OD[oqx]=OD[(w)]
set OD[(w)]=oqx
call Nlx(oqx)
endfunction
function Nmx takes integer oqx returns nothing
set ID[oqx]=ID[oqx]-1
call NLx(oqx)
endfunction
function NMx takes integer oqx returns boolean
if(((QD[((oqx))])>0)==false)then
return false
endif
set QD[sD[SD]]=QD[oqx]
set sD[QD[oqx]-1]=sD[SD]
set QD[oqx]=0
set SD=SD-1
return(SD==F)
endfunction
function Npx takes integer oqx returns nothing
local integer ibx=BD[oqx]
local integer NPx=gD[oqx]
call ijx(ibx)
call NKx(NPx)
call Nmx((oqx))
if NMx(oqx)then
call iHx(tD)
endif
endfunction
function Nqx takes nothing returns nothing
local integer oqx=(ge[(ifx())])
call Npx(oqx)
endfunction
function NQx takes integer oqx returns boolean
if((QD[((oqx))])>0)then
return false
endif
set SD=SD+1
set sD[SD]=oqx
set QD[oqx]=SD+1
return(SD==0)
endfunction
function Nsx takes nothing returns nothing
call TriggerExecute(TD)
endfunction
function NSx takes real x,real y,real z,real Ntx,real NTx,real Nux,real NJx returns nothing
local integer oqx=NFx()
local integer ibx=inx()
set BD[oqx]=ibx
set cD[oqx]=Nux
set CD[oqx]=.0
set dD[oqx]=NJx*DD
set fD[oqx]=Ntx
set FD[oqx]=NTx
set gD[oqx]=Nhx()
set pD[oqx]=x
set PD[oqx]=y
set qD[oqx]=z
set ge[(ibx)]=(oqx)
call icx(ibx,NHx(Nux,NJx,.0),false,function Nqx)
if NQx(oqx)then
call icx(tD,DD,true,function Nsx)
endif
endfunction
function NUx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
local real x=(S2R((XPx(r1x,1))))
local real y=(S2R((XPx(r1x,2))))
local real z=(S2R((XPx(r1x,3))))
local real Ntx=(S2R((XPx(r1x,4))))
local real NTx=(S2R((XPx(r1x,5))))
local real Nux=(S2R((XPx(r1x,6))))
local real NJx=(S2R((XPx(r1x,7))))
if(Ntx==.0)then
set Ntx=1000.
endif
if(Nux==.0)then
set Nux=99999.
endif
if(NJx==.0)then
set NJx=1000.
endif
call NSx(x,y,z,Ntx,NTx,Nux,NJx)
return true
endfunction
function Nwx takes integer NWx returns integer
local integer oqx
if((NWx<0)or(NWx>16-1))then
call oYx("User_GetFromNativeIndex","call DebugEx(User.NAME + \"GetFromNativeIndex: \" + Integer.ToString(nativeIndex) + \" out of bounds\")",uD+"GetFromNativeIndex: "+(I2S((NWx)))+" out of bounds")
return w
endif
set oqx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((Player(NWx))))))),((((R))))))
if(oqx==w)then
call oYx("User_GetFromNativeIndex","call DebugEx(User.NAME + \"GetFromNativeIndex: \" + Integer.ToString(nativeIndex) + \" not assigned\")",uD+"GetFromNativeIndex: "+(I2S((NWx)))+" not assigned")
return w
endif
return oqx
endfunction
function Nyx takes integer oqx returns boolean
if((yD[((oqx))])>0)then
return false
endif
set YD=YD+1
set ZD[YD]=oqx
set yD[oqx]=YD+1
return(YD==0)
endfunction
function NYx takes integer oqx returns boolean
if(((nf[((oqx))])>0)==false)then
return false
endif
set nf[Vf[Ef]]=nf[oqx]
set Vf[nf[oqx]-1]=Vf[Ef]
set nf[oqx]=0
set Ef=Ef-1
return(Ef==F)
endfunction
function Nzx takes integer ocx returns nothing
if iVx(ocx)then
call SetCameraBounds(xE,aE,oE,nE,rE,VE,iE,EE)
endif
endfunction
function NZx takes nothing returns nothing
local integer oqx=(ge[(ifx())])
local integer ocx=oqx
set af[oqx]=false
if NYx(oqx)then
call iHx(Xf)
endif
call Nzx(ocx)
endfunction
function N_x takes integer oqx returns boolean
if((nf[((oqx))])>0)then
return false
endif
set Ef=Ef+1
set Vf[Ef]=oqx
set nf[oqx]=Ef+1
return(Ef==0)
endfunction
function N0x takes nothing returns nothing
local integer i=Ef
local integer oqx
local integer ocx
loop
exitwhen(i<0)
set oqx=Vf[i]
set ocx=oqx
if iVx(ocx)then
call Nzx(ocx)
endif
set i=i-1
endloop
call icx(ifx(),.03,false,Nf)
endfunction
function N1x takes nothing returns nothing
local integer i=Ef
local integer oqx
local integer ocx
local real N2x
local real N3x
local real x
local real y
loop
exitwhen(i<0)
set oqx=Vf[i]
set ocx=oqx
set N2x=ef[oqx]
set N3x=of[oqx]
set x=(GetCameraTargetPositionX())+N2x
set y=(GetCameraTargetPositionY())+N3x
if iVx(ocx)then
if(Of[(ocx)])then
set x=x-6000*xf
endif
if(Rf[(ocx)])then
set x=x+6000*xf
endif
if(If[(ocx)])then
set y=y-6000*xf
endif
if(Af[(ocx)])then
set y=y+6000*xf
endif
endif
if iVx(ocx)then
call SetCameraBounds(x,y,x,y,x,y,x,y)
endif
set i=i-1
endloop
call icx(ifx(),.03,false,function N0x)
endfunction
function N4x takes integer ocx,real x,real y,real ilx returns nothing
local real dX=x-(GetCameraTargetPositionX())
local real dY=y-(GetCameraTargetPositionY())
local integer oqx=ocx
set ef[oqx]=dX*xf*1./ ilx
set of[oqx]=dY*xf*1./ ilx
call icx(rf[oqx],ilx,false,function NZx)
if af[oqx]then
return
endif
set af[oqx]=true
if N_x(oqx)then
call icx(Xf,xf,true,function N1x)
endif
endfunction
function N5x takes integer oqx returns boolean
if(((yD[((oqx))])>0)==false)then
return false
endif
set yD[ZD[YD]]=yD[oqx]
set ZD[yD[oqx]-1]=ZD[YD]
set yD[oqx]=0
set YD=YD-1
return(YD==F)
endfunction
function N6x takes nothing returns nothing
local integer i=YD
local integer oqx
local integer ocx
local real N7x
local real N8x
local real nUx
local real N9x
loop
exitwhen(i<0)
set oqx=ZD[i]
set ocx=oqx
set N7x=UD[oqx]+wD[oqx]
if(N7x<1)then
call N4x(ocx,(GetCameraTargetPositionX())-bf[oqx],(GetCameraTargetPositionY())-Bf[oqx],1.)
set cf[oqx]=.0
set UD[oqx]=.0
set bf[oqx]=.0
set Bf[oqx]=.0
if N5x(oqx)then
call iHx(vf)
endif
else
set N8x=(GetRandomReal(((.0)*1.),((df)*1.)))
set nUx=cf[oqx]+.9
set N9x=(Sin(((((nUx)*1.))*1.)))
set cf[oqx]=nUx
set UD[oqx]=N7x
set bf[oqx]=(Cos(((((N8x)*1.))*1.)))*N9x*N7x
set Bf[oqx]=(Sin(((((N8x)*1.))*1.)))*N9x*N7x
call N4x(ocx,(GetCameraTargetPositionX())+bf[oqx],(GetCameraTargetPositionY())+Bf[oqx],1.)
endif
set i=i-1
endloop
endfunction
function bvx takes integer ocx,real N7x,real ilx returns nothing
local integer oqx=ocx
set UD[oqx]=UD[oqx]+N7x
set wD[oqx]=wD[oqx]+(-N7x*1./ ilx*WD)
if Nyx(oqx)then
call icx(vf,WD,true,function N6x)
endif
endfunction
function bex takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
local real N7x=(S2R((XPx(r1x,1))))
local string bxx=XPx(r1x,2)
local real ilx=(S2R((XPx(r1x,3))))
local integer box
if(bxx==null)then
set box=ocx
else
set box=Nwx((S2I((bxx))))
endif
if(N7x==.0)then
set N7x=10.
endif
if(ilx==.0)then
set ilx=5.
endif
if(box!=w)then
call bvx(ocx,N7x,ilx)
endif
return true
endfunction
function brx takes nothing returns boolean
call XWx("-quake",function NUx)
call XWx("-shake",function bex)
return true
endfunction
function bix takes nothing returns boolean
call E9x(function brx,"CommandCreateQuake_Init")
return true
endfunction
function bax takes nothing returns boolean
set Df=Vnx(ff)
return true
endfunction
function bnx takes string rqx returns integer
return(rmx(lv[(E[((X))])],(((rqx))),(((I2S(((Ff))))))))
endfunction
function bVx takes integer rRx,integer ocx,real x,real y,real N8x returns integer
set gf=x
set Gf=y
set hf=N8x
set Hf=ocx
set jf=rRx
call rcx(Jf)
return Ib
endfunction
function bEx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
local integer rRx=bnx(XPx(r1x,1))
local integer bXx
local string bOx=XPx(r1x,2)
local real x=(S2R((XPx(r1x,3))))
local real y=(S2R((XPx(r1x,4))))
if(bOx==null)then
set bXx=ocx
else
set bXx=Nwx((S2I((bOx))))
endif
if(rRx==w)then
call ajx("invalid unit type")
return true
endif
call bVx(rRx,bXx,x,y,Kf)
return true
endfunction
function bRx takes nothing returns boolean
call XWx("-create",function bEx)
return true
endfunction
function bIx takes nothing returns boolean
call E9x(function bRx,"CommandCreateUnit_Init")
return true
endfunction
function bAx takes nothing returns boolean
set lf=Vnx(Lf)
return true
endfunction
function bNx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
call oYx("CommandDebug_Event_Chat","call DebugEx(String.Word(input, 1))",XPx(r1x,1))
return true
endfunction
function bbx takes nothing returns boolean
call XWx("-debug",function bNx)
return true
endfunction
function bBx takes nothing returns boolean
call E9x(function bbx,"CommandDebug_Init")
return true
endfunction
function bcx takes nothing returns boolean
set mf=Vnx(Mf)
return true
endfunction
function bCx takes integer oqx,real oSx returns nothing
set Pf[oqx]=oSx
call SetHeroXP(C[(oqx)],(R2I(((oSx)*1.))),false)
endfunction
function bdx takes nothing returns boolean
local integer rdx=(bv)
call bCx(RVx(),pf)
return true
endfunction
function bDx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
local real o2x=(S2R((XPx(r1x,1))))
set pf=o2x
call O7x(ocx,function bdx)
return true
endfunction
function bfx takes nothing returns boolean
call XWx("-exp",function bDx)
return true
endfunction
function bFx takes nothing returns boolean
call E9x(function bfx,"CommandExp_Init")
return true
endfunction
function bgx takes nothing returns boolean
set WI=Vnx(SI)
return true
endfunction
function bGx takes nothing returns boolean
set qf=Vnx(Qf)
return true
endfunction
function bhx takes integer oqx returns nothing
set wf[(oqx)]=(((Uf[(oqx)])+(Wf[(oqx)]))*1.)
endfunction
function bHx takes integer oqx,real oSx returns nothing
set Uf[oqx]=oSx
call bhx((oqx))
endfunction
function bjx takes integer oqx,real oSx returns nothing
call bHx(oqx,(Uf[(oqx)])+oSx)
endfunction
function bJx takes real oSx,real bkx,real nwx returns real
return itx(iOx(bkx,oSx),nwx)
endfunction
function bKx takes integer oqx returns nothing
set eF[(oqx)]=(((xF[(oqx)])+(vF[(oqx)]))*1.)
endfunction
function blx takes integer oqx,real oSx returns nothing
set vF[oqx]=oSx
call bKx((oqx))
endfunction
function bLx takes integer oqx,real oSx returns nothing
call blx(oqx,(vF[(oqx)])+oSx)
endfunction
function bmx takes integer oqx returns nothing
set rF[(oqx)]=(((iF[(oqx)])+(oF[(oqx)]))*1.)
endfunction
function bMx takes integer oqx,real oSx returns nothing
set oF[oqx]=oSx
call bmx((oqx))
endfunction
function bpx takes integer oqx,real oSx returns nothing
call bMx(oqx,(oF[(oqx)])+oSx)
endfunction
function bPx takes integer oqx,real oSx returns nothing
local real nwx=(zf[((oqx))])
local real abx=(Zf[(oqx)])
set oSx=bJx(oSx,.0,(zf[((oqx))]))
set Zf[oqx]=oSx
call bLx((oqx),oSx-abx)
call bpx((oqx),oSx-abx)
endfunction
function bqx takes integer oqx,real oSx returns nothing
local real abx=(zf[(oqx)])
set zf[oqx]=oSx
if(abx==.0)then
return
endif
call bPx((oqx),(Zf[((oqx))])*1./ abx*oSx)
endfunction
function bQx takes integer oqx returns nothing
call bqx(oqx,(Yf[(oqx)])*(aF[(oqx)])+(nF[(oqx)]))
endfunction
function bsx takes integer oqx,real oSx returns nothing
set Yf[oqx]=oSx
call bQx((oqx))
endfunction
function bSx takes integer oqx,real oSx returns nothing
call bsx(oqx,(Yf[(oqx)])+oSx)
endfunction
function btx takes integer oqx,real nyx returns nothing
if((Tf[((uf[((oqx))]))])==1)then
set nyx=1.25*nyx
endif
call bjx((oqx),nyx*yf)
call bSx((oqx),nyx*VF)
endfunction
function bTx takes integer oqx,integer oQx returns boolean
return((LoadInteger(o[((V[(E[((I[(oqx)]))])]))],((((A[((oqx))])))),(((oQx)))))==0)
endfunction
function bux takes integer a returns integer
if(a>yE)then
return(VDx((a),(2)))
endif
return zE[a]
endfunction
function bUx takes real a returns real
if(a<0)then
return-a
endif
return a
endfunction
function bwx takes integer oqx,unit oMx,real nyx,real bWx returns nothing
local integer byx
local integer bYx
set nyx=nyx*1
set bWx=bWx*1
if(nyx*bWx<=.0)then
if(bWx<.0)then
set bYx=AF
loop
call UnitRemoveAbility(oMx,NF[bYx])
set bYx=bYx-1
exitwhen(bYx<0)
endloop
else
set bYx=bF
loop
call UnitRemoveAbility(oMx,BF[bYx])
set bYx=bYx-1
exitwhen(bYx<0)
endloop
endif
if(nyx<.0)then
set nyx=-nyx
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(AF)))*1.)))
loop
exitwhen(nyx<1.)
set byx=cF[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
call UnitAddAbility(oMx,NF[bYx])
endif
set bYx=bYx-1
endloop
else
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(bF)))*1.)))
loop
exitwhen(nyx<1.)
set byx=cF[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
call UnitAddAbility(oMx,BF[bYx])
endif
set bYx=bYx-1
endloop
endif
else
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(AF)))*1.)))
if(nyx<.0)then
set nyx=-nyx
loop
exitwhen(bYx<0)
set byx=cF[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
call UnitAddAbility(oMx,NF[bYx])
else
call UnitRemoveAbility(oMx,NF[bYx])
endif
set bYx=bYx-1
endloop
else
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(bF)))*1.)))
loop
exitwhen(bYx<0)
set byx=cF[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
else
call UnitRemoveAbility(oMx,BF[bYx])
endif
set bYx=bYx-1
endloop
endif
endif
endfunction
function bzx takes integer oqx,real oSx,real abx returns nothing
set OF[oqx]=oSx
call bwx(CF,C[(oqx)],oSx,abx)
endfunction
function bZx takes integer oqx,real oSx returns nothing
local real b_x=OF[oqx]
set XF[oqx]=oSx
if(oSx==b_x)then
if RF[oqx]then
set RF[oqx]=false
call Rmx((oqx),IF)
endif
return
endif
if(bTx((((oqx))),db))then
if not RF[oqx]then
set RF[oqx]=true
call I7x((oqx),IF)
endif
else
call bzx(oqx,oSx,b_x)
endif
endfunction
function b0x takes integer oqx returns nothing
set dF[oqx]=(Wf[((oqx))])
endfunction
function b1x takes integer oqx,real oSx returns nothing
set Wf[oqx]=(Wf[(oqx)])+oSx
call b0x(oqx)
endfunction
function b2x takes integer oqx,real oSx returns nothing
set nF[oqx]=oSx
call bQx((oqx))
endfunction
function b3x takes integer oqx,real oSx returns nothing
call b2x(oqx,(nF[(oqx)])+oSx)
endfunction
function b4x takes integer oqx,real nyx returns nothing
if((Tf[((uf[((oqx))]))])==1)then
set nyx=1.25*nyx
endif
call b1x((oqx),nyx*yf)
call b3x((oqx),nyx*VF)
endfunction
function b5x takes integer oqx,real oSx returns nothing
local integer b6x=(R2I((((XF[(oqx)]))*1.)))
local integer b7x=(R2I(((oSx)*1.)))
call bZx(oqx,oSx)
call b4x(oqx,b7x-b6x)
endfunction
function b8x takes integer oqx returns nothing
call b5x(oqx,(tf[((oqx))])*((DF[((oqx))])-1)+(fF[((oqx))]))
endfunction
function b9x takes integer oqx,real oSx returns nothing
set EF[oqx]=oSx
call b8x(oqx)
endfunction
function Bvx takes integer oqx returns nothing
call b9x(oqx,(tf[(oqx)])*(DF[(oqx)])+(fF[(oqx)]))
endfunction
function Bex takes integer oqx,real oSx returns nothing
local integer b6x=(R2I((((tf[(oqx)]))*1.)))
local integer b7x=(R2I(((oSx)*1.)))
set tf[oqx]=oSx
call SetHeroAgi(C[(oqx)],b7x,true)
call btx(oqx,b7x-b6x)
call Bvx((oqx))
endfunction
function Bxx takes integer oqx,real oSx returns nothing
call Bex(oqx,(tf[(oqx)])+oSx)
endfunction
function Box takes integer oqx returns boolean
if((HF[((oqx))])>0)then
return false
endif
set jF=jF+1
set JF[jF]=oqx
set HF[oqx]=jF+1
return(jF==0)
endfunction
function Brx takes nothing returns nothing
local integer olx=jF
loop
exitwhen(olx<0)
set KF[olx]=JF[olx]
set olx=olx-1
endloop
set lF=jF
endfunction
function Bix takes nothing returns integer
local integer o4x
if(lF<0)then
return w
endif
set o4x=KF[0]
set KF[0]=KF[lF]
set lF=lF-1
return o4x
endfunction
function Bax takes real a,limitop Bnx,real b returns boolean
if(Bnx==LESS_THAN)then
if(a<b)then
return true
endif
elseif(Bnx==LESS_THAN_OR_EQUAL)then
if(a<=b)then
return true
endif
elseif(Bnx==EQUAL)then
if(a==b)then
return true
endif
elseif(Bnx==NOT_EQUAL)then
if(a!=b)then
return true
endif
elseif(Bnx==GREATER_THAN)then
if(a>b)then
return true
endif
elseif(Bnx==GREATER_THAN_OR_EQUAL)then
if(a>=b)then
return true
endif
endif
return false
endfunction
function BVx takes integer rkx,real abx,real oSx returns nothing
local integer rdx=rEx((A[(rkx)]))
local integer olx
local integer rIx
local integer rlx
local integer Xwx
local limitop BEx
local integer BXx
set Vv[(rdx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,MF,rIx)
loop
exitwhen(rlx<q)
set Xwx=rDx(rkx,MF,rIx,rlx)
set BEx=(RA[(Xwx)])
set BXx=(OA[(Xwx)])
if(Bax(oSx,BEx,BXx)and not Bax(abx,BEx,BXx))then
call rCx(Xwx,rdx)
endif
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function BOx takes integer oqx,real oSx returns nothing
local real abx=(LF[(oqx)])
set oSx=bJx(oSx,.0,(mF[((oqx))]))
set LF[oqx]=oSx
call SetUnitState(C[(oqx)],UNIT_STATE_MANA,oSx)
call BVx(oqx,abx,oSx)
endfunction
function BRx takes integer oqx,real oSx returns nothing
call BOx(oqx,(LF[(oqx)])+oSx)
endfunction
function BIx takes nothing returns nothing
local integer oqx
call Brx()
loop
set oqx=Bix()
exitwhen(oqx==w)
call BRx((oqx),(GF[(oqx)])*1.5)
endloop
endfunction
function BAx takes integer oqx returns nothing
if Box(oqx)then
call icx(kF,1.5,true,function BIx)
endif
endfunction
function BNx takes integer oqx returns boolean
if(((HF[((oqx))])>0)==false)then
return false
endif
set HF[JF[jF]]=HF[oqx]
set JF[HF[oqx]-1]=JF[jF]
set HF[oqx]=0
set jF=jF-1
return(jF==F)
endfunction
function Bbx takes integer oqx returns nothing
if BNx(oqx)then
call iHx(kF)
endif
endfunction
function BBx takes integer oqx,real oSx returns nothing
local real abx=GF[oqx]
set GF[oqx]=oSx
if((abx>.0)==(oSx>.0))then
return
endif
if(oPx(((((oqx)))),(yb+(hF)))>0)then
return
endif
if(oSx>.0)then
call BAx(oqx)
else
call Bbx(oqx)
endif
endfunction
function Bcx takes integer oqx returns nothing
call BBx(oqx,(gF[(oqx)])*(pF[(oqx)])+(PF[(oqx)]))
endfunction
function BCx takes integer oqx,real oSx returns nothing
set gF[oqx]=oSx
call Bcx((oqx))
endfunction
function Bdx takes integer oqx,real oSx returns nothing
call BCx(oqx,(gF[(oqx)])+oSx)
endfunction
function BDx takes integer oqx,integer nyx returns nothing
local integer Bfx
local integer BFx
if(nyx<0)then
set nyx=-nyx
set Bfx=nyx/ sF
set nyx=nyx-Bfx*sF
loop
exitwhen(Bfx<1)
call rQx((oqx),SF)
call ryx((oqx),SF,2)
call UnitRemoveAbility(C[(((oqx)))],(SF))
set Bfx=Bfx-1
endloop
set BFx=tF[nyx]
call rQx((oqx),BFx)
call ryx((oqx),BFx,2)
call UnitRemoveAbility(C[(((oqx)))],(BFx))
else
set Bfx=nyx/ TF
set nyx=nyx-Bfx*TF
loop
exitwhen(Bfx<1)
call rQx((oqx),uF)
call ryx((oqx),uF,2)
call UnitRemoveAbility(C[(((oqx)))],(uF))
set Bfx=Bfx-1
endloop
set BFx=UF[nyx]
call rQx((oqx),BFx)
call ryx((oqx),BFx,2)
call UnitRemoveAbility(C[(((oqx)))],(BFx))
endif
endfunction
function Bgx takes integer oqx,real abx,real oSx returns nothing
if((LF[((oqx))])==.0)then
return
endif
call BOx((oqx),(LF[((oqx))])*1./ abx*oSx)
endfunction
function BGx takes integer oqx,real oSx returns nothing
local real abx=mF[oqx]
if(abx==oSx)then
return
endif
set mF[oqx]=oSx
call BDx(oqx,(R2I(((oSx-abx)*1.))))
if(abx!=.0)then
call Bgx(oqx,abx,oSx)
endif
endfunction
function Bhx takes integer oqx returns nothing
call BGx(oqx,(QF[(oqx)])*(wF[(oqx)])+(WF[(oqx)]))
endfunction
function BHx takes integer oqx,real oSx returns nothing
set QF[oqx]=oSx
call Bhx((oqx))
endfunction
function Bjx takes integer oqx,real oSx returns nothing
call BHx(oqx,(QF[(oqx)])+oSx)
endfunction
function BJx takes integer oqx,real oSx returns nothing
set zF[oqx]=oSx-(YF[(oqx)])
set ZF[oqx]=oSx
endfunction
function Bkx takes integer oqx returns nothing
call BJx(oqx,(YF[(oqx)])*(vg[(oqx)])+(eg[(oqx)]))
endfunction
function BKx takes integer oqx,real oSx returns nothing
set YF[oqx]=oSx
call Bkx((oqx))
endfunction
function Blx takes integer oqx,real oSx returns nothing
call BKx(oqx,(YF[(oqx)])+oSx)
endfunction
function BLx takes integer oqx,real nyx returns nothing
if((Tf[((uf[((oqx))]))])==2)then
set nyx=1.25*nyx
endif
call Bdx((oqx),nyx*qF)
call Bjx((oqx),nyx*yF)
call Blx((oqx),nyx*xg)
endfunction
function Bmx takes integer oqx,unit oMx,real nyx,real bWx returns nothing
local integer byx
local integer bYx
set nyx=nyx*1
set bWx=bWx*1
if(nyx*bWx<=.0)then
if(bWx<.0)then
set bYx=Vg
loop
call UnitRemoveAbility(oMx,Eg[bYx])
set bYx=bYx-1
exitwhen(bYx<0)
endloop
else
set bYx=Xg
loop
call UnitRemoveAbility(oMx,Og[bYx])
set bYx=bYx-1
exitwhen(bYx<0)
endloop
endif
if(nyx<.0)then
set nyx=-nyx
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(Vg)))*1.)))
loop
exitwhen(nyx<1.)
set byx=Rg[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
call UnitAddAbility(oMx,Eg[bYx])
endif
set bYx=bYx-1
endloop
else
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(Xg)))*1.)))
loop
exitwhen(nyx<1.)
set byx=Rg[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
call UnitAddAbility(oMx,Og[bYx])
endif
set bYx=bYx-1
endloop
endif
else
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(Vg)))*1.)))
if(nyx<.0)then
set nyx=-nyx
loop
exitwhen(bYx<0)
set byx=Rg[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
call UnitAddAbility(oMx,Eg[bYx])
else
call UnitRemoveAbility(oMx,Eg[bYx])
endif
set bYx=bYx-1
endloop
else
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(Xg)))*1.)))
loop
exitwhen(bYx<0)
set byx=Rg[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
else
call UnitRemoveAbility(oMx,Og[bYx])
endif
set bYx=bYx-1
endloop
endif
endif
endfunction
function BMx takes integer oqx,real oSx,real abx returns nothing
set ig[oqx]=oSx
call Bmx(Ig,C[(oqx)],oSx,abx)
endfunction
function Bpx takes integer oqx,real oSx returns nothing
local real b_x=ig[oqx]
set rg[oqx]=oSx
if(oSx==b_x)then
if ag[oqx]then
set ag[oqx]=false
call Rmx((oqx),ng)
endif
return
endif
if(bTx((((oqx))),db))then
if not ag[oqx]then
set ag[oqx]=true
call I7x((oqx),ng)
endif
else
call BMx(oqx,oSx,b_x)
endif
endfunction
function BPx takes integer oqx,real oSx returns nothing
set PF[oqx]=oSx
call Bcx((oqx))
endfunction
function Bqx takes integer oqx,real oSx returns nothing
call BPx(oqx,(PF[(oqx)])+oSx)
endfunction
function BQx takes integer oqx,real oSx returns nothing
set WF[oqx]=oSx
call Bhx((oqx))
endfunction
function Bsx takes integer oqx,real oSx returns nothing
call BQx(oqx,(WF[(oqx)])+oSx)
endfunction
function BSx takes integer oqx,real oSx returns nothing
set eg[oqx]=oSx
call Bkx((oqx))
endfunction
function Btx takes integer oqx,real oSx returns nothing
call BSx(oqx,(eg[(oqx)])+oSx)
endfunction
function BTx takes integer oqx,real nyx returns nothing
if((Tf[((uf[((oqx))]))])==2)then
set nyx=1.25*nyx
endif
call Bqx((oqx),nyx*qF)
call Bsx((oqx),nyx*yF)
call Btx((oqx),nyx*xg)
endfunction
function Bux takes integer oqx,real oSx returns nothing
local integer b6x=(R2I((((rg[(oqx)]))*1.)))
local integer b7x=(R2I(((oSx)*1.)))
call Bpx(oqx,oSx)
call BTx(oqx,b7x-b6x)
endfunction
function BUx takes integer oqx returns nothing
call Bux(oqx,(FF[((oqx))])*((Ag[((oqx))])-1)+(Ng[((oqx))]))
endfunction
function Bwx takes integer oqx,real oSx returns nothing
set og[oqx]=oSx
call BUx(oqx)
endfunction
function BWx takes integer oqx returns nothing
call Bwx(oqx,(FF[(oqx)])*(Ag[(oqx)])+(Ng[(oqx)]))
endfunction
function Byx takes integer oqx,real oSx returns nothing
local integer b6x=(R2I((((FF[(oqx)]))*1.)))
local integer b7x=(R2I(((oSx)*1.)))
set FF[oqx]=oSx
call SetHeroInt(C[(oqx)],b7x,true)
call BLx(oqx,b7x-b6x)
call BWx((oqx))
endfunction
function BYx takes integer oqx,real oSx returns nothing
call Byx(oqx,(FF[(oqx)])+oSx)
endfunction
function Bzx takes integer oqx returns boolean
return bTx((oqx),db)
endfunction
function BZx takes integer oqx,unit oMx,real nyx returns nothing
local boolean B_x=(UnitInventorySize(oMx)>0)
local integer byx
local integer bYx
if not B_x then
call UnitAddAbility(oMx,'AInv')
endif
if(nyx<0)then
set nyx=-nyx
set bYx=gg
loop
exitwhen(nyx<1)
set byx=Gg[bYx]
loop
exitwhen(nyx<byx)
call UnitAddItem(oMx,hg[bYx])
set nyx=nyx-byx
endloop
set bYx=bYx-1
endloop
else
set bYx=Hg
loop
exitwhen(nyx<1)
set byx=Gg[bYx]
loop
exitwhen(nyx<byx)
call UnitAddItem(oMx,jg[bYx])
set nyx=nyx-byx
endloop
set bYx=bYx-1
endloop
endif
if not B_x then
call UnitRemoveAbility(oMx,'AInv')
endif
endfunction
function B0x takes integer oqx,real oSx,real abx returns boolean
if IsUnitPaused(C[(oqx)])then
return false
endif
set cg[oqx]=oSx
call DisableTrigger(fA[(fg)])
call DisableTrigger(fA[(Fg)])
call BZx(Jg,C[(oqx)],(R2I(((oSx)*1.)))-(R2I(((abx)*1.))))
call EnableTrigger(fA[(fg)])
call EnableTrigger(fA[(Fg)])
return true
endfunction
function B1x takes integer oqx,real oSx returns nothing
local real b_x=cg[oqx]
set Cg[oqx]=oSx
if(oSx==b_x)then
if dg[oqx]then
set dg[oqx]=false
call Rmx((oqx),Dg)
endif
return
endif
if Bzx((oqx))then
if not dg[oqx]then
set dg[oqx]=true
call I7x((oqx),Dg)
endif
else
call B0x(oqx,oSx,b_x)
endif
endfunction
function B2x takes integer oqx returns nothing
call B1x(oqx,(Bg[((oqx))]))
endfunction
function B3x takes integer oqx,unit oMx,real nyx,real bWx returns nothing
local integer byx
local integer bYx
set nyx=nyx*1
set bWx=bWx*1
if(nyx*bWx<=.0)then
if(bWx<.0)then
set bYx=Qg
loop
call UnitRemoveAbility(oMx,sg[bYx])
set bYx=bYx-1
exitwhen(bYx<0)
endloop
else
set bYx=Sg
loop
call UnitRemoveAbility(oMx,tg[bYx])
set bYx=bYx-1
exitwhen(bYx<0)
endloop
endif
if(nyx<.0)then
set nyx=-nyx
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(Qg)))*1.)))
loop
exitwhen(nyx<1.)
set byx=Tg[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
call UnitAddAbility(oMx,sg[bYx])
endif
set bYx=bYx-1
endloop
else
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(Sg)))*1.)))
loop
exitwhen(nyx<1.)
set byx=Tg[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
call UnitAddAbility(oMx,tg[bYx])
endif
set bYx=bYx-1
endloop
endif
else
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(Qg)))*1.)))
if(nyx<.0)then
set nyx=-nyx
loop
exitwhen(bYx<0)
set byx=Tg[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
call UnitAddAbility(oMx,sg[bYx])
else
call UnitRemoveAbility(oMx,sg[bYx])
endif
set bYx=bYx-1
endloop
else
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(Sg)))*1.)))
loop
exitwhen(bYx<0)
set byx=Tg[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
else
call UnitRemoveAbility(oMx,tg[bYx])
endif
set bYx=bYx-1
endloop
endif
endif
endfunction
function B4x takes integer oqx,real oSx,real abx returns nothing
set Mg[oqx]=oSx
call B3x(ug,C[(oqx)],oSx,abx)
endfunction
function B5x takes integer oqx,real oSx returns nothing
local real b_x=Mg[oqx]
set pg[oqx]=oSx
if(oSx==b_x)then
if Pg[oqx]then
set Pg[oqx]=false
call Rmx((oqx),qg)
endif
return
endif
if Bzx((oqx))then
if not Pg[oqx]then
set Pg[oqx]=true
call I7x((oqx),qg)
endif
else
call B4x(oqx,oSx,b_x)
endif
endfunction
function B6x takes integer oqx returns nothing
call B5x((oqx),(((Bg[((oqx))])*((Kg[((oqx))])-1)+(kg[((oqx))]))*1.))
endfunction
function B7x takes integer oqx,real oSx returns nothing
set mg[oqx]=oSx
call B6x(oqx)
endfunction
function B8x takes integer oqx returns nothing
local real B9x=(Bg[(oqx)])
local real cvx=(kg[(oqx)])
local real cex=(Kg[(oqx)])
set lg[oqx]=B9x*cex+cvx
set Lg[oqx]=B9x*(cex-1)+cvx
call B7x(oqx,B9x*cex*(Ug[(oqx)])+cvx)
endfunction
function cxx takes integer oqx,real oSx returns nothing
set Bg[oqx]=oSx
call B2x(oqx)
call B8x((oqx))
endfunction
function cox takes integer oqx,real oSx returns nothing
call cxx(oqx,(Bg[(oqx)])+oSx)
endfunction
function crx takes integer oqx returns boolean
if((zg[((oqx))])>0)then
return false
endif
set Zg=Zg+1
set vG[Zg]=oqx
set zg[oqx]=Zg+1
return(Zg==0)
endfunction
function cix takes nothing returns nothing
local integer olx=Zg
loop
exitwhen(olx<0)
set xG[olx]=vG[olx]
set olx=olx-1
endloop
set oG=Zg
endfunction
function cax takes nothing returns integer
local integer o4x
if(oG<0)then
return w
endif
set o4x=xG[0]
set xG[0]=xG[oG]
set oG=oG-1
return o4x
endfunction
function cnx takes integer oqx returns boolean
set pN=pN+1
set MN[pN]=oqx
set mN[oqx]=pN+1
return(pN==0)
endfunction
function cVx takes integer oqx,real x,real y,real z returns nothing
call XZx(oqx,(oN[(oqx)])+x,(rN[(oqx)])+y,(iN[(oqx)])+z)
endfunction
function cEx takes integer oqx,real oSx returns nothing
set jN[oqx]=oSx
call SetTextTagText(nN[(oqx)],FN[oqx],oSx)
endfunction
function cXx takes nothing returns nothing
local integer olx=pN
local integer oqx
local real cOx
local real cRx
local real cIx
loop
set oqx=MN[olx]
set cOx=VG[oqx]+OG[oqx]
set cRx=bG[oqx]+cG[oqx]
set cIx=nG[oqx]+cOx
set nG[oqx]=cIx
set VG[oqx]=cOx
set bG[oqx]=cRx
call cVx((oqx),AG[oqx],NG[oqx],cRx)
call cEx((oqx),cIx*IG[oqx])
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function cAx takes nothing returns nothing
local integer ibx=ifx()
local integer oqx=(ge[(ibx)])
call Oix(oqx,ibx)
call OBx((oqx))
endfunction
function cNx takes string iNx,real X7x,real x,real y,real z,integer id returns integer
local integer rkx=X4x(id)
local real N8x
local integer oqx
local integer ibx
if(rkx==w)then
return w
endif
set N8x=(GetRandomReal(((.0)*1.),((df)*1.)))
set oqx=rkx
set ibx=inx()
set nG[oqx]=1.
set VG[oqx]=EG*XG
set OG[oqx]=RG*XG*XG
set IG[oqx]=X7x
set AG[oqx]=(Cos(((((N8x)*1.))*1.)))*20.*XG
set NG[oqx]=(Sin(((((N8x)*1.))*1.)))*20.*XG
set bG[oqx]=BG*XG
set cG[oqx]=CG*XG*XG
set qN[oqx]=ibx
set LN[oqx]=true
set ge[(ibx)]=(oqx)
call XZx(rkx,x,y,z)
call X6x(rkx,iNx,X7x)
if cnx(oqx)then
call icx(PN,XG,true,function cXx)
endif
call icx(ibx,1.5,false,function cAx)
call Ojx(rkx,.75,1.5)
return rkx
endfunction
function cbx takes integer oqx,string iNx,real X7x,integer id returns integer
local real x=(GetUnitX(C[((oqx))]))
local real y=(GetUnitY(C[((oqx))]))
return cNx(iNx,X7x,x,y,Olx(oqx,x,y)+OLx(oqx,true),id)
endfunction
function cBx takes integer oqx returns boolean
if not(aG[(oqx)])then
return false
endif
call cbx((oqx),iqx("Immortal!!","ff777777"),.02,dG+oqx)
return true
endfunction
function ccx takes integer oqx,integer cCx returns nothing
local integer rdx=rEx(0)
local integer olx
local integer rIx
local integer rlx
set FG[(rdx)]=(cCx)
set Vv[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((gG))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((gG))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function cdx takes integer oqx,integer cCx returns nothing
call ccx(oqx,cCx)
set GG=cCx
endfunction
function cDx takes integer oqx returns nothing
local integer cCx=fG
set fG=w
call cdx((oqx),cCx)
endfunction
function cfx takes integer rkx,real abx,real oSx returns nothing
local integer rdx=rEx((A[(rkx)]))
local integer olx
local integer rIx
local integer rlx
local integer Xwx
local limitop BEx
local integer BXx
set Vv[(rdx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,hG,rIx)
loop
exitwhen(rlx<q)
set Xwx=rDx(rkx,hG,rIx,rlx)
if(XA[(Xwx)])then
set BEx=(RA[(Xwx)])
set BXx=(OA[(Xwx)])
if(Bax(oSx,BEx,BXx)and not Bax(abx,BEx,BXx))then
call rCx(Xwx,rdx)
endif
else
call rCx(Xwx,rdx)
endif
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function cFx takes integer oqx,real oSx returns nothing
local real abx=(rG[(oqx)])
local boolean cgx=(not I6x((oqx),sc)and(oSx<.405))
set oSx=bJx(oSx,.0,(iG[((oqx))]))
set rG[oqx]=oSx
if cgx then
if cBx((oqx))then
set cgx=false
set oSx=DG
else
call cDx(oqx)
endif
endif
call SetWidgetLife(C[(oqx)],oSx)
call cfx(oqx,abx,oSx)
endfunction
function cGx takes integer oqx,real oSx returns nothing
call cFx(oqx,(rG[(oqx)])+oSx)
endfunction
function chx takes nothing returns nothing
local integer oqx
call cix()
loop
set oqx=cax()
exitwhen(oqx==w)
call cGx((oqx),(yg[(oqx)])*1.5)
endloop
endfunction
function cHx takes integer oqx returns nothing
if crx(oqx)then
call icx(eG,1.5,true,function chx)
endif
endfunction
function cjx takes integer oqx returns boolean
if(((zg[((oqx))])>0)==false)then
return false
endif
set zg[vG[Zg]]=zg[oqx]
set vG[zg[oqx]-1]=vG[Zg]
set zg[oqx]=0
set Zg=Zg-1
return(Zg==F)
endfunction
function cJx takes integer oqx returns nothing
if cjx(oqx)then
call iHx(eG)
endif
endfunction
function ckx takes integer oqx,real oSx returns nothing
local real abx=yg[oqx]
set yg[oqx]=oSx
if((abx>.0)==(oSx>.0))then
return
endif
if(oPx(((((oqx)))),(yb+(Yg)))>0)then
return
endif
if(oSx>.0)then
call cHx(oqx)
else
call cJx(oqx)
endif
endfunction
function cKx takes integer oqx returns nothing
call ckx(oqx,(Wg[(oqx)])*(HG[(oqx)])+(jG[(oqx)]))
endfunction
function clx takes integer oqx,real oSx returns nothing
set Wg[oqx]=oSx
call cKx((oqx))
endfunction
function cLx takes integer oqx,real oSx returns nothing
call clx(oqx,(Wg[(oqx)])+oSx)
endfunction
function cmx takes integer oqx,integer nyx returns nothing
local integer Bfx
local integer BFx
if(nyx<0)then
set nyx=-nyx
set Bfx=nyx/ KG
set nyx=nyx-Bfx*KG
loop
exitwhen(Bfx<1)
call rQx((oqx),lG)
call ryx((oqx),lG,2)
call UnitRemoveAbility(C[(((oqx)))],(lG))
set Bfx=Bfx-1
endloop
set BFx=LG[nyx]
call rQx((oqx),BFx)
call ryx((oqx),BFx,2)
call UnitRemoveAbility(C[(((oqx)))],(BFx))
else
set Bfx=nyx/ mG
set nyx=nyx-Bfx*mG
loop
exitwhen(Bfx<1)
call rQx((oqx),MG)
call ryx((oqx),MG,2)
call UnitRemoveAbility(C[(((oqx)))],(MG))
set Bfx=Bfx-1
endloop
set BFx=pG[nyx]
call rQx((oqx),BFx)
call ryx((oqx),BFx,2)
call UnitRemoveAbility(C[(((oqx)))],(BFx))
endif
endfunction
function cMx takes integer oqx,real abx,real oSx returns nothing
local real cpx=(rG[((oqx))])
if(cpx==.0)then
return
endif
call cFx((oqx),cpx*1./ abx*oSx)
endfunction
function cPx takes integer oqx,real oSx returns nothing
local real abx=iG[oqx]
if(abx==oSx)then
return
endif
set iG[oqx]=oSx
call cmx(oqx,(R2I(((oSx-abx)*1.))))
if(abx!=.0)then
call cMx(oqx,abx,oSx)
endif
endfunction
function cqx takes integer oqx returns nothing
call cPx(oqx,(kG[(oqx)])*(PG[(oqx)])+(qG[(oqx)]))
endfunction
function cQx takes integer oqx,real oSx returns nothing
set kG[oqx]=oSx
call cqx((oqx))
endfunction
function csx takes integer oqx,real oSx returns nothing
call cQx(oqx,(kG[(oqx)])+oSx)
endfunction
function cSx takes integer oqx,real nyx returns nothing
if((Tf[((uf[((oqx))]))])==3)then
set nyx=1.25*nyx
endif
call cox((oqx),nyx*wg)
call cLx((oqx),nyx*JG)
call csx((oqx),nyx*QG)
endfunction
function ctx takes integer oqx,unit oMx,real nyx,real bWx returns nothing
local integer byx
local integer bYx
set nyx=nyx*1
set bWx=bWx*1
if(nyx*bWx<=.0)then
if(bWx<.0)then
set bYx=UG
loop
call UnitRemoveAbility(oMx,wG[bYx])
set bYx=bYx-1
exitwhen(bYx<0)
endloop
else
set bYx=WG
loop
call UnitRemoveAbility(oMx,yG[bYx])
set bYx=bYx-1
exitwhen(bYx<0)
endloop
endif
if(nyx<.0)then
set nyx=-nyx
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(UG)))*1.)))
loop
exitwhen(nyx<1.)
set byx=YG[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
call UnitAddAbility(oMx,wG[bYx])
endif
set bYx=bYx-1
endloop
else
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(WG)))*1.)))
loop
exitwhen(nyx<1.)
set byx=YG[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
call UnitAddAbility(oMx,yG[bYx])
endif
set bYx=bYx-1
endloop
endif
else
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(UG)))*1.)))
if(nyx<.0)then
set nyx=-nyx
loop
exitwhen(bYx<0)
set byx=YG[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
call UnitAddAbility(oMx,wG[bYx])
else
call UnitRemoveAbility(oMx,wG[bYx])
endif
set bYx=bYx-1
endloop
else
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(WG)))*1.)))
loop
exitwhen(bYx<0)
set byx=YG[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
else
call UnitRemoveAbility(oMx,yG[bYx])
endif
set bYx=bYx-1
endloop
endif
endif
endfunction
function cTx takes integer oqx,real oSx,real abx returns nothing
set tG[oqx]=oSx
call ctx(zG,C[(oqx)],oSx,abx)
endfunction
function cux takes integer oqx,real oSx returns nothing
local real b_x=tG[oqx]
set SG[oqx]=oSx
if(oSx==b_x)then
if TG[oqx]then
set TG[oqx]=false
call Rmx((oqx),uG)
endif
return
endif
if(bTx((((oqx))),db))then
if not TG[oqx]then
set TG[oqx]=true
call I7x((oqx),uG)
endif
else
call cTx(oqx,oSx,b_x)
endif
endfunction
function cUx takes integer oqx,real oSx returns nothing
set kg[oqx]=oSx
call B8x((oqx))
endfunction
function cwx takes integer oqx,real oSx returns nothing
call cUx(oqx,(kg[(oqx)])+oSx)
endfunction
function cWx takes integer oqx,real oSx returns nothing
set jG[oqx]=oSx
call cKx((oqx))
endfunction
function cyx takes integer oqx,real oSx returns nothing
call cWx(oqx,(jG[(oqx)])+oSx)
endfunction
function cYx takes integer oqx,real oSx returns nothing
set qG[oqx]=oSx
call cqx((oqx))
endfunction
function czx takes integer oqx,real oSx returns nothing
call cYx(oqx,(qG[(oqx)])+oSx)
endfunction
function cZx takes integer oqx,real nyx returns nothing
if((Tf[((uf[((oqx))]))])==3)then
set nyx=1.25*nyx
endif
call cwx((oqx),nyx*wg)
call cyx((oqx),nyx*JG)
call czx((oqx),nyx*QG)
endfunction
function c_x takes integer oqx,real oSx returns nothing
local integer b6x=(R2I((((SG[(oqx)]))*1.)))
local integer b7x=(R2I(((oSx)*1.)))
call cux(oqx,oSx)
call cZx(oqx,b7x-b6x)
endfunction
function c0x takes integer oqx returns nothing
call c_x(oqx,(bg[((oqx))])*((ZG[((oqx))])-1)+(vh[((oqx))]))
endfunction
function c1x takes integer oqx,real oSx returns nothing
set sG[oqx]=oSx
call c0x(oqx)
endfunction
function c2x takes integer oqx returns nothing
call c1x(oqx,(bg[(oqx)])*(ZG[(oqx)])+(vh[(oqx)]))
endfunction
function c3x takes integer oqx,real oSx returns nothing
local integer b6x=(R2I((((bg[(oqx)]))*1.)))
local integer b7x=(R2I(((oSx)*1.)))
set bg[oqx]=oSx
call SetHeroStr(C[(oqx)],b7x,true)
call cSx(oqx,b7x-b6x)
call c2x((oqx))
endfunction
function c4x takes integer oqx,real oSx returns nothing
call c3x(oqx,(bg[(oqx)])+oSx)
endfunction
function c5x takes nothing returns boolean
local integer rdx=(bv)
if(sf=="-agi")then
call Bxx(RVx(),Sf)
elseif(sf=="-int")then
call BYx(RVx(),Sf)
elseif(sf=="-str")then
call c4x(RVx(),Sf)
else
call oYx("CommandHeroAttribute_Enum","call DebugEx(\"unrecognized\")","unrecognized")
endif
return true
endfunction
function c6x takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
local string c7x=(MA[(rdx)])
local real o2x=(S2R((XPx(r1x,1))))
set sf=c7x
set Sf=o2x
call O7x(ocx,function c5x)
return true
endfunction
function c8x takes nothing returns boolean
call XWx("-agi",function c6x)
call XWx("-int",function c6x)
call XWx("-str",function c6x)
return true
endfunction
function c9x takes nothing returns boolean
call E9x(function c8x,"CommandHeroAttribute_Init")
return true
endfunction
function Cvx takes nothing returns boolean
set eh=Vnx(xh)
return true
endfunction
function Cex takes integer oqx,integer cCx returns nothing
if cBx(oqx)then
return
endif
set GG=cCx
call KillUnit(C[(oqx)])
endfunction
function Cxx takes integer oqx returns nothing
call Cex(oqx,w)
endfunction
function Cox takes nothing returns boolean
local integer rdx=(bv)
call Cxx(RVx())
return true
endfunction
function Crx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
call O7x(ocx,function Cox)
return true
endfunction
function Cix takes nothing returns boolean
call XWx("-kill",function Crx)
return true
endfunction
function Cax takes nothing returns boolean
call E9x(function Cix,"CommandKillUnit_Init")
return true
endfunction
function Cnx takes nothing returns boolean
set oh=Vnx(rh)
return true
endfunction
function CVx takes integer oqx returns nothing
set Vh[(oqx)]=true
set Eh[(oqx)]=true
set Xh[(oqx)]=true
endfunction
function CEx takes integer oqx,integer rsx returns nothing
call UnitRemoveAbility(C[(oqx)],rsx)
endfunction
function CXx takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((I[(oqx)]))])]))],((((A[((oqx))])))),(((oQx))))))
endfunction
function COx takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((I[(oqx)]))])]))],((((A[((oqx))])))),(((oQx)+(okx)))))
endfunction
function CRx takes integer oqx,integer Rvx returns integer
local integer olx=(CXx(((oqx)),Q))
local integer rJx
loop
exitwhen(olx<q)
set rJx=(COx(((oqx)),Q,(olx)))
if(((Ih[(rJx)])==Rvx)or((qb[(rJx)])==Rvx)or((Sb[(rJx)])==Rvx))then
return rJx
endif
set olx=olx-1
endloop
return w
endfunction
function CIx takes integer oqx,integer rdx returns boolean
set bv=(rdx)
return rAx(oqx)
endfunction
function CAx takes integer oqx,integer Rvx,real x,real y returns boolean
return(IssuePointOrderById(C[(oqx)],Pb[Rvx],x,y))
endfunction
function CNx takes integer oqx,integer Rvx,real x,real y returns boolean
local boolean o4x
call DisableTrigger(fA[(Bh)])
set o4x=CAx(oqx,Rvx,x,y)
call EnableTrigger(fA[(Bh)])
return o4x
endfunction
function Cbx takes integer oqx returns nothing
local real N8x=(GetUnitFacing(C[((oqx))])*bh)
if CNx(oqx,ch,(GetUnitX(C[((oqx))]))+.01*(Cos(((((N8x)*1.))*1.))),(GetUnitY(C[((oqx))]))+.01*(Sin(((((N8x)*1.))*1.))))then
return
endif
call Rex(oqx,Ch)
endfunction
function CBx takes integer oqx returns boolean
return((oqx>=dh)and(oqx<=Dh))
endfunction
function Ccx takes integer oqx,playerstate CCx returns integer
return GetPlayerState(vx[(oqx)],CCx)
endfunction
function Cdx takes integer oqx,integer CDx returns nothing
call UnitAddItem(C[(oqx)],Gh[CDx])
endfunction
function Cfx takes integer oqx,integer bXx returns nothing
local item oMx=Gh[oqx]
local real x=(GetItemX(Gh[((oqx))]))
local real y=(GetItemY(Gh[((oqx))]))
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oMx))))),((((hh)))),((((oqx)))))
call RemoveItem(oMx)
set oMx=CreateItem(Hh[(gh[(oqx)])],x,y)
set Gh[oqx]=oMx
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oMx))))),((((hh)))),((((oqx)))))
if(bXx!=w)then
call Cdx(bXx,oqx)
endif
set oMx=null
endfunction
function CFx takes integer oqx,playerstate CCx,integer oSx returns nothing
local integer olx
if(oqx==Ge)then
set olx=Jh
loop
call CFx(kh[olx],CCx,oSx)
set olx=olx-1
exitwhen(olx<0)
endloop
else
call SetPlayerState(vx[(oqx)],CCx,oSx)
endif
endfunction
function Cgx takes integer oqx,playerstate CCx,integer oSx returns nothing
call CFx(oqx,CCx,(GetPlayerState(vx[((oqx))],(CCx)))-oSx)
endfunction
function CGx takes integer oqx,integer oQx,integer oSx returns boolean
return((LoadInteger(o[((D[((Kh[(oqx)]))]))],((((lh[((oqx))])))),(osx(((oQx)),(((oSx)))))))!=0)
endfunction
function Chx takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((Qh[oqx]))])]))],((((ph[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function CHx takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((Qh[oqx]))])]))],((((ph[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function Cjx takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((Kh[(oqx)]))])]))],((((lh[((oqx))])))),(((oQx))))))
endfunction
function CJx takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((Kh[(oqx)]))])]))],((((lh[((oqx))])))),(((oQx)+(okx)))))
endfunction
function Ckx takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((Kh[(oqx)]))])]))],((((lh[((oqx))])))),(((oQx)))))
endfunction
function CKx takes integer oqx returns integer
set xH[oqx]=true
set oH[oqx]=false
call rax(rH)
return oqx
endfunction
function Clx takes nothing returns integer
local integer oqx
if(Yh==8190)then
call oYx("SpellInstance_Allocation_allocCustom","call DebugEx(SpellInstance.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",zh+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Zh[(w)]==w)then
set vH=vH+1
set oqx=vH
else
set oqx=Zh[(w)]
set Zh[(w)]=Zh[Zh[(w)]]
endif
set Zh[oqx]=Z
set eH[oqx]=1
call CKx(oqx)
return oqx
endfunction
function CLx takes integer oqx returns nothing
set IH[oqx]=0
set AH[oqx]=false
endfunction
function Cmx takes integer CMx,integer rJx returns integer
local integer oqx=Clx()
set iH[(oqx)]=((.0)*1.)
set aH[(oqx)]=(CMx)
set nH[(oqx)]=(0)
set VH[(oqx)]=(((mg[(CMx)]))*1.)
set EH[(oqx)]=((.0)*1.)
set XH[(oqx)]=(rux(CMx,rJx))
set OH[(oqx)]=(rJx)
set RH[(oqx)]=(((ZF[(CMx)]))*1.)
set uh[(oqx)]=(w)
set Uh[(oqx)]=(w)
set wh[(oqx)]=((.0)*1.)
set Wh[(oqx)]=((.0)*1.)
call CLx(oqx)
return oqx
endfunction
function Cpx takes integer oqx,integer oQx returns real
return(LoadReal(o[((V[(E[((NH[(oqx)]))])]))],((((Ev[((oqx))])))),(((oQx)))))
endfunction
function CPx takes integer oqx,integer Iox,integer rwx,real ilx returns integer
return NIx(oqx,Iox,rwx,w,ilx)
endfunction
function Cqx takes integer CQx returns nothing
local real ilx=(Cpx(((OH[(CQx)])),BH+((XH[(CQx)]))))
if(ilx==.0)then
return
endif
call Ayx((aH[(CQx)]),cH)
set CH=ilx
set dH=CQx
call CPx((aH[(CQx)]),cH,1,ilx)
endfunction
function Csx takes integer oqx returns integer
set jH[oqx]=true
set JH[oqx]=false
call rax(kH)
return oqx
endfunction
function CSx takes nothing returns integer
local integer oqx
if(FH==8190)then
call oYx("FolderUnit_FolderAbilities_StructCooldown_Allocation_allocCustom","call DebugEx(FolderUnit_FolderAbilities_StructCooldown.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",gH+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(GH[(w)]==w)then
set hH=hH+1
set oqx=hH
else
set oqx=GH[(w)]
set GH[(w)]=GH[GH[(w)]]
endif
set GH[oqx]=Z
set HH[oqx]=1
call Csx(oqx)
return oqx
endfunction
function Ctx takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(NH[(oqx)],(Ev[((oqx))]),oQx,oSx)
endfunction
function CTx takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((NH[(oqx)]))])]))],((((Ev[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function Cux takes integer oqx returns nothing
set jH[oqx]=false
call rgx(kH)
endfunction
function CUx takes integer oqx returns nothing
if(HH[oqx]>0)then
return
endif
if(GH[oqx]!=Z)then
call oYx("FolderUnit_FolderAbilities_StructCooldown_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderAbilities_StructCooldown.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",gH+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set GH[oqx]=GH[(w)]
set GH[(w)]=oqx
call Cux(oqx)
endfunction
function Cwx takes integer oqx returns nothing
set HH[oqx]=HH[oqx]-1
call CUx(oqx)
endfunction
function CWx takes integer oqx,integer oQx,integer oSx returns boolean
return rex(NH[(oqx)],(Ev[((oqx))]),oQx,oSx)
endfunction
function Cyx takes integer oqx,integer oQx returns nothing
call SaveInteger(o[(((V[(E[((NH[(oqx)]))])])))],(((((Ev[((oqx))]))))),((((oQx)))),(0))
endfunction
function CYx takes integer rkx,integer rJx returns nothing
local integer rdx=rEx((A[(rkx)]))
local integer rKx
local integer olx
local integer rIx
local integer rlx
set nv[(rdx)]=(rJx)
set Vv[(rdx)]=(rkx)
set rKx=rEx((Ev[(rJx)]))
set nv[(rKx)]=(rJx)
set Vv[(rKx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,pH,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,pH,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set rlx=rfx(rJx,pH,rIx)
loop
exitwhen(rlx<q)
call rCx(rFx(rJx,pH,rIx,rlx),rKx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call rHx(((rKx)))
endfunction
function Czx takes integer oqx,integer ibx,integer rkx,integer rJx returns nothing
call Cwx((oqx))
call ijx(ibx)
if rrx(rkx,mH,oqx)then
call Rmx(rkx,MH)
endif
call rix(rkx,nh+rJx)
if CWx(rJx,mH,oqx)then
endif
call Cyx(rJx,nh+rkx)
call CYx(rkx,rJx)
endfunction
function CZx takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
call Czx(oqx,ibx,lH[oqx],LH[oqx])
endfunction
function C_x takes integer rkx,integer rJx returns nothing
local integer rdx=rEx((A[(rkx)]))
local integer rKx
local integer olx
local integer rIx
local integer rlx
set nv[(rdx)]=(rJx)
set Vv[(rdx)]=(rkx)
set rKx=rEx((Ev[(rJx)]))
set nv[(rKx)]=(rJx)
set Vv[(rKx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,PH,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,PH,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set rlx=rfx(rJx,PH,rIx)
loop
exitwhen(rlx<q)
call rCx(rFx(rJx,PH,rIx,rlx),rKx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call rHx(((rKx)))
endfunction
function C0x takes integer oqx,integer rJx returns nothing
local integer rkx=oqx
local real ilx=(Cpx((rJx),fH+(rux(rkx,rJx))))
local integer ibx
if(ilx==.0)then
return
endif
set oqx=CSx()
set ibx=inx()
set KH[oqx]=ibx
set lH[oqx]=rkx
set LH[oqx]=rJx
set ge[(ibx)]=(oqx)
if rtx(rkx,mH,oqx)then
call I7x(rkx,MH)
endif
call rTx(rkx,nh+rJx,oqx)
if Ctx(rJx,mH,oqx)then
endif
call CTx(rJx,nh+rkx,oqx)
call icx(ibx,ilx,false,function CZx)
call C_x(rkx,rJx)
endfunction
function C1x takes integer oqx,real oSx returns nothing
local real abx=(LF[(oqx)])
set oSx=bJx(abx-oSx,.0,(mF[((oqx))]))
set LF[oqx]=oSx
call BVx(oqx,abx,oSx)
endfunction
function C2x takes string oMx,string C3x returns string
local integer r7x=Qv
local integer rvx=((StringLength(((oMx))))-1)
loop
exitwhen(rvx<0+1)
if(r2x(oMx,rvx-(StringLength(("ff000000")))-(StringLength(("|c")))+1,rvx-(StringLength(("ff000000"))))=="|c")then
set rvx=rvx-(StringLength(("ff000000")))-(StringLength(("|c")))
elseif(r2x(oMx,rvx-(StringLength(("|r")))+1,rvx)=="|r")then
set rvx=rvx-(StringLength(("|r")))
else
if(r7x!=Qv)then
set oMx=(r2x((oMx),0,(r7x-1)))+C3x+Xdx(oMx,r7x)
endif
set r7x=rvx
set rvx=rvx-1
endif
endloop
return oMx
endfunction
function C4x takes integer oqx,string iNx,real X7x,integer id,boolean C5x,real C6x,real C7x returns integer
local real x=(GetUnitX(C[((oqx))]))+C6x
local real y=(GetUnitY(C[((oqx))]))+C7x
local real z=Olx(oqx,x,y)
if C5x then
set iNx=C2x(iNx,"
")
endif
return cNx(iNx,X7x,x,y,z,id)
endfunction
function C8x takes integer oqx,string o6x,string oQx returns string
if((o6x==null)or(oQx==null))then
call oYx("FolderGameCache_StructString_Get","call DebugEx(\"GameCache Get: \"+missionKey+\";\"+key)","GameCache Get: "+o6x+";"+oQx)
return null
endif
return GetStoredString(Kv[(oqx)],o6x,oQx)
endfunction
function C9x takes string rqx,string XCx returns string
if(HaveStoredString(Kv[((SH))],(rqx),("var")))then
return(C8x(SH,(rqx),"var"))
endif
return XCx
endfunction
function dvx takes integer oqx,boolean Omx returns real
if Omx then
return(tH[oqx]*(ob[((oqx))]))
endif
return tH[oqx]
endfunction
function dex takes integer CQx,integer dxx returns nothing
local integer CMx=(aH[(CQx)])
local integer rwx=(XH[(CQx)])
local integer dox=(uh[(CQx)])
local integer drx=(Uh[(CQx)])
local real dix=(wh[(CQx)])
local real dax=(Wh[(CQx)])
local integer rJx=(OH[(CQx)])
local integer dnx=rEx((A[(CMx)]))
local integer rKx
local integer olx
local integer rIx
local integer rlx
set TH[(dnx)]=(dox)
set Ph[(dnx)]=(dxx)
set Mv[(dnx)]=(rwx)
set nv[(dnx)]=(rJx)
set uH[(dnx)]=(CQx)
set UH[(dnx)]=((dix)*1.)
set wH[(dnx)]=((dax)*1.)
set WH[(dnx)]=(drx)
set Vv[(dnx)]=(CMx)
set rKx=rEx((Ev[(rJx)]))
set TH[(rKx)]=(dox)
set Ph[(rKx)]=(dxx)
set Mv[(rKx)]=(rwx)
set nv[(rKx)]=(rJx)
set uH[(rKx)]=(CQx)
set UH[(rKx)]=((dix)*1.)
set wH[(rKx)]=((dax)*1.)
set WH[(rKx)]=(drx)
set Vv[(rKx)]=(CMx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((ah))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((ah))-1)*Iv+(((rIx))-1))))+((rlx)))))),dnx)
set rlx=rlx-1
endloop
set rlx=rOx(CMx,ah,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(CMx,ah,rIx,rlx),dnx)
set rlx=rlx-1
endloop
set rlx=rfx(rJx,ah,rIx)
loop
exitwhen(rlx<q)
call rCx(rFx(rJx,ah,rIx,rlx),rKx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((dnx)))
call rHx(((rKx)))
endfunction
function dVx takes integer oqx returns boolean
if((IH[(oqx)])>0)then
set AH[oqx]=true
return false
endif
return true
endfunction
function dEx takes integer oqx returns nothing
set xH[oqx]=false
call rgx(rH)
endfunction
function dXx takes integer oqx returns nothing
if(eH[oqx]>0)then
return
endif
if(Zh[oqx]!=Z)then
call oYx("SpellInstance_Allocation_deallocCustom_confirm","call DebugEx(SpellInstance.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",zh+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set Zh[oqx]=Zh[(w)]
set Zh[(w)]=oqx
call dEx(oqx)
endfunction
function dOx takes integer oqx returns nothing
set eH[oqx]=eH[oqx]-1
call dXx(oqx)
endfunction
function dRx takes integer oqx returns nothing
if not dVx(oqx)then
return
endif
call dOx((oqx))
endfunction
function dIx takes integer CQx,integer dxx returns nothing
local integer CMx=(aH[(CQx)])
local integer rwx=(XH[(CQx)])
local integer drx=(Uh[(CQx)])
local integer rJx=(OH[(CQx)])
local boolean dAx=(drx!=w)
local integer oqx=CMx
local boolean dNx
call Cqx(CQx)
call C0x(CMx,rJx)
call C1x(CMx,(Cpx((rJx),QH+(rwx))))
if dAx then
set dNx=not(IsUnitAlly(C[(CMx)],vx[((ze[(drx)]))]))
endif
if I6x(CMx,yd)then
call C4x(CMx,iqx((sH[((OH[(CQx)]))]),"ff00ffff"),S2R(C9x("size","0.021")),(0),false,-dvx(CMx,true),.0)
endif
call dex(CQx,dxx)
if dAx then
if dNx then
set yH=true
endif
endif
call dRx(CQx)
set Th[oqx]=w
endfunction
function dbx takes integer oqx,integer CQx,integer CDx returns nothing
call dIx(CQx,CDx)
endfunction
function dBx takes integer oqx,integer CDx,integer rJx,integer rwx,integer dox,integer drx,real dix,real dax returns nothing
local integer CQx=Cmx(oqx,rJx)
set XH[(CQx)]=(rwx)
set uh[(CQx)]=(dox)
set Uh[(CQx)]=(drx)
set wh[(CQx)]=((dix)*1.)
set Wh[(CQx)]=((dax)*1.)
call dbx((oqx),CQx,CDx)
endfunction
function dcx takes integer oqx,integer CDx returns nothing
local integer olx=(Cjx(((CDx)),Sh))
local integer rwx
local integer dCx=(Th[((oqx))])
local integer rJx
local integer dox=(uh[(dCx)])
local integer drx=(Uh[(dCx)])
local real dix=(wh[(dCx)])
local real dax=(Wh[(dCx)])
loop
exitwhen(olx<q)
set rJx=(CJx(((CDx)),Sh,(olx)))
set rwx=(Ckx(((CDx)),yh+(rJx)))
call dBx(oqx,CDx,rJx,rwx,dox,drx,dix,dax)
set olx=olx-1
endloop
endfunction
function ddx takes integer oqx,integer CDx returns nothing
local integer dDx=(gh[(CDx)])
local integer dfx=rEx((ph[(dDx)]))
local integer olx
local integer rIx
local integer rlx
set Ph[(dfx)]=(CDx)
set qh[(dfx)]=(dDx)
set Vv[(dfx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=Chx(dDx,sh,rIx)
loop
exitwhen(rlx<q)
call rCx(CHx(dDx,sh,rIx,rlx),dfx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((dfx)))
call dcx(oqx,CDx)
endfunction
function dFx takes integer oqx returns boolean
if((ZH[(oqx)])>0)then
set vj[oqx]=true
return false
endif
return true
endfunction
function dgx takes integer oqx returns nothing
set rj[oqx]=false
call rgx(ij)
endfunction
function dGx takes integer oqx returns nothing
if(ej[oqx]>0)then
return
endif
if(xj[oqx]!=Z)then
call oYx("OrderInstance_Allocation_deallocCustom_confirm","call DebugEx(OrderInstance.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",oj+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set xj[oqx]=xj[(w)]
set xj[(w)]=oqx
call dgx(oqx)
endfunction
function dhx takes integer oqx returns nothing
set ej[oqx]=ej[oqx]-1
call dGx(oqx)
endfunction
function dHx takes integer oqx returns nothing
if not dFx(oqx)then
return
endif
call dhx((oqx))
endfunction
function djx takes integer oqx returns nothing
local integer I3x=(zH[(oqx)])
if(I3x==w)then
return
endif
set zH[oqx]=w
call dHx(I3x)
endfunction
function dJx takes integer oqx returns nothing
local integer rkx=oqx
endfunction
function dkx takes integer oqx returns nothing
call djx((oqx))
call dJx(oqx)
endfunction
function dKx takes integer oqx,integer oQx returns boolean
return((LoadInteger(o[((V[(E[((Eb[(oqx)]))])]))],((((Xb[((oqx))])))),(((oQx)))))==0)
endfunction
function dlx takes integer oqx,integer o6x,integer oQx returns integer
local integer o7x=(0+(LoadInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx))))))
local integer oSx
if(o7x==0)then
return 0
endif
set oSx=(LoadInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx)+(o7x)))))
call SaveInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx))),(((o7x-1)-0)))
call SaveInteger(o[(((D[oqx])))],((o6x)),((osx(oQx,(oSx)))),(0))
call SaveInteger(o[(((V[(E[(oqx)])])))],(((o6x))),(((oQx+o7x))),(0))
return oSx
endfunction
function dLx takes integer oqx,integer oQx returns integer
return dlx(Eb[(oqx)],(Xb[((oqx))]),oQx)
endfunction
function dmx takes integer oqx returns integer
return(LoadInteger(o[((V[(E[((X))])]))],((((GetUnitCurrentOrder(C[(oqx)]))))),(((Oj)))))
endfunction
function dMx takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(Eb[(oqx)],(Xb[((oqx))]),oQx,oSx)
endfunction
function dpx takes integer oqx,integer oSx returns nothing
if(I5x((oqx),Rb,(oSx)))then
call oYx("UnitList_Add","call DebugEx(UnitList.NAME + \" Add: \" + value.GetName() + \" already in \" + this.GetName())",Rj+" Add: "+(GetUnitName(C[(oSx)]))+" already in "+(Ij[(oqx)]))
return
endif
call dMx(oqx,Rb,oSx)
endfunction
function dPx takes integer oqx,integer o6x,integer oQx,integer dqx,integer dQx,integer dsx returns nothing
local integer o7x=(0+(LoadInteger(o[((V[(E[(((dqx)))])]))],(((dQx))),(((dsx))))))
local integer dSx
local integer olx
local integer n1x
local integer oSx
if(o7x==0)then
return
endif
set dSx=0
set olx=q
set n1x=(0+(LoadInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx))))))
loop
set oSx=(LoadInteger(o[((V[(E[(((dqx)))])]))],(((dQx))),(((dsx)+(olx)))))
if not((LoadInteger(o[((D[((oqx))]))],(((o6x))),(osx(((oQx)),(((oSx)))))))!=0)then
set dSx=dSx+1
call SaveInteger(o[((D[oqx]))],(o6x),(osx(oQx,(oSx))),(n1x+dSx))
call SaveInteger(o[((V[(E[(oqx)])]))],((o6x)),((oQx+n1x+dSx)),((oSx)))
endif
set olx=olx+1
exitwhen(olx>o7x)
endloop
call SaveInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx))),(((n1x+dSx)-0)))
endfunction
function dtx takes integer oqx,integer oQx,integer dqx returns nothing
call dPx(Eb[(oqx)],(Xb[((oqx))]),oQx,Eb[(dqx)],(Xb[((dqx))]),oQx)
endfunction
function dTx takes integer oqx,integer o6x,integer oQx returns nothing
local integer olx=(0+(LoadInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx))))))
local integer oSx
loop
exitwhen(olx<q)
set oSx=(LoadInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx)+(olx)))))
call SaveInteger(o[(((V[(E[(oqx)])])))],(((o6x))),(((oQx+olx))),(0))
call SaveInteger(o[(((D[oqx])))],((o6x)),((osx(oQx,(oSx)))),(0))
set olx=olx-1
endloop
call SaveInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx))),(((0)-0)))
endfunction
function dux takes integer oqx,integer oQx returns nothing
call dTx((Eb[(oqx)]),((Xb[((oqx))])),(oQx))
endfunction
function dUx takes integer oqx,integer oSx returns nothing
call dtx(oqx,Rb,oSx)
call dux((oSx),Rb)
endfunction
function dwx takes nothing returns nothing
local integer rkx
loop
set rkx=(dLx((aj),Rb))
exitwhen(rkx==w)
if(dmx(rkx)==w)then
call dkx((rkx))
else
call dpx(Aj,rkx)
endif
endloop
if(dKx((Aj),Rb))then
call iHx(nj)
else
call dUx(aj,Aj)
endif
endfunction
function dWx takes integer oqx returns nothing
if(I5x((aj),Rb,(oqx)))then
return
endif
if(dKx((aj),Rb))then
call icx(nj,Ej,true,function dwx)
endif
call dpx(aj,oqx)
endfunction
function dyx takes integer oqx,integer dYx returns nothing
if not(I5x((YH),Rb,(oqx)))then
return
endif
call dkx(oqx)
set zH[((oqx))]=(dYx)
call dWx(oqx)
endfunction
function dzx takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((Bj[oqx]))])]))],((((Nj[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function dZx takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((Bj[oqx]))])]))],((((Nj[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function d_x takes integer oqx,integer I3x returns nothing
local integer rkx=oqx
local integer Rvx=(Rh[(I3x)])
local integer d0x=rEx((Nj[(Rvx)]))
local integer rdx
local integer olx
local integer rIx
local integer rlx
set Nh[(d0x)]=(Rvx)
set Vv[(d0x)]=(rkx)
set rdx=rEx((A[(rkx)]))
set Nh[(rdx)]=(Rvx)
set Vv[(rdx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,bj,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,bj,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set rlx=dzx(Rvx,bj,rIx)
loop
exitwhen(rlx<q)
call rCx(dZx(Rvx,bj,rIx,rlx),d0x)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((d0x)))
call rHx(((rdx)))
endfunction
function d1x takes integer oqx,integer I3x returns nothing
local integer Rvx=(Rh[(I3x)])
local integer d2x=CRx((oqx),Rvx)
local boolean d3x=false
local integer d4x
local integer rdx
local integer d5x
local integer d6x
local integer d7x
if(d2x!=w)then
if((qb[(d2x)])==Rvx)then
call Rix((oqx),w)
elseif((Sb[(d2x)])==Rvx)then
call Rix((oqx),d2x)
else
set d4x=(Ah[(d2x)])
if(d4x!=w)then
set rdx=rEx(0)
set Nh[(rdx)]=(Rvx)
set Vv[(rdx)]=(oqx)
set Mv[(rdx)]=((oPx((((oqx))),N+(d2x))))
set nv[(rdx)]=(d2x)
if not CIx(d4x,rdx)then
call Cbx((oqx))
set d3x=true
endif
call rHx(((rdx)))
if d3x then
return
endif
endif
endif
endif
if CBx(Rvx)then
set d5x=(ze[((oqx))])
set d6x=(oPx((((oqx))),fh+(((Rvx)-dh))))
set d7x=(Fh[((gh[(d6x)]))])
if(d7x>Ccx(d5x,PLAYER_STATE_RESOURCE_GOLD))then
call Cfx(d6x,oqx)
call cbx((oqx),iqx("Not enough gold!","ffff0000"),.022,jh+oqx)
return
endif
call Cgx(d5x,PLAYER_STATE_RESOURCE_GOLD,d7x)
if((CGx(((d6x)),Lh,(mh)))and(Mh[((oqx))]))then
call ddx((oqx),d6x)
endif
endif
call dyx((oqx),I3x)
call d_x(oqx,I3x)
endfunction
function d8x takes integer oqx returns nothing
local integer I3x
set Vh[oqx]=false
set I3x=Oh[oqx]
if(I3x==w)then
return
endif
set Oh[oqx]=w
call d1x(oqx,I3x)
endfunction
function d9x takes integer oqx,integer I3x returns nothing
local integer rkx=oqx
local integer Rvx=(Rh[(I3x)])
local real dix=(Cj[(I3x)])
local real dax=(dj[(I3x)])
local integer d0x=rEx((Nj[(Rvx)]))
local integer rdx
local integer olx
local integer rIx
local integer rlx
set Nh[(d0x)]=(Rvx)
set UH[(d0x)]=((dix)*1.)
set wH[(d0x)]=((dax)*1.)
set Vv[(d0x)]=(rkx)
set rdx=rEx((A[(rkx)]))
set Nh[(rdx)]=(Rvx)
set UH[(rdx)]=((dix)*1.)
set wH[(rdx)]=((dax)*1.)
set Vv[(rdx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,Dj,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,Dj,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set rlx=dzx(Rvx,Dj,rIx)
loop
exitwhen(rlx<q)
call rCx(dZx(Rvx,Dj,rIx,rlx),d0x)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((d0x)))
call rHx(((rdx)))
endfunction
function Dvx takes integer oqx,integer I3x returns nothing
call dyx((oqx),I3x)
call d9x(oqx,I3x)
endfunction
function Dex takes integer oqx returns nothing
local integer I3x
set Eh[oqx]=false
set I3x=cj[oqx]
if(I3x==w)then
return
endif
set cj[oqx]=w
call Dvx(oqx,I3x)
endfunction
function Dxx takes integer oqx,integer I3x returns nothing
local integer rkx=oqx
local integer Rvx=(Rh[(I3x)])
local integer dox=(Fj[(I3x)])
local integer drx=(gj[(I3x)])
local integer d0x=rEx((Nj[(Rvx)]))
local integer rdx
local integer Dox
local integer olx
local integer rIx
local integer rlx
set TH[(d0x)]=(dox)
set Nh[(d0x)]=(Rvx)
set WH[(d0x)]=(drx)
set Vv[(d0x)]=(rkx)
set rdx=rEx((A[(rkx)]))
set TH[(rdx)]=(dox)
set Nh[(rdx)]=(Rvx)
set WH[(rdx)]=(drx)
set Vv[(rdx)]=(rkx)
set Dox=rEx((A[(drx)]))
set TH[(Dox)]=(dox)
set Nh[(Dox)]=(Rvx)
set WH[(Dox)]=(rkx)
set Vv[(Dox)]=(drx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,Gj,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,Gj,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set rlx=dzx(Rvx,Gj,rIx)
loop
exitwhen(rlx<q)
call rCx(dZx(Rvx,Gj,rIx,rlx),d0x)
set rlx=rlx-1
endloop
set rlx=rOx(drx,hj,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(drx,hj,rIx,rlx),Dox)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((d0x)))
call rHx(((rdx)))
call rHx(((Dox)))
endfunction
function Drx takes integer oqx,integer I3x returns nothing
call dyx((oqx),I3x)
call Dxx(oqx,I3x)
endfunction
function Dix takes integer oqx returns nothing
local integer I3x
set Xh[oqx]=false
set I3x=fj[oqx]
if(I3x==w)then
return
endif
set fj[oqx]=w
call Drx(oqx,I3x)
endfunction
function Dax takes integer oqx returns nothing
call d8x(oqx)
call Dex(oqx)
call Dix(oqx)
endfunction
function Dnx takes integer oqx,integer rJx returns nothing
local integer rkx=oqx
local integer DVx=B[rJx]
local integer rwx
set oqx=oPx(rkx,nh+rJx)
if(oqx==w)then
return
endif
set rwx=rux(rkx,rJx)
call CVx(rkx)
call CEx(rkx,DVx)
call rQx(rkx,DVx)
call ryx(rkx,DVx,rwx)
call Dax(rkx)
call Czx(oqx,KH[oqx],rkx,rJx)
endfunction
function DEx takes integer oqx,integer rJx returns nothing
call Dnx(oqx,rJx)
endfunction
function DXx takes nothing returns boolean
local integer rdx=(bv)
call DEx((Vv[(rdx)]),(nv[(rdx)]))
return true
endfunction
function DOx takes integer oqx returns nothing
local integer olx=(CXx(((oqx)),Q))
loop
exitwhen(olx<q)
call Dnx((oqx),((COx(((oqx)),Q,(olx)))))
set olx=olx-1
endloop
endfunction
function DRx takes nothing returns boolean
local integer rdx=(bv)
if(Hj==w)then
call DOx(RVx())
else
call DEx(RVx(),Hj)
endif
return true
endfunction
function DIx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
local integer rJx=rPx(XPx(r1x,1))
if(rJx==w)then
if(XPx(r1x,1)!="all")then
call oYx("CommandRefreshAbility_Event_Chat","call DebugEx(\"invalid spell\")","invalid spell")
return true
endif
endif
set Hj=rJx
call O7x(ocx,function DRx)
return true
endfunction
function DAx takes integer oqx,integer oQx,boolean oSx returns nothing
call SaveBoolean(o[((V[(E[((oA[(oqx)]))])]))],((((nA[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function DNx takes integer oqx returns nothing
if(oqx==w)then
call oYx("Event_AddToStatics","call DebugEx(\"event is null\")","event is null")
endif
call DAx(oqx,kj,true)
call rSx(X,Se,(rA[(oqx)]),oqx)
endfunction
function Dbx takes integer oqx returns nothing
call DAx(oqx,kj,false)
call rex(X,Se,(rA[(oqx)]),oqx)
endfunction
function DBx takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((Eb[(oqx)]))])]))],((((Xb[((oqx))])))),(((oQx))))))
endfunction
function Dcx takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((Eb[(oqx)]))])]))],((((Xb[((oqx))])))),(((oQx)+(okx)))))
endfunction
function DCx takes nothing returns nothing
local integer rdx=rEx(0)
set Vv[(rdx)]=(RVx())
set mj[(rdx)]=(lj[Kj])
call Xfx(Lj[Kj],rdx)
call rHx(((rdx)))
endfunction
function Ddx takes integer oqx,code Xbx,integer I3x returns nothing
set Kj=Kj+1
set lj[Kj]=I3x
set Lj[Kj]=XHx(Xbx)
call ForGroup(Kb[oqx],function DCx)
set Kj=Kj-1
endfunction
function DDx takes integer oqx,code Xbx,integer I3x returns nothing
local integer olx=DBx(oqx,Rb)
local integer O8x
if(olx<q)then
return
endif
set O8x=O2x()
loop
call GroupAddUnit(Kb[(O8x)],C[(Dcx(oqx,Rb,olx))])
set olx=olx-1
exitwhen(olx<q)
endloop
call Ddx(O8x,Xbx,I3x)
call O6x(O8x)
endfunction
function Dfx takes integer oqx,code Xbx returns nothing
call DDx(oqx,Xbx,w)
endfunction
function DFx takes nothing returns boolean
local integer rdx=(bv)
call DOx(RVx())
return true
endfunction
function Dgx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
set jj=not jj
if jj then
call DNx(ih)
else
call Dbx(ih)
endif
call Dfx(Mj,function DFx)
return true
endfunction
function DGx takes nothing returns boolean
set ih=XBx("CommandRefreshAbility_Init: set CommandRefreshAbility.NO_CD_CAST_EVENT = Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function CommandRefreshAbility.Event_NoCd_Cast)",ah,pI,function DXx)
call XWx("-refresh",function DIx)
call XWx("-nocd",function Dgx)
return true
endfunction
function Dhx takes nothing returns boolean
call E9x(function DGx,"CommandRefreshAbility_Init")
return true
endfunction
function DHx takes nothing returns boolean
set pj=Vnx(Pj)
return true
endfunction
function Djx takes nothing returns boolean
local integer rdx=(bv)
call OTx(RVx())
return true
endfunction
function DJx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
call O7x(ocx,function Djx)
return true
endfunction
function Dkx takes nothing returns boolean
call XWx("-remove",function DJx)
return true
endfunction
function DKx takes nothing returns boolean
call E9x(function Dkx,"CommandRemoveUnit_Init")
return true
endfunction
function Dlx takes nothing returns boolean
set qj=Vnx(Qj)
return true
endfunction
function DLx takes integer oqx returns real
return((ob[(oqx)])+(tj[(oqx)]))
endfunction
function Dmx takes integer oqx returns nothing
local real o2x=DLx(oqx)
call SetUnitScale(C[(oqx)],o2x,o2x,o2x)
endfunction
function DMx takes integer oSx,integer bkx,integer nwx returns integer
return(R2I(((itx(((R2I(((iOx((bkx),(oSx)))*1.)))),(nwx)))*1.)))
endfunction
function Dpx takes integer oqx,real o2x returns nothing
if((o2x<vJ)or(o2x>eJ))then
call oYx("FolderDummyUnit_FolderPosition_StructX_Set","call DebugEx(FolderDummyUnit_FolderPosition_StructX.NAME + \" out of bounds \" + DummyUnit(this).GetName() + \" \" + R2S(val))",xJ+" out of bounds "+(GetUnitName(zj[((oqx))]))+" "+R2S(o2x))
return
endif
set oJ[oqx]=o2x
call SetUnitX(zj[(oqx)],o2x)
endfunction
function DPx takes integer oqx returns real
return GetUnitX(C[(oqx)])
endfunction
function Dqx takes integer oqx,real o2x returns nothing
if((o2x<rJ)or(o2x>iJ))then
call oYx("FolderDummyUnit_FolderPosition_StructY_Set","call DebugEx(FolderDummyUnit_FolderPosition_StructY.NAME + \" out of bounds \" + DummyUnit(this).GetName() + \" \" + R2S(val))",aJ+" out of bounds "+(GetUnitName(zj[((oqx))]))+" "+R2S(o2x))
return
endif
set nJ[oqx]=o2x
call SetUnitY(zj[(oqx)],o2x)
endfunction
function DQx takes integer oqx returns real
return GetUnitY(C[(oqx)])
endfunction
function Dsx takes integer oqx,integer Rvx,integer Ixx returns boolean
call Dpx((oqx),DPx(Ixx))
call Dqx((oqx),DQx(Ixx))
return(IssueTargetOrderById(zj[((oqx))],Pb[(Rvx)],C[((Ixx))]))
endfunction
function DSx takes integer oqx,integer Iox,integer rwx,integer I3x returns boolean
local integer Aqx=APx(oqx,Iox,rwx,I3x)
if(Aqx==w)then
return false
endif
call Aox((X),(vB),(oqx),(Iox),(w),(Aqx),0)
return true
endfunction
function Dtx takes integer oqx returns nothing
endfunction
function DTx takes integer oqx returns nothing
local real Dux=DLx(oqx)-(Tj[((uf[((oqx))]))])
local integer ATx
call UnitRemoveAbility(C[(((((oqx)))))],(('BUSC')))
if(Dux==0)then
call Ayx((oqx),uj)
call Dmx(oqx)
return
endif
if I6x((oqx),sc)then
call Dmx(oqx)
return
endif
set ATx=Uj[DMx((R2I(((((Dux)-wj)*1./ Wj)*1.))),yj,Yj)]
call UnitAddAbility(zj[((Zj))],(ATx))
call Dsx(Zj,VJ,oqx)
call UnitRemoveAbility(zj[((Zj))],(ATx))
call Dmx(oqx)
call DSx(((oqx)),(uj),(1),w)
call DSx(((oqx)),(EJ),(1),w)
call Dtx((oqx))
endfunction
function DUx takes integer oqx,real o2x returns nothing
set ob[oqx]=o2x
call DTx(oqx)
endfunction
function Dwx takes integer oqx,real oSx returns nothing
call DUx(oqx,(ob[(oqx)])+oSx)
endfunction
function DWx takes integer oqx returns integer
set bJ[oqx]=true
set BJ[oqx]=false
call rax(cJ)
return oqx
endfunction
function Dyx takes nothing returns integer
local integer oqx
if(OJ==8190)then
call oYx("FolderUnit_FolderScale_StructTimed_Allocation_allocCustom","call DebugEx(FolderUnit_FolderScale_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",RJ+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(IJ[(w)]==w)then
set AJ=AJ+1
set oqx=AJ
else
set oqx=IJ[(w)]
set IJ[(w)]=IJ[IJ[(w)]]
endif
set IJ[oqx]=Z
set NJ[oqx]=1
call DWx(oqx)
return oqx
endfunction
function DYx takes integer oqx returns boolean
set gJ=gJ+1
set GJ[gJ]=oqx
set hJ[oqx]=gJ+1
return(gJ==0)
endfunction
function Dzx takes integer oqx,real o2x returns nothing
set ob[oqx]=o2x
call Dmx(oqx)
endfunction
function DZx takes integer oqx,real o2x returns nothing
call Dzx(oqx,(ob[(oqx)])+o2x)
endfunction
function D_x takes nothing returns nothing
local integer olx=gJ
local integer oqx
loop
set oqx=GJ[olx]
call DZx(dJ[oqx],DJ[oqx])
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function D0x takes integer oqx returns nothing
set bJ[oqx]=false
call rgx(cJ)
endfunction
function D1x takes integer oqx returns nothing
if(NJ[oqx]>0)then
return
endif
if(IJ[oqx]!=Z)then
call oYx("FolderUnit_FolderScale_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderScale_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",RJ+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set IJ[oqx]=IJ[(w)]
set IJ[(w)]=oqx
call D0x(oqx)
endfunction
function D2x takes integer oqx returns nothing
set NJ[oqx]=NJ[oqx]-1
call D1x(oqx)
endfunction
function D3x takes integer oqx returns boolean
local integer okx=(hJ[(oqx)])
set hJ[GJ[gJ]]=okx
set GJ[okx-1]=GJ[gJ]
set hJ[oqx]=0
set gJ=gJ-1
return(gJ==F)
endfunction
function D4x takes integer oqx,integer ibx,integer rkx returns nothing
call D2x((oqx))
call ijx(ibx)
if rrx(rkx,fJ,oqx)then
call Rmx(rkx,FJ)
endif
if D3x(oqx)then
call iHx(HJ)
endif
endfunction
function D5x takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
call D4x(oqx,ibx,dJ[oqx])
call DTx(dJ[oqx])
endfunction
function D6x takes integer oqx,real D7x,real ilx returns nothing
local integer rkx=oqx
local integer D8x
local integer ibx
if(ilx==.0)then
call Dwx((oqx),D7x)
return
endif
set D8x=(R2I(((ilx*1./ XJ)*1.)))
set oqx=Dyx()
set ibx=inx()
set CJ[oqx]=ibx
set dJ[oqx]=rkx
set DJ[oqx]=D7x*1./ D8x
set ge[(ibx)]=(oqx)
if rtx(rkx,fJ,oqx)then
call I7x(rkx,FJ)
endif
if DYx(oqx)then
call icx(HJ,XJ,true,function D_x)
endif
call icx(ibx,ilx,false,function D5x)
endfunction
function D9x takes nothing returns boolean
local integer rdx=(bv)
call D6x(RVx(),Sj,sj)
return true
endfunction
function fvx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
local real D7x=(S2R((XPx(r1x,1))))
local real ilx=(S2R((XPx(r1x,2))))
set sj=ilx
set Sj=D7x
call O7x(ocx,function D9x)
return true
endfunction
function fex takes nothing returns boolean
call XWx("-scale",function fvx)
return true
endfunction
function fxx takes nothing returns boolean
call E9x(function fex,"CommandScaleUnit_Init")
return true
endfunction
function fox takes nothing returns boolean
set jJ=Vnx(JJ)
return true
endfunction
function frx takes integer oqx,integer rJx,integer rwx returns nothing
call rzx(oqx,rJx,rwx)
endfunction
function fix takes nothing returns boolean
local integer rdx=(bv)
call frx(RVx(),KJ,kJ)
return true
endfunction
function fax takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
local string fnx=XPx(r1x,1)
local integer rJx=rPx(fnx)
local integer rwx=(S2I((XPx(r1x,2))))
if(rJx==w)then
set rJx=Xcx(fnx,F)
if(rJx==F)then
call oYx("CommandSpell_Event_Chat","call DebugEx(\"invalid spell\")","invalid spell")
return true
endif
endif
set kJ=rwx
set KJ=rJx
call O7x(ocx,function fix)
return true
endfunction
function fVx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer olx=lJ
local integer ocx=(eN[(rdx)])
call PreloadGenStart()
loop
exitwhen(olx<0)
call oYx("CommandSpell_Event_ListAll_Chat","call DebugEx(Spell.ALL[iteration].GetName())",(sH[(LJ[olx])]))
set olx=olx-1
endloop
return true
endfunction
function fEx takes nothing returns boolean
call XWx("-spell",function fax)
call XWx("-spellListAll",function fVx)
return true
endfunction
function fXx takes nothing returns boolean
call E9x(function fEx,"CommandSpell_Init")
return true
endfunction
function fOx takes nothing returns boolean
set mJ=Vnx(MJ)
return true
endfunction
function fRx takes integer Ixx,integer rwx returns nothing
local integer oqx=Ixx
local integer o7x
if not(oPx((((Ixx))),(yb+(qJ)))>0)then
set o7x=1
else
set o7x=QJ[oqx]+1
endif
set QJ[oqx]=o7x
call DSx((Ixx),(qJ),(1),w)
call DSx((Ixx),(sJ[o7x]),(rwx),w)
endfunction
function fIx takes nothing returns boolean
local integer rdx=(bv)
call fRx(RVx(),PJ)
return true
endfunction
function fAx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
local integer rwx=(S2I((XPx(r1x,1))))
local real ilx=(S2R((XPx(r1x,2))))
set pJ=ilx
set PJ=rwx
call O7x(ocx,function fIx)
return true
endfunction
function fNx takes nothing returns boolean
call XWx("-swift",function fAx)
return true
endfunction
function fbx takes nothing returns boolean
call E9x(function fNx,"CommandSwift_Init")
return true
endfunction
function fBx takes nothing returns boolean
set SJ=Vnx(tJ)
return true
endfunction
function fcx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
local integer o2x
call Aox((X),(-$7FFFFEF0),(45),(53),(0),($BA),0)
set o2x=Rlx(X,-$7FFFFEF0,47,'{',0)
call oYx("CommandTest_Event_Chat","call DebugEx(\"TEST: \" + I2S(val))","TEST: "+I2S(o2x))
return true
endfunction
function fCx takes nothing returns boolean
call XWx("-test",function fcx)
return true
endfunction
function fdx takes nothing returns boolean
call E9x(function fCx,"CommandTest_Init")
return true
endfunction
function fDx takes nothing returns boolean
set TJ=Vnx(uJ)
return true
endfunction
function ffx takes string oMx,real XCx returns real
local real o2x=S2R(oMx)
if(o2x!=.0)then
return o2x
endif
if((oMx=="0")or(oMx=="0."))then
return o2x
endif
set oMx=Xdx(oMx,0+1)
if(Xpx(oMx,"0",0)==Qv)then
return o2x
endif
return XCx
endfunction
function fFx takes nothing returns integer
return(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetLocalPlayer())))))),((((R))))))
endfunction
function fgx takes integer oqx,integer oQx returns real
return(LoadReal(o[((V[(E[((I[(oqx)]))])]))],((((A[((oqx))])))),(((oQx)))))
endfunction
function fGx takes integer oqx,real iWx,real iyx,real iYx,real izx returns nothing
local integer ocx=fFx()
set zJ[(oqx)]=((iWx)*1.)
set ZJ[(oqx)]=((iyx)*1.)
set vk[(oqx)]=((iYx)*1.)
set ek[(oqx)]=((izx)*1.)
if(xk[((oqx))])then
set izx=ok
endif
call SetUnitVertexColor(C[(oqx)],(R2I(((iWx+(fgx(((oqx)),rk+(ocx))))*1.))),(R2I(((iyx+(fgx(((oqx)),ik+(ocx))))*1.))),(R2I(((iYx+(fgx(((oqx)),ak+(ocx))))*1.))),(R2I(((izx+(fgx(((oqx)),nk+(ocx))))*1.))))
endfunction
function fhx takes integer oqx,real iWx,real iyx,real iYx,real izx returns nothing
call fGx(oqx,(zJ[(oqx)])+iWx,(ZJ[(oqx)])+iyx,(vk[(oqx)])+iYx,(ek[(oqx)])+izx)
endfunction
function fHx takes integer oqx returns integer
set Ak[oqx]=true
set Nk[oqx]=false
call rax(bk)
return oqx
endfunction
function fjx takes nothing returns integer
local integer oqx
if(Ek==8190)then
call oYx("FolderUnit_FolderVertexColor_StructTimed_Allocation_allocCustom","call DebugEx(FolderUnit_FolderVertexColor_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Xk+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Ok[(w)]==w)then
set Rk=Rk+1
set oqx=Rk
else
set oqx=Ok[(w)]
set Ok[(w)]=Ok[Ok[(w)]]
endif
set Ok[oqx]=Z
set Ik[oqx]=1
call fHx(oqx)
return oqx
endfunction
function fJx takes integer oqx returns boolean
set Gk=Gk+1
set hk[Gk]=oqx
set Hk[oqx]=Gk+1
return(Gk==0)
endfunction
function fkx takes nothing returns nothing
local integer olx=Gk
local integer oqx
loop
set oqx=hk[olx]
call fhx(fk[oqx],Bk[oqx],ck[oqx],Ck[oqx],dk[oqx])
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function fKx takes integer oqx returns nothing
set Ak[oqx]=false
call rgx(bk)
endfunction
function flx takes integer oqx returns nothing
if(Ik[oqx]>0)then
return
endif
if(Ok[oqx]!=Z)then
call oYx("FolderUnit_FolderVertexColor_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderVertexColor_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Xk+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set Ok[oqx]=Ok[(w)]
set Ok[(w)]=oqx
call fKx(oqx)
endfunction
function fLx takes integer oqx returns nothing
set Ik[oqx]=Ik[oqx]-1
call flx(oqx)
endfunction
function fmx takes integer oqx returns boolean
local integer okx=(Hk[(oqx)])
set Hk[hk[Gk]]=okx
set hk[okx-1]=hk[Gk]
set Hk[oqx]=0
set Gk=Gk-1
return(Gk==F)
endfunction
function fMx takes integer oqx,integer ibx,integer rkx returns nothing
call fLx((oqx))
call ijx(ibx)
if rrx(rkx,Fk,oqx)then
call Rmx(rkx,gk)
endif
if fmx(oqx)then
call iHx(jk)
endif
endfunction
function fpx takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
call fMx(oqx,ibx,fk[oqx])
endfunction
function fPx takes integer oqx,real iWx,real iyx,real iYx,real izx,real ilx returns nothing
local integer rkx=oqx
local integer D8x
local integer ibx
if(ilx==.0)then
call fhx((oqx),iWx,iyx,iYx,izx)
return
endif
set D8x=(R2I(((ilx*1./ Vk)*1.)))
set oqx=fjx()
set ibx=inx()
set Bk[oqx]=iWx*1./ D8x
set ck[oqx]=iyx*1./ D8x
set Ck[oqx]=iYx*1./ D8x
set dk[oqx]=izx*1./ D8x
set Dk[oqx]=ibx
set fk[oqx]=rkx
set ge[(ibx)]=(oqx)
if rtx(rkx,Fk,oqx)then
call I7x(rkx,gk)
endif
if fJx(oqx)then
call icx(jk,Vk,true,function fkx)
endif
call icx(ibx,ilx,false,function fpx)
endfunction
function fqx takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=RVx()
local real iWx=UJ
local real iyx=wJ
local real iYx=WJ
local real izx=yJ
if(iWx==-1)then
set iWx=(zJ[(Ixx)])
endif
if(iyx==-1)then
set iyx=(ZJ[(Ixx)])
endif
if(iYx==-1)then
set iYx=(vk[(Ixx)])
endif
if(izx==-1)then
set izx=(ek[(Ixx)])
endif
call fPx(Ixx,iWx,iyx,iYx,izx,YJ)
return true
endfunction
function fQx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
local real iWx=ffx(XPx(r1x,1),-1)
local real iyx=ffx(XPx(r1x,2),-1)
local real iYx=ffx(XPx(r1x,3),-1)
local real izx=ffx(XPx(r1x,4),-1)
local real ilx=(S2R((XPx(r1x,5))))
set UJ=iWx
set wJ=iyx
set WJ=iYx
set yJ=izx
set YJ=ilx
call O7x(ocx,function fqx)
return true
endfunction
function fsx takes nothing returns boolean
call XWx("-vertexcolor",function fQx)
return true
endfunction
function fSx takes nothing returns boolean
call E9x(function fsx,"CommandVertexColorUnit_Init")
return true
endfunction
function ftx takes nothing returns boolean
set Jk=Vnx(kk)
return true
endfunction
function fTx takes integer oqx,real o2x returns nothing
if((o2x<vJ)or(o2x>eJ))then
call oYx("FolderUnit_FolderPosition_StructX_Set","call DebugEx(FolderUnit_FolderPosition_StructX.NAME + \" out of bounds \" + Unit(this).GetName() + \" \" + R2S(val))",Lk+" out of bounds "+(GetUnitName(C[((oqx))]))+" "+R2S(o2x))
return
endif
call SetUnitX(C[(oqx)],o2x)
endfunction
function fux takes integer oqx,real o2x returns nothing
if((o2x<rJ)or(o2x>iJ))then
call oYx("FolderUnit_FolderPosition_StructY_Set","call DebugEx(FolderUnit_FolderPosition_StructY.NAME + \" out of bounds \" + Unit(this).GetName() + \" \" + R2S(val))",mk+" out of bounds "+(GetUnitName(C[((oqx))]))+" "+R2S(o2x))
return
endif
call SetUnitY(C[(oqx)],o2x)
endfunction
function fUx takes integer oqx,real x,real y,real z returns nothing
call SetUnitFlyHeight(C[(oqx)],z-XYx(x,y),.0)
endfunction
function fwx takes integer oqx returns real
return Olx(oqx,(GetUnitX(C[(((oqx)))])),(GetUnitY(C[(((oqx)))])))
endfunction
function fWx takes integer oqx,real x,real y returns nothing
call fTx(oqx,x)
call fux(oqx,y)
call fUx(oqx,x,y,fwx(oqx))
endfunction
function fyx takes nothing returns boolean
local integer rdx=(bv)
call fWx(RVx(),Kk,lk)
return true
endfunction
function fYx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
local real x=(S2R((XPx(r1x,1))))
local real y=(S2R((XPx(r1x,2))))
set Kk=x
set lk=y
call O7x(ocx,function fyx)
return true
endfunction
function fzx takes nothing returns boolean
call XWx("-move",function fYx)
return true
endfunction
function fZx takes nothing returns boolean
call E9x(function fzx,"MoveUnit_Init")
return true
endfunction
function f_x takes nothing returns boolean
set Mk=Vnx(pk)
return true
endfunction
function f0x takes string oMx returns boolean
return(oMx=="true")
endfunction
function f1x takes integer oqx,boolean f2x returns nothing
local real x=(GetUnitX(C[((oqx))]))
local real y=(GetUnitY(C[((oqx))]))
if f2x then
call ajx("ping unit "+(GetUnitName(C[(oqx)]))+" at "+R2S(x)+";"+R2S(y))
endif
call PingMinimapEx(x,y,5,(GetRandomInt((0),($FF))),(GetRandomInt((0),($FF))),(GetRandomInt((0),($FF))),true)
endfunction
function f3x takes nothing returns boolean
local integer rdx=(bv)
call f1x(RVx(),Pk)
return true
endfunction
function f4x takes nothing returns boolean
local integer rdx=(bv)
set Pk=f0x(XPx((mA[(rdx)]),1))
call Dfx(Ob,function f3x)
return true
endfunction
function f5x takes nothing returns boolean
call XWx("-pingSpawns",function f4x)
return true
endfunction
function f6x takes nothing returns boolean
call E9x(function f5x,"PingSpawns_Init")
return true
endfunction
function f7x takes nothing returns boolean
set qk=Vnx(Qk)
return true
endfunction
function f8x takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer id=(S2I((XPx(r1x,1))))
call oYx("RequestEvent_Event_Chat","call DebugEx(Event(id).GetName())",(JA[((id))]))
return true
endfunction
function f9x takes nothing returns boolean
call XWx("-event",function f8x)
return true
endfunction
function Fvx takes nothing returns boolean
call E9x(function f9x,"RequestEvent_Init")
return true
endfunction
function Fex takes nothing returns boolean
set sk=Vnx(Sk)
return true
endfunction
function Fxx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local string oSx=XPx(r1x,1)
local integer b7x
local string o4x
if(oSx==null)then
call oYx("RequestKeyMacro_Event_Chat","call DebugEx(\"invalid syntax\")","invalid syntax")
return true
endif
set b7x=(S2I((oSx)))
if(b7x==0)then
call oYx("RequestKeyMacro_Event_Chat","call DebugEx(\"invalid syntax\")","invalid syntax")
return true
endif
set o4x=o1x(b7x)
if(o4x==null)then
call oYx("RequestKeyMacro_Event_Chat","call DebugEx(\"no key found under \" + Integer.ToString(valueI))","no key found under "+(I2S((b7x))))
return true
endif
call oYx("RequestKeyMacro_Event_Chat","call DebugEx(result)",o4x)
return true
endfunction
function Fox takes nothing returns boolean
call XWx("-key",function Fxx)
return true
endfunction
function Frx takes nothing returns boolean
call E9x(function Fox,"RequestKeyMacro_Init")
return true
endfunction
function Fix takes nothing returns boolean
set tk=Vnx(Tk)
return true
endfunction
function Fax takes nothing returns nothing
local integer olx=Ke
loop
exitwhen(olx<0)
set uk[olx]=le[olx]
set olx=olx-1
endloop
set Uk=Ke
endfunction
function Fnx takes nothing returns integer
local integer o4x
if(Uk<0)then
return w
endif
set o4x=uk[0]
set uk[0]=uk[Uk]
set Uk=Uk-1
return o4x
endfunction
function FVx takes nothing returns nothing
local integer oqx
call oYx("Timer_RequestRunningList","call DebugEx(Timer.NAME + \" Request running list:\")",ee+" Request running list:")
call Fax()
loop
set oqx=Fnx()
exitwhen(oqx==w)
call oYx("Timer_RequestRunningList","call DebugEx(Code.GetNameById(this.GetActionFunc()))",(LoadStr(j,((Je[(oqx)])),0)))
endloop
call oYx("Timer_RequestRunningList","call DebugEx(Timer.NAME + \" end of Request running list\")",ee+" end of Request running list")
endfunction
function FEx takes nothing returns boolean
local integer rdx=(bv)
call FVx()
return true
endfunction
function FXx takes nothing returns boolean
call XWx("-timers",function FEx)
return true
endfunction
function FOx takes nothing returns boolean
call E9x(function FXx,"RequestTimers_Init")
return true
endfunction
function FRx takes nothing returns boolean
set wk=Vnx(Wk)
return true
endfunction
function FIx takes nothing returns boolean
local integer rdx=(bv)
call BZx(Jg,C[RVx()],yk)
return true
endfunction
function FAx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
local real o2x=(S2R((XPx(r1x,1))))
set yk=o2x
call O7x(ocx,function FIx)
return true
endfunction
function FNx takes nothing returns boolean
call XWx("-dmgtest",function FAx)
return true
endfunction
function Fbx takes nothing returns boolean
call E9x(function FNx,"SetDmgTest_Init")
return true
endfunction
function FBx takes nothing returns boolean
set Yk=Vnx(zk)
return true
endfunction
function Fcx takes integer oqx,string o6x,string oQx,string oSx returns nothing
if((o6x==null)or(oQx==null))then
call oYx("FolderGameCache_StructString_Set","call DebugEx(\"GameCache Set: \"+missionKey+\";\"+key)","GameCache Set: "+o6x+";"+oQx)
return
endif
call StoreString(Kv[(oqx)],o6x,oQx,oSx)
endfunction
function FCx takes nothing returns boolean
local integer rdx=(bv)
local string r1x=(mA[(rdx)])
local integer ocx=(eN[(rdx)])
local string rqx=XPx(r1x,1)
local string o2x=XPx(r1x,2)
if(rqx==null)then
call oYx("SetVar_Event_Chat","call DebugEx(\"SetVar: no name given\")","SetVar: no name given")
return true
endif
call Fcx(SH,rqx,"var",o2x)
call oYx("SetVar_Event_Chat","call DebugEx(\"SetVar: value of \" + name + \":\" + SetVar.GetVal(name))","SetVar: value of "+rqx+":"+(C8x(SH,(rqx),"var")))
return true
endfunction
function Fdx takes nothing returns boolean
set SH=V6x()
call XWx("-var",function FCx)
return true
endfunction
function FDx takes nothing returns boolean
call E9x(function Fdx,"SetVar_Init")
return true
endfunction
function Ffx takes nothing returns boolean
set Zk=Vnx(vK)
return true
endfunction
function FFx takes nothing returns boolean
set eK=Vnx(xK)
return true
endfunction
function Fgx takes nothing returns boolean
local integer rdx=(bv)
local integer ocx=(eN[(rdx)])
if rK then
call iLx(ocx,"A vote is already in process.",5.)
return true
elseif iK then
call iLx(ocx,"The vote option is on cooldown for another "+(R2S((((TimerGetRemaining(Oe[(oK)])))*1.)))+"seconds.",5.)
return true
endif
set rK=true
call XUx(vN,"-vote",aK)
return true
endfunction
function FGx takes nothing returns boolean
set oK=inx()
call XWx("-votehost",function Fgx)
return true
endfunction
function Fhx takes nothing returns boolean
call E9x(function FGx,"VoteHost_Init")
return true
endfunction
function FHx takes nothing returns boolean
set nK=Vnx(VK)
return true
endfunction
function Fjx takes code c,string rqx returns nothing
set qV=qV+1
set QV[qV]=CreateTrigger()
set sV[qV]=(GetHandleId(Condition((c))))
set SV[qV]=rqx
call TriggerAddCondition(QV[qV],Condition(c))
endfunction
function FJx takes integer id returns integer
return(LoadInteger(o[((V[(E[((X))])]))],(((OK+(id)))),(((IK)))))
endfunction
function Fkx takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((NH[(oqx)]))])]))],((((Ev[((oqx))])))),(((oQx)))))
endfunction
function FKx takes integer oqx,integer rJx returns boolean
return(Fkx(rJx,nh+oqx)!=w)
endfunction
function Flx takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((NK[(oqx)]))])]))],((((bK[((oqx))])))),(((oQx)))))
endfunction
function FLx takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=FJx((av[(rdx)]))
local integer Fmx=(AK)
if FKx(CMx,Flx(Fmx,BK))then
return false
endif
return true
return true
endfunction
function FMx takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((oA[(oqx)]))])]))],((((nA[((oqx))])))),(((oQx)))))
endfunction
function Fpx takes integer Xwx returns integer
return FMx(Xwx,CK)
endfunction
function FPx takes nothing returns boolean
local integer rdx=(bv)
local integer Fmx=Fpx((Nv))
if((nv[(rdx)])!=Flx(Fmx,BK))then
return false
endif
return true
return true
endfunction
function Fqx takes nothing returns boolean
local integer rdx=(bv)
local integer Fmx=Fpx((Nv))
if((nv[(rdx)])!=Flx(Fmx,BK))then
return false
endif
return true
return true
endfunction
function FQx takes integer oqx,integer okx returns real
return Cpx(oqx,QH+okx)
endfunction
function Fsx takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=FJx((av[(rdx)]))
local integer rJx=Flx((AK),BK)
if((LF[(CMx)])<FQx(rJx,1))then
return false
endif
return true
return true
endfunction
function FSx takes nothing returns boolean
local integer rdx=(bv)
local integer Rox=(Qb[(rdx)])
local integer Fmx=Fpx((Nv))
local integer rJx=Flx(Fmx,BK)
return(Rox==rJx)
return true
endfunction
function Ftx takes nothing returns boolean
local integer rdx=(bv)
local integer d2x=(nv[(rdx)])
local integer Fmx=Fpx((Nv))
local integer rJx=Flx(Fmx,BK)
return(d2x==rJx)
return true
endfunction
function FTx takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=FJx((av[(rdx)]))
local integer rJx=Flx((AK),BK)
return((Mb[(CMx)])==rJx)
return true
endfunction
function Fux takes nothing returns boolean
set EK=XLx(function FLx)
set cK=XLx(function FPx)
set dK=XLx(function Fqx)
set DK=XLx(function Fsx)
set fK=XLx(function FSx)
set FK=XLx(function Ftx)
set gK=XLx(function FTx)
return true
endfunction
function FUx takes nothing returns boolean
call Fjx(function Fux,"AIAutoCast_Init")
return true
endfunction
function Fwx takes nothing returns boolean
set zA=Vnx(uA)
return true
endfunction
function FWx takes code c,string rqx returns nothing
set Fi=Fi+1
set gi[Fi]=CreateTrigger()
set Gi[Fi]=(GetHandleId(Condition((c))))
set hi[Fi]=rqx
call TriggerAddCondition(gi[Fi],Condition(c))
endfunction
function Fyx takes nothing returns boolean
return true
endfunction
function FYx takes nothing returns boolean
set SA=V2x()
set Bv[(w)]=null
set GK=XLx(function Fyx)
return true
endfunction
function Fzx takes nothing returns boolean
call FWx(function FYx,"BoolExpr_Init")
return true
endfunction
function FZx takes nothing returns boolean
set hK=Vnx(HK)
return true
endfunction
function F_x takes nothing returns boolean
set jK=Vnx(JK)
return true
endfunction
function F0x takes nothing returns boolean
set kK=Vnx(KK)
return true
endfunction
function F1x takes nothing returns boolean
set lK=Vnx(LK)
return true
endfunction
function F2x takes nothing returns boolean
set mK=Vnx(MK)
return true
endfunction
function F3x takes nothing returns boolean
set pK=Vnx(PK)
return true
endfunction
function F4x takes nothing returns boolean
set qK=Vnx(QK)
return true
endfunction
function F5x takes nothing returns boolean
set sK=Vnx(SK)
return true
endfunction
function F6x takes nothing returns boolean
set tK=Vnx(TK)
return true
endfunction
function F7x takes nothing returns boolean
set uK=Vnx(UK)
return true
endfunction
function F8x takes nothing returns boolean
set wK=Vnx(WK)
return true
endfunction
function F9x takes nothing returns boolean
set yK=Vnx(YK)
return true
endfunction
function gvx takes nothing returns boolean
set zK=Vnx(ZK)
return true
endfunction
function gex takes nothing returns boolean
set vl=Vnx(xl)
return true
endfunction
function gxx takes nothing returns boolean
set ol=Vnx(rl)
return true
endfunction
function gox takes nothing returns boolean
set il=Vnx(al)
return true
endfunction
function grx takes nothing returns boolean
return true
endfunction
function gix takes nothing returns boolean
call FWx(function grx,"Buff_Init")
return true
endfunction
function gax takes nothing returns boolean
set nl=Vnx(Vl)
return true
endfunction
function gnx takes nothing returns boolean
set El=Vnx(Xl)
return true
endfunction
function gVx takes nothing returns boolean
set Ol=Vnx(Rl)
return true
endfunction
function gEx takes nothing returns boolean
set Il=Vnx(Al)
return true
endfunction
function gXx takes nothing returns boolean
set Nl=Vnx(bl)
return true
endfunction
function gOx takes nothing returns boolean
set Bl=Vnx(cl)
return true
endfunction
function gRx takes nothing returns boolean
set bD=Vnx(XD)
return true
endfunction
function gIx takes nothing returns boolean
set Cl=Vnx(dl)
return true
endfunction
function gAx takes code c,string rqx returns nothing
set aa=aa+1
set na[aa]=CreateTrigger()
set Va[aa]=(GetHandleId(Condition((c))))
set Ea[aa]=rqx
call TriggerAddCondition(na[aa],Condition(c))
endfunction
function gNx takes nothing returns integer
return omx(GetEnumPlayer())
endfunction
function gbx takes nothing returns nothing
local integer rdx=rEx(0)
set eN[(rdx)]=(gNx())
set mj[(rdx)]=(fl[Dl])
call Xfx(Fl[Dl],rdx)
call rHx(((rdx)))
endfunction
function gBx takes integer oqx,code Xbx,integer I3x returns nothing
set Dl=Dl+1
set fl[Dl]=I3x
set Fl[Dl]=XHx(Xbx)
call ForForce(mD[oqx],function gbx)
set Dl=Dl-1
endfunction
function gcx takes nothing returns boolean
local integer rdx=(bv)
local integer ocx=(eN[(rdx)])
local integer oqx=ocx
local integer ibx=inx()
set rf[oqx]=ibx
set af[oqx]=false
set ge[(ibx)]=(oqx)
return true
endfunction
function gCx takes nothing returns nothing
set Nf=function N1x
set Xf=inx()
call gBx(gl,function gcx,w)
endfunction
function gdx takes integer oqx,string o6x,string oQx,real oSx returns nothing
if((o6x==null)or(oQx==null))then
call oYx("FolderGameCache_StructReal_Set","call DebugEx(\"GameCache Set: \"+missionKey+\";\"+key)","GameCache Set: "+o6x+";"+oQx)
return
endif
call StoreReal(Kv[(oqx)],o6x,oQx,oSx)
endfunction
function gDx takes integer oqx,string o6x,string oQx,real oSx returns nothing
call gdx(oqx,o6x,oQx,oSx)
call SyncStoredReal(Kv[((oqx))],(o6x),(oQx))
endfunction
function gfx takes integer oqx,string o6x,string oQx returns real
if((o6x==null)or(oQx==null))then
call oYx("FolderGameCache_StructReal_Get","call DebugEx(\"GameCache Get: \"+missionKey+\";\"+key)","GameCache Get: "+o6x+";"+oQx)
return .0
endif
return GetStoredReal(Kv[(oqx)],o6x,oQx)
endfunction
function gFx takes integer oqx,integer ocx returns boolean
return IsPlayerInForce(vx[ocx],mD[oqx])
endfunction
function ggx takes real x,real y,real z returns real
return(SquareRoot(((x*x+y*y+z*z)*1.)))
endfunction
function gGx takes nothing returns nothing
local real ghx=(GetCameraEyePositionX())
local real gHx=(GetCameraEyePositionY())
local real gjx=(GetCameraEyePositionZ())
local real array gJx
local real array gkx
local real array gKx
local real oUx
local integer oqx
local integer ocx
local string glx
local string gLx
local string gmx
local integer i=SD
local integer gMx
local real gpx
loop
exitwhen(i<0)
set oqx=sD[i]
set oUx=CD[oqx]+dD[oqx]
set CD[oqx]=oUx
set i=i-1
endloop
if hl then
return
endif
set i=Hl
loop
exitwhen(i<0)
set ocx=jl[i]
if iVx(ocx)then
set glx=Jl[ocx]
set gLx=kl[ocx]
set gmx=Kl[ocx]
call gDx(Gl,glx,glx,(GetCameraEyePositionX()))
call gDx(Gl,gLx,gLx,(GetCameraEyePositionY()))
call gDx(Gl,gmx,gmx,(GetCameraEyePositionZ()))
endif
set i=i-1
endloop
set hl=true
call TriggerSyncStart()
call TriggerSyncReady()
set hl=false
set i=Hl
loop
exitwhen(i<0)
set ocx=jl[i]
set glx=Jl[ocx]
set gLx=kl[ocx]
set gmx=Kl[ocx]
set gJx[ocx]=gfx(Gl,glx,glx)
set gkx[ocx]=gfx(Gl,gLx,gLx)
set gKx[ocx]=gfx(Gl,gmx,gmx)
set i=i-1
endloop
set i=SD
loop
exitwhen(i<0)
set oqx=sD[i]
set oUx=CD[oqx]
set gMx=Hl
loop
exitwhen(gMx<0)
set ocx=jl[i]
if(gFx(gD[oqx],ocx)==false)then
set ghx=gJx[ocx]
set gHx=gkx[ocx]
set gjx=gKx[ocx]
set gpx=ggx(pD[oqx]-ghx,PD[oqx]-gHx,qD[oqx]-gjx)-oUx*oUx
if(gpx<cD[oqx])then
call bvx(jl[ocx],(1.-bUx(gpx-oUx)*1./ cD[oqx])*(FD[oqx]+(fD[oqx]-FD[oqx])*(1-oUx*1./ cD[oqx])),5.)
endif
endif
set gMx=gMx-1
endloop
set i=i-1
endloop
endfunction
function gPx takes nothing returns nothing
local integer i
local integer ocx
set TD=CreateTrigger()
set Gl=V6x()
set tD=inx()
call TriggerAddAction(TD,function gGx)
set i=Hl
loop
exitwhen(i<0)
set ocx=jl[i]
set Jl[ocx]="x"+(I2S((ocx)))
set kl[ocx]="y"+(I2S((ocx)))
set Kl[ocx]="z"+(I2S((ocx)))
set i=i-1
endloop
endfunction
function gqx takes nothing returns boolean
local integer rdx=(bv)
local integer ocx=(eN[(rdx)])
local integer oqx=ocx
set cf[oqx]=.0
set UD[oqx]=.0
set wD[oqx]=.0
set bf[oqx]=.0
set Bf[oqx]=.0
return true
endfunction
function gQx takes nothing returns nothing
set vf=inx()
call gBx(gl,function gqx,w)
endfunction
function gsx takes integer oqx returns integer
set ql[oqx]=true
set Ql[oqx]=false
call rax(El)
return oqx
endfunction
function gSx takes nothing returns integer
local integer oqx
if(ml==8190)then
call oYx("CameraField_Allocation_allocCustom","call DebugEx(CameraField.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Xl+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Ml[(w)]==w)then
set pl=pl+1
set oqx=pl
else
set oqx=Ml[(w)]
set Ml[(w)]=Ml[Ml[(w)]]
endif
set Ml[oqx]=Z
set Pl[oqx]=1
call gsx(oqx)
return oqx
endfunction
function gtx takes camerafield oMx returns integer
local integer oqx=gSx()
set sl[oqx]=oMx
return oqx
endfunction
function gTx takes nothing returns nothing
set ll=inx()
set Ll=gtx(CAMERA_FIELD_FARZ)
set Sl=gtx(CAMERA_FIELD_FIELD_OF_VIEW)
set tl=gtx(CAMERA_FIELD_ANGLE_OF_ATTACK)
set Tl=gtx(CAMERA_FIELD_ROLL)
set ul=gtx(CAMERA_FIELD_TARGET_DISTANCE)
set Ul=gtx(CAMERA_FIELD_ROTATION)
set wl=gtx(CAMERA_FIELD_ZOFFSET)
endfunction
function gux takes nothing returns boolean
call gCx()
call gPx()
call gQx()
call gTx()
return true
endfunction
function gUx takes nothing returns boolean
call gAx(function gux,"Camera_Init")
return true
endfunction
function gwx takes nothing returns boolean
set Wl=Vnx(yl)
return true
endfunction
function gWx takes nothing returns boolean
set Yl=Vnx(zl)
return true
endfunction
function gyx takes nothing returns boolean
set Zl=Vnx(vL)
return true
endfunction
function gYx takes nothing returns boolean
set eL=Vnx(xL)
return true
endfunction
function gzx takes nothing returns boolean
set oL=Vnx(rL)
return true
endfunction
function gZx takes nothing returns boolean
set iL=Vnx(aL)
return true
endfunction
function g_x takes nothing returns boolean
set nL=Vnx(VL)
return true
endfunction
function g0x takes nothing returns boolean
set EL=Vnx(XL)
return true
endfunction
function g1x takes nothing returns boolean
set OL=Vnx(RL)
return true
endfunction
function g2x takes code c,string rqx returns nothing
call VRx(pa,c,rqx)
endfunction
function g3x takes integer oqx returns integer
set CL[oqx]=true
set dL[oqx]=false
set DL[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set fL[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(FL)
return oqx
endfunction
function g4x takes nothing returns integer
local integer oqx
if(AL==8190)then
call oYx("DestructableType_Allocation_allocCustom","call DebugEx(DestructableType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",NL+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(bL[(w)]==w)then
set BL=BL+1
set oqx=BL
else
set oqx=bL[(w)]
set bL[(w)]=bL[bL[(w)]]
endif
set bL[oqx]=Z
set cL[oqx]=1
call g3x(oqx)
return oqx
endfunction
function g5x takes integer oqx returns nothing
local destructable g6x=CreateDestructable(gL[oqx],.0,.0,.0,.0,0)
set hL[oqx]=GetDestructableName(g6x)
call RemoveDestructable(g6x)
set g6x=null
endfunction
function g7x takes integer oqx returns nothing
set HL[(oqx)]=(jL+oqx)
endfunction
function g8x takes integer oMx returns integer
local integer oqx=g4x()
set gL[oqx]=oMx
call SaveInteger(o[((V[(E[((X))])]))],(((oMx))),(((GL))),(((oqx))))
call g5x(oqx)
call g7x(oqx)
call RemoveDestructable(CreateDestructable(gL[((oqx))],.0,.0,.0,.0,0))
return oqx
endfunction
function g9x takes nothing returns boolean
set IL=g8x('CKeg')
return true
endfunction
function Gvx takes nothing returns boolean
set JL=g8x('CExp')
return true
endfunction
function Gex takes nothing returns boolean
call g2x(function g9x,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Destructable.page\\DestructableType.struct\\Destructables.pack\\Keg\\obj_keg_wc3dest.j")
call g2x(function Gvx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Destructable.page\\DestructableType.struct\\obj_explosive_wc3dest.j")
return true
endfunction
function Gxx takes nothing returns boolean
set FL=Vnx(NL)
return true
endfunction
function Gox takes nothing returns boolean
set kL=Vnx(KL)
return true
endfunction
function Grx takes nothing returns boolean
set lL=Vnx(LL)
return true
endfunction
function Gix takes nothing returns boolean
set mL=Vnx(ML)
return true
endfunction
function Gax takes nothing returns boolean
set pL=Vnx(PL)
return true
endfunction
function Gnx takes nothing returns boolean
set qL=Vnx(QL)
return true
endfunction
function GVx takes nothing returns boolean
set sL=Vnx(SL)
return true
endfunction
function GEx takes nothing returns boolean
set tL=Vnx(TL)
return true
endfunction
function GXx takes nothing returns boolean
set uL=Vnx(UL)
return true
endfunction
function GOx takes nothing returns boolean
set wL=Vnx(WL)
return true
endfunction
function GRx takes nothing returns boolean
set yL=Vnx(YL)
return true
endfunction
function GIx takes nothing returns boolean
set zL=Vnx(ZL)
return true
endfunction
function GAx takes nothing returns boolean
set vm=Vnx(em)
return true
endfunction
function GNx takes nothing returns boolean
set xm=Vnx(om)
return true
endfunction
function Gbx takes nothing returns boolean
set rm=Vnx(im)
return true
endfunction
function GBx takes nothing returns boolean
set am=Vnx(nm)
return true
endfunction
function Gcx takes code c,string rqx returns nothing
set Xa=Xa+1
set Oa[Xa]=CreateTrigger()
set Ra[Xa]=(GetHandleId(Condition((c))))
set Ia[Xa]=rqx
call TriggerAddCondition(Oa[Xa],Condition(c))
endfunction
function GCx takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((Am[oqx]))])]))],((((Rm[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function Gdx takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((Am[oqx]))])]))],((((Rm[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function GDx takes integer oqx returns nothing
local integer rdx=rEx((Rm[(oqx)]))
local integer olx
local integer rIx
local integer rlx
set Im[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=GCx(oqx,Em,rIx)
loop
exitwhen(rlx<q)
call rCx(Gdx(oqx,Em,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function Gfx takes destructable oMx returns integer
return(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((oMx))))),((((Nm))))))
endfunction
function GFx takes nothing returns boolean
call GDx((Gfx(GetDyingDestructable())))
return true
endfunction
function Ggx takes integer oqx returns integer
set fm[oqx]=true
set Fm[oqx]=false
set gm[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set Am[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(am)
return oqx
endfunction
function GGx takes nothing returns integer
local integer oqx
if(cm==8190)then
call oYx("Destructable_Allocation_allocCustom","call DebugEx(Destructable.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",nm+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Cm[(w)]==w)then
set dm=dm+1
set oqx=dm
else
set oqx=Cm[(w)]
set Cm[(w)]=Cm[Cm[(w)]]
endif
set Cm[oqx]=Z
set Dm[oqx]=1
call Ggx(oqx)
return oqx
endfunction
function Ghx takes integer oqx returns nothing
set Rm[(oqx)]=(Jm+oqx)
endfunction
function GHx takes integer oqx returns nothing
set km[(oqx)]=((LoadInteger(o[((V[(E[((X))])]))],((((GetDestructableTypeId(Gm[(oqx)]))))),(((GL))))))
endfunction
function Gjx takes integer oqx,integer GJx returns nothing
call TriggerRegisterDeathEvent(fA[(oqx)],Gm[GJx])
endfunction
function Gkx takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((fL[oqx]))])]))],((((HL[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function GKx takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((fL[oqx]))])]))],((((HL[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function Glx takes integer oqx returns nothing
local integer GLx=(km[(oqx)])
local integer rdx=rEx(0)
local integer Gmx
local integer olx
local integer rIx
local integer rlx
set Im[(rdx)]=(oqx)
set Km[(rdx)]=(GLx)
set Gmx=rEx((HL[(GLx)]))
set Im[(Gmx)]=(oqx)
set Km[(Gmx)]=(GLx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Vm))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Vm))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set rlx=Gkx(GLx,Vm,rIx)
loop
exitwhen(rlx<q)
call rCx(GKx(GLx,Vm,rIx,rlx),Gmx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call rHx(((Gmx)))
endfunction
function GMx takes destructable oMx returns integer
local integer oqx=GGx()
set Gm[oqx]=oMx
set hm[oqx]=GetDestructableX(oMx)
set Hm[oqx]=GetDestructableY(oMx)
set jm[oqx]=.0
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oMx))))),((((Nm)))),((((oqx)))))
call Ghx(oqx)
call GHx(oqx)
call Gjx(Om,oqx)
call Glx(oqx)
return oqx
endfunction
function Gpx takes nothing returns boolean
local integer rdx=(bv)
local destructable GPx=GetEnumDestructable()
if((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GPx)))))),((((Nm))))))==w)then
call GMx(GPx)
endif
set GPx=null
return true
endfunction
function Gqx takes nothing returns boolean
local integer rdx=(bv)
call EnumDestructablesInRect(bm[Bm],null,function Gpx)
return true
endfunction
function GQx takes integer oqx returns integer
set qm[oqx]=true
set Qm[oqx]=false
set sm[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
call rax(Sm)
return oqx
endfunction
function Gsx takes nothing returns integer
local integer oqx
if(Lm==8190)then
call oYx("Rectangle_Allocation_allocCustom","call DebugEx(Rectangle.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",mm+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Mm[(w)]==w)then
set pm=pm+1
set oqx=pm
else
set oqx=Mm[(w)]
set Mm[(w)]=Mm[Mm[(w)]]
endif
set Mm[oqx]=Z
set Pm[oqx]=1
call GQx(oqx)
return oqx
endfunction
function GSx takes real Gtx,real GTx,real Gux,real GUx returns integer
local integer oqx=Gsx()
set tm[oqx]=(Gtx+Gux)*1./ 2
set Tm[oqx]=(GTx+GUx)*1./ 2
set um[oqx]=Gux
set Um[oqx]=GUx
set wm[oqx]=Gtx
set Wm[oqx]=GTx
return oqx
endfunction
function Gwx takes integer oqx returns nothing
set ym[(oqx)]=(zm+oqx)
endfunction
function GWx takes real Gtx,real GTx,real Gux,real GUx returns integer
local integer oqx=GSx(Gtx,GTx,Gux,GUx)
set bm[oqx]=Rect(Gtx,GTx,Gux,GUx)
call Gwx(oqx)
return oqx
endfunction
function Gyx takes real x,real y returns real
return(x*x+y*y)
endfunction
function GYx takes nothing returns boolean
local integer Gzx=(Gfx(GetFilterDestructable()))
if(Gyx(hm[Gzx]-gf,Hm[Gzx]-Gf)>hf)then
return false
endif
return true
endfunction
function GZx takes nothing returns nothing
set lm=GWx(.0,.0,.0,.0)
set Zm=XLx(function GYx)
endfunction
function G_x takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((gm[(oqx)]))])]))],((((Rm[((oqx))])))),(((oQx)))))
endfunction
function G0x takes integer oqx returns nothing
set rM[oqx]=false
call rgx(zL)
endfunction
function G1x takes integer oqx returns nothing
if(xM[oqx]>0)then
return
endif
if(oM[oqx]!=Z)then
call oYx("FolderDestructable_StructTimedLife_Allocation_deallocCustom_confirm","call DebugEx(FolderDestructable_StructTimedLife.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",ZL+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set oM[oqx]=oM[(w)]
set oM[(w)]=oqx
call G0x(oqx)
endfunction
function G2x takes integer oqx returns nothing
set xM[oqx]=xM[oqx]-1
call G1x(oqx)
endfunction
function G3x takes integer oqx,integer oQx returns nothing
call SaveInteger(o[(((V[(E[((gm[(oqx)]))])])))],(((((Rm[((oqx))]))))),((((oQx)))),(0))
endfunction
function G4x takes integer oqx,integer Xwx returns nothing
if not((LoadInteger(o[((D[((Am[oqx]))]))],((((Rm[((oqx))])))),(osx((((rA[(Xwx)]))),(((Xwx)))))))!=0)then
call oYx("FolderDestructable_StructEvent_Remove","call DebugEx(\"subject \"+I2S(Destructable(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((Rm[((oqx))]))+" has not "+(JA[(Xwx)]))
return
endif
call rex(Am[oqx],(Rm[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function G5x takes integer oqx,integer ibx,integer rkx returns nothing
call G2x((oqx))
call ijx(ibx)
call G3x(rkx,eM)
call G4x(rkx,vM)
endfunction
function G6x takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Im[(rdx)])
local integer oqx=G_x(rkx,eM)
call G5x(oqx,iM[oqx],rkx)
return true
endfunction
function G7x takes nothing returns nothing
endfunction
function G8x takes nothing returns boolean
set Vm=(E0x())
set Em=(E0x())
set Xm=(E0x())
set Om=Xhx(function GFx)
call DNx(XBx("Destructable_Init: call Event.Create(EventType.START, EventPriority.HEADER, function Destructable.Event_Start).AddToStatics()",XE,BI,function Gqx))
call GZx()
set vM=XBx("FolderDestructable_StructTimedLife_Init: set FolderDestructable_StructTimedLife.DEATH_EVENT = Event.Create(Destructable.DEATH_EVENT_TYPE, EventPriority.HEADER, function FolderDestructable_StructTimedLife.Event_Death)",Em,BI,function G6x)
call G7x()
return true
endfunction
function G9x takes nothing returns boolean
call Gcx(function G8x,"Destructable_Init")
return true
endfunction
function hvx takes nothing returns boolean
set aM=Vnx(nM)
return true
endfunction
function hex takes nothing returns boolean
set VM=Vnx(EM)
return true
endfunction
function hxx takes nothing returns boolean
set XM=Vnx(OM)
return true
endfunction
function hox takes nothing returns boolean
set RM=Vnx(IM)
return true
endfunction
function hrx takes nothing returns boolean
set AM=Vnx(NM)
return true
endfunction
function hix takes nothing returns boolean
set bM=Vnx(BM)
return true
endfunction
function hax takes nothing returns boolean
set cM=Vnx(CM)
return true
endfunction
function hnx takes nothing returns boolean
set dM=Vnx(DM)
return true
endfunction
function hVx takes nothing returns boolean
set fM=Vnx(FM)
return true
endfunction
function hEx takes nothing returns boolean
set gM=Vnx(GM)
return true
endfunction
function hXx takes nothing returns boolean
set hM=Vnx(HM)
return true
endfunction
function hOx takes nothing returns boolean
set jM=Vnx(JM)
return true
endfunction
function hRx takes nothing returns boolean
set kM=Vnx(KM)
return true
endfunction
function hIx takes nothing returns boolean
set lM=Vnx(LM)
return true
endfunction
function hAx takes nothing returns boolean
set mM=Vnx(MM)
return true
endfunction
function hNx takes nothing returns boolean
set pM=Vnx(PM)
return true
endfunction
function hbx takes nothing returns boolean
set qM=Vnx(QM)
return true
endfunction
function hBx takes nothing returns boolean
set sM=Vnx(SM)
return true
endfunction
function hcx takes nothing returns boolean
set tM=Vnx(TM)
return true
endfunction
function hCx takes dialog oMx returns integer
return(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((oMx))))),((((WM))))))
endfunction
function hdx takes integer oqx,integer oQx,integer oSx returns boolean
return((LoadInteger(o[((D[((cb[(oqx)]))]))],((((Cb[((oqx))])))),(osx(((oQx)),(((oSx)))))))!=0)
endfunction
function hDx takes integer oqx,integer oQx,integer oSx returns boolean
return rex(YM[(oqx)],(zM[((oqx))]),oQx,oSx)
endfunction
function hfx takes integer oqx,integer oQx,integer oSx returns boolean
return rex(cb[(oqx)],(Cb[((oqx))]),oQx,oSx)
endfunction
function hFx takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((cb[(oqx)]))])]))],((((Cb[((oqx))])))),(((oQx)))))
endfunction
function hgx takes integer oqx,integer oQx returns boolean
return((LoadInteger(o[((V[(E[((cb[(oqx)]))])]))],((((Cb[((oqx))])))),(((oQx)))))==0)
endfunction
function hGx takes integer oqx,integer oQx returns nothing
call SaveInteger(o[(((V[(E[((cb[(oqx)]))])])))],(((((Cb[((oqx))]))))),((((oQx)))),(0))
endfunction
function hhx takes integer ocx returns nothing
local integer oqx
if not iVx(ocx)then
return
endif
set oqx=ocx
if(xp[oqx]==w)then
return
endif
call MultiboardDisplay(op[xp[oqx]],true)
endfunction
function hHx takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[(((cb[(oqx)])))])]))],(((((Cb[((oqx))]))))),((((oQx))+(q)))))
endfunction
function hjx takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(YM[(oqx)],(zM[((oqx))]),oQx,oSx)
endfunction
function hJx takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((cb[(oqx)]))])]))],((((Cb[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function hkx takes integer oqx,integer ocx returns nothing
local boolean hasNext
local integer olx
if(ocx==Ge)then
set olx=Hl
loop
call hkx(oqx,jl[olx])
set olx=olx-1
exitwhen(olx<0)
endloop
return
endif
if(hdx(ocx,yM,oqx)==false)then
return
endif
call hDx(oqx,yM,ocx)
call hfx(ocx,yM,oqx)
if((hFx((ocx),ZM))==oqx)then
call hDx(oqx,vp,ocx)
if hgx(ocx,yM)then
call hGx(ocx,ZM)
call DialogDisplay(vx[ocx],ep[oqx],false)
call hhx(ocx)
else
set oqx=hHx(ocx,yM)
call hjx(oqx,vp,ocx)
call hJx(ocx,ZM,oqx)
call DialogDisplay(vx[ocx],ep[oqx],true)
endif
endif
endfunction
function hKx takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((ap[oqx]))])]))],((((zM[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function hlx takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((ap[oqx]))])]))],((((zM[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function hLx takes integer oqx,integer hmx returns nothing
local integer olx=Xv
local integer rlx
local integer rIx
local integer rdx=rEx((zM[(oqx)]))
set rp[(rdx)]=(oqx)
set ip[(rdx)]=(hmx)
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=hKx(oqx,uM,rIx)
loop
exitwhen(rlx<q)
call rCx(hlx(oqx,uM,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function hMx takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(cb[(oqx)],(Cb[((oqx))]),oQx,oSx)
endfunction
function hpx takes integer oqx,integer ocx returns nothing
local boolean hPx
local integer olx
if(ocx==Ge)then
set olx=Hl
loop
call hpx(oqx,jl[olx])
set olx=olx-1
exitwhen(olx<0)
endloop
return
endif
set hPx=hgx(ocx,yM)
if((hPx==false)and hdx(ocx,yM,oqx))then
return
endif
call hjx(oqx,yM,ocx)
call hMx(ocx,yM,oqx)
if hPx then
call hjx(oqx,vp,ocx)
call hJx(ocx,ZM,oqx)
call DialogDisplay(vx[ocx],ep[oqx],true)
endif
endfunction
function hqx takes nothing returns boolean
local integer hmx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((GetClickedButton()))))),((((wM))))))
local integer oqx=(hCx(GetClickedDialog()))
local integer ocx=opx()
call hkx(oqx,ocx)
call hLx(oqx,hmx)
if not hgx(ocx,yM)then
call hpx((hHx(ocx,yM)),ocx)
endif
return true
endfunction
function hQx takes nothing returns nothing
endfunction
function hsx takes nothing returns boolean
set uM=(E0x())
set UM=Xhx(function hqx)
call hQx()
return true
endfunction
function hSx takes nothing returns boolean
call gAx(function hsx,"Dialog_Init")
return true
endfunction
function htx takes nothing returns boolean
set Ri=Vnx(ai)
return true
endfunction
function hTx takes nothing returns boolean
set np=Vnx(Vp)
return true
endfunction
function hux takes nothing returns boolean
return true
endfunction
function hUx takes nothing returns boolean
set Ep=Vnx(Xp)
return true
endfunction
function hwx takes nothing returns boolean
set Op=Vnx(Rp)
return true
endfunction
function hWx takes nothing returns boolean
set Ip=Vnx(Ap)
return true
endfunction
function hyx takes nothing returns boolean
set Np=Vnx(bp)
return true
endfunction
function hYx takes nothing returns boolean
set Bp=Vnx(cp)
return true
endfunction
function hzx takes nothing returns boolean
set Cp=Vnx(dp)
return true
endfunction
function hZx takes nothing returns boolean
set Dp=Vnx(fp)
return true
endfunction
function h_x takes nothing returns boolean
set Fp=Vnx(gp)
return true
endfunction
function h0x takes nothing returns boolean
set Gp=Vnx(hp)
return true
endfunction
function h1x takes nothing returns boolean
return true
endfunction
function h2x takes nothing returns boolean
set Hp=Vnx(jp)
return true
endfunction
function h3x takes nothing returns boolean
set Jp=Vnx(kp)
return true
endfunction
function h4x takes nothing returns boolean
set Kp=Vnx(lp)
return true
endfunction
function h5x takes nothing returns boolean
set Lp=Vnx(mp)
return true
endfunction
function h6x takes nothing returns boolean
set Mp=Vnx(pp)
return true
endfunction
function h7x takes nothing returns boolean
set Pp=Vnx(qp)
return true
endfunction
function h8x takes nothing returns boolean
set Qp=Vnx(sp)
return true
endfunction
function h9x takes nothing returns boolean
set Sp=Vnx(tp)
return true
endfunction
function Hvx takes nothing returns boolean
set DB=Vnx(cB)
return true
endfunction
function Hex takes nothing returns boolean
set Tp=Vnx(up)
return true
endfunction
function Hxx takes code c,string rqx returns nothing
set ca=ca+1
set Ca[ca]=CreateTrigger()
set da[ca]=(GetHandleId(Condition((c))))
set Da[ca]=rqx
call TriggerAddCondition(Ca[ca],Condition(c))
endfunction
function Hox takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((yp[(oqx)]))])]))],((((Yp[((oqx))])))),(((oQx))))))
endfunction
function Hrx takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((yp[(oqx)]))])]))],((((Yp[((oqx))])))),(((oQx)+(okx)))))
endfunction
function Hix takes integer oqx returns nothing
set oP[oqx]=false
call rgx(Op)
endfunction
function Hax takes integer oqx returns nothing
if(eP[oqx]>0)then
return
endif
if(xP[oqx]!=Z)then
call oYx("DummyUnitEffect_Allocation_deallocCustom_confirm","call DebugEx(DummyUnitEffect.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Rp+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set xP[oqx]=xP[(w)]
set xP[(w)]=oqx
call Hix(oqx)
endfunction
function Hnx takes integer oqx returns nothing
set eP[oqx]=eP[oqx]-1
call Hax(oqx)
endfunction
function HVx takes integer oqx,integer oQx,integer oSx returns boolean
return rex(yp[(oqx)],(Yp[((oqx))]),oQx,oSx)
endfunction
function HEx takes integer oqx,integer Xwx returns nothing
if not((LoadInteger(o[((D[((rP[oqx]))]))],((((Yp[((oqx))])))),(osx((((rA[(Xwx)]))),(((Xwx)))))))!=0)then
call oYx("FolderDummyUnit_StructEvent_Remove","call DebugEx(\"subject \"+I2S(DummyUnit(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((Yp[((oqx))]))+" has not "+(JA[(Xwx)]))
return
endif
call rex(rP[oqx],(Yp[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function HXx takes integer oqx returns nothing
local integer HOx=Zp[oqx]
local effect oMx=vP[oqx]
call Hnx((oqx))
call DestroyEffect(oMx)
set oMx=null
if HVx(HOx,zp,oqx)then
call HEx(HOx,Up)
call HEx(HOx,iP)
endif
endfunction
function HRx takes nothing returns boolean
local integer rdx=(bv)
local integer HOx=(Wp[(rdx)])
local integer olx=Hox(HOx,zp)
local integer oqx
loop
set oqx=Hrx(HOx,zp,olx)
call HXx(oqx)
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function HIx takes nothing returns boolean
local integer rdx=(bv)
local integer HOx=(Wp[(rdx)])
local integer olx=Hox(HOx,zp)
local integer oqx
loop
set oqx=Hrx(HOx,zp,olx)
call HXx(oqx)
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function HAx takes nothing returns nothing
set Up=XBx("DummyUnitEffect_Init: set DummyUnitEffect.DEATH_EVENT = Event.Create(DummyUnit.DEATH_EVENT_TYPE, EventPriority.HEADER, function DummyUnitEffect.Event_Death)",wp,BI,function HRx)
set iP=XBx("DummyUnitEffect_Init: set DummyUnitEffect.DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function DummyUnitEffect.Event_Destroy)",aP,BI,function HIx)
endfunction
function HNx takes nothing returns nothing
endfunction
function Hbx takes integer oqx,integer Xwx returns nothing
if not((LoadInteger(o[((D[((VB[oqx]))]))],((((aB[((oqx))])))),(osx((((rA[(Xwx)]))),(((Xwx)))))))!=0)then
call oYx("FolderUnitEffect_StructEvent_Remove","call DebugEx(\"subject \"+I2S(UnitEffect(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((aB[((oqx))]))+" has not "+(JA[(Xwx)]))
return
endif
call rex(VB[oqx],(aB[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function HBx takes integer oqx,integer Oqx returns nothing
call Hbx(oqx,rC)
if rrx(Oqx,zc,oqx)then
call Rmx(Oqx,eC)
call Rmx(Oqx,xC)
if wc[oqx]then
call Rmx(Oqx,Zc)
else
call Rmx(Oqx,vC)
endif
endif
endfunction
function Hcx takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=(nB[(rdx)])
local integer Oqx=Yc[oqx]
call HBx(oqx,Oqx)
return true
endfunction
function HCx takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
local integer olx=CXx(Oqx,zc)
local integer oqx
loop
set oqx=COx(Oqx,zc,olx)
call Rqx(oqx)
set wc[oqx]=true
set olx=olx-1
exitwhen(olx<q)
endloop
call Rmx(Oqx,vC)
call I7x(Oqx,Zc)
return true
endfunction
function Hdx takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
local integer olx=CXx(Oqx,zc)
local integer oqx
loop
set oqx=COx(Oqx,zc,olx)
call RUx(oqx)
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function HDx takes integer oqx returns nothing
call SetUnitColor(C[(oqx)],(xx[(oqx)]))
endfunction
function Hfx takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
local integer olx=CXx(Oqx,zc)
local integer oqx
loop
set oqx=COx(Oqx,zc,olx)
call ANx(oqx)
set wc[oqx]=false
set olx=olx-1
exitwhen(olx<q)
endloop
call Rmx(Oqx,Zc)
call I7x(Oqx,vC)
call HDx(Oqx)
return true
endfunction
function HFx takes integer oqx returns nothing
if XB[oqx]then
return
endif
if(OB[oqx]==null)then
call DestroyEffect(RB[oqx])
set RB[oqx]=null
else
call DestroyEffect(OB[oqx])
set OB[oqx]=null
endif
if(ci>=Wc[oqx])then
set RB[oqx]=AddSpecialEffectTarget(yc[oqx],C[Yc[oqx]],Uc[oqx])
if(RB[oqx]==null)then
set RB[oqx]=AddSpecialEffect(null,.0,.0)
endif
else
set OB[oqx]=AddSpecialEffect(null,.0,.0)
endif
endfunction
function Hgx takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
local integer olx=CXx(Oqx,zc)
local integer oqx
loop
set oqx=COx(Oqx,zc,olx)
call HFx(oqx)
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function HGx takes nothing returns nothing
set EB=(E0x())
set rC=XBx("UnitEffect_Init: set UnitEffect.DESTROY_EVENT = Event.Create(UnitEffect.DESTROY_EVENT_TYPE, EventPriority.HEADER, function UnitEffect.Event_Destroy)",EB,BI,function Hcx)
set vC=XBx("UnitEffect_Init: set UnitEffect.UNIT_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function UnitEffect.Event_Unit_Death)",VP,BI,function HCx)
set eC=XBx("UnitEffect_Init: set UnitEffect.UNIT_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function UnitEffect.Event_Unit_Destroy)",EP,BI,function Hdx)
set Zc=XBx("UnitEffect_Init: set UnitEffect.UNIT_REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function UnitEffect.Event_Unit_Revive)",XP,BI,function Hfx)
set xC=XBx("UnitEffect_Init: set UnitEffect.UNIT_TYPE_CHANGE_EVENT = Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function UnitEffect.Event_Unit_TypeChange)",OP,BI,function Hgx)
endfunction
function Hhx takes nothing returns boolean
call HAx()
set nP=(E0x())
call HNx()
call HGx()
return true
endfunction
function HHx takes nothing returns boolean
call Hxx(function Hhx,"Effect_Init")
return true
endfunction
function Hjx takes nothing returns boolean
set RP=Vnx(IP)
return true
endfunction
function HJx takes nothing returns boolean
set AP=Vnx(NP)
return true
endfunction
function Hkx takes nothing returns boolean
set bP=Vnx(BP)
return true
endfunction
function HKx takes nothing returns boolean
set cP=Vnx(CP)
return true
endfunction
function Hlx takes nothing returns boolean
set dP=Vnx(DP)
return true
endfunction
function HLx takes nothing returns boolean
set fP=Vnx(FP)
return true
endfunction
function Hmx takes nothing returns nothing
set gP=V2x()
set GP=V2x()
endfunction
function HMx takes nothing returns nothing
set hP=V2x()
set HP=V2x()
set jP=V2x()
set JP=V2x()
set kP=V2x()
endfunction
function Hpx takes nothing returns nothing
set KP=V2x()
set lP=V2x()
endfunction
function HPx takes nothing returns nothing
call HMx()
call Hpx()
endfunction
function Hqx takes nothing returns boolean
call Hmx()
call HPx()
return true
endfunction
function HQx takes nothing returns boolean
call EZx(function Hqx,"EventMemory_Init")
return true
endfunction
function Hsx takes nothing returns boolean
set LP=Vnx(mP)
return true
endfunction
function HSx takes nothing returns boolean
set MP=Vnx(pP)
return true
endfunction
function Htx takes nothing returns boolean
set PP=Vnx(qP)
return true
endfunction
function HTx takes nothing returns boolean
set QP=Vnx(sP)
return true
endfunction
function Hux takes nothing returns boolean
set SP=Vnx(tP)
return true
endfunction
function HUx takes nothing returns boolean
set TP=Vnx(uP)
return true
endfunction
function Hwx takes nothing returns boolean
set UP=Vnx(wP)
return true
endfunction
function HWx takes nothing returns boolean
set WP=Vnx(yP)
return true
endfunction
function Hyx takes nothing returns boolean
set YP=Vnx(zP)
return true
endfunction
function HYx takes nothing returns boolean
set ZP=Vnx(vq)
return true
endfunction
function Hzx takes nothing returns boolean
set eq=Vnx(xq)
return true
endfunction
function HZx takes nothing returns boolean
set oq=Vnx(rq)
return true
endfunction
function H_x takes nothing returns boolean
set iq=Vnx(aq)
return true
endfunction
function H0x takes nothing returns boolean
return true
endfunction
function H1x takes nothing returns boolean
call Gcx(function H0x,"EventCombination_Init")
return true
endfunction
function H2x takes nothing returns boolean
set nq=Vnx(Vq)
return true
endfunction
function H3x takes nothing returns boolean
set zv=Vnx(uv)
return true
endfunction
function H4x takes nothing returns boolean
set Eq=Vnx(Xq)
return true
endfunction
function H5x takes nothing returns boolean
set Oq=Vnx(Rq)
return true
endfunction
function H6x takes nothing returns boolean
set Iq=Vnx(Aq)
return true
endfunction
function H7x takes nothing returns nothing
set bq=w
set Bq=inx()
endfunction
function H8x takes nothing returns nothing
set Cq=inx()
endfunction
function H9x takes integer oqx returns integer
set hq[oqx]=true
set Hq[oqx]=false
call rax(jq)
return oqx
endfunction
function jvx takes nothing returns integer
local integer oqx
if(Dq==8190)then
call oYx("PingColor_Allocation_allocCustom","call DebugEx(PingColor.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",fq+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Fq[(w)]==w)then
set gq=gq+1
set oqx=gq
else
set oqx=Fq[(w)]
set Fq[(w)]=Fq[Fq[(w)]]
endif
set Fq[oqx]=Z
set Gq[oqx]=1
call H9x(oqx)
return oqx
endfunction
function jex takes real iWx,real iyx,real iYx,real izx returns string
return iwx(iWx*1./ 255.,iyx*1./ 255.,iYx*1./ 255.,izx*1./ 255.)
endfunction
function jxx takes integer oqx returns boolean
if((mq[((oqx))])>0)then
return false
endif
set Mq=Mq+1
set pq[Mq]=oqx
set mq[oqx]=Mq+1
return(Mq==0)
endfunction
function jox takes string rqx,integer iWx,integer iyx,integer iYx returns integer
local integer oqx=jvx()
set Jq[oqx]=false
set kq[(oqx)]=(iqx(rqx,jex(iWx,iyx,iYx,$FF)))
set Kq[(oqx)]=(iWx)
set lq[(oqx)]=(iyx)
set Lq[(oqx)]=(iYx)
call jxx(oqx)
return oqx
endfunction
function jrx takes nothing returns nothing
set dq=jox("Blue",0,0,$FF)
set Pq=jox("Green",0,$FF,0)
set qq=jox("Red",$FF,0,0)
set Qq=jox("Magenta",$FF,0,$FF)
set sq=jox("Teal",0,$FF,$FF)
set Sq=jox("Yellow",$FF,$FF,0)
endfunction
function jix takes nothing returns boolean
set Nq=GetTimeOfDayScale()
call H7x()
set cq=true
call H8x()
call jrx()
return true
endfunction
function jax takes nothing returns boolean
call gAx(function jix,"Game_Init")
return true
endfunction
function jnx takes nothing returns boolean
set jq=Vnx(fq)
return true
endfunction
function jVx takes nothing returns boolean
set tq=Vnx(Tq)
return true
endfunction
function jEx takes nothing returns boolean
set uq=Vnx(Uq)
return true
endfunction
function jXx takes nothing returns boolean
set wq=Vnx(Wq)
return true
endfunction
function jOx takes nothing returns boolean
set yq=Vnx(Yq)
return true
endfunction
function jRx takes nothing returns boolean
set zq=Vnx(Zq)
return true
endfunction
function jIx takes nothing returns boolean
set vQ=Vnx(eQ)
return true
endfunction
function jAx takes nothing returns boolean
set xQ=Vnx(oQ)
return true
endfunction
function jNx takes nothing returns boolean
set rQ=Vnx(iQ)
return true
endfunction
function jbx takes nothing returns boolean
set aQ=Vnx(nQ)
return true
endfunction
function jBx takes nothing returns boolean
set VQ=Vnx(EQ)
return true
endfunction
function jcx takes nothing returns boolean
set XQ=Vnx(OQ)
return true
endfunction
function jCx takes nothing returns boolean
set RQ=Vnx(IQ)
return true
endfunction
function jdx takes nothing returns boolean
set AQ=Vnx(NQ)
return true
endfunction
function jDx takes nothing returns boolean
set kb=Vnx(gb)
return true
endfunction
function jfx takes code c,string rqx returns nothing
set Hi=Hi+1
set ji[Hi]=CreateTrigger()
set Ji[Hi]=(GetHandleId(Condition((c))))
set ki[Hi]=rqx
call TriggerAddCondition(ji[Hi],Condition(c))
endfunction
function jFx takes nothing returns integer
local unit oMx=GetFilterUnit()
local integer o4x
if(GetUnitAbilityLevel(oMx,'aLoc')>0)then
set oMx=null
return Z
endif
set o4x=aBx(oMx)
set oMx=null
return o4x
endfunction
function jgx takes real jGx,real jhx returns real
local real o4x
if(jhx==0)then
set o4x=-1
else
set o4x=jGx-(R2I(((jGx*1./ jhx)*1.)))*jhx
if(o4x<0)then
set o4x=o4x+jhx
endif
endif
return o4x
endfunction
function jHx takes real a,real b returns real
local real o4x
set a=jgx(a,df)
set b=jgx(b,df)
set o4x=bUx(a-b)
if(o4x>3.141592654)then
return(df-o4x)
endif
return o4x
endfunction
function jjx takes real x,real y returns real
return(SquareRoot(((x*x+y*y)*1.)))
endfunction
function jJx takes real x returns real
return(Cos(((x)*1.)))
endfunction
function jkx takes real x returns real
return(Sin(((x)*1.)))
endfunction
function jKx takes real jlx,real jLx,real oUx,real N8x,real jmx,real jMx,real x,real y returns boolean
local real dX=x-jlx
local real dY=y-jLx
local real jpx=jHx(N8x,(Atan2(((dY)*1.),((dX)*1.))))
local real d=jjx(dX,dY)
local real jPx=jJx(jpx)*d
local real jqx=jkx(jpx)*d
local real jQx=jmx+(jMx-jmx)*(jPx*1./ oUx)
if((jPx>=.0)and(jPx<=oUx)and(jqx<=jQx))then
return true
endif
return false
endfunction
function jsx takes nothing returns boolean
local integer jSx=jFx()
if not jKx(CQ,dQ,DQ,fQ,FQ,gQ,DPx(jSx),DQx(jSx))then
return false
endif
if(C[jSx]==zj[Zj])then
return false
endif
return true
endfunction
function jtx takes real ozx,real Ixx returns real
local real o4x=jHx(ozx,Ixx)
set ozx=jgx(ozx,df)
set Ixx=jgx(Ixx,df)
set o4x=Ixx-ozx
if(o4x>3.141592654)then
return-(df-o4x)
endif
if(o4x<-3.141592654)then
return(df+o4x)
endif
return o4x
endfunction
function jTx takes real a returns integer
if(a<0)then
return-1
endif
if(a>0)then
return 1
endif
return 0
endfunction
function jux takes real jlx,real jLx,real oUx,real N8x,real jmx,real jMx,real x,real y returns real
local real dX=x-jlx
local real dY=y-jLx
local real jUx=jtx(N8x,(Atan2(((dY)*1.),((dX)*1.))))
local real d=jjx(dX,dY)
local real jpx=bUx(jUx)
local real dirFactor=jTx(jUx)
local real jPx=jJx(jpx)*d
local real jqx=jkx(jpx)*d
local real jwx=(Atan2((((jMx-jmx))*1.),((oUx)*1.)))
local real jWx=(Atan2((((jqx-jmx))*1.),((jPx)*1.)))
local real jyx=jWx-jwx
local real jYx=bUx(jyx)
local real jzx=jjx(jqx-jmx,jPx)
local real jZx
local real j_x
local real j0x
if jKx(jlx,jLx,oUx,N8x,jmx,jMx,x,y)then
return .0
endif
set jZx=jJx(jYx)*jzx
set j_x=jkx(jYx)*jzx
set j0x=jjx(jMx-jmx,oUx)
if(jZx<0)then
if(jqx<jmx)then
return(-jPx)
endif
return jzx
endif
if(jZx>j0x)then
if(jqx<jMx)then
return(jPx-oUx)
endif
return jjx(jZx-j0x,j_x)
endif
if(jPx<0)then
if(jqx<jmx)then
return(-jPx)
endif
return j_x
endif
if(jPx>oUx)then
if(jqx<jMx)then
return(jPx-oUx)
endif
return j_x
endif
return j_x
endfunction
function j1x takes integer oqx,real jlx,real jLx,real oUx,real N8x,real jmx,real jMx returns real
return iOx(.0,jux(jlx,jLx,oUx,N8x,jmx,jMx,(GetUnitX(C[((oqx))])),(GetUnitY(C[((oqx))])))-dvx((oqx),true))
endfunction
function j2x takes integer oqx,real jlx,real jLx,real oUx,real N8x,real jmx,real jMx returns boolean
return(j1x(oqx,jlx,jLx,oUx,N8x,jmx,jMx)==.0)
endfunction
function j3x takes nothing returns boolean
local integer jSx=jFx()
if not j2x(jSx,HQ,jQ,JQ,kQ,KQ,lQ)then
return false
endif
if(C[jSx]==zj[Zj])then
return false
endif
return true
endfunction
function j4x takes nothing returns nothing
set hQ=XLx(function j3x)
set LQ=GWx(.0,.0,.0,.0)
endfunction
function j5x takes nothing returns nothing
set cQ=XLx(function jsx)
set GQ=GWx(.0,.0,.0,.0)
call j4x()
endfunction
function j6x takes nothing returns boolean
return( not(C[jFx()]==zj[Zj]))
endfunction
function j7x takes integer oqx,real x,real y,real j8x returns boolean
local real dX=x-(GetUnitX(C[(((oqx)))]))
local real dY=y-(GetUnitY(C[(((oqx)))]))
set j8x=(j8x+dvx((oqx),true))
return(dX*dX+dY*dY<j8x*j8x)
endfunction
function j9x takes nothing returns boolean
local integer jSx=jFx()
if not j7x(jSx,pQ,PQ,qQ)then
return false
endif
if(C[jSx]==zj[Zj])then
return false
endif
return true
endfunction
function Jvx takes integer oqx,real x,real y,real z,real j8x returns boolean
local real dX=x-(GetUnitX(C[((oqx))]))
local real dY=y-(GetUnitY(C[((oqx))]))
local real dZ=z-fwx(oqx)
set j8x=(j8x+dvx((oqx),true))
return(dX*dX+dY*dY+dZ*dZ<j8x*j8x)
endfunction
function Jex takes nothing returns boolean
local integer jSx=jFx()
if not Jvx(jSx,pQ,PQ,sQ,qQ)then
return false
endif
if(C[jSx]==zj[Zj])then
return false
endif
return true
endfunction
function Jxx takes nothing returns nothing
set MQ=XLx(function j9x)
set QQ=XLx(function Jex)
endfunction
function Jox takes nothing returns nothing
set mQ=XLx(function j6x)
call Jxx()
endfunction
function Jrx takes nothing returns boolean
return( not(C[jFx()]==zj[Zj]))
endfunction
function Jix takes nothing returns boolean
local integer jSx=jFx()
local real Gux=TQ
local real GUx=uQ
local real Gtx=UQ
local real GTx=wQ
local real x=DPx(jSx)
local real y=DQx(jSx)
if((x<=Gux)and(y<=GUx)and(x>=Gtx)and(y>=GTx))then
return true
endif
if(j7x(jSx,itx(iOx(Gtx,x),Gux),itx(iOx(GTx,y),GUx),.0))then
return true
endif
if(C[jSx]==zj[Zj])then
return false
endif
return false
endfunction
function Jax takes nothing returns nothing
set tQ=XLx(function Jix)
set WQ=GWx(.0,.0,.0,.0)
endfunction
function Jnx takes nothing returns nothing
set SQ=XLx(function Jrx)
call Jax()
endfunction
function JVx takes nothing returns nothing
call j5x()
call Jox()
call Jnx()
endfunction
function JEx takes integer oqx returns integer
set xs[oqx]=true
set os[oqx]=false
set Eb[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
call rax(rs)
return oqx
endfunction
function JXx takes nothing returns integer
local integer oqx
if(zQ==8190)then
call oYx("UnitList_Allocation_allocCustom","call DebugEx(UnitList.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Rj+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(ZQ[(w)]==w)then
set vs=vs+1
set oqx=vs
else
set oqx=ZQ[(w)]
set ZQ[(w)]=ZQ[ZQ[(w)]]
endif
set ZQ[oqx]=Z
set es[oqx]=1
call JEx(oqx)
return oqx
endfunction
function JOx takes integer oqx returns nothing
set Xb[(oqx)]=(is+oqx)
endfunction
function JRx takes integer oqx returns nothing
set as[oqx]=0
set ns[oqx]=false
endfunction
function JIx takes string rqx returns integer
local integer oqx=JXx()
set Ij[(oqx)]=(rqx)
call JOx(oqx)
call JRx(oqx)
return oqx
endfunction
function JAx takes nothing returns nothing
set Mj=JIx("world")
endfunction
function JNx takes nothing returns boolean
set bQ=O2x()
set BQ=O2x()
call JVx()
set yQ=O2x()
set YQ=O2x()
call JAx()
return true
endfunction
function Jbx takes nothing returns boolean
call jfx(function JNx,"Group_Init")
return true
endfunction
function JBx takes nothing returns boolean
set Vs=Vnx(Es)
return true
endfunction
function Jcx takes nothing returns boolean
set Xs=Vnx(Os)
return true
endfunction
function JCx takes nothing returns boolean
set Rs=Vnx(Is)
return true
endfunction
function Jdx takes nothing returns boolean
set As=Vnx(Ns)
return true
endfunction
function JDx takes nothing returns boolean
set bs=Vnx(Bs)
return true
endfunction
function Jfx takes nothing returns boolean
set rs=Vnx(Rj)
return true
endfunction
function JFx takes nothing returns boolean
set cs=Vnx(Cs)
return true
endfunction
function Jgx takes nothing returns boolean
set ds=Vnx(Ds)
return true
endfunction
function JGx takes nothing returns boolean
set fs=Vnx(Fs)
return true
endfunction
function Jhx takes nothing returns boolean
set gs=Vnx(Gs)
return true
endfunction
function JHx takes nothing returns boolean
set hs=Vnx(Hs)
return true
endfunction
function Jjx takes nothing returns boolean
set js=Vnx(Js)
return true
endfunction
function JJx takes nothing returns boolean
set ks=Vnx(Ks)
return true
endfunction
function Jkx takes nothing returns boolean
set ls=Vnx(Ls)
return true
endfunction
function JKx takes nothing returns boolean
set ms=Vnx(Ms)
return true
endfunction
function Jlx takes nothing returns boolean
set ps=Vnx(Ps)
return true
endfunction
function JLx takes nothing returns boolean
set qs=Vnx(Qs)
return true
endfunction
function Jmx takes nothing returns boolean
set ss=Vnx(Ss)
return true
endfunction
function JMx takes nothing returns boolean
set ts=Vnx(Ts)
return true
endfunction
function Jpx takes nothing returns boolean
set us=Vnx(Us)
return true
endfunction
function JPx takes nothing returns boolean
set ws=Vnx(Ws)
return true
endfunction
function Jqx takes nothing returns boolean
set ys=Vnx(Ys)
return true
endfunction
function JQx takes nothing returns boolean
set zs=Vnx(Zs)
return true
endfunction
function Jsx takes nothing returns boolean
set vS=Vnx(eS)
return true
endfunction
function JSx takes integer oqx returns integer
set aS[oqx]=true
set nS[oqx]=false
set VS[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
call rax(hs)
return oqx
endfunction
function Jtx takes nothing returns integer
local integer oqx
if(xS==8190)then
call oYx("ItemClass_Allocation_allocCustom","call DebugEx(ItemClass.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Hs+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(oS[(w)]==w)then
set rS=rS+1
set oqx=rS
else
set oqx=oS[(w)]
set oS[(w)]=oS[oS[(w)]]
endif
set oS[oqx]=Z
set iS[oqx]=1
call JSx(oqx)
return oqx
endfunction
function JTx takes integer oqx returns boolean
set ES=ES+1
set XS[ES]=oqx
set OS[oqx]=ES+1
return(ES==0)
endfunction
function Jux takes integer oqx returns nothing
set RS[(oqx)]=(IS+oqx)
endfunction
function JUx takes nothing returns integer
local integer oqx=Jtx()
call JTx(oqx)
call Jux(oqx)
return oqx
endfunction
function Jwx takes nothing returns nothing
set mh=JUx()
set AS=JUx()
endfunction
function JWx takes integer oqx returns integer
set fS[oqx]=true
set FS[oqx]=false
set Kh[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set gS[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(vS)
return oqx
endfunction
function Jyx takes nothing returns integer
local integer oqx
if(cS==8190)then
call oYx("Item_Allocation_allocCustom","call DebugEx(Item.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",eS+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(CS[(w)]==w)then
set dS=dS+1
set oqx=dS
else
set oqx=CS[(w)]
set CS[(w)]=CS[CS[(w)]]
endif
set CS[oqx]=Z
set DS[oqx]=1
call JWx(oqx)
return oqx
endfunction
function JYx takes integer oqx returns nothing
set lh[(oqx)]=(hS+oqx)
endfunction
function Jzx takes integer oMx returns integer
return(LoadInteger(o[((V[(E[((X))])]))],(((oMx))),(((jS)))))
endfunction
function JZx takes integer oqx returns nothing
set gh[oqx]=Jzx(GetItemTypeId(Gh[(oqx)]))
endfunction
function J_x takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((JS[(oqx)]))])]))],((((ph[((oqx))])))),(((oQx))))))
endfunction
function J0x takes integer oqx returns integer
return J_x((oqx),kS)
endfunction
function J1x takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((JS[(oqx)]))])]))],((((ph[((oqx))])))),(((oQx)+(okx)))))
endfunction
function J2x takes integer oqx,integer okx returns integer
return J1x((oqx),kS,okx)
endfunction
function J3x takes integer oqx,integer oQx,integer oSx returns boolean
return rex(Kh[(oqx)],(lh[((oqx))]),oQx,oSx)
endfunction
function J4x takes integer oqx,integer Xwx returns nothing
if not((LoadInteger(o[((D[((gS[oqx]))]))],((((lh[((oqx))])))),(osx((((rA[(Xwx)]))),(((Xwx)))))))!=0)then
call oYx("FolderItem_StructEvent_Remove","call DebugEx(\"subject \"+I2S(Item(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((lh[((oqx))]))+" has not "+(JA[(Xwx)]))
return
endif
call rex(gS[oqx],(lh[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function J5x takes integer oqx,integer oQx returns nothing
call SaveInteger(o[(((V[(E[((Kh[(oqx)]))])])))],(((((lh[((oqx))]))))),((((oQx)))),(0))
endfunction
function J6x takes integer oqx,integer rJx returns nothing
if J3x((oqx),Sh,rJx)then
call J4x((oqx),KS)
endif
call J5x((oqx),yh+rJx)
endfunction
function J7x takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(Kh[(oqx)],(lh[((oqx))]),oQx,oSx)
endfunction
function J8x takes integer oqx,integer Xwx returns nothing
if(gS[oqx]==w)then
call oYx("FolderItem_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oqx)+";"+(JA[(Xwx)]))
set gS[oqx]=X
endif
call rSx(gS[oqx],(lh[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function J9x takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((Kh[(oqx)]))])]))],((((lh[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function kvx takes integer oqx,integer rJx returns nothing
if J7x((oqx),Sh,rJx)then
call J8x((oqx),KS)
endif
call J9x((oqx),yh+rJx,1)
endfunction
function kex takes integer oqx,integer rJx,integer rwx returns nothing
if(rwx==0)then
call J6x(oqx,rJx)
return
endif
if((Ckx(((oqx)),yh+(rJx)))==0)then
call kvx(oqx,rJx)
endif
call J9x((oqx),yh+rJx,rwx)
endfunction
function kxx takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((JS[(oqx)]))])]))],((((ph[((oqx))])))),(((oQx)))))
endfunction
function kox takes integer oqx,integer rJx returns integer
return kxx((oqx),lS+rJx)
endfunction
function krx takes integer oqx returns nothing
local integer GLx=(gh[((oqx))])
local integer olx=J0x(GLx)
local integer rJx
loop
exitwhen(olx<q)
set rJx=J2x(GLx,olx)
call kex(oqx,rJx,kox(GLx,rJx))
set olx=olx-1
endloop
endfunction
function kix takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((gS[oqx]))])]))],((((lh[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function kax takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((gS[oqx]))])]))],((((lh[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function knx takes integer oqx,integer nyx returns nothing
local integer rkx=oqx
local integer rdx=rEx((lh[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set Ph[(rdx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=kix(rkx,mS,rIx)
loop
exitwhen(rlx<q)
call rCx(kax(rkx,mS,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function kVx takes integer oqx returns nothing
local integer rdx=rEx((lh[(oqx)]))
local integer olx
local integer rIx
local integer rlx
set Ph[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=kix(oqx,BS,rIx)
loop
exitwhen(rlx<q)
call rCx(kax(oqx,BS,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function kEx takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((Kh[oqx]))])])],((((lh[((oqx))])))))
endfunction
function kXx takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((gS[oqx]))])])],((((lh[((oqx))])))))
endfunction
function kOx takes integer oqx returns nothing
set fS[oqx]=false
call kEx((oqx))
call kXx(((oqx)))
call rgx(vS)
endfunction
function kRx takes integer oqx returns nothing
if(DS[oqx]>0)then
return
endif
if(CS[oqx]!=Z)then
call oYx("Item_Allocation_deallocCustom_confirm","call DebugEx(Item.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",eS+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set CS[oqx]=CS[(w)]
set CS[(w)]=oqx
call kOx(oqx)
endfunction
function kIx takes integer oqx returns nothing
set DS[oqx]=DS[oqx]-1
call kRx(oqx)
endfunction
function kAx takes integer oqx returns nothing
local item oMx=Gh[oqx]
call SetItemPosition(oMx,.0,.0)
call kVx(oqx)
call kIx((oqx))
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oMx))))),((((hh)))),((((oqx)))))
call RemoveItem(oMx)
set oMx=null
endfunction
function kNx takes integer oqx,integer nyx returns nothing
set LS[oqx]=nyx
call SetItemCharges(Gh[(oqx)],nyx)
call knx(oqx,nyx)
if((nyx==0)and((MS[((gh[((oqx))]))])>0))then
call kAx((oqx))
endif
endfunction
function kbx takes integer oqx returns nothing
call kNx(oqx,(MS[((gh[((oqx))]))]))
endfunction
function kBx takes integer oqx returns integer
return J_x((oqx),pS)
endfunction
function kcx takes integer oqx,integer rRx returns nothing
if J7x((oqx),Lh,rRx)then
call J8x((oqx),PS)
endif
endfunction
function kCx takes integer oqx,integer okx returns integer
return J1x((oqx),pS,okx)
endfunction
function kdx takes integer oqx returns nothing
local integer GLx=(gh[((oqx))])
local integer olx=kBx(GLx)
loop
exitwhen(olx<q)
call kcx(oqx,kCx(GLx,olx))
set olx=olx-1
endloop
endfunction
function kDx takes integer oqx returns nothing
local integer GLx=(gh[((oqx))])
local integer rdx=rEx((ph[(GLx)]))
local integer olx
local integer rIx
local integer rlx
set Ph[(rdx)]=(oqx)
set qh[(rdx)]=(GLx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=Chx(GLx,NS,rIx)
loop
exitwhen(rlx<q)
call rCx(CHx(GLx,NS,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function kfx takes item oMx returns integer
local integer oqx=Jyx()
set Gh[oqx]=oMx
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oMx))))),((((hh)))),((((oqx)))))
set GS[(oqx)]=(-1)
call JYx(oqx)
call JZx(oqx)
call krx(oqx)
call kbx(oqx)
call kdx(oqx)
call kDx(oqx)
return oqx
endfunction
function kFx takes nothing returns nothing
call kfx(GetEnumItem())
endfunction
function kgx takes nothing returns boolean
local integer rdx=(bv)
call EnumItemsInRect(bm[Bm],null,function kFx)
return true
endfunction
function kGx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Ph[(rdx)])
local integer olx=Cjx(rkx,Sh)
local integer rJx
loop
exitwhen(olx<q)
set rJx=CJx(rkx,Sh,olx)
call J3x(rkx,Sh,rJx)
call J5x(rkx,yh+rJx)
set olx=olx-1
endloop
call J4x(rkx,KS)
return true
endfunction
function khx takes integer oqx,integer oQx returns nothing
call dTx((Kh[(oqx)]),((lh[((oqx))])),(oQx))
endfunction
function kHx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Ph[(rdx)])
call khx(rkx,Lh)
call J4x(rkx,PS)
return true
endfunction
function kjx takes nothing returns nothing
endfunction
function kJx takes nothing returns boolean
call Jwx()
set NS=(E0x())
set bS=(E0x())
set BS=(E0x())
call DNx(XBx("Item_Init: call Event.Create(EventType.START, EventPriority.HEADER, function Item.Event_Start).AddToStatics()",XE,BI,function kgx))
set KS=XBx("FolderItem_StructAbilities_Init: set FolderItem_StructAbilities.DESTROY_EVENT = Event.Create(Item.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderItem_StructAbilities.Event_Destroy)",BS,BI,function kGx)
set mS=(E0x())
set PS=XBx("FolderItem_StructClasses_Init: set FolderItem_StructClasses.DESTROY_EVENT = Event.Create(Item.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderItem_StructClasses.Event_Destroy)",BS,BI,function kHx)
call kjx()
return true
endfunction
function kkx takes nothing returns boolean
call Gcx(function kJx,"Item_Init")
return true
endfunction
function kKx takes nothing returns boolean
set qS=Vnx(QS)
return true
endfunction
function klx takes nothing returns boolean
set sS=Vnx(SS)
return true
endfunction
function kLx takes nothing returns boolean
set tS=Vnx(TS)
return true
endfunction
function kmx takes nothing returns boolean
set uS=Vnx(US)
return true
endfunction
function kMx takes nothing returns boolean
set wS=Vnx(WS)
return true
endfunction
function kpx takes nothing returns boolean
set yS=Vnx(YS)
return true
endfunction
function kPx takes nothing returns boolean
set zS=Vnx(ZS)
return true
endfunction
function kqx takes nothing returns boolean
set vt=Vnx(et)
return true
endfunction
function kQx takes nothing returns boolean
set xt=Vnx(ot)
return true
endfunction
function ksx takes nothing returns boolean
set rt=Vnx(it)
return true
endfunction
function kSx takes nothing returns boolean
set at=Vnx(nt)
return true
endfunction
function ktx takes nothing returns boolean
return true
endfunction
function kTx takes nothing returns boolean
set Vt=Vnx(Et)
return true
endfunction
function kux takes nothing returns boolean
set tE=Vnx(pE)
return true
endfunction
function kUx takes nothing returns boolean
set Xt=Vnx(Ot)
return true
endfunction
function kwx takes nothing returns boolean
set Rt=Vnx(It)
return true
endfunction
function kWx takes nothing returns boolean
set At=Vnx(Nt)
return true
endfunction
function kyx takes nothing returns boolean
set bt=Vnx(Bt)
return true
endfunction
function kYx takes nothing returns boolean
set ct=Vnx(Ct)
return true
endfunction
function kzx takes nothing returns boolean
set dt=Vnx(Dt)
return true
endfunction
function kZx takes nothing returns boolean
set ft=Vnx(Ft)
return true
endfunction
function k_x takes nothing returns boolean
set gt=Vnx(Gt)
return true
endfunction
function k0x takes nothing returns boolean
set ht=Vnx(Ht)
return true
endfunction
function k1x takes nothing returns boolean
set jt=Vnx(Jt)
return true
endfunction
function k2x takes nothing returns boolean
set kt=Vnx(Kt)
return true
endfunction
function k3x takes nothing returns boolean
set lt=Vnx(Lt)
return true
endfunction
function k4x takes nothing returns boolean
set mt=Vnx(Mt)
return true
endfunction
function k5x takes nothing returns boolean
set pt=Vnx(Pt)
return true
endfunction
function k6x takes nothing returns boolean
set qt=Vnx(Qt)
return true
endfunction
function k7x takes nothing returns boolean
set St=Vnx(tt)
return true
endfunction
function k8x takes nothing returns boolean
set Tt=Vnx(ut)
return true
endfunction
function k9x takes nothing returns boolean
set Ut=Vnx(wt)
return true
endfunction
function Kvx takes nothing returns nothing
endfunction
function Kex takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((Zt[(oqx)]))])]))],((((vT[((oqx))])))),(((oQx))))))
endfunction
function Kxx takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((Zt[(oqx)]))])]))],((((vT[((oqx))])))),(((oQx)+(okx)))))
endfunction
function Kox takes integer oqx returns nothing
set iT[oqx]=false
call rgx(jt)
endfunction
function Krx takes integer oqx returns nothing
if(oT[oqx]>0)then
return
endif
if(rT[oqx]!=Z)then
call oYx("FolderLightning_FolderColor_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderLightning_FolderColor_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Jt+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set rT[oqx]=rT[(w)]
set rT[(w)]=oqx
call Kox(oqx)
endfunction
function Kix takes integer oqx returns nothing
set oT[oqx]=oT[oqx]-1
call Krx(oqx)
endfunction
function Kax takes integer oqx,integer oQx,integer oSx returns boolean
return rex(Zt[(oqx)],(vT[((oqx))]),oQx,oSx)
endfunction
function Knx takes integer oqx,integer Xwx returns nothing
if not((LoadInteger(o[((D[((aT[oqx]))]))],((((vT[((oqx))])))),(osx((((rA[(Xwx)]))),(((Xwx)))))))!=0)then
call oYx("FolderLightning_StructEvent_Remove","call DebugEx(\"subject \"+I2S(Lightning(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((vT[((oqx))]))+" has not "+(JA[(Xwx)]))
return
endif
call rex(aT[oqx],(vT[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function KVx takes integer oqx returns boolean
local integer okx=(nT[(oqx)])
set nT[VT[ET]]=okx
set VT[okx-1]=VT[ET]
set nT[oqx]=0
set ET=ET-1
return(ET==F)
endfunction
function KEx takes integer oqx,integer ibx,integer rkx returns nothing
call Kix((oqx))
call ijx(ibx)
if Kax(rkx,xT,oqx)then
call Knx(rkx,Yt)
endif
if KVx(oqx)then
call iHx(XT)
endif
endfunction
function KXx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(zt[(rdx)])
local integer olx=Kex(rkx,xT)
local integer oqx
loop
set oqx=Kxx(rkx,xT,olx)
call KEx(oqx,OT[oqx],rkx)
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function KOx takes nothing returns nothing
set Yt=XBx("FolderLightning_FolderColor_StructTimed_Init: set FolderLightning_FolderColor_StructTimed.DESTROY_EVENT = Event.Create(Lightning.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_FolderColor_StructTimed.Event_Destroy)",Wt,BI,function KXx)
set XT=inx()
endfunction
function KRx takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((Zt[(oqx)]))])]))],((((vT[((oqx))])))),(((oQx)))))
endfunction
function KIx takes integer oqx returns nothing
set BT[oqx]=false
call rgx(Tt)
endfunction
function KAx takes integer oqx returns nothing
if(NT[oqx]>0)then
return
endif
if(bT[oqx]!=Z)then
call oYx("FolderLightning_StructDestroyTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderLightning_StructDestroyTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",ut+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set bT[oqx]=bT[(w)]
set bT[(w)]=oqx
call KIx(oqx)
endfunction
function KNx takes integer oqx returns nothing
set NT[oqx]=NT[oqx]-1
call KAx(oqx)
endfunction
function Kbx takes integer oqx,integer oQx returns nothing
call SaveInteger(o[(((V[(E[((Zt[(oqx)]))])])))],(((((vT[((oqx))]))))),((((oQx)))),(0))
endfunction
function KBx takes integer oqx,integer ibx,integer rkx returns nothing
call KNx((oqx))
call ijx(ibx)
call Kbx(rkx,AT)
call Knx(rkx,RT)
endfunction
function Kcx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(zt[(rdx)])
local integer oqx=KRx(rkx,AT)
call KBx(oqx,cT[oqx],rkx)
return true
endfunction
function KCx takes integer oqx returns nothing
set gT[oqx]=false
call rgx(lt)
endfunction
function Kdx takes integer oqx returns nothing
if(fT[oqx]>0)then
return
endif
if(FT[oqx]!=Z)then
call oYx("FolderLightning_StructFromDummyUnitToUnit_Allocation_deallocCustom_confirm","call DebugEx(FolderLightning_StructFromDummyUnitToUnit.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Lt+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set FT[oqx]=FT[(w)]
set FT[(w)]=oqx
call KCx(oqx)
endfunction
function KDx takes integer oqx returns nothing
set fT[oqx]=fT[oqx]-1
call Kdx(oqx)
endfunction
function Kfx takes integer oqx,integer ozx returns nothing
if HVx(ozx,hT,oqx)then
call HEx(ozx,HT)
endif
endfunction
function KFx takes integer oqx returns nothing
local integer oSx=(JT[(oqx)])-1
set JT[oqx]=oSx
if((oSx==0)and kT[oqx])then
call OTx((oqx))
endif
endfunction
function Kgx takes integer oqx,integer Ixx returns nothing
if rrx(Ixx,hT,oqx)then
call Rmx(Ixx,jT)
call KFx(Ixx)
endif
endfunction
function KGx takes integer oqx returns boolean
local integer okx=(KT[(oqx)])
set KT[lT[LT]]=okx
set lT[okx-1]=lT[LT]
set KT[oqx]=0
set LT=LT-1
return(LT==F)
endfunction
function Khx takes integer oqx,integer rkx,integer ozx,integer Ixx returns nothing
call KDx((oqx))
call Kbx(rkx,DT)
call Knx(rkx,CT)
if(ozx!=w)then
call Kfx(oqx,ozx)
endif
if(Ixx!=w)then
call Kgx(oqx,Ixx)
endif
if KGx(oqx)then
call iHx(mT)
endif
endfunction
function KHx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(zt[(rdx)])
local integer oqx=KRx(rkx,DT)
call Khx(oqx,rkx,MT[oqx],pT[oqx])
return true
endfunction
function Kjx takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((aT[oqx]))])]))],((((vT[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function KJx takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((aT[oqx]))])]))],((((vT[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function Kkx takes integer oqx returns nothing
local integer rdx=rEx((vT[(oqx)]))
local integer olx
local integer rIx
local integer rlx
set zt[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=Kjx(oqx,yt,rIx)
loop
exitwhen(rlx<q)
call rCx(KJx(oqx,yt,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function KKx takes integer oqx returns nothing
if qT[oqx]then
set qT[oqx]=false
call Kkx(oqx)
endif
endfunction
function Klx takes integer oqx returns nothing
local integer rdx=rEx((vT[(oqx)]))
local integer olx
local integer rIx
local integer rlx
set zt[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=Kjx(oqx,Wt,rIx)
loop
exitwhen(rlx<q)
call rCx(KJx(oqx,Wt,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function KLx takes integer oqx,real iWx,real iyx,real iYx,real izx returns nothing
local integer ocx=fFx()
set QT[(oqx)]=((iWx)*1.)
set sT[(oqx)]=((iyx)*1.)
set ST[(oqx)]=((iYx)*1.)
set tT[(oqx)]=((izx)*1.)
set iWx=bJx(iWx,.0,1.)
set iyx=bJx(iyx,.0,1.)
set iYx=bJx(iYx,.0,1.)
set izx=bJx(izx,.0,1.)
call SetLightningColor(TT[(oqx)],iWx,iyx,iYx,izx)
endfunction
function Kmx takes integer oqx,real iWx,real iyx,real iYx,real izx returns nothing
call KLx(oqx,(QT[(oqx)])+iWx,(sT[(oqx)])+iyx,(ST[(oqx)])+iYx,(tT[(oqx)])+izx)
endfunction
function KMx takes integer oqx returns integer
set iT[oqx]=true
set WT[oqx]=false
call rax(jt)
return oqx
endfunction
function Kpx takes nothing returns integer
local integer oqx
if(UT==8190)then
call oYx("FolderLightning_FolderColor_StructTimed_Allocation_allocCustom","call DebugEx(FolderLightning_FolderColor_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Jt+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(rT[(w)]==w)then
set wT=wT+1
set oqx=wT
else
set oqx=rT[(w)]
set rT[(w)]=rT[rT[(w)]]
endif
set rT[oqx]=Z
set oT[oqx]=1
call KMx(oqx)
return oqx
endfunction
function KPx takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(Zt[(oqx)],(vT[((oqx))]),oQx,oSx)
endfunction
function Kqx takes integer oqx,integer Xwx returns nothing
if(aT[oqx]==w)then
call oYx("FolderLightning_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oqx)+";"+(JA[(Xwx)]))
set aT[oqx]=X
endif
call rSx(aT[oqx],(vT[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function KQx takes integer oqx returns boolean
set ET=ET+1
set VT[ET]=oqx
set nT[oqx]=ET+1
return(ET==0)
endfunction
function Ksx takes nothing returns nothing
local integer olx=ET
local integer oqx
loop
set oqx=VT[olx]
call Kmx(vu[oqx],yT[oqx],YT[oqx],zT[oqx],ZT[oqx])
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function KSx takes nothing returns nothing
local integer ibx=ifx()
local integer oqx=(ge[(ibx)])
call KEx(oqx,ibx,vu[oqx])
endfunction
function Ktx takes integer oqx,real iWx,real iyx,real iYx,real izx,real ilx returns nothing
local integer rkx=oqx
local integer D8x
local integer ibx
if(ilx==.0)then
call Kmx((oqx),iWx,iyx,iYx,izx)
return
endif
set D8x=(R2I(((ilx*1./ uT)*1.)))
set oqx=Kpx()
set ibx=inx()
set yT[oqx]=iWx*1./ D8x
set YT[oqx]=iyx*1./ D8x
set zT[oqx]=iYx*1./ D8x
set ZT[oqx]=izx*1./ D8x
set OT[oqx]=ibx
set vu[oqx]=rkx
set ge[(ibx)]=(oqx)
if KPx(rkx,xT,oqx)then
call Kqx(rkx,Yt)
endif
if KQx(oqx)then
call icx(XT,uT,true,function Ksx)
endif
call icx(ibx,ilx,false,function KSx)
endfunction
function KTx takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((Zt[oqx]))])])],((((vT[((oqx))])))))
endfunction
function Kux takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((aT[oqx]))])])],((((vT[((oqx))])))))
endfunction
function KUx takes integer oqx returns nothing
set ru[oqx]=false
call KTx((oqx))
call Kux(((oqx)))
call rgx(Ut)
endfunction
function Kwx takes integer oqx returns nothing
if(xu[oqx]>0)then
return
endif
if(ou[oqx]!=Z)then
call oYx("Lightning_Allocation_deallocCustom_confirm","call DebugEx(Lightning.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",wt+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set ou[oqx]=ou[(w)]
set ou[(w)]=oqx
call KUx(oqx)
endfunction
function KWx takes integer oqx returns nothing
set xu[oqx]=xu[oqx]-1
call Kwx(oqx)
endfunction
function Kyx takes nothing returns nothing
local integer KYx=ifx()
local integer oqx=(ge[(KYx)])
local lightning oMx=TT[oqx]
call ijx(KYx)
call KWx((oqx))
call DestroyLightning(oMx)
set oMx=null
endfunction
function Kzx takes integer oqx returns nothing
local integer KYx
call KKx(oqx)
set KYx=inx()
set ge[(KYx)]=(oqx)
call Klx(oqx)
call Ktx((oqx),-((.0)*1.),-((.0)*1.),-((.0)*1.),-(((tT[(oqx)]))*1.),((eu)*1.))
call icx(KYx,eu,false,function Kyx)
endfunction
function KZx takes nothing returns boolean
local integer rdx=(bv)
local integer ozx=(Wp[(rdx)])
local integer olx=Hox(ozx,hT)
local integer oqx
loop
set oqx=Hrx(ozx,hT,olx)
if(pT[oqx]==w)then
call Khx(oqx,PT[oqx],ozx,w)
call Kzx(PT[oqx])
else
call Kfx(oqx,ozx)
set MT[oqx]=w
set iu[oqx]=(oJ[(ozx)])
set au[oqx]=(nJ[(ozx)])
set nu[oqx]=(Vu[(ozx)])+Eu[oqx]
endif
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function K_x takes integer oqx,boolean Omx returns real
if Omx then
return(Iu[oqx]*(ob[((oqx))]))
endif
return Iu[oqx]
endfunction
function K0x takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer olx=CXx(Ixx,hT)
local integer oqx
local real dix
local real dax
loop
set oqx=COx(Ixx,hT,olx)
if(MT[oqx]==w)then
call Khx(oqx,PT[oqx],w,Ixx)
call Kzx(PT[oqx])
else
set dix=DPx(Ixx)
set dax=DQx(Ixx)
call Kgx(oqx,Ixx)
set pT[oqx]=w
set Xu[oqx]=dix
set Ou[oqx]=dax
set Ru[oqx]=Olx(Ixx,dix,dax)+K_x(Ixx,true)
endif
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function K1x takes nothing returns nothing
set CT=XBx("FolderLightning_StructFromDummyUnitToUnit_Init: set FolderLightning_StructFromDummyUnitToUnit.PARENT_STOP_EVENT = Event.Create(Lightning.STOP_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromDummyUnitToUnit.Event_Parent_Stop)",yt,BI,function KHx)
set HT=XBx("FolderLightning_StructFromDummyUnitToUnit_Init: set FolderLightning_StructFromDummyUnitToUnit.SOURCE_DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromDummyUnitToUnit.Event_Source_Destroy)",aP,BI,function KZx)
set jT=XBx("FolderLightning_StructFromDummyUnitToUnit_Init: set FolderLightning_StructFromDummyUnitToUnit.TARGET_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromDummyUnitToUnit.Event_Target_Destroy)",EP,BI,function K0x)
set mT=inx()
endfunction
function K2x takes integer oqx returns nothing
set Cu[oqx]=false
call rgx(mt)
endfunction
function K3x takes integer oqx returns nothing
if(Bu[oqx]>0)then
return
endif
if(cu[oqx]!=Z)then
call oYx("FolderLightning_StructFromSpotToDummyUnit_Allocation_deallocCustom_confirm","call DebugEx(FolderLightning_StructFromSpotToDummyUnit.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Mt+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set cu[oqx]=cu[(w)]
set cu[(w)]=oqx
call K2x(oqx)
endfunction
function K4x takes integer oqx returns nothing
set Bu[oqx]=Bu[oqx]-1
call K3x(oqx)
endfunction
function K5x takes integer oqx returns boolean
local integer okx=(Fu[(oqx)])
set Fu[gu[Gu]]=okx
set gu[okx-1]=gu[Gu]
set Fu[oqx]=0
set Gu=Gu-1
return(Gu==F)
endfunction
function K6x takes integer oqx,integer rkx,integer Ixx returns nothing
call K4x((oqx))
call Kbx(rkx,bu)
call Knx(rkx,Au)
if HVx(Ixx,Du,oqx)then
call HEx(Ixx,fu)
endif
if K5x(oqx)then
call iHx(hu)
endif
endfunction
function K7x takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(zt[(rdx)])
local integer oqx=KRx(rkx,bu)
call K6x(oqx,rkx,Hu[oqx])
return true
endfunction
function K8x takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Wp[(rdx)])
local integer olx=Hox(Ixx,Du)
local integer oqx
loop
set oqx=Hrx(Ixx,Du,olx)
call K6x(oqx,ju[oqx],Ixx)
call Kzx(ju[oqx])
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function K9x takes nothing returns nothing
set Au=XBx("FolderLightning_StructFromSpotToDummyUnit_Init: set FolderLightning_StructFromSpotToDummyUnit.PARENT_STOP_EVENT = Event.Create(Lightning.STOP_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromSpotToDummyUnit.Event_Parent_Stop)",yt,BI,function K7x)
set fu=XBx("FolderLightning_StructFromSpotToDummyUnit_Init: set FolderLightning_StructFromSpotToDummyUnit.TARGET_DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromSpotToDummyUnit.Event_Target_Destroy)",aP,BI,function K8x)
set hu=inx()
endfunction
function lvx takes integer oqx returns nothing
set mu[oqx]=false
call rgx(pt)
endfunction
function lex takes integer oqx returns nothing
if(lu[oqx]>0)then
return
endif
if(Lu[oqx]!=Z)then
call oYx("FolderLightning_StructFromSpotToSpot_Allocation_deallocCustom_confirm","call DebugEx(FolderLightning_StructFromSpotToSpot.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Pt+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set Lu[oqx]=Lu[(w)]
set Lu[(w)]=oqx
call lvx(oqx)
endfunction
function lxx takes integer oqx returns nothing
set lu[oqx]=lu[oqx]-1
call lex(oqx)
endfunction
function lox takes integer oqx,integer rkx returns nothing
call lxx((oqx))
call Kbx(rkx,Ku)
call Knx(rkx,Ju)
endfunction
function lrx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(zt[(rdx)])
local integer oqx=KRx(rkx,Ku)
call lox(oqx,rkx)
return true
endfunction
function lix takes integer oqx returns nothing
set su[oqx]=false
call rgx(qt)
endfunction
function lax takes integer oqx returns nothing
if(qu[oqx]>0)then
return
endif
if(Qu[oqx]!=Z)then
call oYx("FolderLightning_StructFromSpotToUnit_Allocation_deallocCustom_confirm","call DebugEx(FolderLightning_StructFromSpotToUnit.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Qt+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set Qu[oqx]=Qu[(w)]
set Qu[(w)]=oqx
call lix(oqx)
endfunction
function lnx takes integer oqx returns nothing
set qu[oqx]=qu[oqx]-1
call lax(oqx)
endfunction
function lVx takes integer oqx returns boolean
local integer okx=(uu[(oqx)])
set uu[Uu[wu]]=okx
set Uu[okx-1]=Uu[wu]
set uu[oqx]=0
set wu=wu-1
return(wu==F)
endfunction
function lEx takes integer oqx,integer rkx,integer Ixx returns nothing
call lnx((oqx))
call Kbx(rkx,Pu)
call Knx(rkx,Mu)
if rrx(Ixx,tu,oqx)then
call Rmx(Ixx,Tu)
call KFx(Ixx)
endif
if lVx(oqx)then
call iHx(Wu)
endif
endfunction
function lXx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(zt[(rdx)])
local integer oqx=KRx(rkx,Pu)
call lEx(oqx,rkx,yu[oqx])
return true
endfunction
function lOx takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer olx=CXx(Ixx,tu)
local integer oqx
loop
set oqx=COx(Ixx,tu,olx)
call lEx(oqx,Yu[oqx],Ixx)
call Kzx(Yu[oqx])
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function lRx takes nothing returns nothing
set Mu=XBx("FolderLightning_StructFromSpotToUnit_Init: set FolderLightning_StructFromSpotToUnit.PARENT_STOP_EVENT = Event.Create(Lightning.STOP_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromSpotToUnit.Event_Parent_Stop)",yt,BI,function lXx)
set Tu=XBx("FolderLightning_StructFromSpotToUnit_Init: set FolderLightning_StructFromSpotToUnit.TARGET_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromSpotToUnit.Event_Target_Destroy)",EP,BI,function lOx)
set Wu=inx()
endfunction
function lIx takes integer oqx returns nothing
set oU[oqx]=false
call rgx(St)
endfunction
function lAx takes integer oqx returns nothing
if(eU[oqx]>0)then
return
endif
if(xU[oqx]!=Z)then
call oYx("FolderLightning_StructFromUnitToUnit_Allocation_deallocCustom_confirm","call DebugEx(FolderLightning_StructFromUnitToUnit.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",tt+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set xU[oqx]=xU[(w)]
set xU[(w)]=oqx
call lIx(oqx)
endfunction
function lNx takes integer oqx returns nothing
set eU[oqx]=eU[oqx]-1
call lAx(oqx)
endfunction
function lbx takes integer oqx,integer lBx returns nothing
if rrx(lBx,iU,oqx)then
call Rmx(lBx,aU)
call KFx(lBx)
endif
endfunction
function lcx takes integer oqx returns boolean
local integer okx=(nU[(oqx)])
set nU[VU[EU]]=okx
set VU[okx-1]=VU[EU]
set nU[oqx]=0
set EU=EU-1
return(EU==F)
endfunction
function lCx takes integer oqx,integer rkx,integer ozx,integer Ixx returns nothing
call lNx((oqx))
call Kbx(rkx,vU)
call Knx(rkx,zu)
if(ozx!=w)then
call lbx(oqx,ozx)
endif
if(Ixx!=w)then
call lbx(oqx,Ixx)
endif
if lcx(oqx)then
call iHx(XU)
endif
endfunction
function ldx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(zt[(rdx)])
local integer oqx=KRx(rkx,vU)
call lCx(oqx,rkx,OU[oqx],RU[oqx])
return true
endfunction
function lDx takes nothing returns boolean
local integer rdx=(bv)
local integer lBx=(Vv[(rdx)])
local integer olx=CXx(lBx,iU)
local integer oqx
loop
set oqx=COx(lBx,iU,olx)
if(lBx==OU[oqx])then
if(RU[oqx]==w)then
call lCx(oqx,IU[oqx],lBx,w)
call Kzx(IU[oqx])
else
call lbx(oqx,lBx)
set OU[oqx]=w
set AU[oqx]=DPx(lBx)
set NU[oqx]=DQx(lBx)
set bU[oqx]=fwx(lBx)+OLx(lBx,true)
endif
else
if(OU[oqx]==w)then
call lCx(oqx,IU[oqx],w,lBx)
call Kzx(IU[oqx])
else
call lbx(oqx,lBx)
set RU[oqx]=w
set BU[oqx]=DPx(lBx)
set cU[oqx]=DQx(lBx)
set CU[oqx]=fwx(lBx)+K_x(lBx,true)
endif
endif
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function lfx takes nothing returns nothing
set zu=XBx("FolderLightning_StructFromUnitToUnit_Init: set FolderLightning_StructFromUnitToUnit.PARENT_STOP_EVENT = Event.Create(Lightning.STOP_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromUnitToUnit.Event_Parent_Stop)",yt,BI,function ldx)
set aU=XBx("FolderLightning_StructFromUnitToUnit_Init: set FolderLightning_StructFromUnitToUnit.POST_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromUnitToUnit.Event_Post_Destroy)",EP,BI,function lDx)
set XU=inx()
endfunction
function lFx takes nothing returns boolean
call Kvx()
set Wt=(E0x())
set yt=(E0x())
call KOx()
set RT=XBx("FolderLightning_StructDestroyTimed_Init: set FolderLightning_StructDestroyTimed.DESTROY_EVENT = Event.Create(Lightning.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructDestroyTimed.Event_Destroy)",Wt,BI,function Kcx)
call K1x()
call K9x()
set Ju=XBx("FolderLightning_StructFromSpotToSpot_Init: set FolderLightning_StructFromSpotToSpot.PARENT_STOP_EVENT = Event.Create(Lightning.STOP_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromSpotToSpot.Event_Parent_Stop)",yt,BI,function lrx)
call lRx()
call lfx()
return true
endfunction
function lgx takes nothing returns boolean
call Hxx(function lFx,"Lightning_Init")
return true
endfunction
function lGx takes nothing returns boolean
return true
endfunction
function lhx takes nothing returns boolean
set dU=Vnx(DU)
return true
endfunction
function lHx takes nothing returns boolean
set fU=Vnx(FU)
return true
endfunction
function ljx takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=FJx((av[(rdx)]))
local integer Fmx=(AK)
if FKx(CMx,Flx(Fmx,hU))then
return false
endif
return true
return true
endfunction
function lJx takes nothing returns boolean
local integer rdx=(bv)
local integer Fmx=(FMx(((Nv)),CK))
if((nv[(rdx)])!=Flx(Fmx,hU))then
return false
endif
return true
return true
endfunction
function lkx takes nothing returns boolean
local integer rdx=(bv)
local integer Fmx=(FMx(((Nv)),CK))
if((nv[(rdx)])!=Flx(Fmx,hU))then
return false
endif
return true
return true
endfunction
function lKx takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=FJx((av[(rdx)]))
local integer rJx=Flx((AK),hU)
if((LF[(CMx)])<FQx(rJx,1))then
return false
endif
return true
return true
endfunction
function llx takes nothing returns boolean
set gU=XLx(function ljx)
set HU=XLx(function lJx)
set jU=XLx(function lkx)
set JU=XLx(function lKx)
return true
endfunction
function lLx takes nothing returns boolean
call Fjx(function llx,"AICastSpell_Init")
return true
endfunction
function lmx takes integer oqx returns integer
set MU[oqx]=true
set pU[oqx]=false
set zB[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set kc[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(il)
return oqx
endfunction
function lMx takes nothing returns integer
local integer oqx
if(KU==8190)then
call oYx("Buff_Allocation_allocCustom","call DebugEx(Buff.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",al+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(lU[(w)]==w)then
set LU=LU+1
set oqx=LU
else
set oqx=lU[(w)]
set lU[(w)]=lU[lU[(w)]]
endif
set lU[oqx]=Z
set mU[oqx]=1
call lmx(oqx)
return oqx
endfunction
function lpx takes integer oqx returns nothing
set ZB[(oqx)]=(PU+oqx)
endfunction
function lPx takes integer oqx returns nothing
endfunction
function lqx takes integer oqx returns boolean
set iD=iD+1
set aD[iD]=oqx
set QU[oqx]=iD+1
return(iD==0)
endfunction
function lQx takes string rqx returns integer
local integer oqx=lMx()
call lpx(oqx)
set wd[(oqx)]=(true)
set qc[(oqx)]=(false)
set qU[(oqx)]=(false)
set rD[(oqx)]=(rqx+" (hidden)")
set Sc[((oqx))]=(true)
call lPx(oqx)
call Xkx((rD[(oqx)]),ub,oqx)
call lqx(oqx)
return oqx
endfunction
function lsx takes integer oqx,integer o6x,integer oQx,string oSx returns boolean
local integer o7x=(0+(LoadInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx))))))+1
call SaveInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx))),(((o7x)-0)))
call SaveStr(o[((V[(E[(oqx)])]))],((o6x)),((oQx+o7x)),((oSx)))
return(o7x==q)
endfunction
function lSx takes integer oqx,integer oQx,string oSx returns boolean
return lsx(zB[(oqx)],(ZB[((oqx))]),oQx,oSx)
endfunction
function ltx takes integer oqx,integer o6x,integer oQx,integer oSx returns boolean
local integer o7x=(0+(LoadInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx))))))+1
call SaveInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx))),(((o7x)-0)))
call SaveInteger(o[((V[(E[(oqx)])]))],((o6x)),((oQx+o7x)),((oSx)))
return(o7x==q)
endfunction
function lTx takes integer oqx,integer oQx,integer oSx returns boolean
return ltx(zB[(oqx)],(ZB[((oqx))]),oQx,oSx)
endfunction
function lux takes integer oqx,string lUx,string AIx,integer rwx returns nothing
call lSx((oqx),iC,AIx)
call lTx((oqx),aC,rwx)
call lSx((oqx),tc,lUx)
call DestroyEffect(AddSpecialEffect((lUx),.0,.0))
endfunction
function lwx takes integer oqx returns integer
set WU[oqx]=true
set yU[oqx]=false
set xc[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
call rax(YU)
return oqx
endfunction
function lWx takes nothing returns integer
local integer oqx
if(tU==8190)then
call oYx("UnitModSet_Allocation_allocCustom","call DebugEx(UnitModSet.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",TU+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(uU[(w)]==w)then
set UU=UU+1
set oqx=UU
else
set oqx=uU[(w)]
set uU[(w)]=uU[uU[(w)]]
endif
set uU[oqx]=Z
set wU[oqx]=1
call lwx(oqx)
return oqx
endfunction
function lyx takes integer oqx returns nothing
set oc[(oqx)]=(zU+oqx)
endfunction
function lYx takes nothing returns integer
local integer oqx=lWx()
call lyx(oqx)
return oqx
endfunction
function lzx takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(xc[(oqx)],(oc[((oqx))]),oQx,oSx)
endfunction
function lZx takes integer oqx,integer oQx,real oSx returns nothing
call SaveReal(o[((V[(E[((xc[(oqx)]))])]))],((((oc[((oqx))])))),(((oQx))),((((((oSx)*1.))*1.))*1.))
endfunction
function l_x takes integer oqx,integer IIx,real o2x returns nothing
call lzx((oqx),Vc,IIx)
call lZx((oqx),Xc+IIx,o2x)
endfunction
function l0x takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((zB[(oqx)]))])]))],((((ZB[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function l1x takes nothing returns boolean
set kU=lQx(sU+" (dummyBuff)")
call lux(kU,"Abilities\\Spells\\Other\\GeneralAuraTarget\\GeneralAuraTarget.mdl","origin",ri)
set SU=lYx()
call l_x(SU,ZU,.5)
call l0x(((kU)),vc+(1),(SU))
return true
endfunction
function l2x takes nothing returns boolean
set vw=lQx(sU+" (targetBuff)")
set qc[(vw)]=(true)
return true
endfunction
function l3x takes nothing returns boolean
call VRx(Ma,(function l1x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\AI\\LetOff.page\\AILetOff.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(Ma,(function l2x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\AI\\LetOff.page\\AILetOff.struct\\obj_targetBuff_wc3buff.j"))
return true
endfunction
function l4x takes nothing returns boolean
set ew=Vnx(sU)
return true
endfunction
function l5x takes code c,string rqx returns nothing
set wV=wV+1
set WV[wV]=CreateTrigger()
set yV[wV]=(GetHandleId(Condition((c))))
set YV[wV]=rqx
call TriggerAddCondition(WV[wV],Condition(c))
endfunction
function l6x takes integer oqx,integer Iox,integer rwx returns boolean
return DSx(oqx,Iox,rwx,w)
endfunction
function l7x takes nothing returns boolean
local integer rdx=(bv)
local integer ozx=(Vv[(rdx)])
local integer Ixx=(WH[(rdx)])
if not I6x(Ixx,yd)then
return true
endif
set rw=Ixx
call l6x(ozx,kU,1)
return true
endfunction
function l8x takes nothing returns boolean
local integer rdx=(bv)
local integer ozx=(Vv[(rdx)])
call I7x(ozx,xw)
return true
endfunction
function l9x takes integer oqx,integer Xwx returns nothing
if(kc[oqx]==w)then
call oYx("FolderBuff_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oqx)+";"+(JA[(Xwx)]))
set kc[oqx]=X
endif
call rSx(kc[oqx],(ZB[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function Lvx takes integer oqx,integer Rvx,integer Ixx returns boolean
return(IssueTargetOrderById(C[(oqx)],Pb[Rvx],C[(Ixx)]))
endfunction
function Lex takes integer oqx returns boolean
if((Ow[((oqx))])>0)then
return false
endif
set Rw=Rw+1
set Iw[Rw]=oqx
set Ow[oqx]=Rw+1
return(Rw==0)
endfunction
function Lxx takes nothing returns nothing
local integer olx=Rw
loop
exitwhen(olx<0)
set Aw[olx]=Iw[olx]
set olx=olx-1
endloop
set Nw=Rw
endfunction
function Lox takes nothing returns integer
local integer o4x
if(Nw<0)then
return w
endif
set o4x=Aw[0]
set Aw[0]=Aw[Nw]
set Nw=Nw-1
return o4x
endfunction
function Lrx takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((Fw[(oqx)]))])]))],((((gw[((oqx))])))),(((oQx)))))
endfunction
function Lix takes integer oqx returns real
return(tm[((Hw[(oqx)]))])
endfunction
function Lax takes integer oqx returns real
return(Tm[((Hw[(oqx)]))])
endfunction
function Lnx takes integer Oqx returns nothing
local integer oqx=Oqx
local integer rkx=cw[oqx]
local integer Rkx
local real x
local real y
if Cw then
return
endif
if(rkx==w)then
set Rkx=dw
else
set Rkx=(Dw[(rkx)])
endif
if(Rkx==w)then
if(fw[((Lrx(((uf[(Oqx)])),Gw)))])then
call Lvx(Oqx,Xw,hw)
else
call CAx(Oqx,Xw,(GetUnitX(C[((hw))])),(GetUnitY(C[((hw))])))
endif
else
set x=Lix(Rkx)
set y=Lax(Rkx)
if(fw[((Lrx(((uf[(Oqx)])),Gw)))])then
call CAx(Oqx,ch,x,y)
else
call CAx(Oqx,Xw,x,y)
endif
endif
endfunction
function LVx takes nothing returns nothing
local integer oqx
local integer ozx
local integer Ixx
call Lxx()
loop
set oqx=Lox()
exitwhen(oqx==w)
set ozx=oqx
set Ixx=nw[oqx]
if(Gyx(DQx(Ixx)-DQx(ozx),DPx(Ixx)-DPx(ozx))>Bw)then
call Ayx(ozx,kU)
call Lnx(ozx)
endif
endloop
endfunction
function LEx takes nothing returns boolean
local integer rdx=(bv)
local integer ozx=(Vv[(rdx)])
local integer Ixx=rw
local integer oqx=ozx
set nw[oqx]=Ixx
call I7x(ozx,xw)
if rtx(Ixx,Ew,oqx)then
call l6x(Ixx,vw,1)
endif
call Lvx(ozx,Xw,Ixx)
if Lex(oqx)then
call icx(iw,3.,true,function LVx)
endif
return true
endfunction
function LXx takes integer oqx returns boolean
if(((Ow[((oqx))])>0)==false)then
return false
endif
set Ow[Iw[Rw]]=Ow[oqx]
set Iw[Ow[oqx]-1]=Iw[Rw]
set Ow[oqx]=0
set Rw=Rw-1
return(Rw==F)
endfunction
function LOx takes nothing returns boolean
local integer rdx=(bv)
local integer ozx=(Vv[(rdx)])
local integer oqx=ozx
local integer Ixx=nw[oqx]
call Rmx(ozx,xw)
if rrx(Ixx,Ew,oqx)then
call Ayx(Ixx,vw)
endif
if LXx(oqx)then
call iHx(iw)
endif
return true
endfunction
function LRx takes nothing returns boolean
local integer rdx=(bv)
return true
endfunction
function LIx takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx
loop
set oqx=COx(Ixx,Ew,q)
exitwhen(oqx==w)
call Ayx((oqx),kU)
endloop
return true
endfunction
function LAx takes nothing returns boolean
set xw=XBx("AILetOff_Init: set AILetOff.ACQUIRE_EVENT = Event.Create(UNIT.Attack.Events.ACQUIRE_EVENT_TYPE, EventPriority.AI, function AILetOff.Event_Acquire)",ow,jI,function l7x)
set iw=inx()
call DNx(XBx("AILetOff_Init: call Event.Create(Spawn.DUMMY_EVENT_TYPE, EventPriority.AI, function AILetOff.Event_Spawn).AddToStatics()",aw,jI,function l8x))
call l9x(kU,XBx("AILetOff_Init: call AILetOff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.AI, function AILetOff.Event_BuffGain))",Bd,jI,function LEx))
call l9x(kU,XBx("AILetOff_Init: call AILetOff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.AI, function AILetOff.Event_BuffLose))",Jc,jI,function LOx))
call l9x(vw,XBx("AILetOff_Init: call AILetOff.TARGET_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.AI, function AILetOff.Event_TargetBuffGain))",Bd,jI,function LRx))
call l9x(vw,XBx("AILetOff_Init: call AILetOff.TARGET_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.AI, function AILetOff.Event_TargetBuffLose))",Jc,jI,function LIx))
return true
endfunction
function LNx takes nothing returns boolean
call l5x(function LAx,"AILetOff_Init")
return true
endfunction
function Lbx takes nothing returns boolean
set jw=Vnx(Jw)
return true
endfunction
function LBx takes nothing returns boolean
set kw=Vnx(Kw)
return true
endfunction
function Lcx takes nothing returns boolean
set lw=Vnx(Lw)
return true
endfunction
function LCx takes nothing returns boolean
set mw=Vnx(Mw)
return true
endfunction
function Ldx takes nothing returns boolean
set pw=Vnx(Pw)
return true
endfunction
function LDx takes nothing returns boolean
set qw=Vnx(Qw)
return true
endfunction
function Lfx takes nothing returns boolean
set sw=Vnx(Sw)
return true
endfunction
function LFx takes nothing returns boolean
set tw=Vnx(Tw)
return true
endfunction
function Lgx takes nothing returns boolean
set uw=Vnx(Uw)
return true
endfunction
function LGx takes nothing returns boolean
set ww=Vnx(Ww)
return true
endfunction
function Lhx takes nothing returns boolean
set yw=Vnx(Yw)
return true
endfunction
function LHx takes nothing returns boolean
set zw=Vnx(Zw)
return true
endfunction
function Ljx takes nothing returns boolean
set vW=Vnx(eW)
return true
endfunction
function LJx takes nothing returns boolean
set xW=Vnx(oW)
return true
endfunction
function Lkx takes nothing returns boolean
set rW=Vnx(iW)
return true
endfunction
function LKx takes nothing returns boolean
set aW=Vnx(xJ)
return true
endfunction
function Llx takes nothing returns boolean
set nW=Vnx(aJ)
return true
endfunction
function LLx takes nothing returns boolean
set VW=Vnx(EW)
return true
endfunction
function Lmx takes nothing returns boolean
set XW=Vnx(OW)
return true
endfunction
function LMx takes nothing returns boolean
set RW=Vnx(IW)
return true
endfunction
function Lpx takes nothing returns boolean
set AW=Vnx(NW)
return true
endfunction
function LPx takes nothing returns boolean
set bW=Vnx(BW)
return true
endfunction
function Lqx takes nothing returns boolean
set cW=Vnx(CW)
return true
endfunction
function LQx takes nothing returns boolean
set dW=Vnx(DW)
return true
endfunction
function Lsx takes nothing returns boolean
set fW=Vnx(FW)
return true
endfunction
function LSx takes nothing returns boolean
set gW=Vnx(GW)
return true
endfunction
function Ltx takes nothing returns boolean
set hW=Vnx(HW)
return true
endfunction
function LTx takes nothing returns boolean
set jW=Vnx(JW)
return true
endfunction
function Lux takes nothing returns boolean
set kW=Vnx(KW)
return true
endfunction
function LUx takes nothing returns boolean
set lW=Vnx(LW)
return true
endfunction
function Lwx takes code c,string rqx returns nothing
call VRx(qa,c,rqx)
endfunction
function LWx takes integer jGx,integer jhx returns integer
return(jGx-jGx/ jhx*jhx)
endfunction
function Lyx takes integer okx returns string
if(pW==false)then
set pW=true
set PW[0]="{0}"
set PW[1]="{1}"
set PW[2]="{2}"
set PW[3]="{3}"
set PW[4]="{4}"
set PW[5]="{5}"
set PW[6]="{6}"
set PW[7]="{7}"
set PW[8]="{8}"
set PW[9]="{9}"
set PW[$A]="{10}"
set PW[$B]="{11}"
set PW[$C]="{12}"
set PW[$D]="{13}"
set PW[$E]="{14}"
set PW[$F]="{15}"
set PW[16]="{16}"
set PW[17]="{17}"
set PW[18]="{18}"
set PW[19]="{19}"
set PW[20]="{20}"
set PW[21]="{21}"
set PW[22]="{22}"
set PW[23]="{23}"
set PW[24]="{24}"
set PW[25]="{25}"
set PW[26]="{26}"
set PW[27]="{27}"
set PW[28]="{28}"
set PW[29]="{29}"
set PW[30]="{30}"
set PW[31]="{31}"
set PW[32]=" "
set PW[33]="!"
set PW[34]="\""
set PW[35]="#"
set PW[36]="$"
set PW[37]="%"
set PW[38]="&"
set PW[39]="'"
set PW[40]="("
set PW[41]=")"
set PW[42]="*"
set PW[43]="+"
set PW[44]=","
set PW[45]="-"
set PW[46]="."
set PW[47]="/"
set PW[48]="0"
set PW[49]="1"
set PW[50]="2"
set PW[51]="3"
set PW[52]="4"
set PW[53]="5"
set PW[54]="6"
set PW[55]="7"
set PW[56]="8"
set PW[57]="9"
set PW[58]=":"
set PW[59]=";"
set PW[60]="<"
set PW[61]="="
set PW[62]=">"
set PW[63]="?"
set PW[64]="@"
set PW[65]="A"
set PW[66]="B"
set PW[67]="C"
set PW[68]="D"
set PW[69]="E"
set PW[70]="F"
set PW[71]="G"
set PW[72]="H"
set PW[73]="I"
set PW[74]="J"
set PW[75]="K"
set PW[76]="L"
set PW[77]="M"
set PW[78]="N"
set PW[79]="O"
set PW[80]="P"
set PW[81]="Q"
set PW[82]="R"
set PW[83]="S"
set PW[84]="T"
set PW[85]="U"
set PW[86]="V"
set PW[87]="W"
set PW[88]="X"
set PW[89]="Y"
set PW[90]="Z"
set PW[91]="["
set PW[92]="\\"
set PW[93]="]"
set PW[94]="^"
set PW[95]="_"
set PW[96]="`"
set PW[97]="a"
set PW[98]="b"
set PW[99]="c"
set PW['d']="d"
set PW['e']="e"
set PW['f']="f"
set PW['g']="g"
set PW['h']="h"
set PW['i']="i"
set PW['j']="j"
set PW['k']="k"
set PW['l']="l"
set PW['m']="m"
set PW['n']="n"
set PW['o']="o"
set PW['p']="p"
set PW['q']="q"
set PW['r']="r"
set PW['s']="s"
set PW['t']="t"
set PW['u']="u"
set PW['v']="v"
set PW['w']="w"
set PW['x']="x"
set PW['y']="y"
set PW['z']="z"
set PW['{']="{"
set PW['|']="|"
set PW['}']="}"
set PW[$7E]="~"
set PW[$7F]="{DEL}"
set PW[$80]=""
set PW[$81]="{129}"
set PW[$82]=""
set PW[$83]=""
set PW[$84]=""
set PW[$85]=""
set PW[$86]=""
set PW[$87]=""
set PW[$88]=""
set PW[$89]=""
set PW[$8A]=""
set PW[$8B]=""
set PW[$8C]=""
set PW[$8D]="{141}"
set PW[$8E]=""
set PW[$8F]="{143}"
set PW[$90]="{144}"
set PW[$91]=""
set PW[$92]=""
set PW[$93]=""
set PW[$94]=""
set PW[$95]=""
set PW[$96]=""
set PW[$97]=""
set PW[$98]=""
set PW[$99]=""
set PW[$9A]=""
set PW[$9B]=""
set PW[$9C]=""
set PW[$9D]="{157}"
set PW[$9E]=""
set PW[$9F]=""
set PW[$A0]=""
set PW[$A1]=""
set PW[$A2]=""
set PW[$A3]=""
set PW[$A4]=""
set PW[$A5]=""
set PW[$A6]=""
set PW[$A7]=""
set PW[$A8]=""
set PW[$A9]=""
set PW[$AA]=""
set PW[$AB]=""
set PW[$AC]=""
set PW[$AD]="{173}"
set PW[$AE]=""
set PW[$AF]=""
set PW[$B0]=""
set PW[$B1]=""
set PW[$B2]=""
set PW[$B3]=""
set PW[$B4]=""
set PW[$B5]=""
set PW[$B6]=""
set PW[$B7]=""
set PW[$B8]=""
set PW[$B9]=""
set PW[$BA]=""
set PW[$BB]=""
set PW[$BC]=""
set PW[$BD]=""
set PW[$BE]=""
set PW[$BF]=""
set PW[$C0]=""
set PW[$C1]=""
set PW[$C2]=""
set PW[$C3]=""
set PW[$C4]=""
set PW[$C5]=""
set PW[$C6]=""
set PW[$C7]=""
set PW[$C8]=""
set PW[$C9]=""
set PW[$CA]=""
set PW[$CB]=""
set PW[$CC]=""
set PW[$CD]=""
set PW[$CE]=""
set PW[$CF]=""
set PW[$D0]=""
set PW[$D1]=""
set PW[$D2]=""
set PW[$D3]=""
set PW[$D4]=""
set PW[$D5]=""
set PW[$D6]=""
set PW[$D7]=""
set PW[$D8]=""
set PW[$D9]=""
set PW[$DA]=""
set PW[$DB]=""
set PW[$DC]=""
set PW[$DD]=""
set PW[$DE]=""
set PW[$DF]=""
set PW[$E0]=""
set PW[$E1]=""
set PW[$E2]=""
set PW[$E3]=""
set PW[$E4]=""
set PW[$E5]=""
set PW[$E6]=""
set PW[$E7]=""
set PW[$E8]=""
set PW[$E9]=""
set PW[$EA]=""
set PW[$EB]=""
set PW[$EC]=""
set PW[$ED]=""
set PW[$EE]=""
set PW[$EF]=""
set PW[$F0]=""
set PW[$F1]=""
set PW[$F2]=""
set PW[$F3]=""
set PW[$F4]=""
set PW[$F5]=""
set PW[$F6]=""
set PW[$F7]=""
set PW[$F8]=""
set PW[$F9]=""
set PW[$FA]=""
set PW[$FB]=""
set PW[$FC]=""
set PW[$FD]=""
set PW[$FE]=""
set PW[$FF]=""
endif
return PW[okx]
endfunction
function LYx takes integer oMx returns string
local integer rvx=-1
local string s=""
local integer Lzx
loop
set Lzx=LWx(oMx,256)
set s=(Lyx((Lzx)))+s
set rvx=rvx+1
set oMx=(oMx-Lzx)/ 256
exitwhen(oMx==0)
endloop
return s
endfunction
function LZx takes integer id,boolean L_x returns nothing
if(LoadBoolean(o[((V[(E[((X))])]))],(((MW))),(((id)))))then
call oYx("InitAbility","call DebugEx(\"spell \" + GetObjectName(id) + \"(\" + Integer.ToAscii(id) + \") already preloaded\")","spell "+GetObjectName(id)+"("+LYx(id)+") already preloaded")
return
endif
call SaveBoolean(o[((V[(E[((X))])]))],(((MW))),(((id))),(((true))))
if(id==0)then
return
endif
call GetObjectName((id))
if not L_x then
return
endif
if(qW==null)then
set qW=afx(Player($F),'QPrL',0,0,0)
endif
if UnitAddAbility(qW,id)then
call UnitRemoveAbility(qW,id)
endif
endfunction
function L0x takes nothing returns boolean
call LZx('aLoc',false)
return true
endfunction
function L1x takes nothing returns boolean
call Lwx(function L0x,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Misc.page\\DummyUnit.struct\\obj_locustSpell_wc3spell.j")
return true
endfunction
function L2x takes nothing returns boolean
set QW=Vnx(sW)
return true
endfunction
function L3x takes nothing returns boolean
set SW=Vnx(tW)
return true
endfunction
function L4x takes nothing returns boolean
set TW=Vnx(uW)
return true
endfunction
function L5x takes integer oqx,integer oQx returns nothing
call SaveInteger(o[(((V[(E[((yp[(oqx)]))])])))],(((((Yp[((oqx))]))))),((((oQx)))),(0))
endfunction
function L6x takes integer oqx returns boolean
local integer okx=(yW[(oqx)])
set yW[YW[zW]]=okx
set YW[okx-1]=YW[zW]
set yW[oqx]=0
set zW=zW-1
return(zW==F)
endfunction
function L7x takes integer oqx,integer rkx,integer Ixx returns nothing
call HEx(rkx,UW)
call L5x(Ixx,WW)
if L6x(oqx)then
call iHx(ZW)
endif
endfunction
function L8x takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Wp[(rdx)])
local integer oqx=rkx
call L7x(oqx,rkx,vy[oqx])
return true
endfunction
function L9x takes nothing returns nothing
set UW=XBx("FolderDummyUnit_StructFollowDummyUnit_Init: set FolderDummyUnit_StructFollowDummyUnit.PARENT_DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderDummyUnit_StructFollowDummyUnit.Event_ParentDestroy)",aP,BI,function L8x)
set ZW=inx()
endfunction
function mvx takes integer oqx returns boolean
local integer okx=(ry[(oqx)])
set ry[iy[ay]]=okx
set iy[okx-1]=iy[ay]
set ry[oqx]=0
set ay=ay-1
return(ay==F)
endfunction
function mex takes integer oqx,integer rkx,integer Ixx returns nothing
call HEx(rkx,ey)
call rix(Ixx,oy)
if mvx(oqx)then
call iHx(ny)
endif
endfunction
function mxx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Wp[(rdx)])
local integer oqx=rkx
call mex(oqx,rkx,Vy[oqx])
return true
endfunction
function mox takes nothing returns nothing
set ey=XBx("FolderDummyUnit_StructFollowUnit_Init: set FolderDummyUnit_StructFollowUnit.PARENT_DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderDummyUnit_StructFollowUnit.Event_ParentDestroy)",aP,BI,function mxx)
set ny=inx()
endfunction
function mrx takes integer oqx returns boolean
local integer okx=(Oy[(oqx)])
set Oy[Ry[Iy]]=okx
set Ry[okx-1]=Ry[Iy]
set Oy[oqx]=0
set Iy=Iy-1
return(Iy==F)
endfunction
function mix takes integer oqx returns nothing
call HEx((oqx),Xy)
if mrx(oqx)then
call iHx(Ay)
endif
endfunction
function mnx takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=(Wp[(rdx)])
call mix(oqx)
return true
endfunction
function mVx takes nothing returns nothing
set Xy=XBx("FolderDummyUnit_StructRotate_Init: set FolderDummyUnit_StructRotate.DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderDummyUnit_StructRotate.Event_Destroy)",aP,BI,function mnx)
set Ay=inx()
endfunction
function mEx takes integer oqx returns integer
set Dy[oqx]=true
set fy[oqx]=false
set yp[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set rP[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(QW)
return oqx
endfunction
function mXx takes nothing returns integer
local integer oqx
if(by==8190)then
call oYx("DummyUnit_Allocation_allocCustom","call DebugEx(DummyUnit.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",sW+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(By[(w)]==w)then
set cy=cy+1
set oqx=cy
else
set oqx=By[(w)]
set By[(w)]=By[By[(w)]]
endif
set By[oqx]=Z
set Cy[oqx]=1
call mEx(oqx)
return oqx
endfunction
function mOx takes integer oqx returns nothing
set Yp[(oqx)]=(Jy+oqx)
endfunction
function mRx takes integer oqx,real oSx returns nothing
set ky[oqx]=oSx
call SetUnitFacing(zj[(oqx)],oSx*gy)
endfunction
function mIx takes integer oqx,integer bXx returns nothing
set Ky[oqx]=bXx
call SetUnitOwner(zj[(oqx)],vx[bXx],true)
endfunction
function mAx takes integer oqx,real x,real y,real z returns nothing
set Vu[oqx]=z
call SetUnitFlyHeight(zj[(oqx)],z-XYx(x,y),.0)
endfunction
function mNx takes integer oqx,real x,real y,real z returns nothing
call UnitAddAbility(zj[(((oqx)))],('aFly'))
call UnitRemoveAbility(zj[(((oqx)))],('aFly'))
call mAx(oqx,x,y,z)
endfunction
function mbx takes integer oqx,real oSx returns nothing
set ly[oqx]=oSx
call SetUnitScale(zj[(oqx)],oSx,oSx,oSx)
endfunction
function mBx takes integer oqx,real iWx,real iyx,real iYx,real izx returns nothing
set Ly[(oqx)]=((iWx)*1.)
set my[(oqx)]=((iyx)*1.)
set My[(oqx)]=((iYx)*1.)
set py[(oqx)]=((izx)*1.)
call SetUnitVertexColor(zj[(oqx)],(R2I(((iWx)*1.))),(R2I(((iyx)*1.))),(R2I(((iYx)*1.))),(R2I(((izx)*1.))))
endfunction
function mcx takes integer mCx,real x,real y,real z,real N8x returns integer
local integer oqx=mXx()
local unit oMx=afx(vx[Fy],mCx,.0,.0,N8x*gy)
set zj[oqx]=oMx
set Gy[oqx]=mCx
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oMx))))),((((Hy)))),((((oqx)))))
call mOx(oqx)
set oMx=null
call mRx(oqx,N8x)
call mIx(oqx,Fy)
call Dpx(oqx,x)
call Dqx(oqx,y)
call mNx(oqx,x,y,z)
call mbx((oqx),1.)
call mBx((oqx),255.,255.,255.,255.)
return oqx
endfunction
function mdx takes nothing returns nothing
set wp=(E0x())
set aP=(E0x())
call L9x()
call mox()
set Ey=inx()
call mVx()
set Ny=inx()
set Zj=mcx('qWoC',.0,.0,.0,.0)
endfunction
function mDx takes nothing returns boolean
call EVx()
call mdx()
return true
endfunction
function mfx takes nothing returns boolean
call Gcx(function mDx,"Misc_Init")
return true
endfunction
function mFx takes nothing returns boolean
set Py=Vnx(qy)
return true
endfunction
function mgx takes nothing returns boolean
set Qy=Vnx(sy)
return true
endfunction
function mGx takes nothing returns boolean
set Sy=Vnx(ty)
return true
endfunction
function mhx takes nothing returns boolean
set Ty=Vnx(uy)
return true
endfunction
function mHx takes nothing returns boolean
set Uy=Vnx(wy)
return true
endfunction
function mjx takes nothing returns boolean
set Wy=Vnx(yy)
return true
endfunction
function mJx takes nothing returns boolean
set Yy=Vnx(zy)
return true
endfunction
function mkx takes nothing returns boolean
set Zy=Vnx(vY)
return true
endfunction
function mKx takes nothing returns boolean
set eY=Vnx(xY)
return true
endfunction
function mlx takes nothing returns boolean
set oY=Vnx(rY)
return true
endfunction
function mLx takes nothing returns boolean
set iY=Vnx(aY)
return true
endfunction
function mmx takes nothing returns boolean
set nY=Vnx(VY)
return true
endfunction
function mMx takes nothing returns boolean
set EY=Vnx(XY)
return true
endfunction
function mpx takes nothing returns boolean
set OY=Vnx(RY)
return true
endfunction
function mPx takes nothing returns boolean
set IY=Vnx(AY)
return true
endfunction
function mqx takes nothing returns boolean
set NY=Vnx(bY)
return true
endfunction
function mQx takes nothing returns boolean
set BY=Vnx(cY)
return true
endfunction
function msx takes nothing returns boolean
set CY=Vnx(DY)
return true
endfunction
function mSx takes nothing returns boolean
set fY=Vnx(FY)
return true
endfunction
function mtx takes nothing returns boolean
set gY=Vnx(GY)
return true
endfunction
function mTx takes nothing returns boolean
set hY=Vnx(HY)
return true
endfunction
function mux takes nothing returns boolean
set jY=Vnx(JY)
return true
endfunction
function mUx takes nothing returns boolean
set kY=Vnx(KY)
return true
endfunction
function mwx takes nothing returns boolean
set lY=Vnx(LY)
return true
endfunction
function mWx takes nothing returns boolean
set mY=Vnx(MY)
return true
endfunction
function myx takes nothing returns boolean
set pY=Vnx(PY)
return true
endfunction
function mYx takes nothing returns boolean
set qY=Vnx(QY)
return true
endfunction
function mzx takes nothing returns boolean
set sY=Vnx(SY)
return true
endfunction
function mZx takes integer oqx,integer Xwx returns nothing
if not((LoadInteger(o[((D[((yY[oqx]))]))],((((YY[((oqx))])))),(osx((((rA[(Xwx)]))),(((Xwx)))))))!=0)then
call oYx("FolderMissile_StructEvent_Remove","call DebugEx(\"subject \"+I2S(Missile(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((YY[((oqx))]))+" has not "+(JA[(Xwx)]))
return
endif
call rex(yY[oqx],(YY[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function m_x takes integer oqx,integer o6x,integer oQx returns integer
return(LoadInteger(o[((V[(E[(oqx)])]))],((o6x)),((oQx))))
endfunction
function m0x takes integer oqx,integer o6x,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[(oqx)])]))],((o6x)),((oQx)),((oSx)))
endfunction
function m1x takes integer oqx returns integer
local integer el=(zY[(oqx)])
if(el==w)then
return w
endif
set zY[oqx]=m_x(X,el,ZY+oqx)
call m0x(X,el,ZY+oqx,w)
if((zY[(oqx)])==w)then
set vz[oqx]=w
else
call m0x(X,(zY[(oqx)]),xz+oqx,w)
endif
return el
endfunction
function m2x takes integer oqx returns nothing
loop
exitwhen(m1x(oqx)==w)
endloop
endfunction
function m3x takes integer oqx returns nothing
set az[oqx]=false
call rgx(gE)
endfunction
function m4x takes integer oqx returns nothing
if(rz[oqx]>0)then
return
endif
if(iz[oqx]!=Z)then
call oYx("Queue_Allocation_deallocCustom_confirm","call DebugEx(Queue.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",jE+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set iz[oqx]=iz[(w)]
set iz[(w)]=oqx
call m3x(oqx)
endfunction
function m5x takes integer oqx returns nothing
set rz[oqx]=rz[oqx]-1
call m4x(oqx)
endfunction
function m6x takes integer oqx returns nothing
call m2x(oqx)
call m5x((oqx))
endfunction
function m7x takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(WY[(rdx)])
local integer oqx=rkx
call mZx(rkx,wY)
call m2x(oz[(oqx)])
call m6x(oz[oqx])
return true
endfunction
function m8x takes nothing returns nothing
set uY=(E0x())
set UY=(E0x())
set wY=XBx("FolderMissile_StructCheckpoints_Init: set FolderMissile_StructCheckpoints.DESTROY_EVENT = Event.Create(Missile.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderMissile_StructCheckpoints.Event_Destroy)",tY,BI,function m7x)
endfunction
function m9x takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((yp[(oqx)]))])]))],((((Yp[((oqx))])))),(((oQx)))))
endfunction
function Mvx takes integer oqx,integer Xwx returns nothing
if(yY[oqx]==w)then
call oYx("FolderMissile_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oqx)+";"+(JA[(Xwx)]))
set yY[oqx]=X
endif
call rSx(yY[oqx],(YY[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function Mex takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((yp[(oqx)]))])]))],((((Yp[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function Mxx takes integer oqx,integer Xwx returns nothing
if(rP[oqx]==w)then
call oYx("FolderDummyUnit_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oqx)+";"+(JA[(Xwx)]))
set rP[oqx]=X
endif
call rSx(rP[oqx],(Yp[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function Mox takes integer oqx,integer oSx returns nothing
local integer abx=(Xz[(oqx)])
if(abx!=w)then
call L5x(abx,Ez)
call HEx(abx,nz)
call mZx((oqx),Oz)
endif
set Xz[oqx]=oSx
if(oSx!=w)then
call Mvx((oqx),Oz)
call Mex(oSx,Ez,oqx)
call Mxx(oSx,nz)
endif
endfunction
function Mrx takes nothing returns boolean
local integer rdx=(bv)
local integer oSx=(Wp[(rdx)])
local integer oqx=m9x(oSx,Ez)
call Mox(oqx,w)
return true
endfunction
function Mix takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((rP[oqx]))])]))],((((Yp[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function Max takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((rP[oqx]))])]))],((((Yp[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function Mnx takes integer oqx returns integer
set bz[oqx]=true
set Bz[oqx]=false
call rax(yw)
return oqx
endfunction
function MVx takes nothing returns integer
local integer oqx
if(Rz==8190)then
call oYx("FolderDummyUnit_StructDestruction_Allocation_allocCustom","call DebugEx(FolderDummyUnit_StructDestruction.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Yw+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Iz[(w)]==w)then
set Az=Az+1
set oqx=Az
else
set oqx=Iz[(w)]
set Iz[(w)]=Iz[Iz[(w)]]
endif
set Iz[oqx]=Z
set Nz[oqx]=1
call Mnx(oqx)
return oqx
endfunction
function MEx takes integer oqx returns nothing
set bz[oqx]=false
call rgx(yw)
endfunction
function MXx takes integer oqx returns nothing
if(Nz[oqx]>0)then
return
endif
if(Iz[oqx]!=Z)then
call oYx("FolderDummyUnit_StructDestruction_Allocation_deallocCustom_confirm","call DebugEx(FolderDummyUnit_StructDestruction.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Yw+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set Iz[oqx]=Iz[(w)]
set Iz[(w)]=oqx
call MEx(oqx)
endfunction
function MOx takes integer oqx returns nothing
set Nz[oqx]=Nz[oqx]-1
call MXx(oqx)
endfunction
function MRx takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((yp[oqx]))])])],((((Yp[((oqx))])))))
endfunction
function MIx takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((rP[oqx]))])])],((((Yp[((oqx))])))))
endfunction
function MAx takes integer oqx returns nothing
set Dy[oqx]=false
call MRx((oqx))
call MIx(((oqx)))
call rgx(QW)
endfunction
function MNx takes integer oqx returns nothing
if(Cy[oqx]>0)then
return
endif
if(By[oqx]!=Z)then
call oYx("DummyUnit_Allocation_deallocCustom_confirm","call DebugEx(DummyUnit.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",sW+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set By[oqx]=By[(w)]
set By[(w)]=oqx
call MAx(oqx)
endfunction
function Mbx takes integer oqx returns nothing
set Cy[oqx]=Cy[oqx]-1
call MNx(oqx)
endfunction
function MBx takes unit u returns nothing
if(u==null)then
call oYx("Basic_onRemoveUnit","call DebugEx(\"Basic.onRemoveUnit: invalid unit\")","Basic.onRemoveUnit: invalid unit")
return
endif
set nr=nr-1
endfunction
function Mcx takes unit a0 returns nothing
call MBx(a0)
call RemoveUnit(a0)
endfunction
function MCx takes integer oqx returns nothing
local integer rdx=rEx((Yp[(oqx)]))
local integer olx
local integer rIx
local integer rlx
local unit oMx
set Wp[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=Mix(oqx,aP,rIx)
loop
exitwhen(rlx<q)
call rCx(Max(oqx,aP,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
set oMx=zj[oqx]
call Mbx((oqx))
call Mcx(oMx)
set oMx=null
endfunction
function Mdx takes nothing returns nothing
local integer ibx=ifx()
local integer oqx=(ge[(ibx)])
local integer rkx=cz[oqx]
call MOx((oqx))
call ijx(ibx)
call MCx(rkx)
endfunction
function MDx takes integer oqx returns nothing
local integer rkx=oqx
local integer ibx
set oqx=MVx()
set ibx=inx()
set cz[oqx]=rkx
set ge[(ibx)]=(oqx)
call icx(ibx,5.,false,function Mdx)
endfunction
function Mfx takes integer oqx returns nothing
local integer rdx=rEx((Yp[(oqx)]))
local integer olx
local integer rIx
local integer rlx
set Wp[(rdx)]=(oqx)
if(GetUnitAbilityLevel(zj[oqx],'aLoc')==0)then
call oYx("DummyUnit_Destroy","call DebugEx(GetUnitName(this.self) + \" had no locust\")",GetUnitName(zj[oqx])+" had no locust")
endif
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=Mix(oqx,wp,rIx)
loop
exitwhen(rlx<q)
call rCx(Max(oqx,wp,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call SetUnitAnimation(zj[((oqx))],("death"))
call QueueUnitAnimation(zj[((oqx))],(null))
call MDx(oqx)
endfunction
function MFx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(WY[(rdx)])
local integer oqx=rkx
local integer oSx=(Xz[(oqx)])
call Mox(oqx,w)
call Mfx(oSx)
return true
endfunction
function Mgx takes nothing returns nothing
set nz=XBx("FolderMissile_StructDummyUnit_Init: set FolderMissile_StructDummyUnit.DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderMissile_StructDummyUnit.Event_Destroy)",aP,BI,function Mrx)
set Oz=XBx("FolderMissile_StructDummyUnit_Init: set FolderMissile_StructDummyUnit.PARENT_DESTROY_EVENT = Event.Create(Missile.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderMissile_StructDummyUnit.Event_ParentDestroy)",tY,BI,function MFx)
endfunction
function MGx takes integer oqx returns boolean
if(((dz[((oqx))])>0)==false)then
return false
endif
set dz[Dz[fz]]=dz[oqx]
set Dz[dz[oqx]-1]=Dz[fz]
set dz[oqx]=0
set fz=fz-1
return(fz==F)
endfunction
function Mhx takes integer oqx returns nothing
call mZx((oqx),Cz)
if MGx(oqx)then
call iHx(Fz)
endif
endfunction
function MHx takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=(WY[(rdx)])
call Mhx(oqx)
return true
endfunction
function Mjx takes nothing returns nothing
set Cz=XBx("FolderMissile_StructGoToSpot_Init: set FolderMissile_StructGoToSpot.STOP_EVENT = Event.Create(Missile.STOP_EVENT_TYPE, EventPriority.HEADER, function FolderMissile_StructGoToSpot.Event_Stop)",TY,BI,function MHx)
set Fz=inx()
endfunction
function MJx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(WY[(rdx)])
if(Gz[(rkx)]!=w)then
return true
endif
set Gz[(rkx)]=(hz[(rdx)])
return true
endfunction
function Mkx takes integer oqx,integer Ixx returns nothing
if rrx(Ixx,Jz,oqx)then
call Rmx(Ixx,kz)
call Rmx(Ixx,Kz)
call KFx(Ixx)
endif
endfunction
function MKx takes integer oqx returns boolean
if(((lz[((oqx))])>0)==false)then
return false
endif
set lz[Lz[mz]]=lz[oqx]
set Lz[lz[oqx]-1]=Lz[mz]
set lz[oqx]=0
set mz=mz-1
return(mz==F)
endfunction
function Mlx takes integer oqx,integer Ixx returns nothing
if(Ixx!=w)then
call Mkx(oqx,Ixx)
endif
call mZx((oqx),gz)
call mZx((oqx),Hz)
if MKx(oqx)then
call iHx(Mz)
endif
endfunction
function MLx takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=(WY[(rdx)])
call Mlx(oqx,pz[oqx])
return true
endfunction
function Mmx takes integer Ixx,integer MMx returns nothing
local real dix=DPx(Ixx)
local real dax=DQx(Ixx)
local real Mpx=Olx(Ixx,dix,dax)+K_x(Ixx,true)
local integer olx=CXx(Ixx,Jz)
local integer oqx
loop
set oqx=COx(Ixx,Jz,olx)
call Mkx(oqx,Ixx)
set pz[oqx]=w
set Pz[oqx]=dix+qz[oqx]
set Qz[oqx]=dax+sz[oqx]
set Sz[oqx]=Mpx+tz[oqx]
if(Tz[oqx]!=w)then
set WY[(MMx)]=(oqx)
call Xfx(Tz[oqx],MMx)
endif
set olx=olx-1
exitwhen(olx<q)
endloop
endfunction
function MPx takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
call Mmx(Ixx,rdx)
return true
endfunction
function Mqx takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
call Mmx(Ixx,rdx)
return true
endfunction
function MQx takes nothing returns nothing
set gz=XBx("FolderMissile_StructGoToUnit_Init: set FolderMissile_StructGoToUnit.CHECKPOINT_ADD_EVENT = Event.Create(MISSILE.Checkpoints.ADD_EVENT_TYPE, EventPriority.HEADER, function FolderMissile_StructGoToUnit.Event_CheckpointAdd)",uY,BI,function MJx)
set Hz=XBx("FolderMissile_StructGoToUnit_Init: set FolderMissile_StructGoToUnit.STOP_EVENT = Event.Create(Missile.STOP_EVENT_TYPE, EventPriority.HEADER, function FolderMissile_StructGoToUnit.Event_Stop)",TY,BI,function MLx)
set kz=XBx("FolderMissile_StructGoToUnit_Init: set FolderMissile_StructGoToUnit.TARGET_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderMissile_StructGoToUnit.Event_TargetDeath)",VP,BI,function MPx)
set Kz=XBx("FolderMissile_StructGoToUnit_Init: set FolderMissile_StructGoToUnit.TARGET_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderMissile_StructGoToUnit.Event_TargetDestroy)",EP,BI,function Mqx)
set Mz=inx()
endfunction
function Msx takes nothing returns boolean
set tY=(E0x())
set TY=(E0x())
call m8x()
call Mgx()
call Mjx()
call MQx()
set uz=O2x()
return true
endfunction
function MSx takes nothing returns boolean
call Hxx(function Msx,"Missile_Init")
return true
endfunction
function Mtx takes nothing returns boolean
set Uz=Vnx(wz)
return true
endfunction
function MTx takes nothing returns boolean
set Wz=Vnx(yz)
return true
endfunction
function Mux takes nothing returns boolean
set Yz=Vnx(zz)
return true
endfunction
function MUx takes nothing returns boolean
set Zz=Vnx(vZ)
return true
endfunction
function Mwx takes nothing returns boolean
set eZ=Vnx(xZ)
return true
endfunction
function MWx takes nothing returns boolean
set oZ=Vnx(rZ)
return true
endfunction
function Myx takes nothing returns boolean
set iZ=Vnx(aZ)
return true
endfunction
function MYx takes nothing returns boolean
set nZ=Vnx(VZ)
return true
endfunction
function Mzx takes nothing returns boolean
set EZ=Vnx(XZ)
return true
endfunction
function MZx takes integer oqx returns integer
set az[oqx]=true
set AZ[oqx]=false
call rax(gE)
return oqx
endfunction
function M_x takes nothing returns integer
local integer oqx
if(RZ==8190)then
call oYx("Queue_Allocation_allocCustom","call DebugEx(Queue.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",jE+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(iz[(w)]==w)then
set IZ=IZ+1
set oqx=IZ
else
set oqx=iz[(w)]
set iz[(w)]=iz[iz[(w)]]
endif
set iz[oqx]=Z
set rz[oqx]=1
call MZx(oqx)
return oqx
endfunction
function M0x takes nothing returns integer
local integer oqx=M_x()
set zY[oqx]=w
set vz[oqx]=w
return oqx
endfunction
function M1x takes integer ocx returns integer
local integer oqx=ocx
set OZ[oqx]=M0x()
set xp[oqx]=w
return oqx
endfunction
function M2x takes nothing returns nothing
local integer olx=Hl
local integer M3x
loop
exitwhen(olx<0)
set M3x=jl[olx]
call M1x(M3x)
set olx=olx-1
endloop
endfunction
function M4x takes integer ocx returns nothing
if iVx(ocx)then
set cZ=cZ-1
if(cZ==0)then
call SetCameraBounds(xE,aE,oE,nE,rE,VE,iE,EE)
endif
endif
endfunction
function M5x takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((oA[(oqx)]))])]))],((((nA[((oqx))])))),(((oQx))))))
endfunction
function M6x takes integer oqx,integer rRx,integer rIx returns integer
return M5x((oqx),(1+8192*(((rRx)-1)*Iv+((rIx)-1))))
endfunction
function M7x takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((oA[(oqx)]))])]))],((((nA[((oqx))])))),(((oQx)+(okx)))))
endfunction
function M8x takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return M7x((oqx),(1+8192*(((rRx)-1)*Iv+((rIx)-1))),okx)
endfunction
function M9x takes integer oqx returns nothing
local integer olx=Xv
local integer rlx
local integer rdx=rEx((nA[(oqx)]))
local integer rIx
set fZ[(rdx)]=(oqx)
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=M6x(oqx,VI,rIx)
loop
exitwhen(rlx<q)
call rCx(M8x(oqx,VI,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function pvx takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((oA[oqx]))])])],((((nA[((oqx))])))))
endfunction
function pex takes integer oqx returns nothing
set eA[oqx]=false
call pvx((oqx))
call rgx(aI)
endfunction
function pxx takes integer oqx returns nothing
if(vA[oqx]>0)then
return
endif
if(zI[oqx]!=Z)then
call oYx("Event_Allocation_deallocCustom_confirm","call DebugEx(Event.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",nI+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set zI[oqx]=zI[(w)]
set zI[(w)]=oqx
call pex(oqx)
endfunction
function pox takes integer oqx returns nothing
set vA[oqx]=vA[oqx]-1
call pxx(oqx)
endfunction
function prx takes integer oqx returns nothing
call M9x(oqx)
call pox((oqx))
endfunction
function pix takes integer oqx,string oSx returns nothing
set kZ[oqx]=oSx
if(oSx==null)then
call MultiboardSetItemStyle(KZ[oqx],true,false)
else
call MultiboardSetItemIcon(KZ[oqx],oSx)
call MultiboardSetItemStyle(KZ[oqx],true,true)
endif
endfunction
function pax takes integer oqx,real oSx returns nothing
set lZ[oqx]=oSx
call MultiboardSetItemWidth(KZ[oqx],oSx)
endfunction
function pnx takes integer oqx returns nothing
call pix(oqx,null)
call pax(oqx,.0)
endfunction
function pVx takes integer oqx,integer o7x returns nothing
local integer pEx=(jZ[(oqx)])
local integer pXx=(JZ[(oqx)])
local multiboard oMx=op[oqx]
local integer pOx
local integer pRx
set jZ[oqx]=o7x
if(o7x>pEx)then
set pOx=pEx+1
call MultiboardSetColumnCount(oMx,o7x+1)
loop
exitwhen(pOx>o7x)
set pRx=pXx
loop
exitwhen(pRx<0)
call pnx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((op[((oqx))]))))),((((mZ+((pRx))*50+((pOx)))))))))
set pRx=pRx-1
endloop
set pOx=pOx+1
endloop
elseif(o7x<pEx)then
set pOx=pEx
loop
exitwhen(pOx<0)
set pRx=pXx
loop
exitwhen(pRx<0)
call pnx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((op[((oqx))]))))),((((mZ+((pRx))*50+((pOx)))))))))
set pRx=pRx-1
endloop
set pOx=pOx-1
endloop
call MultiboardSetColumnCount(oMx,o7x+1)
endif
set oMx=null
endfunction
function pIx takes integer oqx,integer o7x returns nothing
local integer pEx=(jZ[(oqx)])
local integer pRx=(JZ[(oqx)])
local multiboard oMx=op[oqx]
local integer pOx
local integer i
set JZ[oqx]=o7x
if(o7x>pRx)then
set pRx=pRx+1
set i=pRx
loop
exitwhen(i>o7x)
call MultiboardSetRowCount(oMx,i+1)
set i=i+1
endloop
loop
exitwhen(pRx>o7x)
set pOx=pEx
loop
exitwhen(pOx<0)
call pnx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((op[((oqx))]))))),((((mZ+((pRx))*50+((pOx)))))))))
set pOx=pOx-1
endloop
set pRx=pRx+1
endloop
elseif(o7x<pRx)then
set pRx=pRx-1
loop
exitwhen(pRx<o7x)
call MultiboardSetRowCount(oMx,pRx+1)
set pRx=pRx-1
endloop
endif
set oMx=null
endfunction
function pAx takes integer oqx,integer pRx,integer pOx returns nothing
if(pOx>jZ[oqx])then
call pVx(oqx,pOx)
endif
if(pRx>JZ[oqx])then
call pIx(oqx,pRx)
endif
endfunction
function pNx takes integer oqx,string oSx returns nothing
set MZ[oqx]=oSx
call MultiboardSetItemValue(KZ[oqx],oSx)
endfunction
function pbx takes integer oqx,integer pRx,integer pOx,string oSx returns nothing
call pAx(oqx,pRx,pOx)
call pNx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((op[(oqx)]))))),((((mZ+(pRx)*50+(pOx))))))),oSx)
endfunction
function pBx takes integer oqx returns nothing
local integer olx=tZ[oqx]
local boolean pcx
if(olx==F)then
return
endif
set tZ[oqx]=F
set pcx=(olx==TZ)
set TZ=TZ-1
loop
exitwhen(olx>TZ)
set uZ[olx]=uZ[olx+1]
set tZ[uZ[olx+1]]=olx
set olx=olx+1
endloop
if pcx then
if(TZ>F)then
call StopMusic(false)
call PlayMusic(UZ[uZ[TZ]])
else
call StopMusic(true)
endif
endif
endfunction
function pCx takes integer oqx,integer okx returns nothing
local integer pRx
if(okx==F)then
return
endif
set pRx=HZ[okx]
if iVx(CZ[oqx])then
call pbx(pZ,pRx,PZ,qZ[okx])
call pbx(pZ,pRx,QZ,sZ[okx])
endif
if(pRx==SZ)then
call pBx(wZ)
endif
endfunction
function pdx takes integer oqx returns nothing
local integer bXx=CZ[oqx]
if not DZ[oqx]then
return
endif
set DZ[oqx]=false
call prx(FZ[oqx])
call prx(gZ[oqx])
call prx(GZ[oqx])
call prx(hZ[oqx])
call pCx(oqx,WZ[oqx])
endfunction
function pDx takes integer bXx returns nothing
local integer oqx=bXx
call pdx(oqx)
endfunction
function pfx takes integer oqx,integer okx returns nothing
local integer pRx
if(okx==F)then
return
endif
set pRx=x0[okx]
if iVx(yZ[oqx])then
call pbx(o0,pRx,r0,i0[okx])
call pbx(o0,pRx,n0,V0[okx])
endif
endfunction
function pFx takes integer oqx returns nothing
local integer bXx=yZ[oqx]
if not YZ[oqx]then
return
endif
set YZ[oqx]=false
call prx(zZ[oqx])
call prx(ZZ[oqx])
call prx(v0[oqx])
call prx(e0[oqx])
call pfx(oqx,E0[oqx])
endfunction
function pgx takes integer bXx returns nothing
local integer oqx=bXx
call pFx(oqx)
endfunction
function pGx takes integer oqx,integer Xwx returns nothing
if not((LoadInteger(o[((D[((O0[oqx]))]))],((((Cb[((oqx))])))),(osx((((rA[(Xwx)]))),(((Xwx)))))))!=0)then
call oYx("FolderUser_StructEvent_Remove","call DebugEx(\"subject \"+I2S(User(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((Cb[((oqx))]))+" has not "+(JA[(Xwx)]))
return
endif
call rex(O0[oqx],(Cb[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function phx takes integer ocx returns integer
local integer oqx=ocx
return xp[oqx]
endfunction
function pHx takes integer oqx,integer el returns integer
return m_x(X,el,xz+oqx)
endfunction
function pjx takes integer oqx,integer el returns integer
return m_x(X,el,ZY+oqx)
endfunction
function pJx takes integer oqx,integer el returns boolean
return((zY[(oqx)])==el)or((pHx(oqx,el)!=w)or(pjx(oqx,el)!=w))
endfunction
function pkx takes integer oqx,integer el returns integer
local integer olx
if(pJx(oqx,el)==false)then
return F
endif
set olx=0
loop
set el=pHx(oqx,el)
exitwhen(el==w)
set olx=olx+1
endloop
return olx
endfunction
function pKx takes integer oqx returns integer
local integer olx=F
local integer el=(zY[(oqx)])
loop
exitwhen(el==w)
set el=pjx(oqx,el)
set olx=olx+1
endloop
return olx
endfunction
function plx takes nothing returns boolean
local integer ocx=fFx()
local integer rkx=phx(ocx)
local integer oqx=ocx
if(X0[((ocx))])then
call MultiboardSetTitleText(op[rkx],iqx("<<<","ffffcc00")+" "+(I2S((pkx(OZ[oqx],rkx)+1)))+"/"+(I2S((pKx(OZ[oqx])+1)))+" - "+iqx((A0[(rkx)]),"ff00ff00")+" "+iqx(">>>","ffffcc00"))
return true
endif
return false
endfunction
function pLx takes string oMx,integer nyx returns string
local string o4x=""
loop
exitwhen(nyx<1)
set o4x=o4x+oMx
set nyx=nyx-1
endloop
return o4x
endfunction
function pmx takes string oMx,integer pMx returns string
local integer ppx=((StringLength(((oMx))))-1)
return r2x(oMx,ppx-pMx+1,ppx)
endfunction
function pPx takes real oMx,integer pqx returns string
local integer olx
local integer pQx
local string o4x
if(oMx==.0)then
return("0."+pLx("0",pqx))
endif
set olx=pqx
set pQx=(R2I(((oMx)*1.)))
loop
exitwhen(olx<1)
set oMx=oMx*$A
set olx=olx-1
endloop
set o4x=(I2S(((R2I(((oMx)*1.))))))
set o4x=((I2S((pQx)))+"."+pmx(o4x,pqx))
return o4x
endfunction
function psx takes integer oqx returns nothing
if plx()then
return
endif
call MultiboardSetTitleText(op[(oqx)],iqx("["+pPx((TimerGetElapsed(l)),0)+"]
","ff00bfff")+"\t"+(A0[(oqx)]))
endfunction
function pSx takes integer ocx returns nothing
local integer oqx=ocx
if not X0[oqx]then
return
endif
set X0[oqx]=false
call pGx(ocx,R0)
call pGx(ocx,I0)
call psx(phx(fFx()))
endfunction
function ptx takes integer ocx returns nothing
local integer oqx=ocx
if not BZ[oqx]then
return
endif
set BZ[oqx]=false
call M4x(ocx)
call pDx(ocx)
call pgx(ocx)
call pSx(ocx)
endfunction
function pTx takes integer ocx returns nothing
local real x
local real y
if iVx(ocx)then
set cZ=cZ+1
if(cZ==1)then
set x=(GetCameraTargetPositionX())
set y=(GetCameraTargetPositionY())
call SetCameraBounds(x,y,x,y,x,y,x,y)
endif
endif
endfunction
function pux takes integer oqx returns integer
set D0[oqx]=true
set f0[oqx]=false
call rax(F0)
return oqx
endfunction
function pUx takes nothing returns integer
local integer oqx
if(b0==8190)then
call oYx("FolderUser_FolderKeyEvent_StructDownArrow_Allocation_allocCustom","call DebugEx(FolderUser_FolderKeyEvent_StructDownArrow.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",B0+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(c0[(w)]==w)then
set C0=C0+1
set oqx=C0
else
set oqx=c0[(w)]
set c0[(w)]=c0[c0[(w)]]
endif
set c0[oqx]=Z
set d0[oqx]=1
call pux(oqx)
return oqx
endfunction
function pwx takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(oA[(oqx)],(nA[((oqx))]),oQx,oSx)
endfunction
function pWx takes integer oqx,integer Xwx returns nothing
call pwx((oqx),(rA[(Xwx)]),Xwx)
endfunction
function pyx takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((oA[(oqx)]))])]))],((((nA[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function pYx takes integer oqx,integer Xwx returns nothing
if(O0[oqx]==w)then
call oYx("FolderUser_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oqx)+";"+(JA[(Xwx)]))
set O0[oqx]=X
endif
call rSx(O0[oqx],(Cb[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function pzx takes integer oqx,integer rIx,code iDx,real pZx,real p_x returns integer
local integer rkx=oqx
local integer o4x=XBx("FolderUser_FolderKeyEvent_StructDownArrow_RegisterPress: local Event result = Event.Create(FolderUser_FolderKeyEvent_StructDownArrow.PRESS_EVENT_TYPE, priority, actionFunction)",N0,rIx,iDx)
local integer p0x
if(pZx>.0)then
set oqx=pUx()
set p0x=inx()
set g0[oqx]=pZx
set G0[oqx]=p0x
set h0[oqx]=p_x
set H0[oqx]=o4x
set j0[oqx]=rkx
set ge[(p0x)]=(oqx)
call hMx(rkx,J0,oqx)
call pWx(o4x,k0)
call pyx(o4x,K0,oqx)
endif
call pYx(rkx,o4x)
return o4x
endfunction
function p1x takes integer ocx returns nothing
local integer oqx=ocx
if X0[oqx]then
return
endif
set X0[oqx]=true
call pYx(ocx,R0)
call pYx(ocx,I0)
call psx(phx(fFx()))
endfunction
function p2x takes integer ocx,real oSx returns nothing
if iVx(ocx)then
call CameraSetSmoothingFactor(oSx)
endif
endfunction
function p3x takes integer oqx returns nothing
local string s=pPx(M0[p0],1)
set sZ[P0[m0]]=s
if(L0[(oqx)]==m0)then
set s=iQx((p0>0),iqx("<<< ","ffffcc00"))+iqx(s,"ff00ff00")+iQx((p0<q0),iqx(" >>>","ffffcc00"))
endif
call pbx(pZ,m0,QZ,s)
call p2x((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetLocalPlayer())))))),((((R)))))),M0[p0])
endfunction
function p4x takes integer oqx returns nothing
if iVx(CZ[(oqx)])then
call p3x(oqx)
endif
endfunction
function p5x takes integer oqx returns nothing
local string s=(I2S((s0[S0[oqx]])))
set sZ[P0[Q0]]=s
if(L0[(oqx)]==Q0)then
set s=iQx((S0[oqx]>0),iqx("<<< ","ffffcc00"))+iqx(s,"ff00ff00")+iQx((S0[oqx]<t0),iqx(" >>>","ffffcc00"))
endif
call pbx(pZ,Q0,QZ,s)
set T0=s0[S0[oqx]]
endfunction
function p6x takes integer oqx returns nothing
if iVx(CZ[(oqx)])then
call p5x(oqx)
endif
endfunction
function p7x takes integer oqx returns nothing
local string s=(Ii[(ci)])
set sZ[P0[u0]]=s
if(L0[(oqx)]==u0)then
set s=iQx(((bi[(ci)]-1)>0),iqx("<<< ","ffffcc00"))+iqx(s,"ff00ff00")+iQx(((bi[(ci)]-1)<Ai),iqx(" >>>","ffffcc00"))
endif
call pbx(pZ,u0,QZ,s)
endfunction
function p8x takes integer oqx returns nothing
if iVx(CZ[(oqx)])then
call p7x(oqx)
endif
endfunction
function p9x takes integer oMx returns boolean
return(oMx>0)
endfunction
function Pvx takes integer oqx returns nothing
local string s=w0[W0]
set sZ[P0[U0]]=s
if(L0[(oqx)]==U0)then
set s=iQx((W0>0),iqx("<<< ","ffffcc00"))+iqx(s,"ff00ff00")+iQx((W0<y0),iqx(" >>>","ffffcc00"))
endif
call pbx(pZ,U0,QZ,s)
set Y0=p9x(W0)
endfunction
function Pex takes integer oqx returns nothing
if iVx(CZ[(oqx)])then
call Pvx(oqx)
endif
endfunction
function Pxx takes integer oqx returns nothing
local integer rIx
local integer olx
if(tZ[oqx]!=F)then
return
endif
set rIx=Z0[oqx]
set olx=TZ
set TZ=olx+1
loop
exitwhen(Z0[uZ[olx]]<rIx)
set tZ[uZ[olx]]=olx+1
set uZ[olx+1]=uZ[olx]
set olx=olx-1
endloop
set olx=olx+1
set uZ[olx]=oqx
set tZ[oqx]=olx
if(olx==TZ)then
call PlayMusic(UZ[oqx])
endif
endfunction
function Pox takes integer oqx,boolean Prx returns nothing
local string s=pLx("l",(R2I(((itx(z0*25*1./ 100.,25))*1.))))
local string s2=" "+iqx("("+(I2S((z0)))+"%"+")","ffffcc00")
set sZ[P0[SZ]]=s+s2
call SetMusicVolume((R2I(((((z0*1./ 100.)*1.)*127.)*1.))))
if(L0[(oqx)]==SZ)then
set s=iqx(s,"ff00ff00")
endif
set s=s+s2
if Prx then
call Pxx(wZ)
endif
call pbx(pZ,SZ,QZ,s)
endfunction
function Pix takes integer oqx,boolean Prx returns nothing
if iVx(CZ[(oqx)])then
call Pox(oqx,Prx)
endif
endfunction
function Pax takes real oSx returns nothing
local integer olx=o1
set rd=oSx
loop
exitwhen(olx<0)
call VolumeGroupSetVolume(r1[i1[olx]],oSx)
set olx=olx-1
endloop
endfunction
function Pnx takes integer oqx,boolean PVx returns nothing
local string s=pLx("l",(R2I(((itx(e1*25*1./ 100.,25))*1.))))
local string s2=" "+iqx("("+(I2S((e1)))+"%"+")","ffffcc00")
set sZ[P0[v1]]=s+s2
call Pax(e1*1./ 100.)
if(L0[(oqx)]==v1)then
set s=iqx(s,"ff00ff00")
endif
set s=s+s2
if PVx then
call AHx(n1)
endif
call pbx(pZ,v1,QZ,s)
endfunction
function PEx takes integer oqx,boolean PVx returns nothing
if iVx(CZ[(oqx)])then
call Pnx(oqx,PVx)
endif
endfunction
function PXx takes integer oqx,integer okx returns nothing
local integer POx=WZ[oqx]
local integer PRx
if(okx==POx)then
return
endif
call pCx(oqx,POx)
set WZ[oqx]=okx
if(okx==F)then
set PRx=w
else
set PRx=HZ[okx]
endif
set L0[oqx]=PRx
if(PRx==w)then
call p1x(CZ[oqx])
else
call pSx(CZ[oqx])
endif
if not iVx(CZ[oqx])then
return
endif
if(PRx==m0)then
call p4x(oqx)
endif
if(PRx==Q0)then
call p6x(oqx)
endif
if(PRx==u0)then
call p8x(oqx)
endif
if(PRx==U0)then
call Pex(oqx)
endif
if(PRx==SZ)then
call Pix(oqx,false)
endif
if(PRx==v1)then
call PEx(oqx,false)
endif
endfunction
function PIx takes nothing returns boolean
local integer rdx=(bv)
local integer bXx=(eN[(rdx)])
local integer oqx=bXx
if(WZ[oqx]==l0)then
call PXx(oqx,F)
else
call PXx(oqx,WZ[oqx]+1)
endif
return true
endfunction
function PAx takes integer oqx returns integer
set A1[oqx]=true
set N1[oqx]=false
call rax(b1)
return oqx
endfunction
function PNx takes nothing returns integer
local integer oqx
if(E1==8190)then
call oYx("FolderUser_FolderKeyEvent_StructLeftArrow_Allocation_allocCustom","call DebugEx(FolderUser_FolderKeyEvent_StructLeftArrow.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",X1+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(O1[(w)]==w)then
set R1=R1+1
set oqx=R1
else
set oqx=O1[(w)]
set O1[(w)]=O1[O1[(w)]]
endif
set O1[oqx]=Z
set I1[oqx]=1
call PAx(oqx)
return oqx
endfunction
function Pbx takes integer oqx,integer rIx,code iDx,real pZx,real p_x returns integer
local integer rkx=oqx
local integer o4x=XBx("FolderUser_FolderKeyEvent_StructLeftArrow_RegisterPress: local Event result = Event.Create(FolderUser_FolderKeyEvent_StructLeftArrow.PRESS_EVENT_TYPE, priority, actionFunction)",V1,rIx,iDx)
local integer p0x
if(pZx>.0)then
set oqx=PNx()
set p0x=inx()
set B1[oqx]=pZx
set c1[oqx]=p0x
set C1[oqx]=p_x
set d1[oqx]=o4x
set D1[oqx]=rkx
set ge[(p0x)]=(oqx)
call hMx(rkx,f1,oqx)
call pWx(o4x,F1)
call pyx(o4x,g1,oqx)
endif
call pYx(rkx,o4x)
return o4x
endfunction
function PBx takes integer oqx,real p_x returns nothing
if(S0[oqx]>0)then
set S0[oqx]=S0[oqx]-1
else
if(p_x==1.)then
call iLx(CZ[(oqx)],iqx("Penguin perspective is not supported","ffffcc00"),10.)
endif
endif
call p6x(oqx)
endfunction
function Pcx takes integer oqx returns nothing
if(p0>0)then
set p0=p0-1
endif
call p4x(oqx)
endfunction
function PCx takes integer oqx returns nothing
set ci=(Ni[(R2I(((iOx((0),((bi[(ci)]-1)-1)))*1.)))])
call p8x(oqx)
endfunction
function Pdx takes integer oqx returns nothing
set W0=(R2I(((iOx((0),(W0-1)))*1.)))
call Pex(oqx)
endfunction
function PDx takes integer oqx,real p_x returns nothing
set z0=(R2I(((iOx((0),((R2I(((z0-1.*p_x)*1.))))))*1.)))
call Pix(oqx,true)
endfunction
function Pfx takes integer oqx,real p_x returns nothing
set e1=(R2I(((iOx((0),((R2I(((e1-1.*p_x)*1.))))))*1.)))
call PEx(oqx,true)
endfunction
function PFx takes nothing returns boolean
local integer rdx=(bv)
local real p_x=(G1[(rdx)])
local integer bXx=(eN[(rdx)])
local integer oqx=bXx
local integer PRx=L0[oqx]
if(PRx==Q0)then
call PBx(oqx,p_x)
endif
if not iVx(bXx)then
return true
endif
if(PRx==m0)then
call Pcx(oqx)
endif
if(PRx==u0)then
call PCx(oqx)
endif
if(PRx==U0)then
call Pdx(oqx)
endif
if(PRx==SZ)then
call PDx(oqx,p_x)
endif
if(PRx==v1)then
call Pfx(oqx,p_x)
endif
return true
endfunction
function Pgx takes integer oqx returns integer
set l1[oqx]=true
set L1[oqx]=false
call rax(m1)
return oqx
endfunction
function PGx takes nothing returns integer
local integer oqx
if(H1==8190)then
call oYx("FolderUser_FolderKeyEvent_StructRightArrow_Allocation_allocCustom","call DebugEx(FolderUser_FolderKeyEvent_StructRightArrow.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",j1+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(J1[(w)]==w)then
set k1=k1+1
set oqx=k1
else
set oqx=J1[(w)]
set J1[(w)]=J1[J1[(w)]]
endif
set J1[oqx]=Z
set K1[oqx]=1
call Pgx(oqx)
return oqx
endfunction
function Phx takes integer oqx,integer rIx,code iDx,real pZx,real p_x returns integer
local integer rkx=oqx
local integer o4x=XBx("FolderUser_FolderKeyEvent_StructRightArrow_RegisterPress: local Event result = Event.Create(FolderUser_FolderKeyEvent_StructRightArrow.PRESS_EVENT_TYPE, priority, actionFunction)",h1,rIx,iDx)
local integer p0x
if(pZx>.0)then
set oqx=PGx()
set p0x=inx()
set M1[oqx]=pZx
set p1[oqx]=p0x
set P1[oqx]=p_x
set q1[oqx]=o4x
set Q1[oqx]=rkx
set ge[(p0x)]=(oqx)
call hMx(rkx,s1,oqx)
call pWx(o4x,S1)
call pyx(o4x,t1,oqx)
endif
call pYx(rkx,o4x)
return o4x
endfunction
function PHx takes integer oqx returns nothing
if(S0[oqx]<t0)then
set S0[oqx]=S0[oqx]+1
endif
call p6x(oqx)
endfunction
function Pjx takes integer oqx returns nothing
if(p0<q0)then
set p0=p0+1
endif
call p4x(oqx)
endfunction
function PJx takes integer oqx returns nothing
set ci=(Ni[(R2I(((itx(((bi[(ci)]-1)+1),(Ai)))*1.)))])
call p8x(oqx)
endfunction
function Pkx takes integer oqx returns nothing
set W0=(R2I(((itx((W0+1),(1)))*1.)))
call Pex(oqx)
endfunction
function PKx takes integer oqx,real p_x returns nothing
set z0=(R2I(((itx(((R2I(((z0+1.*p_x)*1.)))),('d')))*1.)))
call Pix(oqx,true)
endfunction
function Plx takes integer oqx,real p_x returns nothing
set e1=(R2I(((itx(((R2I(((e1+1.*p_x)*1.)))),('d')))*1.)))
call PEx(oqx,true)
endfunction
function PLx takes nothing returns boolean
local integer rdx=(bv)
local real p_x=(G1[(rdx)])
local integer bXx=(eN[(rdx)])
local integer oqx=bXx
local integer PRx=L0[oqx]
if(PRx==Q0)then
call PHx(oqx)
endif
if not iVx(bXx)then
return true
endif
if(PRx==m0)then
call Pjx(oqx)
endif
if(PRx==u0)then
call PJx(oqx)
endif
if(PRx==U0)then
call Pkx(oqx)
endif
if(PRx==SZ)then
call PKx(oqx,p_x)
endif
if(PRx==v1)then
call Plx(oqx,p_x)
endif
return true
endfunction
function Pmx takes integer oqx returns integer
set z1[oqx]=true
set Z1[oqx]=false
call rax(v2)
return oqx
endfunction
function PMx takes nothing returns integer
local integer oqx
if(u1==8190)then
call oYx("FolderUser_FolderKeyEvent_StructUpArrow_Allocation_allocCustom","call DebugEx(FolderUser_FolderKeyEvent_StructUpArrow.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",U1+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(w1[(w)]==w)then
set W1=W1+1
set oqx=W1
else
set oqx=w1[(w)]
set w1[(w)]=w1[w1[(w)]]
endif
set w1[oqx]=Z
set Y1[oqx]=1
call Pmx(oqx)
return oqx
endfunction
function Ppx takes integer oqx,integer rIx,code iDx,real pZx,real p_x returns integer
local integer rkx=oqx
local integer o4x=XBx("FolderUser_FolderKeyEvent_StructUpArrow_RegisterPress: local Event result = Event.Create(FolderUser_FolderKeyEvent_StructUpArrow.PRESS_EVENT_TYPE, priority, actionFunction)",T1,rIx,iDx)
local integer p0x
if(pZx>.0)then
set oqx=PMx()
set p0x=inx()
set e2[oqx]=pZx
set o2[oqx]=p0x
set r2[oqx]=p_x
set i2[oqx]=o4x
set n2[oqx]=rkx
set ge[(p0x)]=(oqx)
call hMx(rkx,V2,oqx)
call pWx(o4x,E2)
call pyx(o4x,X2,oqx)
endif
call pYx(rkx,o4x)
return o4x
endfunction
function PPx takes nothing returns boolean
local integer rdx=(bv)
local integer bXx=(eN[(rdx)])
local integer oqx=bXx
if(WZ[oqx]==F)then
call PXx(oqx,l0)
else
call PXx(oqx,WZ[oqx]-1)
endif
return true
endfunction
function Pqx takes integer oqx returns nothing
local integer bXx=CZ[oqx]
if DZ[oqx]then
return
endif
set DZ[oqx]=true
set FZ[oqx]=pzx(bXx,LI,function PIx,.5,1.)
set gZ[oqx]=Pbx(bXx,LI,function PFx,.1,4.)
set GZ[oqx]=Phx(bXx,LI,function PLx,.1,4.)
set hZ[oqx]=Ppx(bXx,LI,function PPx,.5,1.)
set L0[oqx]=F
set WZ[oqx]=F
endfunction
function PQx takes integer bXx returns nothing
local integer oqx=bXx
if(phx(bXx)==pZ)then
call Pqx(oqx)
endif
endfunction
function Psx takes integer oqx returns nothing
local integer PSx=A2[I2]
local integer okx
local string s
call pbx(o0,I2,r0,i0[PSx])
set okx=N2[oqx]
set s=(I2S((okx+1)))+"/"+(I2S((b2+1)))
set V0[PSx]=s
if(R2[oqx]==I2)then
set s=iQx((okx>0),iqx("<<< ","ffffcc00"))+iqx(s,"ff00ff00")+iQx((okx<b2),iqx(" >>>","ffffcc00"))
endif
call pbx(o0,I2,n0,s)
endfunction
function Ptx takes integer oqx,integer okx returns nothing
local integer POx=E0[oqx]
local integer PRx
if(okx==POx)then
return
endif
call pfx(oqx,POx)
set E0[oqx]=okx
if(okx==F)then
set PRx=F
else
set PRx=x0[okx]
endif
set R2[oqx]=PRx
if(PRx==F)then
call p1x(yZ[oqx])
else
call pSx(yZ[oqx])
endif
if not iVx(yZ[oqx])then
return
endif
if(PRx==I2)then
call Psx(oqx)
endif
endfunction
function PTx takes nothing returns boolean
local integer rdx=(bv)
local integer bXx=(eN[(rdx)])
local integer oqx=bXx
if(E0[oqx]==O2)then
call Ptx(oqx,F)
else
call Ptx(oqx,E0[oqx]+1)
endif
return true
endfunction
function Pux takes integer oqx returns nothing
local integer pEx=(jZ[(oqx)])
local integer pXx=(JZ[(oqx)])
local integer PUx=pEx
local integer pRx
loop
exitwhen(PUx<0)
set pRx=pXx
loop
exitwhen(pRx<0)
call pNx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((op[(oqx)]))))),((((mZ+(pRx)*50+(PUx))))))),"")
set pRx=pRx-1
endloop
set PUx=PUx-1
endloop
endfunction
function Pwx takes integer oqx,integer pRx,integer pOx,real oSx returns nothing
call pAx(oqx,pRx,pOx)
call pax((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((op[(oqx)]))))),((((mZ+(pRx)*50+(pOx))))))),oSx)
endfunction
function PWx takes integer oqx,integer pOx,real oSx returns nothing
local integer pRx=(JZ[((oqx))])
loop
exitwhen(pRx<0)
call Pwx((oqx),pRx,pOx,oSx)
set pRx=pRx-1
endloop
endfunction
function Pyx takes integer n_x returns integer
set AE=n_x
if not TriggerEvaluate(IE)then
call oYx("Basic_GetAllocModuleFromQueue","call DebugEx(\"GetAllocModuleFromQueue: \" + \"thread broken\")","GetAllocModuleFromQueue: thread broken")
endif
return BE
endfunction
function PYx takes integer oqx,integer okx returns nothing
local integer i
local integer a5x
local integer c
local integer Pzx
call Pux(o0)
set N2[oqx]=okx
call Psx(oqx)
set i=0+okx*30
set a5x=0+(okx+1)*30-1
set c=0
call pIx(o0,B2+(R2I(((itx((30),(hE-i+1)))*1.)))-1)
call PWx(o0,r0,.2)
call PWx(o0,n0,.05)
loop
exitwhen(i>a5x)
exitwhen(i>hE)
set Pzx=Pyx(i)
call pbx(o0,B2+c,r0,(HE[(Pzx)]))
call pbx(o0,B2+c,n0,(I2S(((cE[(Pzx)])))))
set i=i+1
set c=c+1
endloop
endfunction
function PZx takes nothing returns boolean
local integer rdx=(bv)
local real p_x=(G1[(rdx)])
local integer bXx=(eN[(rdx)])
local integer oqx=bXx
local integer PRx=R2[oqx]
if(PRx==I2)then
if(N2[oqx]>0)then
call PYx(oqx,N2[oqx]-1)
endif
endif
if not iVx(bXx)then
return true
endif
return true
endfunction
function P_x takes nothing returns boolean
local integer rdx=(bv)
local real p_x=(G1[(rdx)])
local integer bXx=(eN[(rdx)])
local integer oqx=bXx
local integer PRx=R2[oqx]
if(PRx==I2)then
if(N2[oqx]<b2)then
call PYx(oqx,N2[oqx]+1)
endif
endif
if not iVx(bXx)then
return true
endif
return true
endfunction
function P0x takes nothing returns boolean
local integer rdx=(bv)
local integer bXx=(eN[(rdx)])
local integer oqx=bXx
if(E0[oqx]==F)then
call Ptx(oqx,O2)
else
call Ptx(oqx,E0[oqx]-1)
endif
return true
endfunction
function P1x takes integer oqx returns nothing
local integer bXx=yZ[oqx]
if YZ[oqx]then
return
endif
set YZ[oqx]=true
set zZ[oqx]=pzx(bXx,LI,function PTx,.5,1.)
set ZZ[oqx]=Pbx(bXx,LI,function PZx,.125,1.)
set v0[oqx]=Phx(bXx,LI,function P_x,.125,1.)
set e0[oqx]=Ppx(bXx,LI,function P0x,.5,1.)
set R2[oqx]=F
set E0[oqx]=F
endfunction
function P2x takes integer bXx returns nothing
local integer oqx=bXx
if(phx(bXx)==o0)then
call P1x(oqx)
endif
endfunction
function P3x takes integer ocx returns nothing
local integer oqx=ocx
if BZ[oqx]then
return
endif
set BZ[oqx]=true
call pTx(ocx)
call PQx(ocx)
call P2x(ocx)
call p1x(ocx)
endfunction
function P4x takes nothing returns boolean
local integer rdx=(bv)
local integer ocx=(eN[(rdx)])
local integer oqx=ocx
if BZ[oqx]then
call ptx(ocx)
return true
endif
call P3x(ocx)
return true
endfunction
function P5x takes integer ocx returns integer
local integer oqx=ocx
set BZ[oqx]=false
return oqx
endfunction
function P6x takes nothing returns nothing
local integer olx=Hl
local integer M3x
loop
exitwhen(olx<0)
set M3x=jl[olx]
call P5x(M3x)
set olx=olx-1
endloop
endfunction
function P7x takes integer ocx returns integer
local integer oqx=ocx
return OZ[oqx]
endfunction
function P8x takes integer oqx,integer ocx returns nothing
local integer rkx=oqx
set oqx=ocx
set xp[oqx]=rkx
if not iVx(ocx)then
return
endif
call MultiboardDisplay(op[rkx],true)
call MultiboardMinimize(op[rkx],false)
call psx(rkx)
endfunction
function P9x takes integer qvx,integer bXx returns nothing
local integer oqx=bXx
if(qvx==pZ)then
call Pqx(oqx)
else
call pdx(oqx)
endif
endfunction
function qex takes integer qvx,integer bXx returns nothing
local integer oqx=bXx
if(qvx==o0)then
call P1x(oqx)
else
call pFx(oqx)
endif
endfunction
function qxx takes integer rkx,integer ocx returns nothing
call P8x(rkx,ocx)
call P9x(rkx,ocx)
call qex(rkx,ocx)
endfunction
function qox takes nothing returns boolean
local integer rdx=(bv)
local integer ocx=(eN[(rdx)])
local integer qrx=P7x(ocx)
local integer rkx=pHx(qrx,phx(ocx))
if(rkx==w)then
set rkx=(vz[(qrx)])
endif
call qxx(rkx,ocx)
return true
endfunction
function qix takes nothing returns boolean
local integer rdx=(bv)
local integer ocx=(eN[(rdx)])
local integer qrx=P7x(ocx)
local integer rkx=pjx(qrx,phx(ocx))
if(rkx==w)then
set rkx=(zY[(qrx)])
endif
call qxx(rkx,ocx)
return true
endfunction
function qax takes integer ocx returns integer
local integer oqx=ocx
set X0[oqx]=false
return oqx
endfunction
function qnx takes nothing returns nothing
local integer olx=Hl
local integer M3x
loop
exitwhen(olx<0)
set M3x=jl[olx]
call qax(M3x)
set olx=olx-1
endloop
endfunction
function qVx takes nothing returns nothing
set R0=XBx("FolderMultiboard_FolderShown_FolderControl_StructPageSwitch_Init: set FolderMultiboard_FolderShown_FolderControl_StructPageSwitch.LEFT_EVENT = Event.Create(USER.KeyEvent.LeftArrow.PRESS_EVENT_TYPE, EventPriority.HEADER, function FolderMultiboard_FolderShown_FolderControl_StructPageSwitch.Event_Left)",V1,BI,function qox)
set I0=XBx("FolderMultiboard_FolderShown_FolderControl_StructPageSwitch_Init: set FolderMultiboard_FolderShown_FolderControl_StructPageSwitch.RIGHT_EVENT = Event.Create(USER.KeyEvent.RightArrow.PRESS_EVENT_TYPE, EventPriority.HEADER, function FolderMultiboard_FolderShown_FolderControl_StructPageSwitch.Event_Right)",h1,BI,function qix)
call qnx()
endfunction
function qEx takes nothing returns nothing
call DNx(XBx("FolderMultiboard_FolderShown_StructControl_Init: call Event.Create(USER.KeyEvent.ESC_EVENT_TYPE, EventPriority.HEADER, function FolderMultiboard_FolderShown_StructControl.Event_Esc).AddToStatics()",bZ,BI,function P4x))
call P6x()
call qVx()
endfunction
function qXx takes nothing returns nothing
call M2x()
call qEx()
endfunction
function qOx takes nothing returns nothing
local integer oqx=phx(fFx())
if(oqx==w)then
return
endif
call psx(oqx)
endfunction
function qRx takes nothing returns boolean
local integer rdx=(bv)
call icx(c2,C2,true,function qOx)
return true
endfunction
function qIx takes nothing returns nothing
set c2=inx()
call DNx(XBx("FolderMultiboard_StructTitle_Init: call Event.Create(EventType.START, EventPriority.HEADER, function FolderMultiboard_StructTitle.Event_Start).AddToStatics()",XE,BI,function qRx))
endfunction
function qAx takes nothing returns boolean
call qXx()
call qIx()
return true
endfunction
function qNx takes nothing returns boolean
call Gcx(function qAx,"Multiboard_Init")
return true
endfunction
function qbx takes nothing returns boolean
set D2=Vnx(f2)
return true
endfunction
function qBx takes nothing returns boolean
set F2=Vnx(g2)
return true
endfunction
function qcx takes nothing returns boolean
set G2=Vnx(h2)
return true
endfunction
function qCx takes nothing returns boolean
set H2=Vnx(j2)
return true
endfunction
function qdx takes nothing returns boolean
set J2=Vnx(k2)
return true
endfunction
function qDx takes nothing returns boolean
set K2=Vnx(l2)
return true
endfunction
function qfx takes nothing returns boolean
set L2=Vnx(m2)
return true
endfunction
function qFx takes integer oqx returns integer
set S2[oqx]=true
set t2[oqx]=false
set T2[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set Bj[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(L2)
return oqx
endfunction
function qgx takes nothing returns integer
local integer oqx
if(p2==8190)then
call oYx("Order_Allocation_allocCustom","call DebugEx(Order.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",m2+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(P2[(w)]==w)then
set q2=q2+1
set oqx=q2
else
set oqx=P2[(w)]
set P2[(w)]=P2[P2[(w)]]
endif
set P2[oqx]=Z
set Q2[oqx]=1
call qFx(oqx)
return oqx
endfunction
function qGx takes integer oqx returns nothing
set Nj[(oqx)]=(U2+oqx)
endfunction
function qhx takes string rqx,integer oMx returns integer
local integer oqx=qgx()
set Pb[oqx]=oMx
call SaveInteger(o[((V[(E[((X))])]))],(((oMx))),(((Oj))),(((oqx))))
call qGx(oqx)
set w2[(oqx)]=(rqx)
return oqx
endfunction
function qHx takes nothing returns boolean
set M2=qhx("acid bomb",$D02B6)
set W2=qhx("ancestral spirit",$D020A)
set Y2=qhx("animate dead",$D00F9)
set Xw=qhx("attack",$D000F)
set Z2=qhx("avatar",$D0076)
set v3=qhx("banish",$D0206)
set e3=qhx("berserk",$D0084)
set o3=qhx("blizzard",$D0079)
set VJ=qhx("blood lust",$D0085)
set r3=qhx("breath of fire",$D0264)
set i3=qhx("breath of frost",$D0250)
set n3=qhx("cannibalize",$D00DC)
set V3=qhx("carrion swarm",$D00FA)
set E3=qhx("chain lightning",$D0097)
set X3=qhx("channel",$D0278)
set O3=qhx("cluster rockets",$D02AC)
set R3=qhx("cripple",$D00DD)
set I3=qhx("cyclone",$D00B0)
set A3=qhx("dark conversion",$D0104)
set N3=qhx("dark portal",$D0105)
set b3=qhx("death and decay",$D00FD)
set B3=qhx("death coil",$D00FE)
set c3=qhx("doom",$D0267)
set C3=qhx("drunken haze",$D0269)
set d3=qhx("eat tree",$D00B2)
set D3=qhx("ensnare",$D008A)
set f3=qhx("entangling roots",$D00CB)
set F3=qhx("evil eye",$D0089)
set g3=qhx("firebolt",$D0107)
set G3=qhx("frenzy",$D0251)
set h3=qhx("frenzyOff",$D0253)
set H3=qhx("frenzyOn",$D0252)
set j3=qhx("heal",$D005F)
set J3=qhx("healing wave",$D0215)
set k3=qhx("hex",$D0216)
set K3=qhx("hold position",$D0019)
set l3=qhx("howl of terror",$D026C)
set L3=qhx("impale",$D024B)
set m3=qhx("inferno",$D0108)
set M3=qhx("inner fire",$D0062)
set p3=qhx("lightning shield",$D008E)
set P3=qhx("load",$D004E)
set q3=qhx("mana burn",$D00D3)
set Q3=qhx("mana shield on",$D026D)
set s3=qhx("mirror image",$D009B)
set S3=qhx("monsoon",$CFE87)
set ch=qhx("move",$D0012)
set t3=qhx("move item to slot 0",$D0022)
set T3=qhx("move item to slot 1",$D0023)
set u3=qhx("move item to slot 2",$D0024)
set U3=qhx("move item to slot 3",$D0025)
set w3=qhx("move item to slot 4",$D0026)
set W3=qhx("move item to slot 5",$D0027)
set Y3=qhx("phase shift",$D0016)
set z3=qhx("phase shift",$D0222)
set Z3=qhx("purge",$D008F)
set v4=qhx("raise dead",$D00E5)
set e4=qhx("resurrection",$D007E)
set o4=qhx("roar",$D00C4)
set r4=qhx("self destruct",$D0048)
set i4=qhx("sanctuary",$D0259)
set n4=qhx("shock wave",$D009D)
set V4=qhx("sleep",$D0103)
set E4=qhx("smart",$D0003)
set X4=qhx("soulburn",$D02BC)
set O4=qhx("spirit wolf",$D009E)
set R4=qhx("star fall",$D00D7)
set I4=qhx("stasis trap",$D0092)
set Ch=qhx("stop",$D0004)
set A4=qhx("stunned",$D0005)
set N4=qhx("summon factory",$D02B2)
set b4=qhx("summon grizzly",$D0272)
set B4=qhx("summon war eagle",$D0274)
set c4=qhx("taunt",$D0228)
set C4=qhx("thunder bolt",$D007F)
set d4=qhx("tunder clap",$D0080)
set dh=qhx("use item in slot 0",$D0028)
set D4=qhx("use item in slot 1",$D0029)
set f4=qhx("use item in slot 2",$D002A)
set F4=qhx("use item in slot 3",$D002B)
set g4=qhx("use item in slot 4",$D002C)
set Dh=qhx("use item in slot 5",$D002D)
set G4=qhx("voodoo",$D0217)
set h4=qhx("ward",$D0218)
set H4=qhx("wind walk",$D00A1)
return true
endfunction
function qjx takes nothing returns boolean
call FWx(function qHx,"Order_Init")
return true
endfunction
function qJx takes nothing returns boolean
set j4=Vnx(J4)
return true
endfunction
function qkx takes nothing returns boolean
set ij=Vnx(oj)
return true
endfunction
function qKx takes nothing returns boolean
set k4=Vnx(K4)
return true
endfunction
function qlx takes nothing returns boolean
set l4=Vnx(L4)
return true
endfunction
function qLx takes nothing returns nothing
endfunction
function qmx takes nothing returns nothing
endfunction
function qMx takes nothing returns nothing
endfunction
function qpx takes nothing returns nothing
endfunction
function qPx takes nothing returns nothing
endfunction
function qqx takes nothing returns boolean
call qLx()
call qmx()
set m4=InitHashtable()
call qMx()
call qpx()
call qPx()
return true
endfunction
function qQx takes nothing returns boolean
call Vdx(function qqx,"Primitive_Init")
return true
endfunction
function qsx takes nothing returns boolean
set M4=Vnx(p4)
return true
endfunction
function qSx takes nothing returns boolean
set P4=Vnx(q4)
return true
endfunction
function qtx takes nothing returns boolean
set Q4=Vnx(s4)
return true
endfunction
function qTx takes nothing returns boolean
set S4=Vnx(t4)
return true
endfunction
function qux takes nothing returns boolean
set Sm=Vnx(mm)
return true
endfunction
function qUx takes nothing returns boolean
set T4=Vnx(u4)
return true
endfunction
function qwx takes nothing returns boolean
set U4=Vnx(w4)
return true
endfunction
function qWx takes nothing returns boolean
set W4=Vnx(Y4)
return true
endfunction
function qyx takes nothing returns boolean
set z4=Vnx(Z4)
return true
endfunction
function qYx takes nothing returns boolean
set v5=Vnx(e5)
return true
endfunction
function qzx takes nothing returns boolean
set x5=Vnx(o5)
return true
endfunction
function qZx takes nothing returns boolean
set r5=Vnx(i5)
return true
endfunction
function q_x takes rect oMx returns integer
local integer oqx=GSx(GetRectMinX(oMx),GetRectMinY(oMx),GetRectMaxX(oMx),GetRectMaxY(oMx))
set bm[oqx]=oMx
call Gwx(oqx)
return oqx
endfunction
function q0x takes nothing returns boolean
set Bm=q_x(GetWorldBounds())
return true
endfunction
function q1x takes nothing returns boolean
call FWx(function q0x,"Region_Init")
return true
endfunction
function q2x takes nothing returns boolean
set a5=Vnx(n5)
return true
endfunction
function q3x takes nothing returns boolean
set V5=Vnx(E5)
return true
endfunction
function q4x takes nothing returns boolean
set X5=Vnx(O5)
return true
endfunction
function q5x takes nothing returns boolean
set R5=Vnx(I5)
return true
endfunction
function q6x takes nothing returns boolean
set lB=Vnx(kB)
return true
endfunction
function q7x takes integer oqx returns integer
set C5[oqx]=true
set d5[oqx]=false
call rax(X5)
return oqx
endfunction
function q8x takes nothing returns integer
local integer oqx
if(N5==8190)then
call oYx("SoundEax_Allocation_allocCustom","call DebugEx(SoundEax.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",O5+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(b5[(w)]==w)then
set B5=B5+1
set oqx=B5
else
set oqx=b5[(w)]
set b5[(w)]=b5[b5[(w)]]
endif
set b5[oqx]=Z
set c5[oqx]=1
call q7x(oqx)
return oqx
endfunction
function q9x takes string oMx returns integer
local integer oqx=q8x()
set xd[(oqx)]=(oMx)
return oqx
endfunction
function Qvx takes nothing returns nothing
set A5=q9x("CombatSoundsEAX")
set D5=q9x("DefaultEAXON")
set f5=q9x("DoodadsEAX")
set F5=q9x("HeroAcksEAX")
set g5=q9x("KotoDrumsEAX")
set G5=q9x("MissilesEAX")
set h5=q9x("SpellsEAX")
endfunction
function Qex takes integer oqx,real oSx returns nothing
set od[oqx]=oSx
call VolumeGroupSetVolume(r1[oqx],oSx)
endfunction
function Qxx takes integer oqx returns boolean
set o1=o1+1
set i1[o1]=oqx
set H5[oqx]=o1+1
return(o1==0)
endfunction
function Qox takes integer oqx,volumegroup Qrx returns integer
set r1[oqx]=Qrx
call Qex(oqx,1.)
call Qxx(oqx)
return oqx
endfunction
function Qix takes nothing returns nothing
call Qox(j5,SOUND_VOLUMEGROUP_AMBIENTSOUNDS)
call Qox(J5,null)
call Qox(k5,null)
call Qox(5,SOUND_VOLUMEGROUP_COMBAT)
call Qox(K5,null)
call Qox(6,SOUND_VOLUMEGROUP_UI)
call Qox(l5,SOUND_VOLUMEGROUP_FIRE)
call Qox(0,null)
call Qox(9,SOUND_VOLUMEGROUP_UNITMOVEMENT)
call Qox(8,SOUND_VOLUMEGROUP_UI)
call Qox(2,SOUND_VOLUMEGROUP_UNITSOUNDS)
call Qox(3,SOUND_VOLUMEGROUP_UNITSOUNDS)
call Qox(4,SOUND_VOLUMEGROUP_UNITSOUNDS)
call Qox(1,SOUND_VOLUMEGROUP_UNITSOUNDS)
endfunction
function Qax takes string Qnx,boolean QVx,boolean QEx,boolean QXx,real QOx,real R0x,integer AGx returns integer
local integer oqx=Afx()
set GB[oqx]=w
set IC[(oqx)]=(Qnx)
call AFx(oqx,0)
set BC[(oqx)]=(AGx)
set GC[(oqx)]=((1.)*1.)
set HC[(oqx)]=((QOx)*1.)
set JC[(oqx)]=((R0x)*1.)
set LB[(oqx)]=(QVx)
set lC[(oqx)]=(QXx)
set mC[(oqx)]=(QEx)
call Agx(oqx)
return oqx
endfunction
function QRx takes nothing returns nothing
endfunction
function QIx takes nothing returns boolean
call Qvx()
call Qix()
set L5=Qax("Sound\\Interface\\Error.wav",false,false,false,$A,$A,w)
call AFx(L5,8)
call QRx()
return true
endfunction
function QAx takes nothing returns boolean
call FWx(function QIx,"Sound_Init")
return true
endfunction
function QNx takes nothing returns boolean
set QB=Vnx(PB)
return true
endfunction
function Qbx takes nothing returns boolean
set m5[0]='AHS0'
call LZx('AHS0',true)
return true
endfunction
function QBx takes nothing returns boolean
set m5[4]='AHS4'
call LZx('AHS4',true)
return true
endfunction
function Qcx takes nothing returns boolean
set m5[1]='AHS1'
call LZx('AHS1',true)
return true
endfunction
function QCx takes nothing returns boolean
set m5[3]='AHS3'
call LZx('AHS3',true)
return true
endfunction
function Qdx takes nothing returns boolean
set m5[2]='AHS2'
call LZx('AHS2',true)
return true
endfunction
function QDx takes nothing returns boolean
call Lwx(function Qbx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Spell.page\\HeroSpell.struct\\obj_slots[0]_wc3spell.j")
call Lwx(function QBx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Spell.page\\HeroSpell.struct\\obj_slots[4]_wc3spell.j")
call Lwx(function Qcx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Spell.page\\HeroSpell.struct\\obj_slots[1]_wc3spell.j")
call Lwx(function QCx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Spell.page\\HeroSpell.struct\\obj_slots[3]_wc3spell.j")
call Lwx(function Qdx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Spell.page\\HeroSpell.struct\\obj_slots[2]_wc3spell.j")
return true
endfunction
function Qfx takes nothing returns boolean
set M5=Vnx(p5)
return true
endfunction
function QFx takes nothing returns boolean
set P5=Vnx(q5)
return true
endfunction
function Qgx takes nothing returns boolean
set Q5=Vnx(s5)
return true
endfunction
function QGx takes nothing returns boolean
set S5=Vnx(t5)
return true
endfunction
function Qhx takes nothing returns boolean
set T5=Vnx(u5)
return true
endfunction
function QHx takes nothing returns boolean
set U5=Vnx(w5)
return true
endfunction
function Qjx takes nothing returns boolean
set W5=Vnx(y5)
return true
endfunction
function QJx takes nothing returns boolean
set Y5=Vnx(z5)
return true
endfunction
function Qkx takes nothing returns boolean
set Z5=Vnx(v6)
return true
endfunction
function QKx takes nothing returns boolean
set e6=Vnx(x6)
return true
endfunction
function Qlx takes nothing returns boolean
return true
endfunction
function QLx takes nothing returns boolean
set o6=Vnx(r6)
return true
endfunction
function Qmx takes integer oqx returns integer
set X6[oqx]=true
set O6[oqx]=false
call rax(P5)
return oqx
endfunction
function QMx takes nothing returns integer
local integer oqx
if(a6==8190)then
call oYx("SpellClass_Allocation_allocCustom","call DebugEx(SpellClass.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",q5+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(n6[(w)]==w)then
set V6=V6+1
set oqx=V6
else
set oqx=n6[(w)]
set n6[(w)]=n6[n6[(w)]]
endif
set n6[oqx]=Z
set E6[oqx]=1
call Qmx(oqx)
return oqx
endfunction
function Qpx takes boolean QPx,integer Qqx,integer QQx returns integer
local integer oqx=QMx()
if(QQx!=0)then
set QQx=QQx-'F000'
endif
set R6[(oqx)]=(Qqx)
set I6[(oqx)]=(QQx)
set A6[(oqx)]=(QPx)
return oqx
endfunction
function Qsx takes nothing returns nothing
set i6=Qpx(true,0,'F000')
set N6=Qpx(true,1,'G000')
set b6=Qpx(false,0,0)
set B6=Qpx(true,4,'K000')
set c6=Qpx(true,2,'H000')
set C6=Qpx(true,3,'J000')
set d6=Qpx(false,0,0)
set D6=Qpx(false,0,0)
endfunction
function QSx takes integer oqx,integer rsx returns integer
return GetUnitAbilityLevel(C[(oqx)],rsx)
endfunction
function Qtx takes integer rJx returns integer
return((g6[((rJx))])+(R6[((G6[(rJx)]))]))
endfunction
function QTx takes integer rJx,integer rwx returns integer
return((I6[((G6[(rJx)]))])+(h6[((rJx))])+rwx)
endfunction
function Qux takes integer rwx,integer rJx,integer Oqx returns nothing
local integer QUx=QSx(Oqx,Qtx(rJx))-1
local integer Qwx=QTx(rJx,QUx)
call CEx(Oqx,Qtx(rJx))
call ryx(Oqx,Qwx,0)
call ryx(Oqx,H6+(R6[((G6[(rJx)]))]),rwx)
if(rwx<(j6[(rJx)]))then
call ryx(Oqx,Qtx(rJx),rwx+1)
else
call CEx(Oqx,Qtx(rJx))
endif
endfunction
function QWx takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Mv[(rdx)])
local integer rJx=(nv[(rdx)])
local integer Oqx=(Vv[(rdx)])
call Qux(rwx,rJx,Oqx)
return true
endfunction
function Qyx takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Mv[(rdx)])
local integer rJx=(nv[(rdx)])
local integer Oqx=(Vv[(rdx)])
call Qux(rwx,rJx,Oqx)
return true
endfunction
function QYx takes nothing returns boolean
local integer rdx=(bv)
local integer rJx=(nv[(rdx)])
local integer Oqx=(Vv[(rdx)])
call Qux(0,rJx,Oqx)
return true
endfunction
function Qzx takes integer oqx,integer QZx,boolean isx returns nothing
local integer olx
if(oqx==Ge)then
set olx=Jh
loop
call Qzx(kh[olx],QZx,isx)
set olx=olx-1
exitwhen(olx<0)
endloop
else
call SetPlayerAbilityAvailable(vx[oqx],QZx,isx)
endif
endfunction
function Q_x takes nothing returns integer
local unit oMx=GetTriggerUnit()
local integer o4x
if(GetUnitAbilityLevel(oMx,'aLoc')>0)then
set oMx=null
return Z
endif
set o4x=aBx(oMx)
set oMx=null
return o4x
endfunction
function Q0x takes nothing returns boolean
local integer Q1x=GetLearnedSkill()
local integer rwx=GetLearnedSkillLevel()
local integer Oqx=Q_x()
local integer rJx=(LoadInteger(o[((V[(E[((X))])]))],(((Q1x))),(((L6)))))
call rzx(Oqx,rJx,rwx)
return true
endfunction
function Q2x takes integer oqx,integer ocx,playerunitevent Q3x,code Q4x returns nothing
local integer olx
if(ocx==Ge)then
set olx=Jh
loop
call Q2x(oqx,kh[olx],Q3x,Q4x)
set olx=olx-1
exitwhen(olx<0)
endloop
endif
call TriggerRegisterPlayerUnitEvent(fA[(oqx)],vx[ocx],Q3x,Condition(Q4x))
endfunction
function Q5x takes nothing returns nothing
local integer olx=f6-1
set F6=XBx("HeroSpell_Init: set HeroSpell.LEARN_EVENT = Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.HEADER, function HeroSpell.Event_Learn)",pv,BI,function QWx)
set J6=XBx("HeroSpell_Init: set HeroSpell.LEVEL_CHANGE_EVENT = Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.HEADER, function HeroSpell.Event_LevelChange)",Pv,BI,function Qyx)
set k6=XBx("HeroSpell_Init: set HeroSpell.SPELL_REMOVE_EVENT = Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.HEADER, function HeroSpell.Event_SpellRemove)",Av,BI,function QYx)
loop
exitwhen(olx<0)
call Qzx(Ge,H6+olx,false)
set olx=olx-1
endloop
set K6=Xhx(function Q0x)
call Q2x(K6,Ge,EVENT_PLAYER_HERO_SKILL,null)
endfunction
function Q6x takes nothing returns boolean
call Qsx()
call Q5x()
return true
endfunction
function Q7x takes nothing returns boolean
call Hxx(function Q6x,"Spell_Init")
return true
endfunction
function Q8x takes nothing returns boolean
set m6=Vnx(M6)
return true
endfunction
function Q9x takes nothing returns boolean
set rH=Vnx(zh)
return true
endfunction
function svx takes nothing returns boolean
set p6=Vnx(P6)
return true
endfunction
function sex takes nothing returns boolean
set q6=Vnx(Q6)
return true
endfunction
function sxx takes nothing returns boolean
set s6=Vnx(S6)
return true
endfunction
function sox takes nothing returns boolean
set t6=Vnx(T6)
return true
endfunction
function srx takes integer oqx returns integer
set y6[oqx]=true
set Y6[oqx]=false
call rax(t6)
return oqx
endfunction
function six takes nothing returns integer
local integer oqx
if(u6==8190)then
call oYx("Spot_Allocation_allocCustom","call DebugEx(Spot.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",T6+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(U6[(w)]==w)then
set w6=w6+1
set oqx=w6
else
set oqx=U6[(w)]
set U6[(w)]=U6[U6[(w)]]
endif
set U6[oqx]=Z
set W6[oqx]=1
call srx(oqx)
return oqx
endfunction
function sax takes location oMx returns integer
local integer oqx=six()
set VN[oqx]=oMx
return oqx
endfunction
function snx takes nothing returns boolean
set EN=(sax(Location(((.0)*1.),((.0)*1.))))
set z6=O2x()
set Z6=inx()
return true
endfunction
function sVx takes nothing returns boolean
call FWx(function snx,"Spot_Init")
return true
endfunction
function sEx takes nothing returns boolean
set v7=Vnx(e7)
return true
endfunction
function sXx takes nothing returns boolean
set x7=Vnx(o7)
return true
endfunction
function sOx takes nothing returns boolean
set r7=Vnx(i7)
return true
endfunction
function sRx takes nothing returns boolean
set a7=Vnx(n7)
return true
endfunction
function sIx takes nothing returns boolean
set V7=Vnx(E7)
return true
endfunction
function sAx takes nothing returns boolean
set X7=Vnx(O7)
return true
endfunction
function sNx takes nothing returns boolean
return true
endfunction
function sbx takes nothing returns boolean
call Vdx(function sNx,"StringData_Init")
return true
endfunction
function sBx takes code c,string rqx returns nothing
call VRx(la,c,rqx)
endfunction
function scx takes integer oqx returns integer
set c7[oqx]=true
set C7[oqx]=false
call rax(d7)
return oqx
endfunction
function sCx takes nothing returns integer
local integer oqx
if(I7==8190)then
call oYx("TileType_Allocation_allocCustom","call DebugEx(TileType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",A7+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(N7[(w)]==w)then
set b7=b7+1
set oqx=b7
else
set oqx=N7[(w)]
set N7[(w)]=N7[N7[(w)]]
endif
set N7[oqx]=Z
set B7[oqx]=1
call scx(oqx)
return oqx
endfunction
function sdx takes integer oMx returns integer
local integer oqx=sCx()
set D7[oqx]=oMx
call SaveInteger(o[((V[(E[((X))])]))],(((oMx))),(((F7))),(((oqx))))
return oqx
endfunction
function sDx takes nothing returns boolean
set R7=sdx('Iice')
return true
endfunction
function sFx takes nothing returns boolean
set g7=sdx('Ibsq')
return true
endfunction
function sgx takes nothing returns boolean
set G7=sdx('Idtr')
return true
endfunction
function sGx takes nothing returns boolean
set h7=sdx('Ibkb')
return true
endfunction
function shx takes nothing returns boolean
set H7=sdx('cIc1')
return true
endfunction
function sHx takes nothing returns boolean
set j7=sdx('cIc2')
return true
endfunction
function sjx takes nothing returns boolean
set J7=sdx('Itbk')
return true
endfunction
function sJx takes nothing returns boolean
set k7=sdx('Isnw')
return true
endfunction
function skx takes nothing returns boolean
set K7=sdx('Idrt')
return true
endfunction
function sKx takes nothing returns boolean
set l7=sdx('Idki')
return true
endfunction
function slx takes nothing returns boolean
set L7=sdx('Ggrs')
return true
endfunction
function sLx takes nothing returns boolean
set m7=sdx('Irbk')
return true
endfunction
function smx takes nothing returns boolean
set M7=sdx('Jgsb')
return true
endfunction
function sMx takes nothing returns boolean
call sBx(function sDx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_ice_wc3tile.j")
call sBx(function sFx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_blackSquares_wc3tile.j")
call sBx(function sgx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_dirtRough_wc3tile.j")
call sBx(function sGx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_blackBricks_wc3tile.j")
call sBx(function shx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_snowCliff_wc3tile.j")
call sBx(function sHx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_runedBricksCliff_wc3tile.j")
call sBx(function sjx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_tiledBricks_wc3tile.j")
call sBx(function sJx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_snow_wc3tile.j")
call sBx(function skx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_dirt_wc3tile.j")
call sBx(function sKx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_darkIce_wc3tile.j")
call sBx(function slx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_greyStones_wc3tile.j")
call sBx(function sLx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_runeBricks_wc3tile.j")
call sBx(function smx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_grass_wc3tile.j")
return true
endfunction
function spx takes nothing returns boolean
set d7=Vnx(A7)
return true
endfunction
function sPx takes nothing returns boolean
return true
endfunction
function sqx takes nothing returns boolean
call Gcx(function sPx,"TileType_Init")
return true
endfunction
function sQx takes nothing returns boolean
set p7=Vnx(P7)
return true
endfunction
function ssx takes nothing returns boolean
set q7=Vnx(Q7)
return true
endfunction
function sSx takes nothing returns boolean
set s7=V2x()
return true
endfunction
function stx takes nothing returns boolean
call Gcx(function sSx,"Tile_Init")
return true
endfunction
function sTx takes nothing returns boolean
set S7=Vnx(t7)
return true
endfunction
function sux takes nothing returns boolean
set T7=Vnx(u7)
return true
endfunction
function sUx takes nothing returns boolean
return true
endfunction
function swx takes nothing returns boolean
call Gcx(function sUx,"TileTypeMod_Init")
return true
endfunction
function sWx takes code c,string rqx returns nothing
call VRx(ka,c,rqx)
endfunction
function syx takes integer oqx returns integer
set Z7[oqx]=true
set v8[oqx]=false
call rax(e8)
return oqx
endfunction
function sYx takes nothing returns integer
local integer oqx
if(w7==8190)then
call oYx("UbersplatType_Allocation_allocCustom","call DebugEx(UbersplatType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",W7+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(y7[(w)]==w)then
set Y7=Y7+1
set oqx=Y7
else
set oqx=y7[(w)]
set y7[(w)]=y7[y7[(w)]]
endif
set y7[oqx]=Z
set z7[oqx]=1
call syx(oqx)
return oqx
endfunction
function szx takes string oMx returns integer
local integer oqx=sYx()
set x8[oqx]=oMx
return oqx
endfunction
function sZx takes nothing returns boolean
set U7=szx("pSnw")
return true
endfunction
function s_x takes nothing returns boolean
call sWx(function sZx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\UbersplatType.struct\\obj_snow_wc3ubersplat.j")
return true
endfunction
function s0x takes nothing returns boolean
set e8=Vnx(W7)
return true
endfunction
function s1x takes nothing returns boolean
set o8=Vnx(r8)
return true
endfunction
function s2x takes nothing returns boolean
set i8=Vnx(a8)
return true
endfunction
function s3x takes nothing returns boolean
set n8=Vnx(V8)
return true
endfunction
function s4x takes nothing returns boolean
set E8=Vnx(X8)
return true
endfunction
function s5x takes nothing returns boolean
set O8=Vnx(R8)
return true
endfunction
function s6x takes nothing returns boolean
set I8=Vnx(A8)
return true
endfunction
function s7x takes nothing returns boolean
set N8=Vnx(b8)
return true
endfunction
function s8x takes nothing returns boolean
set B8=Vnx(c8)
return true
endfunction
function s9x takes nothing returns boolean
set C8=Vnx(d8)
return true
endfunction
function Svx takes nothing returns boolean
set D8=Vnx(f8)
return true
endfunction
function Sex takes nothing returns boolean
set F8=Vnx(g8)
return true
endfunction
function Sxx takes nothing returns boolean
set G8=Vnx(h8)
return true
endfunction
function Sox takes nothing returns boolean
set H8=Vnx(j8)
return true
endfunction
function Srx takes nothing returns boolean
set J8=Vnx(k8)
return true
endfunction
function Six takes nothing returns boolean
set K8=Vnx(l8)
return true
endfunction
function Sax takes nothing returns boolean
set L8=Vnx(m8)
return true
endfunction
function Snx takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((q8[(oqx)]))])]))],((((Q8[((oqx))])))),(((oQx))))))
endfunction
function SVx takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((q8[(oqx)]))])]))],((((Q8[((oqx))])))),(((oQx)+(okx)))))
endfunction
function SEx takes integer oqx returns nothing
set u8[oqx]=false
call rgx(F8)
endfunction
function SXx takes integer oqx returns nothing
if(t8[oqx]>0)then
return
endif
if(T8[oqx]!=Z)then
call oYx("FolderUbersplat_FolderColor_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderUbersplat_FolderColor_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",g8+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set T8[oqx]=T8[(w)]
set T8[(w)]=oqx
call SEx(oqx)
endfunction
function SOx takes integer oqx returns nothing
set t8[oqx]=t8[oqx]-1
call SXx(oqx)
endfunction
function SRx takes integer oqx,integer oQx,integer oSx returns boolean
return rex(q8[(oqx)],(Q8[((oqx))]),oQx,oSx)
endfunction
function SIx takes integer oqx,integer Xwx returns nothing
if not((LoadInteger(o[((D[((U8[oqx]))]))],((((Q8[((oqx))])))),(osx((((rA[(Xwx)]))),(((Xwx)))))))!=0)then
call oYx("FolderUbersplat_StructEvent_Remove","call DebugEx(\"subject \"+I2S(Ubersplat(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((Q8[((oqx))]))+" has not "+(JA[(Xwx)]))
return
endif
call rex(U8[oqx],(Q8[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function SAx takes integer oqx returns boolean
local integer okx=(w8[(oqx)])
set w8[W8[y8]]=okx
set W8[okx-1]=W8[y8]
set w8[oqx]=0
set y8=y8-1
return(y8==F)
endfunction
function SNx takes integer oqx,integer ibx,integer rkx returns nothing
call SOx((oqx))
call ijx(ibx)
call SRx(rkx,S8,oqx)
call SIx(rkx,p8)
if SAx(oqx)then
call iHx(Y8)
endif
endfunction
function Sbx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(P8[(rdx)])
local integer olx=Snx(rkx,S8)
local integer oqx
if(olx>0)then
loop
set oqx=SVx(rkx,S8,olx)
call SNx(oqx,z8[oqx],rkx)
set olx=olx-1
exitwhen(olx<q)
endloop
endif
return true
endfunction
function SBx takes nothing returns nothing
set p8=XBx("FolderUbersplat_FolderColor_StructTimed_Init: set FolderUbersplat_FolderColor_StructTimed.DESTROY_EVENT = Event.Create(Ubersplat.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUbersplat_FolderColor_StructTimed.Event_Destroy)",M8,BI,function Sbx)
set Y8=inx()
endfunction
function Scx takes nothing returns boolean
set M8=(E0x())
call SBx()
return true
endfunction
function SCx takes nothing returns boolean
call Gcx(function Scx,"Ubersplat_Init")
return true
endfunction
function Sdx takes nothing returns boolean
set Z8=Vnx(vvv)
return true
endfunction
function SDx takes nothing returns boolean
set vev=Vnx(vxv)
return true
endfunction
function Sfx takes nothing returns boolean
set vov=Vnx(vrv)
return true
endfunction
function SFx takes nothing returns boolean
set viv=Vnx(vav)
return true
endfunction
function Sgx takes nothing returns boolean
set vnv=Vnx(vVv)
return true
endfunction
function SGx takes nothing returns boolean
set vEv=Vnx(vXv)
return true
endfunction
function Shx takes nothing returns boolean
set vOv=Vnx(vRv)
return true
endfunction
function SHx takes nothing returns boolean
set dN=Vnx(AN)
return true
endfunction
function Sjx takes nothing returns boolean
set PN=inx()
set TN=inx()
set lN=inx()
set yN=inx()
return true
endfunction
function SJx takes nothing returns boolean
call FWx(function Sjx,"TextTag_Init")
return true
endfunction
function Skx takes nothing returns boolean
set vIv=Vnx(vAv)
return true
endfunction
function SKx takes nothing returns boolean
set vNv=Vnx(vbv)
return true
endfunction
function Slx takes nothing returns boolean
set vBv=Vnx(vcv)
return true
endfunction
function SLx takes nothing returns boolean
set vCv=Vnx(vdv)
return true
endfunction
function Smx takes nothing returns boolean
set vDv=Vnx(vfv)
return true
endfunction
function SMx takes nothing returns boolean
set vFv=Vnx(vgv)
return true
endfunction
function Spx takes nothing returns boolean
set vGv=Vnx(vhv)
return true
endfunction
function SPx takes nothing returns boolean
set vHv=Vnx(vjv)
return true
endfunction
function Sqx takes nothing returns boolean
set vJv=Vnx(vkv)
return true
endfunction
function SQx takes nothing returns boolean
set vKv=Vnx(vlv)
return true
endfunction
function Ssx takes nothing returns boolean
set Xe=Vnx(ee)
return true
endfunction
function SSx takes nothing returns nothing
endfunction
function Stx takes nothing returns nothing
endfunction
function STx takes nothing returns boolean
call SSx()
call Stx()
return true
endfunction
function Sux takes nothing returns boolean
call FWx(function STx,"Timer_Init")
return true
endfunction
function SUx takes nothing returns boolean
set vLv=Vnx(vmv)
return true
endfunction
function Swx takes nothing returns boolean
set vMv=Vnx(vpv)
return true
endfunction
function SWx takes nothing returns boolean
set vPv=Vnx(vqv)
return true
endfunction
function Syx takes nothing returns boolean
set vQv=Vnx(vsv)
return true
endfunction
function SYx takes nothing returns boolean
set vSv=Vnx(vtv)
return true
endfunction
function Szx takes nothing returns boolean
set vTv=Vnx(vuv)
return true
endfunction
function SZx takes nothing returns boolean
set vUv=Vnx(vwv)
return true
endfunction
function S_x takes nothing returns boolean
set vWv=Vnx(vyv)
return true
endfunction
function S0x takes nothing returns boolean
set dA=Vnx(Dv)
return true
endfunction
function S1x takes trigger oMx returns integer
return(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((oMx))))),((((gA))))))
endfunction
function S2x takes nothing returns nothing
local integer oqx=(S1x(GetTriggeringTrigger()))
if(DA[oqx]!=null)then
if not TriggerEvaluate(DA[oqx])then
return
endif
endif
call rcx(oqx)
endfunction
function S3x takes nothing returns boolean
set qA=V2x()
set jA=Condition(function S2x)
return true
endfunction
function S4x takes nothing returns boolean
call FWx(function S3x,"Trigger_Init")
return true
endfunction
function S5x takes nothing returns boolean
set vYv[4]='Ada4'
call LZx('Ada4',false)
return true
endfunction
function S6x takes nothing returns boolean
set vzv[5]='Aia5'
call LZx('Aia5',false)
return true
endfunction
function S7x takes nothing returns boolean
set vYv[0]='Ada0'
call LZx('Ada0',false)
return true
endfunction
function S8x takes nothing returns boolean
set vYv[6]='Ada6'
call LZx('Ada6',false)
return true
endfunction
function S9x takes nothing returns boolean
set vYv[5]='Ada5'
call LZx('Ada5',false)
return true
endfunction
function tvx takes nothing returns boolean
set vzv[2]='Aia2'
call LZx('Aia2',false)
return true
endfunction
function tex takes nothing returns boolean
set vzv[0]='Aia0'
call LZx('Aia0',false)
return true
endfunction
function txx takes nothing returns boolean
set vYv[2]='Ada2'
call LZx('Ada2',false)
return true
endfunction
function tox takes nothing returns boolean
set vzv[4]='Aia4'
call LZx('Aia4',false)
return true
endfunction
function trx takes nothing returns boolean
set vZv[0]=1
set vZv[1]=2
set vZv[2]=4
set vZv[3]=8
set vZv[4]=16
set vZv[5]=32
set vZv[6]=64
return true
endfunction
function tix takes nothing returns boolean
set vzv[6]='Aia6'
call LZx('Aia6',false)
return true
endfunction
function tax takes nothing returns boolean
set vzv[3]='Aia3'
call LZx('Aia3',false)
return true
endfunction
function tnx takes nothing returns boolean
set vzv[1]='Aia1'
call LZx('Aia1',false)
return true
endfunction
function tVx takes nothing returns boolean
set vYv[3]='Ada3'
call LZx('Ada3',false)
return true
endfunction
function tEx takes nothing returns boolean
set vYv[1]='Ada1'
call LZx('Ada1',false)
return true
endfunction
function tXx takes nothing returns boolean
call VRx(qa,(function S5x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_decreasingSpells[4]_wc3spell.j"))
call VRx(qa,(function S6x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_increasingSpells[5]_wc3spell.j"))
call VRx(qa,(function S7x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_decreasingSpells[0]_wc3spell.j"))
call VRx(qa,(function S8x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_decreasingSpells[6]_wc3spell.j"))
call VRx(qa,(function S9x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_decreasingSpells[5]_wc3spell.j"))
call VRx(qa,(function tvx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_increasingSpells[2]_wc3spell.j"))
call VRx(qa,(function tex),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_increasingSpells[0]_wc3spell.j"))
call VRx(qa,(function txx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_decreasingSpells[2]_wc3spell.j"))
call VRx(qa,(function tox),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_increasingSpells[4]_wc3spell.j"))
call VRx(ea,(function trx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_this_wc3obj.j"))
call VRx(qa,(function tix),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_increasingSpells[6]_wc3spell.j"))
call VRx(qa,(function tax),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_increasingSpells[3]_wc3spell.j"))
call VRx(qa,(function tnx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_increasingSpells[1]_wc3spell.j"))
call VRx(qa,(function tVx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_decreasingSpells[3]_wc3spell.j"))
call VRx(qa,(function tEx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_decreasingSpells[1]_wc3spell.j"))
return true
endfunction
function tOx takes nothing returns boolean
set v_v=Vnx(v0v)
return true
endfunction
function tRx takes nothing returns boolean
set v1v=Vnx(v2v)
return true
endfunction
function tIx takes nothing returns boolean
set v3v[2]='AiR2'
call LZx('AiR2',false)
return true
endfunction
function tAx takes nothing returns boolean
set v3v[6]='AiR6'
call LZx('AiR6',false)
return true
endfunction
function tNx takes nothing returns boolean
set v4v[1]='AdR1'
call LZx('AdR1',false)
return true
endfunction
function tbx takes nothing returns boolean
set v3v[1]='AiR1'
call LZx('AiR1',false)
return true
endfunction
function tBx takes nothing returns boolean
set v4v[3]='AdR3'
call LZx('AdR3',false)
return true
endfunction
function tcx takes nothing returns boolean
set v3v[8]='AiR8'
call LZx('AiR8',false)
return true
endfunction
function tCx takes nothing returns boolean
set v4v[6]='AdR6'
call LZx('AdR6',false)
return true
endfunction
function tdx takes nothing returns boolean
set v4v[0]='AdR0'
call LZx('AdR0',false)
return true
endfunction
function tDx takes nothing returns boolean
set v4v[4]='AdR4'
call LZx('AdR4',false)
return true
endfunction
function tfx takes nothing returns boolean
set v3v[0]='AiR0'
call LZx('AiR0',false)
return true
endfunction
function tFx takes nothing returns boolean
set v3v[5]='AiR5'
call LZx('AiR5',false)
return true
endfunction
function tgx takes nothing returns boolean
set v3v[7]='AiR7'
call LZx('AiR7',false)
return true
endfunction
function tGx takes nothing returns boolean
set v4v[2]='AdR2'
call LZx('AdR2',false)
return true
endfunction
function thx takes nothing returns boolean
set v4v[8]='AdR8'
call LZx('AdR8',false)
return true
endfunction
function tHx takes nothing returns boolean
set v4v[9]='AdR9'
call LZx('AdR9',false)
return true
endfunction
function tjx takes nothing returns boolean
set v3v[4]='AiR4'
call LZx('AiR4',false)
return true
endfunction
function tJx takes nothing returns boolean
set v4v[7]='AdR7'
call LZx('AdR7',false)
return true
endfunction
function tkx takes nothing returns boolean
set v5v[0]=1
set v5v[1]=2
set v5v[2]=4
set v5v[3]=8
set v5v[4]=16
set v5v[5]=32
set v5v[6]=64
set v5v[7]=$80
set v5v[8]=256
set v5v[9]=512
return true
endfunction
function tKx takes nothing returns boolean
set v4v[5]='AdR5'
call LZx('AdR5',false)
return true
endfunction
function tlx takes nothing returns boolean
set v3v[9]='AiR9'
call LZx('AiR9',false)
return true
endfunction
function tLx takes nothing returns boolean
set v3v[3]='AiR3'
call LZx('AiR3',false)
return true
endfunction
function tmx takes nothing returns boolean
call VRx(qa,(function tIx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[2]_wc3spell.j"))
call VRx(qa,(function tAx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[6]_wc3spell.j"))
call VRx(qa,(function tNx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[1]_wc3spell.j"))
call VRx(qa,(function tbx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[1]_wc3spell.j"))
call VRx(qa,(function tBx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[3]_wc3spell.j"))
call VRx(qa,(function tcx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[8]_wc3spell.j"))
call VRx(qa,(function tCx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[6]_wc3spell.j"))
call VRx(qa,(function tdx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[0]_wc3spell.j"))
call VRx(qa,(function tDx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[4]_wc3spell.j"))
call VRx(qa,(function tfx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[0]_wc3spell.j"))
call VRx(qa,(function tFx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[5]_wc3spell.j"))
call VRx(qa,(function tgx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[7]_wc3spell.j"))
call VRx(qa,(function tGx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[2]_wc3spell.j"))
call VRx(qa,(function thx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[8]_wc3spell.j"))
call VRx(qa,(function tHx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[9]_wc3spell.j"))
call VRx(qa,(function tjx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[4]_wc3spell.j"))
call VRx(qa,(function tJx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[7]_wc3spell.j"))
call VRx(ea,(function tkx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_this_wc3obj.j"))
call VRx(qa,(function tKx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[5]_wc3spell.j"))
call VRx(qa,(function tlx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[9]_wc3spell.j"))
call VRx(qa,(function tLx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[3]_wc3spell.j"))
return true
endfunction
function tMx takes nothing returns boolean
set v6v=Vnx(v7v)
return true
endfunction
function tpx takes nothing returns boolean
set v8v=Vnx(v9v)
return true
endfunction
function tPx takes nothing returns boolean
call LZx('Aatk',false)
return true
endfunction
function tqx takes nothing returns boolean
call VRx(qa,(function tPx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\obj_attack_wc3spell.j"))
return true
endfunction
function tQx takes nothing returns boolean
set evv=Vnx(eev)
return true
endfunction
function tsx takes nothing returns boolean
set sg[2]='AdD2'
call LZx('AdD2',false)
return true
endfunction
function tSx takes nothing returns boolean
set tg[5]='AiD5'
call LZx('AiD5',false)
return true
endfunction
function ttx takes nothing returns boolean
set tg[6]='AiD6'
call LZx('AiD6',false)
return true
endfunction
function tTx takes nothing returns boolean
set tg[2]='AiD2'
call LZx('AiD2',false)
return true
endfunction
function tux takes nothing returns boolean
set sg[3]='AdD3'
call LZx('AdD3',false)
return true
endfunction
function tUx takes nothing returns boolean
set tg[4]='AiD4'
call LZx('AiD4',false)
return true
endfunction
function twx takes nothing returns boolean
set sg[5]='AdD5'
call LZx('AdD5',false)
return true
endfunction
function tWx takes nothing returns boolean
set sg[4]='AdD4'
call LZx('AdD4',false)
return true
endfunction
function tyx takes nothing returns boolean
set tg[3]='AiD3'
call LZx('AiD3',false)
return true
endfunction
function tYx takes nothing returns boolean
set tg[0]='AiD0'
call LZx('AiD0',false)
return true
endfunction
function tzx takes nothing returns boolean
set Tg[0]=1
set Tg[1]=2
set Tg[2]=4
set Tg[3]=8
set Tg[4]=16
set Tg[5]=32
set Tg[6]=64
return true
endfunction
function tZx takes nothing returns boolean
set sg[1]='AdD1'
call LZx('AdD1',false)
return true
endfunction
function t_x takes nothing returns boolean
set sg[6]='AdD6'
call LZx('AdD6',false)
return true
endfunction
function t0x takes nothing returns boolean
set tg[1]='AiD1'
call LZx('AiD1',false)
return true
endfunction
function t1x takes nothing returns boolean
set sg[0]='AdD0'
call LZx('AdD0',false)
return true
endfunction
function t2x takes nothing returns boolean
call VRx(qa,(function tsx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_decreasingSpells[2]_wc3spell.j"))
call VRx(qa,(function tSx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_increasingSpells[5]_wc3spell.j"))
call VRx(qa,(function ttx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_increasingSpells[6]_wc3spell.j"))
call VRx(qa,(function tTx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_increasingSpells[2]_wc3spell.j"))
call VRx(qa,(function tux),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_decreasingSpells[3]_wc3spell.j"))
call VRx(qa,(function tUx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_increasingSpells[4]_wc3spell.j"))
call VRx(qa,(function twx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_decreasingSpells[5]_wc3spell.j"))
call VRx(qa,(function tWx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_decreasingSpells[4]_wc3spell.j"))
call VRx(qa,(function tyx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_increasingSpells[3]_wc3spell.j"))
call VRx(qa,(function tYx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_increasingSpells[0]_wc3spell.j"))
call VRx(ea,(function tzx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_this_wc3obj.j"))
call VRx(qa,(function tZx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_decreasingSpells[1]_wc3spell.j"))
call VRx(qa,(function t_x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_decreasingSpells[6]_wc3spell.j"))
call VRx(qa,(function t0x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_increasingSpells[1]_wc3spell.j"))
call VRx(qa,(function t1x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_decreasingSpells[0]_wc3spell.j"))
return true
endfunction
function t3x takes nothing returns boolean
set exv=Vnx(eov)
return true
endfunction
function t4x takes nothing returns boolean
set erv[0]='Adz0'
call LZx('Adz0',false)
return true
endfunction
function t5x takes nothing returns boolean
set eiv[6]='Aiz6'
call LZx('Aiz6',false)
return true
endfunction
function t6x takes nothing returns boolean
set eiv[2]='Aiz2'
call LZx('Aiz2',false)
return true
endfunction
function t7x takes nothing returns boolean
set eiv[0]='Aiz0'
call LZx('Aiz0',false)
return true
endfunction
function t8x takes nothing returns boolean
set eiv[5]='Aiz5'
call LZx('Aiz5',false)
return true
endfunction
function t9x takes nothing returns boolean
set eiv[1]='Aiz1'
call LZx('Aiz1',false)
return true
endfunction
function Tvx takes nothing returns boolean
set erv[2]='Adz2'
call LZx('Adz2',false)
return true
endfunction
function Tex takes nothing returns boolean
set erv[3]='Adz3'
call LZx('Adz3',false)
return true
endfunction
function Txx takes nothing returns boolean
set erv[4]='Adz4'
call LZx('Adz4',false)
return true
endfunction
function Tox takes nothing returns boolean
set erv[7]='Adz7'
call LZx('Adz7',false)
return true
endfunction
function Trx takes nothing returns boolean
set eav[0]='Iid0'
return true
endfunction
function Tix takes nothing returns boolean
set eiv[7]='Aiz7'
call LZx('Aiz7',false)
return true
endfunction
function Tax takes nothing returns boolean
set eiv[4]='Aiz4'
call LZx('Aiz4',false)
return true
endfunction
function Tnx takes nothing returns boolean
set erv[5]='Adz5'
call LZx('Adz5',false)
return true
endfunction
function TVx takes nothing returns boolean
set erv[6]='Adz6'
call LZx('Adz6',false)
return true
endfunction
function TEx takes nothing returns boolean
set env[0]='Idd0'
return true
endfunction
function TXx takes nothing returns boolean
set env[2]='Idd2'
return true
endfunction
function TOx takes nothing returns boolean
set env[7]='Idd7'
return true
endfunction
function TRx takes nothing returns boolean
set env[3]='Idd3'
return true
endfunction
function TIx takes nothing returns boolean
set eiv[3]='Aiz3'
call LZx('Aiz3',false)
return true
endfunction
function TAx takes nothing returns boolean
set env[4]='Idd4'
return true
endfunction
function TNx takes nothing returns boolean
set eav[1]='Iid1'
return true
endfunction
function Tbx takes nothing returns boolean
set env[6]='Idd6'
return true
endfunction
function TBx takes nothing returns boolean
set eav[2]='Iid2'
return true
endfunction
function Tcx takes nothing returns boolean
set eav[3]='Iid3'
return true
endfunction
function TCx takes nothing returns boolean
set Gg[0]=1
set Gg[1]=2
set Gg[2]=4
set Gg[3]=8
set Gg[4]=16
set Gg[5]=32
set Gg[6]=64
set Gg[7]=$80
return true
endfunction
function Tdx takes nothing returns boolean
set eav[5]='Iid5'
return true
endfunction
function TDx takes nothing returns boolean
set eav[6]='Iid6'
return true
endfunction
function Tfx takes nothing returns boolean
set eav[7]='Iid7'
return true
endfunction
function TFx takes nothing returns boolean
set eav[4]='Iid4'
return true
endfunction
function Tgx takes nothing returns boolean
set env[5]='Idd5'
return true
endfunction
function TGx takes nothing returns boolean
set env[1]='Idd1'
return true
endfunction
function Thx takes nothing returns boolean
set erv[1]='Adz1'
call LZx('Adz1',false)
return true
endfunction
function THx takes nothing returns boolean
call VRx(qa,(function t4x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingSpells[0]_wc3spell.j"))
call VRx(qa,(function t5x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingSpells[6]_wc3spell.j"))
call VRx(qa,(function t6x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingSpells[2]_wc3spell.j"))
call VRx(qa,(function t7x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingSpells[0]_wc3spell.j"))
call VRx(qa,(function t8x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingSpells[5]_wc3spell.j"))
call VRx(qa,(function t9x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingSpells[1]_wc3spell.j"))
call VRx(qa,(function Tvx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingSpells[2]_wc3spell.j"))
call VRx(qa,(function Tex),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingSpells[3]_wc3spell.j"))
call VRx(qa,(function Txx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingSpells[4]_wc3spell.j"))
call VRx(qa,(function Tox),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingSpells[7]_wc3spell.j"))
call VRx(sa,(function Trx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingItemTypes[0]_wc3item.j"))
call VRx(qa,(function Tix),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingSpells[7]_wc3spell.j"))
call VRx(qa,(function Tax),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingSpells[4]_wc3spell.j"))
call VRx(qa,(function Tnx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingSpells[5]_wc3spell.j"))
call VRx(qa,(function TVx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingSpells[6]_wc3spell.j"))
call VRx(sa,(function TEx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingItemTypes[0]_wc3item.j"))
call VRx(sa,(function TXx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingItemTypes[2]_wc3item.j"))
call VRx(sa,(function TOx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingItemTypes[7]_wc3item.j"))
call VRx(sa,(function TRx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingItemTypes[3]_wc3item.j"))
call VRx(qa,(function TIx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingSpells[3]_wc3spell.j"))
call VRx(sa,(function TAx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingItemTypes[4]_wc3item.j"))
call VRx(sa,(function TNx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingItemTypes[1]_wc3item.j"))
call VRx(sa,(function Tbx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingItemTypes[6]_wc3item.j"))
call VRx(sa,(function TBx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingItemTypes[2]_wc3item.j"))
call VRx(sa,(function Tcx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingItemTypes[3]_wc3item.j"))
call VRx(ea,(function TCx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_this_wc3obj.j"))
call VRx(sa,(function Tdx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingItemTypes[5]_wc3item.j"))
call VRx(sa,(function TDx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingItemTypes[6]_wc3item.j"))
call VRx(sa,(function Tfx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingItemTypes[7]_wc3item.j"))
call VRx(sa,(function TFx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingItemTypes[4]_wc3item.j"))
call VRx(sa,(function Tgx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingItemTypes[5]_wc3item.j"))
call VRx(sa,(function TGx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingItemTypes[1]_wc3item.j"))
call VRx(qa,(function Thx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingSpells[1]_wc3spell.j"))
return true
endfunction
function Tjx takes nothing returns boolean
set eVv=Vnx(eEv)
return true
endfunction
function TJx takes nothing returns boolean
call LZx('Amov',false)
return true
endfunction
function Tkx takes nothing returns boolean
call VRx(qa,(function TJx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Movement\\obj_move_wc3spell.j"))
return true
endfunction
function TKx takes nothing returns boolean
set eXv=Vnx(eOv)
return true
endfunction
function Tlx takes nothing returns boolean
set BF[0]='AiG0'
call LZx('AiG0',false)
return true
endfunction
function TLx takes nothing returns boolean
set NF[3]='AdG3'
call LZx('AdG3',false)
return true
endfunction
function Tmx takes nothing returns boolean
set NF[1]='AdG1'
call LZx('AdG1',false)
return true
endfunction
function TMx takes nothing returns boolean
set BF[5]='AiG5'
call LZx('AiG5',false)
return true
endfunction
function Tpx takes nothing returns boolean
set NF[2]='AdG2'
call LZx('AdG2',false)
return true
endfunction
function TPx takes nothing returns boolean
set NF[5]='AdG5'
call LZx('AdG5',false)
return true
endfunction
function Tqx takes nothing returns boolean
set BF[2]='AiG2'
call LZx('AiG2',false)
return true
endfunction
function TQx takes nothing returns boolean
set BF[4]='AiG4'
call LZx('AiG4',false)
return true
endfunction
function Tsx takes nothing returns boolean
set NF[4]='AdG4'
call LZx('AdG4',false)
return true
endfunction
function TSx takes nothing returns boolean
set cF[0]=1
set cF[1]=2
set cF[2]=4
set cF[3]=8
set cF[4]=16
set cF[5]=32
set cF[6]=64
return true
endfunction
function Ttx takes nothing returns boolean
set BF[6]='AiG6'
call LZx('AiG6',false)
return true
endfunction
function TTx takes nothing returns boolean
set BF[1]='AiG1'
call LZx('AiG1',false)
return true
endfunction
function Tux takes nothing returns boolean
set NF[0]='AdG0'
call LZx('AdG0',false)
return true
endfunction
function TUx takes nothing returns boolean
set NF[6]='AdG6'
call LZx('AdG6',false)
return true
endfunction
function Twx takes nothing returns boolean
set BF[3]='AiG3'
call LZx('AiG3',false)
return true
endfunction
function TWx takes nothing returns boolean
call VRx(qa,(function Tlx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_increasingSpells[0]_wc3spell.j"))
call VRx(qa,(function TLx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_decreasingSpells[3]_wc3spell.j"))
call VRx(qa,(function Tmx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_decreasingSpells[1]_wc3spell.j"))
call VRx(qa,(function TMx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_increasingSpells[5]_wc3spell.j"))
call VRx(qa,(function Tpx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_decreasingSpells[2]_wc3spell.j"))
call VRx(qa,(function TPx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_decreasingSpells[5]_wc3spell.j"))
call VRx(qa,(function Tqx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_increasingSpells[2]_wc3spell.j"))
call VRx(qa,(function TQx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_increasingSpells[4]_wc3spell.j"))
call VRx(qa,(function Tsx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_decreasingSpells[4]_wc3spell.j"))
call VRx(ea,(function TSx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_this_wc3obj.j"))
call VRx(qa,(function Ttx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_increasingSpells[6]_wc3spell.j"))
call VRx(qa,(function TTx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_increasingSpells[1]_wc3spell.j"))
call VRx(qa,(function Tux),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_decreasingSpells[0]_wc3spell.j"))
call VRx(qa,(function TUx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_decreasingSpells[6]_wc3spell.j"))
call VRx(qa,(function Twx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_increasingSpells[3]_wc3spell.j"))
return true
endfunction
function Tyx takes nothing returns boolean
set eRv=Vnx(eIv)
return true
endfunction
function TYx takes nothing returns boolean
set eAv=Vnx(eNv)
return true
endfunction
function Tzx takes nothing returns boolean
set Og[0]='AiI0'
call LZx('AiI0',false)
return true
endfunction
function TZx takes nothing returns boolean
set Og[4]='AiI4'
call LZx('AiI4',false)
return true
endfunction
function T_x takes nothing returns boolean
set Eg[0]='AdI0'
call LZx('AdI0',false)
return true
endfunction
function T0x takes nothing returns boolean
set Eg[1]='AdI1'
call LZx('AdI1',false)
return true
endfunction
function T1x takes nothing returns boolean
set Eg[4]='AdI4'
call LZx('AdI4',false)
return true
endfunction
function T2x takes nothing returns boolean
set Og[5]='AiI5'
call LZx('AiI5',false)
return true
endfunction
function T3x takes nothing returns boolean
set Og[6]='AiI6'
call LZx('AiI6',false)
return true
endfunction
function T4x takes nothing returns boolean
set Og[1]='AiI1'
call LZx('AiI1',false)
return true
endfunction
function T5x takes nothing returns boolean
set Eg[6]='AdI6'
call LZx('AdI6',false)
return true
endfunction
function T6x takes nothing returns boolean
set Eg[5]='AdI5'
call LZx('AdI5',false)
return true
endfunction
function T7x takes nothing returns boolean
set Eg[2]='AdI2'
call LZx('AdI2',false)
return true
endfunction
function T8x takes nothing returns boolean
set Og[2]='AiI2'
call LZx('AiI2',false)
return true
endfunction
function T9x takes nothing returns boolean
set Og[3]='AiI3'
call LZx('AiI3',false)
return true
endfunction
function uvx takes nothing returns boolean
set Eg[3]='AdI3'
call LZx('AdI3',false)
return true
endfunction
function uex takes nothing returns boolean
set Rg[0]=1
set Rg[1]=2
set Rg[2]=4
set Rg[3]=8
set Rg[4]=16
set Rg[5]=32
set Rg[6]=64
return true
endfunction
function uxx takes nothing returns boolean
call VRx(qa,(function Tzx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_increasingSpells[0]_wc3spell.j"))
call VRx(qa,(function TZx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_increasingSpells[4]_wc3spell.j"))
call VRx(qa,(function T_x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_decreasingSpells[0]_wc3spell.j"))
call VRx(qa,(function T0x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_decreasingSpells[1]_wc3spell.j"))
call VRx(qa,(function T1x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_decreasingSpells[4]_wc3spell.j"))
call VRx(qa,(function T2x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_increasingSpells[5]_wc3spell.j"))
call VRx(qa,(function T3x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_increasingSpells[6]_wc3spell.j"))
call VRx(qa,(function T4x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_increasingSpells[1]_wc3spell.j"))
call VRx(qa,(function T5x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_decreasingSpells[6]_wc3spell.j"))
call VRx(qa,(function T6x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_decreasingSpells[5]_wc3spell.j"))
call VRx(qa,(function T7x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_decreasingSpells[2]_wc3spell.j"))
call VRx(qa,(function T8x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_increasingSpells[2]_wc3spell.j"))
call VRx(qa,(function T9x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_increasingSpells[3]_wc3spell.j"))
call VRx(qa,(function uvx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_decreasingSpells[3]_wc3spell.j"))
call VRx(ea,(function uex),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_this_wc3obj.j"))
return true
endfunction
function uox takes nothing returns boolean
set ebv=Vnx(eBv)
return true
endfunction
function urx takes nothing returns boolean
set ecv=Vnx(eCv)
return true
endfunction
function uix takes nothing returns boolean
set wG[6]='AdS6'
call LZx('AdS6',false)
return true
endfunction
function uax takes nothing returns boolean
set wG[0]='AdS0'
call LZx('AdS0',false)
return true
endfunction
function unx takes nothing returns boolean
set yG[6]='AiS6'
call LZx('AiS6',false)
return true
endfunction
function uVx takes nothing returns boolean
set yG[4]='AiS4'
call LZx('AiS4',false)
return true
endfunction
function uEx takes nothing returns boolean
set yG[3]='AiS3'
call LZx('AiS3',false)
return true
endfunction
function uXx takes nothing returns boolean
set wG[2]='AdS2'
call LZx('AdS2',false)
return true
endfunction
function uOx takes nothing returns boolean
set wG[1]='AdS1'
call LZx('AdS1',false)
return true
endfunction
function uRx takes nothing returns boolean
set YG[0]=1
set YG[1]=2
set YG[2]=4
set YG[3]=8
set YG[4]=16
set YG[5]=32
set YG[6]=64
return true
endfunction
function uIx takes nothing returns boolean
set yG[5]='AiS5'
call LZx('AiS5',false)
return true
endfunction
function uAx takes nothing returns boolean
set wG[4]='AdS4'
call LZx('AdS4',false)
return true
endfunction
function uNx takes nothing returns boolean
set wG[3]='AdS3'
call LZx('AdS3',false)
return true
endfunction
function ubx takes nothing returns boolean
set yG[1]='AiS1'
call LZx('AiS1',false)
return true
endfunction
function uBx takes nothing returns boolean
set yG[2]='AiS2'
call LZx('AiS2',false)
return true
endfunction
function ucx takes nothing returns boolean
set yG[0]='AiS0'
call LZx('AiS0',false)
return true
endfunction
function uCx takes nothing returns boolean
set wG[5]='AdS5'
call LZx('AdS5',false)
return true
endfunction
function udx takes nothing returns boolean
call VRx(qa,(function uix),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_decreasingSpells[6]_wc3spell.j"))
call VRx(qa,(function uax),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_decreasingSpells[0]_wc3spell.j"))
call VRx(qa,(function unx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_increasingSpells[6]_wc3spell.j"))
call VRx(qa,(function uVx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_increasingSpells[4]_wc3spell.j"))
call VRx(qa,(function uEx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_increasingSpells[3]_wc3spell.j"))
call VRx(qa,(function uXx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_decreasingSpells[2]_wc3spell.j"))
call VRx(qa,(function uOx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_decreasingSpells[1]_wc3spell.j"))
call VRx(ea,(function uRx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_this_wc3obj.j"))
call VRx(qa,(function uIx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_increasingSpells[5]_wc3spell.j"))
call VRx(qa,(function uAx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_decreasingSpells[4]_wc3spell.j"))
call VRx(qa,(function uNx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_decreasingSpells[3]_wc3spell.j"))
call VRx(qa,(function ubx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_increasingSpells[1]_wc3spell.j"))
call VRx(qa,(function uBx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_increasingSpells[2]_wc3spell.j"))
call VRx(qa,(function ucx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_increasingSpells[0]_wc3spell.j"))
call VRx(qa,(function uCx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_decreasingSpells[5]_wc3spell.j"))
return true
endfunction
function uDx takes nothing returns boolean
set edv=Vnx(eDv)
return true
endfunction
function ufx takes nothing returns boolean
set efv=Vnx(eFv)
return true
endfunction
function uFx takes nothing returns boolean
set egv=Vnx(eGv)
return true
endfunction
function ugx takes nothing returns boolean
call LZx('AHer',false)
return true
endfunction
function uGx takes nothing returns boolean
call LZx('aFly',false)
return true
endfunction
function uhx takes nothing returns boolean
call VRx(qa,(function ugx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\obj_skillMenuSpell_wc3spell.j"))
call VRx(qa,(function uGx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\obj_zEnablerSpell_wc3spell.j"))
return true
endfunction
function uHx takes nothing returns boolean
set ehv=Vnx(eHv)
return true
endfunction
function ujx takes nothing returns boolean
set ejv=Vnx(eJv)
return true
endfunction
function uJx takes nothing returns boolean
set ekv=Vnx(eKv)
return true
endfunction
function ukx takes nothing returns boolean
set elv=Vnx(eLv)
return true
endfunction
function uKx takes nothing returns boolean
set emv=Vnx(eMv)
return true
endfunction
function ulx takes nothing returns boolean
set epv=Vnx(ePv)
return true
endfunction
function uLx takes nothing returns boolean
set eqv=Vnx(eQv)
return true
endfunction
function umx takes nothing returns boolean
set esv=Vnx(eSv)
return true
endfunction
function uMx takes nothing returns boolean
set etv=Vnx(eTv)
return true
endfunction
function upx takes nothing returns boolean
set euv=Vnx(eUv)
return true
endfunction
function uPx takes nothing returns boolean
set ewv=Vnx(eWv)
return true
endfunction
function uqx takes nothing returns boolean
set eyv=Vnx(eYv)
return true
endfunction
function uQx takes nothing returns boolean
set ezv=Vnx(eZv)
return true
endfunction
function usx takes nothing returns boolean
set e_v=Vnx(e0v)
return true
endfunction
function uSx takes nothing returns boolean
set e1v=Vnx(e2v)
return true
endfunction
function utx takes nothing returns boolean
set e3v=Vnx(e4v)
return true
endfunction
function uTx takes nothing returns boolean
set e5v=Vnx(e6v)
return true
endfunction
function uux takes nothing returns boolean
set e7v=Vnx(e8v)
return true
endfunction
function uUx takes nothing returns boolean
set e9v=Vnx(xvv)
return true
endfunction
function uwx takes nothing returns boolean
set xev=Vnx(xxv)
return true
endfunction
function uWx takes nothing returns boolean
set xov=Vnx(xrv)
return true
endfunction
function uyx takes nothing returns boolean
set xiv=Vnx(xav)
return true
endfunction
function uYx takes nothing returns boolean
set xnv=Vnx(xVv)
return true
endfunction
function uzx takes nothing returns boolean
set kH=Vnx(gH)
return true
endfunction
function uZx takes nothing returns boolean
set xEv=Vnx(xXv)
return true
endfunction
function u_x takes integer oqx returns integer
set xbv[oqx]=true
set xBv[oqx]=false
call rax(R5)
return oqx
endfunction
function u0x takes nothing returns integer
local integer oqx
if(xRv==8190)then
call oYx("SoundType_Allocation_allocCustom","call DebugEx(SoundType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",I5+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(xIv[(w)]==w)then
set xAv=xAv+1
set oqx=xAv
else
set oqx=xIv[(w)]
set xIv[(w)]=xIv[xIv[(w)]]
endif
set xIv[oqx]=Z
set xNv[oqx]=1
call u_x(oqx)
return oqx
endfunction
function u1x takes nothing returns integer
local integer oqx=u0x()
set AC[(oqx)]=(null)
set bC[(oqx)]=(0)
set cC[(oqx)]=(D5)
set dC[(oqx)]=((1.)*1.)
set fC[(oqx)]=((1.)*1.)
set gC[(oqx)]=(1)
set hC[(oqx)]=((127.)*1.)
set jC[(oqx)]=((10.)*1.)
set kC[(oqx)]=((10.)*1.)
set KC[(oqx)]=(false)
set LC[(oqx)]=(false)
set MC[(oqx)]=(false)
set PC[(oqx)]=((.0)*1.)
set QC[(oqx)]=((.0)*1.)
set SC[(oqx)]=((.0)*1.)
set TC[(oqx)]=((.0)*1.)
set UC[(oqx)]=((.0)*1.)
set WC[(oqx)]=((.0)*1.)
set YC[(oqx)]=((.0)*1.)
set ZC[(oqx)]=((.0)*1.)
set ed[(oqx)]=((.0)*1.)
return oqx
endfunction
function u2x takes nothing returns boolean
set xOv=u1x()
set AC[(xOv)]=("Sound\\Ambient\\DoodadEffects\\FrostmourneLoopUndead01.wav")
set bC[(xOv)]=(J5)
set cC[(xOv)]=(h5)
set dC[(xOv)]=((1)*1.)
set fC[(xOv)]=((1)*1.)
set gC[(xOv)]=($A)
set hC[(xOv)]=((1)*1.)
set KC[(xOv)]=(true)
set MC[(xOv)]=(true)
set PC[(xOv)]=((600)*1.)
set QC[(xOv)]=(($186A0)*1.)
set SC[(xOv)]=(($7D0)*1.)
return true
endfunction
function u3x takes nothing returns boolean
set cH=lQx(xcv+" (dummyBuff)")
call lux(cH,"Unit_page\\Unit_struct\\Abilities\\Events\\Effect\\Channeling\\special.mdx","origin",ri)
call lTx(((cH)),nC,(xOv))
return true
endfunction
function u4x takes nothing returns boolean
call VRx(ma,(function u2x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Abilities\\Events\\Effect\\Channeling\\obj_loopSound_wc3sound.j"))
call VRx(Ma,(function u3x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Abilities\\Events\\Effect\\Channeling\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function u5x takes nothing returns boolean
set xCv=Vnx(xcv)
return true
endfunction
function u6x takes code c,string rqx returns nothing
set ta=ta+1
set Ta[ta]=CreateTrigger()
set ua[ta]=(GetHandleId(Condition((c))))
set Ua[ta]=rqx
call TriggerAddCondition(Ta[ta],Condition(c))
endfunction
function u7x takes integer oqx returns nothing
set xpv[oqx]=false
call rgx(xPv)
endfunction
function u8x takes integer oqx returns nothing
if(xLv[oqx]>0)then
return
endif
if(xmv[oqx]!=Z)then
call oYx("FolderUnit_FolderAnimation_StructLoop_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderAnimation_StructLoop.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",xMv+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set xmv[oqx]=xmv[(w)]
set xmv[(w)]=oqx
call u7x(oqx)
endfunction
function u9x takes integer oqx returns nothing
set xLv[oqx]=xLv[oqx]-1
call u8x(oqx)
endfunction
function Uvx takes integer oqx returns boolean
local integer okx=(xQv[(oqx)])
set xQv[xsv[xSv]]=okx
set xsv[okx-1]=xsv[xSv]
set xQv[oqx]=0
set xSv=xSv-1
return(xSv==F)
endfunction
function Uex takes integer oqx returns nothing
set Rd=oqx
call TriggerEvaluate(xTv)
endfunction
function Uxx takes integer oqx returns nothing
call Uex(oqx)
call SetUnitAnimation(C[((oqx))],("stand"))
call QueueUnitAnimation(C[((oqx))],("stand"))
endfunction
function Uox takes integer oqx,integer rkx returns nothing
call u9x((oqx))
call rix(rkx,xlv)
call Rmx(rkx,xqv)
if Uvx(oqx)then
call iHx(xtv)
endif
call Uxx(xuv[oqx])
endfunction
function Urx takes integer oqx returns nothing
local integer rkx=oqx
set oqx=oPx(rkx,xlv)
if(oqx!=w)then
call Uox(oqx,rkx)
endif
endfunction
function Uix takes integer oqx returns integer
set xpv[oqx]=true
set xWv[oqx]=false
call rax(xPv)
return oqx
endfunction
function Uax takes nothing returns integer
local integer oqx
if(xUv==8190)then
call oYx("FolderUnit_FolderAnimation_StructLoop_Allocation_allocCustom","call DebugEx(FolderUnit_FolderAnimation_StructLoop.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",xMv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(xmv[(w)]==w)then
set xwv=xwv+1
set oqx=xwv
else
set oqx=xmv[(w)]
set xmv[(w)]=xmv[xmv[(w)]]
endif
set xmv[oqx]=Z
set xLv[oqx]=1
call Uix(oqx)
return oqx
endfunction
function Unx takes integer oqx returns boolean
set xSv=xSv+1
set xsv[xSv]=oqx
set xQv[oqx]=xSv+1
return(xSv==0)
endfunction
function UVx takes integer oqx,string UEx returns nothing
call QueueUnitAnimation(C[(oqx)],UEx)
endfunction
function UXx takes nothing returns nothing
local integer olx=xSv
local integer oqx
loop
set oqx=xsv[olx]
call UVx(xuv[oqx],xyv[oqx])
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function UOx takes integer oqx,string UEx returns nothing
call SetUnitAnimation(C[(oqx)],UEx)
endfunction
function URx takes integer oqx,string UEx returns nothing
local integer rkx=oqx
call Urx((rkx))
set oqx=Uax()
set xuv[oqx]=rkx
set xyv[oqx]=UEx
call rTx(rkx,xlv,oqx)
call I7x(rkx,xqv)
if Unx(oqx)then
call icx(xtv,xYv,true,function UXx)
endif
call UOx(rkx,UEx)
endfunction
function UIx takes integer oqx returns nothing
call DSx(((oqx)),(xZv),(1),w)
endfunction
function UAx takes integer oqx returns nothing
call DSx(((oqx)),(x_v),(1),w)
endfunction
function UNx takes integer oqx returns nothing
set IH[oqx]=(IH[(oqx)])+1
endfunction
function Ubx takes integer oqx returns boolean
if((x0v[((oqx))])>0)then
return false
endif
set x1v=x1v+1
set x2v[x1v]=oqx
set x0v[oqx]=x1v+1
return(x1v==0)
endfunction
function UBx takes nothing returns nothing
local integer olx=x1v
loop
exitwhen(olx<0)
set x4v[olx]=x2v[olx]
set olx=olx-1
endloop
set x5v=x1v
endfunction
function Ucx takes nothing returns integer
local integer o4x
if(x5v<0)then
return w
endif
set o4x=x4v[0]
set x4v[0]=x4v[x5v]
set x5v=x5v-1
return o4x
endfunction
function UCx takes integer oqx,real dX,real dY returns real
if(Gyx(dX,dY)<1.)then
return(GetUnitFacing(C[((oqx))])*bh)
endif
return(Atan2(((dY)*1.),((dX)*1.)))
endfunction
function Udx takes integer oqx returns real
local integer dox=(uh[(oqx)])
local integer drx
if(dox!=w)then
return(GetItemX(Gh[((dox))]))
endif
set drx=(Uh[(oqx)])
if(drx!=w)then
return DPx(drx)
endif
return(wh[(oqx)])
endfunction
function UDx takes integer oqx returns real
local integer dox=(uh[(oqx)])
local integer drx
if(dox!=w)then
return(GetItemY(Gh[((dox))]))
endif
set drx=(Uh[(oqx)])
if(drx!=w)then
return DQx(drx)
endif
return(Wh[(oqx)])
endfunction
function Ufx takes integer oqx returns real
return(GetUnitFacing(C[(oqx)])*bh)
endfunction
function UFx takes integer oqx,real oSx returns nothing
call SetUnitFacing(C[(oqx)],oSx*gy)
endfunction
function Ugx takes integer oqx returns nothing
local integer CMx=oqx
local integer CQx=xfv[oqx]
local real N8x
if((x6v[((OH[(CQx)]))])!=0)then
set N8x=UCx(CMx,Udx(CQx)-DPx(CMx),UDx(CQx)-DQx(CMx))
if(Ufx(CMx)!=N8x)then
call UFx(CMx,N8x)
endif
endif
endfunction
function UGx takes nothing returns nothing
local integer oqx
call UBx()
loop
set oqx=Ucx()
exitwhen(oqx==w)
call Ugx(oqx)
endloop
endfunction
function Uhx takes integer oqx,real ilx returns nothing
call icx(x7v[oqx],ilx,false,null)
endfunction
function UHx takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local real ilx=CH
local integer CQx=dH
local integer Ixx=(Uh[(CQx)])
local integer oqx=CMx
local integer ibx=inx()
set xdv[oqx]=ibx
set xDv[oqx]=true
set xfv[oqx]=CQx
call I7x(CMx,xFv)
call I7x(CMx,xgv)
call I7x(CMx,xGv)
call I7x(CMx,xhv)
call I7x(CMx,xHv)
call I7x(CMx,xjv)
if(Ixx!=w)then
if rtx(Ixx,xJv,CMx)then
call I7x(Ixx,xkv)
call I7x(Ixx,xKv)
endif
endif
call icx(ibx,ilx+.01,false,null)
call URx((oqx),(xzv[((OH[(CQx)]))]))
call UIx((oqx))
call UAx((oqx))
call UNx(CQx)
if Ubx(oqx)then
call icx(x3v,.25,true,function UGx)
endif
call Ugx(oqx)
call Uhx(CMx,ilx)
return true
endfunction
function Ujx takes integer oqx returns boolean
if(((x0v[((oqx))])>0)==false)then
return false
endif
set x0v[x2v[x1v]]=x0v[oqx]
set x2v[x0v[oqx]-1]=x2v[x1v]
set x0v[oqx]=0
set x1v=x1v-1
return(x1v==F)
endfunction
function UJx takes integer oqx,integer Iox returns boolean
local integer Aqx=Rlx(X,vB,oqx,Iox,w)
if(Aqx==w)then
return false
endif
if Iox!=TB[Aqx]then
call oYx("FolderUnit_StructBuffs_Subtract","call DebugEx(I2S(LOCAL_REFS_KEY)+\"\t\t subtract CORRUPT buffref\"+whichBuff.GetName()+\";\"+I2S(whichBuff)+\";\"+I2S(whichRef)+\";\"+I2S(whichRef.whichBuff))",I2S(vB)+"\t\t subtract CORRUPT buffref"+(rD[(Iox)])+";"+I2S(Iox)+";"+I2S(Aqx)+";"+I2S(TB[Aqx]))
endif
call Awx(Aqx)
return true
endfunction
function Ukx takes integer oqx returns nothing
call UJx((oqx),xZv)
endfunction
function UKx takes integer oqx returns nothing
call UJx((oqx),x_v)
endfunction
function Ulx takes integer oqx returns nothing
call iHx(oqx)
set ce[(oqx)]=((.0)*1.)
endfunction
function ULx takes integer oqx returns nothing
call MoveLightningEx(x8v[oqx],false,.0,.0,.0,.0,.0,.0)
call MoveLightningEx(x9v[oqx],false,.0,.0,.0,.0,.0,.0)
call Ulx(x7v[oqx])
endfunction
function Umx takes integer CQx,boolean UMx returns nothing
local integer CMx=(aH[(CQx)])
local integer rwx=(XH[(CQx)])
local integer dox=(uh[(CQx)])
local integer drx=(Uh[(CQx)])
local real dix=(wh[(CQx)])
local real dax=(Wh[(CQx)])
local integer rJx=(OH[(CQx)])
local integer dnx=rEx((A[(CMx)]))
local integer rKx
local integer olx
local integer rIx
local integer rlx
set ovv[(dnx)]=(UMx)
set Mv[(dnx)]=(rwx)
set nv[(dnx)]=(rJx)
set uH[(dnx)]=(CQx)
set Vv[(dnx)]=(CMx)
set rKx=rEx((Ev[(rJx)]))
set ovv[(rKx)]=(UMx)
set Mv[(rKx)]=(rwx)
set nv[(rKx)]=(rJx)
set uH[(rKx)]=(CQx)
set Vv[(rKx)]=(CMx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rfx(rJx,oev,rIx)
loop
exitwhen(rlx<q)
call rCx(rFx(rJx,oev,rIx,rlx),rKx)
set rlx=rlx-1
endloop
set rlx=rfx(rJx,oxv,rIx)
if UMx then
loop
exitwhen(rlx<q)
call rCx(rFx(rJx,oxv,rIx,rlx),rKx)
set rlx=rlx-1
endloop
endif
set rlx=rOx(CMx,oev,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(CMx,oev,rIx,rlx),dnx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((dnx)))
call rHx(((rKx)))
endfunction
function Upx takes integer CQx,boolean UMx returns nothing
call Umx(CQx,UMx)
endfunction
function UPx takes integer oqx returns nothing
local integer oSx=(IH[(oqx)])-1
set IH[oqx]=oSx
if((oSx==0)and(AH[oqx]))then
call dRx((oqx))
endif
endfunction
function Uqx takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer oqx=CMx
local integer ibx=xdv[oqx]
local integer CQx=xfv[oqx]
local boolean UQx=((TimerGetRemaining(Oe[(ibx)]))<.1)
local integer Ixx=(Uh[(CQx)])
call ijx(ibx)
if Ujx(oqx)then
call iHx(x3v)
endif
set xDv[oqx]=false
call Rmx(CMx,xFv)
call Rmx(CMx,xgv)
call Rmx(CMx,xGv)
call Rmx(CMx,xhv)
call Rmx(CMx,xHv)
call Rmx(CMx,xjv)
if(Ixx!=w)then
if rrx(Ixx,xJv,CMx)then
call Rmx(Ixx,xkv)
call Rmx(Ixx,xKv)
endif
endif
call Uxx(CMx)
call Ukx(CMx)
call UKx(CMx)
call ULx(CMx)
call Upx(CQx,UQx)
call UPx(CQx)
return true
endfunction
function Usx takes nothing returns boolean
call l9x(cH,XBx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Buff_Init: call FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_BuffGain))",Bd,pI,function UHx))
call l9x(cH,XBx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Buff_Init: call FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_BuffLose))",Jc,pI,function Uqx))
return true
endfunction
function USx takes nothing returns boolean
call u6x(function Usx,"FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Buff_Init")
return true
endfunction
function Utx takes nothing returns boolean
call LZx('AUCU',false)
return true
endfunction
function UTx takes nothing returns boolean
call LZx('AUCQ',false)
return true
endfunction
function Uux takes nothing returns boolean
call LZx('AUCP',false)
return true
endfunction
function UUx takes nothing returns boolean
call LZx('AUCI',false)
return true
endfunction
function Uwx takes nothing returns boolean
call VRx(qa,(function Utx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Abilities\\Events\\Effect\\obj_unitDummySpell_wc3spell.j"))
call VRx(qa,(function UTx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Abilities\\Events\\Effect\\obj_pointOrUnitDummySpell_wc3spell.j"))
call VRx(qa,(function Uux),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Abilities\\Events\\Effect\\obj_pointDummySpell_wc3spell.j"))
call VRx(qa,(function UUx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Abilities\\Events\\Effect\\obj_immediateDummySpell_wc3spell.j"))
return true
endfunction
function UWx takes nothing returns boolean
set oov=Vnx(orv)
return true
endfunction
function Uyx takes nothing returns boolean
set oiv=Vnx(oav)
return true
endfunction
function UYx takes nothing returns boolean
set onv=Vnx(oVv)
return true
endfunction
function Uzx takes nothing returns boolean
set oEv=Vnx(oXv)
return true
endfunction
function UZx takes nothing returns boolean
set oOv=Vnx(oRv)
return true
endfunction
function U_x takes nothing returns boolean
set oIv=Vnx(oAv)
return true
endfunction
function U0x takes nothing returns boolean
set oNv=Vnx(obv)
return true
endfunction
function U1x takes nothing returns boolean
set oBv=Vnx(ocv)
return true
endfunction
function U2x takes nothing returns boolean
set oCv=Vnx(odv)
return true
endfunction
function U3x takes nothing returns boolean
set oDv=Vnx(ofv)
return true
endfunction
function U4x takes nothing returns boolean
set oFv=Vnx(ogv)
return true
endfunction
function U5x takes nothing returns boolean
set oGv=Vnx(ohv)
return true
endfunction
function U6x takes nothing returns boolean
set oHv=Vnx(ojv)
return true
endfunction
function U7x takes nothing returns boolean
set oJv=Vnx(okv)
return true
endfunction
function U8x takes nothing returns boolean
set Qd=Vnx(Pd)
return true
endfunction
function U9x takes nothing returns boolean
set jd=Vnx(fd)
return true
endfunction
function wvx takes nothing returns boolean
set oKv=Vnx(olv)
return true
endfunction
function wex takes nothing returns boolean
set oLv=Vnx(omv)
return true
endfunction
function wxx takes nothing returns boolean
set oMv=Vnx(opv)
return true
endfunction
function wox takes nothing returns boolean
set oPv=Vnx(oqv)
return true
endfunction
function wrx takes nothing returns boolean
set oQv=Vnx(osv)
return true
endfunction
function wix takes nothing returns boolean
set oSv=Vnx(otv)
return true
endfunction
function wax takes nothing returns boolean
set oTv=Vnx(ouv)
return true
endfunction
function wnx takes nothing returns boolean
set oUv=Vnx(owv)
return true
endfunction
function wVx takes nothing returns boolean
set oWv=Vnx(oyv)
return true
endfunction
function wEx takes nothing returns boolean
set oYv=Vnx(ozv)
return true
endfunction
function wXx takes nothing returns boolean
call LZx('Abrf',false)
return true
endfunction
function wOx takes nothing returns boolean
call LZx('Aetf',false)
return true
endfunction
function wRx takes nothing returns boolean
call LZx('Acpf',false)
return true
endfunction
function wIx takes nothing returns boolean
call VRx(qa,(function wXx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Type\\obj_changerBase_wc3spell.j"))
call VRx(qa,(function wOx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Type\\obj_changerCorporalRevert_wc3spell.j"))
call VRx(qa,(function wRx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Type\\obj_changerCorporal_wc3spell.j"))
return true
endfunction
function wAx takes nothing returns boolean
set oZv=Vnx(o_v)
return true
endfunction
function wNx takes nothing returns boolean
set o0v=Vnx(o1v)
return true
endfunction
function wbx takes nothing returns boolean
set o2v=Vnx(o3v)
return true
endfunction
function wBx takes nothing returns boolean
set o4v=Vnx(o5v)
return true
endfunction
function wcx takes nothing returns boolean
set o6v=Vnx(o7v)
return true
endfunction
function wCx takes nothing returns boolean
set o8v=Vnx(o9v)
return true
endfunction
function wdx takes nothing returns boolean
set rvv=Vnx(rev)
return true
endfunction
function wDx takes nothing returns boolean
set rxv=Vnx(rov)
return true
endfunction
function wfx takes nothing returns boolean
set rrv=Vnx(riv)
return true
endfunction
function wFx takes nothing returns boolean
set rav=Vnx(rnv)
return true
endfunction
function wgx takes nothing returns boolean
set rVv=Vnx(rEv)
return true
endfunction
function wGx takes nothing returns boolean
set rXv=Vnx(rOv)
return true
endfunction
function whx takes nothing returns boolean
set rRv=Vnx(rIv)
return true
endfunction
function wHx takes nothing returns boolean
set rAv=Vnx(rNv)
return true
endfunction
function wjx takes nothing returns boolean
set rbv=Vnx(rBv)
return true
endfunction
function wJx takes nothing returns boolean
return true
endfunction
function wkx takes nothing returns boolean
set rcv=Vnx(rCv)
return true
endfunction
function wKx takes nothing returns boolean
set rdv=Vnx(rDv)
return true
endfunction
function wlx takes nothing returns boolean
set rfv=Vnx(rFv)
return true
endfunction
function wLx takes nothing returns boolean
set rgv=Vnx(rGv)
return true
endfunction
function wmx takes nothing returns boolean
set rhv=Vnx(rHv)
return true
endfunction
function wMx takes nothing returns boolean
set rjv=Vnx(rJv)
return true
endfunction
function wpx takes nothing returns boolean
set rkv=Vnx(rKv)
return true
endfunction
function wPx takes nothing returns boolean
set rlv=Vnx(rLv)
return true
endfunction
function wqx takes nothing returns boolean
set rmv=Vnx(rMv)
return true
endfunction
function wQx takes nothing returns boolean
set rpv=Vnx(rPv)
return true
endfunction
function wsx takes nothing returns boolean
set rqv=Vnx(rQv)
return true
endfunction
function wSx takes nothing returns boolean
set xZv=lQx(rsv+" (disableBuff)")
return true
endfunction
function wtx takes nothing returns boolean
set rSv=lQx(rsv+" (normalBuff)")
call lux(rSv,"Abilities\\Spells\\Orc\\StasisTrap\\StasisTotemTarget.mdl","overhead",ri)
return true
endfunction
function wTx takes nothing returns boolean
call LZx('ADAI',false)
return true
endfunction
function wux takes nothing returns boolean
call LZx('Abun',false)
return true
endfunction
function wUx takes nothing returns boolean
call VRx(Ma,(function wSx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Attack\\obj_disableBuff_wc3buff.j"))
call VRx(Ma,(function wtx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Attack\\obj_normalBuff_wc3buff.j"))
call VRx(qa,(function wTx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Attack\\obj_iconSpell_wc3spell.j"))
call VRx(qa,(function wux),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Attack\\obj_disableSpell_wc3spell.j"))
return true
endfunction
function wwx takes nothing returns boolean
set rtv=Vnx(rsv)
return true
endfunction
function wWx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set rTv[((rkx))]=(false)
call rQx(rkx,'Abun')
call rQx(rkx,'ADAI')
return true
endfunction
function wyx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set rTv[((rkx))]=(true)
call UnitRemoveAbility(C[((rkx))],('Abun'))
call UnitRemoveAbility(C[((rkx))],('ADAI'))
return true
endfunction
function wYx takes nothing returns boolean
call l9x(xZv,XBx("FolderUnit_StructAttack_Buff_Init: call FolderUnit_StructAttack.DISABLE_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructAttack.Event_BuffGain))",Bd,pI,function wWx))
call l9x(xZv,XBx("FolderUnit_StructAttack_Buff_Init: call FolderUnit_StructAttack.DISABLE_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructAttack.Event_BuffLose))",Jc,pI,function wyx))
call l9x(rSv,XBx("FolderUnit_StructAttack_Buff_Init: call FolderUnit_StructAttack.NORMAL_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructAttack.Event_BuffGain))",Bd,pI,function wWx))
call l9x(rSv,XBx("FolderUnit_StructAttack_Buff_Init: call FolderUnit_StructAttack.NORMAL_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructAttack.Event_BuffLose))",Jc,pI,function wyx))
return true
endfunction
function wzx takes nothing returns boolean
call u6x(function wYx,"FolderUnit_StructAttack_Buff_Init")
return true
endfunction
function wZx takes nothing returns boolean
set ruv=Vnx(rUv)
return true
endfunction
function w_x takes nothing returns boolean
set rwv=Vnx(rWv)
return true
endfunction
function w0x takes nothing returns boolean
set ryv=Vnx(rYv)
return true
endfunction
function w1x takes nothing returns boolean
set rzv=Vnx(rZv)
return true
endfunction
function w2x takes nothing returns boolean
set r_v=Vnx(r0v)
return true
endfunction
function w3x takes nothing returns boolean
set r1v=Vnx(r2v)
return true
endfunction
function w4x takes nothing returns boolean
set r3v=Vnx(r4v)
return true
endfunction
function w5x takes nothing returns boolean
set r5v=Vnx(r6v)
return true
endfunction
function w6x takes nothing returns boolean
set r7v=Vnx(r8v)
return true
endfunction
function w7x takes nothing returns boolean
set r9v=lQx(ivv+" (dummyBuff)")
return true
endfunction
function w8x takes nothing returns boolean
call VRx(Ma,(function w7x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Death\\Explosion\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function w9x takes nothing returns boolean
set iev=Vnx(ivv)
return true
endfunction
function Wvx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
set ixv[(oqx)]=(true)
return true
endfunction
function Wex takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
set ixv[(oqx)]=(false)
return true
endfunction
function Wxx takes nothing returns boolean
call l9x(r9v,XBx("FolderUnit_FolderDeath_StructExplosion_Buff_Init: call FolderUnit_FolderDeath_StructExplosion.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderDeath_StructExplosion.Event_BuffGain))",Bd,pI,function Wvx))
call l9x(r9v,XBx("FolderUnit_FolderDeath_StructExplosion_Buff_Init: call FolderUnit_FolderDeath_StructExplosion.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderDeath_StructExplosion.Event_BuffLose))",Jc,pI,function Wex))
return true
endfunction
function Wox takes nothing returns boolean
call u6x(function Wxx,"FolderUnit_FolderDeath_StructExplosion_Buff_Init")
return true
endfunction
function Wrx takes nothing returns boolean
set iov=Vnx(irv)
return true
endfunction
function Wix takes nothing returns boolean
set iiv=lQx(iav+" (dummyBuff)")
call lux(iiv,"Unit_page\\Unit_struct\\Death\\Protection\\buff.mdx","chest",ri)
return true
endfunction
function Wax takes nothing returns boolean
call VRx(Ma,(function Wix),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Death\\Protection\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function Wnx takes nothing returns boolean
set inv=Vnx(iav)
return true
endfunction
function WVx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set aG[((rkx))]=(true)
return true
endfunction
function WEx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set aG[((rkx))]=(false)
return true
endfunction
function WXx takes nothing returns boolean
call l9x(iiv,XBx("FolderUnit_FolderDeath_StructProtection_Buff_Init: call FolderUnit_FolderDeath_StructProtection.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderDeath_StructProtection.Event_BuffGain))",Bd,pI,function WVx))
call l9x(iiv,XBx("FolderUnit_FolderDeath_StructProtection_Buff_Init: call FolderUnit_FolderDeath_StructProtection.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderDeath_StructProtection.Event_BuffLose))",Jc,pI,function WEx))
return true
endfunction
function WOx takes nothing returns boolean
call u6x(function WXx,"FolderUnit_FolderDeath_StructProtection_Buff_Init")
return true
endfunction
function WRx takes nothing returns boolean
set iVv=Vnx(iEv)
return true
endfunction
function WIx takes nothing returns boolean
set iXv=Vnx(iOv)
return true
endfunction
function WAx takes nothing returns boolean
set iRv=Vnx(iIv)
return true
endfunction
function WNx takes nothing returns boolean
set iAv=Vnx(iNv)
return true
endfunction
function Wbx takes nothing returns boolean
set ibv=Vnx(iBv)
return true
endfunction
function WBx takes nothing returns boolean
call LZx('AUUD',false)
return true
endfunction
function Wcx takes nothing returns boolean
call VRx(qa,(function WBx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Display\\obj_dummySpell_wc3spell.j"))
return true
endfunction
function WCx takes nothing returns boolean
set icv=Vnx(iCv)
return true
endfunction
function Wdx takes nothing returns boolean
set idv=Vnx(iDv)
return true
endfunction
function WDx takes nothing returns boolean
set ifv=Vnx(iFv)
return true
endfunction
function Wfx takes nothing returns boolean
set igv=Vnx(iGv)
return true
endfunction
function WFx takes nothing returns boolean
set ihv=Vnx(iHv)
return true
endfunction
function Wgx takes nothing returns boolean
set ijv=Vnx(iJv)
return true
endfunction
function WGx takes nothing returns boolean
set ikv=Vnx(iKv)
return true
endfunction
function Whx takes nothing returns boolean
set ilv=Vnx(iLv)
return true
endfunction
function WHx takes nothing returns boolean
set imv=Vnx(iMv)
return true
endfunction
function Wjx takes nothing returns boolean
set ipv=Vnx(iPv)
return true
endfunction
function WJx takes nothing returns boolean
set iqv=Vnx(iQv)
return true
endfunction
function Wkx takes nothing returns boolean
set isv=Vnx(iSv)
return true
endfunction
function WKx takes nothing returns boolean
set itv=Vnx(iTv)
return true
endfunction
function Wlx takes nothing returns boolean
set iuv=Vnx(iUv)
return true
endfunction
function WLx takes nothing returns boolean
set iwv=Vnx(iWv)
return true
endfunction
function Wmx takes nothing returns boolean
set iyv=Vnx(iYv)
return true
endfunction
function WMx takes nothing returns boolean
set izv=Vnx(iZv)
return true
endfunction
function Wpx takes nothing returns boolean
set i_v=Vnx(i0v)
return true
endfunction
function WPx takes nothing returns boolean
set i1v=Vnx(i2v)
return true
endfunction
function Wqx takes nothing returns boolean
set i3v=Vnx(i4v)
return true
endfunction
function WQx takes nothing returns boolean
return true
endfunction
function Wsx takes nothing returns boolean
set i5v=Vnx(i6v)
return true
endfunction
function WSx takes nothing returns boolean
return true
endfunction
function Wtx takes nothing returns boolean
set i7v=Vnx(i8v)
return true
endfunction
function WTx takes integer oMx,string rqx,integer QZx returns integer
local integer oqx=lMx()
set Zb[oqx]=oMx
call SaveInteger(o[((V[(E[((X))])]))],(((oMx))),(((ub))),(((oqx))))
call lpx(oqx)
set Yb[(oqx)]=(QZx)
set wd[(oqx)]=(false)
set qc[(oqx)]=(false)
set qU[(oqx)]=(false)
set rD[(oqx)]=(rqx)
set Yd[(oqx)]=(false)
set Sc[((oqx))]=(true)
call lPx(oqx)
call GetObjectName(((oMx)))
call LZx(QZx,false)
call Xkx((rD[(oqx)]),ub,oqx)
call lqx(oqx)
return oqx
endfunction
function Wux takes nothing returns boolean
set i9v=WTx('BIvu',"Invulnerable",'bIvu')
set avv[(i9v)]=(true)
set aev[(i9v)]=("ReplaceableTextures\\CommandButtons\\BTNInvulnerable.blp")
call lux(i9v,"Abilities\\Spells\\Human\\DivineShield\\DivineShieldTarget.mdl","origin",ri)
return true
endfunction
function WUx takes nothing returns boolean
set axv=lQx(aov+" (dummyBuff)")
return true
endfunction
function Wwx takes nothing returns boolean
set arv=lQx(aov+" (noneBuff)")
return true
endfunction
function WWx takes nothing returns boolean
call VRx(Ma,(function Wux),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Invulnerability\\obj_normalBuff_wc3buff.j"))
call VRx(Ma,(function WUx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Invulnerability\\obj_dummyBuff_wc3buff.j"))
call VRx(Ma,(function Wwx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Invulnerability\\obj_noneBuff_wc3buff.j"))
return true
endfunction
function Wyx takes nothing returns boolean
set aiv=Vnx(aov)
return true
endfunction
function WYx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set aav[((rkx))]=(true)
return true
endfunction
function Wzx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set aav[((rkx))]=(false)
return true
endfunction
function WZx takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(zB[(oqx)],(ZB[((oqx))]),oQx,oSx)
endfunction
function W_x takes integer oqx,integer W0x returns nothing
local integer rkx=oqx
call WZx(W0x,ad,rkx)
call WZx(rkx,Kc,W0x)
endfunction
function W1x takes nothing returns boolean
call l9x(axv,XBx("FolderUnit_StructInvulnerability_Buff_Init: call FolderUnit_StructInvulnerability.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructInvulnerability.Event_BuffGain))",Bd,BI,function WYx))
call l9x(axv,XBx("FolderUnit_StructInvulnerability_Buff_Init: call FolderUnit_StructInvulnerability.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructInvulnerability.Event_BuffLose))",Jc,BI,function Wzx))
call W_x(axv,i9v)
return true
endfunction
function W2x takes nothing returns boolean
call u6x(function W1x,"FolderUnit_StructInvulnerability_Buff_Init")
return true
endfunction
function W3x takes nothing returns boolean
set anv=Vnx(aVv)
return true
endfunction
function W4x takes nothing returns boolean
set aEv=Vnx(aXv)
return true
endfunction
function W5x takes nothing returns boolean
set aOv=Vnx(aRv)
return true
endfunction
function W6x takes nothing returns boolean
set aIv=Vnx(aAv)
return true
endfunction
function W7x takes nothing returns boolean
set aNv=Vnx(abv)
return true
endfunction
function W8x takes nothing returns boolean
set aBv=Vnx(acv)
return true
endfunction
function W9x takes nothing returns boolean
set aCv=Vnx(adv)
return true
endfunction
function yvx takes nothing returns boolean
set aDv=Vnx(afv)
return true
endfunction
function yex takes nothing returns boolean
set aFv=Vnx(agv)
return true
endfunction
function yxx takes nothing returns boolean
set aGv=Vnx(ahv)
return true
endfunction
function yox takes nothing returns boolean
set aHv=Vnx(ajv)
return true
endfunction
function yrx takes nothing returns boolean
set aJv=Vnx(akv)
return true
endfunction
function yix takes nothing returns boolean
set aKv=Vnx(alv)
return true
endfunction
function yax takes nothing returns boolean
set aLv=lQx(amv+" (dummyBuff)")
return true
endfunction
function ynx takes nothing returns boolean
set aMv=WTx('BMSP',"Spell Shield",'bMSP')
set avv[(aMv)]=(true)
set aev[(aMv)]=("ReplaceableTextures\\CommandButtons\\BTNRejuvenation.blp")
call lux(aMv,"Abilities\\Spells\\Items\\StaffOfSanctuary\\Staff_Sanctuary_Target.mdl","chest",ri)
return true
endfunction
function yVx takes nothing returns boolean
call VRx(Ma,(function yax),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\MagicImmunity\\SpellShield\\obj_dummyBuff_wc3buff.j"))
call VRx(Ma,(function ynx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\MagicImmunity\\SpellShield\\obj_normalBuff_wc3buff.j"))
return true
endfunction
function yEx takes nothing returns boolean
set apv=Vnx(amv)
return true
endfunction
function yXx takes nothing returns boolean
local integer rdx=(bv)
local integer Iox=(mc[(rdx)])
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
set aPv[(oqx)]=(true)
call rtx(rkx,aqv,Iox)
return true
endfunction
function yOx takes nothing returns boolean
local integer rdx=(bv)
local integer Iox=(mc[(rdx)])
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
set aPv[(oqx)]=(false)
call rrx(rkx,aqv,Iox)
return true
endfunction
function yRx takes nothing returns boolean
call l9x(aLv,XBx("FolderUnit_FolderMagicImmunity_StructSpellShield_Buff_Init: call FolderUnit_FolderMagicImmunity_StructSpellShield.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderMagicImmunity_StructSpellShield.Event_BuffGain))",Bd,BI,function yXx))
call l9x(aLv,XBx("FolderUnit_FolderMagicImmunity_StructSpellShield_Buff_Init: call FolderUnit_FolderMagicImmunity_StructSpellShield.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderMagicImmunity_StructSpellShield.Event_BuffLose))",Jc,BI,function yOx))
call W_x(aLv,aMv)
return true
endfunction
function yIx takes nothing returns boolean
call u6x(function yRx,"FolderUnit_FolderMagicImmunity_StructSpellShield_Buff_Init")
return true
endfunction
function yAx takes nothing returns boolean
set aQv=lQx(asv+" (dummyBuff)")
return true
endfunction
function yNx takes nothing returns boolean
set aSv=WTx('BMaI',"Magic immune",'bMaI')
set avv[(aSv)]=(true)
set aev[(aSv)]=("ReplaceableTextures\\CommandButtons\\BTNAntiMagicShell.blp")
call lux(aSv,"Abilities\\Spells\\Undead\\AntiMagicShell\\AntiMagicShell.mdl","overhead",ri)
return true
endfunction
function ybx takes nothing returns boolean
call VRx(Ma,(function yAx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\MagicImmunity\\obj_dummyBuff_wc3buff.j"))
call VRx(Ma,(function yNx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\MagicImmunity\\obj_normalBuff_wc3buff.j"))
return true
endfunction
function yBx takes nothing returns boolean
set atv=Vnx(asv)
return true
endfunction
function ycx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set aTv[((rkx))]=(true)
return true
endfunction
function yCx takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set aTv[((rkx))]=(false)
return true
endfunction
function ydx takes nothing returns boolean
call l9x(aQv,XBx("FolderUnit_StructMagicImmunity_Buff_Init: call FolderUnit_StructMagicImmunity.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructMagicImmunity.Event_BuffGain))",Bd,BI,function ycx))
call l9x(aQv,XBx("FolderUnit_StructMagicImmunity_Buff_Init: call FolderUnit_StructMagicImmunity.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructMagicImmunity.Event_BuffLose))",Jc,BI,function yCx))
call W_x(aQv,aSv)
return true
endfunction
function yDx takes nothing returns boolean
call u6x(function ydx,"FolderUnit_StructMagicImmunity_Buff_Init")
return true
endfunction
function yfx takes nothing returns boolean
set auv=Vnx(aUv)
return true
endfunction
function yFx takes nothing returns boolean
set cJ=Vnx(RJ)
return true
endfunction
function ygx takes nothing returns boolean
set Uj[20]='AC0K'
call LZx('AC0K',false)
return true
endfunction
function yGx takes nothing returns boolean
set Uj[$C]='AC0C'
call LZx('AC0C',false)
return true
endfunction
function yhx takes nothing returns boolean
set Uj[$86]='AC3Q'
call LZx('AC3Q',false)
return true
endfunction
function yHx takes nothing returns boolean
set Uj['v']='AC3A'
call LZx('AC3A',false)
return true
endfunction
function yjx takes nothing returns boolean
set Uj[$88]='AC3S'
call LZx('AC3S',false)
return true
endfunction
function yJx takes nothing returns boolean
set Uj[$8A]='AC3U'
call LZx('AC3U',false)
return true
endfunction
function ykx takes nothing returns boolean
set Uj['f']='AC2U'
call LZx('AC2U',false)
return true
endfunction
function yKx takes nothing returns boolean
set Uj[$8C]='AC3W'
call LZx('AC3W',false)
return true
endfunction
function ylx takes nothing returns boolean
set Uj[19]='AC0J'
call LZx('AC0J',false)
return true
endfunction
function yLx takes nothing returns boolean
set Uj[$8F]='AC3Z'
call LZx('AC3Z',false)
return true
endfunction
function ymx takes nothing returns boolean
set Uj[$91]='AC41'
call LZx('AC41',false)
return true
endfunction
function yMx takes nothing returns boolean
set Uj[$92]='AC42'
call LZx('AC42',false)
return true
endfunction
function ypx takes nothing returns boolean
set Uj['l']='AC30'
call LZx('AC30',false)
return true
endfunction
function yPx takes nothing returns boolean
set Uj[$98]='AC48'
call LZx('AC48',false)
return true
endfunction
function yqx takes nothing returns boolean
set Uj[$9A]='AC4A'
call LZx('AC4A',false)
return true
endfunction
function yQx takes nothing returns boolean
set Uj[$9C]='AC4C'
call LZx('AC4C',false)
return true
endfunction
function ysx takes nothing returns boolean
set Uj[$9D]='AC4D'
call LZx('AC4D',false)
return true
endfunction
function ySx takes nothing returns boolean
set Uj[$9E]='AC4E'
call LZx('AC4E',false)
return true
endfunction
function ytx takes nothing returns boolean
set Uj[$93]='AC43'
call LZx('AC43',false)
return true
endfunction
function yTx takes nothing returns boolean
set Uj[$A0]='AC4G'
call LZx('AC4G',false)
return true
endfunction
function yux takes nothing returns boolean
set Uj[$A5]='AC4L'
call LZx('AC4L',false)
return true
endfunction
function yUx takes nothing returns boolean
set Uj[$A7]='AC4N'
call LZx('AC4N',false)
return true
endfunction
function ywx takes nothing returns boolean
set Uj['k']='AC2Z'
call LZx('AC2Z',false)
return true
endfunction
function yWx takes nothing returns boolean
set Uj[$A9]='AC4P'
call LZx('AC4P',false)
return true
endfunction
function yyx takes nothing returns boolean
set Uj[$AA]='AC4Q'
call LZx('AC4Q',false)
return true
endfunction
function yYx takes nothing returns boolean
set Uj[$AD]='AC4T'
call LZx('AC4T',false)
return true
endfunction
function yzx takes nothing returns boolean
set Uj[$B3]='AC4Z'
call LZx('AC4Z',false)
return true
endfunction
function yZx takes nothing returns boolean
set Uj[$B5]='AC51'
call LZx('AC51',false)
return true
endfunction
function y_x takes nothing returns boolean
set Uj['p']='AC34'
call LZx('AC34',false)
return true
endfunction
function y0x takes nothing returns boolean
set Uj[$B6]='AC52'
call LZx('AC52',false)
return true
endfunction
function y1x takes nothing returns boolean
set Uj['h']='AC2W'
call LZx('AC2W',false)
return true
endfunction
function y2x takes nothing returns boolean
set Uj[$BD]='AC59'
call LZx('AC59',false)
return true
endfunction
function y3x takes nothing returns boolean
set Uj[$96]='AC46'
call LZx('AC46',false)
return true
endfunction
function y4x takes nothing returns boolean
set Uj[$BE]='AC5A'
call LZx('AC5A',false)
return true
endfunction
function y5x takes nothing returns boolean
set Uj[$C0]='AC5C'
call LZx('AC5C',false)
return true
endfunction
function y6x takes nothing returns boolean
set Uj[$C1]='AC5D'
call LZx('AC5D',false)
return true
endfunction
function y7x takes nothing returns boolean
set Uj[$C2]='AC5E'
call LZx('AC5E',false)
return true
endfunction
function y8x takes nothing returns boolean
set Uj[$C3]='AC5F'
call LZx('AC5F',false)
return true
endfunction
function y9x takes nothing returns boolean
set Uj[$C8]='AC5K'
call LZx('AC5K',false)
return true
endfunction
function Yvx takes nothing returns boolean
set Uj[$CC]='AC5O'
call LZx('AC5O',false)
return true
endfunction
function Yex takes nothing returns boolean
set Uj[$CF]='AC5R'
call LZx('AC5R',false)
return true
endfunction
function Yxx takes nothing returns boolean
set Uj[$D0]='AC5S'
call LZx('AC5S',false)
return true
endfunction
function Yox takes nothing returns boolean
set Uj[$D2]='AC5U'
call LZx('AC5U',false)
return true
endfunction
function Yrx takes nothing returns boolean
set Uj[$D3]='AC5V'
call LZx('AC5V',false)
return true
endfunction
function Yix takes nothing returns boolean
set Uj[$DC]='AC64'
call LZx('AC64',false)
return true
endfunction
function Yax takes nothing returns boolean
set Uj[$DE]='AC66'
call LZx('AC66',false)
return true
endfunction
function Ynx takes nothing returns boolean
set Uj[$E1]='AC69'
call LZx('AC69',false)
return true
endfunction
function YVx takes nothing returns boolean
set Uj[$E2]='AC6A'
call LZx('AC6A',false)
return true
endfunction
function YEx takes nothing returns boolean
set Uj[$E3]='AC6B'
call LZx('AC6B',false)
return true
endfunction
function YXx takes nothing returns boolean
set Uj[$E6]='AC6E'
call LZx('AC6E',false)
return true
endfunction
function YOx takes nothing returns boolean
set Uj[$E8]='AC6G'
call LZx('AC6G',false)
return true
endfunction
function YRx takes nothing returns boolean
set Uj[$E9]='AC6H'
call LZx('AC6H',false)
return true
endfunction
function YIx takes nothing returns boolean
set Uj[$EA]='AC6I'
call LZx('AC6I',false)
return true
endfunction
function YAx takes nothing returns boolean
set Uj[$EB]='AC6J'
call LZx('AC6J',false)
return true
endfunction
function YNx takes nothing returns boolean
set Uj[$EE]='AC6M'
call LZx('AC6M',false)
return true
endfunction
function Ybx takes nothing returns boolean
set Uj[$F2]='AC6Q'
call LZx('AC6Q',false)
return true
endfunction
function YBx takes nothing returns boolean
set Uj[$F3]='AC6R'
call LZx('AC6R',false)
return true
endfunction
function Ycx takes nothing returns boolean
set Uj[$F4]='AC6S'
call LZx('AC6S',false)
return true
endfunction
function YCx takes nothing returns boolean
set Uj[$F5]='AC6T'
call LZx('AC6T',false)
return true
endfunction
function Ydx takes nothing returns boolean
set Uj[$F6]='AC6U'
call LZx('AC6U',false)
return true
endfunction
function YDx takes nothing returns boolean
set Uj[$F7]='AC6V'
call LZx('AC6V',false)
return true
endfunction
function Yfx takes nothing returns boolean
set Uj[$FA]='AC6Y'
call LZx('AC6Y',false)
return true
endfunction
function YFx takes nothing returns boolean
set Uj[$FB]='AC6Z'
call LZx('AC6Z',false)
return true
endfunction
function Ygx takes nothing returns boolean
set Uj[$FC]='AC70'
call LZx('AC70',false)
return true
endfunction
function YGx takes nothing returns boolean
set Uj[$FE]='AC72'
call LZx('AC72',false)
return true
endfunction
function Yhx takes nothing returns boolean
set Uj[256]='AC74'
call LZx('AC74',false)
return true
endfunction
function YHx takes nothing returns boolean
set Uj[257]='AC75'
call LZx('AC75',false)
return true
endfunction
function Yjx takes nothing returns boolean
set Uj[258]='AC76'
call LZx('AC76',false)
return true
endfunction
function YJx takes nothing returns boolean
set Uj[259]='AC77'
call LZx('AC77',false)
return true
endfunction
function Ykx takes nothing returns boolean
set Uj[260]='AC78'
call LZx('AC78',false)
return true
endfunction
function YKx takes nothing returns boolean
set Uj[261]='AC79'
call LZx('AC79',false)
return true
endfunction
function Ylx takes nothing returns boolean
set Uj[263]='AC7B'
call LZx('AC7B',false)
return true
endfunction
function YLx takes nothing returns boolean
set Uj[266]='AC7E'
call LZx('AC7E',false)
return true
endfunction
function Ymx takes nothing returns boolean
set Uj[267]='AC7F'
call LZx('AC7F',false)
return true
endfunction
function YMx takes nothing returns boolean
set Uj[268]='AC7G'
call LZx('AC7G',false)
return true
endfunction
function Ypx takes nothing returns boolean
set Uj[269]='AC7H'
call LZx('AC7H',false)
return true
endfunction
function YPx takes nothing returns boolean
set Uj[270]='AC7I'
call LZx('AC7I',false)
return true
endfunction
function Yqx takes nothing returns boolean
set Uj[275]='AC7N'
call LZx('AC7N',false)
return true
endfunction
function YQx takes nothing returns boolean
set Uj[427]='ACBV'
call LZx('ACBV',false)
return true
endfunction
function Ysx takes nothing returns boolean
set Uj[276]='AC7O'
call LZx('AC7O',false)
return true
endfunction
function YSx takes nothing returns boolean
set Uj[277]='AC7P'
call LZx('AC7P',false)
return true
endfunction
function Ytx takes nothing returns boolean
set Uj[278]='AC7Q'
call LZx('AC7Q',false)
return true
endfunction
function YTx takes nothing returns boolean
set Uj[279]='AC7R'
call LZx('AC7R',false)
return true
endfunction
function Yux takes nothing returns boolean
set Uj[27]='AC0R'
call LZx('AC0R',false)
return true
endfunction
function YUx takes nothing returns boolean
set Uj[282]='AC7U'
call LZx('AC7U',false)
return true
endfunction
function Ywx takes nothing returns boolean
set Uj[284]='AC7W'
call LZx('AC7W',false)
return true
endfunction
function YWx takes nothing returns boolean
set Uj['d']='AC2S'
call LZx('AC2S',false)
return true
endfunction
function Yyx takes nothing returns boolean
set Uj[286]='AC7Y'
call LZx('AC7Y',false)
return true
endfunction
function YYx takes nothing returns boolean
set Uj[289]='AC81'
call LZx('AC81',false)
return true
endfunction
function Yzx takes nothing returns boolean
set Uj[290]='AC82'
call LZx('AC82',false)
return true
endfunction
function YZx takes nothing returns boolean
set Uj[291]='AC83'
call LZx('AC83',false)
return true
endfunction
function Y_x takes nothing returns boolean
set Uj[292]='AC84'
call LZx('AC84',false)
return true
endfunction
function Y0x takes nothing returns boolean
set Uj[$E]='AC0E'
call LZx('AC0E',false)
return true
endfunction
function Y1x takes nothing returns boolean
set Uj[294]='AC86'
call LZx('AC86',false)
return true
endfunction
function Y2x takes nothing returns boolean
set Uj[295]='AC87'
call LZx('AC87',false)
return true
endfunction
function Y3x takes nothing returns boolean
set Uj[298]='AC8A'
call LZx('AC8A',false)
return true
endfunction
function Y4x takes nothing returns boolean
set Uj[299]='AC8B'
call LZx('AC8B',false)
return true
endfunction
function Y5x takes nothing returns boolean
set Uj[301]='AC8D'
call LZx('AC8D',false)
return true
endfunction
function Y6x takes nothing returns boolean
set Uj[302]='AC8E'
call LZx('AC8E',false)
return true
endfunction
function Y7x takes nothing returns boolean
set Uj['g']='AC2V'
call LZx('AC2V',false)
return true
endfunction
function Y8x takes nothing returns boolean
set Uj[303]='AC8F'
call LZx('AC8F',false)
return true
endfunction
function Y9x takes nothing returns boolean
set Uj[304]='AC8G'
call LZx('AC8G',false)
return true
endfunction
function zvx takes nothing returns boolean
set Uj[305]='AC8H'
call LZx('AC8H',false)
return true
endfunction
function zex takes nothing returns boolean
set Uj[306]='AC8I'
call LZx('AC8I',false)
return true
endfunction
function zxx takes nothing returns boolean
set Uj[307]='AC8J'
call LZx('AC8J',false)
return true
endfunction
function zox takes nothing returns boolean
set Uj[308]='AC8K'
call LZx('AC8K',false)
return true
endfunction
function zrx takes nothing returns boolean
set Uj[30]='AC0U'
call LZx('AC0U',false)
return true
endfunction
function zix takes nothing returns boolean
set Uj[310]='AC8M'
call LZx('AC8M',false)
return true
endfunction
function zax takes nothing returns boolean
set Uj[311]='AC8N'
call LZx('AC8N',false)
return true
endfunction
function znx takes nothing returns boolean
set Uj[312]='AC8O'
call LZx('AC8O',false)
return true
endfunction
function zVx takes nothing returns boolean
set Uj[313]='AC8P'
call LZx('AC8P',false)
return true
endfunction
function zEx takes nothing returns boolean
set Uj['i']='AC2X'
call LZx('AC2X',false)
return true
endfunction
function zXx takes nothing returns boolean
set Uj[317]='AC8T'
call LZx('AC8T',false)
return true
endfunction
function zOx takes nothing returns boolean
set Uj[319]='AC8V'
call LZx('AC8V',false)
return true
endfunction
function zRx takes nothing returns boolean
set Uj[83]='AC2B'
call LZx('AC2B',false)
return true
endfunction
function zIx takes nothing returns boolean
set Uj[321]='AC8X'
call LZx('AC8X',false)
return true
endfunction
function zAx takes nothing returns boolean
set Uj[322]='AC8Y'
call LZx('AC8Y',false)
return true
endfunction
function zNx takes nothing returns boolean
set Uj[323]='AC8Z'
call LZx('AC8Z',false)
return true
endfunction
function zbx takes nothing returns boolean
set Uj[326]='AC92'
call LZx('AC92',false)
return true
endfunction
function zBx takes nothing returns boolean
set Uj['j']='AC2Y'
call LZx('AC2Y',false)
return true
endfunction
function zcx takes nothing returns boolean
set Uj[1]='AC01'
call LZx('AC01',false)
return true
endfunction
function zCx takes nothing returns boolean
set Uj[327]='AC93'
call LZx('AC93',false)
return true
endfunction
function zdx takes nothing returns boolean
set Uj[9]='AC09'
call LZx('AC09',false)
return true
endfunction
function zDx takes nothing returns boolean
set Uj[331]='AC97'
call LZx('AC97',false)
return true
endfunction
function zfx takes nothing returns boolean
set Uj[335]='AC9B'
call LZx('AC9B',false)
return true
endfunction
function zFx takes nothing returns boolean
set Uj[336]='AC9C'
call LZx('AC9C',false)
return true
endfunction
function zgx takes nothing returns boolean
set Uj[337]='AC9D'
call LZx('AC9D',false)
return true
endfunction
function zGx takes nothing returns boolean
set Uj[339]='AC9F'
call LZx('AC9F',false)
return true
endfunction
function zhx takes nothing returns boolean
set Uj[340]='AC9G'
call LZx('AC9G',false)
return true
endfunction
function zHx takes nothing returns boolean
set EJ=lQx(awv+" (transBuff)")
set qc[(EJ)]=(true)
return true
endfunction
function zjx takes nothing returns boolean
set Uj[341]='AC9H'
call LZx('AC9H',false)
return true
endfunction
function zJx takes nothing returns boolean
set Uj[346]='AC9M'
call LZx('AC9M',false)
return true
endfunction
function zkx takes nothing returns boolean
set Uj[347]='AC9N'
call LZx('AC9N',false)
return true
endfunction
function zKx takes nothing returns boolean
set Uj[34]='AC0Y'
call LZx('AC0Y',false)
return true
endfunction
function zlx takes nothing returns boolean
set Uj[350]='AC9Q'
call LZx('AC9Q',false)
return true
endfunction
function zLx takes nothing returns boolean
set Uj[351]='AC9R'
call LZx('AC9R',false)
return true
endfunction
function zmx takes nothing returns boolean
set Uj[352]='AC9S'
call LZx('AC9S',false)
return true
endfunction
function zMx takes nothing returns boolean
set Uj[355]='AC9V'
call LZx('AC9V',false)
return true
endfunction
function zpx takes nothing returns boolean
set Uj[358]='AC9Y'
call LZx('AC9Y',false)
return true
endfunction
function zPx takes nothing returns boolean
set Uj[359]='AC9Z'
call LZx('AC9Z',false)
return true
endfunction
function zqx takes nothing returns boolean
set Uj[$D]='AC0D'
call LZx('AC0D',false)
return true
endfunction
function zQx takes nothing returns boolean
set Uj[35]='AC0Z'
call LZx('AC0Z',false)
return true
endfunction
function zsx takes nothing returns boolean
set Uj[360]='ACA0'
call LZx('ACA0',false)
return true
endfunction
function zSx takes nothing returns boolean
set Uj[361]='ACA1'
call LZx('ACA1',false)
return true
endfunction
function ztx takes nothing returns boolean
set Uj[364]='ACA4'
call LZx('ACA4',false)
return true
endfunction
function zTx takes nothing returns boolean
set Uj[367]='ACA7'
call LZx('ACA7',false)
return true
endfunction
function zux takes nothing returns boolean
set Uj[36]='AC10'
call LZx('AC10',false)
return true
endfunction
function zUx takes nothing returns boolean
set Uj[370]='ACAA'
call LZx('ACAA',false)
return true
endfunction
function zwx takes nothing returns boolean
set Uj[371]='ACAB'
call LZx('ACAB',false)
return true
endfunction
function zWx takes nothing returns boolean
set Uj[372]='ACAC'
call LZx('ACAC',false)
return true
endfunction
function zyx takes nothing returns boolean
set Uj[375]='ACAF'
call LZx('ACAF',false)
return true
endfunction
function zYx takes nothing returns boolean
set Uj[376]='ACAG'
call LZx('ACAG',false)
return true
endfunction
function zzx takes nothing returns boolean
set Uj[37]='AC11'
call LZx('AC11',false)
return true
endfunction
function zZx takes nothing returns boolean
set Uj['u']='AC39'
call LZx('AC39',false)
return true
endfunction
function z_x takes nothing returns boolean
set Uj[380]='ACAK'
call LZx('ACAK',false)
return true
endfunction
function z0x takes nothing returns boolean
set Uj[381]='ACAL'
call LZx('ACAL',false)
return true
endfunction
function z1x takes nothing returns boolean
set Uj[382]='ACAM'
call LZx('ACAM',false)
return true
endfunction
function z2x takes nothing returns boolean
set Uj[383]='ACAN'
call LZx('ACAN',false)
return true
endfunction
function z3x takes nothing returns boolean
set Uj[384]='ACAO'
call LZx('ACAO',false)
return true
endfunction
function z4x takes nothing returns boolean
set Uj[385]='ACAP'
call LZx('ACAP',false)
return true
endfunction
function z5x takes nothing returns boolean
set Uj[387]='ACAR'
call LZx('ACAR',false)
return true
endfunction
function z6x takes nothing returns boolean
set Uj[388]='ACAS'
call LZx('ACAS',false)
return true
endfunction
function z7x takes nothing returns boolean
set Uj[389]='ACAT'
call LZx('ACAT',false)
return true
endfunction
function z8x takes nothing returns boolean
set Uj[38]='AC12'
call LZx('AC12',false)
return true
endfunction
function z9x takes nothing returns boolean
set Uj[391]='ACAV'
call LZx('ACAV',false)
return true
endfunction
function Zvx takes nothing returns boolean
set Uj[392]='ACAW'
call LZx('ACAW',false)
return true
endfunction
function Zex takes nothing returns boolean
set Uj[393]='ACAX'
call LZx('ACAX',false)
return true
endfunction
function Zxx takes nothing returns boolean
set Uj[395]='ACAZ'
call LZx('ACAZ',false)
return true
endfunction
function Zox takes nothing returns boolean
set Uj[396]='ACB0'
call LZx('ACB0',false)
return true
endfunction
function Zrx takes nothing returns boolean
set Uj[296]='AC88'
call LZx('AC88',false)
return true
endfunction
function Zix takes nothing returns boolean
set Uj[280]='AC7S'
call LZx('AC7S',false)
return true
endfunction
function Zax takes nothing returns boolean
set Uj[400]='ACB4'
call LZx('ACB4',false)
return true
endfunction
function Znx takes nothing returns boolean
set Uj[403]='ACB7'
call LZx('ACB7',false)
return true
endfunction
function ZVx takes nothing returns boolean
set Uj[404]='ACB8'
call LZx('ACB8',false)
return true
endfunction
function ZEx takes nothing returns boolean
set Uj[405]='ACB9'
call LZx('ACB9',false)
return true
endfunction
function ZXx takes nothing returns boolean
set Uj[40]='AC14'
call LZx('AC14',false)
return true
endfunction
function ZOx takes nothing returns boolean
set Uj[413]='ACBH'
call LZx('ACBH',false)
return true
endfunction
function ZRx takes nothing returns boolean
set Uj[417]='ACBL'
call LZx('ACBL',false)
return true
endfunction
function ZIx takes nothing returns boolean
set Uj[419]='ACBN'
call LZx('ACBN',false)
return true
endfunction
function ZAx takes nothing returns boolean
set Uj[41]='AC15'
call LZx('AC15',false)
return true
endfunction
function ZNx takes nothing returns boolean
set Uj[420]='ACBO'
call LZx('ACBO',false)
return true
endfunction
function Zbx takes nothing returns boolean
set Uj[285]='AC7X'
call LZx('AC7X',false)
return true
endfunction
function ZBx takes nothing returns boolean
set Uj[421]='ACBP'
call LZx('ACBP',false)
return true
endfunction
function Zcx takes nothing returns boolean
set Uj[422]='ACBQ'
call LZx('ACBQ',false)
return true
endfunction
function ZCx takes nothing returns boolean
set Uj[423]='ACBR'
call LZx('ACBR',false)
return true
endfunction
function Zdx takes nothing returns boolean
set Uj[424]='ACBS'
call LZx('ACBS',false)
return true
endfunction
function ZDx takes nothing returns boolean
set Uj[425]='ACBT'
call LZx('ACBT',false)
return true
endfunction
function Zfx takes nothing returns boolean
set Uj[429]='ACBX'
call LZx('ACBX',false)
return true
endfunction
function ZFx takes nothing returns boolean
set Uj[42]='AC16'
call LZx('AC16',false)
return true
endfunction
function Zgx takes nothing returns boolean
set Uj[431]='ACBZ'
call LZx('ACBZ',false)
return true
endfunction
function ZGx takes nothing returns boolean
set Uj[433]='ACC1'
call LZx('ACC1',false)
return true
endfunction
function Zhx takes nothing returns boolean
set Uj[436]='ACC4'
call LZx('ACC4',false)
return true
endfunction
function ZHx takes nothing returns boolean
set Uj[$A]='AC0A'
call LZx('AC0A',false)
return true
endfunction
function Zjx takes nothing returns boolean
set Uj[43]='AC17'
call LZx('AC17',false)
return true
endfunction
function ZJx takes nothing returns boolean
set Uj[442]='ACCA'
call LZx('ACCA',false)
return true
endfunction
function Zkx takes nothing returns boolean
set Uj[5]='AC05'
call LZx('AC05',false)
return true
endfunction
function ZKx takes nothing returns boolean
set Uj[$7F]='AC3J'
call LZx('AC3J',false)
return true
endfunction
function Zlx takes nothing returns boolean
set Uj[445]='ACCD'
call LZx('ACCD',false)
return true
endfunction
function ZLx takes nothing returns boolean
set Uj[447]='ACCF'
call LZx('ACCF',false)
return true
endfunction
function Zmx takes nothing returns boolean
set Uj[363]='ACA3'
call LZx('ACA3',false)
return true
endfunction
function ZMx takes nothing returns boolean
set Uj[44]='AC18'
call LZx('AC18',false)
return true
endfunction
function Zpx takes nothing returns boolean
set Uj[452]='ACCK'
call LZx('ACCK',false)
return true
endfunction
function ZPx takes nothing returns boolean
set Uj[456]='ACCO'
call LZx('ACCO',false)
return true
endfunction
function Zqx takes nothing returns boolean
set Uj[458]='ACCQ'
call LZx('ACCQ',false)
return true
endfunction
function ZQx takes nothing returns boolean
set Uj[459]='ACCR'
call LZx('ACCR',false)
return true
endfunction
function Zsx takes nothing returns boolean
set Uj[460]='ACCS'
call LZx('ACCS',false)
return true
endfunction
function ZSx takes nothing returns boolean
set Uj[461]='ACCT'
call LZx('ACCT',false)
return true
endfunction
function Ztx takes nothing returns boolean
set Uj[462]='ACCU'
call LZx('ACCU',false)
return true
endfunction
function ZTx takes nothing returns boolean
set Uj[463]='ACCV'
call LZx('ACCV',false)
return true
endfunction
function Zux takes nothing returns boolean
set Uj[464]='ACCW'
call LZx('ACCW',false)
return true
endfunction
function ZUx takes nothing returns boolean
set Uj[465]='ACCX'
call LZx('ACCX',false)
return true
endfunction
function Zwx takes nothing returns boolean
set Uj[467]='ACCZ'
call LZx('ACCZ',false)
return true
endfunction
function ZWx takes nothing returns boolean
set Uj[8]='AC08'
call LZx('AC08',false)
return true
endfunction
function Zyx takes nothing returns boolean
set Uj[468]='ACD0'
call LZx('ACD0',false)
return true
endfunction
function ZYx takes nothing returns boolean
set Uj[470]='ACD2'
call LZx('ACD2',false)
return true
endfunction
function Zzx takes nothing returns boolean
set Uj[471]='ACD3'
call LZx('ACD3',false)
return true
endfunction
function ZZx takes nothing returns boolean
set Uj[473]='ACD5'
call LZx('ACD5',false)
return true
endfunction
function Z_x takes nothing returns boolean
set Uj[475]='ACD7'
call LZx('ACD7',false)
return true
endfunction
function Z0x takes nothing returns boolean
set Uj[476]='ACD8'
call LZx('ACD8',false)
return true
endfunction
function Z1x takes nothing returns boolean
set Uj[478]='ACDA'
call LZx('ACDA',false)
return true
endfunction
function Z2x takes nothing returns boolean
set Uj[479]='ACDB'
call LZx('ACDB',false)
return true
endfunction
function Z3x takes nothing returns boolean
set Uj[47]='AC1B'
call LZx('AC1B',false)
return true
endfunction
function Z4x takes nothing returns boolean
set Uj[480]='ACDC'
call LZx('ACDC',false)
return true
endfunction
function Z5x takes nothing returns boolean
set Uj[482]='ACDE'
call LZx('ACDE',false)
return true
endfunction
function Z6x takes nothing returns boolean
set Uj[484]='ACDG'
call LZx('ACDG',false)
return true
endfunction
function Z7x takes nothing returns boolean
set Uj[487]='ACDJ'
call LZx('ACDJ',false)
return true
endfunction
function Z8x takes nothing returns boolean
set Uj[488]='ACDK'
call LZx('ACDK',false)
return true
endfunction
function Z9x takes nothing returns boolean
set Uj[489]='ACDL'
call LZx('ACDL',false)
return true
endfunction
function vvo takes nothing returns boolean
set Uj[48]='AC1C'
call LZx('AC1C',false)
return true
endfunction
function veo takes nothing returns boolean
set Uj[490]='ACDM'
call LZx('ACDM',false)
return true
endfunction
function vxo takes nothing returns boolean
set Uj[491]='ACDN'
call LZx('ACDN',false)
return true
endfunction
function voo takes nothing returns boolean
set Uj['x']='AC3C'
call LZx('AC3C',false)
return true
endfunction
function vro takes nothing returns boolean
set Uj[492]='ACDO'
call LZx('ACDO',false)
return true
endfunction
function vio takes nothing returns boolean
set Uj[493]='ACDP'
call LZx('ACDP',false)
return true
endfunction
function vao takes nothing returns boolean
set Uj[494]='ACDQ'
call LZx('ACDQ',false)
return true
endfunction
function vno takes nothing returns boolean
set Uj[495]='ACDR'
call LZx('ACDR',false)
return true
endfunction
function vVo takes nothing returns boolean
set Uj[498]='ACDU'
call LZx('ACDU',false)
return true
endfunction
function vEo takes nothing returns boolean
set Uj[500]='ACDW'
call LZx('ACDW',false)
return true
endfunction
function vXo takes nothing returns boolean
set Uj[50]='AC1E'
call LZx('AC1E',false)
return true
endfunction
function vOo takes nothing returns boolean
set Uj[52]='AC1G'
call LZx('AC1G',false)
return true
endfunction
function vRo takes nothing returns boolean
set Uj[53]='AC1H'
call LZx('AC1H',false)
return true
endfunction
function vIo takes nothing returns boolean
set Uj[54]='AC1I'
call LZx('AC1I',false)
return true
endfunction
function vAo takes nothing returns boolean
set Uj[55]='AC1J'
call LZx('AC1J',false)
return true
endfunction
function vNo takes nothing returns boolean
set Uj[57]='AC1L'
call LZx('AC1L',false)
return true
endfunction
function vbo takes nothing returns boolean
set Uj[58]='AC1M'
call LZx('AC1M',false)
return true
endfunction
function vBo takes nothing returns boolean
set Uj[59]='AC1N'
call LZx('AC1N',false)
return true
endfunction
function vco takes nothing returns boolean
set Uj[362]='ACA2'
call LZx('ACA2',false)
return true
endfunction
function vCo takes nothing returns boolean
set Uj[60]='AC1O'
call LZx('AC1O',false)
return true
endfunction
function vdo takes nothing returns boolean
set Uj[63]='AC1R'
call LZx('AC1R',false)
return true
endfunction
function vDo takes nothing returns boolean
set Uj[65]='AC1T'
call LZx('AC1T',false)
return true
endfunction
function vfo takes nothing returns boolean
set Uj[67]='AC1V'
call LZx('AC1V',false)
return true
endfunction
function vFo takes nothing returns boolean
set Uj[71]='AC1Z'
call LZx('AC1Z',false)
return true
endfunction
function vgo takes nothing returns boolean
set Uj[72]='AC20'
call LZx('AC20',false)
return true
endfunction
function vGo takes nothing returns boolean
set Uj[74]='AC22'
call LZx('AC22',false)
return true
endfunction
function vho takes nothing returns boolean
set Uj[79]='AC27'
call LZx('AC27',false)
return true
endfunction
function vHo takes nothing returns boolean
set Uj[82]='AC2A'
call LZx('AC2A',false)
return true
endfunction
function vjo takes nothing returns boolean
set Uj[85]='AC2D'
call LZx('AC2D',false)
return true
endfunction
function vJo takes nothing returns boolean
set Uj[86]='AC2E'
call LZx('AC2E',false)
return true
endfunction
function vko takes nothing returns boolean
set Uj[88]='AC2G'
call LZx('AC2G',false)
return true
endfunction
function vKo takes nothing returns boolean
set Uj[89]='AC2H'
call LZx('AC2H',false)
return true
endfunction
function vlo takes nothing returns boolean
set Uj[90]='AC2I'
call LZx('AC2I',false)
return true
endfunction
function vLo takes nothing returns boolean
set Uj[70]='AC1Y'
call LZx('AC1Y',false)
return true
endfunction
function vmo takes nothing returns boolean
set Uj[93]='AC2L'
call LZx('AC2L',false)
return true
endfunction
function vMo takes nothing returns boolean
set Uj[94]='AC2M'
call LZx('AC2M',false)
return true
endfunction
function vpo takes nothing returns boolean
set Uj[96]='AC2O'
call LZx('AC2O',false)
return true
endfunction
function vPo takes nothing returns boolean
set Uj[$AC]='AC4S'
call LZx('AC4S',false)
return true
endfunction
function vqo takes nothing returns boolean
set Uj[$A6]='AC4M'
call LZx('AC4M',false)
return true
endfunction
function vQo takes nothing returns boolean
set Uj[330]='AC96'
call LZx('AC96',false)
return true
endfunction
function vso takes nothing returns boolean
set Uj[$BF]='AC5B'
call LZx('AC5B',false)
return true
endfunction
function vSo takes nothing returns boolean
set Uj[7]='AC07'
call LZx('AC07',false)
return true
endfunction
function vto takes nothing returns boolean
set Uj[32]='AC0W'
call LZx('AC0W',false)
return true
endfunction
function vTo takes nothing returns boolean
set Uj[374]='ACAE'
call LZx('ACAE',false)
return true
endfunction
function vuo takes nothing returns boolean
set Uj[287]='AC7Z'
call LZx('AC7Z',false)
return true
endfunction
function vUo takes nothing returns boolean
set Uj[16]='AC0G'
call LZx('AC0G',false)
return true
endfunction
function vwo takes nothing returns boolean
set Uj[$F9]='AC6X'
call LZx('AC6X',false)
return true
endfunction
function vWo takes nothing returns boolean
set Uj[$FF]='AC73'
call LZx('AC73',false)
return true
endfunction
function vyo takes nothing returns boolean
set Uj[80]='AC28'
call LZx('AC28',false)
return true
endfunction
function vYo takes nothing returns boolean
set Uj[$89]='AC3T'
call LZx('AC3T',false)
return true
endfunction
function vzo takes nothing returns boolean
set Uj[450]='ACCI'
call LZx('ACCI',false)
return true
endfunction
function vZo takes nothing returns boolean
set Uj[99]='AC2R'
call LZx('AC2R',false)
return true
endfunction
function v_o takes nothing returns boolean
set Uj[469]='ACD1'
call LZx('ACD1',false)
return true
endfunction
function v0o takes nothing returns boolean
set Uj[$E7]='AC6F'
call LZx('AC6F',false)
return true
endfunction
function v1o takes nothing returns boolean
set Uj[281]='AC7T'
call LZx('AC7T',false)
return true
endfunction
function v2o takes nothing returns boolean
set Uj[377]='ACAH'
call LZx('ACAH',false)
return true
endfunction
function v3o takes nothing returns boolean
set Uj[333]='AC99'
call LZx('AC99',false)
return true
endfunction
function v4o takes nothing returns boolean
set Uj[84]='AC2C'
call LZx('AC2C',false)
return true
endfunction
function v5o takes nothing returns boolean
set Uj[397]='ACB1'
call LZx('ACB1',false)
return true
endfunction
function v6o takes nothing returns boolean
set Uj[$DF]='AC67'
call LZx('AC67',false)
return true
endfunction
function v7o takes nothing returns boolean
set Uj[$82]='AC3M'
call LZx('AC3M',false)
return true
endfunction
function v8o takes nothing returns boolean
set Uj['z']='AC3E'
call LZx('AC3E',false)
return true
endfunction
function v9o takes nothing returns boolean
set Uj[$D4]='AC5W'
call LZx('AC5W',false)
return true
endfunction
function evo takes nothing returns boolean
set Uj[$8B]='AC3V'
call LZx('AC3V',false)
return true
endfunction
function eeo takes nothing returns boolean
set Uj[437]='ACC5'
call LZx('ACC5',false)
return true
endfunction
function exo takes nothing returns boolean
set Uj[21]='AC0L'
call LZx('AC0L',false)
return true
endfunction
function eoo takes nothing returns boolean
set Uj[$E5]='AC6D'
call LZx('AC6D',false)
return true
endfunction
function ero takes nothing returns boolean
set Uj[446]='ACCE'
call LZx('ACCE',false)
return true
endfunction
function eio takes nothing returns boolean
set Uj[$F]='AC0F'
call LZx('AC0F',false)
return true
endfunction
function eao takes nothing returns boolean
set Uj[453]='ACCL'
call LZx('ACCL',false)
return true
endfunction
function eno takes nothing returns boolean
set Uj[64]='AC1S'
call LZx('AC1S',false)
return true
endfunction
function eVo takes nothing returns boolean
set Uj[0]='AC00'
call LZx('AC00',false)
return true
endfunction
function eEo takes nothing returns boolean
set Uj[24]='AC0O'
call LZx('AC0O',false)
return true
endfunction
function eXo takes nothing returns boolean
set Uj[$B]='AC0B'
call LZx('AC0B',false)
return true
endfunction
function eOo takes nothing returns boolean
set Uj[455]='ACCN'
call LZx('ACCN',false)
return true
endfunction
function eRo takes nothing returns boolean
set Uj[288]='AC80'
call LZx('AC80',false)
return true
endfunction
function eIo takes nothing returns boolean
set Uj[3]='AC03'
call LZx('AC03',false)
return true
endfunction
function eAo takes nothing returns boolean
set Uj[78]='AC26'
call LZx('AC26',false)
return true
endfunction
function eNo takes nothing returns boolean
set Uj[$C9]='AC5L'
call LZx('AC5L',false)
return true
endfunction
function ebo takes nothing returns boolean
set Uj[472]='ACD4'
call LZx('ACD4',false)
return true
endfunction
function eBo takes nothing returns boolean
set Uj[325]='AC91'
call LZx('AC91',false)
return true
endfunction
function eco takes nothing returns boolean
set Uj[$85]='AC3P'
call LZx('AC3P',false)
return true
endfunction
function eCo takes nothing returns boolean
set Uj[81]='AC29'
call LZx('AC29',false)
return true
endfunction
function edo takes nothing returns boolean
set Uj[$D9]='AC61'
call LZx('AC61',false)
return true
endfunction
function eDo takes nothing returns boolean
set Uj[357]='AC9X'
call LZx('AC9X',false)
return true
endfunction
function efo takes nothing returns boolean
set Uj[$CE]='AC5Q'
call LZx('AC5Q',false)
return true
endfunction
function eFo takes nothing returns boolean
set Uj[95]='AC2N'
call LZx('AC2N',false)
return true
endfunction
function ego takes nothing returns boolean
set Uj['e']='AC2T'
call LZx('AC2T',false)
return true
endfunction
function eGo takes nothing returns boolean
set Uj[448]='ACCG'
call LZx('ACCG',false)
return true
endfunction
function eho takes nothing returns boolean
set Uj[428]='ACBW'
call LZx('ACBW',false)
return true
endfunction
function eHo takes nothing returns boolean
set Uj[$B0]='AC4W'
call LZx('AC4W',false)
return true
endfunction
function ejo takes nothing returns boolean
set Uj[69]='AC1X'
call LZx('AC1X',false)
return true
endfunction
function eJo takes nothing returns boolean
set Uj[$CD]='AC5P'
call LZx('AC5P',false)
return true
endfunction
function eko takes nothing returns boolean
set Uj[271]='AC7J'
call LZx('AC7J',false)
return true
endfunction
function eKo takes nothing returns boolean
set Uj[481]='ACDD'
call LZx('ACDD',false)
return true
endfunction
function elo takes nothing returns boolean
set Uj[$8D]='AC3X'
call LZx('AC3X',false)
return true
endfunction
function eLo takes nothing returns boolean
set Uj[412]='ACBG'
call LZx('ACBG',false)
return true
endfunction
function emo takes nothing returns boolean
set Uj[$99]='AC49'
call LZx('AC49',false)
return true
endfunction
function eMo takes nothing returns boolean
set Uj[443]='ACCB'
call LZx('ACCB',false)
return true
endfunction
function epo takes nothing returns boolean
set Uj[328]='AC94'
call LZx('AC94',false)
return true
endfunction
function ePo takes nothing returns boolean
set Uj[390]='ACAU'
call LZx('ACAU',false)
return true
endfunction
function eqo takes nothing returns boolean
set Uj[369]='ACA9'
call LZx('ACA9',false)
return true
endfunction
function eQo takes nothing returns boolean
set Uj[39]='AC13'
call LZx('AC13',false)
return true
endfunction
function eso takes nothing returns boolean
set Uj[418]='ACBM'
call LZx('ACBM',false)
return true
endfunction
function eSo takes nothing returns boolean
set Uj[474]='ACD6'
call LZx('ACD6',false)
return true
endfunction
function eto takes nothing returns boolean
set uj=lQx(awv+" (moddedBuff)")
return true
endfunction
function eTo takes nothing returns boolean
set Uj[410]='ACBE'
call LZx('ACBE',false)
return true
endfunction
function euo takes nothing returns boolean
set Uj['n']='AC32'
call LZx('AC32',false)
return true
endfunction
function eUo takes nothing returns boolean
set Uj[76]='AC24'
call LZx('AC24',false)
return true
endfunction
function ewo takes nothing returns boolean
set Uj[342]='AC9I'
call LZx('AC9I',false)
return true
endfunction
function eWo takes nothing returns boolean
set Uj[402]='ACB6'
call LZx('ACB6',false)
return true
endfunction
function eyo takes nothing returns boolean
set Uj[$AF]='AC4V'
call LZx('AC4V',false)
return true
endfunction
function eYo takes nothing returns boolean
set Uj[$FD]='AC71'
call LZx('AC71',false)
return true
endfunction
function ezo takes nothing returns boolean
set Uj['o']='AC33'
call LZx('AC33',false)
return true
endfunction
function eZo takes nothing returns boolean
set Uj['q']='AC35'
call LZx('AC35',false)
return true
endfunction
function e_o takes nothing returns boolean
set Uj[373]='ACAD'
call LZx('ACAD',false)
return true
endfunction
function e0o takes nothing returns boolean
set Uj[332]='AC98'
call LZx('AC98',false)
return true
endfunction
function e1o takes nothing returns boolean
set Uj[$ED]='AC6L'
call LZx('AC6L',false)
return true
endfunction
function e2o takes nothing returns boolean
set Uj[66]='AC1U'
call LZx('AC1U',false)
return true
endfunction
function e3o takes nothing returns boolean
set Uj[324]='AC90'
call LZx('AC90',false)
return true
endfunction
function e4o takes nothing returns boolean
set Uj[61]='AC1P'
call LZx('AC1P',false)
return true
endfunction
function e5o takes nothing returns boolean
set Uj['}']='AC3H'
call LZx('AC3H',false)
return true
endfunction
function e6o takes nothing returns boolean
set Uj[87]='AC2F'
call LZx('AC2F',false)
return true
endfunction
function e7o takes nothing returns boolean
set Uj[379]='ACAJ'
call LZx('ACAJ',false)
return true
endfunction
function e8o takes nothing returns boolean
set Uj[366]='ACA6'
call LZx('ACA6',false)
return true
endfunction
function e9o takes nothing returns boolean
set Uj[407]='ACBB'
call LZx('ACBB',false)
return true
endfunction
function xvo takes nothing returns boolean
set Uj[$A4]='AC4K'
call LZx('AC4K',false)
return true
endfunction
function xeo takes nothing returns boolean
set Uj[338]='AC9E'
call LZx('AC9E',false)
return true
endfunction
function xxo takes nothing returns boolean
set Uj[73]='AC21'
call LZx('AC21',false)
return true
endfunction
function xoo takes nothing returns boolean
set Uj[406]='ACBA'
call LZx('ACBA',false)
return true
endfunction
function xro takes nothing returns boolean
set Uj[348]='AC9O'
call LZx('AC9O',false)
return true
endfunction
function xio takes nothing returns boolean
set Uj[$84]='AC3O'
call LZx('AC3O',false)
return true
endfunction
function xao takes nothing returns boolean
set Uj[$F1]='AC6P'
call LZx('AC6P',false)
return true
endfunction
function xno takes nothing returns boolean
set Uj[$DA]='AC62'
call LZx('AC62',false)
return true
endfunction
function xVo takes nothing returns boolean
set Uj[439]='ACC7'
call LZx('ACC7',false)
return true
endfunction
function xEo takes nothing returns boolean
set Uj[$A2]='AC4I'
call LZx('AC4I',false)
return true
endfunction
function xXo takes nothing returns boolean
set Uj[399]='ACB3'
call LZx('ACB3',false)
return true
endfunction
function xOo takes nothing returns boolean
set Uj[297]='AC89'
call LZx('AC89',false)
return true
endfunction
function xRo takes nothing returns boolean
set Uj[51]='AC1F'
call LZx('AC1F',false)
return true
endfunction
function xIo takes nothing returns boolean
set Uj[497]='ACDT'
call LZx('ACDT',false)
return true
endfunction
function xAo takes nothing returns boolean
set Uj[272]='AC7K'
call LZx('AC7K',false)
return true
endfunction
function xNo takes nothing returns boolean
set Uj[$E4]='AC6C'
call LZx('AC6C',false)
return true
endfunction
function xbo takes nothing returns boolean
set Uj[25]='AC0P'
call LZx('AC0P',false)
return true
endfunction
function xBo takes nothing returns boolean
set Uj[98]='AC2Q'
call LZx('AC2Q',false)
return true
endfunction
function xco takes nothing returns boolean
set Uj[409]='ACBD'
call LZx('ACBD',false)
return true
endfunction
function xCo takes nothing returns boolean
set Uj[28]='AC0S'
call LZx('AC0S',false)
return true
endfunction
function xdo takes nothing returns boolean
set Uj[365]='ACA5'
call LZx('ACA5',false)
return true
endfunction
function xDo takes nothing returns boolean
set Uj[45]='AC19'
call LZx('AC19',false)
return true
endfunction
function xfo takes nothing returns boolean
set Uj[320]='AC8W'
call LZx('AC8W',false)
return true
endfunction
function xFo takes nothing returns boolean
set Uj[334]='AC9A'
call LZx('AC9A',false)
return true
endfunction
function xgo takes nothing returns boolean
set Uj[426]='ACBU'
call LZx('ACBU',false)
return true
endfunction
function xGo takes nothing returns boolean
set Uj[435]='ACC3'
call LZx('ACC3',false)
return true
endfunction
function xho takes nothing returns boolean
set Uj[$A1]='AC4H'
call LZx('AC4H',false)
return true
endfunction
function xHo takes nothing returns boolean
set Uj[75]='AC23'
call LZx('AC23',false)
return true
endfunction
function xjo takes nothing returns boolean
set Uj[329]='AC95'
call LZx('AC95',false)
return true
endfunction
function xJo takes nothing returns boolean
set Uj[31]='AC0V'
call LZx('AC0V',false)
return true
endfunction
function xko takes nothing returns boolean
set Uj[4]='AC04'
call LZx('AC04',false)
return true
endfunction
function xKo takes nothing returns boolean
set Uj[309]='AC8L'
call LZx('AC8L',false)
return true
endfunction
function xlo takes nothing returns boolean
set Uj[2]='AC02'
call LZx('AC02',false)
return true
endfunction
function xLo takes nothing returns boolean
set Uj[33]='AC0X'
call LZx('AC0X',false)
return true
endfunction
function xmo takes nothing returns boolean
set Uj[430]='ACBY'
call LZx('ACBY',false)
return true
endfunction
function xMo takes nothing returns boolean
set Uj[457]='ACCP'
call LZx('ACCP',false)
return true
endfunction
function xpo takes nothing returns boolean
set Uj[68]='AC1W'
call LZx('AC1W',false)
return true
endfunction
function xPo takes nothing returns boolean
set Uj[62]='AC1Q'
call LZx('AC1Q',false)
return true
endfunction
function xqo takes nothing returns boolean
set Uj[262]='AC7A'
call LZx('AC7A',false)
return true
endfunction
function xQo takes nothing returns boolean
set Uj[274]='AC7M'
call LZx('AC7M',false)
return true
endfunction
function xso takes nothing returns boolean
set Uj[23]='AC0N'
call LZx('AC0N',false)
return true
endfunction
function xSo takes nothing returns boolean
set Uj[414]='ACBI'
call LZx('ACBI',false)
return true
endfunction
function xto takes nothing returns boolean
set Uj[$EC]='AC6K'
call LZx('AC6K',false)
return true
endfunction
function xTo takes nothing returns boolean
set Uj[432]='ACC0'
call LZx('ACC0',false)
return true
endfunction
function xuo takes nothing returns boolean
set Uj[22]='AC0M'
call LZx('AC0M',false)
return true
endfunction
function xUo takes nothing returns boolean
set Uj[451]='ACCJ'
call LZx('ACCJ',false)
return true
endfunction
function xwo takes nothing returns boolean
set Uj[$80]='AC3K'
call LZx('AC3K',false)
return true
endfunction
function xWo takes nothing returns boolean
set Uj[$C7]='AC5J'
call LZx('AC5J',false)
return true
endfunction
function xyo takes nothing returns boolean
set Uj[483]='ACDF'
call LZx('ACDF',false)
return true
endfunction
function xYo takes nothing returns boolean
set Uj[$A8]='AC4O'
call LZx('AC4O',false)
return true
endfunction
function xzo takes nothing returns boolean
set Uj[264]='AC7C'
call LZx('AC7C',false)
return true
endfunction
function xZo takes nothing returns boolean
set Uj[$C6]='AC5I'
call LZx('AC5I',false)
return true
endfunction
function x_o takes nothing returns boolean
set Uj[273]='AC7L'
call LZx('AC7L',false)
return true
endfunction
function x0o takes nothing returns boolean
set Uj[345]='AC9L'
call LZx('AC9L',false)
return true
endfunction
function x1o takes nothing returns boolean
set Uj[46]='AC1A'
call LZx('AC1A',false)
return true
endfunction
function x2o takes nothing returns boolean
set Uj[$B9]='AC55'
call LZx('AC55',false)
return true
endfunction
function x3o takes nothing returns boolean
set Uj[$E0]='AC68'
call LZx('AC68',false)
return true
endfunction
function x4o takes nothing returns boolean
set Uj[77]='AC25'
call LZx('AC25',false)
return true
endfunction
function x5o takes nothing returns boolean
set Uj[$8E]='AC3Y'
call LZx('AC3Y',false)
return true
endfunction
function x6o takes nothing returns boolean
set Uj[18]='AC0I'
call LZx('AC0I',false)
return true
endfunction
function x7o takes nothing returns boolean
set Uj[454]='ACCM'
call LZx('ACCM',false)
return true
endfunction
function x8o takes nothing returns boolean
set Uj[415]='ACBJ'
call LZx('ACBJ',false)
return true
endfunction
function x9o takes nothing returns boolean
set Uj[92]='AC2K'
call LZx('AC2K',false)
return true
endfunction
function ovo takes nothing returns boolean
set Uj[378]='ACAI'
call LZx('ACAI',false)
return true
endfunction
function oeo takes nothing returns boolean
set Uj[$97]='AC47'
call LZx('AC47',false)
return true
endfunction
function oxo takes nothing returns boolean
set Uj[$D8]='AC60'
call LZx('AC60',false)
return true
endfunction
function ooo takes nothing returns boolean
set Uj[368]='ACA8'
call LZx('ACA8',false)
return true
endfunction
function oro takes nothing returns boolean
set Uj[485]='ACDH'
call LZx('ACDH',false)
return true
endfunction
function oio takes nothing returns boolean
set Uj[$AE]='AC4U'
call LZx('AC4U',false)
return true
endfunction
function oao takes nothing returns boolean
set Uj[394]='ACAY'
call LZx('ACAY',false)
return true
endfunction
function ono takes nothing returns boolean
set Uj[$D1]='AC5T'
call LZx('AC5T',false)
return true
endfunction
function oVo takes nothing returns boolean
set Uj[343]='AC9J'
call LZx('AC9J',false)
return true
endfunction
function oEo takes nothing returns boolean
set Uj[411]='ACBF'
call LZx('ACBF',false)
return true
endfunction
function oXo takes nothing returns boolean
set Uj[$CA]='AC5M'
call LZx('AC5M',false)
return true
endfunction
function oOo takes nothing returns boolean
set Uj[$B4]='AC50'
call LZx('AC50',false)
return true
endfunction
function oRo takes nothing returns boolean
set Uj[$C4]='AC5G'
call LZx('AC5G',false)
return true
endfunction
function oIo takes nothing returns boolean
set Uj[$BB]='AC57'
call LZx('AC57',false)
return true
endfunction
function oAo takes nothing returns boolean
set Uj[$D6]='AC5Y'
call LZx('AC5Y',false)
return true
endfunction
function oNo takes nothing returns boolean
set Uj[$B7]='AC53'
call LZx('AC53',false)
return true
endfunction
function obo takes nothing returns boolean
set Uj[$B2]='AC4Y'
call LZx('AC4Y',false)
return true
endfunction
function oBo takes nothing returns boolean
set Uj['{']='AC3F'
call LZx('AC3F',false)
return true
endfunction
function oco takes nothing returns boolean
set Uj[318]='AC8U'
call LZx('AC8U',false)
return true
endfunction
function oCo takes nothing returns boolean
set Uj[56]='AC1K'
call LZx('AC1K',false)
return true
endfunction
function odo takes nothing returns boolean
set Uj[$C5]='AC5H'
call LZx('AC5H',false)
return true
endfunction
function oDo takes nothing returns boolean
set Uj[496]='ACDS'
call LZx('ACDS',false)
return true
endfunction
function ofo takes nothing returns boolean
set Uj[$A3]='AC4J'
call LZx('AC4J',false)
return true
endfunction
function oFo takes nothing returns boolean
set Uj[449]='ACCH'
call LZx('ACCH',false)
return true
endfunction
function ogo takes nothing returns boolean
set Uj[91]='AC2J'
call LZx('AC2J',false)
return true
endfunction
function oGo takes nothing returns boolean
set Uj[$AB]='AC4R'
call LZx('AC4R',false)
return true
endfunction
function oho takes nothing returns boolean
set Uj[486]='ACDI'
call LZx('ACDI',false)
return true
endfunction
function oHo takes nothing returns boolean
set Uj[398]='ACB2'
call LZx('ACB2',false)
return true
endfunction
function ojo takes nothing returns boolean
set Uj[97]='AC2P'
call LZx('AC2P',false)
return true
endfunction
function oJo takes nothing returns boolean
set Uj[416]='ACBK'
call LZx('ACBK',false)
return true
endfunction
function oko takes nothing returns boolean
set Uj[283]='AC7V'
call LZx('AC7V',false)
return true
endfunction
function oKo takes nothing returns boolean
set Uj[315]='AC8R'
call LZx('AC8R',false)
return true
endfunction
function olo takes nothing returns boolean
set Uj[316]='AC8S'
call LZx('AC8S',false)
return true
endfunction
function oLo takes nothing returns boolean
set Uj[$9B]='AC4B'
call LZx('AC4B',false)
return true
endfunction
function omo takes nothing returns boolean
set Uj[26]='AC0Q'
call LZx('AC0Q',false)
return true
endfunction
function oMo takes nothing returns boolean
set Uj['t']='AC38'
call LZx('AC38',false)
return true
endfunction
function opo takes nothing returns boolean
set Uj['y']='AC3D'
call LZx('AC3D',false)
return true
endfunction
function oPo takes nothing returns boolean
set Uj[314]='AC8Q'
call LZx('AC8Q',false)
return true
endfunction
function oqo takes nothing returns boolean
set Uj[441]='ACC9'
call LZx('ACC9',false)
return true
endfunction
function oQo takes nothing returns boolean
set Uj[$BA]='AC56'
call LZx('AC56',false)
return true
endfunction
function oso takes nothing returns boolean
set Uj[$9F]='AC4F'
call LZx('AC4F',false)
return true
endfunction
function oSo takes nothing returns boolean
set Uj[466]='ACCY'
call LZx('ACCY',false)
return true
endfunction
function oto takes nothing returns boolean
set Uj[6]='AC06'
call LZx('AC06',false)
return true
endfunction
function oTo takes nothing returns boolean
set Uj[29]='AC0T'
call LZx('AC0T',false)
return true
endfunction
function ouo takes nothing returns boolean
set Uj[401]='ACB5'
call LZx('ACB5',false)
return true
endfunction
function oUo takes nothing returns boolean
set Uj[$87]='AC3R'
call LZx('AC3R',false)
return true
endfunction
function owo takes nothing returns boolean
set Uj[$83]='AC3N'
call LZx('AC3N',false)
return true
endfunction
function oWo takes nothing returns boolean
set Uj[$EF]='AC6N'
call LZx('AC6N',false)
return true
endfunction
function oyo takes nothing returns boolean
set Uj[353]='AC9T'
call LZx('AC9T',false)
return true
endfunction
function oYo takes nothing returns boolean
set Uj[$F8]='AC6W'
call LZx('AC6W',false)
return true
endfunction
function ozo takes nothing returns boolean
set Uj[$D7]='AC5Z'
call LZx('AC5Z',false)
return true
endfunction
function oZo takes nothing returns boolean
set Uj[$90]='AC40'
call LZx('AC40',false)
return true
endfunction
function o_o takes nothing returns boolean
set Uj[17]='AC0H'
call LZx('AC0H',false)
return true
endfunction
function o0o takes nothing returns boolean
set Uj[293]='AC85'
call LZx('AC85',false)
return true
endfunction
function o1o takes nothing returns boolean
set Uj[265]='AC7D'
call LZx('AC7D',false)
return true
endfunction
function o2o takes nothing returns boolean
set Uj[349]='AC9P'
call LZx('AC9P',false)
return true
endfunction
function o3o takes nothing returns boolean
set Uj[477]='ACD9'
call LZx('ACD9',false)
return true
endfunction
function o4o takes nothing returns boolean
set Uj[$94]='AC44'
call LZx('AC44',false)
return true
endfunction
function o5o takes nothing returns boolean
set Uj[440]='ACC8'
call LZx('ACC8',false)
return true
endfunction
function o6o takes nothing returns boolean
set Uj[$D5]='AC5X'
call LZx('AC5X',false)
return true
endfunction
function o7o takes nothing returns boolean
set Uj[$B1]='AC4X'
call LZx('AC4X',false)
return true
endfunction
function o8o takes nothing returns boolean
set Uj[386]='ACAQ'
call LZx('ACAQ',false)
return true
endfunction
function o9o takes nothing returns boolean
set Uj[$DD]='AC65'
call LZx('AC65',false)
return true
endfunction
function rvo takes nothing returns boolean
set Uj[408]='ACBC'
call LZx('ACBC',false)
return true
endfunction
function reo takes nothing returns boolean
set Uj[$CB]='AC5N'
call LZx('AC5N',false)
return true
endfunction
function rxo takes nothing returns boolean
set Uj[$DB]='AC63'
call LZx('AC63',false)
return true
endfunction
function roo takes nothing returns boolean
set Uj[499]='ACDV'
call LZx('ACDV',false)
return true
endfunction
function rro takes nothing returns boolean
set Uj[344]='AC9K'
call LZx('AC9K',false)
return true
endfunction
function rio takes nothing returns boolean
set Uj[438]='ACC6'
call LZx('ACC6',false)
return true
endfunction
function rao takes nothing returns boolean
set Uj['s']='AC37'
call LZx('AC37',false)
return true
endfunction
function rno takes nothing returns boolean
set Uj[356]='AC9W'
call LZx('AC9W',false)
return true
endfunction
function rVo takes nothing returns boolean
set Uj[354]='AC9U'
call LZx('AC9U',false)
return true
endfunction
function rEo takes nothing returns boolean
set Uj[$F0]='AC6O'
call LZx('AC6O',false)
return true
endfunction
function rXo takes nothing returns boolean
set Uj[$BC]='AC58'
call LZx('AC58',false)
return true
endfunction
function rOo takes nothing returns boolean
set Uj[$81]='AC3L'
call LZx('AC3L',false)
return true
endfunction
function rRo takes nothing returns boolean
set Uj['w']='AC3B'
call LZx('AC3B',false)
return true
endfunction
function rIo takes nothing returns boolean
set Uj[$7E]='AC3I'
call LZx('AC3I',false)
return true
endfunction
function rAo takes nothing returns boolean
set Uj[300]='AC8C'
call LZx('AC8C',false)
return true
endfunction
function rNo takes nothing returns boolean
set Uj[49]='AC1D'
call LZx('AC1D',false)
return true
endfunction
function rbo takes nothing returns boolean
set Uj['|']='AC3G'
call LZx('AC3G',false)
return true
endfunction
function rBo takes nothing returns boolean
set Uj[444]='ACCC'
call LZx('ACCC',false)
return true
endfunction
function rco takes nothing returns boolean
set Uj['m']='AC31'
call LZx('AC31',false)
return true
endfunction
function rCo takes nothing returns boolean
set Uj['r']='AC36'
call LZx('AC36',false)
return true
endfunction
function rdo takes nothing returns boolean
set Uj[$95]='AC45'
call LZx('AC45',false)
return true
endfunction
function rDo takes nothing returns boolean
set Uj[434]='ACC2'
call LZx('ACC2',false)
return true
endfunction
function rfo takes nothing returns boolean
set Uj[$B8]='AC54'
call LZx('AC54',false)
return true
endfunction
function rFo takes nothing returns boolean
call VRx(qa,(function ygx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[20]_wc3spell.j"))
call VRx(qa,(function yGx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[12]_wc3spell.j"))
call VRx(qa,(function yhx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[134]_wc3spell.j"))
call VRx(qa,(function yHx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[118]_wc3spell.j"))
call VRx(qa,(function yjx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[136]_wc3spell.j"))
call VRx(qa,(function yJx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[138]_wc3spell.j"))
call VRx(qa,(function ykx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[102]_wc3spell.j"))
call VRx(qa,(function yKx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[140]_wc3spell.j"))
call VRx(qa,(function ylx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[19]_wc3spell.j"))
call VRx(qa,(function yLx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[143]_wc3spell.j"))
call VRx(qa,(function ymx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[145]_wc3spell.j"))
call VRx(qa,(function yMx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[146]_wc3spell.j"))
call VRx(qa,(function ypx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[108]_wc3spell.j"))
call VRx(qa,(function yPx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[152]_wc3spell.j"))
call VRx(qa,(function yqx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[154]_wc3spell.j"))
call VRx(qa,(function yQx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[156]_wc3spell.j"))
call VRx(qa,(function ysx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[157]_wc3spell.j"))
call VRx(qa,(function ySx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[158]_wc3spell.j"))
call VRx(qa,(function ytx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[147]_wc3spell.j"))
call VRx(qa,(function yTx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[160]_wc3spell.j"))
call VRx(qa,(function yux),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[165]_wc3spell.j"))
call VRx(qa,(function yUx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[167]_wc3spell.j"))
call VRx(qa,(function ywx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[107]_wc3spell.j"))
call VRx(qa,(function yWx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[169]_wc3spell.j"))
call VRx(qa,(function yyx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[170]_wc3spell.j"))
call VRx(qa,(function yYx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[173]_wc3spell.j"))
call VRx(qa,(function yzx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[179]_wc3spell.j"))
call VRx(qa,(function yZx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[181]_wc3spell.j"))
call VRx(qa,(function y_x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[112]_wc3spell.j"))
call VRx(qa,(function y0x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[182]_wc3spell.j"))
call VRx(qa,(function y1x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[104]_wc3spell.j"))
call VRx(qa,(function y2x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[189]_wc3spell.j"))
call VRx(qa,(function y3x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[150]_wc3spell.j"))
call VRx(qa,(function y4x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[190]_wc3spell.j"))
call VRx(qa,(function y5x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[192]_wc3spell.j"))
call VRx(qa,(function y6x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[193]_wc3spell.j"))
call VRx(qa,(function y7x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[194]_wc3spell.j"))
call VRx(qa,(function y8x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[195]_wc3spell.j"))
call VRx(qa,(function y9x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[200]_wc3spell.j"))
call VRx(qa,(function Yvx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[204]_wc3spell.j"))
call VRx(qa,(function Yex),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[207]_wc3spell.j"))
call VRx(qa,(function Yxx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[208]_wc3spell.j"))
call VRx(qa,(function Yox),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[210]_wc3spell.j"))
call VRx(qa,(function Yrx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[211]_wc3spell.j"))
call VRx(qa,(function Yix),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[220]_wc3spell.j"))
call VRx(qa,(function Yax),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[222]_wc3spell.j"))
call VRx(qa,(function Ynx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[225]_wc3spell.j"))
call VRx(qa,(function YVx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[226]_wc3spell.j"))
call VRx(qa,(function YEx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[227]_wc3spell.j"))
call VRx(qa,(function YXx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[230]_wc3spell.j"))
call VRx(qa,(function YOx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[232]_wc3spell.j"))
call VRx(qa,(function YRx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[233]_wc3spell.j"))
call VRx(qa,(function YIx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[234]_wc3spell.j"))
call VRx(qa,(function YAx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[235]_wc3spell.j"))
call VRx(qa,(function YNx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[238]_wc3spell.j"))
call VRx(qa,(function Ybx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[242]_wc3spell.j"))
call VRx(qa,(function YBx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[243]_wc3spell.j"))
call VRx(qa,(function Ycx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[244]_wc3spell.j"))
call VRx(qa,(function YCx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[245]_wc3spell.j"))
call VRx(qa,(function Ydx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[246]_wc3spell.j"))
call VRx(qa,(function YDx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[247]_wc3spell.j"))
call VRx(qa,(function Yfx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[250]_wc3spell.j"))
call VRx(qa,(function YFx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[251]_wc3spell.j"))
call VRx(qa,(function Ygx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[252]_wc3spell.j"))
call VRx(qa,(function YGx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[254]_wc3spell.j"))
call VRx(qa,(function Yhx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[256]_wc3spell.j"))
call VRx(qa,(function YHx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[257]_wc3spell.j"))
call VRx(qa,(function Yjx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[258]_wc3spell.j"))
call VRx(qa,(function YJx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[259]_wc3spell.j"))
call VRx(qa,(function Ykx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[260]_wc3spell.j"))
call VRx(qa,(function YKx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[261]_wc3spell.j"))
call VRx(qa,(function Ylx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[263]_wc3spell.j"))
call VRx(qa,(function YLx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[266]_wc3spell.j"))
call VRx(qa,(function Ymx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[267]_wc3spell.j"))
call VRx(qa,(function YMx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[268]_wc3spell.j"))
call VRx(qa,(function Ypx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[269]_wc3spell.j"))
call VRx(qa,(function YPx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[270]_wc3spell.j"))
call VRx(qa,(function Yqx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[275]_wc3spell.j"))
call VRx(qa,(function YQx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[427]_wc3spell.j"))
call VRx(qa,(function Ysx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[276]_wc3spell.j"))
call VRx(qa,(function YSx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[277]_wc3spell.j"))
call VRx(qa,(function Ytx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[278]_wc3spell.j"))
call VRx(qa,(function YTx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[279]_wc3spell.j"))
call VRx(qa,(function Yux),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[27]_wc3spell.j"))
call VRx(qa,(function YUx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[282]_wc3spell.j"))
call VRx(qa,(function Ywx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[284]_wc3spell.j"))
call VRx(qa,(function YWx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[100]_wc3spell.j"))
call VRx(qa,(function Yyx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[286]_wc3spell.j"))
call VRx(qa,(function YYx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[289]_wc3spell.j"))
call VRx(qa,(function Yzx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[290]_wc3spell.j"))
call VRx(qa,(function YZx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[291]_wc3spell.j"))
call VRx(qa,(function Y_x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[292]_wc3spell.j"))
call VRx(qa,(function Y0x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[14]_wc3spell.j"))
call VRx(qa,(function Y1x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[294]_wc3spell.j"))
call VRx(qa,(function Y2x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[295]_wc3spell.j"))
call VRx(qa,(function Y3x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[298]_wc3spell.j"))
call VRx(qa,(function Y4x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[299]_wc3spell.j"))
call VRx(qa,(function Y5x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[301]_wc3spell.j"))
call VRx(qa,(function Y6x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[302]_wc3spell.j"))
call VRx(qa,(function Y7x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[103]_wc3spell.j"))
call VRx(qa,(function Y8x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[303]_wc3spell.j"))
call VRx(qa,(function Y9x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[304]_wc3spell.j"))
call VRx(qa,(function zvx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[305]_wc3spell.j"))
call VRx(qa,(function zex),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[306]_wc3spell.j"))
call VRx(qa,(function zxx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[307]_wc3spell.j"))
call VRx(qa,(function zox),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[308]_wc3spell.j"))
call VRx(qa,(function zrx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[30]_wc3spell.j"))
call VRx(qa,(function zix),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[310]_wc3spell.j"))
call VRx(qa,(function zax),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[311]_wc3spell.j"))
call VRx(qa,(function znx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[312]_wc3spell.j"))
call VRx(qa,(function zVx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[313]_wc3spell.j"))
call VRx(qa,(function zEx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[105]_wc3spell.j"))
call VRx(qa,(function zXx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[317]_wc3spell.j"))
call VRx(qa,(function zOx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[319]_wc3spell.j"))
call VRx(qa,(function zRx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[83]_wc3spell.j"))
call VRx(qa,(function zIx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[321]_wc3spell.j"))
call VRx(qa,(function zAx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[322]_wc3spell.j"))
call VRx(qa,(function zNx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[323]_wc3spell.j"))
call VRx(qa,(function zbx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[326]_wc3spell.j"))
call VRx(qa,(function zBx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[106]_wc3spell.j"))
call VRx(qa,(function zcx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[1]_wc3spell.j"))
call VRx(qa,(function zCx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[327]_wc3spell.j"))
call VRx(qa,(function zdx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[9]_wc3spell.j"))
call VRx(qa,(function zDx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[331]_wc3spell.j"))
call VRx(qa,(function zfx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[335]_wc3spell.j"))
call VRx(qa,(function zFx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[336]_wc3spell.j"))
call VRx(qa,(function zgx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[337]_wc3spell.j"))
call VRx(qa,(function zGx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[339]_wc3spell.j"))
call VRx(qa,(function zhx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[340]_wc3spell.j"))
call VRx(Ma,(function zHx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_transBuff_wc3buff.j"))
call VRx(qa,(function zjx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[341]_wc3spell.j"))
call VRx(qa,(function zJx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[346]_wc3spell.j"))
call VRx(qa,(function zkx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[347]_wc3spell.j"))
call VRx(qa,(function zKx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[34]_wc3spell.j"))
call VRx(qa,(function zlx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[350]_wc3spell.j"))
call VRx(qa,(function zLx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[351]_wc3spell.j"))
call VRx(qa,(function zmx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[352]_wc3spell.j"))
call VRx(qa,(function zMx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[355]_wc3spell.j"))
call VRx(qa,(function zpx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[358]_wc3spell.j"))
call VRx(qa,(function zPx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[359]_wc3spell.j"))
call VRx(qa,(function zqx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[13]_wc3spell.j"))
call VRx(qa,(function zQx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[35]_wc3spell.j"))
call VRx(qa,(function zsx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[360]_wc3spell.j"))
call VRx(qa,(function zSx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[361]_wc3spell.j"))
call VRx(qa,(function ztx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[364]_wc3spell.j"))
call VRx(qa,(function zTx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[367]_wc3spell.j"))
call VRx(qa,(function zux),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[36]_wc3spell.j"))
call VRx(qa,(function zUx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[370]_wc3spell.j"))
call VRx(qa,(function zwx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[371]_wc3spell.j"))
call VRx(qa,(function zWx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[372]_wc3spell.j"))
call VRx(qa,(function zyx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[375]_wc3spell.j"))
call VRx(qa,(function zYx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[376]_wc3spell.j"))
call VRx(qa,(function zzx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[37]_wc3spell.j"))
call VRx(qa,(function zZx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[117]_wc3spell.j"))
call VRx(qa,(function z_x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[380]_wc3spell.j"))
call VRx(qa,(function z0x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[381]_wc3spell.j"))
call VRx(qa,(function z1x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[382]_wc3spell.j"))
call VRx(qa,(function z2x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[383]_wc3spell.j"))
call VRx(qa,(function z3x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[384]_wc3spell.j"))
call VRx(qa,(function z4x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[385]_wc3spell.j"))
call VRx(qa,(function z5x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[387]_wc3spell.j"))
call VRx(qa,(function z6x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[388]_wc3spell.j"))
call VRx(qa,(function z7x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[389]_wc3spell.j"))
call VRx(qa,(function z8x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[38]_wc3spell.j"))
call VRx(qa,(function z9x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[391]_wc3spell.j"))
call VRx(qa,(function Zvx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[392]_wc3spell.j"))
call VRx(qa,(function Zex),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[393]_wc3spell.j"))
call VRx(qa,(function Zxx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[395]_wc3spell.j"))
call VRx(qa,(function Zox),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[396]_wc3spell.j"))
call VRx(qa,(function Zrx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[296]_wc3spell.j"))
call VRx(qa,(function Zix),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[280]_wc3spell.j"))
call VRx(qa,(function Zax),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[400]_wc3spell.j"))
call VRx(qa,(function Znx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[403]_wc3spell.j"))
call VRx(qa,(function ZVx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[404]_wc3spell.j"))
call VRx(qa,(function ZEx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[405]_wc3spell.j"))
call VRx(qa,(function ZXx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[40]_wc3spell.j"))
call VRx(qa,(function ZOx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[413]_wc3spell.j"))
call VRx(qa,(function ZRx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[417]_wc3spell.j"))
call VRx(qa,(function ZIx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[419]_wc3spell.j"))
call VRx(qa,(function ZAx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[41]_wc3spell.j"))
call VRx(qa,(function ZNx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[420]_wc3spell.j"))
call VRx(qa,(function Zbx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[285]_wc3spell.j"))
call VRx(qa,(function ZBx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[421]_wc3spell.j"))
call VRx(qa,(function Zcx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[422]_wc3spell.j"))
call VRx(qa,(function ZCx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[423]_wc3spell.j"))
call VRx(qa,(function Zdx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[424]_wc3spell.j"))
call VRx(qa,(function ZDx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[425]_wc3spell.j"))
call VRx(qa,(function Zfx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[429]_wc3spell.j"))
call VRx(qa,(function ZFx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[42]_wc3spell.j"))
call VRx(qa,(function Zgx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[431]_wc3spell.j"))
call VRx(qa,(function ZGx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[433]_wc3spell.j"))
call VRx(qa,(function Zhx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[436]_wc3spell.j"))
call VRx(qa,(function ZHx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[10]_wc3spell.j"))
call VRx(qa,(function Zjx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[43]_wc3spell.j"))
call VRx(qa,(function ZJx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[442]_wc3spell.j"))
call VRx(qa,(function Zkx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[5]_wc3spell.j"))
call VRx(qa,(function ZKx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[127]_wc3spell.j"))
call VRx(qa,(function Zlx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[445]_wc3spell.j"))
call VRx(qa,(function ZLx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[447]_wc3spell.j"))
call VRx(qa,(function Zmx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[363]_wc3spell.j"))
call VRx(qa,(function ZMx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[44]_wc3spell.j"))
call VRx(qa,(function Zpx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[452]_wc3spell.j"))
call VRx(qa,(function ZPx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[456]_wc3spell.j"))
call VRx(qa,(function Zqx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[458]_wc3spell.j"))
call VRx(qa,(function ZQx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[459]_wc3spell.j"))
call VRx(qa,(function Zsx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[460]_wc3spell.j"))
call VRx(qa,(function ZSx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[461]_wc3spell.j"))
call VRx(qa,(function Ztx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[462]_wc3spell.j"))
call VRx(qa,(function ZTx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[463]_wc3spell.j"))
call VRx(qa,(function Zux),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[464]_wc3spell.j"))
call VRx(qa,(function ZUx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[465]_wc3spell.j"))
call VRx(qa,(function Zwx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[467]_wc3spell.j"))
call VRx(qa,(function ZWx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[8]_wc3spell.j"))
call VRx(qa,(function Zyx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[468]_wc3spell.j"))
call VRx(qa,(function ZYx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[470]_wc3spell.j"))
call VRx(qa,(function Zzx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[471]_wc3spell.j"))
call VRx(qa,(function ZZx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[473]_wc3spell.j"))
call VRx(qa,(function Z_x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[475]_wc3spell.j"))
call VRx(qa,(function Z0x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[476]_wc3spell.j"))
call VRx(qa,(function Z1x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[478]_wc3spell.j"))
call VRx(qa,(function Z2x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[479]_wc3spell.j"))
call VRx(qa,(function Z3x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[47]_wc3spell.j"))
call VRx(qa,(function Z4x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[480]_wc3spell.j"))
call VRx(qa,(function Z5x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[482]_wc3spell.j"))
call VRx(qa,(function Z6x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[484]_wc3spell.j"))
call VRx(qa,(function Z7x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[487]_wc3spell.j"))
call VRx(qa,(function Z8x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[488]_wc3spell.j"))
call VRx(qa,(function Z9x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[489]_wc3spell.j"))
call VRx(qa,(function vvo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[48]_wc3spell.j"))
call VRx(qa,(function veo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[490]_wc3spell.j"))
call VRx(qa,(function vxo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[491]_wc3spell.j"))
call VRx(qa,(function voo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[120]_wc3spell.j"))
call VRx(qa,(function vro),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[492]_wc3spell.j"))
call VRx(qa,(function vio),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[493]_wc3spell.j"))
call VRx(qa,(function vao),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[494]_wc3spell.j"))
call VRx(qa,(function vno),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[495]_wc3spell.j"))
call VRx(qa,(function vVo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[498]_wc3spell.j"))
call VRx(qa,(function vEo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[500]_wc3spell.j"))
call VRx(qa,(function vXo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[50]_wc3spell.j"))
call VRx(qa,(function vOo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[52]_wc3spell.j"))
call VRx(qa,(function vRo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[53]_wc3spell.j"))
call VRx(qa,(function vIo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[54]_wc3spell.j"))
call VRx(qa,(function vAo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[55]_wc3spell.j"))
call VRx(qa,(function vNo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[57]_wc3spell.j"))
call VRx(qa,(function vbo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[58]_wc3spell.j"))
call VRx(qa,(function vBo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[59]_wc3spell.j"))
call VRx(qa,(function vco),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[362]_wc3spell.j"))
call VRx(qa,(function vCo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[60]_wc3spell.j"))
call VRx(qa,(function vdo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[63]_wc3spell.j"))
call VRx(qa,(function vDo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[65]_wc3spell.j"))
call VRx(qa,(function vfo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[67]_wc3spell.j"))
call VRx(qa,(function vFo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[71]_wc3spell.j"))
call VRx(qa,(function vgo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[72]_wc3spell.j"))
call VRx(qa,(function vGo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[74]_wc3spell.j"))
call VRx(qa,(function vho),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[79]_wc3spell.j"))
call VRx(qa,(function vHo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[82]_wc3spell.j"))
call VRx(qa,(function vjo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[85]_wc3spell.j"))
call VRx(qa,(function vJo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[86]_wc3spell.j"))
call VRx(qa,(function vko),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[88]_wc3spell.j"))
call VRx(qa,(function vKo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[89]_wc3spell.j"))
call VRx(qa,(function vlo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[90]_wc3spell.j"))
call VRx(qa,(function vLo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[70]_wc3spell.j"))
call VRx(qa,(function vmo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[93]_wc3spell.j"))
call VRx(qa,(function vMo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[94]_wc3spell.j"))
call VRx(qa,(function vpo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[96]_wc3spell.j"))
call VRx(qa,(function vPo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[172]_wc3spell.j"))
call VRx(qa,(function vqo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[166]_wc3spell.j"))
call VRx(qa,(function vQo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[330]_wc3spell.j"))
call VRx(qa,(function vso),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[191]_wc3spell.j"))
call VRx(qa,(function vSo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[7]_wc3spell.j"))
call VRx(qa,(function vto),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[32]_wc3spell.j"))
call VRx(qa,(function vTo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[374]_wc3spell.j"))
call VRx(qa,(function vuo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[287]_wc3spell.j"))
call VRx(qa,(function vUo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[16]_wc3spell.j"))
call VRx(qa,(function vwo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[249]_wc3spell.j"))
call VRx(qa,(function vWo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[255]_wc3spell.j"))
call VRx(qa,(function vyo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[80]_wc3spell.j"))
call VRx(qa,(function vYo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[137]_wc3spell.j"))
call VRx(qa,(function vzo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[450]_wc3spell.j"))
call VRx(qa,(function vZo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[99]_wc3spell.j"))
call VRx(qa,(function v_o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[469]_wc3spell.j"))
call VRx(qa,(function v0o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[231]_wc3spell.j"))
call VRx(qa,(function v1o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[281]_wc3spell.j"))
call VRx(qa,(function v2o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[377]_wc3spell.j"))
call VRx(qa,(function v3o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[333]_wc3spell.j"))
call VRx(qa,(function v4o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[84]_wc3spell.j"))
call VRx(qa,(function v5o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[397]_wc3spell.j"))
call VRx(qa,(function v6o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[223]_wc3spell.j"))
call VRx(qa,(function v7o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[130]_wc3spell.j"))
call VRx(qa,(function v8o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[122]_wc3spell.j"))
call VRx(qa,(function v9o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[212]_wc3spell.j"))
call VRx(qa,(function evo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[139]_wc3spell.j"))
call VRx(qa,(function eeo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[437]_wc3spell.j"))
call VRx(qa,(function exo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[21]_wc3spell.j"))
call VRx(qa,(function eoo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[229]_wc3spell.j"))
call VRx(qa,(function ero),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[446]_wc3spell.j"))
call VRx(qa,(function eio),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[15]_wc3spell.j"))
call VRx(qa,(function eao),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[453]_wc3spell.j"))
call VRx(qa,(function eno),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[64]_wc3spell.j"))
call VRx(qa,(function eVo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[0]_wc3spell.j"))
call VRx(qa,(function eEo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[24]_wc3spell.j"))
call VRx(qa,(function eXo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[11]_wc3spell.j"))
call VRx(qa,(function eOo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[455]_wc3spell.j"))
call VRx(qa,(function eRo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[288]_wc3spell.j"))
call VRx(qa,(function eIo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[3]_wc3spell.j"))
call VRx(qa,(function eAo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[78]_wc3spell.j"))
call VRx(qa,(function eNo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[201]_wc3spell.j"))
call VRx(qa,(function ebo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[472]_wc3spell.j"))
call VRx(qa,(function eBo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[325]_wc3spell.j"))
call VRx(qa,(function eco),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[133]_wc3spell.j"))
call VRx(qa,(function eCo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[81]_wc3spell.j"))
call VRx(qa,(function edo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[217]_wc3spell.j"))
call VRx(qa,(function eDo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[357]_wc3spell.j"))
call VRx(qa,(function efo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[206]_wc3spell.j"))
call VRx(qa,(function eFo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[95]_wc3spell.j"))
call VRx(qa,(function ego),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[101]_wc3spell.j"))
call VRx(qa,(function eGo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[448]_wc3spell.j"))
call VRx(qa,(function eho),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[428]_wc3spell.j"))
call VRx(qa,(function eHo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[176]_wc3spell.j"))
call VRx(qa,(function ejo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[69]_wc3spell.j"))
call VRx(qa,(function eJo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[205]_wc3spell.j"))
call VRx(qa,(function eko),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[271]_wc3spell.j"))
call VRx(qa,(function eKo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[481]_wc3spell.j"))
call VRx(qa,(function elo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[141]_wc3spell.j"))
call VRx(qa,(function eLo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[412]_wc3spell.j"))
call VRx(qa,(function emo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[153]_wc3spell.j"))
call VRx(qa,(function eMo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[443]_wc3spell.j"))
call VRx(qa,(function epo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[328]_wc3spell.j"))
call VRx(qa,(function ePo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[390]_wc3spell.j"))
call VRx(qa,(function eqo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[369]_wc3spell.j"))
call VRx(qa,(function eQo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[39]_wc3spell.j"))
call VRx(qa,(function eso),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[418]_wc3spell.j"))
call VRx(qa,(function eSo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[474]_wc3spell.j"))
call VRx(Ma,(function eto),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_moddedBuff_wc3buff.j"))
call VRx(qa,(function eTo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[410]_wc3spell.j"))
call VRx(qa,(function euo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[110]_wc3spell.j"))
call VRx(qa,(function eUo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[76]_wc3spell.j"))
call VRx(qa,(function ewo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[342]_wc3spell.j"))
call VRx(qa,(function eWo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[402]_wc3spell.j"))
call VRx(qa,(function eyo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[175]_wc3spell.j"))
call VRx(qa,(function eYo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[253]_wc3spell.j"))
call VRx(qa,(function ezo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[111]_wc3spell.j"))
call VRx(qa,(function eZo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[113]_wc3spell.j"))
call VRx(qa,(function e_o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[373]_wc3spell.j"))
call VRx(qa,(function e0o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[332]_wc3spell.j"))
call VRx(qa,(function e1o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[237]_wc3spell.j"))
call VRx(qa,(function e2o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[66]_wc3spell.j"))
call VRx(qa,(function e3o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[324]_wc3spell.j"))
call VRx(qa,(function e4o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[61]_wc3spell.j"))
call VRx(qa,(function e5o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[125]_wc3spell.j"))
call VRx(qa,(function e6o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[87]_wc3spell.j"))
call VRx(qa,(function e7o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[379]_wc3spell.j"))
call VRx(qa,(function e8o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[366]_wc3spell.j"))
call VRx(qa,(function e9o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[407]_wc3spell.j"))
call VRx(qa,(function xvo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[164]_wc3spell.j"))
call VRx(qa,(function xeo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[338]_wc3spell.j"))
call VRx(qa,(function xxo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[73]_wc3spell.j"))
call VRx(qa,(function xoo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[406]_wc3spell.j"))
call VRx(qa,(function xro),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[348]_wc3spell.j"))
call VRx(qa,(function xio),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[132]_wc3spell.j"))
call VRx(qa,(function xao),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[241]_wc3spell.j"))
call VRx(qa,(function xno),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[218]_wc3spell.j"))
call VRx(qa,(function xVo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[439]_wc3spell.j"))
call VRx(qa,(function xEo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[162]_wc3spell.j"))
call VRx(qa,(function xXo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[399]_wc3spell.j"))
call VRx(qa,(function xOo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[297]_wc3spell.j"))
call VRx(qa,(function xRo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[51]_wc3spell.j"))
call VRx(qa,(function xIo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[497]_wc3spell.j"))
call VRx(qa,(function xAo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[272]_wc3spell.j"))
call VRx(qa,(function xNo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[228]_wc3spell.j"))
call VRx(qa,(function xbo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[25]_wc3spell.j"))
call VRx(qa,(function xBo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[98]_wc3spell.j"))
call VRx(qa,(function xco),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[409]_wc3spell.j"))
call VRx(qa,(function xCo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[28]_wc3spell.j"))
call VRx(qa,(function xdo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[365]_wc3spell.j"))
call VRx(qa,(function xDo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[45]_wc3spell.j"))
call VRx(qa,(function xfo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[320]_wc3spell.j"))
call VRx(qa,(function xFo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[334]_wc3spell.j"))
call VRx(qa,(function xgo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[426]_wc3spell.j"))
call VRx(qa,(function xGo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[435]_wc3spell.j"))
call VRx(qa,(function xho),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[161]_wc3spell.j"))
call VRx(qa,(function xHo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[75]_wc3spell.j"))
call VRx(qa,(function xjo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[329]_wc3spell.j"))
call VRx(qa,(function xJo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[31]_wc3spell.j"))
call VRx(qa,(function xko),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[4]_wc3spell.j"))
call VRx(qa,(function xKo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[309]_wc3spell.j"))
call VRx(qa,(function xlo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[2]_wc3spell.j"))
call VRx(qa,(function xLo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[33]_wc3spell.j"))
call VRx(qa,(function xmo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[430]_wc3spell.j"))
call VRx(qa,(function xMo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[457]_wc3spell.j"))
call VRx(qa,(function xpo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[68]_wc3spell.j"))
call VRx(qa,(function xPo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[62]_wc3spell.j"))
call VRx(qa,(function xqo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[262]_wc3spell.j"))
call VRx(qa,(function xQo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[274]_wc3spell.j"))
call VRx(qa,(function xso),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[23]_wc3spell.j"))
call VRx(qa,(function xSo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[414]_wc3spell.j"))
call VRx(qa,(function xto),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[236]_wc3spell.j"))
call VRx(qa,(function xTo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[432]_wc3spell.j"))
call VRx(qa,(function xuo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[22]_wc3spell.j"))
call VRx(qa,(function xUo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[451]_wc3spell.j"))
call VRx(qa,(function xwo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[128]_wc3spell.j"))
call VRx(qa,(function xWo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[199]_wc3spell.j"))
call VRx(qa,(function xyo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[483]_wc3spell.j"))
call VRx(qa,(function xYo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[168]_wc3spell.j"))
call VRx(qa,(function xzo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[264]_wc3spell.j"))
call VRx(qa,(function xZo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[198]_wc3spell.j"))
call VRx(qa,(function x_o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[273]_wc3spell.j"))
call VRx(qa,(function x0o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[345]_wc3spell.j"))
call VRx(qa,(function x1o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[46]_wc3spell.j"))
call VRx(qa,(function x2o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[185]_wc3spell.j"))
call VRx(qa,(function x3o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[224]_wc3spell.j"))
call VRx(qa,(function x4o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[77]_wc3spell.j"))
call VRx(qa,(function x5o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[142]_wc3spell.j"))
call VRx(qa,(function x6o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[18]_wc3spell.j"))
call VRx(qa,(function x7o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[454]_wc3spell.j"))
call VRx(qa,(function x8o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[415]_wc3spell.j"))
call VRx(qa,(function x9o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[92]_wc3spell.j"))
call VRx(qa,(function ovo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[378]_wc3spell.j"))
call VRx(qa,(function oeo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[151]_wc3spell.j"))
call VRx(qa,(function oxo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[216]_wc3spell.j"))
call VRx(qa,(function ooo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[368]_wc3spell.j"))
call VRx(qa,(function oro),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[485]_wc3spell.j"))
call VRx(qa,(function oio),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[174]_wc3spell.j"))
call VRx(qa,(function oao),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[394]_wc3spell.j"))
call VRx(qa,(function ono),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[209]_wc3spell.j"))
call VRx(qa,(function oVo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[343]_wc3spell.j"))
call VRx(qa,(function oEo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[411]_wc3spell.j"))
call VRx(qa,(function oXo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[202]_wc3spell.j"))
call VRx(qa,(function oOo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[180]_wc3spell.j"))
call VRx(qa,(function oRo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[196]_wc3spell.j"))
call VRx(qa,(function oIo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[187]_wc3spell.j"))
call VRx(qa,(function oAo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[214]_wc3spell.j"))
call VRx(qa,(function oNo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[183]_wc3spell.j"))
call VRx(qa,(function obo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[178]_wc3spell.j"))
call VRx(qa,(function oBo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[123]_wc3spell.j"))
call VRx(qa,(function oco),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[318]_wc3spell.j"))
call VRx(qa,(function oCo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[56]_wc3spell.j"))
call VRx(qa,(function odo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[197]_wc3spell.j"))
call VRx(qa,(function oDo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[496]_wc3spell.j"))
call VRx(qa,(function ofo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[163]_wc3spell.j"))
call VRx(qa,(function oFo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[449]_wc3spell.j"))
call VRx(qa,(function ogo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[91]_wc3spell.j"))
call VRx(qa,(function oGo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[171]_wc3spell.j"))
call VRx(qa,(function oho),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[486]_wc3spell.j"))
call VRx(qa,(function oHo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[398]_wc3spell.j"))
call VRx(qa,(function ojo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[97]_wc3spell.j"))
call VRx(qa,(function oJo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[416]_wc3spell.j"))
call VRx(qa,(function oko),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[283]_wc3spell.j"))
call VRx(qa,(function oKo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[315]_wc3spell.j"))
call VRx(qa,(function olo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[316]_wc3spell.j"))
call VRx(qa,(function oLo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[155]_wc3spell.j"))
call VRx(qa,(function omo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[26]_wc3spell.j"))
call VRx(qa,(function oMo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[116]_wc3spell.j"))
call VRx(qa,(function opo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[121]_wc3spell.j"))
call VRx(qa,(function oPo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[314]_wc3spell.j"))
call VRx(qa,(function oqo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[441]_wc3spell.j"))
call VRx(qa,(function oQo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[186]_wc3spell.j"))
call VRx(qa,(function oso),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[159]_wc3spell.j"))
call VRx(qa,(function oSo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[466]_wc3spell.j"))
call VRx(qa,(function oto),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[6]_wc3spell.j"))
call VRx(qa,(function oTo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[29]_wc3spell.j"))
call VRx(qa,(function ouo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[401]_wc3spell.j"))
call VRx(qa,(function oUo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[135]_wc3spell.j"))
call VRx(qa,(function owo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[131]_wc3spell.j"))
call VRx(qa,(function oWo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[239]_wc3spell.j"))
call VRx(qa,(function oyo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[353]_wc3spell.j"))
call VRx(qa,(function oYo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[248]_wc3spell.j"))
call VRx(qa,(function ozo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[215]_wc3spell.j"))
call VRx(qa,(function oZo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[144]_wc3spell.j"))
call VRx(qa,(function o_o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[17]_wc3spell.j"))
call VRx(qa,(function o0o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[293]_wc3spell.j"))
call VRx(qa,(function o1o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[265]_wc3spell.j"))
call VRx(qa,(function o2o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[349]_wc3spell.j"))
call VRx(qa,(function o3o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[477]_wc3spell.j"))
call VRx(qa,(function o4o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[148]_wc3spell.j"))
call VRx(qa,(function o5o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[440]_wc3spell.j"))
call VRx(qa,(function o6o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[213]_wc3spell.j"))
call VRx(qa,(function o7o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[177]_wc3spell.j"))
call VRx(qa,(function o8o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[386]_wc3spell.j"))
call VRx(qa,(function o9o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[221]_wc3spell.j"))
call VRx(qa,(function rvo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[408]_wc3spell.j"))
call VRx(qa,(function reo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[203]_wc3spell.j"))
call VRx(qa,(function rxo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[219]_wc3spell.j"))
call VRx(qa,(function roo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[499]_wc3spell.j"))
call VRx(qa,(function rro),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[344]_wc3spell.j"))
call VRx(qa,(function rio),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[438]_wc3spell.j"))
call VRx(qa,(function rao),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[115]_wc3spell.j"))
call VRx(qa,(function rno),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[356]_wc3spell.j"))
call VRx(qa,(function rVo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[354]_wc3spell.j"))
call VRx(qa,(function rEo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[240]_wc3spell.j"))
call VRx(qa,(function rXo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[188]_wc3spell.j"))
call VRx(qa,(function rOo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[129]_wc3spell.j"))
call VRx(qa,(function rRo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[119]_wc3spell.j"))
call VRx(qa,(function rIo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[126]_wc3spell.j"))
call VRx(qa,(function rAo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[300]_wc3spell.j"))
call VRx(qa,(function rNo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[49]_wc3spell.j"))
call VRx(qa,(function rbo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[124]_wc3spell.j"))
call VRx(qa,(function rBo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[444]_wc3spell.j"))
call VRx(qa,(function rco),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[109]_wc3spell.j"))
call VRx(qa,(function rCo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[114]_wc3spell.j"))
call VRx(qa,(function rdo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[149]_wc3spell.j"))
call VRx(qa,(function rDo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[434]_wc3spell.j"))
call VRx(qa,(function rfo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[184]_wc3spell.j"))
return true
endfunction
function rgo takes nothing returns boolean
set aWv=Vnx(awv)
return true
endfunction
function rGo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
call I7x((oqx),ayv)
call I7x((oqx),aYv)
return true
endfunction
function rho takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
call Rmx((oqx),ayv)
call Rmx((oqx),aYv)
return true
endfunction
function rHo takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
call Ayx((oqx),EJ)
call Dmx(oqx)
endfunction
function rjo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
local integer OHx=inx()
set azv[oqx]=OHx
set ge[(OHx)]=(oqx)
call icx(OHx,1.01,false,function rHo)
return true
endfunction
function rJo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
local integer OHx=azv[oqx]
call ijx(OHx)
return true
endfunction
function rko takes nothing returns boolean
call l9x(uj,XBx("FolderUnit_StructScale_Buff_Init: call FolderUnit_StructScale.MODDED_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructScale.Event_Modded_BuffGain))",Bd,BI,function rGo))
call l9x(uj,XBx("FolderUnit_StructScale_Buff_Init: call FolderUnit_StructScale.MODDED_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructScale.Event_Modded_BuffLose))",Jc,BI,function rho))
call l9x(EJ,XBx("FolderUnit_StructScale_Buff_Init: call FolderUnit_StructScale.TRANS_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructScale.Event_Trans_BuffGain))",Bd,BI,function rjo))
call l9x(EJ,XBx("FolderUnit_StructScale_Buff_Init: call FolderUnit_StructScale.TRANS_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructScale.Event_Trans_BuffLose))",Jc,BI,function rJo))
return true
endfunction
function rKo takes nothing returns boolean
call u6x(function rko,"FolderUnit_StructScale_Buff_Init")
return true
endfunction
function rlo takes nothing returns boolean
set aZv=Vnx(a_v)
return true
endfunction
function rLo takes nothing returns boolean
set a0v=Vnx(a1v)
return true
endfunction
function rmo takes nothing returns boolean
set a2v=Vnx(a3v)
return true
endfunction
function rMo takes nothing returns boolean
set a4v=Vnx(a5v)
return true
endfunction
function rpo takes nothing returns boolean
set bk=Vnx(Xk)
return true
endfunction
function rPo takes nothing returns boolean
set a6v=Vnx(a7v)
return true
endfunction
function rqo takes nothing returns boolean
set a8v=lQx(a9v+" (dummyBuff)")
set SU=lYx()
call l_x(SU,nvv,-.15)
call l_x(SU,nev,-.1)
call l_x(SU,ZU,-.2)
call l0x(((a8v)),vc+(1),(SU))
return true
endfunction
function rQo takes integer oqx,integer o2x returns nothing
call lzx((oqx),Fc,o2x)
endfunction
function rso takes integer oqx returns integer
set nVv[oqx]=true
set nEv[oqx]=false
call rax(nXv)
return oqx
endfunction
function rSo takes nothing returns integer
local integer oqx
if(nov==8190)then
call oYx("UnitMod_Allocation_allocCustom","call DebugEx(UnitMod.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",nrv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(niv[(w)]==w)then
set nav=nav+1
set oqx=nav
else
set oqx=niv[(w)]
set niv[(w)]=niv[niv[(w)]]
endif
set niv[oqx]=Z
set nnv[oqx]=1
call rso(oqx)
return oqx
endfunction
function rto takes integer IXx,code rTo,code ruo returns integer
local integer oqx=rSo()
set nOv[(oqx)]=(IXx)
set Lc[(oqx)]=(XHx(rTo))
set hc[(oqx)]=(XHx(ruo))
return oqx
endfunction
function rUo takes nothing returns boolean
local integer rdx=(bv)
local integer Ipx=(Gc[(rdx)])
call fhx(((Vv[(rdx)])),nIv[(Ipx)],nAv[(Ipx)],nNv[(Ipx)],nbv[(Ipx)])
return true
endfunction
function rwo takes nothing returns boolean
local integer rdx=(bv)
local integer Ipx=(Gc[(rdx)])
call fhx((((Vv[(rdx)]))),-((nIv[(Ipx)])*1.),-((nAv[(Ipx)])*1.),-((nNv[(Ipx)])*1.),-((nbv[(Ipx)])*1.))
return true
endfunction
function rWo takes integer oqx,real iWx,real iyx,real iYx,real izx returns integer
local integer Ipx=rto(nRv,function rUo,function rwo)
set nIv[(Ipx)]=iWx
set nAv[(Ipx)]=iyx
set nNv[(Ipx)]=iYx
set nbv[(Ipx)]=izx
return Ipx
endfunction
function ryo takes nothing returns boolean
set nxv=WTx('BCol',"Cold",'bCol')
set aev[(nxv)]=("ReplaceableTextures\\CommandButtons\\BTNFrost.blp")
call lux(nxv,"Abilities\\Spells\\Other\\FrostDamage\\FrostDamage.mdl","chest",ri)
set SU=lYx()
call rQo(SU,rWo(Db,-'}',-'}',0,0))
call l0x(((nxv)),vc+(1),(SU))
return true
endfunction
function rYo takes nothing returns boolean
call VRx(Ma,(function rqo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Cold\\obj_dummyBuff_wc3buff.j"))
call VRx(Ma,(function ryo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Cold\\obj_normalBuff_wc3buff.j"))
return true
endfunction
function rzo takes nothing returns boolean
set nBv=Vnx(a9v)
return true
endfunction
function rZo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set ncv[((rkx))]=(true)
return true
endfunction
function r_o takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set ncv[((rkx))]=(false)
return true
endfunction
function r0o takes nothing returns boolean
call l9x(a8v,XBx("FolderUnit_StructCold_Buff_Init: call FolderUnit_StructCold.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructCold.Event_BuffGain))",Bd,pI,function rZo))
call l9x(a8v,XBx("FolderUnit_StructCold_Buff_Init: call FolderUnit_StructCold.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructCold.Event_BuffLose))",Jc,pI,function r_o))
return true
endfunction
function r1o takes nothing returns boolean
call u6x(function r0o,"FolderUnit_StructCold_Buff_Init")
return true
endfunction
function r2o takes nothing returns boolean
set nCv=WTx('BFro',"Frost",'bFro')
set aev[(nCv)]=("ReplaceableTextures\\CommandButtons\\BTNFreezingBreath.blp")
call lux(nCv,"Unit_page\\Unit_struct\\Frost\\FreezingBreathTargetArt.mdx","origin",ri)
return true
endfunction
function r3o takes nothing returns boolean
set ndv=lQx(nDv+" (dummyBuff)")
return true
endfunction
function r4o takes nothing returns boolean
call VRx(Ma,(function r2o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Frost\\obj_normalBuff_wc3buff.j"))
call VRx(Ma,(function r3o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Frost\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function r5o takes nothing returns boolean
set nfv=Vnx(nDv)
return true
endfunction
function r6o takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set nFv[(rkx)]=(ngv)
return true
endfunction
function r7o takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set nFv[(rkx)]=((nGv[((uf[(rkx)]))]))
return true
endfunction
function r8o takes nothing returns boolean
call l9x(ndv,XBx("FolderUnit_StructFrost_Buff_Init: call FolderUnit_StructFrost.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructFrost.Event_BuffGain))",Bd,pI,function r6o))
call l9x(ndv,XBx("FolderUnit_StructFrost_Buff_Init: call FolderUnit_StructFrost.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructFrost.Event_BuffLose))",Jc,pI,function r7o))
call W_x(ndv,nCv)
call W_x(a8v,ndv)
call W_x(r9v,ndv)
call W_x(nhv,ndv)
return true
endfunction
function r9o takes nothing returns boolean
call u6x(function r8o,"FolderUnit_StructFrost_Buff_Init")
return true
endfunction
function ivo takes nothing returns boolean
set nHv=lQx(njv+" (dummyBuff)")
return true
endfunction
function ieo takes nothing returns boolean
call VRx(Ma,(function ivo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Invisibility\\Reveal\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function ixo takes nothing returns boolean
set nJv=Vnx(njv)
return true
endfunction
function ioo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set nkv[((rkx))]=(true)
if(xk[(rkx)])then
call UnitRemoveAbility(C[((rkx))],('Apiv'))
call RUx((Abx((rkx),(nKv),(nlv),(ri))))
call SetUnitVertexColor(C[rkx],(R2I((((zJ[(rkx)]))*1.))),(R2I((((ZJ[(rkx)]))*1.))),(R2I((((vk[(rkx)]))*1.))),ok)
endif
return true
endfunction
function iro takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set nkv[((rkx))]=(false)
if(xk[(rkx)])then
call rQx(rkx,'Apiv')
endif
return true
endfunction
function iio takes nothing returns boolean
call l9x(nHv,XBx("FolderUnit_FolderInvisibility_StructReveal_Buff_Init: call FolderUnit_FolderInvisibility_StructReveal.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderInvisibility_StructReveal.Event_BuffGain))",Bd,pI,function ioo))
call l9x(nHv,XBx("FolderUnit_FolderInvisibility_StructReveal_Buff_Init: call FolderUnit_FolderInvisibility_StructReveal.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderInvisibility_StructReveal.Event_BuffLose))",Jc,pI,function iro))
return true
endfunction
function iao takes nothing returns boolean
call u6x(function iio,"FolderUnit_FolderInvisibility_StructReveal_Buff_Init")
return true
endfunction
function ino takes nothing returns boolean
set nLv=lQx(nmv+" (dummyBuff)")
return true
endfunction
function iVo takes nothing returns boolean
set nMv=lQx(nmv+" (permBuff)")
return true
endfunction
function iEo takes nothing returns boolean
call LZx('Apiv',false)
return true
endfunction
function iXo takes nothing returns boolean
set npv=lQx(nmv+" (timedBuff)")
return true
endfunction
function iOo takes nothing returns boolean
call VRx(Ma,(function ino),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Invisibility\\obj_dummyBuff_wc3buff.j"))
call VRx(Ma,(function iVo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Invisibility\\obj_permBuff_wc3buff.j"))
call VRx(qa,(function iEo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Invisibility\\obj_dummySpell_wc3spell.j"))
call VRx(Ma,(function iXo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Invisibility\\obj_timedBuff_wc3buff.j"))
return true
endfunction
function iRo takes nothing returns boolean
set nPv=Vnx(nmv)
return true
endfunction
function iIo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
local integer iAo
set xk[(oqx)]=(true)
set iAo=inx()
set nqv[oqx]=iAo
set ge[(iAo)]=(oqx)
call I7x(rkx,nQv)
call I7x(rkx,nsv)
if not(nkv[(oqx)])then
call rQx(rkx,'Apiv')
endif
return true
endfunction
function iNo takes integer oqx returns nothing
call fGx(oqx,(zJ[(oqx)]),(ZJ[(oqx)]),(vk[(oqx)]),(ek[(oqx)]))
endfunction
function ibo takes integer oqx returns nothing
local integer rkx=oqx
local integer rdx=rEx((A[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set Vv[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,nSv,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,nSv,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function iBo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
set xk[(oqx)]=(false)
call Rmx(rkx,nQv)
call Rmx(rkx,nsv)
call ijx(nqv[oqx])
call UnitRemoveAbility(C[((rkx))],('Apiv'))
call iNo(rkx)
call ibo(oqx)
return true
endfunction
function ico takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set ntv[((rkx))]=(true)
call DSx(((((rkx)))),(nLv),(1),w)
return true
endfunction
function iCo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set ntv[((rkx))]=(false)
call UJx((((rkx))),nLv)
return true
endfunction
function ido takes nothing returns boolean
call l9x(nLv,XBx("FolderUnit_StructInvisibility_Buff_Init: call FolderUnit_StructInvisibility.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructInvisibility.Event_BuffGain))",Bd,pI,function iIo))
call l9x(nLv,XBx("FolderUnit_StructInvisibility_Buff_Init: call FolderUnit_StructInvisibility.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructInvisibility.Event_BuffLose))",Jc,pI,function iBo))
call l9x(npv,XBx("FolderUnit_StructInvisibility_Buff_Init: call FolderUnit_StructInvisibility.TIMED_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructInvisibility.Event_BuffGain))",Bd,pI,function iIo))
call l9x(npv,XBx("FolderUnit_StructInvisibility_Buff_Init: call FolderUnit_StructInvisibility.TIMED_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructInvisibility.Event_BuffLose))",Jc,pI,function iBo))
call l9x(nMv,XBx("FolderUnit_StructInvisibility_Buff_Init: call FolderUnit_StructInvisibility.PERM_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructInvisibility.Event_PermBuffGain))",Bd,pI,function ico))
call l9x(nMv,XBx("FolderUnit_StructInvisibility_Buff_Init: call FolderUnit_StructInvisibility.PERM_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructInvisibility.Event_PermBuffLose))",Jc,pI,function iCo))
return true
endfunction
function iDo takes nothing returns boolean
call u6x(function ido,"FolderUnit_StructInvisibility_Buff_Init")
return true
endfunction
function ifo takes nothing returns boolean
set nTv=lQx(nuv+" (dummyBuff)")
return true
endfunction
function iFo takes nothing returns boolean
call LZx('Aeth',false)
return true
endfunction
function igo takes nothing returns boolean
call VRx(Ma,(function ifo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Ghost\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function iFo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Ghost\\obj_dummySpell_wc3spell.j"))
return true
endfunction
function iGo takes nothing returns boolean
set nUv=Vnx(nuv)
return true
endfunction
function iho takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set nwv[((rkx))]=(true)
call rQx(rkx,'Aeth')
return true
endfunction
function iHo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set nwv[((rkx))]=(false)
call UnitRemoveAbility(C[((rkx))],('Aeth'))
call iNo(rkx)
return true
endfunction
function ijo takes nothing returns boolean
call l9x(nTv,XBx("FolderUnit_StructGhost_Buff_Init: call FolderUnit_StructGhost.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructGhost.Event_BuffGain))",Bd,pI,function iho))
call l9x(nTv,XBx("FolderUnit_StructGhost_Buff_Init: call FolderUnit_StructGhost.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructGhost.Event_BuffLose))",Jc,pI,function iHo))
return true
endfunction
function iJo takes nothing returns boolean
call u6x(function ijo,"FolderUnit_StructGhost_Buff_Init")
return true
endfunction
function iko takes nothing returns boolean
set nWv=Vnx(nyv)
return true
endfunction
function iKo takes nothing returns boolean
set nYv=Vnx(nzv)
return true
endfunction
function ilo takes nothing returns boolean
set nZv=Vnx(n_v)
return true
endfunction
function iLo takes nothing returns boolean
set n0v=Vnx(n1v)
return true
endfunction
function imo takes nothing returns boolean
set pG[1]='SL00'
set pG[2]='SL01'
set pG[3]='SL02'
set pG[4]='SL03'
set pG[5]='SL04'
set pG[6]='SL05'
set pG[7]='SL06'
set pG[8]='SL07'
set pG[9]='SL08'
set pG[$A]='SL09'
set pG[$B]='SL0A'
set pG[$C]='SL0B'
set pG[$D]='SL0C'
set pG[$E]='SL0D'
set pG[$F]='SL0E'
set pG[16]='SL0F'
set pG[17]='SL0G'
set pG[18]='SL0H'
set pG[19]='SL0I'
set pG[20]='SL0J'
set pG[21]='SL0K'
set pG[22]='SL0L'
set pG[23]='SL0M'
set pG[24]='SL0N'
set pG[25]='SL0O'
set pG[26]='SL0P'
set pG[27]='SL0Q'
set pG[28]='SL0R'
set pG[29]='SL0S'
set pG[30]='SL0T'
set pG[31]='SL0U'
set pG[32]='SL0V'
set pG[33]='SL0W'
set pG[34]='SL0X'
set pG[35]='SL0Y'
set pG[36]='SL0Z'
set pG[37]='SL10'
set pG[38]='SL11'
set pG[39]='SL12'
set pG[40]='SL13'
set pG[41]='SL14'
set pG[42]='SL15'
set pG[43]='SL16'
set pG[44]='SL17'
set pG[45]='SL18'
set pG[46]='SL19'
set pG[47]='SL1A'
set pG[48]='SL1B'
set pG[49]='SL1C'
set pG[50]='SL1D'
set pG[51]='SL1E'
set pG[52]='SL1F'
set pG[53]='SL1G'
set pG[54]='SL1H'
set pG[55]='SL1I'
set pG[56]='SL1J'
set pG[57]='SL1K'
set pG[58]='SL1L'
set pG[59]='SL1M'
set pG[60]='SL1N'
set pG[61]='SL1O'
set pG[62]='SL1P'
set pG[63]='SL1Q'
set pG[64]='SL1R'
set pG[65]='SL1S'
set pG[66]='SL1T'
set pG[67]='SL1U'
set pG[68]='SL1V'
set pG[69]='SL1W'
set pG[70]='SL1X'
set pG[71]='SL1Y'
set pG[72]='SL1Z'
set pG[73]='SL20'
set pG[74]='SL21'
set pG[75]='SL22'
set pG[76]='SL23'
set pG[77]='SL24'
set pG[78]='SL25'
set pG[79]='SL26'
set pG[80]='SL27'
set pG[81]='SL28'
set pG[82]='SL29'
set pG[83]='SL2A'
set pG[84]='SL2B'
set pG[85]='SL2C'
set pG[86]='SL2D'
set pG[87]='SL2E'
set pG[88]='SL2F'
set pG[89]='SL2G'
set pG[90]='SL2H'
set pG[91]='SL2I'
set pG[92]='SL2J'
set pG[93]='SL2K'
set pG[94]='SL2L'
set pG[95]='SL2M'
set pG[96]='SL2N'
set pG[97]='SL2O'
set pG[98]='SL2P'
set pG[99]='SL2Q'
set pG['d']='SL2R'
set pG['e']='SL2S'
set pG['f']='SL2T'
set pG['g']='SL2U'
set pG['h']='SL2V'
set pG['i']='SL2W'
set pG['j']='SL2X'
set pG['k']='SL2Y'
set pG['l']='SL2Z'
set pG['m']='SL30'
set pG['n']='SL31'
set pG['o']='SL32'
set pG['p']='SL33'
set pG['q']='SL34'
set pG['r']='SL35'
set pG['s']='SL36'
set pG['t']='SL37'
set pG['u']='SL38'
set pG['v']='SL39'
set pG['w']='SL3A'
set pG['x']='SL3B'
set pG['y']='SL3C'
set pG['z']='SL3D'
set pG['{']='SL3E'
set pG['|']='SL3F'
set pG['}']='SL3G'
set pG[$7E]='SL3H'
set pG[$7F]='SL3I'
set pG[$80]='SL3J'
set pG[$81]='SL3K'
set pG[$82]='SL3L'
set pG[$83]='SL3M'
set pG[$84]='SL3N'
set pG[$85]='SL3O'
set pG[$86]='SL3P'
set pG[$87]='SL3Q'
set pG[$88]='SL3R'
set pG[$89]='SL3S'
set pG[$8A]='SL3T'
set pG[$8B]='SL3U'
set pG[$8C]='SL3V'
set pG[$8D]='SL3W'
set pG[$8E]='SL3X'
set pG[$8F]='SL3Y'
set pG[$90]='SL3Z'
set pG[$91]='SL40'
set pG[$92]='SL41'
set pG[$93]='SL42'
set pG[$94]='SL43'
set pG[$95]='SL44'
set pG[$96]='SL45'
set pG[$97]='SL46'
set pG[$98]='SL47'
set pG[$99]='SL48'
set pG[$9A]='SL49'
set pG[$9B]='SL4A'
set pG[$9C]='SL4B'
set pG[$9D]='SL4C'
set pG[$9E]='SL4D'
set pG[$9F]='SL4E'
set pG[$A0]='SL4F'
set pG[$A1]='SL4G'
set pG[$A2]='SL4H'
set pG[$A3]='SL4I'
set pG[$A4]='SL4J'
set pG[$A5]='SL4K'
set pG[$A6]='SL4L'
set pG[$A7]='SL4M'
set pG[$A8]='SL4N'
set pG[$A9]='SL4O'
set pG[$AA]='SL4P'
set pG[$AB]='SL4Q'
set pG[$AC]='SL4R'
set pG[$AD]='SL4S'
set pG[$AE]='SL4T'
set pG[$AF]='SL4U'
set pG[$B0]='SL4V'
set pG[$B1]='SL4W'
set pG[$B2]='SL4X'
set pG[$B3]='SL4Y'
set pG[$B4]='SL4Z'
set pG[$B5]='SL50'
set pG[$B6]='SL51'
set pG[$B7]='SL52'
set pG[$B8]='SL53'
set pG[$B9]='SL54'
set pG[$BA]='SL55'
set pG[$BB]='SL56'
set pG[$BC]='SL57'
set pG[$BD]='SL58'
set pG[$BE]='SL59'
set pG[$BF]='SL5A'
set pG[$C0]='SL5B'
set pG[$C1]='SL5C'
set pG[$C2]='SL5D'
set pG[$C3]='SL5E'
set pG[$C4]='SL5F'
set pG[$C5]='SL5G'
set pG[$C6]='SL5H'
set pG[$C7]='SL5I'
set pG[$C8]='SL5J'
set pG[$C9]='SL5K'
set pG[$CA]='SL5L'
set pG[$CB]='SL5M'
set pG[$CC]='SL5N'
set pG[$CD]='SL5O'
set pG[$CE]='SL5P'
set pG[$CF]='SL5Q'
set pG[$D0]='SL5R'
set pG[$D1]='SL5S'
set pG[$D2]='SL5T'
set pG[$D3]='SL5U'
set pG[$D4]='SL5V'
set pG[$D5]='SL5W'
set pG[$D6]='SL5X'
set pG[$D7]='SL5Y'
set pG[$D8]='SL5Z'
set pG[$D9]='SL60'
set pG[$DA]='SL61'
set pG[$DB]='SL62'
set pG[$DC]='SL63'
set pG[$DD]='SL64'
set pG[$DE]='SL65'
set pG[$DF]='SL66'
set pG[$E0]='SL67'
set pG[$E1]='SL68'
set pG[$E2]='SL69'
set pG[$E3]='SL6A'
set pG[$E4]='SL6B'
set pG[$E5]='SL6C'
set pG[$E6]='SL6D'
set pG[$E7]='SL6E'
set pG[$E8]='SL6F'
set pG[$E9]='SL6G'
set pG[$EA]='SL6H'
set pG[$EB]='SL6I'
set pG[$EC]='SL6J'
set pG[$ED]='SL6K'
set pG[$EE]='SL6L'
set pG[$EF]='SL6M'
set pG[$F0]='SL6N'
set pG[$F1]='SL6O'
set pG[$F2]='SL6P'
set pG[$F3]='SL6Q'
set pG[$F4]='SL6R'
set pG[$F5]='SL6S'
set pG[$F6]='SL6T'
set pG[$F7]='SL6U'
set pG[$F8]='SL6V'
set pG[$F9]='SL6W'
set pG[$FA]='SL6X'
set pG[$FB]='SL6Y'
set pG[$FC]='SL6Z'
set pG[$FD]='SL70'
set pG[$FE]='SL71'
set pG[$FF]='SL72'
set pG[256]='SL73'
set LG[1]='TL00'
set LG[2]='TL01'
set LG[3]='TL02'
set LG[4]='TL03'
set LG[5]='TL04'
set LG[6]='TL05'
set LG[7]='TL06'
set LG[8]='TL07'
set LG[9]='TL08'
set LG[$A]='TL09'
set LG[$B]='TL0A'
set LG[$C]='TL0B'
set LG[$D]='TL0C'
set LG[$E]='TL0D'
set LG[$F]='TL0E'
set LG[16]='TL0F'
set LG[17]='TL0G'
set LG[18]='TL0H'
set LG[19]='TL0I'
set LG[20]='TL0J'
set LG[21]='TL0K'
set LG[22]='TL0L'
set LG[23]='TL0M'
set LG[24]='TL0N'
set LG[25]='TL0O'
set LG[26]='TL0P'
set LG[27]='TL0Q'
set LG[28]='TL0R'
set LG[29]='TL0S'
set LG[30]='TL0T'
set LG[31]='TL0U'
set LG[32]='TL0V'
set LG[33]='TL0W'
set LG[34]='TL0X'
set LG[35]='TL0Y'
set LG[36]='TL0Z'
set LG[37]='TL10'
set LG[38]='TL11'
set LG[39]='TL12'
set LG[40]='TL13'
set LG[41]='TL14'
set LG[42]='TL15'
set LG[43]='TL16'
set LG[44]='TL17'
set LG[45]='TL18'
set LG[46]='TL19'
set LG[47]='TL1A'
set LG[48]='TL1B'
set LG[49]='TL1C'
set LG[50]='TL1D'
set LG[51]='TL1E'
set LG[52]='TL1F'
set LG[53]='TL1G'
set LG[54]='TL1H'
set LG[55]='TL1I'
set LG[56]='TL1J'
set LG[57]='TL1K'
set LG[58]='TL1L'
set LG[59]='TL1M'
set LG[60]='TL1N'
set LG[61]='TL1O'
set LG[62]='TL1P'
set LG[63]='TL1Q'
set LG[64]='TL1R'
set LG[65]='TL1S'
set LG[66]='TL1T'
set LG[67]='TL1U'
set LG[68]='TL1V'
set LG[69]='TL1W'
set LG[70]='TL1X'
set LG[71]='TL1Y'
set LG[72]='TL1Z'
set LG[73]='TL20'
set LG[74]='TL21'
set LG[75]='TL22'
set LG[76]='TL23'
set LG[77]='TL24'
set LG[78]='TL25'
set LG[79]='TL26'
set LG[80]='TL27'
set LG[81]='TL28'
set LG[82]='TL29'
set LG[83]='TL2A'
set LG[84]='TL2B'
set LG[85]='TL2C'
set LG[86]='TL2D'
set LG[87]='TL2E'
set LG[88]='TL2F'
set LG[89]='TL2G'
set LG[90]='TL2H'
set LG[91]='TL2I'
set LG[92]='TL2J'
set LG[93]='TL2K'
set LG[94]='TL2L'
set LG[95]='TL2M'
set LG[96]='TL2N'
set LG[97]='TL2O'
set LG[98]='TL2P'
set LG[99]='TL2Q'
set LG['d']='TL2R'
set LG['e']='TL2S'
set LG['f']='TL2T'
set LG['g']='TL2U'
set LG['h']='TL2V'
set LG['i']='TL2W'
set LG['j']='TL2X'
set LG['k']='TL2Y'
set LG['l']='TL2Z'
set LG['m']='TL30'
set LG['n']='TL31'
set LG['o']='TL32'
set LG['p']='TL33'
set LG['q']='TL34'
set LG['r']='TL35'
set LG['s']='TL36'
set LG['t']='TL37'
set LG['u']='TL38'
set LG['v']='TL39'
set LG['w']='TL3A'
set LG['x']='TL3B'
set LG['y']='TL3C'
set LG['z']='TL3D'
set LG['{']='TL3E'
set LG['|']='TL3F'
set LG['}']='TL3G'
set LG[$7E]='TL3H'
set LG[$7F]='TL3I'
set LG[$80]='TL3J'
set LG[$81]='TL3K'
set LG[$82]='TL3L'
set LG[$83]='TL3M'
set LG[$84]='TL3N'
set LG[$85]='TL3O'
set LG[$86]='TL3P'
set LG[$87]='TL3Q'
set LG[$88]='TL3R'
set LG[$89]='TL3S'
set LG[$8A]='TL3T'
set LG[$8B]='TL3U'
set LG[$8C]='TL3V'
set LG[$8D]='TL3W'
set LG[$8E]='TL3X'
set LG[$8F]='TL3Y'
set LG[$90]='TL3Z'
set LG[$91]='TL40'
set LG[$92]='TL41'
set LG[$93]='TL42'
set LG[$94]='TL43'
set LG[$95]='TL44'
set LG[$96]='TL45'
set LG[$97]='TL46'
set LG[$98]='TL47'
set LG[$99]='TL48'
set LG[$9A]='TL49'
set LG[$9B]='TL4A'
set LG[$9C]='TL4B'
set LG[$9D]='TL4C'
set LG[$9E]='TL4D'
set LG[$9F]='TL4E'
set LG[$A0]='TL4F'
set LG[$A1]='TL4G'
set LG[$A2]='TL4H'
set LG[$A3]='TL4I'
set LG[$A4]='TL4J'
set LG[$A5]='TL4K'
set LG[$A6]='TL4L'
set LG[$A7]='TL4M'
set LG[$A8]='TL4N'
set LG[$A9]='TL4O'
set LG[$AA]='TL4P'
set LG[$AB]='TL4Q'
set LG[$AC]='TL4R'
set LG[$AD]='TL4S'
set LG[$AE]='TL4T'
set LG[$AF]='TL4U'
set LG[$B0]='TL4V'
set LG[$B1]='TL4W'
set LG[$B2]='TL4X'
set LG[$B3]='TL4Y'
set LG[$B4]='TL4Z'
set LG[$B5]='TL50'
set LG[$B6]='TL51'
set LG[$B7]='TL52'
set LG[$B8]='TL53'
set LG[$B9]='TL54'
set LG[$BA]='TL55'
set LG[$BB]='TL56'
set LG[$BC]='TL57'
set LG[$BD]='TL58'
set LG[$BE]='TL59'
set LG[$BF]='TL5A'
set LG[$C0]='TL5B'
set LG[$C1]='TL5C'
set LG[$C2]='TL5D'
set LG[$C3]='TL5E'
set LG[$C4]='TL5F'
set LG[$C5]='TL5G'
set LG[$C6]='TL5H'
set LG[$C7]='TL5I'
set LG[$C8]='TL5J'
set LG[$C9]='TL5K'
set LG[$CA]='TL5L'
set LG[$CB]='TL5M'
set LG[$CC]='TL5N'
set LG[$CD]='TL5O'
set LG[$CE]='TL5P'
set LG[$CF]='TL5Q'
set LG[$D0]='TL5R'
set LG[$D1]='TL5S'
set LG[$D2]='TL5T'
set LG[$D3]='TL5U'
set LG[$D4]='TL5V'
set LG[$D5]='TL5W'
set LG[$D6]='TL5X'
set LG[$D7]='TL5Y'
set LG[$D8]='TL5Z'
set LG[$D9]='TL60'
set LG[$DA]='TL61'
set LG[$DB]='TL62'
set LG[$DC]='TL63'
set LG[$DD]='TL64'
set LG[$DE]='TL65'
set LG[$DF]='TL66'
set LG[$E0]='TL67'
set LG[$E1]='TL68'
set LG[$E2]='TL69'
set LG[$E3]='TL6A'
set LG[$E4]='TL6B'
set LG[$E5]='TL6C'
set LG[$E6]='TL6D'
set LG[$E7]='TL6E'
set LG[$E8]='TL6F'
set LG[$E9]='TL6G'
set LG[$EA]='TL6H'
set LG[$EB]='TL6I'
set LG[$EC]='TL6J'
set LG[$ED]='TL6K'
set LG[$EE]='TL6L'
set LG[$EF]='TL6M'
set LG[$F0]='TL6N'
set LG[$F1]='TL6O'
set LG[$F2]='TL6P'
set LG[$F3]='TL6Q'
set LG[$F4]='TL6R'
set LG[$F5]='TL6S'
set LG[$F6]='TL6T'
set LG[$F7]='TL6U'
set LG[$F8]='TL6V'
set LG[$F9]='TL6W'
set LG[$FA]='TL6X'
set LG[$FB]='TL6Y'
set LG[$FC]='TL6Z'
set LG[$FD]='TL70'
set LG[$FE]='TL71'
set LG[$FF]='TL72'
set LG[256]='TL73'
return true
endfunction
function iMo takes nothing returns boolean
set n2v[1]='SL00'
call LZx('SL00',false)
set n2v[2]='SL01'
call LZx('SL01',false)
set n2v[3]='SL02'
call LZx('SL02',false)
set n2v[4]='SL03'
call LZx('SL03',false)
set n2v[5]='SL04'
call LZx('SL04',false)
set n2v[6]='SL05'
call LZx('SL05',false)
set n2v[7]='SL06'
call LZx('SL06',false)
set n2v[8]='SL07'
call LZx('SL07',false)
set n2v[9]='SL08'
call LZx('SL08',false)
set n2v[$A]='SL09'
call LZx('SL09',false)
set n2v[$B]='SL0A'
call LZx('SL0A',false)
set n2v[$C]='SL0B'
call LZx('SL0B',false)
set n2v[$D]='SL0C'
call LZx('SL0C',false)
set n2v[$E]='SL0D'
call LZx('SL0D',false)
set n2v[$F]='SL0E'
call LZx('SL0E',false)
set n2v[16]='SL0F'
call LZx('SL0F',false)
set n2v[17]='SL0G'
call LZx('SL0G',false)
set n2v[18]='SL0H'
call LZx('SL0H',false)
set n2v[19]='SL0I'
call LZx('SL0I',false)
set n2v[20]='SL0J'
call LZx('SL0J',false)
set n2v[21]='SL0K'
call LZx('SL0K',false)
set n2v[22]='SL0L'
call LZx('SL0L',false)
set n2v[23]='SL0M'
call LZx('SL0M',false)
set n2v[24]='SL0N'
call LZx('SL0N',false)
set n2v[25]='SL0O'
call LZx('SL0O',false)
set n2v[26]='SL0P'
call LZx('SL0P',false)
set n2v[27]='SL0Q'
call LZx('SL0Q',false)
set n2v[28]='SL0R'
call LZx('SL0R',false)
set n2v[29]='SL0S'
call LZx('SL0S',false)
set n2v[30]='SL0T'
call LZx('SL0T',false)
set n2v[31]='SL0U'
call LZx('SL0U',false)
set n2v[32]='SL0V'
call LZx('SL0V',false)
set n2v[33]='SL0W'
call LZx('SL0W',false)
set n2v[34]='SL0X'
call LZx('SL0X',false)
set n2v[35]='SL0Y'
call LZx('SL0Y',false)
set n2v[36]='SL0Z'
call LZx('SL0Z',false)
set n2v[37]='SL10'
call LZx('SL10',false)
set n2v[38]='SL11'
call LZx('SL11',false)
set n2v[39]='SL12'
call LZx('SL12',false)
set n2v[40]='SL13'
call LZx('SL13',false)
set n2v[41]='SL14'
call LZx('SL14',false)
set n2v[42]='SL15'
call LZx('SL15',false)
set n2v[43]='SL16'
call LZx('SL16',false)
set n2v[44]='SL17'
call LZx('SL17',false)
set n2v[45]='SL18'
call LZx('SL18',false)
set n2v[46]='SL19'
call LZx('SL19',false)
set n2v[47]='SL1A'
call LZx('SL1A',false)
set n2v[48]='SL1B'
call LZx('SL1B',false)
set n2v[49]='SL1C'
call LZx('SL1C',false)
set n2v[50]='SL1D'
call LZx('SL1D',false)
set n2v[51]='SL1E'
call LZx('SL1E',false)
set n2v[52]='SL1F'
call LZx('SL1F',false)
set n2v[53]='SL1G'
call LZx('SL1G',false)
set n2v[54]='SL1H'
call LZx('SL1H',false)
set n2v[55]='SL1I'
call LZx('SL1I',false)
set n2v[56]='SL1J'
call LZx('SL1J',false)
set n2v[57]='SL1K'
call LZx('SL1K',false)
set n2v[58]='SL1L'
call LZx('SL1L',false)
set n2v[59]='SL1M'
call LZx('SL1M',false)
set n2v[60]='SL1N'
call LZx('SL1N',false)
set n2v[61]='SL1O'
call LZx('SL1O',false)
set n2v[62]='SL1P'
call LZx('SL1P',false)
set n2v[63]='SL1Q'
call LZx('SL1Q',false)
set n2v[64]='SL1R'
call LZx('SL1R',false)
set n2v[65]='SL1S'
call LZx('SL1S',false)
set n2v[66]='SL1T'
call LZx('SL1T',false)
set n2v[67]='SL1U'
call LZx('SL1U',false)
set n2v[68]='SL1V'
call LZx('SL1V',false)
set n2v[69]='SL1W'
call LZx('SL1W',false)
set n2v[70]='SL1X'
call LZx('SL1X',false)
set n2v[71]='SL1Y'
call LZx('SL1Y',false)
set n2v[72]='SL1Z'
call LZx('SL1Z',false)
set n2v[73]='SL20'
call LZx('SL20',false)
set n2v[74]='SL21'
call LZx('SL21',false)
set n2v[75]='SL22'
call LZx('SL22',false)
set n2v[76]='SL23'
call LZx('SL23',false)
set n2v[77]='SL24'
call LZx('SL24',false)
set n2v[78]='SL25'
call LZx('SL25',false)
set n2v[79]='SL26'
call LZx('SL26',false)
set n2v[80]='SL27'
call LZx('SL27',false)
set n2v[81]='SL28'
call LZx('SL28',false)
set n2v[82]='SL29'
call LZx('SL29',false)
set n2v[83]='SL2A'
call LZx('SL2A',false)
set n2v[84]='SL2B'
call LZx('SL2B',false)
set n2v[85]='SL2C'
call LZx('SL2C',false)
set n2v[86]='SL2D'
call LZx('SL2D',false)
set n2v[87]='SL2E'
call LZx('SL2E',false)
set n2v[88]='SL2F'
call LZx('SL2F',false)
set n2v[89]='SL2G'
call LZx('SL2G',false)
set n2v[90]='SL2H'
call LZx('SL2H',false)
set n2v[91]='SL2I'
call LZx('SL2I',false)
set n2v[92]='SL2J'
call LZx('SL2J',false)
set n2v[93]='SL2K'
call LZx('SL2K',false)
set n2v[94]='SL2L'
call LZx('SL2L',false)
set n2v[95]='SL2M'
call LZx('SL2M',false)
set n2v[96]='SL2N'
call LZx('SL2N',false)
set n2v[97]='SL2O'
call LZx('SL2O',false)
set n2v[98]='SL2P'
call LZx('SL2P',false)
set n2v[99]='SL2Q'
call LZx('SL2Q',false)
set n2v['d']='SL2R'
call LZx('SL2R',false)
set n2v['e']='SL2S'
call LZx('SL2S',false)
set n2v['f']='SL2T'
call LZx('SL2T',false)
set n2v['g']='SL2U'
call LZx('SL2U',false)
set n2v['h']='SL2V'
call LZx('SL2V',false)
set n2v['i']='SL2W'
call LZx('SL2W',false)
set n2v['j']='SL2X'
call LZx('SL2X',false)
set n2v['k']='SL2Y'
call LZx('SL2Y',false)
set n2v['l']='SL2Z'
call LZx('SL2Z',false)
set n2v['m']='SL30'
call LZx('SL30',false)
set n2v['n']='SL31'
call LZx('SL31',false)
set n2v['o']='SL32'
call LZx('SL32',false)
set n2v['p']='SL33'
call LZx('SL33',false)
set n2v['q']='SL34'
call LZx('SL34',false)
set n2v['r']='SL35'
call LZx('SL35',false)
set n2v['s']='SL36'
call LZx('SL36',false)
set n2v['t']='SL37'
call LZx('SL37',false)
set n2v['u']='SL38'
call LZx('SL38',false)
set n2v['v']='SL39'
call LZx('SL39',false)
set n2v['w']='SL3A'
call LZx('SL3A',false)
set n2v['x']='SL3B'
call LZx('SL3B',false)
set n2v['y']='SL3C'
call LZx('SL3C',false)
set n2v['z']='SL3D'
call LZx('SL3D',false)
set n2v['{']='SL3E'
call LZx('SL3E',false)
set n2v['|']='SL3F'
call LZx('SL3F',false)
set n2v['}']='SL3G'
call LZx('SL3G',false)
set n2v[$7E]='SL3H'
call LZx('SL3H',false)
set n2v[$7F]='SL3I'
call LZx('SL3I',false)
set n2v[$80]='SL3J'
call LZx('SL3J',false)
set n2v[$81]='SL3K'
call LZx('SL3K',false)
set n2v[$82]='SL3L'
call LZx('SL3L',false)
set n2v[$83]='SL3M'
call LZx('SL3M',false)
set n2v[$84]='SL3N'
call LZx('SL3N',false)
set n2v[$85]='SL3O'
call LZx('SL3O',false)
set n2v[$86]='SL3P'
call LZx('SL3P',false)
set n2v[$87]='SL3Q'
call LZx('SL3Q',false)
set n2v[$88]='SL3R'
call LZx('SL3R',false)
set n2v[$89]='SL3S'
call LZx('SL3S',false)
set n2v[$8A]='SL3T'
call LZx('SL3T',false)
set n2v[$8B]='SL3U'
call LZx('SL3U',false)
set n2v[$8C]='SL3V'
call LZx('SL3V',false)
set n2v[$8D]='SL3W'
call LZx('SL3W',false)
set n2v[$8E]='SL3X'
call LZx('SL3X',false)
set n2v[$8F]='SL3Y'
call LZx('SL3Y',false)
set n2v[$90]='SL3Z'
call LZx('SL3Z',false)
set n2v[$91]='SL40'
call LZx('SL40',false)
set n2v[$92]='SL41'
call LZx('SL41',false)
set n2v[$93]='SL42'
call LZx('SL42',false)
set n2v[$94]='SL43'
call LZx('SL43',false)
set n2v[$95]='SL44'
call LZx('SL44',false)
set n2v[$96]='SL45'
call LZx('SL45',false)
set n2v[$97]='SL46'
call LZx('SL46',false)
set n2v[$98]='SL47'
call LZx('SL47',false)
set n2v[$99]='SL48'
call LZx('SL48',false)
set n2v[$9A]='SL49'
call LZx('SL49',false)
set n2v[$9B]='SL4A'
call LZx('SL4A',false)
set n2v[$9C]='SL4B'
call LZx('SL4B',false)
set n2v[$9D]='SL4C'
call LZx('SL4C',false)
set n2v[$9E]='SL4D'
call LZx('SL4D',false)
set n2v[$9F]='SL4E'
call LZx('SL4E',false)
set n2v[$A0]='SL4F'
call LZx('SL4F',false)
set n2v[$A1]='SL4G'
call LZx('SL4G',false)
set n2v[$A2]='SL4H'
call LZx('SL4H',false)
set n2v[$A3]='SL4I'
call LZx('SL4I',false)
set n2v[$A4]='SL4J'
call LZx('SL4J',false)
set n2v[$A5]='SL4K'
call LZx('SL4K',false)
set n2v[$A6]='SL4L'
call LZx('SL4L',false)
set n2v[$A7]='SL4M'
call LZx('SL4M',false)
set n2v[$A8]='SL4N'
call LZx('SL4N',false)
set n2v[$A9]='SL4O'
call LZx('SL4O',false)
set n2v[$AA]='SL4P'
call LZx('SL4P',false)
set n2v[$AB]='SL4Q'
call LZx('SL4Q',false)
set n2v[$AC]='SL4R'
call LZx('SL4R',false)
set n2v[$AD]='SL4S'
call LZx('SL4S',false)
set n2v[$AE]='SL4T'
call LZx('SL4T',false)
set n2v[$AF]='SL4U'
call LZx('SL4U',false)
set n2v[$B0]='SL4V'
call LZx('SL4V',false)
set n2v[$B1]='SL4W'
call LZx('SL4W',false)
set n2v[$B2]='SL4X'
call LZx('SL4X',false)
set n2v[$B3]='SL4Y'
call LZx('SL4Y',false)
set n2v[$B4]='SL4Z'
call LZx('SL4Z',false)
set n2v[$B5]='SL50'
call LZx('SL50',false)
set n2v[$B6]='SL51'
call LZx('SL51',false)
set n2v[$B7]='SL52'
call LZx('SL52',false)
set n2v[$B8]='SL53'
call LZx('SL53',false)
set n2v[$B9]='SL54'
call LZx('SL54',false)
set n2v[$BA]='SL55'
call LZx('SL55',false)
set n2v[$BB]='SL56'
call LZx('SL56',false)
set n2v[$BC]='SL57'
call LZx('SL57',false)
set n2v[$BD]='SL58'
call LZx('SL58',false)
set n2v[$BE]='SL59'
call LZx('SL59',false)
set n2v[$BF]='SL5A'
call LZx('SL5A',false)
set n2v[$C0]='SL5B'
call LZx('SL5B',false)
set n2v[$C1]='SL5C'
call LZx('SL5C',false)
set n2v[$C2]='SL5D'
call LZx('SL5D',false)
set n2v[$C3]='SL5E'
call LZx('SL5E',false)
set n2v[$C4]='SL5F'
call LZx('SL5F',false)
set n2v[$C5]='SL5G'
call LZx('SL5G',false)
set n2v[$C6]='SL5H'
call LZx('SL5H',false)
set n2v[$C7]='SL5I'
call LZx('SL5I',false)
set n2v[$C8]='SL5J'
call LZx('SL5J',false)
set n2v[$C9]='SL5K'
call LZx('SL5K',false)
set n2v[$CA]='SL5L'
call LZx('SL5L',false)
set n2v[$CB]='SL5M'
call LZx('SL5M',false)
set n2v[$CC]='SL5N'
call LZx('SL5N',false)
set n2v[$CD]='SL5O'
call LZx('SL5O',false)
set n2v[$CE]='SL5P'
call LZx('SL5P',false)
set n2v[$CF]='SL5Q'
call LZx('SL5Q',false)
set n2v[$D0]='SL5R'
call LZx('SL5R',false)
set n2v[$D1]='SL5S'
call LZx('SL5S',false)
set n2v[$D2]='SL5T'
call LZx('SL5T',false)
set n2v[$D3]='SL5U'
call LZx('SL5U',false)
set n2v[$D4]='SL5V'
call LZx('SL5V',false)
set n2v[$D5]='SL5W'
call LZx('SL5W',false)
set n2v[$D6]='SL5X'
call LZx('SL5X',false)
set n2v[$D7]='SL5Y'
call LZx('SL5Y',false)
set n2v[$D8]='SL5Z'
call LZx('SL5Z',false)
set n2v[$D9]='SL60'
call LZx('SL60',false)
set n2v[$DA]='SL61'
call LZx('SL61',false)
set n2v[$DB]='SL62'
call LZx('SL62',false)
set n2v[$DC]='SL63'
call LZx('SL63',false)
set n2v[$DD]='SL64'
call LZx('SL64',false)
set n2v[$DE]='SL65'
call LZx('SL65',false)
set n2v[$DF]='SL66'
call LZx('SL66',false)
set n2v[$E0]='SL67'
call LZx('SL67',false)
set n2v[$E1]='SL68'
call LZx('SL68',false)
set n2v[$E2]='SL69'
call LZx('SL69',false)
set n2v[$E3]='SL6A'
call LZx('SL6A',false)
set n2v[$E4]='SL6B'
call LZx('SL6B',false)
set n2v[$E5]='SL6C'
call LZx('SL6C',false)
set n2v[$E6]='SL6D'
call LZx('SL6D',false)
set n2v[$E7]='SL6E'
call LZx('SL6E',false)
set n2v[$E8]='SL6F'
call LZx('SL6F',false)
set n2v[$E9]='SL6G'
call LZx('SL6G',false)
set n2v[$EA]='SL6H'
call LZx('SL6H',false)
set n2v[$EB]='SL6I'
call LZx('SL6I',false)
set n2v[$EC]='SL6J'
call LZx('SL6J',false)
set n2v[$ED]='SL6K'
call LZx('SL6K',false)
set n2v[$EE]='SL6L'
call LZx('SL6L',false)
set n2v[$EF]='SL6M'
call LZx('SL6M',false)
set n2v[$F0]='SL6N'
call LZx('SL6N',false)
set n2v[$F1]='SL6O'
call LZx('SL6O',false)
set n2v[$F2]='SL6P'
call LZx('SL6P',false)
set n2v[$F3]='SL6Q'
call LZx('SL6Q',false)
set n2v[$F4]='SL6R'
call LZx('SL6R',false)
set n2v[$F5]='SL6S'
call LZx('SL6S',false)
set n2v[$F6]='SL6T'
call LZx('SL6T',false)
set n2v[$F7]='SL6U'
call LZx('SL6U',false)
set n2v[$F8]='SL6V'
call LZx('SL6V',false)
set n2v[$F9]='SL6W'
call LZx('SL6W',false)
set n2v[$FA]='SL6X'
call LZx('SL6X',false)
set n2v[$FB]='SL6Y'
call LZx('SL6Y',false)
set n2v[$FC]='SL6Z'
call LZx('SL6Z',false)
set n2v[$FD]='SL70'
call LZx('SL70',false)
set n2v[$FE]='SL71'
call LZx('SL71',false)
set n2v[$FF]='SL72'
call LZx('SL72',false)
set n2v[256]='SL73'
call LZx('SL73',false)
set n3v[1]='TL00'
call LZx('TL00',false)
set n3v[2]='TL01'
call LZx('TL01',false)
set n3v[3]='TL02'
call LZx('TL02',false)
set n3v[4]='TL03'
call LZx('TL03',false)
set n3v[5]='TL04'
call LZx('TL04',false)
set n3v[6]='TL05'
call LZx('TL05',false)
set n3v[7]='TL06'
call LZx('TL06',false)
set n3v[8]='TL07'
call LZx('TL07',false)
set n3v[9]='TL08'
call LZx('TL08',false)
set n3v[$A]='TL09'
call LZx('TL09',false)
set n3v[$B]='TL0A'
call LZx('TL0A',false)
set n3v[$C]='TL0B'
call LZx('TL0B',false)
set n3v[$D]='TL0C'
call LZx('TL0C',false)
set n3v[$E]='TL0D'
call LZx('TL0D',false)
set n3v[$F]='TL0E'
call LZx('TL0E',false)
set n3v[16]='TL0F'
call LZx('TL0F',false)
set n3v[17]='TL0G'
call LZx('TL0G',false)
set n3v[18]='TL0H'
call LZx('TL0H',false)
set n3v[19]='TL0I'
call LZx('TL0I',false)
set n3v[20]='TL0J'
call LZx('TL0J',false)
set n3v[21]='TL0K'
call LZx('TL0K',false)
set n3v[22]='TL0L'
call LZx('TL0L',false)
set n3v[23]='TL0M'
call LZx('TL0M',false)
set n3v[24]='TL0N'
call LZx('TL0N',false)
set n3v[25]='TL0O'
call LZx('TL0O',false)
set n3v[26]='TL0P'
call LZx('TL0P',false)
set n3v[27]='TL0Q'
call LZx('TL0Q',false)
set n3v[28]='TL0R'
call LZx('TL0R',false)
set n3v[29]='TL0S'
call LZx('TL0S',false)
set n3v[30]='TL0T'
call LZx('TL0T',false)
set n3v[31]='TL0U'
call LZx('TL0U',false)
set n3v[32]='TL0V'
call LZx('TL0V',false)
set n3v[33]='TL0W'
call LZx('TL0W',false)
set n3v[34]='TL0X'
call LZx('TL0X',false)
set n3v[35]='TL0Y'
call LZx('TL0Y',false)
set n3v[36]='TL0Z'
call LZx('TL0Z',false)
set n3v[37]='TL10'
call LZx('TL10',false)
set n3v[38]='TL11'
call LZx('TL11',false)
set n3v[39]='TL12'
call LZx('TL12',false)
set n3v[40]='TL13'
call LZx('TL13',false)
set n3v[41]='TL14'
call LZx('TL14',false)
set n3v[42]='TL15'
call LZx('TL15',false)
set n3v[43]='TL16'
call LZx('TL16',false)
set n3v[44]='TL17'
call LZx('TL17',false)
set n3v[45]='TL18'
call LZx('TL18',false)
set n3v[46]='TL19'
call LZx('TL19',false)
set n3v[47]='TL1A'
call LZx('TL1A',false)
set n3v[48]='TL1B'
call LZx('TL1B',false)
set n3v[49]='TL1C'
call LZx('TL1C',false)
set n3v[50]='TL1D'
call LZx('TL1D',false)
set n3v[51]='TL1E'
call LZx('TL1E',false)
set n3v[52]='TL1F'
call LZx('TL1F',false)
set n3v[53]='TL1G'
call LZx('TL1G',false)
set n3v[54]='TL1H'
call LZx('TL1H',false)
set n3v[55]='TL1I'
call LZx('TL1I',false)
set n3v[56]='TL1J'
call LZx('TL1J',false)
set n3v[57]='TL1K'
call LZx('TL1K',false)
set n3v[58]='TL1L'
call LZx('TL1L',false)
set n3v[59]='TL1M'
call LZx('TL1M',false)
set n3v[60]='TL1N'
call LZx('TL1N',false)
set n3v[61]='TL1O'
call LZx('TL1O',false)
set n3v[62]='TL1P'
call LZx('TL1P',false)
set n3v[63]='TL1Q'
call LZx('TL1Q',false)
set n3v[64]='TL1R'
call LZx('TL1R',false)
set n3v[65]='TL1S'
call LZx('TL1S',false)
set n3v[66]='TL1T'
call LZx('TL1T',false)
set n3v[67]='TL1U'
call LZx('TL1U',false)
set n3v[68]='TL1V'
call LZx('TL1V',false)
set n3v[69]='TL1W'
call LZx('TL1W',false)
set n3v[70]='TL1X'
call LZx('TL1X',false)
set n3v[71]='TL1Y'
call LZx('TL1Y',false)
set n3v[72]='TL1Z'
call LZx('TL1Z',false)
set n3v[73]='TL20'
call LZx('TL20',false)
set n3v[74]='TL21'
call LZx('TL21',false)
set n3v[75]='TL22'
call LZx('TL22',false)
set n3v[76]='TL23'
call LZx('TL23',false)
set n3v[77]='TL24'
call LZx('TL24',false)
set n3v[78]='TL25'
call LZx('TL25',false)
set n3v[79]='TL26'
call LZx('TL26',false)
set n3v[80]='TL27'
call LZx('TL27',false)
set n3v[81]='TL28'
call LZx('TL28',false)
set n3v[82]='TL29'
call LZx('TL29',false)
set n3v[83]='TL2A'
call LZx('TL2A',false)
set n3v[84]='TL2B'
call LZx('TL2B',false)
set n3v[85]='TL2C'
call LZx('TL2C',false)
set n3v[86]='TL2D'
call LZx('TL2D',false)
set n3v[87]='TL2E'
call LZx('TL2E',false)
set n3v[88]='TL2F'
call LZx('TL2F',false)
set n3v[89]='TL2G'
call LZx('TL2G',false)
set n3v[90]='TL2H'
call LZx('TL2H',false)
set n3v[91]='TL2I'
call LZx('TL2I',false)
set n3v[92]='TL2J'
call LZx('TL2J',false)
set n3v[93]='TL2K'
call LZx('TL2K',false)
set n3v[94]='TL2L'
call LZx('TL2L',false)
set n3v[95]='TL2M'
call LZx('TL2M',false)
set n3v[96]='TL2N'
call LZx('TL2N',false)
set n3v[97]='TL2O'
call LZx('TL2O',false)
set n3v[98]='TL2P'
call LZx('TL2P',false)
set n3v[99]='TL2Q'
call LZx('TL2Q',false)
set n3v['d']='TL2R'
call LZx('TL2R',false)
set n3v['e']='TL2S'
call LZx('TL2S',false)
set n3v['f']='TL2T'
call LZx('TL2T',false)
set n3v['g']='TL2U'
call LZx('TL2U',false)
set n3v['h']='TL2V'
call LZx('TL2V',false)
set n3v['i']='TL2W'
call LZx('TL2W',false)
set n3v['j']='TL2X'
call LZx('TL2X',false)
set n3v['k']='TL2Y'
call LZx('TL2Y',false)
set n3v['l']='TL2Z'
call LZx('TL2Z',false)
set n3v['m']='TL30'
call LZx('TL30',false)
set n3v['n']='TL31'
call LZx('TL31',false)
set n3v['o']='TL32'
call LZx('TL32',false)
set n3v['p']='TL33'
call LZx('TL33',false)
set n3v['q']='TL34'
call LZx('TL34',false)
set n3v['r']='TL35'
call LZx('TL35',false)
set n3v['s']='TL36'
call LZx('TL36',false)
set n3v['t']='TL37'
call LZx('TL37',false)
set n3v['u']='TL38'
call LZx('TL38',false)
set n3v['v']='TL39'
call LZx('TL39',false)
set n3v['w']='TL3A'
call LZx('TL3A',false)
set n3v['x']='TL3B'
call LZx('TL3B',false)
set n3v['y']='TL3C'
call LZx('TL3C',false)
set n3v['z']='TL3D'
call LZx('TL3D',false)
set n3v['{']='TL3E'
call LZx('TL3E',false)
set n3v['|']='TL3F'
call LZx('TL3F',false)
set n3v['}']='TL3G'
call LZx('TL3G',false)
set n3v[$7E]='TL3H'
call LZx('TL3H',false)
set n3v[$7F]='TL3I'
call LZx('TL3I',false)
set n3v[$80]='TL3J'
call LZx('TL3J',false)
set n3v[$81]='TL3K'
call LZx('TL3K',false)
set n3v[$82]='TL3L'
call LZx('TL3L',false)
set n3v[$83]='TL3M'
call LZx('TL3M',false)
set n3v[$84]='TL3N'
call LZx('TL3N',false)
set n3v[$85]='TL3O'
call LZx('TL3O',false)
set n3v[$86]='TL3P'
call LZx('TL3P',false)
set n3v[$87]='TL3Q'
call LZx('TL3Q',false)
set n3v[$88]='TL3R'
call LZx('TL3R',false)
set n3v[$89]='TL3S'
call LZx('TL3S',false)
set n3v[$8A]='TL3T'
call LZx('TL3T',false)
set n3v[$8B]='TL3U'
call LZx('TL3U',false)
set n3v[$8C]='TL3V'
call LZx('TL3V',false)
set n3v[$8D]='TL3W'
call LZx('TL3W',false)
set n3v[$8E]='TL3X'
call LZx('TL3X',false)
set n3v[$8F]='TL3Y'
call LZx('TL3Y',false)
set n3v[$90]='TL3Z'
call LZx('TL3Z',false)
set n3v[$91]='TL40'
call LZx('TL40',false)
set n3v[$92]='TL41'
call LZx('TL41',false)
set n3v[$93]='TL42'
call LZx('TL42',false)
set n3v[$94]='TL43'
call LZx('TL43',false)
set n3v[$95]='TL44'
call LZx('TL44',false)
set n3v[$96]='TL45'
call LZx('TL45',false)
set n3v[$97]='TL46'
call LZx('TL46',false)
set n3v[$98]='TL47'
call LZx('TL47',false)
set n3v[$99]='TL48'
call LZx('TL48',false)
set n3v[$9A]='TL49'
call LZx('TL49',false)
set n3v[$9B]='TL4A'
call LZx('TL4A',false)
set n3v[$9C]='TL4B'
call LZx('TL4B',false)
set n3v[$9D]='TL4C'
call LZx('TL4C',false)
set n3v[$9E]='TL4D'
call LZx('TL4D',false)
set n3v[$9F]='TL4E'
call LZx('TL4E',false)
set n3v[$A0]='TL4F'
call LZx('TL4F',false)
set n3v[$A1]='TL4G'
call LZx('TL4G',false)
set n3v[$A2]='TL4H'
call LZx('TL4H',false)
set n3v[$A3]='TL4I'
call LZx('TL4I',false)
set n3v[$A4]='TL4J'
call LZx('TL4J',false)
set n3v[$A5]='TL4K'
call LZx('TL4K',false)
set n3v[$A6]='TL4L'
call LZx('TL4L',false)
set n3v[$A7]='TL4M'
call LZx('TL4M',false)
set n3v[$A8]='TL4N'
call LZx('TL4N',false)
set n3v[$A9]='TL4O'
call LZx('TL4O',false)
set n3v[$AA]='TL4P'
call LZx('TL4P',false)
set n3v[$AB]='TL4Q'
call LZx('TL4Q',false)
set n3v[$AC]='TL4R'
call LZx('TL4R',false)
set n3v[$AD]='TL4S'
call LZx('TL4S',false)
set n3v[$AE]='TL4T'
call LZx('TL4T',false)
set n3v[$AF]='TL4U'
call LZx('TL4U',false)
set n3v[$B0]='TL4V'
call LZx('TL4V',false)
set n3v[$B1]='TL4W'
call LZx('TL4W',false)
set n3v[$B2]='TL4X'
call LZx('TL4X',false)
set n3v[$B3]='TL4Y'
call LZx('TL4Y',false)
set n3v[$B4]='TL4Z'
call LZx('TL4Z',false)
set n3v[$B5]='TL50'
call LZx('TL50',false)
set n3v[$B6]='TL51'
call LZx('TL51',false)
set n3v[$B7]='TL52'
call LZx('TL52',false)
set n3v[$B8]='TL53'
call LZx('TL53',false)
set n3v[$B9]='TL54'
call LZx('TL54',false)
set n3v[$BA]='TL55'
call LZx('TL55',false)
set n3v[$BB]='TL56'
call LZx('TL56',false)
set n3v[$BC]='TL57'
call LZx('TL57',false)
set n3v[$BD]='TL58'
call LZx('TL58',false)
set n3v[$BE]='TL59'
call LZx('TL59',false)
set n3v[$BF]='TL5A'
call LZx('TL5A',false)
set n3v[$C0]='TL5B'
call LZx('TL5B',false)
set n3v[$C1]='TL5C'
call LZx('TL5C',false)
set n3v[$C2]='TL5D'
call LZx('TL5D',false)
set n3v[$C3]='TL5E'
call LZx('TL5E',false)
set n3v[$C4]='TL5F'
call LZx('TL5F',false)
set n3v[$C5]='TL5G'
call LZx('TL5G',false)
set n3v[$C6]='TL5H'
call LZx('TL5H',false)
set n3v[$C7]='TL5I'
call LZx('TL5I',false)
set n3v[$C8]='TL5J'
call LZx('TL5J',false)
set n3v[$C9]='TL5K'
call LZx('TL5K',false)
set n3v[$CA]='TL5L'
call LZx('TL5L',false)
set n3v[$CB]='TL5M'
call LZx('TL5M',false)
set n3v[$CC]='TL5N'
call LZx('TL5N',false)
set n3v[$CD]='TL5O'
call LZx('TL5O',false)
set n3v[$CE]='TL5P'
call LZx('TL5P',false)
set n3v[$CF]='TL5Q'
call LZx('TL5Q',false)
set n3v[$D0]='TL5R'
call LZx('TL5R',false)
set n3v[$D1]='TL5S'
call LZx('TL5S',false)
set n3v[$D2]='TL5T'
call LZx('TL5T',false)
set n3v[$D3]='TL5U'
call LZx('TL5U',false)
set n3v[$D4]='TL5V'
call LZx('TL5V',false)
set n3v[$D5]='TL5W'
call LZx('TL5W',false)
set n3v[$D6]='TL5X'
call LZx('TL5X',false)
set n3v[$D7]='TL5Y'
call LZx('TL5Y',false)
set n3v[$D8]='TL5Z'
call LZx('TL5Z',false)
set n3v[$D9]='TL60'
call LZx('TL60',false)
set n3v[$DA]='TL61'
call LZx('TL61',false)
set n3v[$DB]='TL62'
call LZx('TL62',false)
set n3v[$DC]='TL63'
call LZx('TL63',false)
set n3v[$DD]='TL64'
call LZx('TL64',false)
set n3v[$DE]='TL65'
call LZx('TL65',false)
set n3v[$DF]='TL66'
call LZx('TL66',false)
set n3v[$E0]='TL67'
call LZx('TL67',false)
set n3v[$E1]='TL68'
call LZx('TL68',false)
set n3v[$E2]='TL69'
call LZx('TL69',false)
set n3v[$E3]='TL6A'
call LZx('TL6A',false)
set n3v[$E4]='TL6B'
call LZx('TL6B',false)
set n3v[$E5]='TL6C'
call LZx('TL6C',false)
set n3v[$E6]='TL6D'
call LZx('TL6D',false)
set n3v[$E7]='TL6E'
call LZx('TL6E',false)
set n3v[$E8]='TL6F'
call LZx('TL6F',false)
set n3v[$E9]='TL6G'
call LZx('TL6G',false)
set n3v[$EA]='TL6H'
call LZx('TL6H',false)
set n3v[$EB]='TL6I'
call LZx('TL6I',false)
set n3v[$EC]='TL6J'
call LZx('TL6J',false)
set n3v[$ED]='TL6K'
call LZx('TL6K',false)
set n3v[$EE]='TL6L'
call LZx('TL6L',false)
set n3v[$EF]='TL6M'
call LZx('TL6M',false)
set n3v[$F0]='TL6N'
call LZx('TL6N',false)
set n3v[$F1]='TL6O'
call LZx('TL6O',false)
set n3v[$F2]='TL6P'
call LZx('TL6P',false)
set n3v[$F3]='TL6Q'
call LZx('TL6Q',false)
set n3v[$F4]='TL6R'
call LZx('TL6R',false)
set n3v[$F5]='TL6S'
call LZx('TL6S',false)
set n3v[$F6]='TL6T'
call LZx('TL6T',false)
set n3v[$F7]='TL6U'
call LZx('TL6U',false)
set n3v[$F8]='TL6V'
call LZx('TL6V',false)
set n3v[$F9]='TL6W'
call LZx('TL6W',false)
set n3v[$FA]='TL6X'
call LZx('TL6X',false)
set n3v[$FB]='TL6Y'
call LZx('TL6Y',false)
set n3v[$FC]='TL6Z'
call LZx('TL6Z',false)
set n3v[$FD]='TL70'
call LZx('TL70',false)
set n3v[$FE]='TL71'
call LZx('TL71',false)
set n3v[$FF]='TL72'
call LZx('TL72',false)
set n3v[256]='TL73'
call LZx('TL73',false)
return true
endfunction
function ipo takes nothing returns boolean
call VRx(ea,(function imo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\MaxLife\\obj_spells_wc3objLuainits.j"))
call VRx(qa,(function iMo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\MaxLife\\obj_spells_wc3objLuaspells.j"))
return true
endfunction
function iPo takes nothing returns boolean
set n4v=Vnx(n5v)
return true
endfunction
function iqo takes nothing returns boolean
set n6v=Vnx(n7v)
return true
endfunction
function iQo takes nothing returns boolean
set n8v=Vnx(n9v)
return true
endfunction
function iso takes nothing returns boolean
set Vvv=Vnx(Vev)
return true
endfunction
function iSo takes nothing returns boolean
set Yg=lQx(Vxv+" (dummyBuff)")
return true
endfunction
function ito takes nothing returns boolean
call VRx(Ma,(function iSo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\LifeRegeneration\\Disablement\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function iTo takes nothing returns boolean
set Vov=Vnx(Vxv)
return true
endfunction
function iuo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set Vrv[((rkx))]=(true)
call cJx(rkx)
return true
endfunction
function iUo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set Vrv[((rkx))]=(false)
if((yg[(rkx)])>.0)then
call cHx(rkx)
endif
return true
endfunction
function iwo takes nothing returns boolean
call l9x(Yg,XBx("FolderUnit_FolderLifeRegeneration_StructDisablement_Buff_Init: call FolderUnit_FolderLifeRegeneration_StructDisablement.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderLifeRegeneration_StructDisablement.Event_BuffGain))",Bd,pI,function iuo))
call l9x(Yg,XBx("FolderUnit_FolderLifeRegeneration_StructDisablement_Buff_Init: call FolderUnit_FolderLifeRegeneration_StructDisablement.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderLifeRegeneration_StructDisablement.Event_BuffLose))",Jc,pI,function iUo))
return true
endfunction
function iWo takes nothing returns boolean
call u6x(function iwo,"FolderUnit_FolderLifeRegeneration_StructDisablement_Buff_Init")
return true
endfunction
function iyo takes nothing returns boolean
set Viv=Vnx(Vav)
return true
endfunction
function iYo takes nothing returns boolean
set Vnv=Vnx(VVv)
return true
endfunction
function izo takes nothing returns boolean
set VEv=Vnx(VXv)
return true
endfunction
function iZo takes nothing returns boolean
set VOv=Vnx(VRv)
return true
endfunction
function i_o takes nothing returns boolean
set VIv=Vnx(VAv)
return true
endfunction
function i0o takes nothing returns boolean
set UF[1]='SM00'
set UF[2]='SM01'
set UF[3]='SM02'
set UF[4]='SM03'
set UF[5]='SM04'
set UF[6]='SM05'
set UF[7]='SM06'
set UF[8]='SM07'
set UF[9]='SM08'
set UF[$A]='SM09'
set UF[$B]='SM0A'
set UF[$C]='SM0B'
set UF[$D]='SM0C'
set UF[$E]='SM0D'
set UF[$F]='SM0E'
set UF[16]='SM0F'
set UF[17]='SM0G'
set UF[18]='SM0H'
set UF[19]='SM0I'
set UF[20]='SM0J'
set UF[21]='SM0K'
set UF[22]='SM0L'
set UF[23]='SM0M'
set UF[24]='SM0N'
set UF[25]='SM0O'
set UF[26]='SM0P'
set UF[27]='SM0Q'
set UF[28]='SM0R'
set UF[29]='SM0S'
set UF[30]='SM0T'
set UF[31]='SM0U'
set UF[32]='SM0V'
set UF[33]='SM0W'
set UF[34]='SM0X'
set UF[35]='SM0Y'
set UF[36]='SM0Z'
set UF[37]='SM10'
set UF[38]='SM11'
set UF[39]='SM12'
set UF[40]='SM13'
set UF[41]='SM14'
set UF[42]='SM15'
set UF[43]='SM16'
set UF[44]='SM17'
set UF[45]='SM18'
set UF[46]='SM19'
set UF[47]='SM1A'
set UF[48]='SM1B'
set UF[49]='SM1C'
set UF[50]='SM1D'
set UF[51]='SM1E'
set UF[52]='SM1F'
set UF[53]='SM1G'
set UF[54]='SM1H'
set UF[55]='SM1I'
set UF[56]='SM1J'
set UF[57]='SM1K'
set UF[58]='SM1L'
set UF[59]='SM1M'
set UF[60]='SM1N'
set UF[61]='SM1O'
set UF[62]='SM1P'
set UF[63]='SM1Q'
set UF[64]='SM1R'
set UF[65]='SM1S'
set UF[66]='SM1T'
set UF[67]='SM1U'
set UF[68]='SM1V'
set UF[69]='SM1W'
set UF[70]='SM1X'
set UF[71]='SM1Y'
set UF[72]='SM1Z'
set UF[73]='SM20'
set UF[74]='SM21'
set UF[75]='SM22'
set UF[76]='SM23'
set UF[77]='SM24'
set UF[78]='SM25'
set UF[79]='SM26'
set UF[80]='SM27'
set UF[81]='SM28'
set UF[82]='SM29'
set UF[83]='SM2A'
set UF[84]='SM2B'
set UF[85]='SM2C'
set UF[86]='SM2D'
set UF[87]='SM2E'
set UF[88]='SM2F'
set UF[89]='SM2G'
set UF[90]='SM2H'
set UF[91]='SM2I'
set UF[92]='SM2J'
set UF[93]='SM2K'
set UF[94]='SM2L'
set UF[95]='SM2M'
set UF[96]='SM2N'
set UF[97]='SM2O'
set UF[98]='SM2P'
set UF[99]='SM2Q'
set UF['d']='SM2R'
set UF['e']='SM2S'
set UF['f']='SM2T'
set UF['g']='SM2U'
set UF['h']='SM2V'
set UF['i']='SM2W'
set UF['j']='SM2X'
set UF['k']='SM2Y'
set UF['l']='SM2Z'
set UF['m']='SM30'
set UF['n']='SM31'
set UF['o']='SM32'
set UF['p']='SM33'
set UF['q']='SM34'
set UF['r']='SM35'
set UF['s']='SM36'
set UF['t']='SM37'
set UF['u']='SM38'
set UF['v']='SM39'
set UF['w']='SM3A'
set UF['x']='SM3B'
set UF['y']='SM3C'
set UF['z']='SM3D'
set UF['{']='SM3E'
set UF['|']='SM3F'
set UF['}']='SM3G'
set UF[$7E]='SM3H'
set UF[$7F]='SM3I'
set UF[$80]='SM3J'
set UF[$81]='SM3K'
set UF[$82]='SM3L'
set UF[$83]='SM3M'
set UF[$84]='SM3N'
set UF[$85]='SM3O'
set UF[$86]='SM3P'
set UF[$87]='SM3Q'
set UF[$88]='SM3R'
set UF[$89]='SM3S'
set UF[$8A]='SM3T'
set UF[$8B]='SM3U'
set UF[$8C]='SM3V'
set UF[$8D]='SM3W'
set UF[$8E]='SM3X'
set UF[$8F]='SM3Y'
set UF[$90]='SM3Z'
set UF[$91]='SM40'
set UF[$92]='SM41'
set UF[$93]='SM42'
set UF[$94]='SM43'
set UF[$95]='SM44'
set UF[$96]='SM45'
set UF[$97]='SM46'
set UF[$98]='SM47'
set UF[$99]='SM48'
set UF[$9A]='SM49'
set UF[$9B]='SM4A'
set UF[$9C]='SM4B'
set UF[$9D]='SM4C'
set UF[$9E]='SM4D'
set UF[$9F]='SM4E'
set UF[$A0]='SM4F'
set UF[$A1]='SM4G'
set UF[$A2]='SM4H'
set UF[$A3]='SM4I'
set UF[$A4]='SM4J'
set UF[$A5]='SM4K'
set UF[$A6]='SM4L'
set UF[$A7]='SM4M'
set UF[$A8]='SM4N'
set UF[$A9]='SM4O'
set UF[$AA]='SM4P'
set UF[$AB]='SM4Q'
set UF[$AC]='SM4R'
set UF[$AD]='SM4S'
set UF[$AE]='SM4T'
set UF[$AF]='SM4U'
set UF[$B0]='SM4V'
set UF[$B1]='SM4W'
set UF[$B2]='SM4X'
set UF[$B3]='SM4Y'
set UF[$B4]='SM4Z'
set UF[$B5]='SM50'
set UF[$B6]='SM51'
set UF[$B7]='SM52'
set UF[$B8]='SM53'
set UF[$B9]='SM54'
set UF[$BA]='SM55'
set UF[$BB]='SM56'
set UF[$BC]='SM57'
set UF[$BD]='SM58'
set UF[$BE]='SM59'
set UF[$BF]='SM5A'
set UF[$C0]='SM5B'
set UF[$C1]='SM5C'
set UF[$C2]='SM5D'
set UF[$C3]='SM5E'
set UF[$C4]='SM5F'
set UF[$C5]='SM5G'
set UF[$C6]='SM5H'
set UF[$C7]='SM5I'
set UF[$C8]='SM5J'
set UF[$C9]='SM5K'
set UF[$CA]='SM5L'
set UF[$CB]='SM5M'
set UF[$CC]='SM5N'
set UF[$CD]='SM5O'
set UF[$CE]='SM5P'
set UF[$CF]='SM5Q'
set UF[$D0]='SM5R'
set UF[$D1]='SM5S'
set UF[$D2]='SM5T'
set UF[$D3]='SM5U'
set UF[$D4]='SM5V'
set UF[$D5]='SM5W'
set UF[$D6]='SM5X'
set UF[$D7]='SM5Y'
set UF[$D8]='SM5Z'
set UF[$D9]='SM60'
set UF[$DA]='SM61'
set UF[$DB]='SM62'
set UF[$DC]='SM63'
set UF[$DD]='SM64'
set UF[$DE]='SM65'
set UF[$DF]='SM66'
set UF[$E0]='SM67'
set UF[$E1]='SM68'
set UF[$E2]='SM69'
set UF[$E3]='SM6A'
set UF[$E4]='SM6B'
set UF[$E5]='SM6C'
set UF[$E6]='SM6D'
set UF[$E7]='SM6E'
set UF[$E8]='SM6F'
set UF[$E9]='SM6G'
set UF[$EA]='SM6H'
set UF[$EB]='SM6I'
set UF[$EC]='SM6J'
set UF[$ED]='SM6K'
set UF[$EE]='SM6L'
set UF[$EF]='SM6M'
set UF[$F0]='SM6N'
set UF[$F1]='SM6O'
set UF[$F2]='SM6P'
set UF[$F3]='SM6Q'
set UF[$F4]='SM6R'
set UF[$F5]='SM6S'
set UF[$F6]='SM6T'
set UF[$F7]='SM6U'
set UF[$F8]='SM6V'
set UF[$F9]='SM6W'
set UF[$FA]='SM6X'
set UF[$FB]='SM6Y'
set UF[$FC]='SM6Z'
set UF[$FD]='SM70'
set UF[$FE]='SM71'
set UF[$FF]='SM72'
set UF[256]='SM73'
set tF[1]='TM00'
set tF[2]='TM01'
set tF[3]='TM02'
set tF[4]='TM03'
set tF[5]='TM04'
set tF[6]='TM05'
set tF[7]='TM06'
set tF[8]='TM07'
set tF[9]='TM08'
set tF[$A]='TM09'
set tF[$B]='TM0A'
set tF[$C]='TM0B'
set tF[$D]='TM0C'
set tF[$E]='TM0D'
set tF[$F]='TM0E'
set tF[16]='TM0F'
set tF[17]='TM0G'
set tF[18]='TM0H'
set tF[19]='TM0I'
set tF[20]='TM0J'
set tF[21]='TM0K'
set tF[22]='TM0L'
set tF[23]='TM0M'
set tF[24]='TM0N'
set tF[25]='TM0O'
set tF[26]='TM0P'
set tF[27]='TM0Q'
set tF[28]='TM0R'
set tF[29]='TM0S'
set tF[30]='TM0T'
set tF[31]='TM0U'
set tF[32]='TM0V'
set tF[33]='TM0W'
set tF[34]='TM0X'
set tF[35]='TM0Y'
set tF[36]='TM0Z'
set tF[37]='TM10'
set tF[38]='TM11'
set tF[39]='TM12'
set tF[40]='TM13'
set tF[41]='TM14'
set tF[42]='TM15'
set tF[43]='TM16'
set tF[44]='TM17'
set tF[45]='TM18'
set tF[46]='TM19'
set tF[47]='TM1A'
set tF[48]='TM1B'
set tF[49]='TM1C'
set tF[50]='TM1D'
set tF[51]='TM1E'
set tF[52]='TM1F'
set tF[53]='TM1G'
set tF[54]='TM1H'
set tF[55]='TM1I'
set tF[56]='TM1J'
set tF[57]='TM1K'
set tF[58]='TM1L'
set tF[59]='TM1M'
set tF[60]='TM1N'
set tF[61]='TM1O'
set tF[62]='TM1P'
set tF[63]='TM1Q'
set tF[64]='TM1R'
set tF[65]='TM1S'
set tF[66]='TM1T'
set tF[67]='TM1U'
set tF[68]='TM1V'
set tF[69]='TM1W'
set tF[70]='TM1X'
set tF[71]='TM1Y'
set tF[72]='TM1Z'
set tF[73]='TM20'
set tF[74]='TM21'
set tF[75]='TM22'
set tF[76]='TM23'
set tF[77]='TM24'
set tF[78]='TM25'
set tF[79]='TM26'
set tF[80]='TM27'
set tF[81]='TM28'
set tF[82]='TM29'
set tF[83]='TM2A'
set tF[84]='TM2B'
set tF[85]='TM2C'
set tF[86]='TM2D'
set tF[87]='TM2E'
set tF[88]='TM2F'
set tF[89]='TM2G'
set tF[90]='TM2H'
set tF[91]='TM2I'
set tF[92]='TM2J'
set tF[93]='TM2K'
set tF[94]='TM2L'
set tF[95]='TM2M'
set tF[96]='TM2N'
set tF[97]='TM2O'
set tF[98]='TM2P'
set tF[99]='TM2Q'
set tF['d']='TM2R'
set tF['e']='TM2S'
set tF['f']='TM2T'
set tF['g']='TM2U'
set tF['h']='TM2V'
set tF['i']='TM2W'
set tF['j']='TM2X'
set tF['k']='TM2Y'
set tF['l']='TM2Z'
set tF['m']='TM30'
set tF['n']='TM31'
set tF['o']='TM32'
set tF['p']='TM33'
set tF['q']='TM34'
set tF['r']='TM35'
set tF['s']='TM36'
set tF['t']='TM37'
set tF['u']='TM38'
set tF['v']='TM39'
set tF['w']='TM3A'
set tF['x']='TM3B'
set tF['y']='TM3C'
set tF['z']='TM3D'
set tF['{']='TM3E'
set tF['|']='TM3F'
set tF['}']='TM3G'
set tF[$7E]='TM3H'
set tF[$7F]='TM3I'
set tF[$80]='TM3J'
set tF[$81]='TM3K'
set tF[$82]='TM3L'
set tF[$83]='TM3M'
set tF[$84]='TM3N'
set tF[$85]='TM3O'
set tF[$86]='TM3P'
set tF[$87]='TM3Q'
set tF[$88]='TM3R'
set tF[$89]='TM3S'
set tF[$8A]='TM3T'
set tF[$8B]='TM3U'
set tF[$8C]='TM3V'
set tF[$8D]='TM3W'
set tF[$8E]='TM3X'
set tF[$8F]='TM3Y'
set tF[$90]='TM3Z'
set tF[$91]='TM40'
set tF[$92]='TM41'
set tF[$93]='TM42'
set tF[$94]='TM43'
set tF[$95]='TM44'
set tF[$96]='TM45'
set tF[$97]='TM46'
set tF[$98]='TM47'
set tF[$99]='TM48'
set tF[$9A]='TM49'
set tF[$9B]='TM4A'
set tF[$9C]='TM4B'
set tF[$9D]='TM4C'
set tF[$9E]='TM4D'
set tF[$9F]='TM4E'
set tF[$A0]='TM4F'
set tF[$A1]='TM4G'
set tF[$A2]='TM4H'
set tF[$A3]='TM4I'
set tF[$A4]='TM4J'
set tF[$A5]='TM4K'
set tF[$A6]='TM4L'
set tF[$A7]='TM4M'
set tF[$A8]='TM4N'
set tF[$A9]='TM4O'
set tF[$AA]='TM4P'
set tF[$AB]='TM4Q'
set tF[$AC]='TM4R'
set tF[$AD]='TM4S'
set tF[$AE]='TM4T'
set tF[$AF]='TM4U'
set tF[$B0]='TM4V'
set tF[$B1]='TM4W'
set tF[$B2]='TM4X'
set tF[$B3]='TM4Y'
set tF[$B4]='TM4Z'
set tF[$B5]='TM50'
set tF[$B6]='TM51'
set tF[$B7]='TM52'
set tF[$B8]='TM53'
set tF[$B9]='TM54'
set tF[$BA]='TM55'
set tF[$BB]='TM56'
set tF[$BC]='TM57'
set tF[$BD]='TM58'
set tF[$BE]='TM59'
set tF[$BF]='TM5A'
set tF[$C0]='TM5B'
set tF[$C1]='TM5C'
set tF[$C2]='TM5D'
set tF[$C3]='TM5E'
set tF[$C4]='TM5F'
set tF[$C5]='TM5G'
set tF[$C6]='TM5H'
set tF[$C7]='TM5I'
set tF[$C8]='TM5J'
set tF[$C9]='TM5K'
set tF[$CA]='TM5L'
set tF[$CB]='TM5M'
set tF[$CC]='TM5N'
set tF[$CD]='TM5O'
set tF[$CE]='TM5P'
set tF[$CF]='TM5Q'
set tF[$D0]='TM5R'
set tF[$D1]='TM5S'
set tF[$D2]='TM5T'
set tF[$D3]='TM5U'
set tF[$D4]='TM5V'
set tF[$D5]='TM5W'
set tF[$D6]='TM5X'
set tF[$D7]='TM5Y'
set tF[$D8]='TM5Z'
set tF[$D9]='TM60'
set tF[$DA]='TM61'
set tF[$DB]='TM62'
set tF[$DC]='TM63'
set tF[$DD]='TM64'
set tF[$DE]='TM65'
set tF[$DF]='TM66'
set tF[$E0]='TM67'
set tF[$E1]='TM68'
set tF[$E2]='TM69'
set tF[$E3]='TM6A'
set tF[$E4]='TM6B'
set tF[$E5]='TM6C'
set tF[$E6]='TM6D'
set tF[$E7]='TM6E'
set tF[$E8]='TM6F'
set tF[$E9]='TM6G'
set tF[$EA]='TM6H'
set tF[$EB]='TM6I'
set tF[$EC]='TM6J'
set tF[$ED]='TM6K'
set tF[$EE]='TM6L'
set tF[$EF]='TM6M'
set tF[$F0]='TM6N'
set tF[$F1]='TM6O'
set tF[$F2]='TM6P'
set tF[$F3]='TM6Q'
set tF[$F4]='TM6R'
set tF[$F5]='TM6S'
set tF[$F6]='TM6T'
set tF[$F7]='TM6U'
set tF[$F8]='TM6V'
set tF[$F9]='TM6W'
set tF[$FA]='TM6X'
set tF[$FB]='TM6Y'
set tF[$FC]='TM6Z'
set tF[$FD]='TM70'
set tF[$FE]='TM71'
set tF[$FF]='TM72'
set tF[256]='TM73'
return true
endfunction
function i1o takes nothing returns boolean
set VNv[1]='SM00'
call LZx('SM00',false)
set VNv[2]='SM01'
call LZx('SM01',false)
set VNv[3]='SM02'
call LZx('SM02',false)
set VNv[4]='SM03'
call LZx('SM03',false)
set VNv[5]='SM04'
call LZx('SM04',false)
set VNv[6]='SM05'
call LZx('SM05',false)
set VNv[7]='SM06'
call LZx('SM06',false)
set VNv[8]='SM07'
call LZx('SM07',false)
set VNv[9]='SM08'
call LZx('SM08',false)
set VNv[$A]='SM09'
call LZx('SM09',false)
set VNv[$B]='SM0A'
call LZx('SM0A',false)
set VNv[$C]='SM0B'
call LZx('SM0B',false)
set VNv[$D]='SM0C'
call LZx('SM0C',false)
set VNv[$E]='SM0D'
call LZx('SM0D',false)
set VNv[$F]='SM0E'
call LZx('SM0E',false)
set VNv[16]='SM0F'
call LZx('SM0F',false)
set VNv[17]='SM0G'
call LZx('SM0G',false)
set VNv[18]='SM0H'
call LZx('SM0H',false)
set VNv[19]='SM0I'
call LZx('SM0I',false)
set VNv[20]='SM0J'
call LZx('SM0J',false)
set VNv[21]='SM0K'
call LZx('SM0K',false)
set VNv[22]='SM0L'
call LZx('SM0L',false)
set VNv[23]='SM0M'
call LZx('SM0M',false)
set VNv[24]='SM0N'
call LZx('SM0N',false)
set VNv[25]='SM0O'
call LZx('SM0O',false)
set VNv[26]='SM0P'
call LZx('SM0P',false)
set VNv[27]='SM0Q'
call LZx('SM0Q',false)
set VNv[28]='SM0R'
call LZx('SM0R',false)
set VNv[29]='SM0S'
call LZx('SM0S',false)
set VNv[30]='SM0T'
call LZx('SM0T',false)
set VNv[31]='SM0U'
call LZx('SM0U',false)
set VNv[32]='SM0V'
call LZx('SM0V',false)
set VNv[33]='SM0W'
call LZx('SM0W',false)
set VNv[34]='SM0X'
call LZx('SM0X',false)
set VNv[35]='SM0Y'
call LZx('SM0Y',false)
set VNv[36]='SM0Z'
call LZx('SM0Z',false)
set VNv[37]='SM10'
call LZx('SM10',false)
set VNv[38]='SM11'
call LZx('SM11',false)
set VNv[39]='SM12'
call LZx('SM12',false)
set VNv[40]='SM13'
call LZx('SM13',false)
set VNv[41]='SM14'
call LZx('SM14',false)
set VNv[42]='SM15'
call LZx('SM15',false)
set VNv[43]='SM16'
call LZx('SM16',false)
set VNv[44]='SM17'
call LZx('SM17',false)
set VNv[45]='SM18'
call LZx('SM18',false)
set VNv[46]='SM19'
call LZx('SM19',false)
set VNv[47]='SM1A'
call LZx('SM1A',false)
set VNv[48]='SM1B'
call LZx('SM1B',false)
set VNv[49]='SM1C'
call LZx('SM1C',false)
set VNv[50]='SM1D'
call LZx('SM1D',false)
set VNv[51]='SM1E'
call LZx('SM1E',false)
set VNv[52]='SM1F'
call LZx('SM1F',false)
set VNv[53]='SM1G'
call LZx('SM1G',false)
set VNv[54]='SM1H'
call LZx('SM1H',false)
set VNv[55]='SM1I'
call LZx('SM1I',false)
set VNv[56]='SM1J'
call LZx('SM1J',false)
set VNv[57]='SM1K'
call LZx('SM1K',false)
set VNv[58]='SM1L'
call LZx('SM1L',false)
set VNv[59]='SM1M'
call LZx('SM1M',false)
set VNv[60]='SM1N'
call LZx('SM1N',false)
set VNv[61]='SM1O'
call LZx('SM1O',false)
set VNv[62]='SM1P'
call LZx('SM1P',false)
set VNv[63]='SM1Q'
call LZx('SM1Q',false)
set VNv[64]='SM1R'
call LZx('SM1R',false)
set VNv[65]='SM1S'
call LZx('SM1S',false)
set VNv[66]='SM1T'
call LZx('SM1T',false)
set VNv[67]='SM1U'
call LZx('SM1U',false)
set VNv[68]='SM1V'
call LZx('SM1V',false)
set VNv[69]='SM1W'
call LZx('SM1W',false)
set VNv[70]='SM1X'
call LZx('SM1X',false)
set VNv[71]='SM1Y'
call LZx('SM1Y',false)
set VNv[72]='SM1Z'
call LZx('SM1Z',false)
set VNv[73]='SM20'
call LZx('SM20',false)
set VNv[74]='SM21'
call LZx('SM21',false)
set VNv[75]='SM22'
call LZx('SM22',false)
set VNv[76]='SM23'
call LZx('SM23',false)
set VNv[77]='SM24'
call LZx('SM24',false)
set VNv[78]='SM25'
call LZx('SM25',false)
set VNv[79]='SM26'
call LZx('SM26',false)
set VNv[80]='SM27'
call LZx('SM27',false)
set VNv[81]='SM28'
call LZx('SM28',false)
set VNv[82]='SM29'
call LZx('SM29',false)
set VNv[83]='SM2A'
call LZx('SM2A',false)
set VNv[84]='SM2B'
call LZx('SM2B',false)
set VNv[85]='SM2C'
call LZx('SM2C',false)
set VNv[86]='SM2D'
call LZx('SM2D',false)
set VNv[87]='SM2E'
call LZx('SM2E',false)
set VNv[88]='SM2F'
call LZx('SM2F',false)
set VNv[89]='SM2G'
call LZx('SM2G',false)
set VNv[90]='SM2H'
call LZx('SM2H',false)
set VNv[91]='SM2I'
call LZx('SM2I',false)
set VNv[92]='SM2J'
call LZx('SM2J',false)
set VNv[93]='SM2K'
call LZx('SM2K',false)
set VNv[94]='SM2L'
call LZx('SM2L',false)
set VNv[95]='SM2M'
call LZx('SM2M',false)
set VNv[96]='SM2N'
call LZx('SM2N',false)
set VNv[97]='SM2O'
call LZx('SM2O',false)
set VNv[98]='SM2P'
call LZx('SM2P',false)
set VNv[99]='SM2Q'
call LZx('SM2Q',false)
set VNv['d']='SM2R'
call LZx('SM2R',false)
set VNv['e']='SM2S'
call LZx('SM2S',false)
set VNv['f']='SM2T'
call LZx('SM2T',false)
set VNv['g']='SM2U'
call LZx('SM2U',false)
set VNv['h']='SM2V'
call LZx('SM2V',false)
set VNv['i']='SM2W'
call LZx('SM2W',false)
set VNv['j']='SM2X'
call LZx('SM2X',false)
set VNv['k']='SM2Y'
call LZx('SM2Y',false)
set VNv['l']='SM2Z'
call LZx('SM2Z',false)
set VNv['m']='SM30'
call LZx('SM30',false)
set VNv['n']='SM31'
call LZx('SM31',false)
set VNv['o']='SM32'
call LZx('SM32',false)
set VNv['p']='SM33'
call LZx('SM33',false)
set VNv['q']='SM34'
call LZx('SM34',false)
set VNv['r']='SM35'
call LZx('SM35',false)
set VNv['s']='SM36'
call LZx('SM36',false)
set VNv['t']='SM37'
call LZx('SM37',false)
set VNv['u']='SM38'
call LZx('SM38',false)
set VNv['v']='SM39'
call LZx('SM39',false)
set VNv['w']='SM3A'
call LZx('SM3A',false)
set VNv['x']='SM3B'
call LZx('SM3B',false)
set VNv['y']='SM3C'
call LZx('SM3C',false)
set VNv['z']='SM3D'
call LZx('SM3D',false)
set VNv['{']='SM3E'
call LZx('SM3E',false)
set VNv['|']='SM3F'
call LZx('SM3F',false)
set VNv['}']='SM3G'
call LZx('SM3G',false)
set VNv[$7E]='SM3H'
call LZx('SM3H',false)
set VNv[$7F]='SM3I'
call LZx('SM3I',false)
set VNv[$80]='SM3J'
call LZx('SM3J',false)
set VNv[$81]='SM3K'
call LZx('SM3K',false)
set VNv[$82]='SM3L'
call LZx('SM3L',false)
set VNv[$83]='SM3M'
call LZx('SM3M',false)
set VNv[$84]='SM3N'
call LZx('SM3N',false)
set VNv[$85]='SM3O'
call LZx('SM3O',false)
set VNv[$86]='SM3P'
call LZx('SM3P',false)
set VNv[$87]='SM3Q'
call LZx('SM3Q',false)
set VNv[$88]='SM3R'
call LZx('SM3R',false)
set VNv[$89]='SM3S'
call LZx('SM3S',false)
set VNv[$8A]='SM3T'
call LZx('SM3T',false)
set VNv[$8B]='SM3U'
call LZx('SM3U',false)
set VNv[$8C]='SM3V'
call LZx('SM3V',false)
set VNv[$8D]='SM3W'
call LZx('SM3W',false)
set VNv[$8E]='SM3X'
call LZx('SM3X',false)
set VNv[$8F]='SM3Y'
call LZx('SM3Y',false)
set VNv[$90]='SM3Z'
call LZx('SM3Z',false)
set VNv[$91]='SM40'
call LZx('SM40',false)
set VNv[$92]='SM41'
call LZx('SM41',false)
set VNv[$93]='SM42'
call LZx('SM42',false)
set VNv[$94]='SM43'
call LZx('SM43',false)
set VNv[$95]='SM44'
call LZx('SM44',false)
set VNv[$96]='SM45'
call LZx('SM45',false)
set VNv[$97]='SM46'
call LZx('SM46',false)
set VNv[$98]='SM47'
call LZx('SM47',false)
set VNv[$99]='SM48'
call LZx('SM48',false)
set VNv[$9A]='SM49'
call LZx('SM49',false)
set VNv[$9B]='SM4A'
call LZx('SM4A',false)
set VNv[$9C]='SM4B'
call LZx('SM4B',false)
set VNv[$9D]='SM4C'
call LZx('SM4C',false)
set VNv[$9E]='SM4D'
call LZx('SM4D',false)
set VNv[$9F]='SM4E'
call LZx('SM4E',false)
set VNv[$A0]='SM4F'
call LZx('SM4F',false)
set VNv[$A1]='SM4G'
call LZx('SM4G',false)
set VNv[$A2]='SM4H'
call LZx('SM4H',false)
set VNv[$A3]='SM4I'
call LZx('SM4I',false)
set VNv[$A4]='SM4J'
call LZx('SM4J',false)
set VNv[$A5]='SM4K'
call LZx('SM4K',false)
set VNv[$A6]='SM4L'
call LZx('SM4L',false)
set VNv[$A7]='SM4M'
call LZx('SM4M',false)
set VNv[$A8]='SM4N'
call LZx('SM4N',false)
set VNv[$A9]='SM4O'
call LZx('SM4O',false)
set VNv[$AA]='SM4P'
call LZx('SM4P',false)
set VNv[$AB]='SM4Q'
call LZx('SM4Q',false)
set VNv[$AC]='SM4R'
call LZx('SM4R',false)
set VNv[$AD]='SM4S'
call LZx('SM4S',false)
set VNv[$AE]='SM4T'
call LZx('SM4T',false)
set VNv[$AF]='SM4U'
call LZx('SM4U',false)
set VNv[$B0]='SM4V'
call LZx('SM4V',false)
set VNv[$B1]='SM4W'
call LZx('SM4W',false)
set VNv[$B2]='SM4X'
call LZx('SM4X',false)
set VNv[$B3]='SM4Y'
call LZx('SM4Y',false)
set VNv[$B4]='SM4Z'
call LZx('SM4Z',false)
set VNv[$B5]='SM50'
call LZx('SM50',false)
set VNv[$B6]='SM51'
call LZx('SM51',false)
set VNv[$B7]='SM52'
call LZx('SM52',false)
set VNv[$B8]='SM53'
call LZx('SM53',false)
set VNv[$B9]='SM54'
call LZx('SM54',false)
set VNv[$BA]='SM55'
call LZx('SM55',false)
set VNv[$BB]='SM56'
call LZx('SM56',false)
set VNv[$BC]='SM57'
call LZx('SM57',false)
set VNv[$BD]='SM58'
call LZx('SM58',false)
set VNv[$BE]='SM59'
call LZx('SM59',false)
set VNv[$BF]='SM5A'
call LZx('SM5A',false)
set VNv[$C0]='SM5B'
call LZx('SM5B',false)
set VNv[$C1]='SM5C'
call LZx('SM5C',false)
set VNv[$C2]='SM5D'
call LZx('SM5D',false)
set VNv[$C3]='SM5E'
call LZx('SM5E',false)
set VNv[$C4]='SM5F'
call LZx('SM5F',false)
set VNv[$C5]='SM5G'
call LZx('SM5G',false)
set VNv[$C6]='SM5H'
call LZx('SM5H',false)
set VNv[$C7]='SM5I'
call LZx('SM5I',false)
set VNv[$C8]='SM5J'
call LZx('SM5J',false)
set VNv[$C9]='SM5K'
call LZx('SM5K',false)
set VNv[$CA]='SM5L'
call LZx('SM5L',false)
set VNv[$CB]='SM5M'
call LZx('SM5M',false)
set VNv[$CC]='SM5N'
call LZx('SM5N',false)
set VNv[$CD]='SM5O'
call LZx('SM5O',false)
set VNv[$CE]='SM5P'
call LZx('SM5P',false)
set VNv[$CF]='SM5Q'
call LZx('SM5Q',false)
set VNv[$D0]='SM5R'
call LZx('SM5R',false)
set VNv[$D1]='SM5S'
call LZx('SM5S',false)
set VNv[$D2]='SM5T'
call LZx('SM5T',false)
set VNv[$D3]='SM5U'
call LZx('SM5U',false)
set VNv[$D4]='SM5V'
call LZx('SM5V',false)
set VNv[$D5]='SM5W'
call LZx('SM5W',false)
set VNv[$D6]='SM5X'
call LZx('SM5X',false)
set VNv[$D7]='SM5Y'
call LZx('SM5Y',false)
set VNv[$D8]='SM5Z'
call LZx('SM5Z',false)
set VNv[$D9]='SM60'
call LZx('SM60',false)
set VNv[$DA]='SM61'
call LZx('SM61',false)
set VNv[$DB]='SM62'
call LZx('SM62',false)
set VNv[$DC]='SM63'
call LZx('SM63',false)
set VNv[$DD]='SM64'
call LZx('SM64',false)
set VNv[$DE]='SM65'
call LZx('SM65',false)
set VNv[$DF]='SM66'
call LZx('SM66',false)
set VNv[$E0]='SM67'
call LZx('SM67',false)
set VNv[$E1]='SM68'
call LZx('SM68',false)
set VNv[$E2]='SM69'
call LZx('SM69',false)
set VNv[$E3]='SM6A'
call LZx('SM6A',false)
set VNv[$E4]='SM6B'
call LZx('SM6B',false)
set VNv[$E5]='SM6C'
call LZx('SM6C',false)
set VNv[$E6]='SM6D'
call LZx('SM6D',false)
set VNv[$E7]='SM6E'
call LZx('SM6E',false)
set VNv[$E8]='SM6F'
call LZx('SM6F',false)
set VNv[$E9]='SM6G'
call LZx('SM6G',false)
set VNv[$EA]='SM6H'
call LZx('SM6H',false)
set VNv[$EB]='SM6I'
call LZx('SM6I',false)
set VNv[$EC]='SM6J'
call LZx('SM6J',false)
set VNv[$ED]='SM6K'
call LZx('SM6K',false)
set VNv[$EE]='SM6L'
call LZx('SM6L',false)
set VNv[$EF]='SM6M'
call LZx('SM6M',false)
set VNv[$F0]='SM6N'
call LZx('SM6N',false)
set VNv[$F1]='SM6O'
call LZx('SM6O',false)
set VNv[$F2]='SM6P'
call LZx('SM6P',false)
set VNv[$F3]='SM6Q'
call LZx('SM6Q',false)
set VNv[$F4]='SM6R'
call LZx('SM6R',false)
set VNv[$F5]='SM6S'
call LZx('SM6S',false)
set VNv[$F6]='SM6T'
call LZx('SM6T',false)
set VNv[$F7]='SM6U'
call LZx('SM6U',false)
set VNv[$F8]='SM6V'
call LZx('SM6V',false)
set VNv[$F9]='SM6W'
call LZx('SM6W',false)
set VNv[$FA]='SM6X'
call LZx('SM6X',false)
set VNv[$FB]='SM6Y'
call LZx('SM6Y',false)
set VNv[$FC]='SM6Z'
call LZx('SM6Z',false)
set VNv[$FD]='SM70'
call LZx('SM70',false)
set VNv[$FE]='SM71'
call LZx('SM71',false)
set VNv[$FF]='SM72'
call LZx('SM72',false)
set VNv[256]='SM73'
call LZx('SM73',false)
set Vbv[1]='TM00'
call LZx('TM00',false)
set Vbv[2]='TM01'
call LZx('TM01',false)
set Vbv[3]='TM02'
call LZx('TM02',false)
set Vbv[4]='TM03'
call LZx('TM03',false)
set Vbv[5]='TM04'
call LZx('TM04',false)
set Vbv[6]='TM05'
call LZx('TM05',false)
set Vbv[7]='TM06'
call LZx('TM06',false)
set Vbv[8]='TM07'
call LZx('TM07',false)
set Vbv[9]='TM08'
call LZx('TM08',false)
set Vbv[$A]='TM09'
call LZx('TM09',false)
set Vbv[$B]='TM0A'
call LZx('TM0A',false)
set Vbv[$C]='TM0B'
call LZx('TM0B',false)
set Vbv[$D]='TM0C'
call LZx('TM0C',false)
set Vbv[$E]='TM0D'
call LZx('TM0D',false)
set Vbv[$F]='TM0E'
call LZx('TM0E',false)
set Vbv[16]='TM0F'
call LZx('TM0F',false)
set Vbv[17]='TM0G'
call LZx('TM0G',false)
set Vbv[18]='TM0H'
call LZx('TM0H',false)
set Vbv[19]='TM0I'
call LZx('TM0I',false)
set Vbv[20]='TM0J'
call LZx('TM0J',false)
set Vbv[21]='TM0K'
call LZx('TM0K',false)
set Vbv[22]='TM0L'
call LZx('TM0L',false)
set Vbv[23]='TM0M'
call LZx('TM0M',false)
set Vbv[24]='TM0N'
call LZx('TM0N',false)
set Vbv[25]='TM0O'
call LZx('TM0O',false)
set Vbv[26]='TM0P'
call LZx('TM0P',false)
set Vbv[27]='TM0Q'
call LZx('TM0Q',false)
set Vbv[28]='TM0R'
call LZx('TM0R',false)
set Vbv[29]='TM0S'
call LZx('TM0S',false)
set Vbv[30]='TM0T'
call LZx('TM0T',false)
set Vbv[31]='TM0U'
call LZx('TM0U',false)
set Vbv[32]='TM0V'
call LZx('TM0V',false)
set Vbv[33]='TM0W'
call LZx('TM0W',false)
set Vbv[34]='TM0X'
call LZx('TM0X',false)
set Vbv[35]='TM0Y'
call LZx('TM0Y',false)
set Vbv[36]='TM0Z'
call LZx('TM0Z',false)
set Vbv[37]='TM10'
call LZx('TM10',false)
set Vbv[38]='TM11'
call LZx('TM11',false)
set Vbv[39]='TM12'
call LZx('TM12',false)
set Vbv[40]='TM13'
call LZx('TM13',false)
set Vbv[41]='TM14'
call LZx('TM14',false)
set Vbv[42]='TM15'
call LZx('TM15',false)
set Vbv[43]='TM16'
call LZx('TM16',false)
set Vbv[44]='TM17'
call LZx('TM17',false)
set Vbv[45]='TM18'
call LZx('TM18',false)
set Vbv[46]='TM19'
call LZx('TM19',false)
set Vbv[47]='TM1A'
call LZx('TM1A',false)
set Vbv[48]='TM1B'
call LZx('TM1B',false)
set Vbv[49]='TM1C'
call LZx('TM1C',false)
set Vbv[50]='TM1D'
call LZx('TM1D',false)
set Vbv[51]='TM1E'
call LZx('TM1E',false)
set Vbv[52]='TM1F'
call LZx('TM1F',false)
set Vbv[53]='TM1G'
call LZx('TM1G',false)
set Vbv[54]='TM1H'
call LZx('TM1H',false)
set Vbv[55]='TM1I'
call LZx('TM1I',false)
set Vbv[56]='TM1J'
call LZx('TM1J',false)
set Vbv[57]='TM1K'
call LZx('TM1K',false)
set Vbv[58]='TM1L'
call LZx('TM1L',false)
set Vbv[59]='TM1M'
call LZx('TM1M',false)
set Vbv[60]='TM1N'
call LZx('TM1N',false)
set Vbv[61]='TM1O'
call LZx('TM1O',false)
set Vbv[62]='TM1P'
call LZx('TM1P',false)
set Vbv[63]='TM1Q'
call LZx('TM1Q',false)
set Vbv[64]='TM1R'
call LZx('TM1R',false)
set Vbv[65]='TM1S'
call LZx('TM1S',false)
set Vbv[66]='TM1T'
call LZx('TM1T',false)
set Vbv[67]='TM1U'
call LZx('TM1U',false)
set Vbv[68]='TM1V'
call LZx('TM1V',false)
set Vbv[69]='TM1W'
call LZx('TM1W',false)
set Vbv[70]='TM1X'
call LZx('TM1X',false)
set Vbv[71]='TM1Y'
call LZx('TM1Y',false)
set Vbv[72]='TM1Z'
call LZx('TM1Z',false)
set Vbv[73]='TM20'
call LZx('TM20',false)
set Vbv[74]='TM21'
call LZx('TM21',false)
set Vbv[75]='TM22'
call LZx('TM22',false)
set Vbv[76]='TM23'
call LZx('TM23',false)
set Vbv[77]='TM24'
call LZx('TM24',false)
set Vbv[78]='TM25'
call LZx('TM25',false)
set Vbv[79]='TM26'
call LZx('TM26',false)
set Vbv[80]='TM27'
call LZx('TM27',false)
set Vbv[81]='TM28'
call LZx('TM28',false)
set Vbv[82]='TM29'
call LZx('TM29',false)
set Vbv[83]='TM2A'
call LZx('TM2A',false)
set Vbv[84]='TM2B'
call LZx('TM2B',false)
set Vbv[85]='TM2C'
call LZx('TM2C',false)
set Vbv[86]='TM2D'
call LZx('TM2D',false)
set Vbv[87]='TM2E'
call LZx('TM2E',false)
set Vbv[88]='TM2F'
call LZx('TM2F',false)
set Vbv[89]='TM2G'
call LZx('TM2G',false)
set Vbv[90]='TM2H'
call LZx('TM2H',false)
set Vbv[91]='TM2I'
call LZx('TM2I',false)
set Vbv[92]='TM2J'
call LZx('TM2J',false)
set Vbv[93]='TM2K'
call LZx('TM2K',false)
set Vbv[94]='TM2L'
call LZx('TM2L',false)
set Vbv[95]='TM2M'
call LZx('TM2M',false)
set Vbv[96]='TM2N'
call LZx('TM2N',false)
set Vbv[97]='TM2O'
call LZx('TM2O',false)
set Vbv[98]='TM2P'
call LZx('TM2P',false)
set Vbv[99]='TM2Q'
call LZx('TM2Q',false)
set Vbv['d']='TM2R'
call LZx('TM2R',false)
set Vbv['e']='TM2S'
call LZx('TM2S',false)
set Vbv['f']='TM2T'
call LZx('TM2T',false)
set Vbv['g']='TM2U'
call LZx('TM2U',false)
set Vbv['h']='TM2V'
call LZx('TM2V',false)
set Vbv['i']='TM2W'
call LZx('TM2W',false)
set Vbv['j']='TM2X'
call LZx('TM2X',false)
set Vbv['k']='TM2Y'
call LZx('TM2Y',false)
set Vbv['l']='TM2Z'
call LZx('TM2Z',false)
set Vbv['m']='TM30'
call LZx('TM30',false)
set Vbv['n']='TM31'
call LZx('TM31',false)
set Vbv['o']='TM32'
call LZx('TM32',false)
set Vbv['p']='TM33'
call LZx('TM33',false)
set Vbv['q']='TM34'
call LZx('TM34',false)
set Vbv['r']='TM35'
call LZx('TM35',false)
set Vbv['s']='TM36'
call LZx('TM36',false)
set Vbv['t']='TM37'
call LZx('TM37',false)
set Vbv['u']='TM38'
call LZx('TM38',false)
set Vbv['v']='TM39'
call LZx('TM39',false)
set Vbv['w']='TM3A'
call LZx('TM3A',false)
set Vbv['x']='TM3B'
call LZx('TM3B',false)
set Vbv['y']='TM3C'
call LZx('TM3C',false)
set Vbv['z']='TM3D'
call LZx('TM3D',false)
set Vbv['{']='TM3E'
call LZx('TM3E',false)
set Vbv['|']='TM3F'
call LZx('TM3F',false)
set Vbv['}']='TM3G'
call LZx('TM3G',false)
set Vbv[$7E]='TM3H'
call LZx('TM3H',false)
set Vbv[$7F]='TM3I'
call LZx('TM3I',false)
set Vbv[$80]='TM3J'
call LZx('TM3J',false)
set Vbv[$81]='TM3K'
call LZx('TM3K',false)
set Vbv[$82]='TM3L'
call LZx('TM3L',false)
set Vbv[$83]='TM3M'
call LZx('TM3M',false)
set Vbv[$84]='TM3N'
call LZx('TM3N',false)
set Vbv[$85]='TM3O'
call LZx('TM3O',false)
set Vbv[$86]='TM3P'
call LZx('TM3P',false)
set Vbv[$87]='TM3Q'
call LZx('TM3Q',false)
set Vbv[$88]='TM3R'
call LZx('TM3R',false)
set Vbv[$89]='TM3S'
call LZx('TM3S',false)
set Vbv[$8A]='TM3T'
call LZx('TM3T',false)
set Vbv[$8B]='TM3U'
call LZx('TM3U',false)
set Vbv[$8C]='TM3V'
call LZx('TM3V',false)
set Vbv[$8D]='TM3W'
call LZx('TM3W',false)
set Vbv[$8E]='TM3X'
call LZx('TM3X',false)
set Vbv[$8F]='TM3Y'
call LZx('TM3Y',false)
set Vbv[$90]='TM3Z'
call LZx('TM3Z',false)
set Vbv[$91]='TM40'
call LZx('TM40',false)
set Vbv[$92]='TM41'
call LZx('TM41',false)
set Vbv[$93]='TM42'
call LZx('TM42',false)
set Vbv[$94]='TM43'
call LZx('TM43',false)
set Vbv[$95]='TM44'
call LZx('TM44',false)
set Vbv[$96]='TM45'
call LZx('TM45',false)
set Vbv[$97]='TM46'
call LZx('TM46',false)
set Vbv[$98]='TM47'
call LZx('TM47',false)
set Vbv[$99]='TM48'
call LZx('TM48',false)
set Vbv[$9A]='TM49'
call LZx('TM49',false)
set Vbv[$9B]='TM4A'
call LZx('TM4A',false)
set Vbv[$9C]='TM4B'
call LZx('TM4B',false)
set Vbv[$9D]='TM4C'
call LZx('TM4C',false)
set Vbv[$9E]='TM4D'
call LZx('TM4D',false)
set Vbv[$9F]='TM4E'
call LZx('TM4E',false)
set Vbv[$A0]='TM4F'
call LZx('TM4F',false)
set Vbv[$A1]='TM4G'
call LZx('TM4G',false)
set Vbv[$A2]='TM4H'
call LZx('TM4H',false)
set Vbv[$A3]='TM4I'
call LZx('TM4I',false)
set Vbv[$A4]='TM4J'
call LZx('TM4J',false)
set Vbv[$A5]='TM4K'
call LZx('TM4K',false)
set Vbv[$A6]='TM4L'
call LZx('TM4L',false)
set Vbv[$A7]='TM4M'
call LZx('TM4M',false)
set Vbv[$A8]='TM4N'
call LZx('TM4N',false)
set Vbv[$A9]='TM4O'
call LZx('TM4O',false)
set Vbv[$AA]='TM4P'
call LZx('TM4P',false)
set Vbv[$AB]='TM4Q'
call LZx('TM4Q',false)
set Vbv[$AC]='TM4R'
call LZx('TM4R',false)
set Vbv[$AD]='TM4S'
call LZx('TM4S',false)
set Vbv[$AE]='TM4T'
call LZx('TM4T',false)
set Vbv[$AF]='TM4U'
call LZx('TM4U',false)
set Vbv[$B0]='TM4V'
call LZx('TM4V',false)
set Vbv[$B1]='TM4W'
call LZx('TM4W',false)
set Vbv[$B2]='TM4X'
call LZx('TM4X',false)
set Vbv[$B3]='TM4Y'
call LZx('TM4Y',false)
set Vbv[$B4]='TM4Z'
call LZx('TM4Z',false)
set Vbv[$B5]='TM50'
call LZx('TM50',false)
set Vbv[$B6]='TM51'
call LZx('TM51',false)
set Vbv[$B7]='TM52'
call LZx('TM52',false)
set Vbv[$B8]='TM53'
call LZx('TM53',false)
set Vbv[$B9]='TM54'
call LZx('TM54',false)
set Vbv[$BA]='TM55'
call LZx('TM55',false)
set Vbv[$BB]='TM56'
call LZx('TM56',false)
set Vbv[$BC]='TM57'
call LZx('TM57',false)
set Vbv[$BD]='TM58'
call LZx('TM58',false)
set Vbv[$BE]='TM59'
call LZx('TM59',false)
set Vbv[$BF]='TM5A'
call LZx('TM5A',false)
set Vbv[$C0]='TM5B'
call LZx('TM5B',false)
set Vbv[$C1]='TM5C'
call LZx('TM5C',false)
set Vbv[$C2]='TM5D'
call LZx('TM5D',false)
set Vbv[$C3]='TM5E'
call LZx('TM5E',false)
set Vbv[$C4]='TM5F'
call LZx('TM5F',false)
set Vbv[$C5]='TM5G'
call LZx('TM5G',false)
set Vbv[$C6]='TM5H'
call LZx('TM5H',false)
set Vbv[$C7]='TM5I'
call LZx('TM5I',false)
set Vbv[$C8]='TM5J'
call LZx('TM5J',false)
set Vbv[$C9]='TM5K'
call LZx('TM5K',false)
set Vbv[$CA]='TM5L'
call LZx('TM5L',false)
set Vbv[$CB]='TM5M'
call LZx('TM5M',false)
set Vbv[$CC]='TM5N'
call LZx('TM5N',false)
set Vbv[$CD]='TM5O'
call LZx('TM5O',false)
set Vbv[$CE]='TM5P'
call LZx('TM5P',false)
set Vbv[$CF]='TM5Q'
call LZx('TM5Q',false)
set Vbv[$D0]='TM5R'
call LZx('TM5R',false)
set Vbv[$D1]='TM5S'
call LZx('TM5S',false)
set Vbv[$D2]='TM5T'
call LZx('TM5T',false)
set Vbv[$D3]='TM5U'
call LZx('TM5U',false)
set Vbv[$D4]='TM5V'
call LZx('TM5V',false)
set Vbv[$D5]='TM5W'
call LZx('TM5W',false)
set Vbv[$D6]='TM5X'
call LZx('TM5X',false)
set Vbv[$D7]='TM5Y'
call LZx('TM5Y',false)
set Vbv[$D8]='TM5Z'
call LZx('TM5Z',false)
set Vbv[$D9]='TM60'
call LZx('TM60',false)
set Vbv[$DA]='TM61'
call LZx('TM61',false)
set Vbv[$DB]='TM62'
call LZx('TM62',false)
set Vbv[$DC]='TM63'
call LZx('TM63',false)
set Vbv[$DD]='TM64'
call LZx('TM64',false)
set Vbv[$DE]='TM65'
call LZx('TM65',false)
set Vbv[$DF]='TM66'
call LZx('TM66',false)
set Vbv[$E0]='TM67'
call LZx('TM67',false)
set Vbv[$E1]='TM68'
call LZx('TM68',false)
set Vbv[$E2]='TM69'
call LZx('TM69',false)
set Vbv[$E3]='TM6A'
call LZx('TM6A',false)
set Vbv[$E4]='TM6B'
call LZx('TM6B',false)
set Vbv[$E5]='TM6C'
call LZx('TM6C',false)
set Vbv[$E6]='TM6D'
call LZx('TM6D',false)
set Vbv[$E7]='TM6E'
call LZx('TM6E',false)
set Vbv[$E8]='TM6F'
call LZx('TM6F',false)
set Vbv[$E9]='TM6G'
call LZx('TM6G',false)
set Vbv[$EA]='TM6H'
call LZx('TM6H',false)
set Vbv[$EB]='TM6I'
call LZx('TM6I',false)
set Vbv[$EC]='TM6J'
call LZx('TM6J',false)
set Vbv[$ED]='TM6K'
call LZx('TM6K',false)
set Vbv[$EE]='TM6L'
call LZx('TM6L',false)
set Vbv[$EF]='TM6M'
call LZx('TM6M',false)
set Vbv[$F0]='TM6N'
call LZx('TM6N',false)
set Vbv[$F1]='TM6O'
call LZx('TM6O',false)
set Vbv[$F2]='TM6P'
call LZx('TM6P',false)
set Vbv[$F3]='TM6Q'
call LZx('TM6Q',false)
set Vbv[$F4]='TM6R'
call LZx('TM6R',false)
set Vbv[$F5]='TM6S'
call LZx('TM6S',false)
set Vbv[$F6]='TM6T'
call LZx('TM6T',false)
set Vbv[$F7]='TM6U'
call LZx('TM6U',false)
set Vbv[$F8]='TM6V'
call LZx('TM6V',false)
set Vbv[$F9]='TM6W'
call LZx('TM6W',false)
set Vbv[$FA]='TM6X'
call LZx('TM6X',false)
set Vbv[$FB]='TM6Y'
call LZx('TM6Y',false)
set Vbv[$FC]='TM6Z'
call LZx('TM6Z',false)
set Vbv[$FD]='TM70'
call LZx('TM70',false)
set Vbv[$FE]='TM71'
call LZx('TM71',false)
set Vbv[$FF]='TM72'
call LZx('TM72',false)
set Vbv[256]='TM73'
call LZx('TM73',false)
return true
endfunction
function i2o takes nothing returns boolean
call VRx(ea,(function i0o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\MaxMana\\obj_spells_wc3objLuainits.j"))
call VRx(qa,(function i1o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\MaxMana\\obj_spells_wc3objLuaspells.j"))
return true
endfunction
function i3o takes nothing returns boolean
set VBv=Vnx(Vcv)
return true
endfunction
function i4o takes nothing returns boolean
set VCv=Vnx(Vdv)
return true
endfunction
function i5o takes nothing returns boolean
set VDv=Vnx(Vfv)
return true
endfunction
function i6o takes nothing returns boolean
set VFv=Vnx(Vgv)
return true
endfunction
function i7o takes nothing returns boolean
set hF=lQx(VGv+" (dummyBuff)")
return true
endfunction
function i8o takes nothing returns boolean
call VRx(Ma,(function i7o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\ManaRegeneration\\Disablement\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function i9o takes nothing returns boolean
set Vhv=Vnx(VGv)
return true
endfunction
function avo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set VHv[((rkx))]=(true)
call Bbx(rkx)
return true
endfunction
function aeo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set VHv[((rkx))]=(false)
if((GF[(rkx)])>.0)then
call BAx(rkx)
endif
return true
endfunction
function axo takes nothing returns boolean
call l9x(hF,XBx("FolderUnit_FolderManaRegeneration_StructDisablement_Buff_Init: call FolderUnit_FolderManaRegeneration_StructDisablement.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderManaRegeneration_StructDisablement.Event_BuffGain))",Bd,pI,function avo))
call l9x(hF,XBx("FolderUnit_FolderManaRegeneration_StructDisablement_Buff_Init: call FolderUnit_FolderManaRegeneration_StructDisablement.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderManaRegeneration_StructDisablement.Event_BuffLose))",Jc,pI,function aeo))
return true
endfunction
function aoo takes nothing returns boolean
call u6x(function axo,"FolderUnit_FolderManaRegeneration_StructDisablement_Buff_Init")
return true
endfunction
function aro takes nothing returns boolean
set Vjv=Vnx(VJv)
return true
endfunction
function aio takes nothing returns boolean
set Vkv=Vnx(VKv)
return true
endfunction
function aao takes nothing returns boolean
set Vlv=Vnx(VLv)
return true
endfunction
function ano takes nothing returns boolean
set Vmv=Vnx(VMv)
return true
endfunction
function aVo takes nothing returns boolean
set Vpv=Vnx(VPv)
return true
endfunction
function aEo takes nothing returns boolean
set Vqv=Vnx(VQv)
return true
endfunction
function aXo takes nothing returns boolean
set Vsv=Vnx(VSv)
return true
endfunction
function aOo takes nothing returns boolean
call LZx('AmSp',false)
return true
endfunction
function aRo takes nothing returns boolean
call LZx('AmSx',false)
return true
endfunction
function aIo takes nothing returns boolean
call VRx(qa,(function aOo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Movement\\Speed\\BonusA\\obj_dummySpell_wc3spell.j"))
call VRx(qa,(function aRo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Movement\\Speed\\BonusA\\obj_storageSpell_wc3spell.j"))
return true
endfunction
function aAo takes nothing returns boolean
set Vtv=Vnx(VTv)
return true
endfunction
function aNo takes nothing returns boolean
set Vuv=Vnx(VUv)
return true
endfunction
function abo takes nothing returns boolean
set Vwv=Vnx(VWv)
return true
endfunction
function aBo takes nothing returns boolean
set x_v=lQx(Vyv+" (disableBuff)")
return true
endfunction
function aco takes nothing returns boolean
call VRx(Ma,(function aBo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Movement\\obj_disableBuff_wc3buff.j"))
return true
endfunction
function aCo takes nothing returns boolean
set VYv=Vnx(Vyv)
return true
endfunction
function ado takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set Vzv[((rkx))]=(false)
call SetUnitPropWindow(C[rkx],.0)
return true
endfunction
function aDo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set Vzv[((rkx))]=(true)
call SetUnitPropWindow(C[rkx],60.)
return true
endfunction
function afo takes nothing returns boolean
call l9x(x_v,XBx("FolderUnit_StructMovement_Buff_Init: call FolderUnit_StructMovement.DISABLE_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructMovement.Event_BuffGain))",Bd,pI,function ado))
call l9x(x_v,XBx("FolderUnit_StructMovement_Buff_Init: call FolderUnit_StructMovement.DISABLE_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructMovement.Event_BuffLose))",Jc,pI,function aDo))
return true
endfunction
function aFo takes nothing returns boolean
call u6x(function afo,"FolderUnit_StructMovement_Buff_Init")
return true
endfunction
function ago takes nothing returns boolean
set VZv=Vnx(V_v)
return true
endfunction
function aGo takes nothing returns boolean
set V0v=Vnx(V1v)
return true
endfunction
function aho takes nothing returns boolean
set V2v=Vnx(V3v)
return true
endfunction
function aHo takes nothing returns boolean
set V4v=Vnx(V5v)
return true
endfunction
function ajo takes nothing returns boolean
set V6v=Vnx(V7v)
return true
endfunction
function aJo takes nothing returns boolean
set V8v=Vnx(V9v)
return true
endfunction
function ako takes nothing returns boolean
set Evv=Vnx(Eev)
return true
endfunction
function aKo takes nothing returns boolean
set Exv=Vnx(Eov)
return true
endfunction
function alo takes nothing returns boolean
set Erv=lQx(Eiv+" (noneBuff)")
return true
endfunction
function aLo takes nothing returns boolean
call LZx('aBan',false)
return true
endfunction
function amo takes nothing returns boolean
set Eav=lQx(Eiv+" (normalBuff)")
return true
endfunction
function aMo takes nothing returns boolean
set Env=lQx(Eiv+" (dummyBuff)")
return true
endfunction
function apo takes nothing returns boolean
call VRx(Ma,(function alo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Banish\\obj_noneBuff_wc3buff.j"))
call VRx(qa,(function aLo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Banish\\obj_banSpell_wc3spell.j"))
call VRx(Ma,(function amo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Banish\\obj_normalBuff_wc3buff.j"))
call VRx(Ma,(function aMo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Banish\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function aPo takes nothing returns boolean
set EVv=Vnx(Eiv)
return true
endfunction
function aqo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set EEv[((rkx))]=(true)
call I7x(rkx,EXv)
call Dsx(Zj,v3,rkx)
return true
endfunction
function aQo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set EEv[((rkx))]=(false)
call Rmx(rkx,EXv)
call UnitRemoveAbility(C[((((rkx))))],(('bBan')))
return true
endfunction
function aso takes nothing returns boolean
call l9x(Env,XBx("FolderUnit_StructBanish_Buff_Init: call FolderUnit_StructBanish.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructBanish.Event_BuffGain))",Bd,BI,function aqo))
call l9x(Env,XBx("FolderUnit_StructBanish_Buff_Init: call FolderUnit_StructBanish.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructBanish.Event_BuffLose))",Jc,BI,function aQo))
call W_x(Env,Eav)
return true
endfunction
function aSo takes nothing returns boolean
call u6x(function aso,"FolderUnit_StructBanish_Buff_Init")
return true
endfunction
function ato takes nothing returns boolean
set EOv=lQx(ERv+" (dummyBuff)")
return true
endfunction
function aTo takes nothing returns boolean
set EIv=WTx('BCof',"Confused",'bCof')
set aev[(EIv)]=("ReplaceableTextures\\CommandButtons\\BTNBerserkForTrolls.blp")
call lux(EIv,"Abilities\\Spells\\NightElf\\shadowstrike\\shadowstrike.mdl","overhead",ri)
set SU=lYx()
call rQo(SU,rWo(Db,0,-$AF,-$AF,0))
call l0x(((EIv)),vc+(1),(SU))
return true
endfunction
function auo takes nothing returns boolean
call VRx(Ma,(function ato),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Madness\\obj_dummyBuff_wc3buff.j"))
call VRx(Ma,(function aTo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Madness\\obj_normalBuff_wc3buff.j"))
return true
endfunction
function aUo takes nothing returns boolean
set EAv=Vnx(ERv)
return true
endfunction
function awo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set Ze[((rkx))]=(true)
call SetUnitOwner(C[rkx],vx[ex],false)
call Cbx(rkx)
return true
endfunction
function aWo takes integer oqx returns nothing
call aNx(oqx,(ze[(oqx)]))
endfunction
function ayo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set Ze[((rkx))]=(false)
call aWo(rkx)
return true
endfunction
function aYo takes nothing returns boolean
call l9x(EOv,XBx("FolderUnit_StructMadness_Buff_Init: call FolderUnit_StructMadness.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructMadness.Event_BuffGain))",Bd,BI,function awo))
call l9x(EOv,XBx("FolderUnit_StructMadness_Buff_Init: call FolderUnit_StructMadness.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructMadness.Event_BuffLose))",Jc,BI,function ayo))
call W_x(EOv,EIv)
return true
endfunction
function azo takes nothing returns boolean
call u6x(function aYo,"FolderUnit_StructMadness_Buff_Init")
return true
endfunction
function aZo takes nothing returns boolean
set ENv=WTx('BEcl',"Eclipse",'bEcl')
set aev[(ENv)]=("ReplaceableTextures\\CommandButtons\\BTNSoulGem.blp")
call lux(ENv,"Unit_page\\Unit_struct\\Eclipse\\TargetEffect.mdx","origin",Bi)
set SU=lYx()
call rQo(SU,rWo(Db,-50,-$96,-50,0))
call l0x(((ENv)),vc+(1),(SU))
return true
endfunction
function a_o takes nothing returns boolean
set Ebv=lQx(EBv+" (dummyBuff)")
set SU=lYx()
call l_x(SU,Ecv,-.3)
call l_x(SU,ECv,-.5)
call l_x(SU,ZU,-.3)
call l_x(SU,Edv,-.5)
call l0x(((Ebv)),vc+(1),(SU))
return true
endfunction
function a0o takes nothing returns boolean
call VRx(Ma,(function aZo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Eclipse\\obj_normalBuff_wc3buff.j"))
call VRx(Ma,(function a_o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Eclipse\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function a1o takes nothing returns boolean
set EDv=Vnx(EBv)
return true
endfunction
function a2o takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set Efv[((rkx))]=(true)
return true
endfunction
function a3o takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set Efv[((rkx))]=(false)
return true
endfunction
function a4o takes nothing returns boolean
call l9x(Ebv,XBx("FolderUnit_StructEclipse_Buff_Init: call FolderUnit_StructEclipse.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructEclipse.Event_BuffGain))",Bd,pI,function a2o))
call l9x(Ebv,XBx("FolderUnit_StructEclipse_Buff_Init: call FolderUnit_StructEclipse.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructEclipse.Event_BuffLose))",Jc,pI,function a3o))
return true
endfunction
function a5o takes nothing returns boolean
call u6x(function a4o,"FolderUnit_StructEclipse_Buff_Init")
return true
endfunction
function a6o takes nothing returns boolean
set EFv=lQx(Egv+" (normalBuff)")
return true
endfunction
function a7o takes nothing returns boolean
call LZx('aWhI',false)
return true
endfunction
function a8o takes nothing returns boolean
set EGv=lQx(Egv+" (noneBuff)")
return true
endfunction
function a9o takes nothing returns boolean
call LZx('aWhC',false)
return true
endfunction
function nvo takes nothing returns boolean
set Ehv=lQx(Egv+" (dummyBuff)")
return true
endfunction
function neo takes nothing returns boolean
call VRx(Ma,(function a6o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Whirl\\obj_normalBuff_wc3buff.j"))
call VRx(qa,(function a7o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Whirl\\obj_impaleSpell_wc3spell.j"))
call VRx(Ma,(function a8o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Whirl\\obj_noneBuff_wc3buff.j"))
call VRx(qa,(function a9o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Whirl\\obj_cycloneSpell_wc3spell.j"))
call VRx(Ma,(function nvo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Whirl\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function nxo takes nothing returns boolean
set EHv=Vnx(Egv)
return true
endfunction
function noo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local real x
local real y
set Ejv[((rkx))]=(true)
call I7x(rkx,EJv)
set x=DPx(rkx)
set y=DQx(rkx)
call UnitAddType(C[rkx],UNIT_TYPE_SAPPER)
call Dsx(Zj,L3,rkx)
call UnitRemoveType(C[rkx],UNIT_TYPE_SAPPER)
return true
endfunction
function nro takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set Ejv[((rkx))]=(false)
call Rmx(rkx,EJv)
call UnitRemoveAbility(C[((((rkx))))],(('bWhX')))
return true
endfunction
function nio takes nothing returns boolean
call l9x(Ehv,XBx("FolderUnit_StructWhirl_Buff_Init: call FolderUnit_StructWhirl.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructWhirl.Event_BuffGain))",Bd,BI,function noo))
call l9x(Ehv,XBx("FolderUnit_StructWhirl_Buff_Init: call FolderUnit_StructWhirl.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructWhirl.Event_BuffLose))",Jc,BI,function nro))
call W_x(Ehv,EFv)
return true
endfunction
function nao takes nothing returns boolean
call u6x(function nio,"FolderUnit_StructWhirl_Buff_Init")
return true
endfunction
function nno takes nothing returns boolean
set Ekv=Vnx(EKv)
return true
endfunction
function nVo takes nothing returns boolean
set Elv=lQx(ELv+" (dummyBuff)")
return true
endfunction
function nEo takes nothing returns boolean
set Emv=lQx(ELv+" (normalBuff)")
call lux(Emv,"Unit_page\\Unit_struct\\Bleeding\\buff2.mdx","chest",ri)
return true
endfunction
function nXo takes nothing returns boolean
call VRx(Ma,(function nVo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Bleeding\\obj_dummyBuff_wc3buff.j"))
call VRx(Ma,(function nEo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Bleeding\\obj_normalBuff_wc3buff.j"))
return true
endfunction
function nOo takes nothing returns boolean
set EMv=Vnx(ELv)
return true
endfunction
function nRo takes integer oqx returns boolean
if not(aPv[(oqx)])then
return false
endif
call cbx((oqx),iqx("Blocked!!","d4e019aa"),.02,aqv+oqx)
call RUx((Abx(((oqx)),("Abilities\\Spells\\Other\\HealingSpray\\HealBottleMissile.mdl"),("chest"),(ri))))
call Ayx((oqx),COx((oqx),aqv,q))
return true
endfunction
function nIo takes integer oqx returns boolean
if not(aTv[(oqx)])then
return nRo(oqx)
endif
call cbx((oqx),iqx("Magic immune!!","d4e019aa"),.02,Esv+oqx)
return true
endfunction
function nAo takes real oSx returns real
if(oSx<.0)then
return(2.-(Pow((((1.-.06))*1.),((-oSx*ESv)*1.))))
endif
return(1.*1./(1.+.06*oSx*ESv))
endfunction
function nNo takes real oSx returns real
if(oSx<.0)then
return(2.-(Pow((((1.-.06))*1.),((-oSx)*1.))))
endif
return(1.*1./(1.+.06*oSx))
endfunction
function nbo takes integer oqx,integer Ixx returns boolean
if((xk[((oqx))])and not(nkv[((oqx))]))then
return true
endif
if(Euv[(Ixx)])then
return true
endif
return((GetRandomReal(((.0)*1.),((1.)*1.)))<=(bJx(((eF[((oqx))])-(EUv[((Ixx))]))*1./ 'd',.0,1.)))
endfunction
function nBo takes integer oqx returns boolean
if not(aav[(oqx)])then
return false
endif
call cbx((oqx),iqx("Invulnerable!!","ffff0000"),.02,Ewv+oqx)
return true
endfunction
function nco takes integer oqx,real nyx,integer Ixx,boolean nCo returns real
local integer rkx=oqx
local integer rdx=rEx((A[(rkx)]))
local integer ndo
local integer olx
local integer rIx
local integer rlx
set Eyv[(rdx)]=((nyx)*1.)
set EYv[(rdx)]=(rkx)
set WH[(rdx)]=(Ixx)
set Vv[(rdx)]=(Ixx)
set ndo=rEx((A[(Ixx)]))
set Eyv[(ndo)]=((nyx)*1.)
set EYv[(ndo)]=(rkx)
set Vv[(ndo)]=(Ixx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(Ixx,Ezv,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(Ixx,Ezv,rIx,rlx),ndo)
set Eyv[(rdx)]=(((Eyv[(ndo)]))*1.)
set rlx=rlx-1
endloop
set rlx=rOx(rkx,EZv,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,EZv,rIx,rlx),rdx)
set Eyv[(ndo)]=(((Eyv[(rdx)]))*1.)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call rHx(((ndo)))
set nyx=(Eyv[(rdx)])
return nyx
endfunction
function nDo takes integer oqx,real oSx returns nothing
call cFx(oqx,(rG[(oqx)])-oSx)
endfunction
function nfo takes integer oqx,integer Ixx,real nyx,boolean nFo returns real
if nBo(Ixx)then
return .0
endif
set nyx=nyx*(1.-(EWv[(Ixx)]))
if(nyx>.0)then
if nFo then
set nyx=nco(oqx,nyx,Ixx,false)
endif
set nyx=itx(nyx,(rG[(Ixx)]))
call UnitDamageTarget(C[(oqx)],C[Ixx],.0,false,false,null,null,null)
set fG=oqx
call nDo(Ixx,nyx)
return nyx
endif
return .0
endfunction
function ngo takes integer oqx,string iNx,real X7x,real Okx,real OKx,real ilx,integer id,real oSx returns integer
local integer nGo=(LoadInteger(o[((V[(E[((X))])]))],(((ON))),((((id))))))
if((nGo==w)or((fN[(nGo)])<oSx))then
if(nGo!=w)then
call OBx(nGo)
endif
set nGo=OMx(oqx,iNx,X7x,Okx,OKx,ilx,id)
set fN[(nGo)]=((oSx)*1.)
endif
return nGo
endfunction
function nho takes real dX,real dY,real bkx,real nwx returns real
if(dY==.0)then
return((nwx+bkx)*1./ 2)
endif
return bJx(bkx+dX*1./ dY*(nwx-bkx),bkx,nwx)
endfunction
function nHo takes integer oqx,real nyx,boolean njo returns nothing
set nyx=nyx*(E_v[(oqx)])*.01
if(nyx<=.0)then
return
endif
call ngo((oqx),iZx("~"+(I2S(((R2I(((((nyx)*1.))*1.))))))+iQx(njo,"!")+"~",(rb[((ze[((oqx))]))]),"ff20b2aa"),nho(nyx,(iG[((oqx))])*1./ 2.,.016,.022),160.,.0,1.,E0v+oqx,nyx*1./ 2)
call cGx((oqx),nyx)
endfunction
function nJo takes integer oqx,integer Ixx,real nyx,boolean nko,boolean nFo returns real
local boolean njo=false
if(nyx>.0)then
if nko then
if nIo(Ixx)then
return .0
endif
set nyx=nyx*nAo((ZF[(Ixx)])-(ZF[((oqx))]))*(1.-(Etv[(Ixx)]))*(GetRandomReal(((.9)*1.),((1.1)*1.)))
else
set nyx=nyx*nNo((ETv[(Ixx)]))
endif
if(not nko and nbo((oqx),Ixx))then
set nyx=nyx*2.
set njo=true
endif
endif
set nyx=nfo(oqx,Ixx,nyx,nFo)
call nHo((oqx),nyx,njo)
return nyx
endfunction
function nKo takes integer oqx,integer Ixx,real nyx,boolean nko,boolean nFo returns real
return nJo(oqx,Ixx,nyx,nko,nFo)
endfunction
function nlo takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
call RUx((Abx((Ixx),((EQv[(Ixx)])),("chest"),(Bi))))
if I6x(Ixx,yd)then
call nKo(EPv[oqx],Ixx,E2v*(iG[(Ixx)]),false,false)
else
call nKo(EPv[oqx],Ixx,E4v*(iG[(Ixx)]),false,false)
endif
endfunction
function nLo takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(mc[(rdx)])
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
local integer p0x
set Epv[(oqx)]=(true)
set p0x=inx()
set EPv[oqx]=CMx
set Eqv[oqx]=p0x
set ge[(p0x)]=(oqx)
call DSx((((rkx))),(nHv),(1),w)
call icx(p0x,1.,true,function nlo)
return true
endfunction
function nmo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
set Epv[(oqx)]=(false)
call ijx(Eqv[oqx])
call UJx(((rkx)),nHv)
return true
endfunction
function nMo takes nothing returns boolean
call l9x(Elv,XBx("FolderUnit_StructBleeding_Buff_Init: call FolderUnit_StructBleeding.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructBleeding.Event_BuffGain))",Bd,pI,function nLo))
call l9x(Elv,XBx("FolderUnit_StructBleeding_Buff_Init: call FolderUnit_StructBleeding.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructBleeding.Event_BuffLose))",Jc,pI,function nmo))
call W_x(Elv,Emv)
return true
endfunction
function npo takes nothing returns boolean
call u6x(function nMo,"FolderUnit_StructBleeding_Buff_Init")
return true
endfunction
function nPo takes nothing returns boolean
set E5v=WTx('BIgn',"Ignited",'bIgn')
set aev[(E5v)]=("ReplaceableTextures\\CommandButtons\\BTNSelfDestruct.blp")
call lux(E5v,"Abilities\\Spells\\Other\\BreathOfFire\\BreathOfFireDamage.mdx","overhead",ri)
call lux(E5v,"Unit_page\\Unit_struct\\Ignited\\Target.mdx","foot left",Bi)
call lux(E5v,"Unit_page\\Unit_struct\\Ignited\\Target.mdx","foot right",Bi)
call lux(E5v,"Unit_page\\Unit_struct\\Ignited\\Target.mdx","hand left",Bi)
call lux(E5v,"Unit_page\\Unit_struct\\Ignited\\Target.mdx","chest",Bi)
call lux(E5v,"Unit_page\\Unit_struct\\Ignited\\Target.mdx","head",Bi)
return true
endfunction
function nqo takes nothing returns boolean
set E6v=lQx(E7v+" (dummyBuff)")
return true
endfunction
function nQo takes nothing returns boolean
call VRx(Ma,(function nPo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Ignited\\obj_normalBuff_wc3buff.j"))
call VRx(Ma,(function nqo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Ignited\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function nso takes nothing returns boolean
set E8v=Vnx(E7v)
return true
endfunction
function nSo takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
if I6x(Ixx,yd)then
call nKo(Xvv[oqx],Ixx,Xov*(iG[(Ixx)]),true,false)
else
call nKo(Xvv[oqx],Ixx,Xiv*(iG[(Ixx)]),true,false)
endif
endfunction
function nto takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(mc[(rdx)])
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
local integer p0x
set E9v[(oqx)]=(true)
set p0x=inx()
set Xvv[oqx]=CMx
set Xev[oqx]=p0x
set ge[(p0x)]=(oqx)
call DSx((((rkx))),(nHv),(1),w)
call icx(p0x,1.,true,function nSo)
return true
endfunction
function nTo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
set E9v[(oqx)]=(false)
call ijx(Xev[oqx])
call UJx(((rkx)),nHv)
return true
endfunction
function nuo takes nothing returns boolean
call l9x(E6v,XBx("FolderUnit_StructIgnited_Buff_Init: call FolderUnit_StructIgnited.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructIgnited.Event_BuffGain))",Bd,pI,function nto))
call l9x(E6v,XBx("FolderUnit_StructIgnited_Buff_Init: call FolderUnit_StructIgnited.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructIgnited.Event_BuffLose))",Jc,pI,function nTo))
call W_x(E6v,E5v)
return true
endfunction
function nUo takes nothing returns boolean
call u6x(function nuo,"FolderUnit_StructIgnited_Buff_Init")
return true
endfunction
function nwo takes nothing returns boolean
set Xav=Vnx(Xnv)
return true
endfunction
function nWo takes nothing returns boolean
return true
endfunction
function nyo takes nothing returns boolean
call u6x(function nWo,"FolderUnit_StructKnockup_Buff_Init")
return true
endfunction
function nYo takes nothing returns boolean
set XVv=lQx(XEv+" (dummyBuff)")
return true
endfunction
function nzo takes nothing returns boolean
call VRx(Ma,(function nYo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Pathing\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function nZo takes nothing returns boolean
set XXv=Vnx(XEv)
return true
endfunction
function n_o takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set XOv[((rkx))]=(false)
call SetUnitPathing(C[rkx],false)
return true
endfunction
function n0o takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set XOv[((rkx))]=(true)
call SetUnitPathing(C[rkx],true)
return true
endfunction
function n1o takes nothing returns boolean
call l9x(XVv,XBx("FolderUnit_StructPathing_Buff_Init: call FolderUnit_StructPathing.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructPathing.Event_BuffGain))",Bd,pI,function n_o))
call l9x(XVv,XBx("FolderUnit_StructPathing_Buff_Init: call FolderUnit_StructPathing.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructPathing.Event_BuffLose))",Jc,pI,function n0o))
return true
endfunction
function n2o takes nothing returns boolean
call u6x(function n1o,"FolderUnit_StructPathing_Buff_Init")
return true
endfunction
function n3o takes nothing returns boolean
set XRv=lQx(XIv+" (dummyBuff)")
set SU=lYx()
call l_x(SU,nev,-.25)
call l_x(SU,Ecv,-.5)
call l_x(SU,XAv,-.5)
call l_x(SU,ZU,-.1)
call l0x(((XRv)),vc+(1),(SU))
return true
endfunction
function n4o takes nothing returns boolean
set XNv=WTx('BPoi',"Poisoned",'bPoi')
set aev[(XNv)]=("ReplaceableTextures\\CommandButtons\\BTNCorrosiveBreath.blp")
call lux(XNv,"Abilities\\Spells\\Undead\\Curse\\CurseTarget.mdl","overhead",Bi)
set SU=lYx()
call rQo(SU,rWo(Db,-'d',0,-'d',0))
call l0x(((XNv)),vc+(1),(SU))
return true
endfunction
function n5o takes nothing returns boolean
call VRx(Ma,(function n3o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Poisoned\\obj_dummyBuff_wc3buff.j"))
call VRx(Ma,(function n4o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Poisoned\\obj_normalBuff_wc3buff.j"))
return true
endfunction
function n6o takes nothing returns boolean
set Xbv=Vnx(XIv)
return true
endfunction
function n7o takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set XBv[((rkx))]=(true)
return true
endfunction
function n8o takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set XBv[((rkx))]=(false)
return true
endfunction
function n9o takes nothing returns boolean
call l9x(XRv,XBx("FolderUnit_StructPoisoned_Buff_Init: call FolderUnit_StructPoisoned.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructPoisoned.Event_BuffGain))",Bd,pI,function n7o))
call l9x(XRv,XBx("FolderUnit_StructPoisoned_Buff_Init: call FolderUnit_StructPoisoned.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructPoisoned.Event_BuffLose))",Jc,pI,function n8o))
call W_x(XRv,XNv)
return true
endfunction
function Vvo takes nothing returns boolean
call u6x(function n9o,"FolderUnit_StructPoisoned_Buff_Init")
return true
endfunction
function Veo takes nothing returns boolean
set Xcv=Vnx(XCv)
return true
endfunction
function Vxo takes nothing returns boolean
set Xdv=Vnx(XDv)
return true
endfunction
function Voo takes nothing returns boolean
call LZx('ARev',false)
return true
endfunction
function Vro takes nothing returns boolean
call VRx(qa,(function Voo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Revival\\obj_dummySpell_wc3spell.j"))
return true
endfunction
function Vio takes nothing returns boolean
set Xfv=Vnx(XFv)
return true
endfunction
function Vao takes nothing returns boolean
set Xgv=lQx(XGv+" (dummyBuff)")
return true
endfunction
function Vno takes nothing returns boolean
set Xhv=lQx(XGv+" (normalBuff)")
call lux(Xhv,"Abilities\\Spells\\Other\\Silence\\SilenceTarget.mdl","overhead",ri)
return true
endfunction
function VVo takes nothing returns boolean
set XHv=lQx(XGv+" (noneBuff)")
return true
endfunction
function VEo takes nothing returns boolean
call LZx('aSil',false)
return true
endfunction
function VXo takes nothing returns boolean
call VRx(Ma,(function Vao),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Silence\\obj_dummyBuff_wc3buff.j"))
call VRx(Ma,(function Vno),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Silence\\obj_normalBuff_wc3buff.j"))
call VRx(Ma,(function VVo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Silence\\obj_noneBuff_wc3buff.j"))
call VRx(qa,(function VEo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Silence\\obj_silSpell_wc3spell.j"))
return true
endfunction
function VOo takes nothing returns boolean
set Xjv=Vnx(XGv)
return true
endfunction
function VRo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set XJv[((rkx))]=(true)
call I7x(rkx,Xkv)
call Dsx(Zj,X4,rkx)
return true
endfunction
function VIo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set XJv[((rkx))]=(false)
call Rmx(rkx,Xkv)
call UnitRemoveAbility(C[((((rkx))))],(('bSil')))
return true
endfunction
function VAo takes nothing returns boolean
call l9x(Xgv,XBx("FolderUnit_StructSilence_Buff_Init: call FolderUnit_StructSilence.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructSilence.Event_BuffGain))",Bd,BI,function VRo))
call l9x(Xgv,XBx("FolderUnit_StructSilence_Buff_Init: call FolderUnit_StructSilence.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructSilence.Event_BuffLose))",Jc,BI,function VIo))
call W_x(Xgv,Xhv)
return true
endfunction
function VNo takes nothing returns boolean
call u6x(function VAo,"FolderUnit_StructSilence_Buff_Init")
return true
endfunction
function Vbo takes nothing returns boolean
call LZx('ACsl',false)
return true
endfunction
function VBo takes nothing returns boolean
set XKv=lQx(Xlv+" (normalBuff)")
call lux(XKv,"Abilities\\Spells\\Undead\\Sleep\\SleepTarget.mdl","overhead",ri)
return true
endfunction
function Vco takes nothing returns boolean
set XLv=lQx(Xlv+" (dummyBuff)")
return true
endfunction
function VCo takes nothing returns boolean
call VRx(qa,(function Vbo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Sleep\\obj_sleepSpell_wc3spell.j"))
call VRx(Ma,(function VBo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Sleep\\obj_normalBuff_wc3buff.j"))
call VRx(Ma,(function Vco),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Sleep\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function Vdo takes nothing returns boolean
set Xmv=Vnx(Xlv)
return true
endfunction
function VDo takes integer oqx returns nothing
call DSx(((oqx)),(nhv),(1),w)
endfunction
function Vfo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
set Euv[((rkx))]=(true)
call I7x(rkx,XMv)
call VDo(rkx)
call Dsx(Zj,V4,rkx)
call UnitRemoveAbility(C[((((rkx))))],(('BSlp')))
return true
endfunction
function VFo takes integer oqx returns nothing
call UJx((oqx),nhv)
endfunction
function Vgo takes integer oqx returns nothing
local integer rkx=oqx
local integer rdx=rEx((A[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set Vv[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,Xpv,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,Xpv,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function VGo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set Euv[((rkx))]=(false)
call Rmx(rkx,XMv)
call VFo(rkx)
call UnitRemoveAbility(C[((((rkx))))],(('BSlp')))
call UnitRemoveAbility(C[((((rkx))))],(('BUsl')))
call Vgo((rkx))
return true
endfunction
function Vho takes nothing returns boolean
call l9x(XLv,XBx("FolderUnit_StructSleep_Buff_Init: call FolderUnit_StructSleep.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructSleep.Event_BuffGain))",Bd,BI,function Vfo))
call l9x(XLv,XBx("FolderUnit_StructSleep_Buff_Init: call FolderUnit_StructSleep.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructSleep.Event_BuffLose))",Jc,BI,function VGo))
call W_x(XLv,XKv)
return true
endfunction
function VHo takes nothing returns boolean
call u6x(function Vho,"FolderUnit_StructSleep_Buff_Init")
return true
endfunction
function Vjo takes nothing returns boolean
set XPv=Vnx(Xqv)
return true
endfunction
function VJo takes nothing returns boolean
call LZx('AStn',false)
return true
endfunction
function Vko takes nothing returns boolean
set nhv=lQx(XQv+" (dummyBuff)")
return true
endfunction
function VKo takes nothing returns boolean
set Xsv=WTx('BStd',"Stunned",'bStd')
set aev[(Xsv)]=("ReplaceableTextures\\CommandButtons\\BTNStun.blp")
call lux(Xsv,"Abilities\\Spells\\Human\\Thunderclap\\ThunderclapTarget.mdl","overhead",ri)
return true
endfunction
function Vlo takes nothing returns boolean
call VRx(qa,(function VJo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Stun\\obj_stunSpell_wc3spell.j"))
call VRx(Ma,(function Vko),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Stun\\obj_dummyBuff_wc3buff.j"))
call VRx(Ma,(function VKo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Stun\\obj_normalBuff_wc3buff.j"))
return true
endfunction
function VLo takes nothing returns boolean
set XSv=Vnx(XQv)
return true
endfunction
function Vmo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set Mh[((rkx))]=(true)
call Dsx(Zj,C4,rkx)
return true
endfunction
function VMo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
set Mh[((rkx))]=(false)
call UnitRemoveAbility(C[((((rkx))))],(('bStu')))
return true
endfunction
function Vpo takes nothing returns boolean
call l9x(nhv,XBx("FolderUnit_StructStun_Buff_Init: call FolderUnit_StructStun.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructStun.Event_BuffGain))",Bd,BI,function Vmo))
call l9x(nhv,XBx("FolderUnit_StructStun_Buff_Init: call FolderUnit_StructStun.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructStun.Event_BuffLose))",Jc,BI,function VMo))
call W_x(nhv,Xsv)
return true
endfunction
function VPo takes nothing returns boolean
call u6x(function Vpo,"FolderUnit_StructStun_Buff_Init")
return true
endfunction
function Vqo takes nothing returns boolean
set xPv=Vnx(xMv)
return true
endfunction
function VQo takes nothing returns boolean
set Xtv=Vnx(XTv)
return true
endfunction
function Vso takes nothing returns boolean
set Xuv=Vnx(XUv)
return true
endfunction
function VSo takes nothing returns boolean
set Xwv=Vnx(XWv)
return true
endfunction
function Vto takes nothing returns boolean
set Xyv=Vnx(XYv)
return true
endfunction
function VTo takes nothing returns boolean
set Xzv=Vnx(XZv)
return true
endfunction
function Vuo takes nothing returns boolean
set X_v=Vnx(X0v)
return true
endfunction
function VUo takes nothing returns boolean
set X1v=Vnx(X2v)
return true
endfunction
function Vwo takes nothing returns boolean
set X3v=Vnx(X4v)
return true
endfunction
function VWo takes nothing returns boolean
set X5v=Vnx(X6v)
return true
endfunction
function Vyo takes nothing returns boolean
set X7v=Vnx(X8v)
return true
endfunction
function VYo takes nothing returns boolean
set X9v=Vnx(Ovv)
return true
endfunction
function Vzo takes nothing returns boolean
set Oev=Vnx(Oxv)
return true
endfunction
function VZo takes nothing returns boolean
set Oov=Vnx(Orv)
return true
endfunction
function V_o takes nothing returns boolean
set Oiv=Vnx(Oav)
return true
endfunction
function V0o takes nothing returns boolean
set Onv=Vnx(OVv)
return true
endfunction
function V1o takes nothing returns boolean
set OEv=Vnx(OXv)
return true
endfunction
function V2o takes nothing returns boolean
set OOv=Vnx(ORv)
return true
endfunction
function V3o takes nothing returns boolean
set OIv=Vnx(OAv)
return true
endfunction
function V4o takes nothing returns boolean
set ONv=Vnx(Obv)
return true
endfunction
function V5o takes nothing returns boolean
set OBv=Vnx(Ocv)
return true
endfunction
function V6o takes nothing returns boolean
set OCv=Vnx(Odv)
return true
endfunction
function V7o takes nothing returns boolean
set ODv=Vnx(Ofv)
return true
endfunction
function V8o takes nothing returns boolean
set OFv=Vnx(Ogv)
return true
endfunction
function V9o takes nothing returns boolean
set OGv=Vnx(Ohv)
return true
endfunction
function Evo takes nothing returns boolean
set OHv=lQx(Ojv+" (dummyBuff)")
call lux(OHv,"Abilities\\Spells\\Human\\slow\\slowtarget.mdl","origin",ri)
return true
endfunction
function Eeo takes nothing returns boolean
call VRx(Ma,(function Evo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Stamina\\Exhaustion\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function Exo takes nothing returns boolean
set OJv=Vnx(Ojv)
return true
endfunction
function Eoo takes nothing returns boolean
return true
endfunction
function Ero takes nothing returns boolean
call u6x(function Eoo,"FolderUnit_FolderStamina_StructExhaustion_Buff_Init")
return true
endfunction
function Eio takes nothing returns boolean
set Okv=Vnx(OKv)
return true
endfunction
function Eao takes nothing returns boolean
set Olv=Vnx(OLv)
return true
endfunction
function Eno takes nothing returns boolean
set Omv=Vnx(OMv)
return true
endfunction
function EVo takes nothing returns boolean
set Opv=Vnx(OPv)
return true
endfunction
function EEo takes nothing returns boolean
set Oqv=Vnx(OQv)
return true
endfunction
function EXo takes nothing returns boolean
set Osv=Vnx(OSv)
return true
endfunction
function EOo takes nothing returns boolean
return true
endfunction
function ERo takes nothing returns boolean
set Otv=Vnx(OTv)
return true
endfunction
function EIo takes nothing returns boolean
set Ouv=lQx(OUv+" (dummyBuff)")
return true
endfunction
function EAo takes nothing returns boolean
call VRx(Ma,(function EIo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\TimedLife\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function ENo takes nothing returns boolean
set Owv=Vnx(OUv)
return true
endfunction
function Ebo takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer rkx=oqx
call Ayx(rkx,Ouv)
call Cxx(rkx)
endfunction
function EBo takes nothing returns boolean
local integer rdx=(bv)
local real ilx=gf
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
local integer ibx=inx()
set OWv[oqx]=ibx
set ge[(ibx)]=(oqx)
call UnitApplyTimedLife(C[rkx],'RTLF',ilx+.01)
call icx(ibx,ilx,false,function Ebo)
return true
endfunction
function Eco takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
local integer ibx=OWv[oqx]
call ijx(ibx)
return true
endfunction
function ECo takes nothing returns boolean
call l9x(Ouv,XBx("FolderUnit_StructTimedLife_Buff_Init: call FolderUnit_StructTimedLife.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructTimedLife.Event_BuffGain))",Bd,pI,function EBo))
call l9x(Ouv,XBx("FolderUnit_StructTimedLife_Buff_Init: call FolderUnit_StructTimedLife.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructTimedLife.Event_BuffLose))",Jc,pI,function Eco))
return true
endfunction
function Edo takes nothing returns boolean
call u6x(function ECo,"FolderUnit_StructTimedLife_Buff_Init")
return true
endfunction
function EDo takes nothing returns boolean
call LZx('ATra',false)
return true
endfunction
function Efo takes nothing returns boolean
set Oyv=lQx(OYv+" (dummyBuff)")
return true
endfunction
function EFo takes nothing returns boolean
call LZx('Aloa',false)
return true
endfunction
function Ego takes nothing returns boolean
call VRx(qa,(function EDo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Transport\\obj_cargoSpell_wc3spell.j"))
call VRx(Ma,(function Efo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Transport\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function EFo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Transport\\obj_loadInSpell_wc3spell.j"))
return true
endfunction
function EGo takes nothing returns boolean
set Ozv=Vnx(OYv)
return true
endfunction
function Eho takes integer oqx returns nothing
local integer rkx=oqx
local integer rdx=rEx(0)
local integer EHo
local integer olx
local integer rIx
local integer rlx
set Vv[(rdx)]=(oqx)
set EHo=rEx((A[(rkx)]))
set Vv[(EHo)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((O1v))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((O1v))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set rlx=rOx(rkx,O1v,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,O1v,rIx,rlx),EHo)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call rHx(((EHo)))
endfunction
function Ejo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer EJo=(mc[(rdx)])
local integer oqx=rkx
local integer HOx=w
local boolean Eko=true
local integer d5x
local integer EKo
if(EJo==w)then
set HOx=mcx('qTra',DPx(rkx),DQx(rkx),.0,.0)
call UnitAddAbility(zj[((HOx))],('ATra'))
call UnitAddAbility(zj[((HOx))],('Aloa'))
call mIx(HOx,(ze[(rkx)]))
if not(IssueTargetOrderById(zj[((HOx))],Pb[(P3)],C[((rkx))]))then
call oYx("FolderUnit_StructTransport_Event_BuffGain","call DebugEx(FolderUnit_StructTransport.NAME + \": cannot load in \" + parent.GetName())",OYv+": cannot load in "+(GetUnitName(C[(rkx)])))
set Eko=false
endif
else
set d5x=(ze[(rkx)])
set EKo=(ze[(EJo)])
call rQx(EJo,'ATra')
call rQx(EJo,'Aloa')
call aNx(EJo,d5x)
call Qzx(d5x,'Aloa',true)
if not Lvx(EJo,P3,rkx)then
call oYx("FolderUnit_StructTransport_Event_BuffGain","call DebugEx(FolderUnit_StructTransport.NAME + \": cannot load in \" + parent.GetName() + \" (transporter=\"+transporter.GetName()+\")\")",OYv+": cannot load in "+(GetUnitName(C[(rkx)]))+" (transporter="+(GetUnitName(C[(EJo)]))+")")
set Eko=false
endif
call Qzx(d5x,'Aloa',false)
call aNx(EJo,EKo)
endif
if Eko then
set OZv[oqx]=HOx
set O_v[oqx]=EJo
set O0v[(oqx)]=(true)
else
call Ayx(rkx,Oyv)
endif
call Eho(oqx)
return true
endfunction
function Elo takes integer oqx,real x,real y returns nothing
call SetUnitPosition(C[(oqx)],x,y)
endfunction
function ELo takes integer oqx returns nothing
local integer rkx=oqx
local integer rdx=rEx(0)
local integer EHo
local integer olx
local integer rIx
local integer rlx
set Vv[(rdx)]=(oqx)
set EHo=rEx((A[(rkx)]))
set Vv[(EHo)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((O2v))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((O2v))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set rlx=rOx(rkx,O2v,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,O2v,rIx,rlx),EHo)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call rHx(((EHo)))
endfunction
function Emo takes integer oqx,integer ocx,boolean isx returns nothing
if iVx(ocx)then
call SelectUnit(C[oqx],isx)
endif
endfunction
function EMo takes integer oqx returns nothing
local integer rkx=oqx
local integer olx=CXx(rkx,db)
local integer ocx
loop
exitwhen(olx<q)
set ocx=COx(rkx,db,olx)
if not(IsUnitSelected(C[(rkx)],vx[(ocx)]))then
call Emo(rkx,ocx,true)
endif
set olx=olx-1
endloop
endfunction
function Epo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
local integer EJo
local integer HOx
set O0v[(oqx)]=(false)
set EJo=O_v[oqx]
if(EJo==w)then
set HOx=OZv[oqx]
call KillUnit(zj[(HOx)])
call MCx(HOx)
else
call Elo(rkx,DPx(EJo),DQx(EJo))
endif
if IsUnitHidden(C[rkx])then
call ShowUnit(C[rkx],true)
endif
call ELo(oqx)
call EMo(rkx)
return true
endfunction
function EPo takes nothing returns boolean
call l9x(Oyv,XBx("FolderUnit_StructTransport_Buff_Init: call FolderUnit_StructTransport.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructTransport.Event_BuffGain))",Bd,pI,function Ejo))
call l9x(Oyv,XBx("FolderUnit_StructTransport_Buff_Init: call FolderUnit_StructTransport.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructTransport.Event_BuffLose))",Jc,pI,function Epo))
return true
endfunction
function Eqo takes nothing returns boolean
call u6x(function EPo,"FolderUnit_StructTransport_Buff_Init")
return true
endfunction
function EQo takes nothing returns boolean
set O3v=Vnx(O4v)
return true
endfunction
function Eso takes nothing returns boolean
set O5v=Vnx(O6v)
return true
endfunction
function ESo takes nothing returns boolean
set O7v=Vnx(O8v)
return true
endfunction
function Eto takes nothing returns boolean
set O9v=Vnx(Lk)
return true
endfunction
function ETo takes nothing returns boolean
set Rvv=Vnx(mk)
return true
endfunction
function Euo takes nothing returns boolean
set Rev=Vnx(Rxv)
return true
endfunction
function EUo takes nothing returns boolean
set Rov=Vbx("ONud")
return true
endfunction
function Ewo takes nothing returns boolean
call VRx(Ha,(function EUo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Position\\obj_nudgeBolt_wc3bolt.j"))
return true
endfunction
function EWo takes nothing returns boolean
set Rrv=Vnx(Riv)
return true
endfunction
function Eyo takes nothing returns boolean
set Rav[1]="Unit_page\\Unit_struct\\Selection\\Circle\\circleRed.mdx"
set Rav[2]="Unit_page\\Unit_struct\\Selection\\Circle\\circleBlue.mdx"
set Rav[3]="Unit_page\\Unit_struct\\Selection\\Circle\\circleTeal.mdx"
set Rav[4]="Unit_page\\Unit_struct\\Selection\\Circle\\circlePurple.mdx"
set Rav[5]="Unit_page\\Unit_struct\\Selection\\Circle\\circleYellow.mdx"
set Rav[6]="Unit_page\\Unit_struct\\Selection\\Circle\\circleOrange.mdx"
set Rav[7]="Unit_page\\Unit_struct\\Selection\\Circle\\circleGreen.mdx"
set Rav[8]="Unit_page\\Unit_struct\\Selection\\Circle\\circlePink.mdx"
set Rav[9]="Unit_page\\Unit_struct\\Selection\\Circle\\circleGray.mdx"
set Rav[$A]="Unit_page\\Unit_struct\\Selection\\Circle\\circleLightblue.mdx"
set Rav[$B]="Unit_page\\Unit_struct\\Selection\\Circle\\circleDarkgreen.mdx"
set Rav[$C]="Unit_page\\Unit_struct\\Selection\\Circle\\circleBrown.mdx"
return true
endfunction
function EYo takes nothing returns boolean
call VRx(ea,(function Eyo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Selection\\Circle\\obj_this_wc3obj.j"))
return true
endfunction
function Ezo takes nothing returns boolean
set Rnv=Vnx(RVv)
return true
endfunction
function EZo takes nothing returns boolean
set REv=lQx(RXv+" (dummyBuff)")
return true
endfunction
function E_o takes nothing returns boolean
call VRx(Ma,(function EZo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Selection\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function E0o takes nothing returns boolean
set ROv=Vnx(RXv)
return true
endfunction
function E1o takes nothing returns boolean
set RRv=Vnx(RIv)
return true
endfunction
function E2o takes nothing returns boolean
set RAv=Vnx(RNv)
return true
endfunction
function E3o takes nothing returns boolean
set Rbv=Vnx(RBv)
return true
endfunction
function E4o takes nothing returns boolean
set Rcv[1]='SS00'
call LZx('SS00',false)
set Rcv[2]='SS01'
call LZx('SS01',false)
set Rcv[3]='SS02'
call LZx('SS02',false)
set Rcv[4]='SS03'
call LZx('SS03',false)
set Rcv[5]='SS04'
call LZx('SS04',false)
set Rcv[6]='SS05'
call LZx('SS05',false)
set Rcv[7]='SS06'
call LZx('SS06',false)
set Rcv[8]='SS07'
call LZx('SS07',false)
set Rcv[9]='SS08'
call LZx('SS08',false)
set Rcv[$A]='SS09'
call LZx('SS09',false)
set Rcv[$B]='SS0A'
call LZx('SS0A',false)
set Rcv[$C]='SS0B'
call LZx('SS0B',false)
set Rcv[$D]='SS0C'
call LZx('SS0C',false)
set Rcv[$E]='SS0D'
call LZx('SS0D',false)
set Rcv[$F]='SS0E'
call LZx('SS0E',false)
set Rcv[16]='SS0F'
call LZx('SS0F',false)
set Rcv[17]='SS0G'
call LZx('SS0G',false)
set Rcv[18]='SS0H'
call LZx('SS0H',false)
set Rcv[19]='SS0I'
call LZx('SS0I',false)
set Rcv[20]='SS0J'
call LZx('SS0J',false)
set Rcv[21]='SS0K'
call LZx('SS0K',false)
set Rcv[22]='SS0L'
call LZx('SS0L',false)
set Rcv[23]='SS0M'
call LZx('SS0M',false)
set Rcv[24]='SS0N'
call LZx('SS0N',false)
set Rcv[25]='SS0O'
call LZx('SS0O',false)
set Rcv[26]='SS0P'
call LZx('SS0P',false)
set Rcv[27]='SS0Q'
call LZx('SS0Q',false)
set Rcv[28]='SS0R'
call LZx('SS0R',false)
set Rcv[29]='SS0S'
call LZx('SS0S',false)
set Rcv[30]='SS0T'
call LZx('SS0T',false)
set Rcv[31]='SS0U'
call LZx('SS0U',false)
set Rcv[32]='SS0V'
call LZx('SS0V',false)
set Rcv[33]='SS0W'
call LZx('SS0W',false)
set Rcv[34]='SS0X'
call LZx('SS0X',false)
set Rcv[35]='SS0Y'
call LZx('SS0Y',false)
set Rcv[36]='SS0Z'
call LZx('SS0Z',false)
set Rcv[37]='SS10'
call LZx('SS10',false)
set Rcv[38]='SS11'
call LZx('SS11',false)
set Rcv[39]='SS12'
call LZx('SS12',false)
set Rcv[40]='SS13'
call LZx('SS13',false)
set Rcv[41]='SS14'
call LZx('SS14',false)
set Rcv[42]='SS15'
call LZx('SS15',false)
set Rcv[43]='SS16'
call LZx('SS16',false)
set Rcv[44]='SS17'
call LZx('SS17',false)
set Rcv[45]='SS18'
call LZx('SS18',false)
set Rcv[46]='SS19'
call LZx('SS19',false)
set Rcv[47]='SS1A'
call LZx('SS1A',false)
set Rcv[48]='SS1B'
call LZx('SS1B',false)
set Rcv[49]='SS1C'
call LZx('SS1C',false)
set Rcv[50]='SS1D'
call LZx('SS1D',false)
set Rcv[51]='SS1E'
call LZx('SS1E',false)
set Rcv[52]='SS1F'
call LZx('SS1F',false)
set Rcv[53]='SS1G'
call LZx('SS1G',false)
set Rcv[54]='SS1H'
call LZx('SS1H',false)
set Rcv[55]='SS1I'
call LZx('SS1I',false)
set Rcv[56]='SS1J'
call LZx('SS1J',false)
set Rcv[57]='SS1K'
call LZx('SS1K',false)
set Rcv[58]='SS1L'
call LZx('SS1L',false)
set Rcv[59]='SS1M'
call LZx('SS1M',false)
set Rcv[60]='SS1N'
call LZx('SS1N',false)
set Rcv[61]='SS1O'
call LZx('SS1O',false)
set Rcv[62]='SS1P'
call LZx('SS1P',false)
set Rcv[63]='SS1Q'
call LZx('SS1Q',false)
set Rcv[64]='SS1R'
call LZx('SS1R',false)
set Rcv[65]='SS1S'
call LZx('SS1S',false)
set Rcv[66]='SS1T'
call LZx('SS1T',false)
set Rcv[67]='SS1U'
call LZx('SS1U',false)
set Rcv[68]='SS1V'
call LZx('SS1V',false)
set Rcv[69]='SS1W'
call LZx('SS1W',false)
set Rcv[70]='SS1X'
call LZx('SS1X',false)
set Rcv[71]='SS1Y'
call LZx('SS1Y',false)
set Rcv[72]='SS1Z'
call LZx('SS1Z',false)
set Rcv[73]='SS20'
call LZx('SS20',false)
set Rcv[74]='SS21'
call LZx('SS21',false)
set Rcv[75]='SS22'
call LZx('SS22',false)
set Rcv[76]='SS23'
call LZx('SS23',false)
set Rcv[77]='SS24'
call LZx('SS24',false)
set Rcv[78]='SS25'
call LZx('SS25',false)
set Rcv[79]='SS26'
call LZx('SS26',false)
set Rcv[80]='SS27'
call LZx('SS27',false)
set Rcv[81]='SS28'
call LZx('SS28',false)
set Rcv[82]='SS29'
call LZx('SS29',false)
set Rcv[83]='SS2A'
call LZx('SS2A',false)
set Rcv[84]='SS2B'
call LZx('SS2B',false)
set Rcv[85]='SS2C'
call LZx('SS2C',false)
set Rcv[86]='SS2D'
call LZx('SS2D',false)
set Rcv[87]='SS2E'
call LZx('SS2E',false)
set Rcv[88]='SS2F'
call LZx('SS2F',false)
set Rcv[89]='SS2G'
call LZx('SS2G',false)
set Rcv[90]='SS2H'
call LZx('SS2H',false)
set Rcv[91]='SS2I'
call LZx('SS2I',false)
set Rcv[92]='SS2J'
call LZx('SS2J',false)
set Rcv[93]='SS2K'
call LZx('SS2K',false)
set Rcv[94]='SS2L'
call LZx('SS2L',false)
set Rcv[95]='SS2M'
call LZx('SS2M',false)
set Rcv[96]='SS2N'
call LZx('SS2N',false)
set Rcv[97]='SS2O'
call LZx('SS2O',false)
set Rcv[98]='SS2P'
call LZx('SS2P',false)
set Rcv[99]='SS2Q'
call LZx('SS2Q',false)
set Rcv['d']='SS2R'
call LZx('SS2R',false)
set Rcv['e']='SS2S'
call LZx('SS2S',false)
set Rcv['f']='SS2T'
call LZx('SS2T',false)
set Rcv['g']='SS2U'
call LZx('SS2U',false)
set Rcv['h']='SS2V'
call LZx('SS2V',false)
set Rcv['i']='SS2W'
call LZx('SS2W',false)
set Rcv['j']='SS2X'
call LZx('SS2X',false)
set Rcv['k']='SS2Y'
call LZx('SS2Y',false)
set Rcv['l']='SS2Z'
call LZx('SS2Z',false)
set Rcv['m']='SS30'
call LZx('SS30',false)
set Rcv['n']='SS31'
call LZx('SS31',false)
set Rcv['o']='SS32'
call LZx('SS32',false)
set Rcv['p']='SS33'
call LZx('SS33',false)
set Rcv['q']='SS34'
call LZx('SS34',false)
set Rcv['r']='SS35'
call LZx('SS35',false)
set Rcv['s']='SS36'
call LZx('SS36',false)
set Rcv['t']='SS37'
call LZx('SS37',false)
set Rcv['u']='SS38'
call LZx('SS38',false)
set Rcv['v']='SS39'
call LZx('SS39',false)
set Rcv['w']='SS3A'
call LZx('SS3A',false)
set Rcv['x']='SS3B'
call LZx('SS3B',false)
set Rcv['y']='SS3C'
call LZx('SS3C',false)
set Rcv['z']='SS3D'
call LZx('SS3D',false)
set Rcv['{']='SS3E'
call LZx('SS3E',false)
set Rcv['|']='SS3F'
call LZx('SS3F',false)
set Rcv['}']='SS3G'
call LZx('SS3G',false)
set Rcv[$7E]='SS3H'
call LZx('SS3H',false)
set Rcv[$7F]='SS3I'
call LZx('SS3I',false)
set Rcv[$80]='SS3J'
call LZx('SS3J',false)
set Rcv[$81]='SS3K'
call LZx('SS3K',false)
set Rcv[$82]='SS3L'
call LZx('SS3L',false)
set Rcv[$83]='SS3M'
call LZx('SS3M',false)
set Rcv[$84]='SS3N'
call LZx('SS3N',false)
set Rcv[$85]='SS3O'
call LZx('SS3O',false)
set Rcv[$86]='SS3P'
call LZx('SS3P',false)
set Rcv[$87]='SS3Q'
call LZx('SS3Q',false)
set Rcv[$88]='SS3R'
call LZx('SS3R',false)
set Rcv[$89]='SS3S'
call LZx('SS3S',false)
set Rcv[$8A]='SS3T'
call LZx('SS3T',false)
set Rcv[$8B]='SS3U'
call LZx('SS3U',false)
set Rcv[$8C]='SS3V'
call LZx('SS3V',false)
set Rcv[$8D]='SS3W'
call LZx('SS3W',false)
set Rcv[$8E]='SS3X'
call LZx('SS3X',false)
set Rcv[$8F]='SS3Y'
call LZx('SS3Y',false)
set Rcv[$90]='SS3Z'
call LZx('SS3Z',false)
set Rcv[$91]='SS40'
call LZx('SS40',false)
set Rcv[$92]='SS41'
call LZx('SS41',false)
set Rcv[$93]='SS42'
call LZx('SS42',false)
set Rcv[$94]='SS43'
call LZx('SS43',false)
set Rcv[$95]='SS44'
call LZx('SS44',false)
set Rcv[$96]='SS45'
call LZx('SS45',false)
set Rcv[$97]='SS46'
call LZx('SS46',false)
set Rcv[$98]='SS47'
call LZx('SS47',false)
set Rcv[$99]='SS48'
call LZx('SS48',false)
set Rcv[$9A]='SS49'
call LZx('SS49',false)
set Rcv[$9B]='SS4A'
call LZx('SS4A',false)
set Rcv[$9C]='SS4B'
call LZx('SS4B',false)
set Rcv[$9D]='SS4C'
call LZx('SS4C',false)
set Rcv[$9E]='SS4D'
call LZx('SS4D',false)
set Rcv[$9F]='SS4E'
call LZx('SS4E',false)
set Rcv[$A0]='SS4F'
call LZx('SS4F',false)
set Rcv[$A1]='SS4G'
call LZx('SS4G',false)
set Rcv[$A2]='SS4H'
call LZx('SS4H',false)
set Rcv[$A3]='SS4I'
call LZx('SS4I',false)
set Rcv[$A4]='SS4J'
call LZx('SS4J',false)
set Rcv[$A5]='SS4K'
call LZx('SS4K',false)
set Rcv[$A6]='SS4L'
call LZx('SS4L',false)
set Rcv[$A7]='SS4M'
call LZx('SS4M',false)
set Rcv[$A8]='SS4N'
call LZx('SS4N',false)
set Rcv[$A9]='SS4O'
call LZx('SS4O',false)
set Rcv[$AA]='SS4P'
call LZx('SS4P',false)
set Rcv[$AB]='SS4Q'
call LZx('SS4Q',false)
set Rcv[$AC]='SS4R'
call LZx('SS4R',false)
set Rcv[$AD]='SS4S'
call LZx('SS4S',false)
set Rcv[$AE]='SS4T'
call LZx('SS4T',false)
set Rcv[$AF]='SS4U'
call LZx('SS4U',false)
set Rcv[$B0]='SS4V'
call LZx('SS4V',false)
set Rcv[$B1]='SS4W'
call LZx('SS4W',false)
set Rcv[$B2]='SS4X'
call LZx('SS4X',false)
set Rcv[$B3]='SS4Y'
call LZx('SS4Y',false)
set Rcv[$B4]='SS4Z'
call LZx('SS4Z',false)
set Rcv[$B5]='SS50'
call LZx('SS50',false)
set Rcv[$B6]='SS51'
call LZx('SS51',false)
set Rcv[$B7]='SS52'
call LZx('SS52',false)
set Rcv[$B8]='SS53'
call LZx('SS53',false)
set Rcv[$B9]='SS54'
call LZx('SS54',false)
set Rcv[$BA]='SS55'
call LZx('SS55',false)
set Rcv[$BB]='SS56'
call LZx('SS56',false)
set Rcv[$BC]='SS57'
call LZx('SS57',false)
set Rcv[$BD]='SS58'
call LZx('SS58',false)
set Rcv[$BE]='SS59'
call LZx('SS59',false)
set Rcv[$BF]='SS5A'
call LZx('SS5A',false)
set Rcv[$C0]='SS5B'
call LZx('SS5B',false)
set Rcv[$C1]='SS5C'
call LZx('SS5C',false)
set Rcv[$C2]='SS5D'
call LZx('SS5D',false)
set Rcv[$C3]='SS5E'
call LZx('SS5E',false)
set Rcv[$C4]='SS5F'
call LZx('SS5F',false)
set Rcv[$C5]='SS5G'
call LZx('SS5G',false)
set Rcv[$C6]='SS5H'
call LZx('SS5H',false)
set Rcv[$C7]='SS5I'
call LZx('SS5I',false)
set Rcv[$C8]='SS5J'
call LZx('SS5J',false)
set Rcv[$C9]='SS5K'
call LZx('SS5K',false)
set Rcv[$CA]='SS5L'
call LZx('SS5L',false)
set Rcv[$CB]='SS5M'
call LZx('SS5M',false)
set Rcv[$CC]='SS5N'
call LZx('SS5N',false)
set Rcv[$CD]='SS5O'
call LZx('SS5O',false)
set Rcv[$CE]='SS5P'
call LZx('SS5P',false)
set Rcv[$CF]='SS5Q'
call LZx('SS5Q',false)
set Rcv[$D0]='SS5R'
call LZx('SS5R',false)
set Rcv[$D1]='SS5S'
call LZx('SS5S',false)
set Rcv[$D2]='SS5T'
call LZx('SS5T',false)
set Rcv[$D3]='SS5U'
call LZx('SS5U',false)
set Rcv[$D4]='SS5V'
call LZx('SS5V',false)
set Rcv[$D5]='SS5W'
call LZx('SS5W',false)
set Rcv[$D6]='SS5X'
call LZx('SS5X',false)
set Rcv[$D7]='SS5Y'
call LZx('SS5Y',false)
set Rcv[$D8]='SS5Z'
call LZx('SS5Z',false)
set Rcv[$D9]='SS60'
call LZx('SS60',false)
set Rcv[$DA]='SS61'
call LZx('SS61',false)
set Rcv[$DB]='SS62'
call LZx('SS62',false)
set Rcv[$DC]='SS63'
call LZx('SS63',false)
set Rcv[$DD]='SS64'
call LZx('SS64',false)
set Rcv[$DE]='SS65'
call LZx('SS65',false)
set Rcv[$DF]='SS66'
call LZx('SS66',false)
set Rcv[$E0]='SS67'
call LZx('SS67',false)
set Rcv[$E1]='SS68'
call LZx('SS68',false)
set Rcv[$E2]='SS69'
call LZx('SS69',false)
set Rcv[$E3]='SS6A'
call LZx('SS6A',false)
set Rcv[$E4]='SS6B'
call LZx('SS6B',false)
set Rcv[$E5]='SS6C'
call LZx('SS6C',false)
set Rcv[$E6]='SS6D'
call LZx('SS6D',false)
set Rcv[$E7]='SS6E'
call LZx('SS6E',false)
set Rcv[$E8]='SS6F'
call LZx('SS6F',false)
set Rcv[$E9]='SS6G'
call LZx('SS6G',false)
set Rcv[$EA]='SS6H'
call LZx('SS6H',false)
set Rcv[$EB]='SS6I'
call LZx('SS6I',false)
set Rcv[$EC]='SS6J'
call LZx('SS6J',false)
set Rcv[$ED]='SS6K'
call LZx('SS6K',false)
set Rcv[$EE]='SS6L'
call LZx('SS6L',false)
set Rcv[$EF]='SS6M'
call LZx('SS6M',false)
set Rcv[$F0]='SS6N'
call LZx('SS6N',false)
set Rcv[$F1]='SS6O'
call LZx('SS6O',false)
set Rcv[$F2]='SS6P'
call LZx('SS6P',false)
set Rcv[$F3]='SS6Q'
call LZx('SS6Q',false)
set Rcv[$F4]='SS6R'
call LZx('SS6R',false)
set Rcv[$F5]='SS6S'
call LZx('SS6S',false)
set Rcv[$F6]='SS6T'
call LZx('SS6T',false)
set Rcv[$F7]='SS6U'
call LZx('SS6U',false)
set Rcv[$F8]='SS6V'
call LZx('SS6V',false)
set Rcv[$F9]='SS6W'
call LZx('SS6W',false)
set Rcv[$FA]='SS6X'
call LZx('SS6X',false)
set Rcv[$FB]='SS6Y'
call LZx('SS6Y',false)
set Rcv[$FC]='SS6Z'
call LZx('SS6Z',false)
set Rcv[$FD]='SS70'
call LZx('SS70',false)
set Rcv[$FE]='SS71'
call LZx('SS71',false)
set Rcv[$FF]='SS72'
call LZx('SS72',false)
set Rcv[256]='SS73'
call LZx('SS73',false)
set RCv[1]='TS00'
call LZx('TS00',false)
set RCv[2]='TS01'
call LZx('TS01',false)
set RCv[3]='TS02'
call LZx('TS02',false)
set RCv[4]='TS03'
call LZx('TS03',false)
set RCv[5]='TS04'
call LZx('TS04',false)
set RCv[6]='TS05'
call LZx('TS05',false)
set RCv[7]='TS06'
call LZx('TS06',false)
set RCv[8]='TS07'
call LZx('TS07',false)
set RCv[9]='TS08'
call LZx('TS08',false)
set RCv[$A]='TS09'
call LZx('TS09',false)
set RCv[$B]='TS0A'
call LZx('TS0A',false)
set RCv[$C]='TS0B'
call LZx('TS0B',false)
set RCv[$D]='TS0C'
call LZx('TS0C',false)
set RCv[$E]='TS0D'
call LZx('TS0D',false)
set RCv[$F]='TS0E'
call LZx('TS0E',false)
set RCv[16]='TS0F'
call LZx('TS0F',false)
set RCv[17]='TS0G'
call LZx('TS0G',false)
set RCv[18]='TS0H'
call LZx('TS0H',false)
set RCv[19]='TS0I'
call LZx('TS0I',false)
set RCv[20]='TS0J'
call LZx('TS0J',false)
set RCv[21]='TS0K'
call LZx('TS0K',false)
set RCv[22]='TS0L'
call LZx('TS0L',false)
set RCv[23]='TS0M'
call LZx('TS0M',false)
set RCv[24]='TS0N'
call LZx('TS0N',false)
set RCv[25]='TS0O'
call LZx('TS0O',false)
set RCv[26]='TS0P'
call LZx('TS0P',false)
set RCv[27]='TS0Q'
call LZx('TS0Q',false)
set RCv[28]='TS0R'
call LZx('TS0R',false)
set RCv[29]='TS0S'
call LZx('TS0S',false)
set RCv[30]='TS0T'
call LZx('TS0T',false)
set RCv[31]='TS0U'
call LZx('TS0U',false)
set RCv[32]='TS0V'
call LZx('TS0V',false)
set RCv[33]='TS0W'
call LZx('TS0W',false)
set RCv[34]='TS0X'
call LZx('TS0X',false)
set RCv[35]='TS0Y'
call LZx('TS0Y',false)
set RCv[36]='TS0Z'
call LZx('TS0Z',false)
set RCv[37]='TS10'
call LZx('TS10',false)
set RCv[38]='TS11'
call LZx('TS11',false)
set RCv[39]='TS12'
call LZx('TS12',false)
set RCv[40]='TS13'
call LZx('TS13',false)
set RCv[41]='TS14'
call LZx('TS14',false)
set RCv[42]='TS15'
call LZx('TS15',false)
set RCv[43]='TS16'
call LZx('TS16',false)
set RCv[44]='TS17'
call LZx('TS17',false)
set RCv[45]='TS18'
call LZx('TS18',false)
set RCv[46]='TS19'
call LZx('TS19',false)
set RCv[47]='TS1A'
call LZx('TS1A',false)
set RCv[48]='TS1B'
call LZx('TS1B',false)
set RCv[49]='TS1C'
call LZx('TS1C',false)
set RCv[50]='TS1D'
call LZx('TS1D',false)
set RCv[51]='TS1E'
call LZx('TS1E',false)
set RCv[52]='TS1F'
call LZx('TS1F',false)
set RCv[53]='TS1G'
call LZx('TS1G',false)
set RCv[54]='TS1H'
call LZx('TS1H',false)
set RCv[55]='TS1I'
call LZx('TS1I',false)
set RCv[56]='TS1J'
call LZx('TS1J',false)
set RCv[57]='TS1K'
call LZx('TS1K',false)
set RCv[58]='TS1L'
call LZx('TS1L',false)
set RCv[59]='TS1M'
call LZx('TS1M',false)
set RCv[60]='TS1N'
call LZx('TS1N',false)
set RCv[61]='TS1O'
call LZx('TS1O',false)
set RCv[62]='TS1P'
call LZx('TS1P',false)
set RCv[63]='TS1Q'
call LZx('TS1Q',false)
set RCv[64]='TS1R'
call LZx('TS1R',false)
set RCv[65]='TS1S'
call LZx('TS1S',false)
set RCv[66]='TS1T'
call LZx('TS1T',false)
set RCv[67]='TS1U'
call LZx('TS1U',false)
set RCv[68]='TS1V'
call LZx('TS1V',false)
set RCv[69]='TS1W'
call LZx('TS1W',false)
set RCv[70]='TS1X'
call LZx('TS1X',false)
set RCv[71]='TS1Y'
call LZx('TS1Y',false)
set RCv[72]='TS1Z'
call LZx('TS1Z',false)
set RCv[73]='TS20'
call LZx('TS20',false)
set RCv[74]='TS21'
call LZx('TS21',false)
set RCv[75]='TS22'
call LZx('TS22',false)
set RCv[76]='TS23'
call LZx('TS23',false)
set RCv[77]='TS24'
call LZx('TS24',false)
set RCv[78]='TS25'
call LZx('TS25',false)
set RCv[79]='TS26'
call LZx('TS26',false)
set RCv[80]='TS27'
call LZx('TS27',false)
set RCv[81]='TS28'
call LZx('TS28',false)
set RCv[82]='TS29'
call LZx('TS29',false)
set RCv[83]='TS2A'
call LZx('TS2A',false)
set RCv[84]='TS2B'
call LZx('TS2B',false)
set RCv[85]='TS2C'
call LZx('TS2C',false)
set RCv[86]='TS2D'
call LZx('TS2D',false)
set RCv[87]='TS2E'
call LZx('TS2E',false)
set RCv[88]='TS2F'
call LZx('TS2F',false)
set RCv[89]='TS2G'
call LZx('TS2G',false)
set RCv[90]='TS2H'
call LZx('TS2H',false)
set RCv[91]='TS2I'
call LZx('TS2I',false)
set RCv[92]='TS2J'
call LZx('TS2J',false)
set RCv[93]='TS2K'
call LZx('TS2K',false)
set RCv[94]='TS2L'
call LZx('TS2L',false)
set RCv[95]='TS2M'
call LZx('TS2M',false)
set RCv[96]='TS2N'
call LZx('TS2N',false)
set RCv[97]='TS2O'
call LZx('TS2O',false)
set RCv[98]='TS2P'
call LZx('TS2P',false)
set RCv[99]='TS2Q'
call LZx('TS2Q',false)
set RCv['d']='TS2R'
call LZx('TS2R',false)
set RCv['e']='TS2S'
call LZx('TS2S',false)
set RCv['f']='TS2T'
call LZx('TS2T',false)
set RCv['g']='TS2U'
call LZx('TS2U',false)
set RCv['h']='TS2V'
call LZx('TS2V',false)
set RCv['i']='TS2W'
call LZx('TS2W',false)
set RCv['j']='TS2X'
call LZx('TS2X',false)
set RCv['k']='TS2Y'
call LZx('TS2Y',false)
set RCv['l']='TS2Z'
call LZx('TS2Z',false)
set RCv['m']='TS30'
call LZx('TS30',false)
set RCv['n']='TS31'
call LZx('TS31',false)
set RCv['o']='TS32'
call LZx('TS32',false)
set RCv['p']='TS33'
call LZx('TS33',false)
set RCv['q']='TS34'
call LZx('TS34',false)
set RCv['r']='TS35'
call LZx('TS35',false)
set RCv['s']='TS36'
call LZx('TS36',false)
set RCv['t']='TS37'
call LZx('TS37',false)
set RCv['u']='TS38'
call LZx('TS38',false)
set RCv['v']='TS39'
call LZx('TS39',false)
set RCv['w']='TS3A'
call LZx('TS3A',false)
set RCv['x']='TS3B'
call LZx('TS3B',false)
set RCv['y']='TS3C'
call LZx('TS3C',false)
set RCv['z']='TS3D'
call LZx('TS3D',false)
set RCv['{']='TS3E'
call LZx('TS3E',false)
set RCv['|']='TS3F'
call LZx('TS3F',false)
set RCv['}']='TS3G'
call LZx('TS3G',false)
set RCv[$7E]='TS3H'
call LZx('TS3H',false)
set RCv[$7F]='TS3I'
call LZx('TS3I',false)
set RCv[$80]='TS3J'
call LZx('TS3J',false)
set RCv[$81]='TS3K'
call LZx('TS3K',false)
set RCv[$82]='TS3L'
call LZx('TS3L',false)
set RCv[$83]='TS3M'
call LZx('TS3M',false)
set RCv[$84]='TS3N'
call LZx('TS3N',false)
set RCv[$85]='TS3O'
call LZx('TS3O',false)
set RCv[$86]='TS3P'
call LZx('TS3P',false)
set RCv[$87]='TS3Q'
call LZx('TS3Q',false)
set RCv[$88]='TS3R'
call LZx('TS3R',false)
set RCv[$89]='TS3S'
call LZx('TS3S',false)
set RCv[$8A]='TS3T'
call LZx('TS3T',false)
set RCv[$8B]='TS3U'
call LZx('TS3U',false)
set RCv[$8C]='TS3V'
call LZx('TS3V',false)
set RCv[$8D]='TS3W'
call LZx('TS3W',false)
set RCv[$8E]='TS3X'
call LZx('TS3X',false)
set RCv[$8F]='TS3Y'
call LZx('TS3Y',false)
set RCv[$90]='TS3Z'
call LZx('TS3Z',false)
set RCv[$91]='TS40'
call LZx('TS40',false)
set RCv[$92]='TS41'
call LZx('TS41',false)
set RCv[$93]='TS42'
call LZx('TS42',false)
set RCv[$94]='TS43'
call LZx('TS43',false)
set RCv[$95]='TS44'
call LZx('TS44',false)
set RCv[$96]='TS45'
call LZx('TS45',false)
set RCv[$97]='TS46'
call LZx('TS46',false)
set RCv[$98]='TS47'
call LZx('TS47',false)
set RCv[$99]='TS48'
call LZx('TS48',false)
set RCv[$9A]='TS49'
call LZx('TS49',false)
set RCv[$9B]='TS4A'
call LZx('TS4A',false)
set RCv[$9C]='TS4B'
call LZx('TS4B',false)
set RCv[$9D]='TS4C'
call LZx('TS4C',false)
set RCv[$9E]='TS4D'
call LZx('TS4D',false)
set RCv[$9F]='TS4E'
call LZx('TS4E',false)
set RCv[$A0]='TS4F'
call LZx('TS4F',false)
set RCv[$A1]='TS4G'
call LZx('TS4G',false)
set RCv[$A2]='TS4H'
call LZx('TS4H',false)
set RCv[$A3]='TS4I'
call LZx('TS4I',false)
set RCv[$A4]='TS4J'
call LZx('TS4J',false)
set RCv[$A5]='TS4K'
call LZx('TS4K',false)
set RCv[$A6]='TS4L'
call LZx('TS4L',false)
set RCv[$A7]='TS4M'
call LZx('TS4M',false)
set RCv[$A8]='TS4N'
call LZx('TS4N',false)
set RCv[$A9]='TS4O'
call LZx('TS4O',false)
set RCv[$AA]='TS4P'
call LZx('TS4P',false)
set RCv[$AB]='TS4Q'
call LZx('TS4Q',false)
set RCv[$AC]='TS4R'
call LZx('TS4R',false)
set RCv[$AD]='TS4S'
call LZx('TS4S',false)
set RCv[$AE]='TS4T'
call LZx('TS4T',false)
set RCv[$AF]='TS4U'
call LZx('TS4U',false)
set RCv[$B0]='TS4V'
call LZx('TS4V',false)
set RCv[$B1]='TS4W'
call LZx('TS4W',false)
set RCv[$B2]='TS4X'
call LZx('TS4X',false)
set RCv[$B3]='TS4Y'
call LZx('TS4Y',false)
set RCv[$B4]='TS4Z'
call LZx('TS4Z',false)
set RCv[$B5]='TS50'
call LZx('TS50',false)
set RCv[$B6]='TS51'
call LZx('TS51',false)
set RCv[$B7]='TS52'
call LZx('TS52',false)
set RCv[$B8]='TS53'
call LZx('TS53',false)
set RCv[$B9]='TS54'
call LZx('TS54',false)
set RCv[$BA]='TS55'
call LZx('TS55',false)
set RCv[$BB]='TS56'
call LZx('TS56',false)
set RCv[$BC]='TS57'
call LZx('TS57',false)
set RCv[$BD]='TS58'
call LZx('TS58',false)
set RCv[$BE]='TS59'
call LZx('TS59',false)
set RCv[$BF]='TS5A'
call LZx('TS5A',false)
set RCv[$C0]='TS5B'
call LZx('TS5B',false)
set RCv[$C1]='TS5C'
call LZx('TS5C',false)
set RCv[$C2]='TS5D'
call LZx('TS5D',false)
set RCv[$C3]='TS5E'
call LZx('TS5E',false)
set RCv[$C4]='TS5F'
call LZx('TS5F',false)
set RCv[$C5]='TS5G'
call LZx('TS5G',false)
set RCv[$C6]='TS5H'
call LZx('TS5H',false)
set RCv[$C7]='TS5I'
call LZx('TS5I',false)
set RCv[$C8]='TS5J'
call LZx('TS5J',false)
set RCv[$C9]='TS5K'
call LZx('TS5K',false)
set RCv[$CA]='TS5L'
call LZx('TS5L',false)
set RCv[$CB]='TS5M'
call LZx('TS5M',false)
set RCv[$CC]='TS5N'
call LZx('TS5N',false)
set RCv[$CD]='TS5O'
call LZx('TS5O',false)
set RCv[$CE]='TS5P'
call LZx('TS5P',false)
set RCv[$CF]='TS5Q'
call LZx('TS5Q',false)
set RCv[$D0]='TS5R'
call LZx('TS5R',false)
set RCv[$D1]='TS5S'
call LZx('TS5S',false)
set RCv[$D2]='TS5T'
call LZx('TS5T',false)
set RCv[$D3]='TS5U'
call LZx('TS5U',false)
set RCv[$D4]='TS5V'
call LZx('TS5V',false)
set RCv[$D5]='TS5W'
call LZx('TS5W',false)
set RCv[$D6]='TS5X'
call LZx('TS5X',false)
set RCv[$D7]='TS5Y'
call LZx('TS5Y',false)
set RCv[$D8]='TS5Z'
call LZx('TS5Z',false)
set RCv[$D9]='TS60'
call LZx('TS60',false)
set RCv[$DA]='TS61'
call LZx('TS61',false)
set RCv[$DB]='TS62'
call LZx('TS62',false)
set RCv[$DC]='TS63'
call LZx('TS63',false)
set RCv[$DD]='TS64'
call LZx('TS64',false)
set RCv[$DE]='TS65'
call LZx('TS65',false)
set RCv[$DF]='TS66'
call LZx('TS66',false)
set RCv[$E0]='TS67'
call LZx('TS67',false)
set RCv[$E1]='TS68'
call LZx('TS68',false)
set RCv[$E2]='TS69'
call LZx('TS69',false)
set RCv[$E3]='TS6A'
call LZx('TS6A',false)
set RCv[$E4]='TS6B'
call LZx('TS6B',false)
set RCv[$E5]='TS6C'
call LZx('TS6C',false)
set RCv[$E6]='TS6D'
call LZx('TS6D',false)
set RCv[$E7]='TS6E'
call LZx('TS6E',false)
set RCv[$E8]='TS6F'
call LZx('TS6F',false)
set RCv[$E9]='TS6G'
call LZx('TS6G',false)
set RCv[$EA]='TS6H'
call LZx('TS6H',false)
set RCv[$EB]='TS6I'
call LZx('TS6I',false)
set RCv[$EC]='TS6J'
call LZx('TS6J',false)
set RCv[$ED]='TS6K'
call LZx('TS6K',false)
set RCv[$EE]='TS6L'
call LZx('TS6L',false)
set RCv[$EF]='TS6M'
call LZx('TS6M',false)
set RCv[$F0]='TS6N'
call LZx('TS6N',false)
set RCv[$F1]='TS6O'
call LZx('TS6O',false)
set RCv[$F2]='TS6P'
call LZx('TS6P',false)
set RCv[$F3]='TS6Q'
call LZx('TS6Q',false)
set RCv[$F4]='TS6R'
call LZx('TS6R',false)
set RCv[$F5]='TS6S'
call LZx('TS6S',false)
set RCv[$F6]='TS6T'
call LZx('TS6T',false)
set RCv[$F7]='TS6U'
call LZx('TS6U',false)
set RCv[$F8]='TS6V'
call LZx('TS6V',false)
set RCv[$F9]='TS6W'
call LZx('TS6W',false)
set RCv[$FA]='TS6X'
call LZx('TS6X',false)
set RCv[$FB]='TS6Y'
call LZx('TS6Y',false)
set RCv[$FC]='TS6Z'
call LZx('TS6Z',false)
set RCv[$FD]='TS70'
call LZx('TS70',false)
set RCv[$FE]='TS71'
call LZx('TS71',false)
set RCv[$FF]='TS72'
call LZx('TS72',false)
set RCv[256]='TS73'
call LZx('TS73',false)
return true
endfunction
function E5o takes nothing returns boolean
set Rdv[1]='SS00'
set Rdv[2]='SS01'
set Rdv[3]='SS02'
set Rdv[4]='SS03'
set Rdv[5]='SS04'
set Rdv[6]='SS05'
set Rdv[7]='SS06'
set Rdv[8]='SS07'
set Rdv[9]='SS08'
set Rdv[$A]='SS09'
set Rdv[$B]='SS0A'
set Rdv[$C]='SS0B'
set Rdv[$D]='SS0C'
set Rdv[$E]='SS0D'
set Rdv[$F]='SS0E'
set Rdv[16]='SS0F'
set Rdv[17]='SS0G'
set Rdv[18]='SS0H'
set Rdv[19]='SS0I'
set Rdv[20]='SS0J'
set Rdv[21]='SS0K'
set Rdv[22]='SS0L'
set Rdv[23]='SS0M'
set Rdv[24]='SS0N'
set Rdv[25]='SS0O'
set Rdv[26]='SS0P'
set Rdv[27]='SS0Q'
set Rdv[28]='SS0R'
set Rdv[29]='SS0S'
set Rdv[30]='SS0T'
set Rdv[31]='SS0U'
set Rdv[32]='SS0V'
set Rdv[33]='SS0W'
set Rdv[34]='SS0X'
set Rdv[35]='SS0Y'
set Rdv[36]='SS0Z'
set Rdv[37]='SS10'
set Rdv[38]='SS11'
set Rdv[39]='SS12'
set Rdv[40]='SS13'
set Rdv[41]='SS14'
set Rdv[42]='SS15'
set Rdv[43]='SS16'
set Rdv[44]='SS17'
set Rdv[45]='SS18'
set Rdv[46]='SS19'
set Rdv[47]='SS1A'
set Rdv[48]='SS1B'
set Rdv[49]='SS1C'
set Rdv[50]='SS1D'
set Rdv[51]='SS1E'
set Rdv[52]='SS1F'
set Rdv[53]='SS1G'
set Rdv[54]='SS1H'
set Rdv[55]='SS1I'
set Rdv[56]='SS1J'
set Rdv[57]='SS1K'
set Rdv[58]='SS1L'
set Rdv[59]='SS1M'
set Rdv[60]='SS1N'
set Rdv[61]='SS1O'
set Rdv[62]='SS1P'
set Rdv[63]='SS1Q'
set Rdv[64]='SS1R'
set Rdv[65]='SS1S'
set Rdv[66]='SS1T'
set Rdv[67]='SS1U'
set Rdv[68]='SS1V'
set Rdv[69]='SS1W'
set Rdv[70]='SS1X'
set Rdv[71]='SS1Y'
set Rdv[72]='SS1Z'
set Rdv[73]='SS20'
set Rdv[74]='SS21'
set Rdv[75]='SS22'
set Rdv[76]='SS23'
set Rdv[77]='SS24'
set Rdv[78]='SS25'
set Rdv[79]='SS26'
set Rdv[80]='SS27'
set Rdv[81]='SS28'
set Rdv[82]='SS29'
set Rdv[83]='SS2A'
set Rdv[84]='SS2B'
set Rdv[85]='SS2C'
set Rdv[86]='SS2D'
set Rdv[87]='SS2E'
set Rdv[88]='SS2F'
set Rdv[89]='SS2G'
set Rdv[90]='SS2H'
set Rdv[91]='SS2I'
set Rdv[92]='SS2J'
set Rdv[93]='SS2K'
set Rdv[94]='SS2L'
set Rdv[95]='SS2M'
set Rdv[96]='SS2N'
set Rdv[97]='SS2O'
set Rdv[98]='SS2P'
set Rdv[99]='SS2Q'
set Rdv['d']='SS2R'
set Rdv['e']='SS2S'
set Rdv['f']='SS2T'
set Rdv['g']='SS2U'
set Rdv['h']='SS2V'
set Rdv['i']='SS2W'
set Rdv['j']='SS2X'
set Rdv['k']='SS2Y'
set Rdv['l']='SS2Z'
set Rdv['m']='SS30'
set Rdv['n']='SS31'
set Rdv['o']='SS32'
set Rdv['p']='SS33'
set Rdv['q']='SS34'
set Rdv['r']='SS35'
set Rdv['s']='SS36'
set Rdv['t']='SS37'
set Rdv['u']='SS38'
set Rdv['v']='SS39'
set Rdv['w']='SS3A'
set Rdv['x']='SS3B'
set Rdv['y']='SS3C'
set Rdv['z']='SS3D'
set Rdv['{']='SS3E'
set Rdv['|']='SS3F'
set Rdv['}']='SS3G'
set Rdv[$7E]='SS3H'
set Rdv[$7F]='SS3I'
set Rdv[$80]='SS3J'
set Rdv[$81]='SS3K'
set Rdv[$82]='SS3L'
set Rdv[$83]='SS3M'
set Rdv[$84]='SS3N'
set Rdv[$85]='SS3O'
set Rdv[$86]='SS3P'
set Rdv[$87]='SS3Q'
set Rdv[$88]='SS3R'
set Rdv[$89]='SS3S'
set Rdv[$8A]='SS3T'
set Rdv[$8B]='SS3U'
set Rdv[$8C]='SS3V'
set Rdv[$8D]='SS3W'
set Rdv[$8E]='SS3X'
set Rdv[$8F]='SS3Y'
set Rdv[$90]='SS3Z'
set Rdv[$91]='SS40'
set Rdv[$92]='SS41'
set Rdv[$93]='SS42'
set Rdv[$94]='SS43'
set Rdv[$95]='SS44'
set Rdv[$96]='SS45'
set Rdv[$97]='SS46'
set Rdv[$98]='SS47'
set Rdv[$99]='SS48'
set Rdv[$9A]='SS49'
set Rdv[$9B]='SS4A'
set Rdv[$9C]='SS4B'
set Rdv[$9D]='SS4C'
set Rdv[$9E]='SS4D'
set Rdv[$9F]='SS4E'
set Rdv[$A0]='SS4F'
set Rdv[$A1]='SS4G'
set Rdv[$A2]='SS4H'
set Rdv[$A3]='SS4I'
set Rdv[$A4]='SS4J'
set Rdv[$A5]='SS4K'
set Rdv[$A6]='SS4L'
set Rdv[$A7]='SS4M'
set Rdv[$A8]='SS4N'
set Rdv[$A9]='SS4O'
set Rdv[$AA]='SS4P'
set Rdv[$AB]='SS4Q'
set Rdv[$AC]='SS4R'
set Rdv[$AD]='SS4S'
set Rdv[$AE]='SS4T'
set Rdv[$AF]='SS4U'
set Rdv[$B0]='SS4V'
set Rdv[$B1]='SS4W'
set Rdv[$B2]='SS4X'
set Rdv[$B3]='SS4Y'
set Rdv[$B4]='SS4Z'
set Rdv[$B5]='SS50'
set Rdv[$B6]='SS51'
set Rdv[$B7]='SS52'
set Rdv[$B8]='SS53'
set Rdv[$B9]='SS54'
set Rdv[$BA]='SS55'
set Rdv[$BB]='SS56'
set Rdv[$BC]='SS57'
set Rdv[$BD]='SS58'
set Rdv[$BE]='SS59'
set Rdv[$BF]='SS5A'
set Rdv[$C0]='SS5B'
set Rdv[$C1]='SS5C'
set Rdv[$C2]='SS5D'
set Rdv[$C3]='SS5E'
set Rdv[$C4]='SS5F'
set Rdv[$C5]='SS5G'
set Rdv[$C6]='SS5H'
set Rdv[$C7]='SS5I'
set Rdv[$C8]='SS5J'
set Rdv[$C9]='SS5K'
set Rdv[$CA]='SS5L'
set Rdv[$CB]='SS5M'
set Rdv[$CC]='SS5N'
set Rdv[$CD]='SS5O'
set Rdv[$CE]='SS5P'
set Rdv[$CF]='SS5Q'
set Rdv[$D0]='SS5R'
set Rdv[$D1]='SS5S'
set Rdv[$D2]='SS5T'
set Rdv[$D3]='SS5U'
set Rdv[$D4]='SS5V'
set Rdv[$D5]='SS5W'
set Rdv[$D6]='SS5X'
set Rdv[$D7]='SS5Y'
set Rdv[$D8]='SS5Z'
set Rdv[$D9]='SS60'
set Rdv[$DA]='SS61'
set Rdv[$DB]='SS62'
set Rdv[$DC]='SS63'
set Rdv[$DD]='SS64'
set Rdv[$DE]='SS65'
set Rdv[$DF]='SS66'
set Rdv[$E0]='SS67'
set Rdv[$E1]='SS68'
set Rdv[$E2]='SS69'
set Rdv[$E3]='SS6A'
set Rdv[$E4]='SS6B'
set Rdv[$E5]='SS6C'
set Rdv[$E6]='SS6D'
set Rdv[$E7]='SS6E'
set Rdv[$E8]='SS6F'
set Rdv[$E9]='SS6G'
set Rdv[$EA]='SS6H'
set Rdv[$EB]='SS6I'
set Rdv[$EC]='SS6J'
set Rdv[$ED]='SS6K'
set Rdv[$EE]='SS6L'
set Rdv[$EF]='SS6M'
set Rdv[$F0]='SS6N'
set Rdv[$F1]='SS6O'
set Rdv[$F2]='SS6P'
set Rdv[$F3]='SS6Q'
set Rdv[$F4]='SS6R'
set Rdv[$F5]='SS6S'
set Rdv[$F6]='SS6T'
set Rdv[$F7]='SS6U'
set Rdv[$F8]='SS6V'
set Rdv[$F9]='SS6W'
set Rdv[$FA]='SS6X'
set Rdv[$FB]='SS6Y'
set Rdv[$FC]='SS6Z'
set Rdv[$FD]='SS70'
set Rdv[$FE]='SS71'
set Rdv[$FF]='SS72'
set Rdv[256]='SS73'
set RDv[1]='TS00'
set RDv[2]='TS01'
set RDv[3]='TS02'
set RDv[4]='TS03'
set RDv[5]='TS04'
set RDv[6]='TS05'
set RDv[7]='TS06'
set RDv[8]='TS07'
set RDv[9]='TS08'
set RDv[$A]='TS09'
set RDv[$B]='TS0A'
set RDv[$C]='TS0B'
set RDv[$D]='TS0C'
set RDv[$E]='TS0D'
set RDv[$F]='TS0E'
set RDv[16]='TS0F'
set RDv[17]='TS0G'
set RDv[18]='TS0H'
set RDv[19]='TS0I'
set RDv[20]='TS0J'
set RDv[21]='TS0K'
set RDv[22]='TS0L'
set RDv[23]='TS0M'
set RDv[24]='TS0N'
set RDv[25]='TS0O'
set RDv[26]='TS0P'
set RDv[27]='TS0Q'
set RDv[28]='TS0R'
set RDv[29]='TS0S'
set RDv[30]='TS0T'
set RDv[31]='TS0U'
set RDv[32]='TS0V'
set RDv[33]='TS0W'
set RDv[34]='TS0X'
set RDv[35]='TS0Y'
set RDv[36]='TS0Z'
set RDv[37]='TS10'
set RDv[38]='TS11'
set RDv[39]='TS12'
set RDv[40]='TS13'
set RDv[41]='TS14'
set RDv[42]='TS15'
set RDv[43]='TS16'
set RDv[44]='TS17'
set RDv[45]='TS18'
set RDv[46]='TS19'
set RDv[47]='TS1A'
set RDv[48]='TS1B'
set RDv[49]='TS1C'
set RDv[50]='TS1D'
set RDv[51]='TS1E'
set RDv[52]='TS1F'
set RDv[53]='TS1G'
set RDv[54]='TS1H'
set RDv[55]='TS1I'
set RDv[56]='TS1J'
set RDv[57]='TS1K'
set RDv[58]='TS1L'
set RDv[59]='TS1M'
set RDv[60]='TS1N'
set RDv[61]='TS1O'
set RDv[62]='TS1P'
set RDv[63]='TS1Q'
set RDv[64]='TS1R'
set RDv[65]='TS1S'
set RDv[66]='TS1T'
set RDv[67]='TS1U'
set RDv[68]='TS1V'
set RDv[69]='TS1W'
set RDv[70]='TS1X'
set RDv[71]='TS1Y'
set RDv[72]='TS1Z'
set RDv[73]='TS20'
set RDv[74]='TS21'
set RDv[75]='TS22'
set RDv[76]='TS23'
set RDv[77]='TS24'
set RDv[78]='TS25'
set RDv[79]='TS26'
set RDv[80]='TS27'
set RDv[81]='TS28'
set RDv[82]='TS29'
set RDv[83]='TS2A'
set RDv[84]='TS2B'
set RDv[85]='TS2C'
set RDv[86]='TS2D'
set RDv[87]='TS2E'
set RDv[88]='TS2F'
set RDv[89]='TS2G'
set RDv[90]='TS2H'
set RDv[91]='TS2I'
set RDv[92]='TS2J'
set RDv[93]='TS2K'
set RDv[94]='TS2L'
set RDv[95]='TS2M'
set RDv[96]='TS2N'
set RDv[97]='TS2O'
set RDv[98]='TS2P'
set RDv[99]='TS2Q'
set RDv['d']='TS2R'
set RDv['e']='TS2S'
set RDv['f']='TS2T'
set RDv['g']='TS2U'
set RDv['h']='TS2V'
set RDv['i']='TS2W'
set RDv['j']='TS2X'
set RDv['k']='TS2Y'
set RDv['l']='TS2Z'
set RDv['m']='TS30'
set RDv['n']='TS31'
set RDv['o']='TS32'
set RDv['p']='TS33'
set RDv['q']='TS34'
set RDv['r']='TS35'
set RDv['s']='TS36'
set RDv['t']='TS37'
set RDv['u']='TS38'
set RDv['v']='TS39'
set RDv['w']='TS3A'
set RDv['x']='TS3B'
set RDv['y']='TS3C'
set RDv['z']='TS3D'
set RDv['{']='TS3E'
set RDv['|']='TS3F'
set RDv['}']='TS3G'
set RDv[$7E]='TS3H'
set RDv[$7F]='TS3I'
set RDv[$80]='TS3J'
set RDv[$81]='TS3K'
set RDv[$82]='TS3L'
set RDv[$83]='TS3M'
set RDv[$84]='TS3N'
set RDv[$85]='TS3O'
set RDv[$86]='TS3P'
set RDv[$87]='TS3Q'
set RDv[$88]='TS3R'
set RDv[$89]='TS3S'
set RDv[$8A]='TS3T'
set RDv[$8B]='TS3U'
set RDv[$8C]='TS3V'
set RDv[$8D]='TS3W'
set RDv[$8E]='TS3X'
set RDv[$8F]='TS3Y'
set RDv[$90]='TS3Z'
set RDv[$91]='TS40'
set RDv[$92]='TS41'
set RDv[$93]='TS42'
set RDv[$94]='TS43'
set RDv[$95]='TS44'
set RDv[$96]='TS45'
set RDv[$97]='TS46'
set RDv[$98]='TS47'
set RDv[$99]='TS48'
set RDv[$9A]='TS49'
set RDv[$9B]='TS4A'
set RDv[$9C]='TS4B'
set RDv[$9D]='TS4C'
set RDv[$9E]='TS4D'
set RDv[$9F]='TS4E'
set RDv[$A0]='TS4F'
set RDv[$A1]='TS4G'
set RDv[$A2]='TS4H'
set RDv[$A3]='TS4I'
set RDv[$A4]='TS4J'
set RDv[$A5]='TS4K'
set RDv[$A6]='TS4L'
set RDv[$A7]='TS4M'
set RDv[$A8]='TS4N'
set RDv[$A9]='TS4O'
set RDv[$AA]='TS4P'
set RDv[$AB]='TS4Q'
set RDv[$AC]='TS4R'
set RDv[$AD]='TS4S'
set RDv[$AE]='TS4T'
set RDv[$AF]='TS4U'
set RDv[$B0]='TS4V'
set RDv[$B1]='TS4W'
set RDv[$B2]='TS4X'
set RDv[$B3]='TS4Y'
set RDv[$B4]='TS4Z'
set RDv[$B5]='TS50'
set RDv[$B6]='TS51'
set RDv[$B7]='TS52'
set RDv[$B8]='TS53'
set RDv[$B9]='TS54'
set RDv[$BA]='TS55'
set RDv[$BB]='TS56'
set RDv[$BC]='TS57'
set RDv[$BD]='TS58'
set RDv[$BE]='TS59'
set RDv[$BF]='TS5A'
set RDv[$C0]='TS5B'
set RDv[$C1]='TS5C'
set RDv[$C2]='TS5D'
set RDv[$C3]='TS5E'
set RDv[$C4]='TS5F'
set RDv[$C5]='TS5G'
set RDv[$C6]='TS5H'
set RDv[$C7]='TS5I'
set RDv[$C8]='TS5J'
set RDv[$C9]='TS5K'
set RDv[$CA]='TS5L'
set RDv[$CB]='TS5M'
set RDv[$CC]='TS5N'
set RDv[$CD]='TS5O'
set RDv[$CE]='TS5P'
set RDv[$CF]='TS5Q'
set RDv[$D0]='TS5R'
set RDv[$D1]='TS5S'
set RDv[$D2]='TS5T'
set RDv[$D3]='TS5U'
set RDv[$D4]='TS5V'
set RDv[$D5]='TS5W'
set RDv[$D6]='TS5X'
set RDv[$D7]='TS5Y'
set RDv[$D8]='TS5Z'
set RDv[$D9]='TS60'
set RDv[$DA]='TS61'
set RDv[$DB]='TS62'
set RDv[$DC]='TS63'
set RDv[$DD]='TS64'
set RDv[$DE]='TS65'
set RDv[$DF]='TS66'
set RDv[$E0]='TS67'
set RDv[$E1]='TS68'
set RDv[$E2]='TS69'
set RDv[$E3]='TS6A'
set RDv[$E4]='TS6B'
set RDv[$E5]='TS6C'
set RDv[$E6]='TS6D'
set RDv[$E7]='TS6E'
set RDv[$E8]='TS6F'
set RDv[$E9]='TS6G'
set RDv[$EA]='TS6H'
set RDv[$EB]='TS6I'
set RDv[$EC]='TS6J'
set RDv[$ED]='TS6K'
set RDv[$EE]='TS6L'
set RDv[$EF]='TS6M'
set RDv[$F0]='TS6N'
set RDv[$F1]='TS6O'
set RDv[$F2]='TS6P'
set RDv[$F3]='TS6Q'
set RDv[$F4]='TS6R'
set RDv[$F5]='TS6S'
set RDv[$F6]='TS6T'
set RDv[$F7]='TS6U'
set RDv[$F8]='TS6V'
set RDv[$F9]='TS6W'
set RDv[$FA]='TS6X'
set RDv[$FB]='TS6Y'
set RDv[$FC]='TS6Z'
set RDv[$FD]='TS70'
set RDv[$FE]='TS71'
set RDv[$FF]='TS72'
set RDv[256]='TS73'
return true
endfunction
function E6o takes nothing returns boolean
call VRx(qa,(function E4o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\SightRange\\obj_spells_wc3objLuaspells.j"))
call VRx(ea,(function E5o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\SightRange\\obj_spells_wc3objLuainits.j"))
return true
endfunction
function E7o takes nothing returns boolean
set Rfv=Vnx(RFv)
return true
endfunction
function E8o takes nothing returns boolean
set Rgv=Vnx(RGv)
return true
endfunction
function E9o takes nothing returns boolean
return true
endfunction
function Xvo takes nothing returns boolean
set Rhv=Vnx(RHv)
return true
endfunction
function Xeo takes nothing returns boolean
set Rjv=Vnx(RJv)
return true
endfunction
function Xxo takes nothing returns boolean
set Rkv=Vnx(RKv)
return true
endfunction
function Xoo takes nothing returns boolean
set Rlv=Vnx(RLv)
return true
endfunction
function Xro takes nothing returns boolean
set Rmv=Vnx(RMv)
return true
endfunction
function Xio takes nothing returns boolean
return true
endfunction
function Xao takes nothing returns boolean
set Rpv=Vnx(RPv)
return true
endfunction
function Xno takes nothing returns boolean
set Rqv=Vnx(RQv)
return true
endfunction
function XVo takes nothing returns boolean
set Rsv=Vnx(RSv)
return true
endfunction
function XEo takes nothing returns boolean
set Rtv=Vnx(RTv)
return true
endfunction
function XXo takes nothing returns boolean
set Ruv=Vnx(RUv)
return true
endfunction
function XOo takes nothing returns boolean
return true
endfunction
function XRo takes nothing returns boolean
set Rwv=Vnx(RWv)
return true
endfunction
function XIo takes nothing returns boolean
set Ryv=Vnx(RYv)
return true
endfunction
function XAo takes nothing returns boolean
set Rzv=Vnx(RZv)
return true
endfunction
function XNo takes nothing returns boolean
set R_v=Vnx(R0v)
return true
endfunction
function Xbo takes nothing returns boolean
set R1v=Vnx(R2v)
return true
endfunction
function XBo takes nothing returns boolean
return true
endfunction
function Xco takes nothing returns boolean
set R3v=Vnx(R4v)
return true
endfunction
function XCo takes nothing returns boolean
set R5v=Vnx(R6v)
return true
endfunction
function Xdo takes nothing returns boolean
call LZx('Apit',false)
return true
endfunction
function XDo takes nothing returns boolean
call LZx('Ane2',false)
return true
endfunction
function Xfo takes nothing returns boolean
call LZx('AInv',false)
return true
endfunction
function XFo takes nothing returns boolean
call LZx('Aneu',false)
return true
endfunction
function Xgo takes nothing returns boolean
call VRx(qa,(function Xdo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\obj_purchaseItem_wc3spell.j"))
call VRx(qa,(function XDo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\obj_sharedShop_wc3spell.j"))
call VRx(qa,(function Xfo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\obj_heroInventorySpell_wc3spell.j"))
call VRx(qa,(function XFo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\obj_selectHero_wc3spell.j"))
return true
endfunction
function XGo takes nothing returns boolean
set R7v=Vnx(R8v)
return true
endfunction
function Xho takes code c,string rqx returns nothing
set zV=zV+1
set ZV[zV]=CreateTrigger()
set vE[zV]=(GetHandleId(Condition((c))))
set eE[zV]=rqx
call TriggerAddCondition(ZV[zV],Condition(c))
endfunction
function XHo takes unit oMx returns integer
set C[Db]=oMx
call rcx(R9v)
if(Ib==w)then
call Mcx(oMx)
endif
return Ib
endfunction
function Xjo takes nothing returns boolean
local integer rdx=(bv)
local unit XJo=GetEnumUnit()
local integer Xko
if(GetUnitTypeId(XJo)==0)then
call Mcx(XJo)
set XJo=null
return true
endif
set Xko=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((XJo)))))),((((ix))))))
if(Xko==w)then
set Xko=XHo(XJo)
endif
if(Xko==w)then
return true
endif
call NIx((Xko),(i9v),(1),w,((10.)*1.))
call Cbx(Xko)
return true
endfunction
function XKo takes nothing returns boolean
local group Xlo=CreateGroup()
call GroupEnumUnitsInRect(Xlo,bm[Bm],null)
call ForGroup(Xlo,function Xjo)
call DestroyGroup(Xlo)
set Xlo=null
return true
endfunction
function XLo takes nothing returns boolean
call Xho(function XKo,"Unit_InitPreplaced")
return true
endfunction
function Xmo takes code c,string rqx returns nothing
set Aa=Aa+1
set Na[Aa]=CreateTrigger()
set ba[Aa]=(GetHandleId(Condition((c))))
set Ba[Aa]=rqx
call TriggerAddCondition(Na[Aa],Condition(c))
endfunction
function XMo takes nothing returns nothing
endfunction
function Xpo takes nothing returns nothing
endfunction
function XPo takes nothing returns nothing
endfunction
function Xqo takes nothing returns nothing
local integer olx=gg
loop
exitwhen(olx<0)
set hg[olx]=CreateItem('Idd0'+olx,.0,.0)
set olx=olx-1
endloop
set olx=Hg
loop
exitwhen(olx<0)
set jg[olx]=CreateItem('Iid0'+olx,.0,.0)
set olx=olx-1
endloop
call XPo()
endfunction
function XQo takes nothing returns nothing
endfunction
function Xso takes nothing returns nothing
endfunction
function XSo takes nothing returns nothing
endfunction
function Xto takes nothing returns nothing
call XQo()
call Xso()
call XSo()
endfunction
function XTo takes nothing returns nothing
call XMo()
call Xpo()
call Xqo()
call Xto()
endfunction
function Xuo takes integer oqx returns integer
set Iiv[oqx]=true
set Iav[oqx]=false
set Inv[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
call rax(epv)
return oqx
endfunction
function XUo takes nothing returns integer
local integer oqx
if(Iev==8190)then
call oYx("UnitClass_Allocation_allocCustom","call DebugEx(UnitClass.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",ePv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Ixv[(w)]==w)then
set Iov=Iov+1
set oqx=Iov
else
set oqx=Ixv[(w)]
set Ixv[(w)]=Ixv[Ixv[(w)]]
endif
set Ixv[oqx]=Z
set Irv[oqx]=1
call Xuo(oqx)
return oqx
endfunction
function Xwo takes integer oqx returns boolean
set IEv=IEv+1
set IXv[IEv]=oqx
set IOv[oqx]=IEv+1
return(IEv==0)
endfunction
function XWo takes integer oqx returns nothing
set IRv[(oqx)]=(IAv+oqx)
endfunction
function Xyo takes string rqx returns integer
local integer oqx=XUo()
set IVv[(oqx)]=(rqx)
call Xwo(oqx)
call XWo(oqx)
return oqx
endfunction
function XYo takes nothing returns nothing
set Ivv=Xyo("air")
set sc=Xyo("dead")
set INv=Xyo("ground")
set yd=Xyo("hero")
set Ibv=Xyo("illusion")
set IBv=Xyo("mechanical")
set Icv=Xyo("neutral")
set ICv=Xyo("structure")
set Idv=Xyo("summon")
set IDv=Xyo("undecayable")
set Ifv=Xyo("upgraded")
set IFv=Xyo("ward")
endfunction
function Xzo takes nothing returns nothing
endfunction
function XZo takes integer oMx returns integer
return(LoadInteger(o[((V[(E[((X))])]))],(((oMx))),(((Ff)))))
endfunction
function X_o takes integer oqx,string oSx returns nothing
set Si[oqx]=Si[oqx]+";"+oSx
endfunction
function X0o takes integer oqx returns integer
set Ikv[oqx]=true
set IKv[oqx]=false
set I[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set Rv[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(R7v)
return oqx
endfunction
function X1o takes nothing returns integer
local integer oqx
if(Ihv==8190)then
call oYx("Unit_Allocation_allocCustom","call DebugEx(Unit.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",R8v+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(IHv[(w)]==w)then
set Ijv=Ijv+1
set oqx=Ijv
else
set oqx=IHv[(w)]
set IHv[(w)]=IHv[IHv[(w)]]
endif
set IHv[oqx]=Z
set IJv[oqx]=1
call X0o(oqx)
return oqx
endfunction
function X2o takes integer oqx returns nothing
local integer oSx=GetHandleId(C[(oqx)])
set A[(oqx)]=(oSx)
call SaveInteger(o[((V[(E[((X))])]))],(((OK+oSx))),(((IK))),(((oqx))))
endfunction
function X3o takes integer oqx returns nothing
set JT[oqx]=0
set kT[oqx]=false
endfunction
function X4o takes integer oqx,real oSx returns nothing
set Ilv[oqx]=oSx
call SetUnitTimeScale(C[(oqx)],oSx)
endfunction
function X5o takes integer oqx returns nothing
set eF[oqx]=.0
set xF[(oqx)]=.0
set vF[(oqx)]=.0
call bKx(oqx)
endfunction
function X6o takes integer oqx returns nothing
set EUv[(oqx)]=(((ILv[(oqx)])+(Imv[(oqx)]))*1.)
endfunction
function X7o takes integer oqx returns nothing
set EUv[oqx]=.0
set ILv[(oqx)]=.0
set Imv[(oqx)]=.0
call X6o(oqx)
endfunction
function X8o takes integer oqx returns nothing
set rF[oqx]=.0
set iF[(oqx)]=.0
set oF[(oqx)]=.0
call bmx(oqx)
endfunction
function X9o takes integer oqx returns nothing
set IMv[(oqx)]=(((Ipv[(oqx)])+(IPv[(oqx)]))*1.)
endfunction
function Ovo takes integer oqx returns nothing
set IMv[oqx]=.0
set Ipv[(oqx)]=.0
set IPv[(oqx)]=.0
call X9o(oqx)
endfunction
function Oeo takes integer oqx returns nothing
call bCx(oqx,GetHeroXP(C[(oqx)]))
endfunction
function Oxo takes integer oqx returns nothing
set xk[(oqx)]=(false)
set ntv[(oqx)]=(false)
set nkv[((oqx))]=(false)
endfunction
function Ooo takes integer oqx returns nothing
set aTv[(oqx)]=(false)
set aPv[((oqx))]=(false)
endfunction
function Oro takes integer oqx,integer oSx returns nothing
set ze[oqx]=oSx
call aIx((oqx),(ox[(oSx)]))
endfunction
function Oio takes integer oqx returns nothing
call rQx((oqx),'aFly')
call UnitRemoveAbility(C[(((oqx)))],('aFly'))
endfunction
function Oao takes integer oqx returns nothing
set uf[oqx]=XZo(GetUnitTypeId(C[(oqx)]))
endfunction
function Ono takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((Fw[(oqx)]))])]))],((((gw[((oqx))])))),(((oQx))))))
endfunction
function OVo takes integer oqx returns integer
return(Ono(((oqx)),ISv))
endfunction
function OEo takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((Fw[(oqx)]))])]))],((((gw[((oqx))])))),(((oQx)+(okx)))))
endfunction
function OXo takes integer oqx,integer okx returns integer
return(OEo(((oqx)),ISv,(okx)))
endfunction
function OOo takes integer oqx,integer rJx,integer oSx returns nothing
call rzx(oqx,rJx,(oPx(((oqx)),N+(rJx)))+oSx)
endfunction
function ORo takes integer oqx,integer okx returns integer
return(Lrx(((oqx)),Itv+(okx)))
endfunction
function OIo takes integer oqx returns nothing
set Th[oqx]=w
call dpx(Iuv,oqx)
set xDv[(oqx)]=false
endfunction
function OAo takes integer oqx returns nothing
call dpx(ITv,(oqx))
call OIo(oqx)
call dpx(IUv,(oqx))
endfunction
function ONo takes integer rJx,integer Oqx returns nothing
call rrx(Oqx,Izv,rJx)
call rix(Oqx,Iyv+(G6[(rJx)]))
call CEx(Oqx,Qtx(rJx))
call rLx(Oqx,rJx)
call rQx(Oqx,(IZv[((rJx))]))
endfunction
function Obo takes integer rJx,integer Oqx returns nothing
local integer OBo=(G6[(rJx)])
local integer Oco=(oPx((Oqx),Iyv+(OBo)))
local integer rwx=rux(Oqx,Oco)
if(Oco!=w)then
call ONo(Oco,Oqx)
endif
call rtx(Oqx,Izv,rJx)
call rTx(Oqx,Iyv+OBo,rJx)
call CEx(Oqx,(IZv[((rJx))]))
call rzx(Oqx,rJx,rwx)
if(rwx<(j6[(rJx)]))then
call ryx(Oqx,Qtx(rJx),rwx+1)
endif
endfunction
function OCo takes integer oqx,integer okx returns integer
return Lrx((oqx),I_v+okx)
endfunction
function Odo takes integer oqx returns nothing
local integer rJx
local integer GLx=(uf[((oqx))])
local integer olx=OVo(GLx)
set Mb[(oqx)]=w
loop
exitwhen(olx<0)
set rJx=OXo(GLx,olx)
call OOo(oqx,rJx,ORo(GLx,rJx))
set olx=olx-1
endloop
call OAo(oqx)
set olx=(Iwv[(GLx)])
loop
exitwhen(olx<0)
call Obo(OCo(GLx,olx),oqx)
set olx=olx-1
endloop
endfunction
function ODo takes integer oqx returns nothing
set I2v[oqx]=(I3v[((uf[((oqx))]))])
endfunction
function Ofo takes integer oqx returns nothing
set I5v[oqx]=.0
set I6v[oqx]=.0
set I7v[oqx]=false
endfunction
function OFo takes integer oqx returns nothing
set I4v[oqx]=.0
call Ofo(oqx)
endfunction
function Ogo takes integer oqx returns nothing
set I9v[oqx]=1.
set Avv[(oqx)]=1.
endfunction
function OGo takes integer oqx returns nothing
set Aev[(oqx)]=((Axv[((uf[((oqx))]))]))
endfunction
function Oho takes integer oqx,unit oMx,real nyx,real bWx returns nothing
local integer byx
local integer bYx
set nyx=nyx*1
set bWx=bWx*1
if(nyx*bWx<=.0)then
if(bWx<.0)then
set bYx=Arv
loop
call UnitRemoveAbility(oMx,vYv[bYx])
set bYx=bYx-1
exitwhen(bYx<0)
endloop
else
set bYx=Aiv
loop
call UnitRemoveAbility(oMx,vzv[bYx])
set bYx=bYx-1
exitwhen(bYx<0)
endloop
endif
if(nyx<.0)then
set nyx=-nyx
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(Arv)))*1.)))
loop
exitwhen(nyx<1.)
set byx=vZv[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
call UnitAddAbility(oMx,vYv[bYx])
endif
set bYx=bYx-1
endloop
else
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(Aiv)))*1.)))
loop
exitwhen(nyx<1.)
set byx=vZv[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
call UnitAddAbility(oMx,vzv[bYx])
endif
set bYx=bYx-1
endloop
endif
else
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(Arv)))*1.)))
if(nyx<.0)then
set nyx=-nyx
loop
exitwhen(bYx<0)
set byx=vZv[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
call UnitAddAbility(oMx,vYv[bYx])
else
call UnitRemoveAbility(oMx,vYv[bYx])
endif
set bYx=bYx-1
endloop
else
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(Aiv)))*1.)))
loop
exitwhen(bYx<0)
set byx=vZv[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
else
call UnitRemoveAbility(oMx,vzv[bYx])
endif
set bYx=bYx-1
endloop
endif
endif
endfunction
function OHo takes integer oqx,real oSx,real abx returns nothing
set I6v[oqx]=oSx
call Oho(Aav,C[(oqx)],oSx,abx)
endfunction
function Ojo takes integer oqx,real oSx returns nothing
local real b_x=I6v[oqx]
set I5v[oqx]=oSx
if(oSx==b_x)then
if I7v[oqx]then
set I7v[oqx]=false
call Rmx((oqx),Aov)
endif
return
endif
if Bzx((oqx))then
if not I7v[oqx]then
set I7v[oqx]=true
call I7x((oqx),Aov)
endif
else
call OHo(oqx,oSx,b_x)
endif
endfunction
function OJo takes integer oqx returns nothing
call Ojo((oqx),(((I2v[((oqx))])*((I9v[((oqx))])-1)+(I4v[((oqx))]))*1.))
endfunction
function Oko takes integer oqx,real oSx returns nothing
set ETv[oqx]=oSx
call OJo(oqx)
endfunction
function OKo takes integer oqx returns nothing
local real B9x=(I2v[(oqx)])
local real cex=(I9v[(oqx)])
local real cvx=(I4v[(oqx)])
set I0v[oqx]=B9x*cex+cvx
set I1v[oqx]=B9x*(cex-1)+cvx
call Oko(oqx,B9x*cex*(Avv[(oqx)])+cvx)
endfunction
function Olo takes integer oqx returns nothing
set ETv[oqx]=.0
set I0v[oqx]=.0
set I1v[oqx]=.0
call ODo(oqx)
call OFo(oqx)
set I8v[(((oqx)))]=((.0)*1.)
call Ogo(oqx)
set EWv[((oqx))]=((.0)*1.)
set Etv[((oqx))]=((.0)*1.)
call OGo(oqx)
call OKo(oqx)
endfunction
function OLo takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((Fw[(oqx)]))])]))],((((gw[((oqx))])))),(((oQx))))))
endfunction
function Omo takes integer oqx returns integer
return OLo((oqx),Anv)
endfunction
function OMo takes integer oqx,integer oQx,integer okx returns string
return(LoadStr(o[((V[(E[((Fw[(oqx)]))])]))],((((gw[((oqx))])))),(((oQx)+(okx)))))
endfunction
function Opo takes integer oqx,integer okx returns string
return OMo((oqx),Anv,okx)
endfunction
function OPo takes integer oqx,integer okx returns string
return OMo((oqx),AVv,okx)
endfunction
function Oqo takes integer oqx,integer okx returns integer
return OEo((oqx),AEv,okx)
endfunction
function OQo takes integer oqx returns nothing
local integer Oso=(uf[((oqx))])
local integer olx=Omo(Oso)
loop
exitwhen(olx<q)
call Abx((((oqx))),((Opo(Oso,olx))),((OPo(Oso,olx))),((Oqo(Oso,olx))))
set olx=olx-1
endloop
endfunction
function OSo takes integer oqx returns nothing
set AIv[oqx]=false
call I7x((oqx),AAv)
endfunction
function Oto takes integer oqx returns integer
return(ANv[((uf[((oqx))]))])
endfunction
function OTo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
if(Oto(rkx)==Abv)then
call I7x(rkx,ABv)
call I7x(rkx,Acv)
endif
return true
endfunction
function Ouo takes integer oqx returns nothing
call TriggerRegisterUnitEvent(fA[((AXv))],C[(oqx)],(EVENT_UNIT_ACQUIRED_TARGET))
call TriggerRegisterUnitEvent(fA[((AOv))],C[(oqx)],(EVENT_UNIT_TARGET_IN_RANGE))
call dpx(ARv,oqx)
call OSo(oqx)
call OTo()
endfunction
function OUo takes integer oqx returns nothing
set ACv[(oqx)]=(((Adv[((uf[((oqx))]))]))*1.)
endfunction
function Owo takes integer oqx returns nothing
set Uf[oqx]=(ADv[((uf[((oqx))]))])
endfunction
function OWo takes integer oqx returns nothing
set Wf[oqx]=.0
set dF[(oqx)]=.0
endfunction
function Oyo takes integer oqx returns nothing
call Owo(oqx)
call OWo(oqx)
call bhx(oqx)
endfunction
function OYo takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((Fw[(oqx)]))])]))],((((gw[((oqx))])))),(((oQx))))))
endfunction
function Ozo takes integer oqx returns integer
return OYo((oqx),Afv)
endfunction
function OZo takes integer oqx returns integer
set Ajv[oqx]=true
set AJv[oqx]=false
call rax(ehv)
return oqx
endfunction
function O_o takes nothing returns integer
local integer oqx
if(Agv==8190)then
call oYx("UnitAttackSplash_Allocation_allocCustom","call DebugEx(UnitAttackSplash.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",eHv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(AGv[(w)]==w)then
set Ahv=Ahv+1
set oqx=Ahv
else
set oqx=AGv[(w)]
set AGv[(w)]=AGv[AGv[(w)]]
endif
set AGv[oqx]=Z
set AHv[oqx]=1
call OZo(oqx)
return oqx
endfunction
function O0o takes real O1o,real O2o returns integer
local integer oqx=O_o()
set Akv[oqx]=O1o
set AKv[oqx]=O2o
return oqx
endfunction
function O3o takes integer oqx,real O1o,real O2o returns integer
local integer O4o=O0o(O1o,O2o)
call rtx((oqx),Alv,O4o)
return O4o
endfunction
function O5o takes integer oqx,integer oQx,integer okx returns real
return(LoadReal(o[((V[(E[((Fw[(oqx)]))])]))],((((gw[((oqx))])))),(((oQx)+(okx)))))
endfunction
function O6o takes integer oqx,integer okx returns real
return O5o((oqx),Afv,okx)
endfunction
function O7o takes integer oqx,integer okx returns real
return O5o((oqx),ALv,okx)
endfunction
function O8o takes integer oqx returns nothing
local integer GLx=(uf[((oqx))])
local integer olx=Ozo(GLx)
loop
exitwhen(olx<q)
call rtx((oqx),AFv,O3o(oqx,O6o(GLx,olx),O7o(GLx,olx)))
set olx=olx-1
endloop
endfunction
function O9o takes integer oqx returns nothing
set rTv[(oqx)]=(true)
call Ouo(oqx)
call OUo(oqx)
call Oyo(oqx)
call O8o(oqx)
endfunction
function Rvo takes integer oqx returns nothing
set EQv[(oqx)]=((Amv[((uf[((oqx))]))]))
endfunction
function Reo takes integer oqx returns nothing
set nFv[(oqx)]=((nGv[((uf[((oqx))]))]))
set AMv[(oqx)]=(null)
endfunction
function Rxo takes integer oqx returns integer
return Ono((oqx),Apv)
endfunction
function Roo takes integer oqx,integer rRx returns nothing
if I6x(oqx,rRx)then
call oYx("FolderUnit_StructClasses_Add","call DebugEx(FolderUnit_StructClasses.NAME + \": \" + Unit(this).GetName() + \" is already of class \" + whichType.GetName())",ozv+": "+(GetUnitName(C[((oqx))]))+" is already of class "+(IVv[(rRx)]))
return
endif
call dpx(Qc[(rRx)],oqx)
endfunction
function Rro takes integer oqx,integer okx returns integer
return OEo((oqx),Apv,okx)
endfunction
function Rio takes integer oqx returns nothing
local integer GLx=(uf[((oqx))])
local integer olx=Rxo(GLx)
call I7x((oqx),APv)
loop
exitwhen(olx<q)
call Roo(oqx,Rro(GLx,olx))
set olx=olx-1
endloop
endfunction
function Rao takes integer oqx returns nothing
set tH[oqx]=(Aqv[((uf[((oqx))]))])
endfunction
function Rno takes integer oqx returns nothing
local integer GLx=(uf[((oqx))])
set Cg[oqx]=(AQv[(GLx)])
set cg[oqx]=(Asv[(GLx)])
set dg[oqx]=false
endfunction
function RVo takes integer oqx returns nothing
set Bg[oqx]=(AQv[((uf[((oqx))]))])
call Rno(oqx)
endfunction
function REo takes integer oqx returns nothing
set pg[oqx]=.0
set Mg[oqx]=.0
set Pg[oqx]=false
endfunction
function RXo takes integer oqx returns nothing
set kg[oqx]=.0
call REo(oqx)
endfunction
function ROo takes integer oqx returns nothing
set ASv[(oqx)]=(((Atv[((uf[((oqx))]))]))*1.)
endfunction
function RRo takes integer oqx returns nothing
set ATv[(oqx)]=((Auv[((uf[((oqx))]))]))
endfunction
function RIo takes integer oqx returns nothing
set Kg[oqx]=1.
set Ug[(oqx)]=1.
endfunction
function RAo takes integer oqx returns nothing
set Awv[(oqx)]=((AWv[((uf[((oqx))]))]))
endfunction
function RNo takes integer oqx returns nothing
set AYv[(oqx)]=((Azv[((uf[((oqx))]))]))
endfunction
function Rbo takes integer oqx returns nothing
set mg[oqx]=.0
call RVo(oqx)
call RXo(oqx)
call ROo(oqx)
call RRo(oqx)
call TriggerRegisterUnitEvent(fA[((AUv))],C[((oqx))],(EVENT_UNIT_DAMAGED))
call RIo(oqx)
call RAo(oqx)
set Ayv[((oqx))]=((1.)*1.)
call RNo(oqx)
call B8x(oqx)
endfunction
function RBo takes integer oqx returns nothing
call dpx(AZv,(oqx))
set aG[((oqx))]=(false)
endfunction
function Rco takes integer oqx returns nothing
set A_v[(oqx)]=(((A0v[((uf[((oqx))]))]))*1.)
endfunction
function RCo takes integer oqx returns nothing
call Rco(oqx)
call dpx(A1v,(oqx))
endfunction
function Rdo takes integer oqx returns integer
return Ono((oqx),A2v)
endfunction
function RDo takes integer oqx,integer oSx returns nothing
if rtx((oqx),A3v,oSx)then
call I7x((oqx),A4v)
endif
call I7x((oqx),(A5v[(oSx)]))
call Abx(((oqx)),((A6v[(oSx)])),((A7v[(oSx)])),((A8v[(oSx)])))
endfunction
function Rfo takes integer oqx,integer okx returns integer
return OEo((oqx),A2v,okx)
endfunction
function RFo takes integer oqx returns nothing
set A9v[(oqx)]=((Nvv[((uf[((oqx))]))]))
endfunction
function Rgo takes integer oqx returns nothing
set Nev[(oqx)]=((Nxv[((uf[((oqx))]))]))
endfunction
function RGo takes integer oqx returns nothing
local integer rRx=(uf[((oqx))])
local integer olx=Rdo(rRx)
loop
exitwhen(olx<q)
call RDo(oqx,Rfo(rRx,olx))
set olx=olx-1
endloop
call RFo(oqx)
call Rgo(oqx)
endfunction
function Rho takes integer oqx returns nothing
if(I6x((oqx),ICv)or I6x((oqx),IFv))then
set Nov[(oqx)]=(0)
else
set Nov[(oqx)]=(1)
endif
endfunction
function RHo takes integer oqx returns nothing
set Iu[oqx]=(Nav[((uf[((oqx))]))])
endfunction
function Rjo takes integer oqx returns nothing
set Nrv[(oqx)]=.0
set Niv[(oqx)]=.0
call RHo(oqx)
endfunction
function RJo takes boolean oMx returns integer
if oMx then
return 1
endif
return 0
endfunction
function Rko takes integer oqx returns nothing
set NVv[(oqx)]=(RJo((NEv[((uf[((oqx))]))])))
endfunction
function RKo takes integer oqx returns nothing
set Nnv[oqx]=false
call Rko(oqx)
endfunction
function Rlo takes integer oqx returns nothing
set NRv[oqx]=(NIv[((uf[((oqx))]))])
endfunction
function RLo takes integer oqx,integer nyx returns nothing
local integer Bfx
local integer BFx
if(nyx<0)then
set nyx=-nyx
set Bfx=nyx/ Nbv
set nyx=nyx-Bfx*Nbv
loop
exitwhen(Bfx<1)
call rQx((oqx),NBv)
call ryx((oqx),NBv,2)
call UnitRemoveAbility(C[(((oqx)))],(NBv))
set Bfx=Bfx-1
endloop
set BFx=RDv[nyx]
call rQx((oqx),BFx)
call ryx((oqx),BFx,2)
call UnitRemoveAbility(C[(((oqx)))],(BFx))
else
set Bfx=nyx/ Ncv
set nyx=nyx-Bfx*Ncv
loop
exitwhen(Bfx<1)
call rQx((oqx),NCv)
call ryx((oqx),NCv,2)
call UnitRemoveAbility(C[(((oqx)))],(NCv))
set Bfx=Bfx-1
endloop
set BFx=Rdv[nyx]
call rQx((oqx),BFx)
call ryx((oqx),BFx,2)
call UnitRemoveAbility(C[(((oqx)))],(BFx))
endif
endfunction
function Rmo takes integer oqx,real oSx returns nothing
local real abx=NXv[oqx]
if(abx==oSx)then
return
endif
set NXv[oqx]=oSx
call RLo(oqx,(R2I(((oSx-abx)*1.))))
endfunction
function RMo takes integer oqx returns nothing
call Rmo(oqx,(NRv[(oqx)])*(NNv[(oqx)])+(NAv[(oqx)]))
endfunction
function Rpo takes integer oqx returns nothing
set NXv[oqx]=(NOv[((uf[((oqx))]))])
call Rlo(oqx)
set NAv[(oqx)]=.0
set NNv[(oqx)]=1.
call RMo(oqx)
endfunction
function RPo takes integer oqx returns nothing
set YF[oqx]=(Ndv[((uf[((oqx))]))])
endfunction
function Rqo takes integer oqx returns nothing
set zF[oqx]=.0
set ZF[oqx]=.0
call RPo(oqx)
set eg[(oqx)]=.0
set vg[(oqx)]=1.
call Bkx(oqx)
endfunction
function RQo takes integer oqx returns nothing
set Nfv[oqx]=(NFv[((uf[((oqx))]))])
endfunction
function Rso takes integer oqx,real oSx returns nothing
set NDv[oqx]=oSx-(Nfv[(oqx)])
set E_v[oqx]=oSx
endfunction
function RSo takes integer oqx returns nothing
call Rso(oqx,(Nfv[(oqx)])*(NGv[(oqx)])+(Ngv[(oqx)]))
endfunction
function Rto takes integer oqx returns nothing
set NDv[oqx]=.0
set E_v[oqx]=.0
call RQo(oqx)
set Ngv[(oqx)]=.0
set NGv[(oqx)]=1.
call RSo(oqx)
endfunction
function RTo takes integer oqx returns nothing
set Wg[oqx]=(Nhv[((uf[((oqx))]))])
endfunction
function Ruo takes integer oqx returns nothing
set yg[oqx]=.0
call RTo(oqx)
set jG[(oqx)]=.0
set Vrv[((oqx))]=(false)
set HG[(oqx)]=1.
call cKx(oqx)
endfunction
function RUo takes integer oqx returns nothing
set gF[oqx]=(NHv[((uf[((oqx))]))])
endfunction
function Rwo takes integer oqx returns nothing
set GF[oqx]=.0
call RUo(oqx)
set PF[(oqx)]=.0
set VHv[((oqx))]=(false)
set pF[(oqx)]=1.
call Bcx(oqx)
endfunction
function RWo takes integer oqx returns nothing
set kG[oqx]=(NJv[((uf[((oqx))]))])
endfunction
function Ryo takes integer oqx returns nothing
set iG[oqx]=(Njv[((uf[((oqx))]))])
call RWo(oqx)
set qG[(oqx)]=.0
set PG[(oqx)]=1.
call cqx(oqx)
endfunction
function RYo takes integer oqx returns nothing
set QF[oqx]=(NKv[((uf[((oqx))]))])
endfunction
function Rzo takes integer oqx returns nothing
set mF[oqx]=(Nkv[((uf[((oqx))]))])
call RYo(oqx)
set WF[(oqx)]=.0
set wF[(oqx)]=1.
call Bhx(oqx)
endfunction
function RZo takes integer oqx returns nothing
call DSx((((oqx))),(x_v),(1),w)
call UnitRemoveAbility(C[(((oqx)))],('Amov'))
endfunction
function R_o takes integer oqx returns nothing
set Nmv[oqx]=(Nlv[((uf[((oqx))]))])
endfunction
function R0o takes integer oqx returns nothing
set NMv[oqx]=.0
call rQx((oqx),'AmSx')
endfunction
function R1o takes integer oqx returns real
local real nwx=(Nqv[((oqx))])
if(nwx>0)then
return((NQv[(oqx)])*1./ nwx)
endif
return 1.
endfunction
function R2o takes integer oqx,real oSx returns real
if((Nqv[((oqx))])>0)then
set oSx=100.+(oSx-100.)*((1.2-.6)*R1o((oqx))+.6)
endif
set oSx=iOx(100.,oSx)
set oSx=itx(oSx,522.)
return oSx
endfunction
function R3o takes integer oqx,real oSx returns nothing
local real cvx=oSx-(Nmv[(oqx)])
local real R4o=(Nlv[((uf[((oqx))]))])
set NPv[oqx]=cvx
set NLv[oqx]=oSx
call SetUnitMoveSpeed(C[(oqx)],R2o(oqx,oSx)-jTx(cvx))
if(R4o>0)then
call SetUnitTimeScale(C[(oqx)],oSx*1./ R4o)
endif
endfunction
function R5o takes integer oqx returns nothing
call R3o(oqx,(Nmv[(oqx)])*(Npv[(oqx)])+(NMv[(oqx)]))
endfunction
function R6o takes integer oqx returns nothing
set NLv[oqx]=.0
call R_o(oqx)
call R0o(oqx)
set Npv[(oqx)]=1.
call R5o(oqx)
endfunction
function R7o takes integer oqx returns nothing
if((Nlv[((uf[((oqx))]))])>.0)then
set Vzv[(oqx)]=(true)
else
call RZo(oqx)
endif
call R6o(oqx)
endfunction
function R8o takes integer oqx returns nothing
set xb[oqx]=(Ntv[((uf[((oqx))]))])
endfunction
function R9o takes integer oqx returns nothing
set Nsv[(oqx)]=.0
set NSv[(oqx)]=60.
call R8o(oqx)
endfunction
function Ivo takes integer oqx returns nothing
set ob[oqx]=(Tj[((uf[((oqx))]))])
set tj[(oqx)]=.0
endfunction
function Ieo takes integer oqx returns nothing
local integer GLx=(uf[((oqx))])
set zJ[oqx]=(NTv[(GLx)])
set ZJ[oqx]=(Nuv[(GLx)])
set vk[oqx]=(NUv[(GLx)])
set ek[oqx]=(Nwv[(GLx)])
endfunction
function Ixo takes integer oqx returns nothing
call SetUnitMoveSpeed(C[(oqx)],R2o(oqx,(NLv[(oqx)]))-jTx((NPv[(oqx)])))
endfunction
function Ioo takes integer oqx returns nothing
call cbx((oqx),iqx("exhausted","ffffffff"),.021,NZv+oqx)
call DSx(((oqx)),(OHv),(1),w)
endfunction
function Iro takes integer oqx,real oSx returns nothing
local real nwx=(Nqv[((oqx))])
local real abx=(NQv[(oqx)])
set oSx=bJx(oSx,.0,(Nqv[((oqx))]))
set NQv[oqx]=oSx
call Ixo((oqx))
if(nwx<=0)then
return
endif
if(((oSx*1./ nwx)>Nzv)==((abx*1./ nwx)>Nzv))then
return
endif
if((oSx*1./ nwx)>Nzv)then
call UJx(((oqx)),OHv)
else
call Ioo(oqx)
endif
endfunction
function Iio takes integer oqx,real oSx returns nothing
local real abx=(Nqv[(oqx)])
set Nqv[oqx]=oSx
if(abx==.0)then
return
endif
call Iro((oqx),(NQv[((oqx))])*1./ abx*oSx)
endfunction
function Iao takes integer oqx returns nothing
call Iio(oqx,(NWv[(oqx)])*(NYv[(oqx)])+(Nyv[(oqx)]))
endfunction
function Ino takes integer oqx returns nothing
set Nqv[oqx]=.0
set NWv[(oqx)]=200.
set Nyv[(oqx)]=.0
set NYv[(oqx)]=1.
call Iao(oqx)
endfunction
function IVo takes integer oqx,integer oQx,integer oSx returns boolean
return rex(Eb[(oqx)],(Xb[((oqx))]),oQx,oSx)
endfunction
function IEo takes integer oqx,integer oSx returns nothing
if not(I5x((oqx),Rb,(oSx)))then
call oYx("UnitList_Remove","call DebugEx(UnitList.NAME + \" Remove: \" + value.GetName() + \" not in \" + this.GetName())",Rj+" Remove: "+(GetUnitName(C[(oSx)]))+" not in "+(Ij[(oqx)]))
return
endif
call IVo(oqx,Rb,oSx)
endfunction
function IXo takes integer oqx,real IOo returns nothing
local integer rkx=oqx
local integer rdx=rEx((A[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set bvv[(rdx)]=((IOo)*1.)
set Vv[(rdx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,bev,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,bev,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function IRo takes integer oqx,real IOo returns nothing
local integer rkx=oqx
local integer rdx=rEx((A[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set bvv[(rdx)]=((IOo)*1.)
set Vv[(rdx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,bxv,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,bxv,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function IIo takes nothing returns nothing
local integer rkx
local integer oqx
local real x
local real y
local real IOo
loop
set rkx=(dLx((N2v),Rb))
exitwhen(rkx==w)
set oqx=rkx
set x=DPx(rkx)
set y=DQx(rkx)
set IOo=Gyx(x-N5v[oqx],y-N6v[oqx])
call dpx(N7v,rkx)
if(I5x((N8v),Rb,(rkx)))then
if(IOo<N9v)then
call IEo(N8v,rkx)
call IXo(oqx,IOo)
endif
set N5v[oqx]=x
set N6v[oqx]=y
else
if(IOo>N9v)then
set N5v[oqx]=x
set N6v[oqx]=y
call dpx(N8v,rkx)
call IRo(oqx,IOo)
endif
endif
endloop
call dUx(N2v,N7v)
endfunction
function IAo takes integer oqx,integer Xwx returns nothing
local integer rkx=oqx
if not I8x(rkx,N0v+Xwx,1)then
return
endif
call I7x(rkx,Xwx)
if not I8x(rkx,N1v,1)then
return
endif
if(dKx((N2v),Rb))then
call icx(N3v,N4v,true,function IIo)
endif
set N5v[oqx]=DPx(rkx)
set N6v[oqx]=DQx(rkx)
call dpx(N2v,rkx)
endfunction
function INo takes integer oqx returns boolean
if((biv[((oqx))])>0)then
return false
endif
set bav=bav+1
set bnv[bav]=oqx
set biv[oqx]=bav+1
return(bav==0)
endfunction
function Ibo takes nothing returns nothing
local integer olx=bav
loop
exitwhen(olx<0)
set bEv[olx]=bnv[olx]
set olx=olx-1
endloop
set bXv=bav
endfunction
function IBo takes nothing returns integer
local integer o4x
if(bXv<0)then
return w
endif
set o4x=bEv[0]
set bEv[0]=bEv[bXv]
set bXv=bXv-1
return o4x
endfunction
function Ico takes integer oqx,real oSx returns nothing
call Iro(oqx,(NQv[(oqx)])+oSx)
endfunction
function ICo takes nothing returns nothing
local integer oqx
call Ibo()
loop
set oqx=IBo()
exitwhen(oqx==w)
call Ico((oqx),bOv[oqx])
endloop
endfunction
function Ido takes integer oqx,real oSx returns nothing
set bNv[oqx]=oSx
set bOv[oqx]=oSx*.25
endfunction
function IDo takes integer oqx returns nothing
call Ido(oqx,(bRv[(oqx)])*(bAv[(oqx)])+(bIv[(oqx)]))
endfunction
function Ifo takes integer oqx returns nothing
call I7x((oqx),N_v)
call IAo((oqx),bov)
call IAo((oqx),brv)
if INo(oqx)then
call icx(bVv,.25,true,function ICo)
endif
set bRv[(oqx)]=25.
set bIv[(oqx)]=.0
set bAv[(oqx)]=1.
call IDo(oqx)
endfunction
function IFo takes integer oqx returns nothing
local real oSx=(bbv[((uf[((oqx))]))])
local integer b7x=(R2I(((oSx)*1.)))
set tf[oqx]=oSx
call SetHeroAgi(C[(oqx)],b7x,true)
call btx(oqx,b7x)
endfunction
function Igo takes integer oqx returns nothing
set XF[oqx]=.0
set OF[oqx]=.0
set RF[oqx]=false
endfunction
function IGo takes integer oqx returns nothing
set fF[oqx]=.0
call Igo(oqx)
endfunction
function Iho takes integer oqx returns nothing
call Bex(oqx,(tf[(oqx)]))
endfunction
function IHo takes integer oqx returns nothing
set EF[oqx]=.0
call IFo(oqx)
call IGo(oqx)
set DF[(oqx)]=1.
call Iho(oqx)
call b8x(oqx)
call Bvx(oqx)
endfunction
function Ijo takes integer oqx returns nothing
local real oSx=(bBv[((uf[((oqx))]))])
local integer b7x=(R2I(((oSx)*1.)))
set FF[oqx]=oSx
call SetHeroInt(C[(oqx)],b7x,true)
call BLx(oqx,b7x)
endfunction
function IJo takes integer oqx returns nothing
set rg[oqx]=.0
set ig[oqx]=.0
set ag[oqx]=false
endfunction
function Iko takes integer oqx returns nothing
set Ng[oqx]=.0
call IJo(oqx)
endfunction
function IKo takes integer oqx returns nothing
call Byx(oqx,(FF[(oqx)]))
endfunction
function Ilo takes integer oqx returns nothing
set og[oqx]=.0
call Ijo(oqx)
call Iko(oqx)
set Ag[(oqx)]=1.
call IKo(oqx)
call BUx(oqx)
call BWx(oqx)
endfunction
function ILo takes integer oqx returns nothing
local real oSx=(bcv[((uf[((oqx))]))])
local integer b7x=(R2I(((oSx)*1.)))
set bg[oqx]=oSx
call SetHeroStr(C[(oqx)],b7x,true)
call cSx(oqx,b7x)
endfunction
function Imo takes integer oqx returns nothing
set SG[oqx]=.0
set tG[oqx]=.0
set TG[oqx]=false
endfunction
function IMo takes integer oqx returns nothing
set vh[oqx]=.0
call Imo(oqx)
endfunction
function Ipo takes integer oqx returns nothing
call c3x(oqx,(bg[(oqx)]))
endfunction
function IPo takes integer oqx returns nothing
set sG[oqx]=.0
call ILo(oqx)
call IMo(oqx)
set ZG[(oqx)]=1.
call Ipo(oqx)
call c0x(oqx)
call c2x(oqx)
endfunction
function Iqo takes integer oqx,integer oSx returns nothing
if(oSx==0)then
return
endif
call UnitModifySkillPoints(C[(oqx)],oSx)
endfunction
function IQo takes integer oqx returns nothing
set bCv[oqx]=0
call Iqo(oqx,-GetHeroSkillPoints(C[(oqx)]))
endfunction
function Iso takes integer oqx,integer oSx returns nothing
local integer abx=(bCv[(oqx)])
set bCv[oqx]=oSx
call UnitModifySkillPoints(C[(oqx)],oSx-abx)
endfunction
function ISo takes integer oqx,real oSx returns nothing
set I2v[oqx]=oSx
call OKo((oqx))
endfunction
function Ito takes integer oqx,real oSx returns nothing
call ISo(oqx,(I2v[(oqx)])+oSx)
endfunction
function ITo takes integer oqx,integer oSx returns nothing
call Iso(oqx,(bCv[(oqx)])+oSx)
endfunction
function Iuo takes integer oqx,integer abx,integer oSx returns nothing
local integer GLx=(uf[((oqx))])
call bCx((oqx),bDv[0+oSx])
set oSx=oSx-abx
call Dwx((oqx),oSx*bfv)
call Bxx((oqx),oSx*(bFv[(GLx)]))
call Ito((oqx),oSx*(bgv[(GLx)]))
call BYx((oqx),oSx*(bGv[(GLx)]))
call ITo((oqx),oSx)
call c4x((oqx),oSx*(bhv[(GLx)]))
endfunction
function IUo takes integer oqx returns nothing
local integer oSx=(GetHeroLevel(C[((oqx))]))
call Iso((oqx),1)
set bdv[oqx]=oSx
call Iuo(oqx,1,oSx)
call dpx(bHv,(oqx))
endfunction
function Iwo takes integer oqx returns integer
set bmv[oqx]=true
set bMv[oqx]=false
call rax(Vmv)
return oqx
endfunction
function IWo takes nothing returns integer
local integer oqx
if(bkv==8190)then
call oYx("FolderUnit_FolderMovement_FolderEvents_StructInterval_Allocation_allocCustom","call DebugEx(FolderUnit_FolderMovement_FolderEvents_StructInterval.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",VMv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(bKv[(w)]==w)then
set blv=blv+1
set oqx=blv
else
set oqx=bKv[(w)]
set bKv[(w)]=bKv[bKv[(w)]]
endif
set bKv[oqx]=Z
set bLv[oqx]=1
call Iwo(oqx)
return oqx
endfunction
function Iyo takes integer oqx,integer Xwx,real pZx returns nothing
local integer rkx=oqx
local integer p0x
set oqx=FMx(Xwx,bJv+rkx)
if(oqx!=w)then
call oYx("FolderUnit_FolderMovement_FolderEvents_StructInterval_Add","call DebugEx(\"already listed \" + whichEvent.GetName() + \";\" + parent.GetName())","already listed "+(JA[(Xwx)])+";"+(GetUnitName(C[(rkx)])))
return
endif
set oqx=IWo()
set p0x=inx()
set bpv[oqx]=pZx
set bPv[oqx]=p0x
set bqv[oqx]=rkx
set bQv[oqx]=Xwx
set ge[(p0x)]=(oqx)
if rtx(rkx,bsv,oqx)then
call IAo(rkx,bSv)
call IAo(rkx,btv)
endif
call pyx(Xwx,bJv+rkx,oqx)
endfunction
function IYo takes integer oqx returns nothing
set NQv[oqx]=(Nqv[((oqx))])
call I7x((oqx),bjv)
call Iyo((oqx),bTv,.125)
endfunction
function Izo takes integer oqx returns boolean
set b0v=b0v+1
set b1v[b0v]=oqx
set b2v[oqx]=b0v+1
return(b0v==0)
endfunction
function IZo takes nothing returns nothing
local real N8x=GetCameraField(CAMERA_FIELD_ROTATION)-b6v
local real I_o=(Cos(((((N8x)*1.))*1.)))
local real I0o=(Sin(((((N8x)*1.))*1.)))
local integer olx=b0v
local integer oqx
local real I1o
local real x
local real I2o
local real y
local real I3o
local real I4o
loop
set oqx=b1v[olx]
if I6x((oqx),sc)then
set b7v[oqx]=.0
set b8v[oqx]=.0
call MoveLightningEx(buv[oqx],false,.0,.0,.0,.0,.0,.0)
call MoveLightningEx(bUv[oqx],false,.0,.0,.0,.0,.0,.0)
call MoveLightningEx(byv[oqx],false,.0,.0,.0,.0,.0,.0)
call MoveLightningEx(bYv[oqx],false,.0,.0,.0,.0,.0,.0)
else
set I1o=fwx((oqx))+175.*(ob[((oqx))])
set x=DPx((oqx))
set I2o=60.*I_o
set y=DQx((oqx))
set I3o=60.*I0o
set I4o=(ce[(x7v[oqx])])
if(I4o>.0)then
set I4o=(TimerGetRemaining(Oe[(x7v[oqx])]))*1./ I4o
call MoveLightningEx(x8v[oqx],false,x-I2o*1.5,y-I3o*1.5,I1o+75,x+I2o*1.5,y+I3o*1.5,I1o+75)
call SetLightningColor(x8v[oqx],1.,1.,1.,1.)
call MoveLightningEx(x9v[oqx],false,x-I2o*1.5,y-I3o*1.5,I1o+75,x+(I4o*2-1)*I2o*1.5,y+(I4o*2-1)*I3o*1.5,I1o+75)
call SetLightningColor(x9v[oqx],.0,.75,1.,1.)
endif
set I4o=(LF[((oqx))])*1./(mF[((oqx))])
set I4o=b7v[oqx]+(I4o-b7v[oqx])*b9v
set b7v[oqx]=I4o
if(I4o>.9)then
call MoveLightningEx(buv[oqx],false,.0,.0,.0,.0,.0,.0)
call MoveLightningEx(bUv[oqx],false,.0,.0,.0,.0,.0,.0)
else
call MoveLightningEx(buv[oqx],false,x-I2o,y-I3o,I1o+50,x+I2o,y+I3o,I1o+50)
call SetLightningColor(buv[oqx],1.,1.,1.,bJx(Bvv*I4o+Bev,itx(1.,.15),iOx(1.,.15)))
call MoveLightningEx(bUv[oqx],false,x-I2o,y-I3o,I1o+50,x+(I4o*2-1)*I2o,y+(I4o*2-1)*I3o,I1o+50)
call SetLightningColor(bUv[oqx],1.,.0,1.,bJx(Bvv*I4o+Bev,itx(1.,.15),iOx(1.,.15)))
endif
set I4o=(Zf[((oqx))])*1./(zf[((oqx))])
set I4o=Bxv[oqx]+(I4o-Bxv[oqx])*b9v
set Bxv[oqx]=I4o
if(I4o>.9)then
call MoveLightningEx(bwv[oqx],false,.0,.0,.0,.0,.0,.0)
call MoveLightningEx(bWv[oqx],false,.0,.0,.0,.0,.0,.0)
else
call MoveLightningEx(bwv[oqx],false,x-I2o,y-I3o,I1o,x+I2o,y+I3o,I1o)
call SetLightningColor(bwv[oqx],1.,1.,1.,bJx(Bvv*I4o+Bev,itx(1.,.15),iOx(1.,.15)))
call MoveLightningEx(bWv[oqx],false,x-I2o,y-I3o,I1o,x+(I4o*2-1)*I2o,y+(I4o*2-1)*I3o,I1o)
call SetLightningColor(bWv[oqx],.83,.37,.1,bJx(Bvv*I4o+Bev,itx(1.,.15),iOx(1.,.15)))
endif
set I4o=(NQv[((oqx))])*1./(Nqv[((oqx))])
set I4o=b8v[oqx]+(I4o-b8v[oqx])*b9v
set b8v[oqx]=I4o
if(I4o>.9)then
call MoveLightningEx(byv[oqx],false,.0,.0,.0,.0,.0,.0)
call MoveLightningEx(bYv[oqx],false,.0,.0,.0,.0,.0,.0)
else
call MoveLightningEx(byv[oqx],false,x-I2o,y-I3o,I1o,x+I2o,y+I3o,I1o)
call SetLightningColor(byv[oqx],1.,1.,1.,bJx(Bvv*I4o+Bev,itx(1.,.15),iOx(1.,.15)))
call MoveLightningEx(bYv[oqx],false,x-I2o,y-I3o,I1o,x+(I4o*2-1)*I2o,y+(I4o*2-1)*I3o,I1o)
call SetLightningColor(bYv[oqx],1.,1.,.0,bJx(Bvv*I4o+Bev,itx(1.,.15),iOx(1.,.15)))
endif
endif
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function I5o takes integer oqx returns nothing
set x8v[oqx]=AddLightningEx("oBaB",false,.0,.0,.0,.0,.0,.0)
set x9v[oqx]=AddLightningEx("oBaJ",false,.0,.0,.0,.0,.0,.0)
set x7v[oqx]=inx()
set buv[oqx]=AddLightningEx("oBaB",false,.0,.0,.0,.0,.0,.0)
set bUv[oqx]=AddLightningEx("oBaJ",false,.0,.0,.0,.0,.0,.0)
set bwv[oqx]=AddLightningEx("oBaB",false,.0,.0,.0,.0,.0,.0)
set bWv[oqx]=AddLightningEx("oBaJ",false,.0,.0,.0,.0,.0,.0)
set byv[oqx]=AddLightningEx("oBaB",false,.0,.0,.0,.0,.0,.0)
set bYv[oqx]=AddLightningEx("oBaJ",false,.0,.0,.0,.0,.0,.0)
call I7x((oqx),bzv)
call I7x((oqx),bZv)
call I7x((oqx),b_v)
if Izo(oqx)then
call icx(b3v,b4v,true,function IZo)
endif
endfunction
function I6o takes integer oqx returns nothing
local real oSx=(iG[((oqx))])
set rG[oqx]=oSx
call SetWidgetLife(C[(oqx)],oSx)
endfunction
function I7o takes integer oqx returns nothing
local real oSx=(mF[((oqx))])
set LF[oqx]=oSx
call SetUnitState(C[(oqx)],UNIT_STATE_MANA,oSx)
endfunction
function I8o takes integer oqx returns nothing
call dpx(Bov,(oqx))
call dpx(Brv,(oqx))
call dpx(Biv,(oqx))
call dpx(Bav,(oqx))
endfunction
function I9o takes integer oqx returns nothing
set Oh[oqx]=w
set Vh[oqx]=false
call TriggerRegisterUnitEvent(fA[((pb))],C[(oqx)],(EVENT_UNIT_ISSUED_ORDER))
endfunction
function Avo takes integer oqx returns nothing
set cj[oqx]=w
set Eh[oqx]=false
call TriggerRegisterUnitEvent(fA[((Bh))],C[(oqx)],(EVENT_UNIT_ISSUED_POINT_ORDER))
endfunction
function Aeo takes integer oqx returns nothing
set fj[oqx]=w
set Xh[oqx]=false
call TriggerRegisterUnitEvent(fA[((BVv))],C[(oqx)],(EVENT_UNIT_ISSUED_TARGET_ORDER))
endfunction
function Axo takes integer oqx returns nothing
call I9o(oqx)
call Avo(oqx)
call Aeo(oqx)
endfunction
function Aoo takes integer oqx returns nothing
call dpx(YH,oqx)
call I7x((oqx),BEv)
if(dmx((oqx))==w)then
return
endif
call dWx(oqx)
endfunction
function Aro takes integer oqx returns nothing
call Axo(oqx)
call Aoo(oqx)
endfunction
function Aio takes integer oqx returns nothing
set zH[oqx]=w
call I7x((oqx),Bnv)
call Aro(oqx)
endfunction
function Aao takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((BRv[oqx]))])]))],((((gw[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function Ano takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((BRv[oqx]))])]))],((((gw[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function AVo takes integer oqx returns nothing
local integer GLx=(uf[(oqx)])
local integer rdx=rEx(0)
local integer EHo
local integer olx
local integer rIx
local integer rlx
set Vv[(rdx)]=(oqx)
set BOv[(rdx)]=(GLx)
set EHo=rEx((A[(oqx)]))
set Vv[(EHo)]=(oqx)
set BOv[(EHo)]=(GLx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Igv))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Igv))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set rlx=Aao(GLx,Igv,rIx)
loop
exitwhen(rlx<q)
call rCx(Ano(GLx,Igv,rIx,rlx),EHo)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call rHx(((EHo)))
endfunction
function AEo takes integer bXx,unit oMx returns integer
local integer GLx=XZo(GetUnitTypeId(oMx))
local integer oqx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((oMx)))))),((((ix))))))
local integer AXo=a3x("Unit.CreateBasic: "+(ib[(bXx)])+";"+GetUnitName(oMx)+";"+I2S(oqx)+";"+(GetObjectName(IGv[(GLx)])))
local boolean QPx
if(oqx!=0)then
call oYx("Unit_CreateBasic","call DebugEx(\"Unit.CreateBasic: unit \" + this.GetName() + \" already registered\")","Unit.CreateBasic: unit "+(GetUnitName(C[(oqx)]))+" already registered")
return oqx
endif
if(GLx==w)then
call oYx("Unit_CreateBasic","call DebugEx(\"Unit.CreateBasic: null type\")","Unit.CreateBasic: null type")
return w
endif
call X_o(AXo,"A")
set oqx=X1o()
set Pc[oqx]=false
set C[oqx]=oMx
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oMx))))),((((ix)))),((((oqx)))))
call dpx(Mj,oqx)
call X2o(oqx)
call X3o(oqx)
call X_o(AXo,"B")
call X4o(((oqx)),1.)
call X5o(oqx)
call X7o(oqx)
call X8o(oqx)
call Ovo(oqx)
call Oeo(oqx)
set nwv[((oqx))]=(false)
set Iqv[((oqx))]=((1.)*1.)
call Oxo(oqx)
set aav[((oqx))]=(false)
set IQv[((oqx))]=((.0)*1.)
set Ze[((oqx))]=(false)
call Ooo(oqx)
set Isv[((oqx))]=((.0)*1.)
call Oro(oqx,bXx)
set XOv[((oqx))]=(true)
call Oio((oqx))
set XJv[((oqx))]=(false)
set Mh[((oqx))]=(false)
set O0v[((oqx))]=(false)
call Oao(oqx)
call X_o(AXo,"C")
call Odo(oqx)
call X_o(AXo,"C2")
call Olo(oqx)
call X_o(AXo,"C3")
call OQo(oqx)
call X_o(AXo,"C4")
call O9o(oqx)
call X_o(AXo,"C5")
call Rvo(oqx)
call X_o(AXo,"C6")
call Reo(oqx)
call X_o(AXo,"C7")
call Rio(oqx)
call X_o(AXo,"C8")
call Rao(oqx)
call X_o(AXo,"C9")
call Rbo(oqx)
call X_o(AXo,"C10")
call RBo(oqx)
call X_o(AXo,"C11")
call RCo(oqx)
call X_o(AXo,"C12")
call RGo(oqx)
call X_o(AXo,"C13")
call Rho(oqx)
call X_o(AXo,"C14")
call Rjo(oqx)
call X_o(AXo,"C15")
call RKo(oqx)
call X_o(AXo,"C16")
call Rpo(oqx)
call X_o(AXo,"C17")
call Rqo(oqx)
call X_o(AXo,"C18")
call Rto(oqx)
call X_o(AXo,"D")
call Ruo(oqx)
call Rwo(oqx)
call Ryo(oqx)
call Rzo(oqx)
call R7o(oqx)
call R9o(oqx)
call Ivo(oqx)
call Ieo(oqx)
call X_o(AXo,"E")
set EEv[((oqx))]=(false)
set Epv[((oqx))]=(false)
set ncv[((oqx))]=(false)
set Efv[((oqx))]=(false)
set E9v[((oqx))]=(false)
set XBv[((oqx))]=(false)
call Dtx((oqx))
set Ejv[((oqx))]=(false)
set QPx=I6x(oqx,yd)
call X_o(AXo,"F")
if QPx then
call X_o(AXo,"F1")
call Ino(oqx)
call Ifo(oqx)
call X_o(AXo,"F2")
call IHo(oqx)
call Ilo(oqx)
call IPo(oqx)
call X_o(AXo,"F3")
call IQo(oqx)
call X_o(AXo,"F4")
call IUo(oqx)
call X_o(AXo,"F5")
call IYo(oqx)
call X_o(AXo,"F6")
call I5o(oqx)
call X_o(AXo,"F7")
else
call X_o(AXo,"F8")
if not I6x(oqx,IFv)then
call X_o(AXo,"F9")
call Abx((oqx),("Units\\Aura.mdx"),("origin"),(Bi))
call X_o(AXo,"F10")
call HDx(oqx)
call X_o(AXo,"F11")
endif
endif
call X_o(AXo,"G")
call I6o(oqx)
call I7o(oqx)
call X_o(AXo,"H")
call I8o((oqx))
call X_o(AXo,"H2")
call Aio(oqx)
call X_o(AXo,"I")
if BXv then
call AVo(oqx)
endif
call X_o(AXo,"J")
call a1x(AXo)
return oqx
endfunction
function AOo takes nothing returns boolean
set Ib=AEo(Hf,afx(vx[Hf],IGv[jf],gf,Gf,hf*gy))
return true
endfunction
function ARo takes nothing returns boolean
set Ib=AEo(omx(GetOwningPlayer(C[Db])),C[Db])
return true
endfunction
function AIo takes integer oqx returns nothing
local integer olx=(CXx(((oqx)),Q))
loop
exitwhen(olx<q)
call rLx(oqx,(COx(((oqx)),Q,(olx))))
set olx=olx-1
endloop
endfunction
function AAo takes integer oqx returns nothing
call IEo(ITv,(oqx))
call IEo(Iuv,(oqx))
call IEo(IUv,(oqx))
endfunction
function ANo takes integer oqx returns nothing
call IEo(Bov,(oqx))
call IEo(Brv,(oqx))
call IEo(Biv,(oqx))
call IEo(Bav,(oqx))
endfunction
function Abo takes integer oqx returns nothing
if not(I5x((bHv),Rb,(oqx)))then
return
endif
call IEo(bHv,oqx)
endfunction
function ABo takes integer oqx returns nothing
local integer rdx=rEx(0)
local integer EHo
local integer olx
local integer rIx
local integer rlx
set Vv[(rdx)]=(oqx)
set EHo=rEx((A[(oqx)]))
set Vv[(EHo)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((EP))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call ajx("triggerStatic "+(JA[((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((EP))-1)*Iv+(((rIx))-1))))+((rlx)))))))]))
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((EP))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set rlx=rOx(oqx,EP,rIx)
loop
exitwhen(rlx<q)
call ajx("trigger "+(JA[(rDx(oqx,EP,rIx,rlx))]))
call rCx(rDx(oqx,EP,rIx,rlx),EHo)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call rHx(((EHo)))
call AAo(oqx)
call IEo(ARv,(oqx))
call IEo(AZv,((oqx)))
call IEo(A1v,(oqx))
call ANo(oqx)
call Abo(oqx)
endfunction
function Aco takes integer oqx returns boolean
if((JT[(oqx)])>0)then
set kT[oqx]=true
return false
endif
return true
endfunction
function ACo takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((I[oqx]))])])],((((A[((oqx))])))))
endfunction
function Ado takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((Rv[oqx]))])])],((((A[((oqx))])))))
endfunction
function ADo takes integer oqx returns nothing
set Ikv[oqx]=false
call ACo((oqx))
call Ado(((oqx)))
call rgx(R7v)
endfunction
function Afo takes integer oqx returns nothing
if(IJv[oqx]>0)then
return
endif
if(IHv[oqx]!=Z)then
call oYx("Unit_Allocation_deallocCustom_confirm","call DebugEx(Unit.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",R8v+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set IHv[oqx]=IHv[(w)]
set IHv[(w)]=oqx
call ADo(oqx)
endfunction
function AFo takes integer oqx returns nothing
set IJv[oqx]=IJv[oqx]-1
call Afo(oqx)
endfunction
function Ago takes nothing returns boolean
local integer oqx=Ib
local unit oMx
if Pc[oqx]then
return true
endif
set oMx=C[oqx]
set Pc[oqx]=true
call IEo(Mj,oqx)
call AIo(oqx)
call ABo(oqx)
if not Aco(oqx)then
call ShowUnit(C[oqx],false)
return true
endif
call AFo((oqx))
call SaveInteger(o[(((V[((E[((X))]))])))],(((GetHandleId(((oMx)))))),(((((ix))))),(0))
call Mcx(oMx)
set oMx=null
return true
endfunction
function AGo takes nothing returns boolean
return( not((uf[(jFx())])!=jf))
endfunction
function Aho takes integer oqx,integer AHo,integer Ajo returns nothing
local integer rkx=oqx
local integer rdx=rEx(0)
local integer Rrx
local integer olx
local integer rIx
local integer rlx
set Vv[(rdx)]=(rkx)
set BNv[(rdx)]=(AHo)
set Bbv[(rdx)]=(Ajo)
set BOv[(rdx)]=(Ajo)
set Rrx=rEx((A[(rkx)]))
set Vv[(Rrx)]=(rkx)
set BNv[(Rrx)]=(AHo)
set Bbv[(Rrx)]=(Ajo)
set BOv[(Rrx)]=(Ajo)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((OP))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((OP))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set rlx=rOx(rkx,OP,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,OP,rIx,rlx),Rrx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call rHx(((Rrx)))
endfunction
function AJo takes integer oqx,integer Ajo returns nothing
local integer AHo=(uf[(oqx)])
set uf[oqx]=Ajo
if((AHo==w)or(AHo==Ajo))then
return
endif
call Aho(oqx,AHo,Ajo)
endfunction
function Ako takes nothing returns boolean
local integer oqx=aBx(GetTriggerUnit())
call AJo(oqx,XZo(GetUnitTypeId(GetTriggerUnit())))
call Cbx((oqx))
return true
endfunction
function AKo takes nothing returns nothing
set OP=(E0x())
call Q2x(Xhx(function Ako),Ge,EVENT_PLAYER_UNIT_UPGRADE_FINISH,null)
endfunction
function Alo takes nothing returns boolean
local integer rdx=(bv)
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
local integer olx=Omo(Ajo)
loop
exitwhen(olx<q)
call Abx((((oqx))),((Opo(Ajo,olx))),((OPo(Ajo,olx))),((Oqo(Ajo,olx))))
set olx=olx-1
endloop
return true
endfunction
function ALo takes nothing returns boolean
local integer rdx=(bv)
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
set EQv[(oqx)]=((Amv[(Ajo)]))
return true
endfunction
function Amo takes nothing returns boolean
local integer rdx=(bv)
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
set nFv[(oqx)]=((nGv[(Ajo)]))
return true
endfunction
function AMo takes integer oqx,integer rRx returns nothing
if not I6x(oqx,rRx)then
call oYx("FolderUnit_StructClasses_Remove","call DebugEx(FolderUnit_StructClasses.NAME + \": cannot remove class \" + whichType.GetName() + \" from \" + Unit(this).GetName())",ozv+": cannot remove class "+(IVv[(rRx)])+" from "+(GetUnitName(C[((oqx))])))
return
endif
call IEo(Qc[(rRx)],oqx)
endfunction
function Apo takes integer oqx returns nothing
local integer olx=IEv
loop
exitwhen(olx<0)
if I6x(oqx,IXv[olx])then
call AMo(oqx,IXv[olx])
endif
set olx=olx-1
endloop
endfunction
function APo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
call Rmx(rkx,APv)
call Apo(oqx)
return true
endfunction
function Aqo takes nothing returns boolean
local integer rdx=(bv)
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
local integer olx=Rxo(Ajo)
call Apo(oqx)
loop
exitwhen(olx<q)
call Roo(oqx,Rro(Ajo,olx))
set olx=olx-1
endloop
return true
endfunction
function AQo takes integer OBo returns integer
local integer oqx=OBo
set Qc[oqx]=JIx("FolderUnit_StructClasses_Create: set this.dummyGroup = UnitList.Create()")
return oqx
endfunction
function Aso takes nothing returns nothing
local integer olx=IEv
set APv=XBx("FolderUnit_StructClasses_Init: set FolderUnit_StructClasses.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructClasses.Event_Destroy)",EP,BI,function APo)
call DNx(XBx("FolderUnit_StructClasses_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructClasses.Event_TypeChange).AddToStatics()",OP,BI,function Aqo))
loop
exitwhen(olx<0)
call AQo(IXv[olx])
set olx=olx-1
endloop
endfunction
function ASo takes integer oqx,real oSx,boolean Omx returns nothing
set tH[(oqx)]=((dvx(oqx,false)+oSx)*1.)
endfunction
function Ato takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
call ASo(oqx,(Aqv[(Ajo)])-(Aqv[(AHo)]),true)
return true
endfunction
function ATo takes integer oqx returns integer
set Bgv[oqx]=true
set BGv[oqx]=false
call rax(Bhv)
return oqx
endfunction
function Auo takes nothing returns integer
local integer oqx
if(BCv==8190)then
call oYx("UnitState_Allocation_allocCustom","call DebugEx(UnitState.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Bdv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(BDv[(w)]==w)then
set Bfv=Bfv+1
set oqx=Bfv
else
set oqx=BDv[(w)]
set BDv[(w)]=BDv[BDv[(w)]]
endif
set BDv[oqx]=Z
set BFv[oqx]=1
call ATo(oqx)
return oqx
endfunction
function AUo takes string rqx,code iDx returns integer
local integer oqx=Auo()
set ac[(oqx)]=(Xhx(iDx))
set BHv[(oqx)]=(rqx)
return oqx
endfunction
function Awo takes nothing returns boolean
local integer rdx=(bv)
call bLx(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function AWo takes nothing returns nothing
set BBv=(E0x())
set Bcv=AUo(r6v,function Awo)
endfunction
function Ayo takes integer rkx returns boolean
return(I5x((AZv),Rb,(rkx)))
endfunction
function AYo takes integer oqx returns nothing
set JT[oqx]=(JT[(oqx)])+1
endfunction
function Azo takes integer oqx,integer oQx returns boolean
return(LoadBoolean(o[((V[(E[((oA[(oqx)]))])]))],((((nA[((oqx))])))),(((oQx)))))
endfunction
function AZo takes integer oqx,integer Xwx returns boolean
return((LoadInteger(o[((D[((Rv[oqx]))]))],((((A[((oqx))])))),(osx((((rA[(Xwx)]))),(((Xwx)))))))!=0)
endfunction
function A_o takes integer oqx,integer cCx returns nothing
local integer rkx=oqx
local integer A0o=rEx((A[(cCx)]))
local integer rdx
local integer EHo
local integer array A1o
local integer A2o
local integer array A3o
local integer olx
local integer rIx
local integer rlx
set WH[(A0o)]=(rkx)
set Vv[(A0o)]=(cCx)
set rdx=rEx(0)
set FG[(rdx)]=(cCx)
set Vv[(rdx)]=(rkx)
set EHo=rEx((A[(rkx)]))
set FG[(EHo)]=(cCx)
set Vv[(EHo)]=(rkx)
set A2o=F
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((VP))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
set A2o=A2o+1
set A1o[A2o]=(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((VP))-1)*Iv+(((rIx))-1))))+((rlx))))))
set A3o[A2o]=0
set rlx=rlx-1
endloop
set rlx=rOx(cCx,Bkv,rIx)
loop
exitwhen(rlx<q)
set A2o=A2o+1
set A1o[A2o]=rDx(cCx,Bkv,rIx,rlx)
set A3o[A2o]=1
set rlx=rlx-1
endloop
set rlx=rOx(rkx,VP,rIx)
loop
exitwhen(rlx<q)
set A2o=A2o+1
set A1o[A2o]=rDx(rkx,VP,rIx,rlx)
set A3o[A2o]=2
set rlx=rlx-1
endloop
set olx=olx-1
endloop
set olx=0
loop
exitwhen(olx>A2o)
if(A3o[olx]==0)then
if(Azo((A1o[olx]),kj))then
call rCx(A1o[olx],rdx)
if not I6x((oqx),sc)then
return
endif
endif
elseif(A3o[olx]==1)then
if AZo(cCx,A1o[olx])then
call rCx(A1o[olx],A0o)
if not I6x((oqx),sc)then
return
endif
endif
else
if AZo(rkx,A1o[olx])then
call rCx(A1o[olx],EHo)
if not I6x(rkx,sc)then
return
endif
endif
endif
set olx=olx+1
endloop
call rHx(((A0o)))
call rHx(((rdx)))
call rHx(((EHo)))
endfunction
function A4o takes integer oqx returns nothing
set Bpv[oqx]=false
call rgx(Ep)
endfunction
function A5o takes integer oqx returns nothing
if(Bmv[oqx]>0)then
return
endif
if(BMv[oqx]!=Z)then
call oYx("SpotEffectWithSize_Allocation_deallocCustom_confirm","call DebugEx(SpotEffectWithSize.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Xp+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set BMv[oqx]=BMv[(w)]
set BMv[(w)]=oqx
call A4o(oqx)
endfunction
function A6o takes integer oqx returns nothing
set Bmv[oqx]=Bmv[oqx]-1
call A5o(oqx)
endfunction
function A7o takes integer oqx returns nothing
local integer HOx=Blv[oqx]
local effect oMx=BLv[oqx]
call A6o((oqx))
call Mfx(HOx)
call DestroyEffect(oMx)
set oMx=null
endfunction
function A8o takes integer oqx returns integer
set Bpv[oqx]=true
set BQv[oqx]=false
call rax(Ep)
return oqx
endfunction
function A9o takes nothing returns integer
local integer oqx
if(BPv==8190)then
call oYx("SpotEffectWithSize_Allocation_allocCustom","call DebugEx(SpotEffectWithSize.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Xp+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(BMv[(w)]==w)then
set Bqv=Bqv+1
set oqx=Bqv
else
set oqx=BMv[(w)]
set BMv[(w)]=BMv[BMv[(w)]]
endif
set BMv[oqx]=Z
set Bmv[oqx]=1
call A8o(oqx)
return oqx
endfunction
function Nvo takes real x,real y,string ARx,integer rwx,real Neo returns integer
local integer oqx=A9o()
local integer HOx=mcx('qEWS',x,y,XYx(x,y),Bsv)
set Blv[oqx]=HOx
set BLv[oqx]=AddSpecialEffectTarget(iQx(ci>=rwx,ARx),zj[HOx],"origin")
call mbx(HOx,Neo)
return oqx
endfunction
function Nxo takes integer oqx,real x,real y returns nothing
local string ARx=(nFv[((oqx))])
if(ARx!=null)then
call A7o(Nvo(x,y,BSv,ri,(ob[((oqx))])))
endif
endfunction
function Noo takes integer a,integer b returns integer
local integer oqx=(LoadInteger(o[((SA))],(a),(b)))
if(oqx==0)then
set oqx=Xlx()
set Bv[oqx]=And(Bv[a],Bv[b])
call SaveInteger(o[((SA))],(a),(b),(oqx))
endif
return oqx
endfunction
function Nro takes integer oqx,real x,real y,real j8x,integer Q4x returns nothing
call GroupEnumUnitsInRange(Kb[(oqx)],x,y,j8x,Bv[Q4x])
endfunction
function Nio takes integer oqx,real x,real y,real j8x,integer Q4x returns nothing
if(Q4x==w)then
set Q4x=GK
endif
set Q4x=Noo(MQ,Q4x)
set qQ=j8x
set pQ=x
set PQ=y
call Nro((oqx),x,y,j8x+Bwv,Q4x)
endfunction
function Nao takes integer oqx returns integer
local integer o4x=(aBx(FirstOfGroup(Kb[(oqx)])))
if(o4x==w)then
return w
endif
call GroupRemoveUnit(Kb[(oqx)],C[(o4x)])
return o4x
endfunction
function Nno takes integer oqx,integer NVo returns nothing
local integer NEo
loop
set NEo=Nao(NVo)
exitwhen(NEo==w)
call GroupAddUnit(Kb[(oqx)],C[(NEo)])
endloop
endfunction
function NXo takes integer oqx returns integer
local integer o4x=0
local integer Xko
loop
set Xko=Nao((oqx))
exitwhen(Xko==w)
call GroupAddUnit(Kb[(BQ)],C[(Xko)])
set o4x=o4x+1
endloop
call Nno((oqx),BQ)
return o4x
endfunction
function NOo takes integer oqx,integer Ixx,real nyx,boolean nFo returns real
return nfo(oqx,Ixx,nyx,nFo)
endfunction
function NRo takes integer oqx,integer cCx returns nothing
local real NIo=(iG[((oqx))])*BKv
local integer NAo=(ze[(cCx)])
local real x=DPx((oqx))
local real y=DQx((oqx))
local integer NNo
local integer o7x
local integer Ixx
call Nxo(oqx,x,y)
if(((Btv[(NAo)])!=BTv)or(NAo==Buv)or(NAo==BUv))then
return
endif
set NNo=O2x()
set Hf=(ze[(cCx)])
call Nio(NNo,x,y,dvx((oqx),true)*5,BWv)
set o7x=(NXo((NNo)))
if(o7x>0)then
set NIo=NIo*1./ o7x
loop
set Ixx=Nao(NNo)
exitwhen(Ixx==w)
call NOo(cCx,Ixx,NIo,false)
endloop
endif
endfunction
function Nbo takes integer oqx returns integer
set B_v[oqx]=true
set B0v[oqx]=false
call rax(np)
return oqx
endfunction
function NBo takes nothing returns integer
local integer oqx
if(Byv==8190)then
call oYx("FolderSpotEffectWithSize_StructDestroyTimed_Allocation_allocCustom","call DebugEx(FolderSpotEffectWithSize_StructDestroyTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Vp+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(BYv[(w)]==w)then
set Bzv=Bzv+1
set oqx=Bzv
else
set oqx=BYv[(w)]
set BYv[(w)]=BYv[BYv[(w)]]
endif
set BYv[oqx]=Z
set BZv[oqx]=1
call Nbo(oqx)
return oqx
endfunction
function Nco takes integer oqx returns nothing
set B_v[oqx]=false
call rgx(np)
endfunction
function NCo takes integer oqx returns nothing
if(BZv[oqx]>0)then
return
endif
if(BYv[oqx]!=Z)then
call oYx("FolderSpotEffectWithSize_StructDestroyTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderSpotEffectWithSize_StructDestroyTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Vp+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set BYv[oqx]=BYv[(w)]
set BYv[(w)]=oqx
call Nco(oqx)
endfunction
function Ndo takes integer oqx returns nothing
set BZv[oqx]=BZv[oqx]-1
call NCo(oqx)
endfunction
function NDo takes nothing returns nothing
local integer ibx=ifx()
local integer oqx=(ge[(ibx)])
local integer rkx=B1v[oqx]
call Ndo((oqx))
call ijx(ibx)
call A7o(rkx)
endfunction
function Nfo takes integer oqx,real ilx returns nothing
local integer rkx=oqx
local integer ibx
set oqx=NBo()
set ibx=inx()
set B1v[oqx]=rkx
set ge[(ibx)]=(oqx)
call icx(ibx,ilx,false,function NDo)
endfunction
function NFo takes integer oqx,real x,real y returns nothing
local string ARx=(AMv[((oqx))])
if(ARx!=null)then
call Nfo(Nvo(x,y,ARx,ri,(ob[((oqx))])),5.)
endif
endfunction
function Ngo takes integer oqx,integer cCx returns nothing
if(ixv[(oqx)])then
call NRo(oqx,cCx)
elseif I6x((oqx),Idv)then
call NFo(oqx,DPx((oqx)),DQx((oqx)))
endif
endfunction
function NGo takes integer oqx returns nothing
call OTx((oqx))
endfunction
function Nho takes integer oqx returns integer
set B6v[oqx]=true
set B7v[oqx]=false
call rax(iAv)
return oqx
endfunction
function NHo takes nothing returns integer
local integer oqx
if(B2v==8190)then
call oYx("FolderUnit_FolderDecay_StructTimed_Allocation_allocCustom","call DebugEx(FolderUnit_FolderDecay_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",iNv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(B3v[(w)]==w)then
set B4v=B4v+1
set oqx=B4v
else
set oqx=B3v[(w)]
set B3v[(w)]=B3v[B3v[(w)]]
endif
set B3v[oqx]=Z
set B5v[oqx]=1
call Nho(oqx)
return oqx
endfunction
function Njo takes integer oqx returns nothing
set B6v[oqx]=false
call rgx(iAv)
endfunction
function NJo takes integer oqx returns nothing
if(B5v[oqx]>0)then
return
endif
if(B3v[oqx]!=Z)then
call oYx("FolderUnit_FolderDecay_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderDecay_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",iNv+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set B3v[oqx]=B3v[(w)]
set B3v[(w)]=oqx
call Njo(oqx)
endfunction
function Nko takes integer oqx returns nothing
set B5v[oqx]=B5v[oqx]-1
call NJo(oqx)
endfunction
function NKo takes integer oqx,integer ibx,integer rkx returns nothing
call Nko((oqx))
call ijx(ibx)
call rix(rkx,cvv)
call Rmx(rkx,cev)
call Rmx(rkx,cxv)
endfunction
function Nlo takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local integer rkx=B9v[oqx]
call NKo(oqx,ibx,rkx)
call NGo(rkx)
endfunction
function NLo takes integer oqx,real ilx returns nothing
local integer rkx=oqx
local integer ibx
set oqx=NHo()
set ibx=inx()
set B8v[oqx]=ibx
set B9v[oqx]=rkx
set ge[(ibx)]=(oqx)
call rTx(rkx,cvv,oqx)
call I7x(rkx,cev)
call I7x(rkx,cxv)
call icx(ibx,ilx,false,function Nlo)
endfunction
function Nmo takes integer oqx,integer Ixx returns nothing
local real o2x
return
if(oqx==w)then
return
endif
if(Ixx==w)then
return
endif
if((Btv[((ze[(Ixx)]))])!=BTv)then
return
endif
if(IsUnitAlly(C[(Ixx)],vx[((ze[((oqx))]))]))then
return
endif
if I6x(Ixx,sc)then
return
endif
if I6x(Ixx,IBv)then
return
endif
if I6x(Ixx,ICv)then
return
endif
if I6x(Ixx,IFv)then
return
endif
set o2x=(A9v[(oqx)])
if(o2x<=0)then
return
endif
call cGx(Ixx,o2x)
call BRx(Ixx,o2x)
call Ico(Ixx,o2x)
endfunction
function NMo takes integer oqx,integer cCx returns nothing
local boolean Npo=BJv
local real NPo
call AYo((oqx))
if Npo then
set BJv=false
endif
call Roo((oqx),sc)
if((I6x((oqx),yd)and not I6x((oqx),Ibv))or I6x((oqx),IDv))then
call A_o(oqx,cCx)
else
set NPo=(A_v[((oqx))])
set Npo=(Npo or(ixv[((oqx))])or(NPo==.0))
if Npo then
call Ngo((oqx),cCx)
call A_o(oqx,cCx)
if not(Pc[((oqx))])then
call NGo((oqx))
endif
else
call NLo((oqx),NPo)
call A_o(oqx,cCx)
endif
endif
call Nmo((oqx),cCx)
call KFx((oqx))
endfunction
function Nqo takes nothing returns boolean
local integer rkx=Q_x()
local integer cCx
if not Ayo(rkx)then
return true
endif
set cCx=GG
set GG=w
call NMo((rkx),cCx)
return true
endfunction
function NQo takes nothing returns nothing
set gG=(E0x())
set VP=(E0x())
set Bjv=Xhx(function Nqo)
set Bkv=(E0x())
set AZv=JIx("FolderUnit_FolderDeath_StructEvents_Init: set FolderUnit_FolderDeath_StructEvents.REG_GROUP = UnitList.Create()")
call Q2x(Bjv,Ge,EVENT_PLAYER_UNIT_DEATH,null)
endfunction
function Nso takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function NSo takes nothing returns nothing
call NQo()
set BWv=XLx(function Nso)
endfunction
function Nto takes nothing returns nothing
endfunction
function NTo takes integer oqx,integer oQx returns nothing
call dTx((I[(oqx)]),((A[((oqx))])),(oQx))
endfunction
function Nuo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer olx=CXx(rkx,A3v)
local integer oSx
call Rmx(rkx,A4v)
loop
set oSx=COx(rkx,A3v,olx)
call Rmx(rkx,(A5v[(oSx)]))
set olx=olx-1
exitwhen(olx<q)
endloop
call NTo(rkx,A3v)
return true
endfunction
function NUo takes integer oqx returns nothing
local integer rkx=oqx
local integer olx=CXx(rkx,A3v)
local integer oSx
if(olx<q)then
return
endif
call Rmx(rkx,A4v)
loop
set oSx=COx(rkx,A3v,olx)
call Rmx(rkx,(A5v[(oSx)]))
set olx=olx-1
exitwhen(olx<q)
endloop
call NTo(rkx,A3v)
endfunction
function Nwo takes nothing returns boolean
local integer rdx=(bv)
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
local integer olx
call NUo(oqx)
set olx=Rdo(Ajo)
loop
exitwhen(olx<q)
call RDo(oqx,Rfo(Ajo,olx))
set olx=olx-1
endloop
return true
endfunction
function NWo takes integer oqx,integer oSx returns nothing
set A9v[(oqx)]=((A9v[(oqx)])+oSx)
endfunction
function Nyo takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
call NWo(oqx,(Nvv[(Ajo)])-(Nvv[(AHo)]))
return true
endfunction
function NYo takes integer oqx,integer oSx returns nothing
set Nev[(oqx)]=((Nev[(oqx)])+oSx)
endfunction
function Nzo takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
call NYo(oqx,(Nxv[(Ajo)])-(Nxv[(AHo)]))
return true
endfunction
function NZo takes nothing returns nothing
set A4v=XBx("FolderUnit_StructDrop_Init: set FolderUnit_StructDrop.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructDrop.Event_Destroy)",EP,BI,function Nuo)
call DNx(XBx("FolderUnit_StructDrop_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructDrop.Event_TypeChange).AddToStatics()",OP,BI,function Nwo))
call DNx(XBx("FolderUnit_FolderDrop_StructExp_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDrop_StructExp.Event_TypeChange).AddToStatics()",OP,BI,function Nyo))
call DNx(XBx("FolderUnit_FolderDrop_StructSupply_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDrop_StructSupply.Event_TypeChange).AddToStatics()",OP,BI,function Nzo))
endfunction
function N_o takes nothing returns boolean
local integer rdx=(bv)
call bpx(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function N0o takes integer oqx,real oSx returns nothing
set IPv[oqx]=oSx
call X9o((oqx))
endfunction
function N1o takes integer oqx,real oSx returns nothing
call N0o(oqx,(IPv[(oqx)])+oSx)
endfunction
function N2o takes nothing returns boolean
local integer rdx=(bv)
call N1o(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function N3o takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[(((I[(oqx)])))])]))],(((((A[((oqx))]))))),((((oQx))+(q)))))
endfunction
function N4o takes integer oqx,integer Xwx,boolean N5o returns nothing
if N5o then
call rix((oqx),cEv+Xwx)
endif
if rrx((oqx),cnv,Xwx)then
call Rmx((oqx),civ)
endif
call Rmx((oqx),Xwx)
endfunction
function N6o takes nothing returns boolean
local integer rdx=(bv)
local integer N7o=(Vv[(rdx)])
local integer Xwx
loop
set Xwx=N3o((N7o),cnv)
exitwhen(Xwx==w)
call N4o(N7o,Xwx,true)
endloop
return true
endfunction
function N8o takes integer oqx,real oSx returns nothing
set Iqv[(oqx)]=(((Iqv[(oqx)])+oSx)*1.)
endfunction
function N9o takes nothing returns boolean
local integer rdx=(bv)
call N8o(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function bvo takes integer oqx,real oSx returns nothing
set Iu[(oqx)]=((K_x(oqx,false)+oSx)*1.)
endfunction
function beo takes integer oqx,integer AHo,integer Ajo returns nothing
call bvo(oqx,(Nav[(Ajo)])-(Nav[(AHo)]))
endfunction
function bxo takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
call beo(oqx,AHo,Ajo)
return true
endfunction
function boo takes integer rkx returns boolean
return(I5x((bHv),Rb,(rkx)))
endfunction
function bro takes integer oqx returns nothing
local integer abx=(bdv[(oqx)])
local integer oSx=(GetHeroLevel(C[((oqx))]))
set bdv[oqx]=oSx
call UnitModifySkillPoints(C[(oqx)],abx-oSx)
if(oSx==0)then
return
endif
call Iuo(oqx,abx,oSx)
endfunction
function bio takes nothing returns boolean
local integer rkx=Q_x()
if not boo(rkx)then
return true
endif
if cOv then
set cOv=false
return true
endif
call bro(rkx)
return true
endfunction
function bao takes nothing returns nothing
set cXv=Xhx(function bio)
set bHv=JIx("FolderUnit_FolderLevel_StructEvents_Init: set FolderUnit_FolderLevel_StructEvents.REG_GROUP = UnitList.Create()")
call Q2x(cXv,Ge,EVENT_PLAYER_HERO_LEVEL,null)
endfunction
function bno takes nothing returns nothing
set bDv[0+1]=0
set bDv[0+2]=$96
set bDv[0+3]=400
set bDv[0+4]=750
set bDv[0+5]=$4B0
set bDv[0+6]=$6D6
set bDv[0+7]=$960
set bDv[0+8]=$C4E
set bDv[0+9]=$FA0
set bDv[0+$A]=4950
set bDv[0+$B]=6000
set bDv[0+$C]=7150
set bDv[0+$D]=8400
set bDv[0+$E]=9750
set bDv[0+$F]=$2BC0
set bDv[0+16]=$31CE
set bDv[0+17]=$3840
set bDv[0+18]=$3F16
set bDv[0+19]=$4650
set bDv[0+20]=$4DEE
call bao()
endfunction
function bVo takes integer oqx,real oSx returns nothing
set IQv[(oqx)]=(((IQv[(oqx)])+oSx)*1.)
endfunction
function bEo takes nothing returns boolean
local integer rdx=(bv)
call bVo(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function bXo takes nothing returns nothing
endfunction
function bOo takes integer oqx,real oSx returns nothing
set Isv[(oqx)]=(((Isv[(oqx)])+oSx)*1.)
endfunction
function bRo takes nothing returns boolean
local integer rdx=(bv)
call bOo(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function bIo takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
set iG[oqx]=(iG[(oqx)])+(Njv[(Ajo)])-(Njv[(AHo)])
call csx(oqx,(NJv[(Ajo)])-(NJv[(AHo)]))
return true
endfunction
function bAo takes nothing returns nothing
endfunction
function bNo takes nothing returns boolean
local integer rdx=(bv)
call czx(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function bbo takes nothing returns nothing
call DNx(XBx("FolderUnit_StructMaxLife_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructMaxLife.Event_TypeChange).AddToStatics()",OP,BI,function bIo))
call bAo()
set cAv=AUo(n_v,function bNo)
endfunction
function bBo takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
set mF[oqx]=(mF[(oqx)])+(Nkv[(Ajo)])-(Nkv[(AHo)])
call Bjx(oqx,(NKv[(Ajo)])-(NKv[(AHo)]))
return true
endfunction
function bco takes nothing returns nothing
endfunction
function bCo takes nothing returns boolean
local integer rdx=(bv)
call Bsx(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function bdo takes nothing returns nothing
call DNx(XBx("FolderUnit_StructMaxMana_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructMaxMana.Event_TypeChange).AddToStatics()",OP,BI,function bBo))
call bco()
set cNv=AUo(VRv,function bCo)
endfunction
function bDo takes integer oqx,real oSx returns nothing
set xb[(oqx)]=((OLx(oqx,false)+oSx)*1.)
endfunction
function bfo takes integer oqx,integer AHo,integer Ajo returns nothing
call bDo(oqx,(Ntv[(Ajo)])-(Ntv[(AHo)]))
endfunction
function bFo takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
call bfo(oqx,AHo,Ajo)
return true
endfunction
function bgo takes integer oqx,integer oSx returns nothing
set NVv[(oqx)]=((NVv[(oqx)])+oSx)
endfunction
function bGo takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
call bgo(oqx,RJo((NEv[(Ajo)]))-RJo((NEv[(AHo)])))
return true
endfunction
function bho takes nothing returns nothing
call UnitAddAbility(zj[((Zj))],('ARev'))
call DNx(XBx("FolderUnit_FolderRevival_StructAble_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderRevival_StructAble.Event_TypeChange).AddToStatics()",OP,BI,function bGo))
set XP=(E0x())
endfunction
function bHo takes integer oqx,real oSx returns nothing
set NRv[oqx]=oSx
call RMo((oqx))
endfunction
function bjo takes integer oqx,real oSx returns nothing
call bHo(oqx,(NRv[(oqx)])+oSx)
endfunction
function bJo takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
set NXv[oqx]=(NXv[(oqx)])+(NOv[(Ajo)])-(NOv[(AHo)])
call bjo(oqx,(NIv[(Ajo)])-(NIv[(AHo)]))
return true
endfunction
function bko takes nothing returns nothing
endfunction
function bKo takes nothing returns nothing
call DNx(XBx("FolderUnit_StructSightRange_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructSightRange.Event_TypeChange).AddToStatics()",OP,BI,function bJo))
call bko()
endfunction
function blo takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
call Blx(oqx,(Ndv[(Ajo)])-(Ndv[(AHo)]))
return true
endfunction
function bLo takes nothing returns boolean
local integer rdx=(bv)
call Btx(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function bmo takes integer oqx,real oSx returns nothing
set vg[oqx]=oSx
call Bkx((oqx))
endfunction
function bMo takes integer oqx,real oSx returns nothing
call bmo(oqx,(vg[(oqx)])+oSx)
endfunction
function bpo takes nothing returns boolean
local integer rdx=(bv)
call bMo(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function bPo takes nothing returns nothing
call DNx(XBx("FolderUnit_FolderSpellPower_StructBase_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderSpellPower_StructBase.Event_TypeChange).AddToStatics()",OP,BI,function blo))
set cbv=AUo(XZv,function bLo)
set Edv=AUo(X0v,function bpo)
endfunction
function bqo takes integer oqx,real oSx returns nothing
set Nfv[oqx]=oSx
call RSo((oqx))
endfunction
function bQo takes integer oqx,real oSx returns nothing
call bqo(oqx,(Nfv[(oqx)])+oSx)
endfunction
function bso takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
call bQo(oqx,(NFv[(Ajo)])-(NFv[(AHo)]))
return true
endfunction
function bSo takes integer oqx,real oSx returns nothing
set Ngv[oqx]=oSx
call RSo((oqx))
endfunction
function bto takes integer oqx,real oSx returns nothing
call bSo(oqx,(Ngv[(oqx)])+oSx)
endfunction
function bTo takes nothing returns boolean
local integer rdx=(bv)
call bto(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function buo takes integer oqx,real oSx returns nothing
set NGv[oqx]=oSx
call RSo((oqx))
endfunction
function bUo takes integer oqx,real oSx returns nothing
call buo(oqx,(NGv[(oqx)])+oSx)
endfunction
function bwo takes nothing returns boolean
local integer rdx=(bv)
call bUo(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function bWo takes nothing returns nothing
call DNx(XBx("FolderUnit_FolderSpellVamp_StructBase_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderSpellVamp_StructBase.Event_TypeChange).AddToStatics()",OP,BI,function bso))
set cBv=AUo(X6v,function bTo)
set ccv=AUo(X8v,function bwo)
endfunction
function byo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer ocx
local integer olx=CXx(rkx,cdv)
call Rmx(rkx,cCv)
loop
set ocx=COx(rkx,cdv,olx)
call rrx(rkx,cdv,ocx)
call rix(rkx,rk+ocx)
call rix(rkx,ik+ocx)
call rix(rkx,ak+ocx)
call rix(rkx,nk+ocx)
call hGx(ocx,cDv)
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function bYo takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
call fhx(oqx,(NTv[(Ajo)])-(NTv[(AHo)]),(Nuv[(Ajo)])-(Nuv[(AHo)]),(NUv[(Ajo)])-(NUv[(AHo)]),(Nwv[(Ajo)])-(Nwv[(AHo)]))
return true
endfunction
function bzo takes nothing returns boolean
local integer rdx=(bv)
local integer Ipx=(Gc[(rdx)])
local real iWx=nIv[(Ipx)]
local real iyx=nAv[(Ipx)]
local real iYx=nNv[(Ipx)]
local real izx=nbv[(Ipx)]
if(fc[(rdx)])then
call fhx(((Vv[(rdx)])),iWx,iyx,iYx,izx)
else
call fhx((((Vv[(rdx)]))),-((iWx)*1.),-((iyx)*1.),-((iYx)*1.),-((izx)*1.))
endif
return true
endfunction
function bZo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer olx=CXx(rkx,Fk)
local integer oqx
loop
set oqx=COx(rkx,Fk,olx)
call fMx(oqx,Dk[oqx],rkx)
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function b_o takes nothing returns boolean
local integer rdx=(bv)
local integer Ipx=(Gc[(rdx)])
local real iWx=cFv[(Ipx)]
local real iyx=cgv[(Ipx)]
local real iYx=cGv[(Ipx)]
local real izx=chv[(Ipx)]
local real ilx=cHv[(Ipx)]
if(fc[(rdx)])then
call fPx(((Vv[(rdx)])),iWx,iyx,iYx,izx,ilx)
else
call fPx((((Vv[(rdx)]))),-((iWx)*1.),-((iyx)*1.),-((iYx)*1.),-((izx)*1.),((ilx)*1.))
endif
return true
endfunction
function b0o takes nothing returns nothing
set gk=XBx("FolderUnit_FolderVertexColor_StructTimed_Init: set FolderUnit_FolderVertexColor_StructTimed.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderVertexColor_StructTimed.Event_Destroy)",EP,BI,function bZo)
set cfv=AUo(Xk,function b_o)
set jk=inx()
endfunction
function b1o takes nothing returns nothing
set cCv=XBx("FolderUnit_StructVertexColor_Init: set FolderUnit_StructVertexColor.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructVertexColor.Event_Destroy)",EP,BI,function byo)
call DNx(XBx("FolderUnit_StructVertexColor_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructVertexColor.Event_TypeChange).AddToStatics()",OP,BI,function bYo))
set nRv=AUo(a7v,function bzo)
call b0o()
endfunction
function b2o takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=oPx(rkx,xlv)
call Uox(oqx,rkx)
return true
endfunction
function b3o takes nothing returns nothing
set xqv=XBx("FolderUnit_FolderAnimation_StructLoop_Init: set FolderUnit_FolderAnimation_StructLoop.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAnimation_StructLoop.Event_Death)",VP,BI,function b2o)
set xtv=inx()
endfunction
function b4o takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=(Vv[(rdx)])
local integer olx=(CXx(((oqx)),eB))
local integer Iox
loop
set Iox=(COx(((oqx)),eB,(olx)))
if(qc[(Iox)])then
call Ayx(oqx,Iox)
endif
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function b5o takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=(Vv[(rdx)])
local integer olx=(CXx(((oqx)),eB))
local integer Iox
loop
set Iox=(COx(((oqx)),eB,(olx)))
call Ayx(oqx,Iox)
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function b6o takes nothing returns nothing
set pc=(E0x())
set Bd=(E0x())
set Jc=(E0x())
endfunction
function b7o takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer olx=CXx(rkx,Td)
local integer oqx
loop
set oqx=COx(rkx,Td,olx)
call Nex(oqx)
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function b8o takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer rkx=(Vv[(rdx)])
local integer Iox=(jc[(rdx)])
local integer oqx=(Ifx(E[((X))],(dd),(((rkx))),((Iox)),((rwx)),(w)))
if(oqx!=w)then
call Nex(oqx)
endif
return true
endfunction
function b9o takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer olx=CXx(rkx,sd)
local integer oqx
loop
set oqx=COx(rkx,sd,olx)
call A7x(oqx,td[oqx],rkx)
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function Bvo takes nothing returns nothing
set ud=XBx("FolderUnit_FolderBuffs_StructTimed_Init: set FolderUnit_FolderBuffs_StructTimed.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderBuffs_StructTimed.Event_Death)",VP,BI,function b7o)
set Ud=XBx("FolderUnit_FolderBuffs_StructTimed_Init: set FolderUnit_FolderBuffs_StructTimed.LOSE_EVENT = Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderBuffs_StructTimed.Event_Lose)",Jc,BI,function b8o)
set Sd=XBx("FolderUnit_FolderBuffs_FolderTimed_StructCountdown_Init: set FolderUnit_FolderBuffs_FolderTimed_StructCountdown.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderBuffs_FolderTimed_StructCountdown.Event_Death)",VP,BI,function b9o)
endfunction
function Beo takes nothing returns nothing
set xB=XBx("FolderUnit_StructBuffs_Init: set FolderUnit_StructBuffs.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructBuffs.Event_Death)",VP,BI,function b4o)
set oB=XBx("FolderUnit_StructBuffs_Init: set FolderUnit_StructBuffs.DESTROY_EVENT = Event.Create(UNIT.DESTROY_EVENT_TYPE, EventPriority.HEADER_TOP, function FolderUnit_StructBuffs.Event_Destroy)",EP,hI,function b5o)
call b6o()
call Bvo()
endfunction
function Bxo takes integer oqx,real oSx returns nothing
set A_v[(oqx)]=(((A_v[(oqx)])+oSx)*1.)
endfunction
function Boo takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
call Bxo(oqx,(A0v[(Ajo)])-(A0v[(AHo)]))
return true
endfunction
function Bro takes integer oqx,boolean isx returns nothing
call UnitSuspendDecay(C[(oqx)],isx)
endfunction
function Bio takes nothing returns nothing
local integer Bao=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
call Bro(aBx(cJv[Bao]),true)
call ijx(Bao)
endfunction
function Bno takes nothing returns boolean
local integer Bao=inx()
set cJv[Bao]=C[Q_x()]
call icx(Bao,.0,false,function Bio)
return true
endfunction
function BVo takes nothing returns boolean
if not(I5x((A1v),Rb,(jFx())))then
return false
endif
return true
return true
endfunction
function BEo takes nothing returns nothing
set cjv=Xhx(function Bno)
set A1v=JIx("FolderUnit_FolderDecay_StructEvents_Init: set FolderUnit_FolderDecay_StructEvents.REG_GROUP = UnitList.Create()")
call Q2x(cjv,Ge,EVENT_PLAYER_UNIT_DECAY,function BVo)
endfunction
function BXo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=oPx(rkx,cvv)
call NKo(oqx,B8v[oqx],rkx)
return true
endfunction
function BOo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=oPx(rkx,cvv)
call NKo(oqx,B8v[oqx],rkx)
return true
endfunction
function BRo takes nothing returns nothing
set cev=XBx("FolderUnit_FolderDecay_StructTimed_Init: set FolderUnit_FolderDecay_StructTimed.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDecay_StructTimed.Event_Destroy)",EP,BI,function BXo)
set cxv=XBx("FolderUnit_FolderDecay_StructTimed_Init: set FolderUnit_FolderDecay_StructTimed.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDecay_StructTimed.Event_Revive)",XP,BI,function BOo)
endfunction
function BIo takes nothing returns nothing
call DNx(XBx("FolderUnit_FolderDecay_StructDuration_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDecay_StructDuration.Event_TypeChange).AddToStatics()",OP,BI,function Boo))
call BEo()
call BRo()
endfunction
function BAo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
call Rmx(rkx,Bnv)
call djx(oqx)
return true
endfunction
function BNo takes integer oMx returns integer
return(LoadInteger(o[((V[(E[((X))])]))],(((oMx))),(((Oj)))))
endfunction
function Bbo takes integer oqx returns integer
set rj[oqx]=true
set clv[oqx]=false
call rax(ij)
return oqx
endfunction
function BBo takes nothing returns integer
local integer oqx
if(ckv==8190)then
call oYx("OrderInstance_Allocation_allocCustom","call DebugEx(OrderInstance.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",oj+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(xj[(w)]==w)then
set cKv=cKv+1
set oqx=cKv
else
set oqx=xj[(w)]
set xj[(w)]=xj[xj[(w)]]
endif
set xj[oqx]=Z
set ej[oqx]=1
call Bbo(oqx)
return oqx
endfunction
function Bco takes integer oqx returns nothing
set Rh[(oqx)]=(w)
set Fj[(oqx)]=(w)
set gj[(oqx)]=(w)
set Cj[(oqx)]=((.0)*1.)
set dj[(oqx)]=((.0)*1.)
endfunction
function BCo takes integer oqx returns nothing
set ZH[oqx]=0
set vj[oqx]=false
endfunction
function Bdo takes nothing returns integer
local integer oqx=BBo()
call Bco(oqx)
call BCo(oqx)
return oqx
endfunction
function BDo takes nothing returns boolean
local integer oqx=Q_x()
local integer Rvx=(BNo(GetIssuedOrderId()))
local integer I3x=Bdo()
set Rh[(I3x)]=(Rvx)
set cLv[(I3x)]=(0)
if Vh[oqx]then
if(Oh[oqx]!=w)then
call dHx(Oh[oqx])
endif
set Oh[oqx]=I3x
return true
endif
if(O0v[((oqx))])then
return true
endif
call d1x(oqx,I3x)
return true
endfunction
function Bfo takes nothing returns nothing
set bj=(E0x())
set pb=Xhx(function BDo)
endfunction
function BFo takes nothing returns boolean
local real dix=(GetOrderPointX())
local real dax=(GetOrderPointY())
local integer oqx=Q_x()
local integer Rvx=(BNo(GetIssuedOrderId()))
local integer I3x=Bdo()
set Rh[(I3x)]=(Rvx)
set Cj[(I3x)]=((dix)*1.)
set dj[(I3x)]=((dax)*1.)
set cLv[(I3x)]=(2)
if Eh[oqx]then
if(cj[oqx]!=w)then
call dHx(cj[oqx])
endif
set cj[oqx]=I3x
return true
endif
call Dvx(oqx,I3x)
return true
endfunction
function Bgo takes nothing returns nothing
set Dj=(E0x())
set Bh=Xhx(function BFo)
endfunction
function BGo takes item oMx returns integer
return(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((oMx))))),((((hh))))))
endfunction
function Bho takes nothing returns integer
local unit oMx=GetOrderTargetUnit()
local integer o4x
if(GetUnitAbilityLevel(oMx,'aLoc')>0)then
set oMx=null
return Z
endif
set o4x=aBx(oMx)
set oMx=null
return o4x
endfunction
function BHo takes nothing returns boolean
local integer dox=(BGo(GetOrderTargetItem()))
local integer drx=Bho()
local integer oqx=Q_x()
local integer Rvx=(BNo(GetIssuedOrderId()))
local integer I3x=Bdo()
set Rh[(I3x)]=(Rvx)
set Fj[(I3x)]=(dox)
set gj[(I3x)]=(drx)
set cLv[(I3x)]=(4)
if Xh[oqx]then
if(fj[oqx]!=w)then
call dHx(fj[oqx])
endif
set fj[oqx]=I3x
return true
endif
call Drx(oqx,I3x)
return true
endfunction
function Bjo takes nothing returns nothing
set Gj=(E0x())
set BVv=Xhx(function BHo)
set hj=(E0x())
endfunction
function BJo takes nothing returns nothing
call Bfo()
call Bgo()
call Bjo()
endfunction
function Bko takes integer oqx returns boolean
if(((cpv[((oqx))])>0)==false)then
return false
endif
set cpv[cPv[cqv]]=cpv[oqx]
set cPv[cpv[oqx]-1]=cPv[cqv]
set cpv[oqx]=0
set cqv=cqv-1
return(cqv==F)
endfunction
function BKo takes integer oqx returns boolean
if(((cQv[((oqx))])>0)==false)then
return false
endif
set cQv[csv[cSv]]=cQv[oqx]
set csv[cQv[oqx]-1]=csv[cSv]
set cQv[oqx]=0
set cSv=cSv-1
return(cSv==F)
endfunction
function Blo takes integer oqx,integer Xwx returns nothing
if rrx((oqx),cMv,Xwx)then
call Bko(oqx)
call Rmx((oqx),cmv)
if BKo(oqx)then
call iHx(ctv)
endif
endif
call Rmx((oqx),Xwx)
endfunction
function BLo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer olx=CXx(rkx,cMv)
loop
call Blo((rkx),COx(rkx,cMv,olx))
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function Bmo takes integer oqx returns boolean
if(((cwv[((oqx))])>0)==false)then
return false
endif
set cwv[cWv[cyv]]=cwv[oqx]
set cWv[cwv[oqx]-1]=cWv[cyv]
set cwv[oqx]=0
set cyv=cyv-1
return(cyv==F)
endfunction
function BMo takes integer oqx returns nothing
local integer rkx=oqx
local integer rdx=rEx((A[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set Vv[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,cTv,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,cTv,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function Bpo takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=(Vv[(rdx)])
if not((cpv[((oqx))])>0)then
return true
endif
call BKo(oqx)
if((cwv[((oqx))])>0)then
call Bmo(oqx)
call BMo(oqx)
endif
return true
endfunction
function BPo takes integer oqx returns boolean
if((cQv[((oqx))])>0)then
return false
endif
set cSv=cSv+1
set csv[cSv]=oqx
set cQv[oqx]=cSv+1
return(cSv==0)
endfunction
function Bqo takes integer oqx returns boolean
if((cwv[((oqx))])>0)then
return false
endif
set cyv=cyv+1
set cWv[cyv]=oqx
set cwv[oqx]=cyv+1
return(cyv==0)
endfunction
function BQo takes integer oqx returns nothing
local integer rkx=oqx
local integer rdx=rEx((A[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set Vv[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,cUv,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,cUv,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function Bso takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=(Vv[(rdx)])
if not((cpv[((oqx))])>0)then
return true
endif
call BPo(oqx)
call Bqo(oqx)
call BQo(oqx)
return true
endfunction
function BSo takes nothing returns nothing
set cmv=XBx("FolderUnit_FolderOrder_FolderEvents_StructIdle_Init: set FolderUnit_FolderOrder_FolderEvents_StructIdle.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderOrder_FolderEvents_StructIdle.Event_Destroy)",EP,BI,function BLo)
set cTv=(E0x())
set cuv=(E0x())
set cUv=(E0x())
set ctv=inx()
call DNx(XBx("FolderUnit_FolderOrder_FolderEvents_StructIdle_Init: call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderOrder_FolderEvents_StructIdle.Event_Death).AddToStatics()",VP,BI,function Bpo))
call DNx(XBx("FolderUnit_FolderOrder_FolderEvents_StructIdle_Init: call Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderOrder_FolderEvents_StructIdle.Event_Revive).AddToStatics()",XP,BI,function Bso))
endfunction
function Bto takes integer oqx returns nothing
call IEo(YH,oqx)
call Rmx((oqx),BEv)
if not(I5x((aj),Rb,(oqx)))then
return
endif
call IEo(aj,oqx)
if(dKx((aj),Rb))then
call iHx(nj)
endif
endfunction
function BTo takes nothing returns boolean
local integer rdx=(bv)
call Bto(((Vv[(rdx)])))
return true
endfunction
function Buo takes nothing returns nothing
set BEv=XBx("FolderUnit_FolderOrder_FolderEvents_StructLose_Init: set FolderUnit_FolderOrder_FolderEvents_StructLose.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderOrder_FolderEvents_StructLose.Event_Destroy)",EP,BI,function BTo)
set Aj=JIx("FolderUnit_FolderOrder_FolderEvents_StructLose_Init: set FolderUnit_FolderOrder_FolderEvents_StructLose.ENUM_GROUP = UnitList.Create()")
set YH=JIx("FolderUnit_FolderOrder_FolderEvents_StructLose_Init: set FolderUnit_FolderOrder_FolderEvents_StructLose.REG_GROUP = UnitList.Create()")
set aj=JIx("FolderUnit_FolderOrder_FolderEvents_StructLose_Init: set FolderUnit_FolderOrder_FolderEvents_StructLose.UPDATE_GROUP = UnitList.Create()")
set nj=inx()
endfunction
function BUo takes nothing returns nothing
call BJo()
call BSo()
call Buo()
endfunction
function Bwo takes nothing returns nothing
set Bnv=XBx("FolderUnit_StructOrder_Init: set FolderUnit_StructOrder.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructOrder.Event_Destroy)",EP,BI,function BAo)
call BUo()
endfunction
function BWo takes nothing returns nothing
endfunction
function Byo takes integer oqx returns nothing
set c0v[oqx]=false
call rgx(O7v)
endfunction
function BYo takes integer oqx returns nothing
if(cZv[oqx]>0)then
return
endif
if(c_v[oqx]!=Z)then
call oYx("FolderUnit_FolderPosition_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderPosition_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",O8v+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set c_v[oqx]=c_v[(w)]
set c_v[(w)]=oqx
call Byo(oqx)
endfunction
function Bzo takes integer oqx returns nothing
set cZv[oqx]=cZv[oqx]-1
call BYo(oqx)
endfunction
function BZo takes integer oqx returns boolean
local integer okx=(c2v[(oqx)])
set c2v[c3v[c4v]]=okx
set c3v[okx-1]=c3v[c4v]
set c2v[oqx]=0
set c4v=c4v-1
return(c4v==F)
endfunction
function B_o takes integer Ixx returns boolean
return( not((Nlv[((uf[(Ixx)]))])<=.0))
endfunction
function B0o takes integer oqx returns integer
set Cev[oqx]=true
set Cxv[oqx]=false
call rax(O5v)
return oqx
endfunction
function B1o takes nothing returns integer
local integer oqx
if(c7v==8190)then
call oYx("FolderUnit_FolderPosition_FolderTimed_StructAccelerated_Allocation_allocCustom","call DebugEx(FolderUnit_FolderPosition_FolderTimed_StructAccelerated.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",O6v+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(c8v[(w)]==w)then
set c9v=c9v+1
set oqx=c9v
else
set oqx=c8v[(w)]
set c8v[(w)]=c8v[c8v[(w)]]
endif
set c8v[oqx]=Z
set Cvv[oqx]=1
call B0o(oqx)
return oqx
endfunction
function B2o takes integer oqx returns boolean
set CAv=CAv+1
set CNv[CAv]=oqx
set Cbv[oqx]=CAv+1
return(CAv==0)
endfunction
function B3o takes integer oqx,real oSx returns nothing
call fTx(oqx,(GetUnitX(C[((oqx))]))+oSx)
endfunction
function B4o takes integer oqx,real oSx returns nothing
call fux(oqx,(GetUnitY(C[((oqx))]))+oSx)
endfunction
function B5o takes integer oqx,real z returns nothing
call fUx(oqx,(GetUnitX(C[(((oqx)))])),(GetUnitY(C[(((oqx)))])),z)
endfunction
function B6o takes integer oqx,real oSx returns nothing
call B5o(oqx,fwx(oqx)+oSx)
endfunction
function B7o takes nothing returns nothing
local integer olx=CAv
local integer oqx
local integer rkx
local real N2x
local real N3x
local real cRx
loop
set oqx=CNv[olx]
set rkx=Crv[oqx]
set N2x=Civ[oqx]+Cav[oqx]
set N3x=Cnv[oqx]+CVv[oqx]
set cRx=CEv[oqx]+CXv[oqx]
set Civ[oqx]=N2x
set Cnv[oqx]=N3x
set CEv[oqx]=cRx
call B3o(rkx,N2x)
call B4o(rkx,N3x)
call B6o(rkx,cRx)
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function B8o takes integer oqx returns nothing
set Cev[oqx]=false
call rgx(O5v)
endfunction
function B9o takes integer oqx returns nothing
if(Cvv[oqx]>0)then
return
endif
if(c8v[oqx]!=Z)then
call oYx("FolderUnit_FolderPosition_FolderTimed_StructAccelerated_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderPosition_FolderTimed_StructAccelerated.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",O6v+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set c8v[oqx]=c8v[(w)]
set c8v[(w)]=oqx
call B8o(oqx)
endfunction
function cvo takes integer oqx returns nothing
set Cvv[oqx]=Cvv[oqx]-1
call B9o(oqx)
endfunction
function ceo takes integer oqx returns boolean
local integer okx=(Cbv[(oqx)])
set Cbv[CNv[CAv]]=okx
set CNv[okx-1]=CNv[CAv]
set Cbv[oqx]=0
set CAv=CAv-1
return(CAv==F)
endfunction
function cxo takes integer oqx returns nothing
set Rd=oqx
call TriggerEvaluate(Ccv)
endfunction
function coo takes integer oqx,integer ibx,integer rkx returns nothing
call cvo((oqx))
call ijx(ibx)
if rrx(rkx,COv,oqx)then
call Rmx(rkx,CRv)
call Rmx(rkx,CIv)
endif
if ceo(oqx)then
call iHx(CBv)
endif
call cxo(rkx)
endfunction
function cro takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
call coo(oqx,ibx,Crv[oqx])
endfunction
function cio takes integer oqx,real N2x,real N3x,real cRx,real cao,real cno,real cVo,real ilx returns nothing
local integer rkx=oqx
local integer D8x
local integer ibx
if not B_o(oqx)then
return
endif
set D8x=(R2I(((iOx((1),((R2I(((ilx*1./ c6v+.5)*1.))))))*1.)))
set oqx=B1o()
set ibx=inx()
set Cov[oqx]=ibx
set Crv[oqx]=rkx
set Civ[oqx]=N2x*1./ D8x
set Cav[oqx]=cao*1./ D8x*c6v
set Cnv[oqx]=N3x*1./ D8x
set CVv[oqx]=cno*1./ D8x*c6v
set CEv[oqx]=cRx*1./ D8x
set CXv[oqx]=cVo*1./ D8x*c6v
set ge[(ibx)]=(oqx)
if rtx(rkx,COv,oqx)then
call I7x(rkx,CRv)
call I7x(rkx,CIv)
endif
if B2o(oqx)then
call icx(CBv,c6v,true,function B7o)
endif
call icx(ibx,ilx,false,function cro)
endfunction
function cEo takes integer oqx returns integer
set ru[oqx]=true
set CDv[oqx]=false
set Zt[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set aT[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(Ut)
return oqx
endfunction
function cXo takes nothing returns integer
local integer oqx
if(CCv==8190)then
call oYx("Lightning_Allocation_allocCustom","call DebugEx(Lightning.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",wt+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(ou[(w)]==w)then
set Cdv=Cdv+1
set oqx=Cdv
else
set oqx=ou[(w)]
set ou[(w)]=ou[ou[(w)]]
endif
set ou[oqx]=Z
set xu[oqx]=1
call cEo(oqx)
return oqx
endfunction
function cOo takes integer oqx returns nothing
set vT[(oqx)]=(Cgv+oqx)
endfunction
function cRo takes integer oqx returns nothing
set QT[(oqx)]=((GetLightningColorR(TT[(oqx)]))*1.)
endfunction
function cIo takes integer oqx returns nothing
set sT[(oqx)]=((GetLightningColorG(TT[(oqx)]))*1.)
endfunction
function cAo takes integer oqx returns nothing
set ST[(oqx)]=((GetLightningColorB(TT[(oqx)]))*1.)
endfunction
function cNo takes integer oqx returns nothing
set tT[(oqx)]=((GetLightningColorA(TT[(oqx)]))*1.)
endfunction
function cbo takes integer oqx returns nothing
call cRo(oqx)
call cIo(oqx)
call cAo(oqx)
call cNo(oqx)
call KLx(oqx,(QT[(oqx)]),(sT[(oqx)]),(ST[(oqx)]),(tT[(oqx)]))
endfunction
function cBo takes integer rRx returns integer
local integer oqx=cXo()
local lightning oMx=AddLightningEx((TE[(rRx)]),false,.0,.0,.0,.0,.0,.0)
set Cfv[oqx]=true
set qT[oqx]=false
set TT[oqx]=oMx
call cOo(oqx)
call cbo(oqx)
return oqx
endfunction
function cco takes integer oqx returns nothing
if qT[oqx]then
call KKx(oqx)
endif
set qT[oqx]=true
endfunction
function cCo takes integer oqx returns integer
set su[oqx]=true
set CHv[oqx]=false
call rax(qt)
return oqx
endfunction
function cdo takes nothing returns integer
local integer oqx
if(CGv==8190)then
call oYx("FolderLightning_StructFromSpotToUnit_Allocation_allocCustom","call DebugEx(FolderLightning_StructFromSpotToUnit.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Qt+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Qu[(w)]==w)then
set Chv=Chv+1
set oqx=Chv
else
set oqx=Qu[(w)]
set Qu[(w)]=Qu[Qu[(w)]]
endif
set Qu[oqx]=Z
set qu[oqx]=1
call cCo(oqx)
return oqx
endfunction
function cDo takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((Zt[(oqx)]))])]))],((((vT[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function cfo takes integer oqx,real x,real y,real z,real x2,real y2,real z2 returns nothing
call MoveLightningEx(TT[oqx],Cfv[oqx],x,y,z,x2,y2,z2)
endfunction
function cFo takes integer oqx returns boolean
set wu=wu+1
set Uu[wu]=oqx
set uu[oqx]=wu+1
return(wu==0)
endfunction
function cgo takes nothing returns nothing
local integer olx=wu
local integer oqx
local integer Ixx
local real dix
local real dax
local real Mpx
loop
set oqx=Uu[olx]
set Ixx=yu[oqx]
if(Ixx==w)then
set dix=Clv[oqx]
set dax=CLv[oqx]
set Mpx=Cmv[oqx]
else
set dix=DPx(Ixx)
set dax=DQx(Ixx)
set Mpx=Olx(Ixx,dix,dax)+K_x(Ixx,true)
endif
call cfo(Yu[oqx],Cjv[oqx],CJv[oqx],Ckv[oqx],dix,dax,Mpx)
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function cGo takes integer oqx,real jlx,real jLx,real cho,integer Ixx returns nothing
local integer rkx=oqx
local real dix=DPx(Ixx)
local real dax=DQx(Ixx)
call cco(rkx)
set oqx=cdo()
set Yu[oqx]=rkx
set Cjv[oqx]=jlx
set CJv[oqx]=jLx
set Ckv[oqx]=cho
set yu[oqx]=Ixx
call cDo(rkx,Pu,oqx)
call Kqx(rkx,Mu)
if rtx(Ixx,tu,oqx)then
call I7x(Ixx,Tu)
call AYo(Ixx)
endif
call cfo(rkx,jlx,jLx,cho,dix,dax,Olx(Ixx,dix,dax)+K_x(Ixx,true))
if cFo(oqx)then
call icx(Wu,CKv,true,function cgo)
endif
endfunction
function cHo takes integer oqx returns integer
set BT[oqx]=true
set CPv[oqx]=false
call rax(Tt)
return oqx
endfunction
function cjo takes nothing returns integer
local integer oqx
if(CMv==8190)then
call oYx("FolderLightning_StructDestroyTimed_Allocation_allocCustom","call DebugEx(FolderLightning_StructDestroyTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",ut+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(bT[(w)]==w)then
set Cpv=Cpv+1
set oqx=Cpv
else
set oqx=bT[(w)]
set bT[(w)]=bT[bT[(w)]]
endif
set bT[oqx]=Z
set NT[oqx]=1
call cHo(oqx)
return oqx
endfunction
function cJo takes nothing returns nothing
local integer ibx=ifx()
local integer oqx=(ge[(ibx)])
local integer rkx=Cqv[oqx]
call KBx(oqx,ibx,rkx)
call Kzx(rkx)
endfunction
function cko takes integer oqx,real ilx returns nothing
local integer rkx=oqx
local integer ibx
set oqx=KRx(rkx,AT)
if(oqx!=w)then
call KBx(oqx,cT[oqx],rkx)
endif
set oqx=cjo()
set ibx=inx()
set cT[oqx]=ibx
set Cqv[oqx]=rkx
set ge[(ibx)]=(oqx)
call cDo(rkx,AT,oqx)
call Kqx(rkx,RT)
call icx(ibx,ilx,false,function cJo)
endfunction
function cKo takes integer oqx returns nothing
local real ilx
local integer clo
local real jlx=(GetUnitX(C[((oqx))]))
local real jLx=(GetUnitY(C[((oqx))]))
local item cLo=CreateItem('iUPN',jlx,jLx)
local real dix=GetWidgetX(cLo)
local real dax=GetWidgetY(cLo)
local real d=jjx(dix-jlx,dax-jLx)
call RemoveItem(cLo)
set cLo=null
if(d<1.)then
return
endif
set ilx=d*1./ 150.
call cio(oqx,dix-jlx,dax-jLx,.0,.0,.0,.0,ilx)
set clo=cBo(Rov)
call cGo(clo,dix,dax,XYx(dix,dax),oqx)
call cko(clo,ilx)
endfunction
function cmo takes integer oqx,integer ibx,integer rkx returns nothing
call Bzo((oqx))
call ijx(ibx)
if rrx(rkx,czv,oqx)then
call Rmx(rkx,cYv)
call Rmx(rkx,c1v)
endif
if BZo(oqx)then
call iHx(c5v)
endif
call cKo(rkx)
endfunction
function cMo takes integer rkx returns nothing
local integer olx=CXx(rkx,czv)
local integer oqx
loop
set oqx=COx(rkx,czv,olx)
call cmo(oqx,CQv[oqx],rkx)
set olx=olx-1
exitwhen(olx<q)
endloop
endfunction
function cpo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
call cMo(rkx)
return true
endfunction
function cPo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
call cMo(rkx)
return true
endfunction
function cqo takes integer rkx returns nothing
local integer olx=CXx(rkx,COv)
local integer oqx
loop
set oqx=COx(rkx,COv,olx)
call coo(oqx,Cov[oqx],rkx)
set olx=olx-1
exitwhen(olx<q)
endloop
endfunction
function cQo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
call cqo(rkx)
return true
endfunction
function cso takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
call cqo(rkx)
return true
endfunction
function cSo takes nothing returns nothing
set CRv=XBx("FolderUnit_FolderPosition_FolderTimed_StructAccelerated_Init: set FolderUnit_FolderPosition_FolderTimed_StructAccelerated.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderPosition_FolderTimed_StructAccelerated.Event_Death)",VP,BI,function cQo)
set CIv=XBx("FolderUnit_FolderPosition_FolderTimed_StructAccelerated_Init: set FolderUnit_FolderPosition_FolderTimed_StructAccelerated.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderPosition_FolderTimed_StructAccelerated.Event_Destroy)",EP,BI,function cso)
set CBv=inx()
endfunction
function cto takes nothing returns nothing
set cYv=XBx("FolderUnit_FolderPosition_StructTimed_Init: set FolderUnit_FolderPosition_StructTimed.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderPosition_StructTimed.Event_Death)",VP,BI,function cpo)
set c1v=XBx("FolderUnit_FolderPosition_StructTimed_Init: set FolderUnit_FolderPosition_StructTimed.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderPosition_StructTimed.Event_Destroy)",EP,BI,function cPo)
set c5v=inx()
call cSo()
endfunction
function cTo takes nothing returns nothing
call BWo()
call cto()
endfunction
function cuo takes integer oqx,integer oQx returns nothing
call SaveInteger(o[(((V[(E[((dB[(oqx)]))])])))],(((((aB[((oqx))]))))),((((oQx)))),(0))
endfunction
function cUo takes integer oqx returns nothing
set Cyv[oqx]=false
call rgx(Rnv)
endfunction
function cwo takes integer oqx returns nothing
if(Cwv[oqx]>0)then
return
endif
if(CWv[oqx]!=Z)then
call oYx("FolderUnit_FolderSelection_StructCircle_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderSelection_StructCircle.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",RVv+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set CWv[oqx]=CWv[(w)]
set CWv[(w)]=oqx
call cUo(oqx)
endfunction
function cWo takes integer oqx returns nothing
set Cwv[oqx]=Cwv[oqx]-1
call cwo(oqx)
endfunction
function cyo takes integer oqx returns nothing
call cuo(Ctv[oqx],CTv)
call hGx(Cuv[oqx],CSv+CUv[oqx])
call cWo((oqx))
endfunction
function cYo takes integer oqx,integer ocx returns nothing
local integer rkx=oqx
local integer czo
set oqx=hFx(ocx,CSv+oqx)
set czo=Ctv[oqx]
call cyo(oqx)
call RUx(czo)
endfunction
function cZo takes integer oqx,integer ocx returns nothing
local integer rkx=oqx
local integer rdx=rEx(0)
local integer EHo
local integer olx
local integer rIx
local integer rlx
set Vv[(rdx)]=(oqx)
set eN[(rdx)]=(ocx)
set EHo=rEx((A[(rkx)]))
set Vv[(EHo)]=(oqx)
set eN[(EHo)]=(ocx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Czv))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Czv))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set rlx=rOx(rkx,Czv,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,Czv,rIx,rlx),EHo)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call rHx(((EHo)))
endfunction
function c_o takes integer oqx,integer ocx returns nothing
call cYo(oqx,ocx)
call hfx(ocx,db,oqx)
if rrx((oqx),db,ocx)then
call Rmx((oqx),Csv)
call Rmx((oqx),CYv)
endif
call cZo(oqx,ocx)
endfunction
function c0o takes integer rkx returns nothing
local integer olx=CXx(rkx,db)
loop
call c_o((rkx),COx(rkx,db,olx))
set olx=olx-1
exitwhen(olx<q)
endloop
endfunction
function c1o takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
call c0o(rkx)
return true
endfunction
function c2o takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
call c0o(rkx)
return true
endfunction
function c3o takes nothing returns boolean
call c_o((Q_x()),opx())
return true
endfunction
function c4o takes integer oqx,integer ocx returns nothing
local integer rkx=oqx
local integer rdx=rEx(0)
local integer EHo
local integer olx
local integer rIx
local integer rlx
set Vv[(rdx)]=(oqx)
set eN[(rdx)]=(ocx)
set EHo=rEx((A[(rkx)]))
set Vv[(EHo)]=(oqx)
set eN[(EHo)]=(ocx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((C0v))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((C0v))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set rlx=rOx(rkx,C0v,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,C0v,rIx,rlx),EHo)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call rHx(((EHo)))
endfunction
function c5o takes integer oqx returns integer
if(oqx==w)then
call oYx("User_GetNativeIndex","call DebugEx(User.NAME + \"GetNativeIndex: no valid user \" + Integer.ToString(this))",uD+"GetNativeIndex: no valid user "+(I2S((oqx))))
return-1
endif
if(vx[oqx]==null)then
call oYx("User_GetNativeIndex","call DebugEx(User.NAME + \"GetNativeIndex: no valid self \" + Integer.ToString(this))",uD+"GetNativeIndex: no valid self "+(I2S((oqx))))
return-1
endif
return GetPlayerId(vx[oqx])
endfunction
function c6o takes integer oqx returns integer
set Cyv[oqx]=true
set C4v[oqx]=false
call rax(Rnv)
return oqx
endfunction
function c7o takes nothing returns integer
local integer oqx
if(C2v==8190)then
call oYx("FolderUnit_FolderSelection_StructCircle_Allocation_allocCustom","call DebugEx(FolderUnit_FolderSelection_StructCircle.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",RVv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(CWv[(w)]==w)then
set C3v=C3v+1
set oqx=C3v
else
set oqx=CWv[(w)]
set CWv[(w)]=CWv[CWv[(w)]]
endif
set CWv[oqx]=Z
set Cwv[oqx]=1
call c6o(oqx)
return oqx
endfunction
function c8o takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((dB[(oqx)]))])]))],((((aB[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function c9o takes integer oqx,integer ocx returns nothing
local integer rkx=oqx
local string Cvo
local integer czo
if iVx(ocx)then
set Cvo=Rav[c5o(ocx)+1]
else
set Cvo=""
endif
set oqx=c7o()
set czo=(Abx((rkx),(Cvo),(C5v),(ri)))
set Ctv[oqx]=czo
set CUv[oqx]=rkx
set Cuv[oqx]=ocx
call c8o(czo,CTv,oqx)
call hJx(ocx,CSv+rkx,oqx)
endfunction
function Ceo takes integer oqx,integer ocx returns nothing
local integer rkx=oqx
local integer rdx=rEx(0)
local integer EHo
local integer olx
local integer rIx
local integer rlx
set Vv[(rdx)]=(oqx)
set eN[(rdx)]=(ocx)
set EHo=rEx((A[(rkx)]))
set Vv[(EHo)]=(oqx)
set eN[(EHo)]=(ocx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((C_v))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((C_v))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set rlx=rOx(rkx,C_v,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,C_v,rIx,rlx),EHo)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call rHx(((EHo)))
endfunction
function Cxo takes integer oqx,integer ocx returns nothing
local integer rkx=oqx
if not hdx(ocx,db,rkx)then
call hMx(ocx,db,rkx)
if rtx(rkx,db,ocx)then
call I7x(rkx,Csv)
call I7x(rkx,CYv)
endif
call c4o(oqx,ocx)
call c9o(oqx,ocx)
endif
call Ceo(oqx,ocx)
endfunction
function Coo takes nothing returns boolean
call Cxo((Q_x()),opx())
return true
endfunction
function Cro takes nothing returns nothing
endfunction
function Cio takes nothing returns nothing
set Csv=XBx("FolderUnit_StructSelection_Init: set FolderUnit_StructSelection.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructSelection.Event_Death)",VP,BI,function c1o)
set CYv=XBx("FolderUnit_StructSelection_Init: set FolderUnit_StructSelection.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructSelection.Event_Destroy)",EP,BI,function c2o)
set Czv=(E0x())
set CZv=Xhx(function c3o)
set C_v=(E0x())
set C0v=(E0x())
set C1v=Xhx(function Coo)
call Q2x(CZv,Ge,EVENT_PLAYER_UNIT_DESELECTED,null)
call Q2x(C1v,Ge,EVENT_PLAYER_UNIT_SELECTED,null)
call Cro()
endfunction
function Cao takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
call Bxx(oqx,(bbv[(Ajo)])-(bbv[(AHo)]))
return true
endfunction
function Cno takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=(Vv[(rdx)])
set RF[oqx]=false
call Rmx((oqx),IF)
call bzx(oqx,(XF[(oqx)]),OF[oqx])
return true
endfunction
function CVo takes integer oqx,real oSx returns nothing
set DF[oqx]=oSx
call Bvx((oqx))
endfunction
function CEo takes integer oqx,real oSx returns nothing
call CVo(oqx,(DF[(oqx)])+oSx)
endfunction
function CXo takes nothing returns boolean
local integer rdx=(bv)
call CEo(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function COo takes nothing returns nothing
call DNx(XBx("FolderUnit_FolderAgility_StructBase_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAgility_StructBase.Event_TypeChange).AddToStatics()",OP,BI,function Cao))
set IF=XBx("FolderUnit_FolderAgility_FolderBonus_StructDisplayed_Init: set FolderUnit_FolderAgility_FolderBonus_StructDisplayed.SELECTION_EVENT = Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAgility_FolderBonus_StructDisplayed.Event_Selection)",C0v,BI,function Cno)
set C6v=AUo(RMv,function CXo)
endfunction
function CRo takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
call BYx(oqx,(bBv[(Ajo)])-(bBv[(AHo)]))
return true
endfunction
function CIo takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=(Vv[(rdx)])
set ag[oqx]=false
call Rmx((oqx),ng)
call BMx(oqx,(rg[(oqx)]),ig[oqx])
return true
endfunction
function CAo takes integer oqx,real oSx returns nothing
set Ag[oqx]=oSx
call BWx((oqx))
endfunction
function CNo takes integer oqx,real oSx returns nothing
call CAo(oqx,(Ag[(oqx)])+oSx)
endfunction
function Cbo takes nothing returns boolean
local integer rdx=(bv)
call CNo(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function CBo takes nothing returns nothing
call DNx(XBx("FolderUnit_FolderIntelligence_StructBase_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderIntelligence_StructBase.Event_TypeChange).AddToStatics()",OP,BI,function CRo))
set ng=XBx("FolderUnit_FolderIntelligence_FolderBonus_StructDisplayed_Init: set FolderUnit_FolderIntelligence_FolderBonus_StructDisplayed.SELECTION_EVENT = Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderIntelligence_FolderBonus_StructDisplayed.Event_Selection)",C0v,BI,function CIo)
set C7v=AUo(RUv,function Cbo)
endfunction
function Cco takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
call c4x(oqx,(bcv[(Ajo)])-(bcv[(AHo)]))
return true
endfunction
function CCo takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=(Vv[(rdx)])
set TG[oqx]=false
call Rmx((oqx),uG)
call cTx(oqx,(SG[(oqx)]),tG[oqx])
return true
endfunction
function Cdo takes integer oqx,real oSx returns nothing
set ZG[oqx]=oSx
call c2x((oqx))
endfunction
function CDo takes integer oqx,real oSx returns nothing
call Cdo(oqx,(ZG[(oqx)])+oSx)
endfunction
function Cfo takes nothing returns boolean
local integer rdx=(bv)
call CDo(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function CFo takes nothing returns nothing
call DNx(XBx("FolderUnit_FolderStrength_StructBase_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderStrength_StructBase.Event_TypeChange).AddToStatics()",OP,BI,function Cco))
set uG=XBx("FolderUnit_FolderStrength_FolderBonus_StructDisplayed_Init: set FolderUnit_FolderStrength_FolderBonus_StructDisplayed.SELECTION_EVENT = Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderStrength_FolderBonus_StructDisplayed.Event_Selection)",C0v,BI,function CCo)
set C8v=AUo(R2v,function Cfo)
endfunction
function Cgo takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
local integer olx
local integer rJx
if I6x((oqx),yd)then
return true
endif
call AIo(oqx)
set olx=OVo(Ajo)
loop
exitwhen(olx<0)
set rJx=OXo(Ajo,olx)
call OOo(oqx,rJx,ORo(Ajo,rJx))
set olx=olx-1
endloop
return true
endfunction
function CGo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer olx=CXx(rkx,mH)
local integer oqx
loop
set oqx=COx(rkx,mH,olx)
call Czx(oqx,KH[oqx],rkx,LH[oqx])
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function Cho takes nothing returns nothing
set MH=XBx("FolderUnit_FolderAbilities_StructCooldown_Init: set FolderUnit_FolderAbilities_StructCooldown.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAbilities_StructCooldown.Event_Destroy)",EP,BI,function CGo)
set pH=(E0x())
set PH=(E0x())
endfunction
function CHo takes nothing returns integer
local unit oMx=GetSpellTargetUnit()
local integer o4x
if(GetUnitAbilityLevel(oMx,'aLoc')>0)then
set oMx=null
return Z
endif
set o4x=aBx(oMx)
set oMx=null
return o4x
endfunction
function Cjo takes integer oMx returns integer
return(LoadInteger(o[((V[(E[((X))])]))],(((oMx))),(((mv)))))
endfunction
function CJo takes integer CMx,integer rwx,integer drx,real dix,real dax,integer rJx returns nothing
local integer dnx=rEx((A[(CMx)]))
local integer rKx
local integer olx
local integer rIx
local integer rlx
set Mv[(dnx)]=(rwx)
set nv[(dnx)]=(rJx)
set UH[(dnx)]=((dix)*1.)
set wH[(dnx)]=((dax)*1.)
set WH[(dnx)]=(drx)
set Vv[(dnx)]=(CMx)
set rKx=rEx((Ev[(rJx)]))
set Mv[(rKx)]=(rwx)
set nv[(rKx)]=(rJx)
set UH[(rKx)]=((dix)*1.)
set wH[(rKx)]=((dax)*1.)
set WH[(rKx)]=(drx)
set Vv[(rKx)]=(CMx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rfx(rJx,C9v,rIx)
loop
exitwhen(rlx<q)
call rCx(rFx(rJx,C9v,rIx,rlx),dnx)
set rlx=rlx-1
endloop
set rlx=rOx(CMx,C9v,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(CMx,C9v,rIx,rlx),rKx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((dnx)))
call rHx(((rKx)))
endfunction
function Cko takes nothing returns boolean
local integer CMx=Q_x()
local integer drx=CHo()
local real dix=(GetSpellTargetX())
local real dax=(GetSpellTargetY())
local integer rJx=(Cjo(GetSpellAbilityId()))
local integer rwx=rux(CMx,rJx)
call CJo(CMx,rwx,drx,dix,dax,rJx)
return true
endfunction
function CKo takes integer oqx,code oSx returns nothing
if(oSx==null)then
return
endif
set DA[oqx]=CreateTrigger()
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((DA[oqx]))))),((((gA)))),((((oqx)))))
call TriggerAddCondition(DA[oqx],Condition(oSx))
endfunction
function Clo takes nothing returns boolean
if not(I5x((ITv),Rb,(Q_x())))then
return false
endif
if((Cjo(GetSpellAbilityId()))==w)then
return false
endif
return true
return true
endfunction
function CLo takes nothing returns nothing
set C9v=(E0x())
set dvv=Xhx(function Cko)
set ITv=JIx("FolderUnit_FolderAbilities_FolderEvents_StructBegin_Init: set FolderUnit_FolderAbilities_FolderEvents_StructBegin.REG_GROUP = UnitList.Create()")
call CKo(dvv,function Clo)
call Q2x(dvv,Ge,EVENT_PLAYER_UNIT_SPELL_CAST,null)
endfunction
function Cmo takes nothing returns nothing
set oev=(E0x())
set oxv=(E0x())
endfunction
function CMo takes integer rkx returns boolean
return(I5x((IUv),Rb,(rkx)))
endfunction
function Cpo takes integer oqx returns nothing
set bCv[oqx]=GetHeroSkillPoints(C[(oqx)])-1
endfunction
function CPo takes nothing returns boolean
local integer rkx=Q_x()
if not CMo(rkx)then
return true
endif
call Cpo(rkx)
call rWx((rkx),(Cjo(GetLearnedSkill())))
return true
endfunction
function Cqo takes nothing returns nothing
set Pv=(E0x())
set pv=(E0x())
set dev=Xhx(function CPo)
set IUv=JIx("FolderUnit_FolderAbilities_FolderEvents_StructLearn_Init: set FolderUnit_FolderAbilities_FolderEvents_StructLearn.REG_GROUP = UnitList.Create()")
call Q2x(dev,Ge,EVENT_PLAYER_HERO_SKILL,null)
endfunction
function CQo takes nothing returns boolean
local integer CMx=Q_x()
local integer oqx=CMx
local integer CQx=Th[oqx]
local integer Ajo
local integer Cso
local integer CSo
if(CQx==w)then
return true
endif
if dov[oqx]then
return true
endif
set Ajo=(x6v[((OH[(CQx)]))])
set Cso=drv[Ajo]
if(Cso!=0)then
call rQx(CMx,Cso)
set CSo=Bdo()
set Rh[(CSo)]=(X3)
set cLv[(CSo)]=(Ajo)
set gj[(CSo)]=((Uh[(CQx)]))
set Cj[(CSo)]=(((wh[(CQx)]))*1.)
set dj[(CSo)]=(((Wh[(CQx)]))*1.)
call dHx(CSo)
endif
call dIx(CQx,w)
return true
endfunction
function Cto takes integer oqx returns integer
return(Rh[(zH[oqx])])
endfunction
function CTo takes integer oqx,integer Cuo returns integer
return oPx((oqx),fh+Cuo)
endfunction
function CUo takes integer CQx returns nothing
local integer CMx=(aH[(CQx)])
local integer rwx=(XH[(CQx)])
local integer dox=(uh[(CQx)])
local integer drx=(Uh[(CQx)])
local real dix=(wh[(CQx)])
local real dax=(Wh[(CQx)])
local integer rJx=(OH[(CQx)])
local integer dnx=rEx((A[(CMx)]))
local integer rKx
local integer olx
local integer rIx
local integer rlx
set TH[(dnx)]=(dox)
set Mv[(dnx)]=(rwx)
set nv[(dnx)]=(rJx)
set uH[(dnx)]=(CQx)
set UH[(dnx)]=((dix)*1.)
set wH[(dnx)]=((dax)*1.)
set WH[(dnx)]=(drx)
set Vv[(dnx)]=(CMx)
set rKx=rEx((Ev[(rJx)]))
set TH[(rKx)]=(dox)
set Mv[(rKx)]=(rwx)
set nv[(rKx)]=(rJx)
set uH[(rKx)]=(CQx)
set UH[(rKx)]=((dix)*1.)
set wH[(rKx)]=((dax)*1.)
set WH[(rKx)]=(drx)
set Vv[(rKx)]=(CMx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(CMx,div,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(CMx,div,rIx,rlx),dnx)
set rlx=rlx-1
endloop
set rlx=rfx(rJx,div,rIx)
loop
exitwhen(rlx<q)
call rCx(rFx(rJx,div,rIx,rlx),rKx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((dnx)))
call rHx(((rKx)))
endfunction
function Cwo takes nothing returns boolean
local integer CMx=Q_x()
local integer rJx=(Cjo(GetSpellAbilityId()))
local integer CWo=Cto(CMx)
local integer oqx=CMx
local integer CQx=Cmx(CMx,rJx)
local integer rwx
local real dix
local real dax
local integer dox
local integer drx
if CBx(CWo)then
set rwx=(Ckx(((CTo(CMx,((CWo)-dh)))),yh+(rJx)))
set dov[oqx]=true
else
set rwx=rux(CMx,rJx)
set dov[oqx]=false
endif
set Th[oqx]=CQx
set dix=(GetSpellTargetX())
set dax=(GetSpellTargetY())
if((x6v[((OH[(CQx)]))])==0)then
set dox=w
set drx=w
else
set dox=(BGo(GetSpellTargetItem()))
set drx=CHo()
endif
set iH[(CQx)]=((UCx(CMx,dix-DPx(CMx),dax-DQx(CMx)))*1.)
set XH[(CQx)]=(rwx)
set uh[(CQx)]=(dox)
set Uh[(CQx)]=(drx)
set wh[(CQx)]=((dix)*1.)
set Wh[(CQx)]=((dax)*1.)
call CUo(CQx)
return true
endfunction
function Cyo takes integer oqx,integer CYo returns nothing
call UnitRemoveAbility(C[(((oqx)))],(CYo))
endfunction
function Czo takes nothing returns boolean
local integer CMx=Q_x()
if(CMx==w)then
return false
endif
if(QSx(CMx,'BPar')>0)then
call Cyo(CMx,'BPar')
endif
if not(I5x((Iuv),Rb,(CMx)))then
return false
endif
if((Cjo(GetSpellAbilityId()))==w)then
return false
endif
return true
return true
endfunction
function CZo takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),cH)
return true
endfunction
function C_o takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer Rvx=(Nh[(rdx)])
local integer C0o
if(Rvx==K3)then
call Ayx(CMx,cH)
elseif(Rvx==E4)then
set C0o=(ze[(CMx)])
if((OZx(CMx,C0o)==q)and(O4x(CMx,C0o,q)==CMx))then
call Ayx(CMx,cH)
endif
endif
return true
endfunction
function C1o takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
if((Nh[(rdx)])==A4)then
call Ayx(CMx,cH)
endif
return true
endfunction
function C2o takes integer Ixx returns nothing
local integer olx=CXx(Ixx,xJv)
local integer CMx
loop
set CMx=COx(Ixx,xJv,olx)
call Ayx(CMx,cH)
set olx=olx-1
exitwhen(olx<q)
endloop
endfunction
function C3o takes nothing returns boolean
local integer rdx=(bv)
call C2o((Vv[(rdx)]))
return true
endfunction
function C4o takes nothing returns boolean
local integer rdx=(bv)
call C2o((Vv[(rdx)]))
return true
endfunction
function C5o takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rJx=(nv[(rdx)])
local integer oqx=CMx
if((OH[(xfv[oqx])])==rJx)then
call Ayx(CMx,cH)
endif
return true
endfunction
function C6o takes nothing returns nothing
set x3v=inx()
set xFv=XBx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Init: set FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_Death)",VP,BI,function CZo)
set xgv=XBx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Init: set FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.ORDER_EVENT = Event.Create(UNIT.Order.Events.Gain.Immediate.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_Order)",bj,BI,function C_o)
set xGv=XBx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Init: set FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.ORDER_POINT_EVENT = Event.Create(UNIT.Order.Events.Gain.Point.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_Order)",Dj,BI,function C_o)
set xhv=XBx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Init: set FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.ORDER_TARGET_EVENT = Event.Create(UNIT.Order.Events.Gain.Target.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_Order)",Gj,BI,function C_o)
set xHv=XBx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Init: set FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.STUN_EVENT = Event.Create(UNIT.Order.Events.Gain.Target.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_Stun)",Gj,BI,function C1o)
set xkv=XBx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Init: set FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.TARGET_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_TargetDeath)",VP,BI,function C3o)
set xKv=XBx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Init: set FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.TARGET_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_TargetDestroy)",EP,BI,function C4o)
set xjv=XBx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Init: set FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.UNLEARN_EVENT = Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_Unlearn)",Av,BI,function C5o)
endfunction
function C7o takes nothing returns nothing
set ah=(E0x())
set dxv=Xhx(function CQo)
set div=(E0x())
set dav=Xhx(function Cwo)
set Iuv=JIx("FolderUnit_FolderAbilities_FolderEvents_StructEffect_Init: set FolderUnit_FolderAbilities_FolderEvents_StructEffect.REG_GROUP = UnitList.Create()")
call CKo(dxv,function Czo)
call Q2x(dxv,Ge,EVENT_PLAYER_UNIT_SPELL_ENDCAST,null)
call CKo(dav,function Czo)
call Q2x(dav,Ge,EVENT_PLAYER_UNIT_SPELL_EFFECT,null)
set drv[0]='AUCI'
set drv[2]='AUCP'
set drv[3]='AUCQ'
set drv[4]='AUCU'
call C6o()
endfunction
function C8o takes nothing returns nothing
call CLo()
call Cmo()
call Cqo()
set Av=(E0x())
call C7o()
endfunction
function C9o takes nothing returns nothing
call DNx(XBx("FolderUnit_StructAbilities_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructAbilities.Event_TypeChange).AddToStatics()",OP,BI,function Cgo))
set sb=(E0x())
call Cho()
call C8o()
endfunction
function dvo takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
call Ito(oqx,(I3v[(Ajo)])-(I3v[(AHo)]))
return true
endfunction
function deo takes integer oqx,real oSx returns nothing
set I4v[oqx]=oSx
call OKo((oqx))
endfunction
function dxo takes integer oqx,real oSx returns nothing
call deo(oqx,(I4v[(oqx)])+oSx)
endfunction
function doo takes nothing returns boolean
local integer rdx=(bv)
call dxo(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function dro takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=(Vv[(rdx)])
set I7v[oqx]=false
call Rmx((oqx),Aov)
call OHo(oqx,(I5v[(oqx)]),I6v[oqx])
return true
endfunction
function dio takes nothing returns nothing
set dnv=AUo(o9v,function doo)
set Aov=XBx("FolderUnit_FolderArmor_FolderBonus_StructDisplayed_Init: set FolderUnit_FolderArmor_FolderBonus_StructDisplayed.SELECTION_EVENT = Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderArmor_FolderBonus_StructDisplayed.Event_Selection)",C0v,BI,function dro)
endfunction
function dao takes integer oqx,real oSx returns nothing
set I9v[oqx]=oSx
call OKo((oqx))
endfunction
function dno takes integer oqx,real oSx returns nothing
call dao(oqx,(I9v[(oqx)])+oSx)
endfunction
function dVo takes nothing returns boolean
local integer rdx=(bv)
call dno(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function dEo takes integer oqx,real oSx returns nothing
set EWv[(oqx)]=(((EWv[(oqx)])+oSx)*1.)
endfunction
function dXo takes nothing returns boolean
local integer rdx=(bv)
call dEo(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function dOo takes integer oqx,real oSx returns nothing
set Etv[(oqx)]=(((Etv[(oqx)])+oSx)*1.)
endfunction
function dRo takes nothing returns boolean
local integer rdx=(bv)
call dOo(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function dIo takes nothing returns boolean
local integer rdx=(bv)
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
set Aev[(oqx)]=((Axv[(Ajo)]))
return true
endfunction
function dAo takes nothing returns nothing
call DNx(XBx("FolderUnit_FolderArmor_StructBase_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderArmor_StructBase.Event_TypeChange).AddToStatics()",OP,BI,function dvo))
call dio()
set dVv=AUo(rnv,function dVo)
set nvv=AUo(rEv,function dXo)
set dEv=AUo(rOv,function dRo)
call DNx(XBx("FolderUnit_FolderArmor_StructTypeA_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderArmor_StructTypeA.Event_TypeChange).AddToStatics()",OP,BI,function dIo))
endfunction
function dNo takes nothing returns nothing
endfunction
function dbo takes integer oqx,integer Ajo returns nothing
set cg[oqx]=(Asv[(Ajo)])
set dg[oqx]=false
endfunction
function dBo takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
call dbo(oqx,Ajo)
call cox(oqx,(AQv[(Ajo)])-(AQv[(AHo)]))
return true
endfunction
function dco takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=(Vv[(rdx)])
if B0x(oqx,(Cg[(oqx)]),cg[oqx])then
set dg[oqx]=false
call Rmx((oqx),Dg)
endif
return true
endfunction
function dCo takes nothing returns nothing
call DNx(XBx("FolderUnit_FolderDamage_StructBase_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDamage_StructBase.Event_TypeChange).AddToStatics()",OP,BI,function dBo))
set Dg=XBx("FolderUnit_FolderDamage_FolderBase_StructDisplayed_Init: set FolderUnit_FolderDamage_FolderBase_StructDisplayed.SELECTION_EVENT = Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDamage_FolderBase_StructDisplayed.Event_Selection)",C0v,BI,function dco)
endfunction
function ddo takes nothing returns boolean
local integer rdx=(bv)
call cwx(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function dDo takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=(Vv[(rdx)])
set Pg[oqx]=false
call Rmx((oqx),qg)
call B4x(oqx,(pg[(oqx)]),Mg[oqx])
return true
endfunction
function dfo takes nothing returns nothing
set dXv=AUo(aAv,function ddo)
set qg=XBx("FolderUnit_FolderDamage_FolderBonus_StructDisplayed_Init: set FolderUnit_FolderDamage_FolderBonus_StructDisplayed.SELECTION_EVENT = Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDamage_FolderBonus_StructDisplayed.Event_Selection)",C0v,BI,function dDo)
endfunction
function dFo takes nothing returns boolean
local integer rdx=(bv)
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
set ATv[(oqx)]=((Auv[(Ajo)]))
return true
endfunction
function dgo takes nothing returns integer
local unit oMx=GetEventDamageSource()
local integer o4x
if(GetUnitAbilityLevel(oMx,'aLoc')>0)then
set oMx=null
return Z
endif
set o4x=aBx(oMx)
set oMx=null
return o4x
endfunction
function dGo takes integer oqx,integer Ixx returns real
return bJx(((rF[((Ixx))])-(IMv[((oqx))]))*1./ 'd',.05,.5)
endfunction
function dho takes integer oqx,integer Ixx returns boolean
if not(Nov[((Ixx))]>0)then
return false
endif
if(Euv[(Ixx)])then
return false
endif
if(xk[((oqx))])then
return false
endif
if((GetRandomReal(((.0)*1.),((1.)*1.)))>dGo((oqx),Ixx))then
return false
endif
call OMx((oqx),iqx("patzer","dfffdfdf"),.02,140.,.0,1.5,(0))
call RUx((Abx((Ixx),("Abilities\\Spells\\Orc\\MirrorImage\\MirrorImageDeathCaster.mdl"),("chest"),(Bi))))
return true
endfunction
function dHo takes integer oqx,integer Ixx,real nyx returns nothing
local integer rkx=oqx
local integer rdx=rEx(0)
local integer Rrx
local integer olx
local integer rIx
local integer rlx
set Vv[(rdx)]=(rkx)
set WH[(rdx)]=(Ixx)
set Rrx=rEx((A[(rkx)]))
set Vv[(Rrx)]=(rkx)
set WH[(Rrx)]=(Ixx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((BBv))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((BBv))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set rlx=rOx(rkx,BBv,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,BBv,rIx,rlx),Rrx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call rHx(((Rrx)))
endfunction
function djo takes integer oqx,integer Ixx,real nyx returns real
set nyx=nyx*2.
call dHo(oqx,Ixx,nyx)
return nyx
endfunction
function dJo takes integer oqx,integer Ixx returns nothing
local integer rkx=oqx
local real o2x
if(IsUnitAlly(C[(Ixx)],vx[(rkx)]))then
return
endif
set o2x=(IQv[(oqx)])
if(o2x<=.0)then
return
endif
call OMx(rkx,iqx("+"+(I2S(((R2I(((o2x)*1.)))))),"ffc80000"),.02,80.,.0,3.,(0))
call RUx((Abx((rkx),(dAv),(dNv),(Bi))))
call cGx(rkx,o2x)
endfunction
function dko takes integer oqx,integer Ixx returns nothing
local integer rkx=oqx
local real o2x
if(IsUnitAlly(C[(Ixx)],vx[(rkx)]))then
return
endif
set o2x=(Isv[(oqx)])
if(o2x<=.0)then
return
endif
call OMx(rkx,iqx("+"+(I2S(((R2I(((o2x)*1.)))))),"ffc80000"),.02,80.,.0,3.,(0))
call RUx((Abx((rkx),(dbv),(dBv),(Bi))))
call BRx(rkx,o2x)
endfunction
function dKo takes integer oqx,integer oQx returns boolean
return(LoadBoolean(o[((V[(E[((Fw[(oqx)]))])]))],((((gw[((oqx))])))),(((oQx)))))
endfunction
function dlo takes integer oqx,integer dLo returns boolean
return dKo((oqx),dcv+dLo)
endfunction
function dmo takes integer oqx,integer Ixx,real nyx,integer rRx returns nothing
set nyx=nyx*(1.-(I8v[(Ixx)]))
set nyx=nyx*nNo((ETv[(Ixx)]))
set nyx=nyx*(kO[(rRx)*7+((Aev[(Ixx)]))])
call NOo((oqx),Ixx,nyx,false)
endfunction
function dMo takes integer oqx,real dpo,integer dPo,real x,real y,integer dqo returns nothing
local integer dQo=(CXx((((oqx))),Alv))
local boolean dso
local integer d5x
local integer olx
local integer O4o
local integer Ixx
local real dSo
if(dQo<q)then
return
endif
set dso=(dlo((uf[((((oqx))))]),(0)))
set d5x=(ze[((oqx))])
call dpx(dCv,dqo)
set olx=q
loop
set O4o=(COx((((oqx))),Alv,(olx)))
set ddv=dso
set Hf=d5x
call Nio(dDv,x,y,(Akv[(O4o)]),dfv)
set Ixx=Nao(dDv)
if(Ixx!=w)then
set dSo=dpo*(AKv[(O4o)])
loop
call dpx(dCv,Ixx)
call dmo(oqx,Ixx,dSo,dPo)
set Ixx=Nao(dDv)
exitwhen(Ixx==w)
endloop
endif
set olx=olx+1
exitwhen(olx>dQo)
endloop
call dux((dCv),Rb)
endfunction
function dto takes integer oqx,integer Ixx,boolean nFo,real nyx returns nothing
local real armorAmount=(ETv[(Ixx)])
local boolean njo=false
local integer dPo=(AYv[((oqx))])
local real dTo
local integer oldTextTag
local integer rkx=oqx
local real dix=DPx(Ixx)
local real dax=DQx(Ixx)
local integer olx=(ATv[(rkx)])
local integer duo=(Awv[(rkx)])
if dho(rkx,Ixx)then
return
endif
if nBo(Ixx)then
return
endif
loop
exitwhen(olx<1)
set nyx=nyx+(GetRandomInt((1),(duo)))
set olx=olx-1
endloop
set nyx=nyx*(1.-(I8v[(Ixx)]))
set nyx=nyx*nNo((ETv[(Ixx)]))
set nyx=nyx*(kO[((AYv[(rkx)]))*7+((Aev[(Ixx)]))])
set njo=nbo(rkx,Ixx)
set nyx=nco(oqx,nyx,Ixx,false)
set dTo=NOo(rkx,Ixx,nyx,false)
if njo then
set dTo=djo(rkx,Ixx,dTo)
if(dTo>.0)then
call ngo(Ixx,iqx((I2S(((R2I(((((dTo)*1.))*1.))))))+"!",(rb[((ze[(rkx)]))])),nho(dTo,(iG[(Ixx)])*1./ 2.,.024,.028),160.,.0,1.,dIv+Ixx,dTo*1./ 2)
endif
else
if(dTo>.0)then
call ngo(Ixx,iqx((I2S(((R2I(((((dTo)*1.))*1.)))))),(rb[((ze[(rkx)]))])),nho(dTo,(iG[(Ixx)])*1./ 2.,.016,.022),160.,.0,1.,dIv+Ixx,dTo*1./ 2)
endif
endif
call dJo(rkx,Ixx)
call dko(rkx,Ixx)
call dMo(oqx,nyx,dPo,dix,dax,Ixx)
endfunction
function dUo takes nothing returns boolean
local integer rkx=dgo()
local boolean nCo=dRv
local integer Ixx=Q_x()
if((rkx==Z)or((GetEventDamage())==.0)or((ANv[((uf[(((rkx)))]))])==Abv))then
set yH=true
endif
set dRv=false
if yH then
set yH=false
else
if nCo then
call nco((rkx),.0,Ixx,true)
else
call dto((rkx),Ixx,true,(mg[(rkx)]))
endif
endif
return true
endfunction
function dwo takes nothing returns boolean
local integer Ixx=jFx()
if(I5x((dCv),Rb,(Ixx)))then
return false
endif
if(not ddv and(IsUnitAlly(C[(Ixx)],vx[(Hf)])))then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
return true
return true
endfunction
function dWo takes nothing returns nothing
set dOv=(E0x())
set EZv=(E0x())
set AUv=Xhx(function dUo)
set dfv=XLx(function dwo)
set dDv=O2x()
set dCv=JIx("FolderUnit_FolderDamage_StructEvents_Init: set FolderUnit_FolderDamage_StructEvents.SPLASH_GROUP2 = UnitList.Create()")
set dFv=(E0x())
set Ezv=(E0x())
endfunction
function dyo takes integer oqx returns nothing
call cUx(oqx,(kg[(oqx)]))
endfunction
function dYo takes integer oqx,real oSx returns nothing
set Kg[oqx]=oSx
call dyo((oqx))
endfunction
function dzo takes integer oqx,real oSx returns nothing
call dYo(oqx,(Kg[(oqx)])+oSx)
endfunction
function dZo takes nothing returns boolean
local integer rdx=(bv)
call dzo(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function d_o takes nothing returns boolean
local integer rdx=(bv)
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
set Awv[(oqx)]=((AWv[(Ajo)]))
return true
endfunction
function d0o takes nothing returns boolean
local integer rdx=(bv)
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
set AYv[(oqx)]=((Azv[(Ajo)]))
return true
endfunction
function d1o takes nothing returns nothing
call dCo()
call dfo()
call DNx(XBx("FolderUnit_FolderDamage_StructDices_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDamage_StructDices.Event_TypeChange).AddToStatics()",OP,BI,function dFo))
call dWo()
set dgv=AUo(agv,function dZo)
call DNx(XBx("FolderUnit_FolderDamage_StructSides_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDamage_StructSides.Event_TypeChange).AddToStatics()",OP,BI,function d_o))
call DNx(XBx("FolderUnit_FolderDamage_StructTypeA_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDamage_StructTypeA.Event_TypeChange).AddToStatics()",OP,BI,function d0o))
endfunction
function d2o takes nothing returns nothing
endfunction
function d3o takes nothing returns nothing
endfunction
function d4o takes integer oqx,boolean o2x returns nothing
if o2x then
call UJx(((oqx)),x_v)
else
call DSx((((oqx))),(x_v),(1),w)
endif
endfunction
function d5o takes nothing returns boolean
local integer rdx=(bv)
call d4o(((Vv[(rdx)])),not(ic[(rdx)]))
return true
endfunction
function d6o takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
local boolean d7o=((Nlv[(Ajo)])>.0)
if(((Nlv[(AHo)])>.0)==d7o)then
if not d7o then
call RZo(oqx)
endif
return true
endif
if d7o then
call UJx(((oqx)),x_v)
else
call RZo(oqx)
endif
return true
endfunction
function d8o takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer olx=CXx(rkx,bsv)
local integer oqx
loop
set oqx=COx(rkx,bsv,olx)
call iHx(bPv[oqx])
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function d9o takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer rkx=bqv[oqx]
local real Dvo=DPx(rkx)
local real Deo=DQx(rkx)
local integer rdx=rEx((A[(rkx)]))
set bvv[(rdx)]=((Gyx(Dvo-djv[oqx],Deo-dJv[oqx]))*1.)
set Vv[(rdx)]=(rkx)
set djv[oqx]=Dvo
set dJv[oqx]=Deo
call rCx(bQv[oqx],rdx)
call rHx(((rdx)))
endfunction
function Dxo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer olx=CXx(rkx,bsv)
local integer oqx
loop
set oqx=COx(rkx,bsv,olx)
set djv[oqx]=DPx(rkx)
set dJv[oqx]=DQx(rkx)
call icx(bPv[oqx],bpv[oqx],true,function d9o)
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function Doo takes nothing returns nothing
set bSv=XBx("FolderUnit_FolderMovement_FolderEvents_StructInterval_Init: set FolderUnit_FolderMovement_FolderEvents_StructInterval.MOVE_ENDING_EVENT = Event.Create(UNIT.Movement.Events.ENDING_EVENT_TYPE, EventPriority.EVENTS, function FolderUnit_FolderMovement_FolderEvents_StructInterval.Event_Move_Ending)",bev,JI,function d8o)
set btv=XBx("FolderUnit_FolderMovement_FolderEvents_StructInterval_Init: set FolderUnit_FolderMovement_FolderEvents_StructInterval.MOVE_START_EVENT = Event.Create(UNIT.Movement.Events.START_EVENT_TYPE, EventPriority.EVENTS, function FolderUnit_FolderMovement_FolderEvents_StructInterval.Event_Move_Start)",bxv,JI,function Dxo)
endfunction
function Dro takes nothing returns nothing
set dhv=XXx()
set bev=(E0x())
set N7v=JIx("FolderUnit_FolderMovement_StructEvents_Init: set FolderUnit_FolderMovement_StructEvents.ENUM_GROUP = UnitList.Create()")
set N2v=JIx("FolderUnit_FolderMovement_StructEvents_Init: set FolderUnit_FolderMovement_StructEvents.EVENT_GROUP = UnitList.Create()")
set N8v=JIx("FolderUnit_FolderMovement_StructEvents_Init: set FolderUnit_FolderMovement_StructEvents.MOVING_GROUP = UnitList.Create()")
set bxv=(E0x())
set N3v=inx()
call XAx(dhv,function IIo)
set dHv=(E0x())
call Doo()
set dkv=(E0x())
endfunction
function Dio takes boolean b returns integer
if b then
return 1
endif
return 0
endfunction
function Dao takes integer oqx returns nothing
call rQx((oqx),'AUUD')
call UnitRemoveAbility(C[(((oqx)))],('AUUD'))
endfunction
function Dno takes integer oqx,real oSx returns nothing
local integer DVo
set NMv[oqx]=oSx
set oSx=(oSx+(Nmv[((oqx))]))*((Npv[((oqx))])-1.)
if(bUx(oSx)<.1)then
set oSx=.0
endif
if(oSx>.0)then
set DVo=3
else
set DVo=1+Dio(oSx<.0)
endif
call R5o((oqx))
call ryx((oqx),'AmSp',DVo)
call Dao((oqx))
endfunction
function DEo takes integer oqx,real oSx returns nothing
call Dno(oqx,(NMv[(oqx)])+oSx)
endfunction
function DXo takes nothing returns boolean
local integer rdx=(bv)
call DEo(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function DOo takes nothing returns nothing
call Qzx(Ge,'AmSx',false)
set dKv=AUo(VTv,function DXo)
endfunction
function DRo takes integer oqx returns nothing
call Dno(oqx,(NMv[(oqx)]))
endfunction
function DIo takes integer oqx,real oSx returns nothing
set Npv[oqx]=oSx
call DRo((oqx))
endfunction
function DAo takes integer oqx,real oSx returns nothing
call DIo(oqx,(Npv[(oqx)])+oSx)
endfunction
function DNo takes nothing returns boolean
local integer rdx=(bv)
call DAo(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function Dbo takes nothing returns nothing
call DOo()
set ZU=AUo(VUv,function DNo)
endfunction
function DBo takes nothing returns nothing
set dGv=AUo(Vyv,function d5o)
call DNx(XBx("FolderUnit_StructMovement_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructMovement.Event_TypeChange).AddToStatics()",OP,BI,function d6o))
call Dro()
call Dbo()
endfunction
function Dco takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
call Dwx(oqx,(Tj[(Ajo)])-(Tj[(AHo)]))
return true
endfunction
function DCo takes nothing returns boolean
local integer rdx=(bv)
call Dmx(((Vv[(rdx)])))
return true
endfunction
function Ddo takes nothing returns boolean
local integer rdx=(bv)
call DTx(((Vv[(rdx)])))
return true
endfunction
function DDo takes integer oqx,real oSx returns nothing
set tj[oqx]=oSx
call DTx((oqx))
endfunction
function Dfo takes integer oqx,real oSx returns nothing
call DDo(oqx,(tj[(oqx)])+oSx)
endfunction
function DFo takes nothing returns boolean
local integer rdx=(bv)
call Dfo(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function Dgo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer olx=CXx(rkx,fJ)
local integer oqx
loop
set oqx=COx(rkx,fJ,olx)
call D4x(oqx,CJ[oqx],rkx)
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function DGo takes nothing returns boolean
local integer rdx=(bv)
local integer Ipx=(Gc[(rdx)])
local real D7x=dmv[(Ipx)]
local real Dho=dMv[(Ipx)]
if not(fc[(rdx)])then
set D7x=-D7x
endif
call D6x(((Vv[(rdx)])),D7x,Dho)
return true
endfunction
function DHo takes nothing returns nothing
set FJ=XBx("FolderUnit_FolderScale_StructTimed_Init: set FolderUnit_FolderScale_StructTimed.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderScale_StructTimed.Event_Destroy)",EP,BI,function Dgo)
set HJ=inx()
set dLv=AUo(RJ,function DGo)
endfunction
function Djo takes nothing returns nothing
call DNx(XBx("FolderUnit_StructScale_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructScale.Event_TypeChange).AddToStatics()",OP,BI,function Dco))
set ayv=XBx("FolderUnit_StructScale_Init: set FolderUnit_StructScale.MODDED_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructScale.Event_Modded_Death)",VP,BI,function DCo)
set aYv=XBx("FolderUnit_StructScale_Init: set FolderUnit_StructScale.MODDED_REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructScale.Event_Modded_Revive)",XP,BI,function Ddo)
set dlv=AUo(aUv,function DFo)
call DHo()
endfunction
function DJo takes integer oqx returns nothing
set bmv[oqx]=false
call rgx(Vmv)
endfunction
function Dko takes integer oqx returns nothing
if(bLv[oqx]>0)then
return
endif
if(bKv[oqx]!=Z)then
call oYx("FolderUnit_FolderMovement_FolderEvents_StructInterval_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderMovement_FolderEvents_StructInterval.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",VMv+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set bKv[oqx]=bKv[(w)]
set bKv[(w)]=oqx
call DJo(oqx)
endfunction
function DKo takes integer oqx returns nothing
set bLv[oqx]=bLv[oqx]-1
call Dko(oqx)
endfunction
function Dlo takes integer oqx,integer oQx returns nothing
call SaveInteger(o[(((V[(E[((oA[(oqx)]))])])))],(((((nA[((oqx))]))))),((((oQx)))),(0))
endfunction
function DLo takes integer oqx,integer oQx,integer oSx returns boolean
local integer abx=oPx(oqx,oQx)
set oSx=(abx-oSx)
call rTx(oqx,oQx,oSx)
if(abx==0)then
return false
endif
return(oSx==0)
endfunction
function Dmo takes integer oqx,integer Xwx returns nothing
local integer rkx=oqx
if not DLo(rkx,N0v+Xwx,1)then
return
endif
call Rmx(rkx,Xwx)
if not DLo(rkx,N1v,1)then
return
endif
call IEo(N2v,rkx)
if(dKx((N2v),Rb))then
call iHx(N3v)
endif
endfunction
function DMo takes integer oqx,integer Xwx returns nothing
local integer rkx=oqx
local integer p0x
set oqx=FMx(Xwx,bJv+rkx)
if(oqx==w)then
call oYx("FolderUnit_FolderMovement_FolderEvents_StructInterval_Remove","call DebugEx(\"not listed \" + whichEvent.GetName() + \";\" + parent.GetName() + \";\" + I2S(parent))","not listed "+(JA[(Xwx)])+";"+(GetUnitName(C[(rkx)]))+";"+I2S(rkx))
return
endif
set p0x=bPv[oqx]
call DKo((oqx))
call ijx(p0x)
call Dlo(Xwx,bJv+rkx)
if rrx(rkx,bsv,oqx)then
call Dmo(rkx,bSv)
call Dmo(rkx,btv)
endif
endfunction
function Dpo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
call Rmx(rkx,bjv)
call DMo(rkx,bTv)
return true
endfunction
function DPo takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=(Vv[(rdx)])
local real oSx=iOx(.0,(NQv[(oqx)])-dpv)
call Iro(oqx,oSx)
return true
endfunction
function Dqo takes nothing returns nothing
endfunction
function DQo takes nothing returns nothing
set bjv=XBx("FolderUnit_StructStamina_Init: set FolderUnit_StructStamina.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructStamina.Event_Destroy)",EP,BI,function Dpo)
set bTv=XBx("FolderUnit_StructStamina_Init: set FolderUnit_StructStamina.MOVE_EVENT = Event.Create(NULL, NULL, function FolderUnit_StructStamina.Event_Move)",w,w,function DPo)
call Dqo()
endfunction
function Dso takes nothing returns nothing
endfunction
function DSo takes integer oqx,boolean o2x returns nothing
if o2x then
call UJx(((oqx)),xZv)
else
call DSx((((oqx))),(xZv),(1),w)
endif
endfunction
function Dto takes nothing returns boolean
local integer rdx=(bv)
call DSo(((Vv[(rdx)])),not(ic[(rdx)]))
return true
endfunction
function DTo takes nothing returns integer
local unit oMx=GetEventTargetUnit()
local integer o4x
if(GetUnitAbilityLevel(oMx,'aLoc')>0)then
set oMx=null
return Z
endif
set o4x=aBx(oMx)
set oMx=null
return o4x
endfunction
function Duo takes integer oqx,integer Ixx returns nothing
local integer rkx=oqx
local integer Oso=(uf[(rkx)])
local integer rdx=rEx((A[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set WH[(rdx)]=(Ixx)
set Vv[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,ow,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,ow,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function DUo takes integer oqx,integer OHx,integer rkx returns nothing
local integer Ixx=dqv[oqx]
call ijx(OHx)
set AIv[oqx]=false
call KFx(Ixx)
endfunction
function Dwo takes integer oqx,integer Ixx returns nothing
local integer rkx=oqx
local integer rdx=rEx((A[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set WH[(rdx)]=(Ixx)
set Vv[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx((oqx),dsv,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,dsv,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function DWo takes nothing returns nothing
local integer OHx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(OHx)])
call DUo(oqx,OHx,oqx)
call Dwo(oqx,dqv[oqx])
endfunction
function Dyo takes integer oqx,integer Ixx returns nothing
local integer OHx=inx()
if AIv[oqx]then
call DUo(oqx,dQv[oqx],oqx)
endif
set dQv[oqx]=OHx
set AIv[oqx]=true
set dqv[oqx]=Ixx
set ge[(OHx)]=(oqx)
call AYo(Ixx)
call icx(OHx,.01,false,function DWo)
endfunction
function DYo takes nothing returns boolean
local integer rkx=Q_x()
local integer Ixx=DTo()
if((IsUnitEnemy(C[(Ixx)],vx[((ze[(rkx)]))]))and(Cto(Ixx)==w))then
call Lvx(rkx,Xw,Ixx)
endif
call Duo((rkx),Ixx)
call Dyo((rkx),Ixx)
return true
endfunction
function Dzo takes integer oqx,integer Ixx returns nothing
local integer rkx=oqx
local integer Oso=(uf[(rkx)])
local integer rdx=rEx((A[(rkx)]))
local integer Gmx
local integer olx
local integer rIx
local integer rlx
set WH[(rdx)]=(Ixx)
set Vv[(rdx)]=(oqx)
set Gmx=rEx((gw[(Oso)]))
set WH[(Gmx)]=(Ixx)
set Vv[(Gmx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,dSv,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,dSv,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set rlx=Aao(Oso,dSv,rIx)
loop
exitwhen(rlx<q)
call rCx(Ano(Oso,dSv,rIx,rlx),Gmx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call rHx(((Gmx)))
endfunction
function DZo takes nothing returns boolean
local integer rkx=Q_x()
local integer Ixx=DTo()
call Dzo((rkx),Ixx)
return true
endfunction
function D_o takes integer rkx returns boolean
return(I5x((ARv),Rb,(rkx)))
endfunction
function D0o takes integer oqx,integer D1o returns nothing
local integer rkx=oqx
local integer D2o=rEx((A[(D1o)]))
local integer rdx
local integer olx
local integer rIx
local integer rlx
set WH[(D2o)]=(oqx)
set Vv[(D2o)]=(D1o)
set rdx=rEx((A[(rkx)]))
set WH[(rdx)]=(D1o)
set Vv[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(D1o,dTv,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(D1o,dTv,rIx,rlx),D2o)
set rlx=rlx-1
endloop
set rlx=rOx(rkx,dtv,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,dtv,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((D2o)))
call rHx(((rdx)))
endfunction
function D3o takes nothing returns integer
local unit oMx=(GetAttacker())
local integer o4x
if(GetUnitAbilityLevel(oMx,'aLoc')>0)then
set oMx=null
return Z
endif
set o4x=aBx(oMx)
set oMx=null
return o4x
endfunction
function D4o takes nothing returns boolean
local integer rkx=Q_x()
if not D_o(rkx)then
return true
endif
call D0o((rkx),D3o())
return true
endfunction
function D5o takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
call Rmx(rkx,AAv)
if AIv[oqx]then
call DUo(oqx,dQv[oqx],rkx)
endif
return true
endfunction
function D6o takes nothing returns nothing
set AAv=XBx("FolderUnit_FolderAttack_FolderEvents_StructAcquire2_Init: set FolderUnit_FolderAttack_FolderEvents_StructAcquire2.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAttack_FolderEvents_StructAcquire2.Event_Destroy)",EP,BI,function D5o)
set dsv=(E0x())
endfunction
function D7o takes unit oMx returns integer
return(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((oMx))))),((((Hy))))))
endfunction
function D8o takes integer oqx returns nothing
set dzv[oqx]=false
call rgx(rcv)
endfunction
function D9o takes integer oqx returns nothing
if(dyv[oqx]>0)then
return
endif
if(dYv[oqx]!=Z)then
call oYx("FolderUnit_FolderAttack_FolderEvents_StructGround_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderAttack_FolderEvents_StructGround.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",rCv+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set dYv[oqx]=dYv[(w)]
set dYv[(w)]=oqx
call D8o(oqx)
endfunction
function fvo takes integer oqx returns nothing
set dyv[oqx]=dyv[oqx]-1
call D9o(oqx)
endfunction
function feo takes integer oqx,integer HOx,integer rkx returns nothing
call fvo((oqx))
call L5x(HOx,dwv)
call HEx(HOx,dZv)
call rrx(rkx,d_v,oqx)
call KFx(rkx)
endfunction
function fxo takes integer oqx,integer dLo returns boolean
return dlo((uf[((oqx))]),dLo)
endfunction
function foo takes integer oqx returns integer
return CXx((oqx),Alv)
endfunction
function fro takes integer oqx,integer okx returns integer
return COx((oqx),Alv,okx)
endfunction
function fio takes integer oqx returns nothing
call DSx(((oqx)),(r9v),(1),w)
endfunction
function fao takes integer oqx returns nothing
call UJx((oqx),r9v)
endfunction
function fno takes integer oqx,integer Ixx,real nyx,integer rRx returns nothing
set nyx=nyx*(1.-(I8v[(Ixx)]))
set nyx=nyx*nNo((ETv[(Ixx)]))
set nyx=nyx*(kO[(rRx)*7+((Aev[(Ixx)]))])
call fio(Ixx)
call NOo((oqx),Ixx,nyx,false)
call fao(Ixx)
endfunction
function fVo takes integer oqx,real x,real y returns nothing
local boolean dso=fxo((oqx),0)
local real dpo=(mg[((oqx))])+(kg[((oqx))])
local integer fEo=(Awv[((oqx))])
local integer dPo=(AYv[((oqx))])
local integer olx=(ATv[((oqx))])
local integer dQo=foo((oqx))
local integer d5x=(ze[((oqx))])
local real dSo
local integer O4o
local integer Ixx
local real array fXo
loop
exitwhen(olx<1)
set dpo=dpo+(GetRandomInt((1),(fEo)))
set olx=olx-1
endloop
set dpo=dpo*(Kg[((oqx))])*(Ug[((oqx))])
set olx=q
loop
exitwhen(olx>dQo)
set O4o=fro((oqx),olx)
set ddv=dso
set Hf=d5x
call Nio(d1v,x,y,(Akv[(O4o)]),d2v)
loop
set Ixx=Nao(d1v)
exitwhen(Ixx==w)
if not(I5x((d3v),Rb,(Ixx)))then
set fXo[Ixx]=.0
call dpx(d3v,Ixx)
endif
set fXo[Ixx]=fXo[Ixx]+(AKv[(O4o)])
endloop
set olx=olx+1
endloop
loop
set Ixx=(dLx((d3v),Rb))
exitwhen(Ixx==w)
call fno(oqx,Ixx,dpo*fXo[Ixx],dPo)
endloop
endfunction
function fOo takes integer oqx,real x,real y returns nothing
local integer rkx=oqx
local integer rdx=rEx((A[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set UH[(rdx)]=((x)*1.)
set wH[(rdx)]=((y)*1.)
set Vv[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,d0v,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,d0v,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call fVo(oqx,x,y)
endfunction
function fRo takes nothing returns boolean
local integer HOx=(D7o(GetTriggerUnit()))
local integer rkx=dgo()
local integer oqx=m9x(HOx,dwv)
local real x
local real y
if(rkx!=dWv[oqx])then
return true
endif
set x=(oJ[(HOx)])
set y=(nJ[(HOx)])
call feo(oqx,HOx,rkx)
call fOo((rkx),x,y)
return true
endfunction
function fIo takes integer oqx returns integer
set dzv[oqx]=true
set d6v[oqx]=false
call rax(rcv)
return oqx
endfunction
function fAo takes nothing returns integer
local integer oqx
if(d4v==8190)then
call oYx("FolderUnit_FolderAttack_FolderEvents_StructGround_Allocation_allocCustom","call DebugEx(FolderUnit_FolderAttack_FolderEvents_StructGround.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",rCv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(dYv[(w)]==w)then
set d5v=d5v+1
set oqx=d5v
else
set oqx=dYv[(w)]
set dYv[(w)]=dYv[dYv[(w)]]
endif
set dYv[oqx]=Z
set dyv[oqx]=1
call fIo(oqx)
return oqx
endfunction
function fNo takes integer oqx returns integer
set Dev[oqx]=true
set Dxv[oqx]=false
call rax(ww)
return oqx
endfunction
function fbo takes nothing returns integer
local integer oqx
if(d7v==8190)then
call oYx("FolderDummyUnit_StructDestroyTimed_Allocation_allocCustom","call DebugEx(FolderDummyUnit_StructDestroyTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Ww+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(d8v[(w)]==w)then
set d9v=d9v+1
set oqx=d9v
else
set oqx=d8v[(w)]
set d8v[(w)]=d8v[d8v[(w)]]
endif
set d8v[oqx]=Z
set Dvv[oqx]=1
call fNo(oqx)
return oqx
endfunction
function fBo takes integer oqx returns nothing
set Dev[oqx]=false
call rgx(ww)
endfunction
function fco takes integer oqx returns nothing
if(Dvv[oqx]>0)then
return
endif
if(d8v[oqx]!=Z)then
call oYx("FolderDummyUnit_StructDestroyTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderDummyUnit_StructDestroyTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Ww+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set d8v[oqx]=d8v[(w)]
set d8v[(w)]=oqx
call fBo(oqx)
endfunction
function fCo takes integer oqx returns nothing
set Dvv[oqx]=Dvv[oqx]-1
call fco(oqx)
endfunction
function fdo takes nothing returns nothing
local integer ibx=ifx()
local integer oqx=(ge[(ibx)])
local integer rkx=Dov[oqx]
call fCo((oqx))
call ijx(ibx)
call MCx(rkx)
endfunction
function fDo takes integer oqx,real ilx returns nothing
local integer rkx=oqx
local integer ibx
set oqx=fbo()
set ibx=inx()
set Dov[oqx]=rkx
set ge[(ibx)]=(oqx)
call icx(ibx,ilx,false,function fdo)
endfunction
function ffo takes integer oqx returns real
return(Drv[((uf[((oqx))]))])
endfunction
function fFo takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(WH[(rdx)])
local integer rkx=(Vv[(rdx)])
local real dix=DPx(Ixx)
local real dax=DQx(Ixx)
local integer oqx=fAo()
local integer HOx=mcx('qGrA',dix,dax,.0,.0)
set dWv[oqx]=rkx
call TriggerRegisterUnitEvent(fA[((dUv))],zj[(HOx)],(EVENT_UNIT_DAMAGED))
call Mex(HOx,dwv,oqx)
call Mxx(HOx,dZv)
call rtx(rkx,d_v,oqx)
call AYo(rkx)
call fDo(HOx,jjx(dix-DPx(rkx),dax-DQx(rkx))*1./ ffo(rkx)+2.)
return true
endfunction
function fgo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
call Rmx(rkx,ABv)
call Rmx(rkx,Acv)
return true
endfunction
function fGo takes nothing returns boolean
local integer rdx=(bv)
local integer HOx=(Wp[(rdx)])
local integer oqx=m9x(HOx,dwv)
call feo(oqx,HOx,dWv[oqx])
return true
endfunction
function fho takes nothing returns boolean
local integer Ixx=jFx()
if(not ddv and(IsUnitAlly(C[(Ixx)],vx[(Hf)])))then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
return true
return true
endfunction
function fHo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local boolean fjo=((ANv[(Ajo)])==Abv)
if(((ANv[(AHo)])==Abv)==fjo)then
return true
endif
if fjo then
call I7x(rkx,ABv)
call I7x(rkx,Acv)
else
call Rmx(rkx,ABv)
call Rmx(rkx,Acv)
endif
return true
endfunction
function fJo takes nothing returns nothing
set dUv=Xhx(function fRo)
set ABv=XBx("FolderUnit_FolderAttack_FolderEvents_StructGround_Init: set FolderUnit_FolderAttack_FolderEvents_StructGround.ATTACK_EVENT = Event.Create(UNIT.Attack.Events.DUMMY_EVENT_TYPE, EventPriority.EVENTS, function FolderUnit_FolderAttack_FolderEvents_StructGround.Event_Attack)",dSv,JI,function fFo)
set Acv=XBx("FolderUnit_FolderAttack_FolderEvents_StructGround_Init: set FolderUnit_FolderAttack_FolderEvents_StructGround.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.EVENTS, function FolderUnit_FolderAttack_FolderEvents_StructGround.Event_Destroy)",EP,JI,function fgo)
set d0v=(E0x())
set dZv=XBx("FolderUnit_FolderAttack_FolderEvents_StructGround_Init: set FolderUnit_FolderAttack_FolderEvents_StructGround.DUMMY_UNIT_DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.EVENTS, function FolderUnit_FolderAttack_FolderEvents_StructGround.Event_DummyUnitDestroy)",aP,JI,function fGo)
set d1v=O2x()
set d3v=JIx("FolderUnit_FolderAttack_FolderEvents_StructGround_Init: set FolderUnit_FolderAttack_FolderEvents_StructGround.ENUM_GROUP2 = UnitList.Create()")
set d2v=XLx(function fho)
call DNx(XBx("FolderUnit_FolderAttack_FolderEvents_StructGround_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAttack_FolderEvents_StructGround.Event_TypeChange).AddToStatics()",OP,BI,function fHo))
endfunction
function fko takes nothing returns nothing
set ow=(E0x())
set AXv=Xhx(function DYo)
set dSv=(E0x())
set AOv=Xhx(function DZo)
set dtv=(E0x())
set ARv=JIx("FolderUnit_FolderAttack_StructEvents_Init: set FolderUnit_FolderAttack_StructEvents.OFFENDED_REG_GROUP = UnitList.Create()")
set dTv=(E0x())
set duv=Xhx(function D4o)
call Q2x(duv,Ge,EVENT_PLAYER_UNIT_ATTACKED,null)
call D6o()
call fJo()
endfunction
function fKo takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
call bjx(oqx,(ADv[(Ajo)])-(ADv[(AHo)]))
return true
endfunction
function flo takes integer oqx,unit oMx,real nyx,real bWx returns nothing
local integer byx
local integer bYx
set nyx=nyx*'d'
set bWx=bWx*'d'
if(nyx*bWx<=.0)then
if(bWx<.0)then
set bYx=Div
loop
call UnitRemoveAbility(oMx,v4v[bYx])
set bYx=bYx-1
exitwhen(bYx<0)
endloop
else
set bYx=Dav
loop
call UnitRemoveAbility(oMx,v3v[bYx])
set bYx=bYx-1
exitwhen(bYx<0)
endloop
endif
if(nyx<.0)then
set nyx=-nyx
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(Div)))*1.)))
loop
exitwhen(nyx<1.)
set byx=v5v[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
call UnitAddAbility(oMx,v4v[bYx])
endif
set bYx=bYx-1
endloop
else
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(Dav)))*1.)))
loop
exitwhen(nyx<1.)
set byx=v5v[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
call UnitAddAbility(oMx,v3v[bYx])
endif
set bYx=bYx-1
endloop
endif
else
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(Div)))*1.)))
if(nyx<.0)then
set nyx=-nyx
loop
exitwhen(bYx<0)
set byx=v5v[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
call UnitAddAbility(oMx,v4v[bYx])
else
call UnitRemoveAbility(oMx,v4v[bYx])
endif
set bYx=bYx-1
endloop
else
set bYx=(R2I(((itx((bux((R2I(((iOx(bUx(bWx),bUx(nyx)))*1.))))),(Dav)))*1.)))
loop
exitwhen(bYx<0)
set byx=v5v[bYx]
if(byx<=nyx)then
set nyx=nyx-byx
else
call UnitRemoveAbility(oMx,v3v[bYx])
endif
set bYx=bYx-1
endloop
endif
endif
endfunction
function fLo takes integer oqx,real oSx returns nothing
local real abx=(dF[(oqx)])
set dF[oqx]=oSx
call flo(Dnv,C[(oqx)],oSx,abx)
endfunction
function fmo takes integer oqx returns nothing
call fLo((oqx),(((Wf[((oqx))]))*1.))
endfunction
function fMo takes integer oqx,real oSx returns nothing
set Wf[oqx]=oSx
call fmo(oqx)
call bhx((oqx))
endfunction
function fpo takes integer oqx,real oSx returns nothing
call fMo(oqx,(Wf[(oqx)])+oSx)
endfunction
function fPo takes nothing returns boolean
local integer rdx=(bv)
call fpo(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function fqo takes nothing returns nothing
endfunction
function fQo takes nothing returns nothing
set nev=AUo(rLv,function fPo)
call fqo()
endfunction
function fso takes nothing returns nothing
call DNx(XBx("FolderUnit_FolderAttack_FolderSpeed_StructBaseA_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAttack_FolderSpeed_StructBaseA.Event_TypeChange).AddToStatics()",OP,BI,function fKo))
call fQo()
endfunction
function fSo takes integer oqx returns nothing
set Ajv[oqx]=false
call rgx(ehv)
endfunction
function fto takes integer oqx returns nothing
if(AHv[oqx]>0)then
return
endif
if(AGv[oqx]!=Z)then
call oYx("UnitAttackSplash_Allocation_deallocCustom_confirm","call DebugEx(UnitAttackSplash.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",eHv+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set AGv[oqx]=AGv[(w)]
set AGv[(w)]=oqx
call fSo(oqx)
endfunction
function fTo takes integer oqx returns nothing
set AHv[oqx]=AHv[oqx]-1
call fto(oqx)
endfunction
function fuo takes nothing returns boolean
local integer rdx=(bv)
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
local integer olx=CXx((oqx),AFv)
local integer O4o
loop
exitwhen(olx<q)
set O4o=COx((oqx),AFv,olx)
call fTo(((O4o)))
set olx=olx-1
endloop
call NTo((oqx),AFv)
set olx=Ozo(Ajo)
loop
exitwhen(olx<q)
call rtx((oqx),AFv,O3o(oqx,O6o(Ajo,olx),O7o(Ajo,olx)))
set olx=olx-1
endloop
return true
endfunction
function fUo takes nothing returns nothing
set dPv=AUo(rsv,function Dto)
call fko()
call fso()
call DNx(XBx("FolderUnit_FolderAttack_StructSplash_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAttack_StructSplash.Event_TypeChange).AddToStatics()",OP,BI,function fuo))
endfunction
function fwo takes nothing returns boolean
local integer rdx=(bv)
call Dsx(Zj,v3,(Vv[(rdx)]))
return true
endfunction
function fWo takes nothing returns nothing
set EXv=XBx("FolderUnit_StructBanish_Init: set FolderUnit_StructBanish.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructBanish.Event_Revive)",XP,BI,function fwo)
call UnitAddAbility(zj[((Zj))],('aBan'))
endfunction
function fyo takes nothing returns boolean
local integer rdx=(bv)
return true
endfunction
function fYo takes integer oqx returns boolean
local integer okx=(b2v[(oqx)])
set b2v[b1v[b0v]]=okx
set b1v[okx-1]=b1v[b0v]
set b2v[oqx]=0
set b0v=b0v-1
return(b0v==F)
endfunction
function fzo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
if fYo(oqx)then
call iHx(b3v)
endif
call Rmx(rkx,bzv)
call Rmx(rkx,bZv)
call Rmx(rkx,b_v)
call ijx(x7v[oqx])
call DestroyLightning(x8v[oqx])
call DestroyLightning(x9v[oqx])
call DestroyLightning(buv[oqx])
call DestroyLightning(bUv[oqx])
call DestroyLightning(bwv[oqx])
call DestroyLightning(bWv[oqx])
call DestroyLightning(byv[oqx])
call DestroyLightning(bYv[oqx])
return true
endfunction
function fZo takes nothing returns boolean
local integer rdx=(bv)
return true
endfunction
function f_o takes nothing returns nothing
set bzv=XBx("FolderUnit_StructBars_Init: set FolderUnit_StructBars.CAST_EVENT = Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.HEADER_TOP, function FolderUnit_StructBars.Event_SpellEffect)",ah,hI,function fyo)
set bZv=XBx("FolderUnit_StructBars_Init: set FolderUnit_StructBars.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructBars.Event_Destroy)",EP,BI,function fzo)
set b_v=XBx("FolderUnit_StructBars_Init: set FolderUnit_StructBars.END_CAST_EVENT = Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructBars.Event_EndCast)",oev,BI,function fZo)
set b3v=inx()
endfunction
function f0o takes nothing returns nothing
endfunction
function f1o takes nothing returns nothing
endfunction
function f2o takes nothing returns nothing
endfunction
function f3o takes integer oqx,boolean o2x returns nothing
if o2x then
call DSx((((oqx))),(nTv),(1),w)
else
call UJx(((oqx)),nTv)
endif
endfunction
function f4o takes nothing returns boolean
local integer rdx=(bv)
call f3o(((Vv[(rdx)])),(ic[(rdx)]))
return true
endfunction
function f5o takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer rkx=oqx
if(ntv[(oqx)])then
return
endif
call NIx((((oqx))),(nHv),(1),w,((((2.)*1.))*1.))
call Ayx(rkx,npv)
endfunction
function f6o takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=rkx
call icx(nqv[oqx],(ASv[(rkx)])+.01,false,function f5o)
return true
endfunction
function f7o takes nothing returns nothing
endfunction
function f8o takes nothing returns nothing
set nQv=XBx("FolderUnit_StructInvisibility_Init: set FolderUnit_StructInvisibility.ATTACK_EVENT = Event.Create(UNIT.Attack.Events.OFFENDED_REVERSED_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructInvisibility.Event_Attack)",dTv,BI,function f6o)
set nsv=XBx("FolderUnit_StructInvisibility_Init: set FolderUnit_StructInvisibility.CAST_EVENT = Event.Create(UNIT.Abilities.Events.Begin.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructInvisibility.Event_Attack)",C9v,BI,function f6o)
set nSv=(E0x())
call f7o()
endfunction
function f9o takes integer oqx,boolean o2x returns nothing
if o2x then
call DSx((((oqx))),(axv),(1),w)
else
call UJx(((oqx)),axv)
endif
endfunction
function Fvo takes nothing returns boolean
local integer rdx=(bv)
call f9o(((Vv[(rdx)])),(ic[(rdx)]))
return true
endfunction
function Feo takes integer rkx returns boolean
return(I5x((Bov),Rb,(rkx)))
endfunction
function Fxo takes integer oqx returns nothing
call kNx(oqx,(LS[(oqx)]))
endfunction
function Foo takes integer oqx,integer oSx returns nothing
call kNx(oqx,(LS[(oqx)])-oSx)
endfunction
function Fro takes integer oqx,integer CDx returns nothing
local boolean Fio=(CGx(((CDx)),Lh,(mh)))
if(not Fio or not(oPx(((((oqx)))),(yb+(DRv)))>0))then
call ddx(oqx,CDx)
endif
if Fio then
call NIx(((oqx)),(DRv),(1),w,((.01)*1.))
call Fxo(CDx)
elseif(CGx(((CDx)),Lh,(AS)))then
call kAx(CDx)
else
if((LS[(CDx)])>0)then
call Foo(CDx,1)
endif
endif
endfunction
function Fao takes integer oqx,integer CDx returns nothing
call Fro(oqx,CDx)
endfunction
function Fno takes integer oqx returns integer
local integer FVo=(UnitInventorySize(C[((oqx))]))-1
local integer olx=0
loop
exitwhen(olx>FVo)
if((oPx(((oqx)),fh+(olx)))==w)then
return olx
endif
set olx=olx+1
endloop
return-1
endfunction
function FEo takes integer oqx,integer CDx returns integer
local integer FXo
if(CGx(((CDx)),Lh,(AS)))then
return-1
endif
set FXo=Fno(oqx)
call rTx((oqx),fh+FXo,CDx)
call rTx((oqx),DIv+CDx,0+1+FXo)
set GS[(CDx)]=(FXo)
return FXo
endfunction
function FOo takes integer oqx,integer CDx returns integer
local integer o4x=oPx((oqx),DIv+CDx)
if(o4x==0)then
return-1
endif
return(o4x-0-1)
endfunction
function FRo takes integer oqx,integer CDx returns boolean
return(FOo(oqx,CDx)!=-1)
endfunction
function FIo takes integer oqx,integer CDx,integer FXo returns nothing
local integer rkx=oqx
local integer dDx=(gh[(CDx)])
local integer dfx=rEx((ph[(dDx)]))
local integer rdx
local integer olx
local integer rIx
local integer rlx
set Ph[(dfx)]=(CDx)
set DAv[(dfx)]=(FXo)
set qh[(dfx)]=(dDx)
set Vv[(dfx)]=(rkx)
set rdx=rEx((A[(rkx)]))
set Ph[(rdx)]=(CDx)
set DAv[(rdx)]=(FXo)
set qh[(rdx)]=(dDx)
set Vv[(rdx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=Chx(dDx,DXv,rIx)
loop
exitwhen(rlx<q)
call rCx(CHx(dDx,DXv,rIx,rlx),dfx)
if not FRo(rkx,CDx)then
return
endif
set rlx=rlx-1
endloop
set rlx=rOx(rkx,DXv,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,DXv,rIx,rlx),rdx)
if not FRo(rkx,CDx)then
return
endif
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((dfx)))
call rHx(((rdx)))
endfunction
function FAo takes nothing returns boolean
local integer rkx=Q_x()
local integer CDx
local integer FXo
if not Feo(rkx)then
return true
endif
if DOv then
set DOv=false
return true
endif
set CDx=(BGo(GetManipulatedItem()))
if(CDx==w)then
return true
endif
if(CGx(((CDx)),Lh,(AS)))then
call Fao(rkx,CDx)
return true
endif
set FXo=FEo(rkx,CDx)
call FIo((rkx),CDx,FXo)
return true
endfunction
function FNo takes nothing returns nothing
set DXv=(E0x())
set fg=Xhx(function FAo)
set Bov=JIx("FolderUnit_FolderItems_FolderEvents_StructGain_Init: set FolderUnit_FolderItems_FolderEvents_StructGain.REG_GROUP = UnitList.Create()")
call Q2x(fg,Ge,EVENT_PLAYER_UNIT_PICKUP_ITEM,null)
endfunction
function Fbo takes integer rkx returns boolean
return(I5x((Brv),Rb,(rkx)))
endfunction
function FBo takes integer oqx,integer CDx returns integer
local integer FXo
if not(CGx(((CDx)),Lh,(AS)))then
set FXo=FOo(oqx,CDx)
call rix((oqx),fh+FXo)
call rix((oqx),DIv+CDx)
set GS[(CDx)]=(-1)
return FXo
endif
return-1
endfunction
function Fco takes integer oqx,integer CDx,integer FXo returns nothing
local integer rkx=oqx
local integer dDx=(gh[(CDx)])
local integer dfx=rEx((ph[(dDx)]))
local integer rdx
local integer olx
local integer rIx
local integer rlx
set Ph[(dfx)]=(CDx)
set DAv[(dfx)]=(FXo)
set qh[(dfx)]=(dDx)
set Vv[(dfx)]=(rkx)
set rdx=rEx((A[(rkx)]))
set Ph[(rdx)]=(CDx)
set DAv[(rdx)]=(FXo)
set qh[(rdx)]=(dDx)
set Vv[(rdx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=Chx(dDx,DNv,rIx)
loop
exitwhen(rlx<q)
call rCx(CHx(dDx,DNv,rIx,rlx),dfx)
set rlx=rlx-1
endloop
set rlx=rOx(rkx,DNv,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,DNv,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((dfx)))
call rHx(((rdx)))
endfunction
function FCo takes nothing returns boolean
local integer rkx=Q_x()
local integer CDx
local integer FXo
if not Fbo(rkx)then
return true
endif
if Dbv then
set Dbv=false
return true
endif
set CDx=(BGo(GetManipulatedItem()))
if(CDx==w)then
return true
endif
set FXo=FBo(rkx,CDx)
call Fco((rkx),CDx,FXo)
return true
endfunction
function Fdo takes nothing returns nothing
set DNv=(E0x())
set Fg=Xhx(function FCo)
set Brv=JIx("FolderUnit_FolderItems_FolderEvents_StructLose_Init: set FolderUnit_FolderItems_FolderEvents_StructLose.REG_GROUP = UnitList.Create()")
call Q2x(Fg,Ge,EVENT_PLAYER_UNIT_DROP_ITEM,null)
endfunction
function FDo takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((T2[(oqx)]))])]))],((((Nj[((oqx))])))),(((oQx)))))
endfunction
function Ffo takes integer oqx,integer CDx,integer Cuo returns nothing
call rix((oqx),fh+FOo(oqx,CDx))
call rix((oqx),DIv+CDx)
call rTx((oqx),fh+Cuo,CDx)
call rTx((oqx),DIv+CDx,0+1+Cuo)
set GS[(CDx)]=(Cuo)
endfunction
function FFo takes integer CDx,integer FXo,integer dox,integer Fgo,integer Oqx returns nothing
local integer EHo=rEx((A[(Oqx)]))
local integer olx
local integer rIx
local integer rlx
set TH[(EHo)]=(dox)
set Ddv[(EHo)]=(Fgo)
set Ph[(EHo)]=(CDx)
set DAv[(EHo)]=(FXo)
set Vv[(EHo)]=(Oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(Oqx,DBv,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(Oqx,DBv,rIx,rlx),EHo)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((EHo)))
endfunction
function FGo takes nothing returns boolean
local integer rdx=(bv)
local integer Fho=(TH[(rdx)])
local integer Fgo=FDo((Nh[(rdx)]),DCv)
local integer Oqx=(Vv[(rdx)])
local integer FHo=FOo(Oqx,Fho)
local integer dox=CTo(Oqx,Fgo)
call Ffo(Oqx,Fho,Fgo)
if(dox!=w)then
call Ffo(Oqx,dox,FHo)
endif
call FFo(Fho,FHo,dox,Fgo,Oqx)
return true
endfunction
function Fjo takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((T2[(oqx)]))])]))],((((Nj[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function FJo takes integer oqx,integer Xwx returns nothing
if(Bj[oqx]==w)then
call oYx("FolderOrder_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oqx)+";"+(JA[(Xwx)]))
set Bj[oqx]=X
endif
call rSx(Bj[oqx],(Nj[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function Fko takes integer Rvx,integer Cuo returns nothing
call Fjo(Rvx,DCv,Cuo)
call FJo(Rvx,Dcv)
endfunction
function FKo takes nothing returns nothing
set DBv=(E0x())
set Dcv=XBx("FolderUnit_FolderItems_FolderEvents_StructMoveInInventory_Init: set FolderUnit_FolderItems_FolderEvents_StructMoveInInventory.ORDER_EVENT = Event.Create(UNIT.Order.Events.Gain.Target.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderUnit_FolderItems_FolderEvents_StructMoveInInventory.Event_Order)",Gj,LI,function FGo)
call Fko(t3,0)
call Fko(T3,1)
call Fko(u3,2)
call Fko(U3,3)
call Fko(w3,4)
call Fko(W3,5)
endfunction
function Flo takes integer rkx returns boolean
return(I5x((Biv),Rb,(rkx)))
endfunction
function FLo takes nothing returns integer
local unit oMx=GetBuyingUnit()
local integer o4x
if(GetUnitAbilityLevel(oMx,'aLoc')>0)then
set oMx=null
return Z
endif
set o4x=aBx(oMx)
set oMx=null
return o4x
endfunction
function Fmo takes integer oqx,integer FMo,integer CDx returns nothing
local integer dDx=(gh[(CDx)])
local integer dfx=rEx((ph[(dDx)]))
local integer olx
local integer rIx
local integer rlx
set Ph[(dfx)]=(CDx)
set qh[(dfx)]=(dDx)
set WH[(dfx)]=(FMo)
set Vv[(dfx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=Chx(dDx,DDv,rIx)
loop
exitwhen(rlx<q)
call rCx(CHx(dDx,DDv,rIx,rlx),dfx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((dfx)))
endfunction
function Fpo takes nothing returns boolean
local integer FPo=Q_x()
local integer FMo
local integer CDx
if not Flo(FPo)then
return true
endif
set FMo=FLo()
set CDx=kfx(GetSoldItem())
call RUx((Abx((FMo),("Abilities\\Spells\\Items\\TomeOfRetraining\\TomeOfRetrainingCaster.mdl"),("origin"),(Bi))))
call Fmo((FPo),FMo,CDx)
return true
endfunction
function Fqo takes nothing returns nothing
set DDv=(E0x())
set Dfv=Xhx(function Fpo)
set Biv=JIx("FolderUnit_FolderItems_FolderEvents_StructSell_Init: set FolderUnit_FolderItems_FolderEvents_StructSell.REG_GROUP = UnitList.Create()")
call Q2x(Dfv,Ge,EVENT_PLAYER_UNIT_SELL_ITEM,null)
endfunction
function FQo takes integer rkx returns boolean
return(I5x((Bav),Rb,(rkx)))
endfunction
function Fso takes nothing returns boolean
local integer rkx=Q_x()
local integer CDx
if not FQo(rkx)then
return true
endif
set CDx=(BGo(GetManipulatedItem()))
call Fro((rkx),CDx)
return true
endfunction
function FSo takes nothing returns nothing
set sh=(E0x())
set DFv=Xhx(function Fso)
set Bav=JIx("FolderUnit_FolderItems_FolderEvents_StructUse_Init: set FolderUnit_FolderItems_FolderEvents_StructUse.REG_GROUP = UnitList.Create()")
set DRv=lQx(ouv)
call Q2x(DFv,Ge,EVENT_PLAYER_UNIT_USE_ITEM,null)
endfunction
function Fto takes nothing returns nothing
call FNo()
call Fdo()
call FKo()
call Fqo()
call FSo()
endfunction
function FTo takes nothing returns boolean
local integer rdx=(bv)
call DSx(((((((Vv[(rdx)])))))),(Yg),(1),w)
return true
endfunction
function Fuo takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=(Vv[(rdx)])
call cJx(oqx)
return true
endfunction
function FUo takes nothing returns boolean
local integer rdx=(bv)
call UJx((((((Vv[(rdx)]))))),Yg)
return true
endfunction
function Fwo takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
call cLx(oqx,(Nhv[(Ajo)])-(Nhv[(AHo)]))
return true
endfunction
function FWo takes nothing returns boolean
local integer rdx=(bv)
call cyx(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function Fyo takes integer oqx,boolean o2x returns nothing
if o2x then
call DSx((((oqx))),(Yg),(1),w)
else
call UJx(((oqx)),Yg)
endif
endfunction
function FYo takes nothing returns boolean
local integer rdx=(bv)
call Fyo(((Vv[(rdx)])),not(ic[(rdx)]))
return true
endfunction
function Fzo takes nothing returns boolean
local integer rdx=(bv)
call DSx((((((Vv[(rdx)]))))),(Yg),(1),w)
return true
endfunction
function FZo takes nothing returns boolean
local integer rdx=(bv)
call UJx(((((Vv[(rdx)])))),Yg)
return true
endfunction
function F_o takes nothing returns nothing
set DGv=AUo(Vxv,function FYo)
call DNx(XBx("FolderUnit_FolderLifeRegeneration_StructDisablement_Init: call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderLifeRegeneration_StructDisablement.Event_Death).AddToStatics()",VP,BI,function Fzo))
call DNx(XBx("FolderUnit_FolderLifeRegeneration_StructDisablement_Init: call Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderLifeRegeneration_StructDisablement.Event_Revive).AddToStatics()",XP,BI,function FZo))
endfunction
function F0o takes integer oqx,real oSx returns nothing
set HG[oqx]=oSx
call cKx((oqx))
endfunction
function F1o takes integer oqx,real oSx returns nothing
call F0o(oqx,(HG[(oqx)])+oSx)
endfunction
function F2o takes nothing returns boolean
local integer rdx=(bv)
call F1o(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function F3o takes nothing returns nothing
set eG=inx()
call DNx(XBx("FolderUnit_StructLifeRegeneration_Init: call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructLifeRegeneration.Event_Death).AddToStatics()",VP,BI,function FTo))
call DNx(XBx("FolderUnit_StructLifeRegeneration_Init: call Event.Create(UNIT.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructLifeRegeneration.Event_Destroy).AddToStatics()",EP,BI,function Fuo))
call DNx(XBx("FolderUnit_StructLifeRegeneration_Init: call Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructLifeRegeneration.Event_Revive).AddToStatics()",XP,BI,function FUo))
call DNx(XBx("FolderUnit_FolderLifeRegeneration_StructBase_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderLifeRegeneration_StructBase.Event_TypeChange).AddToStatics()",OP,BI,function Fwo))
set Dgv=AUo(Vev,function FWo)
call F_o()
set XAv=AUo(Vav,function F2o)
endfunction
function F4o takes integer oqx,boolean o2x returns nothing
if o2x then
call DSx((((oqx))),(aSv),(1),w)
else
call UJx(((oqx)),aSv)
endif
endfunction
function F5o takes nothing returns boolean
local integer rdx=(bv)
call F4o(((Vv[(rdx)])),(ic[(rdx)]))
return true
endfunction
function F6o takes nothing returns nothing
endfunction
function F7o takes nothing returns nothing
set Dhv=AUo(asv,function F5o)
call F6o()
endfunction
function F8o takes nothing returns boolean
local integer rdx=(bv)
call DSx(((((((Vv[(rdx)])))))),(hF),(1),w)
return true
endfunction
function F9o takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=(Vv[(rdx)])
call Bbx(oqx)
return true
endfunction
function gvo takes nothing returns boolean
local integer rdx=(bv)
call UJx((((((Vv[(rdx)]))))),hF)
return true
endfunction
function geo takes nothing returns boolean
local integer rdx=(bv)
local integer AHo=(BNv[(rdx)])
local integer Ajo=(BOv[(rdx)])
local integer oqx=(Vv[(rdx)])
call Bdx(oqx,(NHv[(Ajo)])-(NHv[(AHo)]))
return true
endfunction
function gxo takes nothing returns boolean
local integer rdx=(bv)
call Bqx(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function goo takes integer oqx,boolean o2x returns nothing
if o2x then
call DSx((((oqx))),(hF),(1),w)
else
call UJx(((oqx)),hF)
endif
endfunction
function gro takes nothing returns boolean
local integer rdx=(bv)
call goo(((Vv[(rdx)])),not(ic[(rdx)]))
return true
endfunction
function gio takes nothing returns boolean
local integer rdx=(bv)
call DSx((((((Vv[(rdx)]))))),(hF),(1),w)
return true
endfunction
function gao takes nothing returns boolean
local integer rdx=(bv)
call UJx(((((Vv[(rdx)])))),hF)
return true
endfunction
function gno takes nothing returns nothing
set Djv=AUo(VGv,function gro)
call DNx(XBx("FolderUnit_FolderManaRegeneration_StructDisablement_Init: call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderManaRegeneration_StructDisablement.Event_Death).AddToStatics()",VP,BI,function gio))
call DNx(XBx("FolderUnit_FolderManaRegeneration_StructDisablement_Init: call Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderManaRegeneration_StructDisablement.Event_Revive).AddToStatics()",XP,BI,function gao))
endfunction
function gVo takes integer oqx,real oSx returns nothing
set pF[oqx]=oSx
call Bcx((oqx))
endfunction
function gEo takes integer oqx,real oSx returns nothing
call gVo(oqx,(pF[(oqx)])+oSx)
endfunction
function gXo takes nothing returns boolean
local integer rdx=(bv)
call gEo(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function gOo takes nothing returns nothing
set kF=inx()
call DNx(XBx("FolderUnit_StructManaRegeneration_Init: call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructManaRegeneration.Event_Death).AddToStatics()",VP,BI,function F8o))
call DNx(XBx("FolderUnit_StructManaRegeneration_Init: call Event.Create(UNIT.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructManaRegeneration.Event_Destroy).AddToStatics()",EP,BI,function F9o))
call DNx(XBx("FolderUnit_StructManaRegeneration_Init: call Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructManaRegeneration.Event_Revive).AddToStatics()",XP,BI,function gvo))
call DNx(XBx("FolderUnit_FolderManaRegeneration_StructBase_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderManaRegeneration_StructBase.Event_TypeChange).AddToStatics()",OP,BI,function geo))
set DHv=AUo(Vgv,function gxo)
call gno()
set ECv=AUo(VJv,function gXo)
endfunction
function gRo takes integer oqx returns nothing
call SetUnitPathing(C[(oqx)],(XOv[(oqx)]))
endfunction
function gIo takes nothing returns boolean
local integer rdx=(bv)
call gRo(((Vv[(rdx)])))
return true
endfunction
function gAo takes nothing returns nothing
endfunction
function gNo takes nothing returns boolean
local integer rdx=(bv)
call Dsx(Zj,X4,(Vv[(rdx)]))
return true
endfunction
function gbo takes nothing returns nothing
set Xkv=XBx("FolderUnit_StructSilence_Init: set FolderUnit_StructSilence.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructSilence.Event_Revive)",XP,BI,function gNo)
call UnitAddAbility(zj[((Zj))],('aSil'))
endfunction
function gBo takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),XLv)
return true
endfunction
function gco takes nothing returns nothing
set XMv=XBx("FolderUnit_StructSleep_Init: set FolderUnit_StructSleep.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructSleep.Event_Damage)",Ezv,BI,function gBo)
set Xpv=(E0x())
call UnitAddAbility(zj[((Zj))],('ACsl'))
endfunction
function gCo takes integer oqx returns boolean
if(((biv[((oqx))])>0)==false)then
return false
endif
set biv[bnv[bav]]=biv[oqx]
set bnv[biv[oqx]-1]=bnv[bav]
set biv[oqx]=0
set bav=bav-1
return(bav==F)
endfunction
function gdo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
if gCo(rkx)then
call iHx(bVv)
endif
call Rmx(rkx,N_v)
call Dmo(rkx,bov)
call Dmo(rkx,brv)
return true
endfunction
function gDo takes nothing returns boolean
local integer rdx=(bv)
call INo((Vv[(rdx)]))
return true
endfunction
function gfo takes nothing returns boolean
local integer rdx=(bv)
call gCo((Vv[(rdx)]))
return true
endfunction
function gFo takes integer oqx,real oSx returns nothing
set bIv[oqx]=oSx
call IDo((oqx))
endfunction
function ggo takes integer oqx,real oSx returns nothing
call gFo(oqx,(bIv[(oqx)])+oSx)
endfunction
function gGo takes nothing returns boolean
local integer rdx=(bv)
call ggo(((Vv[(rdx)])),(Ec[(rdx)]))
return true
endfunction
function gho takes nothing returns nothing
set N_v=XBx("FolderUnit_StructStaminaRegeneration_Init: set FolderUnit_StructStaminaRegeneration.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructStaminaRegeneration.Event_Destroy)",EP,BI,function gdo)
set bov=XBx("FolderUnit_StructStaminaRegeneration_Init: set FolderUnit_StructStaminaRegeneration.MOVE_ENDING_EVENT = Event.Create(UNIT.Movement.Events.ENDING_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructStaminaRegeneration.Event_MoveEnding)",bev,BI,function gDo)
set brv=XBx("FolderUnit_StructStaminaRegeneration_Init: set FolderUnit_StructStaminaRegeneration.MOVE_START_EVENT = Event.Create(UNIT.Movement.Events.START_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructStaminaRegeneration.Event_MoveStart)",bxv,BI,function gfo)
set bVv=inx()
set DJv=AUo(OMv,function gGo)
endfunction
function gHo takes integer oqx,boolean o2x returns nothing
if o2x then
call DSx((((oqx))),(nhv),(1),w)
else
call UJx(((oqx)),nhv)
endif
endfunction
function gjo takes nothing returns boolean
local integer rdx=(bv)
call gHo(((Vv[(rdx)])),(ic[(rdx)]))
return true
endfunction
function gJo takes integer oqx returns integer
set DPv[oqx]=true
set Dqv[oqx]=false
call rax(XPv)
return oqx
endfunction
function gko takes nothing returns integer
local integer oqx
if(DLv==8190)then
call oYx("FolderUnit_FolderStun_StructCancel_Allocation_allocCustom","call DebugEx(FolderUnit_FolderStun_StructCancel.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Xqv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Dmv[(w)]==w)then
set DMv=DMv+1
set oqx=DMv
else
set oqx=Dmv[(w)]
set Dmv[(w)]=Dmv[Dmv[(w)]]
endif
set Dmv[oqx]=Z
set Dpv[oqx]=1
call gJo(oqx)
return oqx
endfunction
function gKo takes integer oqx returns nothing
set DPv[oqx]=false
call rgx(XPv)
endfunction
function glo takes integer oqx returns nothing
if(Dpv[oqx]>0)then
return
endif
if(Dmv[oqx]!=Z)then
call oYx("FolderUnit_FolderStun_StructCancel_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderStun_StructCancel.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Xqv+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set Dmv[oqx]=Dmv[(w)]
set Dmv[(w)]=oqx
call gKo(oqx)
endfunction
function gLo takes integer oqx returns nothing
set Dpv[oqx]=Dpv[oqx]-1
call glo(oqx)
endfunction
function gmo takes integer oqx,integer OHx,integer rkx returns nothing
call gLo((oqx))
call ijx(OHx)
call rix(rkx,Dlv)
call Rmx(rkx,DKv)
call UnitRemoveAbility(C[((((rkx))))],(('bStu')))
endfunction
function gMo takes nothing returns nothing
local integer OHx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(OHx)])
call gmo(oqx,OHx,Dsv[oqx])
endfunction
function gpo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(Vv[(rdx)])
local integer oqx=oPx(rkx,Dlv)
local integer OHx
if not(Mh[(rkx)])then
if(oPx(rkx,Dlv)==w)then
set oqx=gko()
set OHx=inx()
set DQv[oqx]=OHx
set Dsv[oqx]=rkx
set ge[(OHx)]=(oqx)
call rTx(rkx,Dlv,oqx)
call I7x(rkx,DKv)
call icx(OHx,.0,false,function gMo)
endif
endif
return true
endfunction
function gPo takes nothing returns nothing
set DKv=XBx("FolderUnit_FolderStun_StructCancel_Init: set DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderStun_StructCancel.Event_Order)",VP,BI,function gpo)
call FJo(A4,XBx("FolderUnit_FolderStun_StructCancel_Init: call Order.STUNNED.Event.Add(Event.Create(UNIT.Order.Events.Gain.Target.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderStun_StructCancel.Event_Order))",Gj,BI,function gpo))
endfunction
function gqo takes nothing returns nothing
call UnitAddAbility(zj[((Zj))],('AStn'))
set Dkv=AUo(XQv,function gjo)
call gPo()
endfunction
function gQo takes nothing returns nothing
set O2v=(E0x())
set O1v=(E0x())
endfunction
function gso takes nothing returns boolean
local integer rdx=(bv)
call Dsx(Zj,I3,(Vv[(rdx)]))
return true
endfunction
function gSo takes nothing returns nothing
set EJv=XBx("FolderUnit_StructWhirl_Init: set FolderUnit_StructWhirl.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructWhirl.Event_Revive)",XP,BI,function gso)
call UnitAddAbility(zj[((Zj))],('aWhC'))
call UnitAddAbility(zj[((Zj))],('aWhI'))
endfunction
function gto takes nothing returns boolean
return true
endfunction
function gTo takes nothing returns nothing
call aHx(function gto)
endfunction
function guo takes nothing returns nothing
endfunction
function gUo takes nothing returns nothing
call C9o()
call dAo()
call dNo()
call d1o()
call d2o()
call d3o()
call DBo()
call Djo()
call DQo()
call Dso()
call fUo()
call fWo()
call f_o()
call f0o()
call f1o()
call f2o()
set DVv=AUo(nuv,function f4o)
call f8o()
set DEv=AUo(aov,function Fvo)
call Fto()
call F3o()
call F7o()
call gOo()
call DNx(XBx("FolderUnit_StructPathing_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructPathing.Event_TypeChange).AddToStatics()",OP,BI,function gIo))
call gAo()
call gbo()
call gco()
call gho()
call gqo()
call gQo()
call gSo()
call gTo()
call guo()
endfunction
function gwo takes nothing returns boolean
call XTo()
call XYo()
call Xzo()
set Igv=(E0x())
set Jf=Xhx(function AOo)
set R9v=Xhx(function ARo)
set EP=(E0x())
set Ab=Xhx(function Ago)
set BIv=XLx(function AGo)
set BAv=(E0x())
call AKo()
call DNx(XBx("FolderUnit_StructAttachments_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructAttachments.Event_TypeChange).AddToStatics()",OP,BI,function Alo))
call DNx(XBx("FolderUnit_StructBlood_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructBlood.Event_TypeChange).AddToStatics()",OP,BI,function ALo))
call DNx(XBx("FolderUnit_StructBloodExplosion_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructBloodExplosion.Event_TypeChange).AddToStatics()",OP,BI,function Amo))
call Aso()
call DNx(XBx("FolderUnit_StructCollisionSize_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructCollisionSize.Event_TypeChange).AddToStatics()",OP,BI,function Ato))
call AWo()
call NSo()
call Nto()
call NZo()
set cov=AUo(iPv,function N_o)
set crv=AUo(iKv,function N2o)
set civ=XBx("FolderUnit_FolderEvent_StructCounted_Init: set FolderUnit_FolderEvent_StructCounted.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderEvent_StructCounted.Event_Destroy)",EP,BI,function N6o)
set Ecv=AUo(nyv,function N9o)
call DNx(XBx("FolderUnit_StructImpact_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructImpact.Event_TypeChange).AddToStatics()",OP,BI,function bxo))
call bno()
set hG=(E0x())
set cRv=AUo(i6v,function bEo)
call bXo()
set MF=(E0x())
set cIv=AUo(i8v,function bRo)
call bbo()
call bdo()
call DNx(XBx("FolderUnit_StructOutpact_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructOutpact.Event_TypeChange).AddToStatics()",OP,BI,function bFo))
set rx=(E0x())
call bho()
call bKo()
call bPo()
call bWo()
call b1o()
call b3o()
call Beo()
call BIo()
call Bwo()
call cTo()
call Cio()
call COo()
call CBo()
call CFo()
call aHx(function gUo)
return true
endfunction
function gWo takes nothing returns boolean
call Xmo(function gwo,"Unit_Init")
return true
endfunction
function gyo takes nothing returns boolean
set Bhv=Vnx(Bdv)
return true
endfunction
function gYo takes nothing returns boolean
set nXv=Vnx(nrv)
return true
endfunction
function gzo takes nothing returns boolean
set DSv=Vnx(Dtv)
return true
endfunction
function gZo takes nothing returns boolean
set DTv=Vnx(Duv)
return true
endfunction
function g_o takes nothing returns boolean
set DUv=Vnx(Dwv)
return true
endfunction
function g0o takes nothing returns boolean
set DWv=Vnx(Dyv)
return true
endfunction
function g1o takes nothing returns boolean
set DYv=Vnx(Dzv)
return true
endfunction
function g2o takes nothing returns boolean
set DZv=Vnx(D_v)
return true
endfunction
function g3o takes nothing returns boolean
set D0v=Vnx(D1v)
return true
endfunction
function g4o takes nothing returns boolean
set D2v=Vnx(D3v)
return true
endfunction
function g5o takes nothing returns boolean
set D4v=Vnx(D5v)
return true
endfunction
function g6o takes nothing returns boolean
set D6v=Vnx(D7v)
return true
endfunction
function g7o takes nothing returns boolean
set D8v=Vnx(D9v)
return true
endfunction
function g8o takes nothing returns boolean
set fvv=Vnx(fev)
return true
endfunction
function g9o takes nothing returns boolean
set fxv=Vnx(fov)
return true
endfunction
function Gvo takes nothing returns boolean
set YU=Vnx(TU)
return true
endfunction
function Geo takes nothing returns boolean
set YB=Vnx(WB)
return true
endfunction
function Gxo takes nothing returns boolean
set frv=Vnx(fiv)
return true
endfunction
function Goo takes nothing returns boolean
set fav=Vnx(fnv)
return true
endfunction
function Gro takes nothing returns boolean
set fVv=Vnx(fEv)
return true
endfunction
function Gio takes nothing returns boolean
set fXv=Vnx(fOv)
return true
endfunction
function Gao takes nothing returns boolean
set fRv=Vnx(fIv)
return true
endfunction
function Gno takes nothing returns boolean
set fAv=Vnx(fNv)
return true
endfunction
function GVo takes nothing returns boolean
set fbv=Vnx(fBv)
return true
endfunction
function GEo takes nothing returns boolean
set fcv=Vnx(fCv)
return true
endfunction
function GXo takes nothing returns boolean
set fdv=Vnx(fDv)
return true
endfunction
function GOo takes nothing returns boolean
set ffv=Vnx(fFv)
return true
endfunction
function GRo takes nothing returns boolean
set fgv=Vnx(fGv)
return true
endfunction
function GIo takes nothing returns boolean
set fhv=Vnx(fHv)
return true
endfunction
function GAo takes nothing returns boolean
set fjv=Vnx(fJv)
return true
endfunction
function GNo takes nothing returns boolean
set fkv=Vnx(fKv)
return true
endfunction
function Gbo takes nothing returns boolean
set flv=Vnx(fLv)
return true
endfunction
function GBo takes nothing returns boolean
set fmv=Vnx(fMv)
return true
endfunction
function Gco takes nothing returns boolean
set fpv=Vnx(fPv)
return true
endfunction
function GCo takes nothing returns boolean
set fqv=Vnx(fQv)
return true
endfunction
function Gdo takes nothing returns boolean
set fsv=Vnx(fSv)
return true
endfunction
function GDo takes nothing returns boolean
set ftv=Vnx(fTv)
return true
endfunction
function Gfo takes nothing returns boolean
set fuv=Vnx(fUv)
return true
endfunction
function GFo takes nothing returns boolean
set fwv=Vnx(fWv)
return true
endfunction
function Ggo takes nothing returns boolean
set fyv=Vnx(fYv)
return true
endfunction
function GGo takes nothing returns boolean
set fzv=Vnx(fZv)
return true
endfunction
function Gho takes nothing returns boolean
set f_v=Vnx(f0v)
return true
endfunction
function GHo takes nothing returns boolean
set f1v=Vnx(f2v)
return true
endfunction
function Gjo takes nothing returns boolean
set f3v=Vnx(f4v)
return true
endfunction
function GJo takes nothing returns boolean
set f5v=Vnx(f6v)
return true
endfunction
function Gko takes nothing returns boolean
set f7v=Vnx(f8v)
return true
endfunction
function GKo takes nothing returns boolean
set f9v=Vnx(Fvv)
return true
endfunction
function Glo takes nothing returns boolean
set Fev=Vnx(Fxv)
return true
endfunction
function GLo takes nothing returns boolean
set Fov=Vnx(Frv)
return true
endfunction
function Gmo takes nothing returns boolean
set Fiv=Vnx(Fav)
return true
endfunction
function GMo takes nothing returns boolean
set Fnv=Vnx(FVv)
return true
endfunction
function Gpo takes nothing returns boolean
set FEv=Vnx(FXv)
return true
endfunction
function GPo takes nothing returns boolean
set FOv=Vnx(FRv)
return true
endfunction
function Gqo takes nothing returns boolean
set FIv=Vnx(FAv)
return true
endfunction
function GQo takes nothing returns boolean
set FNv=Vnx(Fbv)
return true
endfunction
function Gso takes nothing returns boolean
set FBv=Vnx(Fcv)
return true
endfunction
function GSo takes nothing returns boolean
set FCv=Vnx(Fdv)
return true
endfunction
function Gto takes nothing returns boolean
set FDv=Vnx(Ffv)
return true
endfunction
function GTo takes nothing returns boolean
set FFv=Vnx(Fgv)
return true
endfunction
function Guo takes nothing returns boolean
set FGv=Vnx(Fhv)
return true
endfunction
function GUo takes nothing returns boolean
set FHv=Vnx(Fjv)
return true
endfunction
function Gwo takes nothing returns boolean
set FJv=Vnx(Fkv)
return true
endfunction
function GWo takes nothing returns boolean
set FKv=Vnx(Flv)
return true
endfunction
function Gyo takes nothing returns boolean
set FLv=Vnx(Fmv)
return true
endfunction
function GYo takes nothing returns boolean
set FMv=Vnx(Fpv)
return true
endfunction
function Gzo takes nothing returns boolean
set FPv=Vnx(Fqv)
return true
endfunction
function GZo takes nothing returns boolean
set FQv=Vnx(Fsv)
return true
endfunction
function G_o takes nothing returns boolean
set FSv=Vnx(Ftv)
return true
endfunction
function G0o takes nothing returns boolean
set FTv=Vnx(Fuv)
return true
endfunction
function G1o takes nothing returns boolean
set FUv=Vnx(Fwv)
return true
endfunction
function G2o takes nothing returns boolean
set FWv=Vnx(Fyv)
return true
endfunction
function G3o takes nothing returns boolean
set FYv=Vnx(Fzv)
return true
endfunction
function G4o takes nothing returns boolean
set FZv=Vnx(F_v)
return true
endfunction
function G5o takes nothing returns boolean
set F0v=Vnx(F1v)
return true
endfunction
function G6o takes nothing returns boolean
set F2v=Vnx(F3v)
return true
endfunction
function G7o takes nothing returns boolean
set F4v=Vnx(F5v)
return true
endfunction
function G8o takes nothing returns boolean
set F6v=Vnx(F7v)
return true
endfunction
function G9o takes nothing returns boolean
set F8v=Vnx(F9v)
return true
endfunction
function hvo takes nothing returns boolean
set gvv=Vnx(gev)
return true
endfunction
function heo takes nothing returns boolean
set gxv=Vnx(gov)
return true
endfunction
function hxo takes nothing returns boolean
set grv=Vnx(giv)
return true
endfunction
function hoo takes nothing returns boolean
set gav=Vnx(gnv)
return true
endfunction
function hro takes nothing returns boolean
set gVv=Vnx(gEv)
return true
endfunction
function hio takes nothing returns boolean
set gXv=Vnx(gOv)
return true
endfunction
function hao takes code c,string rqx returns nothing
call VRx(Sa,c,rqx)
endfunction
function hno takes integer oqx returns integer
set gcv[oqx]=true
set gCv[oqx]=false
set Fw[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set BRv[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(gdv)
return oqx
endfunction
function hVo takes nothing returns integer
local integer oqx
if(gIv==8190)then
call oYx("UnitType_Allocation_allocCustom","call DebugEx(UnitType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",gAv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(gNv[(w)]==w)then
set gbv=gbv+1
set oqx=gbv
else
set oqx=gNv[(w)]
set gNv[(w)]=gNv[gNv[(w)]]
endif
set gNv[oqx]=Z
set gBv[oqx]=1
call hno(oqx)
return oqx
endfunction
function hEo takes integer oqx returns nothing
set gw[(oqx)]=(gfv+oqx)
endfunction
function hXo takes integer oqx returns nothing
endfunction
function hOo takes integer oqx returns nothing
call hXo(oqx)
set Iwv[(oqx)]=F
endfunction
function hRo takes integer oqx returns nothing
set I3v[(oqx)]=((.0)*1.)
set Axv[((oqx))]=(0)
endfunction
function hIo takes integer oqx returns nothing
set ANv[oqx]=w
set Drv[(((oqx)))]=((.0)*1.)
set Adv[((oqx))]=((.0)*1.)
set ADv[((oqx))]=((.0)*1.)
endfunction
function hAo takes integer oqx returns nothing
set AQv[(oqx)]=((.0)*1.)
set Atv[((oqx))]=((.0)*1.)
set Auv[((oqx))]=(0)
set AWv[((oqx))]=(0)
set Azv[((oqx))]=(-1)
endfunction
function hNo takes integer oqx returns nothing
set gFv[(oqx)]=(true)
set A0v[((oqx))]=((10.)*1.)
endfunction
function hbo takes integer oqx returns nothing
set Nvv[((oqx))]=(0)
set Nxv[((oqx))]=(0)
endfunction
function hBo takes integer oqx returns nothing
set bbv[(oqx)]=((.0)*1.)
set bFv[((oqx))]=((.0)*1.)
endfunction
function hco takes integer oqx returns nothing
set bBv[(oqx)]=((.0)*1.)
set bGv[((oqx))]=((.0)*1.)
endfunction
function hCo takes integer oqx returns nothing
set bcv[(oqx)]=((.0)*1.)
set bhv[((oqx))]=((.0)*1.)
endfunction
function hdo takes integer oqx returns nothing
call hBo(oqx)
set bgv[((oqx))]=((.0)*1.)
call hco(oqx)
set Tf[((oqx))]=(0)
call hCo(oqx)
endfunction
function hDo takes integer oqx returns nothing
local unit HOx=afx(vx[Fy],IGv[(oqx)],.0,.0,.0)
call KillUnit(HOx)
call Mcx(HOx)
set HOx=null
endfunction
function hfo takes integer oqx returns nothing
set NTv[((oqx))]=((255.)*1.)
set Nuv[((oqx))]=((255.)*1.)
set NUv[((oqx))]=((255.)*1.)
set Nwv[((oqx))]=((255.)*1.)
endfunction
function hFo takes integer oqx returns boolean
set ggv=ggv+1
set gGv[ggv]=oqx
set ghv[oqx]=ggv+1
return(ggv==0)
endfunction
function hgo takes integer oMx returns integer
local integer oqx=hVo()
set gDv[oqx]=null
set IGv[oqx]=oMx
call hEo(oqx)
call hOo(oqx)
call hRo(oqx)
call hIo(oqx)
set Amv[((oqx))]=(null)
set nGv[((oqx))]=(null)
set Aqv[((oqx))]=((.0)*1.)
call hAo(oqx)
call hNo(oqx)
call hbo(oqx)
call hdo(oqx)
set Nav[(((oqx)))]=((60.)*1.)
set NJv[((oqx))]=((.0)*1.)
set Nhv[((oqx))]=((.0)*1.)
set NKv[((oqx))]=((.0)*1.)
set NHv[((oqx))]=((.0)*1.)
call hDo(oqx)
set Ntv[(((oqx)))]=((60.)*1.)
set NEv[((oqx))]=(true)
set Tj[((oqx))]=((1.)*1.)
set Nlv[((oqx))]=((.0)*1.)
set Ndv[((oqx))]=((.0)*1.)
set NFv[((oqx))]=((.0)*1.)
call hfo(oqx)
set nGv[(oqx)]=("Objects\\Spawnmodels\\Human\\HumanSmallDeathExplode\\HumanSmallDeathExplode.mdl")
call hFo(oqx)
call XJx(lv[(E[((X))])],((((GetObjectName(IGv[(oqx)]))))),(((I2S(((Ff)))))),(((oqx))))
return oqx
endfunction
function hGo takes integer oMx returns integer
local integer oqx=hgo(oMx)
set IGv[oqx]=oMx
call SaveInteger(o[((V[(E[((X))])]))],(((oMx))),(((Ff))),(((oqx))))
return oqx
endfunction
function hho takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(Fw[(oqx)],(gw[((oqx))]),oQx,oSx)
endfunction
function hHo takes integer oqx,real iWx,real iyx,real iYx,real izx returns nothing
set NTv[(oqx)]=((iWx)*1.)
set Nuv[(oqx)]=((iyx)*1.)
set NUv[(oqx)]=((iYx)*1.)
set Nwv[(oqx)]=((izx)*1.)
endfunction
function hjo takes nothing returns boolean
set gRv=hGo('uKoM')
call hho(((gRv)),Apv,(INv))
set Tj[(gRv)]=((.85)*1.)
call hHo(gRv,$FF,$FF,$A5,$FF)
set Nav[(gRv)]=((83.044982698962)*1.)
set Ntv[(gRv)]=((83.044982698962)*1.)
set Nlv[(gRv)]=((270)*1.)
set I3v[(gRv)]=((1)*1.)
set Axv[(gRv)]=(2)
set NJv[(gRv)]=(($AF)*1.)
set Njv[(gRv)]=(($AF)*1.)
set Nhv[(gRv)]=((.2)*1.)
set NIv[(gRv)]=(($578)*1.)
set NOv[(gRv)]=(($578)*1.)
set Ndv[(gRv)]=(($A)*1.)
set ANv[(gRv)]=(gHv)
set Adv[(gRv)]=(('x')*1.)
set ADv[((gRv))]=((1.*1./((1.35)*1.))*1.)
set Atv[(gRv)]=((.38)*1.)
set AQv[(gRv)]=((4)*1.)
set Asv[(gRv)]=((4)*1.)
set Auv[(gRv)]=(1)
set AWv[(gRv)]=(3)
set Azv[(gRv)]=(0)
set Aqv[(gRv)]=((42.906574394464)*1.)
set Nxv[(gRv)]=(20)
set Nvv[(gRv)]=($A)
return true
endfunction
function hJo takes nothing returns boolean
set gjv=hGo('uMoo')
call hho(((gjv)),Apv,(INv))
set Tj[(gjv)]=((1.25)*1.)
set Nav[(gjv)]=((41.666666666667)*1.)
set Ntv[(gjv)]=((41.666666666667)*1.)
set Amv[(gjv)]=("Objects\\Spawnmodels\\NightElf\\NightElfBlood\\NightElfBloodDruidoftheClaw.mdx")
set Nlv[(gjv)]=(($87)*1.)
set I3v[(gjv)]=((3)*1.)
set Axv[(gjv)]=(2)
set NJv[(gjv)]=(($8C)*1.)
set Njv[(gjv)]=(($8C)*1.)
set Nhv[(gjv)]=((.8)*1.)
set NIv[(gjv)]=(($578)*1.)
set NOv[(gjv)]=(($578)*1.)
set Ndv[(gjv)]=((27.5)*1.)
set ANv[(gjv)]=(gHv)
set Adv[(gjv)]=((153.6)*1.)
set ADv[((gjv))]=((1.*1./((1.7)*1.))*1.)
set Atv[(gjv)]=((.3)*1.)
set AQv[(gjv)]=(($D)*1.)
set Asv[(gjv)]=(($D)*1.)
set Auv[(gjv)]=(2)
set AWv[(gjv)]=(4)
set Azv[(gjv)]=(0)
set Aqv[(gjv)]=((33.333333333333)*1.)
set Nxv[(gjv)]=(9)
set Nvv[(gjv)]=(60)
return true
endfunction
function hko takes nothing returns boolean
set gJv=hGo('uPeC')
call hho(((gJv)),Apv,(INv))
set Tj[(gJv)]=((3)*1.)
call hHo(gJv,$FF,$BF,0,$FF)
set Nav[(gJv)]=((60)*1.)
set Ntv[(gJv)]=((60)*1.)
set Nlv[(gJv)]=(($C8)*1.)
set I3v[(gJv)]=((0)*1.)
set Axv[(gJv)]=(3)
set NJv[(gJv)]=(('i')*1.)
set Njv[(gJv)]=(('i')*1.)
set Nhv[(gJv)]=((.6)*1.)
set NIv[(gJv)]=((350)*1.)
set NOv[(gJv)]=((350)*1.)
set Ndv[(gJv)]=(($F)*1.)
set ANv[(gJv)]=(gHv)
set Adv[(gJv)]=(('x')*1.)
set ADv[((gJv))]=((1.*1./((1.5)*1.))*1.)
set Atv[(gJv)]=((1)*1.)
set AQv[(gJv)]=((5)*1.)
set Asv[(gJv)]=((5)*1.)
set Auv[(gJv)]=(1)
set AWv[(gJv)]=($A)
set Azv[(gJv)]=(0)
set Aqv[(gJv)]=((16)*1.)
return true
endfunction
function hKo takes integer oqx,integer oQx,integer oSx returns boolean
return((LoadInteger(o[((D[((Fw[(oqx)]))]))],((((gw[((oqx))])))),(osx(((oQx)),(((oSx)))))))!=0)
endfunction
function hlo takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((Fw[(oqx)]))])]))],((((gw[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function hLo takes integer oqx,integer rJx,integer rwx returns nothing
if hKo((oqx),ISv,rJx)then
call oYx("FolderUnitType_FolderAbilities_StructArrayBuild_Add","call DebugEx(\"unitType \"+UnitType(this).GetName()+\" already has spell \"+whichSpell.GetName())","unitType "+(GetObjectName(IGv[((oqx))]))+" already has spell "+(sH[(rJx)]))
return
endif
call hho((oqx),ISv,rJx)
call hlo((oqx),Itv+rJx,rwx)
endfunction
function hmo takes nothing returns boolean
set gkv=hGo('uGnM')
call hho(((gkv)),Apv,(INv))
set Tj[(gkv)]=((1.25)*1.)
set Nav[(gkv)]=((26.666666666667)*1.)
set Ntv[(gkv)]=((26.666666666667)*1.)
set Nlv[(gkv)]=(($87)*1.)
set I3v[(gkv)]=((0)*1.)
set Axv[(gkv)]=(0)
set NJv[(gkv)]=((85)*1.)
set Njv[(gkv)]=((85)*1.)
set Nhv[(gkv)]=((.3)*1.)
set NKv[(gkv)]=((90)*1.)
set Nkv[(gkv)]=((90)*1.)
set NHv[(gkv)]=((.2)*1.)
set NIv[(gkv)]=(($578)*1.)
set NOv[(gkv)]=(($578)*1.)
set Ndv[(gkv)]=((40)*1.)
set ANv[(gkv)]=(gKv)
set Adv[(gkv)]=((600)*1.)
set ADv[((gkv))]=((1.*1./((1.6)*1.))*1.)
set Atv[(gkv)]=((.3)*1.)
set Drv[(gkv)]=(($4B0)*1.)
set AQv[(gkv)]=((7)*1.)
set Asv[(gkv)]=((7)*1.)
set Auv[(gkv)]=(1)
set AWv[(gkv)]=(5)
set Azv[(gkv)]=(3)
set Aqv[(gkv)]=((14.222222222222)*1.)
set Nxv[(gkv)]=(7)
set Nvv[(gkv)]=(35)
call hLo((gkv),(glv),1)
return true
endfunction
function hMo takes integer oqx,integer rJx returns nothing
local integer hpo=Iwv[oqx]+1
set Iwv[oqx]=hpo
call hlo((oqx),I_v+hpo,rJx)
endfunction
function hPo takes nothing returns boolean
set gLv=hGo('UKer')
call hLo((gLv),('AInv'),1)
call hho(((gLv)),Apv,(yd))
call hho(((gLv)),Apv,(INv))
set Tj[(gLv)]=((1.3)*1.)
set Nav[(gLv)]=((80)*1.)
set Ntv[(gLv)]=((80)*1.)
set Nlv[(gLv)]=((320)*1.)
set I3v[(gLv)]=((3)*1.)
set Axv[(gLv)]=(4)
set NJv[(gLv)]=(('d')*1.)
set Njv[(gLv)]=(('d')*1.)
set Nhv[(gLv)]=((0)*1.)
set NKv[(gLv)]=(('d')*1.)
set Nkv[(gLv)]=(('d')*1.)
set NHv[(gLv)]=((0)*1.)
set NIv[(gLv)]=(($708)*1.)
set NOv[(gLv)]=(($708)*1.)
set ANv[(gLv)]=(gHv)
set Adv[(gLv)]=(('x')*1.)
set ADv[((gLv))]=((1.*1./((1.3)*1.))*1.)
set Atv[(gLv)]=((.3)*1.)
set AQv[(gLv)]=(($A)*1.)
set Asv[(gLv)]=(($A)*1.)
set Auv[(gLv)]=(4)
set AWv[(gLv)]=(4)
set Azv[(gLv)]=(0)
set Aqv[(gLv)]=((32)*1.)
call hMo(gLv,gmv)
call hMo(gLv,gMv)
call hMo(gLv,gpv)
call hMo(gLv,gPv)
set bbv[(gLv)]=(($C)*1.)
set bFv[(gLv)]=((3.75)*1.)
set bgv[(gLv)]=((1)*1.)
set bBv[(gLv)]=(($A)*1.)
set bGv[(gLv)]=((3.5)*1.)
set bcv[(gLv)]=((9.5)*1.)
set bhv[(gLv)]=((4)*1.)
return true
endfunction
function hqo takes nothing returns boolean
set gqv=hGo('uBTw')
call hho(((gqv)),Apv,(ICv))
set Tj[(gqv)]=((1.55)*1.)
call hHo(gqv,$C8,$C8,$C8,$FF)
set I3v[(gqv)]=((0)*1.)
set Axv[(gqv)]=(3)
set NJv[(gqv)]=((150000.)*1.)
set Njv[(gqv)]=((150000.)*1.)
set Nhv[(gqv)]=((0)*1.)
set NIv[(gqv)]=(($578)*1.)
set NOv[(gqv)]=(($578)*1.)
set AQv[(gqv)]=((0)*1.)
set Asv[(gqv)]=((0)*1.)
set Auv[(gqv)]=(0)
set AWv[(gqv)]=(0)
call hLo((gqv),(gQv),1)
return true
endfunction
function hQo takes nothing returns boolean
set gsv=hGo('uITP')
call hho(((gsv)),Apv,(INv))
set Tj[(gsv)]=((1.75)*1.)
call hHo(gsv,$AA,$82,$FF,$FF)
set Nav[(gsv)]=((38.4)*1.)
set Ntv[(gsv)]=((38.4)*1.)
set Nlv[(gsv)]=(($91)*1.)
set I3v[(gsv)]=((0)*1.)
set Axv[(gsv)]=(1)
set NJv[(gsv)]=(('s')*1.)
set Njv[(gsv)]=(('s')*1.)
set Nhv[(gsv)]=((.4)*1.)
set NKv[(gsv)]=((80)*1.)
set Nkv[(gsv)]=((80)*1.)
set NHv[(gsv)]=((.4)*1.)
set NIv[(gsv)]=(($578)*1.)
set NOv[(gsv)]=(($578)*1.)
set Ndv[(gsv)]=((35)*1.)
set ANv[(gsv)]=(gSv)
set Adv[(gsv)]=((720)*1.)
set ADv[((gsv))]=((1.*1./((1.8)*1.))*1.)
set Atv[(gsv)]=((.3)*1.)
set Drv[(gsv)]=((900)*1.)
set AQv[(gsv)]=((8)*1.)
set Asv[(gsv)]=((8)*1.)
set Auv[(gsv)]=(1)
set AWv[(gsv)]=(8)
set Azv[(gsv)]=(3)
set Aqv[(gsv)]=((25.6)*1.)
set Nxv[(gsv)]=(9)
set Nvv[(gsv)]=(25)
call hLo((gsv),(gtv),1)
call hLo((gsv),(gTv),1)
return true
endfunction
function hso takes nothing returns boolean
set guv=hGo('uDT2')
call hho(((guv)),Apv,(ICv))
set Tj[(guv)]=((2.25)*1.)
call hHo(guv,$90,0,$90,$FF)
set Nav[(guv)]=(('x')*1.)
set Ntv[(guv)]=(($B4)*1.)
set I3v[(guv)]=((0)*1.)
set Axv[(guv)]=(3)
set NJv[(guv)]=((150000.)*1.)
set Njv[(guv)]=((150000.)*1.)
set Nhv[(guv)]=((0)*1.)
set NIv[(guv)]=(($578)*1.)
set NOv[(guv)]=(($578)*1.)
set ANv[(guv)]=(gSv)
set Adv[(guv)]=(($4B0)*1.)
set ADv[((guv))]=((1.*1./((1.6)*1.))*1.)
set Atv[(guv)]=((.5)*1.)
set Drv[(guv)]=(($3E8)*1.)
set AQv[(guv)]=((32)*1.)
set Asv[(guv)]=((32)*1.)
set Auv[(guv)]=(3)
set AWv[(guv)]=(5)
set Azv[(guv)]=(4)
call hLo((guv),(gQv),1)
call hLo((guv),(gUv),(2))
return true
endfunction
function hSo takes nothing returns boolean
set gwv=hGo('UThr')
call hLo((gwv),('AInv'),1)
call hho(((gwv)),Apv,(yd))
call hho(((gwv)),Apv,(INv))
set Tj[(gwv)]=((1.35)*1.)
set Nav[(gwv)]=((60)*1.)
set Ntv[(gwv)]=((60)*1.)
set Nlv[(gwv)]=((330)*1.)
set I3v[(gwv)]=((.5)*1.)
set Axv[(gwv)]=(4)
set NJv[(gwv)]=(('d')*1.)
set Njv[(gwv)]=(('d')*1.)
set Nhv[(gwv)]=((0)*1.)
set NKv[(gwv)]=(('d')*1.)
set Nkv[(gwv)]=(('d')*1.)
set NHv[(gwv)]=((0)*1.)
set NIv[(gwv)]=(($708)*1.)
set NOv[(gwv)]=(($708)*1.)
set ANv[(gwv)]=(gSv)
set Adv[(gwv)]=((720)*1.)
set ADv[((gwv))]=((1.*1./((1.7)*1.))*1.)
set Atv[(gwv)]=((.3)*1.)
set Drv[(gwv)]=(($4B0)*1.)
set AQv[(gwv)]=((7)*1.)
set Asv[(gwv)]=((7)*1.)
set Auv[(gwv)]=(1)
set AWv[(gwv)]=($A)
set Azv[(gwv)]=(3)
set Aqv[(gwv)]=((32)*1.)
call hMo(gwv,gWv)
call hMo(gwv,gyv)
call hMo(gwv,gYv)
call hMo(gwv,gzv)
set bbv[(gwv)]=((9)*1.)
set bFv[(gwv)]=((3.5)*1.)
set bgv[(gwv)]=((.5)*1.)
set bBv[(gwv)]=((14.5)*1.)
set bGv[(gwv)]=((4)*1.)
set bcv[(gwv)]=((7.5)*1.)
set bhv[(gwv)]=((3)*1.)
return true
endfunction
function hto takes nothing returns boolean
set gZv=hGo('uIcT')
call hho(((gZv)),Apv,(INv))
set Tj[(gZv)]=((1.25)*1.)
call hHo(gZv,$BE,$FF,$FF,$FF)
set Nav[(gZv)]=((60)*1.)
set Ntv[(gZv)]=((60)*1.)
set Nlv[(gZv)]=(($91)*1.)
set I3v[(gZv)]=((1)*1.)
set Axv[(gZv)]=(1)
set NJv[(gZv)]=((70)*1.)
set Njv[(gZv)]=((70)*1.)
set Nhv[(gZv)]=((.15)*1.)
set NIv[(gZv)]=(($578)*1.)
set NOv[(gZv)]=(($578)*1.)
set Ndv[(gZv)]=((20)*1.)
set ANv[(gZv)]=(gHv)
set Adv[(gZv)]=(('x')*1.)
set ADv[((gZv))]=((1.*1./((1.6)*1.))*1.)
set Atv[(gZv)]=((.3)*1.)
set AQv[(gZv)]=((8)*1.)
set Asv[(gZv)]=((8)*1.)
set Auv[(gZv)]=(2)
set AWv[(gZv)]=(2)
set Azv[(gZv)]=(0)
set Aqv[(gZv)]=((32)*1.)
set Nxv[(gZv)]=(6)
set Nvv[(gZv)]=(30)
return true
endfunction
function hTo takes integer oqx,integer o6x,integer oQx,real oSx returns boolean
local integer o7x=(0+(LoadInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx))))))+1
call SaveInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx))),(((o7x)-0)))
call SaveReal(o[((V[(E[(oqx)])]))],((o6x)),((oQx+o7x)),((((oSx)*1.))*1.))
return(o7x==q)
endfunction
function huo takes integer oqx,integer oQx,real oSx returns boolean
return hTo(Fw[(oqx)],(gw[((oqx))]),oQx,oSx)
endfunction
function hUo takes integer oqx,real O1o,real O2o returns nothing
call huo((oqx),Afv,O1o)
call huo((oqx),ALv,O2o)
endfunction
function hwo takes nothing returns boolean
set g_v=hGo('uFTw')
call hho(((g_v)),Apv,(ICv))
set Tj[(g_v)]=((1.4)*1.)
set Nav[(g_v)]=(('x')*1.)
set Ntv[(g_v)]=(($91)*1.)
set I3v[(g_v)]=((0)*1.)
set Axv[(g_v)]=(3)
set NJv[(g_v)]=((150000.)*1.)
set Njv[(g_v)]=((150000.)*1.)
set Nhv[(g_v)]=((0)*1.)
set NIv[(g_v)]=(($578)*1.)
set NOv[(g_v)]=(($578)*1.)
set ANv[(g_v)]=(gSv)
set Adv[(g_v)]=(($4B0)*1.)
set ADv[((g_v))]=((1.*1./((2.5)*1.))*1.)
set Atv[(g_v)]=((.5)*1.)
set Drv[(g_v)]=((700)*1.)
call hUo(g_v,80,1)
call hUo(g_v,$96,.4)
call hUo(g_v,$DC,.2)
set AQv[(g_v)]=((19)*1.)
set Asv[(g_v)]=((19)*1.)
set Auv[(g_v)]=(2)
set AWv[(g_v)]=(3)
set Azv[(g_v)]=(3)
call hLo((g_v),(gQv),1)
call hLo((g_v),(g0v),1)
return true
endfunction
function hWo takes nothing returns boolean
set g1v=hGo('UMan')
call hLo((g1v),('AInv'),1)
call hho(((g1v)),Apv,(yd))
call hho(((g1v)),Apv,(INv))
set Tj[(g1v)]=((1.25)*1.)
set Nav[(g1v)]=((83.044982698962)*1.)
set Ntv[(g1v)]=((91.349480968858)*1.)
set Nlv[(g1v)]=((305)*1.)
set I3v[(g1v)]=((0)*1.)
set Axv[(g1v)]=(4)
set NJv[(g1v)]=(('d')*1.)
set Njv[(g1v)]=(('d')*1.)
set Nhv[(g1v)]=((0)*1.)
set NKv[(g1v)]=(('d')*1.)
set Nkv[(g1v)]=(('d')*1.)
set NHv[(g1v)]=((0)*1.)
set NIv[(g1v)]=(($708)*1.)
set NOv[(g1v)]=(($708)*1.)
set ANv[(g1v)]=(gSv)
set Adv[(g1v)]=((720)*1.)
set ADv[((g1v))]=((1.*1./((1.7)*1.))*1.)
set Atv[(g1v)]=((.55)*1.)
set Drv[(g1v)]=((900)*1.)
set AQv[(g1v)]=(($E)*1.)
set Asv[(g1v)]=(($E)*1.)
set Auv[(g1v)]=(1)
set AWv[(g1v)]=($E)
set Azv[(g1v)]=(3)
set Aqv[(g1v)]=((37.647058823529)*1.)
call hMo(g1v,g2v)
call hMo(g1v,g3v)
call hMo(g1v,g4v)
call hMo(g1v,g5v)
set bbv[(g1v)]=((7.5)*1.)
set bFv[(g1v)]=((3)*1.)
set bgv[(g1v)]=((.4)*1.)
set bBv[(g1v)]=((17.5)*1.)
set bGv[(g1v)]=((4.5)*1.)
set bcv[(g1v)]=((5)*1.)
set bhv[(g1v)]=((2.5)*1.)
return true
endfunction
function hyo takes nothing returns boolean
set g6v=hGo('uFuM')
call hho(((g6v)),Apv,(INv))
set Tj[(g6v)]=((1.75)*1.)
call hHo(g6v,$FF,'x',$96,$FF)
set Nav[(g6v)]=((35.502958579882)*1.)
set Ntv[(g6v)]=((35.502958579882)*1.)
set Nlv[(g6v)]=(($BE)*1.)
set I3v[(g6v)]=((4)*1.)
set Axv[(g6v)]=(2)
set NJv[(g6v)]=((600)*1.)
set Njv[(g6v)]=((600)*1.)
set Nhv[(g6v)]=((1)*1.)
set NKv[(g6v)]=(('d')*1.)
set Nkv[(g6v)]=(('d')*1.)
set NHv[(g6v)]=((.4)*1.)
set NIv[(g6v)]=(($578)*1.)
set NOv[(g6v)]=(($578)*1.)
set Ndv[(g6v)]=((40)*1.)
set ANv[(g6v)]=(gHv)
set Adv[(g6v)]=(($A8)*1.)
set ADv[((g6v))]=((1.*1./((2)*1.))*1.)
set Atv[(g6v)]=((.3)*1.)
set AQv[(g6v)]=((24)*1.)
set Asv[(g6v)]=((24)*1.)
set Auv[(g6v)]=(3)
set AWv[(g6v)]=(4)
set Azv[(g6v)]=(4)
set Aqv[(g6v)]=((28.402366863905)*1.)
set Nxv[(g6v)]=($96)
set Nvv[(g6v)]=(80)
call hLo((g6v),(g7v),1)
return true
endfunction
function hYo takes nothing returns boolean
set g8v=hGo('uTrP')
call hho(((g8v)),Apv,(INv))
set Tj[(g8v)]=((1)*1.)
call hHo(g8v,$FF,$8C,$FF,$FF)
set Nav[(g8v)]=((123.45679012346)*1.)
set Ntv[(g8v)]=((74.074074074074)*1.)
set Nlv[(g8v)]=((280)*1.)
set I3v[(g8v)]=((0)*1.)
set Axv[(g8v)]=(2)
set NJv[(g8v)]=((400)*1.)
set Njv[(g8v)]=((400)*1.)
set Nhv[(g8v)]=((.3)*1.)
set NIv[(g8v)]=(($578)*1.)
set NOv[(g8v)]=(($578)*1.)
set Ndv[(g8v)]=((30)*1.)
set ANv[(g8v)]=(gHv)
set Adv[(g8v)]=(('x')*1.)
set ADv[((g8v))]=((1.*1./((1.35)*1.))*1.)
set Atv[(g8v)]=((.467)*1.)
set AQv[(g8v)]=(($F)*1.)
set Asv[(g8v)]=(($F)*1.)
set Auv[(g8v)]=(1)
set AWv[(g8v)]=(2)
set Azv[(g8v)]=(0)
set Aqv[(g8v)]=((39.506172839506)*1.)
set Nxv[(g8v)]=(21)
set Nvv[(g8v)]=(55)
return true
endfunction
function hzo takes nothing returns boolean
set g9v=hGo('uFT2')
call hho(((g9v)),Apv,(ICv))
set Tj[(g9v)]=((1.6)*1.)
call hHo(g9v,92,92,$FF,$FF)
set Nav[(g9v)]=(('x')*1.)
set Ntv[(g9v)]=(($91)*1.)
set I3v[(g9v)]=((0)*1.)
set Axv[(g9v)]=(3)
set NJv[(g9v)]=((150000.)*1.)
set Njv[(g9v)]=((150000.)*1.)
set Nhv[(g9v)]=((0)*1.)
set NIv[(g9v)]=(($578)*1.)
set NOv[(g9v)]=(($578)*1.)
set ANv[(g9v)]=(gSv)
set Adv[(g9v)]=(($4B0)*1.)
set ADv[((g9v))]=((1.*1./((2.5)*1.))*1.)
set Atv[(g9v)]=((.5)*1.)
set Drv[(g9v)]=((700)*1.)
call hUo(g9v,80,1)
call hUo(g9v,$96,.4)
call hUo(g9v,$DC,.2)
set AQv[(g9v)]=((27)*1.)
set Asv[(g9v)]=((27)*1.)
set Auv[(g9v)]=(4)
set AWv[(g9v)]=(3)
set Azv[(g9v)]=(3)
call hLo((g9v),(gQv),1)
call hLo((g9v),(g0v),(2))
return true
endfunction
function hZo takes nothing returns boolean
set Gvv=hGo('uWoM')
call hho(((Gvv)),Apv,(INv))
set Tj[(Gvv)]=((1.45)*1.)
call hHo(Gvv,$96,'x',$FF,$FF)
set Nav[(Gvv)]=((28.537455410226)*1.)
set Ntv[(Gvv)]=((28.537455410226)*1.)
set Nlv[(Gvv)]=((320)*1.)
set I3v[(Gvv)]=((2)*1.)
set Axv[(Gvv)]=(2)
set NJv[(Gvv)]=((350)*1.)
set Njv[(Gvv)]=((350)*1.)
set Nhv[(Gvv)]=((.4)*1.)
set NIv[(Gvv)]=(($578)*1.)
set NOv[(Gvv)]=(($578)*1.)
set Ndv[(Gvv)]=((20)*1.)
set ANv[(Gvv)]=(gHv)
set Adv[(Gvv)]=(('l')*1.)
set ADv[((Gvv))]=((1.*1./((1.4)*1.))*1.)
set Atv[(Gvv)]=((.33)*1.)
set AQv[(Gvv)]=((18)*1.)
set Asv[(Gvv)]=((18)*1.)
set Auv[(Gvv)]=(3)
set AWv[(Gvv)]=(4)
set Azv[(Gvv)]=(0)
set Aqv[(Gvv)]=((22.829964328181)*1.)
set Nxv[(Gvv)]=(50)
set Nvv[(Gvv)]=(60)
return true
endfunction
function h_o takes nothing returns boolean
set Gev=hGo('UDra')
call hLo((Gev),('AInv'),1)
call hho(((Gev)),Apv,(yd))
call hho(((Gev)),Apv,(INv))
set Tj[(Gev)]=((1.3)*1.)
set Nav[(Gev)]=(('d')*1.)
set Ntv[(Gev)]=((60)*1.)
set Nlv[(Gev)]=((330)*1.)
set I3v[(Gev)]=((1)*1.)
set Axv[(Gev)]=(4)
set NJv[(Gev)]=(('d')*1.)
set Njv[(Gev)]=(('d')*1.)
set Nhv[(Gev)]=((0)*1.)
set NKv[(Gev)]=(('d')*1.)
set Nkv[(Gev)]=(('d')*1.)
set NHv[(Gev)]=((0)*1.)
set NIv[(Gev)]=(($708)*1.)
set NOv[(Gev)]=(($708)*1.)
set ANv[(Gev)]=(gHv)
set Adv[(Gev)]=(('x')*1.)
set ADv[((Gev))]=((1.*1./((1.6)*1.))*1.)
set Atv[(Gev)]=((.55)*1.)
set AQv[(Gev)]=(($E)*1.)
set Asv[(Gev)]=(($E)*1.)
set Auv[(Gev)]=(2)
set AWv[(Gev)]=(7)
set Azv[(Gev)]=(0)
set Aqv[(Gev)]=((32)*1.)
call hMo(Gev,Gxv)
call hMo(Gev,Gov)
call hMo(Gev,Grv)
call hMo(Gev,Giv)
set bbv[(Gev)]=((9)*1.)
set bFv[(Gev)]=((3.7)*1.)
set bgv[(Gev)]=((.65)*1.)
set bBv[(Gev)]=((9)*1.)
set bGv[(Gev)]=((3.7)*1.)
set bcv[(Gev)]=(($B)*1.)
set bhv[(Gev)]=((4)*1.)
return true
endfunction
function h0o takes nothing returns boolean
set Gav=hGo('uRai')
call hho(((Gav)),Apv,(INv))
set Tj[(Gav)]=((1)*1.)
set Nav[(Gav)]=((60)*1.)
set Ntv[(Gav)]=((60)*1.)
set Nlv[(Gav)]=(($96)*1.)
set I3v[(Gav)]=((0)*1.)
set Axv[(Gav)]=(1)
set NJv[(Gav)]=(($C8)*1.)
set Njv[(Gav)]=(($C8)*1.)
set Nhv[(Gav)]=((.1)*1.)
set NIv[(Gav)]=(($578)*1.)
set NOv[(Gav)]=(($578)*1.)
set Ndv[(Gav)]=((30)*1.)
set ANv[(Gav)]=(gHv)
set Adv[(Gav)]=(($A2)*1.)
set ADv[((Gav))]=((1.*1./((1.85)*1.))*1.)
set Atv[(Gav)]=((.5)*1.)
set AQv[(Gav)]=(($A)*1.)
set Asv[(Gav)]=(($A)*1.)
set Auv[(Gav)]=(1)
set AWv[(Gav)]=(5)
set Azv[(Gav)]=(2)
set Aqv[(Gav)]=((32)*1.)
set Nxv[(Gav)]=(35)
set Nvv[(Gav)]=(40)
return true
endfunction
function h1o takes nothing returns boolean
set Gnv=hGo('uVia')
call hho(((Gnv)),Apv,(INv))
set Tj[(Gnv)]=((1.15)*1.)
call hHo(Gnv,$FF,$FF,$FF,$FF)
set Nav[(Gnv)]=((60)*1.)
set Ntv[(Gnv)]=((60)*1.)
set Nlv[(Gnv)]=((270)*1.)
set I3v[(Gnv)]=((0)*1.)
set Axv[(Gnv)]=(5)
set NJv[(Gnv)]=(($C8)*1.)
set Njv[(Gnv)]=(($C8)*1.)
set Nhv[(Gnv)]=((.2)*1.)
set NKv[(Gnv)]=(($96)*1.)
set Nkv[(Gnv)]=(($96)*1.)
set NHv[(Gnv)]=((.2)*1.)
set NIv[(Gnv)]=(($578)*1.)
set NOv[(Gnv)]=(($578)*1.)
set Ndv[(Gnv)]=(($F)*1.)
set ANv[(Gnv)]=(gSv)
set Adv[(Gnv)]=((720)*1.)
set ADv[((Gnv))]=((1.*1./((2)*1.))*1.)
set Atv[(Gnv)]=((.3)*1.)
set Drv[(Gnv)]=(($4B0)*1.)
set AQv[(Gnv)]=((1)*1.)
set Asv[(Gnv)]=((1)*1.)
set Auv[(Gnv)]=(1)
set AWv[(Gnv)]=(2)
set Azv[(Gnv)]=(3)
set Aqv[(Gnv)]=((16)*1.)
set Nxv[(Gnv)]=(20)
set Nvv[(Gnv)]=($A)
return true
endfunction
function h2o takes nothing returns boolean
set GVv=hGo('uAss')
call hho(((GVv)),Apv,(INv))
set Tj[(GVv)]=((1.1)*1.)
set Nav[(GVv)]=((38.4)*1.)
set Ntv[(GVv)]=((38.4)*1.)
set Nlv[(GVv)]=(($87)*1.)
set I3v[(GVv)]=((1)*1.)
set Axv[(GVv)]=(5)
set NJv[(GVv)]=(($F0)*1.)
set Njv[(GVv)]=(($F0)*1.)
set Nhv[(GVv)]=((.2)*1.)
set NKv[(GVv)]=(($C8)*1.)
set Nkv[(GVv)]=(($C8)*1.)
set NHv[(GVv)]=((.6)*1.)
set NIv[(GVv)]=(($708)*1.)
set NOv[(GVv)]=(($708)*1.)
set Ndv[(GVv)]=((60)*1.)
set ANv[(GVv)]=(gHv)
set Adv[(GVv)]=(('x')*1.)
set ADv[((GVv))]=((1.*1./((1.4)*1.))*1.)
set Atv[(GVv)]=((.35)*1.)
set AQv[(GVv)]=(($A)*1.)
set Asv[(GVv)]=(($A)*1.)
set Auv[(GVv)]=(2)
set AWv[(GVv)]=(6)
set Azv[(GVv)]=(0)
set Aqv[(GVv)]=((20.48)*1.)
set Nxv[(GVv)]=(30)
set Nvv[(GVv)]=('d')
call hLo((GVv),(GEv),1)
return true
endfunction
function h3o takes nothing returns boolean
set GXv=hGo('uTus')
call hho(((GXv)),Apv,(INv))
set Tj[(GXv)]=((.75)*1.)
call hHo(GXv,$FF,$FF,$FF,$FF)
set Nav[(GXv)]=((106.66666666667)*1.)
set Ntv[(GXv)]=((126.22222222222)*1.)
set Nlv[(GXv)]=((270)*1.)
set I3v[(GXv)]=((0)*1.)
set Axv[(GXv)]=(1)
set NJv[(GXv)]=(('n')*1.)
set Njv[(GXv)]=(('n')*1.)
set Nhv[(GXv)]=((.25)*1.)
set NIv[(GXv)]=(($578)*1.)
set NOv[(GXv)]=(($578)*1.)
set Ndv[(GXv)]=(($D)*1.)
set ANv[(GXv)]=(gKv)
set Adv[(GXv)]=((600)*1.)
set ADv[((GXv))]=((1.*1./((1.8)*1.))*1.)
set Atv[(GXv)]=((.3)*1.)
set Drv[(GXv)]=(($4B0)*1.)
set AQv[(GXv)]=((7)*1.)
set Asv[(GXv)]=((7)*1.)
set Auv[(GXv)]=(3)
set AWv[(GXv)]=(2)
set Azv[(GXv)]=(1)
set Aqv[(GXv)]=((55.111111111111)*1.)
set Nxv[(GXv)]=($F)
set Nvv[(GXv)]=($F)
return true
endfunction
function h4o takes integer oqx,integer oQx,boolean oSx returns nothing
call SaveBoolean(o[((V[(E[((Fw[(oqx)]))])]))],((((gw[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function h5o takes integer oqx,integer oQx returns boolean
local boolean abx=dKo(oqx,oQx)
call h4o(oqx,oQx,not false)
return(abx==false)
endfunction
function h6o takes nothing returns boolean
set GOv=hGo('uCat')
call hho(((GOv)),Apv,(INv))
set Tj[(GOv)]=((1)*1.)
set Nav[(GOv)]=((60)*1.)
set Ntv[(GOv)]=((60)*1.)
set Nlv[(GOv)]=(('n')*1.)
set I3v[(GOv)]=((2)*1.)
set Axv[(GOv)]=(2)
set NJv[(GOv)]=((300)*1.)
set Njv[(GOv)]=((300)*1.)
set Nhv[(GOv)]=((0)*1.)
set NIv[(GOv)]=(($578)*1.)
set NOv[(GOv)]=(($578)*1.)
set Ndv[(GOv)]=((50)*1.)
set ANv[(GOv)]=(Abv)
set Adv[(GOv)]=(($564)*1.)
set ADv[((GOv))]=((1.*1./((4.5)*1.))*1.)
set Atv[(GOv)]=((.1)*1.)
set Drv[(GOv)]=((900)*1.)
call hUo(GOv,40,1)
call hUo(GOv,75,.4)
call hUo(GOv,'n',.2)
call h5o(((GOv)),dcv+(0))
set AQv[(GOv)]=((20)*1.)
set Asv[(GOv)]=((20)*1.)
set Auv[(GOv)]=(1)
set AWv[(GOv)]=($F)
set Azv[(GOv)]=(2)
set Aqv[(GOv)]=((48)*1.)
set Nxv[(GOv)]=(25)
set Nvv[(GOv)]=(50)
return true
endfunction
function h7o takes nothing returns boolean
set GRv=hGo('UTrL')
call hLo((GRv),('AInv'),1)
call hho(((GRv)),Apv,(yd))
call hho(((GRv)),Apv,(INv))
set Tj[(GRv)]=((1.25)*1.)
set Nav[(GRv)]=((38.4)*1.)
set Ntv[(GRv)]=((38.4)*1.)
set Nlv[(GRv)]=(($B4)*1.)
set I3v[(GRv)]=((7)*1.)
set Axv[(GRv)]=(4)
set NJv[(GRv)]=(($9C4)*1.)
set Njv[(GRv)]=(($9C4)*1.)
set Nhv[(GRv)]=((1)*1.)
set NKv[(GRv)]=(($C8)*1.)
set Nkv[(GRv)]=(($C8)*1.)
set NHv[(GRv)]=((.5)*1.)
set NIv[(GRv)]=(($708)*1.)
set NOv[(GRv)]=(($708)*1.)
set Ndv[(GRv)]=(('x')*1.)
set ANv[(GRv)]=(gHv)
set Adv[(GRv)]=(('x')*1.)
set ADv[((GRv))]=((1.*1./((2.2)*1.))*1.)
set Atv[(GRv)]=((.433)*1.)
set AQv[(GRv)]=((30)*1.)
set Asv[(GRv)]=((30)*1.)
set Auv[(GRv)]=(2)
set AWv[(GRv)]=(6)
set Azv[(GRv)]=(5)
set Aqv[(GRv)]=((20.48)*1.)
set Nxv[(GRv)]=('d')
set Nvv[(GRv)]=($C8)
call hLo((GRv),(GIv),1)
call hLo((GRv),(GAv),1)
return true
endfunction
function h8o takes nothing returns boolean
set GNv=hGo('uDem')
call hho(((GNv)),Apv,(INv))
set Tj[(GNv)]=((1)*1.)
set Nav[(GNv)]=((26.666666666667)*1.)
set Ntv[(GNv)]=((26.666666666667)*1.)
set Nlv[(GNv)]=(($87)*1.)
set I3v[(GNv)]=(($A)*1.)
set Axv[(GNv)]=(3)
set NJv[(GNv)]=((300)*1.)
set Njv[(GNv)]=((300)*1.)
set Nhv[(GNv)]=((0)*1.)
set NIv[(GNv)]=(($578)*1.)
set NOv[(GNv)]=(($578)*1.)
set Ndv[(GNv)]=((75)*1.)
set ANv[(GNv)]=(Abv)
set Adv[(GNv)]=(($6CC)*1.)
set ADv[((GNv))]=((1.*1./((4.5)*1.))*1.)
set Atv[(GNv)]=((.1)*1.)
set Drv[(GNv)]=((900)*1.)
call hUo(GNv,80,1)
call hUo(GNv,$96,.4)
call hUo(GNv,$DC,.2)
call h5o(((GNv)),dcv+(0))
set AQv[(GNv)]=((70)*1.)
set Asv[(GNv)]=((70)*1.)
set Auv[(GNv)]=(1)
set AWv[(GNv)]=(30)
set Azv[(GNv)]=(2)
set Aqv[(GNv)]=((32)*1.)
set Nxv[(GNv)]=(50)
set Nvv[(GNv)]=($96)
call hLo((GNv),(gQv),1)
return true
endfunction
function h9o takes nothing returns boolean
set Gbv=hGo('USmo')
call hLo((Gbv),('AInv'),1)
call hho(((Gbv)),Apv,(yd))
call hho(((Gbv)),Apv,(INv))
set Tj[(Gbv)]=((1.3)*1.)
set Nav[(Gbv)]=(('d')*1.)
set Ntv[(Gbv)]=((76)*1.)
set Nlv[(Gbv)]=((360)*1.)
set I3v[(Gbv)]=((3)*1.)
set Axv[(Gbv)]=(4)
set NJv[(Gbv)]=(('d')*1.)
set Njv[(Gbv)]=(('d')*1.)
set Nhv[(Gbv)]=((0)*1.)
set NKv[(Gbv)]=(('d')*1.)
set Nkv[(Gbv)]=(('d')*1.)
set NHv[(Gbv)]=((0)*1.)
set NIv[(Gbv)]=(($708)*1.)
set NOv[(Gbv)]=(($708)*1.)
set ANv[(Gbv)]=(gHv)
set Adv[(Gbv)]=(('x')*1.)
set ADv[((Gbv))]=((1.*1./((1.4)*1.))*1.)
set Atv[(Gbv)]=((.56)*1.)
set AQv[(Gbv)]=(($D)*1.)
set Asv[(Gbv)]=(($D)*1.)
set Auv[(Gbv)]=(4)
set AWv[(Gbv)]=(4)
set Azv[(Gbv)]=(0)
set Aqv[(Gbv)]=((32)*1.)
call hMo(Gbv,GBv)
call hMo(Gbv,Gcv)
call hMo(Gbv,GCv)
call hMo(Gbv,Gdv)
set bbv[(Gbv)]=((13.5)*1.)
set bFv[(Gbv)]=((4.65)*1.)
set bgv[(Gbv)]=((1)*1.)
set bBv[(Gbv)]=((7.5)*1.)
set bGv[(Gbv)]=((3.5)*1.)
set bcv[(Gbv)]=(($A)*1.)
set bhv[(Gbv)]=((3.85)*1.)
return true
endfunction
function Hvo takes nothing returns boolean
set GDv=hGo('uKoR')
call hho(((GDv)),Apv,(INv))
set Tj[(GDv)]=((1.25)*1.)
call hHo(GDv,$FF,$96,$B4,$FF)
set Nav[(GDv)]=((38.4)*1.)
set Ntv[(GDv)]=((38.4)*1.)
set Nlv[(GDv)]=((270)*1.)
set I3v[(GDv)]=((1)*1.)
set Axv[(GDv)]=(2)
set NJv[(GDv)]=(($8C)*1.)
set Njv[(GDv)]=(($8C)*1.)
set Nhv[(GDv)]=((.2)*1.)
set NIv[(GDv)]=(($578)*1.)
set NOv[(GDv)]=(($578)*1.)
set Ndv[(GDv)]=(($C)*1.)
set ANv[(GDv)]=(gHv)
set Adv[(GDv)]=(('x')*1.)
set ADv[((GDv))]=((1.*1./((1.4)*1.))*1.)
set Atv[(GDv)]=((.38)*1.)
set AQv[(GDv)]=((7)*1.)
set Asv[(GDv)]=((7)*1.)
set Auv[(GDv)]=(1)
set AWv[(GDv)]=(3)
set Azv[(GDv)]=(0)
set Aqv[(GDv)]=((19.84)*1.)
set Nxv[(GDv)]=(20)
set Nvv[(GDv)]=($F)
return true
endfunction
function Heo takes nothing returns boolean
set Gfv=hGo('uTow')
call hho(((Gfv)),Apv,(ICv))
set Tj[(Gfv)]=((2.25)*1.)
set Nav[(Gfv)]=((60)*1.)
set Ntv[(Gfv)]=((60)*1.)
set I3v[(Gfv)]=((0)*1.)
set Axv[(Gfv)]=(3)
set NJv[(Gfv)]=((150000.)*1.)
set Njv[(Gfv)]=((150000.)*1.)
set Nhv[(Gfv)]=((0)*1.)
set NIv[(Gfv)]=(($578)*1.)
set NOv[(Gfv)]=(($578)*1.)
set ANv[(Gfv)]=(Abv)
set Adv[(Gfv)]=(($960)*1.)
set ADv[((Gfv))]=((1.*1./((2.5)*1.))*1.)
set Atv[(Gfv)]=((.3)*1.)
set Drv[(Gfv)]=((900)*1.)
call hUo(Gfv,80,1)
call hUo(Gfv,$96,.4)
call hUo(Gfv,$DC,.2)
set AQv[(Gfv)]=(($A)*1.)
set Asv[(Gfv)]=(($A)*1.)
set Auv[(Gfv)]=(5)
set AWv[(Gfv)]=(3)
set Azv[(Gfv)]=(2)
call hLo((Gfv),(gQv),1)
return true
endfunction
function Hxo takes nothing returns boolean
set GFv=hGo('uPan')
call hho(((GFv)),Apv,(INv))
set Tj[(GFv)]=((1)*1.)
call hHo(GFv,$FF,$FF,$FF,$FF)
set Nav[(GFv)]=(('d')*1.)
set Ntv[(GFv)]=((60)*1.)
set Nlv[(GFv)]=((300)*1.)
set I3v[(GFv)]=((2)*1.)
set Axv[(GFv)]=(2)
set NJv[(GFv)]=(($C8)*1.)
set Njv[(GFv)]=(($C8)*1.)
set Nhv[(GFv)]=((.4)*1.)
set NIv[(GFv)]=(($578)*1.)
set NOv[(GFv)]=(($578)*1.)
set Ndv[(GFv)]=(($E)*1.)
set ANv[(GFv)]=(gHv)
set Adv[(GFv)]=(('x')*1.)
set ADv[((GFv))]=((1.*1./((1.6)*1.))*1.)
set Atv[(GFv)]=((.3)*1.)
set AQv[(GFv)]=(($C)*1.)
set Asv[(GFv)]=(($C)*1.)
set Auv[(GFv)]=(2)
set AWv[(GFv)]=(3)
set Azv[(GFv)]=(0)
set Aqv[(GFv)]=((48)*1.)
set Nxv[(GFv)]=(25)
set Nvv[(GFv)]=(30)
return true
endfunction
function Hoo takes nothing returns boolean
set Ggv=hGo('UJot')
call hLo((Ggv),('AInv'),1)
call hho(((Ggv)),Apv,(yd))
call hho(((Ggv)),Apv,(INv))
set Tj[(Ggv)]=((1.3)*1.)
set Nav[(Ggv)]=((60)*1.)
set Ntv[(Ggv)]=((66)*1.)
set Nlv[(Ggv)]=((280)*1.)
set I3v[(Ggv)]=((0)*1.)
set Axv[(Ggv)]=(4)
set NJv[(Ggv)]=(('d')*1.)
set Njv[(Ggv)]=(('d')*1.)
set Nhv[(Ggv)]=((0)*1.)
set NKv[(Ggv)]=(('d')*1.)
set Nkv[(Ggv)]=(('d')*1.)
set NHv[(Ggv)]=((0)*1.)
set NIv[(Ggv)]=(($708)*1.)
set NOv[(Ggv)]=(($708)*1.)
set ANv[(Ggv)]=(gSv)
set Adv[(Ggv)]=((720)*1.)
set ADv[((Ggv))]=((1.*1./((2)*1.))*1.)
set Atv[(Ggv)]=((.55)*1.)
set Drv[(Ggv)]=((900)*1.)
set AQv[(Ggv)]=(($D)*1.)
set Asv[(Ggv)]=(($D)*1.)
set Auv[(Ggv)]=(2)
set AWv[(Ggv)]=(4)
set Azv[(Ggv)]=(3)
set Aqv[(Ggv)]=((32)*1.)
call hMo(Ggv,GGv)
call hMo(Ggv,Ghv)
call hMo(Ggv,GHv)
call hMo(Ggv,Gjv)
set bbv[(Ggv)]=((6)*1.)
set bFv[(Ggv)]=((2.5)*1.)
set bgv[(Ggv)]=((.8)*1.)
set bBv[(Ggv)]=((16)*1.)
set bGv[(Ggv)]=((4.5)*1.)
set bcv[(Ggv)]=((9)*1.)
set bhv[(Ggv)]=((3.5)*1.)
return true
endfunction
function Hro takes nothing returns boolean
set GJv=hGo('uTar')
call hho(((GJv)),Apv,(INv))
set Tj[(GJv)]=((1.35)*1.)
call hHo(GJv,$FF,$FF,$FF,$BE)
set Nav[(GJv)]=((60)*1.)
set Ntv[(GJv)]=((60)*1.)
set Nlv[(GJv)]=(($87)*1.)
set I3v[(GJv)]=((0)*1.)
set Axv[(GJv)]=(1)
set NJv[(GJv)]=((825)*1.)
set Njv[(GJv)]=((825)*1.)
set Nhv[(GJv)]=((.55)*1.)
set NIv[(GJv)]=(($578)*1.)
set NOv[(GJv)]=(($578)*1.)
set Ndv[(GJv)]=((85)*1.)
set ANv[(GJv)]=(gSv)
set Adv[(GJv)]=((720)*1.)
set ADv[((GJv))]=((1.*1./((1.75)*1.))*1.)
set Atv[(GJv)]=((.43)*1.)
set Drv[(GJv)]=(($4B0)*1.)
set AQv[(GJv)]=(($A)*1.)
set Asv[(GJv)]=(($A)*1.)
set Auv[(GJv)]=(2)
set AWv[(GJv)]=(3)
set Azv[(GJv)]=(4)
set Aqv[(GJv)]=((31)*1.)
set Nxv[(GJv)]=(60)
set Nvv[(GJv)]=('x')
call hLo((GJv),(Gkv),1)
call hLo((GJv),(GKv),1)
return true
endfunction
function Hio takes nothing returns boolean
set Glv=hGo('uPen')
call hho(((Glv)),Apv,(INv))
set Tj[(Glv)]=((1.5)*1.)
set Nav[(Glv)]=((60)*1.)
set Ntv[(Glv)]=((60)*1.)
set I3v[(Glv)]=((0)*1.)
set Axv[(Glv)]=(5)
set NJv[(Glv)]=(('d')*1.)
set Njv[(Glv)]=(('d')*1.)
set Nhv[(Glv)]=((0)*1.)
set NIv[(Glv)]=((350)*1.)
set NOv[(Glv)]=((350)*1.)
set AQv[(Glv)]=((0)*1.)
set Asv[(Glv)]=((0)*1.)
set Auv[(Glv)]=(0)
set AWv[(Glv)]=(0)
set Aqv[(Glv)]=((8)*1.)
return true
endfunction
function Hao takes nothing returns boolean
set GLv=hGo('uLTw')
call hho(((GLv)),Apv,(ICv))
set Tj[(GLv)]=((1.5)*1.)
call hHo(GLv,$C8,$C8,$C0,$FF)
set Nav[(GLv)]=(('x')*1.)
set Ntv[(GLv)]=(($FF)*1.)
set I3v[(GLv)]=((0)*1.)
set Axv[(GLv)]=(3)
set NJv[(GLv)]=((150000.)*1.)
set Njv[(GLv)]=((150000.)*1.)
set Nhv[(GLv)]=((0)*1.)
set NIv[(GLv)]=(($578)*1.)
set NOv[(GLv)]=(($578)*1.)
set ANv[(GLv)]=(gSv)
set Adv[(GLv)]=(($4B0)*1.)
set ADv[((GLv))]=((1.*1./((6)*1.))*1.)
set Atv[(GLv)]=((.5)*1.)
set Drv[(GLv)]=(($5DC)*1.)
set AQv[(GLv)]=((1)*1.)
set Asv[(GLv)]=((1)*1.)
set Auv[(GLv)]=(1)
set AWv[(GLv)]=(1)
set Azv[(GLv)]=(3)
call hLo((GLv),(gQv),1)
call hLo((GLv),(Gmv),1)
return true
endfunction
function Hno takes nothing returns boolean
set GMv=hGo('uNag')
call hho(((GMv)),Apv,(INv))
set Tj[(GMv)]=((1)*1.)
call hHo(GMv,$FF,$FF,$FF,$BE)
set Nav[(GMv)]=((60)*1.)
set Ntv[(GMv)]=((60)*1.)
set Nlv[(GMv)]=(($96)*1.)
set I3v[(GMv)]=((0)*1.)
set Axv[(GMv)]=(0)
set NJv[(GMv)]=((825)*1.)
set Njv[(GMv)]=((825)*1.)
set Nhv[(GMv)]=((.55)*1.)
set NKv[(GMv)]=((400)*1.)
set Nkv[(GMv)]=((400)*1.)
set NHv[(GMv)]=((.5)*1.)
set NIv[(GMv)]=(($578)*1.)
set NOv[(GMv)]=(($578)*1.)
set Ndv[(GMv)]=((70)*1.)
set ANv[(GMv)]=(gHv)
set Adv[(GMv)]=(('x')*1.)
set ADv[((GMv))]=((1.*1./((2.28)*1.))*1.)
set Atv[(GMv)]=((.5)*1.)
set AQv[(GMv)]=(($A)*1.)
set Asv[(GMv)]=(($A)*1.)
set Auv[(GMv)]=(2)
set AWv[(GMv)]=(3)
set Azv[(GMv)]=(3)
set Aqv[(GMv)]=((32)*1.)
set Nxv[(GMv)]=(50)
set Nvv[(GMv)]=('d')
call hLo((GMv),(Gpv),1)
call hLo((GMv),(GPv),1)
return true
endfunction
function HVo takes nothing returns boolean
set Gqv=hGo('uBal')
call hho(((Gqv)),Apv,(INv))
set Tj[(Gqv)]=((1.75)*1.)
set Nav[(Gqv)]=((29.387755102041)*1.)
set Ntv[(Gqv)]=((19.591836734694)*1.)
set Nlv[(Gqv)]=(($87)*1.)
set I3v[(Gqv)]=(($C)*1.)
set Axv[(Gqv)]=(4)
set NJv[(Gqv)]=(($514)*1.)
set Njv[(Gqv)]=(($514)*1.)
set Nhv[(Gqv)]=((1)*1.)
set NIv[(Gqv)]=(($708)*1.)
set NOv[(Gqv)]=(($708)*1.)
set Ndv[(Gqv)]=((70)*1.)
set ANv[(Gqv)]=(gHv)
set Adv[(Gqv)]=(($CC)*1.)
set ADv[((Gqv))]=((1.*1./((2.2)*1.))*1.)
set Atv[(Gqv)]=((.33)*1.)
set AQv[(Gqv)]=((40)*1.)
set Asv[(Gqv)]=((40)*1.)
set Auv[(Gqv)]=(2)
set AWv[(Gqv)]=(6)
set Azv[(Gqv)]=(0)
set Aqv[(Gqv)]=((27.428571428571)*1.)
set Nxv[(Gqv)]=('x')
set Nvv[(Gqv)]=($FA)
call hLo((Gqv),(GQv),1)
call hLo((Gqv),(Gsv),1)
return true
endfunction
function HEo takes nothing returns boolean
set GSv=hGo('uFou')
call hho(((GSv)),Apv,(ICv))
set Tj[(GSv)]=((1.5)*1.)
set Nav[(GSv)]=(('x')*1.)
set Ntv[(GSv)]=((60)*1.)
set I3v[(GSv)]=((0)*1.)
set Axv[(GSv)]=(3)
set NJv[(GSv)]=((150000.)*1.)
set Njv[(GSv)]=((150000.)*1.)
set Nhv[(GSv)]=((0)*1.)
set NIv[(GSv)]=((900)*1.)
set NOv[(GSv)]=((900)*1.)
set AQv[(GSv)]=((0)*1.)
set Asv[(GSv)]=((0)*1.)
set Auv[(GSv)]=(0)
set AWv[(GSv)]=(0)
call hLo((GSv),(gQv),1)
call hLo((GSv),(Gtv),1)
return true
endfunction
function HXo takes nothing returns boolean
set GTv=hGo('UAru')
call hLo((GTv),('AInv'),1)
call hho(((GTv)),Apv,(yd))
call hho(((GTv)),Apv,(INv))
set Tj[(GTv)]=((1.3)*1.)
set Nav[(GTv)]=((60)*1.)
set Ntv[(GTv)]=(('d')*1.)
set Nlv[(GTv)]=((320)*1.)
set I3v[(GTv)]=((2)*1.)
set Axv[(GTv)]=(4)
set NJv[(GTv)]=(('d')*1.)
set Njv[(GTv)]=(('d')*1.)
set Nhv[(GTv)]=((0)*1.)
set NKv[(GTv)]=(('d')*1.)
set Nkv[(GTv)]=(('d')*1.)
set NHv[(GTv)]=((0)*1.)
set NIv[(GTv)]=(($708)*1.)
set NOv[(GTv)]=(($708)*1.)
set ANv[(GTv)]=(gKv)
set Adv[(GTv)]=((720)*1.)
set ADv[((GTv))]=((1.*1./((1.55)*1.))*1.)
set Atv[(GTv)]=((.3)*1.)
set Drv[(GTv)]=((900)*1.)
set AQv[(GTv)]=(($C)*1.)
set Asv[(GTv)]=(($C)*1.)
set Auv[(GTv)]=(3)
set AWv[(GTv)]=(3)
set Azv[(GTv)]=(1)
set Aqv[(GTv)]=((32)*1.)
call hMo(GTv,Guv)
call hMo(GTv,GUv)
call hMo(GTv,Gwv)
call hMo(GTv,GWv)
set bbv[(GTv)]=(($C)*1.)
set bFv[(GTv)]=((3.75)*1.)
set bgv[(GTv)]=((.75)*1.)
set bBv[(GTv)]=(($B)*1.)
set bGv[(GTv)]=((4)*1.)
set bcv[(GTv)]=((8.5)*1.)
set bhv[(GTv)]=((3.5)*1.)
return true
endfunction
function HOo takes nothing returns boolean
set Gyv=hGo('UFuO')
call hLo((Gyv),('AInv'),1)
call hho(((Gyv)),Apv,(yd))
call hho(((Gyv)),Apv,(INv))
set Tj[(Gyv)]=((3.6)*1.)
set Nav[(Gyv)]=((60)*1.)
set Ntv[(Gyv)]=((60)*1.)
set Nlv[(Gyv)]=(($B4)*1.)
set I3v[(Gyv)]=((4)*1.)
set Axv[(Gyv)]=(4)
set NJv[(Gyv)]=((6500)*1.)
set Njv[(Gyv)]=((6500)*1.)
set Nhv[(Gyv)]=((3)*1.)
set NKv[(Gyv)]=(($5DC)*1.)
set Nkv[(Gyv)]=(($5DC)*1.)
set NHv[(Gyv)]=((5)*1.)
set NIv[(Gyv)]=(($708)*1.)
set NOv[(Gyv)]=(($708)*1.)
set Ndv[(Gyv)]=(('d')*1.)
set ANv[(Gyv)]=(gHv)
set Adv[(Gyv)]=(('x')*1.)
set ADv[((Gyv))]=((1.*1./((3)*1.))*1.)
set Atv[(Gyv)]=((.35)*1.)
set AQv[(Gyv)]=((44)*1.)
set Asv[(Gyv)]=((44)*1.)
set Auv[(Gyv)]=(1)
set AWv[(Gyv)]=(20)
set Azv[(Gyv)]=(5)
set Aqv[(Gyv)]=((32)*1.)
set Nxv[(Gyv)]=(50)
set Nvv[(Gyv)]=(50)
call hLo((Gyv),(GYv),1)
call hLo((Gyv),(Gzv),1)
call hLo((Gyv),(GZv),1)
return true
endfunction
function HRo takes nothing returns boolean
set G_v=hGo('uDTw')
call hho(((G_v)),Apv,(ICv))
set Tj[(G_v)]=((2)*1.)
set Nav[(G_v)]=(('x')*1.)
set Ntv[(G_v)]=(($B4)*1.)
set I3v[(G_v)]=((0)*1.)
set Axv[(G_v)]=(3)
set NJv[(G_v)]=((150000.)*1.)
set Njv[(G_v)]=((150000.)*1.)
set Nhv[(G_v)]=((0)*1.)
set NIv[(G_v)]=(($578)*1.)
set NOv[(G_v)]=(($578)*1.)
set ANv[(G_v)]=(gSv)
set Adv[(G_v)]=(($4B0)*1.)
set ADv[((G_v))]=((1.*1./((1.75)*1.))*1.)
set Atv[(G_v)]=((.5)*1.)
set Drv[(G_v)]=(($3E8)*1.)
set AQv[(G_v)]=((23)*1.)
set Asv[(G_v)]=((23)*1.)
set Auv[(G_v)]=(3)
set AWv[(G_v)]=(3)
set Azv[(G_v)]=(4)
call hLo((G_v),(gQv),1)
call hLo((G_v),(gUv),1)
return true
endfunction
function HIo takes nothing returns boolean
set G0v=hGo('uAxe')
call hho(((G0v)),Apv,(INv))
set Tj[(G0v)]=((1.2)*1.)
set Nav[(G0v)]=((41.666666666667)*1.)
set Ntv[(G0v)]=((41.666666666667)*1.)
set Nlv[(G0v)]=(('}')*1.)
set I3v[(G0v)]=((2)*1.)
set Axv[(G0v)]=(2)
set NJv[(G0v)]=((400)*1.)
set Njv[(G0v)]=((400)*1.)
set Nhv[(G0v)]=((.4)*1.)
set NIv[(G0v)]=(($578)*1.)
set NOv[(G0v)]=(($578)*1.)
set Ndv[(G0v)]=((40)*1.)
set ANv[(G0v)]=(gHv)
set Adv[(G0v)]=(('x')*1.)
set ADv[((G0v))]=((1.*1./((1.6)*1.))*1.)
set Atv[(G0v)]=((.35)*1.)
set AQv[(G0v)]=((16)*1.)
set Asv[(G0v)]=((16)*1.)
set Auv[(G0v)]=(3)
set AWv[(G0v)]=(3)
set Azv[(G0v)]=(0)
set Aqv[(G0v)]=((22.222222222222)*1.)
set Nxv[(G0v)]=(20)
set Nvv[(G0v)]=(90)
return true
endfunction
function HAo takes nothing returns boolean
set G1v=hGo('USto')
call hLo((G1v),('AInv'),1)
call hho(((G1v)),Apv,(yd))
call hho(((G1v)),Apv,(INv))
set Tj[(G1v)]=((1.3)*1.)
set Nav[(G1v)]=((60)*1.)
set Ntv[(G1v)]=((60)*1.)
set Nlv[(G1v)]=((290)*1.)
set I3v[(G1v)]=((1.5)*1.)
set Axv[(G1v)]=(4)
set NJv[(G1v)]=(('d')*1.)
set Njv[(G1v)]=(('d')*1.)
set Nhv[(G1v)]=((0)*1.)
set NKv[(G1v)]=(('d')*1.)
set Nkv[(G1v)]=(('d')*1.)
set NHv[(G1v)]=((0)*1.)
set NIv[(G1v)]=(($708)*1.)
set NOv[(G1v)]=(($708)*1.)
set ANv[(G1v)]=(gHv)
set Adv[(G1v)]=(('x')*1.)
set ADv[((G1v))]=((1.*1./((1.7)*1.))*1.)
set Atv[(G1v)]=((.35)*1.)
set AQv[(G1v)]=(($C)*1.)
set Asv[(G1v)]=(($C)*1.)
set Auv[(G1v)]=(1)
set AWv[(G1v)]=($A)
set Azv[(G1v)]=(0)
set Aqv[(G1v)]=((32)*1.)
call hMo(G1v,G2v)
call hMo(G1v,G3v)
call hMo(G1v,G4v)
call hMo(G1v,G5v)
set bbv[(G1v)]=(($A)*1.)
set bFv[(G1v)]=((3.75)*1.)
set bgv[(G1v)]=((.7)*1.)
set bBv[(G1v)]=(($A)*1.)
set bGv[(G1v)]=((3.75)*1.)
set bcv[(G1v)]=((10.5)*1.)
set bhv[(G1v)]=((3.75)*1.)
return true
endfunction
function HNo takes nothing returns boolean
set G6v=hGo('uBDS')
call hho(((G6v)),Apv,(Ivv))
set Tj[(G6v)]=((.7)*1.)
call hHo(G6v,$96,$96,$FF,$FF)
set Nav[(G6v)]=((0)*1.)
set Ntv[(G6v)]=((-20.408163265306)*1.)
set Nlv[(G6v)]=((300)*1.)
set I3v[(G6v)]=((0)*1.)
set Axv[(G6v)]=(2)
set NJv[(G6v)]=((300)*1.)
set Njv[(G6v)]=((300)*1.)
set Nhv[(G6v)]=((.2)*1.)
set NIv[(G6v)]=(($578)*1.)
set NOv[(G6v)]=(($578)*1.)
set Ndv[(G6v)]=((25)*1.)
set ANv[(G6v)]=(gSv)
set Adv[(G6v)]=((720)*1.)
set ADv[((G6v))]=((1.*1./((1.8)*1.))*1.)
set Atv[(G6v)]=((.94)*1.)
set Drv[(G6v)]=((800)*1.)
set AQv[(G6v)]=(($C)*1.)
set Asv[(G6v)]=(($C)*1.)
set Auv[(G6v)]=(1)
set AWv[(G6v)]=(2)
set Azv[(G6v)]=(1)
set Aqv[(G6v)]=((97.959183673469)*1.)
set Nxv[(G6v)]=($E)
set Nvv[(G6v)]=(35)
return true
endfunction
function Hbo takes nothing returns boolean
set G7v=hGo('uKoB')
call hho(((G7v)),Apv,(INv))
set Tj[(G7v)]=((1.4)*1.)
call hHo(G7v,$FF,$FF,$FF,$FF)
set Nav[(G7v)]=((30.612244897959)*1.)
set Ntv[(G7v)]=((30.612244897959)*1.)
set Nlv[(G7v)]=((270)*1.)
set I3v[(G7v)]=((0)*1.)
set Axv[(G7v)]=(5)
set NJv[(G7v)]=((90)*1.)
set Njv[(G7v)]=((90)*1.)
set Nhv[(G7v)]=((.2)*1.)
set NKv[(G7v)]=((50)*1.)
set Nkv[(G7v)]=((50)*1.)
set NHv[(G7v)]=((.4)*1.)
set NIv[(G7v)]=(($578)*1.)
set NOv[(G7v)]=(($578)*1.)
set Ndv[(G7v)]=((25)*1.)
set ANv[(G7v)]=(gSv)
set Adv[(G7v)]=((720)*1.)
set ADv[((G7v))]=((1.*1./((1.8)*1.))*1.)
set Atv[(G7v)]=((.38)*1.)
set Drv[(G7v)]=((900)*1.)
set AQv[(G7v)]=((4)*1.)
set Asv[(G7v)]=((4)*1.)
set Auv[(G7v)]=(2)
set AWv[(G7v)]=(2)
set Azv[(G7v)]=(3)
set Aqv[(G7v)]=((15.816326530612)*1.)
set Nxv[(G7v)]=($F)
set Nvv[(G7v)]=($A)
return true
endfunction
function HBo takes nothing returns boolean
set G8v=hGo('uPeB')
call hho(((G8v)),Apv,(INv))
set Tj[(G8v)]=((1.725)*1.)
set Nav[(G8v)]=((60)*1.)
set Ntv[(G8v)]=((60)*1.)
set Nlv[(G8v)]=((340)*1.)
set I3v[(G8v)]=((0)*1.)
set Axv[(G8v)]=(2)
set NJv[(G8v)]=((55)*1.)
set Njv[(G8v)]=((55)*1.)
set Nhv[(G8v)]=((.2)*1.)
set NIv[(G8v)]=((350)*1.)
set NOv[(G8v)]=((350)*1.)
set Ndv[(G8v)]=(($A)*1.)
set ANv[(G8v)]=(gHv)
set Adv[(G8v)]=(('x')*1.)
set ADv[((G8v))]=((1.*1./((1.5)*1.))*1.)
set Atv[(G8v)]=((1)*1.)
set AQv[(G8v)]=((5)*1.)
set Asv[(G8v)]=((5)*1.)
set Auv[(G8v)]=(1)
set AWv[(G8v)]=(1)
set Azv[(G8v)]=(4)
set Aqv[(G8v)]=((16)*1.)
return true
endfunction
function Hco takes nothing returns boolean
set G9v=hGo('uRes')
call hho(((G9v)),Apv,(ICv))
set Tj[(G9v)]=((1.1)*1.)
call hHo(G9v,$96,$C8,$FF,$FF)
set Nav[(G9v)]=(('x')*1.)
set Ntv[(G9v)]=((60)*1.)
set I3v[(G9v)]=((0)*1.)
set Axv[(G9v)]=(3)
set NJv[(G9v)]=((150000.)*1.)
set Njv[(G9v)]=((150000.)*1.)
set Nhv[(G9v)]=((0)*1.)
set NKv[(G9v)]=(($C8)*1.)
set Nkv[(G9v)]=(($C8)*1.)
set NHv[(G9v)]=((.4)*1.)
set NIv[(G9v)]=((300)*1.)
set NOv[(G9v)]=((300)*1.)
set AQv[(G9v)]=((0)*1.)
set Asv[(G9v)]=((0)*1.)
set Auv[(G9v)]=(0)
set AWv[(G9v)]=(0)
call hLo((G9v),(gQv),1)
call hLo((G9v),(hvv),1)
return true
endfunction
function HCo takes nothing returns boolean
set hev=hGo('uLT2')
call hho(((hev)),Apv,(ICv))
set Tj[(hev)]=((1.6)*1.)
call hHo(hev,$C8,$C8,$C0,$FF)
set Nav[(hev)]=(('x')*1.)
set Ntv[(hev)]=(($FF)*1.)
set I3v[(hev)]=((0)*1.)
set Axv[(hev)]=(3)
set NJv[(hev)]=((150000.)*1.)
set Njv[(hev)]=((150000.)*1.)
set Nhv[(hev)]=((0)*1.)
set NIv[(hev)]=(($578)*1.)
set NOv[(hev)]=(($578)*1.)
set ANv[(hev)]=(gSv)
set Adv[(hev)]=(($4B0)*1.)
set ADv[((hev))]=((1.*1./((5)*1.))*1.)
set Atv[(hev)]=((.5)*1.)
set Drv[(hev)]=(($5DC)*1.)
set AQv[(hev)]=((1)*1.)
set Asv[(hev)]=((1)*1.)
set Auv[(hev)]=(1)
set AWv[(hev)]=(1)
set Azv[(hev)]=(3)
call hLo((hev),(gQv),1)
call hLo((hev),(Gmv),(2))
return true
endfunction
function Hdo takes nothing returns boolean
set hxv=hGo('uDee')
call hho(((hxv)),Apv,(INv))
set Tj[(hxv)]=((1.7)*1.)
set Nav[(hxv)]=((15.555555555556)*1.)
set Ntv[(hxv)]=((15.555555555556)*1.)
set Nlv[(hxv)]=(($96)*1.)
set I3v[(hxv)]=((0)*1.)
set Axv[(hxv)]=(1)
set NJv[(hxv)]=((60)*1.)
set Njv[(hxv)]=((60)*1.)
set Nhv[(hxv)]=((.1)*1.)
set NKv[(hxv)]=((25)*1.)
set Nkv[(hxv)]=((25)*1.)
set NHv[(hxv)]=((.3)*1.)
set NIv[(hxv)]=(($578)*1.)
set NOv[(hxv)]=(($578)*1.)
set Ndv[(hxv)]=(($A)*1.)
set ANv[(hxv)]=(gHv)
set Adv[(hxv)]=(('l')*1.)
set ADv[((hxv))]=((1.*1./((1.4)*1.))*1.)
set Atv[(hxv)]=((.5)*1.)
set AQv[(hxv)]=((5)*1.)
set Asv[(hxv)]=((5)*1.)
set Auv[(hxv)]=(1)
set AWv[(hxv)]=(2)
set Azv[(hxv)]=(0)
set Aqv[(hxv)]=((10.666666666667)*1.)
set Nxv[(hxv)]=(5)
set Nvv[(hxv)]=(20)
return true
endfunction
function HDo takes nothing returns boolean
set hov=hGo('uSnF')
call hho(((hov)),Apv,(Ivv))
set Tj[(hov)]=((.9)*1.)
set Nav[(hov)]=((60)*1.)
set Ntv[(hov)]=((60)*1.)
set Nlv[(hov)]=(($87)*1.)
set I3v[(hov)]=((0)*1.)
set Axv[(hov)]=(0)
set NJv[(hov)]=(('n')*1.)
set Njv[(hov)]=(('n')*1.)
set Nhv[(hov)]=((.3)*1.)
set NKv[(hov)]=((30)*1.)
set Nkv[(hov)]=((30)*1.)
set NHv[(hov)]=((.1)*1.)
set NIv[(hov)]=(($640)*1.)
set NOv[(hov)]=(($640)*1.)
set Ndv[(hov)]=((20)*1.)
set ANv[(hov)]=(gKv)
set Adv[(hov)]=((600)*1.)
set ADv[((hov))]=((1.*1./((1.5)*1.))*1.)
set Atv[(hov)]=((.5)*1.)
set Drv[(hov)]=(($5DC)*1.)
set AQv[(hov)]=((7)*1.)
set Asv[(hov)]=((7)*1.)
set Auv[(hov)]=(1)
set AWv[(hov)]=(4)
set Azv[(hov)]=(3)
set Aqv[(hov)]=((8)*1.)
set Nxv[(hov)]=(25)
set Nvv[(hov)]=(50)
call hLo((hov),(hrv),1)
return true
endfunction
function Hfo takes nothing returns boolean
set hiv=hGo('uTrG')
call hho(((hiv)),Apv,(INv))
set Tj[(hiv)]=((1)*1.)
call hHo(hiv,$AA,$FF,60,$FF)
set Nav[(hiv)]=((38.4)*1.)
set Ntv[(hiv)]=((38.4)*1.)
set Nlv[(hiv)]=((280)*1.)
set I3v[(hiv)]=((0)*1.)
set Axv[(hiv)]=(2)
set NJv[(hiv)]=((600)*1.)
set Njv[(hiv)]=((600)*1.)
set Nhv[(hiv)]=((.3)*1.)
set NIv[(hiv)]=(($578)*1.)
set NOv[(hiv)]=(($578)*1.)
set Ndv[(hiv)]=((20)*1.)
set ANv[(hiv)]=(gHv)
set Adv[(hiv)]=(('x')*1.)
set ADv[((hiv))]=((1.*1./((1.35)*1.))*1.)
set Atv[(hiv)]=((.467)*1.)
set AQv[(hiv)]=((22)*1.)
set Asv[(hiv)]=((22)*1.)
set Auv[(hiv)]=(1)
set AWv[(hiv)]=(4)
set Azv[(hiv)]=(4)
set Aqv[(hiv)]=((20.48)*1.)
set Nxv[(hiv)]=(20)
set Nvv[(hiv)]=(70)
return true
endfunction
function HFo takes nothing returns boolean
set hav=hGo('uWol')
call hho(((hav)),Apv,(INv))
set Tj[(hav)]=((1)*1.)
set Nav[(hav)]=((60)*1.)
set Ntv[(hav)]=((60)*1.)
set Nlv[(hav)]=(('}')*1.)
set I3v[(hav)]=((2)*1.)
set Axv[(hav)]=(2)
set NJv[(hav)]=(('x')*1.)
set Njv[(hav)]=(('x')*1.)
set Nhv[(hav)]=((.4)*1.)
set NKv[(hav)]=(('d')*1.)
set Nkv[(hav)]=(('d')*1.)
set NHv[(hav)]=((1)*1.)
set NIv[(hav)]=(($578)*1.)
set NOv[(hav)]=(($578)*1.)
set Ndv[(hav)]=((22.5)*1.)
set ANv[(hav)]=(gHv)
set Adv[(hav)]=(($84)*1.)
set ADv[((hav))]=((1.*1./((1.35)*1.))*1.)
set Atv[(hav)]=((.33)*1.)
set AQv[(hav)]=((8)*1.)
set Asv[(hav)]=((8)*1.)
set Auv[(hav)]=(2)
set AWv[(hav)]=(3)
set Azv[(hav)]=(0)
set Aqv[(hav)]=((32)*1.)
set Nxv[(hav)]=(8)
set Nvv[(hav)]=(40)
call hLo((hav),(hnv),1)
return true
endfunction
function Hgo takes nothing returns boolean
set hVv=hGo('uDru')
call hho(((hVv)),Apv,(INv))
set Tj[(hVv)]=((1)*1.)
set Nav[(hVv)]=((26.666666666667)*1.)
set Ntv[(hVv)]=((26.666666666667)*1.)
set Nlv[(hVv)]=(('n')*1.)
set I3v[(hVv)]=((1)*1.)
set Axv[(hVv)]=(3)
set NJv[(hVv)]=((300)*1.)
set Njv[(hVv)]=((300)*1.)
set Nhv[(hVv)]=((2)*1.)
set NIv[(hVv)]=(($578)*1.)
set NOv[(hVv)]=(($578)*1.)
set Ndv[(hVv)]=((50)*1.)
set ANv[(hVv)]=(gKv)
set Adv[(hVv)]=((600)*1.)
set ADv[((hVv))]=((1.*1./((1.44)*1.))*1.)
set Atv[(hVv)]=((.85)*1.)
set Drv[(hVv)]=(($4B0)*1.)
set AQv[(hVv)]=((4)*1.)
set Asv[(hVv)]=((4)*1.)
set Auv[(hVv)]=(1)
set AWv[(hVv)]=(3)
set Azv[(hVv)]=(1)
set Aqv[(hVv)]=((21.333333333333)*1.)
set Nxv[(hVv)]=(35)
set Nvv[(hVv)]=(80)
call hLo((hVv),(hEv),1)
return true
endfunction
function HGo takes nothing returns boolean
set hXv=hGo('ULea')
call hLo((hXv),('AInv'),1)
call hho(((hXv)),Apv,(yd))
call hho(((hXv)),Apv,(INv))
set Tj[(hXv)]=((1.25)*1.)
set Nav[(hXv)]=((60)*1.)
set Ntv[(hXv)]=((60)*1.)
set Nlv[(hXv)]=(($96)*1.)
set I3v[(hXv)]=((5)*1.)
set Axv[(hXv)]=(4)
set NJv[(hXv)]=(($FA0)*1.)
set Njv[(hXv)]=(($FA0)*1.)
set Nhv[(hXv)]=((1)*1.)
set NKv[(hXv)]=(($C8)*1.)
set Nkv[(hXv)]=(($C8)*1.)
set NHv[(hXv)]=((.5)*1.)
set NIv[(hXv)]=(($578)*1.)
set NOv[(hXv)]=(($578)*1.)
set Ndv[(hXv)]=((90)*1.)
set ANv[(hXv)]=(gHv)
set Adv[(hXv)]=(('x')*1.)
set ADv[((hXv))]=((1.*1./((1.5)*1.))*1.)
set Atv[(hXv)]=((.5)*1.)
set AQv[(hXv)]=((20)*1.)
set Asv[(hXv)]=((20)*1.)
set Auv[(hXv)]=(2)
set AWv[(hXv)]=(8)
set Azv[(hXv)]=(5)
set Aqv[(hXv)]=((32)*1.)
set Nxv[(hXv)]=('d')
set Nvv[(hXv)]=($C8)
call hLo((hXv),(hOv),1)
return true
endfunction
function Hho takes nothing returns boolean
set hRv=hGo('URoc')
call hLo((hRv),('AInv'),1)
call hho(((hRv)),Apv,(yd))
call hho(((hRv)),Apv,(INv))
set Tj[(hRv)]=((1.4)*1.)
set Nav[(hRv)]=((60)*1.)
set Ntv[(hRv)]=((60)*1.)
set Nlv[(hRv)]=((280)*1.)
set I3v[(hRv)]=((3)*1.)
set Axv[(hRv)]=(4)
set NJv[(hRv)]=(('d')*1.)
set Njv[(hRv)]=(('d')*1.)
set Nhv[(hRv)]=((0)*1.)
set NKv[(hRv)]=(('d')*1.)
set Nkv[(hRv)]=(('d')*1.)
set NHv[(hRv)]=((0)*1.)
set NIv[(hRv)]=(($708)*1.)
set NOv[(hRv)]=(($708)*1.)
set ANv[(hRv)]=(gHv)
set Adv[(hRv)]=(('x')*1.)
set ADv[((hRv))]=((1.*1./((1.55)*1.))*1.)
set Atv[(hRv)]=((.35)*1.)
set AQv[(hRv)]=(($C)*1.)
set Asv[(hRv)]=(($C)*1.)
set Auv[(hRv)]=(2)
set AWv[(hRv)]=($C)
set Azv[(hRv)]=(0)
set Aqv[(hRv)]=((32)*1.)
call hMo(hRv,hIv)
call hMo(hRv,hAv)
call hMo(hRv,hNv)
call hMo(hRv,hbv)
set bbv[(hRv)]=((7.5)*1.)
set bFv[(hRv)]=((3.5)*1.)
set bgv[(hRv)]=((.85)*1.)
set bBv[(hRv)]=((6)*1.)
set bGv[(hRv)]=((3.25)*1.)
set bcv[(hRv)]=((16)*1.)
set bhv[(hRv)]=((5)*1.)
return true
endfunction
function HHo takes nothing returns boolean
set hBv=hGo('uSat')
call hho(((hBv)),Apv,(INv))
set Tj[(hBv)]=((1.4)*1.)
set Nav[(hBv)]=((45.368620037807)*1.)
set Ntv[(hBv)]=((45.368620037807)*1.)
set Nlv[(hBv)]=(($E6)*1.)
set I3v[(hBv)]=((1)*1.)
set Axv[(hBv)]=(2)
set NJv[(hBv)]=((80)*1.)
set Njv[(hBv)]=((80)*1.)
set Nhv[(hBv)]=((.4)*1.)
set NKv[(hBv)]=(('x')*1.)
set Nkv[(hBv)]=(('x')*1.)
set NHv[(hBv)]=((.7)*1.)
set NIv[(hBv)]=(($578)*1.)
set NOv[(hBv)]=(($578)*1.)
set Ndv[(hBv)]=((35)*1.)
set ANv[(hBv)]=(gHv)
set Adv[(hBv)]=(('x')*1.)
set ADv[((hBv))]=((1.*1./((1.35)*1.))*1.)
set Atv[(hBv)]=((.3)*1.)
set AQv[(hBv)]=(($E)*1.)
set Asv[(hBv)]=(($E)*1.)
set Auv[(hBv)]=(1)
set AWv[(hBv)]=(4)
set Azv[(hBv)]=(0)
set Aqv[(hBv)]=((24.196597353497)*1.)
set Nxv[(hBv)]=($F)
set Nvv[(hBv)]=(35)
return true
endfunction
function Hjo takes nothing returns boolean
set hcv=hGo('uSpe')
call hho(((hcv)),Apv,(INv))
set Tj[(hcv)]=((1.35)*1.)
set Nav[(hcv)]=((60)*1.)
set Ntv[(hcv)]=(('q')*1.)
set Nlv[(hcv)]=(('}')*1.)
set I3v[(hcv)]=((0)*1.)
set Axv[(hcv)]=(1)
set NJv[(hcv)]=(($E1)*1.)
set Njv[(hcv)]=(($E1)*1.)
set Nhv[(hcv)]=((.15)*1.)
set NKv[(hcv)]=((75)*1.)
set Nkv[(hcv)]=((75)*1.)
set NHv[(hcv)]=((.2)*1.)
set NIv[(hcv)]=(($578)*1.)
set NOv[(hcv)]=(($578)*1.)
set Ndv[(hcv)]=((35)*1.)
set ANv[(hcv)]=(gKv)
set Adv[(hcv)]=(($A2)*1.)
set ADv[((hcv))]=((1.*1./((2.31)*1.))*1.)
set Atv[(hcv)]=((.31)*1.)
set Drv[(hcv)]=(($4B0)*1.)
set AQv[(hcv)]=(($E)*1.)
set Asv[(hcv)]=(($E)*1.)
set Auv[(hcv)]=(1)
set AWv[(hcv)]=(5)
set Azv[(hcv)]=(1)
set Aqv[(hcv)]=((32)*1.)
set Nxv[(hcv)]=(20)
set Nvv[(hcv)]=(25)
call hLo((hcv),(hCv),1)
return true
endfunction
function HJo takes nothing returns boolean
set hdv=hGo('uFlP')
call hho(((hdv)),Apv,(Ivv))
set Tj[(hdv)]=((1.3)*1.)
call hHo(hdv,$FF,0,$FF,$FF)
set Nav[(hdv)]=((60)*1.)
set Ntv[(hdv)]=((60)*1.)
set Nlv[(hdv)]=((340)*1.)
set I3v[(hdv)]=((0)*1.)
set Axv[(hdv)]=(0)
set NJv[(hdv)]=((40)*1.)
set Njv[(hdv)]=((40)*1.)
set Nhv[(hdv)]=((.2)*1.)
set NIv[(hdv)]=((350)*1.)
set NOv[(hdv)]=((350)*1.)
set Ndv[(hdv)]=(($A)*1.)
set ANv[(hdv)]=(gKv)
set Adv[(hdv)]=(('x')*1.)
set ADv[((hdv))]=((1.*1./((1.5)*1.))*1.)
set Atv[(hdv)]=((1)*1.)
set Drv[(hdv)]=((600)*1.)
set AQv[(hdv)]=((5)*1.)
set Asv[(hdv)]=((5)*1.)
set Auv[(hdv)]=(1)
set AWv[(hdv)]=(1)
set Azv[(hdv)]=(2)
set Aqv[(hdv)]=((20.8)*1.)
return true
endfunction
function Hko takes nothing returns boolean
set hDv=hGo('uPeL')
call hho(((hDv)),Apv,(INv))
set Tj[(hDv)]=((1.5)*1.)
set Nav[(hDv)]=((60)*1.)
set Ntv[(hDv)]=((60)*1.)
set I3v[(hDv)]=((0)*1.)
set Axv[(hDv)]=(5)
set NJv[(hDv)]=(('d')*1.)
set Njv[(hDv)]=(('d')*1.)
set Nhv[(hDv)]=((0)*1.)
set NIv[(hDv)]=((350)*1.)
set NOv[(hDv)]=((350)*1.)
set AQv[(hDv)]=((0)*1.)
set Asv[(hDv)]=((0)*1.)
set Auv[(hDv)]=(0)
set AWv[(hDv)]=(0)
set Aqv[(hDv)]=((8)*1.)
return true
endfunction
function HKo takes nothing returns boolean
set hfv=hGo('uPeo')
call hho(((hfv)),Apv,(INv))
set Tj[(hfv)]=((.85)*1.)
set Nav[(hfv)]=((45)*1.)
set Ntv[(hfv)]=((60)*1.)
set Nlv[(hfv)]=(($AA)*1.)
set I3v[(hfv)]=((0)*1.)
set Axv[(hfv)]=(1)
set NJv[(hfv)]=(('x')*1.)
set Njv[(hfv)]=(('x')*1.)
set Nhv[(hfv)]=((.1)*1.)
set NIv[(hfv)]=((800)*1.)
set NOv[(hfv)]=((800)*1.)
set Ndv[(hfv)]=((35)*1.)
set ANv[(hfv)]=(gHv)
set Adv[(hfv)]=(('l')*1.)
set ADv[((hfv))]=((1.*1./((3)*1.))*1.)
set Atv[(hfv)]=((.5)*1.)
set AQv[(hfv)]=((5)*1.)
set Asv[(hfv)]=((5)*1.)
set Auv[(hfv)]=(1)
set AWv[(hfv)]=(2)
set Azv[(hfv)]=(0)
set Aqv[(hfv)]=((16)*1.)
set Nxv[(hfv)]=($F)
set Nvv[(hfv)]=(20)
return true
endfunction
function Hlo takes nothing returns boolean
set hFv=hGo('uSwo')
call hho(((hFv)),Apv,(INv))
set Tj[(hFv)]=((1.25)*1.)
call hHo(hFv,$FF,$FF,$FF,$FF)
set Nav[(hFv)]=((41.666666666667)*1.)
set Ntv[(hFv)]=((41.666666666667)*1.)
set Nlv[(hFv)]=((270)*1.)
set I3v[(hFv)]=((3)*1.)
set Axv[(hFv)]=(2)
set NJv[(hFv)]=((400)*1.)
set Njv[(hFv)]=((400)*1.)
set Nhv[(hFv)]=((.2)*1.)
set NIv[(hFv)]=(($578)*1.)
set NOv[(hFv)]=(($578)*1.)
set Ndv[(hFv)]=((40)*1.)
set ANv[(hFv)]=(gHv)
set Adv[(hFv)]=(('x')*1.)
set ADv[((hFv))]=((1.*1./((1)*1.))*1.)
set Atv[(hFv)]=((.5)*1.)
set AQv[(hFv)]=((2)*1.)
set Asv[(hFv)]=((2)*1.)
set Auv[(hFv)]=(1)
set AWv[(hFv)]=(3)
set Azv[(hFv)]=(0)
set Aqv[(hFv)]=((21.527777777778)*1.)
set Nxv[(hFv)]=(20)
set Nvv[(hFv)]=($A)
return true
endfunction
function HLo takes integer oqx,integer oQx,string oSx returns boolean
return lsx(Fw[(oqx)],(gw[((oqx))]),oQx,oSx)
endfunction
function Hmo takes integer oqx,integer oQx,integer oSx returns boolean
return ltx(Fw[(oqx)],(gw[((oqx))]),oQx,oSx)
endfunction
function HMo takes integer oqx,string lUx,string AIx,integer rwx returns nothing
call HLo((oqx),AVv,AIx)
call Hmo((oqx),AEv,rwx)
call HLo((oqx),Anv,lUx)
endfunction
function Hpo takes nothing returns boolean
set hgv=hGo('uVic')
set Tj[(hgv)]=((1.2)*1.)
set Nav[(hgv)]=((41.666666666667)*1.)
set Ntv[(hgv)]=((41.666666666667)*1.)
call HMo(hgv,"UnitType_page\\UnitType_struct\\Hammer.mdx","hand right",ri)
set I3v[(hgv)]=((0)*1.)
set Axv[(hgv)]=(2)
set NJv[(hgv)]=(($C8)*1.)
set Njv[(hgv)]=(($C8)*1.)
set Nhv[(hgv)]=((0)*1.)
set NIv[(hgv)]=((500)*1.)
set NOv[(hgv)]=((500)*1.)
set Ndv[(hgv)]=((300)*1.)
set AQv[(hgv)]=((0)*1.)
set Asv[(hgv)]=((0)*1.)
set Auv[(hgv)]=(0)
set AWv[(hgv)]=(0)
return true
endfunction
function HPo takes nothing returns boolean
call hao(function hjo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_KoboldBrown_wc3unit.j")
call hao(function hJo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\obj_Moonkin_wc3unit.j")
call hao(function hko,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Bonus\\obj_PenguinChamp_wc3unit.j")
call hao(function hmo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\obj_GnollMage_wc3unit.j")
call hao(function hPo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Heroes\\obj_Kera_wc3unit.j")
call hao(function hqo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_BaseTower_wc3unit.j")
call hao(function hQo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\obj_TrollPriest_wc3unit.j")
call hao(function hso,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_DarkTower2_wc3unit.j")
call hao(function hSo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Heroes\\obj_Tajran_wc3unit.j")
call hao(function hto,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\obj_Troll_wc3unit.j")
call hao(function hwo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_FrostTower_wc3unit.j")
call hao(function hWo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Heroes\\Lizzy\\obj_Lizzy_wc3unit.j")
call hao(function hyo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_FurbolgMother_wc3unit.j")
call hao(function hYo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_TreantPurple_wc3unit.j")
call hao(function hzo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_FrostTower2_wc3unit.j")
call hao(function hZo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_WolfMother_wc3unit.j")
call hao(function h_o,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Heroes\\obj_Drakul_wc3unit.j")
call hao(function h0o,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\obj_Raider_wc3unit.j")
call hao(function h1o,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\DefenderSpawns\\obj_Vicar_wc3unit.j")
call hao(function h2o,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\Assassin\\obj_Assassin_wc3unit.j")
call hao(function h3o,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_Tuskar_wc3unit.j")
call hao(function h6o,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\obj_Catapult_wc3unit.j")
call hao(function h7o,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\obj_TrueLeader_wc3unit.j")
call hao(function h8o,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\obj_Demolisher_wc3unit.j")
call hao(function h9o,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Heroes\\obj_Smokealot_wc3unit.j")
call hao(function Hvo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_KoboldRed_wc3unit.j")
call hao(function Heo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\Tower\\obj_Tower_wc3unit.j")
call hao(function Hxo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_Pandarene_wc3unit.j")
call hao(function Hoo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Heroes\\obj_Jota_wc3unit.j")
call hao(function Hro,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\Tarog\\obj_Tarog_wc3unit.j")
call hao(function Hio,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_PropPenguin_wc3unit.j")
call hao(function Hao,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_LightningTower_wc3unit.j")
call hao(function Hno,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\obj_Nagarosh_wc3unit.j")
call hao(function HVo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\Balduir\\obj_Balduir_wc3unit.j")
call hao(function HEo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\Fountain\\obj_Fountain_wc3unit.j")
call hao(function HXo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Heroes\\obj_Aruruw_wc3unit.j")
call hao(function HOo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\obj_FurbolgOracle_wc3unit.j")
call hao(function HRo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_DarkTower_wc3unit.j")
call hao(function HIo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\obj_AxeFighter_wc3unit.j")
call hao(function HAo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Heroes\\obj_Stormy_wc3unit.j")
call hao(function HNo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_BlueDragonSpawn_wc3unit.j")
call hao(function Hbo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_KoboldBlue_wc3unit.j")
call hao(function HBo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Bonus\\obj_Penguin_wc3unit.j")
call hao(function Hco,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_Reservoir_wc3unit.j")
call hao(function HCo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_LightningTower2_wc3unit.j")
call hao(function Hdo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Deer\\obj_Deer_wc3unit.j")
call hao(function HDo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\obj_SnowFalcon_wc3unit.j")
call hao(function Hfo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_TreantGreen_wc3unit.j")
call hao(function HFo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\obj_Wolf_wc3unit.j")
call hao(function Hgo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\obj_Drummer_wc3unit.j")
call hao(function HGo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\obj_Leader_wc3unit.j")
call hao(function Hho,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Heroes\\obj_Rocketeye_wc3unit.j")
call hao(function HHo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\obj_Satyr_wc3unit.j")
call hao(function Hjo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\SpearScout\\obj_SpearScout_wc3unit.j")
call hao(function HJo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Bonus\\FlyingPenguin\\obj_FlyingPenguin_wc3unit.j")
call hao(function Hko,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_PenguinLying_wc3unit.j")
call hao(function HKo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\obj_Peon_wc3unit.j")
call hao(function Hlo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\DefenderSpawns\\obj_Swordsman_wc3unit.j")
call hao(function Hpo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\Victor\\obj_Victor_wc3unit.j")
return true
endfunction
function Hqo takes nothing returns boolean
set gdv=Vnx(gAv)
return true
endfunction
function HQo takes nothing returns boolean
set LD=Vnx(HD)
return true
endfunction
function Hso takes nothing returns boolean
set hGv=Vnx(hhv)
return true
endfunction
function HSo takes nothing returns boolean
set hHv=Vnx(hjv)
return true
endfunction
function Hto takes nothing returns boolean
set hJv=Vnx(hkv)
return true
endfunction
function HTo takes nothing returns boolean
set hKv=Vnx(hlv)
return true
endfunction
function Huo takes nothing returns boolean
set hLv=Vnx(hmv)
return true
endfunction
function HUo takes nothing returns boolean
set hMv=Vnx(hpv)
return true
endfunction
function Hwo takes nothing returns boolean
set hPv=Vnx(hqv)
return true
endfunction
function HWo takes nothing returns boolean
set hQv=Vnx(hsv)
return true
endfunction
function Hyo takes nothing returns boolean
set hSv=Vnx(htv)
return true
endfunction
function HYo takes nothing returns boolean
set hTv=Vnx(huv)
return true
endfunction
function Hzo takes nothing returns boolean
set hUv=Vnx(hwv)
return true
endfunction
function HZo takes nothing returns boolean
set hWv=Vnx(hyv)
return true
endfunction
function H_o takes nothing returns boolean
set hYv=Vnx(hzv)
return true
endfunction
function H0o takes nothing returns boolean
set F0=Vnx(B0)
return true
endfunction
function H1o takes nothing returns boolean
set b1=Vnx(X1)
return true
endfunction
function H2o takes nothing returns boolean
set m1=Vnx(j1)
return true
endfunction
function H3o takes nothing returns boolean
set v2=Vnx(U1)
return true
endfunction
function H4o takes nothing returns boolean
set hZv=Vnx(h_v)
return true
endfunction
function H5o takes nothing returns boolean
set h0v=Vnx(h1v)
return true
endfunction
function H6o takes nothing returns boolean
set h2v=Vnx(h3v)
return true
endfunction
function H7o takes nothing returns boolean
set h4v=Vnx(h5v)
return true
endfunction
function H8o takes nothing returns boolean
return true
endfunction
function H9o takes nothing returns boolean
set h6v=Vnx(uD)
return true
endfunction
function jvo takes code c,string rqx returns nothing
set xa=xa+1
set oa[xa]=CreateTrigger()
set ra[xa]=(GetHandleId(Condition((c))))
set ia[xa]=rqx
call TriggerAddCondition(oa[xa],Condition(c))
endfunction
function jeo takes integer oqx returns integer
set Hrv[oqx]=true
set Hiv[oqx]=false
call rax(hGv)
return oqx
endfunction
function jxo takes nothing returns integer
local integer oqx
if(Hvv==8190)then
call oYx("PlayerController_Allocation_allocCustom","call DebugEx(PlayerController.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",hhv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Hev[(w)]==w)then
set Hxv=Hxv+1
set oqx=Hxv
else
set oqx=Hev[(w)]
set Hev[(w)]=Hev[Hev[(w)]]
endif
set Hev[oqx]=Z
set Hov[oqx]=1
call jeo(oqx)
return oqx
endfunction
function joo takes mapcontrol oMx returns integer
local integer oqx=jxo()
set Hav[oqx]=oMx
call SaveInteger(o[((V[(E[((X))])]))],(((Hnv+GetHandleId(oMx)))),(((HVv))),(((oqx))))
return oqx
endfunction
function jro takes integer oqx,mapcontrol oMx returns nothing
call SaveInteger(o[((V[(E[((X))])]))],(((Hnv+GetHandleId(oMx)))),(((HVv))),(((oqx))))
endfunction
function jio takes nothing returns nothing
set h9v=joo(MAP_CONTROL_COMPUTER)
set HEv=joo(MAP_CONTROL_USER)
call jro(h9v,MAP_CONTROL_CREEP)
call jro(h9v,MAP_CONTROL_NONE)
endfunction
function jao takes integer oqx returns integer
set HNv[oqx]=true
set Hbv[oqx]=false
call rax(hHv)
return oqx
endfunction
function jno takes nothing returns integer
local integer oqx
if(HOv==8190)then
call oYx("PlayerSlotState_Allocation_allocCustom","call DebugEx(PlayerSlotState.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",hjv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(HRv[(w)]==w)then
set HIv=HIv+1
set oqx=HIv
else
set oqx=HRv[(w)]
set HRv[(w)]=HRv[HRv[(w)]]
endif
set HRv[oqx]=Z
set HAv[oqx]=1
call jao(oqx)
return oqx
endfunction
function jVo takes playerslotstate oMx returns integer
local integer oqx=jno()
set HBv[oqx]=oMx
call SaveInteger(o[((V[(E[((X))])]))],(((Hcv+GetHandleId(oMx)))),(((HCv))),(((oqx))))
return oqx
endfunction
function jEo takes nothing returns nothing
set HXv=jVo(PLAYER_SLOT_STATE_EMPTY)
set Hdv=jVo(PLAYER_SLOT_STATE_LEFT)
set HDv=jVo(PLAYER_SLOT_STATE_PLAYING)
endfunction
function jXo takes integer oqx returns integer
set HHv[oqx]=true
set Hjv[oqx]=false
call rax(hJv)
return oqx
endfunction
function jOo takes nothing returns integer
local integer oqx
if(HFv==8190)then
call oYx("Team_Allocation_allocCustom","call DebugEx(Team.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",hkv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Hgv[(w)]==w)then
set HGv=HGv+1
set oqx=HGv
else
set oqx=Hgv[(w)]
set Hgv[(w)]=Hgv[Hgv[(w)]]
endif
set Hgv[oqx]=Z
set Hhv[oqx]=1
call jXo(oqx)
return oqx
endfunction
function jRo takes nothing returns nothing
set Hfv=jOo()
set BTv=jOo()
set HJv=jOo()
endfunction
function jIo takes nothing returns nothing
endfunction
function jAo takes integer oqx returns integer
set Hmv[oqx]=true
set HMv[oqx]=false
set cb[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set O0[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(h6v)
return oqx
endfunction
function jNo takes nothing returns integer
local integer oqx
if(Hkv==8190)then
call oYx("User_Allocation_allocCustom","call DebugEx(User.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",uD+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(HKv[(w)]==w)then
set Hlv=Hlv+1
set oqx=Hlv
else
set oqx=HKv[(w)]
set HKv[(w)]=HKv[HKv[(w)]]
endif
set HKv[oqx]=Z
set HLv[oqx]=1
call jAo(oqx)
return oqx
endfunction
function jbo takes integer oqx,playercolor oSx returns nothing
set ox[oqx]=oSx
call SetPlayerColor(vx[oqx],oSx)
endfunction
function jBo takes integer oqx,string oSx returns nothing
set ib[oqx]=oSx
call SetPlayerName(vx[oqx],oSx)
endfunction
function jco takes integer oqx returns boolean
set Jh=Jh+1
set kh[Jh]=oqx
set Hpv[oqx]=Jh+1
return(Jh==0)
endfunction
function jCo takes integer oqx,integer oSx returns nothing
set HPv[oqx]=oSx
if(oSx==HEv)then
set Hqv=Hqv+1
set HQv[Hqv]=oqx
endif
endfunction
function jdo takes mapcontrol oMx returns integer
if((LoadInteger(o[((V[(E[((X))])]))],(((Hnv+GetHandleId(oMx)))),(((HVv)))))==0)then
call oYx("PlayerController_GetFromSelf","call DebugEx(\"PlayerController: GetFromSelf: \"+I2S(GetHandleId(self)))","PlayerController: GetFromSelf: "+I2S(GetHandleId(oMx)))
endif
return(LoadInteger(o[((V[(E[((X))])]))],(((Hnv+GetHandleId(oMx)))),(((HVv)))))
endfunction
function jDo takes integer oqx returns nothing
call jCo(oqx,jdo(GetPlayerController(vx[(oqx)])))
endfunction
function jfo takes integer oqx returns nothing
set Cb[(oqx)]=(Hsv+oqx)
endfunction
function jFo takes integer oqx,integer abx,integer oSx returns nothing
local integer okx
local integer jgo
if(abx==HDv)then
set okx=hFx((oqx),Htv)
set jgo=jl[Hl]
set jl[okx]=jgo
set Hl=Hl-1
call hJx(jgo,Htv,okx)
elseif(oSx==HDv)then
set Hl=Hl+1
set jl[Hl]=oqx
call hJx((oqx),Htv,Hl)
endif
endfunction
function jGo takes integer oqx,integer oSx returns nothing
local integer abx=HSv[oqx]
set HSv[oqx]=oSx
if(abx!=oSx)then
call jFo(oqx,abx,oSx)
endif
endfunction
function jho takes integer oqx returns nothing
set HSv[oqx]=HXv
call jGo(oqx,(LoadInteger(o[((V[(E[((X))])]))],(((Hcv+GetHandleId((GetPlayerSlotState(vx[(oqx)])))))),(((HCv))))))
endfunction
function jHo takes string jjo,integer NWx,string jJo returns integer
local integer oqx=jNo()
local player oMx=Player(NWx)
set vx[oqx]=oMx
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oMx))))),((((R)))),((((oqx)))))
call jbo(oqx,GetPlayerColor(oMx))
set rb[(oqx)]=(jJo)
call jBo(oqx,GetPlayerName(oMx))
set oMx=null
call jco(oqx)
call jDo(oqx)
set kv[((oqx))]=(w)
call jfo(oqx)
call jho(oqx)
set Btv[(oqx)]=w
if((GetPlayerController(vx[oqx])!=MAP_CONTROL_USER)or(GetPlayerSlotState(vx[oqx])!=PLAYER_SLOT_STATE_PLAYING))then
call jBo(oqx,jjo)
endif
return oqx
endfunction
function jko takes integer ocx,integer jgo,alliancetype rRx,boolean isx,boolean jKo returns nothing
call SetPlayerAlliance(vx[ocx],vx[jgo],rRx,isx)
if jKo then
call SetPlayerAlliance(vx[jgo],vx[ocx],rRx,isx)
endif
endfunction
function jlo takes integer oqx,integer ocx returns nothing
local integer olx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((HTv+oqx))),(((Huv))))))
local integer jgo
loop
exitwhen(olx<q)
set jgo=(LoadInteger(o[((V[(E[((X))])]))],(((HTv+oqx))),(((Huv)+(olx)))))
call jko(ocx,jgo,ALLIANCE_PASSIVE,true,true)
call jko(ocx,jgo,ALLIANCE_SHARED_SPELLS,true,true)
call jko(ocx,jgo,ALLIANCE_SHARED_VISION,true,true)
set olx=olx-1
endloop
call rSx(X,HTv+oqx,Huv,ocx)
endfunction
function jLo takes integer oqx,integer oSx returns nothing
set Btv[oqx]=oSx
call jlo(oSx,oqx)
endfunction
function jmo takes integer ocx,integer jMo returns nothing
local integer olx
if(ocx==Ge)then
set olx=Jh
loop
call jmo(kh[olx],jMo)
set olx=olx-1
exitwhen(olx<0)
endloop
else
call FogModifierStart(CreateFogModifierRect(vx[ocx],FOG_OF_WAR_VISIBLE,bm[jMo],true,true))
endif
endfunction
function jpo takes integer oqx,integer ocx,string r1x,boolean jPo returns nothing
local integer olx
if(ocx==Ge)then
set olx=Jh
loop
call jpo(oqx,kh[olx],r1x,jPo)
set olx=olx-1
exitwhen(olx<0)
endloop
endif
call TriggerRegisterPlayerChatEvent(fA[(oqx)],vx[ocx],r1x,jPo)
endfunction
function jqo takes integer oqx,string oMx,integer rRx,integer rIx returns integer
return(ZA+(rmx(lv[(E[((X))])],(((oMx))),(((I2S((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))))))))))
endfunction
function jQo takes integer oqx,string oMx,integer rRx,integer rIx,integer okx returns integer
return(rmx(lv[(E[((X))])],(((oMx))),(((I2S((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))))))+I2S(ZA+((okx))+2))))
endfunction
function jso takes integer oqx,string r1x returns nothing
local integer rdx=rEx(0)
local string jSo
local integer olx
local integer rIx
local integer rlx
set eN[(rdx)]=(oqx)
set jSo=r1x
loop
exitwhen(jSo==null)
set mA[(rdx)]=(r1x)
set MA[(rdx)]=(jSo)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=jqo(vN,jSo,LA,rIx)
loop
exitwhen(rlx<0)
call rCx(jQo(vN,jSo,LA,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
set jSo=(r2x((jSo),0,((StringLength((jSo)))-2)))
endloop
call rHx(((rdx)))
endfunction
function jto takes nothing returns boolean
local string r1x=(GetEventPlayerChatString())
local integer oqx=(omx(GetTriggerPlayer()))
call jso(oqx,r1x)
return true
endfunction
function jTo takes integer oqx,integer ocx,playerevent juo returns nothing
local integer olx
if(ocx==Ge)then
set olx=Jh
loop
call jTo(oqx,kh[olx],juo)
set olx=olx-1
exitwhen(olx<0)
endloop
endif
call TriggerRegisterPlayerEvent(fA[(oqx)],vx[ocx],juo)
endfunction
function jUo takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((O0[oqx]))])]))],((((Cb[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function jwo takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((O0[oqx]))])]))],((((Cb[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function jWo takes integer oqx returns nothing
local integer rdx=rEx(0)
local integer jyo=rEx((Cb[(oqx)]))
local integer olx
local integer rIx
local integer rlx
set eN[(rdx)]=(oqx)
set eN[(jyo)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((h7v))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((h7v))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set rlx=jUo(oqx,h7v,rIx)
loop
exitwhen(rlx<q)
call rCx(jwo(oqx,h7v,rIx,rlx),jyo)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call rHx(((jyo)))
endfunction
function jYo takes nothing returns boolean
local integer oqx=(omx(GetTriggerPlayer()))
call iLx(Ge,iqx((ib[(oqx)]),(rb[(oqx)]))+"'s footprints were blown away",10.)
call jWo(oqx)
return true
endfunction
function jzo takes nothing returns nothing
set h7v=(E0x())
call jTo(Xhx(function jYo),Ge,EVENT_PLAYER_LEAVE)
endfunction
function jZo takes integer nGo,integer o2x returns nothing
local integer rdx=rEx(0)
local integer olx
local integer rIx
local integer rlx
set eN[(rdx)]=(o2x)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((HYv))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((HYv))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function j_o takes integer o2x returns nothing
local integer nGo=H_v
if(o2x==nGo)then
return
endif
if(nGo!=w)then
call pGx(nGo,Hzv)
endif
set H_v=o2x
call pYx(o2x,Hzv)
set H0v=o2x
call ajx("new host is "+Opx(o2x))
call jZo(nGo,o2x)
endfunction
function j0o takes nothing returns nothing
call StoreInteger(HZv,"","",fFx())
call TriggerSyncStart()
call SyncStoredInteger(HZv,"","")
call TriggerSyncReady()
call j_o(GetStoredInteger(HZv,"",""))
endfunction
function j1o takes nothing returns boolean
local integer rdx=(bv)
call aHx(function j0o)
return true
endfunction
function j2o takes nothing returns nothing
set HYv=(E0x())
set Hzv=XBx("FolderUser_StructHostAppointment_Init: set FolderUser_StructHostAppointment.LEAVE_EVENT = Event.Create(User.LEAVE_EVENT_TYPE, EventPriority.HEADER, function FolderUser_StructHostAppointment.Event_Leave)",h7v,BI,function j1o)
set HZv=InitGameCache(hyv)
call j_o(HQv[0])
call aHx(function j0o)
endfunction
function j3o takes nothing returns nothing
local integer i
set gl=Nhx()
set i=Jh
loop
exitwhen(i<0)
call ForceAddPlayer(mD[(gl)],vx[(kh[i])])
set i=i-1
endloop
endfunction
function j4o takes integer oqx returns nothing
local integer rdx=rEx(0)
local integer olx
local integer rIx
local integer rlx
set eN[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((bZ))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((bZ))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function j5o takes nothing returns boolean
local integer oqx=(omx(GetTriggerPlayer()))
call j4o(oqx)
return true
endfunction
function j6o takes integer oqx returns nothing
set D0[oqx]=false
call rgx(F0)
endfunction
function j7o takes integer oqx returns nothing
if(d0[oqx]>0)then
return
endif
if(c0[oqx]!=Z)then
call oYx("FolderUser_FolderKeyEvent_StructDownArrow_Allocation_deallocCustom_confirm","call DebugEx(FolderUser_FolderKeyEvent_StructDownArrow.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",B0+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set c0[oqx]=c0[(w)]
set c0[(w)]=oqx
call j6o(oqx)
endfunction
function j8o takes integer oqx returns nothing
set d0[oqx]=d0[oqx]-1
call j7o(oqx)
endfunction
function j9o takes integer oqx,integer oQx,integer oSx returns boolean
return rex(oA[(oqx)],(nA[((oqx))]),oQx,oSx)
endfunction
function Jvo takes integer oqx,integer Xwx returns nothing
call j9o((oqx),(rA[(Xwx)]),Xwx)
endfunction
function Jeo takes nothing returns boolean
local integer rdx=(bv)
local integer Xwx=(fZ[(rdx)])
local integer oqx=FMx(Xwx,K0)
local integer p0x=G0[oqx]
local integer ocx=j0[oqx]
call j8o((oqx))
call ijx(p0x)
call Dlo(Xwx,K0)
call Jvo(Xwx,k0)
call hfx(ocx,J0,oqx)
call pGx(ocx,Xwx)
return true
endfunction
function Jxo takes integer rkx returns nothing
local integer rdx=rEx((Cb[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set G1[(rdx)]=((1.)*1.)
set eN[(rdx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=jUo(rkx,N0,rIx)
loop
exitwhen(rlx<q)
call rCx(jwo(rkx,N0,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function Joo takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer rdx=rEx(0)
set G1[(rdx)]=((h0[oqx])*1.)
set eN[(rdx)]=(j0[oqx])
call rCx(H0[oqx],rdx)
call rHx(((rdx)))
endfunction
function Jro takes nothing returns boolean
local integer rkx=(omx(GetTriggerPlayer()))
local integer olx
local integer oqx
set If[rkx]=true
call Jxo(rkx)
set olx=Ozx(rkx,J0)
loop
exitwhen(olx<q)
set oqx=O3x(rkx,J0,olx)
call icx(G0[oqx],g0[oqx],true,function Joo)
set olx=olx-1
endloop
return true
endfunction
function Jio takes integer rkx returns nothing
local integer rdx=rEx((Cb[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set eN[(rdx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=jUo(rkx,H2v,rIx)
loop
exitwhen(rlx<q)
call rCx(jwo(rkx,H2v,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function Jao takes nothing returns boolean
local integer rkx=(omx(GetTriggerPlayer()))
local integer olx
local integer oqx
set If[rkx]=false
call Jio(rkx)
set olx=Ozx(rkx,J0)
loop
exitwhen(olx<q)
set oqx=O3x(rkx,J0,olx)
call iHx(G0[oqx])
set olx=olx-1
endloop
return true
endfunction
function Jno takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(eN[(rdx)])
set If[rkx]=false
return true
endfunction
function JVo takes nothing returns nothing
set k0=XBx("FolderUser_FolderKeyEvent_StructDownArrow_Init: set FolderUser_FolderKeyEvent_StructDownArrow.DESTROY_EVENT = Event.Create(Event.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUser_FolderKeyEvent_StructDownArrow.Event_Destroy)",VI,BI,function Jeo)
set N0=(E0x())
set H2v=(E0x())
call jTo(Xhx(function Jro),Ge,EVENT_PLAYER_ARROW_DOWN_DOWN)
call jTo(Xhx(function Jao),Ge,EVENT_PLAYER_ARROW_DOWN_UP)
call gBx(gl,function Jno,w)
endfunction
function JEo takes integer oqx returns nothing
set A1[oqx]=false
call rgx(b1)
endfunction
function JXo takes integer oqx returns nothing
if(I1[oqx]>0)then
return
endif
if(O1[oqx]!=Z)then
call oYx("FolderUser_FolderKeyEvent_StructLeftArrow_Allocation_deallocCustom_confirm","call DebugEx(FolderUser_FolderKeyEvent_StructLeftArrow.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",X1+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set O1[oqx]=O1[(w)]
set O1[(w)]=oqx
call JEo(oqx)
endfunction
function JOo takes integer oqx returns nothing
set I1[oqx]=I1[oqx]-1
call JXo(oqx)
endfunction
function JRo takes nothing returns boolean
local integer rdx=(bv)
local integer Xwx=(fZ[(rdx)])
local integer oqx=FMx(Xwx,g1)
local integer p0x=c1[oqx]
local integer ocx=D1[oqx]
call JOo((oqx))
call ijx(p0x)
call Dlo(Xwx,g1)
call Jvo(Xwx,F1)
call hfx(ocx,f1,oqx)
call pGx(ocx,Xwx)
return true
endfunction
function JIo takes integer rkx returns nothing
local integer rdx=rEx((Cb[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set G1[(rdx)]=((1.)*1.)
set eN[(rdx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=jUo(rkx,V1,rIx)
loop
exitwhen(rlx<q)
call rCx(jwo(rkx,V1,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function JAo takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer rdx=rEx(0)
set G1[(rdx)]=((C1[oqx])*1.)
set eN[(rdx)]=(D1[oqx])
call rCx(d1[oqx],rdx)
call rHx(((rdx)))
endfunction
function JNo takes nothing returns boolean
local integer rkx=(omx(GetTriggerPlayer()))
local integer olx
local integer oqx
set Of[rkx]=true
call JIo(rkx)
set olx=Ozx(rkx,f1)
loop
exitwhen(olx<q)
set oqx=O3x(rkx,f1,olx)
call icx(c1[oqx],B1[oqx],true,function JAo)
set olx=olx-1
endloop
return true
endfunction
function Jbo takes integer rkx returns nothing
local integer rdx=rEx((Cb[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set eN[(rdx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=jUo(rkx,H3v,rIx)
loop
exitwhen(rlx<q)
call rCx(jwo(rkx,H3v,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function JBo takes nothing returns boolean
local integer rkx=(omx(GetTriggerPlayer()))
local integer olx
local integer oqx
set Of[rkx]=false
call Jbo(rkx)
set olx=Ozx(rkx,f1)
loop
exitwhen(olx<q)
set oqx=O3x(rkx,f1,olx)
call iHx(c1[oqx])
set olx=olx-1
endloop
return true
endfunction
function Jco takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(eN[(rdx)])
set Of[rkx]=false
return true
endfunction
function JCo takes nothing returns nothing
set F1=XBx("FolderUser_FolderKeyEvent_StructLeftArrow_Init: set FolderUser_FolderKeyEvent_StructLeftArrow.DESTROY_EVENT = Event.Create(Event.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUser_FolderKeyEvent_StructLeftArrow.Event_Destroy)",VI,BI,function JRo)
set V1=(E0x())
set H3v=(E0x())
call jTo(Xhx(function JNo),Ge,EVENT_PLAYER_ARROW_LEFT_DOWN)
call jTo(Xhx(function JBo),Ge,EVENT_PLAYER_ARROW_LEFT_UP)
call gBx(gl,function Jco,w)
endfunction
function Jdo takes integer oqx returns nothing
set l1[oqx]=false
call rgx(m1)
endfunction
function JDo takes integer oqx returns nothing
if(K1[oqx]>0)then
return
endif
if(J1[oqx]!=Z)then
call oYx("FolderUser_FolderKeyEvent_StructRightArrow_Allocation_deallocCustom_confirm","call DebugEx(FolderUser_FolderKeyEvent_StructRightArrow.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",j1+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set J1[oqx]=J1[(w)]
set J1[(w)]=oqx
call Jdo(oqx)
endfunction
function Jfo takes integer oqx returns nothing
set K1[oqx]=K1[oqx]-1
call JDo(oqx)
endfunction
function JFo takes nothing returns boolean
local integer rdx=(bv)
local integer Xwx=(fZ[(rdx)])
local integer oqx=FMx(Xwx,t1)
local integer p0x=p1[oqx]
local integer ocx=Q1[oqx]
call Jfo((oqx))
call ijx(p0x)
call Dlo(Xwx,t1)
call Jvo(Xwx,S1)
call hfx(ocx,s1,oqx)
call pGx(ocx,Xwx)
return true
endfunction
function Jgo takes integer rkx returns nothing
local integer rdx=rEx((Cb[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set G1[(rdx)]=((1.)*1.)
set eN[(rdx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=jUo(rkx,h1,rIx)
loop
exitwhen(rlx<q)
call rCx(jwo(rkx,h1,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function JGo takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer rdx=rEx(0)
set G1[(rdx)]=((P1[oqx])*1.)
set eN[(rdx)]=(Q1[oqx])
call rCx(q1[oqx],rdx)
call rHx(((rdx)))
endfunction
function Jho takes nothing returns boolean
local integer rkx=(omx(GetTriggerPlayer()))
local integer olx
local integer oqx
set Rf[rkx]=true
call Jgo(rkx)
set olx=Ozx(rkx,s1)
loop
exitwhen(olx<q)
set oqx=O3x(rkx,s1,olx)
call icx(p1[oqx],M1[oqx],true,function JGo)
set olx=olx-1
endloop
return true
endfunction
function JHo takes integer rkx returns nothing
local integer rdx=rEx((Cb[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set eN[(rdx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=jUo(rkx,H4v,rIx)
loop
exitwhen(rlx<q)
call rCx(jwo(rkx,H4v,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function Jjo takes nothing returns boolean
local integer rkx=(omx(GetTriggerPlayer()))
local integer olx
local integer oqx
set Rf[rkx]=false
call JHo(rkx)
set olx=Ozx(rkx,s1)
loop
exitwhen(olx<q)
set oqx=O3x(rkx,s1,olx)
call iHx(p1[oqx])
set olx=olx-1
endloop
return true
endfunction
function JJo takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(eN[(rdx)])
set Rf[rkx]=false
return true
endfunction
function Jko takes nothing returns nothing
set S1=XBx("FolderUser_FolderKeyEvent_StructRightArrow_Init: set FolderUser_FolderKeyEvent_StructRightArrow.DESTROY_EVENT = Event.Create(Event.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUser_FolderKeyEvent_StructRightArrow.Event_Destroy)",VI,BI,function JFo)
set h1=(E0x())
set H4v=(E0x())
call jTo(Xhx(function Jho),Ge,EVENT_PLAYER_ARROW_RIGHT_DOWN)
call jTo(Xhx(function Jjo),Ge,EVENT_PLAYER_ARROW_RIGHT_UP)
call gBx(gl,function JJo,w)
endfunction
function JKo takes integer oqx returns nothing
set z1[oqx]=false
call rgx(v2)
endfunction
function Jlo takes integer oqx returns nothing
if(Y1[oqx]>0)then
return
endif
if(w1[oqx]!=Z)then
call oYx("FolderUser_FolderKeyEvent_StructUpArrow_Allocation_deallocCustom_confirm","call DebugEx(FolderUser_FolderKeyEvent_StructUpArrow.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",U1+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set w1[oqx]=w1[(w)]
set w1[(w)]=oqx
call JKo(oqx)
endfunction
function JLo takes integer oqx returns nothing
set Y1[oqx]=Y1[oqx]-1
call Jlo(oqx)
endfunction
function Jmo takes nothing returns boolean
local integer rdx=(bv)
local integer Xwx=(fZ[(rdx)])
local integer oqx=FMx(Xwx,X2)
local integer p0x=o2[oqx]
local integer ocx=n2[oqx]
call JLo((oqx))
call ijx(p0x)
call Dlo(Xwx,X2)
call Jvo(Xwx,E2)
call hfx(ocx,V2,oqx)
call pGx(ocx,Xwx)
return true
endfunction
function JMo takes integer rkx returns nothing
local integer rdx=rEx((Cb[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set G1[(rdx)]=((1.)*1.)
set eN[(rdx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=jUo(rkx,T1,rIx)
loop
exitwhen(rlx<q)
call rCx(jwo(rkx,T1,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function Jpo takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer rdx=rEx(0)
set G1[(rdx)]=((r2[oqx])*1.)
set eN[(rdx)]=(n2[oqx])
call rCx(i2[oqx],rdx)
call rHx(((rdx)))
endfunction
function JPo takes nothing returns boolean
local integer rkx=(omx(GetTriggerPlayer()))
local integer olx
local integer oqx
set Af[rkx]=true
call JMo(rkx)
set olx=Ozx(rkx,V2)
loop
exitwhen(olx<q)
set oqx=O3x(rkx,V2,olx)
call icx(o2[oqx],e2[oqx],true,function Jpo)
set olx=olx-1
endloop
return true
endfunction
function Jqo takes integer rkx returns nothing
local integer rdx=rEx((Cb[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set eN[(rdx)]=(rkx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=jUo(rkx,H5v,rIx)
loop
exitwhen(rlx<q)
call rCx(jwo(rkx,H5v,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function JQo takes nothing returns boolean
local integer rkx=(omx(GetTriggerPlayer()))
local integer olx
local integer oqx
set Af[rkx]=false
call Jqo(rkx)
set olx=Ozx(rkx,V2)
loop
exitwhen(olx<q)
set oqx=O3x(rkx,V2,olx)
call iHx(o2[oqx])
set olx=olx-1
endloop
return true
endfunction
function Jso takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(eN[(rdx)])
set Af[rkx]=false
return true
endfunction
function JSo takes nothing returns nothing
set E2=XBx("FolderUser_FolderKeyEvent_StructUpArrow_Init: set FolderUser_FolderKeyEvent_StructUpArrow.DESTROY_EVENT = Event.Create(Event.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUser_FolderKeyEvent_StructUpArrow.Event_Destroy)",VI,BI,function Jmo)
set T1=(E0x())
set H5v=(E0x())
call jTo(Xhx(function JPo),Ge,EVENT_PLAYER_ARROW_UP_DOWN)
call jTo(Xhx(function JQo),Ge,EVENT_PLAYER_ARROW_UP_UP)
call gBx(gl,function Jso,w)
endfunction
function Jto takes nothing returns nothing
set bZ=(E0x())
set H1v=Xhx(function j5o)
call jTo(H1v,Ge,EVENT_PLAYER_END_CINEMATIC)
call JVo()
call JCo()
call Jko()
call JSo()
endfunction
function JTo takes nothing returns boolean
local integer oqx
local integer olx
set LA=(E0x())
set h7v=(E0x())
set h8v=O2x()
call jio()
call jEo()
call jRo()
call jIo()
set oqx=jHo("HumanRed",0,"ffff0000")
call jLo((oqx),(BTv))
set oqx=jHo("HumanBlue",1,"ff0000ff")
call jLo((oqx),(BTv))
set oqx=jHo("HumanTeal",2,"ff18e7bd")
call jLo((oqx),(BTv))
set oqx=jHo("HumanPurple",3,"ff520084")
call jLo((oqx),(BTv))
set oqx=jHo("HumanYellow",4,"ffffff00")
call jLo((oqx),(BTv))
set oqx=jHo("HumanOrange",5,"ffff8a08")
call jLo((oqx),(BTv))
set oqx=jHo("HumanGreen",6,"ff18be00")
call jLo((oqx),(BTv))
set oqx=jHo("Castle",7,"ffe759ad")
set Buv=oqx
call jLo((oqx),(BTv))
call StartCampaignAI(vx[oqx],HUv)
set oqx=jHo("Dummy",8,"ff949694")
set Fy=oqx
call jLo((oqx),(HJv))
set oqx=jHo("Creeps",9,"ff7bbef7")
set Hwv=oqx
call jbo(oqx,PLAYER_COLOR_AQUA)
call jLo((oqx),(Hfv))
set oqx=jHo("Spawns",$A,"ff086142")
set HWv=oqx
call jbo(oqx,PLAYER_COLOR_BROWN)
call jLo((oqx),(Hfv))
set oqx=jHo("Castle (controlable)",$B,"ffe759ad")
set BUv=oqx
call jbo(oqx,PLAYER_COLOR_PINK)
call jLo((oqx),(BTv))
set oqx=jHo("Neutral aggressive",$C,"ff000000")
set ex=oqx
call jLo((oqx),(Hfv))
call jko(oqx,oqx,ALLIANCE_PASSIVE,false,false)
set oqx=jHo("Neutral passive",$F,"ff000000")
set Hyv=oqx
set Ge=w
set olx=Jh
loop
exitwhen(olx<0)
call jko(Fy,kh[olx],ALLIANCE_PASSIVE,true,true)
if((Btv[(kh[olx])])==BTv)then
call jko(BUv,kh[olx],ALLIANCE_SHARED_ADVANCED_CONTROL,true,true)
call jko(BUv,kh[olx],ALLIANCE_SHARED_CONTROL,true,true)
endif
set olx=olx-1
endloop
call jmo(Fy,Bm)
call jmo(HWv,Bm)
call jko(Hwv,Buv,ALLIANCE_PASSIVE,true,true)
call jko(Hwv,BUv,ALLIANCE_PASSIVE,true,true)
call jpo(Xhx(function jto),Ge,"",false)
call jzo()
call j2o()
call j3o()
call Jto()
return true
endfunction
function Juo takes nothing returns boolean
call jvo(function JTo,"User_Init")
return true
endfunction
function JUo takes nothing returns boolean
set H6v=Vnx(H7v)
return true
endfunction
function Jwo takes integer oqx returns integer
set jov[oqx]=true
set jrv[oqx]=false
call rax(H6v)
return oqx
endfunction
function JWo takes nothing returns integer
local integer oqx
if(H9v==8190)then
call oYx("WeatherType_Allocation_allocCustom","call DebugEx(WeatherType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",H7v+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(jvv[(w)]==w)then
set jev=jev+1
set oqx=jev
else
set oqx=jvv[(w)]
set jvv[(w)]=jvv[jvv[(w)]]
endif
set jvv[oqx]=Z
set jxv[oqx]=1
call Jwo(oqx)
return oqx
endfunction
function Jyo takes integer oMx returns integer
local integer oqx=JWo()
set jiv[(oqx)]=(oMx)
return oqx
endfunction
function JYo takes nothing returns boolean
set H8v=Jyo('WMoo')
return true
endfunction
function Jzo takes nothing returns boolean
call VRx(ja,(function JYo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\WeatherEffect.page\\WeatherEffect.struct\\obj_moonType_wc3weather.j"))
return true
endfunction
function JZo takes nothing returns boolean
set jav=Vnx(jnv)
return true
endfunction
function J_o takes nothing returns nothing
endfunction
function J0o takes integer oqx returns integer
set jIv[oqx]=true
set jAv[oqx]=false
call rax(jav)
return oqx
endfunction
function J1o takes nothing returns integer
local integer oqx
if(jEv==8190)then
call oYx("WeatherEffect_Allocation_allocCustom","call DebugEx(WeatherEffect.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",jnv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(jXv[(w)]==w)then
set jOv=jOv+1
set oqx=jOv
else
set oqx=jXv[(w)]
set jXv[(w)]=jXv[jXv[(w)]]
endif
set jXv[oqx]=Z
set jRv[oqx]=1
call J0o(oqx)
return oqx
endfunction
function J2o takes integer jMo,integer rRx returns integer
local integer oqx=J1o()
set jNv[oqx]=AddWeatherEffect(bm[jMo],(jiv[(rRx)]))
return oqx
endfunction
function J3o takes nothing returns boolean
local integer rdx=(bv)
if iVx((eN[(rdx)]))then
call EnableWeatherEffect(jNv[(jVv)],true)
endif
return true
endfunction
function J4o takes nothing returns boolean
local integer rdx=(bv)
set jVv=J2o(Bm,H8v)
call DNx(XBx("WeatherEffect_Event_Start: call Event.Create(AfterIntro.FOR_PLAYER_EVENT_TYPE, EventPriority.HEADER, function WeatherEffect.Event_AfterIntro).AddToStatics()",jbv,BI,function J3o))
return true
endfunction
function J5o takes nothing returns boolean
call J_o()
call DNx(XBx("WeatherEffect_Init: call Event.Create(EventType.START, EventPriority.HEADER, function WeatherEffect.Event_Start).AddToStatics()",XE,BI,function J4o))
return true
endfunction
function J6o takes nothing returns boolean
call Gcx(function J5o,"WeatherEffect_Init")
return true
endfunction
function J7o takes nothing returns boolean
set jBv=Vnx(jcv)
return true
endfunction
function J8o takes nothing returns boolean
set jCv=Vnx(jdv)
return true
endfunction
function J9o takes nothing returns boolean
set jDv=Vnx(jfv)
return true
endfunction
function kvo takes nothing returns boolean
set jFv=Vnx(jgv)
return true
endfunction
function keo takes nothing returns boolean
set jGv=Vnx(jhv)
return true
endfunction
function kxo takes nothing returns boolean
set jHv=Vnx(jjv)
return true
endfunction
function koo takes nothing returns boolean
set jJv=Vnx(jkv)
return true
endfunction
function kro takes nothing returns boolean
set jKv=Vnx(jlv)
return true
endfunction
function kio takes code c,string rqx returns nothing
set hV=hV+1
set HV[hV]=CreateTrigger()
set jV[hV]=(GetHandleId(Condition((c))))
set JV[hV]=rqx
call TriggerAddCondition(HV[hV],Condition(c))
endfunction
function kao takes integer oqx,string o6x,string oQx,integer oSx returns boolean
local integer o7x=(ZA+(rmx(lv[(E[((oqx))])],((o6x)),((oQx)))))
local integer olx=o7x
loop
exitwhen((rmx(lv[(E[((oqx))])],((o6x)),((oQx)+I2S(ZA+(olx)+2))))==oSx)
set olx=olx-1
endloop
call XJx(lv[(E[(oqx)])],(o6x),(oQx+I2S(ZA+olx+2)),((rmx(lv[(E[((oqx))])],((o6x)),((oQx)+I2S(ZA+(o7x)+2))))))
set o7x=o7x-1
call XJx(lv[(E[(oqx)])],(o6x),(oQx),(o7x-ZA))
return(o7x==ZA)
endfunction
function kno takes integer oqx,string oMx,integer Xwx returns nothing
call kao(X,(oMx),(I2S((((rA[(Xwx)]))))),(Xwx))
endfunction
function kVo takes nothing returns nothing
if not jPv then
return
endif
set jPv=false
call iJx(jqv)
call kno(vN,"-rdy",jQv)
call Dbx(jsv)
endfunction
function kEo takes integer oqx returns nothing
if(oqx==w)then
return
endif
set jpv=w
call kVo()
if(qe!=w)then
call aEx(qe)
endif
endfunction
function kXo takes integer oqx returns nothing
if jPv then
call kVo()
endif
set jPv=true
set jqv=iAx(Opx(H0v)+" type \"-rdy\" in order to start "+(jSv[((oqx))]),Ge)
set jtv=oqx
call XUx(vN,"-rdy",jQv)
call DNx(jsv)
endfunction
function kOo takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((jTv[(oqx)]))])]))],((((se[((oqx))])))),(((oQx)+(okx)))))
endfunction
function kRo takes nothing returns boolean
local integer rdx=(bv)
if(jpv!=w)then
call kEo(jpv)
endif
call kXo((kOo((((juv[(rdx)]))),jUv,(q))))
return true
endfunction
function kIo takes integer oqx returns nothing
local integer rdx=rEx(0)
local integer olx
local integer rIx
local integer rlx
set juv[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((jmv))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((jmv))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function kAo takes integer oqx returns nothing
set jLv=w
call kIo(oqx)
if jwv then
return
endif
endfunction
function kNo takes integer oqx,integer kbo,integer rwx returns nothing
local integer olx
if(oqx==Ge)then
set olx=Jh
loop
call kNo(kh[olx],kbo,rwx)
set olx=olx-1
exitwhen(olx<0)
endloop
else
call SetPlayerTechResearched(vx[oqx],kbo,rwx)
endif
endfunction
function kBo takes integer oqx returns nothing
local integer rdx=rEx(0)
local integer olx
local integer rIx
local integer rlx
set juv[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((jMv))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((jMv))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function kco takes integer oqx returns nothing
local integer rwx
if(jLv!=w)then
call kAo(jLv)
endif
set jLv=oqx
set rwx=0
if(oqx==jWv)then
set rwx=1
elseif(oqx==jyv)then
set rwx=2
elseif(oqx==jYv)then
set rwx=3
elseif(oqx==jzv)then
set rwx=4
elseif(oqx==jZv)then
set rwx=5
elseif(oqx==j_v)then
set rwx=6
endif
call iLx(Ge,"New Chapter begins: "+iqx((j0v[(oqx)]),"ffffcc00"),15.)
if(rwx>0)then
call kNo(Ge,'R000',rwx)
endif
call kBo(oqx)
endfunction
function kCo takes nothing returns boolean
local integer rdx=(bv)
call DNx(XBx("Act_Event_Start: call Event.Create(Act.START_EVENT_TYPE, EventPriority.MISC, function LevelSet.Event_ActStart).AddToStatics()",jMv,LI,function kRo))
call kco(j1v)
return true
endfunction
function kdo takes integer oqx returns integer
set j6v[oqx]=true
set j7v[oqx]=false
set j8v[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set j9v[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(jKv)
return oqx
endfunction
function kDo takes nothing returns integer
local integer oqx
if(j2v==8190)then
call oYx("Act_Allocation_allocCustom","call DebugEx(Act.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",jlv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(j3v[(w)]==w)then
set j4v=j4v+1
set oqx=j4v
else
set oqx=j3v[(w)]
set j3v[(w)]=j3v[j3v[(w)]]
endif
set j3v[oqx]=Z
set j5v[oqx]=1
call kdo(oqx)
return oqx
endfunction
function kfo takes integer oqx returns boolean
set Jvv=Jvv+1
set Jev[Jvv]=oqx
set Jxv[oqx]=Jvv+1
return(Jvv==0)
endfunction
function kFo takes integer oqx returns nothing
set Jrv[(oqx)]=(Jiv+oqx)
endfunction
function kgo takes string rqx returns integer
local integer oqx=kDo()
set j0v[(oqx)]=(rqx)
call kfo(oqx)
if(Jvv>F)then
set Jov[(Jev[Jvv-1])]=(oqx)
endif
call kFo(oqx)
return oqx
endfunction
function kGo takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(jTv[(oqx)],(se[((oqx))]),oQx,oSx)
endfunction
function kho takes nothing returns nothing
local integer oqx
set oqx=kgo("Penguin Prelude")
set j1v=oqx
set Jav[(oqx)]=(true)
set Jnv[(oqx)]=("X")
call kGo(((oqx)),jUv,(JVv))
set oqx=kgo("Delightful disturbances")
set jWv=oqx
call kGo(((oqx)),jUv,(JEv))
call kGo(((oqx)),jUv,(JXv))
call kGo(((oqx)),jUv,(JOv))
call kGo(((oqx)),jUv,(JRv))
set oqx=kgo("Dash into the fire")
set jyv=oqx
call kGo(((oqx)),jUv,(JIv))
call kGo(((oqx)),jUv,(JAv))
call kGo(((oqx)),jUv,(JNv))
call kGo(((oqx)),jUv,(Jbv))
set oqx=kgo("Return of the elves")
set jYv=oqx
set oqx=kgo("Desire beyond death")
set jzv=oqx
set oqx=kgo("The mourning mountain")
set jZv=oqx
set oqx=kgo("The dragon's flight, Frozen in time")
set j_v=oqx
endfunction
function kHo takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((jTv[(oqx)]))])]))],((((se[((oqx))])))),(((oQx))))))
endfunction
function kjo takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((JBv[(oqx)]))])]))],((((Jcv[((oqx))])))),(((oQx))))))
endfunction
function kJo takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((JBv[(oqx)]))])]))],((((Jcv[((oqx))])))),(((oQx)+(okx)))))
endfunction
function kko takes nothing returns nothing
local integer olx=0
local integer kKo
local integer klo
local integer rlx
local integer kLo
local integer kmo
local integer oqx
loop
exitwhen(olx>Jvv)
set kKo=w
set klo=Jev[olx]
set rlx=(kHo(((klo)),jUv))
loop
exitwhen(rlx<q)
set kLo=(kOo(((klo)),jUv,(rlx)))
set kmo=(kjo(((kLo)),JCv))
loop
exitwhen(kmo<q)
set oqx=(kJo(((kLo)),JCv,(kmo)))
set Jdv[(oqx)]=(kLo)
set ue[(oqx)]=(kKo)
set kKo=oqx
set kmo=kmo-1
endloop
set rlx=rlx-1
endloop
set olx=olx+1
endloop
endfunction
function kMo takes nothing returns boolean
set jLv=w
set jmv=(E0x())
set jMv=(E0x())
call DNx(XBx("Act_Init: call Event.Create(EventType.START, EventPriority.HEADER, function Act.Event_Start).AddToStatics()",XE,BI,function kCo))
set I8v[(hw)]=((1.)*1.)
call kho()
call kko()
return true
endfunction
function kpo takes nothing returns boolean
call kio(function kMo,"Act_Init")
return true
endfunction
function kPo takes nothing returns boolean
set JDv=Vnx(Jfv)
return true
endfunction
function kqo takes code c,string rqx returns nothing
set kV=kV+1
set KV[kV]=CreateTrigger()
set lV[kV]=(GetHandleId(Condition((c))))
set LV[kV]=rqx
call TriggerAddCondition(KV[kV],Condition(c))
endfunction
function kQo takes integer oqx,integer jMo,integer Q4x returns nothing
if(Q4x==w)then
set Q4x=GK
endif
set Q4x=Noo(SQ,Q4x)
call GroupEnumUnitsInRect(Kb[((oqx))],bm[(jMo)],Bv[(Q4x)])
endfunction
function kso takes integer rRx,code Xbx returns nothing
local integer O8x=O2x()
set jf=rRx
call kQo(O8x,Bm,BIv)
call ForGroup(Kb[(O8x)],(Xbx))
call O6x(O8x)
endfunction
function kSo takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=RVx()
call OMx(Ixx,iqx("+"+(I2S(('d'))),"ff0000ff"),.032,60.,1.,2.5,(0))
call Bjx(Ixx,'d')
return true
endfunction
function kto takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=RVx()
call cox(Ixx,$F)
return true
endfunction
function kTo takes nothing returns boolean
local integer rdx=(bv)
local integer klo=(juv[(rdx)])
if(Jav[(klo)])then
return true
endif
call kso(G9v,function kSo)
call kso(Gfv,function kto)
return true
endfunction
function kuo takes nothing returns boolean
call DNx(XBx("ActUpgrades_Init: call Event.Create(Act.ENDING_EVENT_TYPE, EventPriority.MISC, function ActUpgrades.Event_ActEnding).AddToStatics()",jmv,LI,function kTo))
return true
endfunction
function kUo takes nothing returns boolean
call kqo(function kuo,"ActUpgrades_Init")
return true
endfunction
function kwo takes nothing returns boolean
set JFv=Vnx(Jgv)
return true
endfunction
function kWo takes code c,string rqx returns nothing
set AV=AV+1
set NV[AV]=CreateTrigger()
set bV[AV]=(GetHandleId(Condition((c))))
set BV[AV]=rqx
call TriggerAddCondition(NV[AV],Condition(c))
endfunction
function kyo takes nothing returns boolean
local integer olx=Hl
set JGv=(E0x())
set jbv=(E0x())
set Jhv=Nhx()
loop
exitwhen(olx<0)
call ForceAddPlayer(mD[(Jhv)],vx[(jl[olx])])
set olx=olx-1
endloop
return true
endfunction
function kYo takes nothing returns boolean
call kWo(function kyo,"AfterIntro_Init")
return true
endfunction
function kzo takes nothing returns boolean
set JHv=Vnx(Jjv)
return true
endfunction
function kZo takes code c,string rqx returns nothing
set cV=cV+1
set CV[cV]=CreateTrigger()
set dV[cV]=(GetHandleId(Condition((c))))
set DV[cV]=rqx
call TriggerAddCondition(CV[cV],Condition(c))
endfunction
function k_o takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((jTv[(oqx)]))])]))],((((se[((oqx))])))),(((oQx)))))
endfunction
function k0o takes integer k1o returns integer
return k_o(k1o,JLv)
endfunction
function k2o takes integer oqx,real D7x returns nothing
call SetUnitScale(zj[oqx],D7x,D7x,D7x)
endfunction
function k3o takes integer oqx returns boolean
set Iy=Iy+1
set Ry[Iy]=oqx
set Oy[oqx]=Iy+1
return(Iy==0)
endfunction
function k4o takes integer oqx,real oSx returns nothing
call mRx(oqx,(ky[(oqx)])+oSx)
endfunction
function k5o takes nothing returns nothing
local integer olx=Iy
local integer oqx
loop
set oqx=Ry[olx]
call k4o((oqx),Jpv[oqx])
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function k6o takes integer oqx,real NJx returns nothing
set Jpv[oqx]=NJx*JPv
call Mxx((oqx),Xy)
if k3o(oqx)then
call icx(Ay,JPv,true,function k5o)
endif
endfunction
function k7o takes integer k8o,real x,real y,boolean k9o returns nothing
local playercolor Kvo=(ox[(HWv)])
local real iWx=(NTv[(k8o)])
local real iyx=(NTv[(k8o)])
local real iYx=(NTv[(k8o)])
local integer HOx
if k9o then
set HOx=Jmv
else
set HOx=JMv
endif
if(HOx!=w)then
call MCx(HOx)
endif
set HOx=mcx(IGv[k8o],x,y,XYx(x,y)+280.,Kf)
call k2o(HOx,1.5)
call UnitAddAbility(zj[(HOx)],'aLoc')
call SetUnitColor(zj[((HOx))],(Kvo))
call k6o(HOx,df*1./ 3.)
call mBx(HOx,iWx,iyx,iYx,180.)
if k9o then
set Jmv=HOx
else
set JMv=HOx
endif
endfunction
function Keo takes nothing returns boolean
local integer rdx=(bv)
local integer k1o=(Qe[(rdx)])
local integer Kxo=k0o(k1o)
if(Kxo!=w)then
call k7o((Jqv[(Kxo)]),JJv,Jkv,false)
endif
set k1o=(ue[(k1o)])
if(k1o!=w)then
set Kxo=k0o(k1o)
if(Kxo!=w)then
call k7o((Jqv[(Kxo)]),JKv,Jlv,true)
endif
endif
return true
endfunction
function Koo takes nothing returns boolean
local integer rdx=(bv)
call DNx(XBx("BrazierOracle_Event_Start: call Event.Create(Level.START_EVENT_TYPE, EventPriority.MISC2, function BrazierOracle.Event_LevelStart).AddToStatics()",We,mI,function Keo))
return true
endfunction
function Kro takes nothing returns boolean
local integer rdx=(bv)
if(JMv!=w)then
call MCx(JMv)
endif
if(Jmv!=w)then
call MCx(Jmv)
endif
call SetDoodadAnimationRect(bm[Bm],'D01K',"death",false)
call SetDoodadAnimationRect(bm[Bm],'D01M',"death",false)
return true
endfunction
function Kio takes nothing returns boolean
local integer Kao=q_x(Yx)
local integer Kno=q_x(zx)
set JJv=(tm[(Kao)])
set Jkv=(Tm[(Kao)])
set JKv=(tm[(Kno)])
set Jlv=(Tm[(Kno)])
call DNx(XBx("BrazierOracle_Init: call Event.Create(EventType.START, EventPriority.MISC, function BrazierOracle.Event_Start).AddToStatics()",XE,LI,function Koo))
call DNx(XBx("BrazierOracle_Init: call Event.Create(Meteorite.GAME_OVER_EVENT_TYPE, EventPriority.MISC, function BrazierOracle.Event_GameOver).AddToStatics()",JQv,LI,function Kro))
return true
endfunction
function KVo takes nothing returns boolean
call kZo(function Kio,"BrazierOracle_Init")
return true
endfunction
function KEo takes nothing returns boolean
set Jsv=Vnx(JSv)
return true
endfunction
function KXo takes nothing returns nothing
local integer KOo=(kv[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetLocalPlayer())))))),((((R)))))))])
if(KOo==w)then
return
endif
call SetCameraQuickPosition((GetUnitX(C[((KOo))])),(GetUnitY(C[((KOo))])))
endfunction
function KRo takes nothing returns boolean
local integer rdx=(bv)
call Dbx(Jtv)
call icx(inx(),.035,true,function KXo)
return true
endfunction
function KIo takes nothing returns boolean
set Jtv=XBx("CameraQuickPosition_Init: set CameraQuickPosition.PICK_EVENT = Event.Create(HeroSelection.DUMMY_EVENT_TYPE, EventPriority.MISC, function CameraQuickPosition.Event_HeroPick)",JTv,LI,function KRo)
call DNx(Jtv)
return true
endfunction
function KAo takes nothing returns boolean
call kZo(function KIo,"CameraQuickPosition_Init")
return true
endfunction
function KNo takes nothing returns boolean
set Juv=WTx('BMOP',"Mark of the Paw",'bMOP')
set qU[(Juv)]=(true)
set aev[(Juv)]=("ReplaceableTextures\\CommandButtons\\BTNBattleRoar.blp")
call lux(Juv,"Abilities\\Spells\\NightElf\\BattleRoar\\RoarTarget.mdl","overhead",ri)
set SU=lYx()
call l_x(SU,nev,1)
call l0x(((Juv)),vc+(1),(SU))
return true
endfunction
function Kbo takes nothing returns boolean
call VRx(Ma,(function KNo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\CreepBuffs\\MarkOfThePaw.page\\MarkOfThePaw.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function KBo takes nothing returns boolean
set JUv=Vnx(Jwv)
return true
endfunction
function Kco takes code c,string rqx returns nothing
set XV=XV+1
set OV[XV]=CreateTrigger()
set RV[XV]=(GetHandleId(Condition((c))))
set IV[XV]=rqx
call TriggerAddCondition(OV[XV],Condition(c))
endfunction
function KCo takes nothing returns boolean
return true
endfunction
function Kdo takes nothing returns boolean
call Kco(function KCo,"MarkOfThePaw_Init")
return true
endfunction
function KDo takes nothing returns boolean
set JWv=Vnx(Jyv)
return true
endfunction
function Kfo takes nothing returns boolean
set JYv=Vnx(Jzv)
return true
endfunction
function KFo takes nothing returns boolean
set JZv=Vnx(J_v)
return true
endfunction
function Kgo takes nothing returns boolean
set J0v=Vnx(J1v)
return true
endfunction
function KGo takes nothing returns boolean
set J2v=Vnx(J3v)
return true
endfunction
function Kho takes nothing returns boolean
set J4v=Vnx(J5v)
return true
endfunction
function KHo takes nothing returns boolean
set J6v=Vnx(J7v)
return true
endfunction
function Kjo takes nothing returns boolean
set J8v=Vnx(J9v)
return true
endfunction
function KJo takes nothing returns boolean
set kvv=Vnx(kev)
return true
endfunction
function Kko takes nothing returns nothing
endfunction
function KKo takes integer oqx returns boolean
if(((mq[((oqx))])>0)==false)then
return false
endif
set mq[pq[Mq]]=mq[oqx]
set pq[mq[oqx]-1]=pq[Mq]
set mq[oqx]=0
set Mq=Mq-1
return(Mq==F)
endfunction
function Klo takes integer oqx,boolean oSx returns nothing
local boolean abx=Jq[oqx]
if(oSx==abx)then
return
endif
set Jq[oqx]=oSx
if oSx then
call KKo(oqx)
else
call jxx(oqx)
endif
endfunction
function KLo takes integer oqx returns nothing
set kVv[oqx]=false
call rgx(tq)
endfunction
function Kmo takes integer oqx returns nothing
if(kav[oqx]>0)then
return
endif
if(knv[oqx]!=Z)then
call oYx("Ping_Allocation_deallocCustom_confirm","call DebugEx(Ping.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Tq+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set knv[oqx]=knv[(w)]
set knv[(w)]=oqx
call KLo(oqx)
endfunction
function KMo takes integer oqx returns nothing
set kav[oqx]=kav[oqx]-1
call Kmo(oqx)
endfunction
function Kpo takes integer oqx returns boolean
local integer okx=(kEv[(oqx)])
set kEv[kXv[kOv]]=okx
set kXv[okx-1]=kXv[kOv]
set kEv[oqx]=0
set kOv=kOv-1
return(kOv==F)
endfunction
function KPo takes integer oqx returns nothing
local integer Kqo=kiv[oqx]
if(Kqo!=w)then
call Klo(Kqo,false)
endif
call KMo((oqx))
if Kpo(oqx)then
call iHx(Cq)
endif
endfunction
function KQo takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
local integer oqx=oPx(Oqx,kov)
local integer Kso=krv[oqx]
call IEo(Kso,Oqx)
call rix(Oqx,kov)
call Rmx(Oqx,kxv)
if(dKx((Kso),Rb))then
call KPo(kRv[oqx])
endif
return true
endfunction
function KSo takes integer oqx returns integer
set kcv[oqx]=true
set kCv[oqx]=false
call rax(JZv)
return oqx
endfunction
function Kto takes nothing returns integer
local integer oqx
if(kAv==8190)then
call oYx("CreepLocation_Allocation_allocCustom","call DebugEx(CreepLocation.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",J_v+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(kNv[(w)]==w)then
set kbv=kbv+1
set oqx=kbv
else
set oqx=kNv[(w)]
set kNv[(w)]=kNv[kNv[(w)]]
endif
set kNv[oqx]=Z
set kBv[oqx]=1
call KSo(oqx)
return oqx
endfunction
function KTo takes integer jMo returns integer
local integer oqx=Kto()
set krv[oqx]=JIx("CreepLocation_Create: set this.currentUnitsGroup = UnitList.Create()")
set kdv[oqx]=jMo
return oqx
endfunction
function Kuo takes nothing returns nothing
set kxv=XBx("CreepLocation_Init: set CreepLocation.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function CreepLocation.Event_Death)",VP,LI,function KQo)
set kIv=KTo(q_x(co))
set kDv=KTo(q_x(wx))
set kfv=KTo(q_x(Bo))
set kFv=KTo(q_x(do))
set kgv=KTo(q_x(Do))
set kGv=KTo(q_x(Co))
endfunction
function KUo takes nothing returns nothing
endfunction
function Kwo takes integer oqx returns integer
set kVv[oqx]=true
set kKv[oqx]=false
call rax(tq)
return oqx
endfunction
function KWo takes nothing returns integer
local integer oqx
if(kJv==8190)then
call oYx("Ping_Allocation_allocCustom","call DebugEx(Ping.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Tq+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(knv[(w)]==w)then
set kkv=kkv+1
set oqx=kkv
else
set oqx=knv[(w)]
set knv[(w)]=knv[knv[(w)]]
endif
set knv[oqx]=Z
set kav[oqx]=1
call Kwo(oqx)
return oqx
endfunction
function Kyo takes real x,real y,integer Kqo returns integer
local integer oqx=KWo()
set klv[oqx]=(Kq[(Kqo)])
set kLv[oqx]=(lq[(Kqo)])
set kmv[oqx]=(Lq[(Kqo)])
set kiv[oqx]=Kqo
set kMv[oqx]=x
set kpv[oqx]=y
call Klo(Kqo,true)
return oqx
endfunction
function KYo takes integer oqx returns nothing
local integer Kso=krv[oqx]
local integer Oqx
loop
set Oqx=(Otx((Kso),Rb))
exitwhen(Oqx==w)
call Cex((Oqx),w)
endloop
endfunction
function Kzo takes real x,real y,integer iWx,integer iyx,integer iYx,real ilx returns nothing
call PingMinimapEx(x,y,ilx,iWx,iyx,iYx,false)
endfunction
function KZo takes integer oqx returns nothing
set kqv[oqx]=true
call Kzo(kMv[oqx],kpv[oqx],klv[oqx],kLv[oqx],kmv[oqx],5.)
endfunction
function K_o takes integer oqx returns boolean
set kOv=kOv+1
set kXv[kOv]=oqx
set kEv[oqx]=kOv+1
return(kOv==0)
endfunction
function K0o takes nothing returns nothing
local integer olx=kOv
local integer oqx
loop
set oqx=kXv[olx]
if kqv[oqx]then
call Kzo(kMv[oqx],kpv[oqx],klv[oqx],kLv[oqx],kmv[oqx],5.)
endif
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function K1o takes integer oqx returns nothing
if K_o(oqx)then
call icx(Cq,5.,true,function K0o)
endif
endfunction
function K2o takes integer oqx,integer K3o returns nothing
set kRv[oqx]=K3o
call KZo(K3o)
call K1o(K3o)
endfunction
function K4o takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((kQv[(oqx)]))])]))],((((ksv[((oqx))])))),(((oQx))))))
endfunction
function K5o takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((kQv[(oqx)]))])]))],((((ksv[((oqx))])))),(((oQx)+(okx)))))
endfunction
function K6o takes integer oqx,integer Oqx returns nothing
call rTx(Oqx,kov,oqx)
call I7x(Oqx,kxv)
call dpx(krv[oqx],Oqx)
endfunction
function K7o takes integer oqx,real addX,real addY returns integer
local integer o4x=bVx(ktv[oqx],Hwv,kTv[oqx],kuv[oqx],kUv[oqx])
local integer K8o=kwv[oqx]
if(K8o!=w)then
call RDo(o4x,K8o)
endif
return o4x
endfunction
function K9o takes integer oqx returns nothing
local integer lvo=(kjv[(oqx)])
local integer leo=(pq[(GetRandomInt(((0)),((Mq))))])
local real lxo=(tm[(kdv[(lvo)])])
local real loo=(Tm[(kdv[(lvo)])])
local integer K3o=Kyo(lxo,loo,leo)
local integer olx
local integer lro
call KYo(lvo)
if(leo==w)then
call iLx(Ge,iqx((kPv[(oqx)]),"ffffcc00")+" has/have spawned.",10.)
else
call iLx(Ge,iqx((kPv[(oqx)]),"ffffcc00")+" has/have spawned at the "+(kq[(leo)])+" spot.",10.)
endif
call K2o(lvo,K3o)
set olx=K4o(oqx,kSv)
loop
set lro=K5o(oqx,kSv,olx)
call K6o(lvo,K7o(lro,lxo,loo))
set olx=olx-1
exitwhen(olx<q)
endloop
endfunction
function lio takes nothing returns boolean
local integer rdx=(bv)
local integer k1o=(Qe[(rdx)])
local integer olx=kHo(k1o,kHv)
loop
call K9o((kOo(k1o,kHv,olx)))
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function lao takes nothing returns boolean
local integer rdx=(bv)
local integer k1o=(ue[((Qe[(rdx)]))])
local integer o7x
local integer olx
local string lno
if(k1o==w)then
return true
endif
set o7x=kHo(k1o,kHv)
if(o7x<q)then
return true
endif
set olx=o7x
set lno=""
loop
if(olx!=o7x)then
if(olx==q)then
set lno=lno+" and "
else
set lno=lno+", "
endif
endif
set lno=lno+iqx((kPv[((kOo(k1o,kHv,olx)))]),"ffffcc00")
set olx=olx-1
exitwhen(olx<q)
endloop
call iLx(Ge,iqx("Notification:","ffffcc00")+" Next level features the creeps "+lno+".",10.)
return true
endfunction
function lVo takes integer oqx returns integer
set kZv[oqx]=true
set k_v[oqx]=false
set kQv[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set k0v[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(kvv)
return oqx
endfunction
function lEo takes nothing returns integer
local integer oqx
if(kWv==8190)then
call oYx("CreepSet_Allocation_allocCustom","call DebugEx(CreepSet.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",kev+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(kyv[(w)]==w)then
set kYv=kYv+1
set oqx=kYv
else
set oqx=kyv[(w)]
set kyv[(w)]=kyv[kyv[(w)]]
endif
set kyv[oqx]=Z
set kzv[oqx]=1
call lVo(oqx)
return oqx
endfunction
function lXo takes integer oqx returns nothing
set ksv[(oqx)]=(k1v+oqx)
endfunction
function lOo takes string rqx,integer lvo returns integer
local integer oqx=lEo()
set kjv[(oqx)]=(lvo)
set kPv[(oqx)]=(rqx)
call lXo(oqx)
return oqx
endfunction
function lRo takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(kQv[(oqx)],(ksv[((oqx))]),oQx,oSx)
endfunction
function lIo takes integer oqx returns integer
set k7v[oqx]=true
set k8v[oqx]=false
call rax(JYv)
return oqx
endfunction
function lAo takes nothing returns integer
local integer oqx
if(k3v==8190)then
call oYx("Creep_Allocation_allocCustom","call DebugEx(Creep.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Jzv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(k4v[(w)]==w)then
set k5v=k5v+1
set oqx=k5v
else
set oqx=k4v[(w)]
set k4v[(w)]=k4v[k4v[(w)]]
endif
set k4v[oqx]=Z
set k6v[oqx]=1
call lIo(oqx)
return oqx
endfunction
function lNo takes integer lbo,unit lBo returns integer
local real N8x=bh*GetUnitFacing(lBo)
local real x=GetUnitX(lBo)
local real y=GetUnitY(lBo)
local integer oqx
call Mcx(lBo)
set oqx=lAo()
set kUv[oqx]=N8x
set kwv[oqx]=w
set ktv[oqx]=lbo
set kTv[oqx]=x
set kuv[oqx]=y
return oqx
endfunction
function lco takes integer oqx,integer Xwx returns nothing
if(Te[oqx]==w)then
call oYx("FolderLevel_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oqx)+";"+(JA[(Xwx)]))
set Te[oqx]=X
endif
call rSx(Te[oqx],(se[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function lCo takes integer oqx,integer k1o returns nothing
if kGo(k1o,kHv,oqx)then
call lco(k1o,khv)
endif
endfunction
function ldo takes nothing returns boolean
local integer oqx
call Kko()
call Kuo()
call KUo()
set khv=XBx("CreepSet_Init: set CreepSet.LEVEL_START_EVENT = Event.Create(Level.START_EVENT_TYPE, EventPriority.MISC, function CreepSet.Event_LevelStart)",We,LI,function lio)
call DNx(XBx("CreepSet_Init: call Event.Create(Level.START_EVENT_TYPE, EventPriority.MISC, function CreepSet.Event_Warning_LevelStart).AddToStatics()",We,LI,function lao))
set oqx=lOo("Blue Dragon Spawns",kIv)
set k2v=oqx
call lRo((oqx),kSv,(lNo(G6v,Xr)))
call lRo((oqx),kSv,(lNo(G6v,gr)))
call lRo((oqx),kSv,(lNo(GXv,Ar)))
call lRo((oqx),kSv,(lNo(GXv,Cr)))
call lCo(oqx,k9v)
set oqx=lOo("Furbolg Mother",kDv)
set Kvv=oqx
call lRo((oqx),kSv,(lNo(g6v,Br)))
call lRo((oqx),kSv,(lNo(gRv,fr)))
call lRo((oqx),kSv,(lNo(gRv,Fr)))
call lCo(oqx,Kev)
set oqx=lOo("Kobolds",kGv)
set Kxv=oqx
call lRo((oqx),kSv,(lNo(G7v,Nr)))
call lRo((oqx),kSv,(lNo(G7v,Hr)))
call lRo((oqx),kSv,(lNo(GDv,dr)))
call lRo((oqx),kSv,(lNo(GDv,Dr)))
call lCo(oqx,Kev)
set oqx=lOo("Pandarenes",kfv)
set Kov=oqx
call lRo((oqx),kSv,(lNo(GFv,Er)))
call lRo((oqx),kSv,(lNo(GFv,Rr)))
call lCo(oqx,Kev)
set oqx=lOo("Treants",kgv)
set Kxv=oqx
call lRo((oqx),kSv,(lNo(hiv,Jr)))
call lRo((oqx),kSv,(lNo(hiv,kr)))
call lRo((oqx),kSv,(lNo(g8v,jr)))
call lCo(oqx,Kev)
set oqx=lOo("Wolves",kFv)
set Krv=oqx
call lRo((oqx),kSv,(lNo(hav,Ir)))
call lRo((oqx),kSv,(lNo(hav,hr)))
call lRo((oqx),kSv,(lNo(Gvv,Gr)))
call lCo(oqx,Kev)
return true
endfunction
function lDo takes nothing returns boolean
call kqo(function ldo,"CreepSet_Init")
return true
endfunction
function lfo takes nothing returns boolean
set Kiv=Vnx(Kav)
return true
endfunction
function lFo takes nothing returns boolean
set Knv=Vnx(KVv)
return true
endfunction
function lgo takes nothing returns boolean
set KEv=Vnx(KXv)
return true
endfunction
function lGo takes nothing returns boolean
set KOv=Vnx(KRv)
return true
endfunction
function lho takes nothing returns boolean
set KIv=Vnx(KAv)
return true
endfunction
function lHo takes nothing returns boolean
set KNv=Vnx(Kbv)
return true
endfunction
function ljo takes nothing returns boolean
set KBv=Vnx(Kcv)
return true
endfunction
function lJo takes nothing returns boolean
set KCv=Vnx(Kdv)
return true
endfunction
function lko takes nothing returns boolean
set KDv=Vnx(Kfv)
return true
endfunction
function lKo takes nothing returns boolean
set KFv=Vnx(Kgv)
return true
endfunction
function llo takes nothing returns boolean
set KGv=Vnx(Khv)
return true
endfunction
function lLo takes nothing returns boolean
set KHv=Vnx(Kjv)
return true
endfunction
function lmo takes nothing returns boolean
set KJv=Vnx(Kkv)
return true
endfunction
function lMo takes nothing returns boolean
set KKv=Vnx(Klv)
return true
endfunction
function lpo takes nothing returns boolean
set KLv=Vnx(Kmv)
return true
endfunction
function lPo takes nothing returns boolean
set KMv=Vnx(Kpv)
return true
endfunction
function lqo takes nothing returns boolean
set KPv=Vnx(Kqv)
return true
endfunction
function lQo takes nothing returns boolean
set KQv=Vnx(Ksv)
return true
endfunction
function lso takes nothing returns boolean
set KSv=Vnx(Ktv)
return true
endfunction
function lSo takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((Kwv[(oqx)]))])]))],((((KWv[((oqx))])))),(((oQx))))))
endfunction
function lto takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((Kwv[(oqx)]))])]))],((((KWv[((oqx))])))),(((oQx)+(okx)))))
endfunction
function lTo takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((K_v[(oqx)]))])]))],((((K0v[((oqx))])))),(((oQx))))))
endfunction
function luo takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((K_v[(oqx)]))])]))],((((K0v[((oqx))])))),(((oQx)+(okx)))))
endfunction
function lUo takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((K4v[oqx]))])]))],((((K3v[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function lwo takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((K4v[oqx]))])]))],((((K3v[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function lWo takes integer rRx,integer Oqx returns nothing
local integer rdx=rEx(0)
local integer Gmx
local integer olx
local integer rIx
local integer rlx
set K2v[(rdx)]=(rRx)
set Vv[(rdx)]=(Oqx)
set Gmx=rEx((K3v[(rRx)]))
set K2v[(Gmx)]=(rRx)
set Vv[(Gmx)]=(Oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Kuv))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Kuv))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set rlx=lUo(rRx,Kuv,rIx)
loop
exitwhen(rlx<q)
call rCx(lwo(rRx,Kuv,rIx,rlx),Gmx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call rHx(((Gmx)))
endfunction
function lyo takes integer rRx,integer lYo,real x,real y,real N8x returns integer
local integer lzo=bVx(lYo,Buv,x,y,N8x)
call GroupAddUnit(Kb[(KTv)],C[(lzo)])
call lWo(rRx,lzo)
return lzo
endfunction
function lZo takes integer oqx returns real
return(GetRandomReal((((wm[(oqx)]))*1.),(((um[(oqx)]))*1.)))
endfunction
function l_o takes integer oqx returns real
return(GetRandomReal((((Wm[(oqx)]))*1.),(((Um[(oqx)]))*1.)))
endfunction
function l0o takes integer oqx returns nothing
local integer ozx=KYv[oqx]
local integer Ixx=Kzv[oqx]
local real jlx=(tm[(KZv[(ozx)])])
local real jLx=(Tm[(KZv[(ozx)])])
local integer o7x=lTo(oqx,K1v)
local integer O8x=O2x()
local integer olx=q
local integer rRx
loop
exitwhen(olx>o7x)
set rRx=luo(oqx,K1v,olx)
call GroupAddUnit(Kb[(O8x)],C[(lyo(rRx,(K5v[(rRx)]),jlx,jLx,Kf))])
set olx=olx+1
endloop
call GroupPointOrderById(Kb[((O8x))],Pb[(Xw)],(((lZo(KZv[(Ixx)])))*1.),(((l_o(KZv[(Ixx)])))*1.))
call O6x(O8x)
endfunction
function l1o takes integer oqx returns nothing
local integer rkx=oqx
local integer o7x=lSo(rkx,Kyv)
local integer olx=q
local integer l2o
loop
exitwhen(olx>o7x)
set l2o=lto(rkx,Kyv,olx)
call l0o(l2o)
set olx=olx+1
endloop
endfunction
function l3o takes nothing returns boolean
local integer rdx=(bv)
local integer l4o=(k_o(((Qe[(rdx)])),KUv))
call l1o((l4o))
return true
endfunction
function l5o takes nothing returns boolean
local integer rdx=(bv)
call DNx(XBx("DefenderSpawn_Event_Start: call Event.Create(Level.START_EVENT_TYPE, EventPriority.MISC, function DefenderSpawn.Event_LevelStart).AddToStatics()",We,LI,function l3o))
return true
endfunction
function l6o takes integer oqx returns integer
set lev[oqx]=true
set lxv[oqx]=false
call rax(Kiv)
return oqx
endfunction
function l7o takes nothing returns integer
local integer oqx
if(K7v==8190)then
call oYx("DefenderSpawnLocation_Allocation_allocCustom","call DebugEx(DefenderSpawnLocation.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Kav+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(K8v[(w)]==w)then
set K9v=K9v+1
set oqx=K9v
else
set oqx=K8v[(w)]
set K8v[(w)]=K8v[K8v[(w)]]
endif
set K8v[oqx]=Z
set lvv[oqx]=1
call l6o(oqx)
return oqx
endfunction
function l8o takes integer oqx returns boolean
set lov=lov+1
set lrv[lov]=oqx
set liv[oqx]=lov+1
return(lov==0)
endfunction
function l9o takes integer ozx returns integer
local integer oqx=l7o()
set KZv[oqx]=ozx
call l8o(oqx)
return oqx
endfunction
function Lvo takes nothing returns nothing
set K6v=l9o(q_x(go))
set lav=l9o(q_x(Ho))
set lnv=l9o(q_x(Go))
set lVv=l9o(q_x(ho))
endfunction
function Leo takes integer oqx returns integer
set lIv[oqx]=true
set lAv[oqx]=false
set lNv[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set K4v[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(KBv)
return oqx
endfunction
function Lxo takes nothing returns integer
local integer oqx
if(lEv==8190)then
call oYx("DefenderSpawnType_Allocation_allocCustom","call DebugEx(DefenderSpawnType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Kcv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(lXv[(w)]==w)then
set lOv=lOv+1
set oqx=lOv
else
set oqx=lXv[(w)]
set lXv[(w)]=lXv[lXv[(w)]]
endif
set lXv[oqx]=Z
set lRv[oqx]=1
call Leo(oqx)
return oqx
endfunction
function Loo takes integer oqx returns boolean
set lbv=lbv+1
set lBv[lbv]=oqx
set lcv[oqx]=lbv+1
return(lbv==0)
endfunction
function Lro takes integer oqx returns nothing
set K3v[(oqx)]=(lCv+oqx)
endfunction
function Lio takes integer lbo returns integer
local integer oqx=Lxo()
set K5v[(oqx)]=(lbo)
call Loo(oqx)
call Lro(oqx)
return oqx
endfunction
function Lao takes nothing returns nothing
local integer oqx
set oqx=Lio(Gnv)
set oqx=Lio(Gnv)
set oqx=Lio(Gnv)
set ldv=oqx
set oqx=Lio(hFv)
set oqx=Lio(hFv)
set oqx=Lio(hFv)
set lDv=oqx
endfunction
function Lno takes integer oqx returns integer
set ljv[oqx]=true
set lJv[oqx]=false
set Kwv[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
call rax(KQv)
return oqx
endfunction
function LVo takes nothing returns integer
local integer oqx
if(lgv==8190)then
call oYx("DefenderSpawnWave_Allocation_allocCustom","call DebugEx(DefenderSpawnWave.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Ksv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(lGv[(w)]==w)then
set lhv=lhv+1
set oqx=lhv
else
set oqx=lGv[(w)]
set lGv[(w)]=lGv[lGv[(w)]]
endif
set lGv[oqx]=Z
set lHv[oqx]=1
call Lno(oqx)
return oqx
endfunction
function LEo takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((jTv[(oqx)]))])]))],((((se[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function LXo takes integer oqx,integer oSx returns nothing
set lkv[oqx]=oSx
call LEo(oSx,KUv,oqx)
endfunction
function LOo takes integer oqx returns nothing
set KWv[(oqx)]=(llv+oqx)
endfunction
function LRo takes integer k1o returns integer
local integer oqx=LVo()
call LXo(oqx,k1o)
set lKv[(oqx)]=((20.)*1.)
call LOo(oqx)
return oqx
endfunction
function LIo takes integer oqx returns integer
set lPv[oqx]=true
set lqv[oqx]=false
set K_v[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
call rax(KHv)
return oqx
endfunction
function LAo takes nothing returns integer
local integer oqx
if(lLv==8190)then
call oYx("DefenderSpawnGroup_Allocation_allocCustom","call DebugEx(DefenderSpawnGroup.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Kjv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(lmv[(w)]==w)then
set lMv=lMv+1
set oqx=lMv
else
set oqx=lmv[(w)]
set lmv[(w)]=lmv[lmv[(w)]]
endif
set lmv[oqx]=Z
set lpv[oqx]=1
call LIo(oqx)
return oqx
endfunction
function LNo takes integer oqx returns nothing
set K0v[(oqx)]=(lQv+oqx)
endfunction
function Lbo takes integer ozx,integer Ixx returns integer
local integer oqx=LAo()
set KYv[(oqx)]=(ozx)
set Kzv[(oqx)]=(Ixx)
call LNo(oqx)
return oqx
endfunction
function LBo takes integer oqx,integer oQx,integer oSx returns boolean
return ltx(K_v[(oqx)],(K0v[((oqx))]),oQx,oSx)
endfunction
function Lco takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(Kwv[(oqx)],(KWv[((oqx))]),oQx,oSx)
endfunction
function LCo takes nothing returns nothing
local integer olx=lfv
local integer thisTypeIndex
local integer Ldo
local integer oqx
local integer l2o
loop
exitwhen(olx<0)
set Ldo=ye[olx]
if not(lFv[(Ldo)])then
set oqx=LRo(Ldo)
set l2o=Lbo(K6v,lnv)
call LBo((l2o),K1v,(lDv))
call LBo((l2o),K1v,(lDv))
call LBo((l2o),K1v,(ldv))
call Lco(((oqx)),Kyv,(l2o))
set l2o=Lbo(K6v,lVv)
call LBo((l2o),K1v,(lDv))
call LBo((l2o),K1v,(lDv))
call LBo((l2o),K1v,(ldv))
call Lco(((oqx)),Kyv,(l2o))
set l2o=Lbo(K6v,lav)
call LBo((l2o),K1v,(lDv))
call LBo((l2o),K1v,(lDv))
call LBo((l2o),K1v,(ldv))
call Lco(((oqx)),Kyv,(l2o))
endif
set olx=olx-1
endloop
endfunction
function LDo takes nothing returns boolean
set KTv=O2x()
set Kuv=(E0x())
call DNx(XBx("DefenderSpawn_Init: call Event.Create(EventType.START, EventPriority.MISC, function DefenderSpawn.Event_Start).AddToStatics()",XE,LI,function l5o))
call Lvo()
call Lao()
call LCo()
return true
endfunction
function Lfo takes nothing returns boolean
call kqo(function LDo,"DefenderSpawn_Init")
return true
endfunction
function LFo takes nothing returns boolean
set lsv=Vnx(lSv)
return true
endfunction
function Lgo takes nothing returns boolean
return true
endfunction
function LGo takes nothing returns boolean
set ltv=Vnx(lTv)
return true
endfunction
function Lho takes nothing returns boolean
local integer Ixx=jFx()
if((kv[((ze[(Ixx)]))])!=Ixx)then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if((Btv[((ze[(Ixx)]))])!=BTv)then
return false
endif
return true
return true
endfunction
function LHo takes integer oqx,integer id,real oSx returns integer
local integer nGo=(LoadInteger(o[((V[(E[((X))])]))],(((ON))),((((id))))))
if(nGo==w)then
set nGo=cNx(null,.02,(GetUnitX(C[((oqx))])),(GetUnitY(C[((oqx))])),fwx(oqx)+OLx(oqx,true),id)
set fN[(nGo)]=((oSx)*1.)
else
set fN[(nGo)]=(((fN[(nGo)])+oSx)*1.)
endif
return nGo
endfunction
function Ljo takes integer Ixx,real o2x returns nothing
local integer LJo
if I6x(Ixx,sc)then
return
endif
if I6x(Ixx,IBv)then
return
endif
if I6x(Ixx,ICv)then
return
endif
if I6x(Ixx,IFv)then
return
endif
if(o2x<=0)then
return
endif
call RUx((Abx((Ixx),(lwv),(lWv),(ri))))
set LJo=LHo(Ixx,lyv+Ixx,o2x)
call X6x(LJo,iqx("+"+(I2S(((R2I((((fN[(LJo)]))*1.)))))),"ffd45e19"),.02)
call cGx(Ixx,o2x)
call BRx(Ixx,o2x)
call Ico(Ixx,o2x)
endfunction
function Lko takes integer oqx,integer Oqx returns boolean
return IsUnitInGroup(C[Oqx],Kb[oqx])
endfunction
function LKo takes integer oqx,real oSx returns nothing
call bCx(oqx,(Pf[(oqx)])+oSx)
endfunction
function Llo takes integer Ixx,real nyx returns nothing
local integer LJo=LHo(Ixx,lYv+Ixx,nyx)
call X6x(LJo,iqx("+"+(I2S(((R2I((((fN[(LJo)]))*1.)))))),"ff8b008b"),.02)
call LKo(Ixx,nyx)
endfunction
function LLo takes nothing returns boolean
local integer rdx=(bv)
local integer cCx=(FG[(rdx)])
local integer NAo
local integer Oqx
local real nyx
local integer Lmo
local real LMo
local real Lpo
local integer Ixx
if(cCx==w)then
return true
endif
set NAo=(ze[(cCx)])
set Oqx=(Vv[(rdx)])
if(IsUnitAlly(C[(Oqx)],vx[(NAo)]))then
return true
endif
if((Btv[(NAo)])!=BTv)then
return true
endif
set nyx=(Nvv[((uf[(Oqx)]))])
call Ljo(cCx,nyx)
set cCx=(kv[(NAo)])
call Nio(luv,(GetUnitX(C[((Oqx))])),(GetUnitY(C[((Oqx))])),1000.,lUv)
set Lmo=(NXo((luv)))
if(cCx==w)then
set LMo=.0
else
set LMo=.4-.05*Lmo
endif
if(Lmo<=0)then
set Lpo=.0
else
set Lpo=(1.-LMo)*1./ Lmo
endif
if(cCx!=w)then
if Lko(luv,cCx)then
call Llo(cCx,(Lpo+LMo)*nyx)
call GroupRemoveUnit(Kb[(luv)],C[(cCx)])
else
call Llo(cCx,LMo*nyx)
endif
endif
set Ixx=Nao(luv)
if(Ixx!=w)then
loop
call Llo(Ixx,Lpo*nyx)
set Ixx=Nao(luv)
exitwhen(Ixx==w)
endloop
endif
return true
endfunction
function LPo takes integer cCx,integer Oqx returns integer
return(R2I((((Nev[(Oqx)]))*1.)))
endfunction
function Lqo takes integer oqx,playerstate CCx,integer oSx returns nothing
call CFx(oqx,CCx,(GetPlayerState(vx[((oqx))],(CCx)))+oSx)
endfunction
function LQo takes integer oqx,string iNx,real X7x,integer id,boolean Lso,boolean Omx returns integer
local real x=(GetUnitX(C[((oqx))]))
local real y=(GetUnitY(C[((oqx))]))
local real z=Olx(oqx,x,y)
if Lso then
set z=z+OLx(oqx,Omx)
endif
if Omx then
set X7x=X7x*(ob[(oqx)])
endif
return cNx(iNx,X7x,x,y,z,id)
endfunction
function LSo takes nothing returns boolean
local integer rdx=(bv)
local integer cCx=(FG[(rdx)])
local integer Oqx=(Vv[(rdx)])
local integer NAo
local integer Lto
if(cCx==w)then
return true
endif
if((Btv[((ze[(Oqx)]))])!=Hfv)then
return true
endif
set NAo=(ze[(cCx)])
if((Btv[(NAo)])!=BTv)then
return true
endif
if(NAo==Buv)then
return true
endif
set Lto=(R2I(((LPo(cCx,Oqx)*lzv)*1.)))
if(Lto<=0)then
return true
endif
call Lqo(NAo,PLAYER_STATE_RESOURCE_GOLD,Lto)
if(Lto>(Nxv[((uf[(Oqx)]))]))then
call LQo(Oqx,iqx("+"+(I2S((Lto))),"ffffcc00"),1.15*ab,(0),false,false)
else
call LQo(Oqx,iqx("+"+(I2S((Lto))),"ffffcc00"),1.*ab,(0),false,false)
endif
return true
endfunction
function LTo takes nothing returns boolean
set luv=O2x()
set lUv=XLx(function Lho)
call DNx(XBx("Drop_Init: call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function Drop.Exp_Event_Death).AddToStatics()",VP,LI,function LLo))
call DNx(XBx("Drop_Init: call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function Drop.Supply_Event_Death).AddToStatics()",VP,LI,function LSo))
return true
endfunction
function Luo takes nothing returns boolean
call kWo(function LTo,"Drop_Init")
return true
endfunction
function LUo takes integer oqx returns integer
set l3v[oqx]=true
set l4v[oqx]=false
set NH[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set Hv[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(o6)
return oqx
endfunction
function Lwo takes nothing returns integer
local integer oqx
if(l_v==8190)then
call oYx("Spell_Allocation_allocCustom","call DebugEx(Spell.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",r6+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(l0v[(w)]==w)then
set l1v=l1v+1
set oqx=l1v
else
set oqx=l0v[(w)]
set l0v[(w)]=l0v[l0v[(w)]]
endif
set l0v[oqx]=Z
set l2v[oqx]=1
call LUo(oqx)
return oqx
endfunction
function LWo takes integer oqx returns nothing
set Ev[(oqx)]=(l7v+oqx)
endfunction
function Lyo takes integer oqx returns boolean
set lJ=lJ+1
set LJ[lJ]=oqx
set l8v[oqx]=lJ+1
return(lJ==0)
endfunction
function LYo takes string rqx returns integer
local integer oqx=Lwo()
set j6[oqx]=0
set l5v[(oqx)]=(false)
set sH[(oqx)]=(rqx)
call LWo(oqx)
call Xkx((sH[(oqx)]),mv,oqx)
call Lyo(oqx)
return oqx
endfunction
function Lzo takes integer oMx returns integer
local integer oqx=LYo(GetObjectName(oMx))
set B[oqx]=oMx
call SaveInteger(o[((V[(E[((X))])]))],(((oMx))),(((mv))),(((oqx))))
return oqx
endfunction
function LZo takes integer oqx,integer oQx,real oSx returns nothing
call SaveReal(o[((V[(E[((NH[(oqx)]))])]))],((((Ev[((oqx))])))),(((oQx))),((((((oSx)*1.))*1.))*1.))
endfunction
function L_o takes nothing returns boolean
call LZx('AVia',false)
set lZv=Lzo('AVia')
set G6[(lZv)]=(d6)
set j6[(lZv)]=(1)
set sH[(lZv)]=("Eternal Vial")
set Ih[(lZv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Oj))))))
set x6v[(lZv)]=(0)
set xzv[(lZv)]=("spell")
call LZo((lZv),fH+(1),((60)*1.))
call LZo((lZv),Lvv+(1),((750)*1.))
return true
endfunction
function L0o takes integer oqx returns integer
set Lav[oqx]=true
set Lnv[oqx]=false
set JS[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set Qh[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(Vt)
return oqx
endfunction
function L1o takes nothing returns integer
local integer oqx
if(Lxv==8190)then
call oYx("ItemType_Allocation_allocCustom","call DebugEx(ItemType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Et+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Lov[(w)]==w)then
set Lrv=Lrv+1
set oqx=Lrv
else
set oqx=Lov[(w)]
set Lov[(w)]=Lov[Lov[(w)]]
endif
set Lov[oqx]=Z
set Liv[oqx]=1
call L0o(oqx)
return oqx
endfunction
function L2o takes integer oqx returns nothing
set ph[(oqx)]=(LVv+oqx)
endfunction
function L3o takes integer oMx returns integer
local integer oqx=L1o()
set Hh[oqx]=oMx
call SaveInteger(o[((V[(E[((X))])]))],(((oMx))),(((jS))),(((oqx))))
call L2o(oqx)
set MS[((oqx))]=(0)
set Fh[((oqx))]=(0)
return oqx
endfunction
function L4o takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(JS[(oqx)],(ph[((oqx))]),oQx,oSx)
endfunction
function L5o takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((JS[(oqx)]))])]))],((((ph[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function L6o takes integer oqx,integer rJx,integer rwx returns nothing
call L4o((oqx),kS,rJx)
call L5o((oqx),lS+rJx,rwx)
endfunction
function L7o takes nothing returns boolean
set Lev=L3o('IVia')
set LEv[(Lev)]=("ReplaceableTextures\\CommandButtons\\BTNVialFull.blp")
set Fh[(Lev)]=(50)
call L6o((Lev),(lZv),1)
return true
endfunction
function L8o takes nothing returns boolean
call VRx(qa,(function L_o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\EternalVial.page\\EternalVial.struct\\obj_thisSpell_wc3spell.j"))
call VRx(sa,(function L7o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\EternalVial.page\\EternalVial.struct\\obj_thisItem_wc3item.j"))
return true
endfunction
function L9o takes nothing returns boolean
set LXv=Vnx(LOv)
return true
endfunction
function mvo takes code c,string rqx returns nothing
set fn=fn+1
set Fn[fn]=CreateTrigger()
set gn[fn]=(GetHandleId(Condition((c))))
set Gn[fn]=rqx
call TriggerAddCondition(Fn[fn],Condition(c))
endfunction
function meo takes integer oqx,integer Xwx returns nothing
if(Hv[oqx]==w)then
call oYx("FolderSpell_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oqx)+";"+(JA[(Xwx)]))
set Hv[oqx]=X
endif
call rSx(Hv[oqx],(Ev[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function mxo takes integer oqx,integer Ixx,real nyx returns nothing
local integer ndo=rEx((A[(Ixx)]))
local integer olx
local integer rIx
local integer rlx
set LNv[(ndo)]=((nyx)*1.)
set Vv[(ndo)]=(Ixx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(Ixx,BAv,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(Ixx,BAv,rIx,rlx),ndo)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((ndo)))
endfunction
function moo takes integer oqx,integer Ixx,real nyx returns nothing
local integer LJo
if(nyx<1.)then
return
endif
set nyx=nyx*nAo(-(ZF[(oqx)]))*(Iqv[(Ixx)])*(GetRandomReal(((.9)*1.),((1.1)*1.)))
set LJo=LHo(Ixx,LAv+Ixx,nyx)
call X6x(LJo,iqx("+"+(I2S(((R2I((((fN[(LJo)]))*1.)))))),"ff00c800"),.02)
call cGx(Ixx,nyx)
call mxo(oqx,Ixx,nyx)
endfunction
function mro takes integer oqx,integer Ixx,real nyx returns nothing
local integer LJo
if(nyx<1.)then
return
endif
set LJo=LHo(Ixx,LBv+Ixx,nyx)
call X6x(LJo,iqx("+"+(I2S(((R2I((((fN[(LJo)]))*1.)))))),"ffaa55ff"),.02)
call BRx(Ixx,nyx)
endfunction
function mio takes integer oqx,integer Ixx,real nyx returns nothing
local integer LJo
if(nyx<1.)then
return
endif
set LJo=LHo(Ixx,LCv+Ixx,nyx)
call X6x(LJo,iqx("+"+(I2S(((R2I((((fN[(LJo)]))*1.)))))),"ffffff00"),.02)
call Ico(Ixx,nyx)
endfunction
function mao takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
call RUx((Abx((CMx),(LRv),(LIv),(ri))))
call moo(CMx,CMx,Lbv*(iG[(CMx)]))
call mro(CMx,CMx,Lcv*(mF[(CMx)]))
call mio(CMx,CMx,Ldv*(Nqv[(CMx)]))
return true
endfunction
function mno takes nothing returns boolean
call meo(lZv,XBx("EternalVial_Init: call EternalVial.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function EternalVial.Event_SpellEffect))",ah,lI,function mao))
return true
endfunction
function mVo takes nothing returns boolean
call mvo(function mno,"EternalVial_Init")
return true
endfunction
function mEo takes nothing returns boolean
return true
endfunction
function mXo takes nothing returns boolean
set LDv=Vnx(Lfv)
return true
endfunction
function mOo takes integer oqx,integer Xwx returns nothing
if(Am[oqx]==w)then
call oYx("FolderDestructable_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oqx)+";"+(JA[(Xwx)]))
set Am[oqx]=X
endif
call rSx(Am[oqx],(Rm[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function mRo takes nothing returns boolean
local integer rdx=(bv)
call mOo((Im[(rdx)]),Lgv)
return true
endfunction
function mIo takes integer oqx returns integer
set LJv[oqx]=true
set Lkv[oqx]=false
call rax(LDv)
return oqx
endfunction
function mAo takes nothing returns integer
local integer oqx
if(LGv==8190)then
call oYx("Explosive_Allocation_allocCustom","call DebugEx(Explosive.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Lfv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Lhv[(w)]==w)then
set LHv=LHv+1
set oqx=LHv
else
set oqx=Lhv[(w)]
set Lhv[(w)]=Lhv[Lhv[(w)]]
endif
set Lhv[oqx]=Z
set Ljv[oqx]=1
call mIo(oqx)
return oqx
endfunction
function mNo takes integer oqx returns nothing
set LJv[oqx]=false
call rgx(LDv)
endfunction
function mbo takes integer oqx returns nothing
if(Ljv[oqx]>0)then
return
endif
if(Lhv[oqx]!=Z)then
call oYx("Explosive_Allocation_deallocCustom_confirm","call DebugEx(Explosive.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Lfv+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set Lhv[oqx]=Lhv[(w)]
set Lhv[(w)]=oqx
call mNo(oqx)
endfunction
function mBo takes integer oqx returns nothing
set Ljv[oqx]=Ljv[oqx]-1
call mbo(oqx)
endfunction
function mco takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((LPv[oqx]))])])],((((Lqv[((oqx))])))))
endfunction
function mCo takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((LQv[oqx]))])])],((((Lqv[((oqx))])))))
endfunction
function mdo takes integer oqx returns nothing
set Lpv[oqx]=false
call mco((oqx))
call mCo(((oqx)))
call rgx(Hp)
endfunction
function mDo takes integer oqx returns nothing
if(Lmv[oqx]>0)then
return
endif
if(LMv[oqx]!=Z)then
call oYx("SpotEffect_Allocation_deallocCustom_confirm","call DebugEx(SpotEffect.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",jp+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set LMv[oqx]=LMv[(w)]
set LMv[(w)]=oqx
call mdo(oqx)
endfunction
function mfo takes integer oqx returns nothing
set Lmv[oqx]=Lmv[oqx]-1
call mDo(oqx)
endfunction
function mFo takes integer oqx returns nothing
local effect oMx=LLv[oqx]
call mfo((oqx))
if(oMx!=null)then
call DestroyEffect(oMx)
set oMx=null
endif
endfunction
function mgo takes integer oqx returns integer
set Lpv[oqx]=true
set Ltv[oqx]=false
set LPv[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set LQv[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(Hp)
return oqx
endfunction
function mGo takes nothing returns integer
local integer oqx
if(Lsv==8190)then
call oYx("SpotEffect_Allocation_allocCustom","call DebugEx(SpotEffect.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",jp+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(LMv[(w)]==w)then
set LSv=LSv+1
set oqx=LSv
else
set oqx=LMv[(w)]
set LMv[(w)]=LMv[LMv[(w)]]
endif
set LMv[oqx]=Z
set Lmv[oqx]=1
call mgo(oqx)
return oqx
endfunction
function mho takes integer oqx returns nothing
set LLv[oqx]=AddSpecialEffect(iQx(ci>=LTv[oqx],Luv[oqx]),LUv[oqx],Lwv[oqx])
endfunction
function mHo takes real x,real y,string ARx,integer rwx returns integer
local integer oqx=mGo()
set LTv[oqx]=rwx
set Luv[oqx]=ARx
set LUv[oqx]=x
set Lwv[oqx]=y
call mho(oqx)
return oqx
endfunction
function mjo takes integer oqx,real x,real y returns integer
local integer Xko=Nao((oqx))
local real mJo
local integer NEo
local boolean mko
local real mKo
if(Xko==w)then
return w
endif
set mko=false
loop
set mKo=Gyx(DPx(Xko)-x,DQx(Xko)-y)
call GroupAddUnit(Kb[(yQ)],C[(Xko)])
if not mko then
set mJo=mKo
set NEo=Xko
set mko=true
elseif(mKo<mJo)then
set mJo=mKo
set NEo=Xko
endif
set Xko=Nao((oqx))
exitwhen(Xko==w)
endloop
call Nno((oqx),yQ)
return NEo
endfunction
function mlo takes real x,real y,real O1o,code Xbx returns nothing
call SetRect(bm[(lm)],((x-O1o)*1.),((y-O1o)*1.),((x+O1o)*1.),((y+O1o)*1.))
set gf=x
set Gf=y
set hf=O1o*O1o
call EnumDestructablesInRect(bm[lm],Bv[Zm],Xbx)
endfunction
function mLo takes integer oqx,real oSx returns nothing
call SetDestructableLife(Gm[((oqx))],(((GetDestructableLife(Gm[((oqx))]))-oSx)*1.))
endfunction
function mmo takes nothing returns boolean
local integer rdx=(bv)
call mLo((Gfx(GetEnumDestructable())),200.)
return true
endfunction
function mMo takes nothing returns nothing
local integer OHx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(OHx)])
local integer Ixx
local real mpo
local real NIo
call mBo((oqx))
call ijx(OHx)
call mFo((mHo(((LKv[oqx])*1.),((Llv[oqx])*1.),(LWv),(ri))))
call Nio(Lyv,LKv[oqx],Llv[oqx],300.,LYv)
set Ixx=(mjo((Lyv),((LKv[oqx])*1.),((Llv[oqx])*1.)))
if(Ixx!=w)then
set mpo=900.
loop
exitwhen(mpo==0)
set NIo=itx(200.,(rG[(Ixx)]))
call GroupRemoveUnit(Kb[(Lyv)],C[(Ixx)])
set mpo=mpo-NIo
call nDo(Ixx,NIo)
set Ixx=(mjo((Lyv),((LKv[oqx])*1.),((Llv[oqx])*1.)))
exitwhen(Ixx==w)
endloop
endif
call mlo(LKv[oqx],Llv[oqx],300.,function mmo)
endfunction
function mPo takes nothing returns boolean
local integer rdx=(bv)
local integer mqo=(Im[(rdx)])
local integer oqx=mAo()
local integer OHx=inx()
local real x=(hm[(mqo)])
local real y=(Hm[(mqo)])
set LKv[oqx]=x
set Llv[oqx]=y
set ge[(OHx)]=(oqx)
call G4x(mqo,Lgv)
call icx(OHx,.35,false,function mMo)
return true
endfunction
function mQo takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if nBo(Ixx)then
return false
endif
return true
return true
endfunction
function mso takes integer oqx,integer Xwx returns nothing
if(fL[oqx]==w)then
call oYx("FolderDestructableType_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oqx)+";"+(JA[(Xwx)]))
set fL[oqx]=X
endif
call rSx(fL[oqx],(HL[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function mSo takes nothing returns boolean
set LFv=XBx("Explosive_Init: set Explosive.CREATE_EVENT = Event.Create(Destructable.CREATE_EVENT_TYPE, EventPriority.MISC, function Explosive.Event_Create)",Vm,LI,function mRo)
set Lgv=XBx("Explosive_Init: set Explosive.DEATH_EVENT = Event.Create(Destructable.DEATH_EVENT_TYPE, EventPriority.MISC, function Explosive.Event_Death)",Em,LI,function mPo)
set Lyv=O2x()
set LYv=XLx(function mQo)
call mso(JL,LFv)
call mso(IL,LFv)
return true
endfunction
function mto takes nothing returns boolean
call kWo(function mSo,"Explosive_Init")
return true
endfunction
function mTo takes nothing returns boolean
set Lzv=hGo('uGaC')
call hho(((Lzv)),Apv,(ICv))
set Tj[(Lzv)]=((1.5)*1.)
set Nav[(Lzv)]=(('x')*1.)
set Ntv[(Lzv)]=((60)*1.)
set I3v[(Lzv)]=((0)*1.)
set Axv[(Lzv)]=(3)
set NJv[(Lzv)]=((150000.)*1.)
set Njv[(Lzv)]=((150000.)*1.)
set Nhv[(Lzv)]=((0)*1.)
set NIv[(Lzv)]=((500)*1.)
set NOv[(Lzv)]=((500)*1.)
set AQv[(Lzv)]=((0)*1.)
set Asv[(Lzv)]=((0)*1.)
set Auv[(Lzv)]=(0)
set AWv[(Lzv)]=(0)
call hLo((Lzv),(gQv),1)
return true
endfunction
function muo takes nothing returns boolean
call VRx(Sa,(function mTo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\obj_shop_wc3unit.j"))
return true
endfunction
function mUo takes nothing returns boolean
set LZv=Vnx(L_v)
return true
endfunction
function mwo takes nothing returns boolean
set L0v=L3o('IBoS')
set LEv[(L0v)]=("ReplaceableTextures\\CommandButtons\\BTNGolemStormBolt.blp")
call L6o((L0v),(L1v),1)
return true
endfunction
function mWo takes nothing returns boolean
call LZx('ABoS',false)
set L1v=Lzo('ABoS')
set G6[(L1v)]=(d6)
set j6[(L1v)]=(1)
set sH[(L1v)]=("Boomerang Stone")
set Ih[(L1v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0278)))),(((Oj))))))
set x6v[(L1v)]=(4)
set xzv[(L1v)]=("spell")
call LZo((L1v),fH+(1),(($A)*1.))
call LZo((L1v),QH+(1),((50)*1.))
call LZo((L1v),Lvv+(1),((650)*1.))
return true
endfunction
function myo takes nothing returns boolean
call VRx(sa,(function mwo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act1.pack\\BoomerangStone.page\\BoomerangStone.struct\\obj_thisItem_wc3item.j"))
call VRx(qa,(function mWo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act1.pack\\BoomerangStone.page\\BoomerangStone.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function mYo takes nothing returns boolean
set L2v=Vnx(L3v)
return true
endfunction
function mzo takes code c,string rqx returns nothing
set xn=xn+1
set on[xn]=CreateTrigger()
set rn[xn]=(GetHandleId(Condition((c))))
set in[xn]=rqx
call TriggerAddCondition(on[xn],Condition(c))
endfunction
function mZo takes integer oqx returns integer
set L8v[oqx]=true
set L9v[oqx]=false
set mvv[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set yY[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(sY)
return oqx
endfunction
function m_o takes nothing returns integer
local integer oqx
if(L4v==8190)then
call oYx("Missile_Allocation_allocCustom","call DebugEx(Missile.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",SY+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(L5v[(w)]==w)then
set L6v=L6v+1
set oqx=L6v
else
set oqx=L5v[(w)]
set L5v[(w)]=L5v[L5v[(w)]]
endif
set L5v[oqx]=Z
set L7v[oqx]=1
call mZo(oqx)
return oqx
endfunction
function m0o takes integer oqx,real x,real y,real z returns nothing
set mov[oqx]=x
set mrv[oqx]=x*miv
set mav[oqx]=y
set mnv[oqx]=y*miv
set mVv[oqx]=z
set mEv[oqx]=z*miv
endfunction
function m1o takes integer oqx,real oSx returns nothing
set mxv[oqx]=oSx
call m0o(oqx,oSx,.0,.0)
endfunction
function m2o takes integer oqx returns nothing
set mXv[oqx]=.0
set mOv[oqx]=.0
set mRv[oqx]=.0
set mIv[oqx]=.0
set mAv[(oqx)]=((.0)*1.)
endfunction
function m3o takes integer oqx returns nothing
set mbv[oqx]=false
set Xz[oqx]=w
endfunction
function m4o takes integer oqx returns nothing
set YY[(oqx)]=(mcv+oqx)
endfunction
function m5o takes integer oqx returns nothing
set mCv[oqx]=w
set mdv[oqx]=w
endfunction
function m6o takes integer oqx returns nothing
set mDv[oqx]=w
set mfv[oqx]=w
set mFv[((oqx))]=((.0)*1.)
set mgv[((oqx))]=((.0)*1.)
set mGv[((oqx))]=((.0)*1.)
endfunction
function m7o takes integer oqx,real x,real y,real z returns nothing
local real d=ggx(x,y,z)
local real bkx
if mHv[oqx]then
if(d>0)then
if(d<mhv[oqx])then
set bkx=mhv[oqx]
set x=x*1./ d*bkx
set y=y*1./ d*bkx
set z=z*1./ d*bkx
endif
else
set bkx=mhv[oqx]
if(bkx==0)then
set x=.0
set y=.0
set z=.0
else
return
endif
endif
endif
set mJv[oqx]=d
set mkv[oqx]=x
set mKv[oqx]=x*miv
set mlv[oqx]=y
set mLv[oqx]=y*miv
set mmv[oqx]=z
set mMv[oqx]=z*miv
endfunction
function m8o takes integer oqx,real oSx returns nothing
if(oSx<mhv[oqx])then
set oSx=mhv[oqx]
endif
set mJv[oqx]=oSx
call m7o(oqx,oSx,.0,.0)
endfunction
function m9o takes integer oqx returns nothing
set mhv[oqx]=.0
set mHv[oqx]=false
set mjv[oqx]=.0
call m8o(oqx,.0)
endfunction
function Mvo takes nothing returns integer
local integer oqx=m_o()
set mev[oqx]=false
call m1o((oqx),.0)
call m2o(oqx)
set oz[(oqx)]=w
set mNv[((oqx))]=((.0)*1.)
call m3o(oqx)
call m4o(oqx)
call m5o(oqx)
call m6o(oqx)
call m9o(oqx)
return oqx
endfunction
function Meo takes integer oqx returns integer
set msv[oqx]=true
set mSv[oqx]=false
call rax(L2v)
return oqx
endfunction
function Mxo takes nothing returns integer
local integer oqx
if(mpv==8190)then
call oYx("BoomerangStone_Allocation_allocCustom","call DebugEx(BoomerangStone.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",L3v+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(mPv[(w)]==w)then
set mqv=mqv+1
set oqx=mqv
else
set oqx=mPv[(w)]
set mPv[(w)]=mPv[mPv[(w)]]
endif
set mPv[oqx]=Z
set mQv[oqx]=1
call Meo(oqx)
return oqx
endfunction
function Moo takes integer oqx returns real
return(Atan2((((mUv[(oqx)]))*1.),(((mwv[(oqx)]))*1.)))
endfunction
function Mro takes integer oqx,integer id,real D7x returns integer
local real Mio
local integer oSx
if mbv[oqx]then
set Mio=muv[oqx]
else
set Mio=Moo((oqx))
endif
set oSx=mcx(id,(mFv[((oqx))]),(mgv[((oqx))]),(mGv[((oqx))]),Mio)
call Mox(oqx,oSx)
call mbx(oSx,D7x)
return oSx
endfunction
function Mao takes integer Ixx returns boolean
return( not(I6x(Ixx,sc)))and( not(I6x(Ixx,ICv)))and( not(nBo(Ixx)))and( not(IsUnitAlly(C[(Ixx)],vx[(Hf)])))
endfunction
function Mno takes integer oqx returns nothing
set msv[oqx]=false
call rgx(L2v)
endfunction
function MVo takes integer oqx returns nothing
if(mQv[oqx]>0)then
return
endif
if(mPv[oqx]!=Z)then
call oYx("BoomerangStone_Allocation_deallocCustom_confirm","call DebugEx(BoomerangStone.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",L3v+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set mPv[oqx]=mPv[(w)]
set mPv[(w)]=oqx
call Mno(oqx)
endfunction
function MEo takes integer oqx returns nothing
set mQv[oqx]=mQv[oqx]-1
call MVo(oqx)
endfunction
function MXo takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((yY[oqx]))])]))],((((YY[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function MOo takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((yY[oqx]))])]))],((((YY[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function MRo takes integer oqx returns nothing
local integer rdx=rEx((YY[(oqx)]))
local integer olx
local integer rIx
local integer rlx
set WY[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=MXo(oqx,TY,rIx)
loop
exitwhen(rlx<q)
call rCx(MOo(oqx,TY,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function MIo takes integer oqx returns nothing
if mev[oqx]then
set mev[oqx]=false
call MRo(oqx)
endif
endfunction
function MAo takes integer oqx returns nothing
local integer rdx=rEx((YY[(oqx)]))
local integer olx
local integer rIx
local integer rlx
set WY[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=MXo(oqx,tY,rIx)
loop
exitwhen(rlx<q)
call rCx(MOo(oqx,tY,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function MNo takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((mvv[oqx]))])])],((((YY[((oqx))])))))
endfunction
function Mbo takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((yY[oqx]))])])],((((YY[((oqx))])))))
endfunction
function MBo takes integer oqx returns nothing
set L8v[oqx]=false
call MNo((oqx))
call Mbo(((oqx)))
call rgx(sY)
endfunction
function Mco takes integer oqx returns nothing
if(L7v[oqx]>0)then
return
endif
if(L5v[oqx]!=Z)then
call oYx("Missile_Allocation_deallocCustom_confirm","call DebugEx(Missile.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",SY+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set L5v[oqx]=L5v[(w)]
set L5v[(w)]=oqx
call MBo(oqx)
endfunction
function MCo takes integer oqx returns nothing
set L7v[oqx]=L7v[oqx]-1
call Mco(oqx)
endfunction
function Mdo takes integer oqx returns nothing
call MIo(oqx)
call MAo(oqx)
call MCo((oqx))
endfunction
function MDo takes integer CMx returns boolean
return( not(I6x(CMx,sc)))
endfunction
function Mfo takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=mtv[oqx]
call MEo((oqx))
call Mdo(MFo)
if MDo(CMx)then
endif
return true
endfunction
function Mgo takes integer oqx,real dix,real dax,real Mpx returns nothing
if mev[oqx]then
call MIo(oqx)
endif
set mev[oqx]=true
set mzv[(oqx)]=((dix)*1.)
set mZv[(oqx)]=((dax)*1.)
set m_v[(oqx)]=((Mpx)*1.)
endfunction
function MGo takes integer oqx returns real
return jjx((mFv[(oqx)])-(mzv[(oqx)]),(mgv[(oqx)])-(mZv[(oqx)]))
endfunction
function Mho takes integer oqx returns nothing
local real Njx=MGo((oqx))
local real NJx=(mkv[((oqx))])
local real ilx=NHx(Njx,NJx,(mov[((oqx))]))
local real Nkx
if(ilx==.0)then
set mXv[oqx]=.0
set mOv[oqx]=.0
set mRv[oqx]=.0
set mIv[oqx]=.0
set m1v[oqx]=(mFv[((oqx))])
set m2v[oqx]=(mgv[((oqx))])
return
endif
set mOv[oqx]=Njx
set Njx=Njx*(Tan((((((mAv[(oqx)]))*1.))*1.)))
set NJx=Njx*1./ ilx
set Nkx=-2*NJx*1./ ilx
set mXv[oqx]=Nkx
set mRv[oqx]=ilx
set mIv[oqx]=NJx
set m1v[oqx]=(mFv[((oqx))])
set m2v[oqx]=(mgv[((oqx))])
endfunction
function MHo takes integer oqx returns boolean
if((lz[((oqx))])>0)then
return false
endif
set mz=mz+1
set Lz[mz]=oqx
set lz[oqx]=mz+1
return(mz==0)
endfunction
function Mjo takes nothing returns nothing
local integer olx=mz
loop
exitwhen(olx<0)
set m3v[olx]=Lz[olx]
set olx=olx-1
endloop
set m4v=mz
endfunction
function MJo takes nothing returns integer
local integer o4x
if(m4v<0)then
return w
endif
set o4x=m3v[0]
set m3v[0]=m3v[m4v]
set m4v=m4v-1
return o4x
endfunction
function Mko takes integer oqx,real x,real y,real z returns nothing
call Dpx(oqx,x)
call Dqx(oqx,y)
call mAx(oqx,x,y,z)
endfunction
function MKo takes integer oqx returns real
local real Njx=jjx((mzv[((oqx))])-m1v[oqx],(mZv[((oqx))])-m2v[oqx])
local real ilx
local real Mlo
local real MLo
if(Njx==.0)then
return .0
endif
set ilx=mRv[oqx]
if(ilx==.0)then
return .0
endif
set Mlo=bJx(jjx((mFv[((oqx))])-m1v[oqx],(mgv[((oqx))])-m2v[oqx])*1./ Njx,0,1)
set MLo=(1-Mlo)*ilx
return((mXv[oqx]*1./ 2)*MLo*MLo+mIv[oqx]*MLo)
endfunction
function Mmo takes integer oqx,real x,real y,real z returns nothing
set Rd=oqx
set m8v=x
set m9v=y
set Mvv=z
call TriggerEvaluate(Mev)
endfunction
function MMo takes integer oqx,boolean Omx returns real
if Omx then
return(Nrv[oqx]*(ob[((oqx))]))
endif
return Nrv[oqx]
endfunction
function Mpo takes integer oqx,boolean Omx returns real
if Omx then
return(Niv[oqx]*(ob[((oqx))]))
endif
return Niv[oqx]
endfunction
function MPo takes integer oqx,integer Ixx,real C6x,real C7x,real Mqo returns nothing
call Mmo(oqx,DPx(Ixx)+MMo(Ixx,true)+C6x,DQx(Ixx)+Mpo(Ixx,true)+C7x,fwx(Ixx)+K_x(Ixx,true)+Mqo)
endfunction
function MQo takes integer oqx,integer Ixx returns nothing
call MPo(oqx,Ixx,.0,.0,.0)
endfunction
function Mso takes integer oqx,integer Ixx returns nothing
local integer MSo=mdv[oqx]
local integer rdx=rEx((YY[((oqx))]))
set mdv[oqx]=w
call MQo((oqx),Ixx)
set mdv[oqx]=MSo
set WY[(rdx)]=(oqx)
set Vv[(rdx)]=(Ixx)
set bv=(rdx)
call rcx(mCv[oqx])
call rHx(((rdx)))
endfunction
function Mto takes integer oqx,real x,real y,real z returns nothing
local integer HOx=(Xz[((oqx))])
local integer MTo=(mdv[((oqx))])
local integer Muo
local integer rdx
set mFv[(oqx)]=((x)*1.)
set mgv[(oqx)]=((y)*1.)
set mGv[(oqx)]=((z)*1.)
if(HOx!=w)then
call Mko(HOx,x,y,z+MKo((oqx)))
endif
if(MTo!=w)then
set rdx=rEx(0)
set WY[(rdx)]=(oqx)
set bv=(rdx)
call Nio(uz,x,y,(mNv[((oqx))]),MTo)
call rHx(((rdx)))
set Muo=(aBx(FirstOfGroup(Kb[(uz)])))
if(Muo!=w)then
call Mso((oqx),Muo)
endif
endif
if(mfv[oqx]!=w)then
set rdx=rEx(0)
set WY[(rdx)]=(oqx)
set bv=(rdx)
call Nio(uz,x,y,(mNv[((oqx))]),mfv[oqx])
set Muo=Nao(uz)
if(Muo!=w)then
loop
set bv=(rdx)
set Vv[(rdx)]=(Muo)
call rcx(mDv[oqx])
set Muo=Nao(uz)
exitwhen(Muo==w)
endloop
endif
call rHx(((rdx)))
endif
endfunction
function MUo takes integer oqx,real x,real y,real z returns nothing
local integer MSo=mdv[oqx]
local integer rdx=rEx((YY[((oqx))]))
set mdv[oqx]=w
call Mto((oqx),x,y,z)
set mdv[oqx]=MSo
set WY[(rdx)]=(oqx)
set Vv[(rdx)]=(w)
set bv=(rdx)
call rcx(mCv[oqx])
call rHx(((rdx)))
endfunction
function Mwo takes integer oqx,integer MWo returns nothing
local integer rdx=rEx((YY[((oqx))]))
local integer olx
local integer rIx
local integer rlx
set WY[(rdx)]=(oqx)
set hz[(rdx)]=(MWo)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=MXo((oqx),UY,rIx)
loop
exitwhen(rlx<q)
call rCx(MOo((oqx),UY,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function Myo takes integer oqx returns nothing
local integer o2x=(Xz[(oqx)])
if(o2x!=w)then
if mbv[oqx]then
else
call mRx(o2x,Moo((oqx)))
endif
endif
endfunction
function MYo takes integer oqx,real dX,real dY,real dZ returns nothing
local real d=ggx(dX,dY,dZ)
set mwv[(oqx)]=((dX*1./ d)*1.)
set mUv[(oqx)]=((dY*1./ d)*1.)
set Mxv[(oqx)]=((dZ*1./ d)*1.)
call Myo((oqx))
endfunction
function Mzo takes integer oqx,real x,real y,real z returns nothing
call m7o(oqx,(mkv[(oqx)])+x,(mlv[(oqx)])+y,(mmv[(oqx)])+z)
endfunction
function MZo takes integer oqx,real x,real y,real z returns nothing
call Mto(oqx,(mFv[(oqx)])+x,(mgv[(oqx)])+y,(mGv[(oqx)])+z)
endfunction
function M_o takes nothing returns nothing
local integer oqx
local integer M0o
local real M1o
local real M2o
local real Okx
local real x
local real y
local real z
local integer Ixx
local real dix
local real dax
local real Mpx
local real dX
local real dY
local real dZ
local real d
call Mjo()
loop
set oqx=MJo()
exitwhen(oqx==w)
set M0o=Gz[oqx]
set M1o=(mKv[((oqx))])
set M2o=(mLv[((oqx))])
set Okx=(mMv[((oqx))])
set x=(mFv[((oqx))])
set y=(mgv[((oqx))])
set z=(mGv[((oqx))])
set Ixx=pz[oqx]
if(M0o!=w)then
set dix=(m5v[(M0o)])
set dax=(m6v[(M0o)])
set Mpx=(m7v[(M0o)])
elseif(Ixx==w)then
set dix=Pz[oqx]
set dax=Qz[oqx]
set Mpx=Sz[oqx]
else
set dix=DPx(Ixx)+qz[oqx]
set dax=DQx(Ixx)+sz[oqx]
set Mpx=Olx(Ixx,dix,dax)+K_x(Ixx,true)+tz[oqx]
endif
set dX=dix-x
set dY=dax-y
set dZ=Mpx-z
set d=ggx(dX,dY,dZ)
if(d<M1o+(mNv[((oqx))]))then
if(M0o==w)then
call Mlx(oqx,Ixx)
if(Ixx==w)then
call MUo((oqx),dix,dax,Mpx)
else
call Mso((oqx),Ixx)
endif
else
set Gz[oqx]=(pjx(oz[((oqx))],(M0o)))
call Mwo(((oqx)),(M0o))
endif
else
set dX=dX*1./ d
set dY=dY*1./ d
set dZ=dZ*1./ d
call MYo((oqx),dX,dY,dZ)
call Mzo((oqx),(mrv[((oqx))]),(mnv[((oqx))]),(mEv[((oqx))]))
call MZo((oqx),M1o*dX,M1o*dY,M1o*dZ)
endif
endloop
endfunction
function M3o takes integer oqx,integer Ixx,real C6x,real C7x,real Mqo,code M4o returns nothing
call Mgo((oqx),DPx(Ixx)+C6x,DQx(Ixx)+C7x,fwx(Ixx)+K_x(Ixx,true)+Mqo)
set m0v[oqx]=m0v[oqx]
set Gz[oqx]=(zY[(oz[((oqx))])])
set qz[oqx]=C6x
set sz[oqx]=C7x
set tz[oqx]=Mqo
set pz[oqx]=Ixx
set Tz[oqx]=XHx(M4o)
if rtx(Ixx,Jz,oqx)then
call I7x(Ixx,kz)
call I7x(Ixx,Kz)
call AYo(Ixx)
endif
call Mvx((oqx),gz)
call Mvx((oqx),Hz)
call Mho((oqx))
if MHo(oqx)then
call icx(Mz,miv,true,function M_o)
endif
endfunction
function M5o takes nothing returns boolean
local integer rdx=(bv)
call Mdo((WY[(rdx)]))
return true
endfunction
function M6o takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=mtv[oqx]
local integer Ixx=mTv[oqx]
set Hf=(ze[(CMx)])
if Mao(Ixx)then
call NIx((Ixx),(Xsv),(1),w,((myv)*1.))
call nJo((CMx),(Ixx),((mYv)*1.),(false),(false))
endif
set mCv[(MFo)]=XHx((function Mfo))
call m8o(MFo,1100.)
call M3o((MFo),(CMx),.0,.0,.0,(function M5o))
call KFx(CMx)
return true
endfunction
function M7o takes integer oqx,boolean Omx returns real
if Omx then
return(Nsv[oqx]*(ob[((oqx))]))
endif
return Nsv[oqx]
endfunction
function M8o takes integer oqx,boolean Omx returns real
if Omx then
return(NSv[oqx]*(ob[((oqx))]))
endif
return NSv[oqx]
endfunction
function M9o takes integer oqx,integer ozx returns nothing
local real N8x=Ufx(ozx)
local real pMx=M7o(ozx,true)
local real oUx=M8o(ozx,true)
local real x=DPx(ozx)+oUx*(Cos(((((N8x)*1.))*1.)))+pMx*(Cos(((((N8x-b6v)*1.))*1.)))
local real y=DQx(ozx)+oUx*(Sin(((((N8x)*1.))*1.)))+pMx*(Sin(((((N8x-b6v)*1.))*1.)))
local real z=fwx(ozx)+OLx(ozx,true)
call Mto(oqx,x,y,z)
endfunction
function pvo takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer MFo=Mvo()
local integer Ixx=(WH[(rdx)])
local integer oqx=Mxo()
set mtv[oqx]=CMx
set mTv[oqx]=Ixx
call AYo(CMx)
set mNv[(MFo)]=((10.)*1.)
call Mro(MFo,'qBoS',2.)
set mCv[(MFo)]=XHx((function M6o))
set mWv[(MFo)]=(oqx)
call m8o(MFo,1250.)
call M9o(MFo,CMx)
call M3o((MFo),(Ixx),.0,.0,.0,(function M5o))
return true
endfunction
function peo takes nothing returns boolean
call meo(L1v,XBx("BoomerangStone_Init: call BoomerangStone.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BoomerangStone.Event_SpellEffect))",ah,pI,function pvo))
return true
endfunction
function pxo takes nothing returns boolean
call mzo(function peo,"BoomerangStone_Init")
return true
endfunction
function poo takes nothing returns boolean
set Mov=L3o('IMal')
set LEv[(Mov)]=("ReplaceableTextures\\CommandButtons\\BTNHammer.blp")
return true
endfunction
function pro takes nothing returns boolean
call VRx(sa,(function poo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act1.pack\\Mallet.page\\Mallet.struct\\obj_thisItem_wc3item.j"))
return true
endfunction
function pio takes nothing returns boolean
set Mrv=Vnx(Miv)
return true
endfunction
function pao takes integer oqx,integer Xwx returns nothing
if(Qh[oqx]==w)then
call oYx("FolderItemType_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oqx)+";"+(JA[(Xwx)]))
set Qh[oqx]=X
endif
call rSx(Qh[oqx],(ph[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function pno takes integer oqx,real oSx returns nothing
call cUx(oqx,(kg[(oqx)])-oSx)
endfunction
function pVo takes integer oqx,real oSx returns nothing
set vh[oqx]=oSx
call c2x((oqx))
endfunction
function pEo takes integer oqx,real oSx returns nothing
call pVo(oqx,(vh[(oqx)])-oSx)
endfunction
function pXo takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call pno(Oqx,12.)
call pEo(Oqx,4.)
return true
endfunction
function pOo takes integer oqx,real oSx returns nothing
call pVo(oqx,(vh[(oqx)])+oSx)
endfunction
function pRo takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call cwx(Oqx,12.)
call pOo(Oqx,4.)
return true
endfunction
function pIo takes nothing returns boolean
call pao(Mov,XBx("Mallet_Init: call Mallet.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function Mallet.Event_Drop))",DNv,lI,function pXo))
call pao(Mov,XBx("Mallet_Init: call Mallet.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function Mallet.Event_PickUp))",DXv,lI,function pRo))
return true
endfunction
function pAo takes nothing returns boolean
call mzo(function pIo,"Mallet_Init")
return true
endfunction
function pNo takes nothing returns boolean
call LZx('APeF',false)
set Mav=Lzo('APeF')
set G6[(Mav)]=(d6)
set j6[(Mav)]=(1)
set sH[(Mav)]=("Penguin Feather")
set Ih[(Mav)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0278)))),(((Oj))))))
set x6v[(Mav)]=(4)
set xzv[(Mav)]=("spell")
call LZo((Mav),fH+(1),(($C)*1.))
call LZo((Mav),QH+(1),((60)*1.))
call LZo((Mav),Lvv+(1),((725)*1.))
set Mnv[(Mav)]=("ReplaceableTextures\\CommandButtons\\BTNEtherealFormOn.blp")
return true
endfunction
function pbo takes nothing returns boolean
set MVv=L3o('IPeF')
set LEv[(MVv)]=("ReplaceableTextures\\CommandButtons\\BTNPenguin.blp")
call L6o((MVv),(Mav),1)
return true
endfunction
function pBo takes nothing returns boolean
call VRx(qa,(function pNo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act1.pack\\PenguinFeather.page\\PenguinFeather.struct\\obj_thisSpell_wc3spell.j"))
call VRx(sa,(function pbo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act1.pack\\PenguinFeather.page\\PenguinFeather.struct\\obj_thisItem_wc3item.j"))
return true
endfunction
function pco takes nothing returns boolean
set MEv=Vnx(MXv)
return true
endfunction
function pCo takes integer oqx,real oSx returns nothing
call bMx(oqx,(oF[(oqx)])-oSx)
endfunction
function pdo takes integer oqx,real oSx returns nothing
set Ng[oqx]=oSx
call BWx((oqx))
endfunction
function pDo takes integer oqx,real oSx returns nothing
call pdo(oqx,(Ng[(oqx)])-oSx)
endfunction
function pfo takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call pCo(Oqx,MOv)
call pDo(Oqx,MRv)
return true
endfunction
function pFo takes integer oqx,real oSx returns nothing
call pdo(oqx,(Ng[(oqx)])+oSx)
endfunction
function pgo takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call bpx(Oqx,MOv)
call pFo(Oqx,MRv)
return true
endfunction
function pGo takes integer oqx returns integer
set MBv[oqx]=true
set Mcv[oqx]=false
call rax(Sp)
return oqx
endfunction
function pho takes nothing returns integer
local integer oqx
if(MIv==8190)then
call oYx("FolderUnitEffect_StructDestroyTimed_Allocation_allocCustom","call DebugEx(FolderUnitEffect_StructDestroyTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",tp+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(MAv[(w)]==w)then
set MNv=MNv+1
set oqx=MNv
else
set oqx=MAv[(w)]
set MAv[(w)]=MAv[MAv[(w)]]
endif
set MAv[oqx]=Z
set Mbv[oqx]=1
call pGo(oqx)
return oqx
endfunction
function pHo takes integer oqx returns nothing
set MBv[oqx]=false
call rgx(Sp)
endfunction
function pjo takes integer oqx returns nothing
if(Mbv[oqx]>0)then
return
endif
if(MAv[oqx]!=Z)then
call oYx("FolderUnitEffect_StructDestroyTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderUnitEffect_StructDestroyTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",tp+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set MAv[oqx]=MAv[(w)]
set MAv[(w)]=oqx
call pHo(oqx)
endfunction
function pJo takes integer oqx returns nothing
set Mbv[oqx]=Mbv[oqx]-1
call pjo(oqx)
endfunction
function pko takes nothing returns nothing
local integer ibx=ifx()
local integer oqx=(ge[(ibx)])
local integer rkx=MCv[oqx]
call pJo((oqx))
call ijx(ibx)
call RUx(rkx)
endfunction
function pKo takes integer oqx,real ilx returns nothing
local integer rkx=oqx
local integer ibx
set oqx=pho()
set ibx=inx()
set MCv[oqx]=rkx
set ge[(ibx)]=(oqx)
call icx(ibx,ilx,false,function pko)
endfunction
function plo takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer Ixx=(WH[(rdx)])
call pKo((Abx((Ixx),(Mdv),(MDv),(Bi))),2.)
call moo(CMx,Ixx,Mfv)
return true
endfunction
function pLo takes nothing returns boolean
call pao(MVv,XBx("PenguinFeather_Init: call PenguinFeather.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function PenguinFeather.Event_Drop))",DNv,lI,function pfo))
call pao(MVv,XBx("PenguinFeather_Init: call PenguinFeather.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function PenguinFeather.Event_PickUp))",DXv,lI,function pgo))
call meo(Mav,XBx("PenguinFeather_Init: call PenguinFeather.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function PenguinFeather.Event_SpellEffect))",ah,pI,function plo))
return true
endfunction
function pmo takes nothing returns boolean
call mzo(function pLo,"PenguinFeather_Init")
return true
endfunction
function pMo takes nothing returns boolean
set MFv=L3o('IRaF')
set LEv[(MFv)]=("ReplaceableTextures\\CommandButtons\\BTNAdvancedStrengthOfTheWild.blp")
return true
endfunction
function ppo takes nothing returns boolean
call VRx(sa,(function pMo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act1.pack\\RabbitsFoot.page\\RabbitsFoot.struct\\obj_thisItem_wc3item.j"))
return true
endfunction
function pPo takes nothing returns boolean
set Mgv=Vnx(MGv)
return true
endfunction
function pqo takes integer oqx,real oSx returns nothing
call blx(oqx,(vF[(oqx)])-oSx)
endfunction
function pQo takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call oYx("RabbitsFoot_Event_Drop","call DebugEx(\"drop\")","drop")
call pqo(Oqx,.2)
call pCo(Oqx,.25)
return true
endfunction
function pso takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call oYx("RabbitsFoot_Event_PickUp","call DebugEx(\"pickup\")","pickup")
call bLx(Oqx,.2)
call bpx(Oqx,.25)
return true
endfunction
function pSo takes nothing returns boolean
call pao(MFv,XBx("RabbitsFoot_Init: call RabbitsFoot.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function RabbitsFoot.Event_Drop))",DNv,lI,function pQo))
call pao(MFv,XBx("RabbitsFoot_Init: call RabbitsFoot.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function RabbitsFoot.Event_PickUp))",DXv,lI,function pso))
return true
endfunction
function pto takes nothing returns boolean
call mzo(function pSo,"RabbitsFoot_Init")
return true
endfunction
function pTo takes nothing returns boolean
set Mhv=L3o('IRaS')
set LEv[(Mhv)]=("ReplaceableTextures\\CommandButtons\\BTNNatureTouchGrow.blp")
return true
endfunction
function puo takes nothing returns boolean
call VRx(sa,(function pTo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act1.pack\\RamblersStick.page\\RamblersStick.struct\\obj_thisItem_wc3item.j"))
return true
endfunction
function pUo takes nothing returns boolean
set MHv=Vnx(Mjv)
return true
endfunction
function pwo takes integer oqx,real oSx returns nothing
call deo(oqx,(I4v[(oqx)])-oSx)
endfunction
function pWo takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call pwo(Oqx,1.)
call pno(Oqx,5.)
call pDo(Oqx,4.)
return true
endfunction
function pyo takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call dxo(Oqx,1.)
call cwx(Oqx,5.)
call pFo(Oqx,4.)
return true
endfunction
function pYo takes nothing returns boolean
call pao(Mhv,XBx("RamblersStick_Init: call RamblersStick.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function RamblersStick.Event_Drop))",DNv,lI,function pWo))
call pao(Mhv,XBx("RamblersStick_Init: call RamblersStick.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function RamblersStick.Event_PickUp))",DXv,lI,function pyo))
return true
endfunction
function pzo takes nothing returns boolean
call mzo(function pYo,"RamblersStick_Init")
return true
endfunction
function pZo takes nothing returns boolean
set MJv=L3o('IGrA')
set LEv[(MJv)]=("ReplaceableTextures\\CommandButtons\\BTNOrcMeleeUpOne.blp")
return true
endfunction
function p_o takes nothing returns boolean
call VRx(sa,(function pZo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act2.pack\\GruntAxe.page\\GruntAxe.struct\\obj_thisItem_wc3item.j"))
return true
endfunction
function p0o takes nothing returns boolean
set Mkv=Vnx(MKv)
return true
endfunction
function p1o takes code c,string rqx returns nothing
set an=an+1
set nn[an]=CreateTrigger()
set Vn[an]=(GetHandleId(Condition((c))))
set En[an]=rqx
call TriggerAddCondition(nn[an],Condition(c))
endfunction
function p2o takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call pqo(Oqx,50.)
call pno(Oqx,8.)
return true
endfunction
function p3o takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call bLx(Oqx,50.)
call cwx(Oqx,8.)
return true
endfunction
function p4o takes nothing returns boolean
call pao(MJv,XBx("GruntAxe_Init: call GruntAxe.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function GruntAxe.Event_Drop))",DNv,lI,function p2o))
call pao(MJv,XBx("GruntAxe_Init: call GruntAxe.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function GruntAxe.Event_PickUp))",DXv,lI,function p3o))
return true
endfunction
function p5o takes nothing returns boolean
call p1o(function p4o,"GruntAxe_Init")
return true
endfunction
function p6o takes nothing returns boolean
set Mlv=L3o('IRoH')
set LEv[(Mlv)]=("ReplaceableTextures\\CommandButtons\\BTNHoodOfCunning.blp")
return true
endfunction
function p7o takes nothing returns boolean
call VRx(sa,(function p6o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act2.pack\\RobynsHood.page\\RobynsHood.struct\\obj_thisItem_wc3item.j"))
return true
endfunction
function p8o takes nothing returns boolean
set MLv=Vnx(Mmv)
return true
endfunction
function p9o takes integer oqx,real oSx returns nothing
set fF[oqx]=oSx
call Bvx((oqx))
endfunction
function Pvo takes integer oqx,real oSx returns nothing
call p9o(oqx,(fF[(oqx)])-oSx)
endfunction
function Peo takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call Pvo(Oqx,2.)
call pwo(Oqx,4.)
return true
endfunction
function Pxo takes integer oqx,real oSx returns nothing
call p9o(oqx,(fF[(oqx)])+oSx)
endfunction
function Poo takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call Pxo(Oqx,2.)
call dxo(Oqx,4.)
return true
endfunction
function Pro takes nothing returns boolean
call pao(Mlv,XBx("RobynsHood_Init: call RobynsHood.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function RobynsHood.Event_Drop))",DNv,lI,function Peo))
call pao(Mlv,XBx("RobynsHood_Init: call RobynsHood.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function RobynsHood.Event_PickUp))",DXv,lI,function Poo))
return true
endfunction
function Pio takes nothing returns boolean
call p1o(function Pro,"RobynsHood_Init")
return true
endfunction
function Pao takes nothing returns boolean
set MMv=L3o('IElD')
set LEv[(MMv)]=("ReplaceableTextures\\CommandButtons\\BTNWandOfManaSteal.blp")
return true
endfunction
function Pno takes nothing returns boolean
call VRx(sa,(function Pao),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act3.pack\\ElfinDagger.page\\ElfinDagger.struct\\obj_thisItem_wc3item.j"))
return true
endfunction
function PVo takes nothing returns boolean
set Mpv=Vnx(MPv)
return true
endfunction
function PEo takes code c,string rqx returns nothing
set Xn=Xn+1
set On[Xn]=CreateTrigger()
set Rn[Xn]=(GetHandleId(Condition((c))))
set In[Xn]=rqx
call TriggerAddCondition(On[Xn],Condition(c))
endfunction
function PXo takes integer oqx,real oSx returns nothing
set Ayv[(oqx)]=(((Ayv[(oqx)])-oSx)*1.)
endfunction
function POo takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call PXo(Oqx,.25)
call pDo(Oqx,10.)
return true
endfunction
function PRo takes integer oqx,real oSx returns nothing
set Ayv[(oqx)]=(((Ayv[(oqx)])+oSx)*1.)
endfunction
function PIo takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call PRo(Oqx,.25)
call pFo(Oqx,10.)
return true
endfunction
function PAo takes nothing returns boolean
call pao(MMv,XBx("ElfinDagger_Init: call ElfinDagger.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function ElfinDagger.Event_Drop))",DNv,lI,function POo))
call pao(MMv,XBx("ElfinDagger_Init: call ElfinDagger.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function ElfinDagger.Event_PickUp))",DXv,lI,function PIo))
return true
endfunction
function PNo takes nothing returns boolean
call PEo(function PAo,"ElfinDagger_Init")
return true
endfunction
function Pbo takes nothing returns boolean
set Mqv=WTx('BSoD',"Bleeding",'bSoD')
return true
endfunction
function PBo takes nothing returns boolean
call VRx(Ma,(function Pbo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act3.pack\\SpearOfTheDefender.page\\SpearOfTheDefender.struct\\Buff\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function Pco takes nothing returns boolean
set MQv=Vnx(Msv)
return true
endfunction
function PCo takes nothing returns boolean
set MSv=L3o('ISoD')
set LEv[(MSv)]=("ReplaceableTextures\\CommandButtons\\BTNThoriumRanged.blp")
return true
endfunction
function Pdo takes nothing returns boolean
call VRx(sa,(function PCo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act3.pack\\SpearOfTheDefender.page\\SpearOfTheDefender.struct\\obj_thisItem_wc3item.j"))
return true
endfunction
function PDo takes nothing returns boolean
set Mtv=Vnx(MTv)
return true
endfunction
function Pfo takes integer CMx,integer Ixx returns nothing
set MUv=CMx
call NIx((Ixx),(Mqv),(1),w,((10.)*1.))
endfunction
function PFo takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(EYv[(rdx)])
local integer Ixx=(Vv[(rdx)])
call Pfo(CMx,Ixx)
return true
endfunction
function Pgo takes integer oqx,real oSx returns nothing
call dao(oqx,(I9v[(oqx)])-oSx)
endfunction
function PGo takes integer oqx,real oSx returns nothing
call fMo(oqx,(Wf[(oqx)])-oSx)
endfunction
function Pho takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
local integer nyx=(oPx(Oqx,Mwv)-1)
call Pgo(Oqx,.2)
call PGo(Oqx,MWv)
call pno(Oqx,50.)
call rTx(Oqx,Mwv,nyx)
if(nyx==0)then
call I7x(Oqx,Muv)
endif
return true
endfunction
function PHo takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
local integer nyx=(oPx(Oqx,Mwv)+1)
call dno(Oqx,.2)
call fpo(Oqx,MWv)
call cwx(Oqx,50.)
call rTx(Oqx,Mwv,nyx)
if(nyx==0+1)then
call I7x(Oqx,Muv)
endif
return true
endfunction
function Pjo takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
call pKo((Abx((Ixx),((EQv[(Ixx)])),("chest"),(ri))),2.)
call nfo((Myv[oqx]),(Ixx),((M_v)*1.),(false))
endfunction
function PJo takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=MUv
local integer p0x=inx()
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
set Myv[oqx]=CMx
set MYv[oqx]=p0x
set ge[(p0x)]=(oqx)
call icx(p0x,MZv,true,function Pjo)
return true
endfunction
function Pko takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=MYv[oqx]
call ijx(p0x)
return true
endfunction
function PKo takes nothing returns nothing
call l9x(Mqv,XBx("FolderSpearOfTheDefender_StructBuff_Init: call FolderSpearOfTheDefender_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSpearOfTheDefender_StructBuff.Event_BuffGain))",Bd,pI,function PJo))
call l9x(Mqv,XBx("FolderSpearOfTheDefender_StructBuff_Init: call FolderSpearOfTheDefender_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSpearOfTheDefender_StructBuff.Event_BuffLose))",Jc,pI,function Pko))
endfunction
function Plo takes nothing returns boolean
set Muv=XBx("SpearOfTheDefender_Init: set SpearOfTheDefender.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.ITEMS, function SpearOfTheDefender.Event_Damage)",EZv,lI,function PFo)
call pao(MSv,XBx("SpearOfTheDefender_Init: call SpearOfTheDefender.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function SpearOfTheDefender.Event_Drop))",DNv,lI,function Pho))
call pao(MSv,XBx("SpearOfTheDefender_Init: call SpearOfTheDefender.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function SpearOfTheDefender.Event_PickUp))",DXv,lI,function PHo))
call PKo()
return true
endfunction
function PLo takes nothing returns boolean
call PEo(function Plo,"SpearOfTheDefender_Init")
return true
endfunction
function Pmo takes nothing returns boolean
set M0v=L3o('IMeS')
set LEv[(M0v)]=("ReplaceableTextures\\CommandButtons\\BTNGlyph.blp")
return true
endfunction
function PMo takes nothing returns boolean
call VRx(sa,(function Pmo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\MeteoriteShard.page\\MeteoriteShard.struct\\obj_thisItem_wc3item.j"))
return true
endfunction
function Ppo takes nothing returns boolean
set M1v=Vnx(M2v)
return true
endfunction
function PPo takes code c,string rqx returns nothing
set za=za+1
set Za[za]=CreateTrigger()
set vn[za]=(GetHandleId(Condition((c))))
set en[za]=rqx
call TriggerAddCondition(Za[za],Condition(c))
endfunction
function Pqo takes integer oqx,real oSx returns nothing
call cYx(oqx,(qG[(oqx)])-oSx)
endfunction
function PQo takes integer oqx,real oSx returns nothing
call BQx(oqx,(WF[(oqx)])-oSx)
endfunction
function Pso takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call Pqo(Oqx,100.)
call PQo(Oqx,30.)
return true
endfunction
function PSo takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call czx(Oqx,100.)
call Bsx(Oqx,30.)
return true
endfunction
function Pto takes nothing returns boolean
call pao(M0v,XBx("MeteoriteShard_Init: call MeteoriteShard.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function MeteoriteShard.Event_Drop))",DNv,lI,function Pso))
call pao(M0v,XBx("MeteoriteShard_Init: call MeteoriteShard.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function MeteoriteShard.Event_PickUp))",DXv,lI,function PSo))
return true
endfunction
function PTo takes nothing returns boolean
call PPo(function Pto,"MeteoriteShard_Init")
return true
endfunction
function Puo takes nothing returns boolean
set M3v=L3o('ICoi')
call L4o(((M3v)),pS,(AS))
return true
endfunction
function PUo takes nothing returns boolean
set M4v=u1x()
set AC[(M4v)]=("Abilities\\Spells\\Items\\ResourceItems\\ReceiveGold.wav")
set cC[(M4v)]=(h5)
set dC[(M4v)]=((1)*1.)
set fC[(M4v)]=((1)*1.)
set gC[(M4v)]=($A)
set hC[(M4v)]=((1)*1.)
set LC[(M4v)]=(true)
set MC[(M4v)]=(true)
set PC[(M4v)]=((600)*1.)
set QC[(M4v)]=(($186A0)*1.)
set SC[(M4v)]=(($7D0)*1.)
return true
endfunction
function Pwo takes nothing returns boolean
call VRx(sa,(function Puo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GoldCoin.page\\GoldCoin.struct\\obj_thisItem_wc3item.j"))
call VRx(ma,(function PUo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GoldCoin.page\\GoldCoin.struct\\obj_dummySound_wc3sound.j"))
return true
endfunction
function PWo takes nothing returns boolean
set M5v=Vnx(M6v)
return true
endfunction
function Pyo takes nothing returns boolean
local integer rdx=(bv)
local integer PYo=(Ph[(rdx)])
local integer oqx=PYo
call J4x(PYo,M7v)
return true
endfunction
function Pzo takes integer oqx returns integer
set pov[oqx]=true
set prv[oqx]=false
call rax(jw)
return oqx
endfunction
function PZo takes nothing returns integer
local integer oqx
if(M9v==8190)then
call oYx("CustomDrop_Allocation_allocCustom","call DebugEx(CustomDrop.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Jw+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(pvv[(w)]==w)then
set pev=pev+1
set oqx=pev
else
set oqx=pvv[(w)]
set pvv[(w)]=pvv[pvv[(w)]]
endif
set pvv[oqx]=Z
set pxv[oqx]=1
call Pzo(oqx)
return oqx
endfunction
function P_o takes integer Xwx,string P0o,string P1o,integer P2o returns integer
local integer oqx=PZo()
set A7v[oqx]=P1o
set A8v[oqx]=P2o
set A6v[oqx]=P0o
set A5v[oqx]=Xwx
return oqx
endfunction
function P3o takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
local integer PYo=(kfx(CreateItem(Hh[(M3v)],(((GetUnitX(C[((Oqx))])))*1.),(((GetUnitY(C[((Oqx))])))*1.))))
local integer oqx=PYo
set piv[oqx]=Lrx((uf[(Oqx)]),pav)
call J8x(PYo,M7v)
return true
endfunction
function P4o takes integer oqx returns real
return XYx((GetItemX(Gh[((oqx))])),(GetItemY(Gh[((oqx))])))
endfunction
function P5o takes integer oqx,real x,real y,real z returns nothing
call SetSoundPosition(gB[(oqx)],((x)*1.),((y)*1.),((z)*1.))
call AHx(oqx)
endfunction
function P6o takes nothing returns boolean
local integer rdx=(bv)
local integer PYo=(Ph[(rdx)])
local integer Oqx=(Vv[(rdx)])
local real x=(GetItemX(Gh[((PYo))]))
local real y=(GetItemY(Gh[((PYo))]))
local real z=P4o(PYo)
local integer oqx=PYo
local integer P7o=Ahx(M4v)
local integer olx
call P5o(P7o,x,y,z)
call cNx(iqx("+"+(I2S((piv[oqx]))),"ffffcc00"),1.15*ab,(GetItemX(Gh[((PYo))])),(GetItemY(Gh[((PYo))])),P4o(PYo),(0))
call R1x(P7o,true)
set olx=Jh
loop
exitwhen(olx<0)
call Lqo(kh[olx],PLAYER_STATE_RESOURCE_GOLD,piv[oqx])
set olx=olx-1
endloop
return true
endfunction
function P8o takes nothing returns boolean
set M7v=XBx("GoldCoin_Init: set GoldCoin.COIN_DESTROY_EVENT = Event.Create(Item.DESTROY_EVENT_TYPE, EventPriority.MISC, function GoldCoin.Event_Coin_Destroy)",BS,LI,function Pyo)
set M8v=P_o(XBx("GoldCoin_Init: set GoldCoin.THIS_DROP = CustomDrop.Create(Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function GoldCoin.Event_Spawn_Death), null, null, EffectLevel.NORMAL)",VP,lI,function P3o),null,null,Bi)
call pao(M3v,XBx("GoldCoin_Init: call GoldCoin.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Use.DUMMY_EVENT_TYPE, EventPriority.MISC, function GoldCoin.Event_ItemUse))",sh,LI,function P6o))
return true
endfunction
function P9o takes nothing returns boolean
call kWo(function P8o,"GoldCoin_Init")
return true
endfunction
function qvo takes nothing returns boolean
set pnv=hGo('uRos')
set Tj[(pnv)]=((1.5)*1.)
set Nav[(pnv)]=((60)*1.)
set Ntv[(pnv)]=((85)*1.)
set I3v[(pnv)]=((0)*1.)
set Axv[(pnv)]=(5)
set NJv[(pnv)]=(('d')*1.)
set Njv[(pnv)]=(('d')*1.)
set Nhv[(pnv)]=((0)*1.)
set NIv[(pnv)]=((500)*1.)
set NOv[(pnv)]=((500)*1.)
set Ndv[(pnv)]=((500)*1.)
set AQv[(pnv)]=((0)*1.)
set Asv[(pnv)]=((0)*1.)
set Auv[(pnv)]=(0)
set AWv[(pnv)]=(0)
call hLo((pnv),(gQv),1)
return true
endfunction
function qeo takes nothing returns boolean
call LZx('AHRv',false)
set pVv=Lzo('AHRv')
set G6[(pVv)]=(D6)
set j6[(pVv)]=(1)
set sH[(pVv)]=("Revive Hero")
set Ih[(pVv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D007E)))),(((Oj))))))
set x6v[(pVv)]=(0)
set xzv[(pVv)]=("spell,channel")
call LZo((pVv),BH+(1),((2)*1.))
call LZo((pVv),QH+(1),(('d')*1.))
call LZo((pVv),Lvv+(1),((750)*1.))
set Mnv[(pVv)]=("ReplaceableTextures\\CommandButtons\\BTNResurrection.blp")
return true
endfunction
function qxo takes nothing returns boolean
call VRx(Sa,(function qvo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\HeroRevival.page\\HeroRevival.struct\\obj_RosaType_wc3unit.j"))
call VRx(qa,(function qeo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\HeroRevival.page\\HeroRevival.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function qoo takes nothing returns boolean
set pEv=Vnx(pXv)
return true
endfunction
function qro takes integer oqx returns integer
set pbv[oqx]=true
set pBv[oqx]=false
call rax(Eq)
return oqx
endfunction
function qio takes nothing returns integer
local integer oqx
if(pRv==8190)then
call oYx("CineFilter_Allocation_allocCustom","call DebugEx(CineFilter.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Xq+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(pIv[(w)]==w)then
set pAv=pAv+1
set oqx=pAv
else
set oqx=pIv[(w)]
set pIv[(w)]=pIv[pIv[(w)]]
endif
set pIv[oqx]=Z
set pNv[oqx]=1
call qro(oqx)
return oqx
endfunction
function qao takes integer oqx,integer iWx,integer iyx,integer iYx,integer izx returns nothing
set pCv[(oqx)]=(iWx)
set pdv[(oqx)]=(iyx)
set pDv[(oqx)]=(iYx)
set pfv[(oqx)]=(izx)
endfunction
function qno takes integer oqx,integer iWx,integer iyx,integer iYx,integer izx returns nothing
set pFv[(oqx)]=(iWx)
set pgv[(oqx)]=(iyx)
set pGv[(oqx)]=(iYx)
set phv[(oqx)]=(izx)
endfunction
function qVo takes integer oqx,real qEo,real qXo,real qOo,real qRo returns nothing
set pJv[(oqx)]=((qOo)*1.)
set pkv[(oqx)]=((qEo)*1.)
set pKv[(oqx)]=((qRo)*1.)
set plv[(oqx)]=((qXo)*1.)
endfunction
function qIo takes integer oqx,real qEo,real qXo,real qOo,real qRo returns nothing
set pLv[(oqx)]=((qOo)*1.)
set pmv[(oqx)]=((qEo)*1.)
set pMv[(oqx)]=((qRo)*1.)
set ppv[(oqx)]=((qXo)*1.)
endfunction
function qAo takes nothing returns integer
local integer oqx=qio()
set pcv[(oqx)]=(BLEND_MODE_BLEND)
call qao(oqx,$FF,$FF,$FF,$FF)
call qno(oqx,0,0,0,0)
set pHv[(oqx)]=(TEXMAP_FLAG_NONE)
set pjv[(oqx)]=(null)
call qVo(oqx,.0,.0,1.,1.)
call qIo(oqx,.0,.0,1.,1.)
return oqx
endfunction
function qNo takes integer oqx returns integer
set puv[oqx]=true
set pUv[oqx]=false
call rax(pEv)
return oqx
endfunction
function qbo takes nothing returns integer
local integer oqx
if(psv==8190)then
call oYx("HeroRevival_Allocation_allocCustom","call DebugEx(HeroRevival.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",pXv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(pSv[(w)]==w)then
set ptv=ptv+1
set oqx=ptv
else
set oqx=pSv[(w)]
set pSv[(w)]=pSv[pSv[(w)]]
endif
set pSv[oqx]=Z
set pTv[oqx]=1
call qNo(oqx)
return oqx
endfunction
function qBo takes integer Oqx returns nothing
local integer olx=CXx(Oqx,Izv)
local integer rJx
loop
exitwhen(olx<q)
set rJx=COx(Oqx,Izv,olx)
call ONo(rJx,Oqx)
set olx=olx-1
endloop
endfunction
function qco takes integer ocx,real x,real y,real ilx returns nothing
if iVx(ocx)then
call PanCameraToTimed(x,y,ilx)
endif
endfunction
function qCo takes integer oqx,real ilx,integer ocx returns nothing
if not iVx(ocx)then
return
endif
call SetCineFilterBlendMode((pcv[(oqx)]))
call SetCineFilterEndColor(pCv[oqx],pdv[oqx],pDv[oqx],pfv[oqx])
call SetCineFilterEndUV(pkv[oqx],plv[oqx],pJv[oqx],pKv[oqx])
call SetCineFilterStartColor(pFv[oqx],pgv[oqx],pGv[oqx],phv[oqx])
call SetCineFilterStartUV(pmv[oqx],ppv[oqx],pLv[oqx],pMv[oqx])
call SetCineFilterTexMapFlags((pHv[(oqx)]))
call SetCineFilterTexture((pjv[(oqx)]))
call SetCineFilterDuration(ilx)
call DisplayCineFilter(true)
endfunction
function qdo takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
call SetUnitFacing(C[((pZv[oqx]))],(((GetUnitFacing(C[((pwv[oqx]))])*bh))*1.)*gy)
endfunction
function qDo takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
local integer qfo
local integer qFo
local integer qgo
local boolean qGo
local integer oqx
local integer qho
local real x
local real y
local integer qHo
if(Nnv[(Oqx)])then
return true
endif
set pQv=pQv+1
set qfo=(ze[(Oqx)])
set qFo=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetLocalPlayer())))))),((((R))))))
set qgo=pPv[0]
set qGo=(IsUnitSelected(C[(Oqx)],vx[(qFo)]))
set oqx=qbo()
set qho=inx()
set x=lZo(qgo)
set y=l_o(qgo)
set qHo=bVx((uf[(Oqx)]),qfo,x,y,(Atan2(((Lax(dw)-y)*1.),((Lix(dw)-x)*1.))))
set pwv[oqx]=qHo
set pWv[oqx]=(Abx((qHo),(pyv),(pYv),(ri)))
set pzv[oqx]=qho
set pZv[oqx]=Oqx
call rTx(qHo,p_v,oqx)
set ge[(qho)]=(oqx)
call AIo(qHo)
call qBo(qHo)
call DSx((((qHo))),(xZv),(1),w)
call Roo(qHo,Icv)
call pKo((Abx((qHo),(p0v),(p1v),(Bi))),5.)
call DSx((((qHo))),(nTv),(1),w)
call DSx((((qHo))),(nLv),(1),w)
call DSx((((qHo))),(axv),(1),w)
call ckx(qHo,.0)
call BOx(qHo,.0)
call BBx(qHo,p2v)
call cPx(qHo,100.)
call BGx(qHo,p3v)
call DSx((((qHo))),(XVv),(1),w)
call Emo(qHo,qFo,qGo)
call NIx((((qHo))),(nhv),(1),w,((((2.)*1.))*1.))
if((qFo==(ze[(Oqx)]))and qGo)then
call qco(qFo,x,y,3.)
endif
call rTx(Oqx,p_v,oqx)
call I7x(Oqx,p4v)
call SetUnitOwner(C[Oqx],vx[Hyv],false)
call rzx(((qHo)),((pVv)),(1))
call cFx(qHo,100.)
call qCo(pOv,3.,qfo)
call icx(qho,p5v,true,function qdo)
if(pQv==1)then
call URx(p6v,"spell")
endif
return true
endfunction
function qjo takes integer oqx,integer qHo,integer Oqx returns nothing
local integer ghostEffect=pWv[oqx]
local integer qho=pzv[oqx]
call rix(qHo,p_v)
call ijx(qho)
call rix(Oqx,p_v)
call Rmx(Oqx,p4v)
call OTx(qHo)
set pQv=pQv-1
if(pQv==0)then
call Urx(p6v)
endif
endfunction
function qJo takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
local integer oqx=oPx(Oqx,p_v)
call qjo(oqx,pwv[oqx],Oqx)
return true
endfunction
function qko takes nothing returns boolean
local integer rdx=(bv)
call I7x((Vv[(rdx)]),pqv)
return true
endfunction
function qKo takes integer oqx,integer ocx returns nothing
if not iVx(ocx)then
return
endif
call DisplayCineFilter(false)
endfunction
function qlo takes integer oqx returns nothing
local integer rkx=oqx
local integer rdx=rEx(0)
local integer EHo
local integer olx
local integer rIx
local integer rlx
set Vv[(rdx)]=(oqx)
set EHo=rEx((A[(rkx)]))
set Vv[(EHo)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((XP))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((XP))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set rlx=rOx(rkx,XP,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,XP,rIx,rlx),EHo)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call rHx(((EHo)))
endfunction
function qLo takes integer oqx,real x,real y returns nothing
call AMo((oqx),sc)
set Nnv[((oqx))]=(false)
call ReviveHero(C[(oqx)],x,y,false)
call qlo(((oqx)))
endfunction
function qmo takes nothing returns boolean
local integer rdx=(bv)
local integer qHo=(Vv[(rdx)])
local integer qFo=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetLocalPlayer())))))),((((R))))))
local boolean qGo=(IsUnitSelected(C[(qHo)],vx[(qFo)]))
local real N8x=(GetUnitFacing(C[((qHo))])*bh)
local integer qfo=(ze[(qHo)])
local real x=(GetUnitX(C[((qHo))]))
local real y=(GetUnitY(C[((qHo))]))
local integer oqx=oPx(qHo,p_v)
local integer Oqx=pZv[oqx]
call qjo(oqx,qHo,Oqx)
call qKo(pOv,qfo)
call qLo(Oqx,x,y)
call pKo((Abx((Oqx),(p7v),(p8v),(Bi))),5.)
call SetUnitFacing(C[((Oqx))],((N8x)*1.)*gy)
call NIx((Oqx),(aSv),(1),w,((p9v)*1.))
call SetUnitOwner(C[Oqx],vx[qfo],false)
call Emo(Oqx,qFo,qGo)
call cFx(Oqx,Pvv*(iG[(Oqx)]))
call BOx(Oqx,Pev*(mF[(Oqx)]))
return true
endfunction
function qMo takes nothing returns boolean
local integer rdx=(bv)
set pqv=XBx("HeroRevival_Event_Start: set HeroRevival.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function HeroRevival.Event_Death)",VP,LI,function qDo)
set p4v=XBx("HeroRevival_Event_Start: set HeroRevival.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function HeroRevival.Event_Revive)",XP,LI,function qJo)
call DNx(XBx("HeroRevival_Event_Start: call Event.Create(HeroSelection.DUMMY_EVENT_TYPE, EventPriority.MISC, function HeroRevival.Event_HeroPick).AddToStatics()",JTv,LI,function qko))
call meo(pVv,XBx("HeroRevival_Event_Start: call HeroRevival.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.SUCCESS_EVENT_TYPE, EventPriority.MISC, function HeroRevival.Event_SpellEffect))",oxv,LI,function qmo))
return true
endfunction
function qpo takes nothing returns boolean
local real x
local real y
set pOv=qAo()
set pPv[0]=q_x(Rx)
set pPv[1]=q_x(Ix)
call qao(pOv,$94,58,$91,(R2I(((.7*$FF)*1.))))
set pjv[(pOv)]=("ReplaceableTextures\\CameraMasks\\DreamFilter_Mask.blp")
call DNx(XBx("HeroRevival_Init: call Event.Create(EventType.START, EventPriority.MISC, function HeroRevival.Event_Start).AddToStatics()",XE,LI,function qMo))
set Pxv=q_x(Ux)
set x=(tm[(Pxv)])
set y=(Tm[(Pxv)])
set p6v=bVx(pnv,Buv,x,y,(Atan2((((Tm[(pPv[0])])-y)*1.),(((tm[(pPv[0])])-x)*1.))))
return true
endfunction
function qPo takes nothing returns boolean
call kZo(function qpo,"HeroRevival_Init")
return true
endfunction
function qqo takes nothing returns boolean
return true
endfunction
function qQo takes nothing returns boolean
set Pov=Vnx(Prv)
return true
endfunction
function qso takes integer ocx,integer Oqx returns boolean
return(Lko(Pnv,Oqx))and( not((kv[(ocx)])!=w))
endfunction
function qSo takes integer ocx returns nothing
if iVx(ocx)then
call ClearTextMessages()
endif
endfunction
function qto takes nothing returns boolean
local integer rdx=(bv)
local integer ocx=(omx(GetTriggerPlayer()))
local integer Oqx=Q_x()
if qso(ocx,Oqx)then
set PVv[ocx]=w
call qSo(ocx)
endif
return true
endfunction
function qTo takes integer oqx returns integer
set Pdv[oqx]=true
set PDv[oqx]=false
call rax(Gp)
return oqx
endfunction
function quo takes nothing returns integer
local integer oqx
if(Pbv==8190)then
call oYx("FolderSpotEffect_StructDestroyTimed_Allocation_allocCustom","call DebugEx(FolderSpotEffect_StructDestroyTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",hp+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(PBv[(w)]==w)then
set Pcv=Pcv+1
set oqx=Pcv
else
set oqx=PBv[(w)]
set PBv[(w)]=PBv[PBv[(w)]]
endif
set PBv[oqx]=Z
set PCv[oqx]=1
call qTo(oqx)
return oqx
endfunction
function qUo takes integer oqx returns nothing
set Pdv[oqx]=false
call rgx(Gp)
endfunction
function qwo takes integer oqx returns nothing
if(PCv[oqx]>0)then
return
endif
if(PBv[oqx]!=Z)then
call oYx("FolderSpotEffect_StructDestroyTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderSpotEffect_StructDestroyTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",hp+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set PBv[oqx]=PBv[(w)]
set PBv[(w)]=oqx
call qUo(oqx)
endfunction
function qWo takes integer oqx returns nothing
set PCv[oqx]=PCv[oqx]-1
call qwo(oqx)
endfunction
function qyo takes nothing returns nothing
local integer ibx=ifx()
local integer oqx=(ge[(ibx)])
local integer rkx=Pfv[oqx]
call qWo((oqx))
call ijx(ibx)
call mFo(rkx)
endfunction
function qYo takes integer oqx,real ilx returns nothing
local integer rkx=oqx
local integer ibx
set oqx=quo()
set ibx=inx()
set Pfv[oqx]=rkx
set ge[(ibx)]=(oqx)
call icx(ibx,ilx,false,function qyo)
endfunction
function qzo takes integer Oqx returns nothing
local integer oqx=oPx(Oqx,PXv)
call I7x(Oqx,Pav)
call I7x(Oqx,PEv)
call GroupAddUnit(Kb[(Pnv)],C[(Oqx)])
call aNx(Oqx,Buv)
call PauseUnit(C[Oqx],true)
call SetUnitFacing(C[((Oqx))],((PIv[oqx])*1.)*gy)
call fWx(Oqx,PAv[oqx],PNv[oqx])
call qYo((mHo(((PAv[oqx])*1.),((PNv[oqx])*1.),(PFv),(ri))),2.)
endfunction
function qZo takes integer oqx,integer ocx returns nothing
if iVx(ocx)then
call AHx(oqx)
endif
endfunction
function q_o takes integer oqx,integer oQx,integer q0o,integer q1o returns integer
return(LoadInteger(o[((V[(E[(((I[(oqx)])))])]))],(((((A[((oqx))]))))),((((oQx))+((GetRandomInt(((q0o)),((q1o)))))))))
endfunction
function q2o takes integer oqx,integer oQx returns integer
return q_o(oqx,oQx,q,CXx(oqx,oQx))
endfunction
function q3o takes nothing returns boolean
local integer rdx=(bv)
local integer ocx=(omx(GetTriggerPlayer()))
local integer Oqx=Q_x()
local integer oqx
if not qso(ocx,Oqx)then
return true
endif
set oqx=oPx(Oqx,PXv)
if(POv[ocx]!=w)then
call iJx(POv[ocx])
set POv[ocx]=w
endif
if(PVv[ocx]==Oqx)then
if(PRv[ocx]!=w)then
call qzo(PRv[ocx])
endif
set PRv[ocx]=Oqx
call Rmx(Oqx,Pav)
call Rmx(Oqx,PEv)
call GroupRemoveUnit(Kb[(Pnv)],C[(Oqx)])
call RUx((Abx((Oqx),(Pgv),(PGv),(ri))))
call PauseUnit(C[Oqx],false)
call aNx(Oqx,ocx)
else
set POv[ocx]=iAx(Phv[oqx],ocx)
set PVv[ocx]=Oqx
call qZo((q2o(PHv[oqx],Pjv)),ocx)
call SetUnitAnimation(C[((Oqx))],("attack"))
call QueueUnitAnimation(C[((Oqx))],("stand"))
endif
return true
endfunction
function q4o takes integer oqx returns integer
set Ppv[oqx]=true
set PPv[oqx]=false
call rax(Pov)
return oqx
endfunction
function q5o takes nothing returns integer
local integer oqx
if(Plv==8190)then
call oYx("HeroSelection_Allocation_allocCustom","call DebugEx(HeroSelection.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Prv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(PLv[(w)]==w)then
set Pmv=Pmv+1
set oqx=Pmv
else
set oqx=PLv[(w)]
set PLv[(w)]=PLv[PLv[(w)]]
endif
set PLv[oqx]=Z
set PMv[oqx]=1
call q4o(oqx)
return oqx
endfunction
function q6o takes integer lbo,string q7o,rect q8o returns integer
local integer oqx=q5o()
local integer q9o=X4x((0))
local integer jMo=q_x(q8o)
local real x=(tm[(jMo)])
local real y=(Tm[(jMo)])
local real N8x=(Atan2(((Pkv-y)*1.),((PJv-x)*1.)))
local integer Oqx=bVx(lbo,Buv,x,y,N8x)
set PIv[oqx]=N8x
set Pqv[oqx]=iqx((GetHeroProperName(C[(Oqx)])),"ffaaaa00")
set PQv[oqx]=q9o
set PHv[oqx]=Oqx
set PAv[oqx]=x
set PNv[oqx]=y
call rTx(Oqx,PXv,oqx)
call I7x(Oqx,Pav)
call I7x(Oqx,PEv)
call GroupAddUnit(Kb[(Pnv)],C[(Oqx)])
call XZx(q9o,x-50.,y,200.)
call PauseUnit(C[Oqx],true)
call DSx((((Oqx))),(axv),(1),w)
call DSx((((Oqx))),(Xgv),(1),w)
call Iso(Oqx,0)
return oqx
endfunction
function Qvo takes integer oqx,string lUx returns nothing
local integer Azx=Qax(lUx,false,false,false,0,0,D5)
call rtx(PHv[oqx],Pjv,Azx)
endfunction
function Qeo takes nothing returns boolean
local integer rdx=(bv)
set PJv=(tm[(Piv)])
set Pkv=(Tm[(Piv)])
set PKv=q6o(GTv,"Fast, strong, graceful and a superior handling with the bow adorn the reputation of this young defender. In contrast, she cannot keep pace in melee and owns a minor mana pool. If it should become tight, she will call animal spirits for support.",Ax)
set Psv=q6o(Gev,"The Count is a close combat user, even if he does not come with the most of hitpoints. In return, he is able to suck life from his enemies and is granted another chance with 'Rigor Mortis'.",bx)
set PSv=q6o(Ggv,"An elven acquaintance of Count Drakul. There is not much known about this character either but he seems to be into general magics.",Fo)
set Ptv=q6o(gLv,"Covered in metal, Kera is the Sarafin family's bodyguard and mentor of Aruruw. Underneath her cloak, she holds a whole armory of devastating weapons which she knows well to effectively make use of in combat.",fo)
set PTv=q6o(g1v,"This little cheeky fairy has a fragile body, which does not permit her open battles. Since here wings were pulled out, she is not able to fly anymore. Still, she has got a lavish magical potential and is a master of theurgic curses, which could become well handy.",Bx)
set Puv=q6o(hRv,"He is the meter-tall bulwark and has got a heavy punch. Forming a team with his Polar Bear chum, together, boosting the fighting spirit is their aim. Unfortunately, the dwarf is short on legs and hardly experienced in magics.",cx)
set PUv=q6o(Gbv,"The title 'The Stormpike', this hero maintains, is not for a joke. Using his horse he can reach high speeds and his swordsmanship skills are considerable. Other than that, only average attributes.",Cx)
set Pwv=q6o(G1v,"This lively bear originates from the northern polar regions. About five years ago, he moved here alone because the climate up there never appealed to him. Also, there, he comes badly by beer. He is perhaps the most average in the group except his blood alcohol level. Yet, he can produce mana potions for the rest and alcoholize the enemies.",Dx)
set PWv=q6o(gwv,"The greenskin is an apprentice of Shamanism. This allows him to heal the other group members and to summon the energies of nature. Maybe, thereby, he can gain the others' trust by doing so. He is seated on the back of a black timber wolf.",fx)
call Qvo(PKv,"Units\\NightElf\\HeroMoonPriestess\\HeroMoonPriestessPissed3.wav")
call Qvo(PKv,"Units\\NightElf\\HeroMoonPriestess\\HeroMoonPriestessPissed5.wav")
call Qvo(PKv,"Units\\NightElf\\HeroMoonPriestess\\HeroMoonPriestessWhat2.wav")
call Qvo(Psv,"Units\\Undead\\HeroDreadLord\\HeroDreadlordWhat1.wav")
call Qvo(PSv,"Units\\Human\\Kael\\KaelYes4.wav")
call Qvo(Ptv,"Units\\NightElf\\HeroWarden\\HeroWardenPissed7.wav")
call Qvo(Ptv,"Units\\NightElf\\HeroWarden\\HeroWardenReady1.wav")
call Qvo(Ptv,"Units\\NightElf\\HeroWarden\\HeroWardenWarcry1.wav")
call Qvo(Ptv,"Units\\NightElf\\HeroWarden\\HeroWardenWhat1.wav")
call Qvo(PTv,"Units\\Human\\Jaina\\JainaPissed1.wav")
call Qvo(PTv,"Units\\Human\\Jaina\\JainaPissed3.wav")
call Qvo(PTv,"Units\\Human\\Jaina\\JainaWhat1.wav")
call Qvo(PTv,"Units\\Human\\Jaina\\JainaWhat3.wav")
call Qvo(Puv,"Units\\Human\\HeroMountainKing\\HeroMountainKingPissed3.wav")
call Qvo(Puv,"Units\\Human\\HeroMountainKing\\HeroMountainKingPissed5.wav")
call Qvo(Puv,"Units\\Human\\HeroMountainKing\\HeroMountainKingPissed6.wav")
call Qvo(Puv,"Units\\Human\\HeroMountainKing\\HeroMountainKingWhat1.wav")
call Qvo(Puv,"Units\\Human\\HeroMountainKing\\HeroMountainKingWhat2.wav")
call Qvo(PUv,"Units\\Undead\\HeroDeathKnight\\DeathKnightPissed3.wav")
call Qvo(PUv,"Units\\Undead\\HeroDeathKnight\\DeathKnightReady1.wav")
call Qvo(PUv,"Units\\Undead\\HeroDeathKnight\\DeathKnightWhat1.wav")
call Qvo(Pwv,"Units\\Creeps\\PandarenBrewmaster\\PandarenBrewmasterPissed8.wav")
call Qvo(PWv,"Units\\Orc\\Thrall\\ThrallWhat2.wav")
call Qvo(PWv,"Units\\Orc\\Thrall\\ThrallYes2.wav")
call Qvo(PWv,"Units\\Orc\\Thrall\\ThrallYes3.wav")
set Pyv=PHv[PKv]
set PYv=PHv[Psv]
set Pzv=PHv[Ptv]
set PZv=PHv[PTv]
set P_v=PHv[Puv]
set P0v=PHv[PUv]
set P1v=PHv[Pwv]
set P2v=PHv[PWv]
return true
endfunction
function Qxo takes integer ocx,integer Oqx returns nothing
local integer rdx=rEx(0)
local integer olx
local integer rIx
local integer rlx
set Vv[(rdx)]=(Oqx)
set eN[(rdx)]=(ocx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((JTv))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((JTv))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function Qoo takes integer oqx,integer rRx,boolean test returns nothing
call UnitAddItem(C[((oqx))],Gh[((kfx(CreateItem(Hh[(rRx)],((DPx((oqx)))*1.),((DQx((oqx)))*1.)))))])
endfunction
function Qro takes integer oqx,integer oSx returns nothing
local integer abx=(bdv[(oqx)])
if(oSx!=abx)then
call SetHeroLevel(C[(oqx)],oSx,true)
endif
endfunction
function Qio takes nothing returns boolean
local integer Oqx=Q_x()
local integer Qao=(ze[(Oqx)])
if(Oqx!=PRv[Qao])then
return true
endif
call rix(Oqx,PXv)
call UJx(((Oqx)),axv)
set kv[(Qao)]=(Oqx)
call Qxo(Qao,Oqx)
call Qoo(Oqx,Lev,true)
call SetUnitPosition(C[((Oqx))],((P3v)*1.),((P4v)*1.))
call UJx(((Oqx)),Xgv)
call ITo(Oqx,1)
call Lqo(Qao,PLAYER_STATE_RESOURCE_GOLD,300)
call qco(Qao,(GetUnitX(C[((Oqx))])),(GetUnitY(C[((Oqx))])),2.)
call Qoo(Oqx,P5v,true)
if(pe==P6v)then
call Qro(Oqx,3)
call Lqo(Qao,PLAYER_STATE_RESOURCE_LUMBER,$FA)
endif
return true
endfunction
function Qno takes integer oqx returns integer
set qxv[oqx]=true
set qov[oqx]=false
set qrv[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set qiv[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(r5)
return oqx
endfunction
function QVo takes nothing returns integer
local integer oqx
if(P8v==8190)then
call oYx("Region_Allocation_allocCustom","call DebugEx(Region.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",i5+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(P9v[(w)]==w)then
set qvv=qvv+1
set oqx=qvv
else
set oqx=P9v[(w)]
set P9v[(w)]=P9v[P9v[(w)]]
endif
set P9v[oqx]=Z
set qev[oqx]=1
call Qno(oqx)
return oqx
endfunction
function QEo takes integer oqx returns nothing
set qVv[(oqx)]=(qXv+oqx)
endfunction
function QXo takes nothing returns integer
local integer oqx=QVo()
set P7v[oqx]=CreateRegion()
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((P7v[oqx]))))),((((qnv)))),((((oqx)))))
call QEo(oqx)
return oqx
endfunction
function QOo takes integer jMo returns integer
local integer oqx=QXo()
call RegionAddRect(P7v[(oqx)],bm[(jMo)])
return oqx
endfunction
function QRo takes nothing returns boolean
local integer QIo=q_x(vo)
local integer olx
local integer M3x
set Piv=q_x(Nx)
set Pav=XBx("HeroSelection_Init: set HeroSelection.DESELECTION_EVENT = Event.Create(UNIT.Selection.ENDING_EVENT_TYPE, EventPriority.MISC, function HeroSelection.Event_Deselect)",Czv,LI,function qto)
set JTv=(E0x())
set Pnv=O2x()
set PEv=XBx("HeroSelection_Init: set HeroSelection.SELECTION_EVENT = Event.Create(UNIT.Selection.REPEAT_EVENT_TYPE, EventPriority.MISC, function HeroSelection.Event_Select)",C_v,LI,function q3o)
call DNx(XBx("HeroSelection_Init: call Event.Create(EventType.START, EventPriority.MISC, function HeroSelection.Event_Start).AddToStatics()",XE,LI,function Qeo))
set olx=Jh
loop
exitwhen(olx<0)
set M3x=kh[olx]
set POv[M3x]=w
set PVv[M3x]=w
set PRv[M3x]=w
set olx=olx-1
endloop
set P3v=(tm[(QIo)])
set P4v=(Tm[(QIo)])
call TriggerRegisterEnterRegion(fA[((Xhx(function Qio)))],P7v[(QOo(q_x(Zx)))],Condition((null)))
call qco(Ge,(tm[(Piv)]),(Tm[(Piv)]),.0)
return true
endfunction
function QAo takes nothing returns boolean
call kWo(function QRo,"HeroSelection_Init")
return true
endfunction
function QNo takes nothing returns boolean
set qOv=Vnx(qRv)
return true
endfunction
function Qbo takes integer oqx returns integer
set qBv[oqx]=true
set qcv[oqx]=false
call rax(qOv)
return oqx
endfunction
function QBo takes nothing returns integer
local integer oqx
if(qIv==8190)then
call oYx("Hint_Allocation_allocCustom","call DebugEx(Hint.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",qRv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(qAv[(w)]==w)then
set qNv=qNv+1
set oqx=qNv
else
set oqx=qAv[(w)]
set qAv[(w)]=qAv[qAv[(w)]]
endif
set qAv[oqx]=Z
set qbv[oqx]=1
call Qbo(oqx)
return oqx
endfunction
function Qco takes integer oqx returns boolean
set qdv=qdv+1
set qDv[qdv]=oqx
set qfv[oqx]=qdv+1
return(qdv==0)
endfunction
function QCo takes string iNx returns integer
local integer oqx=QBo()
set qCv[oqx]=iNx
call Qco(oqx)
return oqx
endfunction
function Qdo takes nothing returns nothing
local integer oqx
if Y0 then
set oqx=(qDv[(GetRandomInt(((0)),((qdv))))])
call iLx(Ge,iqx("Hint "+(I2S(((qfv[(oqx)]-1)+1-0)))+" of "+(I2S((qdv+1-0)))+": ","ffffcc00")+qCv[oqx],10.)
endif
endfunction
function QDo takes nothing returns boolean
local integer rdx=(bv)
call icx(inx(),60.,true,function Qdo)
return true
endfunction
function Qfo takes nothing returns boolean
call QCo("You receive a notification message each time when there are creep camps in the next level. These creeps spawn outside of the castle and drop some unique effect besides gold/xp like permanent stats bonuses or temporary buffs.")
call QCo("Regard one of the modern travelling services that are next to the side entrances of the castle to spend a visit at the tavern.")
call QCo("Explore the vast castle library that holds ancient wisdom of nature-bound magic.")
call QCo("Wintercastle lies in the crystal mountains, behind the shadowy forest that never met the light of spring.")
call QCo("1-2 heroes should be enough to take care of normal creep camps. The taverns serve 'Tropical Rainbow' for free, but only one vial at a time. You may use it to fast return to the castle or to approach the other camp. It also boosts the attack speed so can be compoundable with finishing off the creeps.")
call DNx(XBx("Hint_Init: call Event.Create(AfterIntro.DUMMY_EVENT_TYPE, EventPriority.MISC, function Hint.Event_AfterIntro).AddToStatics()",JGv,LI,function QDo))
return true
endfunction
function QFo takes nothing returns boolean
call kZo(function Qfo,"Hint_Init")
return true
endfunction
function Qgo takes nothing returns boolean
set qFv=lQx(qgv+" (dummyBuff)")
set qc[(qFv)]=(true)
return true
endfunction
function QGo takes nothing returns boolean
call VRx(Ma,(function Qgo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\HorseRide.page\\HorseRide.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function Qho takes nothing returns boolean
set qGv=Vnx(qgv)
return true
endfunction
function QHo takes nothing returns boolean
set qhv=L3o('IHoR')
call L4o(((qhv)),pS,(AS))
set LEv[(qhv)]=("ReplaceableTextures\\CommandButtons\\BTNRiderlessHorse.blp")
return true
endfunction
function Qjo takes nothing returns boolean
set qHv=hGo('uRiS')
call hho(((qHv)),Apv,(ICv))
set Tj[(qHv)]=((1.3)*1.)
set Nav[(qHv)]=(('x')*1.)
set Ntv[(qHv)]=((60)*1.)
set I3v[(qHv)]=((0)*1.)
set Axv[(qHv)]=(0)
set NJv[(qHv)]=((150000.)*1.)
set Njv[(qHv)]=((150000.)*1.)
set Nhv[(qHv)]=((0)*1.)
set NIv[(qHv)]=((500)*1.)
set NOv[(qHv)]=((500)*1.)
set AQv[(qHv)]=((0)*1.)
set Asv[(qHv)]=((0)*1.)
set Auv[(qHv)]=(0)
set AWv[(qHv)]=(0)
call hLo((qHv),(gQv),1)
return true
endfunction
function QJo takes nothing returns boolean
call VRx(sa,(function QHo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\HorseRide.page\\HorseRide.struct\\obj_shopItem_wc3item.j"))
call VRx(Sa,(function Qjo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\HorseRide.page\\HorseRide.struct\\obj_shop_wc3unit.j"))
return true
endfunction
function Qko takes nothing returns boolean
set qjv=Vnx(qJv)
return true
endfunction
function QKo takes integer Ixx returns integer
local integer oqx=Ixx
return qqv[oqx]
endfunction
function Qlo takes nothing returns nothing
call GroupAddUnit(qKv,zj[QKo(RVx())])
endfunction
function QLo takes integer oqx returns real
return(XYx((GetUnitX(zj[(((oqx)))])),(GetUnitY(zj[(((oqx)))])))+(GetUnitFlyHeight(zj[((oqx))])))
endfunction
function Qmo takes integer oqx,real iWx,real iyx,real iYx,real izx returns nothing
call mBx(oqx,(Ly[(oqx)])+iWx,(my[(oqx)])+iyx,(My[(oqx)])+iYx,(py[(oqx)])+izx)
endfunction
function QMo takes integer oqx returns integer
set qUv[oqx]=true
set qwv[oqx]=false
call rax(kW)
return oqx
endfunction
function Qpo takes nothing returns integer
local integer oqx
if(qSv==8190)then
call oYx("FolderDummyUnit_FolderVertexColor_StructTimed_Allocation_allocCustom","call DebugEx(FolderDummyUnit_FolderVertexColor_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",KW+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(qtv[(w)]==w)then
set qTv=qTv+1
set oqx=qTv
else
set oqx=qtv[(w)]
set qtv[(w)]=qtv[qtv[(w)]]
endif
set qtv[oqx]=Z
set quv[oqx]=1
call QMo(oqx)
return oqx
endfunction
function QPo takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(yp[(oqx)],(Yp[((oqx))]),oQx,oSx)
endfunction
function Qqo takes integer oqx returns boolean
set q2v=q2v+1
set q3v[q2v]=oqx
set q4v[oqx]=q2v+1
return(q2v==0)
endfunction
function QQo takes nothing returns nothing
local integer olx=q2v
local integer oqx
loop
set oqx=q3v[olx]
call Qmo(q_v[oqx],qWv[oqx],qyv[oqx],qYv[oqx],qzv[oqx])
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function Qso takes integer oqx returns nothing
set qUv[oqx]=false
call rgx(kW)
endfunction
function QSo takes integer oqx returns nothing
if(quv[oqx]>0)then
return
endif
if(qtv[oqx]!=Z)then
call oYx("FolderDummyUnit_FolderVertexColor_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderDummyUnit_FolderVertexColor_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",KW+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set qtv[oqx]=qtv[(w)]
set qtv[(w)]=oqx
call Qso(oqx)
endfunction
function Qto takes integer oqx returns nothing
set quv[oqx]=quv[oqx]-1
call QSo(oqx)
endfunction
function QTo takes integer oqx returns boolean
local integer okx=(q4v[(oqx)])
set q4v[q3v[q2v]]=okx
set q3v[okx-1]=q3v[q2v]
set q4v[oqx]=0
set q2v=q2v-1
return(q2v==F)
endfunction
function Quo takes integer oqx,integer ibx,integer rkx returns nothing
call Qto((oqx))
call ijx(ibx)
call HVx(rkx,q1v,oqx)
if QTo(oqx)then
call iHx(Ny)
endif
endfunction
function QUo takes nothing returns nothing
local integer ibx=ifx()
local integer oqx=(ge[(ibx)])
call Quo(oqx,ibx,q_v[oqx])
endfunction
function Qwo takes integer oqx,real iWx,real iyx,real iYx,real izx,real ilx returns nothing
local integer rkx=oqx
local integer D8x
local integer ibx
if(ilx==.0)then
call Qmo((oqx),iWx,iyx,iYx,izx)
return
endif
set D8x=(R2I(((ilx*1./ qsv)*1.)))
set oqx=Qpo()
set ibx=inx()
set qWv[oqx]=iWx*1./ D8x
set qyv[oqx]=iyx*1./ D8x
set qYv[oqx]=iYx*1./ D8x
set qzv[oqx]=izx*1./ D8x
set qZv[oqx]=ibx
set q_v[oqx]=rkx
set ge[(ibx)]=(oqx)
call QPo(rkx,q1v,oqx)
if Qqo(oqx)then
call icx(Ny,qsv,true,function QQo)
endif
call icx(ibx,ilx,false,function QUo)
endfunction
function QWo takes integer Ixx returns nothing
local integer oqx=Ixx
local integer Qyo=qqv[oqx]
local real N8x=(GetUnitFacing(zj[((Qyo))])*bh)
local real x=(GetUnitX(zj[((Qyo))]))
local real y=(GetUnitY(zj[((Qyo))]))
local real z=QLo(Qyo)
local integer HOx=mcx('qHoR',x+qQv*(Cos(((((N8x)*1.))*1.))),y+qQv*(Sin(((((N8x)*1.))*1.))),z,N8x)
call IssuePointOrderById(zj[((HOx))],Pb[(ch)],((x)*1.),((y)*1.))
call mBx(HOx,255.,255.,255.,191.)
call Qwo((HOx),-((255.)*1.),-((255.)*1.),-((255.)*1.),-((191.)*1.),((q5v)*1.))
call fDo(HOx,q5v)
endfunction
function QYo takes nothing returns nothing
call QWo(RVx())
endfunction
function Qzo takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
call ForGroup(Kb[(qMv[oqx])],(function QYo))
endfunction
function QZo takes integer oqx,real x,real y returns nothing
call Dpx(oqx,x)
call Dqx(oqx,y)
call mAx(oqx,x,y,(Vu[(oqx)]))
endfunction
function Q_o takes integer oqx,real x,real y returns boolean
return not((x<(wm[(oqx)]))or(y<(Wm[(oqx)]))or(x>(um[(oqx)]))or(y>(Um[(oqx)])))
endfunction
function Q0o takes integer Ixx returns nothing
local integer oqx=Ixx
local integer Qyo=qqv[oqx]
local integer Q1o=qpv[q6v[oqx]]
local real x=(GetUnitX(zj[((Qyo))]))
local real y=(GetUnitY(zj[((Qyo))]))
local real Q2o
call QZo(OZv[(Ixx)],((x)*1.),((y)*1.))
if Q_o(Q1o,x,y)then
set Q2o=(ky[(Qyo)])-3.141592654
call Ayx(Ixx,qFv)
call SetUnitPosition(C[((Ixx))],((x+q7v*(Cos(((((Q2o)*1.))*1.))))*1.),((y+q7v*(Sin(((((Q2o)*1.))*1.))))*1.))
elseif((BNo(GetUnitCurrentOrder(zj[((Qyo))])))==w)then
call IssuePointOrderById(zj[((Qyo))],Pb[(ch)],(((tm[(Q1o)]))*1.),(((Tm[(Q1o)]))*1.))
endif
endfunction
function Q3o takes nothing returns nothing
call Q0o(RVx())
endfunction
function Q4o takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
call ForGroup(Kb[(qMv[oqx])],(function Q3o))
endfunction
function Q5o takes nothing returns nothing
local integer Q6o=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(Q6o)])
local integer Q7o=qMv[oqx]
local integer Q1o=qpv[oqx]
call GroupClear(qKv)
call ForGroup(Kb[(Q7o)],(function Qlo))
call GroupPointOrderById(qKv,Pb[ch],(tm[(Q1o)]),(Tm[(Q1o)]))
call icx(qmv[oqx],.625,true,function Qzo)
call icx(Q6o,1.,true,function Q4o)
endfunction
function Q8o takes integer oqx,integer Iox,integer rwx returns boolean
call Ayx(oqx,Iox)
return(DSx((oqx),(Iox),(rwx),w))
endfunction
function Q9o takes integer oqx,integer Ixx returns nothing
set q8v=oqx
call Q8o(Ixx,qFv,1)
endfunction
function svo takes nothing returns nothing
call Q9o(q8v,RVx())
endfunction
function seo takes integer Q7o,integer Q1o returns nothing
local integer oqx=Q7o
local integer sxo=inx()
local integer Q6o=inx()
set qmv[oqx]=sxo
set qMv[oqx]=Q7o
set qpv[oqx]=Q1o
set qPv[oqx]=Q6o
set ge[(sxo)]=(oqx)
set ge[(Q6o)]=(oqx)
call icx(Q6o,2.,true,function Q5o)
set q8v=oqx
call ForGroup(Kb[(Q7o)],(function svo))
endfunction
function soo takes nothing returns boolean
local integer rdx=(bv)
local integer Qyo=(Vv[(rdx)])
local integer Ixx=(WH[(rdx)])
local boolean k9o=(Qyo==(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((Vr)))))),((((ix)))))))
local integer Q7o=O2x()
call GroupAddUnit(Kb[(Q7o)],C[(Ixx)])
if k9o then
call seo(Q7o,qLv)
else
call seo(Q7o,qlv)
endif
return true
endfunction
function sro takes integer oqx returns integer
set oP[oqx]=true
set Qxv[oqx]=false
call rax(Op)
return oqx
endfunction
function sio takes nothing returns integer
local integer oqx
if(Qvv==8190)then
call oYx("DummyUnitEffect_Allocation_allocCustom","call DebugEx(DummyUnitEffect.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Rp+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(xP[(w)]==w)then
set Qev=Qev+1
set oqx=Qev
else
set oqx=xP[(w)]
set xP[(w)]=xP[xP[(w)]]
endif
set xP[oqx]=Z
set eP[oqx]=1
call sro(oqx)
return oqx
endfunction
function sao takes integer HOx,string ARx,string AIx,integer rwx returns integer
local integer oqx=sio()
set Zp[oqx]=HOx
set vP[oqx]=AddSpecialEffectTarget(iQx(ci>=rwx,ARx),zj[HOx],AIx)
if QPo(HOx,zp,oqx)then
call Mxx(HOx,Up)
call Mxx(HOx,iP)
endif
return oqx
endfunction
function sno takes integer ocx,integer Oqx returns nothing
if iVx(ocx)then
call SetCameraTargetController(zj[Oqx],.0,.0,false)
endif
endfunction
function sVo takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer sEo=(ze[(Ixx)])
local integer oqx=Ixx
local integer Qyo=mcx('qHoR',(GetUnitX(C[((Ixx))])),(GetUnitY(C[((Ixx))])),fwx(Ixx),(GetRandomReal(((.0)*1.),((df)*1.))))
set qqv[oqx]=Qyo
set q9v[oqx]=sao(Qyo,Qov,Qrv,ri)
set q6v[oqx]=q8v
call sno(sEo,Qyo)
call HXx(sao(Qyo,Qiv,Qav,ri))
call mIx(Qyo,sEo)
call SetUnitMoveSpeed(zj[(Qyo)],((522.)*1.))
call DSx((((Ixx))),(Oyv),(1),w)
return true
endfunction
function sXo takes integer ocx,real ilx returns nothing
if iVx(ocx)then
call ResetToGameCamera(ilx)
endif
endfunction
function sOo takes integer oqx returns nothing
local integer sxo=qmv[oqx]
local integer Q7o=qMv[oqx]
local integer Q6o=qPv[oqx]
call ijx(sxo)
call O6x(Q7o)
call ijx(Q6o)
endfunction
function sRo takes integer oqx,integer Ixx returns nothing
call GroupRemoveUnit(Kb[(qMv[oqx])],C[(Ixx)])
if((aBx(FirstOfGroup(Kb[((qMv[oqx]))])))==w)then
call sOo(oqx)
endif
endfunction
function sIo takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer Qyo=qqv[oqx]
local integer sAo=q9v[oqx]
call sXo(((ze[(Ixx)])),.0)
call IssueImmediateOrderById(zj[((Qyo))],Pb[(Ch)])
call Qwo((Qyo),-((.0)*1.),-((.0)*1.),-((.0)*1.),-((255.)*1.),((Qnv)*1.))
call HXx(sAo)
call RUx((Abx((Ixx),(QVv),(QEv),(ri))))
call UJx(((Ixx)),Oyv)
call fDo(Qyo,Qnv)
call sRo(q6v[oqx],Ixx)
return true
endfunction
function sNo takes nothing returns nothing
call l9x(qFv,XBx("FolderHorseRide_StructTarget_Init: call FolderHorseRide_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderHorseRide_StructTarget.Event_BuffGain))",Bd,pI,function sVo))
call l9x(qFv,XBx("FolderHorseRide_StructTarget_Init: call FolderHorseRide_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderHorseRide_StructTarget.Event_BuffLose))",Jc,pI,function sIo))
endfunction
function sbo takes nothing returns boolean
set qkv=q_x(eo)
set qKv=CreateGroup()
set qlv=q_x(yx)
set qLv=q_x(Wx)
call pao(qhv,XBx("HorseRide_Init: call HorseRide.SHOP_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Sell.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function HorseRide.Event_Sell))",DDv,lI,function soo))
call sNo()
return true
endfunction
function sBo takes nothing returns boolean
call kWo(function sbo,"HorseRide_Init")
return true
endfunction
function sco takes nothing returns boolean
set QXv=Vnx(QOv)
return true
endfunction
function sCo takes nothing returns boolean
set QRv=Vnx(QIv)
return true
endfunction
function sdo takes integer ocx returns integer
local integer oqx=ocx
return QNv[oqx]
endfunction
function sDo takes integer oqx,integer pRx,integer pOx,string oSx returns nothing
call pAx(oqx,pRx,pOx)
call pix((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((op[(oqx)]))))),((((mZ+(pRx)*50+(pOx))))))),oSx)
endfunction
function sfo takes integer CDx,integer FXo,integer Oqx returns nothing
local integer sFo=(LS[(CDx)])
local integer pRx=sdo((ze[(Oqx)]))
if(sFo>0)then
call pbx(Qbv,pRx,QBv+FXo*2,(I2S((sFo))))
endif
call sDo(Qbv,pRx,QBv+FXo*2+1,(LEv[((gh[(CDx)]))]))
endfunction
function sgo takes nothing returns boolean
local integer rdx=(bv)
local integer CDx=(Ph[(rdx)])
local integer Oqx=(Vv[(rdx)])
call sfo(CDx,FOo(Oqx,CDx),Oqx)
return true
endfunction
function sGo takes integer oqx,integer Xwx returns boolean
return((LoadInteger(o[((D[((gS[oqx]))]))],((((lh[((oqx))])))),(osx((((rA[(Xwx)]))),(((Xwx)))))))!=0)
endfunction
function sho takes integer CDx,integer FXo,integer Oqx returns nothing
local integer pRx=sdo((ze[(Oqx)]))
call sDo(Qbv,pRx,QBv+FXo*2+1,null)
call pbx(Qbv,pRx,QBv+FXo*2,null)
endfunction
function sHo takes nothing returns boolean
local integer rdx=(bv)
local integer CDx=(Ph[(rdx)])
if not sGo(CDx,QAv)then
return true
endif
call sho(CDx,(DAv[(rdx)]),(Vv[(rdx)]))
call J4x(CDx,QAv)
return true
endfunction
function sjo takes nothing returns boolean
local integer rdx=(bv)
local integer dox=(TH[(rdx)])
local integer Fgo=(Ddv[(rdx)])
local integer CDx=(Ph[(rdx)])
local integer FXo=(DAv[(rdx)])
local integer Oqx=(Vv[(rdx)])
call sfo(CDx,Fgo,Oqx)
if(dox==w)then
call sho(CDx,FXo,Oqx)
else
call sfo(dox,FXo,Oqx)
endif
return true
endfunction
function sJo takes nothing returns boolean
local integer rdx=(bv)
local integer CDx=(Ph[(rdx)])
call J8x(CDx,QAv)
call sfo(CDx,(DAv[(rdx)]),(Vv[(rdx)]))
return true
endfunction
function sko takes nothing returns string
local integer sKo=jLv
local string o4x="Chapter: "
if(sKo==w)then
return o4x
endif
return o4x+iqx((j0v[(sKo)]),"ff00ff00")
endfunction
function slo takes nothing returns boolean
local integer rdx=(bv)
call pbx(Qbv,QDv,Qfv,sko())
return true
endfunction
function sLo takes integer oqx,integer el returns boolean
if pJx(oqx,el)then
return false
endif
call m0x(X,el,ZY+oqx,w)
if((zY[((oqx))])==w)then
set zY[oqx]=el
set vz[oqx]=el
return true
endif
call m0x(X,el,xz+oqx,(vz[(oqx)]))
call m0x(X,(vz[(oqx)]),ZY+oqx,el)
set vz[oqx]=el
return false
endfunction
function smo takes integer oqx,integer ocx returns nothing
local integer rkx=oqx
set oqx=ocx
if sLo(OZ[oqx],rkx)then
call P8x((rkx),ocx)
else
call psx(rkx)
endif
endfunction
function sMo takes nothing returns boolean
local integer rdx=(bv)
call smo((Qbv),((eN[(rdx)])))
return true
endfunction
function spo takes integer ocx returns nothing
local integer sPo
if((HSv[(ocx)])!=HXv)then
set sPo=(kv[(ocx)])
if(sPo==w)then
call pbx(Qbv,sdo(ocx),1,"inactive")
elseif I6x(sPo,sc)then
call pbx(Qbv,sdo(ocx),1,"dead "+(I2S(((R2I((((((LF[(pwv[(oPx(sPo,p_v))])]))*1.))*1.)))))))
else
call pbx(Qbv,sdo(ocx),1,"active")
endif
endif
endfunction
function sqo takes nothing returns boolean
local integer rdx=(bv)
local integer ocx=(eN[(rdx)])
local integer Oqx=(Vv[(rdx)])
call I7x(Oqx,Qcv)
call I7x(Oqx,QCv)
call I7x(Oqx,Qdv)
call spo(ocx)
return true
endfunction
function sQo takes integer oqx returns integer
return kjo((oqx),JCv)
endfunction
function sso takes integer oqx,integer okx returns integer
return kJo((oqx),JCv,okx)
endfunction
function sSo takes nothing returns string
local integer sto=qe
local string o4x="Level: "
local integer sKo
local integer o7x
local integer olx
local integer kLo
local string sTo
local integer rlx
local integer k1o
local string Ilx
if(sto==w)then
return o4x
endif
if(lFv[(sto)])then
return o4x+(Ue[(sto)])
endif
set sKo=jLv
if(sKo==w)then
return o4x
endif
set o7x=0
set olx=q
loop
exitwhen(olx>(kHo(((sKo)),jUv)))
if(olx>q)then
set o4x=o4x+" | "
endif
set kLo=(kOo(((sKo)),jUv,(olx)))
set sTo=""
set rlx=q
loop
exitwhen(rlx>sQo(kLo))
set k1o=sso(kLo,rlx)
if(Qgv[(k0o(k1o))])then
set Ilx="Boss"
else
set Ilx=(I2S((o7x+1)))
endif
if(k1o==sto)then
set Ilx=iqx(Ilx,"ff00ff00")
endif
if(sTo=="")then
set sTo=sTo+Ilx
else
set sTo=sTo+" - "+Ilx
endif
set o7x=o7x+1
set rlx=rlx+1
endloop
set o4x=o4x+sTo
set olx=olx+1
endloop
return o4x
endfunction
function suo takes nothing returns boolean
local integer rdx=(bv)
local integer k1o=(Qe[(rdx)])
local integer olx
local integer Kxo
local boolean array sUo
local integer rlx
call pbx(Qbv,QFv,Qfv,sSo())
set olx=0
loop
if((QGv[(k1o)]-1)<=lfv)then
set Kxo=k0o(k1o)
if(Kxo==w)then
return true
endif
set sUo[0]=(Qhv[(Kxo)])
set sUo[1]=(QHv[(Kxo)])
set sUo[2]=(Qjv[(Kxo)])
set sUo[4]=(QJv[(Kxo)])
set sUo[5]=(Qkv[(Kxo)])
set sUo[6]=(QKv[(Kxo)])
set sUo[7]=(Qlv[(Kxo)])
set sUo[8]=(Qgv[(Kxo)])
if(Qgv[(Kxo)])then
call sDo(Qbv,QLv+olx,Qfv,"ReplaceableTextures\\CommandButtons\\BTNSelectHeroOff.blp")
elseif((Qgv[(Kxo)])and(olx==1))then
call sDo(Qbv,QLv+olx,Qfv,"ReplaceableTextures\\CommandButtons\\BTNSelectHeroOff.blp")
else
call sDo(Qbv,QLv+olx,Qfv,(Qmv[(k1o)]))
endif
set rlx=0
loop
exitwhen(rlx>8)
if sUo[rlx]then
call sDo(Qbv,QLv+olx,QMv+rlx,"ReplaceableTextures\\WorldEditUI\\Editor-Ally-HighPriority.blp")
else
call sDo(Qbv,QLv+olx,QMv+rlx,"ReplaceableTextures\\WorldEditUI\\Editor-Ally-NoPriority.blp")
endif
if(rlx==2)then
set rlx=rlx+2
else
set rlx=rlx+1
endif
endloop
endif
set olx=olx+1
set k1o=(ue[(k1o)])
exitwhen(olx>1)
endloop
return true
endfunction
function swo takes integer oqx returns integer
set Qsv[oqx]=true
set QSv[oqx]=false
call rax(EZ)
return oqx
endfunction
function sWo takes nothing returns integer
local integer oqx
if(Qpv==8190)then
call oYx("Multiboard_Allocation_allocCustom","call DebugEx(Multiboard.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",XZ+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(QPv[(w)]==w)then
set Qqv=Qqv+1
set oqx=Qqv
else
set oqx=QPv[(w)]
set QPv[(w)]=QPv[QPv[(w)]]
endif
set QPv[oqx]=Z
set QQv[oqx]=1
call swo(oqx)
return oqx
endfunction
function syo takes integer oqx returns integer
set QWv[oqx]=true
set Qyv[oqx]=false
call rax(Uz)
return oqx
endfunction
function sYo takes nothing returns integer
local integer oqx
if(QTv==8190)then
call oYx("MultiboardItem_Allocation_allocCustom","call DebugEx(MultiboardItem.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",wz+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Quv[(w)]==w)then
set QUv=QUv+1
set oqx=QUv
else
set oqx=Quv[(w)]
set Quv[(w)]=Quv[Quv[(w)]]
endif
set Quv[oqx]=Z
set Qwv[oqx]=1
call syo(oqx)
return oqx
endfunction
function szo takes integer sZo,integer pRx,integer pOx returns integer
local integer oqx=sYo()
set QYv[oqx]=pOx
set Qzv[oqx]=pRx
set KZ[oqx]=MultiboardGetItem(op[sZo],pRx,pOx)
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((KZ[oqx]))))),((((Q_v)))),((((oqx)))))
return oqx
endfunction
function s_o takes integer oqx,integer pRx,integer pOx,multiboard oMx returns nothing
local integer s0o=szo(oqx,pRx,pOx)
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oMx))))),((((mZ+pRx*50+pOx)))),((((s0o)))))
endfunction
function s1o takes nothing returns boolean
local integer oqx=Qtv
local multiboard oMx=op[oqx]
local integer pOx=0
local integer pRx
loop
set pRx=0
loop
call s_o(oqx,pRx,pOx,oMx)
set pRx=pRx+1
exitwhen(pRx==32)
endloop
set pOx=pOx+1
exitwhen(pOx==50)
endloop
set oMx=null
return true
endfunction
function s2o takes nothing returns integer
local integer oqx=sWo()
set jZ[oqx]=-1
set JZ[oqx]=-1
set op[oqx]=CreateMultiboard()
set Qtv=oqx
call aHx(function s1o)
return oqx
endfunction
function s3o takes integer oqx returns integer
local integer o7x=(JZ[(oqx)])+1
call pIx(oqx,o7x)
return o7x
endfunction
function s4o takes integer oqx,string iNx returns nothing
set A0[oqx]=iNx
call psx(oqx)
endfunction
function s5o takes nothing returns string
local real s6o=(rG[(hw)])*100.*1./(iG[(hw)])
local string o4x="Meteorite is at: "
if(s6o<.25)then
set o4x=o4x+"ffff0000"
endif
return(o4x+(I2S(((R2I(((s6o)*1.))))))+"%")
endfunction
function s7o takes integer oqx returns integer
local integer o7x=(jZ[(oqx)])+1
call pVx(oqx,o7x)
return o7x
endfunction
function s8o takes integer oqx,integer pRx,integer s9o,integer Svo,real oSx returns nothing
if(s9o>Svo)then
call s8o(oqx,pRx,Svo,s9o,oSx)
else
loop
exitwhen(s9o>Svo)
call Pwx((oqx),pRx,s9o,oSx)
set s9o=s9o+1
endloop
endif
endfunction
function Seo takes integer ocx,integer pRx returns nothing
local integer oqx=ocx
set QNv[oqx]=pRx
endfunction
function Sxo takes nothing returns boolean
local integer rdx=(bv)
local integer Soo
local integer olx
local integer M3x
local integer Sro
local integer Sio
local integer rlx
local string Sao
set QAv=XBx("Infoboard_Event_Start: set Infoboard.CHARGES_CHANGE_EVENT = Event.Create(ITEM.ChargesAmount.DUMMY_EVENT_TYPE, EventPriority.MISC, function Infoboard.Event_ChargesChange)",mS,LI,function sgo)
set Qcv=XBx("Infoboard_Event_Start: set Infoboard.DROP_EVENT = Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.MISC, function Infoboard.Event_Drop)",DNv,LI,function sHo)
set QCv=XBx("Infoboard_Event_Start: set Infoboard.MOVE_EVENT = Event.Create(UNIT.Items.Events.MoveInInventory.DUMMY_EVENT_TYPE, EventPriority.MISC, function Infoboard.Event_Move)",DBv,LI,function sjo)
set Qdv=XBx("Infoboard_Event_Start: set Infoboard.PICK_UP_EVENT = Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.MISC, function Infoboard.Event_PickUp)",DXv,LI,function sJo)
call DNx(XBx("Infoboard_Event_Start: call Event.Create(Act.START_EVENT_TYPE, EventPriority.MISC, function Infoboard.Event_ActStart).AddToStatics()",jMv,LI,function slo))
call DNx(XBx("Infoboard_Event_Start: call Event.Create(AfterIntro.FOR_PLAYER_EVENT_TYPE, EventPriority.MISC, function Infoboard.Event_AfterIntro).AddToStatics()",jbv,LI,function sMo))
call DNx(XBx("Infoboard_Event_Start: call Event.Create(HeroSelection.DUMMY_EVENT_TYPE, EventPriority.MISC, function Infoboard.Event_HeroPick).AddToStatics()",JTv,LI,function sqo))
call DNx(XBx("Infoboard_Event_Start: call Event.Create(Level.START_EVENT_TYPE, EventPriority.MISC2, function Infoboard.Event_LevelStart).AddToStatics()",We,mI,function suo))
set Qbv=s2o()
set Soo=(s3o(Qbv))
if(hw!=w)then
call s4o((Qbv),(s5o()))
endif
set Qfv=s7o(Qbv)
set QMv=s7o(Qbv)
set QBv=s7o(Qbv)
call pbx(Qbv,Soo,Qfv,iqx("Players","ffffcc00"))
call Pwx(Qbv,Soo,Qfv,.06)
call pbx(Qbv,Soo,QMv,iqx("Status","ffffcc00"))
call Pwx(Qbv,Soo,QMv,.04)
call pbx(Qbv,Soo,QBv,iqx("Items in Inventory","ffffcc00"))
call Pwx(Qbv,Soo,QBv,.1)
set Soo=(s3o(Qbv))
call pbx(Qbv,Soo,Qfv,"=================================================")
call Pwx(Qbv,Soo,Qfv,.2)
call s8o(Qbv,Soo,Qfv+1,(jZ[(Qbv)]),.0)
set Soo=(s3o(Qbv))
set olx=0
loop
exitwhen(olx>Hqv)
set M3x=HQv[olx]
set Sro=(HSv[(M3x)])
if(Sro!=HXv)then
set Sio=(kv[(M3x)])
set Soo=(s3o(Qbv))
call Pwx(Qbv,Soo,Qfv,.06)
call Pwx(Qbv,Soo,QMv,.04)
set rlx=6-1
loop
call Pwx(Qbv,Soo,QBv+rlx*2,.007)
call Pwx(Qbv,Soo,QBv+rlx*2+1,.012)
set rlx=rlx-1
exitwhen(rlx<0)
endloop
call Seo(M3x,Soo)
call spo(M3x)
if(Sro==HDv)then
set Sao=(rb[(M3x)])
else
set Sao="ff7F7F7F"
endif
call pbx(Qbv,Soo,Qfv,iqx((ib[(M3x)]),Sao))
else
call Seo(M3x,-1)
endif
set olx=olx+1
endloop
set Soo=(s3o(Qbv))
call Pwx(Qbv,Soo,Qfv,.2)
call s8o(Qbv,Soo,Qfv+1,(jZ[(Qbv)]),.0)
set Soo=(s3o(Qbv))
call Pwx(Qbv,Soo,Qfv,.1)
call sDo(Qbv,Soo,Qfv+1,"ReplaceableTextures\\CommandButtons\\BTNOrcMeleeUpOne.blp")
call sDo(Qbv,Soo,Qfv+2,"ReplaceableTextures\\CommandButtons\\BTNImprovedBows.blp")
call sDo(Qbv,Soo,Qfv+3,"ReplaceableTextures\\CommandButtons\\BTNStaffOfNegation.blp")
call sDo(Qbv,Soo,Qfv+5,"ReplaceableTextures\\CommandButtons\\BTNInvisibility.blp")
call sDo(Qbv,Soo,Qfv+6,"ReplaceableTextures\\CommandButtons\\BTNBootsOfSpeed.blp")
call sDo(Qbv,Soo,Qfv+7,"ReplaceableTextures\\CommandButtons\\BTNGenericSpellImmunity.blp")
call sDo(Qbv,Soo,Qfv+8,"ReplaceableTextures\\CommandButtons\\BTNSelfDestruct.blp")
call sDo(Qbv,Soo,Qfv+9,"ReplaceableTextures\\CommandButtons\\BTNReincarnation.blp")
call s8o(Qbv,Soo,Qfv+1,Qfv+9,.01)
call s8o(Qbv,Soo,Qfv+9+1,(jZ[(Qbv)]),.0)
set QLv=(s3o(Qbv))
call pbx(Qbv,QLv,Qfv,"This round")
call Pwx(Qbv,QLv,Qfv,.1)
call s8o(Qbv,QLv,Qfv+1,Qfv+1+8,.01)
call s8o(Qbv,QLv,Qfv+1+8+1,(jZ[(Qbv)]),.0)
set Soo=(s3o(Qbv))
call pbx(Qbv,Soo,Qfv,"Next round")
call Pwx(Qbv,Soo,Qfv,.1)
call s8o(Qbv,Soo,Qfv+1,Qfv+1+8,.01)
call s8o(Qbv,Soo,Qfv+1+8+1,(jZ[(Qbv)]),.0)
set Soo=(s3o(Qbv))
set QDv=(s3o(Qbv))
call pbx(Qbv,QDv,Qfv,sko())
call Pwx(Qbv,QDv,Qfv,.2)
set QFv=(s3o(Qbv))
call pbx(Qbv,QFv,Qfv,sSo())
call Pwx(Qbv,QFv,Qfv,.2)
return true
endfunction
function Sno takes nothing returns boolean
call DNx(XBx("Infoboard_Init: call Event.Create(EventType.START, EventPriority.MISC, function Infoboard.Event_Start).AddToStatics()",XE,LI,function Sxo))
return true
endfunction
function SVo takes nothing returns boolean
call kWo(function Sno,"Infoboard_Init")
return true
endfunction
function SEo takes nothing returns boolean
set Q0v=Vnx(Q1v)
return true
endfunction
function SXo takes integer oqx returns integer
set Q6v[oqx]=true
set Q7v[oqx]=false
call rax(Q0v)
return oqx
endfunction
function SOo takes nothing returns integer
local integer oqx
if(Q2v==8190)then
call oYx("Infocard_Allocation_allocCustom","call DebugEx(Infocard.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Q1v+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Q3v[(w)]==w)then
set Q4v=Q4v+1
set oqx=Q4v
else
set oqx=Q3v[(w)]
set Q3v[(w)]=Q3v[Q3v[(w)]]
endif
set Q3v[oqx]=Z
set Q5v[oqx]=1
call SXo(oqx)
return oqx
endfunction
function SRo takes boolean SIo,string SAo,string q7o,string SNo returns integer
local integer oqx=SOo()
local quest oMx=CreateQuest()
set Q8v[oqx]=oMx
call QuestSetDescription(oMx,q7o)
call QuestSetIconPath(oMx,SNo)
call QuestSetRequired(oMx,SIo)
call QuestSetTitle(oMx,SAo)
return oqx
endfunction
function Sbo takes nothing returns string
set Q9v=""
set Q9v=Q9v+(iqx("Development:","ffffcc00"))+"
"
set Q9v=Q9v+((iZx(("WaterKnight"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("")+"
"
set Q9v=Q9v+(iqx("Imports:","ffffcc00"))+"
"
set Q9v=Q9v+("Balduir: "+(iZx(("supertoinkz"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("Bleeding: "+(iZx(("cotd333"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("Console: "+(iZx(("Kwaliti"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("Cityscape Set: "+(iZx(("xXm0RpH3usXx"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("EnchantedArrowBlueEffect: "+(iZx(("nGy"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("EnchantedArrowFlash: "+(iZx(("epsilon"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("EnchantedArrowSkeleton: "+(iZx(("Wrathion"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("GhostSword: "+(iZx(("jatter2"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("Immortality: "+(iZx(("Daelin"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("KhakiRecoveryVortex: "+(iZx(("Power"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("Loadscreen Background: "+(iZx(("www.dreamscene.org"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("OrcAssassin: "+(iZx(("Linaze"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("Preview: "+(iZx(("www.albabackgrounds.com"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("SakeBombBarrel: "+(iZx(("Dojo"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("SakeBombMissile: "+(iZx(("RetroSexual"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("SnowPine: "+(iZx(("Gottfrei"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("SpearScout: "+(iZx(("Dojo"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("TaintedLeafHeal: "+(iZx(("WILL_THE_ALMIGHTY"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("Tarog: "+(iZx(("Dojo"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("ThunderstrikeBolt: "+(iZx(("Tranquil"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("ThunderstrikeCharge: "+(iZx(("marcus158"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("ThunderstrikeNova: "+(iZx(("dhguardianes"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("Tower: "+(iZx(("unknownczar"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("VictorHammer: "+(iZx(("Thrikodius"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("VioletEarringMissile: "+(iZx(("EdwardSwolenToe"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("VioletEarringWeaponAttach: "+(iZx(("marcus158"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("Wall: "+(iZx(("Rondo"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("WallEnd: "+(iZx(("Rondo"),"ff00bfff","ffffffff")))+"
"
set Q9v=Q9v+("")+"
"
set Q9v=Q9v+("Everything may be modified in order to fit the map. Rather than exporting stuff you are interested in, refer to the credits.txt enclosed in the map archive.")+"
"
return Q9v
endfunction
function SBo takes nothing returns boolean
call SRo(false,"Commands","!"+" + any string: character speech"+"
","ReplaceableTextures\\CommandButtons\\BTNCommand.blp")
call SRo(false,"Credits",Sbo(),"ReplaceableTextures\\CommandButtons\\BTNStormEarth&Fire.blp")
call SRo(true,"Introduction",svv+"
"+sev+"
"+sxv,"ReplaceableTextures\\CommandButtons\\BTNPenguin.blp")
call SRo(true,"Objective","Defend the meteorite at all costs!","ReplaceableTextures\\CommandButtons\\BTNArcaneObservatory.blp")
call SRo(false,"Mechanics: Dying","When you die, your hero is transformed into a ghost and teleported to the graveyard. There, you will regenerate mana to a maximum of 100 that you can then use to execute your ascension. You can freely move your spirit around but mana is only refreshed while staying at the graveyard. However, it might be useful to leave the area after being filled up to gain a better spot for reviving. The meteorite also has a spell to replenish mana that even works on ghosts.","ReplaceableTextures\\CommandButtons\\BTNSacrifice.blp")
call SRo(false,"Mechanics: Meteorite","Failing at protecting the meteorite above the center of the castle will result in your team's defeat."+"
"+"The highest player spot does have control of the meteorite and can thereby make use of it to cast some valuable spells.","ReplaceableTextures\\CommandButtons\\BTNUndeadShrine.blp")
call SRo(false,"Mechanics: Snowmen","There is one snowman figurine in front of each of the castle's entries. By giving them a lovely stroke they will not turn abominable but rather grant you sight trough their coal eyes that even detect invisible entities. The snowman will revert to neutral aggressive after "+(I2S(((R2I(((((30.)*1.))*1.))))))+" seconds.","")
call SRo(false,"Mechanics: Special spawns' attributes","The infoboard in the upper right corner of your screen shows, among other things, whether the current or next round's attacker spawns are of special behavior/have special abilities. These are, from left to right:"+"
"+"Melee: wave contains melee attackers"+"
"+"Ranged: wave contains ranged attackers"+"
"+"Magician: wave contains casters with magical abilities (this does not include physical abilities)"+"
"+"
"+"Runner: wave contains spawns that avoid aggressions and instead of this directly storm to the meteorite, they get easily dazed when being attacked from behind"+"
"+"Invis: wave contains invisible units"+"
"+"Magic immune: wave contains enemies that are immune to magical abilities"+"
"+"Kamikaze: wave contains suicidal spawns that detonate themselves to get rid of you!"+"
"+"Boss: boss wave, every sixth (last) wave of an chapter","ReplaceableTextures\\CommandButtons\\BTNDarkSummoning.blp")
call SRo(false,"Mechanics: Spell purchase","Your hero can only learn four characteristic spells plus the innate ability but further magical item scrolls can be purchased from the "+(GetObjectName(IGv[(sov)]))+". In contrast to other charged items, one scroll's ability is displayed in the unit's command card (can be switched by pressing the item buttons) and these skills can be leveled up like other hero abilities.","ReplaceableTextures\\CommandButtons\\BTNBansheeAdept.blp")
call FlashQuestDialogButton()
return true
endfunction
function Sco takes nothing returns boolean
call kWo(function SBo,"Infocard_Init")
return true
endfunction
function SCo takes nothing returns boolean
set srv=Vnx(siv)
return true
endfunction
function Sdo takes nothing returns nothing
set Hf=omx(GetEnumPlayer())
endfunction
function SDo takes integer oqx returns integer
set Hf=w
call ForForce(mD[oqx],function Sdo)
return Hf
endfunction
function Sfo takes integer ocx returns nothing
local integer rdx=rEx(0)
local integer olx
local integer rIx
local integer rlx
set eN[(rdx)]=(ocx)
call ForceRemovePlayer(mD[(Jhv)],vx[(ocx)])
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((jbv))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((jbv))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function SFo takes nothing returns nothing
local integer rdx=rEx(0)
local integer Sgo
local integer olx
local integer rIx
local integer rlx
loop
set Sgo=SDo(Jhv)
exitwhen(Sgo==w)
call Sfo(Sgo)
endloop
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((JGv))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((JGv))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function SGo takes nothing returns nothing
call SFo()
endfunction
function Sho takes integer oqx,integer ocx,boolean isx returns nothing
if isx then
call hpx(oqx,ocx)
else
call hkx(oqx,ocx)
endif
endfunction
function SHo takes nothing returns boolean
local integer rdx=(bv)
local integer olx=0
loop
set sVv=kh[olx]
exitwhen((HSv[(sVv)])==HDv)
set olx=olx+1
endloop
call Sho(sEv,sVv,true)
return true
endfunction
function Sjo takes nothing returns boolean
if((uf[(jFx())])!=jf)then
return false
endif
return true
return true
endfunction
function SJo takes integer oqx returns integer
set sNv[oqx]=true
set sbv[oqx]=false
set YM[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set ap[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(tM)
return oqx
endfunction
function Sko takes nothing returns integer
local integer oqx
if(sOv==8190)then
call oYx("Dialog_Allocation_allocCustom","call DebugEx(Dialog.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",TM+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(sRv[(w)]==w)then
set sIv=sIv+1
set oqx=sIv
else
set oqx=sRv[(w)]
set sRv[(w)]=sRv[sRv[(w)]]
endif
set sRv[oqx]=Z
set sAv[oqx]=1
call SJo(oqx)
return oqx
endfunction
function SKo takes integer oqx returns nothing
set zM[(oqx)]=(sBv+oqx)
endfunction
function Slo takes integer oqx,integer SLo returns nothing
call TriggerRegisterDialogEvent(fA[(oqx)],ep[SLo])
endfunction
function Smo takes nothing returns integer
local dialog oMx=DialogCreate()
local integer oqx=Sko()
set ep[oqx]=oMx
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oMx))))),((((WM)))),((((oqx)))))
set oMx=null
call SKo(oqx)
call Slo(UM,oqx)
return oqx
endfunction
function SMo takes integer oqx returns integer
set sfv[oqx]=true
set sFv[oqx]=false
call rax(lsv)
return oqx
endfunction
function Spo takes nothing returns integer
local integer oqx
if(scv==8190)then
call oYx("Difficulty_Allocation_allocCustom","call DebugEx(Difficulty.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",lSv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(sCv[(w)]==w)then
set sdv=sdv+1
set oqx=sdv
else
set oqx=sCv[(w)]
set sCv[(w)]=sCv[sCv[(w)]]
endif
set sCv[oqx]=Z
set sDv[oqx]=1
call SMo(oqx)
return oqx
endfunction
function SPo takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((sHv[(oqx)]))])]))],((((sjv[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function Sqo takes integer oqx returns integer
set sLv[oqx]=true
set smv[oqx]=false
set sHv[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set sMv[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(fM)
return oqx
endfunction
function SQo takes nothing returns integer
local integer oqx
if(sJv==8190)then
call oYx("DialogButton_Allocation_allocCustom","call DebugEx(DialogButton.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",FM+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(skv[(w)]==w)then
set sKv=sKv+1
set oqx=sKv
else
set oqx=skv[(w)]
set skv[(w)]=skv[skv[(w)]]
endif
set skv[oqx]=Z
set slv[oqx]=1
call Sqo(oqx)
return oqx
endfunction
function Sso takes integer oqx returns nothing
set sjv[(oqx)]=(spv+oqx)
endfunction
function SSo takes string iNx,integer Sto returns integer
local integer oqx=SQo()
call Sso(oqx)
set sPv[(oqx)]=(Sto)
set sqv[(oqx)]=(iNx)
return oqx
endfunction
function STo takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(sHv[(oqx)],(sjv[((oqx))]),oQx,oSx)
endfunction
function Suo takes integer oqx,integer hmx returns nothing
local button SUo=DialogAddButton(ep[(oqx)],sqv[hmx],sPv[hmx])
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((SUo))))),((((wM)))),((((hmx)))))
call SaveButtonHandle(FO[(X)],(ssv+oqx),(sSv+hmx),(SUo))
set SUo=null
endfunction
function Swo takes integer oqx,integer o2x returns nothing
call hjx((oqx),sQv,o2x)
call STo(o2x,sQv,oqx)
call Suo(oqx,o2x)
endfunction
function SWo takes integer oqx,string iNx,integer Sto returns integer
local integer o4x=SSo(iNx,Sto)
call Swo(oqx,o4x)
return o4x
endfunction
function Syo takes integer oqx returns boolean
set sTv=sTv+1
set suv[sTv]=oqx
set sUv[oqx]=sTv+1
return(sTv==0)
endfunction
function SYo takes string Szo,code SZo,code S_o returns integer
local integer oqx=Spo()
set sgv[oqx]=Szo
set sGv[oqx]=Xhx(SZo)
set shv[oqx]=Xhx(S_o)
call SPo(SWo(sEv,Szo,0),stv,oqx)
call Syo(oqx)
return oqx
endfunction
function S0o takes nothing returns boolean
return true
endfunction
function S1o takes integer oqx returns integer
set s_v[oqx]=true
set s0v[oqx]=false
call rax(nq)
return oqx
endfunction
function S2o takes nothing returns integer
local integer oqx
if(syv==8190)then
call oYx("Announcement_Allocation_allocCustom","call DebugEx(Announcement.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Vq+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(sYv[(w)]==w)then
set szv=szv+1
set oqx=szv
else
set oqx=sYv[(w)]
set sYv[(w)]=sYv[sYv[(w)]]
endif
set sYv[oqx]=Z
set sZv[oqx]=1
call S1o(oqx)
return oqx
endfunction
function S3o takes integer oSx returns integer
local integer oqx=S2o()
set s1v[oqx]=oSx
return oqx
endfunction
function S4o takes nothing returns boolean
return true
endfunction
function S5o takes nothing returns boolean
local integer rdx=(bv)
local integer lbo=(BOv[(rdx)])
local integer Oqx=(Vv[(rdx)])
local integer oqx=Lrx(lbo,s5v)
call Obo(s6v[oqx],Oqx)
call rzx(((Oqx)),((s6v[oqx])),(1))
return true
endfunction
function S6o takes integer oqx returns integer
set Srv[oqx]=true
set Siv[oqx]=false
call rax(Sav)
return oqx
endfunction
function S7o takes nothing returns integer
local integer oqx
if(s9v==8190)then
call oYx("Artifact_Allocation_allocCustom","call DebugEx(Artifact.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Svv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Sev[(w)]==w)then
set Sxv=Sxv+1
set oqx=Sxv
else
set oqx=Sev[(w)]
set Sev[(w)]=Sev[Sev[(w)]]
endif
set Sev[oqx]=Z
set Sov[oqx]=1
call S6o(oqx)
return oqx
endfunction
function S8o takes integer oqx,integer Xwx returns nothing
if(BRv[oqx]==w)then
call oYx("FolderUnitType_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oqx)+";"+(JA[(Xwx)]))
set BRv[oqx]=X
endif
call rSx(BRv[oqx],(gw[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function S9o takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=RVx()
local integer oqx=Lrx((uf[(Oqx)]),s5v)
call Obo(s6v[oqx],Oqx)
call rzx(((Oqx)),((s6v[oqx])),(1))
return true
endfunction
function tvo takes integer lbo,integer rJx returns integer
local integer oqx=S7o()
set s6v[oqx]=rJx
call hlo(lbo,s5v,oqx)
call S8o(lbo,s4v)
call kso(lbo,function S9o)
return oqx
endfunction
function teo takes nothing returns nothing
set s4v=XBx("Artifact_Start: set Artifact.CREATE_EVENT = Event.Create(Unit.CREATE_EVENT_TYPE, EventPriority.MISC, function Artifact.Event_Create)",Igv,LI,function S5o)
set s7v=O2x()
set s8v=true
call tvo(GTv,Snv)
call tvo(Gev,SVv)
call tvo(Ggv,SEv)
call tvo(gLv,SXv)
call tvo(g1v,SOv)
call tvo(hRv,SRv)
call tvo(Gbv,SIv)
call tvo(G1v,SAv)
call tvo(gwv,SNv)
call iLx(Ge,iqx("Artifacts are enabled.","ff00ff00"),30.)
endfunction
function txo takes integer lbo,integer rJx returns nothing
local integer Ixx
call hLo((lbo),(rJx),1)
set jf=lbo
call GroupEnumUnitsInRect(Kb[((sav))],bm[Bm],Bv[(sXv)])
loop
set Ixx=Nao(sav)
exitwhen(Ixx==w)
call rzx(((Ixx)),((rJx)),(1))
endloop
endfunction
function too takes nothing returns boolean
call teo()
call txo(Gyv,Sbv)
call txo(gjv,SBv)
call txo(GVv,Scv)
call txo(G0v,SCv)
call txo(Gqv,Sdv)
call txo(GJv,SDv)
return true
endfunction
function tro takes nothing returns boolean
return true
endfunction
function tio takes integer oqx,real oSx returns nothing
set NHv[(oqx)]=(((NHv[(oqx)])+oSx)*1.)
endfunction
function tao takes nothing returns boolean
call txo(Gyv,SFv)
call txo(gkv,Sbv)
call txo(hBv,Sgv)
call tio(GMv,2.)
call tio(GJv,2.)
call txo(GVv,SGv)
call txo(Gqv,Shv)
call txo(GOv,SHv)
call txo(Gav,GEv)
call txo(hcv,Sjv)
return true
endfunction
function tno takes integer oqx,integer Xwx returns nothing
if(ap[oqx]==w)then
call oYx("FolderDialog_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oqx)+";"+(JA[(Xwx)]))
set ap[oqx]=X
endif
call rSx(ap[oqx],(zM[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function tVo takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((sHv[(oqx)]))])]))],((((sjv[((oqx))])))),(((oQx)))))
endfunction
function tEo takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((YM[oqx]))])])],((((zM[((oqx))])))))
endfunction
function tXo takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((ap[oqx]))])])],((((zM[((oqx))])))))
endfunction
function tOo takes integer oqx returns nothing
set sNv[oqx]=false
call tEo((oqx))
call tXo(((oqx)))
call rgx(tM)
endfunction
function tRo takes integer oqx returns nothing
if(sAv[oqx]>0)then
return
endif
if(sRv[oqx]!=Z)then
call oYx("Dialog_Allocation_deallocCustom_confirm","call DebugEx(Dialog.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",TM+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set sRv[oqx]=sRv[(w)]
set sRv[(w)]=oqx
call tOo(oqx)
endfunction
function tIo takes integer oqx returns nothing
set sAv[oqx]=sAv[oqx]-1
call tRo(oqx)
endfunction
function tAo takes integer oqx returns nothing
local dialog oMx=ep[oqx]
call tIo((oqx))
call DialogDestroy(oMx)
set oMx=null
endfunction
function tNo takes integer oqx returns nothing
if(bq==oqx)then
return
endif
set bq=oqx
call CFx(Ge,PLAYER_STATE_RESOURCE_FOOD_USED,s1v[oqx]+1)
endfunction
function tbo takes nothing returns boolean
call tNo(sWv[pe])
return true
endfunction
function tBo takes nothing returns nothing
call ijx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))
call tbo()
endfunction
function tco takes nothing returns nothing
if(jLv!=w)then
call kAo(jLv)
endif
set I8v[(hw)]=((.0)*1.)
call tNo(S3o(1))
call icx(inx(),5.,false,function tBo)
call kco(jWv)
endfunction
function tCo takes nothing returns boolean
local integer rdx=(bv)
local integer tdo=(rp[(rdx)])
local integer tDo=(ip[(rdx)])
local integer oqx=tVo(tDo,stv)
local integer okx
local integer olx
local string tfo
call tAo(tdo)
call pGx(sVv,snv)
set pe=oqx
call iLx(Ge,sgv[oqx],30.)
call CFx(Ge,PLAYER_STATE_RESOURCE_GOLD,(s3v[(oqx)]))
set okx=(sUv[(oqx)]-1)
set olx=0
loop
exitwhen(olx>=okx)
if(shv[suv[olx]]!=w)then
call rcx(shv[suv[olx]])
endif
set olx=olx+1
endloop
set tfo="Enemies have "+iqx((I2S(((R2I((((s2v[(oqx)])*'d')*1.)))))),"ffffcc00")+"% damage and "+iqx((I2S(((R2I((((Me[(oqx)])*'d')*1.)))))),"ffffcc00")+"% hitpoints."
call iLx(Ge,tfo,30.)
if(sGv[oqx]!=w)then
call rcx(sGv[oqx])
endif
if(shv[oqx]!=w)then
call rcx(shv[oqx])
endif
if not s8v then
call iLx(Ge,iqx("Artifacts are disabled.","ffff0000"),30.)
endif
call tco()
return true
endfunction
function tFo takes nothing returns nothing
local integer oqx
local integer olx
call ijx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))
set sav=O2x()
set snv=XBx("Difficulty_Start: set Difficulty.LEAVE_EVENT = Event.Create(User.LEAVE_EVENT_TYPE, EventPriority.MISC, function Difficulty.Event_Leave)",h7v,LI,function SHo)
set sXv=XLx(function Sjo)
set sEv=Smo()
set oqx=SYo("Castle visitor (easy)",function S0o,null)
set swv=oqx
set sWv[oqx]=S3o(2)
set s2v[(oqx)]=((1.)*1.)
set s3v[(oqx)]=(500)
set Me[(oqx)]=((1.)*1.)
set oqx=SYo("Vassal (medium)",function S4o,function too)
set Sfv=oqx
set sWv[oqx]=S3o(3)
set s2v[(oqx)]=((1.25)*1.)
set s3v[(oqx)]=(400)
set Me[(oqx)]=((1.25)*1.)
set oqx=SYo("Knight (hard)",function tro,function tao)
set SJv=oqx
set sWv[oqx]=S3o(4)
set s2v[(oqx)]=((1.5)*1.)
set s3v[(oqx)]=(300)
set Me[(oqx)]=((1.5)*1.)
set oqx=SYo("Penguin (Test mode)",null,null)
set P6v=oqx
set sWv[oqx]=S3o(5)
set s2v[(oqx)]=((.75)*1.)
set s3v[(oqx)]=($5DC)
set Me[(oqx)]=((.75)*1.)
set olx=0
loop
set sVv=kh[olx]
exitwhen((HSv[(sVv)])==HDv)
set olx=olx+1
endloop
call DialogSetMessage(ep[(sEv)],("Declare yourself!"))
call pYx(sVv,snv)
call tno(sEv,XBx("Difficulty_Start: call Difficulty.THIS_DIALOG.Event.Add(Event.Create(Dialog.CLICK_EVENT_TYPE, EventPriority.MISC, function Difficulty.Event_DialogClick))",uM,LI,function tCo))
call Sho(sEv,sVv,true)
endfunction
function tgo takes integer oqx returns integer
set Spv[oqx]=true
set SPv[oqx]=false
call rax(Cl)
return oqx
endfunction
function tGo takes nothing returns integer
local integer oqx
if(Slv==8190)then
call oYx("Camera_Allocation_allocCustom","call DebugEx(Camera.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",dl+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(SLv[(w)]==w)then
set Smv=Smv+1
set oqx=Smv
else
set oqx=SLv[(w)]
set SLv[(w)]=SLv[SLv[(w)]]
endif
set SLv[oqx]=Z
set SMv[oqx]=1
call tgo(oqx)
return oqx
endfunction
function tho takes camerasetup oMx returns integer
local integer oqx=tGo()
set Sqv[oqx]=oMx
return oqx
endfunction
function tHo takes integer ocx,boolean isx,real ilx returns nothing
if iVx(ocx)then
call ShowInterface(isx,ilx)
endif
endfunction
function tjo takes integer ocx,boolean isx returns nothing
if iVx(ocx)then
call EnableUserControl(isx)
endif
endfunction
function tJo takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((CA[oqx]))])])],((((GA[((oqx))])))))
endfunction
function tko takes integer oqx returns nothing
set BA[oqx]=false
call tJo((oqx))
call rgx(dA)
endfunction
function tKo takes integer oqx returns nothing
if(bA[oqx]>0)then
return
endif
if(AA[oqx]!=Z)then
call oYx("Trigger_Allocation_deallocCustom_confirm","call DebugEx(Trigger.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Dv+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set AA[oqx]=AA[(w)]
set AA[(w)]=oqx
call tko(oqx)
endfunction
function tlo takes integer oqx returns nothing
set bA[oqx]=bA[oqx]-1
call tKo(oqx)
endfunction
function tLo takes integer oqx returns nothing
local trigger oMx=fA[oqx]
call tlo((oqx))
call DisableTrigger(oMx)
set oMx=null
endfunction
function tmo takes nothing returns nothing
local real x=(tm[(Piv)])
local real y=(Tm[(Piv)])
call EndCinematicScene()
call tHo(Ge,true,1.)
call tjo(Ge,true)
call tLo(SYv)
call R1x(Szv,false)
call R1x(SZv,false)
call MCx(S_v)
call MCx(S0v)
call MCx(S1v)
call MCx(S2v)
call MCx(S3v)
if(S4v!=w)then
call MCx(S4v)
endif
if(S5v!=w)then
call MCx(S5v)
endif
call sXo(Ge,.0)
call qco(Ge,x,y,.0)
call SFo()
call icx(S6v,1.,false,function tFo)
endfunction
function tMo takes nothing returns boolean
local integer olx=0
local integer ocx=(omx(GetTriggerPlayer()))
local integer tpo=(Hpv[(ocx)]-1)
call Sfo((ocx))
loop
exitwhen((HSv[(kh[olx])])==HDv)
set olx=olx+1
endloop
if(tpo==olx)then
call tmo()
endif
return true
endfunction
function tPo takes integer mCx,integer jMo,real tqo returns integer
local real tQo=(tm[(jMo)])
local real tso=(Tm[(jMo)])
local integer lzo=mcx(mCx,tQo,tso,.0,tqo)
call SetUnitColor(zj[((lzo))],(PLAYER_COLOR_BROWN))
return lzo
endfunction
function tSo takes integer mCx,integer jMo,integer Oqx returns integer
local real tQo=(tm[(jMo)])
local real tso=(Tm[(jMo)])
local real tqo=(Atan2((((nJ[(Oqx)])-tso)*1.),(((oJ[(Oqx)])-tQo)*1.)))
local integer lzo=mcx(mCx,tQo,tso,.0,tqo)
call SetUnitColor(zj[((lzo))],(PLAYER_COLOR_BROWN))
return lzo
endfunction
function tto takes integer Oqx,string iNx,real ilx,code tTo returns nothing
call AddIndicator(zj[(Oqx)],($7F),($7F),($7F),(63))
call SetCinematicScene(((Gy[(Oqx)])),(PLAYER_COLOR_BROWN),((GetHeroProperName(zj[(Oqx)]))),(iNx),((ilx)*1.),((ilx*.8)*1.))
call icx(S6v,ilx,false,tTo)
endfunction
function tuo takes integer tUo,real ilx,code tTo returns nothing
call CameraSetupApplyForceDuration(Sqv[(tUo)],(true),((ilx)*1.))
call icx(S6v,ilx,false,tTo)
endfunction
function two takes integer oqx,integer tWo returns nothing
call mRx(oqx,(Atan2((((nJ[(tWo)])-(nJ[((oqx))]))*1.),(((oJ[(tWo)])-(oJ[((oqx))]))*1.))))
endfunction
function tyo takes integer Oqx,integer jMo returns nothing
call Dpx(Oqx,(tm[(jMo)]))
call Dqx(Oqx,(Tm[(jMo)]))
endfunction
function tYo takes integer oqx,integer Ixx returns nothing
call mRx(oqx,(Atan2((((Hm[(Ixx)])-(nJ[((oqx))]))*1.),(((hm[(Ixx)])-(oJ[((oqx))]))*1.))))
endfunction
function tzo takes integer Oqx,integer jMo returns nothing
call IssuePointOrderById(zj[((Oqx))],Pb[(ch)],(((tm[(jMo)]))*1.),(((Tm[(jMo)]))*1.))
endfunction
function tZo takes integer iWx,integer iyx,integer iYx,integer izx,real ilx,code tTo returns nothing
local integer t_o=qAo()
call qao(t_o,iWx,iyx,iYx,$FF)
call qno(t_o,$FF,$FF,$FF,0)
set pjv[(t_o)]=("ReplaceableTextures\\CameraMasks\\White_mask.blp")
call qCo(t_o,ilx,Ge)
call icx(S6v,ilx,false,tTo)
endfunction
function t0o takes nothing returns nothing
call icx(S6v,((3.)*1.),false,(function tmo))
endfunction
function t1o takes nothing returns nothing
call CameraSetupApplyForceDuration(Sqv[((Syv))],(true),((((5.)*1.))*1.))
call tZo(0,0,0,0,4.,function t0o)
endfunction
function t2o takes nothing returns nothing
call tto(S_v,"Wintercastle should be a place for all that are in need of help. In these difficult times, we have to stick together, and as I am looking here, there seem to be already all kind of peoples. So break up your disputes and let's take it on at last...",12.,function t1o)
endfunction
function t3o takes nothing returns nothing
call tto(S0v,"I have to agree with lady Aruruw in this matter.",3.,function t2o)
endfunction
function t4o takes nothing returns nothing
call tto(S2v,"We shouldn't trust him, Milord. He could be a spy just as well. And even if he speaks the truth, he will still just cause trouble for us with his presence. I am aware of the Orcs' nature and their determination to wipe out every traitor.",10.,function t3o)
endfunction
function t5o takes nothing returns nothing
call tto(S5v,"Furthermore, my clan yearns to kill me. Hence, I would like to ask for refuge. As a reward, I promise you to help in every matter, until my legs won't carry me any longer.",9.,function t4o)
endfunction
function t6o takes nothing returns nothing
call two((S5v),(S_v))
call tto(S5v,"Yes, I belong to the Orcish race, but was I expelled of my own tribe, when I hesistated to executed one of our enemies and escaped. You see, I was one of their shamans, not a fighter and never approved the violent methods of my fellows. Alone, I won't be able to last for long in this world of ice out there.",13.5,function t5o)
endfunction
function t7o takes nothing returns nothing
call two((S5v),(S1v))
call tto(S5v,"Listen to my words, please!",3.,function t6o)
endfunction
function t8o takes nothing returns nothing
call tto(S0v,"We should really start deploying some guard posts.",4.,function t7o)
endfunction
function t9o takes nothing returns nothing
call two((S1v),(S5v))
call tto(S1v,"Hey, you are one of these vandals!",3.,function t8o)
endfunction
function Tvo takes nothing returns nothing
call tto(S5v,"Excuse me for my rude intrusion...",3.5,function t9o)
endfunction
function Teo takes nothing returns nothing
set S5v=tPo('O000',tav,.0)
call tzo(S5v,tnv)
call icx(S6v,((2.)*1.),false,(function Tvo))
endfunction
function Txo takes nothing returns nothing
call tto(S_v,"With that said, we are complete. I myself will participate as well. The caravans, which will traverse the forest under the protection of our efforts, are already standing by.",8.,function Teo)
endfunction
function Too takes nothing returns nothing
call tyo(S3v,tev)
call tyo(S4v,tiv)
call two((S1v),(S_v))
call two((S0v),(S_v))
call two((S2v),(S_v))
call two((S3v),(S_v))
call mRx(S_v,3.141592654)
call CameraSetupApplyForceDuration(Sqv[((SWv))],(true),((((.0)*1.))*1.))
call icx(S6v,((1.)*1.),false,(function Txo))
endfunction
function Tro takes nothing returns nothing
call tto(S1v,"Another gal. The group is already to my liking.",3.,function Too)
endfunction
function Tio takes nothing returns nothing
call tto(S0v,"This is LIZZY, a fairy from the Mid East. She was the sole survivor, I rescued, when her homeland was destroyed by the elves. Back then, she decided to accompany me. I am confident she will complement us well with her magical abilities.",13.,function Tro)
endfunction
function Tao takes nothing returns nothing
call two((S3v),(S4v))
call tto(S3v,"And you are? *hic*",2.5,function Tio)
endfunction
function Tno takes nothing returns nothing
call tto(S4v,"*hihi* What a primitive blubberbutt!",3.,function Tao)
endfunction
function TVo takes nothing returns nothing
call Mfx(S4v)
set S4v=tPo('H007',tov,kf)
call tzo(S4v,trv)
call tuo(Swv,2.,function Tno)
endfunction
function TEo takes nothing returns nothing
call SetUnitAnimationByIndex(zj[((S3v))],(6))
call QueueUnitAnimation(zj[((S3v))],("stand"))
call tto(S3v,"What the?! Where are these wretches that mess up my beer?! I thwack them until they decide to become meat eaters!",5.5,function TVo)
endfunction
function TXo takes nothing returns nothing
call icx(S6v,((1.)*1.),false,(function TEo))
endfunction
function TOo takes nothing returns nothing
call tto(S0v,"When the animals are to steal all of the corn from the silos, there won't be any alcohol for you too soon!",5.,function TXo)
endfunction
function TRo takes nothing returns nothing
call tto(S3v,"Eh?",1.,function TOo)
endfunction
function TIo takes nothing returns nothing
call tto(S0v,"We are in perilous situation right now, we should keep a clear mind.",3.5,function TRo)
endfunction
function TAo takes nothing returns nothing
call two((S3v),(S_v))
call tto(S3v,"What?",1.,function TIo)
endfunction
function TNo takes nothing returns nothing
call tto(S_v,"Stormy, now, it isn't the right time to bemuse yourself with this dazing mixture!",4.,function TAo)
endfunction
function Tbo takes nothing returns nothing
call icx(S6v,((1)*1.),false,(function TNo))
endfunction
function TBo takes nothing returns nothing
call two((S_v),(S3v))
call two((S1v),(S3v))
call two((S0v),(S3v))
call two((S2v),(S3v))
call tuo(SWv,2.5,function Tbo)
endfunction
function Tco takes nothing returns nothing
call tto(S3v,"*hic*",1.5,function TBo)
endfunction
function TCo takes nothing returns nothing
call tto(S2v,"...he stood right next to me just a moment ago.",3.,function Tco)
endfunction
function Tdo takes nothing returns nothing
call tto(S2v,"...",.75,function TCo)
endfunction
function TDo takes nothing returns nothing
call tto(S2v,"..",.75,function Tdo)
endfunction
function Tfo takes nothing returns nothing
call tto(S2v,".",.75,function TDo)
endfunction
function TFo takes nothing returns nothing
call CameraSetupApplyForceDuration(Sqv[((Suv))],(true),((((.0)*1.))*1.))
call icx(S6v,((1.)*1.),false,(function Tfo))
endfunction
function Tgo takes nothing returns nothing
call tto(S_v,"Where did he disappear to again?!",2.,function TFo)
endfunction
function TGo takes nothing returns nothing
call tyo(S3v,txv)
call tYo((S3v),(Skv))
set S4v=tPo('h009',tev,kf)
call tto(S_v,"Then, there's Stor...",3.,function Tgo)
endfunction
function Tho takes nothing returns nothing
call tuo(SKv,.5,function TGo)
endfunction
function THo takes nothing returns nothing
call two((S1v),(S_v))
call icx(S6v,((.5)*1.),false,(function Tho))
endfunction
function Tjo takes nothing returns nothing
call tto(S1v,"Woo, I am impressed, young lad'.",3.,function THo)
endfunction
function TJo takes nothing returns nothing
call CameraSetupApplyForceDuration(Sqv[((STv))],(true),((((2.)*1.))*1.))
call tto(S2v,"While approaching your castle I noticed a lot of incensed animals, on the south pass in particular. The "+iqx("Great Winter","ffffcc00")+" hit them pretty well, too, and turned them into raging creatures.",9.5,function Tjo)
endfunction
function Tko takes nothing returns nothing
call two((S2v),(S_v))
call icx(S6v,((1.)*1.),false,(function TJo))
endfunction
function TKo takes nothing returns nothing
call tto(S_v,"I received information about lady Aruruw, about her excellent skills as a huntress. This might be to our advantage on this task.",9.,function Tko)
endfunction
function Tlo takes nothing returns nothing
call tto(S2v,"Do you aim to challenge me?",4.,function TKo)
endfunction
function TLo takes nothing returns nothing
call tuo(SSv,1.,function Tlo)
endfunction
function Tmo takes nothing returns nothing
call icx(S6v,((1.)*1.),false,(function TLo))
endfunction
function TMo takes nothing returns nothing
call two((S2v),(S1v))
call tuo(Stv,1.,function Tmo)
endfunction
function Tpo takes nothing returns nothing
call two((S1v),(S2v))
call tto(S1v,"This shorty can fight?",2.5,function TMo)
endfunction
function TPo takes nothing returns nothing
call tto(S_v,"Lady Aruruw",3.,function Tpo)
endfunction
function Tqo takes nothing returns nothing
call SetUnitAnimation(zj[((S0v))],("stand ready"))
call tto(S0v,"At your service *kindles a cigarette*",3.,function TPo)
endfunction
function TQo takes nothing returns nothing
call CameraSetupApplyForceDuration(Sqv[((Ssv))],(true),((((.5)*1.))*1.))
call tto(S_v,"Sir Smokealot",2.,function Tqo)
endfunction
function Tso takes nothing returns nothing
call tto(S1v,"Aye",1.5,function TQo)
endfunction
function TSo takes nothing returns nothing
call tuo(SQv,.5,function Tso)
endfunction
function Tto takes nothing returns nothing
call tto(S_v,"Rocketeye",1.,function TSo)
endfunction
function TTo takes nothing returns nothing
call SetUnitAnimation(zj[((S_v))],("spell slam"))
call QueueUnitAnimation(zj[((S_v))],("stand"))
call tto(S_v,"Meanwhile, wild animals of the bordering woods have begun to exploit our storages and to attack the residents. This is the reason I called for the four of you.",7.,function Tto)
endfunction
function Tuo takes nothing returns boolean
local integer rdx=(bv)
local real x=(tm[(Piv)])
local real y=(Tm[(Piv)])
call qco(Ge,x,y,.0)
call icx(inx(),.0,false,function SGo)
call icx(inx(),1.,false,function tFo)
return true
set Skv=GMx(uo)
set SKv=tho(ko)
set SQv=tho(Ko)
set Ssv=tho(lo)
set SSv=tho(Lo)
set Stv=tho(mo)
set STv=tho(Mo)
set Suv=tho(po)
set SUv=tho(Po)
set Swv=tho(qo)
set SWv=tho(Qo)
set Syv=tho(so)
set SYv=Xhx(function tMo)
set S6v=inx()
set S7v=q_x(gx)
set S8v=q_x(Kx)
set S9v=q_x(kx)
set tvv=q_x(Fx)
set tev=q_x(lx)
set txv=q_x(Lx)
set tov=q_x(Hx)
set trv=q_x(jx)
set tiv=q_x(Jx)
set tav=q_x(mx)
set tnv=q_x(Mx)
set tVv=q_x(Gx)
set tEv=q_x(hx)
set S_v=tPo(IGv[Gev],S7v,tXv)
set S1v=tSo(IGv[hRv],S9v,S_v)
set S0v=tSo(IGv[Gbv],S8v,S_v)
set S2v=tSo(IGv[GTv],tvv,S_v)
set S3v=tSo(IGv[G1v],tev,S_v)
set S4v=w
set S5v=w
set tOv=tPo('h008',tVv,kf)
set tRv=tPo('h008',tEv,kf)
set Szv=Qax(tIv,true,false,false,0,0,f5)
set SZv=Qax(tIv,true,false,false,0,0,f5)
call tHo(Ge,false,1)
call tjo(Ge,false)
call CameraSetupApplyForceDuration(Sqv[((tho(ko)))],(true),((((0)*1.))*1.))
call AHx(Szv)
call AHx(SZv)
call SetUnitAnimation(zj[((S_v))],("spell slam"))
call jTo(SYv,Ge,EVENT_PLAYER_END_CINEMATIC)
call tto(S_v,"It's about one month now that you searched for shelter in my domicile Wintercastle. Our supply reserves are at a scant stock, so we have to send out caravans in order to retrieve left-behind goods from the surrounding villages.",$B,function TTo)
call QueueUnitAnimation(zj[((S_v))],("stand"))
call jmo(Ge,q_x(Tx))
return true
endfunction
function TUo takes nothing returns boolean
call DNx(XBx("Intro_Init: call Event.Create(EventType.START, EventPriority.MISC, function Intro.Event_Start).AddToStatics()",XE,LI,function Tuo))
return true
endfunction
function Two takes nothing returns boolean
call kWo(function TUo,"Intro_Init")
return true
endfunction
function TWo takes nothing returns boolean
set tAv=Vnx(tNv)
return true
endfunction
function Tyo takes nothing returns boolean
set tbv=Vnx(tBv)
return true
endfunction
function TYo takes nothing returns boolean
set tcv=Vnx(tCv)
return true
endfunction
function Tzo takes nothing returns boolean
set tdv=Vnx(tDv)
return true
endfunction
function TZo takes nothing returns boolean
set tfv=Vnx(tFv)
return true
endfunction
function T_o takes nothing returns boolean
set tgv=Vnx(tGv)
return true
endfunction
function T0o takes nothing returns boolean
set thv=Vnx(tHv)
return true
endfunction
function T1o takes nothing returns boolean
set tjv=Vnx(tJv)
return true
endfunction
function T2o takes nothing returns boolean
set tkv=Vnx(tKv)
return true
endfunction
function T3o takes nothing returns boolean
set tlv=Vnx(tLv)
return true
endfunction
function T4o takes nothing returns boolean
set tmv=Vnx(tMv)
return true
endfunction
function T5o takes nothing returns boolean
set tpv=Vnx(tPv)
return true
endfunction
function T6o takes nothing returns boolean
set tqv=Vnx(tQv)
return true
endfunction
function T7o takes nothing returns boolean
set tsv=Vnx(tSv)
return true
endfunction
function T8o takes code c,string rqx returns nothing
set fV=fV+1
set FV[fV]=CreateTrigger()
set gV[fV]=(GetHandleId(Condition((c))))
set GV[fV]=rqx
call TriggerAddCondition(FV[fV],Condition(c))
endfunction
function T9o takes integer oqx returns integer
set twv[oqx]=true
set tWv[oqx]=false
set jTv[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set Te[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(tsv)
return oqx
endfunction
function uvo takes nothing returns integer
local integer oqx
if(ttv==8190)then
call oYx("Level_Allocation_allocCustom","call DebugEx(Level.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",tSv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(tTv[(w)]==w)then
set tuv=tuv+1
set oqx=tuv
else
set oqx=tTv[(w)]
set tTv[(w)]=tTv[tTv[(w)]]
endif
set tTv[oqx]=Z
set tUv[oqx]=1
call T9o(oqx)
return oqx
endfunction
function ueo takes integer oqx returns boolean
set lfv=lfv+1
set ye[lfv]=oqx
set QGv[oqx]=lfv+1
return(lfv==0)
endfunction
function uxo takes integer oqx returns nothing
set se[(oqx)]=(tyv+oqx)
endfunction
function uoo takes string rqx returns integer
local integer oqx=uvo()
set Qmv[(oqx)]=(Qmv[oqx])
set Jdv[(oqx)]=(w)
set Ue[(oqx)]=(rqx)
set ue[(oqx)]=(w)
call ueo(oqx)
call uxo(oqx)
return oqx
endfunction
function uro takes nothing returns nothing
local integer oqx=uoo("Deers")
set tYv=oqx
set Qmv[(oqx)]=("ReplaceableTextures\\CommandButtons\\BTNStag.blp")
endfunction
function uio takes nothing returns nothing
local integer oqx=uoo("Trolls")
set k9v=oqx
set Qmv[(oqx)]=("ReplaceableTextures\\CommandButtons\\BTNIceTroll.blp")
endfunction
function uao takes nothing returns nothing
local integer oqx=uoo("Gnolls")
set Kev=oqx
set Qmv[(oqx)]=("ReplaceableTextures\\CommandButtons\\BTNGnollWarden.blp")
endfunction
function uno takes nothing returns nothing
local integer oqx=uoo("Wolves")
set tzv=oqx
set Qmv[(oqx)]=("ReplaceableTextures\\CommandButtons\\BTNTimberWolf.blp")
endfunction
function uVo takes nothing returns nothing
local integer oqx=uoo("Moonkins")
set tZv=oqx
set Qmv[(oqx)]=("ReplaceableTextures\\CommandButtons\\BTNOwlBear.blp")
endfunction
function uEo takes nothing returns nothing
local integer oqx=uoo("SnowFalcons")
set t_v=oqx
set Qmv[(oqx)]=("ReplaceableTextures\\CommandButtons\\BTNWarEagle.blp")
endfunction
function uXo takes nothing returns nothing
local integer oqx=uoo("Kobolds")
set t0v=oqx
set Qmv[(oqx)]=("ReplaceableTextures\\CommandButtons\\BTNKobold.blp")
endfunction
function uOo takes nothing returns nothing
local integer oqx=uoo("Treants")
set t1v=oqx
set Qmv[(oqx)]=("ReplaceableTextures\\CommandButtons\\BTNCorruptedEnt.blp")
endfunction
function uRo takes nothing returns nothing
local integer oqx=uoo("Furbolg Oracle")
set t2v=oqx
set Qmv[(oqx)]=("ReplaceableTextures\\CommandButtons\\BTNFurbolgTracker.blp")
endfunction
function uIo takes nothing returns nothing
local integer oqx=uoo("Scouts")
set t3v=oqx
set Qmv[(oqx)]=("ReplaceableTextures\\CommandButtons\\BTNWyvernRider.blp")
endfunction
function uAo takes nothing returns nothing
local integer oqx=uoo("Axe Fighters")
set t4v=oqx
set Qmv[(oqx)]=("ReplaceableTextures\\CommandButtons\\BTNGrunt.blp")
endfunction
function uNo takes nothing returns nothing
local integer oqx=uoo("Raiders")
set t5v=oqx
set Qmv[(oqx)]=("ReplaceableTextures\\CommandButtons\\BTNRaider.blp")
endfunction
function ubo takes nothing returns nothing
local integer oqx=uoo("Catapults")
set t6v=oqx
set Qmv[(oqx)]=("ReplaceableTextures\\CommandButtons\\BTNCatapult.blp")
endfunction
function uBo takes nothing returns nothing
local integer oqx=uoo("Assassins")
set t7v=oqx
set Qmv[(oqx)]=("ReplaceableTextures\\CommandButtons\\BTNHellScream.blp")
endfunction
function uco takes nothing returns nothing
local integer oqx=uoo("Leader")
set t8v=oqx
set Qmv[(oqx)]=("ReplaceableTextures\\CommandButtons\\BTNChaosWarlord.blp")
endfunction
function uCo takes nothing returns nothing
local integer oqx=uoo("Penguins")
set Tvv=oqx
set lFv[(oqx)]=(true)
set Tev[(oqx)]=("1")
endfunction
function udo takes nothing returns nothing
call uro()
call uio()
call uao()
call uno()
call uVo()
call uEo()
call uXo()
call uOo()
call uRo()
call uIo()
call uAo()
call uNo()
call ubo()
call uBo()
call uco()
set t9v=lfv
call uCo()
set Txv=lfv
endfunction
function uDo takes string iNx returns integer
if not cq then
call BJDebugMsg("Debug (uninit): "+iNx)
endif
return iLx(Ge,"Debug: "+iNx,15.)
endfunction
function ufo takes nothing returns nothing
local integer oqx=jLv
if(oqx==w)then
return
endif
call kAo(oqx)
set oqx=(Jov[(oqx)])
if(oqx==w)then
call uDo("Victory")
else
call kco(oqx)
endif
endfunction
function uFo takes nothing returns nothing
local integer oqx=jpv
if(oqx==w)then
return
endif
call kEo(oqx)
set oqx=(Tov[(oqx)])
if(oqx==w)then
call ufo()
else
call kXo(oqx)
endif
endfunction
function ugo takes nothing returns boolean
local integer rdx=(bv)
local integer k1o=(Qe[(rdx)])
local integer oqx=jpv
if(k1o==(kJo(((oqx)),JCv,((kjo(((oqx)),JCv))))))then
call uFo()
else
call aOx((ue[(k1o)]))
endif
return true
endfunction
function uGo takes nothing returns boolean
local integer rdx=(bv)
call kVo()
return true
endfunction
function uho takes integer oqx returns integer
set TVv[oqx]=true
set TEv[oqx]=false
set JBv[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
call rax(thv)
return oqx
endfunction
function uHo takes nothing returns integer
local integer oqx
if(Trv==8190)then
call oYx("LevelSet_Allocation_allocCustom","call DebugEx(LevelSet.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",tHv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Tiv[(w)]==w)then
set Tav=Tav+1
set oqx=Tav
else
set oqx=Tiv[(w)]
set Tiv[(w)]=Tiv[Tiv[(w)]]
endif
set Tiv[oqx]=Z
set Tnv[oqx]=1
call uho(oqx)
return oqx
endfunction
function ujo takes integer oqx returns nothing
set Jcv[(oqx)]=(TXv+oqx)
endfunction
function uJo takes string rqx,integer RKx returns integer
local integer oqx=uHo()
call ujo(oqx)
set jSv[(oqx)]=(rqx)
set Tov[(oqx)]=(w)
set Tov[(RKx)]=(oqx)
return oqx
endfunction
function uko takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(JBv[(oqx)],(Jcv[((oqx))]),oQx,oSx)
endfunction
function uKo takes integer oqx,integer o6x,integer oQx returns nothing
local integer o7x=(0+(LoadInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx))))))
local integer olx=o7x
local integer array ulo
local integer okx
loop
exitwhen(olx<q)
set ulo[((olx)-q+0)]=(LoadInteger(o[((V[(E[((oqx))])]))],(((o6x))),(((oQx)+(olx)))))
set olx=olx-1
endloop
call dTx(oqx,o6x,oQx)
set olx=((o7x)-q+0)
loop
exitwhen(olx<0)
set okx=(GetRandomInt((0),(olx)))
call rSx(oqx,o6x,oQx,ulo[okx])
set ulo[okx]=ulo[olx]
set olx=olx-1
endloop
endfunction
function uLo takes integer oqx,integer oQx returns nothing
call uKo(JBv[(oqx)],(Jcv[((oqx))]),oQx)
endfunction
function umo takes nothing returns nothing
call uko(((JEv)),JCv,(tYv))
call uko(((JEv)),JCv,(k9v))
call uko(((JEv)),JCv,(Kev))
call uLo(((JEv)),JCv)
call uko(((JXv)),JCv,(tzv))
call uko(((JXv)),JCv,(tZv))
call uko(((JXv)),JCv,(t_v))
call uLo(((JXv)),JCv)
call uko(((JOv)),JCv,(t0v))
call uko(((JOv)),JCv,(t1v))
call uLo(((JOv)),JCv)
call uko(((JRv)),JCv,(t2v))
call uko(((JIv)),JCv,(t3v))
call uko(((JIv)),JCv,(t4v))
call uko(((JIv)),JCv,(t5v))
call uLo(((JEv)),JCv)
call uko(((JAv)),JCv,(t6v))
call uko(((JAv)),JCv,(t7v))
call uLo(((JXv)),JCv)
call uko(((Jbv)),JCv,(t8v))
call uko(((JVv)),JCv,(Tvv))
endfunction
function uMo takes nothing returns nothing
set JEv=uJo("Act 1 - Part 1",w)
set JXv=uJo("Act 1 - Part 2",JEv)
set JOv=uJo("Act 1 - Part 3",JXv)
set JRv=uJo("Act 1 - Boss",JOv)
set JIv=uJo("Act 2 - Part 1",w)
set JAv=uJo("Act 2 - Part 2",JIv)
set JNv=uJo("Act 2 - Part 3",JAv)
set Jbv=uJo("Act 2 - Boss",JNv)
set JVv=uJo("Bonus",w)
call umo()
endfunction
function upo takes integer oqx returns nothing
if(jpv!=w)then
call kEo(jpv)
endif
set jpv=oqx
call aOx((kJo(((oqx)),JCv,(q))))
endfunction
function uPo takes nothing returns boolean
local integer rdx=(bv)
if((eN[(rdx)])!=H0v)then
return true
endif
call kVo()
call upo(jtv)
return true
endfunction
function uqo takes nothing returns boolean
local integer rdx=(bv)
call iJx(jqv)
set jqv=iAx(Opx(H0v)+" type \"-rdy\" in order to start "+(jSv[(jtv)]),Ge)
return true
endfunction
function uQo takes nothing returns nothing
set jQv=XBx("FolderLevelSet_StructQuery_Init: set FolderLevelSet_StructQuery.CHAT_EVENT = Event.Create(User.CHAT_EVENT_TYPE, EventPriority.MISC, function FolderLevelSet_StructQuery.Event_Chat)",LA,LI,function uPo)
set jsv=XBx("FolderLevelSet_StructQuery_Init: set FolderLevelSet_StructQuery.HOST_CHANGE_EVENT = Event.Create(USER.HostAppointment.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderLevelSet_StructQuery.Event_HostChange)",HYv,LI,function uqo)
endfunction
function uso takes nothing returns nothing
call DNx(XBx("LevelSet_Init: call Event.Create(Level.ENDING_EVENT_TYPE, EventPriority.MISC, function LevelSet.Event_LevelEnding).AddToStatics()",te,LI,function ugo))
call DNx(XBx("LevelSet_Init: call Event.Create(Meteorite.GAME_OVER_EVENT_TYPE, EventPriority.MISC, function LevelSet.Event_GameOver).AddToStatics()",JQv,LI,function uGo))
call uMo()
call uQo()
endfunction
function uSo takes nothing returns boolean
set te=(E0x())
set We=(E0x())
call udo()
call uso()
return true
endfunction
function uto takes nothing returns boolean
call T8o(function uSo,"Level_Init")
return true
endfunction
function uTo takes nothing returns boolean
set sov=hGo('uLib')
call hho(((sov)),Apv,(ICv))
set Tj[(sov)]=((1.25)*1.)
set Nav[(sov)]=(('x')*1.)
set Ntv[(sov)]=((60)*1.)
set I3v[(sov)]=((0)*1.)
set Axv[(sov)]=(3)
set NJv[(sov)]=((150000.)*1.)
set Njv[(sov)]=((150000.)*1.)
set Nhv[(sov)]=((0)*1.)
set NIv[(sov)]=((500)*1.)
set NOv[(sov)]=((500)*1.)
set AQv[(sov)]=((0)*1.)
set Asv[(sov)]=((0)*1.)
set Auv[(sov)]=(0)
set AWv[(sov)]=(0)
call hLo((sov),(gQv),1)
return true
endfunction
function uuo takes nothing returns boolean
call VRx(Sa,(function uTo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Library.page\\Library.struct\\obj_shop_wc3unit.j"))
return true
endfunction
function uUo takes nothing returns boolean
set TOv=Vnx(TRv)
return true
endfunction
function uwo takes nothing returns boolean
local integer rdx=(bv)
call aIx((Vv[(rdx)]),PLAYER_COLOR_LIGHT_BLUE)
return true
endfunction
function uWo takes nothing returns boolean
call S8o(sov,XBx("Library_Init: call Library.SHOP.Event.Add(Event.Create(Unit.CREATE_EVENT_TYPE, EventPriority.UNIT_TYPES, function Library.Event_Create))",Igv,PI,function uwo))
return true
endfunction
function uyo takes nothing returns boolean
call kWo(function uWo,"Library_Init")
return true
endfunction
function uYo takes nothing returns boolean
set TIv=L3o('ILum')
call L4o(((TIv)),pS,(AS))
return true
endfunction
function uzo takes nothing returns boolean
set TAv=u1x()
set AC[(TAv)]=("Abilities\\Spells\\Items\\ResourceItems\\BundeOfLumber.wav")
set cC[(TAv)]=(h5)
set dC[(TAv)]=((1)*1.)
set fC[(TAv)]=((1)*1.)
set gC[(TAv)]=($A)
set hC[(TAv)]=((1)*1.)
set LC[(TAv)]=(true)
set MC[(TAv)]=(true)
set PC[(TAv)]=((600)*1.)
set QC[(TAv)]=(($186A0)*1.)
set SC[(TAv)]=(($7D0)*1.)
return true
endfunction
function uZo takes nothing returns boolean
call VRx(sa,(function uYo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Lumber.page\\Lumber.struct\\obj_thisItemType_wc3item.j"))
call VRx(ma,(function uzo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Lumber.page\\Lumber.struct\\obj_dummySound_wc3sound.j"))
return true
endfunction
function u_o takes nothing returns boolean
set TNv=Vnx(Tbv)
return true
endfunction
function u0o takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer PYo=(kfx(CreateItem(Hh[(TIv)],((Tdv[oqx])*1.),((TDv[oqx])*1.))))
call mFo(Tfv[oqx])
call J9x(PYo,Tcv,oqx)
call J8x(PYo,TBv)
endfunction
function u1o takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
set Tfv[oqx]=mHo(Tdv[oqx],TDv[oqx],"Abilities\\Spells\\Human\\slow\\slowtarget.mdl",ri)
endfunction
function u2o takes integer oqx returns nothing
call icx(TCv[oqx],30.,false,function u0o)
call icx(TFv[oqx],30.-5.,false,function u1o)
endfunction
function u3o takes nothing returns boolean
local integer rdx=(bv)
local integer PYo=(Ph[(rdx)])
local integer oqx=Ckx(PYo,Tcv)
call J5x(PYo,Tcv)
call J4x(PYo,TBv)
call u2o(oqx)
return true
endfunction
function u4o takes integer oqx returns integer
set Tjv[oqx]=true
set TJv[oqx]=false
call rax(TNv)
return oqx
endfunction
function u5o takes nothing returns integer
local integer oqx
if(Tgv==8190)then
call oYx("Lumber_Allocation_allocCustom","call DebugEx(Lumber.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Tbv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(TGv[(w)]==w)then
set Thv=Thv+1
set oqx=Thv
else
set oqx=TGv[(w)]
set TGv[(w)]=TGv[TGv[(w)]]
endif
set TGv[oqx]=Z
set THv[oqx]=1
call u4o(oqx)
return oqx
endfunction
function u6o takes integer ozx,integer Ixx returns integer
local real x=(tm[(Ixx)])
local real y=(Tm[(Ixx)])
local integer oqx=u5o()
local integer OHx=inx()
local integer HOx=mcx('qLum',(hm[(ozx)]),(Hm[(ozx)]),(jm[(ozx)]),kf)
local integer sxo=inx()
set TCv[oqx]=OHx
set TFv[oqx]=sxo
set Tkv[oqx]=HOx
set TKv[oqx]=mcx('qLuP',x,y,XYx(x,y),kf)
set Tlv[oqx]=(mHo(((x)*1.),((y)*1.),("buildings\\other\\CircleOfPower\\CircleOfPower.mdl"),(ri)))
set Tdv[oqx]=x
set TDv[oqx]=y
set ge[(OHx)]=(oqx)
set ge[(sxo)]=(oqx)
call SetUnitAnimationByIndex(zj[((HOx))],(3))
call mbx(HOx,2.)
call u2o(oqx)
return oqx
endfunction
function u7o takes nothing returns boolean
local integer rdx=(bv)
call u6o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((ar)))))),((((Nm)))))),q_x(xo))
call u6o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((rr)))))),((((Nm)))))),q_x(oo))
call u6o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((ir)))))),((((Nm)))))),q_x(ro))
call u6o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((xr)))))),((((Nm)))))),q_x(io))
call u6o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((Uo)))))),((((Nm)))))),q_x(ao))
call u6o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((Wo)))))),((((Nm)))))),q_x(no))
call u6o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((yo)))))),((((Nm)))))),q_x(Vo))
call u6o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((wo)))))),((((Nm)))))),q_x(Eo))
call u6o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((Yo)))))),((((Nm)))))),q_x(Xo))
call u6o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((zo)))))),((((Nm)))))),q_x(Oo))
call u6o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((er)))))),((((Nm)))))),q_x(Ro))
call u6o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((Zo)))))),((((Nm)))))),q_x(Io))
call u6o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((vr)))))),((((Nm)))))),q_x(Ao))
return true
endfunction
function u8o takes nothing returns boolean
local integer rdx=(bv)
local integer P7o=Ahx(TAv)
local integer PYo=(Ph[(rdx)])
local integer Oqx=(Vv[(rdx)])
local real x=(GetItemX(Gh[((PYo))]))
local real y=(GetItemY(Gh[((PYo))]))
local real z=P4o(PYo)
local integer oqx=PYo
local integer olx
call P5o(P7o,x,y,z)
call cNx(iqx("+"+(I2S((TLv))),"ff00c850"),1.15*ab,x,y,z,(0))
call R1x(P7o,true)
set olx=Jh
loop
exitwhen(olx<0)
call Lqo(kh[olx],PLAYER_STATE_RESOURCE_LUMBER,TLv)
set olx=olx-1
endloop
return true
endfunction
function u9o takes nothing returns boolean
set TBv=XBx("Lumber_Init: set Lumber.DESTROY_EVENT = Event.Create(Item.DESTROY_EVENT_TYPE, EventPriority.MISC, function Lumber.Event_Destroy)",BS,LI,function u3o)
call DNx(XBx("Lumber_Init: call Event.Create(EventType.START, EventPriority.MISC, function Lumber.Event_Start).AddToStatics()",XE,LI,function u7o))
call pao(TIv,XBx("Lumber_Init: call Lumber.THIS_ITEM_TYPE.Event.Add(Event.Create(UNIT.Items.Events.Use.DUMMY_EVENT_TYPE, EventPriority.MISC, function Lumber.Event_ItemUse))",sh,LI,function u8o))
return true
endfunction
function Uvo takes nothing returns boolean
call kWo(function u9o,"Lumber_Init")
return true
endfunction
function Ueo takes nothing returns boolean
set Tmv=Vnx(TMv)
return true
endfunction
function Uxo takes nothing returns boolean
set Tpv=Vnx(TPv)
return true
endfunction
function Uoo takes nothing returns nothing
set Tsv=Tsv+1
call pbx(Tqv,TSv,Ttv,(I2S((Cv))))
call pbx(Tqv,TTv,Ttv,(I2S(((R2I(((((Cv*1./(Tsv*1./(1*1./ .5)))*1.))*1.)))))))
call pbx(Tqv,Tuv,Ttv,(I2S((FE))))
call pbx(Tqv,TUv,Ttv,(I2S((nr))))
endfunction
function Uro takes nothing returns boolean
local integer rdx=(bv)
call smo((Tqv),((eN[(rdx)])))
call icx(TQv,.5,true,function Uoo)
return true
endfunction
function Uio takes nothing returns nothing
local integer Uao=(s3o(Tqv))
local integer olx
local integer okx
set Uao=(s3o(Tqv))
call pbx(Tqv,Uao,Twv,iZx("Log:","ffffffff","ff00bfff"))
call Pwx(Tqv,Uao,Twv,.2)
set olx=0
loop
exitwhen(olx>8-1)
set okx=0+olx
set TWv[okx]=""
set Uao=(s3o(Tqv))
call Pwx(Tqv,Uao,Twv,.000001)
call Pwx(Tqv,Uao,Ttv,.199999)
set Tyv[okx]=Uao
set olx=olx+1
endloop
set TYv=true
endfunction
function Uno takes nothing returns nothing
set Tzv=CreateQuest()
call QuestSetIconPath(Tzv,"ReplaceableTextures\\CommandButtons\\BTNPeon.blp")
call QuestSetTitle(Tzv,"DebugLog")
endfunction
function UVo takes nothing returns boolean
set Tqv=s2o()
set TQv=inx()
call DNx(XBx("Nullboard_Init: call Event.Create(AfterIntro.FOR_PLAYER_EVENT_TYPE, EventPriority.MISC, function Nullboard.Event_AfterIntro).AddToStatics()",jbv,LI,function Uro))
call s4o((Tqv),("Nullboard"))
set Twv=s7o(Tqv)
set Ttv=s7o(Tqv)
set TSv=(s3o(Tqv))
set TTv=(s3o(Tqv))
set Tuv=(s3o(Tqv))
set TUv=(s3o(Tqv))
call pbx(Tqv,TSv,Twv,iZx("Called triggers:","ffffffff","ff00bfff"))
call pbx(Tqv,TTv,Twv,iZx("Per second:","ffffffff","ff00bfff"))
call pbx(Tqv,Tuv,Twv,iZx("Objs count:","ffffffff","ff00bfff"))
call pbx(Tqv,TUv,Twv,iZx("Native objs count:","ffffffff","ff00bfff"))
call PWx(Tqv,Twv,.1)
call PWx(Tqv,Ttv,.1)
call Uio()
call Uno()
set Tsv=0
return true
endfunction
function UEo takes nothing returns boolean
call kZo(function UVo,"Nullboard_Init")
return true
endfunction
function UXo takes nothing returns boolean
set TZv=Vnx(T_v)
return true
endfunction
function UOo takes nothing returns boolean
set T0v=Vnx(T1v)
return true
endfunction
function URo takes nothing returns boolean
set T2v=Vnx(T3v)
return true
endfunction
function UIo takes nothing returns boolean
set T4v=Vnx(T5v)
return true
endfunction
function UAo takes nothing returns boolean
set T6v=Vnx(T7v)
return true
endfunction
function UNo takes nothing returns boolean
set T8v=Vnx(T9v)
return true
endfunction
function Ubo takes nothing returns boolean
set uvv=Vnx(uev)
return true
endfunction
function UBo takes string Uco,string oSx returns integer
local integer o4x=(s3o(pZ))
set Uco=iqx(Uco,"ffffcc00")
set l0=l0+1
call pbx(pZ,o4x,PZ,Uco)
call pbx(pZ,o4x,QZ,oSx)
set HZ[l0]=o4x
set P0[o4x]=l0
set qZ[l0]=Uco
set sZ[l0]=oSx
return o4x
endfunction
function UCo takes integer oqx returns nothing
set S0[oqx]=0+$A
call p6x(oqx)
endfunction
function Udo takes integer bXx returns integer
local integer oqx=bXx
set DZ[oqx]=false
set CZ[oqx]=bXx
call smo((pZ),(bXx))
call p4x((oqx))
call UCo(oqx)
call p8x((oqx))
call Pex((oqx))
call Pix((oqx),false)
call PEx((oqx),false)
return oqx
endfunction
function UDo takes nothing returns boolean
local integer rdx=(bv)
call Udo((eN[(rdx)]))
return true
endfunction
function Ufo takes nothing returns nothing
set p0=0+3
set M0[0+0]=.0
set M0[0+1]=.5
set M0[0+2]=1.
set M0[0+3]=1.5
set M0[0+4]=2.
set M0[0+5]=2.5
set M0[0+6]=3.
set M0[0+7]=3.5
set M0[0+8]=4.
endfunction
function UFo takes nothing returns nothing
set s0[0]=$546
set s0[0+1]=$5AA
set s0[0+2]=$60E
set s0[0+3]=$672
set s0[0+4]=$6D6
set s0[0+5]=$73A
set s0[0+6]=$79E
set s0[0+7]=$802
set s0[0+8]=$866
set s0[0+9]=$8CA
set s0[0+$A]=$92E
set s0[0+$B]=$992
endfunction
function Ugo takes nothing returns nothing
endfunction
function UGo takes nothing returns nothing
set W0=0
set w0[0]="off"
set w0[0+1]="on"
endfunction
function Uho takes integer oqx returns integer
set uEv[oqx]=true
set uXv[oqx]=false
call rax(a5)
return oqx
endfunction
function UHo takes nothing returns integer
local integer oqx
if(uiv==8190)then
call oYx("Music_Allocation_allocCustom","call DebugEx(Music.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",n5+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(uav[(w)]==w)then
set unv=unv+1
set oqx=unv
else
set oqx=uav[(w)]
set uav[(w)]=uav[uav[(w)]]
endif
set uav[oqx]=Z
set uVv[oqx]=1
call Uho(oqx)
return oqx
endfunction
function Ujo takes string oMx,integer rIx returns integer
local integer oqx=UHo()
set tZ[oqx]=F
set Z0[oqx]=rIx
set UZ[oqx]=oMx
return oqx
endfunction
function UJo takes nothing returns nothing
set n1=Qax("Units\\Human\\Footman\\FootmanPissed4.wav",false,false,false,$A,$A,w)
call AFx(n1,8)
endfunction
function Uko takes nothing returns boolean
local integer rdx=(bv)
set pZ=s2o()
set PZ=s7o(pZ)
set QZ=s7o(pZ)
set uxv=(s3o(pZ))
set u0=UBo("SFX Level","")
set uov=(s3o(pZ))
set v1=UBo("Sound volume","")
set SZ=UBo("Music volume","")
set urv=(s3o(pZ))
set Q0=UBo("Camera zoom","")
set m0=UBo("Camera smoothing factor","")
set U0=UBo("Hint","")
call PWx(pZ,PZ,.1)
call PWx(pZ,QZ,.1)
call s4o((pZ),("Options"))
call pbx(pZ,uov,PZ,iqx("Audio","ffffcc00"))
call Pwx(pZ,uov,PZ,.2)
call Pwx(pZ,uov,QZ,.0)
call pbx(pZ,uxv,PZ,iqx("Graphics","ffffcc00"))
call Pwx(pZ,uxv,PZ,.2)
call Pwx(pZ,uxv,QZ,.0)
call pbx(pZ,urv,PZ,iqx("Misc","ffffcc00"))
call Pwx(pZ,urv,PZ,.2)
call Pwx(pZ,urv,QZ,.0)
call DNx(XBx("OptionsBoard_Event_Start: call Event.Create(AfterIntro.FOR_PLAYER_EVENT_TYPE, EventPriority.MISC, function OptionsBoard.Event_AfterIntro).AddToStatics()",jbv,LI,function UDo))
call Ufo()
call UFo()
call Ugo()
call UGo()
set wZ=Ujo("Sound\\Music\\mp3Music\\Credits.mp3",999)
call UJo()
return true
endfunction
function UKo takes nothing returns boolean
call DNx(XBx("OptionsBoard_Init: call Event.Create(EventType.START, EventPriority.MISC, function OptionsBoard.Event_Start).AddToStatics()",XE,LI,function Uko))
return true
endfunction
function Ulo takes nothing returns boolean
call kZo(function UKo,"OptionsBoard_Init")
return true
endfunction
function ULo takes nothing returns boolean
set uOv=hGo('uPha')
call hho(((uOv)),Apv,(ICv))
set Tj[(uOv)]=((2)*1.)
set Nav[(uOv)]=(('x')*1.)
set Ntv[(uOv)]=((60)*1.)
set I3v[(uOv)]=((0)*1.)
set Axv[(uOv)]=(3)
set NJv[(uOv)]=((150000.)*1.)
set Njv[(uOv)]=((150000.)*1.)
set Nhv[(uOv)]=((0)*1.)
set NIv[(uOv)]=((500)*1.)
set NOv[(uOv)]=((500)*1.)
set AQv[(uOv)]=((0)*1.)
set Asv[(uOv)]=((0)*1.)
set Auv[(uOv)]=(0)
set AWv[(uOv)]=(0)
call hLo((uOv),(gQv),1)
return true
endfunction
function Umo takes nothing returns boolean
call VRx(Sa,(function ULo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\obj_shop_wc3unit.j"))
return true
endfunction
function UMo takes nothing returns boolean
set uRv=Vnx(uIv)
return true
endfunction
function Upo takes nothing returns boolean
call LZx('AEmP',false)
set uAv=Lzo('AEmP')
set G6[(uAv)]=(d6)
set j6[(uAv)]=(1)
set sH[(uAv)]=("Emergency Provisions")
set Ih[(uAv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Oj))))))
set x6v[(uAv)]=(0)
set xzv[(uAv)]=("spell")
call LZo((uAv),fH+(1),((20)*1.))
call LZo((uAv),Lvv+(1),((750)*1.))
return true
endfunction
function UPo takes nothing returns boolean
set uNv=L3o('IEmP')
set MS[(uNv)]=(1)
set LEv[(uNv)]=("ReplaceableTextures\\CommandButtons\\BTNDust.blp")
call L6o((uNv),(uAv),1)
return true
endfunction
function Uqo takes nothing returns boolean
call VRx(qa,(function Upo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\EmergencyProvisions.page\\EmergencyProvisions.struct\\obj_thisSpell_wc3spell.j"))
call VRx(sa,(function UPo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\EmergencyProvisions.page\\EmergencyProvisions.struct\\obj_thisItem_wc3item.j"))
return true
endfunction
function UQo takes nothing returns boolean
set ubv=Vnx(uBv)
return true
endfunction
function Uso takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
call pKo((Abx((CMx),(ucv),(uCv),(Bi))),2.)
call moo(CMx,CMx,udv)
return true
endfunction
function USo takes nothing returns boolean
call meo(uAv,XBx("EmergencyProvisions_Init: call EmergencyProvisions.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function EmergencyProvisions.Event_SpellEffect))",ah,lI,function Uso))
return true
endfunction
function Uto takes nothing returns boolean
call mzo(function USo,"EmergencyProvisions_Init")
return true
endfunction
function UTo takes nothing returns boolean
set uDv=hGo('uEoF')
call hho(((uDv)),Apv,(INv))
set Tj[(uDv)]=((1.25)*1.)
set Nav[(uDv)]=((60)*1.)
set Ntv[(uDv)]=(($E1)*1.)
set I3v[(uDv)]=((0)*1.)
set Axv[(uDv)]=(2)
set NJv[(uDv)]=((65)*1.)
set Njv[(uDv)]=((65)*1.)
set Nhv[(uDv)]=((0)*1.)
set NIv[(uDv)]=(($4B0)*1.)
set NOv[(uDv)]=(($4B0)*1.)
set Ndv[(uDv)]=((60)*1.)
set ANv[(uDv)]=(gSv)
set Adv[(uDv)]=((360)*1.)
set ADv[((uDv))]=((1.*1./((.5)*1.))*1.)
set Atv[(uDv)]=((.1)*1.)
set Drv[(uDv)]=((600)*1.)
set AQv[(uDv)]=((2)*1.)
set Asv[(uDv)]=((2)*1.)
set Auv[(uDv)]=(1)
set AWv[(uDv)]=(3)
set Azv[(uDv)]=(3)
set Aqv[(uDv)]=((16)*1.)
call hLo((uDv),(ufv),1)
call hLo((uDv),(uFv),1)
return true
endfunction
function Uuo takes nothing returns boolean
call LZx('AEoF',false)
set ugv=Lzo('AEoF')
set G6[(ugv)]=(d6)
set j6[(ugv)]=(1)
set sH[(ugv)]=("Eye of the Flame")
set Ih[(ugv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0089)))),(((Oj))))))
set x6v[(ugv)]=(2)
set xzv[(ugv)]=("spell")
call LZo((ugv),fH+(1),(($F)*1.))
call LZo((ugv),Lvv+(1),((550)*1.))
set Mnv[(ugv)]=("ReplaceableTextures\\CommandButtons\\")
return true
endfunction
function UUo takes nothing returns boolean
set uGv=L3o('IEoF')
set MS[(uGv)]=(1)
set LEv[(uGv)]=("ReplaceableTextures\\CommandButtons\\BTNSentryWard.blp")
call L6o((uGv),(ugv),1)
return true
endfunction
function Uwo takes nothing returns boolean
call VRx(Sa,(function UTo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\EyeOfTheFlame.page\\EyeOfTheFlame.struct\\obj_summonUnitType_wc3unit.j"))
call VRx(qa,(function Uuo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\EyeOfTheFlame.page\\EyeOfTheFlame.struct\\obj_thisSpell_wc3spell.j"))
call VRx(sa,(function UUo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\EyeOfTheFlame.page\\EyeOfTheFlame.struct\\obj_thisItem_wc3item.j"))
return true
endfunction
function UWo takes nothing returns boolean
set uhv=Vnx(uHv)
return true
endfunction
function Uyo takes integer oqx,real ilx returns nothing
set gf=ilx
call DSx(((oqx)),(Ouv),(1),w)
endfunction
function UYo takes integer oqx,real ilx returns nothing
if(ilx>=.0)then
set AMv[(oqx)]=("Abilities\\Spells\\Orc\\FeralSpirit\\feralspirittarget.mdl")
call Roo(oqx,Idv)
set A_v[(oqx)]=((.0)*1.)
call Uyo((oqx),((ilx)*1.))
endif
endfunction
function Uzo takes integer rRx,integer ocx,real x,real y,real N8x,real ilx returns integer
local integer oqx=bVx(rRx,ocx,x,y,N8x)
call A7o(Nvo(x,y,"Abilities\\Spells\\Orc\\FeralSpirit\\feralspirittarget.mdl",ri,(ob[(oqx)])))
call SetUnitAnimation(C[((oqx))],("birth"))
call QueueUnitAnimation(C[((oqx))],("stand"))
call UYo(oqx,ilx)
return oqx
endfunction
function UZo takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local integer C0o=(ze[(CMx)])
local integer olx=ujv
loop
call Uzo(uDv,C0o,dix,dax,Kf,uJv)
set olx=olx-1
exitwhen(olx<1)
endloop
return true
endfunction
function U_o takes nothing returns boolean
call meo(ugv,XBx("EyeOfTheFlame_Init: call EyeOfTheFlame.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EyeOfTheFlame.Event_SpellEffect))",ah,pI,function UZo))
return true
endfunction
function U0o takes nothing returns boolean
call mzo(function U_o,"EyeOfTheFlame_Init")
return true
endfunction
function U1o takes nothing returns boolean
set ukv=lQx(uKv+" (dummyBuff)")
return true
endfunction
function U2o takes nothing returns boolean
set ulv=lQx(uKv+" (ignitionBuff)")
set qc[(ulv)]=(true)
set qU[(ulv)]=(true)
return true
endfunction
function U3o takes nothing returns boolean
call LZx('AToL',false)
set ufv=Lzo('AToL')
set G6[(ufv)]=(D6)
set j6[(ufv)]=(1)
set sH[(ufv)]=("Torch Light")
set xzv[(ufv)]=("spell")
call LZo((ufv),Lvv+(1),((750)*1.))
set Mnv[(ufv)]=("ReplaceableTextures\\CommandButtons\\BTNVolcano.blp")
return true
endfunction
function U4o takes nothing returns boolean
call VRx(Ma,(function U1o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\EyeOfTheFlame.page\\EyeOfTheFlame.struct\\TorchLight.page\\TorchLight.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(Ma,(function U2o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\EyeOfTheFlame.page\\EyeOfTheFlame.struct\\TorchLight.page\\TorchLight.struct\\obj_ignitionBuff_wc3buff.j"))
call VRx(qa,(function U3o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\EyeOfTheFlame.page\\EyeOfTheFlame.struct\\TorchLight.page\\TorchLight.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function U5o takes nothing returns boolean
set uLv=Vnx(uKv)
return true
endfunction
function U6o takes integer Ixx returns boolean
return( not(I6x(Ixx,IBv)))and( not(I6x(Ixx,ICv)))
endfunction
function U7o takes integer CMx,integer rwx,integer Ixx returns nothing
local real ilx
if I6x(Ixx,yd)then
set ilx=uMv
else
set ilx=upv
endif
call NIx(Ixx,ulv,rwx,CMx,ilx)
endfunction
function U8o takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
if not U6o(Ixx)then
return true
endif
call U7o((EYv[(rdx)]),(Mv[(rdx)]),Ixx)
return true
endfunction
function U9o takes nothing returns boolean
local integer Ixx=jFx()
if not U6o(Ixx)then
return false
endif
if(E9v[(Ixx)])then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if not(IsUnitEnemy(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function wvo takes integer oqx,real x,real y returns integer
return mjo(oqx,x,y)
endfunction
function weo takes real x,real y,real j8x,integer Q4x returns integer
call Nio((bQ),x,y,j8x,Q4x)
return wvo(bQ,x,y)
endfunction
function wxo takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
local integer woo
set Hf=(ze[(Ixx)])
set woo=weo((GetUnitX(C[((Ixx))])),(GetUnitY(C[((Ixx))])),(ACv[(Ixx)]),uPv)
if(woo!=w)then
call Lvx(Ixx,Xw,woo)
endif
endfunction
function wro takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer Q6o=inx()
set uqv[oqx]=Q6o
call I7x(Ixx,umv)
set ge[(Q6o)]=(oqx)
call icx(Q6o,.5,true,function wxo)
return true
endfunction
function wio takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer Q6o=uqv[oqx]
call Rmx(Ixx,umv)
call ijx(Q6o)
return true
endfunction
function wao takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(ukv),((Mv[(rdx)])),w)
return true
endfunction
function wno takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),ukv)
return true
endfunction
function wVo takes nothing returns boolean
set umv=XBx("TorchLight_Init: set TorchLight.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function TorchLight.Event_Damage)",EZv,pI,function U8o)
set uPv=XLx(function U9o)
call l9x(ukv,XBx("TorchLight_Init: call TorchLight.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TorchLight.Event_BuffGain))",Bd,pI,function wro))
call l9x(ukv,XBx("TorchLight_Init: call TorchLight.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TorchLight.Event_BuffLose))",Jc,pI,function wio))
call meo(ufv,XBx("TorchLight_Init: call TorchLight.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TorchLight.Event_Learn))",pv,pI,function wao))
call meo(ufv,XBx("TorchLight_Init: call TorchLight.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TorchLight.Event_Unlearn))",Av,pI,function wno))
call W_x(E5v,ulv)
return true
endfunction
function wEo takes nothing returns boolean
call mvo(function wVo,"TorchLight_Init")
return true
endfunction
function wXo takes nothing returns boolean
set uQv=L3o('IHeO')
set MS[(uQv)]=(2)
set LEv[(uQv)]=("ReplaceableTextures\\CommandButtons\\BTNHealingSalve.blp")
call L6o((uQv),(usv),1)
return true
endfunction
function wOo takes nothing returns boolean
call LZx('AHeO',false)
set usv=Lzo('AHeO')
set G6[(usv)]=(d6)
set j6[(usv)]=(1)
set sH[(usv)]=("Herbal Ointment")
set Ih[(usv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Oj))))))
set x6v[(usv)]=(0)
set xzv[(usv)]=("spell")
call LZo((usv),fH+(1),(($A)*1.))
call LZo((usv),Lvv+(1),((750)*1.))
return true
endfunction
function wRo takes nothing returns boolean
set uSv=WTx('BHeO',"Herbal Ointment",'bHeO')
set avv[(uSv)]=(true)
set aev[(uSv)]=("ReplaceableTextures\\CommandButtons\\BTNHealingSalve.blp")
call lux(uSv,"Abilities\\Spells\\Other\\ANrl\\ANrlTarget.mdl","origin",ri)
call lux(uSv,"Abilities\\Spells\\Other\\ANrm\\ANrmTarget.mdl","origin",Bi)
return true
endfunction
function wIo takes nothing returns boolean
call VRx(sa,(function wXo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\HerbalOintment.page\\HerbalOintment.struct\\obj_thisItem_wc3item.j"))
call VRx(qa,(function wOo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\HerbalOintment.page\\HerbalOintment.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function wRo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\HerbalOintment.page\\HerbalOintment.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function wAo takes nothing returns boolean
set utv=Vnx(uTv)
return true
endfunction
function wNo takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),uSv)
return true
endfunction
function wbo takes integer oqx,boolean wBo,boolean wco,boolean wCo returns integer
local integer o7x
local integer olx
local integer Iox
if wCo then
call RUx((Abx(((oqx)),("Abilities\\Spells\\Human\\DispelMagic\\DispelMagicTarget.mdl"),("origin"),(ri))))
endif
set o7x=0
set olx=(CXx(((oqx)),eB))
loop
set Iox=(COx(((oqx)),eB,(olx)))
if(qU[(Iox)])then
if(avv[(Iox)])then
if wco then
set o7x=o7x+1
call Ayx(oqx,Iox)
endif
else
if wBo then
set o7x=o7x+1
call Ayx(oqx,Iox)
endif
endif
endif
set olx=olx-1
exitwhen(olx<q)
endloop
return o7x
endfunction
function wdo takes nothing returns nothing
local integer p0x=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(p0x)])
local integer Ixx=uYv[oqx]
call moo(Ixx,Ixx,uzv)
call mro(Ixx,Ixx,uZv)
endfunction
function wDo takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=inx()
set uyv[oqx]=p0x
set uYv[oqx]=Ixx
set ge[(p0x)]=(oqx)
call I7x(Ixx,uuv)
call wbo(Ixx,true,false,true)
call icx(p0x,uWv,true,function wdo)
return true
endfunction
function wfo takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=uyv[oqx]
call ijx(p0x)
call Rmx(Ixx,uuv)
return true
endfunction
function wFo takes nothing returns boolean
local integer rdx=(bv)
call NIx(((Vv[(rdx)])),(uSv),((Mv[(rdx)])),w,((uwv)*1.))
return true
endfunction
function wgo takes nothing returns boolean
set uuv=XBx("HerbalOintment_Init: set HerbalOintment.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.ITEMS, function HerbalOintment.Event_Damage)",Ezv,lI,function wNo)
set uUv=(R2I(((uwv*1./ uWv)*1.)))
call l9x(uSv,XBx("HerbalOintment_Init: call HerbalOintment.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HerbalOintment.Event_BuffGain))",Bd,pI,function wDo))
call l9x(uSv,XBx("HerbalOintment_Init: call HerbalOintment.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HerbalOintment.Event_BuffLose))",Jc,pI,function wfo))
call meo(usv,XBx("HerbalOintment_Init: call HerbalOintment.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function HerbalOintment.Event_SpellEffect))",ah,lI,function wFo))
set uzv=u_v*1./ uUv
set uZv=u0v*1./ uUv
return true
endfunction
function wGo takes nothing returns boolean
call mzo(function wgo,"HerbalOintment_Init")
return true
endfunction
function who takes nothing returns boolean
set u1v=WTx('BScP',"Scroll of Protection",'bScP')
set avv[(u1v)]=(true)
set qU[(u1v)]=(true)
set aev[(u1v)]=("ReplaceableTextures\\CommandButtons\\BTNScroll.blp")
call lux(u1v,"Abilities\\Spells\\Items\\AIda\\AIdaTarget.mdl","overhead",Bi)
call lux(u1v,"Abilities\\Spells\\Other\\ANrm\\ANrmTarget.mdl","origin",Bi)
set SU=lYx()
call l_x(SU,dnv,4)
call l0x(((u1v)),vc+(1),(SU))
return true
endfunction
function wHo takes nothing returns boolean
call VRx(Ma,(function who),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\ScrollOfProtection.page\\ScrollOfProtection.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function wjo takes nothing returns boolean
set u2v=Vnx(u3v)
return true
endfunction
function wJo takes nothing returns boolean
call LZx('AScP',false)
set u4v=Lzo('AScP')
set G6[(u4v)]=(d6)
set j6[(u4v)]=(1)
set sH[(u4v)]=("Scroll of Protection")
set Ih[(u4v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Oj))))))
set x6v[(u4v)]=(0)
set xzv[(u4v)]=("spell")
call LZo((u4v),u6v+(1),((600)*1.))
call LZo((u4v),fH+(1),((40)*1.))
call LZo((u4v),QH+(1),((0)*1.))
call LZo((u4v),Lvv+(1),((750)*1.))
return true
endfunction
function wko takes nothing returns boolean
set u7v=L3o('IScP')
set MS[(u7v)]=(1)
set LEv[(u7v)]=("ReplaceableTextures\\CommandButtons\\BTNScroll.blp")
call L6o((u7v),(u4v),1)
return true
endfunction
function wKo takes nothing returns boolean
call VRx(qa,(function wJo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\ScrollOfProtection.page\\ScrollOfProtection.struct\\obj_thisSpell_wc3spell.j"))
call VRx(sa,(function wko),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\ScrollOfProtection.page\\ScrollOfProtection.struct\\obj_thisItem_wc3item.j"))
return true
endfunction
function wlo takes nothing returns boolean
set u8v=Vnx(u9v)
return true
endfunction
function wLo takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,Icv)then
return false
endif
if not(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function wmo takes integer oqx,integer rwx,integer Ixx returns nothing
call NIx((Ixx),(u1v),(rwx),w,((Uov)*1.))
endfunction
function wMo takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local integer Ixx
call mFo((mHo(((wpo)*1.),((wPo)*1.),(Uxv),(Bi))))
set Hf=(ze[(CMx)])
call Nio(Uvv,wpo,wPo,(Cpx((u4v),u6v+(rwx))),Uev)
set Ixx=Nao(Uvv)
if(Ixx!=w)then
loop
set Ixx=Nao(Uvv)
exitwhen(Ixx==w)
call wmo((w),rwx,Ixx)
endloop
endif
return true
endfunction
function wqo takes nothing returns nothing
endfunction
function wQo takes nothing returns boolean
set Uvv=O2x()
set Uev=XLx(function wLo)
call meo(u4v,XBx("ScrollOfProtection_Init: call ScrollOfProtection.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ScrollOfProtection.Event_SpellEffect))",ah,pI,function wMo))
call wqo()
return true
endfunction
function wso takes nothing returns boolean
call mzo(function wQo,"ScrollOfProtection_Init")
return true
endfunction
function wSo takes nothing returns boolean
set Urv=WTx('BFiW',"Fire Water",'bFiW')
set avv[(Urv)]=(true)
set aev[(Urv)]=("ReplaceableTextures\\CommandButtons\\BTNGreaterInvulneralbility.blp")
call lux(Urv,"Abilities\\Spells\\Other\\ImmolationRed\\ImmolationRedTarget.mdl","chest",ri)
call lux(Urv,"Abilities\\Spells\\Other\\ANrm\\ANrmTarget.mdl","origin",Bi)
return true
endfunction
function wto takes nothing returns boolean
call VRx(Ma,(function wSo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\FireWater.page\\FireWater.struct\\Buff\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function wTo takes nothing returns boolean
set Uiv=Vnx(Uav)
return true
endfunction
function wuo takes nothing returns boolean
call LZx('AFiW',false)
set Unv=Lzo('AFiW')
set G6[(Unv)]=(d6)
set j6[(Unv)]=(1)
set sH[(Unv)]=("Fire Water")
set Ih[(Unv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Oj))))))
set x6v[(Unv)]=(0)
set xzv[(Unv)]=("spell")
call LZo((Unv),u6v+(1),((70)*1.))
call LZo((Unv),fH+(1),((40)*1.))
call LZo((Unv),Lvv+(1),((750)*1.))
return true
endfunction
function wUo takes nothing returns boolean
set UVv=L3o('IFiW')
set MS[(UVv)]=(1)
set LEv[(UVv)]=("ReplaceableTextures\\CommandButtons\\BTNGreaterInvulneralbility.blp")
call L6o((UVv),(Unv),1)
return true
endfunction
function wwo takes nothing returns boolean
call VRx(qa,(function wuo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\FireWater.page\\FireWater.struct\\obj_thisSpell_wc3spell.j"))
call VRx(sa,(function wUo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\FireWater.page\\FireWater.struct\\obj_thisItem_wc3item.j"))
return true
endfunction
function wWo takes nothing returns boolean
set UEv=Vnx(UXv)
return true
endfunction
function wyo takes integer rwx,integer Ixx returns nothing
call NIx((Ixx),(Urv),(rwx),w,((UAv)*1.))
endfunction
function wYo takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
call RUx((Abx((CMx),(UOv),(URv),(Bi))))
call mro(CMx,CMx,UIv)
call wyo(rwx,CMx)
return true
endfunction
function wzo takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function wZo takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
local integer w_o
set Hf=(ze[(Ixx)])
call Nio(Ucv,(GetUnitX(C[((Ixx))])),(GetUnitY(C[((Ixx))])),Udv[oqx],UCv)
set w_o=Nao(Ucv)
if(w_o!=w)then
loop
call nJo((Ixx),(w_o),((UNv)*1.),(true),(false))
set w_o=Nao(Ucv)
exitwhen(w_o==w)
endloop
endif
endfunction
function w0o takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=inx()
set Udv[oqx]=(Cpx((Unv),u6v+(rwx)))
set UDv[oqx]=p0x
set ge[(p0x)]=(oqx)
call icx(p0x,UBv,true,function wZo)
return true
endfunction
function w1o takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=UDv[oqx]
call ijx(p0x)
return true
endfunction
function w2o takes nothing returns nothing
set UNv=Ubv*UBv
set Ucv=O2x()
set UCv=XLx(function wzo)
call l9x(Urv,XBx("FolderFireWater_StructBuff_Init: call FolderFireWater_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderFireWater_StructBuff.Event_BuffGain))",Bd,pI,function w0o))
call l9x(Urv,XBx("FolderFireWater_StructBuff_Init: call FolderFireWater_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderFireWater_StructBuff.Event_BuffLose))",Jc,pI,function w1o))
endfunction
function w3o takes nothing returns boolean
call meo(Unv,XBx("FireWater_Init: call FireWater.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function FireWater.Event_SpellEffect))",ah,lI,function wYo))
call w2o()
return true
endfunction
function w4o takes nothing returns boolean
call PPo(function w3o,"FireWater_Init")
return true
endfunction
function w5o takes nothing returns boolean
set Ufv=L3o('ISDr')
set MS[(Ufv)]=(1)
set LEv[(Ufv)]=("ReplaceableTextures\\CommandButtons\\BTNMinorRejuvPotion.blp")
call L6o((Ufv),(UFv),1)
return true
endfunction
function w6o takes nothing returns boolean
set Ugv=L3o('IThQ')
set MS[(Ugv)]=(1)
set LEv[(Ugv)]=("ReplaceableTextures\\CommandButtons\\BTNRejuvPotion.blp")
call L6o(Ugv,UFv,3)
return true
endfunction
function w7o takes nothing returns boolean
call LZx('AIcT',false)
set UFv=Lzo('AIcT')
set G6[(UFv)]=(d6)
set j6[(UFv)]=(3)
set sH[(UFv)]=("Ice Tea")
set Ih[(UFv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Oj))))))
set x6v[(UFv)]=(0)
set xzv[(UFv)]=("spell")
call LZo((UFv),fH+(1),((20)*1.))
call LZo((UFv),Lvv+(1),((750)*1.))
call LZo((UFv),fH+(2),((20)*1.))
call LZo((UFv),Lvv+(2),((750)*1.))
call LZo((UFv),fH+(3),((20)*1.))
call LZo((UFv),Lvv+(3),((750)*1.))
set UGv[1]=$C8
set UGv[2]=350
set UGv[3]=500
return true
endfunction
function w8o takes nothing returns boolean
set Uhv=L3o('IIcT')
set MS[(Uhv)]=(1)
set LEv[(Uhv)]=("ReplaceableTextures\\CommandButtons\\BTNLesserRejuvPotion.blp")
call L6o(Uhv,UFv,2)
return true
endfunction
function w9o takes nothing returns boolean
call VRx(sa,(function w5o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\IceTea.page\\IceTea.struct\\obj_SoftDrink_wc3item.j"))
call VRx(sa,(function w6o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\IceTea.page\\IceTea.struct\\obj_ThirstQuencher_wc3item.j"))
call VRx(qa,(function w7o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\IceTea.page\\IceTea.struct\\obj_thisSpell_wc3spell.j"))
call VRx(sa,(function w8o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\IceTea.page\\IceTea.struct\\obj_IceTea_wc3item.j"))
return true
endfunction
function Wvo takes nothing returns boolean
set UHv=Vnx(Ujv)
return true
endfunction
function Weo takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
call RUx((Abx((CMx),(UJv),(Ukv),(Bi))))
call mro(CMx,CMx,UGv[rwx])
return true
endfunction
function Wxo takes nothing returns boolean
call meo(UFv,XBx("IceTea_Init: call IceTea.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function IceTea.Event_SpellEffect))",ah,lI,function Weo))
return true
endfunction
function Woo takes nothing returns boolean
call PPo(function Wxo,"IceTea_Init")
return true
endfunction
function Wro takes nothing returns boolean
set UKv=L3o('IMea')
set MS[(UKv)]=(1)
set LEv[(UKv)]=("ReplaceableTextures\\CommandButtons\\BTNMonsterLure.blp")
call L6o((UKv),(Ulv),1)
return true
endfunction
function Wio takes nothing returns boolean
call LZx('AMea',false)
set Ulv=Lzo('AMea')
set G6[(Ulv)]=(d6)
set j6[(Ulv)]=(1)
set sH[(Ulv)]=("Meat")
set Ih[(Ulv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Oj))))))
set x6v[(Ulv)]=(0)
set xzv[(Ulv)]=("spell")
call LZo((Ulv),fH+(1),((20)*1.))
call LZo((Ulv),Lvv+(1),((750)*1.))
return true
endfunction
function Wao takes nothing returns boolean
call VRx(sa,(function Wro),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\Meat.page\\Meat.struct\\obj_thisItem_wc3item.j"))
call VRx(qa,(function Wio),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\Meat.page\\Meat.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Wno takes nothing returns boolean
set ULv=Vnx(Umv)
return true
endfunction
function WVo takes integer oqx returns nothing
set Usv[oqx]=false
call rgx(ULv)
endfunction
function WEo takes integer oqx returns nothing
if(Uqv[oqx]>0)then
return
endif
if(UQv[oqx]!=Z)then
call oYx("Meat_Allocation_deallocCustom_confirm","call DebugEx(Meat.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Umv+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set UQv[oqx]=UQv[(w)]
set UQv[(w)]=oqx
call WVo(oqx)
endfunction
function WXo takes integer oqx returns nothing
set Uqv[oqx]=Uqv[oqx]-1
call WEo(oqx)
endfunction
function WOo takes integer oqx,integer CMx,integer ibx returns nothing
local integer p0x=UPv[oqx]
call WXo((oqx))
if rrx(CMx,Upv,oqx)then
call Rmx(CMx,UMv)
endif
call ijx(ibx)
call ijx(p0x)
endfunction
function WRo takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer olx=CXx(CMx,Upv)
local integer oqx
loop
set oqx=COx(CMx,Upv,olx)
call WOo(oqx,CMx,USv[oqx])
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function WIo takes integer oqx returns integer
set Usv[oqx]=true
set UWv[oqx]=false
call rax(ULv)
return oqx
endfunction
function WAo takes nothing returns integer
local integer oqx
if(UUv==8190)then
call oYx("Meat_Allocation_allocCustom","call DebugEx(Meat.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Umv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(UQv[(w)]==w)then
set Uwv=Uwv+1
set oqx=Uwv
else
set oqx=UQv[(w)]
set UQv[(w)]=UQv[UQv[(w)]]
endif
set UQv[oqx]=Z
set Uqv[oqx]=1
call WIo(oqx)
return oqx
endfunction
function WNo takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=Uyv[oqx]
call pKo((Abx((CMx),(UYv),(Uzv),(Bi))),2.)
call moo(CMx,CMx,UZv)
endfunction
function Wbo takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
call WOo(oqx,Uyv[oqx],ibx)
endfunction
function WBo takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer ibx=inx()
local integer p0x=inx()
local integer oqx=WAo()
set Uyv[oqx]=CMx
set USv[oqx]=ibx
set UPv[oqx]=p0x
if rtx(CMx,Upv,oqx)then
call I7x(CMx,UMv)
endif
set ge[(ibx)]=(oqx)
set ge[(p0x)]=(oqx)
call icx(p0x,Uuv,true,function WNo)
call icx(ibx,UTv,false,function Wbo)
return true
endfunction
function Wco takes nothing returns boolean
set UMv=XBx("Meat_Init: set Meat.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function Meat.Event_Death)",VP,lI,function WRo)
set Utv=(R2I(((UTv*1./ Uuv)*1.)))
call meo(Ulv,XBx("Meat_Init: call Meat.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function Meat.Event_SpellEffect))",ah,lI,function WBo))
set UZv=U_v*1./ Utv
return true
endfunction
function WCo takes nothing returns boolean
call PPo(function Wco,"Meat_Init")
return true
endfunction
function Wdo takes nothing returns boolean
set U0v=lQx(U1v+" (dummyBuff)")
call lux(U0v,"Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTo.mdl","origin",Bi)
call lux(U0v,"Abilities\\Spells\\Other\\ANrm\\ANrmTarget.mdl","origin",Bi)
return true
endfunction
function WDo takes nothing returns boolean
set P5v=L3o('ITpS')
set MS[(P5v)]=(1)
set LEv[(P5v)]=("ReplaceableTextures\\CommandButtons\\BTNScrollUber.blp")
call L6o((P5v),(U2v),1)
return true
endfunction
function Wfo takes nothing returns boolean
call LZx('ATpS',false)
set U2v=Lzo('ATpS')
set G6[(U2v)]=(d6)
set j6[(U2v)]=(1)
set sH[(U2v)]=("Teleport Scroll")
set Ih[(U2v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0278)))),(((Oj))))))
set x6v[(U2v)]=(3)
set xzv[(U2v)]=("spell")
call LZo((U2v),BH+(1),((4)*1.))
call LZo((U2v),fH+(1),((30)*1.))
call LZo((U2v),QH+(1),((0)*1.))
call LZo((U2v),Lvv+(1),((99999)*1.))
return true
endfunction
function WFo takes nothing returns boolean
call VRx(Ma,(function Wdo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\TeleportScroll.page\\TeleportScroll.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(sa,(function WDo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\TeleportScroll.page\\TeleportScroll.struct\\obj_thisItem_wc3item.j"))
call VRx(qa,(function Wfo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\TeleportScroll.page\\TeleportScroll.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Wgo takes nothing returns boolean
set U3v=Vnx(U1v)
return true
endfunction
function WGo takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer olx=CXx(Ixx,U8v)
local integer oqx
local integer CMx
loop
set oqx=COx(Ixx,U8v,olx)
set CMx=oqx
call Ayx(CMx,U0v)
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function Who takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,ICv)then
return false
endif
if not(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function WHo takes integer oqx,real x,real y returns integer
local integer Xko=Nao((oqx))
local real mJo
local integer NEo
local boolean mko
local real mKo
if(Xko==w)then
return w
endif
set mko=false
loop
set mKo=iOx(.0,jjx(DPx(Xko)-x,DQx(Xko)-y)-dvx(Xko,true))
call GroupAddUnit(Kb[(yQ)],C[(Xko)])
if not mko then
set mJo=mKo
set NEo=Xko
set mko=true
elseif(mKo<mJo)then
set mJo=mKo
set NEo=Xko
endif
set Xko=Nao((oqx))
exitwhen(Xko==w)
endloop
call Nno((oqx),yQ)
return NEo
endfunction
function Wjo takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer dox=wvv
local real WJo=wev
local real Wko=wxv
local integer oqx=CMx
local integer drx
local real WKo
local real Wlo
local real WLo
local real Wmo
local real dX
local real dY
local real N8x
if(dox==w)then
set Hf=(ze[(CMx)])
call GroupEnumUnitsInRect(Kb[((U4v))],bm[Bm],Bv[(U9v)])
set drx=(WHo((U4v),((WJo)*1.),((Wko)*1.)))
if(drx==w)then
return true
endif
set WLo=(GetUnitX(C[((drx))]))
set Wmo=(GetUnitY(C[((drx))]))
set dX=WJo-WLo
set dY=Wko-Wmo
if(Gyx(dX,dY)>U5v)then
set N8x=(Atan2(((dY)*1.),((dX)*1.)))
set WKo=U6v*(Cos(((((N8x)*1.))*1.)))
set Wlo=U6v*(Sin(((((N8x)*1.))*1.)))
else
set WKo=WJo-WLo
set Wlo=Wko-Wmo
endif
else
if(hw==w)then
return true
endif
if I6x(hw,sc)then
return true
endif
set WKo=.0
set Wlo=.0
set drx=hw
endif
set wov[oqx]=drx
set wrv[oqx]=(Abx((drx),(wiv),(wav),(Bi)))
set wnv[oqx]=WKo
set wVv[oqx]=Wlo
if rtx(drx,U8v,oqx)then
call I7x(drx,U7v)
endif
call rzx(((CMx)),((gQv)),(1))
return true
endfunction
function WMo takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer oqx=CMx
local integer Ixx=wov[oqx]
local integer Wpo=wrv[oqx]
if rrx(Ixx,U8v,oqx)then
call Rmx(Ixx,U7v)
endif
call RUx(Wpo)
call rLx(CMx,gQv)
return true
endfunction
function WPo takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local boolean Eko=(ovv[(rdx)])
local integer oqx=CMx
local integer Ixx=wov[oqx]
local real WKo=wnv[oqx]
local real Wlo=wVv[oqx]
call Ayx(CMx,U0v)
if Eko then
call pKo((Abx((CMx),(wEv),(wXv),(Bi))),2.)
call SetUnitPosition(C[((CMx))],(((GetUnitX(C[((Ixx))]))+WKo)*1.),(((GetUnitY(C[((Ixx))]))+Wlo)*1.))
endif
return true
endfunction
function Wqo takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
set wvv=(TH[(rdx)])
set wev=(UH[(rdx)])
set wxv=(wH[(rdx)])
call Q8o(CMx,U0v,(Mv[(rdx)]))
return true
endfunction
function WQo takes nothing returns boolean
set U4v=O2x()
set U5v=U6v*U6v
set U7v=XBx("TeleportScroll_Init: set TeleportScroll.TARGET_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function TeleportScroll.Event_TargetDeath)",VP,lI,function WGo)
set U9v=XLx(function Who)
call l9x(U0v,XBx("TeleportScroll_Init: call TeleportScroll.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TeleportScroll.Event_BuffGain))",Bd,pI,function Wjo))
call l9x(U0v,XBx("TeleportScroll_Init: call TeleportScroll.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TeleportScroll.Event_BuffLose))",Jc,pI,function WMo))
call meo(U2v,XBx("TeleportScroll_Init: call TeleportScroll.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TeleportScroll.Event_EndCast))",oev,pI,function WPo))
call meo(U2v,XBx("TeleportScroll_Init: call TeleportScroll.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TeleportScroll.Event_SpellEffect))",ah,pI,function Wqo))
return true
endfunction
function Wso takes nothing returns boolean
call PPo(function WQo,"TeleportScroll_Init")
return true
endfunction
function WSo takes nothing returns boolean
set wOv=L3o('IRun')
call L4o(((wOv)),pS,(AS))
return true
endfunction
function Wto takes nothing returns boolean
call VRx(sa,(function WSo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Rune.page\\Rune.struct\\obj_thisItem_wc3item.j"))
return true
endfunction
function WTo takes nothing returns boolean
set wRv=Vnx(wIv)
return true
endfunction
function Wuo takes code c,string rqx returns nothing
set mV=mV+1
set MV[mV]=CreateTrigger()
set pV[mV]=(GetHandleId(Condition((c))))
set PV[mV]=rqx
call TriggerAddCondition(MV[mV],Condition(c))
endfunction
function WUo takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if not(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function Wwo takes integer oqx returns integer
set wFv[oqx]=true
set wgv[oqx]=false
call rax(wRv)
return oqx
endfunction
function WWo takes nothing returns integer
local integer oqx
if(wCv==8190)then
call oYx("Rune_Allocation_allocCustom","call DebugEx(Rune.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",wIv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(wdv[(w)]==w)then
set wDv=wDv+1
set oqx=wDv
else
set oqx=wdv[(w)]
set wdv[(w)]=wdv[wdv[(w)]]
endif
set wdv[oqx]=Z
set wfv[oqx]=1
call Wwo(oqx)
return oqx
endfunction
function Wyo takes integer oqx returns nothing
set wFv[oqx]=false
call rgx(wRv)
endfunction
function WYo takes integer oqx returns nothing
if(wfv[oqx]>0)then
return
endif
if(wdv[oqx]!=Z)then
call oYx("Rune_Allocation_deallocCustom_confirm","call DebugEx(Rune.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",wIv+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set wdv[oqx]=wdv[(w)]
set wdv[(w)]=oqx
call Wyo(oqx)
endfunction
function Wzo takes integer oqx returns nothing
set wfv[oqx]=wfv[oqx]-1
call WYo(oqx)
endfunction
function WZo takes integer oqx,integer ibx,integer W_o returns nothing
call Wzo((oqx))
call ijx(ibx)
call J5x(W_o,wHv)
call J4x(W_o,wjv)
endfunction
function W0o takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local integer W_o=whv[oqx]
call WZo(oqx,ibx,W_o)
call SetWidgetLife(Gh[(W_o)],.0)
endfunction
function W1o takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
local integer oqx
local integer ibx
local integer W_o
if((FG[(rdx)])==w)then
return true
endif
if(wBv<wcv)then
set wBv=wBv+1
return true
endif
set wBv=0
set oqx=WWo()
set ibx=inx()
set W_o=(kfx(CreateItem(Hh[(wOv)],(((GetUnitX(C[((Oqx))])))*1.),(((GetUnitY(C[((Oqx))])))*1.))))
set wGv[oqx]=ibx
set whv[oqx]=W_o
set ge[(ibx)]=(oqx)
call J9x(W_o,wHv,oqx)
call J8x(W_o,wjv)
call icx(ibx,wJv,false,function W0o)
return true
endfunction
function W2o takes nothing returns boolean
local integer rdx=(bv)
local integer W_o=(Ph[(rdx)])
local integer oqx=Ckx(W_o,wHv)
call WZo(oqx,wGv[oqx],W_o)
return true
endfunction
function W3o takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call RDo(Oqx,wbv)
return true
endfunction
function W4o takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx
local integer CDx=(Ph[(rdx)])
local integer Oqx=(Vv[(rdx)])
local real W5o=(GetItemX(Gh[((CDx))]))
local real W6o=(GetItemY(Gh[((CDx))]))
call mFo((mHo(((W5o)*1.),((W6o)*1.),(wkv),(Bi))))
set Hf=(ze[(Oqx)])
call Nio(wAv,W5o,W6o,wKv,wNv)
set Ixx=Nao(wAv)
if(Ixx!=w)then
loop
call moo(Ixx,Ixx,(iG[(Ixx)])*wlv)
call BRx(Ixx,(mF[(Ixx)])*wLv)
set Ixx=Nao(wAv)
exitwhen(Ixx==w)
endloop
endif
return true
endfunction
function W7o takes nothing returns boolean
set wAv=O2x()
set wNv=XLx(function WUo)
set wbv=P_o(XBx("Rune_Init: set Rune.THIS_DROP = CustomDrop.Create(Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function Rune.Event_Spawn_Death), null, null, EffectLevel.NORMAL)",VP,lI,function W1o),null,null,Bi)
set wjv=XBx("Rune_Init: set Rune.RUNE_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function Rune.Event_Rune_Death)",VP,LI,function W2o)
call DNx(XBx("Rune_Init: call Event.Create(Spawn.DUMMY_EVENT_TYPE, EventPriority.MISC, function Rune.Event_Spawn).AddToStatics()",aw,LI,function W3o))
call pao(wOv,XBx("Rune_Init: call Rune.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Use.DUMMY_EVENT_TYPE, EventPriority.MISC, function Rune.Event_ItemUse))",sh,LI,function W4o))
return true
endfunction
function W8o takes nothing returns boolean
call Wuo(function W7o,"Rune_Init")
return true
endfunction
function W9o takes nothing returns boolean
set wmv=hGo('uSnM')
call hho(((wmv)),Apv,(ICv))
call hho(((wmv)),Apv,(INv))
set Tj[(wmv)]=((2)*1.)
set Nav[(wmv)]=((20)*1.)
set Ntv[(wmv)]=((60)*1.)
set I3v[(wmv)]=((0)*1.)
set Axv[(wmv)]=(1)
set NJv[(wmv)]=(($C8)*1.)
set Njv[(wmv)]=(($C8)*1.)
set Nhv[(wmv)]=((0)*1.)
set NIv[(wmv)]=(($5DC)*1.)
set NOv[(wmv)]=(($5DC)*1.)
set Ndv[(wmv)]=((25)*1.)
set AQv[(wmv)]=((0)*1.)
set Asv[(wmv)]=((0)*1.)
set Auv[(wmv)]=(0)
set AWv[(wmv)]=(0)
set Nxv[(wmv)]=(30)
return true
endfunction
function yvo takes nothing returns boolean
set wMv=L3o('ISno')
call L4o(((wMv)),pS,(AS))
return true
endfunction
function yeo takes nothing returns boolean
set wpv=WTx('BPos',"Possession",'bPos')
set avv[(wpv)]=(true)
set aev[(wpv)]=("ReplaceableTextures\\CommandButtons\\BTNMagicalSentry.blp")
return true
endfunction
function yxo takes nothing returns boolean
call VRx(Sa,(function W9o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Snowmen.page\\Snowmen.struct\\obj_thisUnitType_wc3unit.j"))
call VRx(sa,(function yvo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Snowmen.page\\Snowmen.struct\\obj_thisItemType_wc3item.j"))
call VRx(Ma,(function yeo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Snowmen.page\\Snowmen.struct\\obj_possessionBuff_wc3buff.j"))
return true
endfunction
function yoo takes nothing returns boolean
set wPv=Vnx(wqv)
return true
endfunction
function yro takes nothing returns boolean
local integer rdx=(bv)
local integer yio=(Vv[(rdx)])
local real x=(GetUnitX(C[((yio))]))
local real y=(GetUnitY(C[((yio))]))
call OTx(yio)
call kfx(CreateItem(Hh[(wMv)],((x)*1.),((y)*1.)))
set wsv=wsv-1
if(wsv==0)then
set lzv=lzv-((.25)*1.)
call iLx(Ge,iqx("Notification:","ffffcc00")+" "+iqx("You lost control of the last Flower. The spawns' supply loot is reset to the default value.","ffff0000"),10.)
endif
return true
endfunction
function yao takes nothing returns boolean
local integer rdx=(bv)
call SetItemInvulnerable(Gh[((Ph[(rdx)]))],(true))
return true
endfunction
function yno takes nothing returns boolean
local integer rdx=(bv)
local integer yVo=(Ph[(rdx)])
local real x=(GetItemX(Gh[((yVo))]))
local real y=(GetItemY(Gh[((yVo))]))
local integer yio=bVx(wmv,Buv,x,y,Kf)
call I7x(yio,wQv)
call rzx(((yio)),((gQv)),(1))
call rzx((yio),(uFv),(2))
call SetUnitAnimation(C[((yio))],("birth"))
call QueueUnitAnimation(C[((yio))],("stand"))
call NIx((yio),(wpv),(1),w,((30.+.01)*1.))
call pKo((Abx((yio),(wSv),(wtv),(Bi))),2.)
call Uyo((yio),((30.)*1.))
set wsv=wsv+1
if(wsv==1)then
set lzv=lzv+((.25)*1.)
call iLx(Ge,iqx("Notification:","ffffcc00")+" "+iqx("You got control of a Flower, all enemy units drop "+(I2S(((R2I(((((.25*100.)*1.))*1.))))))+"%"+" more supply.","ff00ff00"),10.)
endif
return true
endfunction
function yEo takes nothing returns boolean
set wQv=XBx("Snowmen_Init: set Snowmen.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function Snowmen.Event_Death)",VP,LI,function yro)
call pao(wMv,XBx("Snowmen_Init: call Snowmen.THIS_ITEM_TYPE.Event.Add(Event.Create(Item.CREATE_EVENT_TYPE, EventPriority.MISC, function Snowmen.Event_Create))",NS,LI,function yao))
call pao(wMv,XBx("Snowmen_Init: call Snowmen.THIS_ITEM_TYPE.Event.Add(Event.Create(UNIT.Items.Events.Use.DUMMY_EVENT_TYPE, EventPriority.MISC, function Snowmen.Event_Use))",sh,LI,function yno))
return true
endfunction
function yXo takes nothing returns boolean
call kWo(function yEo,"Snowmen_Init")
return true
endfunction
function yOo takes nothing returns boolean
set wTv=Vnx(wuv)
return true
endfunction
function yRo takes nothing returns boolean
set wUv=Vnx(wwv)
return true
endfunction
function yIo takes nothing returns boolean
set wWv=Vnx(wyv)
return true
endfunction
function yAo takes nothing returns boolean
set wYv=Vnx(wzv)
return true
endfunction
function yNo takes nothing returns boolean
set wZv=Vnx(w_v)
return true
endfunction
function ybo takes nothing returns boolean
set w0v=Vnx(w1v)
return true
endfunction
function yBo takes nothing returns boolean
set w2v=Vnx(w3v)
return true
endfunction
function yco takes nothing returns boolean
set w4v=Vnx(w5v)
return true
endfunction
function yCo takes nothing returns boolean
set w6v=Vnx(w7v)
return true
endfunction
function ydo takes nothing returns boolean
set w8v=Vnx(w9v)
return true
endfunction
function yDo takes nothing returns boolean
set Wvv=Vnx(Wev)
return true
endfunction
function yfo takes nothing returns boolean
set Wxv=Vnx(Wov)
return true
endfunction
function yFo takes nothing returns boolean
set Wrv=Vnx(Wiv)
return true
endfunction
function ygo takes nothing returns boolean
set Wav=Vnx(Wnv)
return true
endfunction
function yGo takes nothing returns boolean
set WVv=Vnx(WEv)
return true
endfunction
function yho takes nothing returns boolean
set WXv=lQx(WOv+" (dummyBuff)")
return true
endfunction
function yHo takes nothing returns boolean
call VRx(Ma,(function yho),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Spawn.page\\Spawn.struct\\Shadow\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function yjo takes nothing returns boolean
set WRv=Vnx(WOv)
return true
endfunction
function yJo takes nothing returns boolean
set WIv=Vnx(WAv)
return true
endfunction
function yko takes nothing returns nothing
call Oux()
endfunction
function yKo takes nothing returns nothing
if(WBv[((k_o((qe),JLv)))])then
if(not(dKx((Ob),Rb))or not((Wcv)==F))then
return
endif
endif
call aEx(qe)
endfunction
function ylo takes nothing returns boolean
local integer rdx=(bv)
local integer OUx=(Vv[(rdx)])
call Rmx(OUx,Wbv)
call IEo(Ob,OUx)
if(WBv[((k_o((qe),JLv)))])then
call yKo()
endif
return true
endfunction
function yLo takes nothing returns nothing
local integer olx=Hl
local integer Oqx
loop
exitwhen(olx<0)
set Oqx=(kv[(jl[olx])])
if(Oqx!=w)then
if I6x(Oqx,sc)then
call qLo(Oqx,(GetUnitX(C[((Oqx))])),(GetUnitY(C[((Oqx))])))
endif
call RUx((Abx((Oqx),("Abilities\\Spells\\Items\\AIre\\AIreTarget.mdl"),("origin"),(ri))))
call cFx(Oqx,(iG[(Oqx)]))
call BOx(Oqx,(mF[(Oqx)]))
endif
set olx=olx-1
endloop
endfunction
function ymo takes nothing returns boolean
local integer rdx=(bv)
local integer klo=(juv[(rdx)])
if((Jav[(klo)])and not(Jav[((Jov[(klo)]))]))then
call Oux()
call yLo()
endif
return true
endfunction
function yMo takes integer oqx returns boolean
if(((Wdv[((oqx))])>0)==false)then
return false
endif
set Wdv[WDv[Wcv]]=Wdv[oqx]
set WDv[Wdv[oqx]-1]=WDv[Wcv]
set Wdv[oqx]=0
set Wcv=Wcv-1
return(Wcv==F)
endfunction
function ypo takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((Wfv[(oqx)]))])]))],((((WFv[((oqx))])))),(((oQx))))))
endfunction
function yPo takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((Wfv[(oqx)]))])]))],((((WFv[((oqx))])))),(((oQx)+(okx)))))
endfunction
function yqo takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((Wfv[(oqx)]))])]))],((((WFv[((oqx))])))),(((oQx)))))
endfunction
function yQo takes integer oqx returns nothing
local integer olx
local integer NVo
if(oqx==w)then
return
endif
if not((Wdv[((oqx))])>0)then
return
endif
call yMo(oqx)
set olx=(ypo(((oqx)),Wgv))
loop
exitwhen(olx<q)
set NVo=(yPo(((oqx)),Wgv,(olx)))
call iHx((yqo(((oqx)),WGv+(NVo))))
call iHx(Whv[oqx])
set olx=olx-1
endloop
endfunction
function yso takes nothing returns boolean
local integer rdx=(bv)
call yQo((k_o(((Qe[(rdx)])),JLv)))
return true
endfunction
function ySo takes integer oqx returns real
return iOx((Wkv[(oqx)]),(WKv[(oqx)]))
endfunction
function yto takes nothing returns nothing
call yKo()
endfunction
function yTo takes integer oqx returns boolean
if((Wdv[((oqx))])>0)then
return false
endif
set Wcv=Wcv+1
set WDv[Wcv]=oqx
set Wdv[oqx]=Wcv+1
return(Wcv==0)
endfunction
function yuo takes integer oqx,integer oQx returns real
return(LoadReal(o[((V[(E[((Wfv[(oqx)]))])]))],((((WFv[((oqx))])))),(((oQx)))))
endfunction
function yUo takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((WMv[(oqx)]))])]))],((((Wpv[((oqx))])))),(((oQx))))))
endfunction
function ywo takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((WMv[(oqx)]))])]))],((((Wpv[((oqx))])))),(((oQx)+(okx)))))
endfunction
function yWo takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((WMv[(oqx)]))])]))],((((Wpv[((oqx))])))),(((oQx)))))
endfunction
function yyo takes integer oqx returns integer
set WYv[oqx]=true
set Wzv[oqx]=false
call rax(WVv)
return oqx
endfunction
function yYo takes nothing returns integer
local integer oqx
if(WUv==8190)then
call oYx("FolderSpawn_StructQueue_Allocation_allocCustom","call DebugEx(FolderSpawn_StructQueue.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",WEv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Wwv[(w)]==w)then
set WWv=WWv+1
set oqx=WWv
else
set oqx=Wwv[(w)]
set Wwv[(w)]=Wwv[Wwv[(w)]]
endif
set Wwv[oqx]=Z
set Wyv[oqx]=1
call yyo(oqx)
return oqx
endfunction
function yzo takes integer oqx returns boolean
return(W3v==oqx)or((W4v[oqx]!=w)or(W5v[oqx]!=w))
endfunction
function yZo takes integer oqx returns boolean
if yzo(oqx)then
return false
endif
set W5v[oqx]=w
if(W3v==w)then
set W6v=oqx
set W3v=oqx
return true
endif
set W4v[oqx]=W6v
set W5v[W6v]=oqx
set W6v=oqx
return false
endfunction
function y_o takes nothing returns integer
local integer oqx=W3v
if(oqx==w)then
return w
endif
set W3v=W5v[oqx]
set W5v[oqx]=w
if(W3v==w)then
set W6v=w
else
set W4v[W3v]=w
endif
return oqx
endfunction
function y0o takes integer oqx returns nothing
set WYv[oqx]=false
call rgx(WVv)
endfunction
function y1o takes integer oqx returns nothing
if(Wyv[oqx]>0)then
return
endif
if(Wwv[oqx]!=Z)then
call oYx("FolderSpawn_StructQueue_Allocation_deallocCustom_confirm","call DebugEx(FolderSpawn_StructQueue.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",WEv+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set Wwv[oqx]=Wwv[(w)]
set Wwv[(w)]=oqx
call y0o(oqx)
endfunction
function y2o takes integer oqx returns nothing
set Wyv[oqx]=Wyv[oqx]-1
call y1o(oqx)
endfunction
function y3o takes integer Ixx returns nothing
local integer oqx=(W8v[(GetRandomInt(((0)),((W9v))))])
call RDo(Ixx,yvv[oqx])
endfunction
function y4o takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((yov[oqx]))])]))],((((yxv[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function y5o takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((yov[oqx]))])]))],((((yxv[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function y6o takes integer rRx,integer Oqx returns nothing
local integer rdx=rEx(0)
local integer Gmx
local integer olx
local integer rIx
local integer rlx
set yev[(rdx)]=(rRx)
set Vv[(rdx)]=(Oqx)
set Gmx=rEx((yxv[(rRx)]))
set yev[(Gmx)]=(rRx)
set Vv[(Gmx)]=(Oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((aw))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((aw))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set rlx=y4o(rRx,aw,rIx)
loop
exitwhen(rlx<q)
call rCx(y5o(rRx,aw,rIx,rlx),Gmx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
call rHx(((Gmx)))
endfunction
function y7o takes integer rRx,integer lYo,real x,real y,real N8x returns nothing
local real izx=(Nwv[(lYo)])
local real NJx=(Nlv[(lYo)])
local integer lzo
set Nlv[(lYo)]=((NJx*.5)*1.)
set Nwv[(lYo)]=((.0)*1.)
set lzo=bVx(lYo,HWv,x,y,N8x)
call dpx(Ob,lzo)
call I7x(lzo,Wbv)
call fPx(lzo,.0,.0,.0,izx,3.)
set Nlv[(lYo)]=((NJx)*1.)
set Nwv[(lYo)]=((izx)*1.)
if((GetRandomInt((1),(17)))==17)then
call y3o(lzo)
endif
call y6o(rRx,lzo)
call B7x(lzo,(s2v[(pe)])*(mg[(lzo)]))
call cPx(lzo,iOx(.405,(Me[(pe)])*(iG[(lzo)])))
call cFx(lzo,(iG[(lzo)]))
endfunction
function y8o takes nothing returns nothing
local integer oqx=y_o()
local integer rRx=WZv[oqx]
local integer lYo=W_v[oqx]
local real x=W0v[oqx]
local real y=W1v[oqx]
local real N8x=W2v[oqx]
call y2o((oqx))
if(W3v==w)then
call iHx(W7v)
endif
call y7o(rRx,lYo,x,y,N8x)
endfunction
function y9o takes integer rRx,integer lYo,real x,real y,real N8x returns nothing
local integer oqx=yYo()
set WZv[oqx]=rRx
set W_v[oqx]=lYo
set W0v[oqx]=x
set W1v[oqx]=y
set W2v[oqx]=N8x
if yZo(oqx)then
call icx(W7v,.75,true,function y8o)
endif
endfunction
function Yvo takes integer rRx,integer lYo,real x,real y,real N8x returns nothing
call y9o(rRx,lYo,x,y,N8x)
endfunction
function Yeo takes nothing returns nothing
local integer NVo=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer olx=(yUo((NVo),WPv))
local integer Yxo
local real N8x
local real Gux
local real GUx
local real Gtx
local real GTx
local integer rlx
local integer rRx
local integer nyx
loop
exitwhen(olx<q)
set Yxo=(ywo((NVo),WPv,(olx)))
set N8x=Wqv[Yxo]
set Gux=WQv[Yxo]
set GUx=Wsv[Yxo]
set Gtx=WSv[Yxo]
set GTx=Wtv[Yxo]
set rlx=(yUo((NVo),WTv))
loop
exitwhen(rlx<q)
set rRx=(ywo((NVo),WTv,(rlx)))
set nyx=(yWo((NVo),Wuv+(rRx)))
loop
exitwhen(nyx<1)
call Yvo(rRx,(yrv[(rRx)]),(GetRandomReal(((Gtx)*1.),((Gux)*1.))),(GetRandomReal(((GTx)*1.),((GUx)*1.))),N8x)
set nyx=nyx-1
endloop
set rlx=rlx-1
endloop
set olx=olx-1
endloop
endfunction
function Yoo takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
call yQo(oqx)
endfunction
function Yro takes integer oqx returns nothing
local integer olx
local integer NVo
call yTo(oqx)
set olx=(ypo(((oqx)),Wgv))
loop
exitwhen(olx<q)
set NVo=(yPo(((oqx)),Wgv,(olx)))
call icx((yqo(((oqx)),WGv+(NVo))),(yuo(((oqx)),Wmv+(NVo))),false,function Yeo)
call icx(Whv[oqx],ySo(oqx),false,function Yoo)
set olx=olx-1
endloop
endfunction
function Yio takes nothing returns boolean
local integer rdx=(bv)
local integer k1o=(Qe[(rdx)])
local integer l4o=(k_o((k1o),JLv))
local integer Yao
local integer Yno
if(l4o==w)then
return true
endif
set Yao=(ue[(k1o)])
set Yno=(k_o((Yao),JLv))
set WHv=0
if(Yao==w)then
call TimerDialogDisplay(Wjv[(WJv)],false)
call icx(WCv,ySo(l4o)+(Wlv[(l4o)]),false,function yto)
else
if(WBv[(l4o)])then
call TimerDialogDisplay(Wjv[(WJv)],false)
else
call TimerDialogSetTitle(Wjv[(WJv)],("Level "+(Ue[(Yao)])+" begins in: "))
call icx(WCv,ySo(l4o)+(Wlv[(l4o)])+(WLv[(Yno)]),false,function yto)
endif
endif
call Yro(l4o)
return true
endfunction
function YVo takes nothing returns boolean
local integer rdx=(bv)
call DNx(XBx("Spawn_Event_Start: call Event.Create(Level.ENDING_EVENT_TYPE, EventPriority.MISC, function Spawn.Event_LevelEnding).AddToStatics()",te,LI,function yso))
call DNx(XBx("Spawn_Event_Start: call Event.Create(Level.START_EVENT_TYPE, EventPriority.MISC, function Spawn.Event_LevelStart).AddToStatics()",We,LI,function Yio))
return true
endfunction
function YEo takes nothing returns nothing
local integer olx=Wcv
loop
exitwhen(olx<0)
set yiv[olx]=WDv[olx]
set olx=olx-1
endloop
set yav=Wcv
endfunction
function YXo takes nothing returns integer
local integer o4x
if(yav<0)then
return w
endif
set o4x=yiv[0]
set yiv[0]=yiv[yav]
set yav=yav-1
return o4x
endfunction
function YOo takes nothing returns nothing
local integer oqx
call YEo()
loop
set oqx=YXo()
exitwhen(oqx==w)
call yQo(oqx)
endloop
endfunction
function YRo takes nothing returns boolean
local integer rdx=(bv)
call iHx(WCv)
call YOo()
return true
endfunction
function YIo takes integer oqx returns integer
set yOv[oqx]=true
set yRv[oqx]=false
call rax(vIv)
return oqx
endfunction
function YAo takes nothing returns integer
local integer oqx
if(ynv==8190)then
call oYx("TimerDialog_Allocation_allocCustom","call DebugEx(TimerDialog.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",vAv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(yVv[(w)]==w)then
set yEv=yEv+1
set oqx=yEv
else
set oqx=yVv[(w)]
set yVv[(w)]=yVv[yVv[(w)]]
endif
set yVv[oqx]=Z
set yXv[oqx]=1
call YIo(oqx)
return oqx
endfunction
function YNo takes integer ozx returns integer
local integer oqx=YAo()
set Wjv[oqx]=CreateTimerDialog(Oe[ozx])
return oqx
endfunction
function Ybo takes integer oqx,real oSx returns nothing
call BOx(oqx,(LF[(oqx)])-oSx)
endfunction
function YBo takes integer oqx,integer Ixx,real nyx returns nothing
local integer LJo
if(nyx<1.)then
return
endif
set LJo=LHo(Ixx,yAv+Ixx,nyx)
call X6x(LJo,iqx("-"+(I2S(((R2I((((((fN[(LJo)]))*1.))*1.)))))),"ffffff00"),.02)
call Ybo(Ixx,nyx)
endfunction
function Yco takes nothing returns boolean
local integer rdx=(bv)
local real NIo=(Eyv[(rdx)])
local integer YCo=(EYv[(rdx)])
local integer Ixx=(WH[(rdx)])
local real Ydo=itx((LF[(Ixx)]),NIo)
call oYx("FolderSpawn_StructShadow_Event_Damage","call DebugEx(\"burn mana\")","burn mana")
call YBo(YCo,Ixx,Ydo)
set Eyv[(rdx)]=((NIo-Ydo)*1.)
return true
endfunction
function YDo takes integer oqx returns nothing
local integer YCo=oqx
call mFo(mHo((GetUnitX(C[((YCo))])),(GetUnitY(C[((YCo))])),"Objects\\Spawnmodels\\Undead\\UndeadDissipate\\UndeadDissipate.mdx",ri))
call OTx(YCo)
endfunction
function Yfo takes nothing returns boolean
local integer rdx=(bv)
local integer OUx=(Vv[(rdx)])
local integer oqx=oPx(OUx,ybv)
call YDo(oqx)
return true
endfunction
function YFo takes nothing returns boolean
local integer rdx=(bv)
local integer OUx=(Vv[(rdx)])
local integer oqx=oPx(OUx,ybv)
call YDo(oqx)
return true
endfunction
function Ygo takes nothing returns boolean
local integer rdx=(bv)
local integer YCo=(Vv[(rdx)])
local integer oqx=YCo
call CAx(YCo,Xw,(GetUnitX(C[((yCv[oqx]))])),(GetUnitY(C[((yCv[oqx]))])))
return true
endfunction
function YGo takes integer oqx returns boolean
return(yfv==oqx)or((yFv[oqx]!=w)or(ygv[oqx]!=w))
endfunction
function Yho takes integer oqx returns boolean
if YGo(oqx)then
return false
endif
set ygv[oqx]=w
if(yfv==w)then
set yGv=oqx
set yfv=oqx
return true
endif
set yFv[oqx]=yGv
set ygv[yGv]=oqx
set yGv=oqx
return false
endfunction
function YHo takes nothing returns integer
local integer oqx=yfv
if(oqx==w)then
return w
endif
set yfv=ygv[oqx]
set ygv[oqx]=w
if(yfv==w)then
set yGv=w
else
set yFv[yfv]=w
endif
return oqx
endfunction
function Yjo takes integer oqx returns boolean
local boolean YJo
local integer Yko
local boolean o4x
if not(NVv[(oqx)]>0)then
return false
endif
if not(IsUnitType(C[(((oqx)))],(UNIT_TYPE_DEAD)))then
return false
endif
set YJo=(IsUnitType(C[(((oqx)))],(UNIT_TYPE_STRUCTURE)))
set Yko=(ze[((oqx))])
call mIx(Zj,Yko)
call Dpx(Zj,DPx((oqx)))
call Dqx(Zj,DQx((oqx)))
call UnitAddType(C[(((oqx)))],(UNIT_TYPE_TAUREN))
call UnitShareVision(C[(oqx)],vx[Yko],true)
set o4x=(IssueImmediateOrderById(zj[((Zj))],Pb[(W2)]))
call mIx(Zj,Fy)
call UnitRemoveType(C[(((oqx)))],(UNIT_TYPE_TAUREN))
if o4x then
if YJo then
call ShowUnit(C[(oqx)],false)
endif
set Nnv[(oqx)]=(false)
call AMo((oqx),sc)
if YJo then
call ShowUnit(C[(oqx)],true)
endif
call cFx((oqx),(iG[((oqx))]))
call qlo((oqx))
return true
endif
return false
endfunction
function YKo takes nothing returns nothing
local integer YCo=YHo()
local integer oqx=YCo
if(yfv==w)then
call iHx(ydv)
endif
call ShowUnit(C[YCo],true)
call Yjo(YCo)
call SetUnitPosition(C[((YCo))],(((GetUnitX(C[((hw))])))*1.),(((GetUnitY(C[((hw))])))*1.))
call CAx(YCo,Xw,(GetUnitX(C[((yCv[oqx]))])),(GetUnitY(C[((yCv[oqx]))])))
call Uyo(YCo,60.)
endfunction
function Ylo takes nothing returns boolean
local integer rdx=(bv)
local integer YCo=(Vv[(rdx)])
local integer oqx=YCo
call mFo(mHo((GetUnitX(C[((YCo))])),(GetUnitY(C[((YCo))])),"Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl",ri))
call SetUnitPosition(C[((YCo))],(((GetUnitX(C[((hw))])))*1.),(((GetUnitY(C[((hw))])))*1.))
call ShowUnit(C[YCo],false)
if Yho(YCo)then
call icx(ydv,1.25,true,function YKo)
endif
return true
endfunction
function YLo takes integer oqx returns boolean
if((cpv[((oqx))])>0)then
return false
endif
set cqv=cqv+1
set cPv[cqv]=oqx
set cpv[oqx]=cqv+1
return(cqv==0)
endfunction
function Ymo takes nothing returns nothing
local integer olx=cSv
loop
exitwhen(olx<0)
set yHv[olx]=csv[olx]
set olx=olx-1
endloop
set yjv=cSv
endfunction
function YMo takes nothing returns integer
local integer o4x
if(yjv<0)then
return w
endif
set o4x=yHv[0]
set yHv[0]=yHv[yjv]
set yjv=yjv-1
return o4x
endfunction
function Ypo takes integer oqx returns nothing
local integer rkx=oqx
local integer rdx=rEx((A[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set Vv[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=rOx(rkx,cuv,rIx)
loop
exitwhen(rlx<q)
call rCx(rDx(rkx,cuv,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function YPo takes nothing returns nothing
local integer oqx
call Ymo()
loop
set oqx=YMo()
exitwhen(oqx==w)
if((cwv[((oqx))])>0)then
if(dmx((oqx))==w)then
call Ypo(oqx)
else
call Bmo(oqx)
call BMo(oqx)
endif
else
if(dmx((oqx))==w)then
call Bqo(oqx)
call BQo(oqx)
endif
endif
endloop
endfunction
function Yqo takes integer oqx,integer Xwx returns nothing
if rtx((oqx),cMv,Xwx)then
call I7x((oqx),cmv)
call YLo(oqx)
if not I6x((oqx),sc)then
if BPo(oqx)then
call icx(ctv,.75,true,function YPo)
endif
endif
endif
call I7x((oqx),Xwx)
endfunction
function YQo takes nothing returns boolean
local integer rdx=(bv)
local integer YCo=(Vv[(rdx)])
local integer OUx=yhv
local integer oqx=YCo
set yCv[oqx]=OUx
call I7x(YCo,yIv)
call I7x(YCo,yDv)
call Yqo(YCo,ycv)
call rTx(OUx,ybv,oqx)
call I7x(OUx,yNv)
call I7x(OUx,yBv)
return true
endfunction
function Yso takes integer oqx returns boolean
local integer Rkx
local integer RKx
if(YGo(oqx)==false)then
return false
endif
if(yfv==oqx)then
call YHo()
return(yfv==w)
endif
set Rkx=ygv[oqx]
set RKx=yFv[oqx]
if(RKx!=w)then
set yFv[oqx]=w
set ygv[RKx]=Rkx
endif
if(Rkx==w)then
set yGv=RKx
else
set ygv[oqx]=w
set yFv[Rkx]=RKx
endif
return(yfv==w)
endfunction
function YSo takes nothing returns boolean
local integer rdx=(bv)
local integer YCo=(Vv[(rdx)])
local integer oqx=YCo
local integer OUx=yCv[oqx]
call Rmx(YCo,yIv)
call Rmx(YCo,yDv)
call Blo(YCo,ycv)
call rix(OUx,ybv)
call Rmx(OUx,yNv)
call Rmx(OUx,yBv)
if Yso(YCo)then
call iHx(ydv)
endif
return true
endfunction
function Yto takes nothing returns nothing
set yIv=XBx("FolderSpawn_StructShadow_Init: set FolderSpawn_StructShadow.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EDIT_EVENT_TYPE, EventPriority.MISC, function FolderSpawn_StructShadow.Event_Damage)",dOv,LI,function Yco)
set yNv=XBx("FolderSpawn_StructShadow_Init: set FolderSpawn_StructShadow.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderSpawn_StructShadow.Event_Death)",VP,LI,function Yfo)
set yBv=XBx("FolderSpawn_StructShadow_Init: set FolderSpawn_StructShadow.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.MISC, function FolderSpawn_StructShadow.Event_Destroy)",EP,LI,function YFo)
set ycv=XBx("FolderSpawn_StructShadow_Init: set FolderSpawn_StructShadow.IDLE_EVENT = Event.Create(UNIT.Order.Events.Idle.START_EVENT_TYPE, EventPriority.MISC, function FolderSpawn_StructShadow.Event_Idle)",cUv,LI,function Ygo)
set ydv=inx()
set yDv=XBx("FolderSpawn_StructShadow_Init: set FolderSpawn_StructShadow.SHADOW_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderSpawn_StructShadow.Event_ShadowDeath)",VP,LI,function Ylo)
call l9x(WXv,XBx("FolderSpawn_StructShadow_Init: call FolderSpawn_StructShadow.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderSpawn_StructShadow.Event_BuffGain))",Bd,LI,function YQo))
call l9x(WXv,XBx("FolderSpawn_StructShadow_Init: call FolderSpawn_StructShadow.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderSpawn_StructShadow.Event_BuffLose))",Jc,LI,function YSo))
endfunction
function YTo takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((sm[(oqx)]))])]))],((((ym[((oqx))])))),(((oQx)))))
endfunction
function Yuo takes integer ozx returns integer
return YTo(ozx,ykv)
endfunction
function YUo takes integer oqx returns integer
set yMv[oqx]=true
set ypv[oqx]=false
call rax(wTv)
return oqx
endfunction
function Ywo takes nothing returns integer
local integer oqx
if(yKv==8190)then
call oYx("SpawnLocation_Allocation_allocCustom","call DebugEx(SpawnLocation.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",wuv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(ylv[(w)]==w)then
set yLv=yLv+1
set oqx=yLv
else
set oqx=ylv[(w)]
set ylv[(w)]=ylv[ylv[(w)]]
endif
set ylv[oqx]=Z
set ymv[oqx]=1
call YUo(oqx)
return oqx
endfunction
function YWo takes integer oqx returns boolean
set yqv=yqv+1
set yQv[yqv]=oqx
set ysv[oqx]=yqv+1
return(yqv==0)
endfunction
function Yyo takes integer ozx returns integer
local integer YYo=Yuo(ozx)
local real x=(tm[(ozx)])
local real y=(Tm[(ozx)])
local integer Yzo=(Dw[(YYo)])
local integer oqx=Ywo()
set Wqv[oqx]=(Atan2(((Lax(Yzo)-y)*1.),((Lix(Yzo)-x)*1.)))
set WQv[oqx]=(um[(ozx)])
set Wsv[oqx]=(Um[(ozx)])
set WSv[oqx]=(wm[(ozx)])
set Wtv[oqx]=(Wm[(ozx)])
set yPv=yPv+1
call YWo(oqx)
return oqx
endfunction
function YZo takes nothing returns nothing
set yJv=Yyo(q_x(px))
set ySv=Yyo(q_x(Qx))
set ytv=Yyo(q_x(sx))
endfunction
function Y_o takes nothing returns boolean
local integer rdx=(bv)
local integer rRx=(yev[(rdx)])
local integer Oqx=(Vv[(rdx)])
call rzx((Oqx),(Gsv),(2))
return true
endfunction
function Y0o takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((yUv[(oqx)]))])]))],((((yxv[((oqx))])))),(((oQx))))))
endfunction
function Y1o takes integer oqx returns integer
return Y0o((oqx),ywv)
endfunction
function Y2o takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((yUv[(oqx)]))])]))],((((yxv[((oqx))])))),(((oQx)+(okx)))))
endfunction
function Y3o takes integer oqx,integer okx returns integer
return Y2o((oqx),ywv,okx)
endfunction
function Y4o takes nothing returns boolean
local integer rdx=(bv)
local integer rRx=(yev[(rdx)])
local integer Oqx=(Vv[(rdx)])
local integer oqx=rRx
local integer olx=Y1o(oqx)
loop
exitwhen(olx<q)
call UnitAddItem(C[((Oqx))],Gh[(Y3o(oqx,olx))])
set olx=olx-1
endloop
call Abx((((Oqx))),(("Abilities\\Spells\\Orc\\CommandAura\\CommandAura.mdl")),(("origin")),((Bi)))
return true
endfunction
function Y5o takes integer oqx returns integer
set y_v[oqx]=true
set y0v[oqx]=false
set yUv[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set yov[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(y1v)
return oqx
endfunction
function Y6o takes nothing returns integer
local integer oqx
if(yWv==8190)then
call oYx("SpawnType_Allocation_allocCustom","call DebugEx(SpawnType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",yyv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(yYv[(w)]==w)then
set yzv=yzv+1
set oqx=yzv
else
set oqx=yYv[(w)]
set yYv[(w)]=yYv[yYv[(w)]]
endif
set yYv[oqx]=Z
set yZv[oqx]=1
call Y5o(oqx)
return oqx
endfunction
function Y7o takes integer oqx,integer oSx returns nothing
set yrv[oqx]=oSx
call hlo(oSx,Gw,oqx)
endfunction
function Y8o takes integer oqx returns boolean
set y2v=y2v+1
set y3v[y2v]=oqx
set y4v[oqx]=y2v+1
return(y2v==0)
endfunction
function Y9o takes integer oqx returns nothing
set yxv[(oqx)]=(y5v+oqx)
endfunction
function zvo takes integer lbo returns integer
local integer oqx=Y6o()
call Y7o(oqx,lbo)
call Y8o(oqx)
call Y9o(oqx)
return oqx
endfunction
function zeo takes integer oqx,integer Xwx returns nothing
if(yov[oqx]==w)then
call oYx("FolderSpawnType_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oqx)+";"+(JA[(Xwx)]))
set yov[oqx]=X
endif
call rSx(yov[oqx],(yxv[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function zxo takes integer oqx returns nothing
set Yev[oqx]=true
call zeo((oqx),yTv)
endfunction
function zoo takes integer rRx,integer nyx returns nothing
call hlo(rRx,pav,nyx)
call hho(((rRx)),A2v,(M8v))
endfunction
function zro takes integer oqx,real oSx returns nothing
set Nlv[(oqx)]=(((Nlv[(oqx)])+oSx)*1.)
endfunction
function zio takes nothing returns nothing
local integer olx=y2v
local integer oqx
local integer lbo
loop
exitwhen(olx<0)
set oqx=y3v[olx]
set lbo=(yrv[(oqx)])
call zro(lbo,(Nlv[(lbo)])*.75)
if(Yiv[(oqx)])then
call hLo((lbo),(Gsv),1)
endif
if(YCv[(oqx)])then
call hLo((lbo),(YKv),1)
endif
set olx=olx-1
endloop
endfunction
function zao takes nothing returns nothing
local integer oqx
set yTv=XBx("FolderSpawnType_StructChampion_Init: set FolderSpawnType_StructChampion.SPAWN_EVENT = Event.Create(Spawn.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderSpawnType_StructChampion.Event_Spawn)",aw,LI,function Y_o)
set yuv=XBx("FolderSpawnType_StructItems_Init: set FolderSpawnType_StructItems.SPAWN_EVENT = Event.Create(Spawn.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderSpawnType_StructItems.Event_Spawn)",aw,LI,function Y4o)
set oqx=zvo(hdv)
set y6v=oqx
set y7v[(oqx)]=(true)
set oqx=zvo(G8v)
set y8v=oqx
set y9v[(oqx)]=(true)
set oqx=zvo(gJv)
set Yvv=oqx
call zxo(oqx)
set y9v[(oqx)]=(true)
set oqx=zvo(hxv)
set Yxv=oqx
set y9v[(oqx)]=(true)
set oqx=zvo(g6v)
set Yov=oqx
call zoo(yrv[(oqx)],('d'))
set y9v[(oqx)]=(true)
call zxo(oqx)
set oqx=zvo(Gyv)
set Yrv=oqx
call zoo(yrv[(oqx)],(350))
set Yiv[(oqx)]=(true)
set y9v[(oqx)]=(true)
set Yav[(oqx)]=(true)
set oqx=zvo(gjv)
set Ynv=oqx
set y9v[(oqx)]=(true)
set oqx=zvo(gjv)
set YVv=oqx
call zxo(oqx)
set oqx=zvo(gkv)
set YEv=oqx
set Yav[(oqx)]=(true)
set y7v[(oqx)]=(true)
set oqx=zvo(GDv)
set YXv=oqx
set y9v[(oqx)]=(true)
set oqx=zvo(hBv)
set YOv=oqx
call zxo(oqx)
set y9v[(oqx)]=(true)
set oqx=zvo(hov)
set YRv=oqx
set y7v[(oqx)]=(true)
set oqx=zvo(hiv)
set YIv=oqx
set Yav[(oqx)]=(true)
set y9v[(oqx)]=(true)
set oqx=zvo(g8v)
set YAv=oqx
set y9v[(oqx)]=(true)
set oqx=zvo(gZv)
set YNv=oqx
set y7v[(oqx)]=(true)
set oqx=zvo(gsv)
set Ybv=oqx
set Yav[(oqx)]=(true)
set y7v[(oqx)]=(true)
set oqx=zvo(hav)
set YBv=oqx
set y9v[(oqx)]=(true)
set fw[(oqx)]=(true)
set oqx=zvo(GVv)
set Ycv=oqx
set YCv[(oqx)]=(true)
set y9v[(oqx)]=(true)
set oqx=zvo(G0v)
set Ydv=oqx
set y9v[(oqx)]=(true)
set oqx=zvo(Gqv)
set YDv=oqx
call zoo(yrv[(oqx)],($C8))
set oqx=zvo(GOv)
set Yfv=oqx
set YFv[(oqx)]=(true)
set y7v[(oqx)]=(true)
set oqx=zvo(GNv)
set Ygv=oqx
set Yiv[(oqx)]=(true)
set y7v[(oqx)]=(true)
set oqx=zvo(hVv)
set YGv=oqx
call zoo(yrv[(oqx)],(55))
call zxo(oqx)
set y7v[(oqx)]=(true)
set oqx=zvo(hXv)
set Yhv=oqx
set Yiv[(oqx)]=(true)
set y9v[(oqx)]=(true)
set oqx=zvo(hfv)
set YHv=oqx
set y9v[(oqx)]=(true)
set oqx=zvo(Gav)
set Yjv=oqx
set y9v[(oqx)]=(true)
set fw[(oqx)]=(true)
set oqx=zvo(hcv)
set YJv=oqx
set y7v[(oqx)]=(true)
set oqx=zvo(hcv)
set Ykv=oqx
set y7v[(oqx)]=(true)
call zio()
endfunction
function zno takes integer oqx returns integer
set Ypv[oqx]=true
set YPv[oqx]=false
set Wfv[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
call rax(Wav)
return oqx
endfunction
function zVo takes nothing returns integer
local integer oqx
if(Ylv==8190)then
call oYx("SpawnWave_Allocation_allocCustom","call DebugEx(SpawnWave.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Wnv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(YLv[(w)]==w)then
set Ymv=Ymv+1
set oqx=Ymv
else
set oqx=YLv[(w)]
set YLv[(w)]=YLv[YLv[(w)]]
endif
set YLv[oqx]=Z
set YMv[oqx]=1
call zno(oqx)
return oqx
endfunction
function zEo takes integer oqx returns nothing
set WFv[(oqx)]=(Yqv+oqx)
endfunction
function zXo takes integer oqx,integer oSx returns nothing
set YQv[oqx]=oSx
call LEo(oSx,JLv,oqx)
endfunction
function zOo takes integer k1o returns integer
local integer oqx=zVo()
local integer ibx=inx()
set Whv[oqx]=ibx
set ge[(ibx)]=(oqx)
call zEo(oqx)
set Wkv[(oqx)]=((30.)*1.)
call zXo(oqx,k1o)
set Wlv[(oqx)]=((.0)*1.)
set WLv[(oqx)]=((.0)*1.)
set WBv[(oqx)]=(k1o==(kJo((((Jdv[(k1o)]))),JCv,((kjo((((Jdv[(k1o)]))),JCv))))))
return oqx
endfunction
function zRo takes integer oqx returns integer
set Yuv[oqx]=true
set YUv[oqx]=false
set WMv[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
call rax(w0v)
return oqx
endfunction
function zIo takes nothing returns integer
local integer oqx
if(Ysv==8190)then
call oYx("SpawnGroup_Allocation_allocCustom","call DebugEx(SpawnGroup.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",w1v+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(YSv[(w)]==w)then
set Ytv=Ytv+1
set oqx=Ytv
else
set oqx=YSv[(w)]
set YSv[(w)]=YSv[YSv[(w)]]
endif
set YSv[oqx]=Z
set YTv[oqx]=1
call zRo(oqx)
return oqx
endfunction
function zAo takes integer oqx returns nothing
set Wpv[(oqx)]=(Ywv+oqx)
endfunction
function zNo takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(WMv[(oqx)],(Wpv[((oqx))]),oQx,oSx)
endfunction
function zbo takes nothing returns integer
local integer oqx=zIo()
call zAo(oqx)
call zNo((oqx),WPv,(ySv))
call zNo((oqx),WPv,(ytv))
call zNo((oqx),WPv,(yJv))
return oqx
endfunction
function zBo takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((WMv[(oqx)]))])]))],((((Wpv[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function zco takes integer oqx,integer rRx,integer nyx returns nothing
call zBo(oqx,Wuv+rRx,nyx)
call zNo(oqx,WTv,rRx)
endfunction
function zCo takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(Wfv[(oqx)],(WFv[((oqx))]),oQx,oSx)
endfunction
function zdo takes integer oqx,integer oQx,real oSx returns nothing
call SaveReal(o[((V[(E[((Wfv[(oqx)]))])]))],((((WFv[((oqx))])))),(((oQx))),((((((oSx)*1.))*1.))*1.))
endfunction
function zDo takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((Wfv[(oqx)]))])]))],((((WFv[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function zfo takes integer oqx,integer NVo,real OGx returns nothing
local integer rkx=oqx
local integer olx=(yUo((NVo),WTv))
local integer rRx
local integer OHx
loop
exitwhen(olx<q)
set rRx=(ywo((NVo),WTv,(olx)))
if(y9v[(rRx)])then
set Qhv[(rkx)]=(true)
endif
if(y7v[(rRx)])then
set QHv[(rkx)]=(true)
endif
if(Yav[(rRx)])then
set Qjv[(rkx)]=(true)
endif
if(fw[(rRx)])then
set Qkv[(rkx)]=(true)
endif
if(YCv[(rRx)])then
set QJv[(rkx)]=(true)
endif
if(YFv[(rRx)])then
set QKv[(rkx)]=(true)
endif
if(YWv[(rRx)])then
set Qlv[(rkx)]=(true)
endif
if(Yiv[(rRx)])then
set Qgv[(rkx)]=(true)
endif
set olx=olx-1
endloop
set OHx=inx()
set ge[(OHx)]=(NVo)
set WKv[(rkx)]=((OGx)*1.)
call zCo(rkx,Wgv,NVo)
call zdo(rkx,Wmv+NVo,OGx)
call zDo(rkx,WGv+NVo,OHx)
endfunction
function zFo takes nothing returns nothing
local integer oqx=zOo(tYv)
local real OGx=.0
local integer zgo=7
local integer NVo
set Jqv[(oqx)]=(hxv)
loop
exitwhen(zgo<1)
set OGx=OGx+10.
set NVo=zbo()
call zco(NVo,Yxv,2)
call zco(NVo,YEv,1)
call zfo(oqx,NVo,OGx)
set zgo=zgo-1
endloop
endfunction
function zGo takes nothing returns nothing
local integer oqx=zOo(k9v)
local real OGx=.0
local integer zgo=7
local integer NVo
set Jqv[(oqx)]=(gZv)
loop
exitwhen(zgo<1)
set OGx=OGx+10.
set NVo=zbo()
call zco(NVo,YNv,2)
call zco(NVo,Ybv,1)
call zfo(oqx,NVo,OGx)
set zgo=zgo-1
endloop
endfunction
function zho takes nothing returns nothing
local integer oqx=zOo(Kev)
local real OGx=.0
local integer zgo=7
local integer NVo
set Jqv[(oqx)]=(gkv)
set NVo=zbo()
call zco(NVo,Yov,1)
call zfo(oqx,NVo,OGx+40.)
loop
exitwhen(zgo<1)
set OGx=OGx+10.
set NVo=zbo()
call zco(NVo,YEv,2)
call zfo(oqx,NVo,OGx)
set NVo=zbo()
call zco(NVo,Ybv,1)
call zfo(oqx,NVo,OGx+5.)
set zgo=zgo-1
endloop
endfunction
function zHo takes nothing returns nothing
local integer oqx=zOo(tzv)
local real OGx=.0
local integer zgo=7
local integer NVo
set Jqv[(oqx)]=(hav)
set NVo=zbo()
call zco(NVo,Yov,1)
call zfo(oqx,NVo,OGx+30.)
loop
exitwhen(zgo<1)
set OGx=OGx+10.
set NVo=zbo()
call zco(NVo,YBv,2)
call zco(NVo,Ybv,1)
call zfo(oqx,NVo,OGx)
set zgo=zgo-1
endloop
endfunction
function zjo takes nothing returns nothing
local integer oqx=zOo(tZv)
local real OGx=.0
local integer zgo=7
local integer NVo
set Jqv[(oqx)]=(gjv)
loop
exitwhen(zgo<1)
set OGx=OGx+10.
set NVo=zbo()
call zco(NVo,Ynv,2)
call zfo(oqx,NVo,OGx)
set zgo=zgo-1
endloop
endfunction
function zJo takes nothing returns nothing
local integer oqx=zOo(t_v)
local real OGx=.0
local integer zgo=7
local integer NVo
set Jqv[(oqx)]=(hov)
loop
exitwhen(zgo<1)
set OGx=OGx+12.
set NVo=zbo()
call zco(NVo,YRv,2)
call zco(NVo,YAv,2)
call zfo(oqx,NVo,OGx)
set zgo=zgo-1
endloop
endfunction
function zko takes nothing returns nothing
local integer oqx=zOo(tzv)
local real OGx=.0
local integer zgo=7
local integer NVo
set Jqv[(oqx)]=(GDv)
set NVo=zbo()
call zco(NVo,Yov,1)
call zfo(oqx,NVo,OGx+30.)
loop
exitwhen(zgo<1)
set OGx=OGx+10.
set NVo=zbo()
call zco(NVo,YXv,4)
call zfo(oqx,NVo,OGx)
set zgo=zgo-1
endloop
set OGx=.0
set zgo=2
loop
exitwhen(zgo<1)
set OGx=OGx+25.
set NVo=zbo()
call zco(NVo,YOv,2)
call zfo(oqx,NVo,OGx)
set zgo=zgo-1
endloop
endfunction
function zKo takes nothing returns nothing
local integer oqx=zOo(t1v)
local real OGx=.0
local integer zgo=7
local integer NVo
set Jqv[(oqx)]=(hiv)
loop
exitwhen(zgo<1)
set OGx=OGx+10.
set NVo=zbo()
call zco(NVo,YAv,2)
call zco(NVo,YIv,1)
call zfo(oqx,NVo,OGx)
set zgo=zgo-1
endloop
endfunction
function zlo takes nothing returns nothing
local integer oqx=zOo(t2v)
local integer NVo=zbo()
call zco(NVo,Yrv,1)
call zfo(oqx,NVo,.0)
endfunction
function zLo takes nothing returns nothing
local integer oqx=zOo(Tvv)
local real OGx=10.
local integer zgo=7
local integer NVo
loop
exitwhen(zgo<1)
set OGx=OGx+10.
set NVo=zbo()
call zco(NVo,y8v,2)
call zco(NVo,y6v,1)
call zfo(oqx,NVo,OGx)
set zgo=zgo-1
endloop
set NVo=zbo()
call zco(NVo,Yvv,1)
call zfo(oqx,NVo,30.)
set WKv[(oqx)]=((300.)*1.)
endfunction
function zmo takes nothing returns nothing
call zFo()
call zGo()
call zho()
call zHo()
call zjo()
call zJo()
call zko()
call zKo()
call zlo()
call zLo()
endfunction
function zMo takes nothing returns boolean
set Ob=JIx("Spawn_Init: set Spawn.ALL_GROUP = UnitList.Create()")
set WNv=XBx("Spawn_Init: set Spawn.CLEAR_CHAT_EVENT = Event.Create(User.CHAT_EVENT_TYPE, EventPriority.MISC, function Spawn.Event_ClearChat)",LA,LI,function yko)
set Wbv=XBx("Spawn_Init: set Spawn.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.MISC, function Spawn.Event_Destroy)",EP,LI,function ylo)
set aw=(E0x())
set WCv=inx()
call DNx(XBx("Spawn_Init: call Event.Create(Act.ENDING_EVENT_TYPE, EventPriority.MISC, function Spawn.Event_ActEnding).AddToStatics()",jmv,LI,function ymo))
call DNx(XBx("Spawn_Init: call Event.Create(EventType.START, EventPriority.MISC, function Spawn.Event_Start).AddToStatics()",XE,LI,function YVo))
call DNx(XBx("Spawn_Init: call Event.Create(Meteorite.GAME_OVER_EVENT_TYPE, EventPriority.MISC, function Spawn.Event_GameOver).AddToStatics()",JQv,LI,function YRo))
set WJv=YNo(WCv)
call XUx(vN,"-clear wave",WNv)
set W7v=inx()
call Yto()
call YZo()
call zao()
call zmo()
return true
endfunction
function zpo takes nothing returns boolean
call kqo(function zMo,"Spawn_Init")
return true
endfunction
function zPo takes nothing returns boolean
set Yyv=Vnx(YYv)
return true
endfunction
function zqo takes nothing returns boolean
set Yzv=Vnx(YZv)
return true
endfunction
function zQo takes nothing returns boolean
set Y_v=Vnx(Y0v)
return true
endfunction
function zso takes nothing returns boolean
set Y1v=Vnx(Y2v)
return true
endfunction
function zSo takes nothing returns boolean
set Y3v=Vnx(Y4v)
return true
endfunction
function zto takes nothing returns boolean
set Y5v=Vnx(Y6v)
return true
endfunction
function zTo takes nothing returns boolean
set Y7v=Vnx(Y8v)
return true
endfunction
function zuo takes nothing returns boolean
set y1v=Vnx(yyv)
return true
endfunction
function zUo takes nothing returns boolean
set Y9v=Vnx(zvv)
return true
endfunction
function zwo takes integer a,integer b returns integer
if(a-a/ b*b>0)then
return(a/ b+1)
endif
return(a/ b)
endfunction
function zWo takes string Uco,string oSx returns integer
local integer o4x=(s3o(o0))
set Uco=iqx(Uco,"ffffcc00")
set O2=O2+1
call pbx(o0,o4x,r0,Uco)
call pbx(o0,o4x,n0,oSx)
set x0[O2]=o4x
set A2[o4x]=O2
set i0[O2]=Uco
set V0[O2]=oSx
return o4x
endfunction
function zyo takes integer bXx returns integer
local integer oqx=bXx
set YZ[oqx]=false
set N2[oqx]=-1
set yZ[oqx]=bXx
set R2[oqx]=F
set E0[oqx]=F
call smo((o0),(bXx))
call PYx(oqx,40)
return oqx
endfunction
function zYo takes nothing returns boolean
local integer rdx=(bv)
call zyo((eN[(rdx)]))
return true
endfunction
function zzo takes nothing returns nothing
local integer oqx=((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetLocalPlayer())))))),((((R)))))))
if not YZ[oqx]then
return
endif
call PYx(oqx,N2[oqx])
endfunction
function zZo takes nothing returns boolean
local integer rdx=(bv)
set o0=s2o()
set r0=s7o(o0)
set n0=s7o(o0)
set b2=zwo(GE,30)-1
set I2=zWo("Page","")
set B2=(JZ[(o0)])+2
call PWx(o0,r0,.2)
call PWx(o0,n0,.05)
call s4o((o0),("StructInfo"))
call DNx(XBx("StructInfo_Event_Start: call Event.Create(AfterIntro.FOR_PLAYER_EVENT_TYPE, EventPriority.MISC, function StructInfo.Event_AfterIntro).AddToStatics()",jbv,LI,function zYo))
set zev=inx()
call icx(zev,1.,true,function zzo)
return true
endfunction
function z_o takes nothing returns boolean
call DNx(XBx("StructInfo_Init: call Event.Create(EventType.START, EventPriority.MISC, function StructInfo.Event_Start).AddToStatics()",XE,LI,function zZo))
return true
endfunction
function z0o takes nothing returns boolean
call kZo(function z_o,"StructInfo_Init")
return true
endfunction
function z1o takes nothing returns boolean
set zxv=hGo('uTav')
call hho(((zxv)),Apv,(ICv))
set Tj[(zxv)]=((2)*1.)
set Nav[(zxv)]=(('x')*1.)
set Ntv[(zxv)]=((60)*1.)
set I3v[(zxv)]=((0)*1.)
set Axv[(zxv)]=(3)
set NJv[(zxv)]=((150000.)*1.)
set Njv[(zxv)]=((150000.)*1.)
set Nhv[(zxv)]=((0)*1.)
set NIv[(zxv)]=((500)*1.)
set NOv[(zxv)]=((500)*1.)
set AQv[(zxv)]=((0)*1.)
set Asv[(zxv)]=((0)*1.)
set Auv[(zxv)]=(0)
set AWv[(zxv)]=(0)
call hLo((zxv),(gQv),1)
return true
endfunction
function z2o takes nothing returns boolean
call VRx(Sa,(function z1o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Tavern.page\\Tavern.struct\\obj_shop_wc3unit.j"))
return true
endfunction
function z3o takes nothing returns boolean
set zov=Vnx(zrv)
return true
endfunction
function z4o takes nothing returns boolean
set ziv=WTx('BTrR',"Tropical Rainbow",'bTrR')
set avv[(ziv)]=(true)
set qU[(ziv)]=(true)
set aev[(ziv)]=("ReplaceableTextures\\CommandButtons\\BTNSnazzyPotion.blp")
call lux(ziv,"Abilities\\Spells\\Orc\\EtherealForm\\SpiritWalkerChange.mdl","head",ri)
set SU=lYx()
call l_x(SU,dgv,.2)
call l_x(SU,XAv,.5)
call l_x(SU,ECv,.5)
call l_x(SU,ZU,.2)
call l_x(SU,Edv,.2)
call lzx(((SU)),Fc,(rWo(Db,0,-$80,-64,0)))
call l0x(((ziv)),vc+(1),(SU))
return true
endfunction
function z5o takes nothing returns boolean
set zav=L3o('ITrR')
call L4o(((zav)),pS,(AS))
set MS[(zav)]=(1)
set LEv[(zav)]=("ReplaceableTextures\\CommandButtons\\BTNSnazzyPotion.blp")
call L6o((zav),(znv),1)
return true
endfunction
function z6o takes nothing returns boolean
call LZx('ATrR',false)
set znv=Lzo('ATrR')
set G6[(znv)]=(d6)
set j6[(znv)]=(1)
set sH[(znv)]=("Tropical Rainbow")
set Ih[(znv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Oj))))))
set x6v[(znv)]=(0)
set xzv[(znv)]=("spell")
call LZo((znv),fH+(1),((60)*1.))
call LZo((znv),Lvv+(1),((750)*1.))
return true
endfunction
function z7o takes nothing returns boolean
call VRx(Ma,(function z4o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Tavern.page\\Tavern.struct\\TropicalRainbow.page\\TropicalRainbow.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(sa,(function z5o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Tavern.page\\Tavern.struct\\TropicalRainbow.page\\TropicalRainbow.struct\\obj_thisItem_wc3item.j"))
call VRx(qa,(function z6o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Tavern.page\\Tavern.struct\\TropicalRainbow.page\\TropicalRainbow.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function z8o takes nothing returns boolean
set zVv=Vnx(zEv)
return true
endfunction
function z9o takes nothing returns boolean
local integer rdx=(bv)
call NIx(((Vv[(rdx)])),(ziv),((Mv[(rdx)])),w,((zXv)*1.))
return true
endfunction
function Zvo takes nothing returns boolean
call meo(znv,XBx("TropicalRainbow_Init: call TropicalRainbow.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TropicalRainbow.Event_SpellEffect))",ah,pI,function z9o))
return true
endfunction
function Zeo takes nothing returns boolean
call PPo(function Zvo,"TropicalRainbow_Init")
return true
endfunction
function Zxo takes nothing returns boolean
set zOv=L3o('IToA')
call L4o(((zOv)),pS,(AS))
return true
endfunction
function Zoo takes nothing returns boolean
call VRx(sa,(function Zxo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Tomes.page\\Tomes.struct\\Agi\\obj_thisItem_wc3item.j"))
return true
endfunction
function Zro takes nothing returns boolean
set zRv=Vnx(zIv)
return true
endfunction
function Zio takes nothing returns boolean
set zAv=L3o('IToI')
call L4o(((zAv)),pS,(AS))
return true
endfunction
function Zao takes nothing returns boolean
call VRx(sa,(function Zio),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Tomes.page\\Tomes.struct\\Int\\obj_thisItem_wc3item.j"))
return true
endfunction
function Zno takes nothing returns boolean
set zNv=Vnx(zbv)
return true
endfunction
function ZVo takes nothing returns boolean
set zBv=L3o('IToS')
call L4o(((zBv)),pS,(AS))
return true
endfunction
function ZEo takes nothing returns boolean
call VRx(sa,(function ZVo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Tomes.page\\Tomes.struct\\Str\\obj_thisItem_wc3item.j"))
return true
endfunction
function ZXo takes nothing returns boolean
set zcv=Vnx(zCv)
return true
endfunction
function ZOo takes nothing returns boolean
set zdv=Vnx(zDv)
return true
endfunction
function ZRo takes nothing returns boolean
local integer rdx=(bv)
local integer ZIo=(Nv)
local integer Oqx=(Vv[(rdx)])
local integer oqx=FMx(ZIo,zfv)
local integer CDx=oqx
call kfx(CreateItem(Hh[(CDx)],(((GetUnitX(C[((Oqx))])))*1.),(((GetUnitY(C[((Oqx))])))*1.)))
return true
endfunction
function ZAo takes integer oqx returns boolean
if((zFv[((oqx))])>0)then
return false
endif
set W9v=W9v+1
set W8v[W9v]=oqx
set zFv[oqx]=W9v+1
return(W9v==0)
endfunction
function ZNo takes integer CDx,code Xbx returns nothing
local integer oqx=CDx
local integer ZIo=XBx("Tomes_Create: local Event dropEvent = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function Tomes.Event_Drop)",VP,LI,function ZRo)
set yvv[oqx]=P_o(ZIo,null,null,w)
call pyx(ZIo,zfv,oqx)
call pao(CDx,XBx("Tomes_Create: call whichItem.Event.Add(Event.Create(UNIT.Items.Events.Use.DUMMY_EVENT_TYPE, EventPriority.MISC, action))",sh,LI,Xbx))
call ZAo(oqx)
endfunction
function Zbo takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call RUx((Abx((Oqx),(zgv),(zGv),(ri))))
call Bxx(Oqx,1)
return true
endfunction
function ZBo takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call RUx((Abx((Oqx),(zhv),(zHv),(ri))))
call BYx(Oqx,1)
return true
endfunction
function Zco takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
call RUx((Abx((Oqx),(zjv),(zJv),(ri))))
call c4x(Oqx,1)
return true
endfunction
function ZCo takes nothing returns boolean
call ZNo(zOv,function Zbo)
call ZNo(zAv,function ZBo)
call ZNo(zBv,function Zco)
return true
endfunction
function Zdo takes nothing returns boolean
call kWo(function ZCo,"Tomes_Init")
return true
endfunction
function ZDo takes nothing returns boolean
set zkv=Vnx(zKv)
return true
endfunction
function Zfo takes nothing returns boolean
local integer rdx=(bv)
local integer ZFo=X4x((0))
local integer rRx
local integer Oqx
local integer oqx
if(ZFo==w)then
return true
endif
set rRx=(BOv[(rdx)])
set Oqx=(Vv[(rdx)])
call XZx(ZFo,(GetUnitX(C[((Oqx))]))+M7o(Oqx,true),(GetUnitY(C[((Oqx))]))+M8o(Oqx,true),fwx(Oqx)+OLx(Oqx,true))
call X0x(ZFo)
call X6x(ZFo,iZx((GetObjectName(IGv[(rRx)])),"ff77ffff","ff00bfff"),ab*1.15)
set oqx=Oqx
set zLv[oqx]=ZFo
call I7x(Oqx,zmv)
return true
endfunction
function Zgo takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
local integer oqx=Oqx
local integer ZFo=zLv[oqx]
call Rmx(Oqx,zmv)
call OBx(ZFo)
return true
endfunction
function ZGo takes nothing returns boolean
set zlv=XBx("UnitNameTag_Init: set UnitNameTag.CREATE_EVENT = Event.Create(Unit.CREATE_EVENT_TYPE, EventPriority.MISC, function UnitNameTag.Event_Create)",Igv,LI,function Zfo)
set zmv=XBx("UnitNameTag_Init: set UnitNameTag.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.MISC, function UnitNameTag.Event_Destroy)",EP,LI,function Zgo)
call S8o((Lzv),zlv)
call S8o((sov),zlv)
call S8o((uOv),zlv)
call S8o((qHv),zlv)
call S8o((zxv),zlv)
return true
endfunction
function Zho takes nothing returns boolean
call kWo(function ZGo,"UnitNameTag_Init")
return true
endfunction
function ZHo takes nothing returns boolean
set zMv=Vnx(zpv)
return true
endfunction
function Zjo takes nothing returns boolean
local integer rdx=(bv)
if iVx((eN[(rdx)]))then
set zqv=(WH[(rdx)])
endif
return true
endfunction
function ZJo takes nothing returns boolean
local integer rdx=(bv)
call smo((zQv),((eN[(rdx)])))
return true
endfunction
function Zko takes integer oqx,integer Xwx returns nothing
if DLo((oqx),cEv+Xwx,1)then
call N4o(oqx,Xwx,false)
endif
endfunction
function ZKo takes integer oqx,integer Xwx returns nothing
if I8x((oqx),cEv+Xwx,1)then
if rtx((oqx),cnv,Xwx)then
call I7x((oqx),civ)
endif
call I7x((oqx),Xwx)
endif
endfunction
function Zlo takes real a,real b,real c returns real
if(b==0)then
return c
endif
return(a*1./ b)
endfunction
function ZLo takes integer ocx,integer Oqx returns nothing
local integer tpo=(Hpv[(ocx)]-1)
if(zsv[ocx]!=w)then
call Zko(Oqx,zPv)
endif
if iVx(ocx)then
set zqv=w
endif
set zsv[tpo]=Oqx
if(Oqx==w)then
return
endif
call ZKo(Oqx,zPv)
set zSv=Zlo((rG[(Oqx)]),(iG[(Oqx)]),.0)
set ztv=Zlo((LF[(Oqx)]),(mF[(Oqx)]),.0)
set zTv=Zlo((NQv[(Oqx)]),(Nqv[(Oqx)]),.0)
endfunction
function Zmo takes nothing returns boolean
local integer rdx=(bv)
local integer ocx=(eN[(rdx)])
local integer Oqx=(Vv[(rdx)])
if(OZx(Oqx,ocx)==0)then
set Oqx=(kv[(ocx)])
if(Oqx!=w)then
if I6x(Oqx,sc)then
set Oqx=(pwv[(oPx((Oqx),p_v))])
endif
call ZLo(ocx,Oqx)
endif
else
call ZLo(ocx,O4x(Oqx,ocx,q))
endif
return true
endfunction
function ZMo takes real Zpo,real ZPo,integer pqx returns string
local string Kvo
local string o4x
if(ZPo<0)then
set Kvo="ffff0000"
elseif(ZPo>0)then
set Kvo="ff00ff00"
else
set Kvo=null
endif
if(pqx==0)then
set o4x=(I2S(((R2I(((((Zpo)*1.))*1.))))))
else
set o4x=pPx(Zpo,pqx)
endif
return iqx(o4x,Kvo)
endfunction
function Zqo takes integer Oqx returns nothing
call pbx(zQv,zuv,zUv,"Armor: ")
call pbx(zQv,zuv,zwv,ZMo((I0v[(Oqx)]),(I1v[(Oqx)]),1))
endfunction
function ZQo takes integer Oqx returns nothing
call pbx(zQv,zWv,zUv,"Attack speed: ")
call pbx(zQv,zWv,zwv,ZMo((wf[(Oqx)]),(Wf[(Oqx)]),3))
endfunction
function Zso takes integer Oqx,integer lbo returns nothing
local real ZPo=(Lg[(Oqx)])
call pbx(zQv,zyv,zUv,"Damage: ")
call pbx(zQv,zyv,zwv,ZMo((lg[(Oqx)])+(Auv[(lbo)]),ZPo,0)+" - "+ZMo((lg[(Oqx)])+(Auv[(lbo)])*(AWv[(lbo)]),ZPo,0))
endfunction
function ZSo takes boolean isx,string oMx,string Zto returns string
if isx then
return oMx
endif
return Zto
endfunction
function ZTo takes integer Oqx returns nothing
local real Zuo=(iG[(Oqx)])
local real oSx
local real I4o
local integer ZUo
if(Zuo<1.)then
set Zuo=1.
endif
set oSx=(rG[(Oqx)])
set I4o=oSx*1./ Zuo
set I4o=zSv+(I4o-zSv)*zYv
set zSv=I4o
set ZUo=(R2I(((I4o*30)*1.)))
call pbx(zQv,zzv,zUv,iqx(pLx("l",ZUo),ZSo(I4o>.5,iwx(2.-2.*I4o,1.,.0,1.),iwx(1.,I4o*2.,.0,1.)))+iqx(pLx("l",30-ZUo),"ff000000"))
call pbx(zQv,zzv,zwv,(I2S(((R2I(((((oSx)*1.))*1.))))))+"/"+(I2S(((R2I(((((Zuo)*1.))*1.)))))))
endfunction
function Zwo takes integer Oqx returns nothing
call pbx(zQv,zZv,zUv,"Life reg.: ")
call pbx(zQv,zZv,zwv,ZMo((yg[(Oqx)]),(jG[(Oqx)]),2))
endfunction
function ZWo takes integer Oqx returns nothing
local real Zuo=(mF[(Oqx)])
local real oSx
local real I4o
local integer ZUo
if(Zuo<1.)then
set Zuo=1.
endif
set oSx=(LF[(Oqx)])
set I4o=oSx*1./ Zuo
set I4o=ztv+(I4o-ztv)*zYv
set ztv=I4o
set ZUo=(R2I(((I4o*40)*1.)))
call pbx(zQv,z_v,zUv,iqx(pLx("l",ZUo),iwx(iOx(I4o,.5),.0,iOx(I4o,.5),1.))+iqx(pLx("l",30-ZUo),"ff000000"))
call pbx(zQv,z_v,zwv,(I2S(((R2I(((((oSx)*1.))*1.))))))+"/"+(I2S(((R2I(((((Zuo)*1.))*1.)))))))
endfunction
function Zyo takes integer Oqx returns nothing
call pbx(zQv,z0v,zUv,"Mana reg.: ")
call pbx(zQv,z0v,zwv,ZMo((GF[(Oqx)]),(PF[(Oqx)]),2))
endfunction
function ZYo takes integer Oqx returns nothing
local real oSx=(NLv[(Oqx)])
local real Zzo=R2o(Oqx,oSx)
local string ZZo=ZMo(oSx,(NPv[(Oqx)]),0)
if(Zzo!=oSx)then
set ZZo=ZZo+" ("+iqx((I2S(((R2I(((((Zzo)*1.))*1.)))))),"ffffcc00")+")"
endif
call pbx(zQv,z1v,zUv,"Move speed: ")
call pbx(zQv,z1v,zwv,ZZo)
endfunction
function Z_o takes integer Oqx returns nothing
call pbx(zQv,z3v,zUv,"Spell power: ")
call pbx(zQv,z3v,zwv,ZMo((ZF[(Oqx)]),(zF[(Oqx)]),0))
endfunction
function Z0o takes integer Oqx returns nothing
local real Zuo=(Nqv[(Oqx)])
local real oSx
local real I4o
local integer ZUo
if(Zuo<1.)then
set Zuo=1.
endif
set oSx=(NQv[(Oqx)])
set I4o=oSx*1./ Zuo
set I4o=zTv+(I4o-zTv)*zYv
set zTv=I4o
set ZUo=(R2I(((I4o*40)*1.)))
call pbx(zQv,z4v,zUv,iqx(pLx("l",ZUo),iwx(iOx(.7,I4o),iOx(.7,I4o),.0,1.))+iqx(pLx("l",30-ZUo),"ff000000"))
call pbx(zQv,z4v,zwv,(I2S(((R2I(((((oSx)*1.))*1.))))))+"/"+(I2S(((R2I(((((Zuo)*1.))*1.)))))))
endfunction
function Z1o takes integer Oqx returns nothing
call pbx(zQv,z5v,zUv,"Stamina reg.: ")
call pbx(zQv,z5v,zwv,ZMo((bNv[(Oqx)]),(bIv[(Oqx)]),2))
endfunction
function Z2o takes integer oqx returns integer
local integer olx=(CXx(((oqx)),eB))
local integer o4x=0
loop
exitwhen(olx<q)
if not(wd[((COx(((oqx)),eB,(olx))))])then
set o4x=o4x+1
endif
set olx=olx-1
endloop
return o4x
endfunction
function Z3o takes integer oqx,integer okx returns integer
local integer o7x=(CXx(((oqx)),eB))
local integer Z4o
local integer mko=0
local integer olx=q
loop
exitwhen(olx>o7x)
set Z4o=(COx(((oqx)),eB,(olx)))
if not(wd[(Z4o)])then
set mko=mko+1
if(mko==okx)then
return Z4o
endif
endif
set olx=olx+1
endloop
return w
endfunction
function Z5o takes integer Oqx returns nothing
local integer o7x=Z2o(Oqx)
local integer olx=z6v
local integer Iox
loop
exitwhen(olx<=o7x)
call sDo(zQv,z7v,zwv+olx,null)
call Pwx(zQv,z7v,zwv,.0)
set olx=olx-1
endloop
set z6v=o7x
call pbx(zQv,z7v,zUv,"Status: ")
loop
exitwhen(olx<q)
set Iox=Z3o(Oqx,olx)
call sDo(zQv,z7v,zwv+olx,(aev[(Iox)]))
call Pwx(zQv,z7v,zwv,.01)
set olx=olx-1
endloop
endfunction
function Z6o takes nothing returns nothing
local integer ocx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetLocalPlayer())))))),((((R))))))
local integer Oqx=zsv[(Hpv[(ocx)]-1)]
local integer lbo=(uf[(Oqx)])
call Zqo(Oqx)
call ZQo(Oqx)
call Zso(Oqx,lbo)
call ZTo(Oqx)
call Zwo(Oqx)
call ZWo(Oqx)
call Zyo(Oqx)
call ZYo(Oqx)
call pbx(zQv,z2v,zUv,iqx((GetUnitName(C[(Oqx)])),ZSo((IsUnitAlly(C[(Oqx)],vx[(ocx)]))and((ze[(Oqx)])!=Buv),"ff00ff00",ZSo((IsUnitEnemy(C[(Oqx)],vx[(ocx)])),"ffff0000","ffffcc00"))))
call Z_o(Oqx)
call Z0o(Oqx)
call Z1o(Oqx)
call Z5o(Oqx)
endfunction
function Z7o takes nothing returns boolean
local integer rdx=(bv)
local integer ocx=(eN[(rdx)])
local integer Oqx=(Vv[(rdx)])
call ZLo(ocx,Oqx)
if iVx(ocx)then
call Z6o()
endif
return true
endfunction
function Z8o takes nothing returns nothing
call Z6o()
endfunction
function Z9o takes nothing returns boolean
local integer rdx=(bv)
set zPv=XBx("UnitStatus_Event_Start: set UnitStatus.ACQUIRE_EVENT = Event.Create(UNIT.Attack.Events.ACQUIRE_EVENT_TYPE, EventPriority.MISC, function UnitStatus.Event_TargetInRange)",ow,LI,function Zjo)
set zQv=s2o()
call DNx(XBx("UnitStatus_Event_Start: call Event.Create(HeroSelection.DUMMY_EVENT_TYPE, EventPriority.MISC, function UnitStatus.Event_HeroPick).AddToStatics()",JTv,LI,function ZJo))
call DNx(XBx("UnitStatus_Event_Start: call Event.Create(UNIT.Selection.ENDING_EVENT_TYPE, EventPriority.MISC, function UnitStatus.Event_Deselect).AddToStatics()",Czv,LI,function Zmo))
call DNx(XBx("UnitStatus_Event_Start: call Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.MISC, function UnitStatus.Event_Select).AddToStatics()",C0v,LI,function Z7o))
set zUv=s7o(zQv)
set zwv=s7o(zQv)
set z2v=(s3o(zQv))
call s3o(zQv)
set zzv=(s3o(zQv))
set zZv=(s3o(zQv))
set z_v=(s3o(zQv))
set z0v=(s3o(zQv))
set z4v=(s3o(zQv))
set z5v=(s3o(zQv))
call s3o(zQv)
set zyv=(s3o(zQv))
set z3v=(s3o(zQv))
set zuv=(s3o(zQv))
set zWv=(s3o(zQv))
set z1v=(s3o(zQv))
call s3o(zQv)
set z7v=(s3o(zQv))
call PWx(zQv,zUv,.1)
call PWx(zQv,zwv,.1)
call s4o((zQv),("Unit Status"))
call Pwx(zQv,zzv,zUv,.12)
call Pwx(zQv,zzv,zwv,.08)
call Pwx(zQv,z_v,zUv,.12)
call Pwx(zQv,z_v,zwv,.08)
call Pwx(zQv,z2v,zUv,.2)
call Pwx(zQv,z2v,zwv,.0)
call Pwx(zQv,z4v,zUv,.12)
call Pwx(zQv,z4v,zwv,.08)
call Pwx(zQv,z7v,zwv,.01)
call icx(inx(),.125,true,function Z8o)
return true
endfunction
function vvr takes nothing returns boolean
call DNx(XBx("UnitStatus_Init: call Event.Create(EventType.START, EventPriority.MISC, function UnitStatus.Event_Start).AddToStatics()",XE,LI,function Z9o))
return true
endfunction
function ver takes nothing returns boolean
call kZo(function vvr,"UnitStatus_Init")
return true
endfunction
function vxr takes nothing returns boolean
set z8v=WTx('BViR',"Victory Rush",'bViR')
set qU[(z8v)]=(true)
set aev[(z8v)]=("ReplaceableTextures\\CommandButtons\\BTNBattleRoar.blp")
call lux(z8v,"Abilities\\Spells\\NightElf\\BattleRoar\\RoarTarget.mdl","overhead",ri)
set SU=lYx()
call l_x(SU,nev,.3)
call l_x(SU,ZU,.2)
call l0x(((z8v)),vc+(1),(SU))
return true
endfunction
function vor takes nothing returns boolean
call VRx(Ma,(function vxr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\VictoryRush.page\\VictoryRush.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function vrr takes nothing returns boolean
set z9v=Vnx(Zvv)
return true
endfunction
function vir takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=(Vv[(rdx)])
local real x=(GetUnitX(C[((Oqx))]))
local real y=(GetUnitY(C[((Oqx))]))
local integer Ixx
call mFo((mHo(((x)*1.),((y)*1.),(Zxv),(ri))))
call Nio(Zov,x,y,Zrv,Ziv)
set Ixx=Nao(Zov)
if(Ixx!=w)then
loop
call NIx((Ixx),(z8v),(1),w,((Zav)*1.))
set Ixx=Nao(Zov)
exitwhen(Ixx==w)
endloop
endif
set Me[(pe)]=(((Me[(pe)])+.01)*1.)
call iLx(Ge,iqx("Notification:","ffffcc00")+" A defender died: Spawns have now "+(I2S(((R2I((((((Me[(pe)])*100.)*1.))*1.))))))+"%"+" life.",10.)
return true
endfunction
function var takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if not(IsUnitAlly(C[(Ixx)],vx[(HWv)]))then
return false
endif
return true
return true
endfunction
function vnr takes nothing returns boolean
set Zev=XBx("VictoryRush_Init: set VictoryRush.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function VictoryRush.Event_Death)",VP,LI,function vir)
set Zov=O2x()
set Ziv=XLx(function var)
return true
endfunction
function vVr takes nothing returns boolean
call kZo(function vnr,"VictoryRush_Init")
return true
endfunction
function vEr takes integer oqx,integer oQx,integer oSx returns boolean
return((LoadInteger(o[((D[((xc[(oqx)]))]))],((((oc[((oqx))])))),(osx(((oQx)),(((oSx)))))))!=0)
endfunction
function vXr takes integer oqx,integer oQx,boolean oSx returns nothing
call SaveBoolean(o[((V[(E[((xc[(oqx)]))])]))],((((oc[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function vOr takes integer oqx,integer IIx,boolean o2x returns nothing
if vEr((oqx),rc,IIx)then
call oYx("FolderUnitModSet_StructBoolMods_Add","call DebugEx(FolderUnitModSet_StructBoolMods.NAME + \": \"+I2S(this) + \" already has \" + state.GetName())",D7v+": "+I2S(oqx)+" already has "+(BHv[(IIx)]))
return
endif
call lzx((oqx),rc,IIx)
call vXr((oqx),nc+IIx,o2x)
endfunction
function vRr takes nothing returns boolean
set Znv=lQx(ZVv+" (dummyBuff)")
set qc[(Znv)]=(true)
call lux(Znv,"Abilities\\Spells\\Human\\ManaShield\\ManaShieldCaster.mdl","origin",ri)
set SU=lYx()
call l_x(SU,XAv,4)
call l_x(SU,ZU,.5)
call vOr(SU,dPv,true)
call l0x(((Znv)),vc+(1),(SU))
return true
endfunction
function vIr takes nothing returns boolean
call VRx(Ma,(function vRr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Waypoint.page\\Waypoint.struct\\RegionCheck\\Retreat\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function vAr takes nothing returns boolean
set ZEv=Vnx(ZVv)
return true
endfunction
function vNr takes nothing returns boolean
set ZXv=Vnx(ZOv)
return true
endfunction
function vbr takes nothing returns boolean
call LZx('Awan',false)
return true
endfunction
function vBr takes nothing returns boolean
call VRx(qa,(function vbr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Waypoint.page\\Waypoint.struct\\Spawns\\obj_wanderSpell_wc3spell.j"))
return true
endfunction
function vcr takes nothing returns boolean
set ZRv=Vnx(ZIv)
return true
endfunction
function vCr takes nothing returns boolean
set ZAv=Vnx(ZNv)
return true
endfunction
function vdr takes integer oqx returns integer
set Zdv[oqx]=true
set ZDv[oqx]=false
call rax(ZAv)
return oqx
endfunction
function vDr takes nothing returns integer
local integer oqx
if(Zbv==8190)then
call oYx("Waypoint_Allocation_allocCustom","call DebugEx(Waypoint.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",ZNv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(ZBv[(w)]==w)then
set Zcv=Zcv+1
set oqx=Zcv
else
set oqx=ZBv[(w)]
set ZBv[(w)]=ZBv[ZBv[(w)]]
endif
set ZBv[oqx]=Z
set ZCv[oqx]=1
call vdr(oqx)
return oqx
endfunction
function vfr takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((sm[(oqx)]))])]))],((((ym[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function vFr takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((qrv[(oqx)]))])]))],((((qVv[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function vgr takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((qrv[(oqx)]))])]))],((((qVv[((oqx))])))),(((oQx)))))
endfunction
function vGr takes integer oqx,integer Oqx returns nothing
local integer rkx=oqx
if not((Zfv[((Oqx))])>0)then
return
endif
set oqx=Oqx
set cw[oqx]=rkx
call Lnx(Oqx)
endfunction
function vhr takes nothing returns boolean
local integer oqx=vgr((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetTriggeringRegion())))))),((((qnv)))))),ykv)
call vGr(oqx,Q_x())
return true
endfunction
function vHr takes integer ozx,integer Rkx returns integer
local integer oqx=vDr()
local integer vjr=QOo(ozx)
set Dw[(oqx)]=(Rkx)
set Hw[(oqx)]=(ozx)
call vfr(ozx,ykv,oqx)
call vFr(vjr,ykv,oqx)
call TriggerRegisterEnterRegion(fA[((Xhx(function vhr)))],P7v[(vjr)],Condition((null)))
return oqx
endfunction
function vJr takes nothing returns boolean
local integer Oqx=Q_x()
if((ze[(Oqx)])!=HWv)then
return true
endif
call DSx((Oqx),(ZFv),(1),w)
return true
endfunction
function vkr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
call Ayx(Ixx,ZFv)
call NIx(((Ixx)),(Znv),(1),w,((ZGv)*1.))
call Lnx(Ixx)
endfunction
function vKr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer ibx=inx()
set Zgv[oqx]=ibx
set ge[(ibx)]=(oqx)
call icx(ibx,3.,false,function vkr)
return true
endfunction
function vlr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer ibx=Zgv[oqx]
call ijx(ibx)
return true
endfunction
function vLr takes nothing returns nothing
endfunction
function vmr takes nothing returns nothing
local integer vMr=QXo()
call RegionAddRect(P7v[(vMr)],bm[(q_x(No))])
call RegionAddRect(P7v[(vMr)],bm[(q_x(bo))])
call RegionAddRect(P7v[(vMr)],bm[(q_x(jo))])
call TriggerRegisterLeaveRegion(fA[((Xhx(function vJr)))],P7v[(vMr)],Condition((null)))
set ZFv=lQx(ZOv)
call l9x(ZFv,XBx("FolderWaypoint_StructRegionCheck_Init: call FolderWaypoint_StructRegionCheck.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderWaypoint_StructRegionCheck.Event_BuffGain))",Bd,LI,function vKr))
call l9x(ZFv,XBx("FolderWaypoint_StructRegionCheck_Init: call FolderWaypoint_StructRegionCheck.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderWaypoint_StructRegionCheck.Event_BuffLose))",Jc,LI,function vlr))
set qc[(ZFv)]=(true)
set Yd[(ZFv)]=(true)
call lux(ZFv,"Abilities\\Spells\\Other\\TalkToMe\\TalkToMe.mdl","overhead",ri)
call vLr()
endfunction
function vpr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
call Rmx(Ixx,Zhv)
call Rmx(Ixx,ZHv)
return true
endfunction
function vPr takes nothing returns boolean
local integer rdx=(bv)
call Lnx((Vv[(rdx)]))
return true
endfunction
function vqr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),ZJv)
return true
endfunction
function vQr takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(ZJv),(1),w)
return true
endfunction
function vsr takes nothing returns nothing
local integer olx=ZKv
loop
exitwhen(olx<0)
set Zlv[olx]=ZLv[olx]
set olx=olx-1
endloop
set Zmv=ZKv
endfunction
function vSr takes nothing returns integer
local integer o4x
if(Zmv<0)then
return w
endif
set o4x=Zlv[0]
set Zlv[0]=Zlv[Zmv]
set Zmv=Zmv-1
return o4x
endfunction
function vtr takes nothing returns boolean
local integer rdx=(bv)
local integer oqx
local integer Ixx
set Cw=true
call vsr()
loop
set oqx=vSr()
exitwhen(oqx==w)
set Ixx=oqx
call Ayx(Ixx,ZJv)
call rQx(Ixx,'Awan')
if(I6x(Ixx,sc)==false)then
call SetUnitAnimation(C[((Ixx))],("victory"))
call QueueUnitAnimation(C[((Ixx))],("spell"))
endif
endloop
return true
endfunction
function vTr takes integer oqx returns boolean
if((Zfv[((oqx))])>0)then
return false
endif
set ZKv=ZKv+1
set ZLv[ZKv]=oqx
set Zfv[oqx]=ZKv+1
return(ZKv==0)
endfunction
function vur takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
set cw[oqx]=w
call I7x(Ixx,Zhv)
call I7x(Ixx,ZHv)
if not Cw then
call Yqo(Ixx,Zjv)
endif
call vTr(Ixx)
return true
endfunction
function vUr takes integer oqx returns boolean
if(((Zfv[((oqx))])>0)==false)then
return false
endif
set Zfv[ZLv[ZKv]]=Zfv[oqx]
set ZLv[Zfv[oqx]-1]=ZLv[ZKv]
set Zfv[oqx]=0
set ZKv=ZKv-1
return(ZKv==F)
endfunction
function vwr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
call Blo(Ixx,Zjv)
call vUr(Ixx)
return true
endfunction
function vWr takes nothing returns nothing
set Zhv=XBx("FolderWaypoint_StructSpawns_Init: set FolderWaypoint_StructSpawns.DESTROY_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderWaypoint_StructSpawns.Event_Destroy)",VP,LI,function vpr)
set Cw=false
set Zjv=XBx("FolderWaypoint_StructSpawns_Init: set FolderWaypoint_StructSpawns.IDLE_EVENT = Event.Create(UNIT.Order.Events.Idle.INTERVAL_EVENT_TYPE, EventPriority.MISC, function FolderWaypoint_StructSpawns.Event_Idle)",cuv,LI,function vPr)
set ZHv=XBx("FolderWaypoint_StructSpawns_Init: set FolderWaypoint_StructSpawns.OWNER_CHANGE_EVENT = Event.Create(UNIT.Owner.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderWaypoint_StructSpawns.Event_OwnerChange)",rx,LI,function vqr)
set Zkv=XBx("FolderWaypoint_StructSpawns_Init: set FolderWaypoint_StructSpawns.SPAWN_EVENT = Event.Create(Spawn.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderWaypoint_StructSpawns.Event_Spawn)",aw,LI,function vQr)
call DNx(XBx("FolderWaypoint_StructSpawns_Init: call Event.Create(Meteorite.GAME_OVER_EVENT_TYPE, EventPriority.MISC, function FolderWaypoint_StructSpawns.Event_GameOver).AddToStatics()",JQv,LI,function vtr))
call DNx(Zkv)
set ZJv=lQx(ZIv)
call l9x(ZJv,XBx("FolderWaypoint_StructSpawns_Init: call FolderWaypoint_StructSpawns.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderWaypoint_StructSpawns.Event_BuffGain))",Bd,pI,function vur))
call l9x(ZJv,XBx("FolderWaypoint_StructSpawns_Init: call FolderWaypoint_StructSpawns.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderWaypoint_StructSpawns.Event_BuffLose))",Jc,pI,function vwr))
endfunction
function vyr takes nothing returns boolean
set dw=vHr(q_x(Px),w)
call vHr(q_x(px),dw)
call vHr(q_x(Qx),dw)
call vHr(q_x(sx),dw)
call vmr()
call vWr()
return true
endfunction
function vYr takes nothing returns boolean
call Wuo(function vyr,"Waypoint_Init")
return true
endfunction
function vzr takes nothing returns boolean
set ZMv=Vnx(Zpv)
return true
endfunction
function vZr takes integer oqx returns boolean
set Zsv=Zsv+1
set ZSv[Zsv]=oqx
set Ztv[oqx]=Zsv+1
return(Zsv==0)
endfunction
function v_r takes integer oqx returns nothing
set ZWv[oqx]=false
call rgx(nl)
endfunction
function v0r takes integer oqx returns nothing
if(ZUv[oqx]>0)then
return
endif
if(Zwv[oqx]!=Z)then
call oYx("FolderCameraField_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderCameraField_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Vl+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set Zwv[oqx]=Zwv[(w)]
set Zwv[(w)]=oqx
call v_r(oqx)
endfunction
function v1r takes integer oqx returns nothing
set ZUv[oqx]=ZUv[oqx]-1
call v0r(oqx)
endfunction
function v2r takes integer oqx returns boolean
local integer okx=(Zyv[(oqx)])
set Zyv[ZYv[Zzv]]=okx
set ZYv[okx-1]=ZYv[Zzv]
set Zyv[oqx]=0
set Zzv=Zzv-1
return(Zzv==F)
endfunction
function v3r takes integer oqx,integer ibx,integer rkx,integer ocx returns nothing
call v1r((oqx))
call ijx(ibx)
if v2r(oqx)then
call iHx(ll)
endif
call hGx(ocx,Zuv+rkx)
endfunction
function v4r takes integer oqx returns integer
set ZWv[oqx]=true
set Z1v[oqx]=false
call rax(nl)
return oqx
endfunction
function v5r takes nothing returns integer
local integer oqx
if(Z_v==8190)then
call oYx("FolderCameraField_StructTimed_Allocation_allocCustom","call DebugEx(FolderCameraField_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Vl+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Zwv[(w)]==w)then
set Z0v=Z0v+1
set oqx=Z0v
else
set oqx=Zwv[(w)]
set Zwv[(w)]=Zwv[Zwv[(w)]]
endif
set Zwv[oqx]=Z
set ZUv[oqx]=1
call v4r(oqx)
return oqx
endfunction
function v6r takes integer oqx returns boolean
set Zzv=Zzv+1
set ZYv[Zzv]=oqx
set Zyv[oqx]=Zzv+1
return(Zzv==0)
endfunction
function v7r takes integer oqx,integer ocx,real oSx returns nothing
if iVx(ocx)then
set Z7v[oqx]=oSx
call SetCameraField(sl[oqx],oSx,.0)
endif
endfunction
function v8r takes nothing returns nothing
local integer olx=Zzv
local integer oqx
local integer rkx
local real v9r
local real abx
loop
set oqx=ZYv[olx]
set rkx=Z2v[oqx]
set v9r=Z3v[oqx]
set abx=(Z7v[(rkx)])
set Z3v[oqx]=v9r-1
call v7r(rkx,Z6v[oqx],abx+(Z5v[oqx]-abx)*1./ v9r)
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function evr takes nothing returns nothing
local integer ibx=ifx()
local integer oqx=(ge[(ibx)])
local integer rkx=Z2v[oqx]
local real oSx=Z5v[oqx]
local integer ocx=Z6v[oqx]
call v3r(oqx,ibx,rkx,ocx)
call v7r(rkx,ocx,oSx)
endfunction
function eer takes integer oqx,integer ocx,real oSx,real ilx returns nothing
local integer rkx=oqx
local integer ibx
set oqx=hFx(ocx,Zuv+rkx)
if(oqx!=w)then
call v3r(oqx,ZZv[oqx],rkx,ocx)
endif
set oqx=v5r()
set ibx=inx()
set ZZv[oqx]=ibx
set Z2v[oqx]=rkx
set Z3v[oqx]=ilx*1./ Z4v
set Z5v[oqx]=oSx
set Z6v[oqx]=ocx
set ge[(ibx)]=(oqx)
call hJx(ocx,Zuv+rkx,oqx)
if v6r(oqx)then
call icx(ll,Z4v,true,function v8r)
endif
call icx(ibx,ilx,false,function evr)
endfunction
function exr takes nothing returns nothing
local real eor=(GetCameraTargetPositionX())
local real err=(GetCameraTargetPositionY())
local integer olx=Zsv
local integer oqx
local integer Sgo
local real eir
loop
set oqx=ZSv[olx]
set Sgo=oqx
set eir=T0
set Zqv[oqx]=eor
set ZQv[oqx]=err
call eer(ul,Sgo,eir,1.)
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function ear takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=(eN[(rdx)])
set Zqv[oqx]=(GetCameraTargetPositionX())
set ZQv[oqx]=(GetCameraTargetPositionY())
if vZr(oqx)then
call icx(ZPv,ZTv,true,function exr)
endif
return true
endfunction
function enr takes nothing returns boolean
set ZPv=inx()
call DNx(XBx("Zoom_Init: call Event.Create(AfterIntro.FOR_PLAYER_EVENT_TYPE, EventPriority.MISC, function Zoom.Event_AfterIntro).AddToStatics()",jbv,LI,function ear))
return true
endfunction
function eVr takes nothing returns boolean
call kZo(function enr,"Zoom_Init")
return true
endfunction
function eEr takes nothing returns boolean
set Z8v=Vnx(Z9v)
return true
endfunction
function eXr takes code c,string rqx returns nothing
set An=An+1
set Nn[An]=CreateTrigger()
set bn[An]=(GetHandleId(Condition((c))))
set Bn[An]=rqx
call TriggerAddCondition(Nn[An],Condition(c))
endfunction
function eOr takes integer oqx,integer Xwx returns nothing
if not((LoadInteger(o[((D[((BRv[oqx]))]))],((((gw[((oqx))])))),(osx((((rA[(Xwx)]))),(((Xwx)))))))!=0)then
call oYx("FolderUnitType_StructEvent_Remove","call DebugEx(\"subject \"+I2S(UnitType(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((gw[((oqx))]))+" has not "+(JA[(Xwx)]))
return
endif
call rex(BRv[oqx],(gw[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function eRr takes integer eIr,string iNx,real ilx returns nothing
call iLx(Ge,"ffffcc00"+(GetUnitName(C[(eIr)]))+": "+"|r"+iNx,ilx)
call PingMinimap(((((DPx(eIr))*1.))*1.),((((DQx(eIr))*1.))*1.),((((1.)*1.))*1.))
call AddIndicator(C[(eIr)],($FF),($FF),($FF),($FF))
endfunction
function eAr takes nothing returns boolean
local integer rdx=(bv)
local integer eNr=(Vv[(rdx)])
call eOr(vee,vve)
call eRr(eNr,"Let's have some fun, everyone!",2.)
call TriggerSleepAction(((2.)*1.))
call eRr(eNr,"Loot the castle!",1.)
return true
endfunction
function ebr takes nothing returns boolean
set vve=XBx("AxeFighter_Init: set AxeFighter.ACQUIRES_TARGET_EVENT = Event.Create(UNIT.Attack.Events.DUMMY_EVENT_TYPE, EventPriority.SPEECHES, function AxeFighter.Event_AcquiresTarget)",dSv,MI,function eAr)
set vee=G0v
call S8o(vee,vve)
return true
endfunction
function eBr takes nothing returns boolean
call eXr(function ebr,"AxeFighter_Init")
return true
endfunction
function ecr takes nothing returns boolean
set vxe=Vnx(voe)
return true
endfunction
function eCr takes nothing returns boolean
local integer rdx=(bv)
local integer eNr=(Vv[(rdx)])
call eOr(vie,vre)
call eRr(eNr,"Crawl before me, little worms!",2.)
call TriggerSleepAction(((1.)*1.))
call eRr(eNr,"I challenge you!",.75)
call TriggerSleepAction(((1.)*1.))
call eRr(eNr,"Only the winner shall be the one to survive.",3.)
return true
endfunction
function edr takes nothing returns boolean
set vre=XBx("Balduir_Init: set Balduir.ACQUIRES_TARGET_EVENT = Event.Create(UNIT.Attack.Events.DUMMY_EVENT_TYPE, EventPriority.SPEECHES, function Balduir.Event_AcquiresTarget)",dSv,MI,function eCr)
set vie=Gqv
call S8o(vie,vre)
return true
endfunction
function eDr takes nothing returns boolean
call eXr(function edr,"Balduir_Init")
return true
endfunction
function efr takes nothing returns boolean
set vae=Vnx(vne)
return true
endfunction
function eFr takes nothing returns boolean
set vVe=Vnx(vEe)
return true
endfunction
function egr takes nothing returns boolean
set vXe=Vnx(vOe)
return true
endfunction
function eGr takes nothing returns boolean
set vRe=Vnx(vIe)
return true
endfunction
function ehr takes nothing returns boolean
set vAe=Vnx(vNe)
return true
endfunction
function eHr takes nothing returns boolean
set vbe=Vnx(vBe)
return true
endfunction
function ejr takes nothing returns boolean
set vce=Vnx(vCe)
return true
endfunction
function eJr takes nothing returns boolean
set vde=Vnx(vDe)
return true
endfunction
function ekr takes code c,string rqx returns nothing
set cn=cn+1
set Cn[cn]=CreateTrigger()
set dn[cn]=(GetHandleId(Condition((c))))
set Dn[cn]=rqx
call TriggerAddCondition(Cn[cn],Condition(c))
endfunction
function eKr takes integer oqx returns boolean
return( not(O0v[(vhe[oqx])]))
endfunction
function elr takes integer oqx returns boolean
if((vHe[((oqx))])>0)then
return false
endif
set vje=vje+1
set vJe[vje]=oqx
set vHe[oqx]=vje+1
return(vje==0)
endfunction
function eLr takes nothing returns nothing
local integer olx=vje
loop
exitwhen(olx<0)
set vKe[olx]=vJe[olx]
set olx=olx-1
endloop
set vle=vje
endfunction
function emr takes nothing returns integer
local integer o4x
if(vle<0)then
return w
endif
set o4x=vKe[0]
set vKe[0]=vKe[vle]
set vle=vle-1
return o4x
endfunction
function eMr takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((vqe[oqx]))])]))],((((vpe[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function epr takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((vqe[oqx]))])]))],((((vpe[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function ePr takes integer oqx,integer Ixx returns nothing
local integer rkx=oqx
local integer rdx=rEx((vpe[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set vPe[(rdx)]=(rkx)
set Vv[(rdx)]=(Ixx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=eMr(rkx,vQe,rIx)
loop
exitwhen(rlx<q)
call rCx(epr(rkx,vQe,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function eqr takes integer oqx,integer Ixx returns nothing
local integer rkx=oqx
call ePr(oqx,Ixx)
endfunction
function eQr takes integer oqx,integer o2x returns nothing
local integer nUx
loop
set nUx=Nao(o2x)
exitwhen(nUx==w)
call dpx(oqx,nUx)
endloop
endfunction
function esr takes integer oqx,integer Ixx returns nothing
local integer rkx=oqx
local integer rdx=rEx((vpe[(rkx)]))
local integer olx
local integer rIx
local integer rlx
set vPe[(rdx)]=(rkx)
set Vv[(rdx)]=(Ixx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=eMr(rkx,vse,rIx)
loop
exitwhen(rlx<q)
call rCx(epr(rkx,vse,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function eSr takes integer oqx,integer Ixx returns nothing
local integer rkx=oqx
call esr(oqx,Ixx)
endfunction
function etr takes integer oqx returns nothing
local integer CMx=(vhe[(oqx)])
local integer Q7o=(vLe[(oqx)])
local real x=(GetUnitX(C[((CMx))]))
local real y=(GetUnitY(C[((CMx))]))
local integer Ixx
set Hf=(ze[(CMx)])
call Nio(vfe,x,y,(vme[(oqx)]),(vMe[(oqx)]))
call GroupRemoveUnit(Kb[(vfe)],C[(CMx)])
set Ixx=(Otx((Q7o),Rb))
if(Ixx!=w)then
loop
if Lko(vfe,Ixx)then
call IEo(Q7o,Ixx)
call GroupRemoveUnit(Kb[(vfe)],C[(Ixx)])
call GroupAddUnit(Kb[(vFe)],C[(Ixx)])
else
call IEo(Q7o,Ixx)
call eqr(oqx,Ixx)
endif
set Ixx=(Otx((Q7o),Rb))
exitwhen(Ixx==w)
endloop
call eQr(Q7o,vFe)
endif
set Ixx=Nao(vfe)
if(Ixx!=w)then
loop
call dpx(Q7o,Ixx)
call eSr(oqx,Ixx)
set Ixx=Nao(vfe)
exitwhen(Ixx==w)
endloop
endif
endfunction
function eTr takes nothing returns nothing
local integer oqx
call eLr()
loop
set oqx=emr()
exitwhen(oqx==w)
call etr(oqx)
endloop
endfunction
function eur takes integer oqx returns nothing
if not eKr(oqx)then
return
endif
if elr(oqx)then
call icx(vke,.75,true,function eTr)
endif
endfunction
function eUr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer olx=CXx(CMx,vGe)
local integer oqx
loop
set oqx=COx(CMx,vGe,olx)
call eur(oqx)
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function ewr takes integer oqx returns boolean
if(((vHe[((oqx))])>0)==false)then
return false
endif
set vHe[vJe[vje]]=vHe[oqx]
set vJe[vHe[oqx]-1]=vJe[vje]
set vHe[oqx]=0
set vje=vje-1
return(vje==F)
endfunction
function eWr takes integer oqx returns nothing
local integer Q7o=(vLe[(oqx)])
local integer Ixx
loop
set Ixx=(dLx((Q7o),Rb))
exitwhen(Ixx==w)
call eqr(oqx,Ixx)
endloop
endfunction
function eyr takes integer oqx returns nothing
if ewr(oqx)then
call iHx(vke)
endif
call eWr(oqx)
endfunction
function eYr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer olx=CXx(CMx,vGe)
local integer oqx
loop
set oqx=COx(CMx,vGe,olx)
call eyr(oqx)
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function ezr takes nothing returns nothing
set vQe=(E0x())
set vse=(E0x())
endfunction
function eZr takes nothing returns boolean
set vfe=O2x()
set vFe=O2x()
set vge=XBx("Aura_Init: set Aura.TRANSPORT_ENDING_EVENT = Event.Create(UNIT.Transport.ENDING_EVENT_TYPE, EventPriority.SPELLS, function Aura.Event_TransportEnding)",O2v,pI,function eUr)
set vSe=XBx("Aura_Init: set Aura.TRANSPORT_START_EVENT = Event.Create(UNIT.Transport.START_EVENT_TYPE, EventPriority.SPELLS, function Aura.Event_TransportStart)",O1v,pI,function eYr)
set vke=inx()
call ezr()
return true
endfunction
function e_r takes nothing returns boolean
call ekr(function eZr,"Aura_Init")
return true
endfunction
function e0r takes nothing returns boolean
set vte=Vnx(vTe)
return true
endfunction
function e1r takes code c,string rqx returns nothing
set tV=tV+1
set TV[tV]=CreateTrigger()
set uV[tV]=(GetHandleId(Condition((c))))
set UV[tV]=rqx
call TriggerAddCondition(TV[tV],Condition(c))
endfunction
function e2r takes integer oqx returns integer
set vye[oqx]=true
set vYe[oqx]=false
set NK[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
call rax(iq)
return oqx
endfunction
function e3r takes nothing returns integer
local integer oqx
if(vue==8190)then
call oYx("EventCombination_Allocation_allocCustom","call DebugEx(EventCombination.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",aq+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(vUe[(w)]==w)then
set vwe=vwe+1
set oqx=vwe
else
set oqx=vUe[(w)]
set vUe[(w)]=vUe[vUe[(w)]]
endif
set vUe[oqx]=Z
set vWe[oqx]=1
call e2r(oqx)
return oqx
endfunction
function e4r takes integer oqx returns nothing
set bK[(oqx)]=(vZe+oqx)
endfunction
function e5r takes code Xbx returns integer
local integer oqx=e3r()
set vze[oqx]=w
call e4r(oqx)
set v_e[(oqx)]=XHx((Xbx))
set vze[(oqx)]=(w)
return oqx
endfunction
function e6r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=FJx((av[(rdx)]))
if((HPv[((ze[(CMx)]))])!=h9v)then
return false
endif
return true
return true
endfunction
function e7r takes integer oqx,integer okx returns real
return Cpx(oqx,fH+okx)
endfunction
function e8r takes integer Xwx,integer rXx returns boolean
if(Azo(Xwx,rXx)==false)then
call DAx((Xwx),(rXx),false==(false))
call DAx(((FMx((Xwx),v0e))),(rXx),false==(true))
return true
endif
return false
endfunction
function e9r takes integer oqx,integer rXx returns integer
return(LoadInteger(o[((V[(E[((X))])]))],(((rXx))),(((v1e+oqx)))))
endfunction
function xvr takes integer oqx,integer rXx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((X))])]))],(((rXx))),(((v1e+oqx))),(((oSx))))
endfunction
function xer takes integer oqx,integer rXx returns boolean
local integer oSx=e9r(oqx,rXx)+1
call xvr(oqx,rXx,oSx)
return(oSx==1)
endfunction
function xxr takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((NK[(oqx)]))])]))],((((bK[((oqx))])))),(((oQx))))))
endfunction
function xor takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((NK[(oqx)]))])]))],((((bK[((oqx))])))),(((oQx)+(okx)))))
endfunction
function xrr takes integer oqx,integer oQx,integer oSx returns boolean
return rex(v3e[(oqx)],(v4e[((oqx))]),oQx,oSx)
endfunction
function xir takes integer oqx,integer p0x,integer oSx returns boolean
return xrr(p0x,v5e,oSx)
endfunction
function xar takes integer oqx,integer rXx returns nothing
local integer olx=(xxr(((oqx)),v2e))
local integer p0x
loop
exitwhen(olx<q)
set p0x=(xor(((oqx)),v2e,(olx)))
if xir((w),p0x,rXx)then
call PauseTimer(v6e[(p0x)])
endif
set olx=olx-1
endloop
endfunction
function xnr takes nothing returns boolean
local integer rdx=(bv)
local integer rXx=(av[(rdx)])
local integer Xwx=(Nv)
local integer rkx=(FMx((Xwx),CK))
if e8r(Xwx,rXx)then
if xer(rkx,rXx)then
call xar(rkx,rXx)
endif
endif
return true
endfunction
function xVr takes integer oqx,integer rXx returns boolean
local integer oSx=e9r(oqx,rXx)-1
call xvr(oqx,rXx,oSx)
return(oSx==0)
endfunction
function xEr takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(v3e[(oqx)],(v4e[((oqx))]),oQx,oSx)
endfunction
function xXr takes integer oqx,integer p0x,integer oSx returns boolean
return xEr(p0x,v5e,oSx)
endfunction
function xOr takes integer oqx returns nothing
call TimerStart(v6e[oqx],v7e[oqx],v8e[oqx],null)
endfunction
function xRr takes integer oqx returns nothing
call xOr(oqx)
endfunction
function xIr takes integer oqx,integer rXx returns nothing
local integer olx=(xxr(((oqx)),v2e))
local integer p0x
loop
exitwhen(olx<q)
set p0x=(xor(((oqx)),v2e,(olx)))
if xXr((w),p0x,rXx)then
call xRr(p0x)
endif
set olx=olx-1
endloop
endfunction
function xAr takes integer oqx,integer fromWhichEvent returns nothing
set AK=(oqx)
if rAx(vze[oqx])then
call rcx(v_e[oqx])
endif
endfunction
function xNr takes nothing returns boolean
local integer rdx=(bv)
local integer rXx=(av[(rdx)])
local integer Xwx=(Nv)
local integer rkx=(FMx((Xwx),CK))
if e8r(Xwx,rXx)then
if xVr(rkx,rXx)then
call xIr(rkx,rXx)
if((xxr(((rkx)),v2e))>0)then
call xAr(rkx,Xwx)
endif
endif
endif
return true
endfunction
function xbr takes integer oqx returns integer
set eoe[oqx]=true
set ere[oqx]=false
call rax(LP)
return oqx
endfunction
function xBr takes nothing returns integer
local integer oqx
if(v9e==8190)then
call oYx("EventPair_Allocation_allocCustom","call DebugEx(EventPair.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",mP+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(eve[(w)]==w)then
set eee=eee+1
set oqx=eee
else
set oqx=eve[(w)]
set eve[(w)]=eve[eve[(w)]]
endif
set eve[oqx]=Z
set exe[oqx]=1
call xbr(oqx)
return oqx
endfunction
function xcr takes integer oqx,integer oSx returns nothing
local integer xCr=(eae[(oqx)])
set eie[oqx]=oSx
if(xCr!=w)then
call pyx(xCr,v0e,oSx)
call pyx(oSx,v0e,xCr)
endif
endfunction
function xdr takes integer oqx,integer oSx returns nothing
local integer xDr=(eie[(oqx)])
set eae[oqx]=oSx
if(xDr!=w)then
call pyx(xDr,v0e,oSx)
call pyx(oSx,v0e,xDr)
endif
endfunction
function xfr takes integer xDr,integer xCr,integer xFr returns integer
local integer oqx=xBr()
set eie[oqx]=w
set eae[oqx]=w
call xcr(oqx,xDr)
call xdr(oqx,xCr)
set ene[(oqx)]=(xFr)
return oqx
endfunction
function xgr takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((v3e[(oqx)]))])]))],((((v4e[((oqx))])))),(((oQx))))))
endfunction
function xGr takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((v3e[(oqx)]))])]))],((((v4e[((oqx))])))),(((oQx)+(okx)))))
endfunction
function xhr takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(NK[(oqx)],(bK[((oqx))]),oQx,oSx)
endfunction
function xHr takes integer oqx,integer oSx returns nothing
call pyx((eie[(oSx)]),CK,oqx)
call pyx((eae[(oSx)]),CK,oqx)
endfunction
function xjr takes integer oqx,integer xJr returns nothing
local integer xDr=(eie[(xJr)])
local integer xCr=(eae[(xJr)])
local integer xFr=(ene[(xJr)])
local integer olx=(xxr((((oqx))),v2e))
local integer rXx
local integer p0x
local integer rlx
local boolean xkr
loop
exitwhen(olx<q)
set p0x=(xor((((oqx))),v2e,(olx)))
set rlx=(xgr((p0x),v5e))
loop
exitwhen(rlx<q)
set rXx=(xGr((p0x),v5e,(rlx)))
set av[((bv))]=(rXx)
set AK=(oqx)
if not rAx(xFr)then
call xir(eVe,p0x,rXx)
endif
set rlx=rlx-1
endloop
call PauseTimer(v6e[(p0x)])
set olx=olx-1
endloop
call xhr((oqx),eEe,xJr)
set olx=(xxr((((oqx))),eXe))
loop
exitwhen(olx<q)
set rXx=(xor((((oqx))),eXe,(olx)))
set av[((bv))]=(rXx)
set AK=(oqx)
set xkr=rAx(xFr)
call DAx((xDr),(rXx),false==(xkr))
call DAx((xCr),(rXx),false==(not xkr))
set olx=olx-1
endloop
call xHr((oqx),xJr)
endfunction
function xKr takes integer oqx,integer xlr,integer xLr,integer xmr,integer xMr,integer xFr returns integer
local integer xDr=XBx("FolderEventCombination_StructPairs_Create: local Event negativeEvent = Event.Create(negativeType, EventPriority.COMBINATION, function FolderEventCombination_StructPairs.Event_Negative)",xmr,HI,function xnr)
local integer xCr=XBx("FolderEventCombination_StructPairs_Create: local Event positiveEvent = Event.Create(positiveType, EventPriority.COMBINATION, function FolderEventCombination_StructPairs.Event_Positive)",xlr,HI,function xNr)
local integer o4x=xfr(xDr,xCr,xFr)
set cv[(xDr)]=(xMr)
set cv[(xCr)]=(xLr)
call xjr(oqx,o4x)
return o4x
endfunction
function xpr takes integer oqx,integer oSx,limitop Bnx returns nothing
set XA[oqx]=true
set OA[oqx]=oSx
set RA[oqx]=Bnx
endfunction
function xPr takes limitop oMx returns limitop
if(oMx==LESS_THAN)then
return GREATER_THAN_OR_EQUAL
endif
if(oMx==LESS_THAN_OR_EQUAL)then
return GREATER_THAN
endif
if(oMx==EQUAL)then
return NOT_EQUAL
endif
if(oMx==NOT_EQUAL)then
return EQUAL
endif
if(oMx==GREATER_THAN)then
return LESS_THAN_OR_EQUAL
endif
if(oMx==GREATER_THAN_OR_EQUAL)then
return LESS_THAN
endif
return null
endfunction
function xqr takes integer oqx,integer rRx,integer oSx,limitop Bnx,integer xFr returns integer
local integer xDr=XBx("FolderEventCombination_StructPairs_CreateLimit: local Event negativeEvent = Event.Create(whichType, EventPriority.COMBINATION, function FolderEventCombination_StructPairs.Event_Negative)",rRx,HI,function xnr)
local integer xCr=XBx("FolderEventCombination_StructPairs_CreateLimit: local Event positiveEvent = Event.Create(whichType, EventPriority.COMBINATION, function FolderEventCombination_StructPairs.Event_Positive)",rRx,HI,function xNr)
local integer o4x=xfr(xDr,xCr,xFr)
call xpr(xDr,oSx,xPr(Bnx))
call xpr(xCr,oSx,Bnx)
call xjr(oqx,o4x)
return o4x
endfunction
function xQr takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((NK[(oqx)]))])]))],((((bK[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function xsr takes integer oqx returns integer
return xxr((oqx),eEe)
endfunction
function xSr takes integer oqx,integer okx returns integer
return xor((oqx),eEe,okx)
endfunction
function xtr takes integer Xwx,integer rXx,boolean isx returns nothing
call DAx(Xwx,rXx,false==isx)
endfunction
function xTr takes integer oqx,integer rXx returns nothing
local integer o7x=0
local integer olx=xsr((oqx))
local boolean xkr
local integer xJr
loop
exitwhen(olx<q)
set xJr=xSr((oqx),olx)
set av[((bv))]=(rXx)
set AK=(oqx)
set xkr=rAx((ene[(xJr)]))
call xtr((eie[(xJr)]),rXx,xkr)
call xtr((eae[(xJr)]),rXx,not xkr)
if not xkr then
set o7x=o7x+1
endif
set olx=olx-1
endloop
call xhr((oqx),eXe,rXx)
if(o7x==0)then
call xIr((oqx),rXx)
endif
call xvr((oqx),rXx,o7x)
endfunction
function xur takes integer oqx,integer Fmx returns nothing
local integer olx=(xxr(((Fmx)),eIe))
local integer xUr
loop
exitwhen(olx<q)
call I7x((oqx),(xor(((Fmx)),eIe,(olx))))
set olx=olx-1
endloop
set olx=(xxr(((Fmx)),eEe))
loop
exitwhen(olx<q)
set xUr=(xor(((Fmx)),eEe,(olx)))
call I7x((oqx),(eie[(xUr)]))
call I7x((oqx),(eae[(xUr)]))
set olx=olx-1
endloop
call xTr(Fmx,(A[((oqx))]))
endfunction
function xwr takes nothing returns boolean
local integer rdx=(bv)
local integer Fmx=Fkx((nv[(rdx)]),eRe)
call xur((Vv[(rdx)]),Fmx)
return true
endfunction
function xWr takes integer oqx,integer oQx returns nothing
call SaveBoolean(o[(((V[(E[((oA[(oqx)]))])])))],(((((nA[((oqx))]))))),((((oQx)))),(false))
endfunction
function xyr takes integer oqx,integer oQx,integer oSx returns boolean
return rex(NK[(oqx)],(bK[((oqx))]),oQx,oSx)
endfunction
function xYr takes integer oqx,integer rXx returns nothing
call SaveInteger(o[(((V[(E[((X))])])))],((((rXx)))),((((v1e+oqx)))),(0))
endfunction
function xzr takes integer oqx,integer rXx returns nothing
local integer olx=xsr((oqx))
local integer xJr
loop
exitwhen(olx<q)
set xJr=xSr((oqx),olx)
call xWr((eie[(xJr)]),rXx)
call xWr((eae[(xJr)]),rXx)
set olx=olx-1
endloop
call xyr((oqx),eXe,rXx)
if(e9r((oqx),rXx)==0)then
call xar((oqx),rXx)
endif
call xYr((oqx),rXx)
endfunction
function xZr takes integer oqx,integer Fmx returns nothing
local integer olx=(xxr(((Fmx)),eIe))
local integer xUr
loop
exitwhen(olx<q)
call Rmx((oqx),(xor(((Fmx)),eIe,(olx))))
set olx=olx-1
endloop
set olx=(xxr(((Fmx)),eEe))
loop
exitwhen(olx<q)
set xUr=(xor(((Fmx)),eEe,(olx)))
call Rmx((oqx),(eie[(xUr)]))
call Rmx((oqx),(eae[(xUr)]))
set olx=olx-1
endloop
call xzr(Fmx,(A[((oqx))]))
endfunction
function x_r takes nothing returns boolean
local integer rdx=(bv)
local integer Fmx=Fkx((nv[(rdx)]),eRe)
call xZr((Vv[(rdx)]),Fmx)
return true
endfunction
function x0r takes integer rJx,code Xbx returns integer
local integer Fmx=e5r(Xbx)
set vze[(Fmx)]=(XLx(function e6r))
if(e7r(rJx,1)>.0)then
call xKr(Fmx,pH,HU,PH,jU,gU)
endif
if(FQx(rJx,1)>.0)then
call xqr(Fmx,MF,(R2I(((FQx(rJx,1))*1.))),GREATER_THAN_OR_EQUAL,JU)
endif
call xQr(Fmx,hU,rJx)
call CTx(rJx,eRe,Fmx)
call meo(rJx,XBx("AICastSpell_CreateBasics: call whichSpell.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.AI, function AICastSpell.Event_Learn))",pv,jI,function xwr))
call meo(rJx,XBx("AICastSpell_CreateBasics: call whichSpell.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.AI, function AICastSpell.Event_Unlearn))",Av,jI,function x_r))
return Fmx
endfunction
function x1r takes nothing returns boolean
local integer rdx=(bv)
call O9x(((LoadInteger(o[((V[(E[((X))])]))],(((OK+(((av[(rdx)])))))),(((IK)))))),(Ih[((eAe))]))
return true
endfunction
function x2r takes nothing returns boolean
local integer rdx=(bv)
local integer Xwx=(Nv)
local integer rkx=(FMx((Xwx),CK))
if(e9r(rkx,(av[(rdx)]))==0)then
call xAr(rkx,Xwx)
endif
return true
endfunction
function x3r takes integer oqx,integer rRx,integer rIx,integer x4r returns integer
local integer o4x=XBx("FolderEventCombination_StructEvents_Create: local Event result = Event.Create(whichType, priority, function FolderEventCombination_StructEvents.Event_Passive)",rRx,rIx,function x2r)
call pyx(o4x,CK,oqx)
call xhr((oqx),eIe,o4x)
set cv[(o4x)]=(x4r)
return o4x
endfunction
function x5r takes nothing returns boolean
local integer Fmx=x0r(eAe,function x1r)
call x3r(Fmx,dsv,jI,w)
return true
endfunction
function x6r takes nothing returns boolean
call e1r(function x5r,"AIBoost_Init")
return true
endfunction
function x7r takes nothing returns boolean
set eNe=WTx('BBoo',"Boost",'bBoo')
set avv[(eNe)]=(true)
set qU[(eNe)]=(true)
set aev[(eNe)]=("ReplaceableTextures\\CommandButtons\\BTNEtherealFormOn.blp")
call lux(eNe,"Boost_page\\Boost_struct\\Buff.mdx","foot",ri)
set SU=lYx()
call l_x(SU,dKv,$96)
call l_x(SU,Bcv,'d')
call l0x(((eNe)),vc+(1),(SU))
return true
endfunction
function x8r takes nothing returns boolean
call LZx('ABoo',false)
set eAe=Lzo('ABoo')
set G6[(eAe)]=(D6)
set j6[(eAe)]=(1)
set sH[(eAe)]=("Boost")
set Ih[(eAe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Oj))))))
set x6v[(eAe)]=(0)
set xzv[(eAe)]=("spell")
call LZo((eAe),fH+(1),((20)*1.))
call LZo((eAe),QH+(1),((18)*1.))
call LZo((eAe),Lvv+(1),((750)*1.))
set Mnv[(eAe)]=("ReplaceableTextures\\CommandButtons\\BTNEtherealFormOn.blp")
return true
endfunction
function x9r takes nothing returns boolean
call VRx(Ma,(function x7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Boost.page\\Boost.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function x8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Boost.page\\Boost.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function ovr takes nothing returns boolean
set ebe=Vnx(eBe)
return true
endfunction
function oer takes code c,string rqx returns nothing
set hn=hn+1
set Hn[hn]=CreateTrigger()
set jn[hn]=(GetHandleId(Condition((c))))
set Jn[hn]=rqx
call TriggerAddCondition(Hn[hn],Condition(c))
endfunction
function oxr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Mv[(rdx)])
call NIx(((Vv[(rdx)])),(eNe),(rwx),w,((ece)*1.))
return true
endfunction
function oor takes nothing returns boolean
call meo(eAe,XBx("Boost_Init: call Boost.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Boost.Event_SpellEffect))",ah,pI,function oxr))
return true
endfunction
function orr takes nothing returns boolean
call oer(function oor,"Boost_Init")
return true
endfunction
function oir takes nothing returns boolean
set eCe=Vnx(ede)
return true
endfunction
function oar takes integer oqx returns integer
return aBx(FirstOfGroup(Kb[oqx]))
endfunction
function onr takes integer oqx returns integer
local integer Xko=oar((oqx))
local integer olx
local integer oVr
local integer o4x
if(Xko==w)then
return w
endif
set olx=1
set oVr=(GetRandomInt((1),(NXo((oqx)))))
loop
exitwhen(olx==oVr)
set olx=olx+1
set Xko=Nao((oqx))
call GroupAddUnit(Kb[(YQ)],C[(Xko)])
endloop
set o4x=oar((oqx))
call Nno((oqx),YQ)
return o4x
endfunction
function oEr takes integer oqx returns integer
return onr(oqx)
endfunction
function oXr takes real x,real y,real j8x,integer Q4x returns integer
call Nio((bQ),x,y,j8x,Q4x)
return oEr(bQ)
endfunction
function oOr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(LoadInteger(o[((V[(E[((X))])]))],(((OK+(((av[(rdx)])))))),(((IK)))))
local integer Ixx
if I6x(CMx,sc)then
return true
endif
set Hf=(ze[(CMx)])
set Ixx=oXr((GetUnitX(C[((CMx))])),(GetUnitY(C[((CMx))])),500.,eDe)
if(Ixx==w)then
return true
endif
call Lvx((CMx),(Ih[((glv))]),(Ixx))
return true
endfunction
function oRr takes nothing returns boolean
local integer Ixx=jFx()
if(oPx((((Ixx))),(yb+(efe)))>0)then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if not(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function oIr takes integer oqx returns integer
set eHe[oqx]=true
set eje[oqx]=false
set v3e[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
call rax(vFv)
return oqx
endfunction
function oAr takes nothing returns integer
local integer oqx
if(eFe==8190)then
call oYx("TriggerTimer_Allocation_allocCustom","call DebugEx(TriggerTimer.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",vgv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(ege[(w)]==w)then
set eGe=eGe+1
set oqx=eGe
else
set oqx=ege[(w)]
set ege[(w)]=ege[ege[(w)]]
endif
set ege[oqx]=Z
set ehe[oqx]=1
call oIr(oqx)
return oqx
endfunction
function oNr takes integer oqx returns nothing
set v4e[(oqx)]=(ele+oqx)
endfunction
function obr takes nothing returns integer
local integer oqx=oAr()
local timer oMx=CreateTimer()
set v6e[oqx]=oMx
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oMx))))),((((eke)))),((((oqx)))))
set oMx=null
call oNr(oqx)
return oqx
endfunction
function oBr takes integer oqx,integer rNx returns nothing
call TriggerRegisterTimerExpireEvent(fA[rNx],v6e[oqx])
endfunction
function ocr takes nothing returns integer
return(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((GetExpiredTimer()))))),((((eke))))))
endfunction
function oCr takes nothing returns boolean
local integer p0x=ocr()
local integer olx=(xgr((p0x),v5e))
local integer oqx=(eLe[(p0x)])
loop
set av[((bv))]=((xGr((p0x),v5e,(olx))))
call xAr((oqx),w)
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function odr takes integer oqx,real pZx returns nothing
local integer p0x=obr()
local integer olx=(xgr((p0x),v5e))
local integer rXx
call oBr(p0x,Xhx(function oCr))
set eLe[(p0x)]=(oqx)
set v8e[(p0x)]=(true)
set v7e[(p0x)]=((pZx)*1.)
loop
exitwhen(olx<q)
set rXx=(xGr((p0x),v5e,(olx)))
if(e9r((oqx),rXx)>0)then
if xXr((w),p0x,rXx)then
call xOr(p0x)
endif
endif
set olx=olx-1
endloop
call xhr((oqx),v2e,p0x)
endfunction
function oDr takes nothing returns boolean
local integer Fmx=x0r(glv,function oOr)
set eDe=XLx(function oRr)
call odr(Fmx,1.)
return true
endfunction
function ofr takes nothing returns boolean
call e1r(function oDr,"AIBurningSpirit_Init")
return true
endfunction
function oFr takes nothing returns boolean
set efe=WTx('BBuS',"Burning Spirit",'bBuS')
set avv[(efe)]=(true)
set qU[(efe)]=(true)
set aev[(efe)]=("ReplaceableTextures\\CommandButtons\\BTNIncinerate.blp")
call lux(efe,"Abilities\\Spells\\Orc\\Bloodlust\\BloodlustSpecial.mdl","hand left",ri)
call lux(efe,"Abilities\\Spells\\Orc\\Bloodlust\\BloodlustSpecial.mdl","hand right",Bi)
set SU=lYx()
call l_x(SU,nev,.6)
call l_x(SU,Bcv,25)
call l_x(SU,ZU,.6)
call l0x(((efe)),vc+(1),(SU))
return true
endfunction
function ogr takes nothing returns boolean
call LZx('ABuT',false)
set glv=Lzo('ABuT')
set G6[(glv)]=(D6)
set j6[(glv)]=(1)
set sH[(glv)]=("Burning Spirit")
set Ih[(glv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0085)))),(((Oj))))))
set x6v[(glv)]=(4)
set xzv[(glv)]=("spell")
call LZo((glv),fH+(1),(($A)*1.))
call LZo((glv),QH+(1),((50)*1.))
call LZo((glv),Lvv+(1),((750)*1.))
set Mnv[(glv)]=("ReplaceableTextures\\CommandButtons\\BTNIncinerate.blp")
return true
endfunction
function oGr takes nothing returns boolean
call VRx(Ma,(function oFr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\BurningSpirit.page\\BurningSpirit.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function ogr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\BurningSpirit.page\\BurningSpirit.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function ohr takes nothing returns boolean
set eme=Vnx(eMe)
return true
endfunction
function oHr takes nothing returns boolean
set epe=Vnx(ePe)
return true
endfunction
function ojr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(LoadInteger(o[((V[(E[((X))])]))],(((OK+(((av[(rdx)])))))),(((IK)))))
local integer Ixx
if I6x(CMx,sc)then
return true
endif
set Hf=(ze[(CMx)])
set Ixx=oXr((GetUnitX(C[((CMx))])),(GetUnitY(C[((CMx))])),500.,eqe)
if(Ixx==w)then
return true
endif
call Lvx((CMx),(Ih[((Sgv))]),(Ixx))
return true
endfunction
function oJr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function okr takes nothing returns boolean
local integer Fmx=x0r(Sgv,function ojr)
set eqe=XLx(function oJr)
call x3r(Fmx,dsv,jI,w)
return true
endfunction
function oKr takes nothing returns boolean
call e1r(function okr,"AIChaosBall_Init")
return true
endfunction
function olr takes nothing returns boolean
call LZx('AKao',false)
set Sgv=Lzo('AKao')
set G6[(Sgv)]=(D6)
set j6[(Sgv)]=(1)
set sH[(Sgv)]=("Chaos Ball")
set Ih[(Sgv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00FE)))),(((Oj))))))
set x6v[(Sgv)]=(4)
set xzv[(Sgv)]=("spell")
call LZo((Sgv),u6v+(1),(('d')*1.))
call LZo((Sgv),BH+(1),((.75)*1.))
call LZo((Sgv),fH+(1),((20)*1.))
call LZo((Sgv),QH+(1),(('d')*1.))
call LZo((Sgv),Lvv+(1),((700)*1.))
set Mnv[(Sgv)]=("ReplaceableTextures\\CommandButtons\\BTNOrbOfDeath.blp")
return true
endfunction
function oLr takes nothing returns boolean
set eQe=lQx(ese+" (poisonBuff)")
set qc[(eQe)]=(true)
set qU[(eQe)]=(true)
return true
endfunction
function omr takes nothing returns boolean
call VRx(qa,(function olr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\ChaosBall.page\\ChaosBall.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function oLr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\ChaosBall.page\\ChaosBall.struct\\obj_poisonBuff_wc3buff.j"))
return true
endfunction
function oMr takes nothing returns boolean
set eSe=Vnx(ese)
return true
endfunction
function opr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function oPr takes integer oqx returns integer
set eue[oqx]=true
set eUe[oqx]=false
call rax(eSe)
return oqx
endfunction
function oqr takes integer oqx,real oSx returns nothing
call mbx(oqx,(ly[(oqx)])+oSx)
endfunction
function oQr takes integer oqx returns integer
set e3e[oqx]=true
set e4e[oqx]=false
call rax(cW)
return oqx
endfunction
function osr takes nothing returns integer
local integer oqx
if(e_e==8190)then
call oYx("FolderDummyUnit_FolderScale_StructTimed_Allocation_allocCustom","call DebugEx(FolderDummyUnit_FolderScale_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",CW+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(e0e[(w)]==w)then
set e1e=e1e+1
set oqx=e1e
else
set oqx=e0e[(w)]
set e0e[(w)]=e0e[e0e[(w)]]
endif
set e0e[oqx]=Z
set e2e[oqx]=1
call oQr(oqx)
return oqx
endfunction
function oSr takes integer oqx returns boolean
set xve=xve+1
set xee[xve]=oqx
set xxe[oqx]=xve+1
return(xve==0)
endfunction
function otr takes nothing returns nothing
local integer olx=xve
local integer oqx
loop
set oqx=xee[olx]
call oqr(e7e[oqx],e5e[oqx])
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function oTr takes integer oqx returns nothing
set e3e[oqx]=false
call rgx(cW)
endfunction
function our takes integer oqx returns nothing
if(e2e[oqx]>0)then
return
endif
if(e0e[oqx]!=Z)then
call oYx("FolderDummyUnit_FolderScale_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderDummyUnit_FolderScale_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",CW+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set e0e[oqx]=e0e[(w)]
set e0e[(w)]=oqx
call oTr(oqx)
endfunction
function oUr takes integer oqx returns nothing
set e2e[oqx]=e2e[oqx]-1
call our(oqx)
endfunction
function owr takes integer oqx returns boolean
local integer okx=(xxe[(oqx)])
set xxe[xee[xve]]=okx
set xee[okx-1]=xee[xve]
set xxe[oqx]=0
set xve=xve-1
return(xve==F)
endfunction
function oWr takes integer oqx,integer ibx,integer rkx returns nothing
call oUr((oqx))
call ijx(ibx)
call HVx(rkx,e9e,oqx)
if owr(oqx)then
call iHx(Ey)
endif
endfunction
function oyr takes nothing returns nothing
local integer ibx=ifx()
local integer oqx=(ge[(ibx)])
call oWr(oqx,ibx,e7e[oqx])
endfunction
function oYr takes integer oqx,real D7x,real ilx returns nothing
local integer rkx=oqx
local integer D8x
local integer ibx
if(ilx==.0)then
call oqr((oqx),D7x)
return
endif
set D8x=(R2I(((ilx*1./ eZe)*1.)))
set oqx=osr()
set ibx=inx()
set e5e[oqx]=D7x*1./ D8x
set e6e[oqx]=ibx
set e7e[oqx]=rkx
set ge[(ibx)]=(oqx)
call QPo(rkx,e9e,oqx)
if oSr(oqx)then
call icx(Ey,eZe,true,function otr)
endif
call icx(ibx,ilx,false,function oyr)
endfunction
function ozr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real ilx=(Cpx((Sgv),BH+(rwx)))
local integer MFo=Mvo()
local integer oqx=oPr(MFo)
local integer HOx
set ewe[oqx]=MFo
set eWe[oqx]=rwx
set eye[oqx]=(WH[(rdx)])
call rTx(CMx,eYe,oqx)
set HOx=Mro(MFo,'qCha',1.)
call m8o(MFo,eze*1./ ilx)
call M9o(MFo,CMx)
call M3o(MFo,CMx,.0,.0,eze,null)
call oYr(HOx,1.,ilx)
return true
endfunction
function oZr takes integer oqx returns nothing
set eue[oqx]=false
call rgx(eSe)
endfunction
function o_r takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local real x=(mFv[(MFo)])
local real y=(mgv[(MFo)])
local integer CMx=xre[oqx]
local integer rwx=eWe[oqx]
local integer Ixx
local real NIo
local real o0r
local real o1r
local real ilx
call oZr(oqx)
call Mdo(MFo)
call mFo((mHo(((x)*1.),((y)*1.),(xie),(Bi))))
set Hf=(ze[(CMx)])
call Nio(ete,x,y,(Cpx((Sgv),u6v+(rwx))),eTe)
set Ixx=Nao(ete)
if(Ixx!=w)then
set NIo=xae
set o0r=xne
set o1r=xVe
loop
if I6x(Ixx,yd)then
set ilx=o0r
else
set ilx=o1r
endif
call NIx((Ixx),(eQe),(rwx),w,((ilx)*1.))
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
set Ixx=Nao(ete)
exitwhen(Ixx==w)
endloop
endif
return true
endfunction
function o2r takes integer oqx returns boolean
if((dz[((oqx))])>0)then
return false
endif
set fz=fz+1
set Dz[fz]=oqx
set dz[oqx]=fz+1
return(fz==0)
endfunction
function o3r takes nothing returns nothing
local integer olx=fz
loop
exitwhen(olx<0)
set xRe[olx]=Dz[olx]
set olx=olx-1
endloop
set xIe=fz
endfunction
function o4r takes nothing returns integer
local integer o4x
if(xIe<0)then
return w
endif
set o4x=xRe[0]
set xRe[0]=xRe[xIe]
set xIe=xIe-1
return o4x
endfunction
function o5r takes nothing returns nothing
local integer oqx
local real M1o
local real M2o
local real Okx
local real dix
local real dax
local real Mpx
local real dX
local real dY
local real dZ
local real d
call o3r()
loop
set oqx=o4r()
exitwhen(oqx==w)
set M1o=(mKv[((oqx))])
set M2o=(mLv[((oqx))])
set Okx=(mMv[((oqx))])
set dix=xEe[oqx]
set dax=xXe[oqx]
set Mpx=xOe[oqx]
set dX=dix-(mFv[((oqx))])
set dY=dax-(mgv[((oqx))])
set dZ=Mpx-(mGv[((oqx))])
set d=ggx(dX,dY,dZ)
if(d<M1o+(mNv[((oqx))]))then
call Mhx(oqx)
call MUo((oqx),dix,dax,Mpx)
else
set dX=dX*1./ d
set dY=dY*1./ d
set dZ=dZ*1./ d
call Mzo((oqx),(mrv[((oqx))]),(mnv[((oqx))]),(mEv[((oqx))]))
call MZo((oqx),M1o*dX,M1o*dY,M1o*dZ)
endif
endloop
endfunction
function o6r takes integer oqx,real dix,real dax,real Mpx returns nothing
call Mgo((oqx),dix,dax,Mpx)
set xEe[oqx]=dix
set xXe[oqx]=dax
set xOe[oqx]=Mpx
call Mvx((oqx),Cz)
call MYo((oqx),dix-(mFv[((oqx))]),dax-(mgv[((oqx))]),Mpx-(mGv[((oqx))]))
call Mho((oqx))
if o2r(oqx)then
call icx(Fz,miv,true,function o5r)
endif
endfunction
function o7r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local boolean Eko=(ovv[(rdx)])
local integer oqx=oPx(CMx,eYe)
local integer MFo=ewe[oqx]
local integer rwx=eWe[oqx]
local real dix
local real dax
call rix(CMx,eYe)
if Eko then
set eye[oqx]=eye[oqx]
set dix=(GetUnitX(C[((eye[oqx]))]))
set dax=(GetUnitY(C[((eye[oqx]))]))
if(Gyx(dix-(GetUnitX(C[((CMx))])),dax-(GetUnitY(C[((CMx))])))<xoe[rwx])then
set xre[oqx]=CMx
call m1o(MFo,600.)
set mAv[((MFo))]=((b6v*((.1)*1.))*1.)
set mCv[(MFo)]=XHx((function o_r))
set mWv[(MFo)]=(oqx)
call m8o(MFo,700.)
call MPo((MFo),(CMx),.0,.0,.0)
call o6r(MFo,dix,dax,XYx(dix,dax))
return true
endif
endif
call oZr(oqx)
call Mdo(MFo)
call BRx(CMx,(Cpx((Sgv),QH+(rwx))))
return true
endfunction
function o8r takes real a returns real
return(a*a)
endfunction
function o9r takes nothing returns boolean
local integer olx
set ete=O2x()
set eTe=XLx(function opr)
call meo(Sgv,XBx("ChaosBall_Init: call ChaosBall.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ChaosBall.Event_SpellEffect))",ah,pI,function ozr))
call meo(Sgv,XBx("ChaosBall_Init: call ChaosBall.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ChaosBall.Event_EndCast))",oev,pI,function o7r))
call W_x(XNv,eQe)
set olx=(j6[(Sgv)])
loop
set xoe[olx]=o8r((Cpx((Sgv),Lvv+(olx)))+xAe)
set olx=olx-1
exitwhen(olx<1)
endloop
return true
endfunction
function rvr takes nothing returns boolean
call oer(function o9r,"ChaosBall_Init")
return true
endfunction
function rer takes nothing returns boolean
set xNe=WTx('BEnC',"Energy Charge",'bEnC')
set avv[(xNe)]=(true)
set qc[(xNe)]=(true)
set aev[(xNe)]=("ReplaceableTextures\\CommandButtons\\BTNSeaGiantPulverize.blp")
call lux(xNe,"Abilities\\Weapons\\GreenDragonMissile\\GreenDragonMissile.mdl","hand right",ri)
set SU=lYx()
call l_x(SU,dXv,25)
call l0x(((xNe)),vc+(1),(SU))
return true
endfunction
function rxr takes nothing returns boolean
call VRx(Ma,(function rer),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\EnergyCharge.page\\EnergyCharge.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function ror takes nothing returns boolean
set xbe=Vnx(xBe)
return true
endfunction
function rrr takes nothing returns boolean
call LZx('AEnC',false)
set SBv=Lzo('AEnC')
set G6[(SBv)]=(D6)
set j6[(SBv)]=(1)
set sH[(SBv)]=("Energy Charge")
set xzv[(SBv)]=("spell")
call LZo((SBv),Lvv+(1),((750)*1.))
set Mnv[(SBv)]=("ReplaceableTextures\\PassiveButtons\\PASBTNSeaGiantPulverize.blp")
return true
endfunction
function rir takes nothing returns boolean
set xce=lQx(xCe+" (dummyBuff)")
return true
endfunction
function rar takes nothing returns boolean
call VRx(qa,(function rrr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\EnergyCharge.page\\EnergyCharge.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function rir),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\EnergyCharge.page\\EnergyCharge.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function rnr takes nothing returns boolean
set xde=Vnx(xCe)
return true
endfunction
function rVr takes integer Ixx returns boolean
return( not(I6x(Ixx,IBv)))and( not(I6x(Ixx,ICv)))
endfunction
function rEr takes integer rwx,integer Ixx returns nothing
call DSx((Ixx),(xNe),(rwx),w)
endfunction
function rXr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(EYv[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx
local integer rOr
if not rVr(Ixx)then
return true
endif
set oqx=CMx
set rOr=xfe[oqx]+1
if(rOr==xFe)then
set xfe[oqx]=0
call RUx(xge[oqx])
call RUx(xGe[oqx])
call rEr((Mv[(rdx)]),CMx)
else
set xfe[oqx]=rOr
if(rOr==1)then
set xge[oqx]=(Abx((CMx),(xhe),(xHe),(ri)))
elseif(rOr==2)then
set xGe[oqx]=(Abx((CMx),(xje),(xJe),(ri)))
endif
endif
return true
endfunction
function rRr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
set xfe[oqx]=0
call I7x(Ixx,xDe)
return true
endfunction
function rIr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call Rmx(Ixx,xDe)
if(xfe[oqx]==2)then
call RUx(xge[oqx])
call RUx(xGe[oqx])
elseif(xfe[oqx]==1)then
call RUx(xge[oqx])
endif
return true
endfunction
function rAr takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(xce),((Mv[(rdx)])),w)
return true
endfunction
function rNr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),xce)
return true
endfunction
function rbr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(EYv[(rdx)])
call moo(Ixx,Ixx,xKe)
call Ayx(Ixx,xNe)
return true
endfunction
function rBr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
call Ayx(Ixx,xce)
call I7x(Ixx,xke)
return true
endfunction
function rcr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer rwx=(Hc[(rdx)])
call Rmx(Ixx,xke)
set rwx=(oPx(((Ixx)),N+(SBv)))
if(rwx>0)then
call DSx((Ixx),(xce),(rwx),w)
endif
return true
endfunction
function rCr takes nothing returns nothing
set xke=XBx("FolderEnergyCharge_StructTarget_Init: set FolderEnergyCharge_StructTarget.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function FolderEnergyCharge_StructTarget.Event_Damage)",EZv,pI,function rbr)
call l9x(xNe,XBx("FolderEnergyCharge_StructTarget_Init: call FolderEnergyCharge_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderEnergyCharge_StructTarget.Event_BuffGain))",Bd,pI,function rBr))
call l9x(xNe,XBx("FolderEnergyCharge_StructTarget_Init: call FolderEnergyCharge_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderEnergyCharge_StructTarget.Event_BuffLose))",Jc,pI,function rcr))
endfunction
function rdr takes nothing returns boolean
set xDe=XBx("EnergyCharge_Init: set EnergyCharge.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function EnergyCharge.Event_Damage)",EZv,pI,function rXr)
call l9x(xce,XBx("EnergyCharge_Init: call EnergyCharge.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnergyCharge.Event_BuffGain))",Bd,pI,function rRr))
call l9x(xce,XBx("EnergyCharge_Init: call EnergyCharge.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnergyCharge.Event_BuffLose))",Jc,pI,function rIr))
call meo(SBv,XBx("EnergyCharge_Init: call EnergyCharge.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnergyCharge.Event_Learn))",pv,pI,function rAr))
call meo(SBv,XBx("EnergyCharge_Init: call EnergyCharge.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnergyCharge.Event_Unlearn))",Av,pI,function rNr))
call rCr()
return true
endfunction
function rDr takes nothing returns boolean
call oer(function rdr,"EnergyCharge_Init")
return true
endfunction
function rfr takes nothing returns boolean
set xle=Vnx(xLe)
return true
endfunction
function rFr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(LoadInteger(o[((V[(E[((X))])]))],(((OK+(((av[(rdx)])))))),(((IK)))))
local integer Ixx
if I6x(CMx,sc)then
return true
endif
set Hf=(ze[(CMx)])
set Ixx=oXr((GetUnitX(C[((CMx))])),(GetUnitY(C[((CMx))])),500.,xMe)
if(Ixx==w)then
return true
endif
call CAx((CMx),(Ih[((xme))]),(((GetUnitX(C[((Ixx))])))*1.),(((GetUnitY(C[((Ixx))])))*1.))
return true
endfunction
function rgr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function rGr takes nothing returns boolean
local integer Fmx=x0r(xme,function rFr)
set xMe=XLx(function rgr)
call x3r(Fmx,dsv,jI,w)
return true
endfunction
function rhr takes nothing returns boolean
call e1r(function rGr,"AIFlamelet_Init")
return true
endfunction
function rHr takes nothing returns boolean
set xpe=lQx(xPe+" (ignitionBuff)")
set qc[(xpe)]=(true)
set qU[(xpe)]=(true)
return true
endfunction
function rjr takes nothing returns boolean
call LZx('AFba',false)
set xme=Lzo('AFba')
set G6[(xme)]=(D6)
set j6[(xme)]=(1)
set sH[(xme)]=("Flamelet")
set Ih[(xme)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Oj))))))
set x6v[(xme)]=(2)
set xzv[(xme)]=("spell")
call LZo((xme),u6v+(1),((80)*1.))
call LZo((xme),BH+(1),((2)*1.))
call LZo((xme),fH+(1),(($C)*1.))
call LZo((xme),QH+(1),((50)*1.))
call LZo((xme),Lvv+(1),((900)*1.))
set Mnv[(xme)]=("ReplaceableTextures\\CommandButtons\\BTNFireBolt.blp")
return true
endfunction
function rJr takes nothing returns boolean
call VRx(Ma,(function rHr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Flamelet.page\\Flamelet.struct\\obj_ignitionBuff_wc3buff.j"))
call VRx(qa,(function rjr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Flamelet.page\\Flamelet.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function rkr takes nothing returns boolean
set xqe=Vnx(xPe)
return true
endfunction
function rKr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=jFx()
local integer MFo
local integer oqx
local integer CQx
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
set MFo=(WY[(rdx)])
set oqx=(mWv[(MFo)])
set CQx=xse[oqx]
if(IsUnitAlly(C[(Ixx)],vx[((ze[((aH[(CQx)]))]))]))then
return false
endif
return true
return true
endfunction
function rlr takes integer oqx,real x,real y,real z returns nothing
call MYo(oqx,x-(mFv[((oqx))]),y-(mgv[((oqx))]),z-(mGv[((oqx))]))
endfunction
function rLr takes integer CQx returns nothing
local integer oqx=CQx
local integer CMx=(aH[(CQx)])
local integer rwx=(XH[(CQx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real rmr=(Cpx((xme),Lvv+(rwx)))
local real dix=(wh[(CQx)])
local real dax=(Wh[(CQx)])
local real N8x=(Atan2(((dax-wPo)*1.),((dix-wpo)*1.)))
local integer MFo=Mvo()
local integer HOx
set xTe[oqx]=MFo
set xse[oqx]=CQx
call M9o(MFo,CMx)
call rlr(MFo,wpo+rmr*(Cos(((((N8x)*1.))*1.))),wPo+rmr*(Sin(((((N8x)*1.))*1.))),XYx(dix,dax)+60.)
set HOx=Mro(MFo,'qFba',1.5)
call oYr(HOx,1,(Cpx(((OH[(CQx)])),BH+(rwx))))
call sao((HOx),(xue),(xUe),(Bi))
endfunction
function rMr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer CQx=(uH[(rdx)])
call RUx((Abx((CMx),(xSe),(xte),(Bi))))
call rLr(CQx)
return true
endfunction
function rpr takes integer oqx returns integer
set xze[oqx]=true
set xZe[oqx]=false
call rax(xqe)
return oqx
endfunction
function rPr takes nothing returns integer
local integer oqx
if(xwe==8190)then
call oYx("Flamelet_Allocation_allocCustom","call DebugEx(Flamelet.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",xPe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(xWe[(w)]==w)then
set xye=xye+1
set oqx=xye
else
set oqx=xWe[(w)]
set xWe[(w)]=xWe[xWe[(w)]]
endif
set xWe[oqx]=Z
set xYe[oqx]=1
call rpr(oqx)
return oqx
endfunction
function rqr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
call Mdo(MFo)
return true
endfunction
function rQr takes integer oqx,code iDx,integer MSo returns nothing
set mDv[oqx]=XHx(iDx)
set mfv[oqx]=MSo
endfunction
function rsr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=(mWv[(MFo)])
local real NIo=x_e[oqx]
local integer rwx=x1e[oqx]
local integer CQx=xse[oqx]
local integer CMx=(aH[(CQx)])
local real ilx
call Mdo(MFo)
call UPx(CQx)
if I6x(Ixx,yd)then
set ilx=x6e
else
set ilx=x7e
endif
call NIx(Ixx,xpe,rwx,CMx,ilx)
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
return true
endfunction
function rSr takes integer CQx returns nothing
local integer CMx=(aH[(CQx)])
local integer rwx=(XH[(CQx)])
local real dix=(wh[(CQx)])
local real dax=(Wh[(CQx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real rmr=(Cpx((xme),Lvv+(rwx)))
local real N8x=(Atan2(((dax-wPo)*1.),((dix-wpo)*1.)))
local integer oqx=rPr()
local integer MFo=xTe[oqx]
set x_e[oqx]=x0e
set x1e[oqx]=rwx
set x2e[oqx]=rmr
set x3e[oqx]=wpo
set x4e[oqx]=wPo
set xse[oqx]=CQx
call UNx(CQx)
set mNv[(MFo)]=(((Cpx((xme),u6v+(rwx))))*1.)
set mWv[(MFo)]=(oqx)
set mCv[(MFo)]=XHx((function rqr))
call m8o(MFo,x5e)
call o6r(MFo,wpo+rmr*(Cos(((((N8x)*1.))*1.))),wPo+rmr*(Sin(((((N8x)*1.))*1.))),XYx(dix,dax)+60.)
call rQr(MFo,function rsr,xQe)
endfunction
function rtr takes nothing returns boolean
local integer rdx=(bv)
local boolean Eko=(ovv[(rdx)])
local integer CQx=(uH[(rdx)])
local integer oqx=CQx
if not Eko then
call Mdo(xTe[oqx])
return true
endif
call rSr(CQx)
return true
endfunction
function rTr takes nothing returns boolean
set xQe=XLx(function rKr)
call meo(xme,XBx("Flamelet_Init: call Flamelet.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Flamelet.Event_SpellEffect))",ah,pI,function rMr))
call meo(xme,XBx("Flamelet_Init: call Flamelet.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Flamelet.Event_EndCast))",oev,pI,function rtr))
call W_x(E5v,xpe)
return true
endfunction
function rur takes nothing returns boolean
call oer(function rTr,"Flamelet_Init")
return true
endfunction
function rUr takes nothing returns boolean
call LZx('AFuA',false)
set GYv=Lzo('AFuA')
set G6[(GYv)]=(D6)
set j6[(GYv)]=(1)
set sH[(GYv)]=("Fuzzy Attack")
set Ih[(GYv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D007F)))),(((Oj))))))
set x6v[(GYv)]=(4)
set xzv[(GYv)]=("spell")
call LZo((GYv),BH+(1),((4.25)*1.))
call LZo((GYv),fH+(1),(($F)*1.))
call LZo((GYv),QH+(1),(($96)*1.))
call LZo((GYv),Lvv+(1),((700)*1.))
set Mnv[(GYv)]=("ReplaceableTextures\\CommandButtons\\BTNFurbolg.blp")
return true
endfunction
function rwr takes nothing returns boolean
call VRx(qa,(function rUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\FuzzyAttack.page\\FuzzyAttack.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function rWr takes nothing returns boolean
set x8e=Vnx(x9e)
return true
endfunction
function ryr takes integer oqx returns nothing
set oEe[oqx]=false
call rgx(x8e)
endfunction
function rYr takes integer oqx returns nothing
if(one[oqx]>0)then
return
endif
if(oVe[oqx]!=Z)then
call oYx("FuzzyAttack_Allocation_deallocCustom_confirm","call DebugEx(FuzzyAttack.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",x9e+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set oVe[oqx]=oVe[(w)]
set oVe[(w)]=oqx
call ryr(oqx)
endfunction
function rzr takes integer oqx returns nothing
set one[oqx]=one[oqx]-1
call rYr(oqx)
endfunction
function rZr takes integer oqx,integer CMx returns nothing
local integer OHx=oie[oqx]
local integer CQx=oae[oqx]
call rzr((oqx))
call rrx(CMx,ooe,oqx)
call ijx(OHx)
call dRx(CQx)
endfunction
function r_r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer olx=CXx(CMx,ooe)
local integer oqx
loop
set oqx=COx(CMx,ooe,olx)
if(ore[oqx]==0)then
call rZr(oqx,CMx)
else
call iHx(oie[oqx])
endif
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function r0r takes integer oqx returns integer
set oEe[oqx]=true
set oRe[oqx]=false
call rax(x8e)
return oqx
endfunction
function r1r takes nothing returns integer
local integer oqx
if(oXe==8190)then
call oYx("FuzzyAttack_Allocation_allocCustom","call DebugEx(FuzzyAttack.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",x9e+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(oVe[(w)]==w)then
set oOe=oOe+1
set oqx=oOe
else
set oqx=oVe[(w)]
set oVe[(w)]=oVe[oVe[(w)]]
endif
set oVe[oqx]=Z
set one[oqx]=1
call r0r(oqx)
return oqx
endfunction
function r2r takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=oIe[oqx]
local integer r3r=ore[oqx]-1
local integer Ixx=oAe[oqx]
call Mdo(MFo)
call nJo((CMx),(oAe[oqx]),((oNe)*1.),(true),(false))
if(r3r==0)then
call rZr(oqx,CMx)
else
set ore[oqx]=r3r
endif
return true
endfunction
function r4r takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer MFo=Mvo()
set ore[oqx]=ore[oqx]+1
set mAv[((MFo))]=((b6v*((.06)*1.))*1.)
set mNv[(MFo)]=((32.)*1.)
call Mro(MFo,'qFuA',1.)
set mCv[(MFo)]=XHx((function r2r))
set mWv[(MFo)]=(oqx)
call m8o(MFo,700.)
call M9o(MFo,oIe[oqx])
call M3o((MFo),(oAe[oqx]),.0,.0,.0,(null))
endfunction
function r5r takes nothing returns nothing
call icx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))),ove,true,function r4r)
endfunction
function r6r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer oqx=r1r()
local integer OHx=inx()
set oIe[oqx]=CMx
set oie[oqx]=OHx
set ore[oqx]=0
set oAe[oqx]=Ixx
set oae[oqx]=Cmx(CMx,GYv)
call rtx(CMx,ooe,oqx)
set ge[(OHx)]=(oqx)
call icx(OHx,oee,false,function r5r)
return true
endfunction
function r7r takes nothing returns boolean
set ove=((Cpx((GYv),BH+(1)))-oee)*1./ oxe-.01
call meo(GYv,XBx("FuzzyAttack_Init: call FuzzyAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FuzzyAttack.Event_EndCast))",oev,pI,function r_r))
call meo(GYv,XBx("FuzzyAttack_Init: call FuzzyAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FuzzyAttack.Event_SpellEffect))",ah,pI,function r6r))
return true
endfunction
function r8r takes nothing returns boolean
call oer(function r7r,"FuzzyAttack_Init")
return true
endfunction
function r9r takes nothing returns boolean
set obe=WTx('BGrN',"Entangled",'bGrN')
set qU[(obe)]=(true)
set aev[(obe)]=("ReplaceableTextures\\CommandButtons\\BTNEntanglingRoots.blp")
call lux(obe,"Abilities\\Spells\\NightElf\\EntanglingRoots\\EntanglingRootsTarget.mdl","origin",ri)
set SU=lYx()
call vOr(SU,dPv,true)
call vOr(SU,dGv,true)
call l0x(((obe)),vc+(1),(SU))
return true
endfunction
function ivr takes nothing returns boolean
call VRx(Ma,(function r9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\GreenNova.page\\GreenNova.struct\\Buff\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function ier takes nothing returns boolean
set oBe=Vnx(oce)
return true
endfunction
function ixr takes nothing returns boolean
call LZx('AGrN',false)
set Gzv=Lzo('AGrN')
set G6[(Gzv)]=(D6)
set j6[(Gzv)]=(1)
set sH[(Gzv)]=("Green Nova")
set Ih[(Gzv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00CB)))),(((Oj))))))
set x6v[(Gzv)]=(0)
set xzv[(Gzv)]=("spell")
call LZo((Gzv),fH+(1),((20)*1.))
call LZo((Gzv),QH+(1),((400)*1.))
call LZo((Gzv),Lvv+(1),((750)*1.))
set Mnv[(Gzv)]=("ReplaceableTextures\\CommandButtons\\BTNEntanglingRoots.blp")
return true
endfunction
function ior takes nothing returns boolean
call VRx(qa,(function ixr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\GreenNova.page\\GreenNova.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function irr takes nothing returns boolean
set oCe=Vnx(ode)
return true
endfunction
function iir takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
if j7x(Ixx,Gf,hf,gf)then
return false
endif
return true
return true
endfunction
function iar takes integer oqx returns integer
set ole[oqx]=true
set oLe[oqx]=false
call rax(oCe)
return oqx
endfunction
function inr takes nothing returns integer
local integer oqx
if(oje==8190)then
call oYx("GreenNova_Allocation_allocCustom","call DebugEx(GreenNova.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",ode+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(oJe[(w)]==w)then
set oke=oke+1
set oqx=oke
else
set oqx=oJe[(w)]
set oJe[(w)]=oJe[oJe[(w)]]
endif
set oJe[oqx]=Z
set oKe[oqx]=1
call iar(oqx)
return oqx
endfunction
function iVr takes integer rwx,integer Ixx returns nothing
local real ilx
if I6x(Ixx,yd)then
set ilx=oue
else
set ilx=oUe
endif
call NIx((Ixx),(obe),(rwx),w,((ilx)*1.))
endfunction
function iEr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local real N8x=ome[oqx]
local integer rwx=oPe[oqx]
local real j8x=oqe[oqx]+oQe[oqx]
local real x=ose[oqx]
local real y=oSe[oqx]
local real iXr=ote*1./ j8x
local integer olx=(R2I(((2*3.141592654*j8x*1./ ote)*1.)))
local integer Ixx
set oqe[oqx]=j8x
loop
call mFo((mHo(((x+j8x*(Cos(((((N8x)*1.))*1.))))*1.),((y+j8x*(Sin(((((N8x)*1.))*1.))))*1.),(oTe),((Ni[(GetRandomInt((bi[(ri)]),(bi[(Bi)])))])))))
set olx=olx-1
exitwhen(olx<1)
set N8x=N8x+iXr
endloop
set gf=j8x-oQe[oqx]
set Gf=x
set hf=y
set Hf=(ze[(oMe[oqx])])
call Nio(oge,x,y,j8x,oHe)
loop
set Ixx=Nao(oge)
exitwhen(Ixx==w)
call iVr(rwx,Ixx)
endloop
endfunction
function iOr takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local integer p0x=ope[oqx]
call ijx(ibx)
call ijx(p0x)
endfunction
function iRr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer oqx=inr()
local integer ibx=inx()
local integer p0x=inx()
set ome[oqx]=(GetUnitFacing(C[((CMx))])*bh)
set oMe[oqx]=CMx
set ope[oqx]=p0x
set oPe[oqx]=(Mv[(rdx)])
set oqe[oqx]=.0
set oQe[oqx]=oGe
set ose[oqx]=(GetUnitX(C[((CMx))]))
set oSe[oqx]=(GetUnitY(C[((CMx))]))
set ge[(ibx)]=(oqx)
set ge[(p0x)]=(oqx)
call icx(p0x,ofe,true,function iEr)
call icx(ibx,oDe,false,function iOr)
return true
endfunction
function iIr takes nothing returns nothing
endfunction
function iAr takes nothing returns boolean
set oDe=ofe*oFe
set oge=O2x()
set oGe=ohe*1./ oFe
set oHe=XLx(function iir)
call meo(Gzv,XBx("GreenNova_Init: call GreenNova.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function GreenNova.Event_SpellEffect))",ah,pI,function iRr))
call iIr()
return true
endfunction
function iNr takes nothing returns boolean
call oer(function iAr,"GreenNova_Init")
return true
endfunction
function ibr takes nothing returns boolean
set owe=Vnx(oWe)
return true
endfunction
function iBr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(LoadInteger(o[((V[(E[((X))])]))],(((OK+(((av[(rdx)])))))),(((IK)))))
local integer Ixx
if I6x(CMx,sc)then
return true
endif
set Hf=(ze[(CMx)])
set Ixx=oXr((GetUnitX(C[((CMx))])),(GetUnitY(C[((CMx))])),500.,oye)
if(Ixx!=w)then
call Lvx((CMx),(Ih[((gtv))]),(Ixx))
endif
return true
endfunction
function icr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if not(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if((rG[(Ixx)])>=(R2I((((iG[(Ixx)]))*1.)))-oYe)then
return false
endif
return true
endfunction
function iCr takes nothing returns boolean
local integer Fmx=x0r(gtv,function iBr)
set oye=XLx(function icr)
call odr(Fmx,1.)
return true
endfunction
function idr takes nothing returns boolean
call e1r(function iCr,"AIHeal_Init")
return true
endfunction
function iDr takes nothing returns boolean
call LZx('AHel',false)
set gtv=Lzo('AHel')
set G6[(gtv)]=(D6)
set j6[(gtv)]=(1)
set sH[(gtv)]=("Heal")
set Ih[(gtv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D005F)))),(((Oj))))))
set x6v[(gtv)]=(4)
set xzv[(gtv)]=("spell")
call LZo((gtv),fH+(1),((5)*1.))
call LZo((gtv),QH+(1),((40)*1.))
call LZo((gtv),Lvv+(1),((900)*1.))
set Mnv[(gtv)]=("ReplaceableTextures\\CommandButtons\\BTNHeal.blp")
return true
endfunction
function ifr takes nothing returns boolean
call VRx(qa,(function iDr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Heal.page\\Heal.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function iFr takes nothing returns boolean
set oze=Vnx(oZe)
return true
endfunction
function igr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer Ixx=(WH[(rdx)])
call pKo((Abx((Ixx),(o_e),(o0e),(ri))),2.)
call moo(CMx,Ixx,oYe)
return true
endfunction
function iGr takes nothing returns boolean
call meo(gtv,XBx("Heal_Init: call Heal.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Heal.Event_SpellEffect))",ah,pI,function igr))
return true
endfunction
function ihr takes nothing returns boolean
call oer(function iGr,"Heal_Init")
return true
endfunction
function iHr takes nothing returns boolean
set o1e=Vnx(o2e)
return true
endfunction
function ijr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(LoadInteger(o[((V[(E[((X))])]))],(((OK+(((av[(rdx)])))))),(((IK)))))
if I6x(CMx,sc)then
return true
endif
set Hf=(ze[(CMx)])
call Nio(o3e,(GetUnitX(C[((CMx))])),(GetUnitY(C[((CMx))])),(Cpx((gTv),u6v+((oPx(((CMx)),N+(gTv)))))),o4e)
if((NXo((o3e)))>3)then
call O9x((CMx),(Ih[((gTv))]))
endif
return true
endfunction
function iJr takes nothing returns boolean
local integer Fmx=x0r(gTv,function ijr)
call odr(Fmx,1.)
return true
endfunction
function ikr takes nothing returns boolean
call e1r(function iJr,"AIHealExplosion_Init")
return true
endfunction
function iKr takes nothing returns boolean
call LZx('AHEx',false)
set gTv=Lzo('AHEx')
set G6[(gTv)]=(D6)
set j6[(gTv)]=(1)
set sH[(gTv)]=("Heal Explosion")
set Ih[(gTv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0085)))),(((Oj))))))
set x6v[(gTv)]=(0)
set xzv[(gTv)]=("spell")
call LZo((gTv),u6v+(1),((300)*1.))
call LZo((gTv),BH+(1),((2.5)*1.))
call LZo((gTv),fH+(1),(($F)*1.))
call LZo((gTv),QH+(1),((25)*1.))
call LZo((gTv),Lvv+(1),((750)*1.))
set Mnv[(gTv)]=("ReplaceableTextures\\CommandButtons\\BTNHealExplosion.blp")
return true
endfunction
function ilr takes nothing returns boolean
call VRx(qa,(function iKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\HealExplosion.page\\HealExplosion.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function iLr takes nothing returns boolean
set o5e=Vnx(o6e)
return true
endfunction
function imr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,Icv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function iMr takes nothing returns boolean
local integer Ixx=jFx()
if(Ixx==Ib)then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,Icv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if not(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function ipr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer oqx=CMx
set o8e[oqx]=(Abx((CMx),(o9e),(rve),(ri)))
set ree[oqx]=rwx
return true
endfunction
function iPr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local boolean Eko=(ovv[(rdx)])
local integer oqx=CMx
local integer iqr=o8e[oqx]
local integer rwx=ree[oqx]
local integer Ixx
call RUx(iqr)
if not Eko then
return true
endif
call RUx((Abx((CMx),(rxe),(roe),(ri))))
set Hf=(ze[(CMx)])
call Nio(o3e,(GetUnitX(C[((CMx))])),(GetUnitY(C[((CMx))])),(Cpx((gTv),u6v+(rwx))),o7e)
set Ixx=Nao(o3e)
if(Ixx!=w)then
loop
call RUx((Abx((Ixx),(rre),(rie),(ri))))
call nJo((CMx),(Ixx),((rae)*1.),(false),(false))
set Ixx=Nao(o3e)
exitwhen(Ixx==w)
endloop
endif
call moo(CMx,CMx,rne)
set Hf=(ze[(CMx)])
set Ib=CMx
call Nio(o3e,(GetUnitX(C[((CMx))])),(GetUnitY(C[((CMx))])),(Cpx((gTv),u6v+(rwx))),o4e)
call GroupRemoveUnit(Kb[(o3e)],C[(CMx)])
set Ixx=Nao(o3e)
if(Ixx!=w)then
loop
call RUx((Abx((Ixx),(rVe),(rEe),(ri))))
call moo(CMx,Ixx,rne)
set Ixx=Nao(o3e)
exitwhen(Ixx==w)
endloop
endif
return true
endfunction
function iQr takes nothing returns boolean
set o3e=O2x()
set o7e=XLx(function imr)
set o4e=XLx(function iMr)
call meo(gTv,XBx("HealExplosion_Init: call HealExplosion.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HealExplosion.Event_SpellEffect))",ah,pI,function ipr))
call meo(gTv,XBx("HealExplosion_Init: call HealExplosion.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HealExplosion.Event_EndCast))",oev,pI,function iPr))
return true
endfunction
function isr takes nothing returns boolean
call oer(function iQr,"HealExplosion_Init")
return true
endfunction
function iSr takes nothing returns boolean
call LZx('AIcA',false)
set hrv=Lzo('AIcA')
set G6[(hrv)]=(D6)
set j6[(hrv)]=(1)
set sH[(hrv)]=("Ice Arrows")
set xzv[(hrv)]=("spell")
call LZo((hrv),QH+(1),((20)*1.))
call LZo((hrv),Lvv+(1),((750)*1.))
set Mnv[(hrv)]=("ReplaceableTextures\\CommandButtons\\BTNColdArrowsOn.blp")
return true
endfunction
function itr takes nothing returns boolean
set rXe=lQx(rOe+" (coldnessBuff)")
set qc[(rXe)]=(true)
set qU[(rXe)]=(true)
return true
endfunction
function iTr takes nothing returns boolean
set rRe=lQx(rOe+" (dummyBuff)")
return true
endfunction
function iur takes nothing returns boolean
call VRx(qa,(function iSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\IceArrows.page\\IceArrows.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function itr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\IceArrows.page\\IceArrows.struct\\obj_coldnessBuff_wc3buff.j"))
call VRx(Ma,(function iTr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\IceArrows.page\\IceArrows.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function iUr takes nothing returns boolean
set rIe=Vnx(rOe)
return true
endfunction
function iwr takes integer Ixx returns boolean
return( not(I6x(Ixx,IBv)))and( not(I6x(Ixx,ICv)))and( not(nIo(Ixx)))
endfunction
function iWr takes integer rwx,integer Ixx returns nothing
local real ilx
if I6x(Ixx,yd)then
set ilx=rBe
else
set ilx=rce
endif
call NIx((Ixx),(rXe),(rwx),w,((ilx)*1.))
endfunction
function iyr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(EYv[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer rwx=(oPx(((CMx)),N+(hrv)))
local real iYr=(LF[(CMx)])-(Cpx((hrv),QH+(rwx)))
if(iYr<.0)then
return true
endif
call BOx(CMx,iYr)
if not iwr(Ixx)then
return true
endif
call RUx((Abx((Ixx),(rNe),(rbe),(ri))))
call iWr(rwx,Ixx)
call nJo((CMx),(Ixx),((rCe)*1.),(true),(false))
return true
endfunction
function izr takes nothing returns boolean
local integer rdx=(bv)
call I7x((Vv[(rdx)]),rAe)
return true
endfunction
function iZr takes nothing returns boolean
local integer rdx=(bv)
call Rmx((Vv[(rdx)]),rAe)
return true
endfunction
function i_r takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(rRe),((Mv[(rdx)])),w)
return true
endfunction
function i0r takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),rRe)
return true
endfunction
function i1r takes nothing returns boolean
set rAe=XBx("IceArrows_Init: set IceArrows.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function IceArrows.Event_Damage)",EZv,pI,function iyr)
call l9x(rRe,XBx("IceArrows_Init: call IceArrows.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function IceArrows.Event_BuffGain))",Bd,pI,function izr))
call l9x(rRe,XBx("IceArrows_Init: call IceArrows.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function IceArrows.Event_BuffLose))",Jc,pI,function iZr))
call meo(hrv,XBx("IceArrows_Init: call IceArrows.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function IceArrows.Event_Learn))",pv,pI,function i_r))
call meo(hrv,XBx("IceArrows_Init: call IceArrows.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function IceArrows.Event_Unlearn))",Av,pI,function i0r))
call W_x(nxv,rXe)
return true
endfunction
function i2r takes nothing returns boolean
call oer(function i1r,"IceArrows_Init")
return true
endfunction
function i3r takes nothing returns boolean
call LZx('ALiS',false)
set GZv=Lzo('ALiS')
set G6[(GZv)]=(D6)
set j6[(GZv)]=(1)
set sH[(GZv)]=("Lightning Shield")
set Ih[(GZv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D008E)))),(((Oj))))))
set x6v[(GZv)]=(4)
set xzv[(GZv)]=("spell")
call LZo((GZv),u6v+(1),(($82)*1.))
call LZo((GZv),fH+(1),((25)*1.))
call LZo((GZv),QH+(1),(('x')*1.))
call LZo((GZv),Lvv+(1),((900)*1.))
set Mnv[(GZv)]=("ReplaceableTextures\\CommandButtons\\BTNLightningShield.blp")
return true
endfunction
function i4r takes nothing returns boolean
set rde=WTx('BLiS',"Lightning Shield",'bLiS')
set qU[(rde)]=(true)
set aev[(rde)]=("ReplaceableTextures\\CommandButtons\\BTNLightningShield.blp")
call lux(rde,"Abilities\\Spells\\Orc\\LightningShield\\LightningShieldTarget.mdl","origin",ri)
return true
endfunction
function i5r takes nothing returns boolean
call VRx(qa,(function i3r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\LightningShield.page\\LightningShield.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function i4r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\LightningShield.page\\LightningShield.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function i6r takes nothing returns boolean
set rDe=Vnx(rfe)
return true
endfunction
function i7r takes nothing returns boolean
local integer Ixx=jFx()
if(Ixx==Ib)then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
return true
return true
endfunction
function i8r takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=rke[oqx]
local integer i9r
set Ib=Ixx
call Nio(rhe,(GetUnitX(C[((Ixx))])),(GetUnitY(C[((Ixx))])),rje[oqx]*OLx(Ixx,true)*1./ 60.,rHe)
set i9r=Nao(rhe)
if(i9r!=w)then
loop
call nJo((Ixx),(i9r),((rFe)*1.),(true),(false))
set i9r=Nao(rhe)
exitwhen(i9r==w)
endloop
endif
endfunction
function avr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=inx()
set rje[oqx]=(Cpx((GZv),u6v+(rwx)))
set rJe[oqx]=p0x
set rke[oqx]=Ixx
set ge[(p0x)]=(oqx)
call icx(p0x,rGe,true,function i8r)
return true
endfunction
function aer takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=rJe[oqx]
call ijx(p0x)
return true
endfunction
function axr takes nothing returns boolean
local integer rdx=(bv)
call NIx(((WH[(rdx)])),(rde),((Mv[(rdx)])),w,((rKe)*1.))
return true
endfunction
function aor takes nothing returns boolean
set rFe=rge*rGe
set rhe=O2x()
set rHe=XLx(function i7r)
call l9x(rde,XBx("LightningShield_Init: call LightningShield.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LightningShield.Event_BuffGain))",Bd,pI,function avr))
call l9x(rde,XBx("LightningShield_Init: call LightningShield.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LightningShield.Event_BuffLose))",Jc,pI,function aer))
call meo(GZv,XBx("LightningShield_Init: call LightningShield.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LightningShield.Event_SpellEffect))",ah,pI,function axr))
return true
endfunction
function arr takes nothing returns boolean
call oer(function aor,"LightningShield_Init")
return true
endfunction
function air takes nothing returns boolean
set rle=lQx(rLe+" (dummyBuff)")
return true
endfunction
function aar takes nothing returns boolean
call VRx(Ma,(function air),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\LunarRestoration.page\\LunarRestoration.struct\\Revival\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function anr takes nothing returns boolean
set rme=Vnx(rLe)
return true
endfunction
function aVr takes nothing returns boolean
set rMe=lQx(rpe+" (dummyBuff)")
return true
endfunction
function aEr takes nothing returns boolean
set rPe=WTx('BLuR',"Lunar Restoration",'bLuR')
set avv[(rPe)]=(true)
set aev[(rPe)]=("ReplaceableTextures\\PassiveButtons\\PASBTNElunesBlessing.blp")
call lux(rPe,"Abilities\\Spells\\Items\\ScrollOfRegeneration\\Scroll_Regen_Target.mdl","chest",Bi)
return true
endfunction
function aXr takes nothing returns boolean
call LZx('ALuR',false)
set hnv=Lzo('ALuR')
set G6[(hnv)]=(D6)
set j6[(hnv)]=(1)
set sH[(hnv)]=("Lunar Restoration")
set xzv[(hnv)]=("spell")
call LZo((hnv),QH+(1),(('d')*1.))
call LZo((hnv),Lvv+(1),((750)*1.))
set Mnv[(hnv)]=("ReplaceableTextures\\PassiveButtons\\PASBTNElunesBlessing.blp")
return true
endfunction
function aOr takes nothing returns boolean
call VRx(Ma,(function aVr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\LunarRestoration.page\\LunarRestoration.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(Ma,(function aEr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\LunarRestoration.page\\LunarRestoration.struct\\obj_effectBuff_wc3buff.j"))
call VRx(qa,(function aXr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\LunarRestoration.page\\LunarRestoration.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function aRr takes nothing returns boolean
set rqe=Vnx(rpe)
return true
endfunction
function aIr takes integer rwx,integer Ixx returns nothing
call DSx((Ixx),(rle),(rwx),w)
endfunction
function aAr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer rwx
if(Nnv[(Ixx)])then
return true
endif
set rwx=(oPx(((Ixx)),N+(hnv)))
call aIr(rwx,Ixx)
return true
endfunction
function aNr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer abr=rse[rwx]
local integer aBr=rSe[rwx]
set rte[oqx]=rwx
set rTe[oqx]=abr
set rue[oqx]=aBr
if((LF[(Ixx)])<(Cpx((hnv),QH+(rwx))))then
set rUe[oqx]=false
call I7x(Ixx,abr)
else
set rUe[oqx]=true
call I7x(Ixx,aBr)
call DSx((Ixx),(rPe),(rwx),w)
endif
return true
endfunction
function acr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
if rUe[oqx]then
call Rmx(Ixx,rue[oqx])
call Ayx(Ixx,rPe)
else
call Rmx(Ixx,rTe[oqx])
endif
return true
endfunction
function aCr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call I7x(Ixx,rQe)
return true
endfunction
function adr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call Rmx(Ixx,rQe)
return true
endfunction
function aDr takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(rMe),((Mv[(rdx)])),w)
return true
endfunction
function afr takes string rqx,integer rRx,integer rIx,integer oSx,limitop Bnx,code iDx returns integer
local integer oqx=XBx(rqx,rRx,rIx,iDx)
call xpr(oqx,oSx,Bnx)
return oqx
endfunction
function aFr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
set rUe[oqx]=true
call I7x(Ixx,rue[oqx])
call Rmx(Ixx,rTe[oqx])
call DSx((Ixx),(rPe),(rte[oqx]),w)
return true
endfunction
function agr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
set rUe[oqx]=false
call I7x(Ixx,rTe[oqx])
call Rmx(Ixx,rue[oqx])
call Ayx(Ixx,rPe)
return true
endfunction
function aGr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),rle)
return true
endfunction
function ahr takes integer oqx returns nothing
if I6x(oqx,yd)then
call qLo(oqx,(GetUnitX(C[((oqx))])),(GetUnitY(C[((oqx))])))
else
call Yjo(oqx)
endif
endfunction
function aHr takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local integer rwx=rye[oqx]
local integer Ixx=oqx
call Ayx(Ixx,rle)
call ahr(Ixx)
call cFx(Ixx,(iG[(Ixx)])*r1e)
call BOx(Ixx,(mF[(Ixx)])*r2e-(Cpx((hnv),QH+(rwx))))
endfunction
function ajr takes nothing returns boolean
local integer rdx=(bv)
local integer ibx=inx()
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local real dix=(GetUnitX(C[((Ixx))]))
local real dax=(GetUnitY(C[((Ixx))]))
local integer oqx=Ixx
set rWe[oqx]=ibx
set rye[oqx]=rwx
set rYe[oqx]=(mHo(((dix)*1.),((dax)*1.),(rze),(ri)))
set rZe[oqx]=dix
set r_e[oqx]=dax
set ge[(ibx)]=(oqx)
call I7x(Ixx,rwe)
set Nnv[(Ixx)]=(true)
call icx(ibx,r0e,false,function aHr)
return true
endfunction
function aJr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer akr=rYe[oqx]
call ijx(rWe[oqx])
call mFo(akr)
call Rmx(Ixx,rwe)
return true
endfunction
function aKr takes nothing returns nothing
set rwe=XBx("FolderLunarRestoration_StructRevival_Init: set FolderLunarRestoration_StructRevival.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderLunarRestoration_StructRevival.Event_Revive)",XP,pI,function aGr)
call l9x(rle,XBx("FolderLunarRestoration_StructRevival_Init: call FolderLunarRestoration_StructRevival.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderLunarRestoration_StructRevival.Event_BuffGain))",Bd,pI,function ajr))
call l9x(rle,XBx("FolderLunarRestoration_StructRevival_Init: call FolderLunarRestoration_StructRevival.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderLunarRestoration_StructRevival.Event_BuffLose))",Jc,pI,function aJr))
endfunction
function alr takes nothing returns boolean
local integer olx
set rQe=XBx("LunarRestoration_Init: set LunarRestoration.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LunarRestoration.Event_Death)",VP,pI,function aAr)
call l9x(rMe,XBx("LunarRestoration_Init: call LunarRestoration.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LunarRestoration.Event_BuffGain))",Bd,pI,function aNr))
call l9x(rMe,XBx("LunarRestoration_Init: call LunarRestoration.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LunarRestoration.Event_BuffLose))",Jc,pI,function acr))
call l9x(rPe,XBx("LunarRestoration_Init: call LunarRestoration.EFFECT_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LunarRestoration.Event_EffectBuffGain))",Bd,pI,function aCr))
call l9x(rPe,XBx("LunarRestoration_Init: call LunarRestoration.EFFECT_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LunarRestoration.Event_EffectBuffLose))",Jc,pI,function adr))
call meo(hnv,XBx("LunarRestoration_Init: call LunarRestoration.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LunarRestoration.Event_Learn))",pv,pI,function aDr))
set olx=(j6[(hnv)])
loop
exitwhen(olx<1)
set rse[olx]=afr("LunarRestoration_Init: set LunarRestoration.MANA_GAIN_EVENT[iteration] = Event.CreateLimit(UNIT.Mana.DUMMY_EVENT_TYPE, EventPriority.SPELLS, Real.ToInt(LunarRestoration.THIS_SPELL.GetManaCost(iteration)), GREATER_THAN_OR_EQUAL, function LunarRestoration.Event_ManaGain)",MF,pI,(R2I((((Cpx((hnv),QH+(olx))))*1.))),GREATER_THAN_OR_EQUAL,function aFr)
set rSe[olx]=afr("LunarRestoration_Init: set LunarRestoration.MANA_LOSE_EVENT[iteration] = Event.CreateLimit(UNIT.Mana.DUMMY_EVENT_TYPE, EventPriority.SPELLS, Real.ToInt(LunarRestoration.THIS_SPELL.GetManaCost(iteration)), LESS_THAN, function LunarRestoration.Event_ManaLose)",MF,pI,(R2I((((Cpx((hnv),QH+(olx))))*1.))),LESS_THAN,function agr)
set olx=olx-1
endloop
call aKr()
return true
endfunction
function aLr takes nothing returns boolean
call oer(function alr,"LunarRestoration_Init")
return true
endfunction
function amr takes nothing returns boolean
set r3e=Vnx(r4e)
return true
endfunction
function aMr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(LoadInteger(o[((V[(E[((X))])]))],(((OK+(((av[(rdx)])))))),(((IK)))))
local integer Ixx
if I6x(CMx,sc)then
return true
endif
set Hf=(ze[(CMx)])
set Ixx=oXr((GetUnitX(C[((CMx))])),(GetUnitY(C[((CMx))])),500.,r5e)
if(Ixx==w)then
return true
endif
call Lvx((CMx),(Ih[((Sbv))]),(Ixx))
return true
endfunction
function apr takes integer oqx,boolean wBo,boolean wco returns integer
local boolean aPr
local integer olx=(CXx(((oqx)),eB))
local integer o4x=0
local integer Iox
loop
exitwhen(olx<q)
set Iox=(COx(((oqx)),eB,(olx)))
if not(wd[(Iox)])then
set aPr=(avv[(Iox)])
if((wBo and not aPr)or(wco and aPr))then
set o4x=o4x+1
endif
endif
set olx=olx-1
endloop
return o4x
endfunction
function aqr takes nothing returns boolean
local integer Ixx=jFx()
if(((rG[(Ixx)])>(iG[(Ixx)]))and(apr(Ixx,false,true)==0))then
return false
endif
if(oPx((((Ixx))),(yb+(r6e)))>0)then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function aQr takes nothing returns boolean
local integer Fmx=x0r(Sbv,function aMr)
set r5e=XLx(function aqr)
call x3r(Fmx,dsv,jI,w)
return true
endfunction
function asr takes nothing returns boolean
call e1r(function aQr,"AIPurge_Init")
return true
endfunction
function aSr takes nothing returns boolean
call LZx('APur',false)
set Sbv=Lzo('APur')
set G6[(Sbv)]=(D6)
set j6[(Sbv)]=(1)
set sH[(Sbv)]=("Purge")
set Ih[(Sbv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D008F)))),(((Oj))))))
set x6v[(Sbv)]=(4)
set xzv[(Sbv)]=("spell")
call LZo((Sbv),fH+(1),((8)*1.))
call LZo((Sbv),QH+(1),((90)*1.))
call LZo((Sbv),Lvv+(1),((900)*1.))
set Mnv[(Sbv)]=("ReplaceableTextures\\CommandButtons\\BTNPurge.blp")
return true
endfunction
function atr takes nothing returns boolean
set r6e=WTx('BPur',"Purge",'bPur')
set qU[(r6e)]=(true)
set aev[(r6e)]=("ReplaceableTextures\\CommandButtons\\BTNPurge.blp")
call lux(r6e,"Abilities\\Spells\\Orc\\Purge\\PurgeBuffTarget.mdl","origin",ri)
return true
endfunction
function aTr takes nothing returns boolean
call VRx(qa,(function aSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Purge.page\\Purge.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function atr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Purge.page\\Purge.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function aur takes nothing returns boolean
set r7e=Vnx(r8e)
return true
endfunction
function aUr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer awr=ioe[oqx]
local integer aWr=iee[oqx]-1
local integer Ixx=oqx
set iee[oqx]=aWr
call Iqx(Ixx,awr)
call lZx(((awr)),Xc+(r9e),((iie*(aWr*1./ ixe))*1.))
call I0x(Ixx,awr)
endfunction
function ayr takes nothing returns boolean
local integer rdx=(bv)
local real ilx=ive
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer awr=lYx()
local integer aYr=inx()
set iee[oqx]=ixe
set ioe[oqx]=awr
set ire[oqx]=aYr
set ge[(aYr)]=(oqx)
call l_x(awr,r9e,iie)
call I0x(Ixx,awr)
call icx(aYr,ilx*1./ ixe,true,function aUr)
return true
endfunction
function azr takes integer oqx,integer oQx returns nothing
call SaveBoolean(o[(((V[(E[((xc[(oqx)]))])])))],(((((oc[((oqx))]))))),((((oQx)))),(false))
endfunction
function aZr takes integer oqx,integer oQx returns nothing
call dTx((xc[(oqx)]),((oc[((oqx))])),(oQx))
endfunction
function a_r takes integer oqx returns nothing
local integer olx=(Iax(((oqx)),rc))
local integer IIx
loop
exitwhen(olx<q)
set IIx=(Inx(((oqx)),rc,(olx)))
call azr((oqx),nc+IIx)
set olx=olx-1
endloop
call aZr((oqx),rc)
endfunction
function a0r takes integer oqx,integer oQx returns nothing
call SaveReal(o[(((V[(E[((xc[(oqx)]))])])))],(((((oc[((oqx))]))))),((((oQx)))),((.0)*1.))
endfunction
function a1r takes integer oqx returns nothing
local integer olx=(Iax(((oqx)),Vc))
local integer IIx
loop
exitwhen(olx<q)
set IIx=(Inx(((oqx)),Vc,(olx)))
call a0r((oqx),Xc+IIx)
set olx=olx-1
endloop
call aZr((oqx),Vc)
endfunction
function a2r takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer Rfx returns nothing
call SaveBoolean(o[(((XO[oqx])))],((RNx(Rbx,RBx,Rcx))),((Rdx(Rbx,RDx,Rfx))),(false))
endfunction
function a3r takes integer oqx,integer IIx returns nothing
local integer oQx=Rlx(X,Rc,oqx,IIx,w)
loop
exitwhen(oQx==w)
call a2r(E[((X))],(Nc),(oqx),(IIx),(oQx),(w))
set oQx=Rlx(X,Rc,oqx,IIx,w)
endloop
endfunction
function a4r takes integer oqx,integer IIx returns nothing
local integer oQx=Rlx(X,bc,oqx,IIx,w)
loop
exitwhen(oQx==w)
call A3x(E[((X))],(Bc),(oqx),(IIx),(oQx),(w))
set oQx=Rlx(X,bc,oqx,IIx,w)
endloop
endfunction
function a5r takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer Rfx returns nothing
call SaveReal(o[(((XO[oqx])))],((RNx(Rbx,RBx,Rcx))),((Rdx(Rbx,RDx,Rfx))),((.0)*1.))
endfunction
function a6r takes integer oqx,integer IIx returns nothing
local integer oQx=Rlx(X,cc,oqx,IIx,w)
loop
exitwhen(oQx==w)
call a5r(E[((X))],(Cc),(oqx),(IIx),(oQx),(w))
set oQx=Rlx(X,cc,oqx,IIx,w)
endloop
endfunction
function a7r takes integer oqx,integer Rbx,integer RBx,integer Rcx,integer RDx,integer Rfx returns nothing
call SaveStr(o[(((XO[oqx])))],((RNx(Rbx,RBx,Rcx))),((Rdx(Rbx,RDx,Rfx))),(null))
endfunction
function a8r takes integer oqx,integer IIx returns nothing
local integer oQx=Rlx(X,dc,oqx,IIx,w)
loop
exitwhen(oQx==w)
call a7r(E[((X))],(Dc),(oqx),(IIx),(oQx),(w))
set oQx=Rlx(X,dc,oqx,IIx,w)
endloop
endfunction
function a9r takes integer oqx returns nothing
local integer olx=Iax((oqx),Oc)
local integer IIx
loop
exitwhen(olx<q)
set IIx=Inx((oqx),Oc,olx)
call a3r(oqx,IIx)
call a4r(oqx,IIx)
call a6r(oqx,IIx)
call a8r(oqx,IIx)
set olx=olx-1
endloop
call aZr((oqx),Oc)
endfunction
function nvr takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((xc[oqx]))])])],((((oc[((oqx))])))))
endfunction
function ner takes integer oqx returns nothing
set WU[oqx]=false
call nvr((oqx))
call rgx(YU)
endfunction
function nxr takes integer oqx returns nothing
if(wU[oqx]>0)then
return
endif
if(uU[oqx]!=Z)then
call oYx("UnitModSet_Allocation_deallocCustom_confirm","call DebugEx(UnitModSet.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",TU+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set uU[oqx]=uU[(w)]
set uU[(w)]=oqx
call ner(oqx)
endfunction
function nor takes integer oqx returns nothing
set wU[oqx]=wU[oqx]-1
call nxr(oqx)
endfunction
function nrr takes integer oqx returns nothing
call a_r(oqx)
call a1r(oqx)
call a9r(oqx)
call aZr(((oqx)),Fc)
call nor((oqx))
endfunction
function nir takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer awr=ioe[oqx]
local integer aYr=ire[oqx]
call ijx(aYr)
call Iqx(Ixx,awr)
call nrr(awr)
return true
endfunction
function nar takes integer rwx,integer Ixx,real ilx returns nothing
if nIo(Ixx)then
return
endif
call wbo(Ixx,false,true,true)
set ive=ilx
call NIx((Ixx),(r6e),(rwx),w,((ilx)*1.))
endfunction
function nnr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local real ilx
if I6x(Ixx,yd)then
set ilx=iae
else
set ilx=ine
endif
call nar(rwx,Ixx,ilx)
return true
endfunction
function nVr takes nothing returns boolean
set r9e=ZU
call l9x(r6e,XBx("Purge_Init: call Purge.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Purge.Event_BuffGain))",Bd,pI,function ayr))
call l9x(r6e,XBx("Purge_Init: call Purge.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Purge.Event_BuffLose))",Jc,pI,function nir))
call meo(Sbv,XBx("Purge_Init: call Purge.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Purge.Event_SpellEffect))",ah,pI,function nnr))
return true
endfunction
function nEr takes nothing returns boolean
call oer(function nVr,"Purge_Init")
return true
endfunction
function nXr takes nothing returns boolean
set iVe=WTx('BSoP',"Poisoned",'bSoP')
set qU[(iVe)]=(true)
set aev[(iVe)]=("ReplaceableTextures\\CommandButtons\\BTNPoisonSting.blp")
call lux(iVe,"Abilities\\Weapons\\PoisonSting\\PoisonStingTarget.mdl","origin",ri)
return true
endfunction
function nOr takes nothing returns boolean
call VRx(Ma,(function nXr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\SoakingPoison.page\\SoakingPoison.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function nRr takes nothing returns boolean
set iEe=Vnx(iXe)
return true
endfunction
function nIr takes nothing returns boolean
set iOe=lQx(iRe+" (dummyBuff)")
set SU=lYx()
call l_x(SU,cov,-20)
call l_x(SU,dKv,-50)
call l0x(((iOe)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,cov,-40)
call l_x(SU,dKv,-50)
call l0x(((iOe)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,cov,-60)
call l_x(SU,dKv,-50)
call l0x(((iOe)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,cov,-80)
call l_x(SU,dKv,-50)
call l0x(((iOe)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,cov,-'d')
call l_x(SU,dKv,-50)
call l0x(((iOe)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,cov,-'x')
call l_x(SU,dKv,-50)
call l0x(((iOe)),vc+(6),(SU))
set iIe[1]=-20
set iIe[2]=-40
set iIe[3]=-60
set iIe[4]=-80
set iIe[5]=-'d'
set iIe[6]=-'x'
set iAe[1]=-50
set iAe[2]=-50
set iAe[3]=-50
set iAe[4]=-50
set iAe[5]=-50
set iAe[6]=-50
return true
endfunction
function nAr takes nothing returns boolean
call LZx('ASoP',false)
set iNe=Lzo('ASoP')
set G6[(iNe)]=(D6)
set j6[(iNe)]=(1)
set sH[(iNe)]=("Soaking Poison")
set xzv[(iNe)]=("spell")
call LZo((iNe),Lvv+(1),((750)*1.))
set Mnv[(iNe)]=("ReplaceableTextures\\PassiveButtons\\PASBTNPoisonSting.blp")
return true
endfunction
function nNr takes nothing returns boolean
call VRx(Ma,(function nIr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\SoakingPoison.page\\SoakingPoison.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function nAr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\SoakingPoison.page\\SoakingPoison.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function nbr takes nothing returns boolean
set ibe=Vnx(iRe)
return true
endfunction
function nBr takes integer Ixx returns boolean
return( not(I6x(Ixx,IBv)))and( not(I6x(Ixx,ICv)))
endfunction
function ncr takes integer CMx,integer rwx,integer Ixx returns nothing
local real ilx
if I6x(Ixx,yd)then
set ilx=ice
else
set ilx=iCe
endif
set ide=CMx
call NIx((Ixx),(iVe),(rwx),w,((ilx)*1.))
endfunction
function nCr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
if not nBr(Ixx)then
return true
endif
call ncr((EYv[(rdx)]),(oPx((((EYv[(rdx)]))),N+(iNe))),Ixx)
return true
endfunction
function ndr takes nothing returns boolean
local integer rdx=(bv)
call I7x((Vv[(rdx)]),iBe)
return true
endfunction
function nDr takes nothing returns boolean
local integer rdx=(bv)
call Rmx((Vv[(rdx)]),iBe)
return true
endfunction
function nfr takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(iOe),((Mv[(rdx)])),w)
return true
endfunction
function nFr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),iOe)
return true
endfunction
function ngr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
call nJo((ige[oqx]),(Ixx),((itx(iGe[oqx],(rG[(Ixx)])-DG))*1.),(false),(false))
endfunction
function nGr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=ide
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=inx()
set ige[oqx]=CMx
set iGe[oqx]=iDe
set ihe[oqx]=p0x
set ge[(p0x)]=(oqx)
call icx(p0x,iFe,true,function ngr)
return true
endfunction
function nhr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=ihe[oqx]
call ijx(p0x)
return true
endfunction
function nHr takes nothing returns nothing
set iDe=ife*iFe
call l9x(iVe,XBx("FolderSoakingPoison_StructTarget_Init: call FolderSoakingPoison_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSoakingPoison_StructTarget.Event_BuffGain))",Bd,pI,function nGr))
call l9x(iVe,XBx("FolderSoakingPoison_StructTarget_Init: call FolderSoakingPoison_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSoakingPoison_StructTarget.Event_BuffLose))",Jc,pI,function nhr))
call W_x(XNv,iVe)
endfunction
function njr takes nothing returns boolean
set iBe=XBx("SoakingPoison_Init: set SoakingPoison.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function SoakingPoison.Event_Damage)",EZv,pI,function nCr)
call l9x(iOe,XBx("SoakingPoison_Init: call SoakingPoison.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoakingPoison.Event_BuffGain))",Bd,pI,function ndr))
call l9x(iOe,XBx("SoakingPoison_Init: call SoakingPoison.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoakingPoison.Event_BuffLose))",Jc,pI,function nDr))
call meo(iNe,XBx("SoakingPoison_Init: call SoakingPoison.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoakingPoison.Event_Learn))",pv,pI,function nfr))
call meo(iNe,XBx("SoakingPoison_Init: call SoakingPoison.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoakingPoison.Event_Unlearn))",Av,pI,function nFr))
call nHr()
return true
endfunction
function nJr takes nothing returns boolean
call oer(function njr,"SoakingPoison_Init")
return true
endfunction
function nkr takes nothing returns boolean
call LZx('AStm',false)
set SFv=Lzo('AStm')
set G6[(SFv)]=(D6)
set j6[(SFv)]=(1)
set sH[(SFv)]=("Stampede")
set Ih[(SFv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0271)))),(((Oj))))))
set x6v[(SFv)]=(2)
set xzv[(SFv)]=("spell")
call LZo((SFv),fH+(1),((8)*1.))
call LZo((SFv),QH+(1),((0)*1.))
call LZo((SFv),Lvv+(1),(($3E8)*1.))
set Mnv[(SFv)]=("ReplaceableTextures\\CommandButtons\\BTNSmash.blp")
return true
endfunction
function nKr takes nothing returns boolean
set iHe=lQx(ije+" (dummyBuff)")
return true
endfunction
function nlr takes nothing returns boolean
call VRx(qa,(function nkr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Stampede.page\\Stampede.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function nKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Stampede.page\\Stampede.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function nLr takes nothing returns boolean
set iJe=Vnx(ije)
return true
endfunction
function nmr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function nMr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=oqx
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local integer Ixx
local real dpo
set Hf=(ze[(CMx)])
call Nio(iPe,wpo,wPo,dvx(CMx,true),iSe)
set Ixx=Nao(iPe)
if(Ixx!=w)then
set dpo=ike*iTe[oqx]
call A7o(Nvo(wpo,wPo,ize,Bi,iZe*(ob[(CMx)])))
loop
call RUx((Abx((Ixx),(i_e),(i0e),(Bi))))
call nJo((CMx),(Ixx),((dpo)*1.),(false),(false))
set Ixx=Nao(iPe)
exitwhen(Ixx==w)
endloop
endif
endfunction
function npr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
local real N2x=iwe[oqx]+iWe[oqx]
local real N3x=iye[oqx]+iYe[oqx]
set iTe[oqx]=iTe[oqx]+iue[oqx]
set iwe[oqx]=N2x
set iye[oqx]=N3x
call B3o(Ixx,N2x)
call B4o(Ixx,N3x)
endfunction
function nPr takes nothing returns boolean
local integer rdx=(bv)
local integer nqr=(mc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local real dix=(UH[(nqr)])
local real dax=(wH[(nqr)])
local real N8x=UCx(Ixx,dix-(GetUnitX(C[((Ixx))])),dax-(GetUnitY(C[((Ixx))])))
local integer oqx=Ixx
local integer p0x=inx()
local integer Q6o=inx()
local real I_o=(Cos(((((N8x)*1.))*1.)))
local real I0o=(Sin(((((N8x)*1.))*1.)))
set ite[oqx]=p0x
set iTe[oqx]=ime
set iue[oqx]=iMe*iQe
set iUe[oqx]=Q6o
set iwe[oqx]=iqe*I_o
set iWe[oqx]=ise*I_o
set iye[oqx]=iqe*I0o
set iYe[oqx]=ise*I0o
set ge[(p0x)]=(oqx)
set ge[(Q6o)]=(oqx)
call icx(p0x,ile,true,function nMr)
call icx(Q6o,iQe,true,function npr)
return true
endfunction
function nQr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=ite[oqx]
local integer Q6o=iUe[oqx]
call ijx(p0x)
call ijx(Q6o)
return true
endfunction
function nsr takes nothing returns boolean
local integer rdx=(bv)
call NIx((Vv[(rdx)]),iHe,(Mv[(rdx)]),rdx,iLe)
return true
endfunction
function nSr takes nothing returns boolean
set ike=iKe*ile
set iLe=-ime*1./ iMe+(SquareRoot(((ime*ime*1./ iMe*1./ iMe+2*ipe*1./ iMe)*1.)))
set iPe=O2x()
set iqe=ime*iQe
set ise=iMe*iQe*iQe
set iSe=XLx(function nmr)
call l9x(iHe,XBx("Stampede_Init: call Stampede.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Stampede.Event_BuffGain))",Bd,pI,function nPr))
call l9x(iHe,XBx("Stampede_Init: call Stampede.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Stampede.Event_BuffLose))",Jc,pI,function nQr))
call meo(SFv,XBx("Stampede_Init: call Stampede.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Stampede.Event_SpellEffect))",ah,pI,function nsr))
return true
endfunction
function ntr takes nothing returns boolean
call oer(function nSr,"Stampede_Init")
return true
endfunction
function nTr takes nothing returns boolean
set i1e=Vnx(i2e)
return true
endfunction
function nur takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(LoadInteger(o[((V[(E[((X))])]))],(((OK+(((av[(rdx)])))))),(((IK)))))
if I6x(CMx,sc)then
return true
endif
set Hf=(ze[(CMx)])
call Nio(i3e,(GetUnitX(C[((CMx))])),(GetUnitY(C[((CMx))])),(Cpx((g7v),u6v+((oPx(((CMx)),N+(g7v)))))),i4e)
if((NXo((i3e)))<2)then
return true
endif
call O9x((CMx),(Ih[((g7v))]))
return true
endfunction
function nUr takes nothing returns boolean
local integer Fmx=x0r(g7v,function nur)
call odr(Fmx,5.)
return true
endfunction
function nwr takes nothing returns boolean
call e1r(function nUr,"AIStomp_Init")
return true
endfunction
function nWr takes nothing returns boolean
call LZx('AStp',false)
set g7v=Lzo('AStp')
set G6[(g7v)]=(D6)
set j6[(g7v)]=(1)
set sH[(g7v)]=("Stomp")
set Ih[(g7v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00C4)))),(((Oj))))))
set x6v[(g7v)]=(0)
set xzv[(g7v)]=("spell")
call LZo((g7v),u6v+(1),((400)*1.))
call LZo((g7v),BH+(1),((.5)*1.))
call LZo((g7v),fH+(1),(($A)*1.))
call LZo((g7v),QH+(1),((40)*1.))
call LZo((g7v),Lvv+(1),((750)*1.))
set Mnv[(g7v)]=("ReplaceableTextures\\CommandButtons\\BTNWarStomp.blp")
return true
endfunction
function nyr takes nothing returns boolean
call VRx(qa,(function nWr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Stomp.page\\Stomp.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function nYr takes nothing returns boolean
set i5e=Vnx(i6e)
return true
endfunction
function nzr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function nZr takes integer oqx returns nothing
local real Dho=1.
local real I1o=250.*32.*1./(16.+dvx((oqx),true))
local real n_r=-8*I1o*1./ Dho*1./ Dho
local real NJx=-n_r*1./ 2*Dho
call cio((oqx),.0,.0,NJx,.0,.0,n_r,Dho)
endfunction
function n0r takes nothing returns boolean
local integer rdx=(bv)
call nZr((Vv[(rdx)]))
return true
endfunction
function n1r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local integer Ixx
call mFo((mHo(((wpo)*1.),((wPo)*1.),(i7e),(ri))))
set Hf=(ze[(CMx)])
call Nio(i3e,wpo,wPo,(Cpx((g7v),u6v+(rwx))),i4e)
set Ixx=Nao(i3e)
if(Ixx!=w)then
loop
call NIx((Ixx),(Xsv),(rwx),w,((i8e)*1.))
call nJo((CMx),(Ixx),((i9e)*1.),(false),(false))
set Ixx=Nao(i3e)
exitwhen(Ixx==w)
endloop
endif
return true
endfunction
function n2r takes nothing returns boolean
set i3e=O2x()
set i4e=XLx(function nzr)
call meo(g7v,XBx("Stomp_Init: call Stomp.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Stomp.Event_SpellEffect))",ah,pI,function n0r))
call meo(g7v,XBx("Stomp_Init: call Stomp.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.SUCCESS_EVENT_TYPE, EventPriority.SPELLS, function Stomp.Event_EndCast))",oxv,pI,function n1r))
return true
endfunction
function n3r takes nothing returns boolean
call oer(function n2r,"Stomp_Init")
return true
endfunction
function n4r takes nothing returns boolean
local integer rdx=(bv)
local integer Ipx=(Gc[(rdx)])
call fPx(((Vv[(rdx)])),cFv[(Ipx)],cgv[(Ipx)],cGv[(Ipx)],chv[(Ipx)],cHv[(Ipx)])
return true
endfunction
function n5r takes nothing returns boolean
local integer rdx=(bv)
local integer Ipx=(Gc[(rdx)])
call fPx((((Vv[(rdx)]))),-((cFv[(Ipx)])*1.),-((cgv[(Ipx)])*1.),-((cGv[(Ipx)])*1.),-((chv[(Ipx)])*1.),((cHv[(Ipx)])*1.))
return true
endfunction
function n6r takes integer oqx,real iWx,real iyx,real iYx,real izx,real ilx returns integer
local integer Ipx=rto(cfv,function n4r,function n5r)
set cFv[(Ipx)]=iWx
set cgv[(Ipx)]=iyx
set cGv[(Ipx)]=iYx
set chv[(Ipx)]=izx
set cHv[(Ipx)]=ilx
return Ipx
endfunction
function n7r takes nothing returns boolean
set ave=lQx(aee+" (dummyBuff)")
set SU=lYx()
call lzx(((SU)),Fc,(n6r(Db,0,0,0,0,2)))
call l0x(((ave)),vc+(1),(SU))
return true
endfunction
function n8r takes nothing returns boolean
call LZx('ABag',false)
set GQv=Lzo('ABag')
set G6[(GQv)]=(D6)
set j6[(GQv)]=(1)
set sH[(GQv)]=("Barrage")
set Ih[(GQv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D007F)))),(((Oj))))))
set x6v[(GQv)]=(4)
set xzv[(GQv)]=("spell")
call LZo((GQv),u6v+(1),(($FA)*1.))
call LZo((GQv),BH+(1),((5)*1.))
call LZo((GQv),fH+(1),(($C)*1.))
call LZo((GQv),QH+(1),((80)*1.))
call LZo((GQv),Lvv+(1),((700)*1.))
set Mnv[(GQv)]=("ReplaceableTextures\\CommandButtons\\BTNFlakCannons.blp")
return true
endfunction
function n9r takes nothing returns boolean
call VRx(Ma,(function n7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\Barrage.page\\Barrage.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function n8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\Barrage.page\\Barrage.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Vvr takes nothing returns boolean
set axe=Vnx(aee)
return true
endfunction
function Ver takes code c,string rqx returns nothing
set kn=kn+1
set Kn[kn]=CreateTrigger()
set ln[kn]=(GetHandleId(Condition((c))))
set Ln[kn]=rqx
call TriggerAddCondition(Kn[kn],Condition(c))
endfunction
function Vxr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if((sUv[(pe)]<sUv[(SJv)]))then
if I6x(Ixx,ICv)then
return false
endif
endif
return true
return true
endfunction
function Vor takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=oqx
local real N8x=(GetUnitFacing(C[((CMx))])*bh)
local integer Ixx
call SetUnitAnimation(C[((CMx))],("attack"))
set Hf=(ze[(CMx)])
call Nio(aae,(GetUnitX(C[((CMx))]))+aXe*(Cos(((((N8x)*1.))*1.))),(GetUnitY(C[((CMx))]))+aXe*(Sin(((((N8x)*1.))*1.))),aVe[oqx],ane)
set Ixx=Nao(aae)
if(Ixx!=w)then
loop
call nJo((CMx),(Ixx),((aoe)*1.),(false),(false))
set Ixx=Nao(aae)
exitwhen(Ixx==w)
endloop
endif
endfunction
function Vrr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=inx()
set aVe[oqx]=(Cpx((GQv),u6v+(rwx)))
set aEe[oqx]=p0x
set ge[(p0x)]=(oqx)
call icx(p0x,aie,true,function Vor)
return true
endfunction
function Vir takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=aEe[oqx]
call ijx(p0x)
return true
endfunction
function Var takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),ave)
return true
endfunction
function Vnr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
call fWx(CMx,(UH[(rdx)]),(wH[(rdx)]))
call DSx((CMx),(ave),((Mv[(rdx)])),w)
return true
endfunction
function VVr takes nothing returns boolean
set aoe=are*aie
set aae=O2x()
set ane=XLx(function Vxr)
call l9x(ave,XBx("Barrage_Init: call Barrage.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Barrage.Event_BuffGain))",Bd,pI,function Vrr))
call l9x(ave,XBx("Barrage_Init: call Barrage.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Barrage.Event_BuffLose))",Jc,pI,function Vir))
call meo(GQv,XBx("Barrage_Init: call Barrage.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Barrage.Event_EndCast))",oev,pI,function Var))
call meo(GQv,XBx("Barrage_Init: call Barrage.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Barrage.Event_SpellEffect))",ah,pI,function Vnr))
return true
endfunction
function VEr takes nothing returns boolean
call Ver(function VVr,"Barrage_Init")
return true
endfunction
function VXr takes nothing returns boolean
set aOe=Vnx(aRe)
return true
endfunction
function VOr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(LoadInteger(o[((V[(E[((X))])]))],(((OK+(((av[(rdx)])))))),(((IK)))))
local integer Ixx
if I6x(CMx,sc)then
return true
endif
set Hf=(ze[(CMx)])
set Ixx=oXr((GetUnitX(C[((CMx))])),(GetUnitY(C[((CMx))])),500.,aIe)
if(Ixx==w)then
return true
endif
call CAx((CMx),(Ih[((Sjv))]),(((GetUnitX(C[((Ixx))])))*1.),(((GetUnitY(C[((Ixx))])))*1.))
return true
endfunction
function VRr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function VIr takes nothing returns boolean
local integer Fmx=x0r(Sjv,function VOr)
set aIe=XLx(function VRr)
call x3r(Fmx,dsv,jI,w)
return true
endfunction
function VAr takes nothing returns boolean
call e1r(function VIr,"AIBouncyBomb_Init")
return true
endfunction
function VNr takes nothing returns boolean
call LZx('ABoB',false)
set Sjv=Lzo('ABoB')
set G6[(Sjv)]=(D6)
set j6[(Sjv)]=(1)
set sH[(Sjv)]=("Bouncy Bomb")
set Ih[(Sjv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0107)))),(((Oj))))))
set x6v[(Sjv)]=(2)
set xzv[(Sjv)]=("spell")
call LZo((Sjv),u6v+(1),(('d')*1.))
call LZo((Sjv),fH+(1),(($A)*1.))
call LZo((Sjv),QH+(1),((25)*1.))
call LZo((Sjv),Lvv+(1),((600)*1.))
set Mnv[(Sjv)]=("ReplaceableTextures\\CommandButtons\\BTNHealthStone.blp")
return true
endfunction
function Vbr takes nothing returns boolean
call VRx(qa,(function VNr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\BouncyBomb.page\\BouncyBomb.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function VBr takes nothing returns boolean
set aAe=Vnx(aNe)
return true
endfunction
function Vcr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function VCr takes integer oqx returns integer
set aHe[oqx]=true
set aje[oqx]=false
call rax(aAe)
return oqx
endfunction
function Vdr takes nothing returns integer
local integer oqx
if(aFe==8190)then
call oYx("BouncyBomb_Allocation_allocCustom","call DebugEx(BouncyBomb.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",aNe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(age[(w)]==w)then
set aGe=aGe+1
set oqx=aGe
else
set oqx=age[(w)]
set age[(w)]=age[age[(w)]]
endif
set age[oqx]=Z
set ahe[oqx]=1
call VCr(oqx)
return oqx
endfunction
function VDr takes integer oqx,real x,real y,real z returns nothing
call Mko(oqx,(oJ[(oqx)])+x,(nJ[(oqx)])+y,(Vu[(oqx)])+z)
endfunction
function Vfr takes integer oqx returns real
return(Vu[oqx]-XYx((oJ[((oqx))]),(nJ[((oqx))])))
endfunction
function VFr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer HOx=aKe[oqx]
local real cRx=aQe[oqx]+aDe
call VDr(HOx,aPe[oqx],aqe[oqx],cRx)
if(Vfr(HOx)<ase)then
set aQe[oqx]=bUx(cRx)
else
set aQe[oqx]=cRx
endif
endfunction
function Vgr takes integer oqx returns nothing
set aHe[oqx]=false
call rgx(aAe)
endfunction
function VGr takes integer oqx returns nothing
if(ahe[oqx]>0)then
return
endif
if(age[oqx]!=Z)then
call oYx("BouncyBomb_Allocation_deallocCustom_confirm","call DebugEx(BouncyBomb.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",aNe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set age[oqx]=age[(w)]
set age[(w)]=oqx
call Vgr(oqx)
endfunction
function Vhr takes integer oqx returns nothing
set ahe[oqx]=ahe[oqx]-1
call VGr(oqx)
endfunction
function VHr takes real x,real y,real z,string ARx,integer rwx returns integer
local destructable g6x=CreateDestructableZ('cEfL',x,y,z,.0,1.,0)
local integer oqx=mHo(x,y,ARx,rwx)
call RemoveDestructable(g6x)
set g6x=null
return oqx
endfunction
function Vjr takes integer oqx,real x,real y,real z,real j8x,integer Q4x returns nothing
if(Q4x==w)then
set Q4x=GK
endif
set Q4x=Noo(MQ,Q4x)
set qQ=j8x
set pQ=x
set PQ=y
set sQ=z
call Nro((oqx),x,y,j8x+Bwv,Q4x)
endfunction
function VJr takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local integer CMx=ake[oqx]
local integer HOx=aKe[oqx]
local integer Q6o=aMe[oqx]
local integer CQx=ape[oqx]
local integer rwx=(XH[(CQx)])
local real x=(oJ[(HOx)])
local real y=(nJ[(HOx)])
local real z=(Vu[(HOx)])
local integer Ixx
local real Vkr
local real NIo
call Vhr((oqx))
call Mfx(HOx)
call ijx(ibx)
call ijx(Q6o)
call mFo((VHr(((x)*1.),((y)*1.),((z)*1.),(aSe),(ri))))
set Hf=(ze[(CMx)])
call Vjr(abe,x,y,z,(Cpx((Sjv),u6v+(rwx))),aBe)
set Ixx=Nao(abe)
if(Ixx!=w)then
set Vkr=ate
loop
set NIo=itx(aTe,Vkr)
set Vkr=Vkr-NIo
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
set Ixx=Nao(abe)
exitwhen(Ixx==w)
endloop
endif
call dRx(CQx)
endfunction
function VKr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local integer oqx=Vdr()
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real Vlr=fwx(CMx)+OLx(CMx,true)
local integer ibx=inx()
local integer Q6o=inx()
local integer CQx=Cmx(CMx,Sjv)
local real dX=dix-(GetUnitX(C[((CMx))]))
local real dY=dax-(GetUnitY(C[((CMx))]))
local real N8x=UCx(CMx,dX,dY)
local real d=jjx(dX,dY)
local integer HOx=mcx('qByB',wpo,wPo,Vlr,N8x)
local real VLr=d*1./ ace
local real Vmr=VLr*(Cos(((((N8x)*1.))*1.)))
local real VMr=VLr*(Sin(((((N8x)*1.))*1.)))
local real Vpr=((XYx(dix,dax)-Vlr)*1./ aJe-afe*1./ 2*aJe)*ade
set ake[oqx]=CMx
set aKe[oqx]=HOx
set ale[oqx]=ggx(Vmr,VMr,Vpr)
set aLe[oqx]=dix
set ame[oqx]=dax
set aMe[oqx]=Q6o
set ape[oqx]=CQx
set aPe[oqx]=Vmr
set aqe[oqx]=VMr
set aQe[oqx]=Vpr
set ge[(ibx)]=(oqx)
set ge[(Q6o)]=(oqx)
call icx(Q6o,ade,true,function VFr)
call icx(ibx,aCe,false,function VJr)
return true
endfunction
function VPr takes nothing returns boolean
set abe=O2x()
set aBe=XLx(function Vcr)
set ace=(R2I(((aCe*1./ ade)*1.)))
set aDe=afe*ade*ade
call meo(Sjv,XBx("BouncyBomb_Init: call BouncyBomb.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BouncyBomb.Event_SpellEffect))",ah,pI,function VKr))
return true
endfunction
function Vqr takes nothing returns boolean
call Ver(function VPr,"BouncyBomb_Init")
return true
endfunction
function VQr takes nothing returns boolean
call LZx('ABuO',false)
set SHv=Lzo('ABuO')
set G6[(SHv)]=(D6)
set j6[(SHv)]=(1)
set sH[(SHv)]=("Burning Oil")
set xzv[(SHv)]=("spell")
call LZo((SHv),u6v+(1),(($8C)*1.))
call LZo((SHv),Lvv+(1),((750)*1.))
set Mnv[(SHv)]=("ReplaceableTextures\\PassiveButtons\\PASBTNFireRocks.blp")
return true
endfunction
function Vsr takes nothing returns boolean
call LZx('ABuX',false)
return true
endfunction
function VSr takes nothing returns boolean
set aue=lQx(aUe+" (dummyBuff)")
return true
endfunction
function Vtr takes nothing returns boolean
call VRx(qa,(function VQr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\BurningOil.page\\BurningOil.struct\\obj_thisSpell_wc3spell.j"))
call VRx(qa,(function Vsr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\BurningOil.page\\BurningOil.struct\\obj_missileGraphicSpell_wc3spell.j"))
call VRx(Ma,(function VSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\BurningOil.page\\BurningOil.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function VTr takes nothing returns boolean
set awe=Vnx(aUe)
return true
endfunction
function Vur takes integer oqx returns integer
set a3e[oqx]=true
set a4e[oqx]=false
call rax(awe)
return oqx
endfunction
function VUr takes nothing returns integer
local integer oqx
if(a_e==8190)then
call oYx("BurningOil_Allocation_allocCustom","call DebugEx(BurningOil.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",aUe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(a0e[(w)]==w)then
set a1e=a1e+1
set oqx=a1e
else
set oqx=a0e[(w)]
set a0e[(w)]=a0e[a0e[(w)]]
endif
set a0e[oqx]=Z
set a2e[oqx]=1
call Vur(oqx)
return oqx
endfunction
function Vwr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=a5e[oqx]
local integer Ixx
set Hf=(ze[(CMx)])
call Nio(aze,nve[oqx],nee[oqx],(Cpx((SHv),u6v+(a7e[oqx]))),nxe)
set Ixx=Nao(aze)
if(Ixx!=w)then
loop
call nJo((CMx),(Ixx),((aWe)*1.),(false),(false))
set Ixx=Nao(aze)
exitwhen(Ixx==w)
endloop
endif
endfunction
function VWr takes integer oqx returns nothing
set a3e[oqx]=false
call rgx(awe)
endfunction
function Vyr takes integer oqx returns nothing
if(a2e[oqx]>0)then
return
endif
if(a0e[oqx]!=Z)then
call oYx("BurningOil_Allocation_deallocCustom_confirm","call DebugEx(BurningOil.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",aUe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set a0e[oqx]=a0e[(w)]
set a0e[(w)]=oqx
call VWr(oqx)
endfunction
function VYr takes integer oqx returns nothing
set a2e[oqx]=a2e[oqx]-1
call Vyr(oqx)
endfunction
function Vzr takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local integer p0x=a6e[oqx]
local integer akr=a8e[oqx]
call VYr((oqx))
call ijx(ibx)
call ijx(p0x)
call mFo(akr)
endfunction
function VZr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local integer rwx=(oPx(((CMx)),N+(SHv)))
local integer oqx=VUr()
local integer ibx=inx()
local integer p0x=inx()
set a5e[oqx]=CMx
set a6e[oqx]=p0x
set a7e[oqx]=rwx
set a8e[oqx]=(mHo(((dix)*1.),((dax)*1.),(a9e),(ri)))
set nve[oqx]=dix
set nee[oqx]=dax
set ge[(ibx)]=(oqx)
set ge[(p0x)]=(oqx)
call icx(p0x,aYe,true,function Vwr)
call icx(ibx,noe,false,function Vzr)
return true
endfunction
function V_r takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function V0r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
call I7x(Ixx,aZe)
call rQx(Ixx,'ABuX')
return true
endfunction
function V1r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
call Rmx(Ixx,aZe)
call UnitRemoveAbility(C[((Ixx))],('ABuX'))
return true
endfunction
function V2r takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(aue),((Mv[(rdx)])),w)
return true
endfunction
function V3r takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),aue)
return true
endfunction
function V4r takes nothing returns boolean
set aWe=aye*aYe
set aze=O2x()
set aZe=XBx("BurningOil_Init: set BurningOil.GROUND_ATTACK_EVENT = Event.Create(UNIT.Attack.Events.Ground.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BurningOil.Event_GroundAttack)",d0v,pI,function VZr)
set nxe=XLx(function V_r)
call l9x(aue,XBx("BurningOil_Init: call BurningOil.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BurningOil.Event_BuffGain))",Bd,pI,function V0r))
call l9x(aue,XBx("BurningOil_Init: call BurningOil.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BurningOil.Event_BuffLose))",Jc,pI,function V1r))
call meo(SHv,XBx("BurningOil_Init: call BurningOil.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BurningOil.Event_Learn))",pv,pI,function V2r))
call meo(SHv,XBx("BurningOil_Init: call BurningOil.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BurningOil.Event_Unlearn))",Av,pI,function V3r))
return true
endfunction
function V5r takes nothing returns boolean
call Ver(function V4r,"BurningOil_Init")
return true
endfunction
function V6r takes nothing returns boolean
set nre=Vbx("OChP")
return true
endfunction
function V7r takes nothing returns boolean
call LZx('AChL',false)
set Gpv=Lzo('AChL')
set G6[(Gpv)]=(D6)
set j6[(Gpv)]=(1)
set sH[(Gpv)]=("Chain Lightning")
set Ih[(Gpv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0097)))),(((Oj))))))
set x6v[(Gpv)]=(4)
set xzv[(Gpv)]=("spell")
call LZo((Gpv),u6v+(1),((500)*1.))
call LZo((Gpv),fH+(1),(($F)*1.))
call LZo((Gpv),QH+(1),((95)*1.))
call LZo((Gpv),Lvv+(1),((550)*1.))
set Mnv[(Gpv)]=("ReplaceableTextures\\CommandButtons\\BTNChainLightning.blp")
return true
endfunction
function V8r takes nothing returns boolean
set nie=Vbx("OChS")
return true
endfunction
function V9r takes nothing returns boolean
call VRx(Ha,(function V6r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\ChainLightning.page\\ChainLightning.struct\\obj_boltPrimary_wc3bolt.j"))
call VRx(qa,(function V7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\ChainLightning.page\\ChainLightning.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ha,(function V8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\ChainLightning.page\\ChainLightning.struct\\obj_boltSecondary_wc3bolt.j"))
return true
endfunction
function Evr takes nothing returns boolean
set nae=Vnx(nne)
return true
endfunction
function Eer takes integer Ixx returns boolean
return( not(I6x(Ixx,sc)))and( not(I6x(Ixx,IBv)))and( not(IsUnitAlly(C[(Ixx)],vx[(Hf)])))and( not(nIo(Ixx)))
endfunction
function Exr takes nothing returns boolean
local integer Ixx=jFx()
if Lko(nXe,Ixx)then
return false
endif
if not Eer(Ixx)then
return false
endif
return true
return true
endfunction
function Eor takes integer oqx returns integer
set nNe[oqx]=true
set nbe[oqx]=false
call rax(nae)
return oqx
endfunction
function Err takes nothing returns integer
local integer oqx
if(nOe==8190)then
call oYx("ChainLightning_Allocation_allocCustom","call DebugEx(ChainLightning.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",nne+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(nRe[(w)]==w)then
set nIe=nIe+1
set oqx=nIe
else
set oqx=nRe[(w)]
set nRe[(w)]=nRe[nRe[(w)]]
endif
set nRe[oqx]=Z
set nAe[oqx]=1
call Eor(oqx)
return oqx
endfunction
function Eir takes integer oqx returns integer
set oU[oqx]=true
set nle[oqx]=false
call rax(St)
return oqx
endfunction
function Ear takes nothing returns integer
local integer oqx
if(nke==8190)then
call oYx("FolderLightning_StructFromUnitToUnit_Allocation_allocCustom","call DebugEx(FolderLightning_StructFromUnitToUnit.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",tt+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(xU[(w)]==w)then
set nKe=nKe+1
set oqx=nKe
else
set oqx=xU[(w)]
set xU[(w)]=xU[xU[(w)]]
endif
set xU[oqx]=Z
set eU[oqx]=1
call Eir(oqx)
return oqx
endfunction
function Enr takes integer oqx returns boolean
set EU=EU+1
set VU[EU]=oqx
set nU[oqx]=EU+1
return(EU==0)
endfunction
function EVr takes nothing returns nothing
local integer olx=EU
local integer oqx
local integer ozx
local integer Ixx
local real jlx
local real jLx
local real cho
local real dix
local real dax
local real Mpx
loop
set oqx=VU[olx]
set ozx=OU[oqx]
set Ixx=RU[oqx]
if(ozx==w)then
set jlx=AU[oqx]
set jLx=NU[oqx]
set cho=bU[oqx]
else
set jlx=DPx(ozx)
set jLx=DQx(ozx)
set cho=Olx(ozx,jlx,jLx)+OLx(ozx,true)
endif
if(Ixx==w)then
set dix=BU[oqx]
set dax=cU[oqx]
set Mpx=CU[oqx]
else
set dix=DPx(Ixx)
set dax=DQx(Ixx)
set Mpx=Olx(Ixx,dix,dax)+K_x(Ixx,true)
endif
call cfo(IU[oqx],jlx,jLx,cho,dix,dax,Mpx)
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function EEr takes integer oqx,integer ozx,integer Ixx returns nothing
local integer rkx=oqx
local real jlx=DPx(ozx)
local real jLx=DQx(ozx)
local real dix=DPx(Ixx)
local real dax=DQx(Ixx)
call cco(rkx)
set oqx=Ear()
set IU[oqx]=rkx
set OU[oqx]=ozx
set RU[oqx]=Ixx
call cDo(rkx,vU,oqx)
call Kqx(rkx,zu)
if rtx(ozx,iU,oqx)then
call I7x(ozx,aU)
call AYo(ozx)
endif
if rtx(Ixx,iU,oqx)then
call I7x(Ixx,aU)
call AYo(Ixx)
endif
call cfo(rkx,DPx(ozx),DQx(ozx),Olx(ozx,jlx,jLx)+OLx(ozx,true),dix,dax,Olx(Ixx,dix,dax)+K_x(Ixx,true))
if Enr(oqx)then
call icx(XU,nLe,true,function EVr)
endif
endfunction
function EXr takes integer oqx returns nothing
set nNe[oqx]=false
call rgx(nae)
endfunction
function EOr takes integer oqx returns nothing
if(nAe[oqx]>0)then
return
endif
if(nRe[oqx]!=Z)then
call oYx("ChainLightning_Allocation_deallocCustom_confirm","call DebugEx(ChainLightning.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",nne+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set nRe[oqx]=nRe[(w)]
set nRe[(w)]=oqx
call EXr(oqx)
endfunction
function ERr takes integer oqx returns nothing
set nAe[oqx]=nAe[oqx]-1
call EOr(oqx)
endfunction
function EIr takes integer oqx,integer Q7o returns nothing
call ERr((oqx))
call O6x(Q7o)
endfunction
function EAr takes integer oqx,integer ENr,integer Ebr,integer Ixx,integer Q7o returns nothing
set Rd=oqx
set Id=ENr
set Ad=Ebr
set Nd=Ixx
set npe=Q7o
call TriggerEvaluate(nPe)
endfunction
function EBr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=nce[oqx]
local integer Ecr=nge[oqx]
local integer ECr=nHe[oqx]
local integer Ixx=nJe[oqx]
local integer Q7o=nhe[oqx]
local real NIo
local real dix
local real dax
local integer Edr
if(Ixx!=w)then
call RUx((Abx((Ixx),(nme),(nMe),(Bi))))
set Hf=(ze[(CMx)])
if(Eer(Ixx))then
set NIo=nCe[oqx]
set nCe[oqx]=NIo*(1.-nDe[oqx])
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
endif
endif
if(ECr==Ecr)then
call EIr(oqx,Q7o)
else
set dix=(GetUnitX(C[((Ixx))]))
set dax=(GetUnitY(C[((Ixx))]))
set nXe=Q7o
set Hf=(ze[(CMx)])
call Nio(nVe,dix,dax,nBe[oqx],nEe)
set Edr=(mjo((nVe),((dix)*1.),((dax)*1.)))
if(Edr==w)then
call EIr(oqx,Q7o)
else
set nHe[oqx]=ECr+1
call EAr(oqx,nie,Ixx,Edr,Q7o)
endif
endif
call Mdo(MFo)
return true
endfunction
function EDr takes integer oqx,integer ENr,integer Ebr,integer Ixx,integer Q7o returns nothing
local integer MFo=Mvo()
local integer clo=cBo(ENr)
set nje[oqx]=MFo
set nJe[oqx]=Ixx
call EEr(clo,Ebr,Ixx)
call GroupAddUnit(Kb[(Q7o)],C[(Ixx)])
call cko(clo,.75)
set mNv[(MFo)]=((10.)*1.)
set mCv[(MFo)]=XHx((function EBr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,iOx(jjx((GetUnitX(C[((Ixx))]))-(GetUnitX(C[((Ebr))])),(GetUnitY(C[((Ixx))]))-(GetUnitY(C[((Ebr))])))*1./ .25,700.))
call M9o(MFo,Ebr)
call M3o((MFo),(Ixx),.0,.0,.0,(null))
endfunction
function Efr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local integer oqx=Err()
local integer Q7o=O2x()
set nBe[oqx]=(Cpx((Gpv),u6v+(rwx)))
set nce[oqx]=CMx
set nCe[oqx]=nde
set nDe[oqx]=nfe
set nFe[oqx]=rwx
set nge[oqx]=nGe
set nhe[oqx]=Q7o
set nHe[oqx]=1
call EDr(oqx,nre,CMx,Ixx,Q7o)
return true
endfunction
function EFr takes nothing returns boolean
set nVe=O2x()
set nEe=XLx(function Exr)
call meo(Gpv,XBx("ChainLightning_Init: call ChainLightning.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ChainLightning.Event_SpellEffect))",ah,pI,function Efr))
return true
endfunction
function Egr takes nothing returns boolean
call Ver(function EFr,"ChainLightning_Init")
return true
endfunction
function EGr takes nothing returns boolean
set nqe=Vnx(nQe)
return true
endfunction
function Ehr takes nothing returns boolean
set nse=Vnx(nSe)
return true
endfunction
function EHr takes nothing returns boolean
set nte=Vnx(nTe)
return true
endfunction
function Ejr takes nothing returns boolean
set nue=Vnx(nUe)
return true
endfunction
function EJr takes nothing returns boolean
return true
endfunction
function Ekr takes nothing returns boolean
set nwe=Vnx(nWe)
return true
endfunction
function EKr takes nothing returns boolean
call LZx('AClv',false)
set Sdv=Lzo('AClv')
set G6[(Sdv)]=(D6)
set j6[(Sdv)]=(1)
set sH[(Sdv)]=("Cleaver")
set Ih[(Sdv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0089)))),(((Oj))))))
set x6v[(Sdv)]=(2)
set xzv[(Sdv)]=("spell")
call LZo((Sdv),fH+(1),((7)*1.))
call LZo((Sdv),QH+(1),((60)*1.))
call LZo((Sdv),Lvv+(1),((750)*1.))
set Mnv[(Sdv)]=("ReplaceableTextures\\CommandButtons\\BTNShockWave.blp")
return true
endfunction
function Elr takes nothing returns boolean
call VRx(qa,(function EKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\Cleaver.page\\Cleaver.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function ELr takes nothing returns boolean
set nye=Vnx(nYe)
return true
endfunction
function Emr takes integer oqx returns integer
set nze[oqx]=true
set nZe[oqx]=false
set n_e[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set n0e[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(nye)
return oqx
endfunction
function EMr takes integer oqx returns nothing
set n8e[(oqx)]=(n9e+oqx)
endfunction
function Epr takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((n_e[(oqx)]))])]))],((((n8e[((oqx))])))),(((oQx))))))
endfunction
function EPr takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((n_e[(oqx)]))])]))],((((n8e[((oqx))])))),(((oQx)+(okx)))))
endfunction
function Eqr takes integer oqx returns nothing
local integer rkx=oqx
local integer olx=Epr(rkx,Vee)
local integer CMx
local integer rwx
local real Vkr
local integer Q7o
local integer C0o
local integer Ixx
local real NIo
if(olx<q)then
return
endif
set CMx=n1e[rkx]
set rwx=n3e[rkx]
set Vkr=n4e[rkx]
set Q7o=n6e[rkx]
set C0o=(ze[(CMx)])
loop
set oqx=EPr(rkx,Vee,olx)
set nXe=Q7o
set Hf=C0o
call Nio(Vxe,Voe[oqx],Vre[oqx],Vie,Vae)
set Ixx=Nao(Vxe)
if(Ixx!=w)then
loop
call GroupAddUnit(Kb[(Q7o)],C[(Ixx)])
if not nIo(Ixx)then
set NIo=itx(Vne,Vkr)
set Vkr=Vkr-NIo
call nJo((CMx),(Ixx),((NIo)*1.),(false),(false))
endif
set Ixx=Nao(Vxe)
exitwhen(Ixx==w)
endloop
endif
set olx=olx-1
exitwhen(olx<q)
endloop
set n4e[rkx]=Vkr
endfunction
function EQr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
call Eqr(oqx)
endfunction
function Esr takes integer oqx returns nothing
local integer rkx=oqx
local integer olx=Epr(rkx,Vee)
local real x
local real y
if(olx<q)then
return
endif
loop
set oqx=EPr(rkx,Vee,olx)
set x=Voe[oqx]+VEe[oqx]
set y=Vre[oqx]+VXe[oqx]
set Voe[oqx]=x
set Vre[oqx]=y
call QZo(VOe[oqx],x,y)
set olx=olx-1
exitwhen(olx<q)
endloop
endfunction
function ESr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
call Esr(oqx)
endfunction
function Etr takes integer oqx returns nothing
set VNe[oqx]=false
call rgx(nwe)
endfunction
function ETr takes integer oqx returns nothing
if(VIe[oqx]>0)then
return
endif
if(VAe[oqx]!=Z)then
call oYx("FolderCleaver_StructWave_Allocation_deallocCustom_confirm","call DebugEx(FolderCleaver_StructWave.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",nWe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set VAe[oqx]=VAe[(w)]
set VAe[(w)]=oqx
call Etr(oqx)
endfunction
function Eur takes integer oqx returns nothing
set VIe[oqx]=VIe[oqx]-1
call ETr(oqx)
endfunction
function EUr takes integer oqx,integer oQx,integer oSx returns boolean
return rex(n_e[(oqx)],(n8e[((oqx))]),oQx,oSx)
endfunction
function Ewr takes integer oqx returns nothing
local integer rkx=oqx
local integer olx=Epr(rkx,Vee)
local integer HOx
if(olx<q)then
return
endif
loop
set oqx=EPr(rkx,Vee,olx)
set HOx=VOe[oqx]
call Eur((oqx))
call Mfx(HOx)
call EUr(rkx,Vee,oqx)
set olx=olx-1
exitwhen(olx<q)
endloop
endfunction
function EWr takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((n_e[oqx]))])])],((((n8e[((oqx))])))))
endfunction
function Eyr takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((n0e[oqx]))])])],((((n8e[((oqx))])))))
endfunction
function EYr takes integer oqx returns nothing
set nze[oqx]=false
call EWr((oqx))
call Eyr(((oqx)))
call rgx(nye)
endfunction
function Ezr takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local integer p0x=n2e[oqx]
local integer Q7o=n6e[oqx]
local integer Q6o=n7e[oqx]
call Ewr(oqx)
call EYr(oqx)
call ijx(ibx)
call ijx(p0x)
call O6x(Q7o)
call ijx(Q6o)
endfunction
function EZr takes integer oqx returns integer
set VNe[oqx]=true
set Vce[oqx]=false
call rax(nwe)
return oqx
endfunction
function E_r takes nothing returns integer
local integer oqx
if(Vbe==8190)then
call oYx("FolderCleaver_StructWave_Allocation_allocCustom","call DebugEx(FolderCleaver_StructWave.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",nWe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(VAe[(w)]==w)then
set VBe=VBe+1
set oqx=VBe
else
set oqx=VAe[(w)]
set VAe[(w)]=VAe[VAe[(w)]]
endif
set VAe[oqx]=Z
set VIe[oqx]=1
call EZr(oqx)
return oqx
endfunction
function E0r takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(n_e[(oqx)],(n8e[((oqx))]),oQx,oSx)
endfunction
function E1r takes integer oqx,real x,real y,real N8x returns nothing
local integer rkx=oqx
local real I_o=(Cos(((((N8x)*1.))*1.)))
local real I0o=(Sin(((((N8x)*1.))*1.)))
set oqx=E_r()
set x=x+VCe*I_o
set y=y+VCe*I0o
set VOe[oqx]=mcx('qClv',x,y,XYx(x,y),N8x)
set Vde[oqx]=rkx
set Voe[oqx]=x
set VEe[oqx]=VDe*I_o
set Vre[oqx]=y
set VXe[oqx]=VDe*I0o
call E0r(rkx,Vee,oqx)
endfunction
function E2r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local integer oqx=Emr(CMx)
local integer ibx=inx()
local integer p0x=inx()
local integer Q6o=inx()
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real dX=dix-wpo
local real dY=dax-wPo
local real N8x=UCx(CMx,dX,dY)
set n1e[oqx]=CMx
set n2e[oqx]=p0x
set n3e[oqx]=rwx
set n4e[oqx]=n5e
set n6e[oqx]=O2x()
set n7e[oqx]=Q6o
set ge[(ibx)]=(oqx)
set ge[(p0x)]=(oqx)
set ge[(Q6o)]=(oqx)
call EMr(oqx)
call icx(p0x,Vve,true,function EQr)
call icx(Q6o,VVe,true,function ESr)
call icx(ibx,VRe,false,function Ezr)
call E1r(oqx,wpo,wPo,N8x)
call E1r(oqx,wpo,wPo,N8x-b6v*1./ 3)
call E1r(oqx,wpo,wPo,N8x+b6v*1./ 3)
return true
endfunction
function E3r takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if Lko(nXe,Ixx)then
return false
endif
return true
return true
endfunction
function E4r takes nothing returns nothing
set Vxe=O2x()
set VDe=Vfe*VVe
set Vae=XLx(function E3r)
endfunction
function E5r takes nothing returns boolean
call meo(Sdv,XBx("Cleaver_Init: call Cleaver.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Cleaver.Event_SpellEffect))",ah,pI,function E2r))
call E4r()
set VRe=VFe*1./ Vfe
return true
endfunction
function E6r takes nothing returns boolean
call Ver(function E5r,"Cleaver_Init")
return true
endfunction
function E7r takes nothing returns boolean
set Vge=WTx('BCoR',"Cold Resistance",'bCoR')
set aev[(Vge)]=("ReplaceableTextures\\CommandButtons\\BTNFreezingBreath.blp")
call lux(Vge,"Abilities\\Spells\\Undead\\FrostArmor\\FrostArmorTarget.mdl","origin",ri)
set SU=lYx()
call l_x(SU,dEv,$F)
call l0x(((Vge)),vc+(1),(SU))
return true
endfunction
function E8r takes nothing returns boolean
call LZx('ACRe',false)
set GEv=Lzo('ACRe')
set G6[(GEv)]=(D6)
set j6[(GEv)]=(1)
set sH[(GEv)]=("Cold Resistance")
set xzv[(GEv)]=("spell")
call LZo((GEv),Lvv+(1),((750)*1.))
set Mnv[(GEv)]=("ReplaceableTextures\\PassiveButtons\\PASBTNFreezingBreath.blp")
return true
endfunction
function E9r takes nothing returns boolean
call VRx(Ma,(function E7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\ColdResistance.page\\ColdResistance.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function E8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\ColdResistance.page\\ColdResistance.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Xvr takes nothing returns boolean
set VGe=Vnx(Vhe)
return true
endfunction
function Xer takes nothing returns boolean
local integer rdx=(bv)
call Q8o((Vv[(rdx)]),Vge,(Mv[(rdx)]))
return true
endfunction
function Xxr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),Vge)
return true
endfunction
function Xor takes nothing returns boolean
call meo(GEv,XBx("ColdResistance_Init: call ColdResistance.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ColdResistance.Event_Learn))",pv,pI,function Xer))
call meo(GEv,XBx("ColdResistance_Init: call ColdResistance.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ColdResistance.Event_Unlearn))",Av,pI,function Xxr))
return true
endfunction
function Xrr takes nothing returns boolean
call Ver(function Xor,"ColdResistance_Init")
return true
endfunction
function Xir takes nothing returns boolean
call LZx('ADeA',false)
set SCv=Lzo('ADeA')
set G6[(SCv)]=(D6)
set j6[(SCv)]=(1)
set sH[(SCv)]=("Death Axe")
set xzv[(SCv)]=("spell")
call LZo((SCv),u6v+(1),((80)*1.))
call LZo((SCv),Lvv+(1),((750)*1.))
set Mnv[(SCv)]=("ReplaceableTextures\\CommandButtons\\BTNSpiritWalkerMasterTraining.blp")
return true
endfunction
function Xar takes nothing returns boolean
call VRx(qa,(function Xir),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\DeathAxe.page\\DeathAxe.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Xnr takes nothing returns boolean
set VHe=Vnx(Vje)
return true
endfunction
function XVr takes integer oqx returns integer
set Vme[oqx]=true
set VMe[oqx]=false
call rax(VHe)
return oqx
endfunction
function XEr takes nothing returns integer
local integer oqx
if(Vke==8190)then
call oYx("DeathAxe_Allocation_allocCustom","call DebugEx(DeathAxe.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Vje+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(VKe[(w)]==w)then
set Vle=Vle+1
set oqx=Vle
else
set oqx=VKe[(w)]
set VKe[(w)]=VKe[VKe[(w)]]
endif
set VKe[oqx]=Z
set VLe[oqx]=1
call XVr(oqx)
return oqx
endfunction
function XXr takes integer oqx returns nothing
set Vme[oqx]=false
call rgx(VHe)
endfunction
function XOr takes integer oqx returns nothing
if(VLe[oqx]>0)then
return
endif
if(VKe[oqx]!=Z)then
call oYx("DeathAxe_Allocation_deallocCustom_confirm","call DebugEx(DeathAxe.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Vje+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set VKe[oqx]=VKe[(w)]
set VKe[(w)]=oqx
call XXr(oqx)
endfunction
function XRr takes integer oqx returns nothing
set VLe[oqx]=VLe[oqx]-1
call XOr(oqx)
endfunction
function XIr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx
local real NIo
if(Ixx==w)then
call XRr((oqx))
call Mdo(MFo)
return true
endif
set CMx=Vpe[oqx]
set NIo=VPe[oqx]
call XRr((oqx))
call Mdo(MFo)
if nIo(Ixx)then
return true
endif
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
call NIx((Ixx),(rSv),(Vse[oqx]),w,((VTe)*1.))
return true
endfunction
function XAr takes nothing returns nothing
local integer OHx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(OHx)])
local integer CMx=Vpe[oqx]
local integer rwx=Vse[oqx]
local real XNr=(GetUnitX(C[((CMx))]))
local real Xbr=(GetUnitY(C[((CMx))]))
local real rmr=(Cpx((SCv),Lvv+(rwx)))
local integer Ixx
local real dix
local real dax
local real N8x
local integer MFo
local integer HOx
call ijx(OHx)
set Hf=(ze[(CMx)])
set Ixx=weo(XNr,Xbr,(Cpx((SCv),Lvv+(rwx))),Vte)
if(Ixx==w)then
call XRr((oqx))
else
set dix=(GetUnitX(C[((Ixx))]))
set dax=(GetUnitY(C[((Ixx))]))
set N8x=(Atan2(((dax-Xbr)*1.),((dix-XNr)*1.)))
set MFo=Mvo()
set HOx=Mro(MFo,'qDeA',1.5)
call m1o(MFo,500.)
set mNv[(MFo)]=(((Cpx((SCv),u6v+(rwx))))*1.)
set mCv[(MFo)]=XHx((function XIr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,350.)
call M9o(MFo,CMx)
call sao((HOx),(Vue),(VUe),(ri))
set mdv[(MFo)]=(Vwe)
call o6r(MFo,XNr+rmr*(Cos(((((N8x)*1.))*1.))),Xbr+rmr*(Sin(((((N8x)*1.))*1.))),XYx(dix,dax)+60.)
endif
call KFx(CMx)
endfunction
function XBr takes integer CMx,integer rwx returns nothing
local integer oqx=XEr()
local integer OHx=inx()
set Vpe[oqx]=CMx
set VPe[oqx]=Vqe
set VQe[oqx]=OHx
set Vse[oqx]=rwx
set ge[(OHx)]=(oqx)
call AYo(CMx)
call icx(OHx,VSe,false,function XAr)
endfunction
function Xcr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
call XBr(CMx,rwx)
return true
endfunction
function XCr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,Icv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function Xdr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
set Hf=(ze[(Vpe[oqx])])
if not XCr()then
return false
endif
return true
return true
endfunction
function XDr takes nothing returns boolean
local integer rdx=(bv)
call I7x((Vv[(rdx)]),VJe)
return true
endfunction
function Xfr takes nothing returns boolean
local integer rdx=(bv)
call Rmx((Vv[(rdx)]),VJe)
return true
endfunction
function XFr takes nothing returns boolean
set VJe=XBx("DeathAxe_Init: set DeathAxe.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DeathAxe.Event_Death)",VP,pI,function Xcr)
set Vwe=XLx(function Xdr)
set Vte=XLx(function XCr)
call meo(SCv,XBx("DeathAxe_Init: call DeathAxe.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DeathAxe.Event_Learn))",pv,pI,function XDr))
call meo(SCv,XBx("DeathAxe_Init: call DeathAxe.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DeathAxe.Event_Unlearn))",Av,pI,function Xfr))
return true
endfunction
function Xgr takes nothing returns boolean
call Ver(function XFr,"DeathAxe_Init")
return true
endfunction
function XGr takes nothing returns boolean
set VWe=WTx('BDrR',"Drum Roll",'bDrR')
set avv[(VWe)]=(true)
set aev[(VWe)]=("ReplaceableTextures\\PassiveButtons\\PASBTNDrum.blp")
call lux(VWe,"Abilities\\Spells\\Other\\GeneralAuraTarget\\GeneralAuraTarget.mdl","origin",ri)
set SU=lYx()
call l_x(SU,dgv,.2)
call l0x(((VWe)),vc+(1),(SU))
return true
endfunction
function Xhr takes nothing returns boolean
call VRx(Ma,(function XGr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\DrumRoll.page\\DrumRoll.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function XHr takes nothing returns boolean
set Vye=Vnx(VYe)
return true
endfunction
function Xjr takes nothing returns boolean
call LZx('ADrR',false)
set hEv=Lzo('ADrR')
set G6[(hEv)]=(D6)
set j6[(hEv)]=(1)
set sH[(hEv)]=("Drum Roll")
set xzv[(hEv)]=("spell")
call LZo((hEv),u6v+(1),((500)*1.))
call LZo((hEv),Lvv+(1),((750)*1.))
set Mnv[(hEv)]=("ReplaceableTextures\\PassiveButtons\\PASBTNCommand.blp")
return true
endfunction
function XJr takes nothing returns boolean
set Vze=lQx(VZe+" (dummyBuff)")
call lux(Vze,"Abilities\\Spells\\Orc\\CommandAura\\CommandAura.mdl","origin",ri)
return true
endfunction
function Xkr takes nothing returns boolean
call VRx(qa,(function Xjr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\DrumRoll.page\\DrumRoll.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function XJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\DrumRoll.page\\DrumRoll.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function XKr takes nothing returns boolean
set V_e=Vnx(VZe)
return true
endfunction
function Xlr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if not(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function XLr takes integer oqx returns integer
set V5e[oqx]=true
set V6e[oqx]=false
set V7e[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set vqe[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(vde)
return oqx
endfunction
function Xmr takes nothing returns integer
local integer oqx
if(V1e==8190)then
call oYx("Aura_Allocation_allocCustom","call DebugEx(Aura.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",vDe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(V2e[(w)]==w)then
set V3e=V3e+1
set oqx=V3e
else
set oqx=V2e[(w)]
set V2e[(w)]=V2e[V2e[(w)]]
endif
set V2e[oqx]=Z
set V4e[oqx]=1
call XLr(oqx)
return oqx
endfunction
function XMr takes integer oqx returns nothing
set vpe[(oqx)]=(V8e+oqx)
endfunction
function Xpr takes integer CMx returns integer
local integer oqx=Xmr()
call XMr(oqx)
set vme[(oqx)]=((.0)*1.)
set vhe[(oqx)]=(CMx)
set vMe[(oqx)]=(w)
set vLe[(oqx)]=(JIx("Aura_Create: call this.SetTargetGroup(UnitList.Create())"))
return oqx
endfunction
function XPr takes integer oqx,integer Xwx returns nothing
if(vqe[oqx]==w)then
call oYx("FolderAura_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oqx)+";"+(JA[(Xwx)]))
set vqe[oqx]=X
endif
call rSx(vqe[oqx],(vpe[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function Xqr takes integer oqx returns boolean
if((Ere[((oqx))])>0)then
return false
endif
set Eie=Eie+1
set Eae[Eie]=oqx
set Ere[oqx]=Eie+1
return(Eie==0)
endfunction
function XQr takes integer oqx returns nothing
if rtx(vhe[oqx],vGe,oqx)then
call I7x(vhe[oqx],vge)
call I7x(vhe[oqx],vSe)
endif
call Xqr(oqx)
call eur(oqx)
endfunction
function Xsr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer XSr=Xpr(Ixx)
set V9e[oqx]=XSr
set Eve[oqx]=rwx
set Eee[(XSr)]=(oqx)
set vme[(XSr)]=(((Cpx((hEv),u6v+(rwx))))*1.)
set vMe[(XSr)]=(V0e)
call XPr(XSr,Exe)
call XPr(XSr,Eoe)
call XQr(XSr)
return true
endfunction
function Xtr takes integer oqx returns boolean
if(((Ere[((oqx))])>0)==false)then
return false
endif
set Ere[Eae[Eie]]=Ere[oqx]
set Eae[Ere[oqx]-1]=Eae[Eie]
set Ere[oqx]=0
set Eie=Eie-1
return(Eie==F)
endfunction
function XTr takes integer oqx returns nothing
if rrx(vhe[oqx],vGe,oqx)then
call Rmx(vhe[oqx],vge)
call Rmx(vhe[oqx],vSe)
endif
call Xtr(oqx)
call eyr(oqx)
endfunction
function Xur takes integer oqx returns boolean
if((as[(oqx)])>0)then
set ns[oqx]=true
return false
endif
return true
endfunction
function XUr takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((Eb[oqx]))])])],((((Xb[((oqx))])))))
endfunction
function Xwr takes integer oqx returns nothing
set xs[oqx]=false
call XUr((oqx))
call rgx(rs)
endfunction
function XWr takes integer oqx returns nothing
if(es[oqx]>0)then
return
endif
if(ZQ[oqx]!=Z)then
call oYx("UnitList_Allocation_deallocCustom_confirm","call DebugEx(UnitList.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Rj+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set ZQ[oqx]=ZQ[(w)]
set ZQ[(w)]=oqx
call Xwr(oqx)
endfunction
function Xyr takes integer oqx returns nothing
set es[oqx]=es[oqx]-1
call XWr(oqx)
endfunction
function XYr takes integer oqx returns nothing
call dux((oqx),Rb)
if not Xur(oqx)then
return
endif
call Xyr((oqx))
endfunction
function Xzr takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((vqe[oqx]))])])],((((vpe[((oqx))])))))
endfunction
function XZr takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((V7e[oqx]))])])],((((vpe[((oqx))])))))
endfunction
function X_r takes integer oqx returns nothing
set V5e[oqx]=false
call XZr((oqx))
call Xzr(((oqx)))
call rgx(vde)
endfunction
function X0r takes integer oqx returns nothing
if(V4e[oqx]>0)then
return
endif
if(V2e[oqx]!=Z)then
call oYx("Aura_Allocation_deallocCustom_confirm","call DebugEx(Aura.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",vDe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set V2e[oqx]=V2e[(w)]
set V2e[(w)]=oqx
call X_r(oqx)
endfunction
function X1r takes integer oqx returns nothing
set V4e[oqx]=V4e[oqx]-1
call X0r(oqx)
endfunction
function X2r takes integer oqx returns nothing
local integer CMx=(vhe[(oqx)])
local integer Q7o=(vLe[(oqx)])
call XTr(oqx)
call XYr(Q7o)
call Xzr(oqx)
call X1r((oqx))
endfunction
function X3r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer XSr=V9e[oqx]
call X2r(XSr)
return true
endfunction
function X4r takes nothing returns boolean
local integer rdx=(bv)
call Q8o((Vv[(rdx)]),Vze,(Mv[(rdx)]))
return true
endfunction
function X5r takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),Vze)
return true
endfunction
function X6r takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer rkx=(Eee[(XSr)])
call UJx(Ixx,VWe)
return true
endfunction
function X7r takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer CMx=(vhe[(XSr)])
local integer rkx=(Eee[(XSr)])
local integer rwx=Eve[rkx]
call DSx((Ixx),(VWe),(rwx),w)
return true
endfunction
function X8r takes nothing returns nothing
set Exe=XBx("FolderDrumRoll_StructTarget_Init: set FolderDrumRoll_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderDrumRoll_StructTarget.Event_Ending)",vQe,pI,function X6r)
set Eoe=XBx("FolderDrumRoll_StructTarget_Init: set FolderDrumRoll_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderDrumRoll_StructTarget.Event_Start)",vse,pI,function X7r)
endfunction
function X9r takes nothing returns boolean
set V0e=XLx(function Xlr)
call l9x(Vze,XBx("DrumRoll_Init: call DrumRoll.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DrumRoll.Event_BuffGain))",Bd,pI,function Xsr))
call l9x(Vze,XBx("DrumRoll_Init: call DrumRoll.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DrumRoll.Event_BuffLose))",Jc,pI,function X3r))
call meo(hEv,XBx("DrumRoll_Init: call DrumRoll.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DrumRoll.Event_Learn))",pv,pI,function X4r))
call meo(hEv,XBx("DrumRoll_Init: call DrumRoll.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DrumRoll.Event_Unlearn))",Av,pI,function X5r))
call X8r()
return true
endfunction
function Ovr takes nothing returns boolean
call Ver(function X9r,"DrumRoll_Init")
return true
endfunction
function Oer takes nothing returns boolean
set Ene=WTx('BEnS',"Poisoned",'bEnS')
set qU[(Ene)]=(true)
set aev[(Ene)]=("ReplaceableTextures\\CommandButtons\\BTNEnvenomedSpear.blp")
call lux(Ene,"Abilities\\Weapons\\PoisonSting\\PoisonStingTarget.mdl","origin",ri)
return true
endfunction
function Oxr takes nothing returns boolean
call VRx(Ma,(function Oer),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\EnvenomedSpears.page\\EnvenomedSpears.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function Oor takes nothing returns boolean
set EVe=Vnx(EEe)
return true
endfunction
function Orr takes nothing returns boolean
set EXe=lQx(EOe+" (dummyBuff)")
return true
endfunction
function Oir takes nothing returns boolean
call LZx('AEnS',false)
set hCv=Lzo('AEnS')
set G6[(hCv)]=(D6)
set j6[(hCv)]=(1)
set sH[(hCv)]=("Envenomed Spears")
set xzv[(hCv)]=("spell")
call LZo((hCv),Lvv+(1),((750)*1.))
set Mnv[(hCv)]=("ReplaceableTextures\\PassiveButtons\\PASBTNEnvenomedSpear.blp")
return true
endfunction
function Oar takes nothing returns boolean
call VRx(Ma,(function Orr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\EnvenomedSpears.page\\EnvenomedSpears.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function Oir),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\EnvenomedSpears.page\\EnvenomedSpears.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Onr takes nothing returns boolean
set ERe=Vnx(EOe)
return true
endfunction
function OVr takes integer Ixx returns boolean
return( not(I6x(Ixx,IBv)))and( not(I6x(Ixx,ICv)))
endfunction
function OEr takes integer CMx,integer rwx,integer Ixx returns nothing
local real ilx
if I6x(Ixx,yd)then
set ilx=EAe
else
set ilx=ENe
endif
call NIx(Ixx,Ene,rwx,CMx,ilx)
endfunction
function OXr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
if not OVr(Ixx)then
return true
endif
call OEr((EYv[(rdx)]),(oPx((((EYv[(rdx)]))),N+(hCv))),Ixx)
return true
endfunction
function OOr takes nothing returns boolean
local integer rdx=(bv)
call I7x((Vv[(rdx)]),EIe)
return true
endfunction
function ORr takes nothing returns boolean
local integer rdx=(bv)
call Rmx((Vv[(rdx)]),EIe)
return true
endfunction
function OIr takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(EXe),((Mv[(rdx)])),w)
return true
endfunction
function OAr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),EXe)
return true
endfunction
function ONr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
call nJo((ECe[oqx]),(Ixx),((itx(Ede[oqx],(rG[(Ixx)])-DG))*1.),(false),(false))
endfunction
function Obr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(mc[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=inx()
set ECe[oqx]=CMx
set Ede[oqx]=Ebe
set EDe[oqx]=p0x
set ge[(p0x)]=(oqx)
call icx(p0x,Ece,true,function ONr)
return true
endfunction
function OBr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=EDe[oqx]
call ijx(p0x)
return true
endfunction
function Ocr takes nothing returns nothing
set Ebe=EBe*Ece
call l9x(Ene,XBx("FolderEnvenomedSpears_StructTarget_Init: call FolderEnvenomedSpears_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderEnvenomedSpears_StructTarget.Event_BuffGain))",Bd,pI,function Obr))
call l9x(Ene,XBx("FolderEnvenomedSpears_StructTarget_Init: call FolderEnvenomedSpears_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderEnvenomedSpears_StructTarget.Event_BuffLose))",Jc,pI,function OBr))
call W_x(XNv,Ene)
endfunction
function OCr takes nothing returns boolean
set EIe=XBx("EnvenomedSpears_Init: set EnvenomedSpears.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function EnvenomedSpears.Event_Damage)",EZv,pI,function OXr)
call l9x(EXe,XBx("EnvenomedSpears_Init: call EnvenomedSpears.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnvenomedSpears.Event_BuffGain))",Bd,pI,function OOr))
call l9x(EXe,XBx("EnvenomedSpears_Init: call EnvenomedSpears.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnvenomedSpears.Event_BuffLose))",Jc,pI,function ORr))
call meo(hCv,XBx("EnvenomedSpears_Init: call EnvenomedSpears.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnvenomedSpears.Event_Learn))",pv,pI,function OIr))
call meo(hCv,XBx("EnvenomedSpears_Init: call EnvenomedSpears.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnvenomedSpears.Event_Unlearn))",Av,pI,function OAr))
call Ocr()
return true
endfunction
function Odr takes nothing returns boolean
call Ver(function OCr,"EnvenomedSpears_Init")
return true
endfunction
function ODr takes nothing returns boolean
set Efe=Vnx(EFe)
return true
endfunction
function Ofr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(LoadInteger(o[((V[(E[((X))])]))],(((OK+(((av[(rdx)])))))),(((IK)))))
local integer Ixx
if I6x(CMx,sc)then
return true
endif
set Hf=(ze[(CMx)])
set Ixx=oXr((GetUnitX(C[((CMx))])),(GetUnitY(C[((CMx))])),500.,Ege)
if(Ixx!=w)then
call Lvx((CMx),(Ih[((Scv))]),(Ixx))
endif
return true
endfunction
function OFr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function Ogr takes nothing returns boolean
local integer Fmx=x0r(Scv,function Ofr)
set Ege=XLx(function OFr)
call x3r(Fmx,dsv,jI,w)
return true
endfunction
function OGr takes nothing returns boolean
call e1r(function Ogr,"AIKnockout_Init")
return true
endfunction
function Ohr takes nothing returns boolean
set EGe=WTx('BKnO',"Knockout",'bKnO')
set avv[(EGe)]=(true)
set aev[(EGe)]=("ReplaceableTextures\\CommandButtons\\BTNEntanglingRoots.blp")
return true
endfunction
function OHr takes nothing returns boolean
call VRx(Ma,(function Ohr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\Knockout.page\\Knockout.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function Ojr takes nothing returns boolean
set Ehe=Vnx(EHe)
return true
endfunction
function OJr takes nothing returns boolean
call LZx('AKno',false)
set Scv=Lzo('AKno')
set G6[(Scv)]=(D6)
set j6[(Scv)]=(1)
set sH[(Scv)]=("Knockout")
set Ih[(Scv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D007F)))),(((Oj))))))
set x6v[(Scv)]=(4)
set xzv[(Scv)]=("spell")
call LZo((Scv),fH+(1),(($C)*1.))
call LZo((Scv),QH+(1),((80)*1.))
call LZo((Scv),Lvv+(1),((700)*1.))
set Mnv[(Scv)]=("ReplaceableTextures\\CommandButtons\\BTNSeaGiantPulverize.blp")
return true
endfunction
function Okr takes nothing returns boolean
call VRx(qa,(function OJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\Knockout.page\\Knockout.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function OKr takes nothing returns boolean
set Eje=Vnx(EJe)
return true
endfunction
function Olr takes integer oqx returns integer
set Eke[oqx]=true
set EKe[oqx]=false
call rax(Eje)
return oqx
endfunction
function OLr takes integer oqx,integer Ixx returns nothing
local real dix=DPx(Ixx)
local real dax=DQx(Ixx)
local real Omr=DPx((oqx))
local real OMr=DQx((oqx))
if((dix!=Omr)or(dax!=OMr))then
call SetUnitFacing(C[((oqx))],(((Atan2(((dax-OMr)*1.),((dix-Omr)*1.))))*1.)*gy)
endif
endfunction
function Opr takes integer oqx returns nothing
set Eke[oqx]=false
call rgx(Eje)
endfunction
function OPr takes integer CMx,integer Ixx returns boolean
return( not(Ixx==w))and( not(IsUnitAlly(C[(Ixx)],vx[((ze[(CMx)]))])))and( not(nIo(Ixx)))
endfunction
function Oqr takes integer oqx,real N2x,real N3x,real cRx,real cao,real cno,real cVo,real ilx returns nothing
local integer rkx=oqx
local integer ibx
set oqx=B1o()
set ibx=inx()
set Cov[oqx]=ibx
set Crv[oqx]=rkx
set Civ[oqx]=N2x
set Cav[oqx]=cao
set Cnv[oqx]=N3x
set CVv[oqx]=cno
set CEv[oqx]=cRx
set CXv[oqx]=cVo
set ge[(ibx)]=(oqx)
if rtx(rkx,COv,oqx)then
call I7x(rkx,CRv)
call I7x(rkx,CIv)
endif
if B2o(oqx)then
call icx(CBv,c6v,true,function B7o)
endif
call icx(ibx,ilx,false,function cro)
endfunction
function OQr takes integer oqx,real N2x,real N3x,real cRx,real cao,real cno,real cVo,real ilx returns nothing
if B_o(oqx)then
call Oqr(oqx,N2x,N3x,cRx,cao,cno,cVo,ilx)
endif
endfunction
function Osr takes integer oqx,real NJx,real Nkx,real N8x,real ilx returns nothing
local real I_o=(Cos(((((N8x)*1.))*1.)))
local real I0o=(Sin(((((N8x)*1.))*1.)))
set Nkx=Nkx*c6v*c6v
set NJx=NJx*c6v
call OQr(oqx,NJx*I_o,NJx*I0o,.0,Nkx*I_o,Nkx*I0o,.0,ilx)
endfunction
function OSr takes integer oqx,real NJx,real Nkx,real N8x,real ilx returns nothing
call NIx(((((oqx)))),(x_v),(1),w,((((ilx)*1.))*1.))
call Osr(oqx,NJx,Nkx,N8x,ilx)
endfunction
function Otr takes integer CMx,integer rwx,integer Ixx returns nothing
if not(oPx((((Ixx))),(yb+(EGe)))>0)then
call NIx((Ixx),(EGe),(rwx),w,((EMe)*1.))
endif
call OSr(Ixx,900.,-900.,(Atan2((((GetUnitY(C[((Ixx))]))-(GetUnitY(C[((CMx))])))*1.),(((GetUnitX(C[((Ixx))]))-(GetUnitX(C[((CMx))])))*1.))),.14)
call nJo((CMx),(Ixx),((Epe)*1.),(true),(false))
endfunction
function OTr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=Ele[oqx]
local integer rwx=ELe[oqx]
local integer Ixx=Eme[oqx]
call Opr(oqx)
call Mdo(MFo)
if(Ixx==w)then
return true
endif
if OPr(CMx,Ixx)then
call Otr(CMx,rwx,Ixx)
endif
return true
endfunction
function Our takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer MFo=Mvo()
local integer oqx=Olr(MFo)
set Ele[oqx]=CMx
set ELe[oqx]=rwx
set Eme[oqx]=Ixx
call SetUnitPosition(C[((CMx))],(((GetUnitX(C[((Ixx))])))*1.),(((GetUnitY(C[((Ixx))])))*1.))
call OLr(CMx,Ixx)
set mNv[(MFo)]=((10.)*1.)
call Mro(MFo,'qKnO',2.)
set mCv[(MFo)]=XHx((function OTr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,700.)
call M9o(MFo,CMx)
call M3o((MFo),(Ixx),.0,.0,.0,(null))
return true
endfunction
function OUr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call NIx((Ixx),(Xsv),(rwx),w,((EPe)*1.))
return true
endfunction
function Owr takes nothing returns boolean
call meo(Scv,XBx("Knockout_Init: call Knockout.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Knockout.Event_SpellEffect))",ah,pI,function Our))
call l9x(EGe,XBx("FolderKnockout_StructTarget_Init: call FolderKnockout_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderKnockout_StructTarget.Event_BuffGain))",Bd,pI,function OUr))
return true
endfunction
function OWr takes nothing returns boolean
call Ver(function Owr,"Knockout_Init")
return true
endfunction
function Oyr takes nothing returns boolean
set Eqe=Vnx(EQe)
return true
endfunction
function OYr takes nothing returns boolean
local integer rdx=(bv)
call O9x(((LoadInteger(o[((V[(E[((X))])]))],(((OK+(((av[(rdx)])))))),(((IK)))))),(Ih[((SGv))]))
return true
endfunction
function Ozr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(LoadInteger(o[((V[(E[((X))])]))],(((OK+(((av[(rdx)])))))),(((IK)))))
if((rG[(CMx)])>=(R2I((((NJv[(GVv)])-Ese)*1.))))then
return false
endif
return true
return true
endfunction
function OZr takes nothing returns boolean
local integer Fmx=x0r(SGv,function OYr)
call xqr(Fmx,hG,(R2I((((NJv[(GVv)])-Ese)*1.))),LESS_THAN,XLx(function Ozr))
return true
endfunction
function O_r takes nothing returns boolean
call e1r(function OZr,"AIMedipack_Init")
return true
endfunction
function O0r takes nothing returns boolean
call LZx('AMeP',false)
set SGv=Lzo('AMeP')
set G6[(SGv)]=(D6)
set j6[(SGv)]=(1)
set sH[(SGv)]=("Medipack")
set Ih[(SGv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Oj))))))
set x6v[(SGv)]=(0)
set xzv[(SGv)]=("spell")
call LZo((SGv),fH+(1),(($F)*1.))
call LZo((SGv),QH+(1),((25)*1.))
call LZo((SGv),Lvv+(1),((750)*1.))
set Mnv[(SGv)]=("ReplaceableTextures\\CommandButtons\\BTNManual.blp")
return true
endfunction
function O1r takes nothing returns boolean
call VRx(qa,(function O0r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\Medipack.page\\Medipack.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function O2r takes nothing returns boolean
set ESe=Vnx(Ete)
return true
endfunction
function O3r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
call RUx((Abx((CMx),(ETe),(Eue),(ri))))
call wbo(CMx,true,false,true)
call moo(CMx,CMx,Ese)
return true
endfunction
function O4r takes nothing returns boolean
call meo(SGv,XBx("Medipack_Init: call Medipack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Medipack.Event_SpellEffect))",ah,pI,function O3r))
return true
endfunction
function O5r takes nothing returns boolean
call Ver(function O4r,"Medipack_Init")
return true
endfunction
function O6r takes nothing returns boolean
set EUe=lQx(Ewe+" (silenceBuff)")
set qc[(EUe)]=(true)
set qU[(EUe)]=(true)
return true
endfunction
function O7r takes nothing returns boolean
call LZx('AMuS',false)
set Shv=Lzo('AMuS')
set G6[(Shv)]=(D6)
set j6[(Shv)]=(1)
set sH[(Shv)]=("Muting Shout")
set Ih[(Shv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00C4)))),(((Oj))))))
set x6v[(Shv)]=(0)
set xzv[(Shv)]=("spell")
call LZo((Shv),u6v+(1),((550)*1.))
call LZo((Shv),fH+(1),(($F)*1.))
call LZo((Shv),QH+(1),((30)*1.))
call LZo((Shv),Lvv+(1),((750)*1.))
set Mnv[(Shv)]=("ReplaceableTextures\\CommandButtons\\BTNBattleRoar.blp")
return true
endfunction
function O8r takes nothing returns boolean
call VRx(Ma,(function O6r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\MutingShout.page\\MutingShout.struct\\obj_silenceBuff_wc3buff.j"))
call VRx(qa,(function O7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\MutingShout.page\\MutingShout.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function O9r takes nothing returns boolean
set EWe=Vnx(Ewe)
return true
endfunction
function Rvr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function Rer takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local integer Ixx
local integer ECr
call mFo((mHo(((wpo)*1.),((wPo)*1.),(Eze),(ri))))
set Hf=(ze[(CMx)])
call Nio(Eye,wpo,wPo,(Cpx((Shv),u6v+(rwx))),EYe)
set Ixx=Nao(Eye)
set ECr=0
if(Ixx!=w)then
loop
set ECr=ECr+1
call NIx((Ixx),(EUe),(rwx),w,((EZe)*1.))
set Ixx=Nao(Eye)
exitwhen(Ixx==w)
endloop
endif
call moo(CMx,CMx,E_e*(iG[(CMx)])*ECr)
return true
endfunction
function Rxr takes nothing returns boolean
set Eye=O2x()
set EYe=XLx(function Rvr)
call meo(Shv,XBx("MutingShout_Init: call MutingShout.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MutingShout.Event_SpellEffect))",ah,pI,function Rer))
call W_x(Xhv,EUe)
return true
endfunction
function Ror takes nothing returns boolean
call Ver(function Rxr,"MutingShout_Init")
return true
endfunction
function Rrr takes nothing returns boolean
call LZx('AReP',false)
set GIv=Lzo('AReP')
set G6[(GIv)]=(D6)
set j6[(GIv)]=(1)
set sH[(GIv)]=("Realplex")
set Ih[(GIv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D009B)))),(((Oj))))))
set x6v[(GIv)]=(0)
set xzv[(GIv)]=("spell")
call LZo((GIv),fH+(1),(($A)*1.))
call LZo((GIv),QH+(1),((50)*1.))
call LZo((GIv),Lvv+(1),((750)*1.))
set Mnv[(GIv)]=("ReplaceableTextures\\CommandButtons\\BTNInvisibility.blp")
return true
endfunction
function Rir takes nothing returns boolean
call VRx(qa,(function Rrr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\Realplex.page\\Realplex.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Rar takes nothing returns boolean
set E0e=Vnx(E1e)
return true
endfunction
function Rnr takes integer oqx returns nothing
set E7e[oqx]=false
call rgx(E0e)
endfunction
function RVr takes integer oqx returns nothing
if(E5e[oqx]>0)then
return
endif
if(E6e[oqx]!=Z)then
call oYx("Realplex_Allocation_deallocCustom_confirm","call DebugEx(Realplex.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",E1e+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set E6e[oqx]=E6e[(w)]
set E6e[(w)]=oqx
call Rnr(oqx)
endfunction
function REr takes integer oqx returns nothing
set E5e[oqx]=E5e[oqx]-1
call RVr(oqx)
endfunction
function RXr takes integer oqx returns nothing
set BJv=true
call Cex((oqx),w)
endfunction
function ROr takes integer oqx,integer CMx,integer RRr returns nothing
local integer ibx=E4e[oqx]
local integer RIr
call REr((oqx))
call ijx(ibx)
call rix(CMx,E3e)
call Rmx(CMx,E2e)
loop
set RIr=(Otx((RRr),Rb))
exitwhen(RIr==w)
call RXr(RIr)
endloop
call XYr(RRr)
endfunction
function RAr takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=oPx((Vv[(rdx)]),E3e)
call ROr(oqx,E8e[oqx],E9e[oqx])
return true
endfunction
function RNr takes integer oqx,integer RIr,integer RRr returns nothing
call rix(RIr,E3e)
call Rmx(RIr,Xee)
call IEo(RRr,RIr)
endfunction
function Rbr takes nothing returns boolean
local integer rdx=(bv)
local integer RIr=(Vv[(rdx)])
local integer oqx=oPx(RIr,E3e)
local integer RRr=E9e[oqx]
call RNr(oqx,RIr,RRr)
return true
endfunction
function RBr takes integer oqx returns integer
set E7e[oqx]=true
set Xne[oqx]=false
call rax(E0e)
return oqx
endfunction
function Rcr takes nothing returns integer
local integer oqx
if(Xie==8190)then
call oYx("Realplex_Allocation_allocCustom","call DebugEx(Realplex.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",E1e+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(E6e[(w)]==w)then
set Xae=Xae+1
set oqx=Xae
else
set oqx=E6e[(w)]
set E6e[(w)]=E6e[E6e[(w)]]
endif
set E6e[oqx]=Z
set E5e[oqx]=1
call RBr(oqx)
return oqx
endfunction
function RCr takes integer oqx returns integer
set c0v[oqx]=true
set XOe[oqx]=false
call rax(O7v)
return oqx
endfunction
function Rdr takes nothing returns integer
local integer oqx
if(XEe==8190)then
call oYx("FolderUnit_FolderPosition_StructTimed_Allocation_allocCustom","call DebugEx(FolderUnit_FolderPosition_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",O8v+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(c_v[(w)]==w)then
set XXe=XXe+1
set oqx=XXe
else
set oqx=c_v[(w)]
set c_v[(w)]=c_v[c_v[(w)]]
endif
set c_v[oqx]=Z
set cZv[oqx]=1
call RCr(oqx)
return oqx
endfunction
function RDr takes integer oqx returns boolean
set c4v=c4v+1
set c3v[c4v]=oqx
set c2v[oqx]=c4v+1
return(c4v==0)
endfunction
function Rfr takes nothing returns nothing
local integer olx=c4v
local integer oqx
local integer rkx
loop
set oqx=c3v[olx]
set rkx=XRe[oqx]
call B3o(rkx,XIe[oqx])
call B4o(rkx,XAe[oqx])
call B6o(rkx,XNe[oqx])
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function RFr takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
call cmo(oqx,ibx,XRe[oqx])
endfunction
function Rgr takes integer oqx,real N2x,real N3x,real cRx,real ilx returns nothing
local integer rkx=oqx
local integer D8x=(R2I(((ilx*1./ XVe)*1.)))
local integer ibx
set oqx=Rdr()
set ibx=inx()
set CQv[oqx]=ibx
set XRe[oqx]=rkx
set XIe[oqx]=N2x*1./ D8x
set XAe[oqx]=N3x*1./ D8x
set XNe[oqx]=cRx*1./ D8x
set ge[(ibx)]=(oqx)
if rtx(rkx,czv,oqx)then
call I7x(rkx,cYv)
call I7x(rkx,c1v)
endif
if RDr(oqx)then
call icx(c5v,XVe,true,function Rfr)
endif
call icx(ibx,ilx,false,function RFr)
endfunction
function RGr takes integer oqx,real N2x,real N3x,real cRx,real ilx returns nothing
if not B_o(oqx)then
return
endif
call Rgr(oqx,N2x,N3x,cRx,ilx)
endfunction
function Rhr takes integer oqx,real x,real y,real z,real ilx returns nothing
call RGr(oqx,x-DPx((oqx)),y-DQx((oqx)),z-fwx((oqx)),ilx)
endfunction
function RHr takes integer oqx returns real
return GetUnitFlyHeight(C[(oqx)])
endfunction
function Rjr takes integer oqx,real x,real y,real ilx returns nothing
call Rhr(oqx,x,y,XYx(x,y)+RHr((oqx)),ilx)
endfunction
function RJr takes integer oqx,real oSx returns nothing
set Avv[oqx]=oSx
call OKo((oqx))
endfunction
function Rkr takes integer oqx,real oSx returns nothing
call RJr(oqx,(Avv[(oqx)])+oSx)
endfunction
function RKr takes integer oqx returns nothing
local integer olx=(CXx((((oqx))),Q))
loop
exitwhen(olx<q)
call rLx((oqx),(COx((((oqx))),Q,(olx))))
set olx=olx-1
endloop
call Roo(oqx,Ibv)
endfunction
function Rlr takes integer oqx,real oSx returns nothing
set Ug[oqx]=oSx
call B8x((oqx))
endfunction
function RLr takes integer oqx,real oSx returns nothing
call Rlr(oqx,(Ug[(oqx)])+oSx)
endfunction
function Rmr takes integer oqx,integer oQx returns boolean
return(LoadBoolean(o[((V[(E[((cb[(oqx)]))])]))],((((Cb[((oqx))])))),(((oQx)))))
endfunction
function RMr takes integer oqx,integer oQx returns boolean
return(Rmr(oqx,oQx)!=false)
endfunction
function Rpr takes integer oqx,integer oQx,boolean oSx returns nothing
call SaveBoolean(o[((V[(E[((cb[(oqx)]))])]))],((((Cb[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function RPr takes integer oqx,integer oQx returns boolean
local boolean abx=Rmr(oqx,oQx)
call Rpr(oqx,oQx,not false)
return(abx==false)
endfunction
function Rqr takes integer oqx,integer oQx,real oSx returns nothing
call SaveReal(o[((V[(E[((I[(oqx)]))])]))],((((A[((oqx))])))),(((oQx))),((((((oSx)*1.))*1.))*1.))
endfunction
function RQr takes integer oqx,real iWx,real iyx,real iYx,real izx,integer ocx returns nothing
if not RMr(ocx,cDv)then
call RPr(ocx,cDv)
if rtx((oqx),cdv,ocx)then
call I7x((oqx),cCv)
endif
endif
call Rqr((oqx),rk+ocx,iWx)
call Rqr((oqx),ik+ocx,iyx)
call Rqr((oqx),ak+ocx,iYx)
call Rqr((oqx),nk+ocx,izx)
call SetUnitVertexColor(C[(oqx)],(R2I((((zJ[(oqx)])+iWx)*1.))),(R2I((((ZJ[(oqx)])+iyx)*1.))),(R2I((((vk[(oqx)])+iYx)*1.))),(R2I((((ek[(oqx)])+izx)*1.))))
endfunction
function Rsr takes integer oqx,real iWx,real iyx,real iYx,real izx,integer ocx returns nothing
call RQr(oqx,(fgx(((oqx)),rk+(ocx)))+iWx,(fgx(((oqx)),ik+(ocx)))+iyx,(fgx(((oqx)),ak+(ocx)))+iYx,(fgx(((oqx)),nk+(ocx)))+izx,ocx)
endfunction
function RSr takes integer rRx,integer ocx,real x,real y,real N8x,real ilx,string Rtr returns integer
local integer oqx
set BXv=false
set oqx=bVx(rRx,ocx,x,y,N8x)
set BXv=true
call Rkr(oqx,-.5)
call RKr(oqx)
call RLr(oqx,-1.)
call Rsr(oqx,-191.,-191.,.0,.0,ocx)
call UYo(oqx,ilx)
set AMv[(oqx)]=(Rtr)
call AVo(oqx)
return oqx
endfunction
function RTr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer RRr=E9e[oqx]
local integer RIr
loop
set RIr=(dLx((RRr),Rb))
exitwhen(RIr==w)
call GroupAddUnit(Kb[(Xve)],C[(RIr)])
call UJx(((RIr)),XVv)
endloop
call UJx(((E8e[oqx])),XVv)
loop
set RIr=Nao(Xve)
exitwhen(RIr==w)
call dpx(RRr,RIr)
call UJx(((RIr)),XVv)
call PauseUnit(C[RIr],false)
endloop
endfunction
function Rur takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real RUr=(GetUnitFacing(C[((CMx))])*bh)
local integer C0o=(ze[(CMx)])
local integer Rwr=(uf[(CMx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local integer oqx=oPx(CMx,E3e)
local real N8x=RUr-b6v
local real N2x=Xxe*(Cos(((((N8x)*1.))*1.)))
local real N3x=Xxe*(Sin(((((N8x)*1.))*1.)))
local real x=wpo-Xoe*1./ 2*N2x
local real y=wPo-Xoe*1./ 2*N3x
local integer ibx
local integer RRr
local integer olx
local integer oVr
local integer RIr
call mFo((mHo(((wpo)*1.),((wPo)*1.),(Xre),(ri))))
if(oqx!=w)then
call ROr(oqx,CMx,E9e[oqx])
endif
set oqx=Rcr()
set ibx=inx()
set RRr=JIx("Realplex_Event_SpellEffect: set illusionGroup = UnitList.Create()")
set E8e[oqx]=CMx
set E4e[oqx]=ibx
set E9e[oqx]=RRr
call rTx(CMx,E3e,oqx)
call I7x(CMx,E2e)
set ge[(ibx)]=(oqx)
call DSx((((CMx))),(XVv),(1),w)
set olx=Xoe+1
set oVr=(GetRandomInt((1),(Xoe)))
loop
exitwhen(olx<1)
if(olx==oVr)then
call Rjr(CMx,x,y,Xbe)
else
set RIr=RSr(Rwr,C0o,wpo,wPo,RUr,XBe,Xce)
call RLr(RIr,.5)
call rTx(RIr,E3e,oqx)
call I7x(RIr,Xee)
call DSx((((RIr))),(XVv),(1),w)
call dpx(RRr,RIr)
call PauseUnit(C[RIr],true)
call fTx(RIr,wpo)
call fux(RIr,wPo)
call Rjr(RIr,x,y,Xbe)
endif
set olx=olx-1
set x=x+N2x
set y=y+N3x
endloop
call icx(ibx,Xbe,false,function RTr)
return true
endfunction
function RWr takes nothing returns boolean
set E2e=XBx("Realplex_Init: set Realplex.CASTER_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Realplex.Event_Caster_Death)",VP,pI,function RAr)
set Xve=O2x()
set Xee=XBx("Realplex_Init: set Realplex.ILLUSION_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Realplex.Event_Illusion_Death)",VP,pI,function Rbr)
call meo(GIv,XBx("Realplex_Init: call Realplex.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Realplex.Event_SpellEffect))",ah,pI,function Rur))
return true
endfunction
function Ryr takes nothing returns boolean
call Ver(function RWr,"Realplex_Init")
return true
endfunction
function RYr takes nothing returns boolean
call LZx('ASeW',false)
set Gkv=Lzo('ASeW')
set G6[(Gkv)]=(D6)
set j6[(Gkv)]=(1)
set sH[(Gkv)]=("Serpent Ward")
set Ih[(Gkv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0218)))),(((Oj))))))
set x6v[(Gkv)]=(2)
set xzv[(Gkv)]=("spell")
call LZo((Gkv),fH+(1),(($F)*1.))
call LZo((Gkv),QH+(1),((55)*1.))
call LZo((Gkv),Lvv+(1),((550)*1.))
set Mnv[(Gkv)]=("ReplaceableTextures\\CommandButtons\\BTNSerpentWard.blp")
return true
endfunction
function Rzr takes nothing returns boolean
set XCe=hGo('uSeW')
call hho(((XCe)),Apv,(INv))
set Tj[(XCe)]=((1)*1.)
set Nav[(XCe)]=((60)*1.)
set Ntv[(XCe)]=(($E1)*1.)
set I3v[(XCe)]=((0)*1.)
set Axv[(XCe)]=(2)
set NJv[(XCe)]=(('d')*1.)
set Njv[(XCe)]=(('d')*1.)
set Nhv[(XCe)]=((0)*1.)
set NIv[(XCe)]=(($4B0)*1.)
set NOv[(XCe)]=(($4B0)*1.)
set Ndv[(XCe)]=((35)*1.)
set ANv[(XCe)]=(gSv)
set Adv[(XCe)]=((720)*1.)
set ADv[((XCe))]=((1.*1./((1.5)*1.))*1.)
set Atv[(XCe)]=((.3)*1.)
set Drv[(XCe)]=((900)*1.)
set AQv[(XCe)]=(($C)*1.)
set Asv[(XCe)]=(($C)*1.)
set Auv[(XCe)]=(1)
set AWv[(XCe)]=(3)
set Azv[(XCe)]=(1)
set Aqv[(XCe)]=((16)*1.)
return true
endfunction
function RZr takes nothing returns boolean
call VRx(qa,(function RYr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\SerpentWard.page\\SerpentWard.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Sa,(function Rzr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\SerpentWard.page\\SerpentWard.struct\\obj_summonUnitType_wc3unit.j"))
return true
endfunction
function R_r takes nothing returns boolean
set Xde=Vnx(XDe)
return true
endfunction
function R0r takes integer oqx returns integer
set Xhe[oqx]=true
set XHe[oqx]=false
call rax(Xde)
return oqx
endfunction
function R1r takes nothing returns integer
local integer oqx
if(Xfe==8190)then
call oYx("SerpentWard_Allocation_allocCustom","call DebugEx(SerpentWard.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",XDe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(XFe[(w)]==w)then
set Xge=Xge+1
set oqx=Xge
else
set oqx=XFe[(w)]
set XFe[(w)]=XFe[XFe[(w)]]
endif
set XFe[oqx]=Z
set XGe[oqx]=1
call R0r(oqx)
return oqx
endfunction
function R2r takes integer oqx returns nothing
set Xhe[oqx]=false
call rgx(Xde)
endfunction
function R3r takes integer oqx returns nothing
if(XGe[oqx]>0)then
return
endif
if(XFe[oqx]!=Z)then
call oYx("SerpentWard_Allocation_deallocCustom_confirm","call DebugEx(SerpentWard.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",XDe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set XFe[oqx]=XFe[(w)]
set XFe[(w)]=oqx
call R2r(oqx)
endfunction
function R4r takes integer oqx returns nothing
set XGe[oqx]=XGe[oqx]-1
call R3r(oqx)
endfunction
function R5r takes integer CMx,real dix,real dax returns nothing
local integer C0o=(ze[(CMx)])
local integer olx=XKe
loop
call Uzo(XCe,C0o,dix,dax,Kf,Xle)
set olx=olx-1
exitwhen(olx<1)
endloop
endfunction
function R6r takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=Xje[oqx]
local real dix=XJe[oqx]
local real dax=Xke[oqx]
call R4r((oqx))
call Mdo(MFo)
call R5r(CMx,dix,dax)
return true
endfunction
function R7r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local integer oqx=R1r()
local integer MFo=Mvo()
set Xje[oqx]=CMx
set XJe[oqx]=dix
set Xke[oqx]=dax
set mAv[((MFo))]=((b6v*((.1)*1.))*1.)
set mNv[(MFo)]=((10.)*1.)
call Mro(MFo,'qSeW',2.)
set mCv[(MFo)]=XHx((function R6r))
set mWv[(MFo)]=(oqx)
call m8o(MFo,900.)
call M9o(MFo,CMx)
call o6r(MFo,dix,dax,XYx(dix,dax))
return true
endfunction
function R8r takes nothing returns boolean
call meo(Gkv,XBx("SerpentWard_Init: call SerpentWard.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SerpentWard.Event_SpellEffect))",ah,pI,function R7r))
return true
endfunction
function R9r takes nothing returns boolean
call Ver(function R8r,"SerpentWard_Init")
return true
endfunction
function Ivr takes nothing returns boolean
set XLe=hGo('uSpW')
call hho(((XLe)),Apv,(INv))
set Tj[(XLe)]=((1.25)*1.)
set Nav[(XLe)]=((49.586776859504)*1.)
set Ntv[(XLe)]=((49.586776859504)*1.)
set I3v[(XLe)]=((0)*1.)
set Axv[(XLe)]=(2)
set NJv[(XLe)]=((300)*1.)
set Njv[(XLe)]=((300)*1.)
set Nhv[(XLe)]=((0)*1.)
set NIv[(XLe)]=(($4B0)*1.)
set NOv[(XLe)]=(($4B0)*1.)
set Ndv[(XLe)]=((45)*1.)
set ANv[(XLe)]=(gHv)
set Adv[(XLe)]=(('l')*1.)
set ADv[((XLe))]=((1.*1./((1)*1.))*1.)
set Atv[(XLe)]=((.33)*1.)
set AQv[(XLe)]=(($F)*1.)
set Asv[(XLe)]=(($F)*1.)
set Auv[(XLe)]=(1)
set AWv[(XLe)]=(2)
set Azv[(XLe)]=(0)
set Aqv[(XLe)]=((26.446280991736)*1.)
return true
endfunction
function Ier takes nothing returns boolean
call LZx('ASpW',false)
set GPv=Lzo('ASpW')
set G6[(GPv)]=(D6)
set j6[(GPv)]=(1)
set sH[(GPv)]=("Spirit Wolves")
set Ih[(GPv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D009E)))),(((Oj))))))
set x6v[(GPv)]=(0)
set xzv[(GPv)]=("spell")
call LZo((GPv),fH+(1),((22)*1.))
call LZo((GPv),QH+(1),(('}')*1.))
call LZo((GPv),Lvv+(1),((750)*1.))
set Mnv[(GPv)]=("ReplaceableTextures\\CommandButtons\\BTNSpiritWolf.blp")
return true
endfunction
function Ixr takes nothing returns boolean
call VRx(Sa,(function Ivr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\SpiritWolves.page\\SpiritWolves.struct\\obj_summonUnitType_wc3unit.j"))
call VRx(qa,(function Ier),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\SpiritWolves.page\\SpiritWolves.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Ior takes nothing returns boolean
set Xme=Vnx(XMe)
return true
endfunction
function Irr takes integer oqx returns nothing
set XTe[oqx]=false
call rgx(Xme)
endfunction
function Iir takes integer oqx returns nothing
if(XSe[oqx]>0)then
return
endif
if(Xte[oqx]!=Z)then
call oYx("SpiritWolves_Allocation_deallocCustom_confirm","call DebugEx(SpiritWolves.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",XMe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set Xte[oqx]=Xte[(w)]
set Xte[(w)]=oqx
call Irr(oqx)
endfunction
function Iar takes integer oqx returns nothing
set XSe[oqx]=XSe[oqx]-1
call Iir(oqx)
endfunction
function Inr takes nothing returns boolean
local integer rdx=(bv)
local integer IVr=(Vv[(rdx)])
local integer oqx=oPx(IVr,XPe)
local integer IEr=Xqe[oqx]
local integer CMx
local integer CQx
call rix(IVr,XPe)
call Rmx(IVr,Xpe)
call IEo(IEr,IVr)
if(dKx((IEr),Rb))then
set CMx=XQe[oqx]
set CQx=Xse[oqx]
call Iar((oqx))
call rix(CMx,XPe)
call XYr(IEr)
call dRx(CQx)
endif
return true
endfunction
function IXr takes integer oqx returns nothing
set as[oqx]=(as[(oqx)])+1
endfunction
function IOr takes integer oqx returns nothing
local integer oSx=(as[(oqx)])-1
set as[oqx]=oSx
if((oSx==0)and ns[oqx])then
call XYr((oqx))
endif
endfunction
function IRr takes integer oqx returns nothing
local integer IEr=Xqe[oqx]
local integer IVr=(Otx((IEr),Rb))
call IXr(IEr)
loop
call Cex((IVr),w)
set IVr=(Otx((IEr),Rb))
exitwhen(IVr==w)
endloop
call IOr(IEr)
endfunction
function IIr takes integer oqx returns integer
set XTe[oqx]=true
set XWe[oqx]=false
call rax(Xme)
return oqx
endfunction
function IAr takes nothing returns integer
local integer oqx
if(XUe==8190)then
call oYx("SpiritWolves_Allocation_allocCustom","call DebugEx(SpiritWolves.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",XMe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Xte[(w)]==w)then
set Xwe=Xwe+1
set oqx=Xwe
else
set oqx=Xte[(w)]
set Xte[(w)]=Xte[Xte[(w)]]
endif
set Xte[oqx]=Z
set XSe[oqx]=1
call IIr(oqx)
return oqx
endfunction
function INr takes integer oqx,integer C0o,real wpo,real wPo,real N8x,integer IEr returns integer
local integer IVr=Uzo(XLe,C0o,wpo,wPo,N8x,XYe)
call rTx(IVr,XPe,oqx)
call I7x(IVr,Xpe)
call dpx(IEr,IVr)
return IVr
endfunction
function Ibr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer oqx=oPx(CMx,XPe)
local integer olx
local integer IEr
local real N8x
local integer C0o
local real wpo
local real wPo
local integer IVr
if(oqx!=w)then
call IRr(oqx)
endif
set olx=Xue
if(olx>0)then
set oqx=IAr()
set IEr=JIx("SpiritWolves_Event_SpellEffect: set summonGroup = UnitList.Create()")
set XQe[oqx]=CMx
set Xqe[oqx]=IEr
set Xse[oqx]=Cmx(CMx,GPv)
call rTx(CMx,XPe,oqx)
set N8x=(GetUnitFacing(C[((CMx))])*bh)
set C0o=(ze[(CMx)])
set wpo=(GetUnitX(C[((CMx))]))+Xye*(Cos(((((N8x)*1.))*1.)))
set wPo=(GetUnitY(C[((CMx))]))+Xye*(Sin(((((N8x)*1.))*1.)))
loop
set IVr=INr(oqx,C0o,wpo,wPo,N8x,IEr)
set olx=olx-1
exitwhen(olx<1)
endloop
endif
return true
endfunction
function IBr takes nothing returns boolean
set Xpe=XBx("SpiritWolves_Init: set SpiritWolves.SUMMON_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SpiritWolves.Event_Summon_Death)",VP,pI,function Inr)
call meo(GPv,XBx("SpiritWolves_Init: call SpiritWolves.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SpiritWolves.Event_SpellEffect))",ah,pI,function Ibr))
return true
endfunction
function Icr takes nothing returns boolean
call Ver(function IBr,"SpiritWolves_Init")
return true
endfunction
function ICr takes nothing returns boolean
call LZx('AStb',false)
set GAv=Lzo('AStb')
set G6[(GAv)]=(D6)
set j6[(GAv)]=(1)
set sH[(GAv)]=("Stormbolt")
set Ih[(GAv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D007F)))),(((Oj))))))
set x6v[(GAv)]=(4)
set xzv[(GAv)]=("spell")
call LZo((GAv),fH+(1),(($F)*1.))
call LZo((GAv),QH+(1),((80)*1.))
call LZo((GAv),Lvv+(1),((700)*1.))
set Mnv[(GAv)]=("ReplaceableTextures\\CommandButtons\\BTNStormBolt.blp")
return true
endfunction
function Idr takes nothing returns boolean
call VRx(qa,(function ICr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\Stormbolt.page\\Stormbolt.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function IDr takes nothing returns boolean
set Xze=Vnx(XZe)
return true
endfunction
function Ifr takes integer oqx returns integer
set X_e[oqx]=true
set X0e[oqx]=false
call rax(Xze)
return oqx
endfunction
function IFr takes integer oqx returns nothing
set X_e[oqx]=false
call rgx(Xze)
endfunction
function Igr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=X1e[oqx]
call IFr(oqx)
call Mdo(MFo)
if(Ixx==w)then
return true
endif
if nIo(Ixx)then
return true
endif
call NIx((Ixx),(Xsv),(X2e[oqx]),w,((X3e)*1.))
call nJo((CMx),(Ixx),((X4e)*1.),(true),(false))
return true
endfunction
function IGr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer MFo=Mvo()
local integer oqx=Ifr(MFo)
set X1e[oqx]=CMx
set X2e[oqx]=rwx
set mNv[(MFo)]=((10.)*1.)
call Mro(MFo,'qStb',2.)
set mCv[(MFo)]=XHx((function Igr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,700.)
call M9o(MFo,CMx)
call M3o((MFo),(Ixx),.0,.0,.0,(null))
return true
endfunction
function Ihr takes nothing returns boolean
call meo(GAv,XBx("Stormbolt_Init: call Stormbolt.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Stormbolt.Event_SpellEffect))",ah,pI,function IGr))
return true
endfunction
function IHr takes nothing returns boolean
call Ver(function Ihr,"Stormbolt_Init")
return true
endfunction
function Ijr takes nothing returns boolean
call LZx('ASuM',false)
set hOv=Lzo('ASuM')
set G6[(hOv)]=(D6)
set j6[(hOv)]=(1)
set sH[(hOv)]=("Summon Minions")
set Ih[(hOv)]=((LoadInteger(o[((V[(E[((X))])]))],((((OrderId("summonGrizzly"))))),(((Oj))))))
set x6v[(hOv)]=(0)
set xzv[(hOv)]=("spell")
call LZo((hOv),BH+(1),(($A)*1.))
call LZo((hOv),fH+(1),((30)*1.))
call LZo((hOv),QH+(1),((0)*1.))
call LZo((hOv),Lvv+(1),((750)*1.))
set Mnv[(hOv)]=("ReplaceableTextures\\CommandButtons\\BTNMassTeleport.blp")
set X5e=hcv
set X6e=G0v
return true
endfunction
function IJr takes nothing returns boolean
set X7e=lQx(X8e+" (dummyBuff)")
return true
endfunction
function Ikr takes nothing returns boolean
call VRx(qa,(function Ijr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\SummonMinions.page\\SummonMinions.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function IJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\SummonMinions.page\\SummonMinions.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function IKr takes nothing returns boolean
set X9e=Vnx(X8e)
return true
endfunction
function Ilr takes integer oqx,integer oQx,integer okx returns integer
return(LoadInteger(o[((V[(E[((One[(oqx)]))])]))],((((OVe[((oqx))])))),(((oQx)+(okx)))))
endfunction
function ILr takes integer oqx,integer oQx returns real
return(LoadReal(o[((V[(E[((One[(oqx)]))])]))],((((OVe[((oqx))])))),(((oQx)))))
endfunction
function Imr takes integer oqx returns integer
local integer olx=q
local real oVr=(GetRandomReal(((.0)*1.),((Oae[oqx])*1.)))
local real IMr=.0
local integer rRx
loop
set rRx=Ilr(oqx,OXe,olx)
set IMr=IMr+ILr(oqx,ORe+rRx)
exitwhen(oVr<=IMr)
set olx=olx+1
endloop
return rRx
endfunction
function Ipr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=oqx
local real N8x=(GetRandomReal(((.0)*1.),((df)*1.)))
local integer C0o=(ze[(CMx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real x=wpo-Ore*(Cos(((((N8x)*1.))*1.)))
local real y=wPo-Ore*(Sin(((((N8x)*1.))*1.)))
local integer olx=Oie
local integer lbo
local integer lzo
loop
exitwhen(olx<1)
set lbo=Imr(OIe)
set lzo=Uzo(lbo,C0o,x,y,N8x,OAe)
call fhx((lzo),-((.0)*1.),-((.0)*1.),-((.0)*1.),-(((Nwv[(lbo)]))*1.))
call fPx(lzo,.0,.0,.0,(Nwv[(lbo)]),1.)
set olx=olx-1
endloop
endfunction
function IPr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer oqx=CMx
local integer p0x=inx()
set Oxe[oqx]=p0x
set Ooe[oqx]=rwx
set ge[(p0x)]=(oqx)
call icx(p0x,Ove,true,function Ipr)
return true
endfunction
function Iqr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer oqx=CMx
local integer p0x=Oxe[oqx]
call ijx(p0x)
return true
endfunction
function IQr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),X7e)
return true
endfunction
function Isr takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(X7e),((Mv[(rdx)])),w)
return true
endfunction
function ISr takes integer oqx returns integer
set OCe[oqx]=true
set Ode[oqx]=false
set One[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
call rax(eyv)
return oqx
endfunction
function Itr takes nothing returns integer
local integer oqx
if(ONe==8190)then
call oYx("UnitTypePool_Allocation_allocCustom","call DebugEx(UnitTypePool.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",eYv+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Obe[(w)]==w)then
set OBe=OBe+1
set oqx=OBe
else
set oqx=Obe[(w)]
set Obe[(w)]=Obe[Obe[(w)]]
endif
set Obe[oqx]=Z
set Oce[oqx]=1
call ISr(oqx)
return oqx
endfunction
function ITr takes integer oqx returns nothing
set OVe[(oqx)]=(Ofe+oqx)
endfunction
function Iur takes nothing returns integer
local integer oqx=Itr()
set Oae[oqx]=.0
call ITr(oqx)
return oqx
endfunction
function IUr takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(One[(oqx)],(OVe[((oqx))]),oQx,oSx)
endfunction
function Iwr takes integer oqx,integer oQx,real oSx returns nothing
call SaveReal(o[((V[(E[((One[(oqx)]))])]))],((((OVe[((oqx))])))),(((oQx))),((((((oSx)*1.))*1.))*1.))
endfunction
function IWr takes integer oqx,integer rRx,real Iyr returns nothing
set Oae[oqx]=Oae[oqx]+Iyr
call IUr(oqx,OXe,rRx)
call Iwr(oqx,ORe+rRx,Iyr)
endfunction
function IYr takes nothing returns boolean
set Ove=(Cpx((hOv),BH+(1)))*1./ Oee-.01
call l9x(X7e,XBx("SummonMinions_Init: call SummonMinions.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SummonMinions.Event_BuffGain))",Bd,pI,function IPr))
call l9x(X7e,XBx("SummonMinions_Init: call SummonMinions.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SummonMinions.Event_BuffLose))",Jc,pI,function Iqr))
call meo(hOv,XBx("SummonMinions_Init: call SummonMinions.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SummonMinions.Event_EndCast))",oev,pI,function IQr))
call meo(hOv,XBx("SummonMinions_Init: call SummonMinions.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SummonMinions.Event_SpellEffect))",ah,pI,function Isr))
set OIe=Iur()
call IWr(OIe,G0v,OFe)
call IWr(OIe,hcv,Oge)
return true
endfunction
function Izr takes nothing returns boolean
call Ver(function IYr,"SummonMinions_Init")
return true
endfunction
function IZr takes nothing returns boolean
set OGe=hGo('uArS')
call hho(((OGe)),Apv,(ICv))
call hho(((OGe)),Apv,(INv))
set Tj[(OGe)]=((1.5)*1.)
set Nav[(OGe)]=(('x')*1.)
set Ntv[(OGe)]=((60)*1.)
set I3v[(OGe)]=((0)*1.)
set Axv[(OGe)]=(3)
set NJv[(OGe)]=((150000.)*1.)
set Njv[(OGe)]=((150000.)*1.)
set Nhv[(OGe)]=((0)*1.)
set NIv[(OGe)]=((500)*1.)
set NOv[(OGe)]=((500)*1.)
set AQv[(OGe)]=((0)*1.)
set Asv[(OGe)]=((0)*1.)
set Auv[(OGe)]=(0)
set AWv[(OGe)]=(0)
return true
endfunction
function I_r takes nothing returns boolean
call VRx(Sa,(function IZr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\Artifact.page\\Artifact.struct\\obj_thisUnitType_wc3unit.j"))
return true
endfunction
function I0r takes nothing returns boolean
set Sav=Vnx(Svv)
return true
endfunction
function I1r takes nothing returns boolean
set s8v=false
return true
endfunction
function I2r takes nothing returns boolean
call kqo(function I1r,"Artifact_Init")
return true
endfunction
function I3r takes nothing returns boolean
return true
endfunction
function I4r takes nothing returns boolean
set Ohe=Vnx(OHe)
return true
endfunction
function I5r takes nothing returns boolean
set Oje=lQx(OJe+" (eclipseBuff)")
set qc[(Oje)]=(true)
return true
endfunction
function I6r takes nothing returns boolean
call LZx('ABaS',false)
set SVv=Lzo('ABaS')
set G6[(SVv)]=(b6)
set j6[(SVv)]=(6)
set sH[(SVv)]=("Bat Swarm")
set Ih[(SVv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Oj))))))
set x6v[(SVv)]=(4)
set xzv[(SVv)]=("spell")
call LZo((SVv),u6v+(1),((400)*1.))
call LZo((SVv),fH+(1),(($E)*1.))
call LZo((SVv),QH+(1),((75)*1.))
call LZo((SVv),Lvv+(1),((800)*1.))
call LZo((SVv),u6v+(2),((400)*1.))
call LZo((SVv),fH+(2),(($E)*1.))
call LZo((SVv),QH+(2),((85)*1.))
call LZo((SVv),Lvv+(2),((800)*1.))
call LZo((SVv),u6v+(3),((400)*1.))
call LZo((SVv),fH+(3),(($E)*1.))
call LZo((SVv),QH+(3),((95)*1.))
call LZo((SVv),Lvv+(3),((800)*1.))
call LZo((SVv),u6v+(4),((400)*1.))
call LZo((SVv),fH+(4),(($E)*1.))
call LZo((SVv),QH+(4),(('i')*1.))
call LZo((SVv),Lvv+(4),((800)*1.))
call LZo((SVv),u6v+(5),((400)*1.))
call LZo((SVv),fH+(5),(($E)*1.))
call LZo((SVv),QH+(5),(('s')*1.))
call LZo((SVv),Lvv+(5),((800)*1.))
call LZo((SVv),u6v+(6),((400)*1.))
call LZo((SVv),fH+(6),(($E)*1.))
call LZo((SVv),QH+(6),(('}')*1.))
call LZo((SVv),Lvv+(6),((800)*1.))
set Mnv[(SVv)]=("ReplaceableTextures\\CommandButtons\\BTNCarrionSwarm.blp")
set Oke[1]=7
set Oke[2]=7
set Oke[3]=7
set Oke[4]=7
set Oke[5]=7
set Oke[6]=7
set OKe[1]=7
set OKe[2]=7
set OKe[3]=7
set OKe[4]=7
set OKe[5]=7
set OKe[6]=7
set Ole[1]=20
set Ole[2]=25
set Ole[3]=30
set Ole[4]=35
set Ole[5]=40
set Ole[6]=45
set OLe[1]=3
set OLe[2]=3
set OLe[3]=3
set OLe[4]=3
set OLe[5]=3
set OLe[6]=3
set Ome[1]=20
set Ome[2]=30
set Ome[3]=45
set Ome[4]=65
set Ome[5]=90
set Ome[6]='x'
return true
endfunction
function I7r takes nothing returns boolean
call VRx(Ma,(function I5r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\BatSwarm.page\\BatSwarm.struct\\obj_eclipseBuff_wc3buff.j"))
call VRx(qa,(function I6r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\BatSwarm.page\\BatSwarm.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function I8r takes nothing returns boolean
set OMe=Vnx(OJe)
return true
endfunction
function I9r takes code c,string rqx returns nothing
set qn=qn+1
set Qn[qn]=CreateTrigger()
set sn[qn]=(GetHandleId(Condition((c))))
set Sn[qn]=rqx
call TriggerAddCondition(Qn[qn],Condition(c))
endfunction
function Avr takes nothing returns boolean
local integer Ixx=jFx()
if(I5x((OPe),Rb,(Ixx)))then
return false
endif
if(Ixx==Ib)then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if I6x(Ixx,IFv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function Aer takes integer oqx returns integer
set Ote[oqx]=true
set OTe[oqx]=false
call rax(OMe)
return oqx
endfunction
function Axr takes nothing returns integer
local integer oqx
if(Oqe==8190)then
call oYx("BatSwarm_Allocation_allocCustom","call DebugEx(BatSwarm.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",OJe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(OQe[(w)]==w)then
set Ose=Ose+1
set oqx=Ose
else
set oqx=OQe[(w)]
set OQe[(w)]=OQe[OQe[(w)]]
endif
set OQe[oqx]=Z
set OSe[oqx]=1
call Aer(oqx)
return oqx
endfunction
function Aor takes integer oqx returns nothing
set Ote[oqx]=false
call rgx(OMe)
endfunction
function Arr takes integer oqx returns nothing
if(OSe[oqx]>0)then
return
endif
if(OQe[oqx]!=Z)then
call oYx("BatSwarm_Allocation_deallocCustom_confirm","call DebugEx(BatSwarm.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",OJe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set OQe[oqx]=OQe[(w)]
set OQe[(w)]=oqx
call Aor(oqx)
endfunction
function Air takes integer oqx returns nothing
set OSe[oqx]=OSe[oqx]-1
call Arr(oqx)
endfunction
function Aar takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=Oue[oqx]
local real Anr=Owe[oqx]
local integer Ixx=OWe[oqx]
call Air((oqx))
call Mdo(MFo)
call moo(CMx,Ixx,Anr)
return true
endfunction
function AVr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer AEr=(Vv[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=Oue[oqx]
local integer Ixx=OWe[oqx]
call Mdo(MFo)
if not I6x(AEr,sc)then
call RUx((Abx((AEr),(Oye),(OYe),(Bi))))
call nJo((CMx),(AEr),((OUe[oqx])*1.),(false),(false))
endif
if not(IsUnitAlly(C[(Ixx)],vx[((ze[(CMx)]))]))then
call Air((oqx))
return true
endif
set MFo=Mvo()
set mAv[((MFo))]=((b6v*((.06)*1.))*1.)
set mNv[(MFo)]=((8.)*1.)
call Mro(MFo,'qBST',1.5)
set mCv[(MFo)]=XHx((function Aar))
set mWv[(MFo)]=(oqx)
call m8o(MFo,500.)
call M9o(MFo,AEr)
call M3o((MFo),(CMx),.0,.0,.0,(null))
return true
endfunction
function AXr takes integer CQx returns nothing
local integer CMx=(aH[(CQx)])
local integer rwx=(XH[(CQx)])
local integer Ixx=(Uh[(CQx)])
local integer C0o=(ze[(CMx)])
local real O1o
local real dix
local real dax
local integer AOr
local integer olx
local integer AEr
local integer oqx
local integer MFo
if(IsUnitAlly(C[(Ixx)],vx[(C0o)]))then
call NIx((Ixx),(aMv),(rwx),w,((OKe[rwx])*1.))
else
call NIx((Ixx),(Oje),(rwx),w,((Oke[rwx])*1.))
endif
set O1o=(Cpx((SVv),u6v+(rwx)))
set dix=(GetUnitX(C[((Ixx))]))
set dax=(GetUnitY(C[((Ixx))]))
set AOr=JIx("BatSwarm_Start: set enemyGroup = UnitList.Create()")
set olx=OLe[rwx]
loop
exitwhen(olx<1)
set Hf=C0o
set OPe=AOr
set Ib=Ixx
set AEr=weo(dix,dax,O1o,Ope)
exitwhen(AEr==w)
set oqx=Axr()
set MFo=Mvo()
set Oue[oqx]=CMx
set OUe[oqx]=Ome[rwx]
set Owe[oqx]=Ole[rwx]
set OWe[oqx]=Ixx
call dpx(AOr,AEr)
set mAv[((MFo))]=((b6v*((.06)*1.))*1.)
set mNv[(MFo)]=((8.)*1.)
call SetUnitColor(zj[((Mro(MFo,'qBaS',.5)))],((ox[(C0o)])))
set mCv[(MFo)]=XHx((function AVr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,500.)
call M9o(MFo,Ixx)
call M3o((MFo),(AEr),.0,.0,.0,(null))
set olx=olx-1
endloop
call XYr(AOr)
endfunction
function ARr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer CQx=(mWv[(MFo)])
call Mdo(MFo)
call AXr(CQx)
call UPx(CQx)
return true
endfunction
function AIr takes integer CQx returns nothing
local integer MFo=Mvo()
call UNx(CQx)
set mAv[((MFo))]=((b6v*((.4)*1.))*1.)
set mNv[(MFo)]=((32.)*1.)
call Mro(MFo,'qBSM',1.)
set mCv[(MFo)]=XHx((function ARr))
set mWv[(MFo)]=(CQx)
call m8o(MFo,900.)
call M9o(MFo,(aH[(CQx)]))
call M3o((MFo),((Uh[(CQx)])),.0,.0,.0,(null))
endfunction
function AAr takes nothing returns boolean
local integer rdx=(bv)
local integer CQx=(uH[(rdx)])
if((Uh[(CQx)])==(aH[(CQx)]))then
call AXr(CQx)
else
call AIr(CQx)
endif
return true
endfunction
function ANr takes nothing returns boolean
set Ope=XLx(function Avr)
call meo(SVv,XBx("BatSwarm_Init: call BatSwarm.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BatSwarm.Event_SpellEffect))",ah,pI,function AAr))
call W_x(ENv,Oje)
return true
endfunction
function Abr takes nothing returns boolean
call I9r(function ANr,"BatSwarm_Init")
return true
endfunction
function ABr takes nothing returns boolean
set Oze=lQx(OZe+" (bleedingBuff)")
return true
endfunction
function Acr takes nothing returns boolean
call LZx('AHaE',false)
set Snv=Lzo('AHaE')
set G6[(Snv)]=(b6)
set j6[(Snv)]=(6)
set sH[(Snv)]=("Hawk Eye")
set Ih[(Snv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Oj))))))
set x6v[(Snv)]=(0)
set xzv[(Snv)]=("spell")
call LZo((Snv),u6v+(1),((750)*1.))
call LZo((Snv),fH+(1),(($A)*1.))
call LZo((Snv),QH+(1),((30)*1.))
call LZo((Snv),Lvv+(1),((750)*1.))
call LZo((Snv),u6v+(2),((750)*1.))
call LZo((Snv),fH+(2),(($A)*1.))
call LZo((Snv),QH+(2),((40)*1.))
call LZo((Snv),Lvv+(2),((750)*1.))
call LZo((Snv),u6v+(3),((750)*1.))
call LZo((Snv),fH+(3),(($A)*1.))
call LZo((Snv),QH+(3),((50)*1.))
call LZo((Snv),Lvv+(3),((750)*1.))
call LZo((Snv),u6v+(4),((750)*1.))
call LZo((Snv),fH+(4),(($A)*1.))
call LZo((Snv),QH+(4),((60)*1.))
call LZo((Snv),Lvv+(4),((750)*1.))
call LZo((Snv),u6v+(5),((750)*1.))
call LZo((Snv),fH+(5),(($A)*1.))
call LZo((Snv),QH+(5),((70)*1.))
call LZo((Snv),Lvv+(5),((750)*1.))
call LZo((Snv),u6v+(6),((750)*1.))
call LZo((Snv),fH+(6),(($A)*1.))
call LZo((Snv),QH+(6),((80)*1.))
call LZo((Snv),Lvv+(6),((750)*1.))
set Mnv[(Snv)]=("ReplaceableTextures\\CommandButtons\\BTNScout.blp")
set O_e[1]=$F
set O_e[2]=20
set O_e[3]=25
set O_e[4]=30
set O_e[5]=35
set O_e[6]=40
set O0e[1]=-.1
set O0e[2]=-.1
set O0e[3]=-.2
set O0e[4]=-.2
set O0e[5]=-.3
set O0e[6]=-.3
set O1e[1]=$A
set O1e[2]=$A
set O1e[3]=$A
set O1e[4]=$A
set O1e[5]=$A
set O1e[6]=$A
set O2e[1]=3
set O2e[2]=3
set O2e[3]=3
set O2e[4]=3
set O2e[5]=3
set O2e[6]=3
set O3e[1]=5
set O3e[2]=5
set O3e[3]=5
set O3e[4]=5
set O3e[5]=5
set O3e[6]=5
return true
endfunction
function ACr takes nothing returns boolean
set O4e=lQx(OZe+" (dummyBuff)")
set qc[(O4e)]=(true)
call lux(O4e,"HawkEye_page\\HawkEye_struct\\buff2.mdx","overhead",ri)
set SU=lYx()
call l_x(SU,nvv,-.1)
call l0x(((O4e)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,nvv,-.1)
call l0x(((O4e)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,nvv,-.2)
call l0x(((O4e)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,nvv,-.2)
call l0x(((O4e)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,nvv,-.3)
call l0x(((O4e)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,nvv,-.3)
call l0x(((O4e)),vc+(6),(SU))
return true
endfunction
function Adr takes nothing returns boolean
call VRx(Ma,(function ABr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\HawkEye.page\\HawkEye.struct\\obj_bleedingBuff_wc3buff.j"))
call VRx(qa,(function Acr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\HawkEye.page\\HawkEye.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function ACr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\HawkEye.page\\HawkEye.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function ADr takes nothing returns boolean
set O5e=Vnx(OZe)
return true
endfunction
function Afr takes nothing returns boolean
local integer rdx=(bv)
local integer AFr=(EYv[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer rwx=(oPx(((Ixx)),zb+(O4e)))
call NIx(Ixx,Oze,rwx,AFr,O3e[rwx])
return true
endfunction
function Agr takes integer oqx returns integer
set Rxe[oqx]=true
set Roe[oqx]=false
call rax(O5e)
return oqx
endfunction
function AGr takes nothing returns integer
local integer oqx
if(O8e==8190)then
call oYx("HawkEye_Allocation_allocCustom","call DebugEx(HawkEye.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",OZe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(O9e[(w)]==w)then
set Rve=Rve+1
set oqx=Rve
else
set oqx=O9e[(w)]
set O9e[(w)]=O9e[O9e[(w)]]
endif
set O9e[oqx]=Z
set Ree[oqx]=1
call Agr(oqx)
return oqx
endfunction
function Ahr takes integer oqx returns nothing
set Rxe[oqx]=false
call rgx(O5e)
endfunction
function AHr takes integer oqx returns nothing
if(Ree[oqx]>0)then
return
endif
if(O9e[oqx]!=Z)then
call oYx("HawkEye_Allocation_deallocCustom_confirm","call DebugEx(HawkEye.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",OZe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set O9e[oqx]=O9e[(w)]
set O9e[(w)]=oqx
call Ahr(oqx)
endfunction
function Ajr takes integer oqx returns nothing
set Ree[oqx]=Ree[oqx]-1
call AHr(oqx)
endfunction
function AJr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=(mWv[(MFo)])
local real Akr=Rre[oqx]
call Mdo(MFo)
call Ajr((oqx))
if(Ixx==w)then
return true
endif
call mro(Ixx,Ixx,Akr)
return true
endfunction
function AKr takes integer ozx,integer Ixx,real Akr returns nothing
local integer oqx=AGr()
local integer MFo=Mvo()
set Rre[oqx]=Akr
set mAv[((MFo))]=((b6v*((.1)*1.))*1.)
set mNv[(MFo)]=((32.)*1.)
call Mro(MFo,'qHaE',1.25)
set mCv[(MFo)]=XHx((function AJr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,500.)
call M9o(MFo,ozx)
call M3o((MFo),(Ixx),.0,.0,.0,(null))
endfunction
function Alr takes nothing returns boolean
local integer rdx=(bv)
local integer cCx=(FG[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer rwx=(oPx(((Ixx)),zb+(O4e)))
local integer ALr=(kv[((ze[(cCx)]))])
if((ALr!=w)and not I6x(ALr,sc))then
set cCx=ALr
endif
call AKr(Ixx,cCx,O_e[rwx])
return true
endfunction
function Amr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function AMr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call I7x(Ixx,O6e)
call I7x(Ixx,O7e)
call DSx((((Ixx))),(nHv),(1),w)
return true
endfunction
function Apr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call Rmx(Ixx,O6e)
call Rmx(Ixx,O7e)
call UJx(((Ixx)),nHv)
return true
endfunction
function APr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local string Aqr
local integer Ixx
local integer ECr
if(ci==ri)then
set Aqr=Rne
else
set Aqr=RVe
endif
call mFo((mHo(((wpo)*1.),((wPo)*1.),(Aqr),(ri))))
set Hf=(ze[(CMx)])
call Nio(Rie,wpo,wPo,(Cpx((Snv),u6v+(rwx))),Rae)
set Ixx=(mjo((Rie),((wpo)*1.),((wPo)*1.)))
if(Ixx!=w)then
set ECr=O2e[rwx]
loop
call GroupRemoveUnit(Kb[(Rie)],C[(Ixx)])
call NIx((Ixx),(O4e),(rwx),w,((O1e[rwx])*1.))
set ECr=ECr-1
exitwhen(ECr<1)
set Ixx=(mjo((Rie),((wpo)*1.),((wPo)*1.)))
exitwhen(Ixx==w)
endloop
endif
return true
endfunction
function AQr takes nothing returns boolean
set O6e=XBx("HawkEye_Init: set HawkEye.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.SPELLS, function HawkEye.Event_Damage)",Ezv,pI,function Afr)
set O7e=XBx("HawkEye_Init: set HawkEye.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HawkEye.Event_Death)",VP,pI,function Alr)
set Rie=O2x()
set Rae=XLx(function Amr)
call l9x(O4e,XBx("HawkEye_Init: call HawkEye.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HawkEye.Event_BuffGain))",Bd,pI,function AMr))
call l9x(O4e,XBx("HawkEye_Init: call HawkEye.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HawkEye.Event_BuffLose))",Jc,pI,function Apr))
call meo(Snv,XBx("HawkEye_Init: call HawkEye.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HawkEye.Event_SpellEffect))",ah,pI,function APr))
call W_x(Emv,Oze)
return true
endfunction
function Asr takes nothing returns boolean
call I9r(function AQr,"HawkEye_Init")
return true
endfunction
function ASr takes nothing returns boolean
set REe=WTx('BCrM',"Spell Potion",'bCrM')
set avv[(REe)]=(true)
set qU[(REe)]=(true)
set aev[(REe)]=("ReplaceableTextures\\CommandButtons\\BTNMinorRejuvPotion.blp")
call lux(REe,"Abilities\\Spells\\Human\\MagicSentry\\MagicSentryCaster.mdl","overhead",ri)
set SU=lYx()
call l_x(SU,cbv,30)
call l0x(((REe)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,cbv,50)
call l0x(((REe)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,cbv,70)
call l0x(((REe)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,cbv,90)
call l0x(((REe)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,cbv,'n')
call l0x(((REe)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,cbv,$82)
call l0x(((REe)),vc+(6),(SU))
return true
endfunction
function Atr takes nothing returns boolean
set RXe[1]=30
set RXe[2]=50
set RXe[3]=70
set RXe[4]=90
set RXe[5]='n'
set RXe[6]=$82
set ROe[1]=7.5
set ROe[2]=7.5
set ROe[3]=7.5
set ROe[4]=7.5
set ROe[5]=7.5
set ROe[6]=7.5
return true
endfunction
function ATr takes nothing returns boolean
call VRx(Ma,(function ASr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\MagicBottle.page\\MagicBottle.struct\\Buff\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function Atr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\MagicBottle.page\\MagicBottle.struct\\Buff\\obj_this_wc3obj.j"))
return true
endfunction
function Aur takes nothing returns boolean
set RRe=Vnx(RIe)
return true
endfunction
function AUr takes nothing returns boolean
call LZx('AMaB',false)
set SAv=Lzo('AMaB')
set G6[(SAv)]=(b6)
set j6[(SAv)]=(6)
set sH[(SAv)]=("Magic Bottle")
set Ih[(SAv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Oj))))))
set x6v[(SAv)]=(4)
set xzv[(SAv)]=("spell")
call LZo((SAv),fH+(1),(($D)*1.))
call LZo((SAv),QH+(1),((55)*1.))
call LZo((SAv),Lvv+(1),((700)*1.))
call LZo((SAv),fH+(2),(($D)*1.))
call LZo((SAv),QH+(2),((75)*1.))
call LZo((SAv),Lvv+(2),((700)*1.))
call LZo((SAv),fH+(3),(($D)*1.))
call LZo((SAv),QH+(3),((95)*1.))
call LZo((SAv),Lvv+(3),((700)*1.))
call LZo((SAv),fH+(4),(($D)*1.))
call LZo((SAv),QH+(4),(('s')*1.))
call LZo((SAv),Lvv+(4),((700)*1.))
call LZo((SAv),fH+(5),(($D)*1.))
call LZo((SAv),QH+(5),(('}')*1.))
call LZo((SAv),Lvv+(5),((700)*1.))
call LZo((SAv),fH+(6),(($D)*1.))
call LZo((SAv),QH+(6),(($87)*1.))
call LZo((SAv),Lvv+(6),((700)*1.))
set Mnv[(SAv)]=("ReplaceableTextures\\CommandButtons\\BTNPotionOfOmniscience.blp")
set RAe[1]=40
set RAe[2]=60
set RAe[3]=80
set RAe[4]='d'
set RAe[5]='x'
set RAe[6]=$8C
set RNe[1]=1.5
set RNe[2]=1.5
set RNe[3]=1.5
set RNe[4]=1.5
set RNe[5]=1.5
set RNe[6]=1.5
return true
endfunction
function Awr takes nothing returns boolean
call VRx(qa,(function AUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\MagicBottle.page\\MagicBottle.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function AWr takes nothing returns boolean
set Rbe=Vnx(RBe)
return true
endfunction
function Ayr takes integer oqx returns integer
set Rfe[oqx]=true
set RFe[oqx]=false
call rax(Rbe)
return oqx
endfunction
function AYr takes nothing returns integer
local integer oqx
if(Rce==8190)then
call oYx("MagicBottle_Allocation_allocCustom","call DebugEx(MagicBottle.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",RBe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(RCe[(w)]==w)then
set Rde=Rde+1
set oqx=Rde
else
set oqx=RCe[(w)]
set RCe[(w)]=RCe[RCe[(w)]]
endif
set RCe[oqx]=Z
set RDe[oqx]=1
call Ayr(oqx)
return oqx
endfunction
function Azr takes integer oqx returns nothing
set Rfe[oqx]=false
call rgx(Rbe)
endfunction
function AZr takes integer oqx returns nothing
if(RDe[oqx]>0)then
return
endif
if(RCe[oqx]!=Z)then
call oYx("MagicBottle_Allocation_deallocCustom_confirm","call DebugEx(MagicBottle.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",RBe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set RCe[oqx]=RCe[(w)]
set RCe[(w)]=oqx
call Azr(oqx)
endfunction
function A_r takes integer oqx returns nothing
set RDe[oqx]=RDe[oqx]-1
call AZr(oqx)
endfunction
function A0r takes integer rwx,integer Ixx returns nothing
call NIx((Ixx),(REe),(rwx),w,((ROe[rwx])*1.))
endfunction
function A1r takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=Rge[oqx]
local integer rwx=RGe[oqx]
local integer Ixx=Rhe[oqx]
call A_r((oqx))
call Mdo(MFo)
call RUx((Abx((Ixx),(RHe),(Rje),(Bi))))
if(IsUnitAlly(C[(Ixx)],vx[((ze[(CMx)]))]))then
call mro(CMx,Ixx,RAe[rwx])
call A0r(rwx,Ixx)
else
if(wbo(Ixx,true,true,true)>0)then
call mro(CMx,CMx,RAe[rwx])
endif
call NIx((((Ixx))),(Ehv),(1),w,((((RNe[rwx])*1.))*1.))
call A0r(rwx,CMx)
endif
return true
endfunction
function A2r takes integer CMx,integer rwx,integer Ixx returns nothing
local integer oqx=AYr()
local integer MFo=Mvo()
set Rge[oqx]=CMx
set RGe[oqx]=rwx
set Rhe[oqx]=Ixx
set mAv[((MFo))]=((b6v*((.06)*1.))*1.)
set mNv[(MFo)]=((10.)*1.)
call Mro(MFo,'qCMP',2.)
set mCv[(MFo)]=XHx((function A1r))
set mWv[(MFo)]=(oqx)
call m8o(MFo,900.)
call M9o(MFo,CMx)
call M3o((MFo),(Ixx),.0,.0,.0,(null))
endfunction
function A3r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
call A2r(CMx,rwx,Ixx)
return true
endfunction
function A4r takes nothing returns nothing
endfunction
function A5r takes nothing returns boolean
call meo(SAv,XBx("MagicBottle_Init: call MagicBottle.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MagicBottle.Event_SpellEffect))",ah,pI,function A3r))
call A4r()
return true
endfunction
function A6r takes nothing returns boolean
call I9r(function A5r,"MagicBottle_Init")
return true
endfunction
function A7r takes nothing returns boolean
set RJe[1]=$96
set RJe[2]=$96
set RJe[3]=$96
set RJe[4]=$96
set RJe[5]=$96
set RJe[6]=$96
set Rke[1]=60
set Rke[2]=90
set Rke[3]='x'
set Rke[4]=$96
set Rke[5]=$B4
set Rke[6]=$D2
return true
endfunction
function A8r takes nothing returns boolean
call VRx(ea,(function A7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\RedwoodValkyrie.page\\RedwoodValkyrie.struct\\Air\\obj_this_wc3obj.j"))
return true
endfunction
function A9r takes nothing returns boolean
set RKe=Vnx(Rle)
return true
endfunction
function Nvr takes nothing returns boolean
set RLe=lQx(Rme+" (ignitionBuff)")
set qc[(RLe)]=(true)
set qU[(RLe)]=(true)
return true
endfunction
function Ner takes nothing returns boolean
call LZx('ARwV',false)
set RMe=Lzo('ARwV')
set G6[(RMe)]=(b6)
set j6[(RMe)]=(6)
set sH[(RMe)]=("Redwood Valkyrie")
set Ih[(RMe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Oj))))))
set x6v[(RMe)]=(3)
set xzv[(RMe)]=("attack")
call LZo((RMe),u6v+(1),((80)*1.))
call LZo((RMe),fH+(1),((4)*1.))
call LZo((RMe),QH+(1),((30)*1.))
call LZo((RMe),Lvv+(1),(($514)*1.))
call LZo((RMe),u6v+(2),((80)*1.))
call LZo((RMe),fH+(2),((4)*1.))
call LZo((RMe),QH+(2),((40)*1.))
call LZo((RMe),Lvv+(2),(($514)*1.))
call LZo((RMe),u6v+(3),((80)*1.))
call LZo((RMe),fH+(3),((4)*1.))
call LZo((RMe),QH+(3),((50)*1.))
call LZo((RMe),Lvv+(3),(($514)*1.))
call LZo((RMe),u6v+(4),((80)*1.))
call LZo((RMe),fH+(4),((4)*1.))
call LZo((RMe),QH+(4),((60)*1.))
call LZo((RMe),Lvv+(4),(($514)*1.))
call LZo((RMe),u6v+(5),((80)*1.))
call LZo((RMe),fH+(5),((4)*1.))
call LZo((RMe),QH+(5),((70)*1.))
call LZo((RMe),Lvv+(5),(($514)*1.))
call LZo((RMe),u6v+(6),((80)*1.))
call LZo((RMe),fH+(6),((4)*1.))
call LZo((RMe),QH+(6),((80)*1.))
call LZo((RMe),Lvv+(6),(($514)*1.))
set Mnv[(RMe)]=("ReplaceableTextures\\CommandButtons\\BTNFlamingArrows.blp")
set Rpe[1]='s'
set Rpe[2]='s'
set Rpe[3]='s'
set Rpe[4]='s'
set Rpe[5]='s'
set Rpe[6]='s'
set RPe[1]=1.75
set RPe[2]=2
set RPe[3]=2.25
set RPe[4]=2.5
set RPe[5]=2.75
set RPe[6]=3
set Rqe[1]=20
set Rqe[2]=30
set Rqe[3]=40
set Rqe[4]=50
set Rqe[5]=60
set Rqe[6]=70
set RQe[1]=5
set RQe[2]=$F
set RQe[3]=30
set RQe[4]=50
set RQe[5]=75
set RQe[6]='i'
return true
endfunction
function Nxr takes nothing returns boolean
call VRx(Ma,(function Nvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\RedwoodValkyrie.page\\RedwoodValkyrie.struct\\obj_ignitionBuff_wc3buff.j"))
call VRx(qa,(function Ner),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\RedwoodValkyrie.page\\RedwoodValkyrie.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Nor takes nothing returns boolean
set Rse=Vnx(Rme)
return true
endfunction
function Nrr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer Ixx=jFx()
local integer oqx
local integer CQx
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
set oqx=(mWv[(MFo)])
if(I5x((Rte[oqx]),Rb,(Ixx)))then
return false
endif
set CQx=RTe[oqx]
if(IsUnitAlly(C[(Ixx)],vx[((ze[((aH[(CQx)]))]))]))then
return false
endif
return true
return true
endfunction
function Nir takes integer oqx returns integer
set Rwe[oqx]=true
set RWe[oqx]=false
call rax(RKe)
return oqx
endfunction
function Nar takes integer oqx returns nothing
set Rwe[oqx]=false
call rgx(RKe)
endfunction
function Nnr takes integer CMx,real NVr,real NEr,real x,real y returns nothing
local integer Ixx
call mFo((mHo(((x)*1.),((y)*1.),("Abilities\\Spells\\Other\\Incinerate\\FireLordDeathExplode.mdl"),(Bi))))
set Hf=(ze[(CMx)])
call Nio(RZe,x,y,NVr,R_e)
set Ixx=Nao(RZe)
if(Ixx!=w)then
loop
call nJo((CMx),(Ixx),((NEr)*1.),(true),(false))
set Ixx=Nao(RZe)
exitwhen(Ixx==w)
endloop
endif
endfunction
function NXr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local real x=(mFv[(MFo)])
local real y=(mgv[(MFo)])
local integer CQx=Rye[oqx]
local integer CMx=(aH[(CQx)])
local integer rwx=(XH[(CQx)])
call Nar(oqx)
call Mdo(MFo)
call Nnr(CMx,RJe[rwx],Rke[rwx]+(VH[(CQx)])*R0e,x,y)
call UPx(CQx)
return true
endfunction
function NOr takes integer CQx returns nothing
local integer CMx=(aH[(CQx)])
local integer rwx=(XH[(CQx)])
local integer Ixx=(Uh[(CQx)])
local integer MFo=Mvo()
local integer oqx=Nir(MFo)
set Rye[oqx]=CQx
set mNv[(MFo)]=(((Cpx((RMe),u6v+(rwx))))*1.)
call sao((Mro(MFo,'qRwA',1.5)),(RYe),(Rze),(Bi))
set mCv[(MFo)]=XHx((function NXr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,R1e)
call M9o(MFo,CMx)
call M3o((MFo),(Ixx),.0,.0,.0,(null))
call UNx(CQx)
endfunction
function NRr takes integer oqx returns integer
set R6e[oqx]=true
set R7e[oqx]=false
call rax(Rse)
return oqx
endfunction
function NIr takes nothing returns integer
local integer oqx
if(R2e==8190)then
call oYx("RedwoodValkyrie_Allocation_allocCustom","call DebugEx(RedwoodValkyrie.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Rme+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(R3e[(w)]==w)then
set R4e=R4e+1
set oqx=R4e
else
set oqx=R3e[(w)]
set R3e[(w)]=R3e[R3e[(w)]]
endif
set R3e[oqx]=Z
set R5e[oqx]=1
call NRr(oqx)
return oqx
endfunction
function NAr takes integer oqx returns nothing
set R6e[oqx]=false
call rgx(Rse)
endfunction
function NNr takes integer oqx returns nothing
if(R5e[oqx]>0)then
return
endif
if(R3e[oqx]!=Z)then
call oYx("RedwoodValkyrie_Allocation_deallocCustom_confirm","call DebugEx(RedwoodValkyrie.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Rme+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set R3e[oqx]=R3e[(w)]
set R3e[(w)]=oqx
call NAr(oqx)
endfunction
function Nbr takes integer oqx returns nothing
set R5e[oqx]=R5e[oqx]-1
call NNr(oqx)
endfunction
function NBr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
call XYr(Rte[oqx])
call Nbr((oqx))
call Mdo(MFo)
return true
endfunction
function Ncr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=(mWv[(MFo)])
local real NIo=R8e[oqx]
local integer CQx=RTe[oqx]
local integer CMx=(aH[(CQx)])
local real NCr
call dpx(Rte[oqx],Ixx)
if I6x(Ixx,yd)then
set NCr=Ire
else
set NCr=Iie
endif
call NIx(Ixx,RLe,(XH[(CQx)]),CMx,NCr)
call dto(CMx,Ixx,true,NIo)
return true
endfunction
function Ndr takes integer CQx returns nothing
local integer CMx=(aH[(CQx)])
local integer rwx=(XH[(CQx)])
local real dix=(wh[(CQx)])
local real dax=(Wh[(CQx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real rmr=(Cpx((RMe),Lvv+(rwx)))
local integer oqx=NIr()
local integer MFo=Mvo()
local real N8x=(Atan2(((dax-wPo)*1.),((dix-wpo)*1.)))
set R8e[oqx]=RQe[rwx]+(mg[(CMx)])*RPe[rwx]
set R9e[oqx]=rmr
set Ive[oqx]=wpo
set Iee[oqx]=wPo
set Rte[oqx]=JIx("RedwoodValkyrie_Start: set this.targetGroup = UnitList.Create()")
set RTe[oqx]=CQx
set mNv[(MFo)]=(((Cpx((RMe),u6v+(rwx))))*1.)
call sao((Mro(MFo,'qRwV',1.5)),(Ixe),(Ioe),(Bi))
set mWv[(MFo)]=(oqx)
set mCv[(MFo)]=XHx((function NBr))
call m8o(MFo,R1e)
call M9o(MFo,CMx)
call o6r(MFo,wpo+rmr*(Cos(((((N8x)*1.))*1.))),wPo+rmr*(Sin(((((N8x)*1.))*1.))),XYx(dix,dax)+60.)
call rQr(MFo,function Ncr,RSe)
endfunction
function NDr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer CQx=(uH[(rdx)])
call RUx((Abx((CMx),(Rue),(RUe),(Bi))))
if((Ixx!=w)and not I6x(Ixx,INv))then
call NOr(CQx)
return true
endif
call Ndr(CQx)
return true
endfunction
function Nfr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,Ivv)then
return false
endif
if nBo(Ixx)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function NFr takes nothing returns nothing
set RZe=O2x()
set R_e=XLx(function Nfr)
endfunction
function Ngr takes nothing returns boolean
set RSe=XLx(function Nrr)
call meo(RMe,XBx("RedwoodValkyrie_Init: call RedwoodValkyrie.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RedwoodValkyrie.Event_SpellEffect))",ah,pI,function NDr))
call W_x(E5v,RLe)
call NFr()
return true
endfunction
function NGr takes nothing returns boolean
call I9r(function Ngr,"RedwoodValkyrie_Init")
return true
endfunction
function Nhr takes nothing returns boolean
set Iae=lQx(Ine+" (frostBuff)")
set qc[(Iae)]=(true)
set qU[(Iae)]=(true)
return true
endfunction
function NHr takes nothing returns boolean
call LZx('ASaD',false)
set SIv=Lzo('ASaD')
set G6[(SIv)]=(b6)
set j6[(SIv)]=(6)
set sH[(SIv)]=("Sapphireblue Dagger")
set Ih[(SIv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Oj))))))
set x6v[(SIv)]=(2)
set xzv[(SIv)]=("spell")
call LZo((SIv),u6v+(1),(($C8)*1.))
call LZo((SIv),fH+(1),(($B)*1.))
call LZo((SIv),QH+(1),((30)*1.))
call LZo((SIv),Lvv+(1),((99999)*1.))
call LZo((SIv),u6v+(2),(($C8)*1.))
call LZo((SIv),fH+(2),(($B)*1.))
call LZo((SIv),QH+(2),((30)*1.))
call LZo((SIv),Lvv+(2),((99999)*1.))
call LZo((SIv),u6v+(3),(($C8)*1.))
call LZo((SIv),fH+(3),(($B)*1.))
call LZo((SIv),QH+(3),((30)*1.))
call LZo((SIv),Lvv+(3),((99999)*1.))
call LZo((SIv),u6v+(4),(($C8)*1.))
call LZo((SIv),fH+(4),(($B)*1.))
call LZo((SIv),QH+(4),((30)*1.))
call LZo((SIv),Lvv+(4),((99999)*1.))
call LZo((SIv),u6v+(5),(($C8)*1.))
call LZo((SIv),fH+(5),(($B)*1.))
call LZo((SIv),QH+(5),((30)*1.))
call LZo((SIv),Lvv+(5),((99999)*1.))
call LZo((SIv),u6v+(6),(($C8)*1.))
call LZo((SIv),fH+(6),(($B)*1.))
call LZo((SIv),QH+(6),((30)*1.))
call LZo((SIv),Lvv+(6),((99999)*1.))
set Mnv[(SIv)]=("ReplaceableTextures\\CommandButtons\\BTNDaggerOfEscape.blp")
set IVe[1]=8
set IVe[2]=8
set IVe[3]=8
set IVe[4]=8
set IVe[5]=8
set IVe[6]=8
set IEe[1]=4
set IEe[2]=4
set IEe[3]=4
set IEe[4]=4
set IEe[5]=4
set IEe[6]=4
set IXe[1]=8
set IXe[2]=$D
set IXe[3]=20
set IXe[4]=29
set IXe[5]=40
set IXe[6]=53
set IOe[1]=500
set IOe[2]=500
set IOe[3]=500
set IOe[4]=500
set IOe[5]=500
set IOe[6]=500
return true
endfunction
function Njr takes nothing returns boolean
set IRe=WTx('BSaD',"Sapphireblue Dagger",'bSaD')
set avv[(IRe)]=(true)
set qc[(IRe)]=(true)
set qU[(IRe)]=(true)
set aev[(IRe)]=("ReplaceableTextures\\CommandButtons\\BTNThoriumMelee.blp")
call lux(IRe,"SapphireblueDagger_page\\SapphireblueDagger_struct\\casterBuff.mdx","weapon",ri)
call lux(IRe,"SapphireblueDagger_page\\SapphireblueDagger_struct\\casterBuff.mdx","weapon",Bi)
call lux(IRe,"SapphireblueDagger_page\\SapphireblueDagger_struct\\casterBuff.mdx","weapon",Bi)
call lux(IRe,"SapphireblueDagger_page\\SapphireblueDagger_struct\\casterBuff.mdx","weapon",Bi)
call lux(IRe,"SapphireblueDagger_page\\SapphireblueDagger_struct\\casterBuff.mdx","weapon",Bi)
return true
endfunction
function NJr takes nothing returns boolean
call VRx(Ma,(function Nhr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\SapphireblueDagger.page\\SapphireblueDagger.struct\\obj_frostBuff_wc3buff.j"))
call VRx(qa,(function NHr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\SapphireblueDagger.page\\SapphireblueDagger.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function Njr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\SapphireblueDagger.page\\SapphireblueDagger.struct\\obj_casterBuff_wc3buff.j"))
return true
endfunction
function Nkr takes nothing returns boolean
set IIe=Vnx(Ine)
return true
endfunction
function NKr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer rwx=(oPx(((CMx)),zb+(IRe)))
call nJo((CMx),(Ixx),((IXe[rwx])*1.),(true),(false))
return true
endfunction
function Nlr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if I6x(Ixx,yd)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function NLr takes nothing returns boolean
local integer rdx=(bv)
call I7x((Vv[(rdx)]),IAe)
return true
endfunction
function Nmr takes nothing returns boolean
local integer rdx=(bv)
call Rmx((Vv[(rdx)]),IAe)
return true
endfunction
function NMr takes integer oqx,real jlx,real jLx,real oUx,real N8x,real jmx,real jMx,integer Q4x returns nothing
local real Neo=iOx(oUx,iOx(jMx,jmx))+ICe
if(Q4x==w)then
set Q4x=GK
endif
set Q4x=Noo(hQ,Q4x)
set kQ=N8x
set JQ=oUx
set HQ=jlx
set jQ=jLx
set lQ=jMx
set KQ=jmx
call SetRect(bm[(LQ)],((jlx-Neo)*1.),((jLx-Neo)*1.),((jlx+Neo)*1.),((jLx+Neo)*1.))
call GroupEnumUnitsInRect(Kb[(oqx)],bm[LQ],Bv[Q4x])
endfunction
function Npr takes real jlx,real jLx,real dix,real dax,integer CMx,integer rwx returns nothing
local real dX=dix-jlx
local real dY=dax-jLx
local real pMx=dvx(CMx,true)
local integer Ixx
local real ilx
set Hf=(ze[(CMx)])
call NMr(INe,jlx,jLx,jjx(dX,dY),(Atan2(((dY)*1.),((dX)*1.))),pMx,pMx,Ibe)
set Ixx=Nao(INe)
if(Ixx!=w)then
set ilx=IEe[rwx]
loop
call NIx((Ixx),(Iae),(rwx),w,((ilx)*1.))
set Ixx=Nao(INe)
exitwhen(Ixx==w)
endloop
endif
endfunction
function NPr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local real O1o=(Cpx((SIv),u6v+(rwx)))
local integer C0o=(ze[(CMx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real dX=dix-wpo
local real dY=dax-wPo
local real N8x
if(Gyx(dX,dY)>IBe[rwx])then
set N8x=UCx(CMx,dX,dY)
set dix=wpo+IOe[rwx]*(Cos(((((N8x)*1.))*1.)))
set dax=wPo+IOe[rwx]*(Sin(((((N8x)*1.))*1.)))
endif
call mFo((mHo(((wpo)*1.),((wPo)*1.),(Ice),(Bi))))
call Npr(wpo,wPo,dix,dax,CMx,rwx)
call mFo((mHo(((dix)*1.),((dax)*1.),(Ide),(ri))))
call SetUnitPosition(C[((CMx))],((dix)*1.),((dax)*1.))
call NIx((CMx),(IRe),(rwx),w,((IVe[rwx])*1.))
call fRx(CMx,rwx)
return true
endfunction
function Nqr takes nothing returns boolean
local integer olx
set IAe=XBx("SapphireblueDagger_Init: set SapphireblueDagger.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function SapphireblueDagger.Event_Damage)",EZv,pI,function NKr)
set INe=O2x()
set Ibe=XLx(function Nlr)
call l9x(IRe,XBx("SapphireblueDagger_Init: call SapphireblueDagger.CASTER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SapphireblueDagger.Event_BuffGain))",Bd,pI,function NLr))
call l9x(IRe,XBx("SapphireblueDagger_Init: call SapphireblueDagger.CASTER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SapphireblueDagger.Event_BuffLose))",Jc,pI,function Nmr))
call meo(SIv,XBx("SapphireblueDagger_Init: call SapphireblueDagger.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SapphireblueDagger.Event_SpellEffect))",ah,pI,function NPr))
call W_x(nCv,Iae)
set olx=(j6[(SIv)])
loop
set IBe[olx]=o8r(IOe[olx])
set olx=olx-1
exitwhen(olx<1)
endloop
return true
endfunction
function NQr takes nothing returns boolean
call I9r(function Nqr,"SapphireblueDagger_Init")
return true
endfunction
function Nsr takes nothing returns boolean
call LZx('ASiB',false)
set SXv=Lzo('ASiB')
set G6[(SXv)]=(b6)
set j6[(SXv)]=(6)
set sH[(SXv)]=("Silent Boots")
set Ih[(SXv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Oj))))))
set x6v[(SXv)]=(0)
set xzv[(SXv)]=("spell")
call LZo((SXv),fH+(1),(($A)*1.))
call LZo((SXv),QH+(1),((50)*1.))
call LZo((SXv),Lvv+(1),((750)*1.))
call LZo((SXv),fH+(2),((9)*1.))
call LZo((SXv),QH+(2),((50)*1.))
call LZo((SXv),Lvv+(2),((750)*1.))
call LZo((SXv),fH+(3),((8)*1.))
call LZo((SXv),QH+(3),((50)*1.))
call LZo((SXv),Lvv+(3),((750)*1.))
call LZo((SXv),fH+(4),((7)*1.))
call LZo((SXv),QH+(4),((50)*1.))
call LZo((SXv),Lvv+(4),((750)*1.))
call LZo((SXv),fH+(5),((6)*1.))
call LZo((SXv),QH+(5),((50)*1.))
call LZo((SXv),Lvv+(5),((750)*1.))
call LZo((SXv),fH+(6),((5)*1.))
call LZo((SXv),QH+(6),((50)*1.))
call LZo((SXv),Lvv+(6),((750)*1.))
set Mnv[(SXv)]=("ReplaceableTextures\\CommandButtons\\BTNSlippersOfAgility.blp")
set IDe[1]=$A
set IDe[2]=20
set IDe[3]=30
set IDe[4]=40
set IDe[5]=50
set IDe[6]=60
set Ife[1]=1
set Ife[2]=1
set Ife[3]=1
set Ife[4]=1
set Ife[5]=1
set Ife[6]=1
set IFe[1]=5
set IFe[2]=6
set IFe[3]=7
set IFe[4]=8
set IFe[5]=9
set IFe[6]=$A
set Ige[1]=2
set Ige[2]=2
set Ige[3]=2
set Ige[4]=2
set Ige[5]=2
set Ige[6]=2
set IGe[1]=$82
set IGe[2]=$AA
set IGe[3]=$D2
set IGe[4]=$FA
set IGe[5]=290
set IGe[6]=330
return true
endfunction
function NSr takes nothing returns boolean
set Ihe=WTx('BSiB',"Silent Boots",'bSiB')
set avv[(Ihe)]=(true)
set qc[(Ihe)]=(true)
set qU[(Ihe)]=(true)
set aev[(Ihe)]=("ReplaceableTextures\\CommandButtons\\BTNSlippersOfAgility.blp")
call lux(Ihe,"Abilities\\Spells\\Orc\\SpiritLink\\SpiritLinkTarget.mdl","origin",ri)
set SU=lYx()
call vOr(SU,DVv,true)
call l0x(((Ihe)),vc+(1),(SU))
set SU=lYx()
call vOr(SU,DVv,true)
call l0x(((Ihe)),vc+(2),(SU))
set SU=lYx()
call vOr(SU,DVv,true)
call l0x(((Ihe)),vc+(3),(SU))
set SU=lYx()
call vOr(SU,DVv,true)
call l0x(((Ihe)),vc+(4),(SU))
set SU=lYx()
call vOr(SU,DVv,true)
call l0x(((Ihe)),vc+(5),(SU))
set SU=lYx()
call vOr(SU,DVv,true)
call l0x(((Ihe)),vc+(6),(SU))
return true
endfunction
function Ntr takes nothing returns boolean
call VRx(qa,(function Nsr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\SilentBoots.page\\SilentBoots.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function NSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\SilentBoots.page\\SilentBoots.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function NTr takes nothing returns boolean
set IHe=Vnx(Ije)
return true
endfunction
function Nur takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local real NIo=(Eyv[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer rwx=(oPx(((CMx)),zb+(Ihe)))
local real NUr
call oYx("SilentBoots_Event_Damage","call DebugEx(SilentBoots.NAME+ \" dmg\")",Ije+" dmg")
if I6x(Ixx,yd)then
set NUr=Ife[rwx]
else
set NUr=Ige[rwx]
endif
call NIx((((Ixx))),(xZv),(1),w,((((NUr)*1.))*1.))
call NIx((((Ixx))),(Xgv),(1),w,((((NUr)*1.))*1.))
set Eyv[(rdx)]=((NIo+IDe[rwx])*1.)
return true
endfunction
function Nwr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),Ihe)
return true
endfunction
function NWr takes string rqx,real XCx returns real
if(HaveStoredString(Kv[((SH))],(rqx),("var")))then
return(S2R(((C8x(SH,(rqx),"var")))))
endif
return XCx
endfunction
function Nyr takes integer oqx,integer rRx,integer rIx returns integer
return(0+(LoadInteger(o[((V[(E[((U8[oqx]))])]))],((((Q8[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1)))))))))
endfunction
function NYr takes integer oqx,integer rRx,integer rIx,integer okx returns integer
return(LoadInteger(o[((V[(E[((U8[oqx]))])]))],((((Q8[((oqx))])))),((((1+8192*(((rRx)-1)*Iv+((rIx)-1))))+(okx)))))
endfunction
function Nzr takes integer oqx returns nothing
local integer rdx=rEx((Q8[(oqx)]))
local integer olx
local integer rIx
local integer rlx
set P8[(rdx)]=(oqx)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=Nyr(oqx,M8,rIx)
loop
exitwhen(rlx<q)
call rCx(NYr(oqx,M8,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function NZr takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((q8[oqx]))])])],((((Q8[((oqx))])))))
endfunction
function N_r takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((U8[oqx]))])])],((((Q8[((oqx))])))))
endfunction
function N0r takes integer oqx returns nothing
set Ite[oqx]=false
call NZr((oqx))
call N_r(((oqx)))
call rgx(L8)
endfunction
function N1r takes integer oqx returns nothing
if(Ise[oqx]>0)then
return
endif
if(ISe[oqx]!=Z)then
call oYx("Ubersplat_Allocation_deallocCustom_confirm","call DebugEx(Ubersplat.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",m8+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set ISe[oqx]=ISe[(w)]
set ISe[(w)]=oqx
call N0r(oqx)
endfunction
function N2r takes integer oqx returns nothing
set Ise[oqx]=Ise[oqx]-1
call N1r(oqx)
endfunction
function N3r takes integer oqx returns nothing
call Nzr(oqx)
if(Iqe[(oqx)])then
call DestroyUbersplat(IQe[oqx])
endif
call N2r((oqx))
endfunction
function N4r takes nothing returns nothing
local integer oqx=(ge[(ifx())])
call ijx(IPe[(oqx)])
call N3r((oqx))
endfunction
function N5r takes integer oqx returns nothing
if(Iqe[(oqx)])then
call DestroyUbersplat(IQe[oqx])
endif
set IQe[oqx]=CreateUbersplat((IWe[(oqx)]),(Iye[(oqx)]),x8[(IYe[(oqx)])],DMx((R2I((((ITe[(oqx)]))*1.))),0,$FF),DMx((R2I((((Iue[(oqx)]))*1.))),0,$FF),DMx((R2I((((IUe[(oqx)]))*1.))),0,$FF),DMx((R2I((((Iwe[(oqx)]))*1.))),0,$FF),(Ize[(oqx)]),(IZe[(oqx)]))
set Iqe[oqx]=(GetHandleId(IQe[oqx])!=-1)
call SetUbersplatRenderAlways(IQe[oqx],true)
endfunction
function N6r takes integer oqx,real iWx,real iyx,real iYx,real izx returns nothing
set ITe[(oqx)]=((iWx)*1.)
set Iue[(oqx)]=((iyx)*1.)
set IUe[(oqx)]=((iYx)*1.)
set Iwe[(oqx)]=((izx)*1.)
call N5r((oqx))
endfunction
function N7r takes integer oqx,real iWx,real iyx,real iYx,real izx returns nothing
call N6r(oqx,(ITe[(oqx)])+iWx,(Iue[(oqx)])+iyx,(IUe[(oqx)])+iYx,(Iwe[(oqx)])+izx)
endfunction
function N8r takes integer oqx returns integer
set u8[oqx]=true
set I2e[oqx]=false
call rax(F8)
return oqx
endfunction
function N9r takes nothing returns integer
local integer oqx
if(I0e==8190)then
call oYx("FolderUbersplat_FolderColor_StructTimed_Allocation_allocCustom","call DebugEx(FolderUbersplat_FolderColor_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",g8+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(T8[(w)]==w)then
set I1e=I1e+1
set oqx=I1e
else
set oqx=T8[(w)]
set T8[(w)]=T8[T8[(w)]]
endif
set T8[oqx]=Z
set t8[oqx]=1
call N8r(oqx)
return oqx
endfunction
function bvr takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(q8[(oqx)],(Q8[((oqx))]),oQx,oSx)
endfunction
function ber takes integer oqx,integer Xwx returns nothing
if(U8[oqx]==w)then
call oYx("FolderUbersplat_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oqx)+";"+(JA[(Xwx)]))
set U8[oqx]=X
endif
call rSx(U8[oqx],(Q8[((oqx))]),(rA[(Xwx)]),Xwx)
endfunction
function bxr takes integer oqx returns boolean
set y8=y8+1
set W8[y8]=oqx
set w8[oqx]=y8+1
return(y8==0)
endfunction
function bor takes nothing returns nothing
local integer olx=y8
local integer oqx
loop
set oqx=W8[olx]
call N7r(I7e[oqx],I3e[oqx],I4e[oqx],I5e[oqx],I6e[oqx])
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function brr takes nothing returns nothing
local integer ibx=ifx()
local integer oqx=(ge[(ibx)])
call SNx(oqx,ibx,I7e[oqx])
endfunction
function bir takes integer oqx,real iWx,real iyx,real iYx,real izx,real ilx returns nothing
local integer rkx=oqx
local integer D8x
local integer ibx
if(ilx==.0)then
call N7r(rkx,iWx,iyx,iYx,izx)
return
endif
set D8x=(R2I(((ilx*1./ I_e)*1.)))
set oqx=N9r()
set ibx=inx()
set I3e[oqx]=iWx*1./ D8x
set I4e[oqx]=iyx*1./ D8x
set I5e[oqx]=iYx*1./ D8x
set I6e[oqx]=izx*1./ D8x
set z8[oqx]=ibx
set I7e[oqx]=rkx
set ge[(ibx)]=(oqx)
call bvr(rkx,S8,oqx)
call ber(rkx,p8)
if bxr(oqx)then
call icx(Y8,I_e,true,function bor)
endif
call icx(ibx,ilx,false,function brr)
endfunction
function bar takes integer oqx,real iWx,real iyx,real iYx,real izx,real ilx returns nothing
call bir(oqx,-iWx,-iyx,-iYx,-izx,ilx)
endfunction
function bnr takes integer oqx,real ilx returns nothing
local integer ibx=inx()
set IPe[oqx]=ibx
set ge[(ibx)]=(oqx)
call icx(ibx,ilx,false,function N4r)
call bar((oqx),.0,.0,.0,(Iwe[((oqx))]),ilx)
endfunction
function bVr takes integer oqx returns integer
set Ite[oqx]=true
set Ave[oqx]=false
set q8[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
set U8[((oqx))]=(bI[(GetRandomInt((0),(NI)))])
call rax(L8)
return oqx
endfunction
function bEr takes nothing returns integer
local integer oqx
if(I8e==8190)then
call oYx("Ubersplat_Allocation_allocCustom","call DebugEx(Ubersplat.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",m8+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(ISe[(w)]==w)then
set I9e=I9e+1
set oqx=I9e
else
set oqx=ISe[(w)]
set ISe[(w)]=ISe[ISe[(w)]]
endif
set ISe[oqx]=Z
set Ise[oqx]=1
call bVr(oqx)
return oqx
endfunction
function bXr takes integer oqx returns nothing
set Q8[(oqx)]=(Axe+oqx)
endfunction
function bOr takes integer oqx,real iWx,real iyx,real iYx,real izx returns nothing
set ITe[(oqx)]=((iWx)*1.)
set Iue[(oqx)]=((iyx)*1.)
set IUe[(oqx)]=((iYx)*1.)
set Iwe[(oqx)]=((izx)*1.)
endfunction
function bRr takes integer oqx,real x,real y returns nothing
set IWe[(oqx)]=((x)*1.)
set Iye[(oqx)]=((y)*1.)
endfunction
function bIr takes integer rRx,real x,real y,real iWx,real iyx,real iYx,real izx,boolean bAr,boolean bNr returns integer
local integer oqx=bEr()
set IQe[oqx]=null
set Iqe[oqx]=false
call bXr(oqx)
set Ize[(oqx)]=(bAr)
set IZe[(oqx)]=(bNr)
set IYe[(oqx)]=(rRx)
call bOr(oqx,iWx,iyx,iYx,izx)
call bRr(oqx,x,y)
call N5r(oqx)
return oqx
endfunction
function bbr takes integer oqx,integer Iox,integer rwx returns real
set oqx=(Ifx(E[((X))],(dd),((oqx)),((Iox)),((rwx)),(w)))
if(oqx==w)then
return .0
endif
return(TimerGetRemaining(Oe[(Jd[oqx])]))
endfunction
function bBr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
local real x=(GetUnitX(C[((Ixx))]))
local real y=(GetUnitY(C[((Ixx))]))
call bnr(bIr(U7,x,y,$FF,$FF,$FF,bbr(Ixx,Ihe,IKe[oqx])*1./ IFe[IKe[oqx]]*NWr("snowAlphaFactor",1.5)*$FF,false,false),NWr("snowDur",5.))
endfunction
function bcr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer bCr=Ile[oqx]
local integer rwx=IKe[oqx]
local integer aWr=ILe[oqx]-1
local integer Ixx=oqx
set ILe[oqx]=aWr
call Iqx(Ixx,bCr)
call lZx(((bCr)),Xc+(dKv),((IGe[rwx]*(aWr*1./ Ime))*1.))
call I0x(Ixx,bCr)
endfunction
function bdr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer bCr=lYx()
local integer bDr=inx()
local integer aYr=inx()
set IKe[oqx]=rwx
set Ile[oqx]=bCr
set ILe[oqx]=Ime
set IMe[oqx]=bDr
set Ipe[oqx]=aYr
set ge[(bDr)]=(oqx)
set ge[(aYr)]=(oqx)
call I7x(Ixx,IJe)
call I7x(Ixx,Ike)
call l_x(bCr,dKv,IGe[rwx])
call I0x(Ixx,bCr)
call icx(bDr,NWr("snow",.125),true,function bBr)
call icx(aYr,IFe[rwx]*1./ Ime,true,function bcr)
return true
endfunction
function bfr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer bCr=Ile[oqx]
local integer bDr=IMe[oqx]
local integer aYr=Ipe[oqx]
call ijx(bDr)
call ijx(aYr)
call Rmx(Ixx,IJe)
call Rmx(Ixx,Ike)
call Iqx(Ixx,bCr)
call nrr(bCr)
return true
endfunction
function bFr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
call RUx((Abx((CMx),(Aoe),(Are),(ri))))
call NIx((((CMx))),(npv),(1),w,((((IFe[rwx])*1.))*1.))
call NIx((CMx),(Ihe),(rwx),w,((IFe[rwx])*1.))
return true
endfunction
function bgr takes nothing returns boolean
set IJe=XBx("SilentBoots_Init: set SilentBoots.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function SilentBoots.Event_Damage)",EZv,pI,function Nur)
set Ike=XBx("SilentBoots_Init: set SilentBoots.INVISIBILITY_EVENT = Event.Create(UNIT.Invisibility.ENDING_EVENT_TYPE, EventPriority.SPELLS, function SilentBoots.Event_InvisibilityEnding)",nSv,pI,function Nwr)
call l9x(Ihe,XBx("SilentBoots_Init: call SilentBoots.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SilentBoots.Event_BuffGain))",Bd,pI,function bdr))
call l9x(Ihe,XBx("SilentBoots_Init: call SilentBoots.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SilentBoots.Event_BuffLose))",Jc,pI,function bfr))
call meo(SXv,XBx("SilentBoots_Init: call SilentBoots.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SilentBoots.Event_SpellEffect))",ah,pI,function bFr))
call W_x(npv,Ihe)
return true
endfunction
function bGr takes nothing returns boolean
call I9r(function bgr,"SilentBoots_Init")
return true
endfunction
function bhr takes nothing returns boolean
call LZx('AStS',false)
set SRv=Lzo('AStS')
set G6[(SRv)]=(b6)
set j6[(SRv)]=(6)
set sH[(SRv)]=("Stone Shield")
set Ih[(SRv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Oj))))))
set x6v[(SRv)]=(4)
set xzv[(SRv)]=("spell")
call LZo((SRv),fH+(1),((8)*1.))
call LZo((SRv),QH+(1),((35)*1.))
call LZo((SRv),Lvv+(1),((700)*1.))
call LZo((SRv),fH+(2),((8)*1.))
call LZo((SRv),QH+(2),((45)*1.))
call LZo((SRv),Lvv+(2),((700)*1.))
call LZo((SRv),fH+(3),((8)*1.))
call LZo((SRv),QH+(3),((55)*1.))
call LZo((SRv),Lvv+(3),((700)*1.))
call LZo((SRv),fH+(4),((8)*1.))
call LZo((SRv),QH+(4),((65)*1.))
call LZo((SRv),Lvv+(4),((700)*1.))
call LZo((SRv),fH+(5),((8)*1.))
call LZo((SRv),QH+(5),((75)*1.))
call LZo((SRv),Lvv+(5),((700)*1.))
call LZo((SRv),fH+(6),((8)*1.))
call LZo((SRv),QH+(6),((85)*1.))
call LZo((SRv),Lvv+(6),((700)*1.))
set Mnv[(SRv)]=("ReplaceableTextures\\CommandButtons\\BTNArcaniteArmor.blp")
set Aie[1]=$A
set Aie[2]=$F
set Aie[3]=20
set Aie[4]=25
set Aie[5]=30
set Aie[6]=35
set Aae[1]=$A
set Aae[2]=$A
set Aae[3]=$A
set Aae[4]=$A
set Aae[5]=$A
set Aae[6]=$A
set Ane[1]=.5
set Ane[2]=.5
set Ane[3]=.5
set Ane[4]=.5
set Ane[5]=.5
set Ane[6]=.5
set AVe[1]=2
set AVe[2]=4
set AVe[3]=6
set AVe[4]=8
set AVe[5]=$A
set AVe[6]=$C
set AEe[1]=800
set AEe[2]=800
set AEe[3]=800
set AEe[4]=800
set AEe[5]=800
set AEe[6]=800
return true
endfunction
function bHr takes nothing returns boolean
set AXe=WTx('BStS',"Stone Shield",'bStS')
set avv[(AXe)]=(true)
set aev[(AXe)]=("ReplaceableTextures\\CommandButtons\\BTNArcaniteArmor.blp")
call lux(AXe,"Abilities\\Spells\\Items\\AIda\\AIdaTarget.mdl","overhead",ri)
return true
endfunction
function bjr takes nothing returns boolean
call VRx(qa,(function bhr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\StoneShield.page\\StoneShield.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function bHr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\StoneShield.page\\StoneShield.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function bJr takes nothing returns boolean
set AOe=Vnx(ARe)
return true
endfunction
function bkr takes nothing returns boolean
local integer Ixx=jFx()
if(I5x((OPe),Rb,(Ixx)))then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function bKr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer HOx=Afe[oqx]
local integer Ixx=oqx
local real x=(oJ[(HOx)])
local real y=(nJ[(HOx)])
local real dix=(GetUnitX(C[((Ixx))]))
local real dax=(GetUnitY(C[((Ixx))]))
local real dX=x-dix
local real dY=y-dax
local real N8x=(Atan2(((dY)*1.),((dX)*1.)))+Abe[oqx]
local real blr=dvx(Ixx,true)*6
set dix=dix+blr*(Cos(((((N8x)*1.))*1.)))
set dax=dax+blr*(Sin(((((N8x)*1.))*1.)))
set dX=dix-x
set dY=dax-y
set N8x=(Atan2(((dY)*1.),((dX)*1.)))
set blr=jjx(dX,dY)
if(blr>AFe[oqx])then
set blr=AFe[oqx]
endif
set x=x+blr*(Cos(((((N8x)*1.))*1.)))
set y=y+blr*(Sin(((((N8x)*1.))*1.)))
call mRx(HOx,N8x+b6v)
call QZo(HOx,x,y)
endfunction
function bLr takes integer oqx returns nothing
local integer CMx=oqx
local integer HOx=Afe[oqx]
local real x=(oJ[(HOx)])
local real y=(nJ[(HOx)])
local real z=(Vu[(HOx)])
local integer Ixx
local real NIo
call mFo(VHr(x,y,z,AJe,ri))
set Hf=(ze[(CMx)])
call Vjr(AIe,x,y,z,Ake,AAe)
set Ixx=Nao(AIe)
if(Ixx!=w)then
set NIo=ACe[oqx]
loop
call RUx((Abx((Ixx),(AKe),(Ale),(Bi))))
call nJo((CMx),(Ixx),((NIo)*1.),(false),(false))
set Ixx=Nao(AIe)
exitwhen(Ixx==w)
endloop
endif
endfunction
function bmr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer bMr=Ace[oqx]
local integer rwx=Age[oqx]
local integer aWr=AGe[oqx]-1
local integer Ixx=oqx
set AGe[oqx]=aWr
call Iqx(Ixx,bMr)
call lZx(((bMr)),Xc+(dnv),((Aie[rwx]*(aWr*1./ Ahe))*1.))
call I0x(Ixx,bMr)
call bLr(oqx)
endfunction
function bpr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(mc[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local real x=(GetUnitX(C[((CMx))]))
local real y=(GetUnitY(C[((CMx))]))
local real z=fwx(CMx)+K_x(Ixx,true)
local real dix=(GetUnitX(C[((Ixx))]))
local real dax=(GetUnitY(C[((Ixx))]))
local real dX=dix-x
local real dY=dax-y
local real N8x=(Atan2(((dY)*1.),((dX)*1.)))
local integer oqx=Ixx
local integer bMr=lYx()
local integer HOx=mcx('qStS',x,y,z,N8x)
local integer Q6o=inx()
local integer aYr=inx()
set ANe[oqx]=N8x
set Abe[oqx]=df*1./ .9*ABe
set Ace[oqx]=bMr
set ACe[oqx]=AVe[rwx]+Ane[rwx]*(EF[(CMx)])
set Ade[oqx]=ADe*ABe
set Afe[oqx]=HOx
set AFe[oqx]=AEe[rwx]*ABe
set Age[oqx]=rwx
set AGe[oqx]=Ahe
set AHe[oqx]=Q6o
set Aje[oqx]=aYr
set ge[(Q6o)]=(oqx)
set ge[(aYr)]=(oqx)
call mbx(HOx,1.5)
call oYr(HOx,-1,Aae[rwx])
call l_x(bMr,dnv,Aie[rwx])
call I0x(Ixx,bMr)
call icx(Q6o,ABe,true,function bKr)
call icx(aYr,Aae[rwx]*1./ Ahe,true,function bmr)
return true
endfunction
function bPr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer bMr=Ace[oqx]
local integer HOx=Afe[oqx]
local integer Q6o=AHe[oqx]
local integer aYr=Aje[oqx]
call Mfx(HOx)
call ijx(Q6o)
call ijx(aYr)
call Iqx(Ixx,bMr)
call nrr(bMr)
return true
endfunction
function bqr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
call Ayx(Ixx,AXe)
call NIx(Ixx,AXe,rwx,CMx,Aae[rwx])
return true
endfunction
function bQr takes nothing returns boolean
set AIe=O2x()
set AAe=XLx(function bkr)
call l9x(AXe,XBx("StoneShield_Init: call StoneShield.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function StoneShield.Event_BuffGain))",Bd,pI,function bpr))
call l9x(AXe,XBx("StoneShield_Init: call StoneShield.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function StoneShield.Event_BuffLose))",Jc,pI,function bPr))
call meo(SRv,XBx("StoneShield_Init: call StoneShield.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function StoneShield.Event_SpellEffect))",ah,pI,function bqr))
return true
endfunction
function bsr takes nothing returns boolean
call I9r(function bQr,"StoneShield_Init")
return true
endfunction
function bSr takes nothing returns boolean
set ALe=lQx(Ame+" (sleepBuff)")
set qc[(ALe)]=(true)
return true
endfunction
function btr takes nothing returns boolean
call LZx('ATaL',false)
set SNv=Lzo('ATaL')
set G6[(SNv)]=(b6)
set j6[(SNv)]=(6)
set sH[(SNv)]=("Tainted Leaf")
set Ih[(SNv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Oj))))))
set x6v[(SNv)]=(4)
set xzv[(SNv)]=("spell")
call LZo((SNv),u6v+(1),(($C8)*1.))
call LZo((SNv),fH+(1),((6)*1.))
call LZo((SNv),QH+(1),((70)*1.))
call LZo((SNv),Lvv+(1),((800)*1.))
call LZo((SNv),u6v+(2),(($C8)*1.))
call LZo((SNv),fH+(2),((6)*1.))
call LZo((SNv),QH+(2),((70)*1.))
call LZo((SNv),Lvv+(2),((800)*1.))
call LZo((SNv),u6v+(3),(($C8)*1.))
call LZo((SNv),fH+(3),((6)*1.))
call LZo((SNv),QH+(3),((70)*1.))
call LZo((SNv),Lvv+(3),((800)*1.))
call LZo((SNv),u6v+(4),(($C8)*1.))
call LZo((SNv),fH+(4),((6)*1.))
call LZo((SNv),QH+(4),((70)*1.))
call LZo((SNv),Lvv+(4),((800)*1.))
call LZo((SNv),u6v+(5),(($C8)*1.))
call LZo((SNv),fH+(5),((6)*1.))
call LZo((SNv),QH+(5),((70)*1.))
call LZo((SNv),Lvv+(5),((800)*1.))
call LZo((SNv),u6v+(6),(($C8)*1.))
call LZo((SNv),fH+(6),((6)*1.))
call LZo((SNv),QH+(6),((70)*1.))
call LZo((SNv),Lvv+(6),((800)*1.))
set Mnv[(SNv)]=("ReplaceableTextures\\CommandButtons\\BTNRejuvenation.blp")
set AMe[1]='d'
set AMe[2]=$96
set AMe[3]=$C8
set AMe[4]=$FA
set AMe[5]=300
set AMe[6]=350
set Ape[1]=8
set Ape[2]=8
set Ape[3]=8
set Ape[4]=8
set Ape[5]=8
set Ape[6]=8
set APe[1]=3
set APe[2]=3
set APe[3]=3
set APe[4]=3
set APe[5]=3
set APe[6]=3
set Aqe[1]=3
set Aqe[2]=4
set Aqe[3]=5
set Aqe[4]=6
set Aqe[5]=7
set Aqe[6]=8
set AQe[1]=.05
set AQe[2]=.1
set AQe[3]=.15
set AQe[4]=.2
set AQe[5]=.25
set AQe[6]=.3
set Ase[1]=80
set Ase[2]='d'
set Ase[3]='x'
set Ase[4]=$8C
set Ase[5]=$A0
set Ase[6]=$B4
set ASe[1]=25
set ASe[2]=40
set ASe[3]=55
set ASe[4]=70
set ASe[5]=85
set ASe[6]='d'
return true
endfunction
function bTr takes nothing returns boolean
set Ate=WTx('BTaL',"Tainted Leaf",'bTaL')
set avv[(Ate)]=(true)
set qU[(Ate)]=(true)
set aev[(Ate)]=("ReplaceableTextures\\CommandButtons\\BTNRejuvenation.blp")
set SU=lYx()
call vOr(SU,Dhv,true)
call l_x(SU,cAv,'d')
call lzx(((SU)),Fc,(rWo(Db,$FF,-$7F,$FF,0)))
call l0x(((Ate)),vc+(1),(SU))
set SU=lYx()
call vOr(SU,Dhv,true)
call l_x(SU,cAv,$96)
call lzx(((SU)),Fc,(rWo(Db,$FF,-$7F,$FF,0)))
call l0x(((Ate)),vc+(2),(SU))
set SU=lYx()
call vOr(SU,Dhv,true)
call l_x(SU,cAv,$C8)
call lzx(((SU)),Fc,(rWo(Db,$FF,-$7F,$FF,0)))
call l0x(((Ate)),vc+(3),(SU))
set SU=lYx()
call vOr(SU,Dhv,true)
call l_x(SU,cAv,$FA)
call lzx(((SU)),Fc,(rWo(Db,$FF,-$7F,$FF,0)))
call l0x(((Ate)),vc+(4),(SU))
set SU=lYx()
call vOr(SU,Dhv,true)
call l_x(SU,cAv,300)
call lzx(((SU)),Fc,(rWo(Db,$FF,-$7F,$FF,0)))
call l0x(((Ate)),vc+(5),(SU))
set SU=lYx()
call vOr(SU,Dhv,true)
call l_x(SU,cAv,350)
call lzx(((SU)),Fc,(rWo(Db,$FF,-$7F,$FF,0)))
call l0x(((Ate)),vc+(6),(SU))
return true
endfunction
function bur takes nothing returns boolean
set ATe=lQx(Ame+" (castBuff)")
return true
endfunction
function bUr takes nothing returns boolean
call VRx(Ma,(function bSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\TaintedLeaf.page\\TaintedLeaf.struct\\obj_sleepBuff_wc3buff.j"))
call VRx(qa,(function btr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\TaintedLeaf.page\\TaintedLeaf.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function bTr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\TaintedLeaf.page\\TaintedLeaf.struct\\obj_taintedBuff_wc3buff.j"))
call VRx(Ma,(function bur),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\TaintedLeaf.page\\TaintedLeaf.struct\\obj_castBuff_wc3buff.j"))
return true
endfunction
function bwr takes nothing returns boolean
set Aue=Vnx(Ame)
return true
endfunction
function bWr takes nothing returns boolean
local integer Ixx=jFx()
if(Ixx==Ib)then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function byr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=Awe
local integer Ixx=AWe
local real dix=Aye
local real dax=AYe
local integer Q7o=O2x()
local integer oqx=CMx
set Aze[oqx]=Q7o
set Hf=(ze[(CMx)])
set Ib=Ixx
call Nio(Q7o,dix,dax,(Cpx((SNv),u6v+(rwx))),AUe)
return true
endfunction
function bYr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer oqx=CMx
local integer Q7o=Aze[oqx]
call O6x(Q7o)
return true
endfunction
function bzr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
local integer CMx=AZe[oqx]
local integer rwx=A0e[oqx]
call moo(CMx,Ixx,A2e[rwx])
endfunction
function bZr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(mc[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=inx()
set AZe[oqx]=CMx
set A_e[oqx]=p0x
set A0e[oqx]=rwx
set ge[(p0x)]=(oqx)
call icx(p0x,A1e,true,function bzr)
return true
endfunction
function b_r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=A_e[oqx]
local integer rwx=A0e[oqx]
call ijx(p0x)
return true
endfunction
function b0r takes nothing returns boolean
local integer rdx=(bv)
set Awe=(Mv[(rdx)])
set AWe=(WH[(rdx)])
set Aye=(UH[(rdx)])
set AYe=(wH[(rdx)])
call DSx(((Vv[(rdx)])),(ATe),(1),w)
return true
endfunction
function b1r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local real O1o=(Cpx((SNv),u6v+(rwx)))
local real NIo=ASe[rwx]
local integer Q7o=Aze[(CMx)]
local integer Ajo=(uf[(Ixx)])
local real dix=(GetUnitX(C[((Ixx))]))
local real dax=(GetUnitY(C[((Ixx))]))
call A7o(Nvo(dix,dax,A3e,Bi,O1o*1./ 160.))
if(IsUnitAlly(C[(Ixx)],vx[((ze[(CMx)]))]))then
call NIx((Ixx),(Ate),(rwx),(CMx),((Ape[rwx])*1.))
call moo(CMx,Ixx,(AQe[rwx]*(iG[(Ixx)]))*(1.-RJo(Ixx==CMx)*(1.-A4e)))
else
if I6x(Ixx,yd)then
call NIx((Ixx),(ALe),(rwx),w,((APe[rwx])*1.))
else
call NIx((Ixx),(ALe),(rwx),w,((Aqe[rwx])*1.))
endif
set Ixx=Nao(Q7o)
if(Ixx!=w)then
loop
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
set Ixx=Nao(Q7o)
exitwhen(Ixx==w)
endloop
endif
endif
return true
endfunction
function b2r takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),ATe)
return true
endfunction
function b3r takes nothing returns boolean
local integer i
set AUe=XLx(function bWr)
call l9x(ATe,XBx("TaintedLeaf_Init: call TaintedLeaf.CAST_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TaintedLeaf.Event_Cast_BuffGain))",Bd,pI,function byr))
call l9x(ATe,XBx("TaintedLeaf_Init: call TaintedLeaf.CAST_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TaintedLeaf.Event_Cast_BuffLose))",Jc,pI,function bYr))
call l9x(Ate,XBx("TaintedLeaf_Init: call TaintedLeaf.TAINTED_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TaintedLeaf.Event_BuffGain))",Bd,pI,function bZr))
call l9x(Ate,XBx("TaintedLeaf_Init: call TaintedLeaf.TAINTED_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TaintedLeaf.Event_BuffLose))",Jc,pI,function b_r))
call meo(SNv,XBx("TaintedLeaf_Init: call TaintedLeaf.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Begin.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TaintedLeaf.Event_Cast))",C9v,pI,function b0r))
call meo(SNv,XBx("TaintedLeaf_Init: call TaintedLeaf.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TaintedLeaf.Event_SpellEffect))",ah,pI,function b1r))
call meo(SNv,XBx("TaintedLeaf_Init: call TaintedLeaf.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TaintedLeaf.Event_EndCast))",oev,pI,function b2r))
call W_x(XKv,ALe)
set i=(j6[(SNv)])
loop
exitwhen(i<1)
set A2e[i]=Ase[i]*1./(R2I(((Ape[i]*1./ A1e)*1.)))
set i=i-1
endloop
return true
endfunction
function b4r takes nothing returns boolean
call I9r(function b3r,"TaintedLeaf_Init")
return true
endfunction
function b5r takes nothing returns boolean
set A5e[1]=2
set A5e[2]=2
set A5e[3]=2
set A5e[4]=2
set A5e[5]=2
set A6e[1]=.5
set A6e[2]=.5
set A6e[3]=.5
set A6e[4]=.5
set A6e[5]=.5
set A7e[1]=6
set A7e[2]=6
set A7e[3]=6
set A7e[4]=6
set A7e[5]=6
set A8e[1]=2
set A8e[2]=2
set A8e[3]=3
set A8e[4]=3
set A8e[5]=4
return true
endfunction
function b6r takes nothing returns boolean
set A9e=lQx(Nve+" (activeBuff)")
call lux(A9e,"VioletEarring_page\\VioletEarring_struct\\Charge\\WeaponEffectGreen.mdx","weapon",ri)
return true
endfunction
function b7r takes nothing returns boolean
call LZx('AVEX',false)
return true
endfunction
function b8r takes nothing returns boolean
set Nee=lQx(Nve+" (dummyBuff)")
return true
endfunction
function b9r takes nothing returns boolean
set Nxe=lQx(Nve+" (banishBuff)")
return true
endfunction
function Bvr takes nothing returns boolean
set Noe=lQx(Nve+" (cooldownBuff)")
return true
endfunction
function Ber takes nothing returns boolean
call VRx(ea,(function b5r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\VioletEarring.page\\VioletEarring.struct\\Charge\\obj_this_wc3obj.j"))
call VRx(Ma,(function b6r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\VioletEarring.page\\VioletEarring.struct\\Charge\\obj_activeBuff_wc3buff.j"))
call VRx(qa,(function b7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\VioletEarring.page\\VioletEarring.struct\\Charge\\obj_missileArtSpell_wc3spell.j"))
call VRx(Ma,(function b8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\VioletEarring.page\\VioletEarring.struct\\Charge\\obj_dummyBuff_wc3buff.j"))
call VRx(Ma,(function b9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\VioletEarring.page\\VioletEarring.struct\\Charge\\obj_banishBuff_wc3buff.j"))
call VRx(Ma,(function Bvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\VioletEarring.page\\VioletEarring.struct\\Charge\\obj_cooldownBuff_wc3buff.j"))
return true
endfunction
function Bxr takes nothing returns boolean
set Nre=Vnx(Nve)
return true
endfunction
function Bor takes nothing returns boolean
set Nie=lQx(Nae+" (dummyBuff)")
call lux(Nie,"VioletEarring_page\\VioletEarring_struct\\Port\\PortCircle.mdx","origin",ri)
return true
endfunction
function Brr takes nothing returns boolean
call VRx(Ma,(function Bor),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\VioletEarring.page\\VioletEarring.struct\\Port\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function Bir takes nothing returns boolean
set Nne=Vnx(Nae)
return true
endfunction
function Bar takes nothing returns boolean
call LZx('AViE',false)
set SOv=Lzo('AViE')
set G6[(SOv)]=(b6)
set j6[(SOv)]=(6)
set sH[(SOv)]=("Violet Earring")
set Ih[(SOv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Oj))))))
set x6v[(SOv)]=(4)
set xzv[(SOv)]=("spell")
call LZo((SOv),fH+(1),((40)*1.))
call LZo((SOv),QH+(1),((0)*1.))
call LZo((SOv),Lvv+(1),(($3E8)*1.))
call LZo((SOv),fH+(2),((38)*1.))
call LZo((SOv),QH+(2),((0)*1.))
call LZo((SOv),Lvv+(2),(($3E8)*1.))
call LZo((SOv),fH+(3),((36)*1.))
call LZo((SOv),QH+(3),((0)*1.))
call LZo((SOv),Lvv+(3),(($3E8)*1.))
call LZo((SOv),fH+(4),((34)*1.))
call LZo((SOv),QH+(4),((0)*1.))
call LZo((SOv),Lvv+(4),(($3E8)*1.))
call LZo((SOv),fH+(5),((32)*1.))
call LZo((SOv),QH+(5),((0)*1.))
call LZo((SOv),Lvv+(5),(($3E8)*1.))
call LZo((SOv),fH+(6),((30)*1.))
call LZo((SOv),QH+(6),((0)*1.))
call LZo((SOv),Lvv+(6),(($3E8)*1.))
set Mnv[(SOv)]=("ReplaceableTextures\\CommandButtons\\BTNHeartOfAszune.blp")
set NVe[1]=$A0
set NVe[2]=$FA
set NVe[3]=340
set NVe[4]=430
set NVe[5]=520
set NVe[6]=610
return true
endfunction
function Bnr takes nothing returns boolean
call VRx(qa,(function Bar),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\VioletEarring.page\\VioletEarring.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function BVr takes nothing returns boolean
set NEe=Vnx(NXe)
return true
endfunction
function BEr takes integer oqx returns integer
set NBe[oqx]=true
set Nce[oqx]=false
call rax(Nne)
return oqx
endfunction
function BXr takes nothing returns integer
local integer oqx
if(NIe==8190)then
call oYx("FolderVioletEarring_StructPort_Allocation_allocCustom","call DebugEx(FolderVioletEarring_StructPort.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Nae+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(NAe[(w)]==w)then
set NNe=NNe+1
set oqx=NNe
else
set oqx=NAe[(w)]
set NAe[(w)]=NAe[NAe[(w)]]
endif
set NAe[oqx]=Z
set Nbe[oqx]=1
call BEr(oqx)
return oqx
endfunction
function BOr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer rkx=NCe[oqx]
local integer CMx=(aH[(rkx)])
local integer rwx=(XH[(rkx)])
local real wpo
local real wPo
call Mdo(MFo)
set wpo=(GetUnitX(C[((CMx))]))
set wPo=(GetUnitY(C[((CMx))]))
call RUx((Abx((CMx),(NDe),(Nfe),(ri))))
call fWx(CMx,(GetUnitX(C[((Ixx))])),(GetUnitY(C[((Ixx))])))
call RUx((Abx((Ixx),(NDe),(Nfe),(ri))))
call fWx(Ixx,wpo,wPo)
call UJx(CMx,Nie)
call UJx(Ixx,Nie)
return true
endfunction
function BRr takes integer rkx returns nothing
local integer CMx=(aH[(rkx)])
local integer Ixx=(Uh[(rkx)])
local integer oqx=BXr()
local integer MFo=Mvo()
set NCe[oqx]=rkx
call UNx(rkx)
call DSx((CMx),(Nie),(1),w)
call DSx((Ixx),(Nie),(1),w)
call Mvx(MFo,Nde)
set mAv[((MFo))]=((b6v*((.0)*1.))*1.)
set mNv[(MFo)]=((10.)*1.)
set mCv[(MFo)]=XHx((function BOr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,600.)
call M9o(MFo,CMx)
call M3o((MFo),(Ixx),.0,.0,.0,(function M5o))
call Mro(MFo,'qViE',1.)
endfunction
function BIr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer CQx=(uH[(rdx)])
call RUx((Abx((CMx),(NOe),(NRe),(ri))))
call Dnx((CMx),(g2v))
call Dnx((CMx),(g3v))
call BRx(CMx,NVe[rwx])
if(CMx!=Ixx)then
call BRr(CQx)
endif
return true
endfunction
function BAr takes nothing returns boolean
local integer rdx=(bv)
local real nyx=(Eyv[(rdx)])
local integer CMx=(EYv[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer rwx=(oPx(((CMx)),zb+(A9e)))
local real BNr
if((GetUnitAbilityLevel(C[((Ixx))],('BVEX')))==0)then
return true
endif
call UnitRemoveAbility(C[((Ixx))],('BVEX'))
if I6x(Ixx,yd)then
set BNr=A6e[rwx]
else
set BNr=A5e[rwx]
endif
call NIx((Ixx),(Nxe),(rwx),w,((BNr)*1.))
call NIx((CMx),(Noe),(rwx),w,((A7e[rwx])*1.))
set Eyv[(rdx)]=((nyx*A8e[rwx])*1.)
return true
endfunction
function Bbr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
call I7x(CMx,NFe)
call rQx(CMx,'AVEX')
return true
endfunction
function BBr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Hc[(rdx)])
call Rmx(CMx,NFe)
call UnitRemoveAbility(C[((CMx))],('AVEX'))
return true
endfunction
function Bcr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
call Ayx(CMx,A9e)
return true
endfunction
function BCr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer oqx=CMx
if Nge[oqx]then
call DSx((CMx),(A9e),(rwx),w)
endif
return true
endfunction
function Bdr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer oqx=CMx
set Nge[oqx]=true
call DSx((CMx),(A9e),(rwx),w)
return true
endfunction
function BDr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer oqx=CMx
set Nge[oqx]=false
call Ayx(CMx,A9e)
call Ayx(CMx,Noe)
return true
endfunction
function Bfr takes nothing returns boolean
local integer rdx=(bv)
call Q8o((Vv[(rdx)]),Nee,(Mv[(rdx)]))
return true
endfunction
function BFr takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(Nee),((Mv[(rdx)])),w)
return true
endfunction
function Bgr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),Nee)
return true
endfunction
function BGr takes nothing returns nothing
set NFe=XBx("FolderVioletEarring_StructCharge_Init: set FolderVioletEarring_StructCharge.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_Damage)",EZv,pI,function BAr)
call l9x(A9e,XBx("FolderVioletEarring_StructCharge_Init: call FolderVioletEarring_StructCharge.ACTIVE_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_ActiveBuffGain))",Bd,pI,function Bbr))
call l9x(A9e,XBx("FolderVioletEarring_StructCharge_Init: call FolderVioletEarring_StructCharge.ACTIVE_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_ActiveBuffLose))",Jc,pI,function BBr))
call l9x(Noe,XBx("FolderVioletEarring_StructCharge_Init: call FolderVioletEarring_StructCharge.COOLDOWN_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_CooldownBuffGain))",Bd,pI,function Bcr))
call l9x(Noe,XBx("FolderVioletEarring_StructCharge_Init: call FolderVioletEarring_StructCharge.COOLDOWN_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_CooldownBuffLose))",Jc,pI,function BCr))
call l9x(Nee,XBx("FolderVioletEarring_StructCharge_Init: call FolderVioletEarring_StructCharge.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_BuffGain))",Bd,pI,function Bdr))
call l9x(Nee,XBx("FolderVioletEarring_StructCharge_Init: call FolderVioletEarring_StructCharge.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_BuffLose))",Jc,pI,function BDr))
call meo(SOv,XBx("FolderVioletEarring_StructCharge_Init: call VioletEarring.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_ChangeLevel))",Pv,pI,function Bfr))
call meo(SOv,XBx("FolderVioletEarring_StructCharge_Init: call VioletEarring.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_Learn))",pv,pI,function BFr))
call meo(SOv,XBx("FolderVioletEarring_StructCharge_Init: call VioletEarring.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_Unlearn))",Av,pI,function Bgr))
call W_x(Eav,Nxe)
endfunction
function Bhr takes integer oqx returns nothing
set NBe[oqx]=false
call rgx(Nne)
endfunction
function BHr takes integer oqx returns nothing
if(Nbe[oqx]>0)then
return
endif
if(NAe[oqx]!=Z)then
call oYx("FolderVioletEarring_StructPort_Allocation_deallocCustom_confirm","call DebugEx(FolderVioletEarring_StructPort.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Nae+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set NAe[oqx]=NAe[(w)]
set NAe[(w)]=oqx
call Bhr(oqx)
endfunction
function Bjr takes integer oqx returns nothing
set Nbe[oqx]=Nbe[oqx]-1
call BHr(oqx)
endfunction
function BJr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer rkx=NCe[oqx]
call mZx(MFo,Nde)
call UPx(rkx)
call Bjr((oqx))
return true
endfunction
function Bkr takes nothing returns boolean
call meo(SOv,XBx("VioletEarring_Init: call VioletEarring.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function VioletEarring.Event_SpellEffect))",ah,pI,function BIr))
call BGr()
set Nde=XBx("FolderVioletEarring_StructPort_Init: set FolderVioletEarring_StructPort.MISSILE_DESTROY_EVENT = Event.Create(Missile.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructPort.Event_Missile_Destroy)",tY,pI,function BJr)
return true
endfunction
function BKr takes nothing returns boolean
call I9r(function Bkr,"VioletEarring_Init")
return true
endfunction
function Blr takes nothing returns boolean
set NGe[1]=5
set NGe[2]=6
set NGe[3]=7
set NGe[4]=8
set NGe[5]=9
set NGe[6]=$A
set Nhe[1]=30
set Nhe[2]=40
set Nhe[3]=50
set Nhe[4]=60
set Nhe[5]=70
set Nhe[6]=80
set NHe[1]=2.5
set NHe[2]=3
set NHe[3]=3.5
set NHe[4]=4
set NHe[5]=4.5
set NHe[6]=5
return true
endfunction
function BLr takes nothing returns boolean
set Nje=lQx(NJe+" (poisonBuff)")
set qc[(Nje)]=(true)
set qU[(Nje)]=(true)
return true
endfunction
function Bmr takes nothing returns boolean
call VRx(ea,(function Blr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\Vomit.page\\Vomit.struct\\Target\\obj_this_wc3obj.j"))
call VRx(Ma,(function BLr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\Vomit.page\\Vomit.struct\\Target\\obj_poisonBuff_wc3buff.j"))
return true
endfunction
function BMr takes nothing returns boolean
set Nke=Vnx(NJe)
return true
endfunction
function Bpr takes nothing returns boolean
call LZx('AVom',false)
set NKe=Lzo('AVom')
set G6[(NKe)]=(b6)
set j6[(NKe)]=(6)
set sH[(NKe)]=("Vomit")
set Ih[(NKe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Oj))))))
set x6v[(NKe)]=(4)
set xzv[(NKe)]=("spell")
call LZo((NKe),u6v+(1),(('}')*1.))
call LZo((NKe),fH+(1),((3)*1.))
call LZo((NKe),QH+(1),((25)*1.))
call LZo((NKe),Lvv+(1),((700)*1.))
call LZo((NKe),u6v+(2),(('}')*1.))
call LZo((NKe),fH+(2),((3)*1.))
call LZo((NKe),QH+(2),((30)*1.))
call LZo((NKe),Lvv+(2),((700)*1.))
call LZo((NKe),u6v+(3),(('}')*1.))
call LZo((NKe),fH+(3),((3)*1.))
call LZo((NKe),QH+(3),((35)*1.))
call LZo((NKe),Lvv+(3),((700)*1.))
call LZo((NKe),u6v+(4),(('}')*1.))
call LZo((NKe),fH+(4),((3)*1.))
call LZo((NKe),QH+(4),((40)*1.))
call LZo((NKe),Lvv+(4),((700)*1.))
call LZo((NKe),u6v+(5),(('}')*1.))
call LZo((NKe),fH+(5),((3)*1.))
call LZo((NKe),QH+(5),((45)*1.))
call LZo((NKe),Lvv+(5),((700)*1.))
call LZo((NKe),u6v+(6),(('}')*1.))
call LZo((NKe),fH+(6),((3)*1.))
call LZo((NKe),QH+(6),((50)*1.))
call LZo((NKe),Lvv+(6),((700)*1.))
set Mnv[(NKe)]=("ReplaceableTextures\\CommandButtons\\BTNCorrosiveBreath.blp")
set Nle[1]=$A
set Nle[2]=20
set Nle[3]=30
set Nle[4]=40
set Nle[5]=50
set Nle[6]=60
return true
endfunction
function BPr takes nothing returns boolean
call VRx(qa,(function Bpr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\Vomit.page\\Vomit.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Bqr takes nothing returns boolean
set NLe=Vnx(Nme)
return true
endfunction
function BQr takes integer Ixx returns boolean
return( not(I6x(Ixx,sc)))and( not((I6x(Ib,INv)!=I6x(Ixx,sc))and(I6x(Ib,Ivv)!=I6x(Ixx,Ivv))))and( not(I6x(Ixx,ICv)))and( not(IsUnitAlly(C[(Ixx)],vx[(Hf)])))
endfunction
function Bsr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer Ixx=jFx()
local integer oqx=(mWv[(MFo)])
if(I5x((NPe[oqx]),Rb,(Ixx)))then
return false
endif
if not BQr(Ixx)then
return false
endif
return true
return true
endfunction
function BSr takes nothing returns boolean
return BQr(jFx())
return true
endfunction
function Btr takes integer oqx returns integer
set NTe[oqx]=true
set Nue[oqx]=false
call rax(NLe)
return oqx
endfunction
function BTr takes nothing returns integer
local integer oqx
if(NQe==8190)then
call oYx("Vomit_Allocation_allocCustom","call DebugEx(Vomit.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Nme+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Nse[(w)]==w)then
set NSe=NSe+1
set oqx=NSe
else
set oqx=Nse[(w)]
set Nse[(w)]=Nse[Nse[(w)]]
endif
set Nse[oqx]=Z
set Nte[oqx]=1
call Btr(oqx)
return oqx
endfunction
function Bur takes integer oqx returns nothing
set NTe[oqx]=false
call rgx(NLe)
endfunction
function BUr takes integer oqx returns nothing
if(Nte[oqx]>0)then
return
endif
if(Nse[oqx]!=Z)then
call oYx("Vomit_Allocation_deallocCustom_confirm","call DebugEx(Vomit.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Nme+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set Nse[oqx]=Nse[(w)]
set Nse[(w)]=oqx
call Bur(oqx)
endfunction
function Bwr takes integer oqx returns nothing
set Nte[oqx]=Nte[oqx]-1
call BUr(oqx)
endfunction
function BWr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=NUe[oqx]
local integer rwx=Nwe[oqx]
local integer Ixx=Nye[oqx]
local integer CQx=NYe[oqx]
local real NIo
call Bwr((oqx))
call Mdo(MFo)
set Hf=(ze[(CMx)])
set Ib=Ixx
call Nio(NMe,(GetUnitX(C[((Ixx))])),(GetUnitY(C[((Ixx))])),(Cpx((NKe),u6v+(rwx)))*NWe[oqx],Nqe)
call GroupRemoveUnit(Kb[(NMe)],C[(Ixx)])
set Ixx=Nao(NMe)
if(Ixx!=w)then
set NIo=Nle[rwx]
loop
call nJo((CMx),(Ixx),((NIo)*1.),(false),(false))
set Ixx=Nao(NMe)
exitwhen(Ixx==w)
endloop
endif
call dRx(CQx)
return true
endfunction
function Byr takes integer oqx,integer rwx,integer Ixx returns nothing
local real ilx
if I6x(Ixx,yd)then
set ilx=NHe[rwx]
else
set ilx=NGe[rwx]
endif
call NIx(Ixx,Nje,rwx,N_e[oqx],ilx)
endfunction
function BYr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=(mWv[(MFo)])
call dpx(NPe[oqx],Ixx)
call Byr((w),Nwe[oqx],Ixx)
return true
endfunction
function Bzr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local real Mpx=XYx(dix,dax)+60.
local real D7x=(ob[(CMx)])
local integer oqx=BTr()
local integer MFo=Mvo()
local integer CQx=Cmx(CMx,NKe)
set NUe[oqx]=CMx
set Nwe[oqx]=(XH[(CQx)])
set NWe[oqx]=D7x
set Nye[oqx]=Nye[oqx]
set NYe[oqx]=CQx
set Nze[oqx]=(GetUnitX(C[((CMx))]))
set NZe[oqx]=(GetUnitY(C[((CMx))]))
set mAv[((MFo))]=((b6v*((.06)*1.))*1.)
set mNv[(MFo)]=(((Cpx((NKe),u6v+(Nwe[oqx]))))*1.)
call Mro(MFo,'qVom',D7x)
set mCv[(MFo)]=XHx((function BWr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,900.)
call M9o(MFo,CMx)
call o6r(MFo,dix,dax,Mpx)
call rQr(MFo,function BYr,Npe)
return true
endfunction
function BZr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
call nJo((N_e[oqx]),(Ixx),((N1e[oqx])*1.),(false),(false))
endfunction
function B_r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(mc[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local real ilx
local integer D8x
local integer oqx
local integer p0x
if I6x(Ixx,yd)then
set ilx=NHe[rwx]
else
set ilx=NGe[rwx]
endif
set D8x=(R2I(((ilx*1./ N0e)*1.)))
set oqx=Ixx
set p0x=inx()
set N_e[oqx]=CMx
set N1e[oqx]=Nhe[rwx]*1./ D8x
set N2e[oqx]=p0x
set ge[(p0x)]=(oqx)
call icx(p0x,N0e,true,function BZr)
return true
endfunction
function B0r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=N2e[oqx]
call ijx(p0x)
return true
endfunction
function B1r takes nothing returns nothing
call l9x(Nje,XBx("FolderVomit_StructTarget_Init: call FolderVomit_StructTarget.POISON_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVomit_StructTarget.BuffGain))",Bd,pI,function B_r))
call l9x(Nje,XBx("FolderVomit_StructTarget_Init: call FolderVomit_StructTarget.POISON_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVomit_StructTarget.BuffLose))",Jc,pI,function B0r))
call W_x(XNv,Nje)
endfunction
function B2r takes nothing returns boolean
set NMe=O2x()
set Npe=XLx(function Bsr)
set Nqe=XLx(function BSr)
call meo(NKe,XBx("Vomit_Init: call Vomit.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Vomit.Event_SpellEffect))",ah,pI,function Bzr))
call B1r()
return true
endfunction
function B3r takes nothing returns boolean
call I9r(function B2r,"Vomit_Init")
return true
endfunction
function B4r takes nothing returns boolean
set N3e[1]=30
set N3e[2]=40
set N3e[3]=50
set N3e[4]=60
set N3e[5]=70
set N3e[6]=80
return true
endfunction
function B5r takes nothing returns boolean
set N4e=WTx('BWhS',"White Staff",'bWhS')
set avv[(N4e)]=(true)
set aev[(N4e)]=("ReplaceableTextures\\CommandButtons\\BTNAdvancedStrengthOfTheMoon.blp")
call lux(N4e,"Abilities\\Spells\\Items\\AIil\\AIilTarget.mdl","origin",ri)
set SU=lYx()
call l_x(SU,cov,30)
call l0x(((N4e)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,cov,40)
call l0x(((N4e)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,cov,50)
call l0x(((N4e)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,cov,60)
call l0x(((N4e)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,cov,70)
call l0x(((N4e)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,cov,80)
call l0x(((N4e)),vc+(6),(SU))
return true
endfunction
function B6r takes nothing returns boolean
call VRx(ea,(function B4r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\WhiteStaff.page\\WhiteStaff.struct\\Target\\obj_this_wc3obj.j"))
call VRx(Ma,(function B5r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\WhiteStaff.page\\WhiteStaff.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function B7r takes nothing returns boolean
set N5e=Vnx(N6e)
return true
endfunction
function B8r takes nothing returns boolean
set N7e=u1x()
set AC[(N7e)]=("Abilities\\Spells\\Other\\Drain\\SiphonManaLoop.wav")
set bC[(N7e)]=(k5)
set cC[(N7e)]=(h5)
set dC[(N7e)]=((1)*1.)
set fC[(N7e)]=((1)*1.)
set gC[(N7e)]=($A)
set hC[(N7e)]=((1)*1.)
set KC[(N7e)]=(true)
set MC[(N7e)]=(true)
set PC[(N7e)]=((600)*1.)
set QC[(N7e)]=(($186A0)*1.)
set SC[(N7e)]=(($7D0)*1.)
return true
endfunction
function B9r takes nothing returns boolean
set N8e=Vbx("OWhS")
return true
endfunction
function cvr takes nothing returns boolean
call LZx('AWhS',false)
set SEv=Lzo('AWhS')
set G6[(SEv)]=(b6)
set j6[(SEv)]=(6)
set sH[(SEv)]=("White Staff")
set Ih[(SEv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Oj))))))
set x6v[(SEv)]=(4)
set xzv[(SEv)]=("spell")
call LZo((SEv),BH+(1),((5)*1.))
call LZo((SEv),fH+(1),(($A)*1.))
call LZo((SEv),QH+(1),((5)*1.))
call LZo((SEv),Lvv+(1),((700)*1.))
call LZo((SEv),BH+(2),((4.75)*1.))
call LZo((SEv),fH+(2),(($A)*1.))
call LZo((SEv),QH+(2),((5)*1.))
call LZo((SEv),Lvv+(2),((700)*1.))
call LZo((SEv),BH+(3),((4.5)*1.))
call LZo((SEv),fH+(3),(($A)*1.))
call LZo((SEv),QH+(3),((5)*1.))
call LZo((SEv),Lvv+(3),((700)*1.))
call LZo((SEv),BH+(4),((4.25)*1.))
call LZo((SEv),fH+(4),(($A)*1.))
call LZo((SEv),QH+(4),((5)*1.))
call LZo((SEv),Lvv+(4),((700)*1.))
call LZo((SEv),BH+(5),((4)*1.))
call LZo((SEv),fH+(5),(($A)*1.))
call LZo((SEv),QH+(5),((5)*1.))
call LZo((SEv),Lvv+(5),((700)*1.))
call LZo((SEv),BH+(6),((3.75)*1.))
call LZo((SEv),fH+(6),(($A)*1.))
call LZo((SEv),QH+(6),((5)*1.))
call LZo((SEv),Lvv+(6),((700)*1.))
set Mnv[(SEv)]=("ReplaceableTextures\\CommandButtons\\BTNAdvancedStrengthOfTheMoon.blp")
set N9e[1]=8
set N9e[2]=$C
set N9e[3]=16
set N9e[4]=20
set N9e[5]=24
set N9e[6]=28
return true
endfunction
function cer takes nothing returns boolean
call VRx(ma,(function B8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\WhiteStaff.page\\WhiteStaff.struct\\obj_dummySound_wc3sound.j"))
call VRx(Ha,(function B9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\WhiteStaff.page\\WhiteStaff.struct\\obj_bolt_wc3bolt.j"))
call VRx(qa,(function cvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\WhiteStaff.page\\WhiteStaff.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function cxr takes nothing returns boolean
set bve=Vnx(bee)
return true
endfunction
function cor takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=oqx
call mro(CMx,CMx,bae[oqx])
endfunction
function crr takes integer CMx,integer rwx,integer Ixx returns nothing
local integer oqx=CMx
local integer clo=cBo(N8e)
local integer p0x=inx()
set bxe[oqx]=true
set boe[oqx]=Ahx(N7e)
set bre[oqx]=clo
set bie[oqx]=p0x
set bae[oqx]=bne[rwx]
set bVe[oqx]=Ixx
set ge[(p0x)]=(oqx)
call Ajx(boe[oqx],CMx)
call EEr(clo,CMx,Ixx)
if I6x(Ixx,Idv)then
set bEe[oqx]=true
call DSx((((Ixx))),(r9v),(1),w)
call D6x(Ixx,bXe*(Tj[((uf[(Ixx)]))]),(Cpx((SEv),BH+(rwx))))
else
set bEe[oqx]=false
endif
call icx(p0x,bOe,true,function cor)
if(IsUnitAlly(C[(Ixx)],vx[((ze[(CMx)]))]))then
set bRe[oqx]=APx(Ixx,N4e,rwx,w)
else
set bRe[oqx]=w
endif
endfunction
function cir takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
call crr(CMx,rwx,Ixx)
return true
endfunction
function car takes integer CMx returns nothing
local integer oqx=CMx
local integer clo=bre[oqx]
local integer p0x=bie[oqx]
local boolean cnr=bEe[oqx]
local integer Ixx=bVe[oqx]
local integer cVr=bRe[oqx]
call R1x(boe[oqx],true)
call Kzx(clo)
call ijx(p0x)
if(cVr!=w)then
call Awx(cVr)
endif
if cnr then
call Cex((Ixx),(CMx))
call UJx(((Ixx)),r9v)
endif
endfunction
function cEr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer oqx=(CMx)
if not bxe[oqx]then
return true
endif
set bxe[oqx]=false
call car(CMx)
return true
endfunction
function cXr takes nothing returns nothing
endfunction
function cOr takes nothing returns boolean
local integer rwx
call meo(SEv,XBx("WhiteStaff_Init: call WhiteStaff.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function WhiteStaff.Event_SpellEffect))",ah,pI,function cir))
call meo(SEv,XBx("WhiteStaff_Init: call WhiteStaff.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function WhiteStaff.Event_EndCast))",oev,pI,function cEr))
set rwx=(j6[(SEv)])
loop
exitwhen(rwx<1)
set bne[rwx]=N9e[rwx]*bOe
set rwx=rwx-1
endloop
call cXr()
return true
endfunction
function cRr takes nothing returns boolean
call I9r(function cOr,"WhiteStaff_Init")
return true
endfunction
function cIr takes nothing returns boolean
set bIe=lQx(bAe+" (dummyBuff)")
return true
endfunction
function cAr takes nothing returns boolean
call VRx(Ma,(function cIr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Barrier.page\\Barrier.struct\\Knockback\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function cNr takes nothing returns boolean
set bNe=Vnx(bAe)
return true
endfunction
function cbr takes nothing returns boolean
set bbe=WTx('BBar',"Strong",'bBar')
set avv[(bbe)]=(true)
set aev[(bbe)]=("ReplaceableTextures\\CommandButtons\\BTNFrostMourne.blp")
return true
endfunction
function cBr takes nothing returns boolean
set bBe[1]=hGo('uBar')
call hho(((bBe[1])),Apv,(ICv))
set Tj[(bBe[1])]=((1)*1.)
set Nav[(bBe[1])]=((60)*1.)
set Ntv[(bBe[1])]=((60)*1.)
set Nlv[(bBe[1])]=((1)*1.)
set I3v[(bBe[1])]=((5)*1.)
set Axv[(bBe[1])]=(3)
set NJv[(bBe[1])]=(('}')*1.)
set Njv[(bBe[1])]=(('}')*1.)
set Nhv[(bBe[1])]=((0)*1.)
set Ndv[(bBe[1])]=((60)*1.)
set AQv[(bBe[1])]=((0)*1.)
set Asv[(bBe[1])]=((0)*1.)
set Auv[(bBe[1])]=(0)
set AWv[(bBe[1])]=(0)
set Aqv[(bBe[1])]=((40)*1.)
return true
endfunction
function ccr takes integer rJx,integer cCr,integer cdr,integer cDr,integer cfr,integer cFr returns nothing
local integer OBo=(G6[(rJx)])
local integer cgr=(cDr+(R6[(OBo)]))
local integer cGr=(I6[(OBo)])
local integer rwx=(cdr-1)
call LZx(cfr,false)
call LZx(cFr,false)
call Qzx(Ge,cgr,false)
call Qzx(Ge,cfr,false)
call Qzx(Ge,cFr,false)
set bCe[((rJx))]=(cfr)
set IZv[((rJx))]=(cFr)
set h6[((rJx))]=(cCr)
set g6[((rJx))]=(cDr)
call meo(rJx,F6)
call meo(rJx,J6)
call meo(rJx,k6)
loop
exitwhen(rwx<0)
set cgr=(cGr+cCr+rwx)
call SaveInteger(o[((V[(E[((X))])]))],(((cgr))),(((L6))),(((rJx))))
call LZx(cgr,false)
set rwx=rwx-1
endloop
endfunction
function chr takes nothing returns boolean
call LZx('ABar',false)
set bce=Lzo('ABar')
set G6[(bce)]=(B6)
set j6[(bce)]=(6)
set sH[(bce)]=("Barrier")
set Ih[(bce)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D02B2)))),(((Oj))))))
set x6v[(bce)]=(0)
set xzv[(bce)]=("spell")
call LZo((bce),fH+(1),((8)*1.))
call LZo((bce),QH+(1),((20)*1.))
call LZo((bce),Lvv+(1),((750)*1.))
call LZo((bce),fH+(2),((8)*1.))
call LZo((bce),QH+(2),((30)*1.))
call LZo((bce),Lvv+(2),((750)*1.))
call LZo((bce),fH+(3),((8)*1.))
call LZo((bce),QH+(3),((40)*1.))
call LZo((bce),Lvv+(3),((750)*1.))
call LZo((bce),fH+(4),((8)*1.))
call LZo((bce),QH+(4),((50)*1.))
call LZo((bce),Lvv+(4),((750)*1.))
call LZo((bce),fH+(5),((8)*1.))
call LZo((bce),QH+(5),((60)*1.))
call LZo((bce),Lvv+(5),((750)*1.))
call LZo((bce),fH+(6),((8)*1.))
call LZo((bce),QH+(6),((70)*1.))
call LZo((bce),Lvv+(6),((750)*1.))
set Mnv[(bce)]=("ReplaceableTextures\\CommandButtons\\BTNFrostMourne.blp")
call ccr(bce,'FBA0',6,'VBA0','LPBA','LRBA')
set bde[1]=3
set bde[2]=3
set bde[3]=4
set bde[4]=4
set bde[5]=5
set bde[6]=5
set bDe[1]=3
set bDe[2]=3.5
set bDe[3]=4
set bDe[4]=4.5
set bDe[5]=5
set bDe[6]=5.5
return true
endfunction
function cHr takes nothing returns boolean
set bBe[6]=hGo('uBa6')
call hho(((bBe[6])),Apv,(ICv))
set Tj[(bBe[6])]=((1)*1.)
set Nav[(bBe[6])]=((60)*1.)
set Ntv[(bBe[6])]=((60)*1.)
set I3v[(bBe[6])]=(($A)*1.)
set Axv[(bBe[6])]=(3)
set NJv[(bBe[6])]=((500)*1.)
set Njv[(bBe[6])]=((500)*1.)
set Nhv[(bBe[6])]=((0)*1.)
set Ndv[(bBe[6])]=(('n')*1.)
set AQv[(bBe[6])]=((0)*1.)
set Asv[(bBe[6])]=((0)*1.)
set Auv[(bBe[6])]=(0)
set AWv[(bBe[6])]=(0)
set Aqv[(bBe[6])]=((40)*1.)
return true
endfunction
function cjr takes nothing returns boolean
set bBe[2]=hGo('uBa2')
call hho(((bBe[2])),Apv,(ICv))
set Tj[(bBe[2])]=((1)*1.)
set Nav[(bBe[2])]=((60)*1.)
set Ntv[(bBe[2])]=((60)*1.)
set I3v[(bBe[2])]=((6)*1.)
set Axv[(bBe[2])]=(3)
set NJv[(bBe[2])]=(($B4)*1.)
set Njv[(bBe[2])]=(($B4)*1.)
set Nhv[(bBe[2])]=((0)*1.)
set Ndv[(bBe[2])]=((70)*1.)
set AQv[(bBe[2])]=((0)*1.)
set Asv[(bBe[2])]=((0)*1.)
set Auv[(bBe[2])]=(0)
set AWv[(bBe[2])]=(0)
set Aqv[(bBe[2])]=((40)*1.)
return true
endfunction
function cJr takes nothing returns boolean
set bBe[3]=hGo('uBa3')
call hho(((bBe[3])),Apv,(ICv))
set Tj[(bBe[3])]=((1)*1.)
set Nav[(bBe[3])]=((60)*1.)
set Ntv[(bBe[3])]=((60)*1.)
set I3v[(bBe[3])]=((7)*1.)
set Axv[(bBe[3])]=(3)
set NJv[(bBe[3])]=(($F0)*1.)
set Njv[(bBe[3])]=(($F0)*1.)
set Nhv[(bBe[3])]=((0)*1.)
set Ndv[(bBe[3])]=((80)*1.)
set AQv[(bBe[3])]=((0)*1.)
set Asv[(bBe[3])]=((0)*1.)
set Auv[(bBe[3])]=(0)
set AWv[(bBe[3])]=(0)
set Aqv[(bBe[3])]=((40)*1.)
return true
endfunction
function ckr takes nothing returns boolean
set bBe[4]=hGo('uBa4')
call hho(((bBe[4])),Apv,(ICv))
set Tj[(bBe[4])]=((1)*1.)
set Nav[(bBe[4])]=((60)*1.)
set Ntv[(bBe[4])]=((60)*1.)
set I3v[(bBe[4])]=((8)*1.)
set Axv[(bBe[4])]=(3)
set NJv[(bBe[4])]=((310)*1.)
set Njv[(bBe[4])]=((310)*1.)
set Nhv[(bBe[4])]=((0)*1.)
set Ndv[(bBe[4])]=((90)*1.)
set AQv[(bBe[4])]=((0)*1.)
set Asv[(bBe[4])]=((0)*1.)
set Auv[(bBe[4])]=(0)
set AWv[(bBe[4])]=(0)
set Aqv[(bBe[4])]=((40)*1.)
return true
endfunction
function cKr takes nothing returns boolean
set bBe[5]=hGo('uBa5')
call hho(((bBe[5])),Apv,(ICv))
set Tj[(bBe[5])]=((1)*1.)
set Nav[(bBe[5])]=((60)*1.)
set Ntv[(bBe[5])]=((60)*1.)
set I3v[(bBe[5])]=((9)*1.)
set Axv[(bBe[5])]=(3)
set NJv[(bBe[5])]=((400)*1.)
set Njv[(bBe[5])]=((400)*1.)
set Nhv[(bBe[5])]=((0)*1.)
set Ndv[(bBe[5])]=(('d')*1.)
set AQv[(bBe[5])]=((0)*1.)
set Asv[(bBe[5])]=((0)*1.)
set Auv[(bBe[5])]=(0)
set AWv[(bBe[5])]=(0)
set Aqv[(bBe[5])]=((40)*1.)
return true
endfunction
function clr takes nothing returns boolean
call VRx(Ma,(function cbr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Barrier.page\\Barrier.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(Sa,(function cBr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Barrier.page\\Barrier.struct\\obj_summonUnitType[1]_wc3unit.j"))
call VRx(qa,(function chr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Barrier.page\\Barrier.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Sa,(function cHr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Barrier.page\\Barrier.struct\\obj_summonUnitType[6]_wc3unit.j"))
call VRx(Sa,(function cjr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Barrier.page\\Barrier.struct\\obj_summonUnitType[2]_wc3unit.j"))
call VRx(Sa,(function cJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Barrier.page\\Barrier.struct\\obj_summonUnitType[3]_wc3unit.j"))
call VRx(Sa,(function ckr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Barrier.page\\Barrier.struct\\obj_summonUnitType[4]_wc3unit.j"))
call VRx(Sa,(function cKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Barrier.page\\Barrier.struct\\obj_summonUnitType[5]_wc3unit.j"))
return true
endfunction
function cLr takes nothing returns boolean
set bfe=Vnx(bFe)
return true
endfunction
function cmr takes code c,string rqx returns nothing
set tn=tn+1
set Tn[tn]=CreateTrigger()
set un[tn]=(GetHandleId(Condition((c))))
set Un[tn]=rqx
call TriggerAddCondition(Tn[tn],Condition(c))
endfunction
function cMr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real N8x=(GetUnitFacing(C[((CMx))])*bh)
local integer C0o=(ze[(CMx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real cpr=(Cos(((((N8x)*1.))*1.)))
local real cPr=(Sin(((((N8x)*1.))*1.)))
local real ilx=bDe[rwx]
local integer olx=bde[rwx]
local integer cqr=bBe[rwx]
local real dix=wpo+bge*cpr
local real dax=wPo+bge*cPr
local real cQr=olx*bGe
local integer csr
set N8x=N8x-cQr*1./ 2.
loop
set csr=bVx(cqr,C0o,dix,dax,Kf)
call NIx((csr),(bbe),(rwx),w,((ilx)*1.))
call pKo((Abx((csr),(bhe),(bHe),(Bi))),2.)
call RZo(csr)
call DSx((((csr))),(XVv),(1),w)
call fTx(csr,dix)
call fux(csr,dax)
call Rgr(csr,bje*(Cos(((((N8x)*1.))*1.))),bje*(Sin(((((N8x)*1.))*1.))),.0,bJe)
call Uyo((csr),((ilx)*1.))
call NIx(((csr)),(bIe),(1),w,((bJe)*1.))
set olx=olx-1
exitwhen(olx<1)
set N8x=N8x+bGe
endloop
return true
endfunction
function cSr takes nothing returns boolean
local integer Ixx=jFx()
if(I5x((OPe),Rb,(Ixx)))then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
return true
return true
endfunction
function ctr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
local integer Q7o=ble[oqx]
local real dix=(GetUnitX(C[((Ixx))]))
local real dax=(GetUnitY(C[((Ixx))]))
local integer w_o
set OPe=Q7o
call Nio(bke,dix,dax,bme,bKe)
set w_o=Nao(bke)
if(w_o!=w)then
loop
call dpx(Q7o,w_o)
call OSr(w_o,1000.,-520.,(Atan2((((GetUnitY(C[((w_o))]))-dax)*1.),(((GetUnitX(C[((w_o))]))-dix)*1.))),.35)
set w_o=Nao(bke)
exitwhen(w_o==w)
endloop
endif
endfunction
function cTr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer Q6o=inx()
set ble[oqx]=JIx("FolderBarrier_StructKnockback_Event_BuffGain: set this.targetGroup = UnitList.Create()")
set bLe[oqx]=Q6o
set ge[(Q6o)]=(oqx)
call icx(Q6o,.1,true,function ctr)
return true
endfunction
function cUr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer Q7o=ble[oqx]
local integer Q6o=bLe[oqx]
call O6x(Q7o)
call ijx(Q6o)
return true
endfunction
function cwr takes nothing returns nothing
set bke=O2x()
set bKe=XLx(function cSr)
call l9x(bIe,XBx("FolderBarrier_StructKnockback_Init: call FolderBarrier_StructKnockback.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderBarrier_StructKnockback.Event_BuffGain))",Bd,pI,function cTr))
call l9x(bIe,XBx("FolderBarrier_StructKnockback_Init: call FolderBarrier_StructKnockback.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderBarrier_StructKnockback.Event_BuffLose))",Jc,pI,function cUr))
endfunction
function cWr takes nothing returns boolean
call meo(bce,XBx("Barrier_Init: call Barrier.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Barrier.Event_SpellEffect))",ah,pI,function cMr))
call cwr()
return true
endfunction
function cyr takes nothing returns boolean
call cmr(function cWr,"Barrier_Init")
return true
endfunction
function cYr takes nothing returns boolean
set bMe[1]=20
set bMe[2]=30
set bMe[3]=40
set bMe[4]=50
set bMe[5]=60
set bpe[1]=5
set bpe[2]=6
set bpe[3]=7
set bpe[4]=8
set bpe[5]=9
return true
endfunction
function czr takes nothing returns boolean
call VRx(ea,(function cYr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Blizzard.page\\Blizzard.struct\\Wave\\obj_this_wc3obj.j"))
return true
endfunction
function cZr takes nothing returns boolean
set bPe=Vnx(bqe)
return true
endfunction
function c_r takes nothing returns boolean
set bQe=lQx(bse+" (dummyBuff)")
return true
endfunction
function c0r takes nothing returns boolean
call LZx('ABlz',false)
set bSe=Lzo('ABlz')
set G6[(bSe)]=(B6)
set j6[(bSe)]=(6)
set sH[(bSe)]=("Blizzard")
set Ih[(bSe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0079)))),(((Oj))))))
set x6v[(bSe)]=(2)
set xzv[(bSe)]=("spell")
call LZo((bSe),u6v+(1),((275)*1.))
call LZo((bSe),BH+(1),((5)*1.))
call LZo((bSe),fH+(1),((0)*1.))
call LZo((bSe),QH+(1),((40)*1.))
call LZo((bSe),Lvv+(1),((600)*1.))
call LZo((bSe),u6v+(2),((325)*1.))
call LZo((bSe),BH+(2),((5)*1.))
call LZo((bSe),fH+(2),((0)*1.))
call LZo((bSe),QH+(2),((55)*1.))
call LZo((bSe),Lvv+(2),((600)*1.))
call LZo((bSe),u6v+(3),((375)*1.))
call LZo((bSe),BH+(3),((5)*1.))
call LZo((bSe),fH+(3),((0)*1.))
call LZo((bSe),QH+(3),((70)*1.))
call LZo((bSe),Lvv+(3),((600)*1.))
call LZo((bSe),u6v+(4),((425)*1.))
call LZo((bSe),BH+(4),((5)*1.))
call LZo((bSe),fH+(4),((0)*1.))
call LZo((bSe),QH+(4),((85)*1.))
call LZo((bSe),Lvv+(4),((600)*1.))
call LZo((bSe),u6v+(5),((475)*1.))
call LZo((bSe),BH+(5),((5)*1.))
call LZo((bSe),fH+(5),((0)*1.))
call LZo((bSe),QH+(5),(('d')*1.))
call LZo((bSe),Lvv+(5),((600)*1.))
call LZo((bSe),u6v+(6),((525)*1.))
call LZo((bSe),BH+(6),((5)*1.))
call LZo((bSe),fH+(6),((0)*1.))
call LZo((bSe),QH+(6),(('s')*1.))
call LZo((bSe),Lvv+(6),((600)*1.))
set Mnv[(bSe)]=("ReplaceableTextures\\CommandButtons\\BTNBlizzard.blp")
call ccr(bSe,'FBZ0',6,'VBZ0','LPBZ','LRBZ')
return true
endfunction
function c1r takes nothing returns boolean
call VRx(Ma,(function c_r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Blizzard.page\\Blizzard.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function c0r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Blizzard.page\\Blizzard.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function c2r takes nothing returns boolean
set bte=Vnx(bse)
return true
endfunction
function c3r takes integer oqx returns integer
set b1e[oqx]=true
set b2e[oqx]=false
call rax(bPe)
return oqx
endfunction
function c4r takes nothing returns integer
local integer oqx
if(bze==8190)then
call oYx("FolderBlizzard_StructWave_Allocation_allocCustom","call DebugEx(FolderBlizzard_StructWave.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",bqe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(bZe[(w)]==w)then
set b_e=b_e+1
set oqx=b_e
else
set oqx=bZe[(w)]
set bZe[(w)]=bZe[bZe[(w)]]
endif
set bZe[oqx]=Z
set b0e[oqx]=1
call c3r(oqx)
return oqx
endfunction
function c5r takes integer oqx returns nothing
set b1e[oqx]=false
call rgx(bPe)
endfunction
function c6r takes integer oqx returns nothing
if(b0e[oqx]>0)then
return
endif
if(bZe[oqx]!=Z)then
call oYx("FolderBlizzard_StructWave_Allocation_deallocCustom_confirm","call DebugEx(FolderBlizzard_StructWave.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",bqe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set bZe[oqx]=bZe[(w)]
set bZe[(w)]=oqx
call c5r(oqx)
endfunction
function c7r takes integer oqx returns nothing
set b0e[oqx]=b0e[oqx]-1
call c6r(oqx)
endfunction
function c8r takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local real O1o=b3e[oqx]
local integer CMx=b4e[oqx]
local real NIo=b5e[oqx]
local real dix=b6e[oqx]
local real dax=b7e[oqx]
local integer CQx=Cmx(CMx,bSe)
local integer Ixx
call c7r((oqx))
call ijx(ibx)
call dRx(CQx)
call Nio(Bve,dix,dax,O1o,Bee)
loop
set Ixx=Nao(Bve)
exitwhen(Ixx==w)
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
endloop
endfunction
function c9r takes integer CMx,integer rwx,real dix,real dax returns nothing
local real O1o=(Cpx((bSe),u6v+(rwx)))
local integer oqx=c4r()
local integer P7o=Qax("Abilities\\Spells\\Human\\Blizzard\\BlizzardTarget"+(I2S(((GetRandomInt((1),(3))))))+".wav",false,true,false,$A,$A,h5)
local integer ibx=inx()
local integer olx
local real N8x
local real n_x
set b3e[oqx]=O1o
set b4e[oqx]=CMx
set b5e[oqx]=bMe[rwx]
set b6e[oqx]=dix
set b7e[oqx]=dax
set ge[(ibx)]=(oqx)
set O1o=O1o*.75
set olx=bpe[rwx]
loop
exitwhen(olx<1)
set N8x=(GetRandomReal(((.0)*1.),((df)*1.)))
set n_x=(GetRandomReal(((.0)*1.),((O1o)*1.)))
call mFo((mHo(((dix+n_x*(Cos(((((N8x)*1.))*1.))))*1.),((dax+n_x*(Sin(((((N8x)*1.))*1.))))*1.),(b8e),(ri))))
set olx=olx-1
endloop
call icx(ibx,b9e,false,function c8r)
call P5o(P7o,dix,dax,XYx(dix,dax))
call R1x(P7o,true)
endfunction
function Cvr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
call c9r(Ixx,bwe[oqx],bWe[oqx],bye[oqx])
endfunction
function Cer takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer CQx=bTe
local integer Ixx=(aH[(CQx)])
local real dix=(wh[(CQx)])
local real dax=(Wh[(CQx)])
local integer oqx=Ixx
local integer Cxr=Qax("Abilities\\Spells\\Human\\Blizzard\\BlizzardLoop1.wav",true,true,false,$A,$A,h5)
local integer p0x=inx()
set bue[oqx]=Cxr
set bUe[oqx]=p0x
set bwe[oqx]=rwx
set bWe[oqx]=dix
set bye[oqx]=dax
set ge[(p0x)]=(oqx)
call icx(p0x,bYe,true,function Cvr)
call P5o(Cxr,dix,dax,XYx(dix,dax))
call c9r(Ixx,rwx,dix,dax)
return true
endfunction
function Cor takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer Cxr=bue[oqx]
local integer p0x=bUe[oqx]
call R1x(Cxr,true)
call ijx(p0x)
return true
endfunction
function Crr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),bQe)
return true
endfunction
function Cir takes nothing returns boolean
local integer rdx=(bv)
set bTe=(uH[(rdx)])
call DSx(((Vv[(rdx)])),(bQe),((Mv[(rdx)])),w)
return true
endfunction
function Car takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function Cnr takes nothing returns nothing
set Bve=O2x()
set Bee=XLx(function Car)
endfunction
function CVr takes nothing returns boolean
call l9x(bQe,XBx("Blizzard_Init: call Blizzard.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Blizzard.Event_BuffGain))",Bd,pI,function Cer))
call l9x(bQe,XBx("Blizzard_Init: call Blizzard.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Blizzard.Event_BuffLose))",Jc,pI,function Cor))
call meo(bSe,XBx("Blizzard_Init: call Blizzard.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Blizzard.Event_EndCast))",oev,pI,function Crr))
call meo(bSe,XBx("Blizzard_Init: call Blizzard.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Blizzard.Event_SpellEffect))",ah,pI,function Cir))
call Cnr()
return true
endfunction
function CEr takes nothing returns boolean
call cmr(function CVr,"Blizzard_Init")
return true
endfunction
function CXr takes nothing returns boolean
set Bxe[1]=8
set Bxe[2]=9
set Bxe[3]=$A
set Bxe[4]=$B
set Bxe[5]=$C
set Bxe[6]=$D
return true
endfunction
function COr takes nothing returns boolean
set Boe=WTx('BChB',"Cold and slowed",'bChB')
set qc[(Boe)]=(true)
set qU[(Boe)]=(true)
set aev[(Boe)]=("ReplaceableTextures\\CommandButtons\\BTNBreathOfFrost.blp")
call lux(Boe,"Abilities\\Spells\\Undead\\FrostArmor\\FrostArmorDamage.mdl","chest",Bi)
set SU=lYx()
call l_x(SU,dKv,-25)
call l0x(((Boe)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,dKv,-35)
call l0x(((Boe)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,dKv,-45)
call l0x(((Boe)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,dKv,-55)
call l0x(((Boe)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,dKv,-65)
call l0x(((Boe)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,dKv,-75)
call l0x(((Boe)),vc+(6),(SU))
return true
endfunction
function CRr takes nothing returns boolean
call VRx(ea,(function CXr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\ChillyBreath.page\\ChillyBreath.struct\\Buff\\obj_this_wc3obj.j"))
call VRx(Ma,(function COr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\ChillyBreath.page\\ChillyBreath.struct\\Buff\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function CIr takes nothing returns boolean
set Bre=Vnx(Bie)
return true
endfunction
function CAr takes nothing returns boolean
call LZx('AChB',false)
set Bae=Lzo('AChB')
set G6[(Bae)]=(B6)
set j6[(Bae)]=(6)
set sH[(Bae)]=("Chilly Breath")
set Ih[(Bae)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0250)))),(((Oj))))))
set x6v[(Bae)]=(2)
set xzv[(Bae)]=("spell")
call LZo((Bae),BH+(1),((2)*1.))
call LZo((Bae),fH+(1),(($E)*1.))
call LZo((Bae),QH+(1),((20)*1.))
call LZo((Bae),Lvv+(1),((500)*1.))
call LZo((Bae),BH+(2),((2)*1.))
call LZo((Bae),fH+(2),(($E)*1.))
call LZo((Bae),QH+(2),((30)*1.))
call LZo((Bae),Lvv+(2),((550)*1.))
call LZo((Bae),BH+(3),((2)*1.))
call LZo((Bae),fH+(3),(($E)*1.))
call LZo((Bae),QH+(3),((40)*1.))
call LZo((Bae),Lvv+(3),((600)*1.))
call LZo((Bae),BH+(4),((2)*1.))
call LZo((Bae),fH+(4),(($E)*1.))
call LZo((Bae),QH+(4),((50)*1.))
call LZo((Bae),Lvv+(4),((650)*1.))
call LZo((Bae),BH+(5),((2)*1.))
call LZo((Bae),fH+(5),(($E)*1.))
call LZo((Bae),QH+(5),((60)*1.))
call LZo((Bae),Lvv+(5),((700)*1.))
call LZo((Bae),BH+(6),((2)*1.))
call LZo((Bae),fH+(6),(($E)*1.))
call LZo((Bae),QH+(6),((70)*1.))
call LZo((Bae),Lvv+(6),((750)*1.))
set Mnv[(Bae)]=("ReplaceableTextures\\CommandButtons\\BTNBreathOfFrost.blp")
call ccr(Bae,'FCB0',6,'VCB0','LPCB','LRCB')
set Bne[1]=800
set Bne[2]=850
set Bne[3]=900
set Bne[4]=950
set Bne[5]=$3E8
set Bne[6]=$41A
set BVe[1]=35
set BVe[2]=60
set BVe[3]=85
set BVe[4]='n'
set BVe[5]=$87
set BVe[6]=$A0
return true
endfunction
function CNr takes nothing returns boolean
set BEe=u1x()
set AC[(BEe)]=("Abilities\\Spells\\Other\\BreathOfFrost\\BreathOfFrost1.wav")
set bC[(BEe)]=(J5)
set cC[(BEe)]=(h5)
set dC[(BEe)]=((1)*1.)
set fC[(BEe)]=((1)*1.)
set gC[(BEe)]=($A)
set hC[(BEe)]=((1)*1.)
set jC[(BEe)]=(($A)*1.)
set kC[(BEe)]=(($A)*1.)
set MC[(BEe)]=(true)
set PC[(BEe)]=((600)*1.)
set QC[(BEe)]=(($186A0)*1.)
set SC[(BEe)]=(($7D0)*1.)
return true
endfunction
function Cbr takes nothing returns boolean
call VRx(qa,(function CAr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\ChillyBreath.page\\ChillyBreath.struct\\obj_thisSpell_wc3spell.j"))
call VRx(ma,(function CNr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\ChillyBreath.page\\ChillyBreath.struct\\obj_effectSound_wc3sound.j"))
return true
endfunction
function CBr takes nothing returns boolean
set BXe=Vnx(BOe)
return true
endfunction
function Ccr takes nothing returns boolean
local integer Ixx=jFx()
if Lko(nXe,Ixx)then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function CCr takes real jGx,real jhx returns real
return bUx(jGx-(R2I(((jGx*1./ jhx)*1.)))*jhx)
endfunction
function Cdr takes real CDr,real pZx returns real
local real d
local real d2
if(pZx==0)then
return .0
endif
set d=CCr(CDr,pZx)
set d2=bUx(pZx)-d
if(d2<d)then
return(CDr+jTx(pZx)*d2)
endif
return(CDr-jTx(pZx)*d)
endfunction
function Cfr takes integer oqx returns integer
set BMe[oqx]=true
set Bpe[oqx]=false
call rax(q7)
return oqx
endfunction
function CFr takes nothing returns integer
local integer oqx
if(BKe==8190)then
call oYx("Tile_Allocation_allocCustom","call DebugEx(Tile.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Q7+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Ble[(w)]==w)then
set BLe=BLe+1
set oqx=BLe
else
set oqx=Ble[(w)]
set Ble[(w)]=Ble[Ble[(w)]]
endif
set Ble[oqx]=Z
set Bme[oqx]=1
call Cfr(oqx)
return oqx
endfunction
function Cgr takes real x,real y returns integer
local integer xI=(R2I(((Cdr(x,$80))*1.)))/ $80
local integer yI=(R2I(((Cdr(y,$80))*1.)))/ $80
local integer oqx=(LoadInteger(o[((s7))],(xI),(yI)))
if(oqx==w)then
set oqx=CFr()
call SaveInteger(o[((s7))],(xI),(yI),(oqx))
set BPe[oqx]=1
set Bqe[(oqx)]=(xI*$80)
set BQe[(oqx)]=(yI*$80)
set Bse[(oqx)]=w
else
set BPe[oqx]=BPe[oqx]+1
endif
return oqx
endfunction
function CGr takes integer oqx returns nothing
set BMe[oqx]=false
call rgx(q7)
endfunction
function Chr takes integer oqx returns nothing
if(Bme[oqx]>0)then
return
endif
if(Ble[oqx]!=Z)then
call oYx("Tile_Allocation_deallocCustom_confirm","call DebugEx(Tile.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Q7+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set Ble[oqx]=Ble[(w)]
set Ble[(w)]=oqx
call CGr(oqx)
endfunction
function CHr takes integer oqx returns nothing
set Bme[oqx]=Bme[oqx]-1
call Chr(oqx)
endfunction
function Cjr takes integer oqx returns nothing
if(BPe[oqx]==1)then
call SaveInteger(o[(((s7)))],(((R2I((((Bqe[(oqx)]))*1.)))/ $80)),(((R2I((((BQe[(oqx)]))*1.)))/ $80)),(0))
call CHr((oqx))
return
endif
set BPe[oqx]=BPe[oqx]-1
endfunction
function CJr takes integer oqx,integer el returns boolean
local integer Rkx
local integer RKx
if(pJx(oqx,el)==false)then
return false
endif
if((zY[(oqx)])==el)then
call m1x(oqx)
return((zY[((oqx))])==w)
endif
set Rkx=m_x(X,el,ZY+oqx)
set RKx=m_x(X,el,xz+oqx)
if(RKx!=w)then
call m0x(X,el,xz+oqx,w)
call m0x(X,RKx,ZY+oqx,Rkx)
endif
if(Rkx==w)then
set vz[oqx]=RKx
else
call m0x(X,el,ZY+oqx,w)
call m0x(X,Rkx,xz+oqx,RKx)
endif
return((zY[((oqx))])==w)
endfunction
function Ckr takes integer oqx,integer o2x returns nothing
call SetTerrainType((Bqe[((oqx))]),(BQe[((oqx))]),D7[o2x],-1,1,0)
endfunction
function CKr takes integer oqx,integer o2x returns nothing
if(Bse[oqx]==w)then
call oYx("FolderTile_StructType_Remove","call DebugEx(FolderTile_StructType.NAME + \" tile \" + I2S(this) + \" has not \" + I2S(val))",P7+" tile "+I2S(oqx)+" has not "+I2S(o2x))
return
endif
call CJr(Bse[oqx],o2x)
if((zY[((Bse[oqx]))])==w)then
call m6x(Bse[oqx])
set Bse[oqx]=w
call Ckr(oqx,BTe[oqx])
else
set o2x=(vz[(Bse[oqx])])
call Ckr(oqx,(Bue[(o2x)]))
endif
endfunction
function Clr takes integer oqx returns nothing
set BWe[oqx]=false
call rgx(T7)
endfunction
function CLr takes integer oqx returns nothing
if(BUe[oqx]>0)then
return
endif
if(Bwe[oqx]!=Z)then
call oYx("TileTypeMod_Allocation_deallocCustom_confirm","call DebugEx(TileTypeMod.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",u7+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set Bwe[oqx]=Bwe[(w)]
set Bwe[(w)]=oqx
call Clr(oqx)
endfunction
function Cmr takes integer oqx returns nothing
set BUe[oqx]=BUe[oqx]-1
call CLr(oqx)
endfunction
function CMr takes integer oqx returns nothing
local integer Cpr=(Bte[(oqx)])
call CKr(Cpr,oqx)
call Cjr(Cpr)
call Cmr((oqx))
endfunction
function CPr takes nothing returns nothing
local integer oqx=(ge[(ifx())])
call ijx(BSe[(oqx)])
call CMr((oqx))
endfunction
function Cqr takes integer oqx,real ilx returns nothing
local integer ibx=inx()
set BSe[oqx]=ibx
set ge[(ibx)]=(oqx)
call icx(ibx,ilx,false,function CPr)
endfunction
function CQr takes integer oqx returns integer
set BWe[oqx]=true
set Bze[oqx]=false
call rax(T7)
return oqx
endfunction
function Csr takes nothing returns integer
local integer oqx
if(Bye==8190)then
call oYx("TileTypeMod_Allocation_allocCustom","call DebugEx(TileTypeMod.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",u7+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Bwe[(w)]==w)then
set BYe=BYe+1
set oqx=BYe
else
set oqx=Bwe[(w)]
set Bwe[(w)]=Bwe[Bwe[(w)]]
endif
set Bwe[oqx]=Z
set BUe[oqx]=1
call CQr(oqx)
return oqx
endfunction
function CSr takes integer oqx returns integer
return(LoadInteger(o[((V[(E[((X))])]))],((((GetTerrainType((Bqe[((oqx))]),(BQe[((oqx))])))))),(((F7)))))
endfunction
function Ctr takes integer oqx,integer o2x returns nothing
if(Bse[oqx]==w)then
set BTe[oqx]=CSr(oqx)
set Bse[oqx]=M0x()
endif
call sLo(Bse[oqx],o2x)
call Ckr(oqx,(Bue[(o2x)]))
endfunction
function CTr takes real x,real y,integer o2x returns integer
local integer Cpr=Cgr(x,y)
local integer oqx=Csr()
set Bte[(oqx)]=(Cpr)
set Bue[(oqx)]=(o2x)
call Ctr(Cpr,oqx)
return oqx
endfunction
function Cur takes integer oqx,real x,real y returns nothing
local integer o2x=Cgr(x,y)
if pJx(Bge[oqx],o2x)then
call Cjr(o2x)
return
endif
call sLo(Bge[oqx],o2x)
call Cqr(CTr(x,y,R7),4.)
endfunction
function CUr takes integer rwx,integer Ixx returns nothing
call NIx((Ixx),(Boe),(rwx),w,((Bxe[rwx])*1.))
endfunction
function Cwr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local real N8x=BAe[oqx]
local integer CMx=BNe[oqx]
local integer HOx=BBe[oqx]
local real CWr=BCe[oqx]
local real rmr=Bfe[oqx]
local real Cyr=Bce[oqx]
local integer Q7o=BFe[oqx]
local real oUx=Cyr+CWr
local real x=(oJ[(HOx)])+Bhe[oqx]
local real y=(nJ[(HOx)])+BHe[oqx]
local real jMx=BJe+(Bke-BJe)*(Cyr*1./ rmr)
local real jmx=BJe+(Bke-BJe)*(oUx*1./ rmr)
local integer Ixx
local real NIo
local integer rwx
call Cur(oqx,x,y)
call Cur(oqx,(mFv[(BZe[oqx])]),(mgv[(BZe[oqx])]))
call Cur(oqx,(mFv[(B_e[oqx])]),(mgv[(B_e[oqx])]))
set Bce[oqx]=oUx
call QZo(HOx,x,y)
set Hf=(ze[(CMx)])
set nXe=Q7o
call NMr(BRe,x,y,CWr,N8x,jmx,jMx,BIe)
set Ixx=Nao(BRe)
if(Ixx!=w)then
set NIo=Bbe[oqx]*(1+oUx*1./ rmr*B0e)
set rwx=BDe[oqx]
loop
call GroupAddUnit(Kb[(Q7o)],C[(Ixx)])
call CUr(rwx,Ixx)
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
set Ixx=Nao(BRe)
exitwhen(Ixx==w)
endloop
endif
endfunction
function CYr takes nothing returns boolean
local integer rdx=(bv)
return true
endfunction
function Czr takes integer oqx,integer ozx,real oUx,real NJx,real N8x,real CZr returns nothing
local real jlx=(GetUnitX(C[((ozx))]))
local real jLx=(GetUnitY(C[((ozx))]))
local integer MFo=Mvo()
local real dix
local real dax
local integer HOx
set B_e[oqx]=MFo
set N8x=N8x-b6v*1./ 3
set dix=jlx+oUx*(Cos(((((N8x)*1.))*1.)))
set dax=jLx+oUx*(Sin(((((N8x)*1.))*1.)))
set mNv[(MFo)]=((10.)*1.)
call Mro(MFo,'qChB',.4)
set mCv[(MFo)]=XHx((function CYr))
call m8o(MFo,NJx)
call M9o(MFo,ozx)
set HOx=(Xz[(MFo)])
call SetUnitTimeScale(zj[(HOx)],((CZr)*1.))
call o6r(MFo,dix,dax,XYx(dix,dax))
set N8x=N8x+2*b6v*1./ 3
set MFo=Mvo()
set dix=jlx+oUx*(Cos(((((N8x)*1.))*1.)))
set dax=jLx+oUx*(Sin(((((N8x)*1.))*1.)))
set BZe[oqx]=MFo
set mNv[(MFo)]=((10.)*1.)
call SetUnitTimeScale(zj[(Mro(MFo,'qChB',.4))],((CZr)*1.))
set mCv[(MFo)]=XHx((function CYr))
call m8o(MFo,NJx)
call M9o(MFo,ozx)
set HOx=(Xz[(MFo)])
call SetUnitTimeScale(zj[(HOx)],((CZr)*1.))
call o6r(MFo,dix,dax,XYx(dix,dax))
endfunction
function C_r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real dX=dix-wpo
local real dY=dax-wPo
local real CZr=.35*1./(Cpx((Bae),BH+(rwx)))
local real N8x=UCx(CMx,dX,dY)
local integer oqx=CMx
local integer HOx=mcx('qChB',wpo,wPo,Olx(CMx,wpo,wPo)+OLx(CMx,true),N8x)
local integer Cxr=Ahx(BEe)
local integer Q6o=inx()
call oYx("ChillyBreath_Event_SpellEffect","call DebugEx(\"create \"+I2S(this)+\";\"+I2S(updateTimer))","create "+I2S(oqx)+";"+I2S(Q6o))
set BAe[oqx]=N8x
set BNe[oqx]=CMx
set Bbe[oqx]=BVe[rwx]
set BBe[oqx]=HOx
set Bce[oqx]=.0
set BCe[oqx]=Bde[rwx]
set BDe[oqx]=rwx
set Bfe[oqx]=Bne[rwx]
set BFe[oqx]=O2x()
set Bge[oqx]=M0x()
set BGe[oqx]=Q6o
set Bhe[oqx]=(Cos(((((N8x)*1.))*1.)))*Bde[rwx]
set BHe[oqx]=(Sin(((((N8x)*1.))*1.)))*Bde[rwx]
set ge[(Q6o)]=(oqx)
call k2o(HOx,.75)
call SetUnitTimeScale(zj[(HOx)],((CZr)*1.))
call P5o(Cxr,wpo,wPo,XYx(wpo,wPo))
call R1x(Cxr,true)
call icx(Q6o,Bje,true,function Cwr)
call Czr(oqx,CMx,Bne[rwx],B1e[rwx],N8x,CZr)
call nZr(CMx)
return true
endfunction
function C0r takes integer oqx returns nothing
local integer HOx=BBe[oqx]
local integer Q7o=BFe[oqx]
local integer Q6o=BGe[oqx]
call oYx("ChillyBreath_Ending","call DebugEx(\"destroy \"+I2S(this)+\";\"+I2S(updateTimer))","destroy "+I2S(oqx)+";"+I2S(Q6o))
call SetUnitTimeScale(zj[(HOx)],((1.)*1.))
call Mfx(HOx)
call O6x(Q7o)
call m6x(Bge[oqx])
call ijx(Q6o)
call SetUnitTimeScale(zj[((Xz[(BZe[oqx])]))],((1.)*1.))
call Mdo(BZe[oqx])
call SetUnitTimeScale(zj[((Xz[(B_e[oqx])]))],((1.)*1.))
call Mdo(B_e[oqx])
endfunction
function C1r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local boolean Eko=(ovv[(rdx)])
local integer oqx=CMx
call C0r(oqx)
if Eko then
call Dnx((CMx),(Gov))
endif
return true
endfunction
function C2r takes nothing returns nothing
call W_x(nxv,Boe)
call W_x(EIv,Boe)
endfunction
function C3r takes nothing returns boolean
local integer olx
set BRe=O2x()
set BIe=XLx(function Ccr)
call meo(Bae,XBx("ChillyBreath_Init: call ChillyBreath.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ChillyBreath.Event_SpellEffect))",ah,pI,function C_r))
call meo(Bae,XBx("ChillyBreath_Init: call ChillyBreath.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ChillyBreath.Event_EndCast))",oev,pI,function C1r))
set olx=(j6[(Bae)])
loop
set B1e[olx]=Bne[olx]*1./(Cpx((Bae),BH+(olx)))
set Bde[olx]=B1e[olx]*Bje
set olx=olx-1
exitwhen(olx<1)
endloop
call C2r()
return true
endfunction
function C4r takes nothing returns boolean
call cmr(function C3r,"ChillyBreath_Init")
return true
endfunction
function C5r takes nothing returns boolean
set B2e=Vnx(B3e)
return true
endfunction
function C6r takes code c,string rqx returns nothing
set zn=zn+1
set Zn[zn]=CreateTrigger()
set vV[zn]=(GetHandleId(Condition((c))))
set eV[zn]=rqx
call TriggerAddCondition(Zn[zn],Condition(c))
endfunction
function C7r takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=Lrx((BOv[(rdx)]),B5e)
local integer Oqx=(Vv[(rdx)])
call Obo(B6e[oqx],Oqx)
call rzx(((Oqx)),((B6e[oqx])),(1))
return true
endfunction
function C8r takes integer oqx returns integer
set cxe[oqx]=true
set coe[oqx]=false
call rax(B2e)
return oqx
endfunction
function C9r takes nothing returns integer
local integer oqx
if(B8e==8190)then
call oYx("ElementalSpellToHero_Allocation_allocCustom","call DebugEx(ElementalSpellToHero.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",B3e+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(B9e[(w)]==w)then
set cve=cve+1
set oqx=cve
else
set oqx=B9e[(w)]
set B9e[(w)]=B9e[B9e[(w)]]
endif
set B9e[oqx]=Z
set cee[oqx]=1
call C8r(oqx)
return oqx
endfunction
function dvr takes nothing returns boolean
local integer rdx=(bv)
local integer Oqx=RVx()
local integer oqx=Lrx((uf[(Oqx)]),B5e)
call Obo(B6e[oqx],Oqx)
call rzx(((Oqx)),((B6e[oqx])),(1))
return true
endfunction
function der takes integer lbo,integer rJx returns integer
local integer oqx=C9r()
set B6e[oqx]=rJx
call hlo(lbo,B5e,oqx)
call S8o(lbo,B4e)
call kso(lbo,function dvr)
return oqx
endfunction
function dxr takes nothing returns boolean
set B4e=XBx("ElementalSpellToHero_Init: set ElementalSpellToHero.CREATE_EVENT = Event.Create(Unit.CREATE_EVENT_TYPE, EventPriority.MISC, function ElementalSpellToHero.Event_Create)",Igv,LI,function C7r)
set B7e=O2x()
call der(GTv,cre)
call der(Gev,Bae)
call der(Ggv,cie)
call der(gLv,cae)
call der(g1v,SDv)
call der(hRv,cne)
call der(Gbv,cVe)
call der(G1v,GKv)
call der(gwv,cEe)
return true
endfunction
function dor takes nothing returns boolean
call C6r(function dxr,"ElementalSpellToHero_Init")
return true
endfunction
function drr takes nothing returns boolean
set cXe=lQx(cOe+" (ignitionBuff)")
return true
endfunction
function dir takes nothing returns boolean
set cRe[1]=4
set cRe[2]=4
set cRe[3]=5
set cRe[4]=5
set cRe[5]=6
set cRe[6]=6
set cIe[1]=$A
set cIe[2]=$F
set cIe[3]=20
set cIe[4]=25
set cIe[5]=30
set cIe[6]=35
return true
endfunction
function dar takes nothing returns boolean
call VRx(Ma,(function drr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Fireburst.page\\Fireburst.struct\\Shot\\obj_ignitionBuff_wc3buff.j"))
call VRx(ea,(function dir),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Fireburst.page\\Fireburst.struct\\Shot\\obj_this_wc3obj.j"))
return true
endfunction
function dnr takes nothing returns boolean
set cAe=Vnx(cOe)
return true
endfunction
function dVr takes nothing returns boolean
call LZx('AFiB',false)
set SDv=Lzo('AFiB')
set G6[(SDv)]=(B6)
set j6[(SDv)]=(6)
set sH[(SDv)]=("Fireburst")
set Ih[(SDv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0107)))),(((Oj))))))
set x6v[(SDv)]=(4)
set xzv[(SDv)]=("spell")
call LZo((SDv),u6v+(1),(($96)*1.))
call LZo((SDv),fH+(1),((6)*1.))
call LZo((SDv),QH+(1),((45)*1.))
call LZo((SDv),Lvv+(1),((700)*1.))
call LZo((SDv),u6v+(2),(($AF)*1.))
call LZo((SDv),fH+(2),((6)*1.))
call LZo((SDv),QH+(2),((65)*1.))
call LZo((SDv),Lvv+(2),((700)*1.))
call LZo((SDv),u6v+(3),(($C8)*1.))
call LZo((SDv),fH+(3),((6)*1.))
call LZo((SDv),QH+(3),((90)*1.))
call LZo((SDv),Lvv+(3),((700)*1.))
call LZo((SDv),u6v+(4),(($E1)*1.))
call LZo((SDv),fH+(4),((6)*1.))
call LZo((SDv),QH+(4),(('x')*1.))
call LZo((SDv),Lvv+(4),((700)*1.))
call LZo((SDv),u6v+(5),(($FA)*1.))
call LZo((SDv),fH+(5),((6)*1.))
call LZo((SDv),QH+(5),(($9B)*1.))
call LZo((SDv),Lvv+(5),((700)*1.))
call LZo((SDv),u6v+(6),((275)*1.))
call LZo((SDv),fH+(6),((6)*1.))
call LZo((SDv),QH+(6),(($C3)*1.))
call LZo((SDv),Lvv+(6),((700)*1.))
set Mnv[(SDv)]=("ReplaceableTextures\\CommandButtons\\BTNFireForTheCannon.blp")
call ccr(SDv,'FFB0',6,'VFB0','LPFB','LRFB')
set cNe[1]=3
set cNe[2]=3
set cNe[3]=4
set cNe[4]=4
set cNe[5]=5
set cNe[6]=5
return true
endfunction
function dEr takes nothing returns boolean
set cbe=lQx(cBe+" (dummyBuff)")
set qc[(cbe)]=(true)
return true
endfunction
function dXr takes nothing returns boolean
call VRx(qa,(function dVr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Fireburst.page\\Fireburst.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function dEr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Fireburst.page\\Fireburst.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function dOr takes nothing returns boolean
set cce=Vnx(cBe)
return true
endfunction
function dRr takes integer oqx returns integer
set cFe[oqx]=true
set cge[oqx]=false
call rax(cce)
return oqx
endfunction
function dIr takes nothing returns integer
local integer oqx
if(cCe==8190)then
call oYx("Fireburst_Allocation_allocCustom","call DebugEx(Fireburst.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",cBe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(cde[(w)]==w)then
set cDe=cDe+1
set oqx=cDe
else
set oqx=cde[(w)]
set cde[(w)]=cde[cde[(w)]]
endif
set cde[oqx]=Z
set cfe[oqx]=1
call dRr(oqx)
return oqx
endfunction
function dAr takes integer oqx returns integer
set cUe[oqx]=true
set cwe[oqx]=false
call rax(cAe)
return oqx
endfunction
function dNr takes nothing returns integer
local integer oqx
if(cSe==8190)then
call oYx("FolderFireburst_StructShot_Allocation_allocCustom","call DebugEx(FolderFireburst_StructShot.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",cOe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(cte[(w)]==w)then
set cTe=cTe+1
set oqx=cTe
else
set oqx=cte[(w)]
set cte[(w)]=cte[cte[(w)]]
endif
set cte[oqx]=Z
set cue[oqx]=1
call dAr(oqx)
return oqx
endfunction
function dbr takes integer oqx returns nothing
set cke[oqx]=cke[oqx]+1
endfunction
function dBr takes real x1,real y1,real x2,real y2,real n_x returns real
local real m=(y2-y1)*1./(x2-x1)
local real n=y1-m*x1
return(m*n_x+n)
endfunction
function dcr takes integer oqx returns nothing
set cFe[oqx]=false
call rgx(cce)
endfunction
function dCr takes integer oqx returns nothing
if(cfe[oqx]>0)then
return
endif
if(cde[oqx]!=Z)then
call oYx("Fireburst_Allocation_deallocCustom_confirm","call DebugEx(Fireburst.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",cBe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set cde[oqx]=cde[(w)]
set cde[(w)]=oqx
call dcr(oqx)
endfunction
function ddr takes integer oqx returns nothing
set cfe[oqx]=cfe[oqx]-1
call dCr(oqx)
endfunction
function dDr takes integer oqx returns nothing
if not che[oqx]then
return
endif
if(cke[oqx]>0)then
return
endif
call ddr((oqx))
endfunction
function dfr takes integer oqx returns nothing
set cke[oqx]=cke[oqx]-1
call dDr(oqx)
endfunction
function dFr takes integer oqx returns nothing
set cUe[oqx]=false
call rgx(cAe)
endfunction
function dgr takes integer oqx returns nothing
if(cue[oqx]>0)then
return
endif
if(cte[oqx]!=Z)then
call oYx("FolderFireburst_StructShot_Allocation_deallocCustom_confirm","call DebugEx(FolderFireburst_StructShot.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",cOe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set cte[oqx]=cte[(w)]
set cte[(w)]=oqx
call dFr(oqx)
endfunction
function dGr takes integer oqx returns nothing
set cue[oqx]=cue[oqx]-1
call dgr(oqx)
endfunction
function dhr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer rkx=cWe[oqx]
local integer CMx=cGe[rkx]
local integer rwx=cJe[rkx]
local integer Ixx=cle[rkx]
local real dix=(mFv[(MFo)])
local real dax=(mgv[(MFo)])
call Mdo(MFo)
call NIx(Ixx,cXe,rwx,CMx,cRe[rwx])
call nJo((CMx),(Ixx),((c1e[oqx])*1.),(true),(false))
call dfr(rkx)
call dGr((oqx))
return true
endfunction
function dHr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer rkx=cWe[oqx]
local integer CMx=cGe[rkx]
local integer rwx=cJe[rkx]
local real dix=(mFv[(MFo)])
local real dax=(mgv[(MFo)])
local real wpo
local real wPo
local real djr
local real NIo
local real d
local real dJr
call Mdo(MFo)
call mFo((mHo(((dix)*1.),((dax)*1.),("Objects\\Spawnmodels\\Other\\NeutralBuildingExplosion\\NeutralBuildingExplosion.mdl"),(Bi))))
if(Ixx!=w)then
call NIx(Ixx,cXe,rwx,CMx,cRe[rwx])
endif
set Hf=(ze[(CMx)])
call Nio(cye,dix,dax,(Cpx((SDv),u6v+(rwx))),cYe)
set Ixx=Nao(cye)
if(Ixx!=w)then
set wpo=cme[rkx]
set wPo=cMe[rkx]
set djr=dvx(CMx,true)
set NIo=cIe[rwx]
loop
set d=jjx((GetUnitX(C[((Ixx))]))-wpo,(GetUnitY(C[((Ixx))]))-wPo)
set dJr=dBr(djr,cze,(Cpx((SDv),Lvv+(rwx))),cZe,d)
set dJr=bJx(dJr,cze,cZe)
call GroupAddUnit(Kb[(c_e)],C[(Ixx)])
call nJo((CMx),(Ixx),((NIo*dJr)*1.),(true),(false))
set Ixx=Nao(cye)
exitwhen(Ixx==w)
endloop
endif
set Hf=(ze[(CMx)])
call Nio(cye,dix,dax,(Cpx((SDv),Lvv+(rwx))),cYe)
call GroupRemoveUnit(Kb[(cye)],C[(cle[rkx])])
loop
set Ixx=Nao(c_e)
exitwhen(Ixx==w)
call GroupRemoveUnit(Kb[(cye)],C[(Ixx)])
endloop
set Ixx=(WHo((cye),((dix)*1.),((dax)*1.)))
if((Ixx==w)or not(oPx((((CMx))),(yb+(c0e)))>0))then
call dfr(rkx)
call dGr((oqx))
return true
endif
set c1e[oqx]=cIe[rwx]*c2e[(oPx(((CMx)),zb+(c0e)))]
set MFo=Mvo()
set mAv[((MFo))]=((b6v*((.06)*1.))*1.)
set mNv[(MFo)]=((10.)*1.)
set mCv[(MFo)]=XHx((function dhr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,900.)
call M9o(MFo,CMx)
call M3o((MFo),(Ixx),.0,.0,.0,(null))
call Mro(MFo,'qFiE',.75)
return true
endfunction
function dkr takes integer rkx returns nothing
local integer CMx=cGe[rkx]
local integer HOx=cHe[rkx]
local integer Ixx=cle[rkx]
local integer MFo=Mvo()
local integer oqx=dNr()
local real jlx
local real jLx
local real N8x
set cWe[oqx]=rkx
call dbr(rkx)
set jlx=(oJ[(HOx)])
set jLx=(nJ[(HOx)])
set N8x=(Atan2((((GetUnitY(C[((Ixx))]))-jLx)*1.),(((GetUnitX(C[((Ixx))]))-jlx)*1.)))
call mRx(HOx,N8x)
set mAv[((MFo))]=((b6v*((.2)*1.))*1.)
set mNv[(MFo)]=((10.)*1.)
set mCv[(MFo)]=XHx((function dHr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,1000.)
call M3o((MFo),(Ixx),.0,.0,.0,(null))
call Mro(MFo,'qFiS',1.)
call rQr(MFo,function dHr,c3e)
call Mto(MFo,jlx+c4e*(Cos(((((N8x)*1.))*1.))),jLx+c4e*(Sin(((((N8x)*1.))*1.))),(Vu[(HOx)]))
endfunction
function dKr takes integer oqx returns nothing
local integer HOx=cHe[oqx]
local integer p0x=cje[oqx]
local integer CQx=cLe[oqx]
call Mfx(HOx)
call ijx(p0x)
if rrx(cGe[oqx],cQe,oqx)then
call Ayx(cGe[oqx],cbe)
endif
set che[oqx]=true
call dDr(oqx)
endfunction
function dlr takes integer oqx returns nothing
call dkr(oqx)
if(cKe[oqx]==1)then
call dKr(oqx)
else
set cKe[oqx]=cKe[oqx]-1
endif
endfunction
function dLr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
call dlr(oqx)
endfunction
function dmr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
call icx(cje[oqx],cse,true,function dLr)
call dlr(oqx)
endfunction
function dMr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer CQx=(uH[(rdx)])
local real x=(GetUnitX(C[((CMx))]))
local real y=(GetUnitY(C[((CMx))]))
local real z=fwx(CMx)+OLx(CMx,true)*3
local integer oqx=dIr()
local integer HOx=mcx('qFiB',x,y,z,(iH[(CQx)]))
local integer p0x=inx()
set cGe[oqx]=CMx
set che[oqx]=false
set cHe[oqx]=HOx
set cje[oqx]=p0x
set cJe[oqx]=rwx
set cke[oqx]=0
set cKe[oqx]=cNe[rwx]
set cle[oqx]=Ixx
set cLe[oqx]=CQx
set cme[oqx]=x
set cMe[oqx]=y
set ge[(p0x)]=(oqx)
call HXx((sao((HOx),(cpe),(cPe),(Bi))))
call SetUnitAnimation(zj[((HOx))],("spell"))
call SetUnitColor(zj[((HOx))],((xx[(CMx)])))
call mBx(HOx,0,0,0,0)
call Qwo(HOx,$FF,$FF,$FF,$FF,cqe)
if rtx(CMx,cQe,oqx)then
call DSx((CMx),(cbe),(rwx),w)
endif
call icx(p0x,cqe,false,function dmr)
return true
endfunction
function dpr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
return true
endfunction
function dPr takes integer CMx returns nothing
local integer olx=CXx(CMx,cQe)
local integer oqx
loop
exitwhen(olx<q)
set oqx=COx(CMx,cQe,olx)
call dKr(oqx)
endloop
endfunction
function dqr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
call dPr(CMx)
return true
endfunction
function dQr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer Ixx=jFx()
local integer oqx=(mWv[(MFo)])
local integer rkx=cWe[oqx]
if I6x(Ixx,sc)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[((ze[(cGe[rkx])]))]))then
return false
endif
return true
endfunction
function dsr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if nIo(Ixx)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function dSr takes nothing returns nothing
set c3e=XLx(function dQr)
set cye=O2x()
set c_e=O2x()
set cYe=XLx(function dsr)
call W_x(E5v,cXe)
endfunction
function dtr takes nothing returns boolean
call meo(SDv,XBx("Fireburst_Init: call Fireburst.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Fireburst.Event_SpellEffect))",ah,pI,function dMr))
call l9x(cbe,XBx("Fireburst_Init: call Fireburst.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Fireburst.Event_BuffGain))",Bd,pI,function dpr))
call l9x(cbe,XBx("Fireburst_Init: call Fireburst.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Fireburst.Event_BuffLose))",Jc,pI,function dqr))
call dSr()
return true
endfunction
function dTr takes nothing returns boolean
call cmr(function dtr,"Fireburst_Init")
return true
endfunction
function dUr takes nothing returns boolean
call LZx('AFlT',false)
set c5e=Lzo('AFlT')
set G6[(c5e)]=(B6)
set j6[(c5e)]=(6)
set sH[(c5e)]=("Flame Tongue")
set Ih[(c5e)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D02AC)))),(((Oj))))))
set x6v[(c5e)]=(2)
set xzv[(c5e)]=("spell")
call LZo((c5e),u6v+(1),(($C8)*1.))
call LZo((c5e),fH+(1),(($A)*1.))
call LZo((c5e),QH+(1),((30)*1.))
call LZo((c5e),Lvv+(1),((700)*1.))
call LZo((c5e),u6v+(2),(($C8)*1.))
call LZo((c5e),fH+(2),(($A)*1.))
call LZo((c5e),QH+(2),((45)*1.))
call LZo((c5e),Lvv+(2),((700)*1.))
call LZo((c5e),u6v+(3),(($C8)*1.))
call LZo((c5e),fH+(3),(($A)*1.))
call LZo((c5e),QH+(3),((55)*1.))
call LZo((c5e),Lvv+(3),((700)*1.))
call LZo((c5e),u6v+(4),(($C8)*1.))
call LZo((c5e),fH+(4),(($A)*1.))
call LZo((c5e),QH+(4),((70)*1.))
call LZo((c5e),Lvv+(4),((700)*1.))
call LZo((c5e),u6v+(5),(($C8)*1.))
call LZo((c5e),fH+(5),(($A)*1.))
call LZo((c5e),QH+(5),((90)*1.))
call LZo((c5e),Lvv+(5),((700)*1.))
call LZo((c5e),u6v+(6),(($C8)*1.))
call LZo((c5e),fH+(6),(($A)*1.))
call LZo((c5e),QH+(6),(('s')*1.))
call LZo((c5e),Lvv+(6),((700)*1.))
set Mnv[(c5e)]=("ReplaceableTextures\\CommandButtons\\BTNMarkOfFire.blp")
set c6e[1]=500
set c6e[2]=900
set c6e[3]=$5DC
set c6e[4]=$898
set c6e[5]=$BB8
set c6e[6]=$F3C
set c7e[1]=.5
set c7e[2]=.6
set c7e[3]=.7
set c7e[4]=.8
set c7e[5]=.9
set c7e[6]=1
set c8e[1]=600
set c8e[2]=600
set c8e[3]=600
set c8e[4]=600
set c8e[5]=600
set c8e[6]=600
set c9e[1]=500
set c9e[2]=500
set c9e[3]=500
set c9e[4]=500
set c9e[5]=500
set c9e[6]=500
set Cve[1]=700
set Cve[2]=700
set Cve[3]=700
set Cve[4]=700
set Cve[5]=700
set Cve[6]=700
set Cee[1]=.5
set Cee[2]=.5
set Cee[3]=.5
set Cee[4]=.5
set Cee[5]=.5
set Cee[6]=.5
set Cxe[1]=35
set Cxe[2]=50
set Cxe[3]=65
set Cxe[4]=80
set Cxe[5]=95
set Cxe[6]='n'
return true
endfunction
function dwr takes nothing returns boolean
call VRx(qa,(function dUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\FlameTongue.page\\FlameTongue.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function dWr takes nothing returns boolean
set Coe=Vnx(Cre)
return true
endfunction
function dyr takes nothing returns boolean
local integer Ixx=jFx()
if(I5x((OPe),Rb,(Ixx)))then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function dYr takes integer oqx returns integer
set COe[oqx]=true
set CRe[oqx]=false
call rax(Coe)
return oqx
endfunction
function dzr takes nothing returns integer
local integer oqx
if(Cne==8190)then
call oYx("FlameTongue_Allocation_allocCustom","call DebugEx(FlameTongue.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Cre+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(CVe[(w)]==w)then
set CEe=CEe+1
set oqx=CEe
else
set oqx=CVe[(w)]
set CVe[(w)]=CVe[CVe[(w)]]
endif
set CVe[oqx]=Z
set CXe[oqx]=1
call dYr(oqx)
return oqx
endfunction
function dZr takes integer oqx,real O1o,integer CMx,integer C0o,real NIo,integer d_r,real d0r,real d1r,integer Q7o,real x,real y,integer CQx returns nothing
local integer Ixx
local real d2r
local real Vkr
set x=x+d_r*d0r
set y=y+d_r*d1r
call mFo((mHo(((x)*1.),((y)*1.),(Cqe),(ri))))
call mFo((mHo(((x)*1.),((y)*1.),(CQe),(Bi))))
set OPe=Q7o
set Hf=C0o
call Nio(Cie,x,y,O1o,Cae)
set Ixx=Nao(Cie)
if(Ixx!=w)then
set d2r=Cce[oqx]
set Vkr=Cke[oqx]
loop
set NIo=itx(NIo,Vkr)
call dpx(Q7o,Ixx)
set Vkr=Vkr-NIo
if(E9v[(Ixx)])then
set NIo=NIo*d2r
endif
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
set Ixx=Nao(Cie)
exitwhen(Ixx==w)
endloop
set Cke[oqx]=Vkr
endif
endfunction
function d3r takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local real N8x=CIe[oqx]
local real O1o=CAe[oqx]
local integer CMx=CNe[oqx]
local real NIo=Cbe[oqx]
local real oUx=Che[oqx]+CHe[oqx]
local integer Q7o=CKe[oqx]
local real x=Cle[oqx]+CLe[oqx]
local real y=Cme[oqx]+CMe[oqx]
local integer CQx=Cpe[oqx]
local integer C0o=(ze[(CMx)])
local real d4r=oUx*(CCe[oqx]*oUx+CFe[oqx])
local real d0r=d4r*CDe[oqx]
local real d1r=d4r*Cfe[oqx]
set Che[oqx]=oUx
set Cle[oqx]=x
set Cme[oqx]=y
call dZr(oqx,O1o,CMx,C0o,NIo,-1,d0r,d1r,Q7o,x,y,CQx)
call dZr(oqx,O1o,CMx,C0o,NIo,1,d0r,d1r,Q7o,x,y,CQx)
endfunction
function d5r takes integer oqx returns nothing
set COe[oqx]=false
call rgx(Coe)
endfunction
function d6r takes integer oqx returns nothing
if(CXe[oqx]>0)then
return
endif
if(CVe[oqx]!=Z)then
call oYx("FlameTongue_Allocation_deallocCustom_confirm","call DebugEx(FlameTongue.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Cre+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set CVe[oqx]=CVe[(w)]
set CVe[(w)]=oqx
call d5r(oqx)
endfunction
function d7r takes integer oqx returns nothing
set CXe[oqx]=CXe[oqx]-1
call d6r(oqx)
endfunction
function d8r takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local integer p0x=CGe[oqx]
local integer Q7o=CKe[oqx]
local integer CQx=Cpe[oqx]
call d7r((oqx))
call ijx(ibx)
call ijx(p0x)
call XYr(Q7o)
call dRx(CQx)
endfunction
function d9r takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
set CHe[oqx]=-CHe[oqx]
set CLe[oqx]=-CLe[oqx]
set CMe[oqx]=-CMe[oqx]
call dux((CKe[oqx]),Rb)
call icx(CGe[oqx],CPe,true,function d3r)
call icx(ibx,Cse[CJe[oqx]],false,function d8r)
endfunction
function Dvr takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
call iHx(CGe[oqx])
call icx(ibx,.15,false,function d9r)
endfunction
function Der takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real dX=dix-wpo
local real dY=dax-wPo
local real N8x=UCx(CMx,dX,dY)
local real d=jjx(dX,dY)
local real Dxr=N8x-b6v
local integer oqx=dzr()
local integer ibx=inx()
local integer p0x=inx()
local integer CQx=Cmx(CMx,c5e)
set CIe[oqx]=N8x
set CAe[oqx]=(Cpx((c5e),u6v+(rwx)))
set CNe[oqx]=CMx
set Cbe[oqx]=Cxe[rwx]+(mg[(CMx)])*CBe
set Cce[oqx]=(1.+c7e[rwx])
set CCe[oqx]=Cde[rwx]
set CDe[oqx]=(Cos(((((Dxr)*1.))*1.)))
set Cfe[oqx]=(Sin(((((Dxr)*1.))*1.)))
set CFe[oqx]=Cge[rwx]
set CGe[oqx]=p0x
set Che[oqx]=.0
set CHe[oqx]=Cje[rwx]
set CJe[oqx]=rwx
set Cke[oqx]=c6e[rwx]
set CKe[oqx]=JIx("FlameTongue_Event_SpellEffect: set this.targetGroup = UnitList.Create()")
set Cle[oqx]=dix
set CLe[oqx]=Cje[rwx]*(Cos(((((N8x)*1.))*1.)))
set Cme[oqx]=dax
set CMe[oqx]=Cje[rwx]*(Sin(((((N8x)*1.))*1.)))
set Cpe[oqx]=CQx
set ge[(ibx)]=(oqx)
set ge[(p0x)]=(oqx)
call icx(p0x,CPe,true,function d3r)
call icx(ibx,Cse[rwx],false,function Dvr)
return true
endfunction
function Dor takes nothing returns boolean
local integer olx
set Cie=O2x()
set Cae=XLx(function dyr)
call meo(c5e,XBx("FlameTongue_Init: call FlameTongue.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FlameTongue.Event_SpellEffect))",ah,pI,function Der))
set olx=(j6[(c5e)])
loop
set Cse[olx]=(R2I((((c8e[olx]*1./ Cve[olx])*1./ CPe)*1.)))*CPe
set CSe[olx]=Cee[olx]*c8e[olx]
set Cje[olx]=Cve[olx]*CPe
set Cde[olx]=c9e[olx]*1./ CSe[olx]*1./(CSe[olx]+c8e[olx])
set Cge[olx]=-Cde[olx]*c8e[olx]
set olx=olx-1
exitwhen(olx<1)
endloop
return true
endfunction
function Drr takes nothing returns boolean
call cmr(function Dor,"FlameTongue_Init")
return true
endfunction
function Dir takes nothing returns boolean
set Cte[1]=-90
set Cte[2]=-90
set Cte[3]=-90
set Cte[4]=-90
set Cte[5]=-90
set Cte[6]=-90
set CTe[1]=5
set CTe[2]=8
set CTe[3]=$B
set CTe[4]=$E
set CTe[5]=17
set CTe[6]=20
return true
endfunction
function Dar takes nothing returns boolean
set Cue=WTx('BFrS',"Frozen Star",'bFrS')
set qc[(Cue)]=(true)
set aev[(Cue)]=("ReplaceableTextures\\CommandButtons\\BTNBreathOfFrost.blp")
set SU=lYx()
call l_x(SU,dKv,-90)
call l0x(((Cue)),vc+(1),(SU))
return true
endfunction
function Dnr takes nothing returns boolean
call VRx(ea,(function Dir),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\FrozenStar.page\\FrozenStar.struct\\Target\\obj_this_wc3obj.j"))
call VRx(Ma,(function Dar),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\FrozenStar.page\\FrozenStar.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function DVr takes nothing returns boolean
set CUe=Vnx(Cwe)
return true
endfunction
function DEr takes nothing returns boolean
set CWe[1]=30
set CWe[2]=40
set CWe[3]=60
set CWe[4]=70
set CWe[5]=80
set CWe[6]=90
return true
endfunction
function DXr takes nothing returns boolean
call VRx(ea,(function DEr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\FrozenStar.page\\FrozenStar.struct\\Explosion\\obj_this_wc3obj.j"))
return true
endfunction
function DOr takes nothing returns boolean
set Cye=Vnx(CYe)
return true
endfunction
function DRr takes nothing returns boolean
call LZx('AFrS',false)
set Cze=Lzo('AFrS')
set G6[(Cze)]=(B6)
set j6[(Cze)]=(6)
set sH[(Cze)]=("Frozen Star")
set Ih[(Cze)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00FA)))),(((Oj))))))
set x6v[(Cze)]=(2)
set xzv[(Cze)]=("spell")
call LZo((Cze),u6v+(1),((400)*1.))
call LZo((Cze),fH+(1),((9)*1.))
call LZo((Cze),QH+(1),((55)*1.))
call LZo((Cze),Lvv+(1),((700)*1.))
call LZo((Cze),u6v+(2),((500)*1.))
call LZo((Cze),fH+(2),((9)*1.))
call LZo((Cze),QH+(2),((75)*1.))
call LZo((Cze),Lvv+(2),((700)*1.))
call LZo((Cze),u6v+(3),((600)*1.))
call LZo((Cze),fH+(3),((9)*1.))
call LZo((Cze),QH+(3),((95)*1.))
call LZo((Cze),Lvv+(3),((700)*1.))
call LZo((Cze),u6v+(4),((700)*1.))
call LZo((Cze),fH+(4),((9)*1.))
call LZo((Cze),QH+(4),(('s')*1.))
call LZo((Cze),Lvv+(4),((700)*1.))
call LZo((Cze),u6v+(5),((800)*1.))
call LZo((Cze),fH+(5),((9)*1.))
call LZo((Cze),QH+(5),(($87)*1.))
call LZo((Cze),Lvv+(5),((700)*1.))
call LZo((Cze),u6v+(6),((900)*1.))
call LZo((Cze),fH+(6),((9)*1.))
call LZo((Cze),QH+(6),(($9B)*1.))
call LZo((Cze),Lvv+(6),((700)*1.))
set Mnv[(Cze)]=("ReplaceableTextures\\CommandButtons\\BTNStaffOfNegation.blp")
set CZe[1]=700
set CZe[2]=700
set CZe[3]=700
set CZe[4]=700
set CZe[5]=700
set CZe[6]=700
set C_e[1]=$C8
set C_e[2]=$C8
set C_e[3]=$C8
set C_e[4]=$C8
set C_e[5]=$C8
set C_e[6]=$C8
set C0e[1]=600
set C0e[2]=600
set C0e[3]=600
set C0e[4]=600
set C0e[5]=600
set C0e[6]=600
return true
endfunction
function DIr takes nothing returns boolean
call VRx(qa,(function DRr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\FrozenStar.page\\FrozenStar.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function DAr takes nothing returns boolean
set C1e=Vnx(C2e)
return true
endfunction
function DNr takes nothing returns boolean
local integer Ixx=jFx()
if(I5x((OPe),Rb,(Ixx)))then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function Dbr takes real a,real b returns boolean
set a=jgx(a,df)
set b=jgx(b,df)
if(a<b)then
return false
endif
return true
endfunction
function DBr takes integer oqx returns integer
set dxe[oqx]=true
set doe[oqx]=false
call rax(C1e)
return oqx
endfunction
function Dcr takes nothing returns integer
local integer oqx
if(C8e==8190)then
call oYx("FrozenStar_Allocation_allocCustom","call DebugEx(FrozenStar.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",C2e+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(C9e[(w)]==w)then
set dve=dve+1
set oqx=dve
else
set oqx=C9e[(w)]
set C9e[(w)]=C9e[C9e[(w)]]
endif
set C9e[oqx]=Z
set dee[oqx]=1
call DBr(oqx)
return oqx
endfunction
function DCr takes integer rwx,integer Ixx returns nothing
call NIx((Ixx),(Cue),(rwx),w,((CTe[rwx])*1.))
endfunction
function Ddr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local real N8x=dre[oqx]
local integer HOx=dVe[oqx]
local real oUx=dIe[oqx]+dAe[oqx]
local integer Q7o=dBe[oqx]
local real x=dCe[oqx]+dde[oqx]
local real y=dDe[oqx]+dfe[oqx]
local real d4r=oUx*(dEe[oqx]*oUx+dRe[oqx])
local integer Ixx
local integer rwx
set dIe[oqx]=oUx
set dCe[oqx]=x
set dDe[oqx]=y
set x=x+d4r*dXe[oqx]
set y=y+d4r*dOe[oqx]
call mFo((mHo(((x)*1.),((y)*1.),(dGe),(ri))))
call Dpx(HOx,x)
call Dqx(HOx,y)
set Hf=(ze[(dae[oqx])])
set OPe=Q7o
call Nio(C3e,x,y,die[oqx],C4e)
set Ixx=Nao(C3e)
if(Ixx!=w)then
set rwx=dbe[oqx]
loop
call dpx(Q7o,Ixx)
call DCr(rwx,Ixx)
set Ixx=Nao(C3e)
exitwhen(Ixx==w)
endloop
endif
endfunction
function DDr takes integer oqx returns nothing
set dxe[oqx]=false
call rgx(C1e)
endfunction
function Dfr takes integer oqx returns nothing
if(dee[oqx]>0)then
return
endif
if(C9e[oqx]!=Z)then
call oYx("FrozenStar_Allocation_deallocCustom_confirm","call DebugEx(FrozenStar.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",C2e+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set C9e[oqx]=C9e[(w)]
set C9e[(w)]=oqx
call DDr(oqx)
endfunction
function DFr takes integer oqx returns nothing
set dee[oqx]=dee[oqx]-1
call Dfr(oqx)
endfunction
function Dgr takes integer oqx,integer CMx,real NIo,integer rwx,real x,real y returns nothing
local integer rkx=oqx
local integer Ixx
call mFo((mHo(((x)*1.),((y)*1.),(dHe),(ri))))
set Hf=(ze[(CMx)])
call Nio(dje,x,y,(Cpx((Cze),u6v+(rwx))),dJe)
set Ixx=Nao(dje)
if(Ixx!=w)then
loop
call DCr(rwx,Ixx)
call OSr(Ixx,dke,.0,(Atan2((((GetUnitY(C[((Ixx))]))-y)*1.),(((GetUnitX(C[((Ixx))]))-x)*1.)))+3.141592654,dKe)
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
set Ixx=Nao(dje)
exitwhen(Ixx==w)
endloop
endif
endfunction
function DGr takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local integer CMx=dae[oqx]
local real NIo=dne[oqx]
local integer HOx=dVe[oqx]
local integer rwx=dbe[oqx]
local integer Q7o=dBe[oqx]
local integer Q6o=dce[oqx]
local real x=dCe[oqx]
local real y=dDe[oqx]
local integer CQx=dFe[oqx]
call DFr((oqx))
call Mfx(HOx)
call ijx(ibx)
call XYr(Q7o)
call ijx(Q6o)
call dRx(CQx)
call Dgr((w),CMx,NIo,rwx,x,y)
endfunction
function Dhr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local real DHr=(GetUnitFacing(C[((CMx))])*bh)
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real dX=dix-wpo
local real dY=dax-wPo
local real N8x=UCx(CMx,dX,dY)
local real Djr=CZe[rwx]*C5e
local real d=jjx(dX,dY)
local real jpx=itx(jHx(DHr,N8x)*C6e,C7e)
local real Dxr=N8x-b6v+2*b6v*RJo(Dbr(DHr,N8x))
local real oUx=Djr*(Cos(((((jpx)*1.))*1.)))
local real DJr=((Sin(((((jpx)*1.))*1.)))*Djr)*1./(oUx*(oUx-CZe[rwx]))
local integer oqx=Dcr()
local integer ibx=inx()
local integer Q6o=inx()
local integer CQx=Cmx(CMx,Cze)
set dre[oqx]=N8x
set die[oqx]=C_e[rwx]
set dae[oqx]=CMx
set dne[oqx]=CWe[rwx]
set dVe[oqx]=mcx('qFrS',wpo,wPo,Olx(CMx,wpo,wPo)+OLx(CMx,true),N8x)
set dEe[oqx]=DJr
set dXe[oqx]=Dxr*(Cos(((((Dxr)*1.))*1.)))
set dOe[oqx]=Dxr*(Sin(((((Dxr)*1.))*1.)))
set dRe[oqx]=-DJr*CZe[rwx]
set dIe[oqx]=.0
set dAe[oqx]=dNe[rwx]
set dbe[oqx]=rwx
set dBe[oqx]=JIx("FrozenStar_Event_SpellEffect: set this.targetGroup = UnitList.Create()")
set dce[oqx]=Q6o
set dCe[oqx]=wpo
set dde[oqx]=dNe[rwx]*(Cos(((((N8x)*1.))*1.)))
set dDe[oqx]=wPo
set dfe[oqx]=dNe[rwx]*(Sin(((((N8x)*1.))*1.)))
set dFe[oqx]=CQx
set ge[(ibx)]=(oqx)
set ge[(Q6o)]=(oqx)
call icx(Q6o,dge,true,function Ddr)
call icx(ibx,dhe[rwx],false,function DGr)
return true
endfunction
function Dkr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
endfunction
function DKr takes nothing returns nothing
set dje=O2x()
set dJe=XLx(function Dkr)
endfunction
function Dlr takes nothing returns boolean
local integer olx
set C3e=O2x()
set C4e=XLx(function DNr)
call meo(Cze,XBx("FrozenStar_Init: call FrozenStar.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FrozenStar.Event_SpellEffect))",ah,pI,function Dhr))
set olx=(j6[(Cze)])
loop
set dhe[olx]=CZe[olx]*1./ C0e[olx]
set dNe[olx]=C0e[olx]*dge
set olx=olx-1
exitwhen(olx<1)
endloop
call DKr()
call W_x(nxv,Cue)
return true
endfunction
function DLr takes nothing returns boolean
call cmr(function Dlr,"FrozenStar_Init")
return true
endfunction
function Dmr takes nothing returns boolean
set dle[5]=hGo('uGh5')
call hho(((dle[5])),Apv,(INv))
set Tj[(dle[5])]=((1)*1.)
set Nav[(dle[5])]=((60)*1.)
set Ntv[(dle[5])]=((60)*1.)
set Nlv[(dle[5])]=(($DC)*1.)
set I3v[(dle[5])]=((1)*1.)
set Axv[(dle[5])]=(1)
set NJv[(dle[5])]=((350)*1.)
set Njv[(dle[5])]=((350)*1.)
set Nhv[(dle[5])]=((0)*1.)
set NIv[(dle[5])]=(($578)*1.)
set NOv[(dle[5])]=(($578)*1.)
set Ndv[(dle[5])]=((80)*1.)
set ANv[(dle[5])]=(gHv)
set Adv[(dle[5])]=((153.6)*1.)
set ADv[((dle[5]))]=((1.*1./((1.7)*1.))*1.)
set Atv[(dle[5])]=((.3)*1.)
set AQv[(dle[5])]=(($A)*1.)
set Asv[(dle[5])]=(($A)*1.)
set Auv[(dle[5])]=(2)
set AWv[(dle[5])]=(2)
set Azv[(dle[5])]=(0)
set Aqv[(dle[5])]=((20)*1.)
return true
endfunction
function DMr takes nothing returns boolean
set dle[1]=hGo('uGho')
call hho(((dle[1])),Apv,(INv))
set Tj[(dle[1])]=((1)*1.)
set Nav[(dle[1])]=((60)*1.)
set Ntv[(dle[1])]=((60)*1.)
set Nlv[(dle[1])]=(($DC)*1.)
set I3v[(dle[1])]=((1)*1.)
set Axv[(dle[1])]=(1)
set NJv[(dle[1])]=(($C8)*1.)
set Njv[(dle[1])]=(($C8)*1.)
set Nhv[(dle[1])]=((0)*1.)
set NIv[(dle[1])]=(($578)*1.)
set NOv[(dle[1])]=(($578)*1.)
set Ndv[(dle[1])]=((40)*1.)
set ANv[(dle[1])]=(gKv)
set Adv[(dle[1])]=((480)*1.)
set ADv[((dle[1]))]=((1.*1./((1.7)*1.))*1.)
set Atv[(dle[1])]=((.3)*1.)
set Drv[(dle[1])]=((600)*1.)
set AQv[(dle[1])]=((7)*1.)
set Asv[(dle[1])]=((7)*1.)
set Auv[(dle[1])]=(2)
set AWv[(dle[1])]=(2)
set Azv[(dle[1])]=(3)
set Aqv[(dle[1])]=((20)*1.)
return true
endfunction
function Dpr takes nothing returns boolean
set dle[3]=hGo('uGh3')
call hho(((dle[3])),Apv,(INv))
set Tj[(dle[3])]=((1)*1.)
set Nav[(dle[3])]=((60)*1.)
set Ntv[(dle[3])]=((60)*1.)
set Nlv[(dle[3])]=(($DC)*1.)
set I3v[(dle[3])]=((1)*1.)
set Axv[(dle[3])]=(1)
set NJv[(dle[3])]=((275)*1.)
set Njv[(dle[3])]=((275)*1.)
set Nhv[(dle[3])]=((0)*1.)
set NIv[(dle[3])]=(($578)*1.)
set NOv[(dle[3])]=(($578)*1.)
set Ndv[(dle[3])]=((60)*1.)
set ANv[(dle[3])]=(gHv)
set Adv[(dle[3])]=((153.6)*1.)
set ADv[((dle[3]))]=((1.*1./((1.7)*1.))*1.)
set Atv[(dle[3])]=((.3)*1.)
set AQv[(dle[3])]=((5)*1.)
set Asv[(dle[3])]=((5)*1.)
set Auv[(dle[3])]=(2)
set AWv[(dle[3])]=(2)
set Azv[(dle[3])]=(0)
set Aqv[(dle[3])]=((20)*1.)
return true
endfunction
function DPr takes nothing returns boolean
set dle[4]=hGo('uGh4')
call hho(((dle[4])),Apv,(INv))
set Tj[(dle[4])]=((1)*1.)
set Nav[(dle[4])]=((60)*1.)
set Ntv[(dle[4])]=((60)*1.)
set Nlv[(dle[4])]=(($DC)*1.)
set I3v[(dle[4])]=((1)*1.)
set Axv[(dle[4])]=(1)
set NJv[(dle[4])]=((350)*1.)
set Njv[(dle[4])]=((350)*1.)
set Nhv[(dle[4])]=((0)*1.)
set NIv[(dle[4])]=(($578)*1.)
set NOv[(dle[4])]=(($578)*1.)
set Ndv[(dle[4])]=((60)*1.)
set ANv[(dle[4])]=(gHv)
set Adv[(dle[4])]=((153.6)*1.)
set ADv[((dle[4]))]=((1.*1./((1.7)*1.))*1.)
set Atv[(dle[4])]=((.3)*1.)
set AQv[(dle[4])]=(($A)*1.)
set Asv[(dle[4])]=(($A)*1.)
set Auv[(dle[4])]=(2)
set AWv[(dle[4])]=(2)
set Azv[(dle[4])]=(0)
set Aqv[(dle[4])]=((20)*1.)
return true
endfunction
function Dqr takes nothing returns boolean
set dLe=lQx(dme+" (dummyBuff)")
call lux(dLe,"GhostSword_page\\GhostSword_struct\\Sword\\ScimitarAttachment.mdx","weapon",ri)
return true
endfunction
function DQr takes nothing returns boolean
set dMe[1]=.5
set dMe[2]=.75
set dMe[3]=1
set dMe[4]=1.25
set dMe[5]=1.5
set dMe[6]=1.75
set dpe[1]=5
set dpe[2]=7.5
set dpe[3]=7.5
set dpe[4]=$A
set dpe[5]=$A
set dpe[6]=12.5
set dPe[1]=.25
set dPe[2]=.25
set dPe[3]=.25
set dPe[4]=.25
set dPe[5]=.25
set dPe[6]=.25
set dqe[1]=2
set dqe[2]=2
set dqe[3]=2
set dqe[4]=2
set dqe[5]=2
set dqe[6]=2
return true
endfunction
function Dsr takes nothing returns boolean
set dle[6]=hGo('uGh6')
call hho(((dle[6])),Apv,(INv))
set Tj[(dle[6])]=((1)*1.)
set Nav[(dle[6])]=((60)*1.)
set Ntv[(dle[6])]=((60)*1.)
set Nlv[(dle[6])]=(($DC)*1.)
set I3v[(dle[6])]=((1)*1.)
set Axv[(dle[6])]=(1)
set NJv[(dle[6])]=((350)*1.)
set Njv[(dle[6])]=((350)*1.)
set Nhv[(dle[6])]=((0)*1.)
set NIv[(dle[6])]=(($578)*1.)
set NOv[(dle[6])]=(($578)*1.)
set Ndv[(dle[6])]=(('d')*1.)
set ANv[(dle[6])]=(gHv)
set Adv[(dle[6])]=((153.6)*1.)
set ADv[((dle[6]))]=((1.*1./((1.7)*1.))*1.)
set Atv[(dle[6])]=((.3)*1.)
set AQv[(dle[6])]=(($A)*1.)
set Asv[(dle[6])]=(($A)*1.)
set Auv[(dle[6])]=(2)
set AWv[(dle[6])]=(2)
set Azv[(dle[6])]=(0)
set Aqv[(dle[6])]=((20)*1.)
return true
endfunction
function DSr takes nothing returns boolean
set dle[2]=hGo('uGh2')
call hho(((dle[2])),Apv,(INv))
set Tj[(dle[2])]=((1)*1.)
set Nav[(dle[2])]=((60)*1.)
set Ntv[(dle[2])]=((60)*1.)
set Nlv[(dle[2])]=(($DC)*1.)
set I3v[(dle[2])]=((1)*1.)
set Axv[(dle[2])]=(1)
set NJv[(dle[2])]=((275)*1.)
set Njv[(dle[2])]=((275)*1.)
set Nhv[(dle[2])]=((0)*1.)
set NIv[(dle[2])]=(($578)*1.)
set NOv[(dle[2])]=(($578)*1.)
set Ndv[(dle[2])]=((40)*1.)
set ANv[(dle[2])]=(gHv)
set Adv[(dle[2])]=((153.6)*1.)
set ADv[((dle[2]))]=((1.*1./((1.7)*1.))*1.)
set Atv[(dle[2])]=((.3)*1.)
set AQv[(dle[2])]=((5)*1.)
set Asv[(dle[2])]=((5)*1.)
set Auv[(dle[2])]=(2)
set AWv[(dle[2])]=(2)
set Azv[(dle[2])]=(0)
set Aqv[(dle[2])]=((20)*1.)
return true
endfunction
function Dtr takes nothing returns boolean
call VRx(Sa,(function Dmr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\obj_summonUnitType[5]_wc3unit.j"))
call VRx(Sa,(function DMr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\obj_summonUnitType[1]_wc3unit.j"))
call VRx(Sa,(function Dpr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\obj_summonUnitType[3]_wc3unit.j"))
call VRx(Sa,(function DPr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\obj_summonUnitType[4]_wc3unit.j"))
call VRx(Ma,(function Dqr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function DQr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\obj_this_wc3obj.j"))
call VRx(Sa,(function Dsr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\obj_summonUnitType[6]_wc3unit.j"))
call VRx(Sa,(function DSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\obj_summonUnitType[2]_wc3unit.j"))
return true
endfunction
function DTr takes nothing returns boolean
set dQe=Vnx(dme)
return true
endfunction
function Dur takes nothing returns boolean
call LZx('AGhS',false)
set cae=Lzo('AGhS')
set G6[(cae)]=(B6)
set j6[(cae)]=(6)
set sH[(cae)]=("Ghost Sword")
set Ih[(cae)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0274)))),(((Oj))))))
set x6v[(cae)]=(4)
set xzv[(cae)]=("spell")
call LZo((cae),fH+(1),(($C)*1.))
call LZo((cae),QH+(1),((40)*1.))
call LZo((cae),Lvv+(1),((750)*1.))
call LZo((cae),fH+(2),(($C)*1.))
call LZo((cae),QH+(2),((50)*1.))
call LZo((cae),Lvv+(2),((750)*1.))
call LZo((cae),fH+(3),(($C)*1.))
call LZo((cae),QH+(3),((60)*1.))
call LZo((cae),Lvv+(3),((750)*1.))
call LZo((cae),fH+(4),(($C)*1.))
call LZo((cae),QH+(4),((70)*1.))
call LZo((cae),Lvv+(4),((750)*1.))
call LZo((cae),fH+(5),(($C)*1.))
call LZo((cae),QH+(5),((80)*1.))
call LZo((cae),Lvv+(5),((750)*1.))
call LZo((cae),fH+(6),(($C)*1.))
call LZo((cae),QH+(6),((90)*1.))
call LZo((cae),Lvv+(6),((750)*1.))
set Mnv[(cae)]=("ReplaceableTextures\\CommandButtons\\BTNThoriumMelee.blp")
call ccr(cae,'FGS0',6,'VGS0','LPGS','LRGS')
set dse[1]=2
set dse[2]=2
set dse[3]=3
set dse[4]=3
set dse[5]=4
set dse[6]=4
set dSe[1]=25
set dSe[2]=25
set dSe[3]=25
set dSe[4]=25
set dSe[5]=25
set dSe[6]=25
return true
endfunction
function DUr takes nothing returns boolean
set dte=lQx(dTe+" (dummyBuff)")
set qc[(dte)]=(true)
return true
endfunction
function Dwr takes nothing returns boolean
call VRx(qa,(function Dur),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function DUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function DWr takes nothing returns boolean
set due=Vnx(dTe)
return true
endfunction
function Dyr takes integer oqx returns boolean
if((dwe[((oqx))])>0)then
return false
endif
set dWe=dWe+1
set dye[dWe]=oqx
set dwe[oqx]=dWe+1
return(dWe==0)
endfunction
function DYr takes nothing returns nothing
local integer olx=dWe
loop
exitwhen(olx<0)
set dZe[olx]=dye[olx]
set olx=olx-1
endloop
set d_e=dWe
endfunction
function Dzr takes nothing returns integer
local integer o4x
if(d_e<0)then
return w
endif
set o4x=dZe[0]
set dZe[0]=dZe[d_e]
set d_e=d_e-1
return o4x
endfunction
function DZr takes nothing returns nothing
local integer oqx
local real N8x
local real iXr
local integer Ixx
local real djr
local integer olx
local integer D_r
call DYr()
loop
set oqx=Dzr()
exitwhen(oqx==w)
set N8x=d0e[oqx]
set iXr=d1e[oqx]
set Ixx=oqx
set djr=dvx(Ixx,true)
set d0e[oqx]=N8x+d2e*dze
set olx=CXx(Ixx,d3e)
loop
exitwhen(olx<q)
set D_r=COx(Ixx,d3e,olx)
if((LoadInteger(o[((V[(E[((X))])]))],((((GetUnitCurrentOrder(C[((Ixx))]))))),(((Oj)))))==w)then
endif
call fWx(D_r,(GetUnitX(C[((Ixx))]))+(djr*(1+d4e))*(Cos(((((N8x)*1.))*1.))),(GetUnitY(C[((Ixx))]))+(djr*(1+d4e))*(Sin(((((N8x)*1.))*1.))))
set N8x=N8x+iXr
set olx=olx-1
endloop
endloop
endfunction
function D0r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer olx
local integer D_r
if Dyr(oqx)then
call icx(dYe,dze,true,function DZr)
endif
set olx=CXx(Ixx,d3e)
loop
exitwhen(olx<q)
set D_r=COx(Ixx,d3e,olx)
call UJx(((D_r)),Oyv)
set olx=olx-1
endloop
return true
endfunction
function D1r takes integer oqx returns boolean
if(((dwe[((oqx))])>0)==false)then
return false
endif
set dwe[dye[dWe]]=dwe[oqx]
set dye[dwe[oqx]-1]=dye[dWe]
set dwe[oqx]=0
set dWe=dWe-1
return(dWe==F)
endfunction
function D2r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer olx
local integer D_r
if D1r(oqx)then
call iHx(dYe)
endif
set olx=CXx(Ixx,d3e)
loop
exitwhen(olx<q)
set D_r=COx(Ixx,d3e,olx)
call DSx((((D_r))),(Oyv),(1),w)
set olx=olx-1
endloop
return true
endfunction
function D3r takes integer C0o,real x,real y,real N8x,integer rwx returns integer
local integer D_r=Uzo(dle[rwx],C0o,x,y,N8x,dSe[rwx])
call DSx((D_r),(dLe),(rwx),w)
call DSx((((D_r))),(nTv),(1),w)
call DSx((((D_r))),(x_v),(1),w)
call DSx((((D_r))),(XVv),(1),w)
call rzx((D_r),(d6e),(rwx))
call rzx(((D_r)),((gQv)),(1))
return D_r
endfunction
function D4r takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer CQx=(mc[(rdx)])
local integer CMx=(aH[(CQx)])
local real djr=dvx(Ixx,true)
local integer olx=dse[rwx]
local real dix=(GetUnitX(C[((Ixx))]))
local real dax=(GetUnitY(C[((Ixx))]))
local real N8x=(GetUnitFacing(C[((CMx))])*bh)
local real iXr=df*1./ olx
local integer C0o=(ze[(CMx)])
local integer oqx=Ixx
local integer D_r
set d0e[oqx]=N8x
set d1e[oqx]=iXr
call I7x(Ixx,dUe)
call I7x(Ixx,d5e)
loop
exitwhen(olx<1)
set D_r=D3r(C0o,dix+(djr*(1+d4e))*(Cos(((((N8x)*1.))*1.))),dax+(djr*(1+d4e))*(Sin(((((N8x)*1.))*1.))),N8x,rwx)
call rtx(Ixx,d3e,D_r)
call AYo(D_r)
call DUx(D_r,djr*1./ 36.)
call SetUnitLookAt(C[D_r],"bone_chest",C[Ixx],.0,.0,.0)
set N8x=N8x+iXr
set olx=olx-1
endloop
if Dyr(oqx)then
call icx(dYe,dze,true,function DZr)
endif
return true
endfunction
function D5r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer olx=CXx(Ixx,d3e)
local integer D_r
loop
exitwhen(olx<q)
set D_r=COx(Ixx,d3e,olx)
call Cex((D_r),w)
call KFx(D_r)
set olx=olx-1
endloop
call NTo(Ixx,d3e)
call Rmx(Ixx,dUe)
call Rmx(Ixx,d5e)
if D1r(oqx)then
call iHx(dYe)
endif
return true
endfunction
function D6r takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer CQx=(uH[(rdx)])
call Ayx(Ixx,dte)
call NIx(Ixx,dte,rwx,CQx,dSe[rwx])
return true
endfunction
function D7r takes nothing returns boolean
local integer rdx=(bv)
local integer D_r=(Vv[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer oqx=D_r
local real ilx
if I6x(Ixx,yd)then
set ilx=dPe[d8e[oqx]]
else
set ilx=dqe[d8e[oqx]]
endif
call nar(d8e[oqx],Ixx,ilx)
return true
endfunction
function D8r takes nothing returns boolean
local integer rdx=(bv)
local integer D_r=(EYv[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=D_r
local real D9r=itx((LF[(Ixx)]),Dve[oqx])
if(D9r>.0)then
call RUx((Abx((Ixx),(Dee),(Dxe),(ri))))
call Ybo(Ixx,D9r)
call nJo((D_r),(Ixx),((D9r*Doe[oqx])*1.),(true),(false))
endif
return true
endfunction
function fvr takes integer oqx returns boolean
if((DEe[((oqx))])>0)then
return false
endif
set DXe=DXe+1
set DOe[DXe]=oqx
set DEe[oqx]=DXe+1
return(DXe==0)
endfunction
function fer takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer fxr=inx()
set Die[oqx]=true
set Dae[oqx]=fxr
set Doe[oqx]=dMe[rwx]
set d8e[oqx]=rwx
set Dve[oqx]=dpe[rwx]
set ge[(fxr)]=(oqx)
call RUx((Abx((Ixx),(Dne),(DVe),(ri))))
call I7x(Ixx,d7e)
call I7x(Ixx,d9e)
if fvr(oqx)then
endif
return true
endfunction
function for takes integer oqx returns boolean
if(((DEe[((oqx))])>0)==false)then
return false
endif
set DEe[DOe[DXe]]=DEe[oqx]
set DOe[DEe[oqx]-1]=DOe[DXe]
set DEe[oqx]=0
set DXe=DXe-1
return(DXe==F)
endfunction
function frr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer fxr=Dae[oqx]
call RUx((Abx((Ixx),(DRe),(DIe),(ri))))
call ijx(fxr)
call Rmx(Ixx,d7e)
call Rmx(Ixx,d9e)
if Die[oqx]then
if for(oqx)then
call iHx(Dre)
endif
endif
return true
endfunction
function fir takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function far takes nothing returns nothing
set d7e=XBx("FolderGhostSword_StructSword_Init: set FolderGhostSword_StructSword.CRIT_EVENT = Event.Create(UNIT.CriticalChance.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderGhostSword_StructSword.Event_Crit)",BBv,pI,function D7r)
set d9e=XBx("FolderGhostSword_StructSword_Init: set FolderGhostSword_StructSword.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function FolderGhostSword_StructSword.Event_Damage)",EZv,pI,function D8r)
set Dre=inx()
call l9x(dLe,XBx("FolderGhostSword_StructSword_Init: call FolderGhostSword_StructSword.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderGhostSword_StructSword.Event_BuffGain))",Bd,pI,function fer))
call l9x(dLe,XBx("FolderGhostSword_StructSword_Init: call FolderGhostSword_StructSword.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderGhostSword_StructSword.Event_BuffLose))",Jc,pI,function frr))
set DAe=O2x()
set DNe=XLx(function fir)
endfunction
function fnr takes nothing returns boolean
set dUe=XBx("GhostSword_Init: set GhostSword.TRANSPORT_ENDING_EVENT = Event.Create(UNIT.Transport.ENDING_EVENT_TYPE, EventPriority.SPELLS, function GhostSword.Event_TransportEnding)",O2v,pI,function D0r)
set d5e=XBx("GhostSword_Init: set GhostSword.TRANSPORT_START_EVENT = Event.Create(UNIT.Transport.START_EVENT_TYPE, EventPriority.SPELLS, function GhostSword.Event_TransportStart)",O1v,pI,function D2r)
set dYe=inx()
call l9x(dte,XBx("GhostSword_Init: call GhostSword.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function GhostSword.Event_BuffGain))",Bd,pI,function D4r))
call l9x(dte,XBx("GhostSword_Init: call GhostSword.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function GhostSword.Event_BuffLose))",Jc,pI,function D5r))
call meo(cae,XBx("GhostSword_Init: call GhostSword.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function GhostSword.Event_SpellEffect))",ah,pI,function D6r))
call far()
return true
endfunction
function fVr takes nothing returns boolean
call cmr(function fnr,"GhostSword_Init")
return true
endfunction
function fEr takes nothing returns boolean
set Dbe[1]=20
set Dbe[2]=30
set Dbe[3]=40
set Dbe[4]=50
set Dbe[5]=60
set Dbe[6]=70
set DBe[1]=.2
set DBe[2]=.3
set DBe[3]=.4
set DBe[4]=.5
set DBe[5]=.6
set DBe[6]=.7
return true
endfunction
function fXr takes nothing returns boolean
set Dce=WTx('BHnS',"Hack'n'Slay",'bHnS')
set aev[(Dce)]=("ReplaceableTextures\\CommandButtons\\BTNCriticalStrike.blp")
set SU=lYx()
call l_x(SU,nev,.2)
call l_x(SU,Bcv,20)
call l0x(((Dce)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,nev,.3)
call l_x(SU,Bcv,30)
call l0x(((Dce)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,nev,.4)
call l_x(SU,Bcv,40)
call l0x(((Dce)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,nev,.5)
call l_x(SU,Bcv,50)
call l0x(((Dce)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,nev,.6)
call l_x(SU,Bcv,60)
call l0x(((Dce)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,nev,.7)
call l_x(SU,Bcv,70)
call l0x(((Dce)),vc+(6),(SU))
return true
endfunction
function fOr takes nothing returns boolean
call VRx(ea,(function fEr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\HackNSlay.page\\HackNSlay.struct\\Target\\obj_this_wc3obj.j"))
call VRx(Ma,(function fXr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\HackNSlay.page\\HackNSlay.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function fRr takes nothing returns boolean
set DCe=Vnx(Dde)
return true
endfunction
function fIr takes nothing returns boolean
set DDe=lQx(Dfe+" (dummyBuff)")
set avv[(DDe)]=(true)
return true
endfunction
function fAr takes nothing returns boolean
call LZx('AHnS',false)
set d6e=Lzo('AHnS')
set G6[(d6e)]=(D6)
set j6[(d6e)]=(6)
set sH[(d6e)]=("Hack'n'Slay")
set xzv[(d6e)]=("spell")
call LZo((d6e),u6v+(1),((400)*1.))
call LZo((d6e),Lvv+(1),((750)*1.))
call LZo((d6e),u6v+(2),((400)*1.))
call LZo((d6e),Lvv+(2),((750)*1.))
call LZo((d6e),u6v+(3),((400)*1.))
call LZo((d6e),Lvv+(3),((750)*1.))
call LZo((d6e),u6v+(4),((400)*1.))
call LZo((d6e),Lvv+(4),((750)*1.))
call LZo((d6e),u6v+(5),((400)*1.))
call LZo((d6e),Lvv+(5),((750)*1.))
call LZo((d6e),u6v+(6),((400)*1.))
call LZo((d6e),Lvv+(6),((750)*1.))
set Mnv[(d6e)]=("ReplaceableTextures\\PassiveButtons\\PASBTNCriticalStrike.blp")
return true
endfunction
function fNr takes nothing returns boolean
call VRx(Ma,(function fIr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\HackNSlay.page\\HackNSlay.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function fAr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\HackNSlay.page\\HackNSlay.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function fbr takes nothing returns boolean
set DFe=Vnx(Dfe)
return true
endfunction
function fBr takes code c,string rqx returns nothing
set wn=wn+1
set Wn[wn]=CreateTrigger()
set yn[wn]=(GetHandleId(Condition((c))))
set Yn[wn]=rqx
call TriggerAddCondition(Wn[wn],Condition(c))
endfunction
function fcr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if((IsUnitAlly(C[(Ixx)],vx[(Hf)]))==false)then
return false
endif
return true
return true
endfunction
function fCr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer oqx=CMx
local integer XSr=Xpr(CMx)
set DGe[oqx]=XSr
set Dhe[oqx]=CMx
set DHe[oqx]=rwx
set Eee[(XSr)]=(oqx)
set vme[(XSr)]=(((Cpx((d6e),u6v+(rwx))))*1.)
set vMe[(XSr)]=(Dge)
call XPr(XSr,Dje)
call XPr(XSr,DJe)
call XQr(XSr)
return true
endfunction
function fdr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer oqx=CMx
local integer XSr=DGe[oqx]
call X2r(XSr)
return true
endfunction
function fDr takes nothing returns boolean
local integer rdx=(bv)
call Q8o((Vv[(rdx)]),DDe,(Mv[(rdx)]))
return true
endfunction
function ffr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),DDe)
return true
endfunction
function fFr takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer rkx=(Eee[(XSr)])
call UJx(Ixx,Dce)
return true
endfunction
function fgr takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer CMx=(vhe[(XSr)])
local integer rkx=(Eee[(XSr)])
local integer rwx=DHe[rkx]
call DSx((Ixx),(Dce),(rwx),w)
return true
endfunction
function fGr takes nothing returns nothing
set Dje=XBx("FolderHackNSlay_StructTarget_Init: set FolderHackNSlay_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderHackNSlay_StructTarget.Event_Ending)",vQe,pI,function fFr)
set DJe=XBx("FolderHackNSlay_StructTarget_Init: set FolderHackNSlay_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderHackNSlay_StructTarget.Event_Start)",vse,pI,function fgr)
endfunction
function fhr takes nothing returns boolean
set Dge=XLx(function fcr)
call l9x(DDe,XBx("HackNSlay_Init: call HackNSlay.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HackNSlay.Event_BuffGain))",Bd,pI,function fCr))
call l9x(DDe,XBx("HackNSlay_Init: call HackNSlay.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HackNSlay.Event_BuffLose))",Jc,pI,function fdr))
call meo(d6e,XBx("HackNSlay_Init: call HackNSlay.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function HackNSlay.Event_Learn))",Pv,pI,function fDr))
call meo(d6e,XBx("HackNSlay_Init: call HackNSlay.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HackNSlay.Event_Learn))",pv,pI,function fDr))
call meo(d6e,XBx("HackNSlay_Init: call HackNSlay.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HackNSlay.Event_Unlearn))",Av,pI,function ffr))
call fGr()
return true
endfunction
function fHr takes nothing returns boolean
call fBr(function fhr,"HackNSlay_Init")
return true
endfunction
function fjr takes nothing returns boolean
call LZx('AIcB',false)
set Dke=Lzo('AIcB')
set G6[(Dke)]=(B6)
set j6[(Dke)]=(6)
set sH[(Dke)]=("Ice Block")
set Ih[(Dke)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0216)))),(((Oj))))))
set x6v[(Dke)]=(0)
set xzv[(Dke)]=("spell")
call LZo((Dke),fH+(1),(($F)*1.))
call LZo((Dke),QH+(1),((30)*1.))
call LZo((Dke),Lvv+(1),((750)*1.))
call LZo((Dke),fH+(2),(($F)*1.))
call LZo((Dke),QH+(2),((35)*1.))
call LZo((Dke),Lvv+(2),((750)*1.))
call LZo((Dke),fH+(3),(($F)*1.))
call LZo((Dke),QH+(3),((40)*1.))
call LZo((Dke),Lvv+(3),((750)*1.))
call LZo((Dke),fH+(4),(($F)*1.))
call LZo((Dke),QH+(4),((45)*1.))
call LZo((Dke),Lvv+(4),((750)*1.))
call LZo((Dke),fH+(5),(($F)*1.))
call LZo((Dke),QH+(5),((50)*1.))
call LZo((Dke),Lvv+(5),((750)*1.))
set Mnv[(Dke)]=("ReplaceableTextures\\CommandButtons\\BTNIcyTreasureBox.blp")
set DKe[1]=5
set DKe[2]=$A
set DKe[3]=$F
set DKe[4]=20
set DKe[5]=25
set Dle[1]=5
set Dle[2]=5.5
set Dle[3]=6
set Dle[4]=6.5
set Dle[5]=7
return true
endfunction
function fJr takes nothing returns boolean
set DLe=WTx('BIcB',"Ice Block",'bIcB')
set avv[(DLe)]=(true)
set qU[(DLe)]=(true)
set aev[(DLe)]=("ReplaceableTextures\\CommandButtons\\BTNIcyTreasureBox.blp")
call lux(DLe,"Abilities\\Spells\\Undead\\FreezingBreath\\FreezingBreathTargetArt.mdl","origin",ri)
call lux(DLe,"Abilities\\Spells\\Items\\StaffOfSanctuary\\Staff_Sanctuary_Target.mdl","chest",Bi)
set SU=lYx()
call l_x(SU,Dgv,5)
call vOr(SU,DEv,true)
call vOr(SU,Dhv,true)
call vOr(SU,Dkv,true)
call l0x(((DLe)),vc+(1),(SU))
return true
endfunction
function fkr takes nothing returns boolean
call VRx(qa,(function fjr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\IceBlock.page\\IceBlock.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function fJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\IceBlock.page\\IceBlock.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function fKr takes nothing returns boolean
set Dme=Vnx(DMe)
return true
endfunction
function flr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Mv[(rdx)])
call NIx(((Vv[(rdx)])),(DLe),(rwx),w,((Dle[rwx])*1.))
return true
endfunction
function fLr takes nothing returns boolean
call meo(Dke,XBx("IceBlock_Init: call IceBlock.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function IceBlock.Event_SpellEffect))",ah,pI,function flr))
return true
endfunction
function fmr takes nothing returns boolean
call cmr(function fLr,"IceBlock_Init")
return true
endfunction
function fMr takes nothing returns boolean
set Dpe=lQx(DPe+" (frostBuff)")
return true
endfunction
function fpr takes nothing returns boolean
set Dqe=lQx(DPe+" (coldnessBuff)")
return true
endfunction
function fPr takes nothing returns boolean
call LZx('AIcS',false)
set cie=Lzo('AIcS')
set G6[(cie)]=(B6)
set j6[(cie)]=(6)
set sH[(cie)]=("Ice Shock")
set Ih[(cie)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0108)))),(((Oj))))))
set x6v[(cie)]=(4)
set xzv[(cie)]=("spell")
call LZo((cie),u6v+(1),(($C8)*1.))
call LZo((cie),fH+(1),(($F)*1.))
call LZo((cie),QH+(1),((70)*1.))
call LZo((cie),Lvv+(1),((600)*1.))
call LZo((cie),u6v+(2),(($C8)*1.))
call LZo((cie),fH+(2),(($F)*1.))
call LZo((cie),QH+(2),((70)*1.))
call LZo((cie),Lvv+(2),((600)*1.))
call LZo((cie),u6v+(3),(($C8)*1.))
call LZo((cie),fH+(3),(($F)*1.))
call LZo((cie),QH+(3),((70)*1.))
call LZo((cie),Lvv+(3),((600)*1.))
call LZo((cie),u6v+(4),(($C8)*1.))
call LZo((cie),fH+(4),(($F)*1.))
call LZo((cie),QH+(4),((70)*1.))
call LZo((cie),Lvv+(4),((600)*1.))
call LZo((cie),u6v+(5),(($C8)*1.))
call LZo((cie),fH+(5),(($F)*1.))
call LZo((cie),QH+(5),((70)*1.))
call LZo((cie),Lvv+(5),((600)*1.))
call LZo((cie),u6v+(6),(($C8)*1.))
call LZo((cie),fH+(6),(($F)*1.))
call LZo((cie),QH+(6),((70)*1.))
call LZo((cie),Lvv+(6),((600)*1.))
set Mnv[(cie)]=("ReplaceableTextures\\CommandButtons\\BTNGlacier.blp")
call ccr(cie,'FIS0',6,'VIS0','LPIS','LRIS')
set DQe[1]=1
set DQe[2]=1
set DQe[3]=1
set DQe[4]=1
set DQe[5]=1
set DQe[6]=1
set Dse[1]=4
set Dse[2]=4
set Dse[3]=4
set Dse[4]=4
set Dse[5]=4
set Dse[6]=4
set DSe[1]=1
set DSe[2]=1
set DSe[3]=1
set DSe[4]=1
set DSe[5]=1
set DSe[6]=1
set Dte[1]=25
set Dte[2]=50
set Dte[3]=75
set Dte[4]='d'
set Dte[5]='}'
set Dte[6]=$96
set DTe[1]=$A
set DTe[2]=25
set DTe[3]=40
set DTe[4]=55
set DTe[5]=70
set DTe[6]=85
set Due[1]=4
set Due[2]=4
set Due[3]=4
set Due[4]=4
set Due[5]=4
set Due[6]=4
return true
endfunction
function fqr takes nothing returns boolean
call VRx(Ma,(function fMr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\IceShock.page\\IceShock.struct\\obj_frostBuff_wc3buff.j"))
call VRx(Ma,(function fpr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\IceShock.page\\IceShock.struct\\obj_coldnessBuff_wc3buff.j"))
call VRx(qa,(function fPr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\IceShock.page\\IceShock.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function fQr takes nothing returns boolean
set DUe=Vnx(DPe)
return true
endfunction
function fsr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function fSr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local integer C0o
local real ilx
local real NIo
call mFo((mHo(((dix)*1.),((dax)*1.),(Dye),(ri))))
set C0o=(ze[(CMx)])
set Hf=C0o
call Nio(Dwe,dix,dax,(Cpx((cie),u6v+(rwx))),DWe)
call GroupRemoveUnit(Kb[(Dwe)],C[(Ixx)])
if I6x(Ixx,yd)then
set ilx=DQe[rwx]
else
set ilx=Due[rwx]
endif
call NIx((Ixx),(Dpe),(rwx),w,((ilx)*1.))
call nJo((CMx),(Ixx),((Dte[rwx])*1.),(true),(false))
set Ixx=Nao(Dwe)
if(Ixx!=w)then
set NIo=DTe[rwx]
loop
if I6x(Ixx,yd)then
set ilx=DSe[rwx]
else
set ilx=Dse[rwx]
endif
call NIx((Ixx),(Dqe),(rwx),w,((ilx)*1.))
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
set Ixx=Nao(Dwe)
exitwhen(Ixx==w)
endloop
endif
return true
endfunction
function ftr takes nothing returns boolean
set Dwe=O2x()
set DWe=XLx(function fsr)
call meo(cie,XBx("IceShock_Init: call IceShock.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function IceShock.Event_SpellEffect))",ah,pI,function fSr))
call W_x(nxv,Dqe)
call W_x(nCv,Dpe)
return true
endfunction
function fTr takes nothing returns boolean
call fBr(function ftr,"IceShock_Init")
return true
endfunction
function fur takes nothing returns boolean
set DYe[1]=$A
set DYe[2]=$F
set DYe[3]=20
set DYe[4]=25
set DYe[5]=30
set DYe[6]=35
return true
endfunction
function fUr takes nothing returns boolean
set Dze=WTx('BIFo',"Inner Force",'bIFo')
set avv[(Dze)]=(true)
set qc[(Dze)]=(true)
set aev[(Dze)]=("ReplaceableTextures\\CommandButtons\\BTNImmolationOn.blp")
call lux(Dze,"Abilities\\Spells\\NightElf\\Immolation\\ImmolationTarget.mdl","origin",ri)
set SU=lYx()
call l_x(SU,Bcv,$A)
call l0x(((Dze)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,Bcv,$F)
call l0x(((Dze)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,Bcv,20)
call l0x(((Dze)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,Bcv,25)
call l0x(((Dze)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,Bcv,30)
call l0x(((Dze)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,Bcv,35)
call l0x(((Dze)),vc+(6),(SU))
return true
endfunction
function fwr takes nothing returns boolean
call VRx(ea,(function fur),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\InnerForce.page\\InnerForce.struct\\Crit\\obj_this_wc3obj.j"))
call VRx(Ma,(function fUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\InnerForce.page\\InnerForce.struct\\Crit\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function fWr takes nothing returns boolean
set DZe=Vnx(D_e)
return true
endfunction
function fyr takes nothing returns boolean
call LZx('AIFo',false)
set cVe=Lzo('AIFo')
set G6[(cVe)]=(B6)
set j6[(cVe)]=(6)
set sH[(cVe)]=("Inner Force")
set Ih[(cVe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0108)))),(((Oj))))))
set x6v[(cVe)]=(0)
set xzv[(cVe)]=("spell")
call LZo((cVe),u6v+(1),(($E1)*1.))
call LZo((cVe),fH+(1),(($D)*1.))
call LZo((cVe),QH+(1),((40)*1.))
call LZo((cVe),Lvv+(1),((750)*1.))
call LZo((cVe),u6v+(2),(($E1)*1.))
call LZo((cVe),fH+(2),(($D)*1.))
call LZo((cVe),QH+(2),((50)*1.))
call LZo((cVe),Lvv+(2),((750)*1.))
call LZo((cVe),u6v+(3),(($E1)*1.))
call LZo((cVe),fH+(3),(($D)*1.))
call LZo((cVe),QH+(3),((60)*1.))
call LZo((cVe),Lvv+(3),((750)*1.))
call LZo((cVe),u6v+(4),(($E1)*1.))
call LZo((cVe),fH+(4),(($D)*1.))
call LZo((cVe),QH+(4),((70)*1.))
call LZo((cVe),Lvv+(4),((750)*1.))
call LZo((cVe),u6v+(5),(($E1)*1.))
call LZo((cVe),fH+(5),(($D)*1.))
call LZo((cVe),QH+(5),((80)*1.))
call LZo((cVe),Lvv+(5),((750)*1.))
call LZo((cVe),u6v+(6),(($E1)*1.))
call LZo((cVe),fH+(6),(($D)*1.))
call LZo((cVe),QH+(6),((90)*1.))
call LZo((cVe),Lvv+(6),((750)*1.))
set Mnv[(cVe)]=("ReplaceableTextures\\CommandButtons\\BTNImmolationOn.blp")
call ccr(cVe,'FIF0',6,'VIF0','LPIF','LRIF')
set D0e[1]=25
set D0e[2]=34
set D0e[3]=43
set D0e[4]=52
set D0e[5]=61
set D0e[6]=70
set D1e[1]=30
set D1e[2]=50
set D1e[3]=70
set D1e[4]=90
set D1e[5]='x'
set D1e[6]=$96
return true
endfunction
function fYr takes nothing returns boolean
call VRx(qa,(function fyr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\InnerForce.page\\InnerForce.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function fzr takes nothing returns boolean
set D2e=Vnx(D3e)
return true
endfunction
function fZr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if((IsUnitAlly(C[(Ixx)],vx[(Hf)]))==false)then
return false
endif
return true
return true
endfunction
function f_r takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function f0r takes integer oqx returns integer
set fee[oqx]=true
set fxe[oqx]=false
call rax(D2e)
return oqx
endfunction
function f1r takes nothing returns integer
local integer oqx
if(D7e==8190)then
call oYx("InnerForce_Allocation_allocCustom","call DebugEx(InnerForce.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",D3e+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(D8e[(w)]==w)then
set D9e=D9e+1
set oqx=D9e
else
set oqx=D8e[(w)]
set D8e[(w)]=D8e[D8e[(w)]]
endif
set D8e[oqx]=Z
set fve[oqx]=1
call f0r(oqx)
return oqx
endfunction
function f2r takes integer oqx returns nothing
local integer CMx=fae[oqx]
local real O1o=dvx(CMx,true)+fie[oqx]
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local integer Ixx
local real Anr
local real NIo
call RUx((Abx((CMx),(fbe),(fBe),(Bi))))
set Hf=(ze[(CMx)])
call Nio(D4e,wpo,wPo,O1o,D5e)
set Ixx=Nao(D4e)
if(Ixx!=w)then
set Anr=fVe[oqx]
loop
call moo(CMx,Ixx,Anr)
set Ixx=Nao(D4e)
exitwhen(Ixx==w)
endloop
endif
set Hf=(ze[(CMx)])
call Nio(D4e,wpo,wPo,O1o,D6e)
set Ixx=Nao(D4e)
if(Ixx!=w)then
set NIo=fne[oqx]
loop
call OSr(Ixx,fce,fCe,(Atan2((((GetUnitY(C[((Ixx))]))-wPo)*1.),(((GetUnitX(C[((Ixx))]))-wpo)*1.))),fde)
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
set Ixx=Nao(D4e)
exitwhen(Ixx==w)
endloop
endif
endfunction
function f3r takes nothing returns nothing
local integer OHx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(OHx)])
call f2r(oqx)
endfunction
function f4r takes integer oqx returns nothing
local integer OHx
call RUx((Abx((fae[oqx]),(fIe),(fAe),(ri))))
set OHx=inx()
set fre[oqx]=fre[oqx]+1
set ge[(OHx)]=(oqx)
call icx(OHx,fNe,false,function f3r)
endfunction
function f5r takes nothing returns nothing
call f4r(((ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])))
endfunction
function f6r takes integer oqx returns nothing
set fee[oqx]=false
call rgx(D2e)
endfunction
function f7r takes integer oqx returns nothing
if(fve[oqx]>0)then
return
endif
if(D8e[oqx]!=Z)then
call oYx("InnerForce_Allocation_deallocCustom_confirm","call DebugEx(InnerForce.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",D3e+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set D8e[oqx]=D8e[(w)]
set D8e[(w)]=oqx
call f6r(oqx)
endfunction
function f8r takes integer oqx returns nothing
set fve[oqx]=fve[oqx]-1
call f7r(oqx)
endfunction
function f9r takes integer oqx returns nothing
if not foe[oqx]then
return
endif
if(fre[oqx]>0)then
return
endif
call f8r((oqx))
endfunction
function Fvr takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local integer p0x=fEe[oqx]
local integer CQx=fOe[oqx]
call ijx(ibx)
call ijx(p0x)
call dRx(CQx)
set foe[oqx]=true
call f9r(oqx)
endfunction
function Fer takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real O1o=(Cpx((cVe),u6v+(rwx)))
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local integer oqx=f1r()
local integer ibx=inx()
local integer p0x=inx()
local integer CQx=Cmx(CMx,cVe)
set foe[oqx]=false
set fre[oqx]=0
set fie[oqx]=O1o
set fae[oqx]=CMx
set fne[oqx]=D1e[rwx]
set fVe[oqx]=D0e[rwx]
set fEe[oqx]=p0x
set fXe[oqx]=rwx
set fOe[oqx]=CQx
set ge[(ibx)]=(oqx)
set ge[(p0x)]=(oqx)
call icx(p0x,fRe,true,function f5r)
call icx(ibx,(fDe-1)*fRe,false,function Fvr)
call f4r(oqx)
return true
endfunction
function Fxr takes nothing returns boolean
local integer rdx=(bv)
call Q8o((Vv[(rdx)]),Dze,(Mv[(rdx)]))
return true
endfunction
function For takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),Dze)
return true
endfunction
function Frr takes nothing returns nothing
call meo(cVe,XBx("FolderInnerForce_StructCrit_Init: call InnerForce.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function FolderInnerForce_StructCrit.Event_Learn))",Pv,pI,function Fxr))
call meo(cVe,XBx("FolderInnerForce_StructCrit_Init: call InnerForce.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInnerForce_StructCrit.Event_Learn))",pv,pI,function Fxr))
call meo(cVe,XBx("FolderInnerForce_StructCrit_Init: call InnerForce.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInnerForce_StructCrit.Event_Unlearn))",Av,pI,function For))
endfunction
function Fir takes nothing returns boolean
set D4e=O2x()
set D5e=XLx(function fZr)
set D6e=XLx(function f_r)
call meo(cVe,XBx("InnerForce_Init: call InnerForce.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function InnerForce.Event_SpellEffect))",ah,pI,function Fer))
call Frr()
return true
endfunction
function Far takes nothing returns boolean
call cmr(function Fir,"InnerForce_Init")
return true
endfunction
function Fnr takes nothing returns boolean
call LZx('AMon',false)
set cne=Lzo('AMon')
set G6[(cne)]=(B6)
set j6[(cne)]=(6)
set sH[(cne)]=("Monolith")
set Ih[(cne)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0089)))),(((Oj))))))
set x6v[(cne)]=(2)
set xzv[(cne)]=("spell")
call LZo((cne),u6v+(1),((350)*1.))
call LZo((cne),fH+(1),((20)*1.))
call LZo((cne),QH+(1),((40)*1.))
call LZo((cne),Lvv+(1),((99999)*1.))
call LZo((cne),u6v+(2),((350)*1.))
call LZo((cne),fH+(2),((20)*1.))
call LZo((cne),QH+(2),((50)*1.))
call LZo((cne),Lvv+(2),((99999)*1.))
call LZo((cne),u6v+(3),((350)*1.))
call LZo((cne),fH+(3),((20)*1.))
call LZo((cne),QH+(3),((60)*1.))
call LZo((cne),Lvv+(3),((99999)*1.))
call LZo((cne),u6v+(4),((350)*1.))
call LZo((cne),fH+(4),((20)*1.))
call LZo((cne),QH+(4),((70)*1.))
call LZo((cne),Lvv+(4),((99999)*1.))
call LZo((cne),u6v+(5),((350)*1.))
call LZo((cne),fH+(5),((20)*1.))
call LZo((cne),QH+(5),((80)*1.))
call LZo((cne),Lvv+(5),((99999)*1.))
call LZo((cne),u6v+(6),((350)*1.))
call LZo((cne),fH+(6),((20)*1.))
call LZo((cne),QH+(6),((90)*1.))
call LZo((cne),Lvv+(6),((99999)*1.))
set Mnv[(cne)]=("ReplaceableTextures\\CommandButtons\\BTNResStone.blp")
call ccr(cne,'FMo0',6,'VMo0','LPMo','LRMo')
set ffe[1]=$F
set ffe[2]=$F
set ffe[3]=$F
set ffe[4]=$F
set ffe[5]=$F
set ffe[6]=$F
set fFe[1]=650
set fFe[2]=650
set fFe[3]=650
set fFe[4]=650
set fFe[5]=650
set fFe[6]=650
set fge[1]=$F
set fge[2]=25
set fge[3]=35
set fge[4]=45
set fge[5]=55
set fge[6]=65
return true
endfunction
function FVr takes nothing returns boolean
set fGe=hGo('uMon')
call hho(((fGe)),Apv,(ICv))
set Tj[(fGe)]=((1)*1.)
call hHo(fGe,$FF,$FF,$FF,$FF)
set Nav[(fGe)]=(('d')*1.)
set Ntv[(fGe)]=(('d')*1.)
set I3v[(fGe)]=((0)*1.)
set Axv[(fGe)]=(3)
set NJv[(fGe)]=(($C8)*1.)
set Njv[(fGe)]=(($C8)*1.)
set Nhv[(fGe)]=((0)*1.)
set NKv[(fGe)]=((0)*1.)
set Nkv[(fGe)]=((0)*1.)
set NHv[(fGe)]=((0)*1.)
set NIv[(fGe)]=((800)*1.)
set NOv[(fGe)]=((800)*1.)
set Ndv[(fGe)]=((0)*1.)
set AQv[(fGe)]=((0)*1.)
set Asv[(fGe)]=((0)*1.)
set Auv[(fGe)]=(0)
set AWv[(fGe)]=(0)
set Aqv[(fGe)]=((64)*1.)
call hLo((fGe),(fhe),1)
return true
endfunction
function FEr takes nothing returns boolean
call VRx(qa,(function Fnr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Monolith.page\\Monolith.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Sa,(function FVr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Monolith.page\\Monolith.struct\\obj_MonolithType_wc3unit.j"))
return true
endfunction
function FXr takes nothing returns boolean
set fHe=Vnx(fje)
return true
endfunction
function FOr takes code c,string rqx returns nothing
set mn=mn+1
set Mn[mn]=CreateTrigger()
set pn[mn]=(GetHandleId(Condition((c))))
set Pn[mn]=rqx
call TriggerAddCondition(Mn[mn],Condition(c))
endfunction
function FRr takes nothing returns boolean
local integer Ixx=jFx()
if(Ixx==Ib)then
return false
endif
if(I5x((OPe),Rb,(Ixx)))then
return false
endif
if I6x(Ixx,sc)then
return false
endif
return true
return true
endfunction
function FIr takes integer oqx returns integer
set fMe[oqx]=true
set fpe[oqx]=false
call rax(fHe)
return oqx
endfunction
function FAr takes nothing returns integer
local integer oqx
if(fKe==8190)then
call oYx("Monolith_Allocation_allocCustom","call DebugEx(Monolith.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",fje+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(fle[(w)]==w)then
set fLe=fLe+1
set oqx=fLe
else
set oqx=fle[(w)]
set fle[(w)]=fle[fle[(w)]]
endif
set fle[oqx]=Z
set fme[oqx]=1
call FIr(oqx)
return oqx
endfunction
function FNr takes integer oqx returns nothing
set fMe[oqx]=false
call rgx(fHe)
endfunction
function Fbr takes integer oqx returns nothing
if(fme[oqx]>0)then
return
endif
if(fle[oqx]!=Z)then
call oYx("Monolith_Allocation_deallocCustom_confirm","call DebugEx(Monolith.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",fje+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set fle[oqx]=fle[(w)]
set fle[(w)]=oqx
call FNr(oqx)
endfunction
function FBr takes integer oqx returns nothing
set fme[oqx]=fme[oqx]-1
call Fbr(oqx)
endfunction
function Fcr takes integer FCr,integer CMx,integer rwx returns nothing
call SetUnitAnimation(C[((FCr))],("work"))
call DSx(FCr,fwe,rwx,CMx)
endfunction
function Fdr takes integer CMx,integer rwx,real x,real y returns nothing
local integer FCr=Uzo(fGe,(ze[(CMx)]),x,y,Kf,ffe[rwx])
call Fcr(FCr,CMx,rwx)
endfunction
function FDr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=fPe[oqx]
local integer rwx=fse[oqx]
local integer Q6o=fue[oqx]
local real x=(mFv[(MFo)])
local real y=(mgv[(MFo)])
call FBr((oqx))
call Mdo(MFo)
call ijx(Q6o)
call Fdr(CMx,rwx,x,y)
return true
endfunction
function Ffr takes integer oqx,real o2x returns nothing
set muv[oqx]=o2x
set mbv[oqx]=true
call Myo(oqx)
endfunction
function FFr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=fPe[oqx]
local integer MFo=fQe[oqx]
local integer Q7o=fSe[oqx]
local integer C0o=(ze[(CMx)])
local real x=(mFv[(MFo)])
local real y=(mgv[(MFo)])
local integer Ixx
local real NIo
set Ib=CMx
set Hf=C0o
set OPe=Q7o
call Vjr(fJe,(mFv[(MFo)]),(mgv[(MFo)]),(mGv[(MFo)]),(mNv[(MFo)]),fke)
set Ixx=Nao(fJe)
if(Ixx!=w)then
set NIo=fqe[oqx]
loop
call dpx(Q7o,Ixx)
call RUx((Abx((Ixx),(fye),(fYe),(Bi))))
call OSr(Ixx,(mJv[(MFo)]),(mxv[(MFo)]),(Atan2((((GetUnitY(C[((Ixx))]))-y)*1.),(((GetUnitX(C[((Ixx))]))-x)*1.))),1.)
if not(IsUnitAlly(C[(Ixx)],vx[(C0o)]))then
call nJo((CMx),(Ixx),((NIo)*1.),(false),(false))
endif
set Ixx=Nao(fJe)
exitwhen(Ixx==w)
endloop
endif
endfunction
function Fgr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real rmr=fFe[rwx]
local real N8x=UCx(CMx,dix-wpo,dax-wPo)
local integer oqx
local integer MFo
local integer Q6o
local real FGr
local real NJx
local real n_r
set dix=wpo+rmr*(Cos(((((N8x)*1.))*1.)))
set dax=wPo+rmr*(Sin(((((N8x)*1.))*1.)))
set oqx=FAr()
set MFo=Mvo()
set Q6o=inx()
set fPe[oqx]=CMx
set fqe[oqx]=fge[rwx]
set fQe[oqx]=MFo
set fse[oqx]=rwx
set fSe[oqx]=JIx("Monolith_Event_SpellEffect: set this.targetGroup = UnitList.Create()")
set fte[oqx]=dix
set fTe[oqx]=dax
set fue[oqx]=Q6o
set ge[(Q6o)]=(oqx)
set FGr=1.
set NJx=800.
set n_r=-NJx*NJx*1./(2*(rmr+FGr))
call m1o(MFo,n_r)
set mNv[(MFo)]=((fUe)*1.)
set mCv[(MFo)]=XHx((function FDr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,NJx)
call M9o(MFo,CMx)
call o6r(MFo,dix,dax,XYx(dix,dax)+60.)
call Ffr(MFo,Kf)
call Mro(MFo,'qMon',.75)
call icx(Q6o,fWe,true,function FFr)
return true
endfunction
function Fhr takes nothing returns boolean
set fJe=O2x()
set fke=XLx(function FRr)
call meo(cne,XBx("Monolith_Init: call Monolith.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Monolith.Event_SpellEffect))",ah,pI,function Fgr))
return true
endfunction
function FHr takes nothing returns boolean
call FOr(function Fhr,"Monolith_Init")
return true
endfunction
function Fjr takes nothing returns boolean
set fze=WTx('BMoM',"Monolith - Mana Regen",'bMoM')
set avv[(fze)]=(true)
set aev[(fze)]=("ReplaceableTextures\\CommandButtons\\BTNResStone.blp")
call lux(fze,"Abilities\\Spells\\Other\\GeneralAuraTarget\\GeneralAuraTarget.mdl","origin",ri)
set SU=lYx()
call l_x(SU,DHv,5)
call l0x(((fze)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,DHv,6.5)
call l0x(((fze)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,DHv,8)
call l0x(((fze)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,DHv,9.5)
call l0x(((fze)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,DHv,$B)
call l0x(((fze)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,DHv,12.5)
call l0x(((fze)),vc+(6),(SU))
return true
endfunction
function FJr takes nothing returns boolean
set fZe[1]=5
set fZe[2]=6.5
set fZe[3]=8
set fZe[4]=9.5
set fZe[5]=$B
set fZe[6]=12.5
return true
endfunction
function Fkr takes nothing returns boolean
call VRx(Ma,(function Fjr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Monolith.page\\Monolith.struct\\SacredAura.page\\SacredAura.struct\\Target\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function FJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Monolith.page\\Monolith.struct\\SacredAura.page\\SacredAura.struct\\Target\\obj_this_wc3obj.j"))
return true
endfunction
function FKr takes nothing returns boolean
set f_e=Vnx(f0e)
return true
endfunction
function Flr takes nothing returns boolean
call LZx('ASaA',false)
set f1e=Lzo('ASaA')
set G6[(f1e)]=(D6)
set j6[(f1e)]=(1)
set sH[(f1e)]=("Sacred Aura")
set xzv[(f1e)]=("spell")
call LZo((f1e),u6v+(1),((350)*1.))
call LZo((f1e),Lvv+(1),((750)*1.))
set Mnv[(f1e)]=("ReplaceableTextures\\PassiveButtons\\PASBTNBrilliance.blp")
return true
endfunction
function FLr takes nothing returns boolean
set fwe=WTx('BMoA',"Monolith Aura",'bMoA')
set avv[(fwe)]=(true)
set aev[(fwe)]=("ReplaceableTextures\\CommandButtons\\BTNResStone.blp")
call lux(fwe,"Monolith_page\\Monolith_struct\\SacredAura_page\\SacredAura_struct\\Aura.mdx","origin",ri)
call lux(fwe,"Monolith_page\\Monolith_struct\\SacredAura_page\\SacredAura_struct\\AuraHead.mdx","overhead",Bi)
return true
endfunction
function Fmr takes nothing returns boolean
call VRx(qa,(function Flr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Monolith.page\\Monolith.struct\\SacredAura.page\\SacredAura.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function FLr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Monolith.page\\Monolith.struct\\SacredAura.page\\SacredAura.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function FMr takes nothing returns boolean
set f2e=Vnx(f3e)
return true
endfunction
function Fpr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if not(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function FPr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(mc[(rdx)])
local integer FCr=(Vv[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer oqx=FCr
local integer XSr=Xpr(FCr)
set f5e[oqx]=XSr
set f6e[oqx]=CMx
set f7e[oqx]=rwx
set Eee[(XSr)]=(oqx)
set vme[(XSr)]=(((Cpx((cne),u6v+(rwx))))*1.)
set vMe[(XSr)]=(f4e)
call XPr(XSr,f8e)
call XPr(XSr,f9e)
call XQr(XSr)
return true
endfunction
function Fqr takes nothing returns boolean
local integer rdx=(bv)
local integer FCr=(Vv[(rdx)])
local integer oqx=FCr
local integer XSr=f5e[oqx]
call X2r(XSr)
return true
endfunction
function FQr takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer rkx=(Eee[(XSr)])
call UJx(Ixx,fze)
return true
endfunction
function Fsr takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer CMx=(vhe[(XSr)])
local integer rkx=(Eee[(XSr)])
local integer rwx=f7e[rkx]
call DSx((Ixx),(fze),(rwx),w)
return true
endfunction
function FSr takes nothing returns nothing
set f8e=XBx("FolderSacredAura_StructTarget_Init: set FolderSacredAura_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderSacredAura_StructTarget.Event_Ending)",vQe,pI,function FQr)
set f9e=XBx("FolderSacredAura_StructTarget_Init: set FolderSacredAura_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderSacredAura_StructTarget.Event_Start)",vse,pI,function Fsr)
endfunction
function Ftr takes nothing returns boolean
set f4e=XLx(function Fpr)
call l9x(fwe,XBx("SacredAura_Init: call SacredAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SacredAura.Event_BuffGain))",Bd,pI,function FPr))
call l9x(fwe,XBx("SacredAura_Init: call SacredAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SacredAura.Event_BuffLose))",Jc,pI,function Fqr))
call FSr()
return true
endfunction
function FTr takes nothing returns boolean
call FOr(function Ftr,"SacredAura_Init")
return true
endfunction
function Fur takes nothing returns boolean
set Fve=WTx('BSev',"Severance",'bSev')
set qU[(Fve)]=(true)
set aev[(Fve)]=("ReplaceableTextures\\CommandButtons\\BTNAcidBomb.blp")
call lux(Fve,"Abilities\\Spells\\Undead\\UnholyFrenzy\\UnholyFrenzyTarget.mdl","overhead",ri)
set SU=lYx()
call l_x(SU,dnv,-3)
call l_x(SU,dKv,-30)
call l0x(((Fve)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,dnv,-6)
call l_x(SU,dKv,-40)
call l0x(((Fve)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,dnv,-9)
call l_x(SU,dKv,-50)
call l0x(((Fve)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,dnv,-$C)
call l_x(SU,dKv,-60)
call l0x(((Fve)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,dnv,-$F)
call l_x(SU,dKv,-70)
call l0x(((Fve)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,dnv,-18)
call l_x(SU,dKv,-80)
call l0x(((Fve)),vc+(6),(SU))
return true
endfunction
function FUr takes nothing returns boolean
set Fee[1]=-3
set Fee[2]=-6
set Fee[3]=-9
set Fee[4]=-$C
set Fee[5]=-$F
set Fee[6]=-18
set Fxe[1]=-30
set Fxe[2]=-40
set Fxe[3]=-50
set Fxe[4]=-60
set Fxe[5]=-70
set Fxe[6]=-80
set Foe[1]=$A
set Foe[2]=$A
set Foe[3]=$A
set Foe[4]=$A
set Foe[5]=$A
set Foe[6]=$A
return true
endfunction
function Fwr takes nothing returns boolean
call VRx(Ma,(function Fur),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Severance.page\\Severance.struct\\Buff\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function FUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Severance.page\\Severance.struct\\Buff\\obj_this_wc3obj.j"))
return true
endfunction
function FWr takes nothing returns boolean
set Fre=Vnx(Fie)
return true
endfunction
function Fyr takes nothing returns boolean
call LZx('ASev',false)
set GKv=Lzo('ASev')
set G6[(GKv)]=(B6)
set j6[(GKv)]=(6)
set sH[(GKv)]=("Severance")
set Ih[(GKv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D026C)))),(((Oj))))))
set x6v[(GKv)]=(4)
set xzv[(GKv)]=("spell")
call LZo((GKv),u6v+(1),((500)*1.))
call LZo((GKv),fH+(1),(($C)*1.))
call LZo((GKv),QH+(1),((40)*1.))
call LZo((GKv),Lvv+(1),((800)*1.))
call LZo((GKv),u6v+(2),((500)*1.))
call LZo((GKv),fH+(2),(($C)*1.))
call LZo((GKv),QH+(2),((50)*1.))
call LZo((GKv),Lvv+(2),((800)*1.))
call LZo((GKv),u6v+(3),((500)*1.))
call LZo((GKv),fH+(3),(($C)*1.))
call LZo((GKv),QH+(3),((65)*1.))
call LZo((GKv),Lvv+(3),((800)*1.))
call LZo((GKv),u6v+(4),((500)*1.))
call LZo((GKv),fH+(4),(($C)*1.))
call LZo((GKv),QH+(4),((85)*1.))
call LZo((GKv),Lvv+(4),((800)*1.))
call LZo((GKv),u6v+(5),((500)*1.))
call LZo((GKv),fH+(5),(($C)*1.))
call LZo((GKv),QH+(5),(('n')*1.))
call LZo((GKv),Lvv+(5),((800)*1.))
call LZo((GKv),u6v+(6),((500)*1.))
call LZo((GKv),fH+(6),(($C)*1.))
call LZo((GKv),QH+(6),(($8C)*1.))
call LZo((GKv),Lvv+(6),((800)*1.))
set Mnv[(GKv)]=("ReplaceableTextures\\CommandButtons\\BTNAcidBomb.blp")
call ccr(GKv,'FSV0',6,'VSV0','LPSV','LRSV')
set Fae[1]=5
set Fae[2]=6
set Fae[3]=7
set Fae[4]=8
set Fae[5]=9
set Fae[6]=$A
set Fne[1]=20
set Fne[2]=30
set Fne[3]=40
set Fne[4]=50
set Fne[5]=60
set Fne[6]=70
return true
endfunction
function FYr takes nothing returns boolean
call VRx(qa,(function Fyr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Severance.page\\Severance.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Fzr takes nothing returns boolean
set FVe=Vnx(FEe)
return true
endfunction
function FZr takes integer Ixx returns boolean
return( not(I6x(Ixx,sc)))and( not(I6x(Ixx,IBv)))and( not(IsUnitAlly(C[(Ixx)],vx[(Hf)])))and( not(nIo(Ixx)))
endfunction
function F_r takes nothing returns boolean
local integer Ixx=jFx()
if(I5x((OPe),Rb,(Ixx)))then
return false
endif
if not FZr(Ixx)then
return false
endif
return true
return true
endfunction
function F0r takes integer oqx returns integer
set Fbe[oqx]=true
set FBe[oqx]=false
call rax(FVe)
return oqx
endfunction
function F1r takes nothing returns integer
local integer oqx
if(FRe==8190)then
call oYx("Severance_Allocation_allocCustom","call DebugEx(Severance.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",FEe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(FIe[(w)]==w)then
set FAe=FAe+1
set oqx=FAe
else
set oqx=FIe[(w)]
set FIe[(w)]=FIe[FIe[(w)]]
endif
set FIe[oqx]=Z
set FNe[oqx]=1
call F0r(oqx)
return oqx
endfunction
function F2r takes integer rwx,integer Ixx returns nothing
call NIx((Ixx),(Fve),(rwx),w,((Foe[rwx])*1.))
endfunction
function F3r takes integer oqx returns nothing
set Fbe[oqx]=false
call rgx(FVe)
endfunction
function F4r takes integer oqx returns nothing
if(FNe[oqx]>0)then
return
endif
if(FIe[oqx]!=Z)then
call oYx("Severance_Allocation_deallocCustom_confirm","call DebugEx(Severance.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",FEe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set FIe[oqx]=FIe[(w)]
set FIe[(w)]=oqx
call F3r(oqx)
endfunction
function F5r takes integer oqx returns nothing
set FNe[oqx]=FNe[oqx]-1
call F4r(oqx)
endfunction
function F6r takes integer oqx returns nothing
call F5r((oqx))
call XYr(FFe[oqx])
endfunction
function F7r takes integer oqx,real jlx,real jLx,real cho,integer Ixx returns nothing
set Rd=oqx
set m8v=jlx
set m9v=jLx
set Mvv=cho
set Id=Ixx
call TriggerEvaluate(FHe)
endfunction
function F8r takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=FCe[oqx]
local integer Ecr=Ffe[oqx]
local integer ECr=Fge[oqx]
local integer Ixx=FGe[oqx]
local integer Q7o=FFe[oqx]
local real dix=(mFv[(MFo)])
local real dax=(mgv[(MFo)])
local real Mpx=(mGv[(MFo)])
local real NIo
call Mdo(MFo)
if(Ixx!=w)then
set Hf=(ze[(CMx)])
if FZr(Ixx)then
set NIo=Fde[oqx]
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
set Fde[oqx]=NIo*(1.-Fhe)
call F2r(FDe[oqx],Ixx)
endif
endif
if(ECr==Ecr)then
call F6r(oqx)
else
set OPe=Q7o
set Hf=(ze[(CMx)])
call Nio(FXe,dix,dax,Fce[oqx],FOe)
if(Ixx!=w)then
call GroupRemoveUnit(Kb[(FXe)],C[(Ixx)])
call IEo(Q7o,Ixx)
endif
set Ixx=(mjo((FXe),((dix)*1.),((dax)*1.)))
if(Ixx==w)then
call F6r(oqx)
else
set Fge[oqx]=ECr+1
call F7r(oqx,dix,dax,Mpx,Ixx)
endif
endif
return true
endfunction
function F9r takes integer oqx,real jlx,real jLx,real cho,integer Ixx returns nothing
local integer MFo=Mvo()
set FGe[oqx]=Ixx
call dpx(FFe[oqx],Ixx)
set mNv[(MFo)]=((10.)*1.)
call Mro(MFo,'qSev',2.)
set mCv[(MFo)]=XHx((function F8r))
set mWv[(MFo)]=(oqx)
call m8o(MFo,900.)
call Mto(MFo,jlx,jLx,cho)
call M3o((MFo),(Ixx),.0,.0,.0,(null))
endfunction
function gvr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local integer oqx=F1r()
set Fce[oqx]=(Cpx((GKv),u6v+(rwx)))
set FCe[oqx]=CMx
set Fde[oqx]=Fne[rwx]
set FDe[oqx]=rwx
set Ffe[oqx]=Fae[rwx]
set FFe[oqx]=JIx("Severance_Event_SpellEffect: set this.targetGroup = UnitList.Create()")
set Fge[oqx]=1
call F9r(oqx,wpo,wPo,Olx(CMx,wpo,wPo)+OLx(CMx,true),Ixx)
return true
endfunction
function ger takes nothing returns boolean
set FXe=O2x()
set FOe=XLx(function F_r)
call meo(GKv,XBx("Severance_Init: call Severance.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Severance.Event_SpellEffect))",ah,pI,function gvr))
call W_x(EIv,Fve)
return true
endfunction
function gxr takes nothing returns boolean
call cmr(function ger,"Severance_Init")
return true
endfunction
function gor takes nothing returns boolean
set Fje[1]=700
set Fje[2]=700
set Fje[3]=700
set Fje[4]=700
set Fje[5]=700
set Fje[6]=700
set FJe[1]=7
set FJe[2]=$D
set FJe[3]=21
set FJe[4]=31
set FJe[5]=43
set FJe[6]=57
set Fke[1]=50
set Fke[2]=50
set Fke[3]=50
set Fke[4]=50
set Fke[5]=50
set Fke[6]=50
set FKe[1]=400
set FKe[2]=500
set FKe[3]=600
set FKe[4]=700
set FKe[5]=800
set FKe[6]=900
return true
endfunction
function grr takes nothing returns boolean
call VRx(ea,(function gor),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\SnowySphere.page\\SnowySphere.struct\\Particle\\obj_this_wc3obj.j"))
return true
endfunction
function gir takes nothing returns boolean
set Fle=Vnx(FLe)
return true
endfunction
function gar takes nothing returns boolean
call LZx('ASnS',false)
set Fme=Lzo('ASnS')
set G6[(Fme)]=(B6)
set j6[(Fme)]=(6)
set sH[(Fme)]=("Snowy Sphere")
set Ih[(Fme)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D02B6)))),(((Oj))))))
set x6v[(Fme)]=(2)
set xzv[(Fme)]=("spell")
call LZo((Fme),u6v+(1),((75)*1.))
call LZo((Fme),fH+(1),(($F)*1.))
call LZo((Fme),Lvv+(1),((500)*1.))
call LZo((Fme),u6v+(2),((75)*1.))
call LZo((Fme),fH+(2),(($F)*1.))
call LZo((Fme),Lvv+(2),((500)*1.))
call LZo((Fme),u6v+(3),((75)*1.))
call LZo((Fme),fH+(3),(($F)*1.))
call LZo((Fme),Lvv+(3),((500)*1.))
call LZo((Fme),u6v+(4),((75)*1.))
call LZo((Fme),fH+(4),(($F)*1.))
call LZo((Fme),Lvv+(4),((500)*1.))
call LZo((Fme),u6v+(5),((75)*1.))
call LZo((Fme),fH+(5),(($F)*1.))
call LZo((Fme),Lvv+(5),((500)*1.))
call LZo((Fme),u6v+(6),((75)*1.))
call LZo((Fme),fH+(6),(($F)*1.))
call LZo((Fme),Lvv+(6),((500)*1.))
set Mnv[(Fme)]=("ReplaceableTextures\\CommandButtons\\BTNTornado.blp")
set FMe[1]=$E
set FMe[2]=$E
set FMe[3]=$E
set FMe[4]=$E
set FMe[5]=$E
set FMe[6]=$E
set Fpe[1]=800
set Fpe[2]=800
set Fpe[3]=800
set Fpe[4]=800
set Fpe[5]=800
set Fpe[6]=800
set FPe[1]=800
set FPe[2]=800
set FPe[3]=800
set FPe[4]=800
set FPe[5]=800
set FPe[6]=800
set Fqe[1]=20
set Fqe[2]=30
set Fqe[3]=40
set Fqe[4]=50
set Fqe[5]=60
set Fqe[6]=70
return true
endfunction
function gnr takes nothing returns boolean
call VRx(qa,(function gar),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\SnowySphere.page\\SnowySphere.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function gVr takes nothing returns boolean
set FQe=Vnx(Fse)
return true
endfunction
function gEr takes integer oqx returns integer
set FUe[oqx]=true
set Fwe[oqx]=false
call rax(FQe)
return oqx
endfunction
function gXr takes nothing returns integer
local integer oqx
if(FSe==8190)then
call oYx("SnowySphere_Allocation_allocCustom","call DebugEx(SnowySphere.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Fse+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Fte[(w)]==w)then
set FTe=FTe+1
set oqx=FTe
else
set oqx=Fte[(w)]
set Fte[(w)]=Fte[Fte[(w)]]
endif
set Fte[oqx]=Z
set Fue[oqx]=1
call gEr(oqx)
return oqx
endfunction
function gOr takes integer oqx returns integer
set gie[oqx]=true
set gae[oqx]=false
call rax(Fle)
return oqx
endfunction
function gRr takes nothing returns integer
local integer oqx
if(gee==8190)then
call oYx("FolderSnowySphere_StructParticle_Allocation_allocCustom","call DebugEx(FolderSnowySphere_StructParticle.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",FLe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(gxe[(w)]==w)then
set goe=goe+1
set oqx=goe
else
set oqx=gxe[(w)]
set gxe[(w)]=gxe[gxe[(w)]]
endif
set gxe[oqx]=Z
set gre[oqx]=1
call gOr(oqx)
return oqx
endfunction
function gIr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=gVe[oqx]
local integer HOx=gXe[oqx]
local integer Q7o=gOe[oqx]
local real x=(oJ[(HOx)])+gIe[oqx]
local real y=(nJ[(HOx)])+gNe[oqx]
local integer Ixx
local real NIo
call Mko(HOx,x,y,(Vu[(HOx)]))
set OPe=Q7o
set Hf=(ze[(CMx)])
call Nio(gce,x,y,gne[oqx],gCe)
set Ixx=Nao(gce)
if(Ixx!=w)then
set NIo=gEe[oqx]
loop
call dpx(Q7o,Ixx)
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
set Ixx=Nao(gce)
exitwhen(Ixx==w)
endloop
endif
endfunction
function gAr takes integer oqx returns nothing
set gie[oqx]=false
call rgx(Fle)
endfunction
function gNr takes integer oqx returns nothing
if(gre[oqx]>0)then
return
endif
if(gxe[oqx]!=Z)then
call oYx("FolderSnowySphere_StructParticle_Allocation_deallocCustom_confirm","call DebugEx(FolderSnowySphere_StructParticle.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",FLe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set gxe[oqx]=gxe[(w)]
set gxe[(w)]=oqx
call gAr(oqx)
endfunction
function gbr takes integer oqx returns nothing
set gre[oqx]=gre[oqx]-1
call gNr(oqx)
endfunction
function gBr takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local integer HOx=gXe[oqx]
local integer Q7o=gOe[oqx]
local integer Q6o=gRe[oqx]
local integer CQx=gbe[oqx]
call gbr((oqx))
call MCx(HOx)
call ijx(ibx)
call XYr(Q7o)
call ijx(Q6o)
call UPx(CQx)
endfunction
function gcr takes real N8x,integer CMx,real NIo,integer rwx,integer CQx,real x,real y,real z returns nothing
local integer oqx=gRr()
local integer ibx=inx()
local integer HOx=mcx('qSnP',x,y,z,N8x)
local integer Q6o=inx()
set gne[oqx]=Fke[rwx]
set gVe[oqx]=CMx
set gEe[oqx]=NIo
set gXe[oqx]=HOx
set gOe[oqx]=JIx("FolderSnowySphere_StructParticle_Start: set this.targetGroup = UnitList.Create()")
set gRe[oqx]=Q6o
set gIe[oqx]=gAe[rwx]*(Cos(((((N8x)*1.))*1.)))
set gNe[oqx]=gAe[rwx]*(Sin(((((N8x)*1.))*1.)))
set gbe[oqx]=CQx
set ge[(ibx)]=(oqx)
set ge[(Q6o)]=(oqx)
call UNx(CQx)
call icx(Q6o,gBe,true,function gIr)
call icx(ibx,gde[rwx],false,function gBr)
endfunction
function gCr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local real N8x=F_e[oqx]+F0e[oqx]
local integer HOx=FYe[oqx]
set F_e[oqx]=N8x
call gcr(N8x,FWe[oqx],Fye[oqx],FZe[oqx],F6e[oqx],(oJ[(HOx)])+F2e[oqx],(nJ[(HOx)])+F4e[oqx],(Vu[(HOx)]))
endfunction
function gdr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer HOx=FYe[oqx]
call Mko(HOx,(oJ[(HOx)])+F7e[oqx],(nJ[(HOx)])+F9e[oqx],(Vu[(HOx)]))
endfunction
function gDr takes integer oqx returns nothing
set FUe[oqx]=false
call rgx(FQe)
endfunction
function gfr takes integer oqx returns nothing
if(Fue[oqx]>0)then
return
endif
if(Fte[oqx]!=Z)then
call oYx("SnowySphere_Allocation_deallocCustom_confirm","call DebugEx(SnowySphere.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Fse+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set Fte[oqx]=Fte[(w)]
set Fte[(w)]=oqx
call gDr(oqx)
endfunction
function gFr takes integer oqx returns nothing
set Fue[oqx]=Fue[oqx]-1
call gfr(oqx)
endfunction
function ggr takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local integer HOx=FYe[oqx]
local integer p0x=Fze[oqx]
local integer Q6o=F5e[oqx]
local integer CQx=F6e[oqx]
call gFr((oqx))
call Mfx(HOx)
call ijx(ibx)
call ijx(p0x)
call ijx(Q6o)
call dRx(CQx)
endfunction
function gGr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real Vlr=fwx(CMx)+OLx(CMx,true)
local real N8x=UCx(CMx,dix-wpo,dax-wPo)
local real I_o=(Cos(((((N8x)*1.))*1.)))
local real I0o=(Sin(((((N8x)*1.))*1.)))
local integer oqx=gXr()
local integer HOx=mcx('qSnS',wpo,wPo,Vlr,N8x)
local integer ibx=inx()
local integer p0x=inx()
local integer Q6o=inx()
local integer CQx=Cmx(CMx,Fme)
set FWe[oqx]=CMx
set Fye[oqx]=FJe[rwx]
set FYe[oqx]=HOx
set Fze[oqx]=p0x
set FZe[oqx]=rwx
set F_e[oqx]=N8x
set F0e[oqx]=F1e[rwx]
set F2e[oqx]=F3e*I_o
set F4e[oqx]=F3e*I0o
set F5e[oqx]=Q6o
set F6e[oqx]=CQx
set F7e[oqx]=F8e[rwx]*I_o
set F9e[oqx]=F8e[rwx]*I0o
set ge[(ibx)]=(oqx)
set ge[(p0x)]=(oqx)
set ge[(Q6o)]=(oqx)
call icx(p0x,gve[rwx],true,function gCr)
call icx(Q6o,gDe,true,function gdr)
call icx(ibx,gfe[rwx],false,function ggr)
return true
endfunction
function ghr takes nothing returns boolean
local integer Ixx=jFx()
if(I5x((OPe),Rb,(Ixx)))then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function gHr takes nothing returns nothing
local integer olx
set gce=O2x()
set gCe=XLx(function ghr)
set olx=(j6[(Fme)])
loop
set gde[olx]=FKe[olx]*1./ Fje[olx]
set gAe[olx]=Fje[olx]*gBe
set olx=olx-1
exitwhen(olx<1)
endloop
endfunction
function gjr takes nothing returns boolean
local integer olx
call meo(Fme,XBx("SnowySphere_Init: call SnowySphere.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SnowySphere.Event_SpellEffect))",ah,pI,function gGr))
set olx=(j6[(Fme)])
loop
set gfe[olx]=Fpe[olx]*1./ FPe[olx]
set F8e[olx]=FPe[olx]*gDe
set gve[olx]=gfe[olx]*1./ Fqe[olx]
set F1e[olx]=FMe[olx]*gve[olx]*1./ gfe[olx]
set olx=olx-1
exitwhen(olx<1)
endloop
call gHr()
return true
endfunction
function gJr takes nothing returns boolean
call cmr(function gjr,"SnowySphere_Init")
return true
endfunction
function gkr takes nothing returns boolean
call LZx('AThS',false)
set cEe=Lzo('AThS')
set G6[(cEe)]=(B6)
set j6[(cEe)]=(6)
set sH[(cEe)]=("Thunderstrike")
set Ih[(cEe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0080)))),(((Oj))))))
set x6v[(cEe)]=(2)
set xzv[(cEe)]=("spell")
call LZo((cEe),u6v+(1),((350)*1.))
call LZo((cEe),fH+(1),((9)*1.))
call LZo((cEe),QH+(1),((90)*1.))
call LZo((cEe),Lvv+(1),(($3E8)*1.))
call LZo((cEe),u6v+(2),((400)*1.))
call LZo((cEe),fH+(2),((9)*1.))
call LZo((cEe),QH+(2),(('i')*1.))
call LZo((cEe),Lvv+(2),(($3E8)*1.))
call LZo((cEe),u6v+(3),((450)*1.))
call LZo((cEe),fH+(3),((9)*1.))
call LZo((cEe),QH+(3),(('x')*1.))
call LZo((cEe),Lvv+(3),(($3E8)*1.))
call LZo((cEe),u6v+(4),((500)*1.))
call LZo((cEe),fH+(4),((9)*1.))
call LZo((cEe),QH+(4),(($87)*1.))
call LZo((cEe),Lvv+(4),(($3E8)*1.))
call LZo((cEe),u6v+(5),((550)*1.))
call LZo((cEe),fH+(5),((9)*1.))
call LZo((cEe),QH+(5),(($96)*1.))
call LZo((cEe),Lvv+(5),(($3E8)*1.))
call LZo((cEe),u6v+(6),((600)*1.))
call LZo((cEe),fH+(6),((9)*1.))
call LZo((cEe),QH+(6),(($A5)*1.))
call LZo((cEe),Lvv+(6),(($3E8)*1.))
set Mnv[(cEe)]=("ReplaceableTextures\\CommandButtons\\BTNMonsoon.blp")
call ccr(cEe,'FTh0',6,'VTh0','LPTh','LRTh')
set gFe[1]=2
set gFe[2]=2.25
set gFe[3]=2.5
set gFe[4]=2.75
set gFe[5]=3
set gFe[6]=3.25
set gge[1]=1.5
set gge[2]=1.75
set gge[3]=2
set gge[4]=2.25
set gge[5]=2.5
set gge[6]=2.75
set gGe[1]=50
set gGe[2]=75
set gGe[3]='d'
set gGe[4]='}'
set gGe[5]=$96
set gGe[6]=$AF
return true
endfunction
function gKr takes nothing returns boolean
call VRx(qa,(function gkr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Thunderstrike.page\\Thunderstrike.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function glr takes nothing returns boolean
set ghe=Vnx(gHe)
return true
endfunction
function gLr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function gmr takes integer oqx returns integer
set gme[oqx]=true
set gMe[oqx]=false
call rax(ghe)
return oqx
endfunction
function gMr takes nothing returns integer
local integer oqx
if(gke==8190)then
call oYx("Thunderstrike_Allocation_allocCustom","call DebugEx(Thunderstrike.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",gHe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(gKe[(w)]==w)then
set gle=gle+1
set oqx=gle
else
set oqx=gKe[(w)]
set gKe[(w)]=gKe[gKe[(w)]]
endif
set gKe[oqx]=Z
set gLe[oqx]=1
call gmr(oqx)
return oqx
endfunction
function gpr takes integer oqx,real I1o,real ilx returns nothing
if(ilx>0)then
call SetUnitFlyHeight(zj[(oqx)],I1o,(I1o-(GetUnitFlyHeight(zj[((oqx))])))*1./ ilx)
else
call SetUnitFlyHeight(zj[(oqx)],I1o,.0)
endif
endfunction
function gPr takes integer oqx returns nothing
set gme[oqx]=false
call rgx(ghe)
endfunction
function gqr takes integer oqx returns nothing
if(gLe[oqx]>0)then
return
endif
if(gKe[oqx]!=Z)then
call oYx("Thunderstrike_Allocation_deallocCustom_confirm","call DebugEx(Thunderstrike.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",gHe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set gKe[oqx]=gKe[(w)]
set gKe[(w)]=oqx
call gPr(oqx)
endfunction
function gQr takes integer oqx returns nothing
set gLe[oqx]=gLe[oqx]-1
call gqr(oqx)
endfunction
function gsr takes nothing returns nothing
local integer OHx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(OHx)])
local real dix=gte[oqx]
local real dax=gTe[oqx]
local integer CQx=gUe[oqx]
local integer rwx=(XH[(CQx)])
local integer gSr=mcx('qTSN',dix,dax,XYx(dix,dax),.0)
call gQr((oqx))
call ijx(OHx)
call MCx(gSe[oqx])
call dRx(CQx)
call mbx(gSr,(Cpx((cEe),u6v+(rwx)))*1./(100.))
call fDo(gSr,2.)
endfunction
function gtr takes nothing returns nothing
local integer OHx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(OHx)])
local real O1o=gpe[oqx]
local integer CMx=gPe[oqx]
local integer gTr=gqe[oqx]
local real NIo=gQe[oqx]
local real dix=gte[oqx]
local real dax=gTe[oqx]
local integer CQx=gUe[oqx]
local integer rwx=(XH[(CQx)])
local integer Ixx
local real gur
local real gUr
local real gwr
call MCx(gTr)
call qYo((mHo(((dix)*1.),((dax)*1.),(gYe),(ri))),.5)
set Hf=(ze[(CMx)])
call Nio(gje,dix,dax,O1o,gJe)
set Ixx=Nao(gje)
if(Ixx!=w)then
set gur=gge[rwx]
set gUr=gFe[rwx]
loop
if I6x(Ixx,yd)then
set gwr=gur
else
set gwr=gUr
endif
call NIx((Ixx),(Xsv),(rwx),w,((gwr)*1.))
call nJo((CMx),(Ixx),((NIo)*1.),(true),(true))
set Ixx=Nao(gje)
exitwhen(Ixx==w)
endloop
endif
call icx(OHx,.15,false,function gsr)
endfunction
function gWr takes integer CMx,integer rwx,real dix,real dax,integer CQx returns nothing
local real O1o=(Cpx((cEe),u6v+(rwx)))
local real Mpx=XYx(dix,dax)
local integer oqx=gMr()
local integer gTr=mcx('qThS',dix,dax,Mpx,Kf)
local integer OHx=inx()
local integer gyr=mcx('qTSA',dix,dax,Mpx,Kf)
set gpe[oqx]=O1o
set gPe[oqx]=CMx
set gqe[oqx]=gTr
set gQe[oqx]=gGe[rwx]
set gse[oqx]=OHx
set gSe[oqx]=gyr
set gte[oqx]=dix
set gTe[oqx]=dax
set gue[oqx]=Mpx
set gUe[oqx]=CQx
set ge[(OHx)]=(oqx)
call k2o(gyr,O1o*1./(256.*1./ 5))
call mBx(gyr,$FF,$FF,$FF,$7F)
call gpr(gTr,gwe,gWe-gye)
call oYr(gTr,O1o*1./ 128.-1.,gWe)
call icx(OHx,gWe,false,function gtr)
endfunction
function gYr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
call gWr(CMx,(Mv[(rdx)]),(UH[(rdx)]),(wH[(rdx)]),Cmx(CMx,cEe))
return true
endfunction
function gzr takes nothing returns boolean
set gje=O2x()
set gJe=XLx(function gLr)
call meo(cEe,XBx("Thunderstrike_Init: call Thunderstrike.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Thunderstrike.Event_SpellEffect))",ah,pI,function gYr))
return true
endfunction
function gZr takes nothing returns boolean
call cmr(function gzr,"Thunderstrike_Init")
return true
endfunction
function g_r takes nothing returns boolean
set gze[6]=hGo('uTW6')
call hho(((gze[6])),Apv,(INv))
set Tj[(gze[6])]=((1.4)*1.)
call hHo(gze[6],$C8,$C8,$C8,$FF)
set Nav[(gze[6])]=((60)*1.)
set Ntv[(gze[6])]=((60)*1.)
set Nlv[(gze[6])]=((320)*1.)
set I3v[(gze[6])]=((3)*1.)
set Axv[(gze[6])]=(2)
set NJv[(gze[6])]=((620)*1.)
set Njv[(gze[6])]=((620)*1.)
set Nhv[(gze[6])]=((0)*1.)
set NKv[(gze[6])]=((0)*1.)
set Nkv[(gze[6])]=((0)*1.)
set NHv[(gze[6])]=((0)*1.)
set NIv[(gze[6])]=(($578)*1.)
set NOv[(gze[6])]=(($578)*1.)
set Ndv[(gze[6])]=(('n')*1.)
set ANv[(gze[6])]=(gHv)
set Adv[(gze[6])]=(('l')*1.)
set ADv[((gze[6]))]=((1.*1./((1.35)*1.))*1.)
set Atv[(gze[6])]=((.33)*1.)
set AQv[(gze[6])]=((35)*1.)
set Asv[(gze[6])]=((35)*1.)
set Auv[(gze[6])]=(4)
set AWv[(gze[6])]=(5)
set Azv[(gze[6])]=(0)
set Aqv[(gze[6])]=((33)*1.)
return true
endfunction
function g0r takes nothing returns boolean
set gze[1]=hGo('uTW1')
call hho(((gze[1])),Apv,(INv))
set Tj[(gze[1])]=((.9)*1.)
call hHo(gze[1],$C8,$C8,$C8,$FF)
set Nav[(gze[1])]=((60)*1.)
set Ntv[(gze[1])]=((60)*1.)
set Nlv[(gze[1])]=((320)*1.)
set I3v[(gze[1])]=((0)*1.)
set Axv[(gze[1])]=(2)
set NJv[(gze[1])]=((90)*1.)
set Njv[(gze[1])]=((90)*1.)
set Nhv[(gze[1])]=((0)*1.)
set NKv[(gze[1])]=((0)*1.)
set Nkv[(gze[1])]=((0)*1.)
set NHv[(gze[1])]=((0)*1.)
set NIv[(gze[1])]=(($578)*1.)
set NOv[(gze[1])]=(($578)*1.)
set Ndv[(gze[1])]=((50)*1.)
set ANv[(gze[1])]=(gHv)
set Adv[(gze[1])]=(('l')*1.)
set ADv[((gze[1]))]=((1.*1./((1.35)*1.))*1.)
set Atv[(gze[1])]=((.33)*1.)
set AQv[(gze[1])]=((8)*1.)
set Asv[(gze[1])]=((8)*1.)
set Auv[(gze[1])]=(1)
set AWv[(gze[1])]=(5)
set Azv[(gze[1])]=(0)
set Aqv[(gze[1])]=((33)*1.)
return true
endfunction
function g1r takes nothing returns boolean
set gze[2]=hGo('uTW2')
call hho(((gze[2])),Apv,(INv))
set Tj[(gze[2])]=((1)*1.)
call hHo(gze[2],$C8,$C8,$C8,$FF)
set Nav[(gze[2])]=((60)*1.)
set Ntv[(gze[2])]=((60)*1.)
set Nlv[(gze[2])]=((320)*1.)
set I3v[(gze[2])]=((1)*1.)
set Axv[(gze[2])]=(2)
set NJv[(gze[2])]=(($87)*1.)
set Njv[(gze[2])]=(($87)*1.)
set Nhv[(gze[2])]=((0)*1.)
set NKv[(gze[2])]=((0)*1.)
set Nkv[(gze[2])]=((0)*1.)
set NHv[(gze[2])]=((0)*1.)
set NIv[(gze[2])]=(($578)*1.)
set NOv[(gze[2])]=(($578)*1.)
set Ndv[(gze[2])]=((80)*1.)
set ANv[(gze[2])]=(gHv)
set Adv[(gze[2])]=(('l')*1.)
set ADv[((gze[2]))]=((1.*1./((1.35)*1.))*1.)
set Atv[(gze[2])]=((.33)*1.)
set AQv[(gze[2])]=(($C)*1.)
set Asv[(gze[2])]=(($C)*1.)
set Auv[(gze[2])]=(2)
set AWv[(gze[2])]=(3)
set Azv[(gze[2])]=(0)
set Aqv[(gze[2])]=((33)*1.)
return true
endfunction
function g2r takes nothing returns boolean
call LZx('ATwW',false)
set cre=Lzo('ATwW')
set G6[(cre)]=(B6)
set j6[(cre)]=(6)
set sH[(cre)]=("Twin Wolves")
set Ih[(cre)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D009E)))),(((Oj))))))
set x6v[(cre)]=(0)
set xzv[(cre)]=("spell")
call LZo((cre),fH+(1),(($F)*1.))
call LZo((cre),QH+(1),(('d')*1.))
call LZo((cre),Lvv+(1),((750)*1.))
call LZo((cre),fH+(2),(($F)*1.))
call LZo((cre),QH+(2),(('d')*1.))
call LZo((cre),Lvv+(2),((750)*1.))
call LZo((cre),fH+(3),(($F)*1.))
call LZo((cre),QH+(3),(('d')*1.))
call LZo((cre),Lvv+(3),((750)*1.))
call LZo((cre),fH+(4),(($F)*1.))
call LZo((cre),QH+(4),(('d')*1.))
call LZo((cre),Lvv+(4),((750)*1.))
call LZo((cre),fH+(5),(($F)*1.))
call LZo((cre),QH+(5),(('d')*1.))
call LZo((cre),Lvv+(5),((750)*1.))
call LZo((cre),fH+(6),(($F)*1.))
call LZo((cre),QH+(6),(('d')*1.))
call LZo((cre),Lvv+(6),((750)*1.))
set Mnv[(cre)]=("ReplaceableTextures\\CommandButtons\\BTNWolf.blp")
call ccr(cre,'FAW0',6,'VAW0','LPAW','LRAW')
return true
endfunction
function g3r takes nothing returns boolean
set gze[3]=hGo('uTW3')
call hho(((gze[3])),Apv,(INv))
set Tj[(gze[3])]=((1.1)*1.)
call hHo(gze[3],$C8,$C8,$C8,$FF)
set Nav[(gze[3])]=((60)*1.)
set Ntv[(gze[3])]=((60)*1.)
set Nlv[(gze[3])]=((320)*1.)
set I3v[(gze[3])]=((1)*1.)
set Axv[(gze[3])]=(2)
set NJv[(gze[3])]=(($C8)*1.)
set Njv[(gze[3])]=(($C8)*1.)
set Nhv[(gze[3])]=((0)*1.)
set NKv[(gze[3])]=((0)*1.)
set Nkv[(gze[3])]=((0)*1.)
set NHv[(gze[3])]=((0)*1.)
set NIv[(gze[3])]=(($578)*1.)
set NOv[(gze[3])]=(($578)*1.)
set Ndv[(gze[3])]=(('n')*1.)
set ANv[(gze[3])]=(gHv)
set Adv[(gze[3])]=(('l')*1.)
set ADv[((gze[3]))]=((1.*1./((1.35)*1.))*1.)
set Atv[(gze[3])]=((.33)*1.)
set AQv[(gze[3])]=((16)*1.)
set Asv[(gze[3])]=((16)*1.)
set Auv[(gze[3])]=(3)
set AWv[(gze[3])]=(3)
set Azv[(gze[3])]=(0)
set Aqv[(gze[3])]=((33)*1.)
return true
endfunction
function g4r takes nothing returns boolean
set gze[4]=hGo('uTW4')
call hho(((gze[4])),Apv,(INv))
set Tj[(gze[4])]=((1.2)*1.)
call hHo(gze[4],$C8,$C8,$C8,$FF)
set Nav[(gze[4])]=((60)*1.)
set Ntv[(gze[4])]=((60)*1.)
set Nlv[(gze[4])]=((320)*1.)
set I3v[(gze[4])]=((2)*1.)
set Axv[(gze[4])]=(2)
set NJv[(gze[4])]=((315)*1.)
set Njv[(gze[4])]=((315)*1.)
set Nhv[(gze[4])]=((0)*1.)
set NKv[(gze[4])]=((0)*1.)
set Nkv[(gze[4])]=((0)*1.)
set NHv[(gze[4])]=((0)*1.)
set NIv[(gze[4])]=(($578)*1.)
set NOv[(gze[4])]=(($578)*1.)
set Ndv[(gze[4])]=(('n')*1.)
set ANv[(gze[4])]=(gHv)
set Adv[(gze[4])]=(('l')*1.)
set ADv[((gze[4]))]=((1.*1./((1.35)*1.))*1.)
set Atv[(gze[4])]=((.33)*1.)
set AQv[(gze[4])]=((22)*1.)
set Asv[(gze[4])]=((22)*1.)
set Auv[(gze[4])]=(3)
set AWv[(gze[4])]=(4)
set Azv[(gze[4])]=(0)
set Aqv[(gze[4])]=((33)*1.)
return true
endfunction
function g5r takes nothing returns boolean
set gZe[1]=20
set gZe[2]=20
set gZe[3]=20
set gZe[4]=20
set gZe[5]=20
set gZe[6]=20
set g_e[1]=2
set g_e[2]=2
set g_e[3]=2
set g_e[4]=2
set g_e[5]=2
set g_e[6]=2
return true
endfunction
function g6r takes nothing returns boolean
set gze[5]=hGo('uTW5')
call hho(((gze[5])),Apv,(INv))
set Tj[(gze[5])]=((1.3)*1.)
call hHo(gze[5],$C8,$C8,$C8,$FF)
set Nav[(gze[5])]=((60)*1.)
set Ntv[(gze[5])]=((60)*1.)
set Nlv[(gze[5])]=((320)*1.)
set I3v[(gze[5])]=((2)*1.)
set Axv[(gze[5])]=(2)
set NJv[(gze[5])]=((450)*1.)
set Njv[(gze[5])]=((450)*1.)
set Nhv[(gze[5])]=((0)*1.)
set NKv[(gze[5])]=((0)*1.)
set Nkv[(gze[5])]=((0)*1.)
set NHv[(gze[5])]=((0)*1.)
set NIv[(gze[5])]=(($578)*1.)
set NOv[(gze[5])]=(($578)*1.)
set Ndv[(gze[5])]=(('n')*1.)
set ANv[(gze[5])]=(gHv)
set Adv[(gze[5])]=(('l')*1.)
set ADv[((gze[5]))]=((1.*1./((1.35)*1.))*1.)
set Atv[(gze[5])]=((.33)*1.)
set AQv[(gze[5])]=((31)*1.)
set Asv[(gze[5])]=((31)*1.)
set Auv[(gze[5])]=(4)
set AWv[(gze[5])]=(4)
set Azv[(gze[5])]=(0)
set Aqv[(gze[5])]=((33)*1.)
return true
endfunction
function g7r takes nothing returns boolean
call VRx(Sa,(function g_r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\obj_summonUnitType[6]_wc3unit.j"))
call VRx(Sa,(function g0r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\obj_summonUnitType[1]_wc3unit.j"))
call VRx(Sa,(function g1r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\obj_summonUnitType[2]_wc3unit.j"))
call VRx(qa,(function g2r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Sa,(function g3r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\obj_summonUnitType[3]_wc3unit.j"))
call VRx(Sa,(function g4r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\obj_summonUnitType[4]_wc3unit.j"))
call VRx(ea,(function g5r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\obj_this_wc3obj.j"))
call VRx(Sa,(function g6r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\obj_summonUnitType[5]_wc3unit.j"))
return true
endfunction
function g8r takes nothing returns boolean
set g0e=Vnx(g1e)
return true
endfunction
function g9r takes integer rwx,integer CMx,real x,real y,real N8x returns integer
local integer C0o=(ze[(CMx)])
local integer Gvr=Uzo(gze[rwx],C0o,x,y,N8x,gZe[rwx])
call rzx((Gvr),(g5e),(rwx))
call fhx((Gvr),-((.0)*1.),-((.0)*1.),-((.0)*1.),-((255.)*1.))
call fPx(Gvr,.0,.0,.0,255.,g6e)
return Gvr
endfunction
function Ger takes integer Gxr,integer rwx,integer Gor returns nothing
set g8e=Gor
call rzx((Gxr),(g9e),(rwx))
endfunction
function Grr takes integer Ixx,integer rwx returns nothing
call NIx((Ixx),(Gve),(rwx),w,((Gee[rwx])*1.))
endfunction
function Gir takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real Gar=(GetUnitFacing(C[((CMx))])*bh)
local real Gnr=dvx(CMx,true)+g2e
local real jlx=(GetUnitX(C[((CMx))]))+Gnr*(Cos(((((Gar)*1.))*1.)))
local real jLx=(GetUnitY(C[((CMx))]))+Gnr*(Sin(((((Gar)*1.))*1.)))
local integer GVr=g_e[rwx]
local real GEr=Gar-g3e*1./ 2
local real GXr=g3e*1./(GVr-1)
local integer array GOr
local real N8x
local real x
local real y
loop
exitwhen(GVr<1)
set N8x=GEr+(GVr-1)*GXr
set x=jlx+g4e*(Cos(((((N8x)*1.))*1.)))
set y=jLx+g4e*(Sin(((((N8x)*1.))*1.)))
set GOr[GVr]=g9r(rwx,CMx,x,y,N8x)
call CAx(GOr[GVr],Xw,x+g7e*(Cos(((((N8x)*1.))*1.))),y+g7e*(Sin(((((N8x)*1.))*1.))))
set GVr=GVr-1
endloop
call Ger(GOr[1],rwx,GOr[2])
call Ger(GOr[2],rwx,GOr[1])
call Grr(CMx,rwx)
return true
endfunction
function GRr takes nothing returns boolean
call meo(cre,XBx("TwinWolves_Init: call TwinWolves.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TwinWolves.Event_SpellEffect))",ah,pI,function Gir))
return true
endfunction
function GIr takes nothing returns boolean
call FOr(function GRr,"TwinWolves_Init")
return true
endfunction
function GAr takes nothing returns boolean
set Gxe=WTx('BBrh',"Brotherhood",'bBrh')
set aev[(Gxe)]=("ReplaceableTextures\\PassiveButtons\\PASBTNGnollCommandAura.blp")
return true
endfunction
function GNr takes nothing returns boolean
call LZx('ABrh',false)
set g9e=Lzo('ABrh')
set G6[(g9e)]=(D6)
set j6[(g9e)]=(1)
set sH[(g9e)]=("Brotherhood")
set xzv[(g9e)]=("spell")
call LZo((g9e),Lvv+(1),((750)*1.))
set Mnv[(g9e)]=("ReplaceableTextures\\PassiveButtons\\PASBTNGnollCommandAura.blp")
return true
endfunction
function Gbr takes nothing returns boolean
call VRx(Ma,(function GAr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\Brotherhood.page\\Brotherhood.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function GNr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\Brotherhood.page\\Brotherhood.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function GBr takes nothing returns boolean
set Goe=Vnx(Gre)
return true
endfunction
function Gcr takes nothing returns boolean
local integer rdx=(bv)
local integer AFr=(EYv[(rdx)])
local real GCr=(Eyv[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer Gdr=Gae[oqx]
local real GDr
if((Pc[(Gdr)])or I6x(Gdr,sc))then
return true
endif
set GDr=GCr*Gne*1./ 2
if(GDr<=.0)then
return true
endif
call nfo((AFr),(Gdr),((GDr)*1.),(false))
set Eyv[(rdx)]=((GCr-GDr)*1.)
return true
endfunction
function Gfr takes nothing returns boolean
local integer rdx=(bv)
local integer Gdr=g8e
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
set Gae[oqx]=Gdr
call I7x(Ixx,Gie)
call AYo(Gdr)
return true
endfunction
function GFr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer Gdr=Gae[oqx]
call Rmx(Ixx,Gie)
call KFx(Gdr)
return true
endfunction
function Ggr takes nothing returns boolean
local integer rdx=(bv)
call Q8o((Vv[(rdx)]),Gxe,(Mv[(rdx)]))
return true
endfunction
function GGr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),Gxe)
return true
endfunction
function Ghr takes nothing returns boolean
set Gie=XBx("Brotherhood_Init: set Brotherhood.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.SPELLS, function Brotherhood.Event_Damage)",Ezv,pI,function Gcr)
call l9x(Gxe,XBx("Brotherhood_Init: call Brotherhood.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Brotherhood.Event_BuffGain))",Bd,pI,function Gfr))
call l9x(Gxe,XBx("Brotherhood_Init: call Brotherhood.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Brotherhood.Event_BuffLose))",Jc,pI,function GFr))
call meo(g9e,XBx("Brotherhood_Init: call Brotherhood.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Brotherhood.Event_Learn))",pv,pI,function Ggr))
call meo(g9e,XBx("Brotherhood_Init: call Brotherhood.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Brotherhood.Event_Unlearn))",Av,pI,function GGr))
return true
endfunction
function GHr takes nothing returns boolean
call FOr(function Ghr,"Brotherhood_Init")
return true
endfunction
function Gjr takes nothing returns boolean
call LZx('ACar',false)
set g5e=Lzo('ACar')
set G6[(g5e)]=(D6)
set j6[(g5e)]=(1)
set sH[(g5e)]=("Carnivore")
set xzv[(g5e)]=("spell")
call LZo((g5e),Lvv+(1),((750)*1.))
set Mnv[(g5e)]=("ReplaceableTextures\\PassiveButtons\\PASBTNVampiricAura.blp")
return true
endfunction
function GJr takes nothing returns boolean
set GVe=WTx('BCar',"Carnivore",'bCar')
set aev[(GVe)]=("ReplaceableTextures\\PassiveButtons\\PASBTNVampiricAura.blp")
call lux(GVe,"Abilities\\Spells\\NightElf\\BattleRoar\\RoarTarget.mdl","overhead",ri)
set SU=lYx()
call l_x(SU,Bcv,20)
call l_x(SU,cRv,5)
call l0x(((GVe)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,Bcv,30)
call l_x(SU,cRv,$A)
call l0x(((GVe)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,Bcv,40)
call l_x(SU,cRv,$F)
call l0x(((GVe)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,Bcv,50)
call l_x(SU,cRv,20)
call l0x(((GVe)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,Bcv,60)
call l_x(SU,cRv,25)
call l0x(((GVe)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,Bcv,70)
call l_x(SU,cRv,30)
call l0x(((GVe)),vc+(6),(SU))
return true
endfunction
function Gkr takes nothing returns boolean
set GEe[1]=5
set GEe[2]=$A
set GEe[3]=$F
set GEe[4]=20
set GEe[5]=25
set GEe[6]=30
set GXe[1]=20
set GXe[2]=30
set GXe[3]=40
set GXe[4]=50
set GXe[5]=60
set GXe[6]=70
return true
endfunction
function GKr takes nothing returns boolean
call VRx(qa,(function Gjr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\Carnivore.page\\Carnivore.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function GJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\Carnivore.page\\Carnivore.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function Gkr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\Carnivore.page\\Carnivore.struct\\obj_this_wc3obj.j"))
return true
endfunction
function Glr takes nothing returns boolean
set GOe=Vnx(GRe)
return true
endfunction
function GLr takes nothing returns boolean
local integer rdx=(bv)
call Q8o((Vv[(rdx)]),GVe,(Mv[(rdx)]))
return true
endfunction
function Gmr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),GVe)
return true
endfunction
function GMr takes nothing returns boolean
call meo(g5e,XBx("Carnivore_Init: call Carnivore.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Carnivore.Event_Learn))",pv,pI,function GLr))
call meo(g5e,XBx("Carnivore_Init: call Carnivore.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Carnivore.Event_Unlearn))",Av,pI,function Gmr))
return true
endfunction
function Gpr takes nothing returns boolean
call FOr(function GMr,"Carnivore_Init")
return true
endfunction
function GPr takes nothing returns boolean
set Gve=WTx('BWoM',"Wolf's Mark",'bWoM')
set qc[(Gve)]=(true)
set aev[(Gve)]=("ReplaceableTextures\\PassiveButtons\\PASBTNVampiricAura.blp")
call lux(Gve,"Abilities\\Spells\\NightElf\\BattleRoar\\RoarTarget.mdl","overhead",ri)
set SU=lYx()
call l_x(SU,Bcv,'d')
call l_x(SU,crv,'d')
call l_x(SU,cRv,5)
call l0x(((Gve)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,Bcv,'}')
call l_x(SU,crv,'}')
call l_x(SU,cRv,$A)
call l0x(((Gve)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,Bcv,$96)
call l_x(SU,crv,$96)
call l_x(SU,cRv,$F)
call l0x(((Gve)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,Bcv,$AF)
call l_x(SU,crv,$AF)
call l_x(SU,cRv,20)
call l0x(((Gve)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,Bcv,$C8)
call l_x(SU,crv,$C8)
call l_x(SU,cRv,25)
call l0x(((Gve)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,Bcv,$E1)
call l_x(SU,crv,$E1)
call l_x(SU,cRv,30)
call l0x(((Gve)),vc+(6),(SU))
return true
endfunction
function Gqr takes nothing returns boolean
set GIe[1]='d'
set GIe[2]='}'
set GIe[3]=$96
set GIe[4]=$AF
set GIe[5]=$C8
set GIe[6]=$E1
set Gee[1]=5
set Gee[2]=5
set Gee[3]=5
set Gee[4]=5
set Gee[5]=5
set Gee[6]=5
set GAe[1]='d'
set GAe[2]='}'
set GAe[3]=$96
set GAe[4]=$AF
set GAe[5]=$C8
set GAe[6]=$E1
set GNe[1]=5
set GNe[2]=$A
set GNe[3]=$F
set GNe[4]=20
set GNe[5]=25
set GNe[6]=30
return true
endfunction
function GQr takes nothing returns boolean
call VRx(Ma,(function GPr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\WolfsMark.page\\WolfsMark.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function Gqr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\WolfsMark.page\\WolfsMark.struct\\obj_this_wc3obj.j"))
return true
endfunction
function Gsr takes nothing returns boolean
set Gbe=Vnx(GBe)
return true
endfunction
function GSr takes nothing returns boolean
return true
endfunction
function Gtr takes nothing returns boolean
call FOr(function GSr,"WolfsMark_Init")
return true
endfunction
function GTr takes nothing returns boolean
return true
endfunction
function Gur takes nothing returns boolean
set Gce=Vnx(GCe)
return true
endfunction
function GUr takes nothing returns boolean
call LZx('AViM',false)
set Gde=Lzo('AViM')
set G6[(Gde)]=(B6)
set j6[(Gde)]=(6)
set sH[(Gde)]=("Vivid Meteor")
set Ih[(Gde)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D026F)))),(((Oj))))))
set x6v[(Gde)]=(2)
set xzv[(Gde)]=("spell")
call LZo((Gde),u6v+(1),((300)*1.))
call LZo((Gde),fH+(1),(($A)*1.))
call LZo((Gde),QH+(1),((80)*1.))
call LZo((Gde),Lvv+(1),(($578)*1.))
call LZo((Gde),u6v+(2),((300)*1.))
call LZo((Gde),fH+(2),(($A)*1.))
call LZo((Gde),QH+(2),(('d')*1.))
call LZo((Gde),Lvv+(2),(($578)*1.))
call LZo((Gde),u6v+(3),((300)*1.))
call LZo((Gde),fH+(3),(($A)*1.))
call LZo((Gde),QH+(3),(('x')*1.))
call LZo((Gde),Lvv+(3),(($578)*1.))
call LZo((Gde),u6v+(4),((300)*1.))
call LZo((Gde),fH+(4),(($A)*1.))
call LZo((Gde),QH+(4),(($8C)*1.))
call LZo((Gde),Lvv+(4),(($578)*1.))
call LZo((Gde),u6v+(5),((300)*1.))
call LZo((Gde),fH+(5),(($A)*1.))
call LZo((Gde),QH+(5),(($A0)*1.))
call LZo((Gde),Lvv+(5),(($578)*1.))
call LZo((Gde),u6v+(6),((300)*1.))
call LZo((Gde),fH+(6),(($A)*1.))
call LZo((Gde),QH+(6),(($B4)*1.))
call LZo((Gde),Lvv+(6),(($578)*1.))
set Mnv[(Gde)]=("ReplaceableTextures\\CommandButtons\\BTNFireRocks.blp")
call ccr(Gde,'FVM0',6,'VVM0','LPVM','LRVM')
set GDe[1]='}'
set GDe[2]=$C8
set GDe[3]=275
set GDe[4]=350
set GDe[5]=425
set GDe[6]=500
set Gfe[1]=3
set Gfe[2]=4
set Gfe[3]=5
set Gfe[4]=6
set Gfe[5]=7
set Gfe[6]=8
set GFe[1]=65
set GFe[2]='i'
set GFe[3]=$91
set GFe[4]=$B9
set GFe[5]=$E1
set GFe[6]=265
set Gge[1]=2
set Gge[2]=2.5
set Gge[3]=3
set Gge[4]=3.5
set Gge[5]=4
set Gge[6]=4.5
return true
endfunction
function Gwr takes nothing returns boolean
set GGe=lQx(Ghe+" (poisonBuff)")
set qc[(GGe)]=(true)
set qU[(GGe)]=(true)
return true
endfunction
function GWr takes nothing returns boolean
call VRx(qa,(function GUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\VividMeteor.page\\VividMeteor.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function Gwr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\VividMeteor.page\\VividMeteor.struct\\obj_poisonBuff_wc3buff.j"))
return true
endfunction
function Gyr takes nothing returns boolean
set GHe=Vnx(Ghe)
return true
endfunction
function GYr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if I6x(Ixx,Icv)then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function Gzr takes integer oqx returns integer
set Gme[oqx]=true
set GMe[oqx]=false
call rax(GHe)
return oqx
endfunction
function GZr takes nothing returns integer
local integer oqx
if(Gke==8190)then
call oYx("VividMeteor_Allocation_allocCustom","call DebugEx(VividMeteor.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Ghe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(GKe[(w)]==w)then
set Gle=Gle+1
set oqx=Gle
else
set oqx=GKe[(w)]
set GKe[(w)]=GKe[GKe[(w)]]
endif
set GKe[oqx]=Z
set GLe[oqx]=1
call Gzr(oqx)
return oqx
endfunction
function G_r takes integer oqx returns boolean
set G3e=G3e+1
set G4e[G3e]=oqx
set G5e[oqx]=G3e+1
return(G3e==0)
endfunction
function G0r takes nothing returns nothing
local integer olx=G3e
local integer oqx
local real iXr
local integer rlx
local real n_x
local real x
local real y
local real N8x
local integer HOx
loop
set oqx=G4e[olx]
set iXr=GUe[oqx]+G8e
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((G0e+oqx))),(((G1e))))))
set n_x=GWe[oqx]+G9e
set x=GYe[oqx]
set y=Gze[oqx]
set GUe[oqx]=iXr
set GWe[oqx]=n_x
set N8x=Gue[oqx]+iXr
set Gue[oqx]=N8x
loop
set N8x=N8x+G_e
set HOx=(LoadInteger(o[((V[(E[((X))])]))],(((G0e+oqx))),(((G1e)+(rlx)))))
call mRx(HOx,N8x+b6v)
call QZo(HOx,x+n_x*(Cos(((((N8x)*1.))*1.))),y+n_x*(Sin(((((N8x)*1.))*1.))))
set rlx=rlx-1
exitwhen(rlx<q)
endloop
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function G1r takes integer oqx,real x,real y returns nothing
local real N8x=GTe
local integer olx
local integer HOx
set Gue[oqx]=GTe
set GUe[oqx]=Gwe
set GWe[oqx]=Gye
set GYe[oqx]=x
set Gze[oqx]=y
set olx=GZe
loop
exitwhen(olx<1)
set N8x=N8x+G_e
set HOx=mcx('qViM',x+Gye*(Cos(((((N8x)*1.))*1.))),y+Gye*(Sin(((((N8x)*1.))*1.))),XYx(x,y),GTe+b6v)
call rSx(X,G0e+oqx,G1e,HOx)
call k2o(HOx,.75)
call SetUnitTimeScale(zj[(HOx)],((.75*1./ G2e)*1.))
set olx=olx-1
endloop
if G_r(oqx)then
call icx(G6e,G7e,true,function G0r)
endif
endfunction
function G2r takes integer oqx returns nothing
set Gme[oqx]=false
call rgx(GHe)
endfunction
function G3r takes integer oqx returns nothing
if(GLe[oqx]>0)then
return
endif
if(GKe[oqx]!=Z)then
call oYx("VividMeteor_Allocation_deallocCustom_confirm","call DebugEx(VividMeteor.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Ghe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set GKe[oqx]=GKe[(w)]
set GKe[(w)]=oqx
call G2r(oqx)
endfunction
function G4r takes integer oqx returns nothing
set GLe[oqx]=GLe[oqx]-1
call G3r(oqx)
endfunction
function G5r takes integer oqx returns boolean
local integer okx=(G5e[(oqx)])
set G5e[G4e[G3e]]=okx
set G4e[okx-1]=G4e[G3e]
set G5e[oqx]=0
set G3e=G3e-1
return(G3e==F)
endfunction
function G6r takes integer oqx returns nothing
local integer olx
local integer HOx
if G5r(oqx)then
call iHx(G6e)
endif
set olx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((G0e+oqx))),(((G1e))))))
loop
set HOx=(LoadInteger(o[((V[(E[((X))])]))],(((G0e+oqx))),(((G1e)+(olx)))))
call rex(X,G0e+oqx,G1e,HOx)
if(olx!=q)then
call MCx(HOx)
endif
set olx=olx-1
exitwhen(olx<q)
endloop
endfunction
function G7r takes nothing returns nothing
local integer OHx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(OHx)])
local integer CMx=GPe[oqx]
local real Anr=GQe[oqx]
local integer rwx=Gse[oqx]
local real dix=GSe[oqx]
local real dax=Gte[oqx]
local integer C0o=(ze[(CMx)])
local integer Ixx
local real NIo
local real G8r
local real G9r
local real hvr
call G4r((oqx))
call ijx(OHx)
call Nio(Gje,dix,dax,Gpe[oqx],GJe)
set Ixx=Nao(Gje)
if(Ixx!=w)then
set NIo=Gqe[oqx]
set G8r=Gfe[rwx]
set G9r=Gge[rwx]
loop
if(IsUnitAlly(C[(Ixx)],vx[(C0o)]))then
call moo(CMx,Ixx,Anr)
else
if I6x(Ixx,yd)then
set hvr=G9r
else
set hvr=G8r
endif
call NIx((Ixx),(GGe),(rwx),w,((hvr)*1.))
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
endif
set Ixx=Nao(Gje)
exitwhen(Ixx==w)
endloop
endif
call G6r(oqx)
endfunction
function her takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local integer oqx=GZr()
local integer OHx=inx()
set Gpe[oqx]=(Cpx((Gde),u6v+(rwx)))
set GPe[oqx]=CMx
set Gqe[oqx]=GFe[rwx]
set GQe[oqx]=GDe[rwx]
set Gse[oqx]=rwx
set GSe[oqx]=dix
set Gte[oqx]=dax
set ge[(OHx)]=(oqx)
call G1r(oqx,dix,dax)
call icx(OHx,G2e,false,function G7r)
return true
endfunction
function hxr takes nothing returns nothing
set Gwe=hve*G7e
set G8e=hee*G7e*G7e
set G_e=df*1./ GZe
set G9e=-Gye*1./ G2e*G7e
set G6e=inx()
endfunction
function hor takes nothing returns boolean
set Gje=O2x()
set GJe=XLx(function GYr)
call meo(Gde,XBx("VividMeteor_Init: call VividMeteor.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function VividMeteor.Event_SpellEffect))",ah,pI,function her))
call W_x(XNv,GGe)
call hxr()
return true
endfunction
function hrr takes nothing returns boolean
call cmr(function hor,"VividMeteor_Init")
return true
endfunction
function hir takes nothing returns boolean
call LZx('AWaM',false)
set hxe=Lzo('AWaM')
set G6[(hxe)]=(B6)
set j6[(hxe)]=(6)
set sH[(hxe)]=("Warmth Magnetism")
set Ih[(hxe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0105)))),(((Oj))))))
set x6v[(hxe)]=(4)
set xzv[(hxe)]=("spell")
call LZo((hxe),fH+(1),((6)*1.))
call LZo((hxe),QH+(1),((50)*1.))
call LZo((hxe),Lvv+(1),((600)*1.))
call LZo((hxe),fH+(2),((6)*1.))
call LZo((hxe),QH+(2),((50)*1.))
call LZo((hxe),Lvv+(2),((600)*1.))
call LZo((hxe),fH+(3),((6)*1.))
call LZo((hxe),QH+(3),((60)*1.))
call LZo((hxe),Lvv+(3),((600)*1.))
call LZo((hxe),fH+(4),((6)*1.))
call LZo((hxe),QH+(4),((60)*1.))
call LZo((hxe),Lvv+(4),((600)*1.))
call LZo((hxe),fH+(5),((6)*1.))
call LZo((hxe),QH+(5),((70)*1.))
call LZo((hxe),Lvv+(5),((600)*1.))
call LZo((hxe),fH+(6),((6)*1.))
call LZo((hxe),QH+(6),((70)*1.))
call LZo((hxe),Lvv+(6),((600)*1.))
set Mnv[(hxe)]=("ReplaceableTextures\\CommandButtons\\BTNGnollCommandAura.blp")
call ccr(hxe,'FWM0',6,'VWM0','LPWM','LRWM')
set hoe[1]=20
set hoe[2]=30
set hoe[3]=40
set hoe[4]=50
set hoe[5]=60
set hoe[6]=70
return true
endfunction
function har takes nothing returns boolean
set hre=Vbx("OWaM")
return true
endfunction
function hnr takes nothing returns boolean
set hie=lQx(hae+" (dummyBuff)")
set qc[(hie)]=(true)
set qU[(hie)]=(true)
set SU=lYx()
call vOr(SU,dGv,true)
call l0x(((hie)),vc+(1),(SU))
set SU=lYx()
call vOr(SU,dGv,true)
call l0x(((hie)),vc+(2),(SU))
set SU=lYx()
call vOr(SU,dGv,true)
call l0x(((hie)),vc+(3),(SU))
set SU=lYx()
call vOr(SU,dGv,true)
call l0x(((hie)),vc+(4),(SU))
set SU=lYx()
call vOr(SU,dGv,true)
call l0x(((hie)),vc+(5),(SU))
set SU=lYx()
call vOr(SU,dGv,true)
call l0x(((hie)),vc+(6),(SU))
return true
endfunction
function hVr takes nothing returns boolean
call VRx(qa,(function hir),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\WarmthMagnetism.page\\WarmthMagnetism.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ha,(function har),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\WarmthMagnetism.page\\WarmthMagnetism.struct\\obj_bolt_wc3bolt.j"))
call VRx(Ma,(function hnr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\WarmthMagnetism.page\\WarmthMagnetism.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function hEr takes nothing returns boolean
set hne=Vnx(hae)
return true
endfunction
function hXr takes integer oqx,integer CMx returns nothing
if rrx(CMx,hEe,oqx)then
call Rmx(CMx,hVe)
endif
endfunction
function hOr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local integer olx=CXx(CMx,hEe)
local integer oqx
loop
set oqx=COx(CMx,hEe,olx)
call hXr(oqx,CMx)
set hXe[oqx]=w
set hOe[oqx]=wpo
set hRe[oqx]=wPo
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function hRr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
call nJo((hXe[oqx]),(Ixx),((hBe[oqx])*1.),(true),(false))
endfunction
function hIr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=hXe[oqx]
local integer rwx=hde[oqx]
local integer Ixx=oqx
local real dix=(GetUnitX(C[((Ixx))]))
local real dax=(GetUnitY(C[((Ixx))]))
local real wpo
local real wPo
local real dX
local real dY
local real d
local real oUx
local real N8x
local boolean hAr
local real eor
local real err
if(CMx==w)then
set wpo=hOe[oqx]
set wPo=hRe[oqx]
else
set wpo=(GetUnitX(C[((CMx))]))
set wPo=(GetUnitY(C[((CMx))]))
endif
set dX=wpo-dix
set dY=wPo-dax
set d=jjx(dX,dY)
set oUx=hIe
set N8x=(Atan2(((dY)*1.),((dX)*1.)))
set hAr=(d<oUx+hGe)
set eor=dix+oUx*(Cos(((((N8x)*1.))*1.)))
set err=dax+oUx*(Sin(((((N8x)*1.))*1.)))
call fTx(Ixx,eor)
call fux(Ixx,err)
if hAr then
call Ayx(Ixx,hie)
endif
endfunction
function hNr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=hbe
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer clo=cBo(hre)
local integer p0x=inx()
local integer hbr=inx()
set hXe[oqx]=CMx
set hBe[oqx]=hoe[rwx]
set hce[oqx]=clo
set hCe[oqx]=p0x
set hde[oqx]=rwx
set hDe[oqx]=hbr
if rtx(CMx,hEe,oqx)then
call I7x(CMx,hVe)
endif
set ge[(p0x)]=(oqx)
set ge[(hbr)]=(oqx)
call EEr(clo,Ixx,CMx)
call RUx((Abx((Ixx),(hfe),(hFe),(Bi))))
call icx(p0x,hge,true,function hRr)
call icx(hbr,hNe,true,function hIr)
return true
endfunction
function hBr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer CMx=hXe[oqx]
local integer clo=hce[oqx]
local integer p0x=hCe[oqx]
local integer hbr=hDe[oqx]
if(CMx!=w)then
call hXr(oqx,CMx)
endif
call Kzx(clo)
call ijx(p0x)
call ijx(hbr)
return true
endfunction
function hcr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
set hbe=CMx
call Q8o((WH[(rdx)]),hie,(Mv[(rdx)]))
return true
endfunction
function hCr takes nothing returns boolean
set hVe=XBx("WarmthMagnetism_Init: set WarmthMagnetism.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function WarmthMagnetism.Event_Caster_Death)",VP,pI,function hOr)
set hIe=hAe*hNe
call l9x(hie,XBx("WarmthMagnetism_Init: call WarmthMagnetism.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function WarmthMagnetism.Event_BuffGain))",Bd,pI,function hNr))
call l9x(hie,XBx("WarmthMagnetism_Init: call WarmthMagnetism.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function WarmthMagnetism.Event_BuffLose))",Jc,pI,function hBr))
call meo(hxe,XBx("WarmthMagnetism_Init: call WarmthMagnetism.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function WarmthMagnetism.Event_SpellEffect))",ah,pI,function hcr))
call W_x(Xhv,hie)
return true
endfunction
function hdr takes nothing returns boolean
call cmr(function hCr,"WarmthMagnetism_Init")
return true
endfunction
function hDr takes nothing returns boolean
set hhe=lQx(hHe+" (dummyBuff)")
call lux(hhe,"Abilities\\Spells\\Undead\\DeathandDecay\\DeathandDecayDamage.mdl","origin",Bi)
return true
endfunction
function hfr takes nothing returns boolean
call VRx(Ma,(function hDr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Amaterasu.page\\Amaterasu.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function hFr takes nothing returns boolean
set hje=Vnx(hHe)
return true
endfunction
function hgr takes nothing returns boolean
set hJe=lQx(hke+" (dummyBuff)")
call lux(hJe,"Abilities\\Spells\\Orc\\LiquidFire\\Liquidfire.mdl","origin",ri)
call lux(hJe,"Abilities\\Spells\\Other\\Doom\\DoomTarget.mdl","origin",Bi)
call lux(hJe,"Abilities\\Spells\\Orc\\Voodoo\\VoodooAura.mdl","origin",Bi)
return true
endfunction
function hGr takes nothing returns boolean
call LZx('AAma',false)
set hKe=Lzo('AAma')
set G6[(hKe)]=(C6)
set j6[(hKe)]=(3)
set sH[(hKe)]=("Amaterasu")
set Ih[(hKe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00FD)))),(((Oj))))))
set x6v[(hKe)]=(0)
set xzv[(hKe)]=("spell,channel")
call LZo((hKe),u6v+(1),((450)*1.))
call LZo((hKe),BH+(1),(($F)*1.))
call LZo((hKe),fH+(1),((90)*1.))
call LZo((hKe),QH+(1),(($91)*1.))
call LZo((hKe),Lvv+(1),((750)*1.))
call LZo((hKe),u6v+(2),((450)*1.))
call LZo((hKe),BH+(2),(($F)*1.))
call LZo((hKe),fH+(2),((90)*1.))
call LZo((hKe),QH+(2),(($D2)*1.))
call LZo((hKe),Lvv+(2),((750)*1.))
call LZo((hKe),u6v+(3),((450)*1.))
call LZo((hKe),BH+(3),(($F)*1.))
call LZo((hKe),fH+(3),((90)*1.))
call LZo((hKe),QH+(3),((275)*1.))
call LZo((hKe),Lvv+(3),((750)*1.))
set Mnv[(hKe)]=("ReplaceableTextures\\CommandButtons\\BTNOrbofSlowness.blp")
call ccr(hKe,'FAm0',3,'VAm0','LPAm','LRAm')
set hle[1]=300
set hle[2]=500
set hle[3]=800
set hLe[1]=600
set hLe[2]=900
set hLe[3]=$4B0
return true
endfunction
function hhr takes nothing returns boolean
call VRx(Ma,(function hgr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Amaterasu.page\\Amaterasu.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function hGr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Amaterasu.page\\Amaterasu.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function hHr takes nothing returns boolean
set hme=Vnx(hke)
return true
endfunction
function hjr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if nIo(Ixx)then
return false
endif
if(oPx((((Ixx))),(yb+(hhe)))>0)then
return false
endif
return true
return true
endfunction
function hJr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
local integer woo
local real NIo
call Nio(hMe,hSe[oqx],hte[oqx],hPe[oqx],hpe)
set woo=Nao(hMe)
if(woo!=w)then
set NIo=hqe[oqx]
loop
call NIx(((woo)),(hhe),(1),w,((hue)*1.))
if I6x(woo,INv)then
call nJo((Ixx),(woo),((NIo)*1.),(false),(false))
else
call nJo((Ixx),(woo),((NIo*hUe)*1.),(false),(false))
endif
set woo=Nao(hMe)
exitwhen(woo==w)
endloop
endif
endfunction
function hkr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local real dix=(GetUnitX(C[((Ixx))]))
local real dax=(GetUnitY(C[((Ixx))]))
local integer oqx=Ixx
local integer p0x=inx()
set hPe[oqx]=(Cpx((hKe),u6v+(rwx)))
set hqe[oqx]=hQe[rwx]
set hse[oqx]=p0x
set hSe[oqx]=dix
set hte[oqx]=dax
set ge[(p0x)]=(oqx)
call icx(p0x,hTe,true,function hJr)
return true
endfunction
function hKr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=hse[oqx]
call ijx(p0x)
return true
endfunction
function hlr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),hJe)
return true
endfunction
function hLr takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(hJe),((Mv[(rdx)])),w)
return true
endfunction
function hmr takes nothing returns nothing
endfunction
function hMr takes nothing returns boolean
local integer olx
set hMe=O2x()
set hpe=XLx(function hjr)
call l9x(hJe,XBx("Amaterasu_Init: call Amaterasu.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Amaterasu.Event_BuffGain))",Bd,pI,function hkr))
call l9x(hJe,XBx("Amaterasu_Init: call Amaterasu.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Amaterasu.Event_BuffLose))",Jc,pI,function hKr))
call meo(hKe,XBx("Amaterasu_Init: call Amaterasu.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Amaterasu.Event_EndCast))",oev,pI,function hlr))
call meo(hKe,XBx("Amaterasu_Init: call Amaterasu.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Amaterasu.Event_SpellEffect))",ah,pI,function hLr))
set olx=(j6[(hKe)])
loop
set hQe[olx]=hLe[olx]*1./(R2I((((Cpx((hKe),BH+(olx)))*1./ hue)*1.)))
set olx=olx-1
exitwhen(olx<1)
endloop
call hmr()
return true
endfunction
function hpr takes nothing returns boolean
call FOr(function hMr,"Amaterasu_Init")
return true
endfunction
function hPr takes nothing returns boolean
set hwe=Vbx("OCrp")
return true
endfunction
function hqr takes nothing returns boolean
set hWe=WTx('BCrp',"Crippled",'bCrp')
set qU[(hWe)]=(true)
set aev[(hWe)]=("ReplaceableTextures\\CommandButtons\\BTNDispelMagic.blp")
call lux(hWe,"ArcaneAttractor_page\\ArcaneAttractor_struct\\Target\\Target.mdx","origin",ri)
set SU=lYx()
call l_x(SU,nev,-.3)
call l_x(SU,dgv,-.3)
call l0x(((hWe)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,nev,-.35)
call l_x(SU,dgv,-.3)
call l0x(((hWe)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,nev,-.4)
call l_x(SU,dgv,-.3)
call l0x(((hWe)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,nev,-.45)
call l_x(SU,dgv,-.3)
call l0x(((hWe)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,nev,-.5)
call l_x(SU,dgv,-.3)
call l0x(((hWe)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,nev,-.55)
call l_x(SU,dgv,-.3)
call l0x(((hWe)),vc+(6),(SU))
return true
endfunction
function hQr takes nothing returns boolean
set hye[1]=-.3
set hye[2]=-.3
set hye[3]=-.3
set hye[4]=-.3
set hye[5]=-.3
set hye[6]=-.3
set hYe[1]=5
set hYe[2]=5
set hYe[3]=5
set hYe[4]=5
set hYe[5]=5
set hYe[6]=5
set hze[1]=-.3
set hze[2]=-.35
set hze[3]=-.4
set hze[4]=-.45
set hze[5]=-.5
set hze[6]=-.55
return true
endfunction
function hsr takes nothing returns boolean
call VRx(Ha,(function hPr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcaneAttractor.page\\ArcaneAttractor.struct\\Target\\obj_bolt_wc3bolt.j"))
call VRx(Ma,(function hqr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcaneAttractor.page\\ArcaneAttractor.struct\\Target\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function hQr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcaneAttractor.page\\ArcaneAttractor.struct\\Target\\obj_this_wc3obj.j"))
return true
endfunction
function hSr takes nothing returns boolean
set hZe=Vnx(h_e)
return true
endfunction
function htr takes nothing returns boolean
call LZx('ACrp',false)
set g3v=Lzo('ACrp')
set G6[(g3v)]=(N6)
set j6[(g3v)]=(6)
set sH[(g3v)]=("Arcane Attractor")
set Ih[(g3v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00DD)))),(((Oj))))))
set x6v[(g3v)]=(2)
set xzv[(g3v)]=("spell")
call LZo((g3v),u6v+(1),((300)*1.))
call LZo((g3v),fH+(1),((20)*1.))
call LZo((g3v),QH+(1),((85)*1.))
call LZo((g3v),Lvv+(1),((650)*1.))
call LZo((g3v),u6v+(2),((300)*1.))
call LZo((g3v),fH+(2),((19)*1.))
call LZo((g3v),QH+(2),(('n')*1.))
call LZo((g3v),Lvv+(2),((650)*1.))
call LZo((g3v),u6v+(3),((300)*1.))
call LZo((g3v),fH+(3),((18)*1.))
call LZo((g3v),QH+(3),(($87)*1.))
call LZo((g3v),Lvv+(3),((650)*1.))
call LZo((g3v),u6v+(4),((300)*1.))
call LZo((g3v),fH+(4),((17)*1.))
call LZo((g3v),QH+(4),(($A0)*1.))
call LZo((g3v),Lvv+(4),((650)*1.))
call LZo((g3v),u6v+(5),((300)*1.))
call LZo((g3v),fH+(5),((16)*1.))
call LZo((g3v),QH+(5),(($B9)*1.))
call LZo((g3v),Lvv+(5),((650)*1.))
call LZo((g3v),u6v+(6),((300)*1.))
call LZo((g3v),fH+(6),(($F)*1.))
call LZo((g3v),QH+(6),(($D2)*1.))
call LZo((g3v),Lvv+(6),((650)*1.))
set Mnv[(g3v)]=("ReplaceableTextures\\CommandButtons\\BTNDispelMagic.blp")
call ccr(g3v,'FCp0',6,'VCp0','LPCp','LRCp')
set h0e[1]=.06
set h0e[2]=.07
set h0e[3]=.08
set h0e[4]=.09
set h0e[5]=.1
set h0e[6]=.11
set h1e[1]=$A
set h1e[2]=$A
set h1e[3]=$A
set h1e[4]=$A
set h1e[5]=$A
set h1e[6]=$A
set h2e[1]=20
set h2e[2]=30
set h2e[3]=40
set h2e[4]=50
set h2e[5]=60
set h2e[6]=70
return true
endfunction
function hTr takes nothing returns boolean
set h3e=hGo('uCrp')
call hho(((h3e)),Apv,(Ivv))
set Tj[(h3e)]=((1)*1.)
set Nav[(h3e)]=(($B)*1.)
set Ntv[(h3e)]=(($B)*1.)
set Nlv[(h3e)]=(($96)*1.)
set Axv[(h3e)]=(5)
set NJv[(h3e)]=((150000.)*1.)
set Njv[(h3e)]=((150000.)*1.)
set Nhv[(h3e)]=((0)*1.)
set NIv[(h3e)]=((750)*1.)
set NOv[(h3e)]=((750)*1.)
set Ndv[(h3e)]=((50)*1.)
set AQv[(h3e)]=((0)*1.)
set Asv[(h3e)]=((0)*1.)
set Auv[(h3e)]=(0)
set AWv[(h3e)]=(0)
set Aqv[(h3e)]=((8)*1.)
call hLo((h3e),(gQv),1)
return true
endfunction
function hur takes nothing returns boolean
call VRx(qa,(function htr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcaneAttractor.page\\ArcaneAttractor.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Sa,(function hTr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcaneAttractor.page\\ArcaneAttractor.struct\\obj_summonUnitType_wc3unit.j"))
return true
endfunction
function hUr takes nothing returns boolean
set h4e=Vnx(h5e)
return true
endfunction
function hwr takes integer oqx returns nothing
local integer ibx=h8e[oqx]
local integer p0x=h9e[oqx]
local integer IVr=Hve[oqx]
call ijx(ibx)
call ijx(p0x)
call Rmx(IVr,h7e)
call OTx(IVr)
endfunction
function hWr takes nothing returns boolean
local integer rdx=(bv)
local integer IVr=(Vv[(rdx)])
local integer oqx=IVr
call hwr(oqx)
return true
endfunction
function hyr takes nothing returns boolean
local integer Ixx=jFx()
if(oPx((((Ixx))),(yb+(hWe)))>0)then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
if((GetRandomReal(((.0)*1.),((1.)*1.)))>Hxe)then
return false
endif
return true
return true
endfunction
function hYr takes integer oqx,integer CMx,integer rwx,integer Ixx returns nothing
local integer rkx=oqx
local integer hzr=cBo(hwe)
call EEr(hzr,Hve[rkx],Ixx)
call cko(hzr,1.)
set Ib=CMx
call NIx((Ixx),(hWe),(rwx),w,((hYe[rwx])*1.))
endfunction
function hZr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CQx=Hoe[oqx]
local integer CMx=(aH[(CQx)])
local integer rwx=(XH[(CQx)])
local integer IVr=Hve[oqx]
local real x=(GetUnitX(C[((IVr))]))
local real y=(GetUnitY(C[((IVr))]))
local integer Ixx
local real NIo
local real h_r
set Hf=(ze[(CMx)])
call Nio(h6e,x,y,(Cpx((g3v),u6v+(rwx))),Hee)
set Ixx=(mjo((h6e),((x)*1.),((y)*1.)))
if(Ixx!=w)then
set NIo=h2e[rwx]
set h_r=h0e[rwx]
call hYr(oqx,CMx,rwx,Ixx)
call nZr(Ixx)
call OSr(Ixx,450.,.0,(Atan2((((GetUnitY(C[((Ixx))]))-y)*1.),(((GetUnitX(C[((Ixx))]))-x)*1.)))+3.141592654,1.)
if(oPx((((CMx))),(yb+(c0e)))>0)then
call NIx((((Ixx))),((Xsv)),(1),w,((((HEe[(oPx(((CMx)),zb+(c0e)))])*1.))*1.))
endif
call RUx((Abx((Ixx),(HXe),(HOe),(Bi))))
call nJo((CMx),(Ixx),((NIo+h_r*(rG[(Ixx)]))*1.),(true),(false))
endif
endfunction
function h0r takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
call hwr(oqx)
endfunction
function h1r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local integer CQx=(uH[(rdx)])
local integer IVr=Uzo(h3e,(ze[(CMx)]),dix,dax,(iH[(CQx)]),h1e[rwx])
local integer oqx=IVr
local integer ibx=inx()
local integer p0x=inx()
set h8e[oqx]=ibx
set h9e[oqx]=p0x
set Hve[oqx]=IVr
set Hoe[oqx]=CQx
set ge[(ibx)]=(oqx)
set ge[(p0x)]=(oqx)
call I7x(IVr,h7e)
call RUx((Abx((IVr),(Hre),(Hie),(Bi))))
call SetUnitAnimation(C[((IVr))],("channel"))
call aIx(IVr,(xx[(CMx)]))
call SetUnitFlyHeight(C[((IVr))],((Hae)*1.),.0)
call fGx(IVr,0,0,0,0)
call fPx(IVr,$FF,$FF,$FF,$FF,1.)
call mFo((mHo(((dix)*1.),((dax)*1.),(Hne),(ri))))
call icx(p0x,HVe,true,function hZr)
call icx(ibx,h1e[rwx],false,function h0r)
return true
endfunction
function h2r takes nothing returns nothing
endfunction
function h3r takes nothing returns boolean
set h6e=O2x()
set h7e=XBx("ArcaneAttractor_Init: set ArcaneAttractor.SUMMON_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function ArcaneAttractor.Event_Summon_Destroy)",EP,pI,function hWr)
set Hee=XLx(function hyr)
call meo(g3v,XBx("ArcaneAttractor_Init: call ArcaneAttractor.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ArcaneAttractor.Event_SpellEffect))",ah,pI,function h1r))
call h2r()
return true
endfunction
function h4r takes nothing returns boolean
call FOr(function h3r,"ArcaneAttractor_Init")
return true
endfunction
function h5r takes nothing returns boolean
set HRe[1]=0
set HRe[2]=0
set HRe[3]=0
set HIe[1]=60
set HIe[2]=60
set HIe[3]=60
set HAe[1]=3
set HAe[2]=4
set HAe[3]=5
set HNe[1]=1
set HNe[2]=2
set HNe[3]=3
set Hbe[1]='d'
set Hbe[2]=$AF
set Hbe[3]=$FA
return true
endfunction
function h6r takes nothing returns boolean
set HBe[2]=hGo('uAW2')
call hho(((HBe[2])),Apv,(INv))
set Tj[(HBe[2])]=((1.375)*1.)
call hHo(HBe[2],$96,'x',$FF,$FF)
set Nav[(HBe[2])]=((60)*1.)
set Ntv[(HBe[2])]=((60)*1.)
call HMo(HBe[2],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","hand left",Bi)
call HMo(HBe[2],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","hand right",Bi)
call HMo(HBe[2],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","foot left",Bi)
call HMo(HBe[2],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","foot right",Bi)
set Nlv[(HBe[2])]=((320)*1.)
set I3v[(HBe[2])]=((2)*1.)
set Axv[(HBe[2])]=(2)
set NJv[(HBe[2])]=((750)*1.)
set Njv[(HBe[2])]=((750)*1.)
set Nhv[(HBe[2])]=((0)*1.)
set NKv[(HBe[2])]=((300)*1.)
set Nkv[(HBe[2])]=((300)*1.)
set NHv[(HBe[2])]=((0)*1.)
set NIv[(HBe[2])]=(($578)*1.)
set NOv[(HBe[2])]=(($578)*1.)
set Ndv[(HBe[2])]=((80)*1.)
set ANv[(HBe[2])]=(gHv)
set Adv[(HBe[2])]=(('l')*1.)
set ADv[((HBe[2]))]=((1.*1./((1.35)*1.))*1.)
set Atv[(HBe[2])]=((.33)*1.)
set AQv[(HBe[2])]=((48)*1.)
set Asv[(HBe[2])]=((48)*1.)
set Auv[(HBe[2])]=(2)
set AWv[(HBe[2])]=($B)
set Azv[(HBe[2])]=(0)
set Aqv[(HBe[2])]=((33)*1.)
return true
endfunction
function h7r takes nothing returns boolean
call LZx('AArw',false)
set Hce=Lzo('AArw')
set G6[(Hce)]=(c6)
set j6[(Hce)]=(3)
set sH[(Hce)]=("Arctic Wolf")
set Ih[(Hce)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D009E)))),(((Oj))))))
set x6v[(Hce)]=(2)
set xzv[(Hce)]=("spell")
call LZo((Hce),u6v+(1),((300)*1.))
call LZo((Hce),fH+(1),((60)*1.))
call LZo((Hce),QH+(1),(($96)*1.))
call LZo((Hce),Lvv+(1),((750)*1.))
call LZo((Hce),u6v+(2),((300)*1.))
call LZo((Hce),fH+(2),((60)*1.))
call LZo((Hce),QH+(2),(($96)*1.))
call LZo((Hce),Lvv+(2),((750)*1.))
call LZo((Hce),u6v+(3),((300)*1.))
call LZo((Hce),fH+(3),((60)*1.))
call LZo((Hce),QH+(3),(($96)*1.))
call LZo((Hce),Lvv+(3),((750)*1.))
set Mnv[(Hce)]=("ReplaceableTextures\\CommandButtons\\BTNWolf.blp")
call ccr(Hce,'FAW0',3,'VAW0','LPAW','LRAW')
return true
endfunction
function h8r takes nothing returns boolean
set HBe[1]=hGo('uArW')
call hho(((HBe[1])),Apv,(INv))
set Tj[(HBe[1])]=((1.25)*1.)
call hHo(HBe[1],$96,'x',$FF,$C8)
set Nav[(HBe[1])]=((60)*1.)
set Ntv[(HBe[1])]=((60)*1.)
call HMo(HBe[1],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","hand left",Bi)
call HMo(HBe[1],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","hand right",Bi)
call HMo(HBe[1],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","foot left",Bi)
call HMo(HBe[1],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","foot right",Bi)
set Nlv[(HBe[1])]=((320)*1.)
set I3v[(HBe[1])]=((2)*1.)
set Axv[(HBe[1])]=(2)
set NJv[(HBe[1])]=((750)*1.)
set Njv[(HBe[1])]=((750)*1.)
set Nhv[(HBe[1])]=((0)*1.)
set NKv[(HBe[1])]=((300)*1.)
set Nkv[(HBe[1])]=((300)*1.)
set NHv[(HBe[1])]=((0)*1.)
set NIv[(HBe[1])]=(($578)*1.)
set NOv[(HBe[1])]=(($578)*1.)
set Ndv[(HBe[1])]=((50)*1.)
set ANv[(HBe[1])]=(gHv)
set Adv[(HBe[1])]=(('l')*1.)
set ADv[((HBe[1]))]=((1.*1./((1.35)*1.))*1.)
set Atv[(HBe[1])]=((.33)*1.)
set AQv[(HBe[1])]=((30)*1.)
set Asv[(HBe[1])]=((30)*1.)
set Auv[(HBe[1])]=(2)
set AWv[(HBe[1])]=(9)
set Azv[(HBe[1])]=(0)
set Aqv[(HBe[1])]=((33)*1.)
return true
endfunction
function h9r takes nothing returns boolean
set HBe[3]=hGo('uAW3')
call hho(((HBe[3])),Apv,(INv))
set Tj[(HBe[3])]=((1.5)*1.)
call hHo(HBe[3],$96,'x',$FF,$FF)
set Nav[(HBe[3])]=((60)*1.)
set Ntv[(HBe[3])]=((60)*1.)
call HMo(HBe[3],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","hand left",Bi)
call HMo(HBe[3],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","hand right",Bi)
call HMo(HBe[3],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","foot left",Bi)
call HMo(HBe[3],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","foot right",Bi)
set Nlv[(HBe[3])]=((320)*1.)
set I3v[(HBe[3])]=((2)*1.)
set Axv[(HBe[3])]=(2)
set NJv[(HBe[3])]=((750)*1.)
set Njv[(HBe[3])]=((750)*1.)
set Nhv[(HBe[3])]=((0)*1.)
set NKv[(HBe[3])]=((300)*1.)
set Nkv[(HBe[3])]=((300)*1.)
set NHv[(HBe[3])]=((0)*1.)
set NIv[(HBe[3])]=(($578)*1.)
set NOv[(HBe[3])]=(($578)*1.)
set Ndv[(HBe[3])]=(('n')*1.)
set ANv[(HBe[3])]=(gHv)
set Adv[(HBe[3])]=(('l')*1.)
set ADv[((HBe[3]))]=((1.*1./((1.35)*1.))*1.)
set Atv[(HBe[3])]=((.33)*1.)
set AQv[(HBe[3])]=((70)*1.)
set Asv[(HBe[3])]=((70)*1.)
set Auv[(HBe[3])]=(2)
set AWv[(HBe[3])]=(22)
set Azv[(HBe[3])]=(0)
set Aqv[(HBe[3])]=((33)*1.)
return true
endfunction
function Hvr takes nothing returns boolean
call VRx(ea,(function h5r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcticWolf.page\\ArcticWolf.struct\\obj_this_wc3obj.j"))
call VRx(Sa,(function h6r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcticWolf.page\\ArcticWolf.struct\\obj_summonUnitType[2]_wc3unit.j"))
call VRx(qa,(function h7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcticWolf.page\\ArcticWolf.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Sa,(function h8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcticWolf.page\\ArcticWolf.struct\\obj_summonUnitType[1]_wc3unit.j"))
call VRx(Sa,(function h9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcticWolf.page\\ArcticWolf.struct\\obj_summonUnitType[3]_wc3unit.j"))
return true
endfunction
function Her takes nothing returns boolean
set HCe=Vnx(Hde)
return true
endfunction
function Hxr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function Hor takes nothing returns boolean
local integer Ixx=jFx()
if(I5x((OPe),Rb,(Ixx)))then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function Hrr takes integer oqx returns integer
set Hle[oqx]=true
set HLe[oqx]=false
call rax(HCe)
return oqx
endfunction
function Hir takes nothing returns integer
local integer oqx
if(Hje==8190)then
call oYx("ArcticWolf_Allocation_allocCustom","call DebugEx(ArcticWolf.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Hde+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(HJe[(w)]==w)then
set Hke=Hke+1
set oqx=Hke
else
set oqx=HJe[(w)]
set HJe[(w)]=HJe[HJe[(w)]]
endif
set HJe[oqx]=Z
set HKe[oqx]=1
call Hrr(oqx)
return oqx
endfunction
function Har takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local real O1o=Hpe[oqx]
local integer CMx=HPe[oqx]
local real NIo=Hze[oqx]
local integer HOx=Hqe[oqx]
local integer Q7o=HYe[oqx]
local real x=(oJ[(HOx)])
local real y=(nJ[(HOx)])
local integer Ixx
local integer rwx
local real gwr
set Hf=(ze[(CMx)])
set OPe=Q7o
call Nio(HDe,x,y,O1o,Hhe)
set Ixx=Nao(HDe)
if(Ixx!=w)then
set rwx=HUe[oqx]
set gwr=Hwe[oqx]
loop
call NIx((Ixx),(Xsv),(rwx),w,((gwr)*1.))
call dpx(Q7o,Ixx)
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
set Ixx=Nao(HDe)
exitwhen(Ixx==w)
endloop
endif
endfunction
function Hnr takes integer oqx,real x,real y returns nothing
call QZo(oqx,(oJ[(oqx)])+x,(nJ[(oqx)])+y)
endfunction
function HVr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
call Hnr(Hqe[oqx],H0e[oqx],H1e[oqx])
endfunction
function HEr takes integer oqx returns nothing
set Hle[oqx]=false
call rgx(HCe)
endfunction
function HXr takes integer oqx returns nothing
if(HKe[oqx]>0)then
return
endif
if(HJe[oqx]!=Z)then
call oYx("ArcticWolf_Allocation_deallocCustom_confirm","call DebugEx(ArcticWolf.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Hde+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set HJe[oqx]=HJe[(w)]
set HJe[(w)]=oqx
call HEr(oqx)
endfunction
function HOr takes integer oqx returns nothing
set HKe[oqx]=HKe[oqx]-1
call HXr(oqx)
endfunction
function HRr takes real x,real y,real O1o,integer CMx,real NIo returns nothing
local integer Ixx
call mHo(x,y,H3e,ri)
set Hf=(ze[(CMx)])
call Nio(HDe,x,y,O1o,Hfe)
set Ixx=Nao(HDe)
if(Ixx!=w)then
loop
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
set Ixx=Nao(HDe)
exitwhen(Ixx==w)
endloop
endif
endfunction
function HIr takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local real N8x=HMe[oqx]
local integer CMx=HPe[oqx]
local integer HOx=Hqe[oqx]
local integer HAr=HQe[oqx]
local real HNr=HTe[oqx]
local integer p0x=Hue[oqx]
local integer GVr=HWe[oqx]
local real Hbr=Hye[oqx]
local integer Q7o=HYe[oqx]
local integer HBr=HZe[oqx]
local integer Q6o=H_e[oqx]
local integer C0o=(ze[(CMx)])
local real x=(oJ[(HOx)])
local real y=(nJ[(HOx)])
local integer Gvr
call HOr((oqx))
call HXx(HAr)
call ijx(ibx)
call ijx(p0x)
call XYr(Q7o)
call ijx(Q6o)
call fDo(HOx,H2e)
call Qwo((HOx),-((.0)*1.),-((.0)*1.),-((.0)*1.),-((127.)*1.),((H2e)*1.))
call HRr(x,y,Hpe[oqx],CMx,HNr)
loop
exitwhen(GVr<1)
set Gvr=Uzo(HBr,C0o,x,y,N8x,Hbr)
set GVr=GVr-1
endloop
endfunction
function Hcr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real N8x=UCx(CMx,dix-wpo,dax-wPo)
local real ilx=jjx(dix-wpo,dax-wPo)*1./ Hge
local real HCr=(Cos(((((N8x)*1.))*1.)))
local real Hdr=(Sin(((((N8x)*1.))*1.)))
local real XNr=wpo+HHe*HCr
local real Xbr=wPo+HHe*Hdr
local integer oqx=Hir()
local integer HOx=mcx('qArW',XNr,Xbr,XYx(XNr,Xbr)+Hme,N8x)
local integer ibx=inx()
local integer p0x=inx()
local integer Q6o=inx()
set HMe[oqx]=N8x
set Hpe[oqx]=(Cpx((Hce),u6v+(rwx)))
set HPe[oqx]=CMx
set Hqe[oqx]=HOx
set HQe[oqx]=sao(HOx,Hse,HSe,Bi)
set Hte[oqx]=ibx
set HTe[oqx]=Hbe[rwx]
set Hue[oqx]=p0x
set HUe[oqx]=rwx
set Hwe[oqx]=HAe[rwx]
set HWe[oqx]=HNe[rwx]
set Hye[oqx]=HIe[rwx]
set HYe[oqx]=JIx("ArcticWolf_Event_SpellEffect: set this.targetGroup = UnitList.Create()")
set Hze[oqx]=HRe[rwx]
set HZe[oqx]=HBe[rwx]
set H_e[oqx]=Q6o
set H0e[oqx]=HFe*HCr
set H1e[oqx]=HFe*Hdr
set ge[(ibx)]=(oqx)
set ge[(p0x)]=(oqx)
set ge[(Q6o)]=(oqx)
call SetUnitAnimationByIndex(zj[((HOx))],(2))
call mbx(HOx,2.)
call mBx(HOx,255.,255.,255.,127.)
call icx(p0x,.25,true,function Har)
call icx(Q6o,HGe,true,function HVr)
call icx(ibx,ilx,false,function HIr)
return true
endfunction
function HDr takes nothing returns boolean
set HDe=O2x()
set Hfe=XLx(function Hxr)
set HFe=Hge*HGe
set Hhe=XLx(function Hor)
call meo(Hce,XBx("ArcticWolf_Init: call ArcticWolf.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ArcticWolf.Event_SpellEffect))",ah,pI,function Hcr))
return true
endfunction
function Hfr takes nothing returns boolean
call FOr(function HDr,"ArcticWolf_Init")
return true
endfunction
function HFr takes nothing returns boolean
set H4e=lQx(H5e+" (dummyBuff)")
call lux(H4e,"BoulderCrash_page\\BoulderCrash_struct\\Visuals\\Area2.mdx","origin",ri)
return true
endfunction
function Hgr takes nothing returns boolean
call VRx(Ma,(function HFr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\BoulderCrash.page\\BoulderCrash.struct\\Visuals\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function HGr takes nothing returns boolean
set H6e=Vnx(H5e)
return true
endfunction
function Hhr takes nothing returns boolean
set H7e=lQx(H8e+" (dummyBuff)")
return true
endfunction
function HHr takes nothing returns boolean
call LZx('ABoC',false)
set hbv=Lzo('ABoC')
set G6[(hbv)]=(C6)
set j6[(hbv)]=(3)
set sH[(hbv)]=("Boulder Crash")
set Ih[(hbv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00FD)))),(((Oj))))))
set x6v[(hbv)]=(0)
set xzv[(hbv)]=("morph")
call LZo((hbv),u6v+(1),((450)*1.))
call LZo((hbv),BH+(1),(($F)*1.))
call LZo((hbv),fH+(1),((90)*1.))
call LZo((hbv),QH+(1),(($91)*1.))
call LZo((hbv),Lvv+(1),((750)*1.))
call LZo((hbv),u6v+(2),((600)*1.))
call LZo((hbv),BH+(2),(($F)*1.))
call LZo((hbv),fH+(2),((90)*1.))
call LZo((hbv),QH+(2),(($D2)*1.))
call LZo((hbv),Lvv+(2),((750)*1.))
call LZo((hbv),u6v+(3),((850)*1.))
call LZo((hbv),BH+(3),(($F)*1.))
call LZo((hbv),fH+(3),((90)*1.))
call LZo((hbv),QH+(3),((275)*1.))
call LZo((hbv),Lvv+(3),((750)*1.))
set Mnv[(hbv)]=("ReplaceableTextures\\CommandButtons\\BTNDizzy.blp")
call ccr(hbv,'FBC0',3,'VBC0','LPBC','LRBC')
set H9e[1]=40
set H9e[2]=60
set H9e[3]=80
set jve[1]=50
set jve[2]=75
set jve[3]='d'
return true
endfunction
function Hjr takes nothing returns boolean
call VRx(Ma,(function Hhr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\BoulderCrash.page\\BoulderCrash.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function HHr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\BoulderCrash.page\\BoulderCrash.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function HJr takes nothing returns boolean
set jee=Vnx(H8e)
return true
endfunction
function Hkr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function HKr takes integer oqx,real NJx,real N8x,real ilx returns nothing
call RGr(oqx,NJx*(Cos(((((N8x)*1.))*1.))),NJx*(Sin(((((N8x)*1.))*1.))),.0,ilx)
endfunction
function Hlr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=oqx
local integer rwx=jie[oqx]
local real O1o=(Cpx((hbv),u6v+(rwx)))
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real djr=dvx(CMx,true)
local real HLr=djr
local integer Ixx
local real NIo
local real d
local real dJr
local real Hmr
set Hf=(ze[(CMx)])
call Nio(jxe,wpo,wPo,O1o,joe)
set Ixx=Nao(jxe)
if(Ixx!=w)then
set NIo=jne[rwx]
loop
set d=jjx((GetUnitX(C[((Ixx))]))-wpo,(GetUnitY(C[((Ixx))]))-wPo)
set dJr=dBr(djr,jVe,O1o,jEe,d)
set Hmr=NHx(d-HLr,jve[rwx],.0)
call HKr(Ixx,jve[rwx],(Atan2(((wPo-(GetUnitY(C[((Ixx))])))*1.),((wpo-(GetUnitX(C[((Ixx))])))*1.))),Hmr)
call nJo((CMx),(Ixx),((NIo*dJr)*1.),(true),(false))
set Ixx=Nao(jxe)
exitwhen(Ixx==w)
endloop
endif
endfunction
function HMr takes integer oqx,integer CMx,integer rwx returns nothing
call DSx((CMx),(H4e),(rwx),w)
endfunction
function Hpr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=inx()
set jre[oqx]=p0x
set jie[oqx]=rwx
set ge[(p0x)]=(oqx)
call icx(p0x,jae,true,function Hlr)
call HMr((w),Ixx,rwx)
return true
endfunction
function HPr takes integer oqx,integer CMx returns nothing
call Ayx(CMx,H4e)
endfunction
function Hqr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=jre[oqx]
call ijx(p0x)
call HPr((w),Ixx)
return true
endfunction
function HQr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),H7e)
return true
endfunction
function Hsr takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(H7e),((Mv[(rdx)])),w)
return true
endfunction
function HSr takes integer oqx returns boolean
set ay=ay+1
set iy[ay]=oqx
set ry[oqx]=ay+1
return(ay==0)
endfunction
function Htr takes nothing returns nothing
local integer olx=ay
local integer oqx
local real C6x
local real C7x
local real Mqo
local integer Ixx
local real D7x
loop
set oqx=iy[olx]
set C6x=jIe[oqx]
set C7x=jAe[oqx]
set Mqo=jNe[oqx]
set Ixx=Vy[oqx]
if jbe[oqx]then
set C6x=C6x+M7o(Ixx,false)
set C7x=C7x+M8o(Ixx,false)
set Mqo=Mqo+OLx(Ixx,false)
endif
if jBe[oqx]then
set D7x=(ob[(Ixx)])
set C6x=C6x*D7x
set C7x=C7x*D7x
set Mqo=Mqo*D7x
endif
call Mko((oqx),DPx(Ixx)+C6x,DQx(Ixx)+C7x,fwx(Ixx)+Mqo)
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function HTr takes integer oqx,integer Ixx,boolean Lso,boolean Omx,real C6x,real C7x,real Mqo returns nothing
set jIe[oqx]=C6x
set jAe[oqx]=C7x
set jNe[oqx]=Mqo
set Vy[oqx]=Ixx
set jbe[oqx]=Lso
set jBe[oqx]=Omx
call Mxx((oqx),ey)
if HSr(oqx)then
call icx(ny,jce,true,function Htr)
endif
endfunction
function Hur takes nothing returns nothing
local integer oqx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
call TimerStart(Oe[oqx],(GetRandomReal((((jDe[(oqx)]))*1.),(((jde[(oqx)]))*1.))),false,function Hur)
call rcx((jCe[(oqx)]))
endfunction
function HUr takes integer oqx,real Hwr,real HWr,code iDx returns nothing
local real iCx=(GetRandomReal(((Hwr)*1.),((HWr)*1.)))
set jCe[(oqx)]=(XHx(iDx))
set Je[(oqx)]=((GetHandleId(Condition((iDx)))))
set Be[(oqx)]=((LoadStr(j,(GetHandleId(Condition(((iDx))))),0)))
set ce[(oqx)]=((iCx)*1.)
set jde[(oqx)]=((HWr)*1.)
set jDe[(oqx)]=((Hwr)*1.)
call TimerStart(Oe[oqx],iCx,false,function Hur)
call iBx(oqx)
endfunction
function Hyr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
call Mdo(MFo)
return true
endfunction
function HYr takes integer oqx,real o2x returns nothing
set mhv[oqx]=o2x
set mHv[oqx]=true
set mjv[oqx]=o2x*o2x
endfunction
function Hzr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=oqx
local integer rwx=jRe[oqx]
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real Vlr=fwx(CMx)
local real Nkx=S2R(C9x("acc","200."))
local real N8x=(GetRandomReal(((.0)*1.),((df)*1.)))
local real blr=(Cpx((hbv),u6v+(rwx)))*S2R(C9x("distFactor","0.75"))
local real I1o=(GetRandomReal(((330.)*1.),((520.)*1.)))
local real D7x=(GetRandomReal(((.5)*1.),((1.)*1.)))
local real NJx=S2R(C9x("speed","300."))
local real ilx=NHx(blr,NJx,Nkx)
local integer MFo=Mvo()
local integer HOx
call m1o(MFo,Nkx)
set mCv[(MFo)]=XHx((function Hyr))
call m8o(MFo,NJx)
call HYr(MFo,100.)
call Mto(MFo,wpo+blr*(Cos(((((N8x)*1.))*1.))),wPo+blr*(Sin(((((N8x)*1.))*1.))),Vlr+I1o)
call o6r(MFo,wpo,wPo,Vlr)
call Ffr(MFo,Kf)
if((GetRandomInt((0),(1)))==0)then
set HOx=Mro(MFo,'qBoC',D7x)
else
set HOx=Mro(MFo,'qBCS',D7x)
endif
set mNv[(MFo)]=((64.)*1.)
call mBx(HOx,255.,255.,255.,S2R(C9x("alpha","200.")))
call Qwo((HOx),-((0)*1.),-((0)*1.),-((0)*1.),-(((py[(HOx)]))*1.),((ilx*S2R(C9x("durFactor","0.9")))*1.))
endfunction
function HZr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer H_r=mcx('qBCA',(GetUnitX(C[((Ixx))])),(GetUnitY(C[((Ixx))])),fwx(Ixx),(GetUnitFacing(C[((Ixx))])*bh))
local integer p0x=inx()
set jXe[oqx]=H_r
set jOe[oqx]=p0x
set jRe[oqx]=rwx
set ge[(p0x)]=(oqx)
call HTr(H_r,Ixx,false,false,.0,.0,.0)
call HUr(p0x,jfe,jFe,function Hzr)
return true
endfunction
function H0r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer H_r=jXe[oqx]
local integer p0x=jOe[oqx]
call Mfx(H_r)
call ijx(p0x)
return true
endfunction
function H1r takes nothing returns nothing
call l9x(H4e,XBx("FolderBoulderCrash_StructVisuals_Init: call FolderBoulderCrash_StructVisuals.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderBoulderCrash_StructVisuals.Event_BuffGain))",Bd,pI,function HZr))
call l9x(H4e,XBx("FolderBoulderCrash_StructVisuals_Init: call FolderBoulderCrash_StructVisuals.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderBoulderCrash_StructVisuals.Event_BuffLose))",Jc,pI,function H0r))
endfunction
function H2r takes nothing returns boolean
local integer rwx
set jxe=O2x()
set joe=XLx(function Hkr)
call l9x(H7e,XBx("BoulderCrash_Init: call BoulderCrash.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BoulderCrash.Event_BuffGain))",Bd,pI,function Hpr))
call l9x(H7e,XBx("BoulderCrash_Init: call BoulderCrash.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BoulderCrash.Event_BuffLose))",Jc,pI,function Hqr))
call meo(hbv,XBx("BoulderCrash_Init: call BoulderCrash.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BoulderCrash.Event_EndCast))",oev,pI,function HQr))
call meo(hbv,XBx("BoulderCrash_Init: call BoulderCrash.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BoulderCrash.Event_SpellEffect))",ah,pI,function Hsr))
set rwx=(j6[(hbv)])
loop
exitwhen(rwx<1)
set jne[rwx]=H9e[rwx]*jae
set rwx=rwx-1
endloop
call H1r()
return true
endfunction
function H3r takes nothing returns boolean
call FOr(function H2r,"BoulderCrash_Init")
return true
endfunction
function H4r takes nothing returns boolean
set jge=lQx(jGe+" (eclipseBuff)")
set qc[(jge)]=(true)
set qU[(jge)]=(true)
return true
endfunction
function H5r takes nothing returns boolean
set jhe=Vbx("OCoT")
return true
endfunction
function H6r takes nothing returns boolean
set jHe=Vbx("OCon")
return true
endfunction
function H7r takes nothing returns boolean
call LZx('ACon',false)
set jje=Lzo('ACon')
set G6[(jje)]=(i6)
set j6[(jje)]=(6)
set sH[(jje)]=("Conflagration")
set Ih[(jje)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0264)))),(((Oj))))))
set x6v[(jje)]=(2)
set xzv[(jje)]=("spell")
call LZo((jje),fH+(1),((9)*1.))
call LZo((jje),QH+(1),(('}')*1.))
call LZo((jje),Lvv+(1),((500)*1.))
call LZo((jje),fH+(2),((9)*1.))
call LZo((jje),QH+(2),(($96)*1.))
call LZo((jje),Lvv+(2),((550)*1.))
call LZo((jje),fH+(3),((9)*1.))
call LZo((jje),QH+(3),(($AF)*1.))
call LZo((jje),Lvv+(3),((600)*1.))
call LZo((jje),fH+(4),((9)*1.))
call LZo((jje),QH+(4),(($C8)*1.))
call LZo((jje),Lvv+(4),((650)*1.))
call LZo((jje),fH+(5),((9)*1.))
call LZo((jje),QH+(5),(($E1)*1.))
call LZo((jje),Lvv+(5),((700)*1.))
call LZo((jje),fH+(6),((9)*1.))
call LZo((jje),QH+(6),(($FA)*1.))
call LZo((jje),Lvv+(6),((750)*1.))
set Mnv[(jje)]=("ReplaceableTextures\\CommandButtons\\BTNWallOfFire.blp")
call ccr(jje,'FCo0',6,'VCo0','LPCo','LRCo')
set jJe[1]=400
set jJe[2]=425
set jJe[3]=450
set jJe[4]=475
set jJe[5]=500
set jJe[6]=525
set jke[1]=25
set jke[2]=35
set jke[3]=45
set jke[4]=55
set jke[5]=65
set jke[6]=75
set jKe[1]=6
set jKe[2]=7
set jKe[3]=8
set jKe[4]=9
set jKe[5]=$A
set jKe[6]=$B
set jle[1]=650
set jle[2]=650
set jle[3]=650
set jle[4]=650
set jle[5]=650
set jle[6]=650
set jLe[1]=3
set jLe[2]=3.5
set jLe[3]=4
set jLe[4]=4.5
set jLe[5]=5
set jLe[6]=5.5
return true
endfunction
function H8r takes nothing returns boolean
set jme=lQx(jGe+" (ignitionBuff)")
set qc[(jme)]=(true)
set qU[(jme)]=(true)
return true
endfunction
function H9r takes nothing returns boolean
call VRx(Ma,(function H4r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Conflagration.page\\Conflagration.struct\\obj_eclipseBuff_wc3buff.j"))
call VRx(Ha,(function H5r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Conflagration.page\\Conflagration.struct\\obj_totalBolt_wc3bolt.j"))
call VRx(Ha,(function H6r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Conflagration.page\\Conflagration.struct\\obj_dummyBolt_wc3bolt.j"))
call VRx(qa,(function H7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Conflagration.page\\Conflagration.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function H8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Conflagration.page\\Conflagration.struct\\obj_ignitionBuff_wc3buff.j"))
return true
endfunction
function jvr takes nothing returns boolean
set jMe=Vnx(jGe)
return true
endfunction
function jer takes nothing returns boolean
local integer Ixx=jFx()
if(I5x((OPe),Rb,(Ixx)))then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function jxr takes integer oqx returns integer
set jte[oqx]=true
set jTe[oqx]=false
call rax(jMe)
return oqx
endfunction
function jor takes nothing returns integer
local integer oqx
if(jqe==8190)then
call oYx("Conflagration_Allocation_allocCustom","call DebugEx(Conflagration.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",jGe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(jQe[(w)]==w)then
set jse=jse+1
set oqx=jse
else
set oqx=jQe[(w)]
set jQe[(w)]=jQe[jQe[(w)]]
endif
set jQe[oqx]=Z
set jSe[oqx]=1
call jxr(oqx)
return oqx
endfunction
function jrr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local real N8x=jue[oqx]
local integer CMx=jUe[oqx]
local integer HOx=jWe[oqx]
local real CWr=jYe[oqx]
local real rmr=j_e[oqx]
local real Cyr=jye[oqx]
local integer Q7o=j0e[oqx]
local real oUx=Cyr+CWr
local real x=(oJ[(HOx)])+j2e[oqx]
local real y=(nJ[(HOx)])+j3e[oqx]
local real jMx=Jxe+(Joe-Jxe)*(oUx*1./ rmr)
local real jmx=Jxe+(Joe-Jxe)*(Cyr*1./ rmr)
local real jir=x+jmx*(Cos(((((N8x+b6v)*1.))*1.)))
local real jar=y+jmx*(Sin(((((N8x+b6v)*1.))*1.)))
local real jnr=x+jmx*(Cos(((((N8x-b6v)*1.))*1.)))
local real jVr=y+jmx*(Sin(((((N8x-b6v)*1.))*1.)))
local real jEr=x+CWr*(Cos(((((N8x)*1.))*1.)))
local real jXr=y+CWr*(Sin(((((N8x)*1.))*1.)))
local real jOr=jEr+jMx*(Cos(((((N8x+b6v)*1.))*1.)))
local real jRr=jXr+jMx*(Sin(((((N8x+b6v)*1.))*1.)))
local real jIr=jEr+jMx*(Cos(((((N8x-b6v)*1.))*1.)))
local real jAr=jXr+jMx*(Sin(((((N8x-b6v)*1.))*1.)))
local integer Ixx
local real NIo
local integer rwx
local real jNr
call cfo(j4e[oqx],jir,jar,XYx(jir,jar),jOr,jRr,XYx(jOr,jRr))
call cfo(j5e[oqx],jnr,jVr,XYx(jnr,jVr),jIr,jAr,XYx(jIr,jAr))
call cfo(j6e[oqx],jir,jar,XYx(jir,jar),jnr,jVr,XYx(jnr,jVr))
call cfo(j7e[oqx],jOr,jRr,XYx(jOr,jRr),jIr,jAr,XYx(jIr,jAr))
set jye[oqx]=oUx
call QZo(HOx,x,y)
set Hf=(ze[(CMx)])
set OPe=Q7o
call NMr(jpe,x,y,CWr,N8x,jmx,jMx,jPe)
set Ixx=Nao(jpe)
if(Ixx!=w)then
set NIo=jwe[oqx]
set rwx=jZe[oqx]
loop
call dpx(Q7o,Ixx)
if I6x(Ixx,yd)then
set jNr=jLe[rwx]
else
set jNr=jKe[rwx]
endif
call NIx((Ixx),(jge),(rwx),w,((jNr)*1.))
call NIx(Ixx,jme,rwx,CMx,jNr)
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
set Ixx=Nao(jpe)
exitwhen(Ixx==w)
endloop
endif
endfunction
function jbr takes integer oqx returns nothing
set jte[oqx]=false
call rgx(jMe)
endfunction
function jBr takes integer oqx returns nothing
if(jSe[oqx]>0)then
return
endif
if(jQe[oqx]!=Z)then
call oYx("Conflagration_Allocation_deallocCustom_confirm","call DebugEx(Conflagration.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",jGe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set jQe[oqx]=jQe[(w)]
set jQe[(w)]=oqx
call jbr(oqx)
endfunction
function jcr takes integer oqx returns nothing
set jSe[oqx]=jSe[oqx]-1
call jBr(oqx)
endfunction
function jCr takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local integer HOx=jWe[oqx]
local integer Q7o=j0e[oqx]
local integer Q6o=j1e[oqx]
call Mfx(HOx)
call ijx(ibx)
call XYr(Q7o)
call ijx(Q6o)
call Kzx(j4e[oqx])
call Kzx(j5e[oqx])
call Kzx(j6e[oqx])
call Kzx(j7e[oqx])
call Kzx(j8e[oqx])
call Kzx(j9e[oqx])
call Kzx(Jve[oqx])
call Kzx(Jee[oqx])
call jcr((oqx))
endfunction
function jdr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real D7x=(ob[(CMx)])
local real dX=dix-wpo
local real dY=dax-wPo
local real N8x=UCx(CMx,dX,dY)
local real rmr=jJe[rwx]*D7x
local real n_x=(dvx(CMx,false)+.0)*D7x
local real x=wpo+n_x*(Cos(((((N8x)*1.))*1.)))
local real y=wPo+n_x*(Sin(((((N8x)*1.))*1.)))
local real d=jjx(dX,dY)
local integer oqx=jor()
local integer ibx=inx()
local integer Cxr=Qax("/",true,false,false,$A,$A,h5)
local integer Q6o=inx()
local integer jDr=cBo(jhe)
local integer jfr=cBo(jhe)
local integer jFr=cBo(jhe)
local integer jgr=cBo(jhe)
local real jmx
local real jMx
local real jir
local real jar
local real jnr
local real jVr
local real jEr
local real jXr
local real jOr
local real jRr
local real jIr
local real jAr
local real ilx
set jue[oqx]=N8x
set jUe[oqx]=CMx
set jwe[oqx]=jke[rwx]
set jWe[oqx]=mcx('qCon',x,y,Olx(CMx,x,y)+OLx(CMx,true),N8x)
set jye[oqx]=.0
set jYe[oqx]=jze[rwx]
set jZe[oqx]=rwx
set j_e[oqx]=rmr
set j0e[oqx]=JIx("Conflagration_Event_SpellEffect: set this.targetGroup = UnitList.Create()")
set j1e[oqx]=Q6o
set j2e[oqx]=dX*1./ d*jze[rwx]
set j3e[oqx]=dY*1./ d*jze[rwx]
set ge[(ibx)]=(oqx)
set ge[(Q6o)]=(oqx)
set j4e[oqx]=cBo(jHe)
set j5e[oqx]=cBo(jHe)
set j6e[oqx]=cBo(jHe)
set j7e[oqx]=cBo(jHe)
set j8e[oqx]=jDr
set j9e[oqx]=jfr
set Jve[oqx]=jFr
set Jee[oqx]=jgr
set jmx=Jxe
set jMx=Joe
set jir=x+jmx*(Cos(((((N8x+b6v)*1.))*1.)))
set jar=y+jmx*(Sin(((((N8x+b6v)*1.))*1.)))
set jnr=x+jmx*(Cos(((((N8x-b6v)*1.))*1.)))
set jVr=y+jmx*(Sin(((((N8x-b6v)*1.))*1.)))
set jEr=x+rmr*(Cos(((((N8x)*1.))*1.)))
set jXr=y+rmr*(Sin(((((N8x)*1.))*1.)))
set jOr=jEr+jMx*(Cos(((((N8x+b6v)*1.))*1.)))
set jRr=jXr+jMx*(Sin(((((N8x+b6v)*1.))*1.)))
set jIr=jEr+jMx*(Cos(((((N8x-b6v)*1.))*1.)))
set jAr=jXr+jMx*(Sin(((((N8x-b6v)*1.))*1.)))
call cfo(jDr,jir,jar,XYx(jir,jar),jOr,jRr,XYx(jOr,jRr))
call cfo(jfr,jnr,jVr,XYx(jnr,jVr),jIr,jAr,XYx(jIr,jAr))
call cfo(jFr,jir,jar,XYx(jir,jar),jnr,jVr,XYx(jnr,jVr))
call cfo(jgr,jOr,jRr,XYx(jOr,jRr),jIr,jAr,XYx(jIr,jAr))
set ilx=NHx(rmr-jYe[oqx],jle[rwx],.0)
call SetUnitTimeScale(zj[(jWe[oqx])],((.5*1./ ilx)*1.))
call mbx(jWe[oqx],D7x)
call P5o(Cxr,x,y,XYx(x,y))
call R1x(Cxr,true)
call icx(Q6o,Jre,true,function jrr)
call icx(ibx,ilx,false,function jCr)
return true
endfunction
function jGr takes nothing returns boolean
local integer olx
set jpe=O2x()
set jPe=XLx(function jer)
call meo(jje,XBx("Conflagration_Init: call Conflagration.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Conflagration.Event_SpellEffect))",ah,pI,function jdr))
call W_x(ENv,jge)
call W_x(E5v,jme)
set olx=(j6[(jje)])
loop
set Jie[olx]=jJe[olx]*1./ jle[olx]
set jze[olx]=jle[olx]*Jre
set olx=olx-1
exitwhen(olx<1)
endloop
return true
endfunction
function jhr takes nothing returns boolean
call FOr(function jGr,"Conflagration_Init")
return true
endfunction
function jHr takes nothing returns boolean
call LZx('ACyR',false)
set Jae=Lzo('ACyR')
set G6[(Jae)]=(C6)
set j6[(Jae)]=(3)
set sH[(Jae)]=("Relocate")
set Ih[(Jae)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0085)))),(((Oj))))))
set x6v[(Jae)]=(2)
set xzv[(Jae)]=("spell")
call LZo((Jae),fH+(1),((0)*1.))
call LZo((Jae),QH+(1),((0)*1.))
call LZo((Jae),Lvv+(1),((99999)*1.))
call LZo((Jae),fH+(2),((0)*1.))
call LZo((Jae),QH+(2),((0)*1.))
call LZo((Jae),Lvv+(2),((99999)*1.))
set Mnv[(Jae)]=("ReplaceableTextures\\CommandButtons\\BTNUndeadUnLoad.blp")
call ccr(Jae,'FCR0',3,'VCR0','LPCR','LRCR')
return true
endfunction
function jjr takes nothing returns boolean
call VRx(qa,(function jHr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Cyclone.page\\Cyclone.struct\\Relocate\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function jJr takes nothing returns boolean
set Jne=Vnx(JVe)
return true
endfunction
function jkr takes nothing returns boolean
call LZx('ACyc',false)
set gzv=Lzo('ACyc')
set G6[(gzv)]=(C6)
set j6[(gzv)]=(3)
set sH[(gzv)]=("Cyclone")
set Ih[(gzv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D022D)))),(((Oj))))))
set x6v[(gzv)]=(2)
set xzv[(gzv)]=("spell")
call LZo((gzv),u6v+(1),((500)*1.))
call LZo((gzv),fH+(1),(('x')*1.))
call LZo((gzv),QH+(1),(($96)*1.))
call LZo((gzv),Lvv+(1),(($3E8)*1.))
call LZo((gzv),u6v+(2),((500)*1.))
call LZo((gzv),fH+(2),(('x')*1.))
call LZo((gzv),QH+(2),(($C8)*1.))
call LZo((gzv),Lvv+(2),(($3E8)*1.))
call LZo((gzv),u6v+(3),((500)*1.))
call LZo((gzv),fH+(3),(('x')*1.))
call LZo((gzv),QH+(3),(($FA)*1.))
call LZo((gzv),Lvv+(3),(($3E8)*1.))
set Mnv[(gzv)]=("ReplaceableTextures\\CommandButtons\\BTNTornado.blp")
call ccr(gzv,'FCy0',3,'VCy0','LPCy','LRCy')
set JEe[1]=40
set JEe[2]=40
set JEe[3]=40
set JXe[1]=$3E8
set JXe[2]=$3E8
set JXe[3]=$3E8
set JOe[1]=3
set JOe[2]=3
set JOe[3]=3
set JRe[1]=50
set JRe[2]=80
set JRe[3]='x'
return true
endfunction
function jKr takes nothing returns boolean
set JIe=hGo('uCyc')
call hho(((JIe)),Apv,(ICv))
set Tj[(JIe)]=((1)*1.)
call hHo(JIe,$FF,$FF,$FF,$FF)
set Nav[(JIe)]=(('d')*1.)
set Ntv[(JIe)]=(('d')*1.)
set Nlv[(JIe)]=((350)*1.)
set I3v[(JIe)]=((0)*1.)
set Axv[(JIe)]=(3)
set NJv[(JIe)]=(($C8)*1.)
set Njv[(JIe)]=(($C8)*1.)
set Nhv[(JIe)]=((0)*1.)
set NKv[(JIe)]=((0)*1.)
set Nkv[(JIe)]=((0)*1.)
set NHv[(JIe)]=((0)*1.)
set NIv[(JIe)]=((800)*1.)
set NOv[(JIe)]=((800)*1.)
set Ndv[(JIe)]=((0)*1.)
set AQv[(JIe)]=((0)*1.)
set Asv[(JIe)]=((0)*1.)
set Auv[(JIe)]=(0)
set AWv[(JIe)]=(0)
set Aqv[(JIe)]=((64)*1.)
call hLo((JIe),(gQv),1)
return true
endfunction
function jlr takes nothing returns boolean
call VRx(qa,(function jkr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Cyclone.page\\Cyclone.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Sa,(function jKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Cyclone.page\\Cyclone.struct\\obj_CycloneType_wc3unit.j"))
return true
endfunction
function jLr takes nothing returns boolean
set JAe=Vnx(JNe)
return true
endfunction
function jmr takes nothing returns boolean
local integer rdx=(bv)
local integer jMr=(Vv[(rdx)])
local integer CMx=JBe[(jMr)]
call Rmx(jMr,Jbe)
if rrx(CMx,Jce,jMr)then
endif
return true
endfunction
function jpr takes nothing returns boolean
local integer Ixx=jFx()
if(I5x((OPe),Rb,(Ixx)))then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function jPr takes integer oqx returns integer
set Jhe[oqx]=true
set JHe[oqx]=false
call rax(JAe)
return oqx
endfunction
function jqr takes nothing returns integer
local integer oqx
if(Jfe==8190)then
call oYx("Cyclone_Allocation_allocCustom","call DebugEx(Cyclone.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",JNe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(JFe[(w)]==w)then
set Jge=Jge+1
set oqx=Jge
else
set oqx=JFe[(w)]
set JFe[(w)]=JFe[JFe[(w)]]
endif
set JFe[oqx]=Z
set JGe[oqx]=1
call jPr(oqx)
return oqx
endfunction
function jQr takes integer oqx returns nothing
set Jhe[oqx]=false
call rgx(JAe)
endfunction
function jsr takes integer oqx returns nothing
if(JGe[oqx]>0)then
return
endif
if(JFe[oqx]!=Z)then
call oYx("Cyclone_Allocation_deallocCustom_confirm","call DebugEx(Cyclone.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",JNe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set JFe[oqx]=JFe[(w)]
set JFe[(w)]=oqx
call jQr(oqx)
endfunction
function jSr takes integer oqx returns nothing
set JGe[oqx]=JGe[oqx]-1
call jsr(oqx)
endfunction
function jtr takes integer CMx,integer jMr,integer rwx returns nothing
set JPe=CMx
call rzx((jMr),(Jqe),(rwx))
endfunction
function jTr takes integer CMx,integer rwx,real x,real y returns nothing
local integer jMr=Uzo(JIe,(ze[(CMx)]),x,y,Kf,JEe[rwx])
set JBe[(jMr)]=CMx
call I7x(jMr,Jbe)
if rtx(CMx,Jce,jMr)then
endif
call jtr(CMx,jMr,rwx)
endfunction
function jur takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=Jje[oqx]
local integer rwx=JKe[oqx]
local integer Q6o=JMe[oqx]
local real x=(mFv[(MFo)])
local real y=(mgv[(MFo)])
call jSr((oqx))
call Mdo(MFo)
call ijx(Q6o)
call jTr(CMx,rwx,x,y)
return true
endfunction
function jUr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=Jje[oqx]
local integer MFo=Jke[oqx]
local integer rwx=JKe[oqx]
local integer Q7o=Jle[oqx]
local real x=(mFv[(MFo)])
local real y=(mgv[(MFo)])
local integer Ixx
local real NIo
local real jwr
set OPe=Q7o
set Hf=(ze[(CMx)])
call Nio(JCe,(mFv[(MFo)]),(mgv[(MFo)]),(mNv[(MFo)]),Jde)
set Ixx=Nao(JCe)
if(Ixx!=w)then
set NIo=JJe[oqx]
set jwr=JOe[rwx]
loop
if not Lko(nXe,Ixx)then
call dpx(Q7o,Ixx)
call nJo((CMx),(Ixx),((NIo)*1.),(false),(false))
call NIx((((Ixx))),(Ehv),(1),w,((((jwr)*1.))*1.))
endif
set Ixx=Nao(JCe)
exitwhen(Ixx==w)
endloop
endif
endfunction
function jWr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real oUx=bJx(jjx(dax-wPo,dix-wpo),JDe,JXe[rwx])
local real N8x=UCx(CMx,dix-wpo,dax-wPo)
local integer oqx
local integer MFo
local integer Q6o
set dix=wpo+oUx*(Cos(((((N8x)*1.))*1.)))
set dax=wPo+oUx*(Sin(((((N8x)*1.))*1.)))
set oqx=jqr()
set MFo=Mvo()
set Q6o=inx()
set Jje[oqx]=CMx
set JJe[oqx]=JRe[rwx]
set Jke[oqx]=MFo
set JKe[oqx]=rwx
set Jle[oqx]=JIx("Cyclone_Event_SpellEffect: set this.targetGroup = UnitList.Create()")
set JLe[oqx]=dix
set Jme[oqx]=dax
set JMe[oqx]=Q6o
set ge[(Q6o)]=(oqx)
call m1o(MFo,.0)
set mNv[(MFo)]=((Jpe)*1.)
set mCv[(MFo)]=XHx((function jur))
set mWv[(MFo)]=(oqx)
call m8o(MFo,800)
call M9o(MFo,CMx)
call o6r(MFo,dix,dax,XYx(dix,dax)+60.)
call Ffr(MFo,Kf)
call Mro(MFo,'qCyc',.75)
call icx(Q6o,JQe,true,function jUr)
return true
endfunction
function jyr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local integer jMr=N3o(CMx,Jce)
call CAx(jMr,ch,dix,dax)
return true
endfunction
function jYr takes nothing returns boolean
set Jbe=XBx("Cyclone_Init: set Cyclone.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function Cyclone.Event_Destroy)",EP,pI,function jmr)
set JCe=O2x()
set Jde=XLx(function jpr)
call meo(gzv,XBx("Cyclone_Init: call Cyclone.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Cyclone.Event_SpellEffect))",ah,pI,function jWr))
call meo(Jae,XBx("FolderCyclone_StructRelocate_Init: call FolderCyclone_StructRelocate.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderCyclone_StructRelocate.Event_SpellEffect))",ah,pI,function jyr))
return true
endfunction
function jzr takes nothing returns boolean
call FOr(function jYr,"Cyclone_Init")
return true
endfunction
function jZr takes nothing returns boolean
set Jse=WTx('BCyT',"Cyclone - Churned",'bCyT')
set aev[(Jse)]=("ReplaceableTextures\\CommandButtons\\BTNCyclone.blp")
return true
endfunction
function j_r takes nothing returns boolean
call VRx(Ma,(function jZr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Cyclone.page\\Cyclone.struct\\WindDance.page\\WindDance.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function j0r takes nothing returns boolean
set JSe=Vnx(Jte)
return true
endfunction
function j1r takes nothing returns boolean
set JTe=WTx('BCyA',"Cyclone Aura",'bCyA')
set avv[(JTe)]=(true)
set aev[(JTe)]=("ReplaceableTextures\\CommandButtons\\BTNTornado.blp")
return true
endfunction
function j2r takes nothing returns boolean
set Jue[1]=20
set Jue[2]=30
set Jue[3]=40
return true
endfunction
function j3r takes nothing returns boolean
call LZx('AWiD',false)
set Jqe=Lzo('AWiD')
set j6[(Jqe)]=(3)
set sH[(Jqe)]=("Wind Dance")
set xzv[(Jqe)]=("spell")
set Mnv[(Jqe)]=("ReplaceableTextures\\CommandButtons\\PASBTNWindDance.blp")
return true
endfunction
function j4r takes nothing returns boolean
call VRx(Ma,(function j1r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Cyclone.page\\Cyclone.struct\\WindDance.page\\WindDance.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function j2r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Cyclone.page\\Cyclone.struct\\WindDance.page\\WindDance.struct\\obj_this_wc3obj.j"))
call VRx(qa,(function j3r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Cyclone.page\\Cyclone.struct\\WindDance.page\\WindDance.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function j5r takes nothing returns boolean
set JUe=Vnx(Jwe)
return true
endfunction
function j6r takes nothing returns boolean
call LZx('ADeS',false)
set Gcv=Lzo('ADeS')
set G6[(Gcv)]=(N6)
set j6[(Gcv)]=(6)
set sH[(Gcv)]=("Depriving Shock")
set Ih[(Gcv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0104)))),(((Oj))))))
set x6v[(Gcv)]=(4)
set xzv[(Gcv)]=("spell")
call LZo((Gcv),u6v+(1),(($96)*1.))
call LZo((Gcv),BH+(1),((2)*1.))
call LZo((Gcv),fH+(1),((4)*1.))
call LZo((Gcv),QH+(1),((30)*1.))
call LZo((Gcv),Lvv+(1),((575)*1.))
call LZo((Gcv),u6v+(2),(($AF)*1.))
call LZo((Gcv),BH+(2),((2)*1.))
call LZo((Gcv),fH+(2),((4)*1.))
call LZo((Gcv),QH+(2),((45)*1.))
call LZo((Gcv),Lvv+(2),((575)*1.))
call LZo((Gcv),u6v+(3),(($C8)*1.))
call LZo((Gcv),BH+(3),((2)*1.))
call LZo((Gcv),fH+(3),((4)*1.))
call LZo((Gcv),QH+(3),((60)*1.))
call LZo((Gcv),Lvv+(3),((575)*1.))
call LZo((Gcv),u6v+(4),(($E1)*1.))
call LZo((Gcv),BH+(4),((2)*1.))
call LZo((Gcv),fH+(4),((4)*1.))
call LZo((Gcv),QH+(4),((75)*1.))
call LZo((Gcv),Lvv+(4),((575)*1.))
call LZo((Gcv),u6v+(5),(($FA)*1.))
call LZo((Gcv),BH+(5),((2)*1.))
call LZo((Gcv),fH+(5),((4)*1.))
call LZo((Gcv),QH+(5),((90)*1.))
call LZo((Gcv),Lvv+(5),((575)*1.))
call LZo((Gcv),u6v+(6),((275)*1.))
call LZo((Gcv),BH+(6),((2)*1.))
call LZo((Gcv),fH+(6),((4)*1.))
call LZo((Gcv),QH+(6),(('i')*1.))
call LZo((Gcv),Lvv+(6),((575)*1.))
set Mnv[(Gcv)]=("ReplaceableTextures\\CommandButtons\\BTNRavenForm.blp")
call ccr(Gcv,'FDS0',6,'VDS0','LPDS','LRDS')
return true
endfunction
function j7r takes nothing returns boolean
set JWe=WTx('BDeS',"Revived",'bDeS')
set aev[(JWe)]=("ReplaceableTextures\\CommandButtons\\BTNAnimateDead.blp")
return true
endfunction
function j8r takes nothing returns boolean
set Jye=lQx(JYe+" (stunBuff)")
return true
endfunction
function j9r takes nothing returns boolean
set Jze=Vbx("ODeS")
return true
endfunction
function Jvr takes nothing returns boolean
set JZe[1]=25
set JZe[2]=25
set JZe[3]=25
set JZe[4]=25
set JZe[5]=25
set JZe[6]=25
set J_e[1]=.5
set J_e[2]=.5
set J_e[3]=.5
set J_e[4]=.5
set J_e[5]=.5
set J_e[6]=.5
set J0e[1]=40
set J0e[2]=60
set J0e[3]=80
set J0e[4]='d'
set J0e[5]='x'
set J0e[6]=$8C
set J1e[1]=65
set J1e[2]='d'
set J1e[3]=$8C
set J1e[4]=$B9
set J1e[5]=$EB
set J1e[6]=290
set J2e[1]=.75
set J2e[2]=.75
set J2e[3]=.75
set J2e[4]=.75
set J2e[5]=.75
set J2e[6]=.75
return true
endfunction
function Jer takes nothing returns boolean
call VRx(qa,(function j6r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\DeprivingShock.page\\DeprivingShock.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function j7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\DeprivingShock.page\\DeprivingShock.struct\\obj_summonBuff_wc3buff.j"))
call VRx(Ma,(function j8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\DeprivingShock.page\\DeprivingShock.struct\\obj_stunBuff_wc3buff.j"))
call VRx(Ha,(function j9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\DeprivingShock.page\\DeprivingShock.struct\\obj_bolt_wc3bolt.j"))
call VRx(ea,(function Jvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\DeprivingShock.page\\DeprivingShock.struct\\obj_this_wc3obj.j"))
return true
endfunction
function Jxr takes nothing returns boolean
set J3e=Vnx(JYe)
return true
endfunction
function Jor takes integer Ixx,integer C0o,integer rwx returns nothing
if not I6x(Ixx,sc)then
return
endif
call RUx((Abx((Ixx),(J8e),(J9e),(ri))))
call ahr(Ixx)
call DSx((Ixx),(JWe),(rwx),w)
call aNx(Ixx,C0o)
call UYo(Ixx,JZe[rwx])
set nFv[(Ixx)]=(kve)
call fhx(Ixx,-$80,-$80,-$80,0)
endfunction
function Jrr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer olx
local integer oqx
local integer CMx
call Rmx(Ixx,J4e)
call Rmx(Ixx,J5e)
set olx=CXx(Ixx,J6e)
loop
set oqx=COx(Ixx,J6e,olx)
set CMx=oqx
set J7e[oqx]=false
call rrx(Ixx,J6e,oqx)
call Jor(Ixx,(ze[(CMx)]),kee[oqx])
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function Jir takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer olx
local integer oqx
call Rmx(Ixx,J4e)
call Rmx(Ixx,J5e)
set olx=CXx(Ixx,J6e)
loop
set oqx=COx(Ixx,J6e,olx)
set J7e[oqx]=false
call rrx(Ixx,J6e,oqx)
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function Jar takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=oqx
local integer Ixx=kVe[oqx]
local real Ydo=itx(kxe[oqx],(LF[(Ixx)]))
call YBo(CMx,Ixx,Ydo)
call nJo((CMx),(Ixx),((kre[oqx]+Ydo*kie[oqx])*1.),(true),(false))
call mro(CMx,CMx,Ydo*kEe)
endfunction
function Jnr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer oqx=CMx
local integer JVr=inx()
local integer clo=cBo(Jze)
set kxe[oqx]=J1e[rwx]*koe
set kre[oqx]=J0e[rwx]*koe
set kie[oqx]=J2e[rwx]
set kae[oqx]=JVr
set kne[oqx]=clo
set kee[oqx]=rwx
set kVe[oqx]=Ixx
set J7e[oqx]=true
set ge[(JVr)]=(oqx)
if rtx(Ixx,J6e,oqx)then
call I7x(Ixx,J4e)
call I7x(Ixx,J5e)
endif
call EEr(clo,CMx,Ixx)
call AYo(Ixx)
call DSx((Ixx),(Jye),(rwx),w)
call icx(JVr,koe,true,function Jar)
return true
endfunction
function JEr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local boolean Eko=(ovv[(rdx)])
local integer oqx=CMx
local integer JVr=kae[oqx]
local integer clo=kne[oqx]
local integer rwx=kee[oqx]
local integer Ixx=kVe[oqx]
local boolean JXr=J7e[oqx]
call ijx(JVr)
call Kzx(clo)
if JXr then
if rrx(Ixx,J6e,oqx)then
call Rmx(Ixx,J4e)
call Rmx(Ixx,J5e)
endif
endif
if Eko then
call fRx(CMx,rwx)
endif
call RUx((Abx((Ixx),(kXe),(kOe),(Bi))))
call NIx((Ixx),(Jye),(rwx),w,((J_e[rwx])*1.))
call UJx(Ixx,Jye)
call KFx(Ixx)
return true
endfunction
function JOr takes nothing returns boolean
set J4e=XBx("DeprivingShock_Init: set DeprivingShock.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DeprivingShock.Event_Death)",VP,pI,function Jrr)
set J5e=XBx("DeprivingShock_Init: set DeprivingShock.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function DeprivingShock.Event_Destroy)",EP,pI,function Jir)
call meo(Gcv,XBx("DeprivingShock_Init: call DeprivingShock.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DeprivingShock.Event_SpellEffect))",ah,pI,function Jnr))
call meo(Gcv,XBx("DeprivingShock_Init: call DeprivingShock.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DeprivingShock.Event_EndCast))",oev,pI,function JEr))
call W_x(Xsv,Jye)
return true
endfunction
function JRr takes nothing returns boolean
call FOr(function JOr,"DeprivingShock_Init")
return true
endfunction
function JIr takes nothing returns boolean
call LZx('ABiB',false)
set kRe=Lzo('ABiB')
set j6[(kRe)]=(3)
set sH[(kRe)]=("Big Boom")
set Ih[(kRe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D009B)))),(((Oj))))))
set x6v[(kRe)]=(3)
set xzv[(kRe)]=("spell")
call LZo((kRe),u6v+(1),((300)*1.))
call LZo((kRe),fH+(1),((0)*1.))
call LZo((kRe),QH+(1),((0)*1.))
call LZo((kRe),Lvv+(1),((50)*1.))
call LZo((kRe),u6v+(2),((300)*1.))
call LZo((kRe),fH+(2),((0)*1.))
call LZo((kRe),QH+(2),((0)*1.))
call LZo((kRe),Lvv+(2),((50)*1.))
call LZo((kRe),u6v+(3),((300)*1.))
call LZo((kRe),fH+(3),((0)*1.))
call LZo((kRe),QH+(3),((0)*1.))
call LZo((kRe),Lvv+(3),((50)*1.))
set Mnv[(kRe)]=("ReplaceableTextures\\CommandButtons\\BTNSelfDestruct.blp")
set kIe[1]=5
set kIe[2]=6
set kIe[3]=7
set kAe[1]=$A
set kAe[2]=$C
set kAe[3]=$E
set kNe[1]='d'
set kNe[2]=$C8
set kNe[3]=300
return true
endfunction
function JAr takes nothing returns boolean
set kbe=lQx(kBe+" (ignitionBuff)")
set qc[(kbe)]=(true)
return true
endfunction
function JNr takes nothing returns boolean
call VRx(qa,(function JIr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\BigBoom\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function JAr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\BigBoom\\obj_ignitionBuff_wc3buff.j"))
return true
endfunction
function Jbr takes nothing returns boolean
set kce=Vnx(kBe)
return true
endfunction
function JBr takes nothing returns boolean
set kCe=WTx('BDGF',"Fire Buff",'bDGF')
set avv[(kCe)]=(true)
set qc[(kCe)]=(true)
set aev[(kCe)]=("ReplaceableTextures\\CommandButtons\\BTNFire.blp")
call lux(kCe,"Abilities\\Spells\\Items\\AIfb\\AIfbTarget.mdl","weapon",ri)
return true
endfunction
function Jcr takes nothing returns boolean
set kde[1]=30
set kde[2]=30
set kde[3]=30
set kDe[1]='}'
set kDe[2]=$8C
set kDe[3]=$A0
set kfe[1]=.3
set kfe[2]=.5
set kfe[3]=.7
return true
endfunction
function JCr takes nothing returns boolean
call VRx(Ma,(function JBr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\FireBuff\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function Jcr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\FireBuff\\obj_this_wc3obj.j"))
return true
endfunction
function Jdr takes nothing returns boolean
set kFe=Vnx(kge)
return true
endfunction
function JDr takes nothing returns boolean
set kGe[1]=3
set kGe[2]=4
set kGe[3]=5
return true
endfunction
function Jfr takes nothing returns boolean
set khe=WTx('BDGC',"Cold Buff",'bDGC')
set avv[(khe)]=(true)
set aev[(khe)]=("ReplaceableTextures\\CommandButtons\\BTNFrost.blp")
call lux(khe,"Abilities\\Spells\\Items\\AIob\\AIobTarget.mdl","weapon",ri)
return true
endfunction
function JFr takes nothing returns boolean
set kHe=lQx(kje+" (coldnessBuff)")
set qc[(kHe)]=(true)
return true
endfunction
function Jgr takes nothing returns boolean
call VRx(ea,(function JDr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\IceBuff\\obj_this_wc3obj.j"))
call VRx(Ma,(function Jfr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\IceBuff\\obj_dummyBuff_wc3buff.j"))
call VRx(Ma,(function JFr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\IceBuff\\obj_coldnessBuff_wc3buff.j"))
return true
endfunction
function JGr takes nothing returns boolean
set kJe=Vnx(kje)
return true
endfunction
function Jhr takes nothing returns boolean
set kke=hGo('UDoG')
call hLo((kke),('AInv'),1)
call hho(((kke)),Apv,(yd))
call hho(((kke)),Apv,(INv))
set Tj[(kke)]=((1.3)*1.)
set Nav[(kke)]=((80)*1.)
set Ntv[(kke)]=((80)*1.)
set Nlv[(kke)]=((320)*1.)
set I3v[(kke)]=((3)*1.)
set Axv[(kke)]=(4)
set NJv[(kke)]=(('d')*1.)
set Njv[(kke)]=(('d')*1.)
set Nhv[(kke)]=((0)*1.)
set NKv[(kke)]=(('d')*1.)
set Nkv[(kke)]=(('d')*1.)
set NHv[(kke)]=((0)*1.)
set NIv[(kke)]=(($708)*1.)
set NOv[(kke)]=(($708)*1.)
set ANv[(kke)]=(gHv)
set Adv[(kke)]=(('x')*1.)
set ADv[((kke))]=((1.*1./((1.3)*1.))*1.)
set Atv[(kke)]=((.3)*1.)
set AQv[(kke)]=(($A)*1.)
set Asv[(kke)]=(($A)*1.)
set Auv[(kke)]=(4)
set AWv[(kke)]=(4)
set Azv[(kke)]=(0)
set Aqv[(kke)]=((32)*1.)
set bbv[(kke)]=(($C)*1.)
set bFv[(kke)]=((3.75)*1.)
set bgv[(kke)]=((1)*1.)
set bBv[(kke)]=(($A)*1.)
set bGv[(kke)]=((3.5)*1.)
set bcv[(kke)]=((9.5)*1.)
set bhv[(kke)]=((4)*1.)
return true
endfunction
function JHr takes nothing returns boolean
call LZx('ADoG',false)
set gpv=Lzo('ADoG')
set G6[(gpv)]=(c6)
set j6[(gpv)]=(3)
set sH[(gpv)]=("Doppelganger")
set Ih[(gpv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D009B)))),(((Oj))))))
set x6v[(gpv)]=(2)
set xzv[(gpv)]=("spell")
call LZo((gpv),fH+(1),((60)*1.))
call LZo((gpv),QH+(1),(($AF)*1.))
call LZo((gpv),Lvv+(1),((600)*1.))
call LZo((gpv),fH+(2),((60)*1.))
call LZo((gpv),QH+(2),(($C8)*1.))
call LZo((gpv),Lvv+(2),((600)*1.))
call LZo((gpv),fH+(3),((60)*1.))
call LZo((gpv),QH+(3),(($E1)*1.))
call LZo((gpv),Lvv+(3),((600)*1.))
set Mnv[(gpv)]=("ReplaceableTextures\\CommandButtons\\BTNAvengingWatcher.blp")
call ccr(gpv,'FDG0',3,'VDG0','LPDG','LRDG')
set kKe[1]=.3
set kKe[2]=.5
set kKe[3]=.7
set kle[1]=45
set kle[2]=45
set kle[3]=45
return true
endfunction
function Jjr takes nothing returns boolean
set kLe=lQx(kme+" (dummyBuff)")
return true
endfunction
function JJr takes nothing returns boolean
set kMe=WTx('BDGI',"Doppelganger",'bDGI')
set avv[(kMe)]=(true)
set aev[(kMe)]=("ReplaceableTextures\\CommandButtons\\BTNDoom.blp")
return true
endfunction
function Jkr takes nothing returns boolean
call VRx(Sa,(function Jhr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\obj_thisUnitType_wc3unit.j"))
call VRx(qa,(function JHr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function Jjr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(Ma,(function JJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\obj_illusionBuff_wc3buff.j"))
return true
endfunction
function JKr takes nothing returns boolean
set kpe=Vnx(kme)
return true
endfunction
function Jlr takes nothing returns boolean
local integer rdx=(bv)
local integer RIr=(Vv[(rdx)])
local integer oqx=oPx(RIr,kqe)
local integer CMx=oqx
local integer OHx=kQe[oqx]
set kse[oqx]=w
call ijx(OHx)
call rix(RIr,kqe)
call Rmx(RIr,kPe)
call Ayx(CMx,kLe)
return true
endfunction
function JLr takes integer oqx,real x,real y,real z returns nothing
call fTx(oqx,x)
call fux(oqx,y)
call fUx(oqx,x,y,z)
endfunction
function Jmr takes integer rwx,integer Ixx returns nothing
call NIx((Ixx),(kCe),(rwx),w,((kde[rwx])*1.))
endfunction
function JMr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local real x=(mFv[(MFo)])
local real y=(mgv[(MFo)])
local integer CMx=oqx
call MCx((Xz[(MFo)]))
call Mdo(MFo)
call UJx(((CMx)),Oyv)
call JLr(CMx,x,y,XYx(x,y))
call Jmr(kue[oqx],CMx)
return true
endfunction
function Jpr takes integer oqx,integer oSx returns nothing
local integer abx=(bdv[(oqx)])
if(oSx!=abx)then
call SetHeroLevel(C[(oqx)],oSx,false)
endif
endfunction
function JPr takes integer rwx,integer Ixx returns nothing
call DSx((Ixx),(khe),(rwx),w)
endfunction
function Jqr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local real x=(mFv[(MFo)])
local real y=(mgv[(MFo)])
local integer CMx=oqx
local integer rwx=kue[oqx]
local integer RIr
call MCx((Xz[(MFo)]))
call Mdo(MFo)
set RIr=RSr((uf[(CMx)]),(ze[(CMx)]),x,y,(GetUnitFacing(C[((CMx))])*bh),kte[oqx],kze)
set kse[oqx]=RIr
call rTx(RIr,kqe,oqx)
call I7x(RIr,kPe)
call AIo(RIr)
call qBo(RIr)
call rzx((RIr),(kRe),(rwx))
call DSx((RIr),(kMe),(rwx),w)
call Rlr(RIr,kTe[oqx])
call Jpr(RIr,(bdv[(CMx)]))
call JPr(rwx,RIr)
return true
endfunction
function JQr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local real N8x=kSe[oqx]
local integer CMx=oqx
local real XNr=kUe[oqx]
local real Xbr=kwe[oqx]
local real dix=kWe[oqx]
local real dax=kye[oqx]
local real dX=dix-XNr
local real dY=dax-Xbr
local real d=iOx(kYe,jjx(dX,dY)-kYe)
local integer MFo
set N8x=N8x-b6v
set dix=XNr+d*(Cos(((((N8x)*1.))*1.)))
set dax=Xbr+d*(Sin(((((N8x)*1.))*1.)))
set MFo=Mvo()
call m1o(MFo,500.)
set mNv[(MFo)]=(((Cpx((gpv),u6v+(kue[oqx]))))*1.)
call Mro(MFo,'qDoG',1.)
set mCv[(MFo)]=XHx((function JMr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,800.)
call M9o(MFo,CMx)
call o6r(MFo,dix,dax,XYx(dix,dax)+60.)
set N8x=N8x+3.141592654
set MFo=Mvo()
set dix=XNr+d*(Cos(((((N8x)*1.))*1.)))
set dax=Xbr+d*(Sin(((((N8x)*1.))*1.)))
call m1o(MFo,500.)
set mNv[(MFo)]=(((Cpx((gpv),u6v+(kue[oqx]))))*1.)
call Mro(MFo,'qDoG',1.)
set mCv[(MFo)]=XHx((function Jqr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,800.)
call M9o(MFo,CMx)
call o6r(MFo,dix,dax,XYx(dix,dax)+60.)
endfunction
function Jsr takes nothing returns boolean
local integer rdx=(bv)
local integer nqr=(mc[(rdx)])
local integer CMx=(Vv[(rdx)])
local integer rwx=(Hc[(rdx)])
local real dix=(UH[(nqr)])
local real dax=(wH[(nqr)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local integer oqx=CMx
local integer OHx=inx()
set kSe[oqx]=UCx(CMx,dix-wpo,dax-wPo)
set kQe[oqx]=OHx
set kte[oqx]=kle[rwx]
set kse[oqx]=w
set kTe[oqx]=kKe[rwx]
set kue[oqx]=rwx
set kUe[oqx]=wpo
set kwe[oqx]=wPo
set kWe[oqx]=dix
set kye[oqx]=dax
set ge[(OHx)]=(oqx)
call DSx((((CMx))),(Oyv),(1),w)
call icx(OHx,.5,false,function JQr)
return true
endfunction
function JSr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer oqx=CMx
local integer RIr=kse[oqx]
if(RIr!=w)then
call Cex((RIr),w)
endif
return true
endfunction
function Jtr takes integer oqx,integer Iox,integer rwx,integer I3x returns boolean
call Ayx(oqx,Iox)
return DSx(oqx,Iox,rwx,I3x)
endfunction
function JTr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
call A7o((Nvo((((GetUnitX(C[((CMx))])))*1.),(((GetUnitY(C[((CMx))])))*1.),(kZe),(ri),(((ob[(CMx)]))*1.))))
call Jtr(CMx,kLe,(Mv[(rdx)]),rdx)
return true
endfunction
function Jur takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function JUr takes integer RIr returns integer
return oPx(RIr,kqe)
endfunction
function Jwr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer JWr=JUr(CMx)
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local integer Jyr=(Nvo(((wpo)*1.),((wPo)*1.),(k1e),(ri),(((ob[(CMx)]))*1.)))
local integer Ixx
local real NIo
local real JYr
local real Jzr
local real NCr
call oYr(Blv[(Jyr)],((4.)*1.),((.25)*1.))
call Nfo(Jyr,1.)
set Jyr=(Nvo(((wpo)*1.),((wPo)*1.),(k2e),(ri),(((ob[(CMx)]))*1.)))
call oYr(Blv[(Jyr)],((4.)*1.),((.25)*1.))
call Nfo(Jyr,1.)
set Hf=(ze[(CMx)])
call Nio(k_e,(GetUnitX(C[((CMx))])),(GetUnitY(C[((CMx))])),(Cpx((kRe),u6v+(rwx))),k0e)
if(JWr==w)then
set JWr=CMx
endif
set Ixx=Nao(k_e)
if(Ixx!=w)then
set NIo=kNe[rwx]
set JYr=kIe[rwx]
set Jzr=kAe[rwx]
loop
if I6x(Ixx,yd)then
set NCr=JYr
else
set NCr=Jzr
endif
call NIx(Ixx,kbe,rwx,JWr,NCr)
call nJo((JWr),(Ixx),((NIo)*1.),(false),(false))
set Ixx=Nao(k_e)
exitwhen(Ixx==w)
endloop
endif
call Cex((CMx),w)
return true
endfunction
function JZr takes nothing returns nothing
set k_e=O2x()
set k0e=XLx(function Jur)
call meo(kRe,XBx("FolderDoppelganger_StructBigBoom_Init: call FolderDoppelganger_StructBigBoom.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderDoppelganger_StructBigBoom.Event_SpellEffect))",ah,pI,function Jwr))
call W_x(E5v,kbe)
endfunction
function J_r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(EYv[(rdx)])
local integer w_o=(Vv[(rdx)])
local integer oqx=Ixx
call RUx((Abx((w_o),("Abilities\\Weapons\\LordofFlameMissile\\LordofFlameMissile.mdl"),("chest"),(Bi))))
return true
endfunction
function J0r takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
set k4e[oqx]=O3o(Ixx,kDe[rwx],kfe[rwx])
call I7x(Ixx,k3e)
return true
endfunction
function J1r takes integer oqx,integer O4o returns nothing
call rrx((oqx),Alv,O4o)
call fTo(((O4o)))
endfunction
function J2r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call Rmx(Ixx,k3e)
call J1r(Ixx,k4e[oqx])
return true
endfunction
function J3r takes nothing returns nothing
set k3e=XBx("FolderDoppelganger_StructFireBuff_Init: set FolderDoppelganger_StructFireBuff.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function FolderDoppelganger_StructFireBuff.Event_Damage)",EZv,pI,function J_r)
call l9x(kCe,XBx("FolderDoppelganger_StructFireBuff_Init: call FolderDoppelganger_StructFireBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderDoppelganger_StructFireBuff.Event_BuffGain))",Bd,pI,function J0r))
call l9x(kCe,XBx("FolderDoppelganger_StructFireBuff_Init: call FolderDoppelganger_StructFireBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderDoppelganger_StructFireBuff.Event_BuffLose))",Jc,pI,function J2r))
endfunction
function J4r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(EYv[(rdx)])
local integer w_o=(Vv[(rdx)])
local integer oqx=Ixx
call NIx((w_o),(kHe),(k6e[oqx]),w,((k7e[oqx])*1.))
call RUx((Abx((w_o),("Abilities\\Weapons\\LichMissile\\LichMissile.mdl"),("chest"),(Bi))))
return true
endfunction
function J5r takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
set k7e[oqx]=kGe[rwx]
set k6e[oqx]=rwx
call I7x(Ixx,k5e)
return true
endfunction
function J6r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
call Rmx(Ixx,k5e)
return true
endfunction
function J7r takes nothing returns nothing
set k5e=XBx("FolderDoppelganger_StructIceBuff_Init: set FolderDoppelganger_StructIceBuff.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function FolderDoppelganger_StructIceBuff.Event_Damage)",EZv,pI,function J4r)
call l9x(khe,XBx("FolderDoppelganger_StructIceBuff_Init: call FolderDoppelganger_StructIceBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderDoppelganger_StructIceBuff.Event_BuffGain))",Bd,pI,function J5r))
call l9x(khe,XBx("FolderDoppelganger_StructIceBuff_Init: call FolderDoppelganger_StructIceBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderDoppelganger_StructIceBuff.Event_BuffLose))",Jc,pI,function J6r))
call W_x(nxv,kHe)
endfunction
function J8r takes nothing returns boolean
set kPe=XBx("Doppelganger_Init: set Doppelganger.ILLUSION_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function Doppelganger.Event_IllusionDestroy)",EP,pI,function Jlr)
call l9x(kLe,XBx("Doppelganger_Init: call Doppelganger.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Doppelganger.Event_BuffGain))",Bd,pI,function Jsr))
call l9x(kLe,XBx("Doppelganger_Init: call Doppelganger.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Doppelganger.Event_BuffLose))",Jc,pI,function JSr))
call meo(gpv,XBx("Doppelganger_Init: call Doppelganger.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Doppelganger.Event_SpellEffect))",ah,pI,function JTr))
call JZr()
call J3r()
call J7r()
return true
endfunction
function J9r takes nothing returns boolean
call FOr(function J8r,"Doppelganger_Init")
return true
endfunction
function kvr takes nothing returns boolean
call LZx('AEbS',false)
set Guv=Lzo('AEbS')
set G6[(Guv)]=(i6)
set j6[(Guv)]=(6)
set sH[(Guv)]=("Ebony Shot")
set Ih[(Guv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0089)))),(((Oj))))))
set x6v[(Guv)]=(3)
set xzv[(Guv)]=("attack")
call LZo((Guv),u6v+(1),((80)*1.))
call LZo((Guv),fH+(1),(($E)*1.))
call LZo((Guv),QH+(1),((30)*1.))
call LZo((Guv),Lvv+(1),(($3E8)*1.))
call LZo((Guv),u6v+(2),((80)*1.))
call LZo((Guv),fH+(2),(($E)*1.))
call LZo((Guv),QH+(2),((40)*1.))
call LZo((Guv),Lvv+(2),(($3E8)*1.))
call LZo((Guv),u6v+(3),((80)*1.))
call LZo((Guv),fH+(3),(($E)*1.))
call LZo((Guv),QH+(3),((50)*1.))
call LZo((Guv),Lvv+(3),(($3E8)*1.))
call LZo((Guv),u6v+(4),((80)*1.))
call LZo((Guv),fH+(4),(($E)*1.))
call LZo((Guv),QH+(4),((60)*1.))
call LZo((Guv),Lvv+(4),(($3E8)*1.))
call LZo((Guv),u6v+(5),((80)*1.))
call LZo((Guv),fH+(5),(($E)*1.))
call LZo((Guv),QH+(5),((70)*1.))
call LZo((Guv),Lvv+(5),(($3E8)*1.))
call LZo((Guv),u6v+(6),((80)*1.))
call LZo((Guv),fH+(6),(($E)*1.))
call LZo((Guv),QH+(6),((80)*1.))
call LZo((Guv),Lvv+(6),(($3E8)*1.))
set Mnv[(Guv)]=("ReplaceableTextures\\CommandButtons\\BTNImprovedBows.blp")
call ccr(Guv,'FES0',6,'VES0','LPES','LRES')
set k8e[1]=20
set k8e[2]=20
set k8e[3]=20
set k8e[4]=20
set k8e[5]=20
set k8e[6]=20
set k9e[1]=3
set k9e[2]=3
set k9e[3]=5
set k9e[4]=5
set k9e[5]=7
set k9e[6]=7
set Kve[1]=1.75
set Kve[2]=1.75
set Kve[3]=2
set Kve[4]=2
set Kve[5]=2.25
set Kve[6]=2.25
set Kee[1]=b6v*1*1./ 6
set Kee[2]=b6v*1*1./ 6
set Kee[3]=b6v*1*1./ 6
set Kee[4]=b6v*1*1./ 6
set Kee[5]=b6v*1*1./ 6
set Kee[6]=b6v*1*1./ 6
set Kxe[1]=b6v*2*1./ 3
set Kxe[2]=b6v*2*1./ 3
set Kxe[3]=b6v*2*1./ 3
set Kxe[4]=b6v*2*1./ 3
set Kxe[5]=b6v*2*1./ 3
set Kxe[6]=b6v*2*1./ 3
set Koe[1]=5
set Koe[2]=$F
set Koe[3]=30
set Koe[4]=45
set Koe[5]=65
set Koe[6]=85
return true
endfunction
function ker takes nothing returns boolean
set Kre=lQx(Kie+" (ignitionBuff)")
set qc[(Kre)]=(true)
set qU[(Kre)]=(true)
return true
endfunction
function kxr takes nothing returns boolean
call VRx(qa,(function kvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\EbonyShot.page\\EbonyShot.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function ker),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\EbonyShot.page\\EbonyShot.struct\\obj_ignitionBuff_wc3buff.j"))
return true
endfunction
function kor takes nothing returns boolean
set Kae=Vnx(Kie)
return true
endfunction
function krr takes integer oqx returns nothing
set KRe[oqx]=false
call rgx(Kae)
endfunction
function kir takes integer oqx returns nothing
if(KXe[oqx]>0)then
return
endif
if(KOe[oqx]!=Z)then
call oYx("EbonyShot_Allocation_deallocCustom_confirm","call DebugEx(EbonyShot.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Kie+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set KOe[oqx]=KOe[(w)]
set KOe[(w)]=oqx
call krr(oqx)
endfunction
function kar takes integer oqx returns nothing
set KXe[oqx]=KXe[oqx]-1
call kir(oqx)
endfunction
function knr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx
local integer o7x
call mZx(MFo,Kne)
set oqx=(mWv[(MFo)])
set o7x=KVe[oqx]-1
if(o7x==0)then
call XYr(KEe[oqx])
call kar((oqx))
else
set KVe[oqx]=o7x
endif
return true
endfunction
function kVr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=jFx()
local integer MFo
local integer oqx
local integer CQx
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
set MFo=(WY[(rdx)])
set oqx=(mWv[(MFo)])
set CQx=KAe[oqx]
if(IsUnitAlly(C[(Ixx)],vx[((ze[((aH[(CQx)]))]))]))then
return false
endif
if(I5x((KEe[oqx]),Rb,(Ixx)))then
call nJo(((aH[(CQx)])),(Ixx),((NWr("dmgGraze",k8e[(XH[(CQx)])])*miv)*1.),(true),(false))
return false
endif
return true
return true
endfunction
function kEr takes string rqx,integer XCx returns integer
if(HaveStoredString(Kv[((SH))],(rqx),("var")))then
return(S2I(((C8x(SH,(rqx),"var")))))
endif
return XCx
endfunction
function kXr takes integer oqx returns integer
set KRe[oqx]=true
set KCe[oqx]=false
call rax(Kae)
return oqx
endfunction
function kOr takes nothing returns integer
local integer oqx
if(KBe==8190)then
call oYx("EbonyShot_Allocation_allocCustom","call DebugEx(EbonyShot.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Kie+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(KOe[(w)]==w)then
set Kce=Kce+1
set oqx=Kce
else
set oqx=KOe[(w)]
set KOe[(w)]=KOe[KOe[(w)]]
endif
set KOe[oqx]=Z
set KXe[oqx]=1
call kXr(oqx)
return oqx
endfunction
function kRr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
call Mdo(MFo)
return true
endfunction
function kIr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=(mWv[(MFo)])
local real NIo=Kde[oqx]
local integer CQx=KAe[oqx]
local integer CMx=(aH[(CQx)])
call dpx(KEe[oqx],Ixx)
call RUx((Abx((Ixx),(Kge),(KGe),(ri))))
call nJo((CMx),(Ixx),((NIo)*1.),(false),(true))
return true
endfunction
function kAr takes integer oqx,integer CQx,real N8x,real kNr returns nothing
local integer CMx=(aH[(CQx)])
local integer rwx=(XH[(CQx)])
local real dix=(wh[(CQx)])
local real dax=(Wh[(CQx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local integer MFo=Mvo()
call Mvx(MFo,Kne)
set mNv[(MFo)]=(((Cpx((Guv),u6v+(rwx))))*1.)
call sao((Mro(MFo,'qEbS',1.5)),(KDe),(Kfe),(Bi))
set mWv[(MFo)]=(oqx)
set mCv[(MFo)]=XHx((function kRr))
call m8o(MFo,KFe)
call M9o(MFo,CMx)
call o6r(MFo,wpo+kNr*(Cos(((((N8x)*1.))*1.))),wPo+kNr*(Sin(((((N8x)*1.))*1.))),XYx(dix,dax)+OLx(CMx,true))
call rQr(MFo,function kIr,KIe)
endfunction
function kbr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local integer CQx=(uH[(rdx)])
local real wpo
local real wPo
local integer rwx
local real d
local integer kBr
local real kNr
local real cQr
local real N8x
local real iXr
local integer oqx
local integer olx
call RUx((Abx((CMx),(KNe),(Kbe),(Bi))))
set wpo=(GetUnitX(C[((CMx))]))
set wPo=(GetUnitY(C[((CMx))]))
set rwx=(XH[(CQx)])
set d=jjx(dix-wpo,dax-wPo)
set kBr=kEr("missiles",k9e[rwx])
set kNr=NWr("range",(Cpx((Guv),Lvv+(rwx))))
set cQr=dBr(.0,NWr("windowClose",Kxe[rwx]),kNr,NWr("windowFar",Kee[rwx]),d)
set N8x=(iH[(CQx)])-cQr*1./ 2
set iXr=cQr*1./(kBr-1)
set oqx=kOr()
set KVe[oqx]=kBr
set Kde[oqx]=Koe[rwx]+(mg[(CMx)])*Kve[rwx]
set KEe[oqx]=JIx("EbonyShot_Event_SpellEffect: set this.targetGroup = UnitList.Create()")
set KAe[oqx]=CQx
set olx=kBr
loop
exitwhen(olx<1)
call kAr(oqx,CQx,N8x,kNr)
set N8x=N8x+iXr
set olx=olx-1
endloop
return true
endfunction
function kcr takes nothing returns boolean
set Kne=XBx("EbonyShot_Init: set EbonyShot.MISSILE_DESTROY_EVENT = Event.Create(Missile.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function EbonyShot.Event_Missile_Destroy)",tY,pI,function knr)
set KIe=XLx(function kVr)
call meo(Guv,XBx("EbonyShot_Init: call EbonyShot.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EbonyShot.Event_SpellEffect))",ah,pI,function kbr))
return true
endfunction
function kCr takes nothing returns boolean
call FOr(function kcr,"EbonyShot_Init")
return true
endfunction
function kdr takes nothing returns boolean
set Khe=WTx('BEmB',"Emphatic Bite",'bEmB')
set avv[(Khe)]=(true)
set aev[(Khe)]=("ReplaceableTextures\\CommandButtons\\BTNCannibalize.blp")
call lux(Khe,"Abilities\\Spells\\Orc\\Bloodlust\\BloodlustTarget.mdl","weapon",ri)
set SU=lYx()
call l_x(SU,dgv,.1)
call l0x(((Khe)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,dgv,.15)
call l0x(((Khe)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,dgv,.2)
call l0x(((Khe)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,dgv,.25)
call l0x(((Khe)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,dgv,.3)
call l0x(((Khe)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,dgv,.35)
call l0x(((Khe)),vc+(6),(SU))
return true
endfunction
function kDr takes nothing returns boolean
set KHe[1]=.1
set KHe[2]=.15
set KHe[3]=.2
set KHe[4]=.25
set KHe[5]=.3
set KHe[6]=.35
set Kje[1]=8
set Kje[2]=8
set Kje[3]=8
set Kje[4]=8
set Kje[5]=8
set Kje[6]=8
return true
endfunction
function kfr takes nothing returns boolean
call VRx(Ma,(function kdr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\EmphaticBite.page\\EmphaticBite.struct\\Buff\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function kDr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\EmphaticBite.page\\EmphaticBite.struct\\Buff\\obj_this_wc3obj.j"))
return true
endfunction
function kFr takes nothing returns boolean
set KJe=Vnx(Kke)
return true
endfunction
function kgr takes nothing returns boolean
set KKe=lQx(Kle+" (bleedingBuff)")
set qc[(KKe)]=(true)
return true
endfunction
function kGr takes nothing returns boolean
set KLe=lQx(Kle+" (dummyBuff)")
set SU=lYx()
call vOr(SU,Dkv,true)
call l0x(((KLe)),vc+(1),(SU))
return true
endfunction
function khr takes nothing returns boolean
call LZx('AEmC',false)
set Gxv=Lzo('AEmC')
set G6[(Gxv)]=(i6)
set j6[(Gxv)]=(6)
set sH[(Gxv)]=("Emphatic Bite")
set Ih[(Gxv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00DC)))),(((Oj))))))
set x6v[(Gxv)]=(4)
set xzv[(Gxv)]=("spell")
call LZo((Gxv),fH+(1),(($B)*1.))
call LZo((Gxv),QH+(1),((75)*1.))
call LZo((Gxv),Lvv+(1),((700)*1.))
call LZo((Gxv),fH+(2),(($A)*1.))
call LZo((Gxv),QH+(2),((85)*1.))
call LZo((Gxv),Lvv+(2),((700)*1.))
call LZo((Gxv),fH+(3),((9)*1.))
call LZo((Gxv),QH+(3),(('d')*1.))
call LZo((Gxv),Lvv+(3),((700)*1.))
call LZo((Gxv),fH+(4),((8)*1.))
call LZo((Gxv),QH+(4),(('s')*1.))
call LZo((Gxv),Lvv+(4),((700)*1.))
call LZo((Gxv),fH+(5),((7)*1.))
call LZo((Gxv),QH+(5),(($82)*1.))
call LZo((Gxv),Lvv+(5),((700)*1.))
call LZo((Gxv),fH+(6),((7)*1.))
call LZo((Gxv),QH+(6),(($82)*1.))
call LZo((Gxv),Lvv+(6),((700)*1.))
set Mnv[(Gxv)]=("ReplaceableTextures\\CommandButtons\\BTNCannibalize.blp")
call ccr(Gxv,'FEB0',6,'VEB0','LPEB','LREB')
set Kme[1]=3
set Kme[2]=3
set Kme[3]=3
set Kme[4]=3
set Kme[5]=3
set Kme[6]=3
set KMe[1]=30
set KMe[2]=45
set KMe[3]=60
set KMe[4]=80
set KMe[5]='d'
set KMe[6]='}'
set Kpe[1]=45
set Kpe[2]=65
set Kpe[3]=90
set Kpe[4]='x'
set Kpe[5]=$9B
set Kpe[6]=$C3
set KPe[1]=45
set KPe[2]=65
set KPe[3]=90
set KPe[4]='x'
set KPe[5]=$9B
set KPe[6]=$C3
return true
endfunction
function kHr takes nothing returns boolean
set Kqe=lQx(Kle+" (silenceBuff)")
set qc[(Kqe)]=(true)
return true
endfunction
function kjr takes nothing returns boolean
call VRx(Ma,(function kgr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\EmphaticBite.page\\EmphaticBite.struct\\obj_bleedingBuff_wc3buff.j"))
call VRx(Ma,(function kGr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\EmphaticBite.page\\EmphaticBite.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function khr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\EmphaticBite.page\\EmphaticBite.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function kHr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\EmphaticBite.page\\EmphaticBite.struct\\obj_silenceBuff_wc3buff.j"))
return true
endfunction
function kJr takes nothing returns boolean
set KQe=Vnx(Kle)
return true
endfunction
function kkr takes integer oqx,real kKr,real klr,real kLr,real kmr,real kMr,real kpr,real ilx returns nothing
if B_o(oqx)then
call Oqr(oqx,kKr*c6v,klr*c6v,kLr*c6v,kmr*c6v*c6v,kMr*c6v*c6v,kpr*c6v*c6v,ilx)
endif
endfunction
function kPr takes integer rwx,integer Ixx returns nothing
call NIx((Ixx),(Khe),(rwx),w,((Kje[rwx])*1.))
endfunction
function kqr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=oqx
local integer rwx=Kue[oqx]
local integer Ixx=Kye[oqx]
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real dix
local real dax
local real dX
local real dY
local real d
local real oUx
local real N8x
local boolean kQr
local real eor
local real err
if(Ixx==w)then
set dix=Kze[oqx]
set dax=KZe[oqx]
else
set dix=(GetUnitX(C[((Ixx))]))
set dax=(GetUnitY(C[((Ixx))]))
endif
set dX=dix-wpo
set dY=dax-wPo
set d=jjx(dX,dY)
set oUx=Kse
set N8x=(Atan2(((dY)*1.),((dX)*1.)))
set kQr=(d<oUx+K_e)
set eor=wpo+oUx*(Cos(((((N8x)*1.))*1.)))
set err=wPo+oUx*(Sin(((((N8x)*1.))*1.)))
call fTx(CMx,eor)
call fux(CMx,err)
if kQr then
call Ayx(CMx,KLe)
if(Ixx!=w)then
call RUx((Abx((Ixx),(K0e),(K1e),(Bi))))
if(IsUnitAlly(C[(Ixx)],vx[((ze[(CMx)]))]))then
call kPr(rwx,Ixx)
call moo(CMx,Ixx,KMe[rwx])
else
call nJo((CMx),(Ixx),((KPe[rwx])*1.),(false),(true))
if not nIo(Ixx)then
call NIx((Ixx),(KLe),(rwx),w,((Kme[rwx])*1.))
endif
call NIx((Ixx),(KLe),(rwx),w,((Kme[rwx])*1.))
endif
call moo(CMx,CMx,Kpe[rwx])
endif
endif
endfunction
function ksr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer CMx=(Vv[(rdx)])
local integer Ixx=Ib
local real jlx=(GetUnitX(C[((CMx))]))
local real jLx=(GetUnitY(C[((CMx))]))
local real dix=(GetUnitX(C[((Ixx))]))
local real dax=(GetUnitY(C[((Ixx))]))
local real blr=jjx(dix-jlx,dax-jLx)
local real kSr=NHx(blr,KSe,.0)
local real I1o=KTe*blr
local integer oqx=CMx
local integer hbr=inx()
local integer CQx=Cmx(CMx,Gxv)
local real Okx
local real ktr
set Kue[oqx]=rwx
set KUe[oqx]=hbr
set Kwe[oqx]=jlx
set KWe[oqx]=jLx
set Kye[oqx]=Ixx
set KYe[oqx]=CQx
set ge[(hbr)]=(oqx)
call SetUnitAnimation(C[((CMx))],("attack"))
call QueueUnitAnimation(C[((CMx))],("stand"))
if(kSr>0)then
set Okx=4*I1o*1./ kSr
set ktr=-8*I1o*1./ kSr*1./ kSr
call kkr(CMx,.0,.0,Okx,.0,.0,ktr,kSr)
endif
call icx(hbr,Kte,true,function kqr)
return true
endfunction
function kTr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer oqx=CMx
local integer hbr=KUe[oqx]
local integer Ixx=Kye[oqx]
local integer CQx=KYe[oqx]
call ijx(hbr)
call dRx(CQx)
return true
endfunction
function kur takes nothing returns boolean
local integer rdx=(bv)
set Ib=(WH[(rdx)])
call Q8o((Vv[(rdx)]),KLe,(Mv[(rdx)]))
return true
endfunction
function kUr takes nothing returns nothing
endfunction
function kwr takes nothing returns boolean
set Kse=KSe*Kte
call l9x(KLe,XBx("EmphaticBite_Init: call EmphaticBite.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EmphaticBite.Event_BuffGain))",Bd,pI,function ksr))
call l9x(KLe,XBx("EmphaticBite_Init: call EmphaticBite.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EmphaticBite.Event_BuffLose))",Jc,pI,function kTr))
call meo(Gxv,XBx("EmphaticBite_Init: call EmphaticBite.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EmphaticBite.Event_SpellEffect))",ah,pI,function kur))
call W_x(Xhv,Kqe)
call W_x(Emv,KKe)
call kUr()
return true
endfunction
function kWr takes nothing returns boolean
call FOr(function kwr,"EmphaticBite_Init")
return true
endfunction
function kyr takes nothing returns boolean
call LZx('AEnA',false)
set Gwv=Lzo('AEnA')
set G6[(Gwv)]=(c6)
set j6[(Gwv)]=(3)
set sH[(Gwv)]=("Enchanted Arrow")
set Ih[(Gwv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0269)))),(((Oj))))))
set x6v[(Gwv)]=(2)
set xzv[(Gwv)]=("spell")
call LZo((Gwv),u6v+(1),(($C8)*1.))
call LZo((Gwv),BH+(1),((1)*1.))
call LZo((Gwv),fH+(1),((60)*1.))
call LZo((Gwv),QH+(1),(($E1)*1.))
call LZo((Gwv),Lvv+(1),((99999)*1.))
call LZo((Gwv),u6v+(2),(($C8)*1.))
call LZo((Gwv),BH+(2),((1)*1.))
call LZo((Gwv),fH+(2),((60)*1.))
call LZo((Gwv),QH+(2),(($F0)*1.))
call LZo((Gwv),Lvv+(2),((99999)*1.))
call LZo((Gwv),u6v+(3),(($C8)*1.))
call LZo((Gwv),BH+(3),((1)*1.))
call LZo((Gwv),fH+(3),((60)*1.))
call LZo((Gwv),QH+(3),((260)*1.))
call LZo((Gwv),Lvv+(3),((99999)*1.))
set Mnv[(Gwv)]=("ReplaceableTextures\\CommandButtons\\BTNImprovedStrengthOfTheMoon.blp")
call ccr(Gwv,'FEA0',3,'VEA0','LPEA','LREA')
set K2e[1]=99999
set K2e[2]=99999
set K2e[3]=99999
set K3e[1]=3
set K3e[2]=4
set K3e[3]=5
set K4e[1]=5
set K4e[2]=5
set K4e[3]=5
set K5e[1]=300
set K5e[2]=400
set K5e[3]=500
return true
endfunction
function kYr takes nothing returns boolean
call VRx(qa,(function kyr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\EnchantedArrow.page\\EnchantedArrow.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function kzr takes nothing returns boolean
set K6e=Vnx(K7e)
return true
endfunction
function kZr takes integer oqx returns nothing
set lae[oqx]=false
call rgx(K6e)
endfunction
function k_r takes integer oqx returns nothing
if(lre[oqx]>0)then
return
endif
if(lie[oqx]!=Z)then
call oYx("EnchantedArrow_Allocation_deallocCustom_confirm","call DebugEx(EnchantedArrow.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",K7e+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set lie[oqx]=lie[(w)]
set lie[(w)]=oqx
call kZr(oqx)
endfunction
function k0r takes integer oqx returns nothing
set lre[oqx]=lre[oqx]-1
call k_r(oqx)
endfunction
function k1r takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=lee[oqx]
local integer rwx=lxe[oqx]
local integer Q6o=loe[oqx]
local real x=(mFv[(MFo)])
local real y=(mgv[(MFo)])
call ijx(Q6o)
call mZx(MFo,lve)
call k0r((oqx))
return true
endfunction
function k2r takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function k3r takes integer oqx returns integer
set lae[oqx]=true
set lXe[oqx]=false
call rax(K6e)
return oqx
endfunction
function k4r takes nothing returns integer
local integer oqx
if(lVe==8190)then
call oYx("EnchantedArrow_Allocation_allocCustom","call DebugEx(EnchantedArrow.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",K7e+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(lie[(w)]==w)then
set lEe=lEe+1
set oqx=lEe
else
set oqx=lie[(w)]
set lie[(w)]=lie[lie[(w)]]
endif
set lie[oqx]=Z
set lre[oqx]=1
call k3r(oqx)
return oqx
endfunction
function k5r takes integer oqx,integer CMx,integer rwx,real x,real y returns nothing
local real O1o=(Cpx((Gwv),u6v+(rwx)))
local integer Ixx
local real NIo
local real gwr
call A7o((Nvo(((x)*1.),((y)*1.),(lBe),(ri),((O1o*1./ lce)*1.))))
set Hf=(ze[(CMx)])
call Nio(K9e,x,y,2*O1o,lne)
set Ixx=Nao(K9e)
if(Ixx!=w)then
set NIo=lOe[oqx]
set gwr=lIe[oqx]
loop
call NIx((((Ixx))),((Xsv)),(1),w,((((gwr)*1.))*1.))
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
set Ixx=Nao(K9e)
exitwhen(Ixx==w)
endloop
endif
endfunction
function k6r takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=lee[oqx]
local integer rwx=lxe[oqx]
local real x=(mFv[(MFo)])
local real y=(mgv[(MFo)])
call Mdo(MFo)
call k5r(oqx,CMx,rwx,x,y)
return true
endfunction
function k7r takes integer oqx,integer id,real D7x,real Mio returns integer
local integer oSx=mcx(id,(mFv[((oqx))]),(mgv[((oqx))]),(mGv[((oqx))]),Mio)
call Mox(oqx,oSx)
call mbx(oSx,D7x)
return oSx
endfunction
function k8r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real rmr=K2e[rwx]
local real N8x=UCx(CMx,dix-wpo,dax-wPo)
local integer oqx
local integer MFo
local integer Q6o
set dix=wpo+rmr*(Cos(((((N8x)*1.))*1.)))
set dax=wPo+rmr*(Sin(((((N8x)*1.))*1.)))
set oqx=k4r()
set MFo=Mvo()
set Q6o=inx()
set lee[oqx]=CMx
set lOe[oqx]=K5e[rwx]+K3e[rwx]
set lRe[oqx]=MFo
set lxe[oqx]=rwx
set lIe[oqx]=K4e[rwx]
set lAe[oqx]=JIx("EnchantedArrow_Event_SpellEffect: set this.targetGroup = UnitList.Create()")
set lNe[oqx]=dix
set lbe[oqx]=dax
set loe[oqx]=Q6o
set ge[(Q6o)]=(oqx)
call Mvx(MFo,lve)
call m1o(MFo,400.)
set mNv[(MFo)]=(((Cpx((Gwv),u6v+(rwx))))*1.)
set mCv[(MFo)]=XHx((function k6r))
set mWv[(MFo)]=(oqx)
call m8o(MFo,1100.)
call M9o(MFo,CMx)
call sao((k7r(MFo,'qEnA',.0,(Atan2(((dax-wPo)*1.),((dix-wpo)*1.))))),(lCe),(lde),(Bi))
call sao(((Xz[(MFo)])),(lDe),(lfe),(Bi))
call oYr((Xz[(MFo)]),5.,(Cpx((Gwv),BH+(rwx))))
set lFe[(CMx)]=oqx
return true
endfunction
function k9r takes integer oqx,integer Kvr,integer Ker returns nothing
local integer olx=DBx(oqx,Rb)
local integer Kxr
loop
exitwhen(olx<q)
set Kxr=Dcx(oqx,Rb,olx)
if not Lko(Kvr,Kxr)then
call dpx(Ker,Kxr)
endif
set olx=olx-1
endloop
endfunction
function Kor takes integer oqx returns real
return miv
endfunction
function Krr takes integer oqx,real x,real y,real j8x,integer Q4x returns nothing
if(Q4x==w)then
set Q4x=GK
endif
set Q4x=Noo(mQ,Q4x)
call GroupEnumUnitsInRange(Kb[((oqx))],((x)*1.),((y)*1.),((j8x)*1.),Bv[(Q4x)])
endfunction
function Kir takes integer oqx returns nothing
call DSx(((oqx)),(XVv),(1),w)
endfunction
function Kar takes nothing returns nothing
call Kir(RVx())
endfunction
function Knr takes integer oqx returns nothing
call UJx((oqx),XVv)
endfunction
function KVr takes nothing returns nothing
call Knr(RVx())
endfunction
function KEr takes real x,real y returns boolean
local item cLo
local real dix
local real dax
local real d
call Krr(z6,x,y,$3E8,w)
call ForGroup(Kb[(z6)],(function Kar))
set cLo=CreateItem('iUPN',x,y)
call ForGroup(Kb[(z6)],(function KVr))
set dix=GetWidgetX(cLo)
set dax=GetWidgetY(cLo)
set d=Gyx(dix-x,dax-y)
call RemoveItem(cLo)
set cLo=null
return(d>1.)
endfunction
function KXr takes integer oqx returns nothing
call MUo(oqx,(mFv[((oqx))]),(mgv[((oqx))]),(mGv[((oqx))]))
endfunction
function KOr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=lee[oqx]
local integer MFo=lRe[oqx]
local integer Q7o=lAe[oqx]
local real dix=lNe[oqx]
local real dax=lbe[oqx]
local real KRr
local real KIr
local integer Ixx
local real N8x
local real NJx
local real KAr
local real Vmr
local real VMr
local real eor
local real err
set OPe=Q7o
set Hf=(ze[(CMx)])
set KRr=(mFv[(MFo)])
set KIr=(mgv[(MFo)])
call Nio(K9e,KRr,KIr,(Cpx((Gwv),u6v+(lxe[oqx]))),lne)
call k9r(Q7o,K9e,K8e)
loop
set Ixx=(dLx((K8e),Rb))
exitwhen(Ixx==w)
call IEo(Q7o,Ixx)
call UJx(((Ixx)),x_v)
endloop
set Ixx=Nao(K9e)
if(Ixx!=w)then
set N8x=Moo(MFo)
set NJx=(mJv[(MFo)])
set KAr=Kor(MFo)
set Vmr=NJx*lge*(Cos(((((N8x)*1.))*1.)))
set VMr=NJx*lge*(Sin(((((N8x)*1.))*1.)))
loop
if not(I5x((Q7o),Rb,(Ixx)))then
call dpx(Q7o,Ixx)
call DSx((((Ixx))),(x_v),(1),w)
endif
set eor=(GetUnitX(C[((Ixx))]))+Vmr
set err=(GetUnitY(C[((Ixx))]))+VMr
if not KEr(eor,err)then
call fWx(Ixx,eor,err)
endif
set Ixx=Nao(K9e)
exitwhen(Ixx==w)
endloop
endif
if KEr(KRr,KIr)then
call KXr(MFo)
endif
endfunction
function KNr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local boolean Eko=(ovv[(rdx)])
local integer oqx=lFe[(CMx)]
local real dix
local real dax
if not Eko then
call Mdo(lRe[oqx])
call Dnx((CMx),(Gwv))
call BRx(CMx,(Cpx((Gwv),QH+(rwx))))
return true
endif
set dix=lNe[oqx]
set dax=lbe[oqx]
call o6r(lRe[oqx],dix,dax,XYx(dix,dax)+60.)
call icx(loe[oqx],lge,true,function KOr)
return true
endfunction
function Kbr takes nothing returns boolean
set K8e=JIx("EnchantedArrow_Init: set EnchantedArrow.DIFFERENCE_GROUP = UnitList.Create()")
set K9e=O2x()
set lve=XBx("EnchantedArrow_Init: set EnchantedArrow.MISSILE_DESTROY_EVENT = Event.Create(Missile.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function EnchantedArrow.Event_Destroy)",tY,pI,function k1r)
set lne=XLx(function k2r)
call meo(Gwv,XBx("EnchantedArrow_Init: call EnchantedArrow.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnchantedArrow.Event_SpellEffect))",ah,pI,function k8r))
call meo(Gwv,XBx("EnchantedArrow_Init: call EnchantedArrow.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnchantedArrow.Event_EndCast))",oev,pI,function KNr))
return true
endfunction
function KBr takes nothing returns boolean
call FOr(function Kbr,"EnchantedArrow_Init")
return true
endfunction
function Kcr takes nothing returns boolean
call LZx('AFSR',false)
set lGe=Lzo('AFSR')
set G6[(lGe)]=(c6)
set j6[(lGe)]=(3)
set sH[(lGe)]=("Revert")
set Ih[(lGe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0104)))),(((Oj))))))
set x6v[(lGe)]=(0)
set xzv[(lGe)]=("spell")
call LZo((lGe),fH+(1),((0)*1.))
call LZo((lGe),Lvv+(1),((750)*1.))
call LZo((lGe),fH+(2),((0)*1.))
call LZo((lGe),Lvv+(2),((750)*1.))
call LZo((lGe),fH+(3),((0)*1.))
call LZo((lGe),Lvv+(3),((750)*1.))
set Mnv[(lGe)]=("ReplaceableTextures\\CommandButtons\\BTNNeutralManaShieldOff.blp")
call ccr(lGe,'FFX0',3,'VFX0','LPFX','LRFX')
return true
endfunction
function KCr takes nothing returns boolean
set lhe=lQx(lHe+" (dummyBuff)")
set qc[(lhe)]=(true)
call lux(lhe,"Abilities\\Spells\\NightElf\\Barkskin\\BarkSkinTarget.mdl","hand left",ri)
call lux(lhe,"Abilities\\Spells\\NightElf\\Barkskin\\BarkSkinTarget.mdl","hand right",ri)
return true
endfunction
function Kdr takes nothing returns boolean
call VRx(qa,(function Kcr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairyShape.page\\FairyShape.struct\\Revert\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function KCr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairyShape.page\\FairyShape.struct\\Revert\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function KDr takes nothing returns boolean
set lje=Vnx(lHe)
return true
endfunction
function Kfr takes nothing returns boolean
call LZx('AFSX',false)
return true
endfunction
function KFr takes nothing returns boolean
set lJe=lQx(lke+" (eclipseBuff)")
return true
endfunction
function Kgr takes nothing returns boolean
call LZx('AFSC',false)
return true
endfunction
function KGr takes nothing returns boolean
local integer rdx=(bv)
local integer Ipx=(Gc[(rdx)])
call D6x(((Vv[(rdx)])),dmv[(Ipx)],dMv[(Ipx)])
return true
endfunction
function Khr takes nothing returns boolean
local integer rdx=(bv)
local integer Ipx=(Gc[(rdx)])
call D6x((((Vv[(rdx)]))),-((dmv[(Ipx)])*1.),((dMv[(Ipx)])*1.))
return true
endfunction
function KHr takes integer oqx,real D7x,real Dho returns integer
local integer Ipx=rto(dLv,function KGr,function Khr)
set dmv[(Ipx)]=D7x
set dMv[(Ipx)]=Dho
return Ipx
endfunction
function Kjr takes nothing returns boolean
set c0e=lQx(lke+" (dummyBuff)")
set qc[(c0e)]=(true)
set SU=lYx()
call vOr(SU,DVv,true)
call lzx(((SU)),Fc,(KHr(Db,1,.5)))
call l0x(((c0e)),vc+(1),(SU))
set SU=lYx()
call vOr(SU,DVv,true)
call lzx(((SU)),Fc,(KHr(Db,1,.5)))
call l0x(((c0e)),vc+(2),(SU))
set SU=lYx()
call vOr(SU,DVv,true)
call lzx(((SU)),Fc,(KHr(Db,1,.5)))
call l0x(((c0e)),vc+(3),(SU))
return true
endfunction
function KJr takes nothing returns boolean
set lKe=hGo('ULFS')
call hLo((lKe),('AInv'),1)
call hho(((lKe)),Apv,(yd))
call hho(((lKe)),Apv,(INv))
set Tj[(lKe)]=((1.25)*1.)
set Nav[(lKe)]=((83.044982698962)*1.)
set Ntv[(lKe)]=((91.349480968858)*1.)
set Nlv[(lKe)]=((305)*1.)
set I3v[(lKe)]=((0)*1.)
set Axv[(lKe)]=(4)
set NJv[(lKe)]=(('d')*1.)
set Njv[(lKe)]=(('d')*1.)
set Nhv[(lKe)]=((0)*1.)
set NKv[(lKe)]=(('d')*1.)
set Nkv[(lKe)]=(('d')*1.)
set NHv[(lKe)]=((0)*1.)
set NIv[(lKe)]=(($708)*1.)
set NOv[(lKe)]=(($708)*1.)
set ANv[(lKe)]=(gSv)
set Adv[(lKe)]=((720)*1.)
set ADv[((lKe))]=((1.*1./((1.7)*1.))*1.)
set Atv[(lKe)]=((.55)*1.)
set Drv[(lKe)]=((900)*1.)
set AQv[(lKe)]=(($E)*1.)
set Asv[(lKe)]=(($E)*1.)
set Auv[(lKe)]=(1)
set AWv[(lKe)]=($E)
set Azv[(lKe)]=(3)
set Aqv[(lKe)]=((37.647058823529)*1.)
call hMo(lKe,g2v)
call hMo(lKe,g3v)
call hMo(lKe,g4v)
call hMo(lKe,lle)
set bbv[(lKe)]=((7.5)*1.)
set bFv[(lKe)]=((3)*1.)
set bgv[(lKe)]=((.4)*1.)
set bBv[(lKe)]=((17.5)*1.)
set bGv[(lKe)]=((4.5)*1.)
set bcv[(lKe)]=((5)*1.)
set bhv[(lKe)]=((2.5)*1.)
return true
endfunction
function Kkr takes nothing returns boolean
set lLe=Vbx("OFaS")
return true
endfunction
function KKr takes nothing returns boolean
call LZx('AFaS',false)
set g4v=Lzo('AFaS')
set G6[(g4v)]=(c6)
set j6[(g4v)]=(3)
set sH[(g4v)]=("Fairy Shape")
set Ih[(g4v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00D3)))),(((Oj))))))
set x6v[(g4v)]=(0)
set xzv[(g4v)]=("spell")
call LZo((g4v),u6v+(1),((300)*1.))
call LZo((g4v),fH+(1),(($F)*1.))
call LZo((g4v),QH+(1),((90)*1.))
call LZo((g4v),Lvv+(1),((750)*1.))
call LZo((g4v),u6v+(2),((300)*1.))
call LZo((g4v),fH+(2),(($F)*1.))
call LZo((g4v),QH+(2),(('i')*1.))
call LZo((g4v),Lvv+(2),((750)*1.))
call LZo((g4v),u6v+(3),((300)*1.))
call LZo((g4v),fH+(3),(($F)*1.))
call LZo((g4v),QH+(3),(('x')*1.))
call LZo((g4v),Lvv+(3),((750)*1.))
set Mnv[(g4v)]=("ReplaceableTextures\\CommandButtons\\BTNManaBurn.blp")
call ccr(g4v,'FFS0',3,'VFS0','LPFS','LRFS')
set lme[1]=50
set lme[2]=80
set lme[3]='n'
set lMe[1]=5
set lMe[2]=5
set lMe[3]=5
set lpe[1]=6
set lpe[2]=6
set lpe[3]=6
set lPe[1]=$A
set lPe[2]=$E
set lPe[3]=$E
set lqe[1]=4
set lqe[2]=4
set lqe[3]=4
set HEe[1]=4
set HEe[2]=5
set HEe[3]=6
set lQe[1]=.5
set lQe[2]=.5
set lQe[3]=.5
set c2e[1]=.5
set c2e[2]=.7
set c2e[3]=.9
set lse[1]=2
set lse[2]=2
set lse[3]=2
return true
endfunction
function Klr takes nothing returns boolean
call VRx(qa,(function Kfr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairyShape.page\\FairyShape.struct\\obj_revertAbility_wc3spell.j"))
call VRx(Ma,(function KFr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairyShape.page\\FairyShape.struct\\obj_eclipseBuff_wc3buff.j"))
call VRx(qa,(function Kgr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairyShape.page\\FairyShape.struct\\obj_changerAbility_wc3spell.j"))
call VRx(Ma,(function Kjr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairyShape.page\\FairyShape.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(Sa,(function KJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairyShape.page\\FairyShape.struct\\obj_thisUnitType_wc3unit.j"))
call VRx(Ha,(function Kkr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairyShape.page\\FairyShape.struct\\obj_bolt_wc3bolt.j"))
call VRx(qa,(function KKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairyShape.page\\FairyShape.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function KLr takes nothing returns boolean
set lSe=Vnx(lke)
return true
endfunction
function Kmr takes nothing returns boolean
local integer CMx=Ib
local integer Ixx=jFx()
local integer KMr
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if((LF[(Ixx)])<=.0)then
return false
endif
set KMr=oPx(CMx,lue+Ixx)
if(KMr<lUe)then
set lUe=KMr
endif
return true
return true
endfunction
function Kpr takes integer oqx,integer Ajo,integer KPr returns nothing
call rQx((oqx),KPr)
call UnitRemoveAbility(C[(((oqx)))],(KPr))
call AJo(oqx,Ajo)
endfunction
function Kqr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=RVx()
if(oPx(Ib,lue+Ixx)>lUe)then
call GroupRemoveUnit(Kb[(lte)],C[(Ixx)])
endif
return true
endfunction
function KQr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local real O1o=lwe[oqx]
local integer CMx=oqx
local integer rwx=lYe[oqx]
local real x=(GetUnitX(C[((CMx))]))
local real y=(GetUnitY(C[((CMx))]))
local integer Ixx
local real Ksr
local real Anr
local integer Q7o
local integer clo
local real KSr
local real Ydo
set Hf=(ze[(CMx)])
set Ib=CMx
set lUe=l0e
call Nio(lte,x,y,O1o,lTe)
call ForGroup(Kb[(lte)],(function Kqr))
set Ixx=(mjo((lte),((x)*1.),((y)*1.)))
if(Ixx!=w)then
set Ksr=lWe[oqx]
set Anr=lye[oqx]
set Q7o=l_e[oqx]
call I8x(CMx,lue+Ixx,1)
if not Lko(Q7o,Ixx)then
call AYo(Ixx)
call GroupAddUnit(Kb[(Q7o)],C[(Ixx)])
endif
set clo=cBo(lLe)
call EEr(clo,CMx,Ixx)
call cko(clo,.35)
call RUx((Abx((Ixx),(l1e),(l2e),(ri))))
if not nIo(Ixx)then
if I6x(Ixx,yd)then
set KSr=lse[rwx]
else
set KSr=lqe[rwx]
endif
call NIx((Ixx),(lJe),(rwx),w,((KSr)*1.))
set Ydo=itx((LF[(Ixx)]),Ksr)
call YBo(CMx,Ixx,Ydo)
call moo(CMx,CMx,Ydo*1./ Ksr*Anr)
endif
endif
endfunction
function Ktr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer oqx=CMx
local integer p0x=inx()
set lwe[oqx]=(Cpx((g4v),u6v+(rwx)))
set lWe[oqx]=lme[rwx]
set lye[oqx]=lPe[rwx]
set lYe[oqx]=rwx
set lze[oqx]=(uf[(CMx)])
set lZe[oqx]=p0x
set l_e[oqx]=O2x()
set ge[(p0x)]=(oqx)
call Kpr(CMx,lKe,'AFSC')
call icx(p0x,lQe[rwx],true,function KQr)
if(oPx((((CMx))),(yb+(l3e)))>0)then
call Ayx(CMx,cH)
endif
return true
endfunction
function KTr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer oqx=CMx
local integer p0x=lZe[oqx]
local integer Kur=lze[oqx]
local integer Q7o=l_e[oqx]
local integer Ixx
call ijx(p0x)
loop
set Ixx=Nao(Q7o)
exitwhen(Ixx==w)
call rix(CMx,lue+Ixx)
call KFx(Ixx)
endloop
call Kpr(CMx,Kur,'AFSX')
return true
endfunction
function KUr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Mv[(rdx)])
call NIx(((Vv[(rdx)])),(c0e),(rwx),w,((lMe[rwx])*1.))
return true
endfunction
function Kwr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local real x=l4e
local real y=l5e
local integer oqx=Ixx
set l6e[oqx]=(mHo(((x)*1.),((y)*1.),(l7e),(ri)))
set l8e[oqx]=x
set l9e[oqx]=y
return true
endfunction
function KWr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer Kyr=l6e[oqx]
call mFo(Kyr)
return true
endfunction
function KYr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer oqx=CMx
local real x=l8e[oqx]
local real y=l9e[oqx]
call Ayx(CMx,lhe)
call mFo((mHo((((GetUnitX(C[((CMx))])))*1.),(((GetUnitY(C[((CMx))])))*1.),(Lve),(ri))))
call JLr(CMx,x,y,XYx(x,y))
call mFo((mHo(((x)*1.),((y)*1.),(Lee),(ri))))
call Ayx(CMx,c0e)
return true
endfunction
function Kzr takes nothing returns nothing
call l9x(lhe,XBx("FolderFairyShape_StructRevert_Init: call FolderFairyShape_StructRevert.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderFairyShape_StructRevert.Event_BuffGain))",Bd,pI,function Kwr))
call l9x(lhe,XBx("FolderFairyShape_StructRevert_Init: call FolderFairyShape_StructRevert.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderFairyShape_StructRevert.Event_BuffLose))",Jc,pI,function KWr))
call meo(lGe,XBx("FolderFairyShape_StructRevert_Init: call FolderFairyShape_StructRevert.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderFairyShape_StructRevert.Event_SpellEffect))",ah,pI,function KYr))
endfunction
function KZr takes nothing returns boolean
set lte=O2x()
set lTe=XLx(function Kmr)
call l9x(c0e,XBx("FairyShape_Init: call FairyShape.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FairyShape.Event_BuffGain))",Bd,pI,function Ktr))
call l9x(c0e,XBx("FairyShape_Init: call FairyShape.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FairyShape.Event_BuffLose))",Jc,pI,function KTr))
call meo(g4v,XBx("FairyShape_Init: call FairyShape.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FairyShape.Event_SpellEffect))",ah,pI,function KUr))
call W_x(ENv,lJe)
call Kzr()
return true
endfunction
function K_r takes nothing returns boolean
call FOr(function KZr,"FairyShape_Init")
return true
endfunction
function K0r takes nothing returns boolean
set Lxe[1]=1
set Lxe[2]=2
set Lxe[3]=3
set Loe[1]=$F
set Loe[2]=25
set Loe[3]=35
return true
endfunction
function K1r takes nothing returns boolean
set Lre=lQx(Lie+" (coldnessBuff)")
set qc[(Lre)]=(true)
set qU[(Lre)]=(true)
return true
endfunction
function K2r takes nothing returns boolean
set Lae=lQx(Lie+" (dummyBuff)")
set qc[(Lae)]=(true)
call lux(Lae,"Abilities\\Spells\\NightElf\\Starfall\\StarfallTarget.mdl","origin",ri)
return true
endfunction
function K3r takes nothing returns boolean
call VRx(ea,(function K0r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairysTears.page\\FairysTears.struct\\Target\\obj_this_wc3obj.j"))
call VRx(Ma,(function K1r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairysTears.page\\FairysTears.struct\\Target\\obj_coldnessBuff_wc3buff.j"))
call VRx(Ma,(function K2r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairysTears.page\\FairysTears.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function K4r takes nothing returns boolean
set Lne=Vnx(Lie)
return true
endfunction
function K5r takes nothing returns boolean
call LZx('AFyT',false)
set LVe=Lzo('AFyT')
set G6[(LVe)]=(c6)
set j6[(LVe)]=(3)
set sH[(LVe)]=("Fairy's Tears")
set Ih[(LVe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00D7)))),(((Oj))))))
set x6v[(LVe)]=(0)
set xzv[(LVe)]=("spell,channel")
call LZo((LVe),u6v+(1),((450)*1.))
call LZo((LVe),BH+(1),((24)*1.))
call LZo((LVe),fH+(1),((80)*1.))
call LZo((LVe),QH+(1),(($FA)*1.))
call LZo((LVe),Lvv+(1),((750)*1.))
call LZo((LVe),u6v+(2),((525)*1.))
call LZo((LVe),BH+(2),((27)*1.))
call LZo((LVe),fH+(2),((80)*1.))
call LZo((LVe),QH+(2),((350)*1.))
call LZo((LVe),Lvv+(2),((750)*1.))
call LZo((LVe),u6v+(3),((600)*1.))
call LZo((LVe),BH+(3),((30)*1.))
call LZo((LVe),fH+(3),((80)*1.))
call LZo((LVe),QH+(3),((450)*1.))
call LZo((LVe),Lvv+(3),((750)*1.))
set Mnv[(LVe)]=("ReplaceableTextures\\CommandButtons\\BTNStarfall.blp")
call ccr(LVe,'FFy0',3,'VFy0','LPFy','LRFy')
return true
endfunction
function K6r takes nothing returns boolean
set LEe=lQx(LXe+" (dummyBuff)")
call lux(LEe,"Abilities\\Spells\\NightElf\\Starfall\\StarfallCaster.mdl","origin",ri)
return true
endfunction
function K7r takes nothing returns boolean
call VRx(qa,(function K5r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairysTears.page\\FairysTears.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function K6r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairysTears.page\\FairysTears.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function K8r takes nothing returns boolean
set LOe=Vnx(LXe)
return true
endfunction
function K9r takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if(oPx((((Ixx))),(yb+(Lae)))>0)then
return false
endif
return true
return true
endfunction
function lvr takes integer CMx,real NIo,integer rwx,integer Ixx returns nothing
set gf=NIo
set Ib=CMx
call NIx((Ixx),(Lae),(rwx),w,((LDe)*1.))
endfunction
function ler takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
local integer woo
set Hf=(ze[(Ixx)])
call Nio(LRe,(GetUnitX(C[((Ixx))])),(GetUnitY(C[((Ixx))])),LAe[oqx],LIe)
set woo=(onr((LRe)))
if(woo!=w)then
call lvr(Ixx,LNe[oqx],LCe[oqx],woo)
endif
endfunction
function lxr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local real dix=(GetUnitX(C[((Ixx))]))
local real dax=(GetUnitY(C[((Ixx))]))
local integer oqx=Ixx
local integer HOx=mcx('qStf',dix,dax,XYx(dix,dax),.0)
local integer p0x=inx()
set LAe[oqx]=(Cpx((LVe),u6v+(rwx)))
set LNe[oqx]=Loe[rwx]+(ZF[(Ixx)])*Lbe
set LBe[oqx]=HOx
set Lce[oqx]=p0x
set LCe[oqx]=rwx
set ge[(p0x)]=(oqx)
call HTr(HOx,Ixx,false,false,.0,.0,.0)
call k2o(HOx,(Cpx((LVe),u6v+(rwx)))*4*1./(4*128.))
call icx(p0x,Lde,true,function ler)
return true
endfunction
function lor takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer HOx=LBe[oqx]
local integer p0x=Lce[oqx]
call Mfx(HOx)
call ijx(p0x)
return true
endfunction
function lrr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),LEe)
return true
endfunction
function lir takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(LEe),((Mv[(rdx)])),w)
return true
endfunction
function lar takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
call NIx((Ixx),(Lre),(LGe[oqx]),w,((Lxe[LGe[oqx]])*1.))
call nJo((Lfe[oqx]),(Ixx),((LFe[oqx])*1.),(true),(false))
endfunction
function lnr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=Ib
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer JVr=inx()
set Lfe[oqx]=CMx
set LFe[oqx]=gf
set Lge[oqx]=JVr
set LGe[oqx]=rwx
set ge[(JVr)]=(oqx)
call icx(JVr,Lhe,false,function lar)
return true
endfunction
function lVr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer JVr=Lge[oqx]
call ijx(JVr)
return true
endfunction
function lEr takes nothing returns nothing
call l9x(Lae,XBx("FolderFairysTears_StructTarget_Init: call FolderFairysTears_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderFairysTears_StructTarget.Event_BuffGain))",Bd,pI,function lnr))
call l9x(Lae,XBx("FolderFairysTears_StructTarget_Init: call FolderFairysTears_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderFairysTears_StructTarget.Event_BuffLose))",Jc,pI,function lVr))
call W_x(nxv,Lre)
endfunction
function lXr takes nothing returns boolean
set LRe=O2x()
set LIe=XLx(function K9r)
call l9x(LEe,XBx("FairysTears_Init: call FairysTears.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FairysTears.Event_BuffGain))",Bd,pI,function lxr))
call l9x(LEe,XBx("FairysTears_Init: call FairysTears.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FairysTears.Event_BuffLose))",Jc,pI,function lor))
call meo(LVe,XBx("FairysTears_Init: call FairysTears.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FairysTears.Event_EndCast))",oev,pI,function lrr))
call meo(LVe,XBx("FairysTears_Init: call FairysTears.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FairysTears.Event_SpellEffect))",ah,pI,function lir))
call lEr()
return true
endfunction
function lOr takes nothing returns boolean
call FOr(function lXr,"FairysTears_Init")
return true
endfunction
function lRr takes nothing returns boolean
set LHe=hGo('uFLD')
call hho(((LHe)),Apv,(ICv))
set Tj[(LHe)]=((1)*1.)
call hHo(LHe,$FF,$FF,$FF,$FF)
set Nav[(LHe)]=(('d')*1.)
set Ntv[(LHe)]=(('d')*1.)
set Nlv[(LHe)]=((1)*1.)
set I3v[(LHe)]=((0)*1.)
set Axv[(LHe)]=(3)
set NJv[(LHe)]=((150000.)*1.)
set Njv[(LHe)]=((150000.)*1.)
set Nhv[(LHe)]=((0)*1.)
set NKv[(LHe)]=(($3E8)*1.)
set Nkv[(LHe)]=(($3E8)*1.)
set NHv[(LHe)]=((1)*1.)
set NIv[(LHe)]=(($4B0)*1.)
set NOv[(LHe)]=(($4B0)*1.)
set Ndv[(LHe)]=(($3E8)*1.)
set AQv[(LHe)]=((0)*1.)
set Asv[(LHe)]=((0)*1.)
set Auv[(LHe)]=(0)
set AWv[(LHe)]=(0)
set Aqv[(LHe)]=(($96)*1.)
call hLo((LHe),(gQv),1)
return true
endfunction
function lIr takes nothing returns boolean
call LZx('AFLD',false)
set Giv=Lzo('AFLD')
set G6[(Giv)]=(C6)
set j6[(Giv)]=(3)
set sH[(Giv)]=("Fountain of Life and Death")
set Ih[(Giv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D022D)))),(((Oj))))))
set x6v[(Giv)]=(2)
set xzv[(Giv)]=("spell")
call LZo((Giv),u6v+(1),((500)*1.))
call LZo((Giv),fH+(1),(('x')*1.))
call LZo((Giv),QH+(1),((300)*1.))
call LZo((Giv),Lvv+(1),((750)*1.))
call LZo((Giv),u6v+(2),((600)*1.))
call LZo((Giv),fH+(2),(('n')*1.))
call LZo((Giv),QH+(2),((375)*1.))
call LZo((Giv),Lvv+(2),((750)*1.))
call LZo((Giv),u6v+(3),((700)*1.))
call LZo((Giv),fH+(3),(('d')*1.))
call LZo((Giv),QH+(3),((450)*1.))
call LZo((Giv),Lvv+(3),((750)*1.))
set Mnv[(Giv)]=("ReplaceableTextures\\CommandButtons\\BTNFountainOfLife.blp")
call ccr(Giv,'FFL0',3,'VFL0','LPFL','LRFL')
set Lje[1]=30
set Lje[2]=45
set Lje[3]=60
return true
endfunction
function lAr takes nothing returns boolean
call VRx(Sa,(function lRr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FountainOfLifeAndDeath.page\\FountainOfLifeAndDeath.struct\\obj_FountainType_wc3unit.j"))
call VRx(qa,(function lIr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FountainOfLifeAndDeath.page\\FountainOfLifeAndDeath.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function lNr takes nothing returns boolean
set LJe=Vnx(Lke)
return true
endfunction
function lbr takes integer oqx returns integer
set LMe[oqx]=true
set Lpe[oqx]=false
call rax(LJe)
return oqx
endfunction
function lBr takes nothing returns integer
local integer oqx
if(LKe==8190)then
call oYx("FountainOfLifeAndDeath_Allocation_allocCustom","call DebugEx(FountainOfLifeAndDeath.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Lke+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Lle[(w)]==w)then
set LLe=LLe+1
set oqx=LLe
else
set oqx=Lle[(w)]
set Lle[(w)]=Lle[Lle[(w)]]
endif
set Lle[oqx]=Z
set Lme[oqx]=1
call lbr(oqx)
return oqx
endfunction
function lcr takes integer lCr,integer CMx,integer rwx returns nothing
call DSx(lCr,LQe,rwx,CMx)
endfunction
function ldr takes integer CMx,integer rwx returns nothing
call rzx((CMx),(Lse),(rwx))
call Rnx(CMx,Lse)
endfunction
function lDr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local integer oqx=lBr()
local real N8x=UCx(CMx,dix-(GetUnitX(C[((CMx))])),dax-(GetUnitY(C[((CMx))])))
local integer lCr=Uzo(LHe,(ze[(CMx)]),dix,dax,N8x,Lje[rwx])
set dix=(GetUnitX(C[((lCr))]))
set dax=(GetUnitY(C[((lCr))]))
call Rhr(lCr,dix,dax,XYx(dix,dax)+LPe,Lqe)
call lcr(lCr,CMx,rwx)
call ldr(lCr,rwx)
return true
endfunction
function lfr takes nothing returns boolean
call meo(Giv,XBx("FountainOfLifeAndDeath_Init: call FountainOfLifeAndDeath.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FountainOfLifeAndDeath.Event_SpellEffect))",ah,pI,function lDr))
return true
endfunction
function lFr takes nothing returns boolean
call FOr(function lfr,"FountainOfLifeAndDeath_Init")
return true
endfunction
function lgr takes nothing returns boolean
set LSe=WTx('BFLT',"Fountain of Life and Death - weakened",'bFLT')
set aev[(LSe)]=("ReplaceableTextures\\CommandButtons\\BTNOrbOfDarkness.blp")
call lux(LSe,"Abilities\\Spells\\Other\\Drain\\DrainTarget.mdl","origin",ri)
set SU=lYx()
call l_x(SU,nvv,-.3)
call l0x(((LSe)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,nvv,-.4)
call l0x(((LSe)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,nvv,-.5)
call l0x(((LSe)),vc+(3),(SU))
return true
endfunction
function lGr takes nothing returns boolean
set Lte[1]=-.3
set Lte[2]=-.4
set Lte[3]=-.5
return true
endfunction
function lhr takes nothing returns boolean
call VRx(Ma,(function lgr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FountainOfLifeAndDeath.page\\FountainOfLifeAndDeath.struct\\DecayAura.page\\DecayAura.struct\\Target\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function lGr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FountainOfLifeAndDeath.page\\FountainOfLifeAndDeath.struct\\DecayAura.page\\DecayAura.struct\\Target\\obj_this_wc3obj.j"))
return true
endfunction
function lHr takes nothing returns boolean
set LTe=Vnx(Lue)
return true
endfunction
function ljr takes nothing returns boolean
call LZx('ADkA',false)
set LUe=Lzo('ADkA')
set j6[(LUe)]=(3)
set sH[(LUe)]=("Decay Aura")
set xzv[(LUe)]=("spell")
set Mnv[(LUe)]=("ReplaceableTextures\\PassiveButtons\\PASBTNShadeTrueSight.blp")
return true
endfunction
function lJr takes nothing returns boolean
set LQe=lQx(Lwe+" (dummyBuff)")
call lux(LQe,"Abilities\\Spells\\Undead\\Darksummoning\\DarkSummonTarget.mdl","origin",Bi)
return true
endfunction
function lkr takes nothing returns boolean
set LWe[1]=30
set LWe[2]=40
set LWe[3]=50
return true
endfunction
function lKr takes nothing returns boolean
call VRx(qa,(function ljr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FountainOfLifeAndDeath.page\\FountainOfLifeAndDeath.struct\\DecayAura.page\\DecayAura.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function lJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FountainOfLifeAndDeath.page\\FountainOfLifeAndDeath.struct\\DecayAura.page\\DecayAura.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function lkr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FountainOfLifeAndDeath.page\\FountainOfLifeAndDeath.struct\\DecayAura.page\\DecayAura.struct\\obj_this_wc3obj.j"))
return true
endfunction
function llr takes nothing returns boolean
set Lye=Vnx(Lwe)
return true
endfunction
function lLr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function lmr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=(mj[(rdx)])
call nJo((LZe[oqx]),(Ixx),((L_e[oqx])*1.),(true),(false))
return true
endfunction
function lMr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
call DDx((vLe[(Lze[oqx])]),function lmr,oqx)
endfunction
function lpr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(mc[(rdx)])
local integer lCr=(Vv[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer XSr=Xpr(lCr)
local integer p0x=inx()
local integer oqx=lCr
set Lze[oqx]=XSr
set LZe[oqx]=CMx
set L_e[oqx]=L0e[rwx]
set L1e[oqx]=p0x
set L2e[oqx]=rwx
set Eee[(XSr)]=(oqx)
set ge[(p0x)]=(oqx)
set vme[(XSr)]=(((Cpx((Giv),u6v+(rwx))))*1.)
set vMe[(XSr)]=(LYe)
call XPr(XSr,L3e)
call XPr(XSr,L4e)
call XQr(XSr)
call icx(p0x,L5e,true,function lMr)
return true
endfunction
function lPr takes nothing returns boolean
local integer rdx=(bv)
local integer lCr=(Vv[(rdx)])
local integer oqx=lCr
local integer XSr=Lze[oqx]
local integer p0x=L1e[oqx]
call X2r(XSr)
call ijx(p0x)
return true
endfunction
function lqr takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer rkx=(Eee[(XSr)])
call UJx(Ixx,LSe)
return true
endfunction
function lQr takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer CMx=(vhe[(XSr)])
local integer rkx=(Eee[(XSr)])
local integer rwx=L2e[rkx]
call DSx((Ixx),(LSe),(rwx),w)
return true
endfunction
function lsr takes nothing returns nothing
set L3e=XBx("FolderDecayAura_StructTarget_Init: set FolderDecayAura_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderDecayAura_StructTarget.Event_Ending)",vQe,pI,function lqr)
set L4e=XBx("FolderDecayAura_StructTarget_Init: set FolderDecayAura_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderDecayAura_StructTarget.Event_Start)",vse,pI,function lQr)
endfunction
function lSr takes nothing returns boolean
local integer olx
set LYe=XLx(function lLr)
call l9x(LQe,XBx("DecayAura_Init: call DecayAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DecayAura.Event_BuffGain))",Bd,pI,function lpr))
call l9x(LQe,XBx("DecayAura_Init: call DecayAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DecayAura.Event_BuffLose))",Jc,pI,function lPr))
set olx=(j6[(LUe)])
loop
exitwhen(olx<1)
set L0e[olx]=LWe[olx]*L5e
set olx=olx-1
endloop
call lsr()
return true
endfunction
function ltr takes nothing returns boolean
call FOr(function lSr,"DecayAura_Init")
return true
endfunction
function lTr takes nothing returns boolean
set L6e=Vnx(L7e)
return true
endfunction
function lur takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=FJx((av[(rdx)]))
return true
return true
endfunction
function lUr takes nothing returns boolean
local integer rdx=(bv)
local integer Fmx=Fkx((nv[(rdx)]),L8e)
call xur((Vv[(rdx)]),Fmx)
return true
endfunction
function lwr takes nothing returns boolean
local integer rdx=(bv)
local integer Fmx=Fkx((nv[(rdx)]),L8e)
call xZr((Vv[(rdx)]),Fmx)
return true
endfunction
function lWr takes integer rJx,code Xbx returns integer
local integer Fmx=e5r(Xbx)
set vze[(Fmx)]=(XLx(function lur))
if(e7r(rJx,1)>.0)then
call xKr(Fmx,pH,cK,PH,dK,EK)
endif
if(FQx(rJx,1)>.0)then
call xqr(Fmx,MF,(R2I(((FQx(rJx,1))*1.))),GREATER_THAN_OR_EQUAL,DK)
endif
call xQr(Fmx,BK,rJx)
call CTx(rJx,L8e,Fmx)
call meo(rJx,XBx("AIAutoCast_CreateBasics: call whichSpell.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.AI, function AIAutoCast.Event_Learn))",pv,jI,function lUr))
call meo(rJx,XBx("AIAutoCast_CreateBasics: call whichSpell.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.AI, function AIAutoCast.Event_Unlearn))",Av,jI,function lwr))
call xKr(Fmx,sb,FK,sb,fK,gK)
return Fmx
endfunction
function lyr takes nothing returns boolean
local integer rdx=(bv)
call O9x(((LoadInteger(o[((V[(E[((X))])]))],(((OK+(((av[(rdx)])))))),(((IK)))))),(Ih[((Lse))]))
return true
endfunction
function lYr takes nothing returns boolean
local integer Fmx=lWr(Lse,function lyr)
call odr(Fmx,1.)
return true
endfunction
function lzr takes nothing returns boolean
call e1r(function lYr,"AIPalingenesis_Init")
return true
endfunction
function lZr takes nothing returns boolean
set L9e=WTx('BFDL',"Revived",'bFDL')
set aev[(L9e)]=("ReplaceableTextures\\CommandButtons\\BTNAnimateDead.blp")
return true
endfunction
function l_r takes nothing returns boolean
call LZx('AFLX',false)
set Lse=Lzo('AFLX')
set j6[(Lse)]=(3)
set sH[(Lse)]=("Palingenesis")
set Ih[(Lse)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0251)))),(((Oj))))))
set qb[(Lse)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0253)))),(((Oj))))))
set Sb[(Lse)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0252)))),(((Oj))))))
set xzv[(Lse)]=("spell")
call LZo((Lse),u6v+(1),((500)*1.))
call LZo((Lse),fH+(1),((6)*1.))
call LZo((Lse),QH+(1),(('d')*1.))
call LZo((Lse),u6v+(2),((600)*1.))
call LZo((Lse),fH+(2),((6)*1.))
call LZo((Lse),QH+(2),(('d')*1.))
call LZo((Lse),u6v+(3),((700)*1.))
call LZo((Lse),fH+(3),((6)*1.))
call LZo((Lse),QH+(3),(('d')*1.))
set Mnv[(Lse)]=("ReplaceableTextures\\CommandButtons\\BTNOrbOfDarkness.blp")
set mve[1]=30
set mve[2]=30
set mve[3]=30
return true
endfunction
function l0r takes nothing returns boolean
call VRx(Ma,(function lZr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FountainOfLifeAndDeath.page\\FountainOfLifeAndDeath.struct\\Palingenesis.page\\Palingenesis.struct\\obj_summonBuff_wc3buff.j"))
call VRx(qa,(function l_r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FountainOfLifeAndDeath.page\\FountainOfLifeAndDeath.struct\\Palingenesis.page\\Palingenesis.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function l1r takes nothing returns boolean
set mee=Vnx(mxe)
return true
endfunction
function l2r takes nothing returns boolean
local integer Ixx=jFx()
if not I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
return true
return true
endfunction
function l3r takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=mie[oqx]
local integer rwx=mae[oqx]
local integer C0o=(ze[(CMx)])
call Mdo(MFo)
if(Ixx==w)then
return true
endif
if not I6x(Ixx,sc)then
return true
endif
call RUx((Abx((Ixx),(mVe),(mEe),(ri))))
call ahr(Ixx)
call DSx((Ixx),(L9e),(rwx),w)
call aNx(Ixx,C0o)
call UYo(Ixx,mve[rwx])
set nFv[(Ixx)]=(mXe)
call fhx(Ixx,-$80,-$80,-$80,0)
return true
endfunction
function l4r takes integer CMx,integer rwx,integer Ixx returns nothing
local integer MFo=Mvo()
local integer oqx=MFo
set mie[oqx]=CMx
set mae[oqx]=rwx
set mne[oqx]=Ixx
set mAv[((MFo))]=((b6v*((.06)*1.))*1.)
set mNv[(MFo)]=((10.)*1.)
call Mro(MFo,'qFDM',2.)
set mCv[(MFo)]=XHx((function l3r))
set mWv[(MFo)]=(oqx)
call m8o(MFo,500.)
call M9o(MFo,CMx)
call M3o((MFo),(Ixx),.0,.0,.0,(function M5o))
endfunction
function l5r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx
local real x=(GetUnitX(C[((CMx))]))
local real y=(GetUnitY(C[((CMx))]))
call Nio(moe,x,y,(Cpx((Lse),u6v+(rwx))),mre)
set Ixx=WHo(moe,x,y)
if(Ixx==w)then
return true
endif
call l4r(CMx,rwx,Ixx)
return true
endfunction
function l6r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real x=(GetUnitX(C[((CMx))]))
local real y=(GetUnitY(C[((CMx))]))
call Nio(moe,x,y,(Cpx((Lse),u6v+(rwx))),mre)
return not((aBx(FirstOfGroup(Kb[((moe))])))==w)
return true
endfunction
function l7r takes nothing returns boolean
set moe=O2x()
set mre=XLx(function l2r)
call meo(Lse,XBx("Palingenesis_Init: call Palingenesis.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Palingenesis.Event_SpellEffect))",ah,pI,function l5r))
set Ah[(Lse)]=(XLx(function l6r))
return true
endfunction
function l8r takes nothing returns boolean
call FOr(function l7r,"Palingenesis_Init")
return true
endfunction
function l9r takes nothing returns boolean
set mOe[1]=.5
set mOe[2]=.5
set mOe[3]=.5
set mOe[4]=.5
set mOe[5]=.5
set mOe[6]=.5
return true
endfunction
function Lvr takes nothing returns boolean
set mRe=lQx(mIe+" (dummyBuff)")
return true
endfunction
function Ler takes nothing returns boolean
call VRx(ea,(function l9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\GarmentsOfTheSalamander.page\\GarmentsOfTheSalamander.struct\\Regen\\obj_this_wc3obj.j"))
call VRx(Ma,(function Lvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\GarmentsOfTheSalamander.page\\GarmentsOfTheSalamander.struct\\Regen\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function Lxr takes nothing returns boolean
set mAe=Vnx(mIe)
return true
endfunction
function Lor takes nothing returns boolean
call LZx('ASaR',false)
set mNe=Lzo('ASaR')
set G6[(mNe)]=(N6)
set j6[(mNe)]=(6)
set sH[(mNe)]=("Revert to Human Form")
set Ih[(mNe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0089)))),(((Oj))))))
set x6v[(mNe)]=(0)
set xzv[(mNe)]=("spell")
call LZo((mNe),fH+(1),((3)*1.))
call LZo((mNe),Lvv+(1),((750)*1.))
call LZo((mNe),fH+(2),((3)*1.))
call LZo((mNe),Lvv+(2),((750)*1.))
call LZo((mNe),fH+(3),((3)*1.))
call LZo((mNe),Lvv+(3),((750)*1.))
call LZo((mNe),fH+(4),((3)*1.))
call LZo((mNe),Lvv+(4),((750)*1.))
call LZo((mNe),fH+(5),((3)*1.))
call LZo((mNe),Lvv+(5),((750)*1.))
call LZo((mNe),fH+(6),((3)*1.))
call LZo((mNe),Lvv+(6),((750)*1.))
set Mnv[(mNe)]=("ReplaceableTextures\\CommandButtons\\BTNHeroBloodElfPrince.blp")
call ccr(mNe,'FSR0',6,'VSR0','LPSR','LRSR')
return true
endfunction
function Lrr takes nothing returns boolean
call LZx('ASaX',false)
return true
endfunction
function Lir takes nothing returns boolean
set mbe=hGo('USal')
call hLo((mbe),('AInv'),1)
call hho(((mbe)),Apv,(yd))
call hho(((mbe)),Apv,(INv))
set Tj[(mbe)]=((.95)*1.)
call hHo(mbe,$FF,$96,$AA,$FF)
set Nav[(mbe)]=((110.80332409972)*1.)
set Ntv[(mbe)]=((22.160664819945)*1.)
set Nlv[(mbe)]=((280)*1.)
set I3v[(mbe)]=((1)*1.)
set Axv[(mbe)]=(4)
set NJv[(mbe)]=(('d')*1.)
set Njv[(mbe)]=(('d')*1.)
set Nhv[(mbe)]=((0)*1.)
set NKv[(mbe)]=(('d')*1.)
set Nkv[(mbe)]=(('d')*1.)
set NHv[(mbe)]=((0)*1.)
set NIv[(mbe)]=(($578)*1.)
set NOv[(mbe)]=(($578)*1.)
set ANv[(mbe)]=(gKv)
set Adv[(mbe)]=((360)*1.)
set ADv[((mbe))]=((1.*1./((1.8)*1.))*1.)
set Atv[(mbe)]=((.5)*1.)
set Drv[(mbe)]=((500)*1.)
set AQv[(mbe)]=((29)*1.)
set Asv[(mbe)]=((29)*1.)
set Auv[(mbe)]=(1)
set AWv[(mbe)]=($A)
set Azv[(mbe)]=(0)
set Aqv[(mbe)]=((53.185595567867)*1.)
set Nxv[(mbe)]=(20)
set Nvv[(mbe)]=($A)
set bbv[(mbe)]=((6)*1.)
set bFv[(mbe)]=((2.5)*1.)
set bgv[(mbe)]=((.8)*1.)
set bBv[(mbe)]=((16)*1.)
set bGv[(mbe)]=((4.5)*1.)
set bcv[(mbe)]=((9)*1.)
set bhv[(mbe)]=((3.5)*1.)
call hLo((mbe),(GGv),1)
call hLo((mbe),(Ghv),1)
call hLo((mbe),(GHv),1)
call hLo((mbe),(lle),1)
return true
endfunction
function Lar takes nothing returns boolean
call LZx('ASaC',false)
return true
endfunction
function Lnr takes nothing returns boolean
set mBe=lQx(mce+" (dummyBuff)")
call lux(mBe,"Units\\Aura.mdx","origin",ri)
set SU=lYx()
call l_x(SU,Dgv,3)
call vOr(SU,Djv,true)
call lzx(((SU)),Fc,(KHr(Db,.2,.5)))
call l0x(((mBe)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,Dgv,5)
call vOr(SU,Djv,true)
call lzx(((SU)),Fc,(KHr(Db,.35,.5)))
call l0x(((mBe)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,Dgv,7)
call vOr(SU,Djv,true)
call lzx(((SU)),Fc,(KHr(Db,.5,.5)))
call l0x(((mBe)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,Dgv,9)
call vOr(SU,Djv,true)
call lzx(((SU)),Fc,(KHr(Db,.65,.5)))
call l0x(((mBe)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,Dgv,$B)
call vOr(SU,Djv,true)
call lzx(((SU)),Fc,(KHr(Db,.8,.5)))
call l0x(((mBe)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,Dgv,$D)
call vOr(SU,Djv,true)
call lzx(((SU)),Fc,(KHr(Db,.95,.5)))
call l0x(((mBe)),vc+(6),(SU))
return true
endfunction
function LVr takes nothing returns boolean
call LZx('ASam',false)
set Ghv=Lzo('ASam')
set G6[(Ghv)]=(N6)
set j6[(Ghv)]=(6)
set sH[(Ghv)]=("Garments of the Salamander")
set Ih[(Ghv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0089)))),(((Oj))))))
set x6v[(Ghv)]=(0)
set xzv[(Ghv)]=("spell")
call LZo((Ghv),u6v+(1),((500)*1.))
call LZo((Ghv),fH+(1),((5)*1.))
call LZo((Ghv),QH+(1),(($F)*1.))
call LZo((Ghv),Lvv+(1),((750)*1.))
call LZo((Ghv),u6v+(2),((500)*1.))
call LZo((Ghv),fH+(2),((5)*1.))
call LZo((Ghv),QH+(2),(($F)*1.))
call LZo((Ghv),Lvv+(2),((750)*1.))
call LZo((Ghv),u6v+(3),((500)*1.))
call LZo((Ghv),fH+(3),((5)*1.))
call LZo((Ghv),QH+(3),(($F)*1.))
call LZo((Ghv),Lvv+(3),((750)*1.))
call LZo((Ghv),u6v+(4),((500)*1.))
call LZo((Ghv),fH+(4),((5)*1.))
call LZo((Ghv),QH+(4),(($F)*1.))
call LZo((Ghv),Lvv+(4),((750)*1.))
call LZo((Ghv),u6v+(5),((500)*1.))
call LZo((Ghv),fH+(5),((5)*1.))
call LZo((Ghv),QH+(5),(($F)*1.))
call LZo((Ghv),Lvv+(5),((750)*1.))
call LZo((Ghv),u6v+(6),((500)*1.))
call LZo((Ghv),fH+(6),((5)*1.))
call LZo((Ghv),QH+(6),(($F)*1.))
call LZo((Ghv),Lvv+(6),((750)*1.))
set Mnv[(Ghv)]=("ReplaceableTextures\\CommandButtons\\BTNThunderLizardSalamander.blp")
call ccr(Ghv,'FGa0',6,'VGa0','LPGa','LRGa')
set mCe[1]=3
set mCe[2]=5
set mCe[3]=7
set mCe[4]=9
set mCe[5]=$B
set mCe[6]=$D
return true
endfunction
function LEr takes nothing returns boolean
call VRx(qa,(function Lor),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\GarmentsOfTheSalamander.page\\GarmentsOfTheSalamander.struct\\obj_revertSpell_wc3spell.j"))
call VRx(qa,(function Lrr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\GarmentsOfTheSalamander.page\\GarmentsOfTheSalamander.struct\\obj_revertAbility_wc3spell.j"))
call VRx(Sa,(function Lir),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\GarmentsOfTheSalamander.page\\GarmentsOfTheSalamander.struct\\obj_thisUnitType_wc3unit.j"))
call VRx(qa,(function Lar),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\GarmentsOfTheSalamander.page\\GarmentsOfTheSalamander.struct\\obj_changerAbility_wc3spell.j"))
call VRx(Ma,(function Lnr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\GarmentsOfTheSalamander.page\\GarmentsOfTheSalamander.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function LVr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\GarmentsOfTheSalamander.page\\GarmentsOfTheSalamander.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function LXr takes nothing returns boolean
set mde=Vnx(mce)
return true
endfunction
function LOr takes integer OBo,integer LRr,integer Oqx returns nothing
if((oPx((Oqx),Iyv+(OBo)))!=w)then
call Obo(LRr,Oqx)
endif
endfunction
function LIr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
set mDe[oqx]=(uf[(Ixx)])
call Kpr(Ixx,mbe,'ASaC')
call RUx((Abx((Ixx),(mfe),(mFe),(ri))))
call LOr(b6,NKe,Ixx)
call LOr(i6,jje,Ixx)
call LOr(N6,mNe,Ixx)
call DSx(((Ixx)),(mRe),((rwx)),w)
return true
endfunction
function LAr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer Kur=mDe[oqx]
call Kpr(Ixx,Kur,'ASaX')
call RUx((Abx((Ixx),(mfe),(mFe),(ri))))
call LOr(b6,SEv,Ixx)
call LOr(i6,GGv,Ixx)
call LOr(N6,Ghv,Ixx)
call Ayx((Ixx),mRe)
return true
endfunction
function LNr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),mBe)
return true
endfunction
function Lbr takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(mBe),((Mv[(rdx)])),w)
return true
endfunction
function LBr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if not(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function Lcr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer ozx=oqx
local integer LCr=mHe[oqx]
local integer rwx=(oPx(((ozx)),N+(mNe)))
local real x=(GetUnitX(C[((ozx))]))
local real y=(GetUnitY(C[((ozx))]))
local integer Ldr
set Hf=(ze[(ozx)])
call Nio(mge,x,y,(Cpx((Ghv),u6v+(rwx))),mGe)
set Ldr=(NXo((mge)))
call Iqx(ozx,LCr)
call lZx(((LCr)),Xc+(Dgv),((mOe[rwx]*Ldr)*1.))
call I0x(ozx,LCr)
if(rwx!=(oPx(((ozx)),zb+(mRe))))then
call Ayx(ozx,mRe)
call DSx((ozx),(mRe),(rwx),w)
endif
endfunction
function LDr takes nothing returns boolean
local integer rdx=(bv)
local integer ozx=(Vv[(rdx)])
local integer p0x=inx()
local integer LCr=lYx()
local integer oqx=ozx
set mhe[oqx]=p0x
set mHe[oqx]=LCr
set ge[(p0x)]=(oqx)
call l_x(LCr,Dgv,.0)
call I0x(ozx,LCr)
call icx(p0x,mje,true,function Lcr)
return true
endfunction
function Lfr takes nothing returns boolean
local integer rdx=(bv)
local integer ozx=(Vv[(rdx)])
local integer oqx=ozx
local integer p0x=mhe[oqx]
local integer LCr=mHe[oqx]
call ijx(p0x)
call Iqx(ozx,LCr)
call nrr(LCr)
return true
endfunction
function LFr takes nothing returns nothing
set mge=O2x()
set mGe=XLx(function LBr)
call l9x(mRe,XBx("FolderGarmentsOfTheSalamander_StructRegen_Init: call FolderGarmentsOfTheSalamander_StructRegen.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderGarmentsOfTheSalamander_StructRegen.Event_BuffGain))",Bd,pI,function LDr))
call l9x(mRe,XBx("FolderGarmentsOfTheSalamander_StructRegen_Init: call FolderGarmentsOfTheSalamander_StructRegen.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderGarmentsOfTheSalamander_StructRegen.Event_BuffLose))",Jc,pI,function Lfr))
endfunction
function Lgr takes nothing returns boolean
call l9x(mBe,XBx("GarmentsOfTheSalamander_Init: call GarmentsOfTheSalamander.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function GarmentsOfTheSalamander.Event_BuffGain))",Bd,pI,function LIr))
call l9x(mBe,XBx("GarmentsOfTheSalamander_Init: call GarmentsOfTheSalamander.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function GarmentsOfTheSalamander.Event_BuffLose))",Jc,pI,function LAr))
call meo(mNe,XBx("GarmentsOfTheSalamander_Init: call GarmentsOfTheSalamander.REVERT_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function GarmentsOfTheSalamander.Event_RevertSpellEffect))",ah,pI,function LNr))
call meo(Ghv,XBx("GarmentsOfTheSalamander_Init: call GarmentsOfTheSalamander.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function GarmentsOfTheSalamander.Event_SpellEffect))",ah,pI,function Lbr))
call LFr()
return true
endfunction
function LGr takes nothing returns boolean
call FOr(function Lgr,"GarmentsOfTheSalamander_Init")
return true
endfunction
function Lhr takes nothing returns boolean
set mJe=Vnx(mke)
return true
endfunction
function LHr takes nothing returns boolean
set mKe=Vnx(mle)
return true
endfunction
function Ljr takes nothing returns boolean
set mLe=Vnx(mme)
return true
endfunction
function LJr takes nothing returns boolean
set mMe=Vnx(mpe)
return true
endfunction
function Lkr takes nothing returns boolean
set mPe=WTx('BHNP',"Hand of Nature (Prison)",'bHNP')
set aev[(mPe)]=("ReplaceableTextures\\CommandButtons\\BTNEntanglingRoots.blp")
set SU=lYx()
call vOr(SU,dGv,true)
call l0x(((mPe)),vc+(1),(SU))
set SU=lYx()
call vOr(SU,dGv,true)
call l0x(((mPe)),vc+(2),(SU))
set SU=lYx()
call vOr(SU,dGv,true)
call l0x(((mPe)),vc+(3),(SU))
set SU=lYx()
call vOr(SU,dGv,true)
call l0x(((mPe)),vc+(4),(SU))
set SU=lYx()
call vOr(SU,dGv,true)
call l0x(((mPe)),vc+(5),(SU))
set SU=lYx()
call vOr(SU,dGv,true)
call l0x(((mPe)),vc+(6),(SU))
return true
endfunction
function LKr takes nothing returns boolean
call VRx(Ma,(function Lkr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\Prison\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function Llr takes nothing returns boolean
set mqe=Vnx(mQe)
return true
endfunction
function LLr takes nothing returns boolean
set mse[1]=-40
set mse[2]=-50
set mse[3]=-60
set mse[4]=-70
set mse[5]=-80
set mse[6]=-90
set mSe[1]=3
set mSe[2]=3.5
set mSe[3]=4
set mSe[4]=4.5
set mSe[5]=5
set mSe[6]=5.5
set mte[1]=40
set mte[2]=40
set mte[3]=40
set mte[4]=40
set mte[5]=40
set mte[6]=40
set mTe[1]=1
set mTe[2]=1
set mTe[3]=1
set mTe[4]=1
set mTe[5]=1
set mTe[6]=1
return true
endfunction
function Lmr takes nothing returns boolean
set mue=WTx('BHoN',"Hand of Nature",'bHoN')
set qU[(mue)]=(true)
set aev[(mue)]=("ReplaceableTextures\\CommandButtons\\BTNEntanglingRoots.blp")
call lux(mue,"Abilities\\Spells\\NightElf\\EntanglingRoots\\EntanglingRootsTarget.mdl","origin",ri)
set SU=lYx()
call l_x(SU,cov,-40)
call l0x(((mue)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,cov,-50)
call l0x(((mue)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,cov,-60)
call l0x(((mue)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,cov,-70)
call l0x(((mue)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,cov,-80)
call l0x(((mue)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,cov,-90)
call l0x(((mue)),vc+(6),(SU))
return true
endfunction
function LMr takes nothing returns boolean
call VRx(ea,(function LLr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\Roots\\Buff\\obj_this_wc3obj.j"))
call VRx(Ma,(function Lmr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\Roots\\Buff\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function Lpr takes nothing returns boolean
set mUe=Vnx(mwe)
return true
endfunction
function LPr takes nothing returns boolean
return true
endfunction
function Lqr takes nothing returns boolean
set mWe=Vnx(mye)
return true
endfunction
function LQr takes nothing returns boolean
return true
endfunction
function Lsr takes nothing returns boolean
set mYe=Vnx(mze)
return true
endfunction
function LSr takes nothing returns boolean
call LZx('AHoN',false)
set mZe=Lzo('AHoN')
set G6[(mZe)]=(N6)
set j6[(mZe)]=(6)
set sH[(mZe)]=("Hand of Nature")
set Ih[(mZe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00CB)))),(((Oj))))))
set x6v[(mZe)]=(3)
set xzv[(mZe)]=("spell")
call LZo((mZe),u6v+(1),((350)*1.))
call LZo((mZe),fH+(1),((8)*1.))
call LZo((mZe),QH+(1),((65)*1.))
call LZo((mZe),Lvv+(1),((650)*1.))
call LZo((mZe),u6v+(2),((350)*1.))
call LZo((mZe),fH+(2),((8)*1.))
call LZo((mZe),QH+(2),((75)*1.))
call LZo((mZe),Lvv+(2),((650)*1.))
call LZo((mZe),u6v+(3),((350)*1.))
call LZo((mZe),fH+(3),((8)*1.))
call LZo((mZe),QH+(3),((85)*1.))
call LZo((mZe),Lvv+(3),((650)*1.))
call LZo((mZe),u6v+(4),((350)*1.))
call LZo((mZe),fH+(4),((8)*1.))
call LZo((mZe),QH+(4),((95)*1.))
call LZo((mZe),Lvv+(4),((650)*1.))
call LZo((mZe),u6v+(5),((350)*1.))
call LZo((mZe),fH+(5),((8)*1.))
call LZo((mZe),QH+(5),(('i')*1.))
call LZo((mZe),Lvv+(5),((650)*1.))
call LZo((mZe),u6v+(6),((350)*1.))
call LZo((mZe),fH+(6),((8)*1.))
call LZo((mZe),QH+(6),(('s')*1.))
call LZo((mZe),Lvv+(6),((650)*1.))
set Mnv[(mZe)]=("ReplaceableTextures\\CommandButtons\\BTNEntanglingRoots.blp")
call ccr(mZe,'FHN0',6,'VHN0','LPHN','LRHN')
set m_e[1]=40
set m_e[2]=40
set m_e[3]=40
set m_e[4]=40
set m_e[5]=40
set m_e[6]=40
set m0e[1]=3
set m0e[2]=3
set m0e[3]=3
set m0e[4]=3
set m0e[5]=3
set m0e[6]=3
set m1e[1]=2
set m1e[2]=2
set m1e[3]=2
set m1e[4]=2
set m1e[5]=2
set m1e[6]=2
return true
endfunction
function Ltr takes nothing returns boolean
set m2e[5]=hGo('uCL5')
call hho(((m2e[5])),Apv,(INv))
set Tj[(m2e[5])]=((.9)*1.)
call hHo(m2e[5],0,$FF,0,$FF)
set Nav[(m2e[5])]=(('d')*1.)
set Ntv[(m2e[5])]=(($E1)*1.)
call HMo(m2e[5],"Units\\CobraLily\\LightingOrb.mdx","head",Bi)
set I3v[(m2e[5])]=((2)*1.)
set Axv[(m2e[5])]=(2)
set NJv[(m2e[5])]=((450)*1.)
set Njv[(m2e[5])]=((450)*1.)
set Nhv[(m2e[5])]=((0)*1.)
set NIv[(m2e[5])]=(($4B0)*1.)
set NOv[(m2e[5])]=(($4B0)*1.)
set Ndv[(m2e[5])]=(($F)*1.)
set ANv[(m2e[5])]=(gSv)
set Adv[(m2e[5])]=((600)*1.)
set ADv[((m2e[5]))]=((1.*1./((1.25)*1.))*1.)
set Atv[(m2e[5])]=((.4)*1.)
set Drv[(m2e[5])]=((600)*1.)
set AQv[(m2e[5])]=((32)*1.)
set Asv[(m2e[5])]=((32)*1.)
set Auv[(m2e[5])]=(3)
set AWv[(m2e[5])]=(4)
set Azv[(m2e[5])]=(1)
set Aqv[(m2e[5])]=((16)*1.)
return true
endfunction
function LTr takes nothing returns boolean
set m2e[1]=hGo('uCoL')
call hho(((m2e[1])),Apv,(INv))
set Tj[(m2e[1])]=((.7)*1.)
call hHo(m2e[1],0,$FF,0,$FF)
set Nav[(m2e[1])]=(('d')*1.)
set Ntv[(m2e[1])]=(($E1)*1.)
call HMo(m2e[1],"HandOfNature_page\\HandOfNature_struct\\LightingOrb.mdx","head",Bi)
set I3v[(m2e[1])]=((0)*1.)
set Axv[(m2e[1])]=(2)
set NJv[(m2e[1])]=(($96)*1.)
set Njv[(m2e[1])]=(($96)*1.)
set Nhv[(m2e[1])]=((0)*1.)
set NIv[(m2e[1])]=(($4B0)*1.)
set NOv[(m2e[1])]=(($4B0)*1.)
set Ndv[(m2e[1])]=(($F)*1.)
set ANv[(m2e[1])]=(gSv)
set Adv[(m2e[1])]=((600)*1.)
set ADv[((m2e[1]))]=((1.*1./((1.25)*1.))*1.)
set Atv[(m2e[1])]=((.4)*1.)
set Drv[(m2e[1])]=((600)*1.)
set AQv[(m2e[1])]=(($C)*1.)
set Asv[(m2e[1])]=(($C)*1.)
set Auv[(m2e[1])]=(1)
set AWv[(m2e[1])]=(3)
set Azv[(m2e[1])]=(1)
set Aqv[(m2e[1])]=((40)*1.)
return true
endfunction
function Lur takes nothing returns boolean
set m3e=lQx(m4e+" (dummyBuff)")
return true
endfunction
function LUr takes nothing returns boolean
set m2e[2]=hGo('uCL2')
call hho(((m2e[2])),Apv,(INv))
set Tj[(m2e[2])]=((.75)*1.)
call hHo(m2e[2],0,$FF,0,$FF)
set Nav[(m2e[2])]=(('d')*1.)
set Ntv[(m2e[2])]=(($E1)*1.)
call HMo(m2e[2],"Units\\CobraLily\\LightingOrb.mdx","head",Bi)
set I3v[(m2e[2])]=((1)*1.)
set Axv[(m2e[2])]=(2)
set NJv[(m2e[2])]=(($E1)*1.)
set Njv[(m2e[2])]=(($E1)*1.)
set Nhv[(m2e[2])]=((0)*1.)
set NIv[(m2e[2])]=(($4B0)*1.)
set NOv[(m2e[2])]=(($4B0)*1.)
set Ndv[(m2e[2])]=(($F)*1.)
set ANv[(m2e[2])]=(gSv)
set Adv[(m2e[2])]=((600)*1.)
set ADv[((m2e[2]))]=((1.*1./((1.25)*1.))*1.)
set Atv[(m2e[2])]=((.4)*1.)
set Drv[(m2e[2])]=((600)*1.)
set AQv[(m2e[2])]=((16)*1.)
set Asv[(m2e[2])]=((16)*1.)
set Auv[(m2e[2])]=(2)
set AWv[(m2e[2])]=(2)
set Azv[(m2e[2])]=(1)
set Aqv[(m2e[2])]=((16)*1.)
return true
endfunction
function Lwr takes nothing returns boolean
set m2e[3]=hGo('uCL3')
call hho(((m2e[3])),Apv,(INv))
set Tj[(m2e[3])]=((.8)*1.)
call hHo(m2e[3],0,$FF,0,$FF)
set Nav[(m2e[3])]=(('d')*1.)
set Ntv[(m2e[3])]=(($E1)*1.)
call HMo(m2e[3],"Units\\CobraLily\\LightingOrb.mdx","head",Bi)
set I3v[(m2e[3])]=((1)*1.)
set Axv[(m2e[3])]=(2)
set NJv[(m2e[3])]=((300)*1.)
set Njv[(m2e[3])]=((300)*1.)
set Nhv[(m2e[3])]=((0)*1.)
set NIv[(m2e[3])]=(($4B0)*1.)
set NOv[(m2e[3])]=(($4B0)*1.)
set Ndv[(m2e[3])]=(($F)*1.)
set ANv[(m2e[3])]=(gSv)
set Adv[(m2e[3])]=((600)*1.)
set ADv[((m2e[3]))]=((1.*1./((1.25)*1.))*1.)
set Atv[(m2e[3])]=((.4)*1.)
set Drv[(m2e[3])]=((600)*1.)
set AQv[(m2e[3])]=((21)*1.)
set Asv[(m2e[3])]=((21)*1.)
set Auv[(m2e[3])]=(2)
set AWv[(m2e[3])]=(3)
set Azv[(m2e[3])]=(1)
set Aqv[(m2e[3])]=((16)*1.)
return true
endfunction
function LWr takes nothing returns boolean
set m2e[6]=hGo('uCL6')
call hho(((m2e[6])),Apv,(INv))
set Tj[(m2e[6])]=((.95)*1.)
call hHo(m2e[6],0,$FF,0,$FF)
set Nav[(m2e[6])]=(('d')*1.)
set Ntv[(m2e[6])]=(($E1)*1.)
call HMo(m2e[6],"Units\\CobraLily\\LightingOrb.mdx","head",Bi)
set I3v[(m2e[6])]=((2)*1.)
set Axv[(m2e[6])]=(2)
set NJv[(m2e[6])]=((525)*1.)
set Njv[(m2e[6])]=((525)*1.)
set Nhv[(m2e[6])]=((0)*1.)
set NIv[(m2e[6])]=(($4B0)*1.)
set NOv[(m2e[6])]=(($4B0)*1.)
set Ndv[(m2e[6])]=(($F)*1.)
set ANv[(m2e[6])]=(gSv)
set Adv[(m2e[6])]=((600)*1.)
set ADv[((m2e[6]))]=((1.*1./((1.25)*1.))*1.)
set Atv[(m2e[6])]=((.4)*1.)
set Drv[(m2e[6])]=((600)*1.)
set AQv[(m2e[6])]=((38)*1.)
set Asv[(m2e[6])]=((38)*1.)
set Auv[(m2e[6])]=(3)
set AWv[(m2e[6])]=(5)
set Azv[(m2e[6])]=(1)
set Aqv[(m2e[6])]=((16)*1.)
return true
endfunction
function Lyr takes nothing returns boolean
set m2e[4]=hGo('uCL4')
call hho(((m2e[4])),Apv,(INv))
set Tj[(m2e[4])]=((.85)*1.)
call hHo(m2e[4],0,$FF,0,$FF)
set Nav[(m2e[4])]=(('d')*1.)
set Ntv[(m2e[4])]=(($E1)*1.)
call HMo(m2e[4],"Units\\CobraLily\\LightingOrb.mdx","head",Bi)
set I3v[(m2e[4])]=((2)*1.)
set Axv[(m2e[4])]=(2)
set NJv[(m2e[4])]=((375)*1.)
set Njv[(m2e[4])]=((375)*1.)
set Nhv[(m2e[4])]=((0)*1.)
set NIv[(m2e[4])]=(($4B0)*1.)
set NOv[(m2e[4])]=(($4B0)*1.)
set Ndv[(m2e[4])]=(($F)*1.)
set ANv[(m2e[4])]=(gSv)
set Adv[(m2e[4])]=((600)*1.)
set ADv[((m2e[4]))]=((1.*1./((1.25)*1.))*1.)
set Atv[(m2e[4])]=((.4)*1.)
set Drv[(m2e[4])]=((600)*1.)
set AQv[(m2e[4])]=((26)*1.)
set Asv[(m2e[4])]=((26)*1.)
set Auv[(m2e[4])]=(3)
set AWv[(m2e[4])]=(3)
set Azv[(m2e[4])]=(1)
set Aqv[(m2e[4])]=((16)*1.)
return true
endfunction
function LYr takes nothing returns boolean
call VRx(qa,(function LSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Sa,(function Ltr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\obj_summonUnitType[5]_wc3unit.j"))
call VRx(Sa,(function LTr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\obj_summonUnitType[1]_wc3unit.j"))
call VRx(Ma,(function Lur),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(Sa,(function LUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\obj_summonUnitType[2]_wc3unit.j"))
call VRx(Sa,(function Lwr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\obj_summonUnitType[3]_wc3unit.j"))
call VRx(Sa,(function LWr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\obj_summonUnitType[6]_wc3unit.j"))
call VRx(Sa,(function Lyr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\obj_summonUnitType[4]_wc3unit.j"))
return true
endfunction
function Lzr takes nothing returns boolean
set m5e=Vnx(m4e)
return true
endfunction
function LZr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function L_r takes integer oqx,integer Ixx returns nothing
call UJx(Ixx,mPe)
endfunction
function L0r takes integer oqx,integer oQx,integer oSx returns boolean
return rex(Mee[(oqx)],(Mxe[((oqx))]),oQx,oSx)
endfunction
function L1r takes integer oqx returns nothing
local integer ibx=Mre[oqx]
local integer p0x=Mie[oqx]
local integer L2r=Mae[oqx]
local integer L3r=Mne[oqx]
local integer Ipx
call ijx(ibx)
call ijx(p0x)
call m6x(L2r)
set Ipx=(zY[(L3r)])
loop
exitwhen(Ipx==w)
call Cqr(Ipx,MVe[(Ipx)])
set Ipx=pjx(L3r,Ipx)
endloop
call m6x(L3r)
endfunction
function L4r takes integer oqx returns nothing
call FlushChildHashtable(o[(V[(E[((Mee[oqx]))])])],((((Mxe[((oqx))])))))
endfunction
function L5r takes integer oqx returns nothing
set MOe[oqx]=false
call L4r((oqx))
call rgx(m5e)
endfunction
function L6r takes integer oqx returns nothing
if(MEe[oqx]>0)then
return
endif
if(MXe[oqx]!=Z)then
call oYx("HandOfNature_Allocation_deallocCustom_confirm","call DebugEx(HandOfNature.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",m4e+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set MXe[oqx]=MXe[(w)]
set MXe[(w)]=oqx
call L5r(oqx)
endfunction
function L7r takes integer oqx returns nothing
set MEe[oqx]=MEe[oqx]-1
call L6r(oqx)
endfunction
function L8r takes nothing returns boolean
local integer rdx=(bv)
local integer IVr=(Vv[(rdx)])
local integer oqx=oPx(IVr,m8e)
if m9e[oqx]then
set m9e[oqx]=false
call L_r((w),Mve[oqx])
endif
if L0r(oqx,Moe,IVr)then
call L1r(oqx)
call L7r((oqx))
endif
return true
endfunction
function L9r takes integer oqx returns integer
set MOe[oqx]=true
set MAe[oqx]=false
set Mee[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
call rax(m5e)
return oqx
endfunction
function mvr takes nothing returns integer
local integer oqx
if(MRe==8190)then
call oYx("HandOfNature_Allocation_allocCustom","call DebugEx(HandOfNature.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",m4e+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(MXe[(w)]==w)then
set MIe=MIe+1
set oqx=MIe
else
set oqx=MXe[(w)]
set MXe[(w)]=MXe[MXe[(w)]]
endif
set MXe[oqx]=Z
set MEe[oqx]=1
call L9r(oqx)
return oqx
endfunction
function mer takes integer oqx returns nothing
set Mxe[(oqx)]=(MNe+oqx)
endfunction
function mxr takes integer oqx,integer Ixx returns nothing
call DSx((Ixx),(mPe),(1),w)
endfunction
function mor takes integer oqx,integer oQx returns integer
return(0+(LoadInteger(o[((V[(E[((Mee[(oqx)]))])]))],((((Mxe[((oqx))])))),(((oQx))))))
endfunction
function mrr takes integer oqx,integer oQx,integer oSx returns boolean
return rSx(Mee[(oqx)],(Mxe[((oqx))]),oQx,oSx)
endfunction
function mir takes integer oqx returns integer
set MFe[oqx]=true
set Mge[oqx]=false
call rax(mWe)
return oqx
endfunction
function mar takes nothing returns integer
local integer oqx
if(MCe==8190)then
call oYx("FolderHandOfNature_StructRoots_Allocation_allocCustom","call DebugEx(FolderHandOfNature_StructRoots.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",mye+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Mde[(w)]==w)then
set MDe=MDe+1
set oqx=MDe
else
set oqx=Mde[(w)]
set Mde[(w)]=Mde[Mde[(w)]]
endif
set Mde[oqx]=Z
set Mfe[oqx]=1
call mir(oqx)
return oqx
endfunction
function mnr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer MFo=Mhe[oqx]
local integer effectAligment=-MHe[oqx]
call mFo((mHo((((mFv[(MFo)])+MHe[oqx]*(GetRandomReal(((25.)*1.),((50.)*1.))))*1.),(((mgv[(MFo)])+MHe[oqx]*(GetRandomReal(((25.)*1.),((50.)*1.))))*1.),(Mle),(Bi))))
set MHe[oqx]=MHe[oqx]
endfunction
function mVr takes integer oqx returns nothing
set MFe[oqx]=false
call rgx(mWe)
endfunction
function mEr takes integer oqx returns nothing
if(Mfe[oqx]>0)then
return
endif
if(Mde[oqx]!=Z)then
call oYx("FolderHandOfNature_StructRoots_Allocation_deallocCustom_confirm","call DebugEx(FolderHandOfNature_StructRoots.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",mye+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set Mde[oqx]=Mde[(w)]
set Mde[(w)]=oqx
call mVr(oqx)
endfunction
function mXr takes integer oqx returns nothing
set Mfe[oqx]=Mfe[oqx]-1
call mEr(oqx)
endfunction
function mOr takes integer CMx,integer rwx,integer Ixx returns nothing
local real ilx
if I6x(Ixx,yd)then
set ilx=mTe[rwx]
else
set ilx=mSe[rwx]
endif
set Ib=CMx
call NIx((Ixx),(mue),(rwx),w,((ilx)*1.))
endfunction
function mRr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=MGe[oqx]
local integer p0x=Mje[oqx]
local integer rwx=MJe[oqx]
local integer Ixx=Mke[oqx]
call mXr((oqx))
call Mdo(MFo)
call ijx(p0x)
call mOr(CMx,rwx,Ixx)
return true
endfunction
function mIr takes integer CMx,integer rwx,integer Ixx returns nothing
local integer oqx=mar()
local integer MFo=Mvo()
local integer p0x=inx()
set MGe[oqx]=CMx
set Mhe[oqx]=MFo
set MHe[oqx]=-1
set Mje[oqx]=p0x
set MJe[oqx]=rwx
set Mke[oqx]=Ixx
set ge[(p0x)]=(oqx)
call icx(p0x,MKe,true,function mnr)
set mNv[(MFo)]=((10.)*1.)
set mCv[(MFo)]=XHx((function mRr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,400.)
call M9o(MFo,CMx)
call M3o((MFo),(Ixx),.0,.0,.0,(null))
endfunction
function mAr takes integer oqx,real x,real y returns nothing
local integer o2x=Cgr(x,y)
local integer Ipx
if pJx(Mae[oqx],o2x)then
call Cjr(o2x)
return
endif
call sLo(Mae[oqx],o2x)
set Ipx=CTr(x,y,M7)
set MVe[(Ipx)]=(TimerGetRemaining(Oe[(Mre[oqx])]))*2+2
call sLo(Mne[oqx],Ipx)
endfunction
function mNr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local real jlx=MPe[oqx]
local real jLx=Mqe[oqx]
local real oUx=MMe[oqx]+Mpe[oqx]
local real N8x
set MMe[oqx]=oUx
set N8x=(GetRandomReal(((.0)*1.),((df)*1.)))
loop
exitwhen(N8x>df)
call mAr(oqx,jlx+oUx*(Cos(((((N8x)*1.))*1.))),jLx+oUx*(Sin(((((N8x)*1.))*1.))))
set N8x=N8x+b6v*1./ 2
endloop
endfunction
function mbr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
call iHx(Mie[oqx])
endfunction
function mBr takes integer oqx,integer CQx returns nothing
local integer rwx=(XH[(CQx)])
local real ilx=m_e[rwx]
local integer D8x=(R2I(((MLe*1./ Mme)*1.)))
local integer ibx=inx()
local integer p0x=inx()
set Mre[oqx]=ibx
set Mie[oqx]=p0x
set MMe[oqx]=.0
set Mpe[oqx]=(Cpx((mZe),u6v+(rwx)))*1./ D8x
set MPe[oqx]=(wh[(CQx)])
set Mqe[oqx]=(Wh[(CQx)])
set Mae[oqx]=M0x()
set Mne[oqx]=M0x()
set ge[(ibx)]=(oqx)
set ge[(p0x)]=(oqx)
call icx(p0x,Mme,true,function mNr)
call icx(ibx,MLe,false,function mbr)
endfunction
function mcr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local integer CQx=(uH[(rdx)])
local integer oqx=mvr()
local real n_x
local real N8x
local integer mCr
local integer mdr
local real x
local real y
local integer IVr
local integer Ecr
local integer ECr
call mer(oqx)
set Mbe[oqx]=CMx
if(Ixx==w)then
set n_x=2*(Aqv[(m2e[rwx])])*(Tj[(m2e[rwx])])
set m9e[oqx]=false
else
set n_x=dvx(Ixx,true)+S2R((C8x(SH,("hon"),"var")))*(Aqv[(m2e[rwx])])*(Tj[(m2e[rwx])])
set m9e[oqx]=true
set Mve[oqx]=Ixx
call mxr((w),Ixx)
endif
call mFo((mHo(((dix)*1.),((dax)*1.),(MBe),(Bi))))
set N8x=(Atan2(((dax-(GetUnitY(C[((CMx))])))*1.),((dix-(GetUnitX(C[((CMx))])))*1.)))
set mCr=m0e[rwx]
set mdr=1
loop
exitwhen(mdr>mCr)
set x=dix+n_x*(Cos(((((N8x)*1.))*1.)))
set y=dax+n_x*(Sin(((((N8x)*1.))*1.)))
set IVr=Uzo(m2e[rwx],(ze[(CMx)]),x,y,N8x,m_e[rwx])
call rTx(IVr,m8e,oqx)
call oYx("HandOfNature_Event_SpellEffect","call DebugEx(I2S(this)+\";\"+I2S(this.Id.Get())+\" add \"+I2S(this.Data.Integer.Table.Count(SUMMONS_KEY_ARRAY)))",I2S(oqx)+";"+I2S((Mxe[(oqx)]))+" add "+I2S(mor(oqx,Moe)))
call mrr(oqx,Moe,IVr)
call rzx((IVr),(Mce),(rwx))
call DSx((IVr),(m3e),(1),w)
call fWx(IVr,x,y)
call DUx(IVr,.0)
call D6x(IVr,(Tj[(m2e[rwx])]),1.)
set Hf=(ze[(IVr)])
call Nio(m6e,dix,dax,(Cpx((mZe),u6v+(rwx))),m7e)
set Ecr=m1e[rwx]
set ECr=1
loop
exitwhen(ECr>Ecr)
set Ixx=(mjo((m6e),((dix)*1.),((dax)*1.)))
exitwhen(Ixx==w)
call GroupRemoveUnit(Kb[(m6e)],C[(Ixx)])
if(Ixx!=w)then
call mIr(IVr,rwx,Ixx)
endif
set ECr=ECr+1
endloop
set N8x=N8x+df*1./ mCr
set mdr=mdr+1
endloop
call mBr(oqx,CQx)
return true
endfunction
function mDr takes nothing returns nothing
endfunction
function mfr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
call nJo((MSe[oqx]),(Mue[oqx]),((Mte[oqx])*1.),(true),(false))
endfunction
function mFr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=Ib
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=inx()
set MSe[oqx]=CMx
set Mte[oqx]=MQe[rwx]
set MTe[oqx]=p0x
set Mue[oqx]=Ixx
set ge[(p0x)]=(oqx)
call icx(p0x,Mse,true,function mfr)
return true
endfunction
function mgr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=MTe[oqx]
call ijx(p0x)
return true
endfunction
function mGr takes nothing returns nothing
local integer olx=(j6[(mZe)])
loop
set MQe[olx]=mte[olx]*Mse*1./ mSe[olx]
set olx=olx-1
exitwhen(olx<1)
endloop
call l9x(mue,XBx("FolderHandOfNature_FolderRoots_StructBuff_Init: call FolderHandOfNature_FolderRoots_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderHandOfNature_FolderRoots_StructBuff.Event_BuffGain))",Bd,pI,function mFr))
call l9x(mue,XBx("FolderHandOfNature_FolderRoots_StructBuff_Init: call FolderHandOfNature_FolderRoots_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderHandOfNature_FolderRoots_StructBuff.Event_BuffLose))",Jc,pI,function mgr))
call W_x(nhv,mue)
endfunction
function mhr takes nothing returns boolean
set m6e=O2x()
set m7e=XLx(function LZr)
call l9x(m3e,XBx("HandOfNature_Init: call HandOfNature.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HandOfNature.Event_BuffLose))",Jc,pI,function L8r))
call meo(mZe,XBx("HandOfNature_Init: call HandOfNature.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HandOfNature.Event_SpellEffect))",ah,pI,function mcr))
call mDr()
call mGr()
return true
endfunction
function mHr takes nothing returns boolean
call FOr(function mhr,"HandOfNature_Init")
return true
endfunction
function mjr takes nothing returns boolean
set MUe=WTx('BSlP',"Poisoned",'bSlP')
set qU[(MUe)]=(true)
set aev[(MUe)]=("ReplaceableTextures\\CommandButtons\\BTNPoisonSting.blp")
call lux(MUe,"Abilities\\Weapons\\PoisonSting\\PoisonStingTarget.mdl","origin",ri)
return true
endfunction
function mJr takes nothing returns boolean
set Mwe[1]=-$F
set Mwe[2]=-20
set Mwe[3]=-25
set Mwe[4]=-30
set Mwe[5]=-35
set Mwe[6]=-40
set MWe[1]=-40
set MWe[2]=-70
set MWe[3]=-95
set MWe[4]=-'s'
set MWe[5]=-'x'
set MWe[6]=-'}'
return true
endfunction
function mkr takes nothing returns boolean
call VRx(Ma,(function mjr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\SlowPoison.page\\SlowPoison.struct\\Target\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function mJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\SlowPoison.page\\SlowPoison.struct\\Target\\obj_this_wc3obj.j"))
return true
endfunction
function mKr takes nothing returns boolean
set Mye=Vnx(MYe)
return true
endfunction
function mlr takes nothing returns boolean
call LZx('ASlP',false)
set Mce=Lzo('ASlP')
set G6[(Mce)]=(D6)
set j6[(Mce)]=(1)
set sH[(Mce)]=("Slow Poison")
set xzv[(Mce)]=("spell")
call LZo((Mce),Lvv+(1),((750)*1.))
set Mnv[(Mce)]=("ReplaceableTextures\\PassiveButtons\\PASBTNPoisonSting.blp")
return true
endfunction
function mLr takes nothing returns boolean
set Mze=lQx(MZe+" (dummyBuff)")
return true
endfunction
function mmr takes nothing returns boolean
call VRx(qa,(function mlr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\SlowPoison.page\\SlowPoison.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function mLr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\SlowPoison.page\\SlowPoison.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function mMr takes nothing returns boolean
set M_e=Vnx(MZe)
return true
endfunction
function mpr takes integer Ixx returns boolean
return( not(I6x(Ixx,IBv)))and( not(I6x(Ixx,ICv)))
endfunction
function mPr takes integer CMx,integer rwx,integer Ixx returns nothing
local real ilx
if I6x(Ixx,yd)then
set ilx=M1e
else
set ilx=M2e
endif
set M3e=CMx
call NIx((Ixx),(MUe),(rwx),w,((ilx)*1.))
endfunction
function mqr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
if not mpr(Ixx)then
return true
endif
call mPr((EYv[(rdx)]),(oPx((((EYv[(rdx)]))),N+(Mce))),Ixx)
return true
endfunction
function mQr takes nothing returns boolean
local integer rdx=(bv)
call I7x((Vv[(rdx)]),M0e)
return true
endfunction
function msr takes nothing returns boolean
local integer rdx=(bv)
call Rmx((Vv[(rdx)]),M0e)
return true
endfunction
function mSr takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(Mze),((Mv[(rdx)])),w)
return true
endfunction
function mtr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),Mze)
return true
endfunction
function mTr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
call nJo((M7e[oqx]),(Ixx),((itx(M8e[oqx],(rG[(Ixx)])-DG))*1.),(false),(false))
endfunction
function mur takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=M3e
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=inx()
set M7e[oqx]=CMx
set M8e[oqx]=M4e
set M9e[oqx]=p0x
set ge[(p0x)]=(oqx)
call icx(p0x,M6e,true,function mTr)
return true
endfunction
function mUr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=M9e[oqx]
call ijx(p0x)
return true
endfunction
function mwr takes nothing returns nothing
set M4e=M5e*M6e
call l9x(MUe,XBx("FolderSlowPoison_StructTarget_Init: call FolderSlowPoison_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSlowPoison_StructTarget.Event_BuffGain))",Bd,pI,function mur))
call l9x(MUe,XBx("FolderSlowPoison_StructTarget_Init: call FolderSlowPoison_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSlowPoison_StructTarget.Event_BuffLose))",Jc,pI,function mUr))
call W_x(XNv,MUe)
endfunction
function mWr takes nothing returns boolean
set M0e=XBx("SlowPoison_Init: set SlowPoison.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function SlowPoison.Event_Damage)",EZv,pI,function mqr)
call l9x(Mze,XBx("SlowPoison_Init: call SlowPoison.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SlowPoison.Event_BuffGain))",Bd,pI,function mQr))
call l9x(Mze,XBx("SlowPoison_Init: call SlowPoison.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SlowPoison.Event_BuffLose))",Jc,pI,function msr))
call meo(Mce,XBx("SlowPoison_Init: call SlowPoison.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SlowPoison.Event_Learn))",pv,pI,function mSr))
call meo(Mce,XBx("SlowPoison_Init: call SlowPoison.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SlowPoison.Event_Unlearn))",Av,pI,function mtr))
call mwr()
return true
endfunction
function myr takes nothing returns boolean
call FOr(function mWr,"SlowPoison_Init")
return true
endfunction
function mYr takes nothing returns boolean
set pve=hGo('uTrM')
call hho(((pve)),Apv,(IBv))
call hho(((pve)),Apv,(INv))
set Tj[(pve)]=((1.35)*1.)
set Nav[(pve)]=((60)*1.)
set Ntv[(pve)]=((60)*1.)
set I3v[(pve)]=((1)*1.)
set Axv[(pve)]=(1)
set NJv[(pve)]=((5)*1.)
set Njv[(pve)]=((5)*1.)
set Nhv[(pve)]=((0)*1.)
set AQv[(pve)]=((0)*1.)
set Asv[(pve)]=((0)*1.)
set Auv[(pve)]=(0)
set AWv[(pve)]=(0)
set Aqv[(pve)]=((16)*1.)
return true
endfunction
function mzr takes nothing returns boolean
set pee=WTx('BSMB',"Mine",'bSMB')
set avv[(pee)]=(true)
set qc[(pee)]=(true)
set aev[(pee)]=("ReplaceableTextures\\CommandButtons\\BTNGoblinLandMine.blp")
call lux(pee,"HopNDrop_page\\HopNDrop_struct\\SetMines\\Mine\\PointingArrow.mdx","overhead",ri)
return true
endfunction
function mZr takes nothing returns boolean
call VRx(Sa,(function mYr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HopNDrop.page\\HopNDrop.struct\\SetMines\\Mine\\obj_summonUnitType_wc3unit.j"))
call VRx(Ma,(function mzr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HopNDrop.page\\HopNDrop.struct\\SetMines\\Mine\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function m_r takes nothing returns boolean
set pxe=Vnx(poe)
return true
endfunction
function m0r takes nothing returns boolean
set pre[1]=$C8
set pre[2]=$DC
set pre[3]=$F0
set pre[4]=260
set pre[5]=280
set pre[6]=300
set pie[1]=30
set pie[2]=45
set pie[3]=60
set pie[4]=80
set pie[5]='i'
set pie[6]=$87
return true
endfunction
function m1r takes nothing returns boolean
set pae=lQx(pne+" (dummyBuff)")
set qc[(pae)]=(true)
call lux(pae,"units\\human\\phoenix\\phoenix.mdl","origin",Bi)
return true
endfunction
function m2r takes nothing returns boolean
call VRx(ea,(function m0r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HopNDrop.page\\HopNDrop.struct\\SetMines\\obj_this_wc3obj.j"))
call VRx(Ma,(function m1r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HopNDrop.page\\HopNDrop.struct\\SetMines\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function m3r takes nothing returns boolean
set pVe=Vnx(pne)
return true
endfunction
function m4r takes nothing returns boolean
set pEe=lQx(pXe+" (dummyBuff)")
call lux(pEe,"Abilities\\Spells\\Undead\\OrbOfDeath\\OrbOfDeathMissile.mdl","origin",Bi)
call lux(pEe,"units\\human\\phoenix\\phoenix.mdl","origin",Bi)
return true
endfunction
function m5r takes nothing returns boolean
call LZx('AHop',false)
set GUv=Lzo('AHop')
set G6[(GUv)]=(N6)
set j6[(GUv)]=(6)
set sH[(GUv)]=("Hop'n'Drop")
set Ih[(GUv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0092)))),(((Oj))))))
set x6v[(GUv)]=(2)
set xzv[(GUv)]=("spell")
call LZo((GUv),fH+(1),((22)*1.))
call LZo((GUv),QH+(1),(('x')*1.))
call LZo((GUv),Lvv+(1),((900)*1.))
call LZo((GUv),fH+(2),((21)*1.))
call LZo((GUv),QH+(2),(($8C)*1.))
call LZo((GUv),Lvv+(2),((900)*1.))
call LZo((GUv),fH+(3),((20)*1.))
call LZo((GUv),QH+(3),(($A0)*1.))
call LZo((GUv),Lvv+(3),((900)*1.))
call LZo((GUv),fH+(4),((19)*1.))
call LZo((GUv),QH+(4),(($B4)*1.))
call LZo((GUv),Lvv+(4),((900)*1.))
call LZo((GUv),fH+(5),((18)*1.))
call LZo((GUv),QH+(5),(($C8)*1.))
call LZo((GUv),Lvv+(5),((900)*1.))
call LZo((GUv),fH+(6),((17)*1.))
call LZo((GUv),QH+(6),(($DC)*1.))
call LZo((GUv),Lvv+(6),((900)*1.))
set Mnv[(GUv)]=("ReplaceableTextures\\CommandButtons\\BTNGoblinLandMine.blp")
call ccr(GUv,'FHD0',6,'VHD0','LPHD','LRHD')
return true
endfunction
function m6r takes nothing returns boolean
call VRx(Ma,(function m4r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HopNDrop.page\\HopNDrop.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function m5r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HopNDrop.page\\HopNDrop.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function m7r takes nothing returns boolean
set pOe=Vnx(pXe)
return true
endfunction
function m8r takes integer oqx,real x,real y returns nothing
if(not IsTerrainPathable(((x)*1.),((y)*1.),PATHING_TYPE_WALKABILITY))then
call fTx(oqx,x)
call fux(oqx,y)
endif
endfunction
function m9r takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
local real cRx=pfe[oqx]+pge[oqx]
local real x=(GetUnitX(C[((Ixx))]))+pCe[oqx]
local real y=(GetUnitY(C[((Ixx))]))+pDe[oqx]
local real z=fwx(Ixx)+cRx
local real Mvr=XYx(x,y)
set pfe[oqx]=cRx
call m8r(Ixx,x,y)
if((cRx<.0)and(z<Mvr+pHe))then
call B5o(Ixx,Mvr)
call Ayx(Ixx,pEe)
else
call B5o(Ixx,z)
endif
endfunction
function Mer takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local real dix=pbe
local real dax=pBe
local real N8x=(Atan2(((dax-(GetUnitY(C[((Ixx))])))*1.),((dix-(GetUnitX(C[((Ixx))])))*1.)))
local integer oqx=Ixx
local integer hbr=inx()
local real zD=XYx(dix,dax)-fwx(Ixx)
set pce[oqx]=hbr
set pCe[oqx]=(Cos(((((N8x)*1.))*1.)))*pde
set pDe[oqx]=(Sin(((((N8x)*1.))*1.)))*pde
set pfe[oqx]=pFe-zD*1./ pAe
set pge[oqx]=pGe+4*zD*1./ phe
set ge[(hbr)]=(oqx)
call icx(hbr,pNe,true,function m9r)
return true
endfunction
function Mxr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer hbr=pce[oqx]
call ijx(hbr)
call cKo(Ixx)
return true
endfunction
function Mor takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
set pbe=(UH[(rdx)])
set pBe=(wH[(rdx)])
call DSx((CMx),(pEe),(rwx),w)
call NIx(((CMx)),(pae),((rwx)),w,((pIe)*1.))
return true
endfunction
function Mrr takes real O1o,integer CMx,real dpo,integer rwx,real x,real y,real z returns nothing
local integer Mir=bVx(pve,(ze[(CMx)]),x,y,(GetUnitFacing(C[((CMx))])*bh))
local integer oqx=Mir
set pqe[oqx]=O1o
set pQe[oqx]=CMx
set pse[oqx]=dpo
call I7x(Mir,pSe)
call DSx((((Mir))),(nTv),(1),w)
call DSx((((Mir))),(XVv),(1),w)
call B5o(Mir,z)
call DUx(Mir,(64+O1o)*1./ $C0)
call Oqr(Mir,.0,.0,pte*c6v,.0,.0,2*((XYx(x,y)-z)*1./ pTe*1./ pTe-pte*1./ pTe)*c6v*c6v,pTe)
call Uyo((Mir),((pue)*1.))
endfunction
function Mar takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
call Mrr(pme[oqx],Ixx,pMe[oqx],pPe[oqx],(GetUnitX(C[((Ixx))])),(GetUnitY(C[((Ixx))])),fwx(Ixx))
endfunction
function Mnr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=inx()
set pme[oqx]=pre[rwx]
set pMe[oqx]=pie[rwx]
set ppe[oqx]=p0x
set pPe[oqx]=rwx
set ge[(p0x)]=(oqx)
call icx(p0x,ple,true,function Mar)
return true
endfunction
function MVr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=ppe[oqx]
call ijx(p0x)
return true
endfunction
function MEr takes nothing returns boolean
local integer rdx=(bv)
local integer Mir=(Vv[(rdx)])
local real MXr=(GetUnitX(C[((Mir))]))
local real MOr=(GetUnitY(C[((Mir))]))
local integer oqx=Mir
local real O1o=pqe[oqx]
local integer CMx=pQe[oqx]
local real dpo=pse[oqx]
local integer C0o=(ze[(CMx)])
local integer Ixx
call Rmx(Mir,pSe)
call SetUnitAnimation(C[((Mir))],("spell"))
call Ayx(Mir,pee)
set Hf=C0o
call Nio(pUe,MXr,MOr,O1o,pwe)
set Ixx=Nao(pUe)
if(Ixx!=w)then
loop
call DSx((((Ixx))),(r9v),(1),w)
call NIx((((Ixx))),(x_v),(1),w,((((pWe)*1.))*1.))
call nJo((CMx),(Ixx),((dpo)*1.),(false),(true))
call UJx(((Ixx)),r9v)
set Ixx=Nao(pUe)
exitwhen(Ixx==w)
endloop
endif
return true
endfunction
function MRr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if I6x(Ixx,IFv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function MIr takes nothing returns nothing
set pSe=XBx("FolderHopNDrop_FolderSetMines_StructMine_Init: set FolderHopNDrop_FolderSetMines_StructMine.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderHopNDrop_FolderSetMines_StructMine.Event_Death)",VP,pI,function MEr)
set pUe=O2x()
set pwe=XLx(function MRr)
endfunction
function MAr takes nothing returns nothing
set ple=pIe*1./(pLe+1)+.01
call l9x(pae,XBx("FolderHopNDrop_StructSetMines_Init: call FolderHopNDrop_StructSetMines.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderHopNDrop_StructSetMines.Event_BuffGain))",Bd,pI,function Mnr))
call l9x(pae,XBx("FolderHopNDrop_StructSetMines_Init: call FolderHopNDrop_StructSetMines.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderHopNDrop_StructSetMines.Event_BuffLose))",Jc,pI,function MVr))
call MIr()
endfunction
function MNr takes nothing returns boolean
set pRe=pIe*1./ 2.
set pAe=(R2I(((pIe*1./ pNe)*1.)))
call l9x(pEe,XBx("HopNDrop_Init: call HopNDrop.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HopNDrop.Event_BuffGain))",Bd,pI,function Mer))
call l9x(pEe,XBx("HopNDrop_Init: call HopNDrop.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HopNDrop.Event_BuffLose))",Jc,pI,function Mxr))
call meo(GUv,XBx("HopNDrop_Init: call HopNDrop.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HopNDrop.Event_SpellEffect))",ah,pI,function Mor))
set pje=pIe*pIe*1./ pRe*1./ pRe*pNe
set pde=pJe*1./ pAe
set phe=pAe*pAe
set pke=-2*pKe*pNe*pNe*1./ pRe*1./ pRe
set pFe=2*pKe*1./ pAe
set pGe=-4*pKe*1./ phe
call MAr()
return true
endfunction
function Mbr takes nothing returns boolean
call FOr(function MNr,"HopNDrop_Init")
return true
endfunction
function MBr takes nothing returns boolean
set pye[1]=$A
set pye[2]=$F
set pye[3]=25
set pye[4]=35
set pye[5]=45
set pye[6]=55
return true
endfunction
function Mcr takes nothing returns boolean
call VRx(ea,(function MBr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Cone\\obj_this_wc3obj.j"))
return true
endfunction
function MCr takes nothing returns boolean
set pYe=Vnx(pze)
return true
endfunction
function Mdr takes nothing returns boolean
call LZx('AInS',false)
set pZe=Lzo('AInS')
set G6[(pZe)]=(D6)
set j6[(pZe)]=(1)
set sH[(pZe)]=("Funiculus Umbilicalis")
set xzv[(pZe)]=("spell")
call LZo((pZe),Lvv+(1),((750)*1.))
set Mnv[(pZe)]=("ReplaceableTextures\\CommandButtons\\BTNDoom.blp")
return true
endfunction
function MDr takes nothing returns boolean
set p_e=lQx(p0e+" (dummyBuff)")
return true
endfunction
function Mfr takes nothing returns boolean
call VRx(qa,(function Mdr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Summon\\FuniculusUmbilicalis\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function MDr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Summon\\FuniculusUmbilicalis\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function MFr takes nothing returns boolean
set p1e=Vnx(p0e)
return true
endfunction
function Mgr takes nothing returns boolean
set p2e[4]=hGo('uDe4')
call hho(((p2e[4])),Apv,(INv))
set Tj[(p2e[4])]=((.7)*1.)
set Nav[(p2e[4])]=(('d')*1.)
set Ntv[(p2e[4])]=((60)*1.)
set Nlv[(p2e[4])]=((270)*1.)
set I3v[(p2e[4])]=((0)*1.)
set Axv[(p2e[4])]=(4)
set NJv[(p2e[4])]=(($FF)*1.)
set Njv[(p2e[4])]=(($FF)*1.)
set Nhv[(p2e[4])]=((0)*1.)
set NIv[(p2e[4])]=(($708)*1.)
set NOv[(p2e[4])]=(($708)*1.)
set Ndv[(p2e[4])]=((45)*1.)
set ANv[(p2e[4])]=(gSv)
set Adv[(p2e[4])]=((600)*1.)
set ADv[((p2e[4]))]=((1.*1./((1.8)*1.))*1.)
set Atv[(p2e[4])]=((.55)*1.)
set Drv[(p2e[4])]=((600)*1.)
set AQv[(p2e[4])]=((28)*1.)
set Asv[(p2e[4])]=((28)*1.)
set Auv[(p2e[4])]=(2)
set AWv[(p2e[4])]=(7)
set Azv[(p2e[4])]=(4)
set Aqv[(p2e[4])]=((16)*1.)
return true
endfunction
function MGr takes nothing returns boolean
set p2e[1]=hGo('uDes')
call hho(((p2e[1])),Apv,(INv))
set Tj[(p2e[1])]=((.6)*1.)
set Nav[(p2e[1])]=(('d')*1.)
set Ntv[(p2e[1])]=((60)*1.)
set Nlv[(p2e[1])]=((270)*1.)
set I3v[(p2e[1])]=((0)*1.)
set Axv[(p2e[1])]=(4)
set NJv[(p2e[1])]=((75)*1.)
set Njv[(p2e[1])]=((75)*1.)
set Nhv[(p2e[1])]=((0)*1.)
set NIv[(p2e[1])]=(($708)*1.)
set NOv[(p2e[1])]=(($708)*1.)
set Ndv[(p2e[1])]=(($F)*1.)
set ANv[(p2e[1])]=(gSv)
set Adv[(p2e[1])]=((600)*1.)
set ADv[((p2e[1]))]=((1.*1./((1.8)*1.))*1.)
set Atv[(p2e[1])]=((.55)*1.)
set Drv[(p2e[1])]=((600)*1.)
set AQv[(p2e[1])]=(($A)*1.)
set Asv[(p2e[1])]=(($A)*1.)
set Auv[(p2e[1])]=(2)
set AWv[(p2e[1])]=(7)
set Azv[(p2e[1])]=(4)
set Aqv[(p2e[1])]=((16)*1.)
return true
endfunction
function Mhr takes nothing returns boolean
set p3e[1]=4
set p3e[2]=4
set p3e[3]=4
set p3e[4]=4
set p3e[5]=4
set p4e[1]=23
set p4e[2]=23
set p4e[3]=23
set p4e[4]=23
set p4e[5]=23
return true
endfunction
function MHr takes nothing returns boolean
set p5e=lQx(p6e+" (dummyBuff)")
return true
endfunction
function Mjr takes nothing returns boolean
set p2e[2]=hGo('uDe2')
call hho(((p2e[2])),Apv,(INv))
set Tj[(p2e[2])]=((.7)*1.)
set Nav[(p2e[2])]=(('d')*1.)
set Ntv[(p2e[2])]=((60)*1.)
set Nlv[(p2e[2])]=((270)*1.)
set I3v[(p2e[2])]=((0)*1.)
set Axv[(p2e[2])]=(4)
set NJv[(p2e[2])]=(('}')*1.)
set Njv[(p2e[2])]=(('}')*1.)
set Nhv[(p2e[2])]=((0)*1.)
set NIv[(p2e[2])]=(($708)*1.)
set NOv[(p2e[2])]=(($708)*1.)
set Ndv[(p2e[2])]=((25)*1.)
set ANv[(p2e[2])]=(gSv)
set Adv[(p2e[2])]=((600)*1.)
set ADv[((p2e[2]))]=((1.*1./((1.8)*1.))*1.)
set Atv[(p2e[2])]=((.55)*1.)
set Drv[(p2e[2])]=((600)*1.)
set AQv[(p2e[2])]=(($E)*1.)
set Asv[(p2e[2])]=(($E)*1.)
set Auv[(p2e[2])]=(2)
set AWv[(p2e[2])]=(7)
set Azv[(p2e[2])]=(4)
set Aqv[(p2e[2])]=((16)*1.)
return true
endfunction
function MJr takes nothing returns boolean
set p2e[3]=hGo('uDe3')
call hho(((p2e[3])),Apv,(INv))
set Tj[(p2e[3])]=((.7)*1.)
set Nav[(p2e[3])]=(('d')*1.)
set Ntv[(p2e[3])]=((60)*1.)
set Nlv[(p2e[3])]=((270)*1.)
set I3v[(p2e[3])]=((0)*1.)
set Axv[(p2e[3])]=(4)
set NJv[(p2e[3])]=(($B9)*1.)
set Njv[(p2e[3])]=(($B9)*1.)
set Nhv[(p2e[3])]=((0)*1.)
set NIv[(p2e[3])]=(($708)*1.)
set NOv[(p2e[3])]=(($708)*1.)
set Ndv[(p2e[3])]=((35)*1.)
set ANv[(p2e[3])]=(gSv)
set Adv[(p2e[3])]=((600)*1.)
set ADv[((p2e[3]))]=((1.*1./((1.8)*1.))*1.)
set Atv[(p2e[3])]=((.55)*1.)
set Drv[(p2e[3])]=((600)*1.)
set AQv[(p2e[3])]=((20)*1.)
set Asv[(p2e[3])]=((20)*1.)
set Auv[(p2e[3])]=(2)
set AWv[(p2e[3])]=(7)
set Azv[(p2e[3])]=(4)
set Aqv[(p2e[3])]=((16)*1.)
return true
endfunction
function Mkr takes nothing returns boolean
set p2e[5]=hGo('uDe5')
call hho(((p2e[5])),Apv,(INv))
set Tj[(p2e[5])]=((.7)*1.)
set Nav[(p2e[5])]=(('d')*1.)
set Ntv[(p2e[5])]=((60)*1.)
set Nlv[(p2e[5])]=((270)*1.)
set I3v[(p2e[5])]=((0)*1.)
set Axv[(p2e[5])]=(4)
set NJv[(p2e[5])]=((335)*1.)
set Njv[(p2e[5])]=((335)*1.)
set Nhv[(p2e[5])]=((0)*1.)
set NIv[(p2e[5])]=(($708)*1.)
set NOv[(p2e[5])]=(($708)*1.)
set Ndv[(p2e[5])]=((55)*1.)
set ANv[(p2e[5])]=(gSv)
set Adv[(p2e[5])]=((600)*1.)
set ADv[((p2e[5]))]=((1.*1./((1.8)*1.))*1.)
set Atv[(p2e[5])]=((.55)*1.)
set Drv[(p2e[5])]=((600)*1.)
set AQv[(p2e[5])]=((38)*1.)
set Asv[(p2e[5])]=((38)*1.)
set Auv[(p2e[5])]=(2)
set AWv[(p2e[5])]=(7)
set Azv[(p2e[5])]=(4)
set Aqv[(p2e[5])]=((16)*1.)
return true
endfunction
function MKr takes nothing returns boolean
call VRx(Sa,(function Mgr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Summon\\obj_summonUnitType[4]_wc3unit.j"))
call VRx(Sa,(function MGr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Summon\\obj_summonUnitType[1]_wc3unit.j"))
call VRx(ea,(function Mhr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Summon\\obj_this_wc3obj.j"))
call VRx(Ma,(function MHr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Summon\\obj_dummyBuff_wc3buff.j"))
call VRx(Sa,(function Mjr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Summon\\obj_summonUnitType[2]_wc3unit.j"))
call VRx(Sa,(function MJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Summon\\obj_summonUnitType[3]_wc3unit.j"))
call VRx(Sa,(function Mkr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Summon\\obj_summonUnitType[5]_wc3unit.j"))
return true
endfunction
function Mlr takes nothing returns boolean
set p7e=Vnx(p6e)
return true
endfunction
function MLr takes nothing returns boolean
set p8e=WTx('BInB',"Infection",'bInB')
set qc[(p8e)]=(true)
set qU[(p8e)]=(true)
set aev[(p8e)]=("ReplaceableTextures\\CommandButtons\\BTNDoom.blp")
call lux(p8e,"Abilities\\Spells\\Other\\AcidBomb\\BottleImpact.mdl","head",Bi)
call lux(p8e,"Abilities\\Spells\\Other\\Parasite\\ParasiteTarget.mdl","overhead",ri)
return true
endfunction
function Mmr takes nothing returns boolean
set p9e[1]=-3
set p9e[2]=-5
set p9e[3]=-7
set p9e[4]=-9
set p9e[5]=-$B
set p9e[6]=-$D
set Pve[1]=20
set Pve[2]=35
set Pve[3]=60
set Pve[4]=95
set Pve[5]=$8C
set Pve[6]=$C3
set Pee[1]=5
set Pee[2]=5
set Pee[3]=5
set Pee[4]=5
set Pee[5]=5
set Pee[6]=5
return true
endfunction
function MMr takes nothing returns boolean
call VRx(Ma,(function MLr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Target\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function Mmr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Target\\obj_this_wc3obj.j"))
return true
endfunction
function Mpr takes nothing returns boolean
set Pxe=Vnx(Poe)
return true
endfunction
function MPr takes nothing returns boolean
call LZx('AIfc',false)
set Gov=Lzo('AIfc')
set G6[(Gov)]=(N6)
set j6[(Gov)]=(6)
set sH[(Gov)]=("Infection")
set Ih[(Gov)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00EE)))),(((Oj))))))
set x6v[(Gov)]=(0)
set xzv[(Gov)]=("spell")
call LZo((Gov),fH+(1),(($D)*1.))
call LZo((Gov),QH+(1),((50)*1.))
call LZo((Gov),Lvv+(1),((750)*1.))
call LZo((Gov),fH+(2),(($D)*1.))
call LZo((Gov),QH+(2),((62)*1.))
call LZo((Gov),Lvv+(2),((750)*1.))
call LZo((Gov),fH+(3),(($D)*1.))
call LZo((Gov),QH+(3),((74)*1.))
call LZo((Gov),Lvv+(3),((750)*1.))
call LZo((Gov),fH+(4),(($D)*1.))
call LZo((Gov),QH+(4),((86)*1.))
call LZo((Gov),Lvv+(4),((750)*1.))
call LZo((Gov),fH+(5),(($D)*1.))
call LZo((Gov),QH+(5),((98)*1.))
call LZo((Gov),Lvv+(5),((750)*1.))
call LZo((Gov),fH+(6),(($D)*1.))
call LZo((Gov),QH+(6),(('n')*1.))
call LZo((Gov),Lvv+(6),((750)*1.))
set Mnv[(Gov)]=("ReplaceableTextures\\CommandButtons\\BTNDoom.blp")
call ccr(Gov,'FIn0',6,'VIn0','LPIn','LRIn')
set Pre[1]=3
set Pre[2]=5
set Pre[3]=7
set Pre[4]=9
set Pre[5]=$B
set Pre[6]=$D
set Pie[1]=8
set Pie[2]=8
set Pie[3]=9
set Pie[4]=9
set Pie[5]=$A
set Pie[6]=$A
set Pae[1]=0
set Pae[2]=0
set Pae[3]=0
set Pae[4]=0
set Pae[5]=0
set Pae[6]=0
return true
endfunction
function Mqr takes nothing returns boolean
set Pne=WTx('BInf',"Infection",'bInf')
set avv[(Pne)]=(true)
set aev[(Pne)]=("ReplaceableTextures\\CommandButtons\\BTNDoom.blp")
call lux(Pne,"Infection_page\\Infection_struct\\CasterEffect.mdx","head",ri)
set SU=lYx()
call l_x(SU,cIv,3)
call l_x(SU,cbv,0)
call l0x(((Pne)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,cIv,5)
call l_x(SU,cbv,0)
call l0x(((Pne)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,cIv,7)
call l_x(SU,cbv,0)
call l0x(((Pne)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,cIv,9)
call l_x(SU,cbv,0)
call l0x(((Pne)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,cIv,$B)
call l_x(SU,cbv,0)
call l0x(((Pne)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,cIv,$D)
call l_x(SU,cbv,0)
call l0x(((Pne)),vc+(6),(SU))
return true
endfunction
function MQr takes nothing returns boolean
call VRx(qa,(function MPr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function Mqr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function Msr takes nothing returns boolean
set PVe=Vnx(PEe)
return true
endfunction
function MSr takes integer CMx,integer rwx,integer Ixx returns nothing
set PRe=CMx
call NIx((Ixx),(p8e),(rwx),w,((Pee[rwx])*1.))
endfunction
function Mtr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(EYv[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx
local integer rwx
if(IsUnitAlly(C[(Ixx)],vx[((ze[(CMx)]))]))then
return true
endif
set oqx=CMx
set rwx=POe[oqx]
call MSr(CMx,rwx,Ixx)
return true
endfunction
function MTr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
set POe[oqx]=rwx
call I7x(Ixx,PXe)
return true
endfunction
function Mur takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call Rmx(Ixx,PXe)
return true
endfunction
function MUr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Mv[(rdx)])
call NIx(((Vv[(rdx)])),(Pne),(rwx),w,((Pie[rwx])*1.))
return true
endfunction
function Mwr takes nothing returns boolean
local integer Ixx=jFx()
if(I5x((OPe),Rb,(Ixx)))then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function MWr takes nothing returns nothing
set PIe=PAe*1./ PNe
set Pbe=O2x()
set PBe=PNe*Pce
set PCe=XLx(function Mwr)
endfunction
function Myr takes integer CMx,integer rwx,integer Ixx returns nothing
local integer oqx=CMx
local integer nyx=PDe[oqx]
local integer IVr
if(nyx<p3e[rwx])then
set nyx=nyx+1
set IVr=Uzo(p2e[rwx],(ze[(CMx)]),(GetUnitX(C[((Ixx))])),(GetUnitY(C[((Ixx))])),(GetUnitFacing(C[((Ixx))])*bh),p4e[rwx])
set PDe[oqx]=nyx
call rTx(IVr,Pfe,oqx)
call I7x(IVr,PFe)
set Pge=CMx
call rzx(((IVr)),((pZe)),(1))
endif
endfunction
function MYr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call Myr(PGe[oqx],Phe[oqx],Ixx)
return true
endfunction
function Mzr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
local integer CMx=PGe[oqx]
call nJo((CMx),(Ixx),((PHe[oqx])*1.),(true),(false))
endfunction
function MZr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=PRe
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=inx()
set PGe[oqx]=CMx
set PHe[oqx]=Pje[rwx]
set PJe[oqx]=p0x
set Phe[oqx]=rwx
call I7x(Ixx,Pde)
call icx(p0x,Pke,true,function Mzr)
return true
endfunction
function M_r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=PJe[oqx]
call ijx(p0x)
call Rmx(Ixx,Pde)
return true
endfunction
function M0r takes nothing returns nothing
local integer olx
set Pde=XBx("FolderInfection_StructTarget_Init: set FolderInfection_StructTarget.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_StructTarget.Event_Death)",VP,pI,function MYr)
call l9x(p8e,XBx("FolderInfection_StructTarget_Init: call FolderInfection_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_StructTarget.Event_BuffGain))",Bd,pI,function MZr))
call l9x(p8e,XBx("FolderInfection_StructTarget_Init: call FolderInfection_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_StructTarget.Event_BuffLose))",Jc,pI,function M_r))
set olx=(j6[(Gov)])
loop
set Pje[olx]=Pve[olx]*1./(R2I(((Pee[olx]*1./ Pke)*1.)))
set olx=olx-1
exitwhen(olx<1)
endloop
endfunction
function M1r takes nothing returns boolean
local integer rdx=(bv)
local integer IVr=(Vv[(rdx)])
local integer oqx=oPx(IVr,Pfe)
local integer nyx=PDe[oqx]-1
set PDe[oqx]=nyx
call rix(IVr,Pfe)
call Rmx(IVr,PFe)
return true
endfunction
function M2r takes nothing returns boolean
local integer rdx=(bv)
local integer M3r=(Vv[(rdx)])
local real M4r=(LNv[(rdx)])*Ple
local integer olx=CXx(M3r,PLe)
local integer oqx
local integer Ixx
loop
set oqx=COx(M3r,PLe,olx)
set Ixx=oqx
call moo(M3r,Ixx,M4r)
set olx=olx-1
exitwhen(olx<q)
endloop
return true
endfunction
function M5r takes nothing returns boolean
local integer rdx=(bv)
local integer M3r=Pge
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call ajx("A")
set Pme[oqx]=M3r
call ajx("B")
if rtx(M3r,PLe,oqx)then
call ajx("C")
call I7x(M3r,PKe)
endif
call ajx("D")
return true
endfunction
function M6r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer M3r=Pme[oqx]
if rrx(M3r,PLe,oqx)then
call Rmx(M3r,PKe)
endif
return true
endfunction
function M7r takes nothing returns boolean
local integer rdx=(bv)
call Q8o((Vv[(rdx)]),p_e,(Mv[(rdx)]))
return true
endfunction
function M8r takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),p_e)
return true
endfunction
function M9r takes nothing returns nothing
set PKe=XBx("FolderInfection_FolderSummon_StructFuniculusUmbilicalis_Init: set FolderInfection_FolderSummon_StructFuniculusUmbilicalis.HEAL_EVENT = Event.Create(Unit.HEALED_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_FolderSummon_StructFuniculusUmbilicalis.Event_Heal)",BAv,pI,function M2r)
call l9x(p_e,XBx("FolderInfection_FolderSummon_StructFuniculusUmbilicalis_Init: call FolderInfection_FolderSummon_StructFuniculusUmbilicalis.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_FolderSummon_StructFuniculusUmbilicalis.Event_BuffGain))",Bd,pI,function M5r))
call l9x(p_e,XBx("FolderInfection_FolderSummon_StructFuniculusUmbilicalis_Init: call FolderInfection_FolderSummon_StructFuniculusUmbilicalis.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_FolderSummon_StructFuniculusUmbilicalis.Event_BuffLose))",Jc,pI,function M6r))
call meo(pZe,XBx("FolderInfection_FolderSummon_StructFuniculusUmbilicalis_Init: call FolderInfection_FolderSummon_StructFuniculusUmbilicalis.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_FolderSummon_StructFuniculusUmbilicalis.Event_Learn))",Pv,pI,function M7r))
call meo(pZe,XBx("FolderInfection_FolderSummon_StructFuniculusUmbilicalis_Init: call FolderInfection_FolderSummon_StructFuniculusUmbilicalis.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_FolderSummon_StructFuniculusUmbilicalis.Event_Learn))",pv,pI,function M7r))
call meo(pZe,XBx("FolderInfection_FolderSummon_StructFuniculusUmbilicalis_Init: call FolderInfection_FolderSummon_StructFuniculusUmbilicalis.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_FolderSummon_StructFuniculusUmbilicalis.Event_Unlearn))",Av,pI,function M8r))
endfunction
function pvr takes nothing returns nothing
set PFe=XBx("FolderInfection_StructSummon_Init: set FolderInfection_StructSummon.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_StructSummon.Event_Death)",VP,pI,function M1r)
call M9r()
endfunction
function per takes nothing returns boolean
set PXe=XBx("Infection_Init: set Infection.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function Infection.Event_Damage)",EZv,pI,function Mtr)
call l9x(Pne,XBx("Infection_Init: call Infection.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Infection.Event_BuffGain))",Bd,pI,function MTr))
call l9x(Pne,XBx("Infection_Init: call Infection.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Infection.Event_BuffLose))",Jc,pI,function Mur))
call meo(Gov,XBx("Infection_Init: call Infection.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Infection.Event_SpellEffect))",ah,pI,function MUr))
call MWr()
call M0r()
call pvr()
return true
endfunction
function pxr takes nothing returns boolean
call FOr(function per,"Infection_Init")
return true
endfunction
function por takes nothing returns boolean
set PMe[1]=20
set PMe[2]=30
set PMe[3]=40
set PMe[4]=50
set PMe[5]=60
set Ppe[1]=20
set Ppe[2]=30
set Ppe[3]=40
set Ppe[4]=50
set Ppe[5]=60
return true
endfunction
function prr takes nothing returns boolean
set PPe=lQx(Pqe+" (dummyBuff)")
return true
endfunction
function pir takes nothing returns boolean
call VRx(ea,(function por),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\KhakiRecovery.page\\KhakiRecovery.struct\\Restoration\\obj_this_wc3obj.j"))
call VRx(Ma,(function prr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\KhakiRecovery.page\\KhakiRecovery.struct\\Restoration\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function par takes nothing returns boolean
set PQe=Vnx(Pqe)
return true
endfunction
function pnr takes nothing returns boolean
set Pse=Vbx("OKRS")
return true
endfunction
function pVr takes nothing returns boolean
set PSe=WTx('BRec',"Khaki Recovery",'bRec')
set avv[(PSe)]=(true)
set qc[(PSe)]=(true)
set qU[(PSe)]=(true)
set aev[(PSe)]=("ReplaceableTextures\\CommandButtons\\BTNMagicImmunity.blp")
call lux(PSe,"Abilities\\Spells\\NightElf\\Barkskin\\BarkSkinTarget.mdl","chest",ri)
set SU=lYx()
call l_x(SU,dKv,50)
call l0x(((PSe)),vc+(1),(SU))
return true
endfunction
function pEr takes nothing returns boolean
call LZx('ARec',false)
set gWv=Lzo('ARec')
set G6[(gWv)]=(i6)
set j6[(gWv)]=(6)
set sH[(gWv)]=("Khaki Recovery")
set Ih[(gWv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0215)))),(((Oj))))))
set x6v[(gWv)]=(4)
set xzv[(gWv)]=("spell")
call LZo((gWv),u6v+(1),((500)*1.))
call LZo((gWv),fH+(1),((6)*1.))
call LZo((gWv),QH+(1),(('i')*1.))
call LZo((gWv),Lvv+(1),((650)*1.))
call LZo((gWv),u6v+(2),((500)*1.))
call LZo((gWv),fH+(2),((6)*1.))
call LZo((gWv),QH+(2),(('x')*1.))
call LZo((gWv),Lvv+(2),((650)*1.))
call LZo((gWv),u6v+(3),((500)*1.))
call LZo((gWv),fH+(3),((6)*1.))
call LZo((gWv),QH+(3),(($87)*1.))
call LZo((gWv),Lvv+(3),((650)*1.))
call LZo((gWv),u6v+(4),((500)*1.))
call LZo((gWv),fH+(4),((6)*1.))
call LZo((gWv),QH+(4),(($96)*1.))
call LZo((gWv),Lvv+(4),((650)*1.))
call LZo((gWv),u6v+(5),((500)*1.))
call LZo((gWv),fH+(5),((6)*1.))
call LZo((gWv),QH+(5),(($A5)*1.))
call LZo((gWv),Lvv+(5),((650)*1.))
call LZo((gWv),u6v+(6),((500)*1.))
call LZo((gWv),fH+(6),((6)*1.))
call LZo((gWv),QH+(6),(($B4)*1.))
call LZo((gWv),Lvv+(6),((650)*1.))
set Mnv[(gWv)]=("ReplaceableTextures\\CommandButtons\\BTNMagicImmunity.blp")
call ccr(gWv,'FRc0',6,'VRc0','LPRc','LRRc')
set Pte[1]=3
set Pte[2]=3
set Pte[3]=4
set Pte[4]=4
set Pte[5]=5
set Pte[6]=5
set PTe[1]=8
set PTe[2]=8
set PTe[3]=8
set PTe[4]=8
set PTe[5]=8
set PTe[6]=8
set Pue[1]=50
set Pue[2]=60
set Pue[3]=70
set Pue[4]=80
set Pue[5]=90
set Pue[6]='d'
set PUe[1]='x'
set PUe[2]=$B4
set PUe[3]=$F0
set PUe[4]=300
set PUe[5]=360
set PUe[6]=420
set Pwe[1]=30
set Pwe[2]=45
set Pwe[3]=60
set Pwe[4]=75
set Pwe[5]=90
set Pwe[6]='i'
return true
endfunction
function pXr takes nothing returns boolean
set PWe=Vbx("OKhR")
return true
endfunction
function pOr takes nothing returns boolean
call VRx(Ha,(function pnr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\KhakiRecovery.page\\KhakiRecovery.struct\\obj_boltSecondary_wc3bolt.j"))
call VRx(Ma,(function pVr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\KhakiRecovery.page\\KhakiRecovery.struct\\obj_moveSpeedBuff_wc3buff.j"))
call VRx(qa,(function pEr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\KhakiRecovery.page\\KhakiRecovery.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ha,(function pXr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\KhakiRecovery.page\\KhakiRecovery.struct\\obj_boltPrimary_wc3bolt.j"))
return true
endfunction
function pRr takes nothing returns boolean
set Pye=Vnx(PYe)
return true
endfunction
function pIr takes nothing returns boolean
local integer Ixx=jFx()
if Lko(nXe,Ixx)then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,Icv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if not(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function pAr takes integer oqx returns integer
set P3e[oqx]=true
set P4e[oqx]=false
call rax(Pye)
return oqx
endfunction
function pNr takes nothing returns integer
local integer oqx
if(P_e==8190)then
call oYx("KhakiRecovery_Allocation_allocCustom","call DebugEx(KhakiRecovery.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",PYe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(P0e[(w)]==w)then
set P1e=P1e+1
set oqx=P1e
else
set oqx=P0e[(w)]
set P0e[(w)]=P0e[P0e[(w)]]
endif
set P0e[oqx]=Z
set P2e[oqx]=1
call pAr(oqx)
return oqx
endfunction
function pbr takes integer oqx returns nothing
set P3e[oqx]=false
call rgx(Pye)
endfunction
function pBr takes integer oqx returns nothing
if(P2e[oqx]>0)then
return
endif
if(P0e[oqx]!=Z)then
call oYx("KhakiRecovery_Allocation_deallocCustom_confirm","call DebugEx(KhakiRecovery.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",PYe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set P0e[oqx]=P0e[(w)]
set P0e[(w)]=oqx
call pbr(oqx)
endfunction
function pcr takes integer oqx returns nothing
set P2e[oqx]=P2e[oqx]-1
call pBr(oqx)
endfunction
function pCr takes integer oqx,integer OHx returns nothing
call pcr((oqx))
call ijx(OHx)
call XYr(qee[oqx])
endfunction
function pdr takes boolean pDr,integer pfr,integer pFr returns integer
if pDr then
return cBo(pfr)
endif
return cBo(pFr)
endfunction
function pgr takes integer oqx,integer CMx,integer rwx,integer pGr,integer Edr,integer ECr returns nothing
local integer clo=pdr((ECr==0),PWe,Pse)
local real Anr=P8e[oqx]*(1.+qne*(ECr-1))
set P9e[oqx]=Edr
call dpx(qee[oqx],Edr)
call RUx((Abx((Edr),(qVe),(qEe),(Bi))))
call NIx((Edr),(PSe),(rwx),w,((PTe[rwx])*1.))
call moo(CMx,Edr,Anr)
if(ECr!=0)then
call SetLightningColor(TT[(clo)],(0)*1./ 255.,($FF)*1./ 255.,(0)*1./ 255.,($FF)*1./ 255.)
endif
call EEr(clo,pGr,Edr)
call pKo((Abx((Edr),(qXe),(qOe),(ri))),2.)
call cko(clo,.75)
endfunction
function phr takes nothing returns nothing
local integer OHx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(OHx)])
local integer Q7o=qee[oqx]
local integer ECr=qxe[oqx]+1
local integer CMx
local integer pGr
local real pHr
local real pjr
local integer Edr
if(ECr>qoe[oqx])then
call pCr(oqx,OHx)
else
set CMx=P6e[oqx]
set pGr=P9e[oqx]
set pHr=(GetUnitX(C[((pGr))]))
set pjr=(GetUnitY(C[((pGr))]))
set OPe=Q7o
set Hf=(ze[(CMx)])
call Nio(Pze,pHr,pjr,P5e[oqx],PZe)
set Edr=(mjo((Pze),((pHr)*1.),((pjr)*1.)))
if(Edr==w)then
call pCr(oqx,OHx)
else
set qxe[oqx]=ECr
call pgr(oqx,CMx,qve[oqx],pGr,Edr,ECr-1)
endif
endif
endfunction
function pJr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer oqx=pNr()
local integer OHx=inx()
local integer Q7o=JIx("KhakiRecovery_Event_SpellEffect: local UnitList targetGroup = UnitList.Create()")
set P5e[oqx]=(Cpx((gWv),u6v+(rwx)))
set P6e[oqx]=CMx
set P7e[oqx]=OHx
set P8e[oqx]=PUe[rwx]
set P9e[oqx]=Ixx
set qve[oqx]=rwx
set qee[oqx]=Q7o
set qxe[oqx]=1
set qoe[oqx]=Pte[rwx]
set ge[(OHx)]=(oqx)
call RUx((Abx((CMx),(qre),(qie),(ri))))
call icx(OHx,qae,true,function phr)
call pgr(oqx,CMx,rwx,CMx,Ixx,0)
call wbo(Ixx,true,false,true)
return true
endfunction
function pkr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(FG[(rdx)])
local integer oqx=CMx
call pKo((Abx((CMx),(qIe),(qAe),(ri))),2.)
call moo(CMx,CMx,qNe[oqx])
call mro(CMx,CMx,qbe[oqx])
return true
endfunction
function pKr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
set qNe[oqx]=PMe[rwx]
set qbe[oqx]=Ppe[rwx]
call I7x(Ixx,qRe)
return true
endfunction
function plr takes nothing returns boolean
local integer rdx=(bv)
call Rmx((Vv[(rdx)]),qRe)
return true
endfunction
function pLr takes nothing returns boolean
local integer rdx=(bv)
call Q8o((Vv[(rdx)]),PPe,(Mv[(rdx)]))
return true
endfunction
function pmr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),PPe)
return true
endfunction
function pMr takes nothing returns nothing
set qRe=XBx("FolderKhakiRecovery_StructRestoration_Init: set FolderKhakiRecovery_StructRestoration.DEATH_EVENT = Event.Create(UNIT.Death.Events.KILLER_EVENT_TYPE, EventPriority.SPELLS, function FolderKhakiRecovery_StructRestoration.Event_Death)",Bkv,pI,function pkr)
call l9x(PPe,XBx("FolderKhakiRecovery_StructRestoration_Init: call FolderKhakiRecovery_StructRestoration.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderKhakiRecovery_StructRestoration.Event_BuffGain))",Bd,pI,function pKr))
call l9x(PPe,XBx("FolderKhakiRecovery_StructRestoration_Init: call FolderKhakiRecovery_StructRestoration.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderKhakiRecovery_StructRestoration.Event_BuffLose))",Jc,pI,function plr))
call meo(gWv,XBx("FolderKhakiRecovery_StructRestoration_Init: call KhakiRecovery.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function FolderKhakiRecovery_StructRestoration.Event_Learn))",Pv,pI,function pLr))
call meo(gWv,XBx("FolderKhakiRecovery_StructRestoration_Init: call KhakiRecovery.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderKhakiRecovery_StructRestoration.Event_Learn))",pv,pI,function pLr))
call meo(gWv,XBx("FolderKhakiRecovery_StructRestoration_Init: call KhakiRecovery.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderKhakiRecovery_StructRestoration.Event_Unlearn))",Av,pI,function pmr))
endfunction
function ppr takes nothing returns boolean
set Pze=O2x()
set PZe=XLx(function pIr)
call meo(gWv,XBx("KhakiRecovery_Init: call KhakiRecovery.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function KhakiRecovery.Event_SpellEffect))",ah,pI,function pJr))
call pMr()
return true
endfunction
function pPr takes nothing returns boolean
call FOr(function ppr,"KhakiRecovery_Init")
return true
endfunction
function pqr takes nothing returns boolean
set qBe[1]=60
set qBe[2]=60
set qBe[3]=60
set qBe[4]=60
set qBe[5]=60
set qBe[6]=60
return true
endfunction
function pQr takes nothing returns boolean
set qce[2]=hGo('uMC2')
call hho(((qce[2])),Apv,(INv))
set Tj[(qce[2])]=((1.4)*1.)
set Nav[(qce[2])]=((123.45679012346)*1.)
set Ntv[(qce[2])]=((74.074074074074)*1.)
set nGv[(qce[2])]=("Units\\Undead\\Abomination\\AbominationExplosion.mdx")
set Nlv[(qce[2])]=((270)*1.)
set I3v[(qce[2])]=(($A)*1.)
set Axv[(qce[2])]=(2)
set NJv[(qce[2])]=(($5DC)*1.)
set Njv[(qce[2])]=(($5DC)*1.)
set Nhv[(qce[2])]=((0)*1.)
set NIv[(qce[2])]=(($578)*1.)
set NOv[(qce[2])]=(($578)*1.)
set Ndv[(qce[2])]=(($96)*1.)
set ANv[(qce[2])]=(gHv)
set Adv[(qce[2])]=((300)*1.)
set ADv[((qce[2]))]=((1.*1./((2)*1.))*1.)
set Atv[(qce[2])]=((.5)*1.)
set AQv[(qce[2])]=((60)*1.)
set Asv[(qce[2])]=((60)*1.)
set Auv[(qce[2])]=(5)
set AWv[(qce[2])]=(8)
set Azv[(qce[2])]=(0)
set Aqv[(qce[2])]=((59.259259259259)*1.)
return true
endfunction
function psr takes nothing returns boolean
set qce[3]=hGo('uMC3')
call hho(((qce[3])),Apv,(INv))
set Tj[(qce[3])]=((1.65)*1.)
set Nav[(qce[3])]=((123.45679012346)*1.)
set Ntv[(qce[3])]=((74.074074074074)*1.)
set nGv[(qce[3])]=("Units\\Undead\\Abomination\\AbominationExplosion.mdx")
set Nlv[(qce[3])]=((270)*1.)
set I3v[(qce[3])]=(($A)*1.)
set Axv[(qce[3])]=(2)
set NJv[(qce[3])]=(($7D0)*1.)
set Njv[(qce[3])]=(($7D0)*1.)
set Nhv[(qce[3])]=((0)*1.)
set NIv[(qce[3])]=(($578)*1.)
set NOv[(qce[3])]=(($578)*1.)
set Ndv[(qce[3])]=(($C8)*1.)
set ANv[(qce[3])]=(gHv)
set Adv[(qce[3])]=((300)*1.)
set ADv[((qce[3]))]=((1.*1./((2)*1.))*1.)
set Atv[(qce[3])]=((.5)*1.)
set AQv[(qce[3])]=((80)*1.)
set Asv[(qce[3])]=((80)*1.)
set Auv[(qce[3])]=(5)
set AWv[(qce[3])]=($A)
set Azv[(qce[3])]=(0)
set Aqv[(qce[3])]=((59.259259259259)*1.)
return true
endfunction
function pSr takes nothing returns boolean
set qce[1]=hGo('uMC1')
call hho(((qce[1])),Apv,(INv))
set Tj[(qce[1])]=((1.25)*1.)
set Nav[(qce[1])]=((123.45679012346)*1.)
set Ntv[(qce[1])]=((74.074074074074)*1.)
set nGv[(qce[1])]=("Units\\Undead\\Abomination\\AbominationExplosion.mdx")
set Nlv[(qce[1])]=((270)*1.)
set I3v[(qce[1])]=(($A)*1.)
set Axv[(qce[1])]=(2)
set NJv[(qce[1])]=(($3E8)*1.)
set Njv[(qce[1])]=(($3E8)*1.)
set Nhv[(qce[1])]=((0)*1.)
set NIv[(qce[1])]=(($578)*1.)
set NOv[(qce[1])]=(($578)*1.)
set Ndv[(qce[1])]=(('d')*1.)
set ANv[(qce[1])]=(gHv)
set Adv[(qce[1])]=((300)*1.)
set ADv[((qce[1]))]=((1.*1./((2)*1.))*1.)
set Atv[(qce[1])]=((.5)*1.)
set AQv[(qce[1])]=((40)*1.)
set Asv[(qce[1])]=((40)*1.)
set Auv[(qce[1])]=(5)
set AWv[(qce[1])]=(6)
set Azv[(qce[1])]=(0)
set Aqv[(qce[1])]=((59.259259259259)*1.)
return true
endfunction
function ptr takes nothing returns boolean
call LZx('AMaC',false)
set g5v=Lzo('AMaC')
set G6[(g5v)]=(C6)
set j6[(g5v)]=(3)
set sH[(g5v)]=("Mana Colossus")
set Ih[(g5v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0272)))),(((Oj))))))
set x6v[(g5v)]=(0)
set xzv[(g5v)]=("spell")
call LZo((g5v),fH+(1),(('x')*1.))
call LZo((g5v),QH+(1),(($FA)*1.))
call LZo((g5v),Lvv+(1),((750)*1.))
call LZo((g5v),fH+(2),(('x')*1.))
call LZo((g5v),QH+(2),((350)*1.))
call LZo((g5v),Lvv+(2),((750)*1.))
call LZo((g5v),fH+(3),(('x')*1.))
call LZo((g5v),QH+(3),((450)*1.))
call LZo((g5v),Lvv+(3),((750)*1.))
set Mnv[(g5v)]=("ReplaceableTextures\\CommandButtons\\BTNAbomination.blp")
call ccr(g5v,'FMC0',3,'VMC0','LPMC','LRMC')
return true
endfunction
function pTr takes nothing returns boolean
call VRx(ea,(function pqr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaColossus.page\\ManaColossus.struct\\obj_this_wc3obj.j"))
call VRx(Sa,(function pQr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaColossus.page\\ManaColossus.struct\\obj_thisUnitTypes[2]_wc3unit.j"))
call VRx(Sa,(function psr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaColossus.page\\ManaColossus.struct\\obj_thisUnitTypes[3]_wc3unit.j"))
call VRx(Sa,(function pSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaColossus.page\\ManaColossus.struct\\obj_thisUnitTypes[1]_wc3unit.j"))
call VRx(qa,(function ptr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaColossus.page\\ManaColossus.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function pur takes nothing returns boolean
set qCe=Vnx(qde)
return true
endfunction
function pUr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer C0o=(ze[(CMx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real N8x=(GetUnitFacing(C[((CMx))])*bh)
local integer IVr=Uzo(qce[rwx],C0o,wpo+qDe*(Cos(((((N8x)*1.))*1.))),wPo+qDe*(Sin(((((N8x)*1.))*1.))),N8x,qBe[rwx])
call rzx((IVr),(qfe),(rwx))
return true
endfunction
function pwr takes nothing returns boolean
call meo(g5v,XBx("ManaColossus_Init: call ManaColossus.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ManaColossus.Event_SpellEffect))",ah,pI,function pUr))
return true
endfunction
function pWr takes nothing returns boolean
call FOr(function pwr,"ManaColossus_Init")
return true
endfunction
function pyr takes nothing returns boolean
set qFe=WTx('BTVT',"Theurgic Vessel - Target",'bTVT')
set avv[(qFe)]=(true)
set aev[(qFe)]=("ReplaceableTextures\\CommandButtons\\BTNPotionOfVampirism.blp")
call lux(qFe,"Abilities\\Spells\\Undead\\Possession\\PossessionTarget.mdl","origin",ri)
set SU=lYx()
call l_x(SU,Edv,.2)
call l_x(SU,cBv,.2)
call l0x(((qFe)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,Edv,.3)
call l_x(SU,cBv,.3)
call l0x(((qFe)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,Edv,.4)
call l_x(SU,cBv,.4)
call l0x(((qFe)),vc+(3),(SU))
return true
endfunction
function pYr takes nothing returns boolean
set qge[1]=.2
set qge[2]=.3
set qge[3]=.4
set qGe[1]=.2
set qGe[2]=.3
set qGe[3]=.4
return true
endfunction
function pzr takes nothing returns boolean
call VRx(Ma,(function pyr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaColossus.page\\TheurgicVessel.struct\\Target\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function pYr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaColossus.page\\TheurgicVessel.struct\\Target\\obj_this_wc3obj.j"))
return true
endfunction
function pZr takes nothing returns boolean
set qhe=Vnx(qHe)
return true
endfunction
function p_r takes nothing returns boolean
set qje=WTx('BThV',"Theurgic Vessel",'bThV')
set avv[(qje)]=(true)
set aev[(qje)]=("ReplaceableTextures\\CommandButtons\\BTNPotionOfVampirism.blp")
call lux(qje,"Abilities\\Spells\\Items\\AIso\\BIsvTarget.mdx","chest",ri)
return true
endfunction
function p0r takes nothing returns boolean
call LZx('AThV',false)
set qfe=Lzo('AThV')
set G6[(qfe)]=(D6)
set j6[(qfe)]=(1)
set sH[(qfe)]=("Theurgic Vessel")
set xzv[(qfe)]=("spell")
call LZo((qfe),u6v+(1),((600)*1.))
call LZo((qfe),Lvv+(1),((750)*1.))
set Mnv[(qfe)]=("ReplaceableTextures\\CommandButtons\\BTNPotionOfVampirism.blp")
return true
endfunction
function p1r takes nothing returns boolean
call VRx(Ma,(function p_r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaColossus.page\\TheurgicVessel.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function p0r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaColossus.page\\TheurgicVessel.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function p2r takes nothing returns boolean
set qJe=Vnx(qke)
return true
endfunction
function p3r takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if not(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function p4r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer oqx=CMx
local integer XSr=Xpr(CMx)
set qle[oqx]=CMx
set qLe[oqx]=rwx
set Eee[(XSr)]=(oqx)
set vme[(XSr)]=(((Cpx((qfe),u6v+(rwx))))*1.)
set vMe[(XSr)]=(qKe)
call XPr(XSr,qme)
call XPr(XSr,qMe)
call XQr(XSr)
return true
endfunction
function p5r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer oqx=CMx
local integer XSr=qpe[oqx]
call X2r(XSr)
return true
endfunction
function p6r takes nothing returns boolean
local integer rdx=(bv)
call Q8o((Vv[(rdx)]),qje,(Mv[(rdx)]))
return true
endfunction
function p7r takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),qje)
return true
endfunction
function p8r takes nothing returns boolean
set qKe=XLx(function p3r)
call l9x(qje,XBx("TheurgicVessel_Init: call TheurgicVessel.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TheurgicVessel.Event_BuffGain))",Bd,pI,function p4r))
call l9x(qje,XBx("TheurgicVessel_Init: call TheurgicVessel.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TheurgicVessel.Event_BuffLose))",Jc,pI,function p5r))
call meo(qfe,XBx("TheurgicVessel_Init: call TheurgicVessel.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function TheurgicVessel.Event_Learn))",Pv,pI,function p6r))
call meo(qfe,XBx("TheurgicVessel_Init: call TheurgicVessel.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TheurgicVessel.Event_Learn))",pv,pI,function p6r))
call meo(qfe,XBx("TheurgicVessel_Init: call TheurgicVessel.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TheurgicVessel.Event_Unlearn))",Av,pI,function p7r))
return true
endfunction
function p9r takes nothing returns boolean
call fBr(function p8r,"TheurgicVessel_Init")
return true
endfunction
function Pvr takes nothing returns boolean
set qPe=lQx(qqe+" (dummyBuff)")
set qc[(qPe)]=(true)
call lux(qPe,"Abilities\\Spells\\NightElf\\Barkskin\\BarkSkinTarget.mdl","hand left",ri)
call lux(qPe,"Abilities\\Spells\\NightElf\\Barkskin\\BarkSkinTarget.mdl","hand right",ri)
return true
endfunction
function Per takes nothing returns boolean
call LZx('AMaR',false)
set qQe=Lzo('AMaR')
set G6[(qQe)]=(i6)
set j6[(qQe)]=(6)
set sH[(qQe)]=("Revert")
set Ih[(qQe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0104)))),(((Oj))))))
set x6v[(qQe)]=(0)
set xzv[(qQe)]=("spell")
call LZo((qQe),fH+(1),((0)*1.))
call LZo((qQe),Lvv+(1),((750)*1.))
call LZo((qQe),fH+(2),((0)*1.))
call LZo((qQe),Lvv+(2),((750)*1.))
call LZo((qQe),fH+(3),((0)*1.))
call LZo((qQe),Lvv+(3),((750)*1.))
call LZo((qQe),fH+(4),((0)*1.))
call LZo((qQe),Lvv+(4),((750)*1.))
call LZo((qQe),fH+(5),((0)*1.))
call LZo((qQe),Lvv+(5),((750)*1.))
call LZo((qQe),fH+(6),((0)*1.))
call LZo((qQe),Lvv+(6),((750)*1.))
set Mnv[(qQe)]=("ReplaceableTextures\\CommandButtons\\BTNNeutralManaShieldOff.blp")
call ccr(qQe,'FMR0',6,'VMR0','LPMR','LRMR')
return true
endfunction
function Pxr takes nothing returns boolean
call VRx(Ma,(function Pvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaLaser.page\\ManaLaser.struct\\Revert\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function Per),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaLaser.page\\ManaLaser.struct\\Revert\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Por takes nothing returns boolean
set qse=Vnx(qqe)
return true
endfunction
function Prr takes nothing returns boolean
set qSe=Vbx("OMaL")
return true
endfunction
function Pir takes nothing returns boolean
call LZx('AMaL',false)
set qte=Lzo('AMaL')
set G6[(qte)]=(i6)
set j6[(qte)]=(6)
set sH[(qte)]=("Mana Laser")
set Ih[(qte)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00D3)))),(((Oj))))))
set x6v[(qte)]=(2)
set xzv[(qte)]=("spell")
call LZo((qte),u6v+(1),(($C8)*1.))
call LZo((qte),fH+(1),(($F)*1.))
call LZo((qte),QH+(1),((90)*1.))
call LZo((qte),Lvv+(1),((99999)*1.))
call LZo((qte),u6v+(2),(($C8)*1.))
call LZo((qte),fH+(2),(($F)*1.))
call LZo((qte),QH+(2),(('i')*1.))
call LZo((qte),Lvv+(2),((99999)*1.))
call LZo((qte),u6v+(3),(($C8)*1.))
call LZo((qte),fH+(3),(($F)*1.))
call LZo((qte),QH+(3),(('x')*1.))
call LZo((qte),Lvv+(3),((99999)*1.))
call LZo((qte),u6v+(4),(($C8)*1.))
call LZo((qte),fH+(4),(($F)*1.))
call LZo((qte),QH+(4),(($87)*1.))
call LZo((qte),Lvv+(4),((99999)*1.))
call LZo((qte),u6v+(5),(($C8)*1.))
call LZo((qte),fH+(5),(($F)*1.))
call LZo((qte),QH+(5),(($96)*1.))
call LZo((qte),Lvv+(5),((99999)*1.))
call LZo((qte),u6v+(6),(($C8)*1.))
call LZo((qte),fH+(6),(($F)*1.))
call LZo((qte),QH+(6),(($A5)*1.))
call LZo((qte),Lvv+(6),((99999)*1.))
set Mnv[(qte)]=("ReplaceableTextures\\CommandButtons\\BTNManaBurn.blp")
call ccr(qte,'FML0',6,'VML0','LPML','LRML')
set qTe[1]=650
set qTe[2]=650
set qTe[3]=650
set qTe[4]=650
set qTe[5]=650
set qTe[6]=650
set que[1]=900
set que[2]=900
set que[3]=900
set que[4]=900
set que[5]=900
set que[6]=900
set qUe[1]=3
set qUe[2]=3
set qUe[3]=4
set qUe[4]=4
set qUe[5]=5
set qUe[6]=5
set qwe[1]=50
set qwe[2]=80
set qwe[3]='n'
set qwe[4]=$8C
set qwe[5]=$B4
set qwe[6]=$E6
return true
endfunction
function Par takes nothing returns boolean
call VRx(Ha,(function Prr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaLaser.page\\ManaLaser.struct\\obj_bolt_wc3bolt.j"))
call VRx(qa,(function Pir),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaLaser.page\\ManaLaser.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Pnr takes nothing returns boolean
set qWe=Vnx(qye)
return true
endfunction
function PVr takes nothing returns boolean
local integer Ixx=jFx()
if(I5x((OPe),Rb,(Ixx)))then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function PEr takes integer oqx returns integer
set q3e[oqx]=true
set q4e[oqx]=false
call rax(qWe)
return oqx
endfunction
function PXr takes nothing returns integer
local integer oqx
if(q_e==8190)then
call oYx("ManaLaser_Allocation_allocCustom","call DebugEx(ManaLaser.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",qye+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(q0e[(w)]==w)then
set q1e=q1e+1
set oqx=q1e
else
set oqx=q0e[(w)]
set q0e[(w)]=q0e[q0e[(w)]]
endif
set q0e[oqx]=Z
set q2e[oqx]=1
call PEr(oqx)
return oqx
endfunction
function POr takes integer oqx returns integer
set gT[oqx]=true
set QOe[oqx]=false
call rax(lt)
return oqx
endfunction
function PRr takes nothing returns integer
local integer oqx
if(QEe==8190)then
call oYx("FolderLightning_StructFromDummyUnitToUnit_Allocation_allocCustom","call DebugEx(FolderLightning_StructFromDummyUnitToUnit.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Lt+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(FT[(w)]==w)then
set QXe=QXe+1
set oqx=QXe
else
set oqx=FT[(w)]
set FT[(w)]=FT[FT[(w)]]
endif
set FT[oqx]=Z
set fT[oqx]=1
call POr(oqx)
return oqx
endfunction
function PIr takes integer oqx returns boolean
set LT=LT+1
set lT[LT]=oqx
set KT[oqx]=LT+1
return(LT==0)
endfunction
function PAr takes nothing returns nothing
local integer olx=LT
local integer oqx
local integer ozx
local integer Ixx
local real jlx
local real jLx
local real cho
local real dix
local real dax
local real Mpx
loop
set oqx=lT[olx]
set ozx=MT[oqx]
set Ixx=pT[oqx]
if(ozx==w)then
set jlx=iu[oqx]
set jLx=au[oqx]
set cho=nu[oqx]
else
set jlx=(oJ[(ozx)])
set jLx=(nJ[(ozx)])
set cho=(Vu[(ozx)])+Eu[oqx]
endif
if(Ixx==w)then
set dix=Xu[oqx]
set dax=Ou[oqx]
set Mpx=Ru[oqx]
else
set dix=DPx(Ixx)
set dax=DQx(Ixx)
set Mpx=Olx(Ixx,dix,dax)+K_x(Ixx,true)
endif
call cfo(PT[oqx],jlx,jLx,cho,dix,dax,Mpx)
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function PNr takes integer oqx,integer ozx,real Pbr,integer Ixx returns nothing
local integer rkx=oqx
local real dix=DPx(Ixx)
local real dax=DQx(Ixx)
call cco(rkx)
set oqx=PRr()
set PT[oqx]=rkx
set MT[oqx]=ozx
set Eu[oqx]=Pbr
set pT[oqx]=Ixx
call cDo(rkx,DT,oqx)
call Kqx(rkx,CT)
if QPo(ozx,hT,oqx)then
call Mxx(ozx,HT)
endif
if rtx(Ixx,hT,oqx)then
call I7x(Ixx,jT)
call AYo(Ixx)
endif
call cfo(rkx,(oJ[(ozx)]),(nJ[(ozx)]),(Vu[(ozx)])+Pbr,dix,dax,Olx(Ixx,dix,dax)+K_x(Ixx,true))
if PIr(oqx)then
call icx(mT,QRe,true,function PAr)
endif
endfunction
function PBr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local real O1o=q6e[oqx]
local real Ksr=q7e[oqx]
local integer CMx=q8e[oqx]
local integer HOx=Qee[oqx]
local integer Q7o=Qoe[oqx]
local real x=(oJ[(HOx)])+Qie[oqx]
local real y=(nJ[(HOx)])+Qne[oqx]
local integer Ixx
local integer Pcr
local integer PCr
local integer clo
local real Pdr
local real Ydo
call Mko(HOx,x,y,XYx(x,y)+q5e)
set Hf=(ze[(CMx)])
set OPe=Q7o
call Nio(qYe,x,y,O1o,qze)
set Ixx=Nao(qYe)
if(Ixx!=w)then
set Pcr=q9e[oqx]
set PCr=Qve[oqx]
loop
set clo=cBo(qSe)
call dpx(Q7o,Ixx)
call PNr(clo,HOx,60.,Ixx)
call cko(clo,.35)
call RUx((Abx((Ixx),(QIe),(QAe),(ri))))
if not nIo(Ixx)then
set Pdr=(LF[(Ixx)])
set Ydo=itx(Pdr,Ksr)
call YBo(CMx,Ixx,Ydo)
if(Pcr<PCr)then
set Pcr=Pcr+1
call NIx((Ixx),(r6e),(1),w,((ine)*1.))
call wbo(Ixx,false,true,true)
set q9e[oqx]=Pcr
endif
endif
set Ixx=Nao(qYe)
exitwhen(Ixx==w)
endloop
endif
endfunction
function PDr takes integer oqx returns nothing
set q3e[oqx]=false
call rgx(qWe)
endfunction
function Pfr takes integer oqx returns nothing
if(q2e[oqx]>0)then
return
endif
if(q0e[oqx]!=Z)then
call oYx("ManaLaser_Allocation_deallocCustom_confirm","call DebugEx(ManaLaser.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",qye+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set q0e[oqx]=q0e[(w)]
set q0e[(w)]=oqx
call PDr(oqx)
endfunction
function PFr takes integer oqx returns nothing
set q2e[oqx]=q2e[oqx]-1
call Pfr(oqx)
endfunction
function Pgr takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local integer CMx=q8e[oqx]
local integer HOx=Qee[oqx]
local integer Q7o=Qoe[oqx]
local integer Q6o=Qre[oqx]
local real x=(oJ[(HOx)])
local real y=(nJ[(HOx)])
local real z=(Vu[(HOx)])
call PFr((oqx))
call Mfx(HOx)
call ijx(ibx)
call XYr(Q7o)
call ijx(Q6o)
call UJx(((CMx)),Oyv)
call JLr(CMx,x,y,XYx(x,y))
endfunction
function PGr takes integer Ixx,real x,real y returns nothing
set Qbe=x
set QBe=y
call NIx((Ixx),(qPe),(1),w,((Qce)*1.))
endfunction
function Phr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local real N8x=UCx(CMx,dix-wpo,dax-wPo)
local real HCr=(Cos(((((N8x)*1.))*1.)))
local real Hdr=(Sin(((((N8x)*1.))*1.)))
local real XNr=wpo+qZe*HCr
local real Xbr=wPo+qZe*Hdr
local integer oqx=PXr()
local integer HOx=mcx('qMaL',XNr,Xbr,XYx(XNr,Xbr)+q5e,N8x)
local integer ibx=inx()
local integer Q6o=inx()
set q6e[oqx]=(Cpx((qte),u6v+(rwx)))
set q7e[oqx]=qwe[rwx]
set q8e[oqx]=CMx
set q9e[oqx]=0
set Qve[oqx]=qUe[rwx]
set Qee[oqx]=HOx
set Qxe[oqx]=ibx
set Qoe[oqx]=JIx("ManaLaser_Event_SpellEffect: set this.targetGroup = UnitList.Create()")
set Qre[oqx]=Q6o
set Qie[oqx]=Qae[rwx]*HCr
set Qne[oqx]=Qae[rwx]*Hdr
set ge[(ibx)]=(oqx)
set ge[(Q6o)]=(oqx)
call DSx((((CMx))),(Oyv),(1),w)
call icx(Q6o,QVe,true,function PBr)
call icx(ibx,QNe[rwx],false,function Pgr)
call PGr(CMx,wpo,wPo)
return true
endfunction
function PHr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local real x=Qbe
local real y=QBe
local integer oqx=Ixx
set QCe[oqx]=(mHo(((x)*1.),((y)*1.),(Qde),(ri)))
set QDe[oqx]=x
set Qfe[oqx]=y
call Obo(qQe,Ixx)
return true
endfunction
function Pjr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer Kyr=QCe[oqx]
call mFo(Kyr)
call Obo(qte,Ixx)
return true
endfunction
function PJr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer oqx=CMx
local real x=QDe[oqx]
local real y=Qfe[oqx]
call Ayx(CMx,qPe)
call mFo((mHo((((GetUnitX(C[((CMx))])))*1.),(((GetUnitY(C[((CMx))])))*1.),(QFe),(ri))))
call JLr(CMx,x,y,XYx(x,y))
call mFo((mHo(((x)*1.),((y)*1.),(Qge),(ri))))
return true
endfunction
function Pkr takes nothing returns nothing
call l9x(qPe,XBx("FolderManaLaser_StructRevert_Init: call FolderManaLaser_StructRevert.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderManaLaser_StructRevert.Event_BuffGain))",Bd,pI,function PHr))
call l9x(qPe,XBx("FolderManaLaser_StructRevert_Init: call FolderManaLaser_StructRevert.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderManaLaser_StructRevert.Event_BuffLose))",Jc,pI,function Pjr))
call meo(qQe,XBx("FolderManaLaser_StructRevert_Init: call FolderManaLaser_StructRevert.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderManaLaser_StructRevert.Event_SpellEffect))",ah,pI,function PJr))
endfunction
function PKr takes nothing returns boolean
local integer olx
set qYe=O2x()
set qze=XLx(function PVr)
call meo(qte,XBx("ManaLaser_Init: call ManaLaser.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ManaLaser.Event_SpellEffect))",ah,pI,function Phr))
set olx=(j6[(qte)])
loop
set QNe[olx]=qTe[olx]*1./ que[olx]
set Qae[olx]=que[olx]*QVe
set olx=olx-1
exitwhen(olx<1)
endloop
call Pkr()
return true
endfunction
function Plr takes nothing returns boolean
call FOr(function PKr,"ManaLaser_Init")
return true
endfunction
function PLr takes nothing returns boolean
call LZx('AMaX',false)
set QGe=Lzo('AMaX')
set G6[(QGe)]=(C6)
set j6[(QGe)]=(3)
set sH[(QGe)]=("Charm")
set Ih[(QGe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0206)))),(((Oj))))))
set x6v[(QGe)]=(4)
set xzv[(QGe)]=("spell")
call LZo((QGe),fH+(1),(($A)*1.))
call LZo((QGe),QH+(1),(($A)*1.))
call LZo((QGe),Lvv+(1),((350)*1.))
call LZo((QGe),fH+(2),(($A)*1.))
call LZo((QGe),QH+(2),(($A)*1.))
call LZo((QGe),Lvv+(2),((350)*1.))
call LZo((QGe),fH+(3),(($A)*1.))
call LZo((QGe),QH+(3),(($A)*1.))
call LZo((QGe),Lvv+(3),((350)*1.))
set Mnv[(QGe)]=("ReplaceableTextures\\CommandButtons\\BTNCharm.blp")
call ccr(QGe,'FMX0',3,'VMX0','LPMX','LRMX')
return true
endfunction
function Pmr takes nothing returns boolean
call VRx(qa,(function PLr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\MassMimesis.page\\MassMimesis.struct\\Charm\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function PMr takes nothing returns boolean
set Qhe=Vnx(QHe)
return true
endfunction
function Ppr takes nothing returns boolean
return true
endfunction
function PPr takes nothing returns boolean
set Qje=Vnx(QJe)
return true
endfunction
function Pqr takes nothing returns boolean
call LZx('AMaM',false)
set Gjv=Lzo('AMaM')
set G6[(Gjv)]=(C6)
set j6[(Gjv)]=(3)
set sH[(Gjv)]=("Mass Mimesis")
set Ih[(Gjv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0206)))),(((Oj))))))
set x6v[(Gjv)]=(2)
set xzv[(Gjv)]=("spell")
call LZo((Gjv),fH+(1),(('x')*1.))
call LZo((Gjv),QH+(1),((400)*1.))
call LZo((Gjv),Lvv+(1),((99999)*1.))
call LZo((Gjv),fH+(2),(('x')*1.))
call LZo((Gjv),QH+(2),((500)*1.))
call LZo((Gjv),Lvv+(2),((99999)*1.))
call LZo((Gjv),fH+(3),(('x')*1.))
call LZo((Gjv),QH+(3),((600)*1.))
call LZo((Gjv),Lvv+(3),((99999)*1.))
set Mnv[(Gjv)]=("ReplaceableTextures\\CommandButtons\\BTNAbsorbMagic.blp")
call ccr(Gjv,'FMM0',3,'VMM0','LPMM','LRMM')
set Qke[1]=20
set Qke[2]=20
set Qke[3]=20
set QKe[1]=60
set QKe[2]=60
set QKe[3]=60
return true
endfunction
function PQr takes nothing returns boolean
set Qle=lQx(QLe+" (dummyBuff)")
return true
endfunction
function Psr takes nothing returns boolean
call VRx(qa,(function Pqr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\MassMimesis.page\\MassMimesis.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function PQr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\MassMimesis.page\\MassMimesis.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function PSr takes nothing returns boolean
set Qme=Vnx(QLe)
return true
endfunction
function Ptr takes integer CMx,integer Ixx returns boolean
return( not(I6x(Ixx,yd)and not(IsUnitAlly(C[(Ixx)],vx[((ze[(CMx)]))]))))and( not(I6x(Ixx,Ibv)))and( not(I6x(Ixx,ICv)))and( not(I6x(Ixx,IFv)))
endfunction
function PTr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer rJx=(nv[(rdx)])
local integer oqx
local integer Q7o
local integer rwx
local real Pur
local real PUr
local real dix
local real dax
local real dX
local real dY
local integer Pwr
if(Ixx==w)then
return true
endif
if not Ptr(CMx,Ixx)then
return true
endif
set oqx=CMx
set Q7o=Qpe[oqx]
if(I5x((Q7o),Rb,(Ixx)))then
return true
endif
call dpx(Q7o,Ixx)
set rwx=QPe[oqx]
set Pur=Qqe[oqx]
set PUr=QQe[oqx]
set dix=(GetUnitX(C[((Ixx))]))
set dax=(GetUnitY(C[((Ixx))]))
set dX=dix-Pur
set dY=dax-PUr
set Pwr=RSr((uf[(Ixx)]),(ze[(CMx)]),Qqe[oqx],QQe[oqx],(Atan2(((dY)*1.),((dX)*1.))),Qke[rwx],Qse)
call RUx((Abx((Pwr),(QSe),(Qte),(ri))))
call DSx((((Pwr))),(nTv),(1),w)
call DSx((((Pwr))),(XVv),(1),w)
call rzx(((Pwr)),((gQv)),(1))
call CAx(Pwr,Xw,dix,dax)
return true
endfunction
function PWr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local real dix=QTe
local real dax=Que
local real O1o=(Cpx((Gjv),u6v+(rwx)))
local real Mpx=XYx(dix,dax)
local integer oqx=Ixx
local integer HOx=mcx('qMaM',dix,dax,Mpx,.0)
local integer Pyr=mcx('qMM2',dix,dax,Mpx,.0)
set QUe[oqx]=(Cpx((Gjv),u6v+(rwx)))
set Qwe[oqx]=HOx
set QWe[oqx]=Pyr
set QPe[oqx]=rwx
set Qpe[oqx]=JIx("MassMimesis_Event_BuffGain: set this.targetGroup = UnitList.Create()")
set Qqe[oqx]=dix
set QQe[oqx]=dax
call I7x(Ixx,QMe)
call Obo(QGe,Ixx)
return true
endfunction
function PYr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer HOx=Qwe[oqx]
local integer Pyr=QWe[oqx]
local integer Q7o=Qpe[oqx]
call MCx(HOx)
call Mfx(Pyr)
call XYr(Q7o)
call Rmx(Ixx,QMe)
call Obo(Gjv,Ixx)
return true
endfunction
function Pzr takes integer oqx returns integer
set Q_e[oqx]=true
set Q0e[oqx]=false
call rax(Qje)
return oqx
endfunction
function PZr takes nothing returns integer
local integer oqx
if(Qye==8190)then
call oYx("FolderMassMimesis_StructMissile_Allocation_allocCustom","call DebugEx(FolderMassMimesis_StructMissile.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",QJe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(QYe[(w)]==w)then
set Qze=Qze+1
set oqx=Qze
else
set oqx=QYe[(w)]
set QYe[(w)]=QYe[QYe[(w)]]
endif
set QYe[oqx]=Z
set QZe[oqx]=1
call Pzr(oqx)
return oqx
endfunction
function P_r takes integer oqx returns nothing
set Q_e[oqx]=false
call rgx(Qje)
endfunction
function P0r takes integer oqx returns nothing
if(QZe[oqx]>0)then
return
endif
if(QYe[oqx]!=Z)then
call oYx("FolderMassMimesis_StructMissile_Allocation_deallocCustom_confirm","call DebugEx(FolderMassMimesis_StructMissile.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",QJe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set QYe[oqx]=QYe[(w)]
set QYe[(w)]=oqx
call P_r(oqx)
endfunction
function P1r takes integer oqx returns nothing
set QZe[oqx]=QZe[oqx]-1
call P0r(oqx)
endfunction
function P2r takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=Q1e[oqx]
local integer rwx=Q2e[oqx]
local real dix=Q3e[oqx]
local real dax=Q4e[oqx]
call P1r((oqx))
call Mdo(MFo)
set QTe=dix
set Que=dax
call NIx((CMx),(Qle),(rwx),w,((QKe[rwx])*1.))
return true
endfunction
function P3r takes integer CMx,integer rwx,real dix,real dax returns nothing
local integer oqx=PZr()
local integer MFo=Mvo()
set Q1e[oqx]=CMx
set Q2e[oqx]=rwx
set Q3e[oqx]=dix
set Q4e[oqx]=dax
call m1o(MFo,2000.)
set mAv[((MFo))]=((b6v*((.2)*1.))*1.)
set mNv[(MFo)]=((48.)*1.)
call Mro(MFo,'qMMM',1.)
set mCv[(MFo)]=XHx((function P2r))
set mWv[(MFo)]=(oqx)
call m8o(MFo,500.)
call M9o(MFo,CMx)
call o6r(MFo,dix,dax,XYx(dix,dax))
endfunction
function P4r takes nothing returns boolean
local integer rdx=(bv)
call P3r((Vv[(rdx)]),(Mv[(rdx)]),(UH[(rdx)]),(wH[(rdx)]))
return true
endfunction
function P5r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer rkx=CMx
if((CMx!=Ixx)and I6x(Ixx,yd))then
return true
endif
call A7o((Nvo((((GetUnitX(C[((Ixx))])))*1.),(((GetUnitY(C[((Ixx))])))*1.),(Q5e),(ri),(((ob[(Ixx)]))*1.))))
call SetUnitPosition(C[((Ixx))],((Qqe[rkx])*1.),((QQe[rkx])*1.))
call A7o((Nvo((((GetUnitX(C[((Ixx))])))*1.),(((GetUnitY(C[((Ixx))])))*1.),(Q6e),(ri),(((ob[(Ixx)]))*1.))))
return true
endfunction
function P6r takes nothing returns boolean
local integer olx
set QMe=XBx("MassMimesis_Init: set MassMimesis.ANY_CAST_EVENT = Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MassMimesis.Event_AnyCast)",ah,pI,function PTr)
call l9x(Qle,XBx("MassMimesis_Init: call MassMimesis.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MassMimesis.Event_BuffGain))",Bd,pI,function PWr))
call l9x(Qle,XBx("MassMimesis_Init: call MassMimesis.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MassMimesis.Event_BuffLose))",Jc,pI,function PYr))
call meo(Gjv,XBx("MassMimesis_Init: call MassMimesis.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MassMimesis.Event_SpellEffect))",ah,pI,function P4r))
set olx=(j6[(Gjv)])
loop
set olx=olx-1
exitwhen(olx<1)
endloop
call meo(QGe,XBx("FolderMassMimesis_StructCharm_Init: call FolderMassMimesis_StructCharm.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderMassMimesis_StructCharm.Event_SpellEffect))",ah,pI,function P5r))
return true
endfunction
function P7r takes nothing returns boolean
call FOr(function P6r,"MassMimesis_Init")
return true
endfunction
function P8r takes nothing returns boolean
call LZx('AAva',false)
set hNv=Lzo('AAva')
set G6[(hNv)]=(c6)
set j6[(hNv)]=(3)
set sH[(hNv)]=("Mountain King")
set Ih[(hNv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0076)))),(((Oj))))))
set x6v[(hNv)]=(0)
set xzv[(hNv)]=("spell")
call LZo((hNv),fH+(1),((70)*1.))
call LZo((hNv),QH+(1),(('}')*1.))
call LZo((hNv),Lvv+(1),((750)*1.))
call LZo((hNv),fH+(2),((70)*1.))
call LZo((hNv),QH+(2),(('}')*1.))
call LZo((hNv),Lvv+(2),((750)*1.))
call LZo((hNv),fH+(3),((70)*1.))
call LZo((hNv),QH+(3),(('}')*1.))
call LZo((hNv),Lvv+(3),((750)*1.))
set Mnv[(hNv)]=("ReplaceableTextures\\CommandButtons\\BTNAvatar.blp")
call ccr(hNv,'FAv0',3,'VAv0','LPAv','LRAv')
set Q7e[1]=.4
set Q7e[2]=.6
set Q7e[3]=.8
set Q8e[1]=5
set Q8e[2]=$A
set Q8e[3]=$F
set Q9e[1]=30
set Q9e[2]=45
set Q9e[3]=60
set sve[1]=.2
set sve[2]=.3
set sve[3]=.4
set see[1]=.2
set see[2]=.3
set see[3]=.4
set sxe[1]=.2
set sxe[2]=.3
set sxe[3]=.4
return true
endfunction
function P9r takes nothing returns boolean
call LZx('aAvC',false)
return true
endfunction
function qvr takes nothing returns boolean
set soe=WTx('BAva',"Avatar",'bAva')
set avv[(soe)]=(true)
set aev[(soe)]=("ReplaceableTextures\\CommandButtons\\BTNAvatar.blp")
call lux(soe,"Abilities\\Spells\\Orc\\SpiritLink\\SpiritLinkTarget.mdl","chest",Bi)
set SU=lYx()
call l_x(SU,C8v,.2)
call l_x(SU,C6v,.2)
call l_x(SU,C7v,.2)
call l_x(SU,cRv,5)
call lzx(((SU)),Fc,(KHr(Db,.4,1)))
call vOr(SU,Dhv,true)
call l0x(((soe)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,C8v,.3)
call l_x(SU,C6v,.3)
call l_x(SU,C7v,.3)
call l_x(SU,cRv,$A)
call lzx(((SU)),Fc,(KHr(Db,.6,1)))
call vOr(SU,Dhv,true)
call l0x(((soe)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,C8v,.4)
call l_x(SU,C6v,.4)
call l_x(SU,C7v,.4)
call l_x(SU,cRv,$F)
call lzx(((SU)),Fc,(KHr(Db,.8,1)))
call vOr(SU,Dhv,true)
call l0x(((soe)),vc+(3),(SU))
return true
endfunction
function qer takes nothing returns boolean
set sre=hGo('UAva')
call hLo((sre),('AInv'),1)
call hho(((sre)),Apv,(yd))
call hho(((sre)),Apv,(INv))
set Tj[(sre)]=((1.4)*1.)
set Nav[(sre)]=((60)*1.)
set Ntv[(sre)]=((60)*1.)
set Nlv[(sre)]=((280)*1.)
set I3v[(sre)]=((3)*1.)
set Axv[(sre)]=(4)
set NJv[(sre)]=(('d')*1.)
set Njv[(sre)]=(('d')*1.)
set Nhv[(sre)]=((0)*1.)
set NKv[(sre)]=(('d')*1.)
set Nkv[(sre)]=(('d')*1.)
set NHv[(sre)]=((0)*1.)
set NIv[(sre)]=(($708)*1.)
set NOv[(sre)]=(($708)*1.)
set ANv[(sre)]=(gHv)
set Adv[(sre)]=(('x')*1.)
set ADv[((sre))]=((1.*1./((1.55)*1.))*1.)
set Atv[(sre)]=((.35)*1.)
set AQv[(sre)]=(($C)*1.)
set Asv[(sre)]=(($C)*1.)
set Auv[(sre)]=(2)
set AWv[(sre)]=($C)
set Azv[(sre)]=(0)
set Aqv[(sre)]=((32)*1.)
call hMo(sre,hIv)
call hMo(sre,hAv)
call hMo(sre,hNv)
call hMo(sre,hbv)
set bbv[(sre)]=((7.5)*1.)
set bFv[(sre)]=((3.5)*1.)
set bgv[(sre)]=((.85)*1.)
set bBv[(sre)]=((6)*1.)
set bGv[(sre)]=((3.25)*1.)
set bcv[(sre)]=((16)*1.)
set bhv[(sre)]=((5)*1.)
return true
endfunction
function qxr takes nothing returns boolean
call LZx('aAvX',false)
return true
endfunction
function qor takes nothing returns boolean
call VRx(qa,(function P8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\MountainKing.page\\MountainKing.struct\\obj_thisSpell_wc3spell.j"))
call VRx(qa,(function P9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\MountainKing.page\\MountainKing.struct\\obj_changerAbility_wc3spell.j"))
call VRx(Ma,(function qvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\MountainKing.page\\MountainKing.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(Sa,(function qer),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\MountainKing.page\\MountainKing.struct\\obj_thisUnitType_wc3unit.j"))
call VRx(qa,(function qxr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\MountainKing.page\\MountainKing.struct\\obj_revertAbility_wc3spell.j"))
return true
endfunction
function qrr takes nothing returns boolean
set sie=Vnx(sae)
return true
endfunction
function qir takes integer oqx,string UEx returns nothing
call AddUnitAnimationProperties(C[(oqx)],UEx,true)
call HDx((oqx))
endfunction
function qar takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local real qnr=(ZF[(Ixx)])
local integer oqx=Ixx
local integer qVr=lYx()
set sne[oqx]=qVr
call l_x(qVr,cRv,qnr*sVe)
call qir(Ixx,"alternate")
call I0x(Ixx,qVr)
call LOr(c6,sEe,Ixx)
return true
endfunction
function qEr takes integer oqx,string UEx returns nothing
call AddUnitAnimationProperties(C[(oqx)],UEx,false)
call HDx((oqx))
endfunction
function qXr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer qVr=sne[oqx]
call qEr(Ixx,"alternate")
call Iqx(Ixx,qVr)
call nrr(qVr)
call LOr(c6,hNv,Ixx)
return true
endfunction
function qOr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Mv[(rdx)])
call NIx(((Vv[(rdx)])),(soe),(rwx),w,((Q9e[rwx])*1.))
return true
endfunction
function qRr takes nothing returns boolean
call l9x(soe,XBx("MountainKing_Init: call MountainKing.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MountainKing.Event_BuffGain))",Bd,pI,function qar))
call l9x(soe,XBx("MountainKing_Init: call MountainKing.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MountainKing.Event_BuffLose))",Jc,pI,function qXr))
call meo(hNv,XBx("MountainKing_Init: call MountainKing.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MountainKing.Event_SpellEffect))",ah,pI,function qOr))
return true
endfunction
function qIr takes nothing returns boolean
call FOr(function qRr,"MountainKing_Init")
return true
endfunction
function qAr takes nothing returns boolean
call LZx('AThu',false)
set sEe=Lzo('AThu')
set G6[(sEe)]=(b6)
set j6[(sEe)]=(6)
set sH[(sEe)]=("Thunderbringer")
set Ih[(sEe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Oj))))))
set x6v[(sEe)]=(4)
set xzv[(sEe)]=("spell")
call LZo((sEe),u6v+(1),(('d')*1.))
call LZo((sEe),fH+(1),((7)*1.))
call LZo((sEe),Lvv+(1),(($AF)*1.))
call LZo((sEe),u6v+(2),(($96)*1.))
call LZo((sEe),fH+(2),((7)*1.))
call LZo((sEe),Lvv+(2),(($AF)*1.))
call LZo((sEe),u6v+(3),(($C8)*1.))
call LZo((sEe),fH+(3),((7)*1.))
call LZo((sEe),Lvv+(3),(($AF)*1.))
call LZo((sEe),u6v+(4),(($E1)*1.))
call LZo((sEe),fH+(4),((7)*1.))
call LZo((sEe),Lvv+(4),(($AF)*1.))
call LZo((sEe),u6v+(5),(($FA)*1.))
call LZo((sEe),fH+(5),((7)*1.))
call LZo((sEe),Lvv+(5),(($AF)*1.))
call LZo((sEe),u6v+(6),((275)*1.))
call LZo((sEe),fH+(6),((7)*1.))
call LZo((sEe),Lvv+(6),(($AF)*1.))
set Mnv[(sEe)]=("ReplaceableTextures\\CommandButtons\\BTNStormHammer.blp")
set sXe[1]=30
set sXe[2]=60
set sXe[3]=90
set sXe[4]='x'
set sXe[5]=$96
set sXe[6]=$B4
set sOe[1]=2
set sOe[2]=2.25
set sOe[3]=2.5
set sOe[4]=2.75
set sOe[5]=3
set sOe[6]=3.25
return true
endfunction
function qNr takes nothing returns boolean
call VRx(qa,(function qAr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\MountainKing.page\\MountainKing.struct\\Thunderbringer.page\\Thunderbringer.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function qbr takes nothing returns boolean
set sRe=Vnx(sIe)
return true
endfunction
function qBr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
endfunction
function qcr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local real x=(GetUnitX(C[((Ixx))]))
local real y=(GetUnitY(C[((Ixx))]))
local real NIo
local real gwr
call RUx((Abx((CMx),(sbe),(sBe),(ri))))
call mFo((mHo(((x)*1.),((y)*1.),(sce),(Bi))))
call mFo((mHo(((x)*1.),((y)*1.),(sCe),(Bi))))
set Hf=(ze[(CMx)])
call Nio(sAe,x,y,(Cpx((sEe),u6v+(rwx))),sNe)
set Ixx=Nao(sAe)
if(Ixx!=w)then
set NIo=(mg[(CMx)])+sXe[rwx]
set gwr=sOe[rwx]
loop
call NIx((Ixx),(Xsv),(rwx),w,((gwr)*1.))
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
set Ixx=Nao(sAe)
exitwhen(Ixx==w)
endloop
endif
return true
endfunction
function qCr takes nothing returns boolean
set sAe=O2x()
set sNe=XLx(function qBr)
call meo(sEe,XBx("Thunderbringer_Init: call Thunderbringer.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Thunderbringer.Event_SpellEffect))",ah,pI,function qcr))
return true
endfunction
function qdr takes nothing returns boolean
call I9r(function qCr,"Thunderbringer_Init")
return true
endfunction
function qDr takes nothing returns boolean
set sde=Vbx("ONeW")
return true
endfunction
function qfr takes nothing returns boolean
set sDe=lQx(sfe+" (silenceBuff)")
set qc[(sDe)]=(true)
set qU[(sDe)]=(true)
return true
endfunction
function qFr takes nothing returns boolean
call LZx('ANeW',false)
set GHv=Lzo('ANeW')
set G6[(GHv)]=(c6)
set j6[(GHv)]=(3)
set sH[(GHv)]=("Negation Wave")
set Ih[(GHv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0215)))),(((Oj))))))
set x6v[(GHv)]=(4)
set xzv[(GHv)]=("spell")
call LZo((GHv),u6v+(1),((500)*1.))
call LZo((GHv),fH+(1),((9)*1.))
call LZo((GHv),QH+(1),(('i')*1.))
call LZo((GHv),Lvv+(1),((550)*1.))
call LZo((GHv),u6v+(2),((500)*1.))
call LZo((GHv),fH+(2),((9)*1.))
call LZo((GHv),QH+(2),(('x')*1.))
call LZo((GHv),Lvv+(2),((550)*1.))
call LZo((GHv),u6v+(3),((500)*1.))
call LZo((GHv),fH+(3),((9)*1.))
call LZo((GHv),QH+(3),(($87)*1.))
call LZo((GHv),Lvv+(3),((550)*1.))
set Mnv[(GHv)]=("ReplaceableTextures\\CommandButtons\\BTNFeedback.blp")
call ccr(GHv,'FNW0',3,'VNW0','LPNW','LRNW')
set sFe[1]=7
set sFe[2]=$B
set sFe[3]=$F
set sge[1]=30
set sge[2]=40
set sge[3]=50
set sGe[1]=1
set sGe[2]=1.1
set sGe[3]=1.2
set she[1]=2
set she[2]=2.2
set she[3]=2.4
return true
endfunction
function qgr takes nothing returns boolean
call VRx(Ha,(function qDr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\NegationWave.page\\NegationWave.struct\\obj_bolt_wc3bolt.j"))
call VRx(Ma,(function qfr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\NegationWave.page\\NegationWave.struct\\obj_silenceBuff_wc3buff.j"))
call VRx(qa,(function qFr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\NegationWave.page\\NegationWave.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function qGr takes nothing returns boolean
set sHe=Vnx(sfe)
return true
endfunction
function qhr takes nothing returns boolean
local integer Ixx=jFx()
if(I5x((OPe),Rb,(Ixx)))then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,Icv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function qHr takes integer oqx returns integer
set spe[oqx]=true
set sPe[oqx]=false
call rax(sHe)
return oqx
endfunction
function qjr takes nothing returns integer
local integer oqx
if(sle==8190)then
call oYx("NegationWave_Allocation_allocCustom","call DebugEx(NegationWave.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",sfe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(sLe[(w)]==w)then
set sme=sme+1
set oqx=sme
else
set oqx=sLe[(w)]
set sLe[(w)]=sLe[sLe[(w)]]
endif
set sLe[oqx]=Z
set sMe[oqx]=1
call qHr(oqx)
return oqx
endfunction
function qJr takes integer oqx returns nothing
set spe[oqx]=false
call rgx(sHe)
endfunction
function qkr takes integer oqx returns nothing
if(sMe[oqx]>0)then
return
endif
if(sLe[oqx]!=Z)then
call oYx("NegationWave_Allocation_deallocCustom_confirm","call DebugEx(NegationWave.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",sfe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set sLe[oqx]=sLe[(w)]
set sLe[(w)]=oqx
call qJr(oqx)
endfunction
function qKr takes integer oqx returns nothing
set sMe[oqx]=sMe[oqx]-1
call qkr(oqx)
endfunction
function qlr takes integer oqx returns nothing
call qKr((oqx))
call ijx(sSe[oqx])
call XYr(sue[oqx])
endfunction
function qLr takes integer oqx,integer pGr,integer Edr,integer ECr returns nothing
local integer clo=cBo(sde)
local real qmr
set ste[oqx]=Edr
call EEr(clo,pGr,Edr)
call pKo((Abx((Edr),(sye),(sYe),(ri))),2.)
call dpx(sue[oqx],Edr)
call cko(clo,.75)
if I6x(Edr,yd)then
set qmr=sGe[sTe[oqx]]
else
set qmr=she[sTe[oqx]]
endif
call NIx((Edr),(sDe),(sTe[oqx]),w,((qmr)*1.))
call nJo((sQe[oqx]),(Edr),((sse[oqx])*1.),(true),(false))
endfunction
function qMr takes nothing returns nothing
local integer OHx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(OHx)])
local integer Q7o=sue[oqx]
local integer ECr=sUe[oqx]+1
local integer CMx
local integer pGr
local real pHr
local real pjr
local integer Edr
if(ECr>swe[oqx])then
call qlr(oqx)
else
set CMx=sQe[oqx]
set pGr=ste[oqx]
set pHr=(GetUnitX(C[((pGr))]))
set pjr=(GetUnitY(C[((pGr))]))
set OPe=Q7o
set Hf=(ze[(CMx)])
call Nio(sje,pHr,pjr,sqe[oqx],sJe)
set Edr=(mjo((sje),((pHr)*1.),((pjr)*1.)))
if(Edr==w)then
call qlr(oqx)
else
set sUe[oqx]=ECr
call qLr(oqx,pGr,Edr,ECr-1)
endif
endif
endfunction
function qpr takes integer oqx,integer Iox,integer rwx returns real
local real o4x
if not(oPx((((oqx))),(yb+(Iox)))>0)then
return .0
endif
set o4x=bbr(oqx,Iox,rwx)
if(o4x==.0)then
return sze
endif
return o4x
endfunction
function qPr takes integer oqx,integer Iox,integer rwx,integer I3x,real ilx returns integer
if(ilx==sze)then
return APx(oqx,Iox,rwx,I3x)
endif
return(NIx((oqx),(Iox),(rwx),(I3x),((ilx)*1.)))
endfunction
function qqr takes integer oqx,integer Ixx,boolean wBo,boolean wco,integer rwx returns nothing
local integer qQr=Ixx
local integer o7x=F
local real array ilx
local integer olx=(CXx(((qQr)),eB))
local integer array ulo
local integer Z4o
loop
exitwhen(olx<q)
set Z4o=(COx(((qQr)),eB,(olx)))
if(not(wd[(Z4o)])and(((avv[(Z4o)])and wco)or(not(avv[(Z4o)])and wBo))and((oPx(((Ixx)),zb+(Z4o)))<=rwx))then
set o7x=o7x+1
set ilx[o7x]=qpr(Ixx,Z4o,(oPx(((Ixx)),zb+(Z4o))))
set ulo[o7x]=Z4o
call Ayx(Ixx,Z4o)
endif
set olx=olx-1
endloop
loop
exitwhen(o7x<0)
call qPr(oqx,ulo[o7x],rwx,w,ilx[o7x])
set o7x=o7x-1
endloop
endfunction
function qsr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer oqx
local integer OHx
call RUx((Abx((CMx),(ske),(sKe),(ri))))
set oqx=qjr()
set OHx=inx()
set sqe[oqx]=(Cpx((GHv),u6v+(rwx)))
set sQe[oqx]=CMx
set sse[oqx]=sge[rwx]
set sSe[oqx]=OHx
set ste[oqx]=Ixx
set sTe[oqx]=rwx
set sue[oqx]=JIx("NegationWave_Event_SpellEffect: set this.targetGroup = UnitList.Create()")
set sUe[oqx]=1
set swe[oqx]=sFe[rwx]
set ge[(OHx)]=(oqx)
call icx(OHx,sWe,true,function qMr)
call qLr(oqx,CMx,Ixx,0)
call qqr(CMx,Ixx,false,true,rwx)
return true
endfunction
function qSr takes nothing returns boolean
set sje=O2x()
set sJe=XLx(function qhr)
call meo(GHv,XBx("NegationWave_Init: call NegationWave.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function NegationWave.Event_SpellEffect))",ah,pI,function qsr))
call W_x(Xhv,sDe)
return true
endfunction
function qtr takes nothing returns boolean
call FOr(function qSr,"NegationWave_Init")
return true
endfunction
function qTr takes nothing returns boolean
set sZe[1]='aNG1'
call LZx('aNG1',false)
return true
endfunction
function qur takes nothing returns boolean
set s_e=lQx(s0e+" (dummyBuff)")
return true
endfunction
function qUr takes nothing returns boolean
set s1e[1]=30
set s1e[2]=30
set s1e[3]=30
set s1e[4]=30
set s1e[5]=30
set s1e[6]=30
return true
endfunction
function qwr takes nothing returns boolean
set s2e=hGo('uNGS')
call hho(((s2e)),Apv,(INv))
set Tj[(s2e)]=((1.25)*1.)
call hHo(s2e,0,$FF,0,$FF)
set Nav[(s2e)]=(($B)*1.)
set Ntv[(s2e)]=(($B)*1.)
set Axv[(s2e)]=(5)
set NJv[(s2e)]=(('d')*1.)
set Njv[(s2e)]=(('d')*1.)
set Nhv[(s2e)]=((0)*1.)
set NIv[(s2e)]=(($96)*1.)
set NOv[(s2e)]=(($96)*1.)
set Ndv[(s2e)]=((0)*1.)
set AQv[(s2e)]=((0)*1.)
set Asv[(s2e)]=((0)*1.)
set Auv[(s2e)]=(0)
set AWv[(s2e)]=(0)
set Aqv[(s2e)]=((8)*1.)
call hLo((s2e),(gQv),1)
return true
endfunction
function qWr takes nothing returns boolean
set s3e[1]=hGo('uNG1')
call hho(((s3e[1])),Apv,(INv))
set Tj[(s3e[1])]=((1)*1.)
set Nav[(s3e[1])]=((60)*1.)
set Ntv[(s3e[1])]=((60)*1.)
set Nlv[(s3e[1])]=(($DC)*1.)
set I3v[(s3e[1])]=((0)*1.)
set Axv[(s3e[1])]=(0)
set NJv[(s3e[1])]=((40)*1.)
set Njv[(s3e[1])]=((40)*1.)
set Nhv[(s3e[1])]=((0)*1.)
set NIv[(s3e[1])]=((600)*1.)
set NOv[(s3e[1])]=((600)*1.)
set Ndv[(s3e[1])]=(($F)*1.)
set ANv[(s3e[1])]=(gHv)
set Adv[(s3e[1])]=(('x')*1.)
set ADv[((s3e[1]))]=((1.*1./((1.75)*1.))*1.)
set Atv[(s3e[1])]=((.467)*1.)
set AQv[(s3e[1])]=((7)*1.)
set Asv[(s3e[1])]=((7)*1.)
set Auv[(s3e[1])]=(2)
set AWv[(s3e[1])]=(2)
set Azv[(s3e[1])]=(0)
set Aqv[(s3e[1])]=((32)*1.)
return true
endfunction
function qyr takes nothing returns boolean
call VRx(qa,(function qTr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\NurturingGrounds.page\\NurturingGrounds.struct\\Egg\\obj_changerAbility[1]_wc3spell.j"))
call VRx(Ma,(function qur),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\NurturingGrounds.page\\NurturingGrounds.struct\\Egg\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function qUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\NurturingGrounds.page\\NurturingGrounds.struct\\Egg\\obj_this_wc3obj.j"))
call VRx(Sa,(function qwr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\NurturingGrounds.page\\NurturingGrounds.struct\\Egg\\obj_egg_wc3unit.j"))
call VRx(Sa,(function qWr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\NurturingGrounds.page\\NurturingGrounds.struct\\Egg\\obj_treant[1]_wc3unit.j"))
return true
endfunction
function qYr takes nothing returns boolean
set s4e=Vnx(s0e)
return true
endfunction
function qzr takes nothing returns boolean
call LZx('ANuG',false)
set gyv=Lzo('ANuG')
set G6[(gyv)]=(N6)
set j6[(gyv)]=(6)
set sH[(gyv)]=("Nurturing Grounds")
set Ih[(gyv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00CB)))),(((Oj))))))
set x6v[(gyv)]=(2)
set xzv[(gyv)]=("spell")
call LZo((gyv),u6v+(1),((350)*1.))
call LZo((gyv),fH+(1),((17)*1.))
call LZo((gyv),QH+(1),((50)*1.))
call LZo((gyv),Lvv+(1),((750)*1.))
call LZo((gyv),u6v+(2),((400)*1.))
call LZo((gyv),fH+(2),((17)*1.))
call LZo((gyv),QH+(2),((62)*1.))
call LZo((gyv),Lvv+(2),((750)*1.))
call LZo((gyv),u6v+(3),((450)*1.))
call LZo((gyv),fH+(3),((17)*1.))
call LZo((gyv),QH+(3),((74)*1.))
call LZo((gyv),Lvv+(3),((750)*1.))
call LZo((gyv),u6v+(4),((500)*1.))
call LZo((gyv),fH+(4),((17)*1.))
call LZo((gyv),QH+(4),((86)*1.))
call LZo((gyv),Lvv+(4),((750)*1.))
call LZo((gyv),u6v+(5),((550)*1.))
call LZo((gyv),fH+(5),((17)*1.))
call LZo((gyv),QH+(5),((98)*1.))
call LZo((gyv),Lvv+(5),((750)*1.))
call LZo((gyv),u6v+(6),((600)*1.))
call LZo((gyv),fH+(6),((17)*1.))
call LZo((gyv),QH+(6),(('n')*1.))
call LZo((gyv),Lvv+(6),((750)*1.))
set Mnv[(gyv)]=("ReplaceableTextures\\CommandButtons\\BTNEntanglingRoots.blp")
call ccr(gyv,'FNG0',6,'VNG0','LPNG','LRNG')
set s5e[1]=$C
set s5e[2]=$E
set s5e[3]=16
set s5e[4]=18
set s5e[5]=20
set s5e[6]=22
set s6e[1]=1
set s6e[2]=1
set s6e[3]=1
set s6e[4]=1
set s6e[5]=1
set s6e[6]=1
set s7e[1]=3
set s7e[2]=3
set s7e[3]=4
set s7e[4]=4
set s7e[5]=5
set s7e[6]=5
return true
endfunction
function qZr takes nothing returns boolean
call VRx(qa,(function qzr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\NurturingGrounds.page\\NurturingGrounds.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function q_r takes nothing returns boolean
set s8e=Vnx(s9e)
return true
endfunction
function q0r takes integer oqx returns integer
set Sre[oqx]=true
set Sie[oqx]=false
call rax(s8e)
return oqx
endfunction
function q1r takes nothing returns integer
local integer oqx
if(Sve==8190)then
call oYx("NurturingGrounds_Allocation_allocCustom","call DebugEx(NurturingGrounds.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",s9e+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(See[(w)]==w)then
set Sxe=Sxe+1
set oqx=Sxe
else
set oqx=See[(w)]
set See[(w)]=See[See[(w)]]
endif
set See[oqx]=Z
set Soe[oqx]=1
call q0r(oqx)
return oqx
endfunction
function q2r takes integer oqx,real x,real y,real ilx returns nothing
local integer o2x=Cgr(x,y)
if pJx(Sbe[oqx],o2x)then
call Cjr(o2x)
return
endif
call sLo(Sbe[oqx],o2x)
call Cqr(CTr(x,y,M7),ilx)
endfunction
function q3r takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local real q4r=Sne[oqx]+SEe[oqx]
local real dix
local real dax
local real q5r
local real jEr
local real q6r
local real jXr
local real q7r
local real y
local real x
set Sne[oqx]=q4r
set dix=SAe[oqx]
set dax=SNe[oqx]
set q5r=dix-q4r
set jEr=dix+q4r
set q6r=dax-q4r
set jXr=dax+q4r
set q7r=q4r*q4r
set y=q6r
call oYx("NurturingGrounds_Spread","call DebugEx(\"spread \"+R2S(curLength))","spread "+R2S(q4r))
loop
exitwhen(y>jXr)
set x=q5r
loop
exitwhen(x>jEr)
if(Gyx(x-dix,y-dax)<=q7r)then
call q2r(oqx,x,y,s5e[SOe[oqx]]+2*(1-Sne[oqx]*1./(Cpx((gyv),u6v+(SOe[oqx]))))*s6e[SOe[oqx]])
endif
set x=x+Sce
endloop
set y=y+Sce
endloop
endfunction
function q8r takes nothing returns nothing
local integer q9r=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(q9r)])
call oYx("NurturingGrounds_EndSpread","call DebugEx(\"endSpread\")","endSpread")
call iHx(q9r)
call iHx(SBe[oqx])
endfunction
function Qvr takes integer oqx returns nothing
set Sre[oqx]=false
call rgx(s8e)
endfunction
function Qer takes integer oqx returns nothing
if(Soe[oqx]>0)then
return
endif
if(See[oqx]!=Z)then
call oYx("NurturingGrounds_Allocation_deallocCustom_confirm","call DebugEx(NurturingGrounds.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",s9e+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set See[oqx]=See[(w)]
set See[(w)]=oqx
call Qvr(oqx)
endfunction
function Qxr takes integer oqx returns nothing
set Soe[oqx]=Soe[oqx]-1
call Qer(oqx)
endfunction
function Qor takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
call oYx("NurturingGrounds_EndingByTimer","call DebugEx(\"end\")","end")
call ijx(ibx)
call ijx(SVe[oqx])
call ijx(SIe[oqx])
call m6x(Sbe[oqx])
call ijx(SBe[oqx])
call Qxr((oqx))
endfunction
function Qrr takes real x,real y,integer CMx,integer rwx returns nothing
local integer IVr=bVx(s2e,(ze[(CMx)]),x,y,Kf)
call Roo(IVr,Idv)
call Uyo((IVr),((s1e[rwx])*1.))
call DSx((IVr),(s_e),(rwx),w)
call SetUnitAnimation(C[((IVr))],("birth"))
endfunction
function Qir takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local real N8x=(GetRandomReal(((.0)*1.),((df)*1.)))
local real oUx=(GetRandomReal(((.0)*1.),((Sne[oqx])*1.)))
local real x=SAe[oqx]+oUx*(Cos(((((N8x)*1.))*1.)))
local real y=SNe[oqx]+oUx*(Sin(((((N8x)*1.))*1.)))
call oYx("NurturingGrounds_SpawnEggByTimer","call DebugEx(\"create egg\")","create egg")
call Qrr(x,y,Sae[oqx],SOe[oqx])
endfunction
function Qar takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local real O1o=(Cpx((gyv),u6v+(rwx)))
local real ilx=s5e[rwx]
local real Qnr=s6e[rwx]
local integer oqx=q1r()
local integer ibx=inx()
local integer QVr=inx()
local integer q9r=inx()
local integer Q6o=inx()
set Sae[oqx]=CMx
set Sne[oqx]=.0
set SVe[oqx]=QVr
set SEe[oqx]=O1o*1./ Qnr*SXe
set SOe[oqx]=rwx
set SRe[oqx]=Qnr
set SIe[oqx]=q9r
set SAe[oqx]=dix
set SNe[oqx]=dax
set Sbe[oqx]=M0x()
set SBe[oqx]=Q6o
set ge[(ibx)]=(oqx)
set ge[(QVr)]=(oqx)
set ge[(q9r)]=(oqx)
set ge[(Q6o)]=(oqx)
call icx(Q6o,SXe,true,function q3r)
call icx(q9r,Qnr,false,function q8r)
call icx(ibx,ilx+Qnr,false,function Qor)
call icx(QVr,(ilx+Qnr)*1./(s7e[rwx]+1),true,function Qir)
return true
endfunction
function QEr takes nothing returns boolean
local integer rdx=(bv)
local integer QXr=(Vv[(rdx)])
local integer rwx=(oPx(((QXr)),zb+(s_e)))
call Ayx(QXr,s_e)
call Kpr(QXr,s3e[rwx],sZe[rwx])
return true
endfunction
function QOr takes nothing returns boolean
local integer rdx=(bv)
local integer QXr=(Vv[(rdx)])
call I7x(QXr,SCe)
return true
endfunction
function QRr takes nothing returns boolean
local integer rdx=(bv)
local integer QXr=(Vv[(rdx)])
call Rmx(QXr,SCe)
return true
endfunction
function QIr takes nothing returns nothing
set SCe=XBx("FolderNurturingGrounds_StructEgg_Init: set FolderNurturingGrounds_StructEgg.HEAL_EVENT = Event.Create(Unit.HEALED_EVENT_TYPE, EventPriority.SPELLS, function FolderNurturingGrounds_StructEgg.Event_Heal)",BAv,pI,function QEr)
call l9x(s_e,XBx("FolderNurturingGrounds_StructEgg_Init: call FolderNurturingGrounds_StructEgg.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderNurturingGrounds_StructEgg.Event_BuffGain))",Bd,pI,function QOr))
call l9x(s_e,XBx("FolderNurturingGrounds_StructEgg_Init: call FolderNurturingGrounds_StructEgg.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderNurturingGrounds_StructEgg.Event_BuffLose))",Jc,pI,function QRr))
endfunction
function QAr takes nothing returns boolean
local integer olx
call meo(gyv,XBx("NurturingGrounds_Init: call NurturingGrounds.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function NurturingGrounds.Event_SpellEffect))",ah,pI,function Qar))
set olx=(j6[(gyv)])
loop
set olx=olx-1
exitwhen(olx<1)
endloop
call QIr()
return true
endfunction
function QNr takes nothing returns boolean
call cmr(function QAr,"NurturingGrounds_Init")
return true
endfunction
function Qbr takes nothing returns boolean
set Sde[1]=275
set Sde[2]=275
set Sde[3]=275
set SDe[1]=600
set SDe[2]=725
set SDe[3]=850
set Sfe[1]=1
set Sfe[2]=1
set Sfe[3]=1
set SFe[1]=3
set SFe[2]=4
set SFe[3]=5
set Sge[1]=1.5
set Sge[2]=2
set Sge[3]=2.5
set SGe[1]=50
set SGe[2]=90
set SGe[3]=$8C
return true
endfunction
function QBr takes nothing returns boolean
call VRx(ea,(function Qbr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PandaPaw.page\\PandaPaw.struct\\Arrival\\Target\\obj_this_wc3obj.j"))
return true
endfunction
function Qcr takes nothing returns boolean
set She=Vnx(SHe)
return true
endfunction
function QCr takes nothing returns boolean
set Sje=szx("CLTS")
return true
endfunction
function Qdr takes nothing returns boolean
set SJe[1]=.5
set SJe[2]=.5
set SJe[3]=.5
return true
endfunction
function QDr takes nothing returns boolean
call VRx(ka,(function QCr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PandaPaw.page\\PandaPaw.struct\\Arrival\\obj_dummyUbersplat_wc3ubersplat.j"))
call VRx(ea,(function Qdr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PandaPaw.page\\PandaPaw.struct\\Arrival\\obj_this_wc3obj.j"))
return true
endfunction
function Qfr takes nothing returns boolean
set Ske=Vnx(SKe)
return true
endfunction
function QFr takes nothing returns boolean
set Sle=lQx(SLe+" (dummyBuff)")
set SU=lYx()
call l_x(SU,cRv,5)
call l0x(((Sle)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,cRv,$A)
call l0x(((Sle)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,cRv,$F)
call l0x(((Sle)),vc+(3),(SU))
return true
endfunction
function Qgr takes nothing returns boolean
set Sme[1]=5
set Sme[2]=$A
set Sme[3]=$F
return true
endfunction
function QGr takes nothing returns boolean
call VRx(Ma,(function QFr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PandaPaw.page\\PandaPaw.struct\\Leech\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function Qgr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PandaPaw.page\\PandaPaw.struct\\Leech\\obj_this_wc3obj.j"))
return true
endfunction
function Qhr takes nothing returns boolean
set SMe=Vnx(SLe)
return true
endfunction
function QHr takes nothing returns boolean
set Spe=lQx(SPe+" (dummyBuff)")
set SU=lYx()
call vOr(SU,DEv,true)
call vOr(SU,Dkv,true)
call l0x(((Spe)),vc+(1),(SU))
return true
endfunction
function Qjr takes nothing returns boolean
call LZx('APaP',false)
set G4v=Lzo('APaP')
set G6[(G4v)]=(c6)
set j6[(G4v)]=(3)
set sH[(G4v)]=("Panda Paw")
set Ih[(G4v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0269)))),(((Oj))))))
set x6v[(G4v)]=(2)
set xzv[(G4v)]=("attack")
call LZo((G4v),u6v+(1),((400)*1.))
call LZo((G4v),fH+(1),(($F)*1.))
call LZo((G4v),QH+(1),(('}')*1.))
call LZo((G4v),Lvv+(1),((800)*1.))
call LZo((G4v),u6v+(2),((400)*1.))
call LZo((G4v),fH+(2),(($E)*1.))
call LZo((G4v),QH+(2),(($96)*1.))
call LZo((G4v),Lvv+(2),((800)*1.))
call LZo((G4v),u6v+(3),((400)*1.))
call LZo((G4v),fH+(3),(($D)*1.))
call LZo((G4v),QH+(3),(($AF)*1.))
call LZo((G4v),Lvv+(3),((800)*1.))
set Mnv[(G4v)]=("ReplaceableTextures\\CommandButtons\\BTNBearForm.blp")
call ccr(G4v,'FPP0',3,'VPP0','LPPP','LRPP')
set Sqe[1]=500
set Sqe[2]=500
set Sqe[3]=500
set SQe[1]=650
set SQe[2]=650
set SQe[3]=650
return true
endfunction
function QJr takes nothing returns boolean
call VRx(Ma,(function QHr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PandaPaw.page\\PandaPaw.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function Qjr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PandaPaw.page\\PandaPaw.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Qkr takes nothing returns boolean
set Sse=Vnx(SPe)
return true
endfunction
function QKr takes integer oqx,real oSx returns nothing
call X4o(oqx,(Ilv[(oqx)])+oSx)
endfunction
function Qlr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local real Nkx=Swe[oqx]*1./ S3e*1./ S3e
local real N8x=SSe[oqx]
local integer CMx=oqx
local real p=Sue[oqx]*1./ S3e*1./ Nkx
local real dix=SZe[oqx]
local real dax=S_e[oqx]
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real Vlr=fwx(CMx)
local integer HOx=mcx(IGv[(uf[(CMx)])],wpo+S4e*(Cos(((((N8x)*1.))*1.))),wPo+S4e*(Sin(((((N8x)*1.))*1.))),Vlr,N8x)
local real Dho=-p+(SquareRoot(((p*p+2*ggx(dix-wpo,dax-wPo,XYx(dix,dax)-Vlr)*1./ Nkx)*1.)))
if(Dho>.3)then
call SetUnitAnimation(C[((CMx))],("attack"))
call QueueUnitAnimation(C[((CMx))],("stand"))
endif
call UnitAddAbility(zj[((HOx))],('aLoc'))
call fDo(HOx,S5e)
call Qwo((HOx),-((255.)*1.),-((255.)*1.),-((255.)*1.),-((255.)*1.),((S5e)*1.))
endfunction
function QLr takes integer oqx,real x,real y,real z returns nothing
call fTx(oqx,x)
call fux(oqx,y)
call fUx(oqx,x,y,z)
endfunction
function Qmr takes real oSx,real QMr,real Qpr returns real
local real QPr=jHx(oSx,Qpr)
local real Qqr=jHx(oSx,QMr)
if(Qqr+QPr-.01>bUx(Qpr-QMr))then
if(Qqr<QPr)then
return QMr
endif
return Qpr
endif
return oSx
endfunction
function QQr takes integer oqx returns integer
set tae[oqx]=true
set tne[oqx]=false
call rax(She)
return oqx
endfunction
function Qsr takes nothing returns integer
local integer oqx
if(txe==8190)then
call oYx("FolderPandaPaw_FolderArrival_StructTarget_Allocation_allocCustom","call DebugEx(FolderPandaPaw_FolderArrival_StructTarget.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",SHe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(toe[(w)]==w)then
set tre=tre+1
set oqx=tre
else
set oqx=toe[(w)]
set toe[(w)]=toe[toe[(w)]]
endif
set toe[oqx]=Z
set tie[oqx]=1
call QQr(oqx)
return oqx
endfunction
function QSr takes integer oqx,real N8x,integer rwx,integer Ixx,real dix,real dax returns nothing
local integer rkx=oqx
set N8x=Qmr((Atan2((((GetUnitY(C[((Ixx))]))-dax)*1.),(((GetUnitX(C[((Ixx))]))-dix)*1.))),N8x-tee,N8x+tee)
set oqx=Qsr()
set tVe[oqx]=SGe[rwx]+Sfe[rwx]*(VH[(S0e[rkx])])
set tEe[oqx]=rkx
set tXe[oqx]=tOe[rwx]*(Cos(((((N8x)*1.))*1.)))
set tRe[oqx]=tOe[rwx]*(Sin(((((N8x)*1.))*1.)))
set tIe[oqx]=tAe[rwx]
set tNe[oqx]=tbe[rwx]
if rtx(Ixx,tBe,oqx)then
call I7x(Ixx,tce)
endif
call rTx(Ixx,tCe+rkx,oqx)
endfunction
function Qtr takes integer oqx returns boolean
if((tde[((oqx))])>0)then
return false
endif
set tDe=tDe+1
set tfe[tDe]=oqx
set tde[oqx]=tDe+1
return(tDe==0)
endfunction
function QTr takes nothing returns nothing
local integer olx=tDe
loop
exitwhen(olx<0)
set tGe[olx]=tfe[olx]
set olx=olx-1
endloop
set the=tDe
endfunction
function Qur takes nothing returns integer
local integer o4x
if(the<0)then
return w
endif
set o4x=tGe[0]
set tGe[0]=tGe[the]
set the=the-1
return o4x
endfunction
function QUr takes integer oqx,integer CMx,integer Ixx returns nothing
local real cRx
local integer rwx
local real gwr
set oqx=oPx(Ixx,tCe+oqx)
set cRx=tIe[oqx]+tNe[oqx]
set tIe[oqx]=cRx
call B3o(Ixx,tXe[oqx])
call B4o(Ixx,tRe[oqx])
call B6o(Ixx,cRx)
if((cRx<.0)and(fwx(Ixx)<XYx((GetUnitX(C[((Ixx))])),(GetUnitY(C[((Ixx))])))+tHe))then
set rwx=Sye[tEe[oqx]]
call RUx((Abx((Ixx),(tje),(tJe),(Bi))))
call cKo(Ixx)
if I6x(Ixx,yd)then
set gwr=Sge[rwx]
else
set gwr=SFe[rwx]
endif
call NIx((((Ixx))),((Xsv)),(1),w,((((gwr)*1.))*1.))
call nJo((CMx),(Ixx),((tVe[oqx])*1.),(true),(true))
endif
endfunction
function Qwr takes nothing returns boolean
local integer rdx=(bv)
local integer rkx=(mj[(rdx)])
call QUr((rkx),Ste[rkx],(Vv[(rdx)]))
return true
endfunction
function QWr takes integer rkx returns nothing
call DDx(Sze[rkx],function Qwr,rkx)
endfunction
function Qyr takes nothing returns nothing
local integer oqx
local integer rkx
local integer CMx
local integer Q7o
local integer Ixx
call QTr()
loop
set oqx=Qur()
exitwhen(oqx==w)
set rkx=oqx
set CMx=Ste[rkx]
set Q7o=Sze[rkx]
call QWr(rkx)
endloop
endfunction
function QYr takes integer oqx returns nothing
set tae[oqx]=false
call rgx(She)
endfunction
function Qzr takes integer oqx returns nothing
if(tie[oqx]>0)then
return
endif
if(toe[oqx]!=Z)then
call oYx("FolderPandaPaw_FolderArrival_StructTarget_Allocation_deallocCustom_confirm","call DebugEx(FolderPandaPaw_FolderArrival_StructTarget.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",SHe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set toe[oqx]=toe[(w)]
set toe[(w)]=oqx
call QYr(oqx)
endfunction
function QZr takes integer oqx returns nothing
set tie[oqx]=tie[oqx]-1
call Qzr(oqx)
endfunction
function Q_r takes integer oqx,integer rkx,integer Ixx,integer Q7o returns nothing
call QZr((oqx))
if rrx(Ixx,tBe,oqx)then
call Rmx(Ixx,tce)
endif
call rix(Ixx,tCe+rkx)
call IEo(Q7o,Ixx)
endfunction
function Q0r takes integer oqx,integer Ixx,integer Q7o returns nothing
local integer rkx=oqx
set oqx=oPx(Ixx,tCe+rkx)
call Q_r(oqx,rkx,Ixx,Q7o)
endfunction
function Q1r takes integer oqx,integer Q7o returns nothing
local integer Ixx
loop
set Ixx=(Otx((Q7o),Rb))
exitwhen(Ixx==w)
call Q0r(oqx,Ixx,Q7o)
endloop
endfunction
function Q2r takes integer oqx returns boolean
if(((tde[((oqx))])>0)==false)then
return false
endif
set tde[tfe[tDe]]=tde[oqx]
set tfe[tde[oqx]-1]=tfe[tDe]
set tde[oqx]=0
set tDe=tDe-1
return(tDe==F)
endfunction
function Q3r takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local integer rkx=(oqx)
local integer Q7o=Sze[rkx]
local integer CQx=S0e[rkx]
call Q1r(oqx,Q7o)
call ijx(ibx)
call XYr(Q7o)
if Q2r(oqx)then
call ijx(tFe)
endif
call UPx(CQx)
endfunction
function Q4r takes integer oqx,real N8x,integer CMx,integer rwx,real dix,real dax,integer CQx returns nothing
local integer rkx=oqx
local integer Ixx
local integer Q7o
local integer ibx
call bnr(bIr(Sje,dix,dax,$FF,$FF,$FF,$7F,false,false),5.)
call mFo((mHo(((dix)*1.),((dax)*1.),(S7e),(ri))))
set dix=dix+S8e*(Cos(((((N8x)*1.))*1.)))
set dax=dax+S8e*(Sin(((((N8x)*1.))*1.)))
set gf=dix
set Gf=dax
set hf=N8x
set Hf=(ze[(CMx)])
call Nio(S9e,dix,dax,(Cpx((G4v),u6v+(rwx))),tve)
set Ixx=Nao(S9e)
set Q7o=Sze[rkx]
if(Ixx==w)then
call XYr(Q7o)
else
set ibx=inx()
set ge[(ibx)]=(oqx)
loop
call dpx(Q7o,Ixx)
call QSr(oqx,N8x,rwx,Ixx,dix,dax)
set Ixx=Nao(S9e)
exitwhen(Ixx==w)
endloop
if Qtr(oqx)then
call icx(tFe,tge,true,function Qyr)
endif
call icx(ibx,SJe[rwx],false,function Q3r)
endif
endfunction
function Q5r takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=oqx
local real oUx=Sue[oqx]+Swe[oqx]
local real dix=SZe[oqx]
local real dax=S_e[oqx]
local real Mpx=XYx(dix,dax)
local real x=(GetUnitX(C[((CMx))]))
local real y=(GetUnitY(C[((CMx))]))
local real z=fwx(CMx)
local real dX=dix-x
local real dY=dax-y
local real dZ=Mpx-z
local real Q6r=(Atan2(((dY)*1.),((dX)*1.)))
local real d=ggx(dX,dY,dZ)
local boolean kQr=(d<oUx+S6e)
local real Q7r
local real VLr
local integer CQx
if kQr then
set x=dix
set y=dax
set z=Mpx
else
set Q7r=(Atan2(((dZ)*1.),((jjx(dX,dY))*1.)))
set VLr=oUx*(Cos(((((Q7r)*1.))*1.)))
set x=x+VLr*(Cos(((((Q6r)*1.))*1.)))
set y=y+VLr*(Sin(((((Q6r)*1.))*1.)))
set z=z+oUx*(Sin(((((Q7r)*1.))*1.)))
call SetUnitFacing(C[((CMx))],((Q6r)*1.)*gy)
endif
call QLr(CMx,x,y,z)
if kQr then
set CQx=S0e[oqx]
call UNx(CQx)
call Ayx(CMx,Spe)
call Q4r(oqx,Q6r,CMx,Sye[oqx],dix,dax,CQx)
else
set SSe[oqx]=Q6r
set Sue[oqx]=oUx
endif
endfunction
function Q8r takes nothing returns boolean
local integer rdx=(bv)
local integer nqr=(mc[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer CQx=Cmx(Ixx,G4v)
local real dix=(UH[(nqr)])
local real dax=(wH[(nqr)])
local real N8x=UCx(Ixx,dix-(GetUnitX(C[((Ixx))])),dax-(GetUnitY(C[((Ixx))])))
local integer oqx=Ixx
local integer ibx=inx()
local integer sxo=inx()
local integer hbr=inx()
set SSe[oqx]=N8x
set Ste[oqx]=Ixx
set STe[oqx]=sxo
set Sue[oqx]=SUe[rwx]
set Swe[oqx]=SWe[rwx]
set Sye[oqx]=rwx
set SYe[oqx]=hbr
set Sze[oqx]=JIx("PandaPaw_Event_BuffGain: set this.targetGroup = UnitList.Create()")
set SZe[oqx]=dix
set S_e[oqx]=dax
set S0e[oqx]=CQx
set ge[(sxo)]=(oqx)
set ge[(hbr)]=(oqx)
call QKr(Ixx,S1e)
call icx(sxo,S2e,true,function Qlr)
call icx(hbr,S3e,true,function Q5r)
return true
endfunction
function Q9r takes integer oqx,real oSx returns nothing
call X4o(oqx,(Ilv[(oqx)])-oSx)
endfunction
function svr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer sxo=STe[oqx]
local integer hbr=SYe[oqx]
local integer CQx=S0e[oqx]
call ijx(sxo)
call ijx(hbr)
call Q9r(Ixx,S1e)
call dRx(CQx)
return true
endfunction
function ser takes nothing returns boolean
local integer rdx=(bv)
call Jtr((Vv[(rdx)]),Spe,(Mv[(rdx)]),rdx)
return true
endfunction
function sxr takes nothing returns boolean
local integer Ixx=jFx()
if(jHx((Atan2((((GetUnitY(C[((Ixx))]))-Gf)*1.),(((GetUnitX(C[((Ixx))]))-gf)*1.))),hf)>b6v)then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function sor takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer olx=CXx(Ixx,tBe)
local integer oqx
local integer rkx
loop
set oqx=COx(Ixx,tBe,olx)
set rkx=tEe[oqx]
call Q_r(oqx,rkx,Ixx,Sze[rkx])
set olx=olx-1
exitwhen(olx<q)
endloop
call GroupRemoveUnit(Kb[(S9e)],C[(Ixx)])
return true
endfunction
function srr takes nothing returns nothing
local integer olx
set tce=XBx("FolderPandaPaw_FolderArrival_StructTarget_Init: set FolderPandaPaw_FolderArrival_StructTarget.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderPandaPaw_FolderArrival_StructTarget.Event_Death)",VP,pI,function sor)
set olx=(j6[(G4v)])
loop
set tOe[olx]=SDe[olx]*1./ SJe[olx]*tge
set tbe[olx]=-8.*Sde[olx]*1./ SJe[olx]*1./ SJe[olx]*tge*tge
set tAe[olx]=-SJe[olx]*tbe[olx]*1./ 2*1./ tge
set olx=olx-1
exitwhen(olx<1)
endloop
endfunction
function sir takes nothing returns nothing
set S9e=O2x()
set tve=XLx(function sxr)
set tFe=inx()
call srr()
endfunction
function sar takes nothing returns boolean
local integer rdx=(bv)
call Q8o((Vv[(rdx)]),Sle,(Mv[(rdx)]))
return true
endfunction
function snr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),Sle)
return true
endfunction
function sVr takes nothing returns nothing
call meo(G4v,XBx("FolderPandaPaw_StructLeech_Init: call PandaPaw.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function FolderPandaPaw_StructLeech.Event_Learn))",Pv,pI,function sar))
call meo(G4v,XBx("FolderPandaPaw_StructLeech_Init: call PandaPaw.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderPandaPaw_StructLeech.Event_Learn))",pv,pI,function sar))
call meo(G4v,XBx("FolderPandaPaw_StructLeech_Init: call PandaPaw.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderPandaPaw_StructLeech.Event_Unlearn))",Av,pI,function snr))
endfunction
function sEr takes nothing returns boolean
local integer olx
call l9x(Spe,XBx("PandaPaw_Init: call PandaPaw.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function PandaPaw.Event_BuffGain))",Bd,pI,function Q8r))
call l9x(Spe,XBx("PandaPaw_Init: call PandaPaw.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function PandaPaw.Event_BuffLose))",Jc,pI,function svr))
call meo(G4v,XBx("PandaPaw_Init: call PandaPaw.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function PandaPaw.Event_SpellEffect))",ah,pI,function ser))
set olx=(j6[(G4v)])
loop
set SUe[olx]=SQe[olx]*S3e
set SWe[olx]=Sqe[olx]*S3e*S3e
set olx=olx-1
exitwhen(olx<1)
endloop
call sir()
call sVr()
return true
endfunction
function sXr takes nothing returns boolean
call FOr(function sEr,"PandaPaw_Init")
return true
endfunction
function sOr takes nothing returns boolean
set tke[1]=3
set tke[2]=3
set tke[3]=4
set tke[4]=4
set tke[5]=5
set tke[6]=5
set tKe[1]=20
set tKe[2]=30
set tKe[3]=40
set tKe[4]=50
set tKe[5]=60
set tKe[6]=70
set tle[1]=4
set tle[2]=4
set tle[3]=4
set tle[4]=4
set tle[5]=4
set tle[6]=4
return true
endfunction
function sRr takes nothing returns boolean
call VRx(ea,(function sOr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PurgingRain.page\\PurgingRain.struct\\Wave\\obj_this_wc3obj.j"))
return true
endfunction
function sIr takes nothing returns boolean
set tLe=Vnx(tme)
return true
endfunction
function sAr takes nothing returns boolean
call LZx('APRa',false)
set g2v=Lzo('APRa')
set G6[(g2v)]=(i6)
set j6[(g2v)]=(6)
set sH[(g2v)]=("Purging Rain")
set Ih[(g2v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0079)))),(((Oj))))))
set x6v[(g2v)]=(2)
set xzv[(g2v)]=("spell")
call LZo((g2v),u6v+(1),((300)*1.))
call LZo((g2v),BH+(1),((5)*1.))
call LZo((g2v),fH+(1),(($F)*1.))
call LZo((g2v),QH+(1),((80)*1.))
call LZo((g2v),Lvv+(1),((600)*1.))
call LZo((g2v),u6v+(2),((325)*1.))
call LZo((g2v),BH+(2),((5)*1.))
call LZo((g2v),fH+(2),(($F)*1.))
call LZo((g2v),QH+(2),(('d')*1.))
call LZo((g2v),Lvv+(2),((600)*1.))
call LZo((g2v),u6v+(3),((350)*1.))
call LZo((g2v),BH+(3),((5)*1.))
call LZo((g2v),fH+(3),(($F)*1.))
call LZo((g2v),QH+(3),(('x')*1.))
call LZo((g2v),Lvv+(3),((600)*1.))
call LZo((g2v),u6v+(4),((375)*1.))
call LZo((g2v),BH+(4),((5)*1.))
call LZo((g2v),fH+(4),(($F)*1.))
call LZo((g2v),QH+(4),(($8C)*1.))
call LZo((g2v),Lvv+(4),((600)*1.))
call LZo((g2v),u6v+(5),((400)*1.))
call LZo((g2v),BH+(5),((5)*1.))
call LZo((g2v),fH+(5),(($F)*1.))
call LZo((g2v),QH+(5),(($A0)*1.))
call LZo((g2v),Lvv+(5),((600)*1.))
call LZo((g2v),u6v+(6),((425)*1.))
call LZo((g2v),BH+(6),((5)*1.))
call LZo((g2v),fH+(6),(($F)*1.))
call LZo((g2v),QH+(6),(($B4)*1.))
call LZo((g2v),Lvv+(6),((600)*1.))
set Mnv[(g2v)]=("ReplaceableTextures\\CommandButtons\\BTNStarfall.blp")
call ccr(g2v,'FPR0',6,'VPR0','LPPR','LRPR')
return true
endfunction
function sNr takes nothing returns boolean
set l3e=lQx(tMe+" (dummyBuff)")
return true
endfunction
function sbr takes nothing returns boolean
call VRx(qa,(function sAr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PurgingRain.page\\PurgingRain.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function sNr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PurgingRain.page\\PurgingRain.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function sBr takes nothing returns boolean
set tpe=Vnx(tMe)
return true
endfunction
function scr takes integer oqx returns integer
set tye[oqx]=true
set tYe[oqx]=false
call rax(tLe)
return oqx
endfunction
function sCr takes nothing returns integer
local integer oqx
if(tue==8190)then
call oYx("FolderPurgingRain_StructWave_Allocation_allocCustom","call DebugEx(FolderPurgingRain_StructWave.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",tme+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(tUe[(w)]==w)then
set twe=twe+1
set oqx=twe
else
set oqx=tUe[(w)]
set tUe[(w)]=tUe[tUe[(w)]]
endif
set tUe[oqx]=Z
set tWe[oqx]=1
call scr(oqx)
return oqx
endfunction
function sdr takes integer oqx returns nothing
set tye[oqx]=false
call rgx(tLe)
endfunction
function sDr takes integer oqx returns nothing
if(tWe[oqx]>0)then
return
endif
if(tUe[oqx]!=Z)then
call oYx("FolderPurgingRain_StructWave_Allocation_deallocCustom_confirm","call DebugEx(FolderPurgingRain_StructWave.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",tme+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set tUe[oqx]=tUe[(w)]
set tUe[(w)]=oqx
call sdr(oqx)
endfunction
function sfr takes integer oqx returns nothing
set tWe[oqx]=tWe[oqx]-1
call sDr(oqx)
endfunction
function sFr takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local real O1o=tze[oqx]
local integer CMx=tZe[oqx]
local real NIo=t_e[oqx]
local real dix=t0e[oqx]
local real dax=t1e[oqx]
local integer CQx=Cmx(CMx,g2v)
local integer rwx=(XH[(CQx)])
local integer Ixx
call sfr((oqx))
call ijx(ibx)
call dRx(CQx)
set Hf=(ze[(CMx)])
call Nio(t4e,dix,dax,O1o,t5e)
loop
set Ixx=Nao(t4e)
exitwhen(Ixx==w)
call nar(rwx,Ixx,tle[rwx])
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
endloop
endfunction
function sgr takes integer CMx,integer rwx,real dix,real dax returns nothing
local real O1o=(Cpx((g2v),u6v+(rwx)))
local integer oqx=sCr()
local integer ibx=inx()
local integer olx
local real N8x
local real n_x
set tze[oqx]=O1o
set tZe[oqx]=CMx
set t_e[oqx]=tKe[rwx]
set t0e[oqx]=dix
set t1e[oqx]=dax
set ge[(ibx)]=(oqx)
set O1o=O1o*.75
set olx=tke[rwx]
loop
exitwhen(olx<1)
set N8x=(GetRandomReal(((.0)*1.),((df)*1.)))
set n_x=(GetRandomReal(((.0)*1.),((O1o)*1.)))
call mFo((mHo(((dix+n_x*(Cos(((((N8x)*1.))*1.))))*1.),((dax+n_x*(Sin(((((N8x)*1.))*1.))))*1.),(t2e),(ri))))
set olx=olx-1
endloop
call icx(ibx,t3e,false,function sFr)
endfunction
function sGr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
call sgr(Ixx,tse[oqx],tSe[oqx],tte[oqx])
endfunction
function shr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
call Ayx(Ixx,l3e)
endfunction
function sHr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer CQx=tPe
local integer Ixx=(aH[(CQx)])
local real dix=(wh[(CQx)])
local real dax=(Wh[(CQx)])
local integer oqx=Ixx
local integer ibx=inx()
local integer p0x=inx()
set tqe[oqx]=ibx
set tQe[oqx]=p0x
set tse[oqx]=rwx
set tSe[oqx]=dix
set tte[oqx]=dax
set ge[(ibx)]=(oqx)
set ge[(p0x)]=(oqx)
call icx(p0x,tTe,true,function sGr)
call icx(ibx,(Cpx((g2v),BH+(rwx))),false,function shr)
call sgr(Ixx,rwx,dix,dax)
return true
endfunction
function sjr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer ibx=tqe[oqx]
local integer p0x=tQe[oqx]
call ijx(ibx)
call ijx(p0x)
return true
endfunction
function sJr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
if(oPx((((CMx))),(yb+(c0e)))>0)then
return true
endif
call Ayx(CMx,l3e)
return true
endfunction
function skr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer CQx=(uH[(rdx)])
if(oPx((((CMx))),(yb+(c0e)))>0)then
call Ayx(CMx,cH)
endif
set tPe=CQx
call Q8o(CMx,l3e,rwx)
return true
endfunction
function sKr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function slr takes nothing returns nothing
set t4e=O2x()
set t5e=XLx(function sKr)
endfunction
function sLr takes nothing returns boolean
call l9x(l3e,XBx("PurgingRain_Init: call PurgingRain.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function PurgingRain.Event_BuffGain))",Bd,pI,function sHr))
call l9x(l3e,XBx("PurgingRain_Init: call PurgingRain.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function PurgingRain.Event_BuffLose))",Jc,pI,function sjr))
call meo(g2v,XBx("PurgingRain_Init: call PurgingRain.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function PurgingRain.Event_EndCast))",oev,pI,function sJr))
call meo(g2v,XBx("PurgingRain_Init: call PurgingRain.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function PurgingRain.Event_SpellEffect))",ah,pI,function skr))
call slr()
return true
endfunction
function smr takes nothing returns boolean
call FOr(function sLr,"PurgingRain_Init")
return true
endfunction
function sMr takes nothing returns boolean
set t6e=Vbx("ORBD")
return true
endfunction
function spr takes nothing returns boolean
call VRx(Ha,(function sMr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RazorBlade.page\\RazorBladeDrawBack.struct\\Blade\\obj_bolt_wc3bolt.j"))
return true
endfunction
function sPr takes nothing returns boolean
set t7e=Vnx(t8e)
return true
endfunction
function sqr takes nothing returns boolean
set t9e[1]=60
set t9e[2]=60
set t9e[3]=60
set t9e[4]=60
set t9e[5]=60
set t9e[6]=60
set Tve[1]=.15
set Tve[2]=.15
set Tve[3]=.15
set Tve[4]=.15
set Tve[5]=.15
set Tve[6]=.15
set Tee[1]=3
set Tee[2]=4
set Tee[3]=5
set Tee[4]=6
set Tee[5]=7
set Tee[6]=8
set Txe[1]=20
set Txe[2]=30
set Txe[3]=40
set Txe[4]=50
set Txe[5]=60
set Txe[6]=70
return true
endfunction
function sQr takes nothing returns boolean
call VRx(ea,(function sqr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RazorBlade.page\\RazorBladeDrawBack.struct\\obj_this_wc3obj.j"))
return true
endfunction
function ssr takes nothing returns boolean
set Toe=Vnx(Tre)
return true
endfunction
function sSr takes integer oqx,integer oQx returns integer
return(LoadInteger(o[((V[(E[((Tae[(oqx)]))])]))],((((Tne[((oqx))])))),(((oQx)))))
endfunction
function str takes nothing returns boolean
local integer rdx=(bv)
local integer sTr=(hz[(rdx)])
local integer sur=sSr(sTr,TVe)
call Kzx(sur)
return true
endfunction
function sUr takes nothing returns boolean
local integer Ixx=jFx()
if(I5x((OPe),Rb,(Ixx)))then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function swr takes nothing returns nothing
set Tie=XBx("FolderRazorBladeDrawBack_StructBlade_Init: set FolderRazorBladeDrawBack_StructBlade.CHECKPOINT_IMPACT_EVENT = Event.Create(MISSILE.Checkpoints.IMPACT_EVENT_TYPE, EventPriority.SPELLS, function FolderRazorBladeDrawBack_StructBlade.CheckpointImpact)",UY,pI,function str)
set TEe=O2x()
set TXe=XLx(function sUr)
set TOe=inx()
endfunction
function sWr takes nothing returns boolean
call swr()
return true
endfunction
function syr takes nothing returns boolean
call FOr(function sWr,"RazorBladeDrawBack_Init")
return true
endfunction
function sYr takes nothing returns boolean
set TRe=lQx(TIe+" (dummyBuff)")
set SU=lYx()
call l_x(SU,cBv,20)
call l0x(((TRe)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,cBv,20)
call l0x(((TRe)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,cBv,25)
call l0x(((TRe)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,cBv,25)
call l0x(((TRe)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,cBv,30)
call l0x(((TRe)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,cBv,35)
call l0x(((TRe)),vc+(6),(SU))
return true
endfunction
function szr takes nothing returns boolean
set TAe[1]=20
set TAe[2]=20
set TAe[3]=25
set TAe[4]=25
set TAe[5]=30
set TAe[6]=35
return true
endfunction
function sZr takes nothing returns boolean
call VRx(Ma,(function sYr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RazorBlade.page\\RazorBlade.struct\\Vamp\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function szr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RazorBlade.page\\RazorBlade.struct\\Vamp\\obj_this_wc3obj.j"))
return true
endfunction
function s_r takes nothing returns boolean
set TNe=Vnx(TIe)
return true
endfunction
function s0r takes nothing returns boolean
call LZx('ARaz',false)
set gmv=Lzo('ARaz')
set G6[(gmv)]=(i6)
set j6[(gmv)]=(6)
set sH[(gmv)]=("Razor Blade")
set Ih[(gmv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0089)))),(((Oj))))))
set x6v[(gmv)]=(2)
set xzv[(gmv)]=("spell")
call LZo((gmv),u6v+(1),((90)*1.))
call LZo((gmv),fH+(1),(($C)*1.))
call LZo((gmv),QH+(1),((70)*1.))
call LZo((gmv),Lvv+(1),((99999)*1.))
call LZo((gmv),u6v+(2),((90)*1.))
call LZo((gmv),fH+(2),(($C)*1.))
call LZo((gmv),QH+(2),((85)*1.))
call LZo((gmv),Lvv+(2),((99999)*1.))
call LZo((gmv),u6v+(3),((90)*1.))
call LZo((gmv),fH+(3),(($C)*1.))
call LZo((gmv),QH+(3),(('d')*1.))
call LZo((gmv),Lvv+(3),((99999)*1.))
call LZo((gmv),u6v+(4),((90)*1.))
call LZo((gmv),fH+(4),(($C)*1.))
call LZo((gmv),QH+(4),(('s')*1.))
call LZo((gmv),Lvv+(4),((99999)*1.))
call LZo((gmv),u6v+(5),((90)*1.))
call LZo((gmv),fH+(5),(($C)*1.))
call LZo((gmv),QH+(5),(($82)*1.))
call LZo((gmv),Lvv+(5),((99999)*1.))
call LZo((gmv),u6v+(6),((90)*1.))
call LZo((gmv),fH+(6),(($C)*1.))
call LZo((gmv),QH+(6),(($91)*1.))
call LZo((gmv),Lvv+(6),((99999)*1.))
set Mnv[(gmv)]=("ReplaceableTextures\\CommandButtons\\BTNWhirlwind.blp")
call ccr(gmv,'FRB0',6,'VRB0','LPRB','LRRB')
set Tbe[1]=750
set Tbe[2]=750
set Tbe[3]=750
set Tbe[4]=750
set Tbe[5]=750
set Tbe[6]=750
set TBe[1]=20
set TBe[2]=35
set TBe[3]=55
set TBe[4]=80
set TBe[5]='n'
set TBe[6]=$91
return true
endfunction
function s1r takes nothing returns boolean
set Tce=Vbx("ORaz")
return true
endfunction
function s2r takes nothing returns boolean
call VRx(qa,(function s0r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RazorBlade.page\\RazorBlade.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ha,(function s1r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RazorBlade.page\\RazorBlade.struct\\obj_bolt_wc3bolt.j"))
return true
endfunction
function s3r takes nothing returns boolean
set TCe=Vnx(Tde)
return true
endfunction
function s4r takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function s5r takes integer oqx returns integer
set THe[oqx]=true
set Tje[oqx]=false
call rax(TCe)
return oqx
endfunction
function s6r takes nothing returns integer
local integer oqx
if(TFe==8190)then
call oYx("RazorBlade_Allocation_allocCustom","call DebugEx(RazorBlade.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Tde+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Tge[(w)]==w)then
set TGe=TGe+1
set oqx=TGe
else
set oqx=Tge[(w)]
set Tge[(w)]=Tge[Tge[(w)]]
endif
set Tge[oqx]=Z
set The[oqx]=1
call s5r(oqx)
return oqx
endfunction
function s7r takes integer oqx returns nothing
set THe[oqx]=false
call rgx(TCe)
endfunction
function s8r takes integer oqx returns nothing
if(The[oqx]>0)then
return
endif
if(Tge[oqx]!=Z)then
call oYx("RazorBlade_Allocation_deallocCustom_confirm","call DebugEx(RazorBlade.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Tde+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set Tge[oqx]=Tge[(w)]
set Tge[(w)]=oqx
call s7r(oqx)
endfunction
function s9r takes integer oqx returns nothing
set The[oqx]=The[oqx]-1
call s8r(oqx)
endfunction
function Svr takes integer oqx returns integer
set Tte[oqx]=true
set TTe[oqx]=false
call rax(Toe)
return oqx
endfunction
function Ser takes nothing returns integer
local integer oqx
if(Tqe==8190)then
call oYx("RazorBladeDrawBack_Allocation_allocCustom","call DebugEx(RazorBladeDrawBack.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Tre+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(TQe[(w)]==w)then
set Tse=Tse+1
set oqx=Tse
else
set oqx=TQe[(w)]
set TQe[(w)]=TQe[TQe[(w)]]
endif
set TQe[oqx]=Z
set TSe[oqx]=1
call Svr(oqx)
return oqx
endfunction
function Sxr takes integer oqx returns integer
set T8e[oqx]=true
set T9e[oqx]=false
call rax(t7e)
return oqx
endfunction
function Sor takes nothing returns integer
local integer oqx
if(T4e==8190)then
call oYx("FolderRazorBladeDrawBack_StructBlade_Allocation_allocCustom","call DebugEx(FolderRazorBladeDrawBack_StructBlade.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",t8e+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(T5e[(w)]==w)then
set T6e=T6e+1
set oqx=T6e
else
set oqx=T5e[(w)]
set T5e[(w)]=T5e[T5e[(w)]]
endif
set T5e[oqx]=Z
set T7e[oqx]=1
call Sxr(oqx)
return oqx
endfunction
function Srr takes integer oqx returns boolean
if(((uae[((oqx))])>0)==false)then
return false
endif
set uae[une[uVe]]=uae[oqx]
set une[uae[oqx]-1]=une[uVe]
set uae[oqx]=0
set uVe=uVe-1
return(uVe==F)
endfunction
function Sir takes integer oqx returns nothing
set Tte[oqx]=false
call rgx(Toe)
endfunction
function Sar takes integer oqx returns nothing
if(TSe[oqx]>0)then
return
endif
if(TQe[oqx]!=Z)then
call oYx("RazorBladeDrawBack_Allocation_deallocCustom_confirm","call DebugEx(RazorBladeDrawBack.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Tre+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set TQe[oqx]=TQe[(w)]
set TQe[(w)]=oqx
call Sir(oqx)
endfunction
function Snr takes integer oqx returns nothing
set TSe[oqx]=TSe[oqx]-1
call Sar(oqx)
endfunction
function SVr takes integer oqx returns nothing
call ijx(Tye[oqx])
call Mdo(TZe[oqx])
call Snr((oqx))
endfunction
function SEr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer SXr=uve[oqx]
local integer hzr=uee[oqx]
local integer rkx=uoe[oqx]
if Srr(oqx)then
call iHx(TOe)
endif
call mZx(MFo,Tie)
call ijx(SXr)
call Kzx(hzr)
call Mdo(MFo)
if(T3e[rkx]==1)then
call SVr(rkx)
else
set T3e[rkx]=T3e[rkx]-1
endif
return true
endfunction
function SOr takes nothing returns nothing
local integer OHx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer MFo=(ge[(OHx)])
local integer oqx
local integer rkx
call ijx(OHx)
set oqx=(mWv[(MFo)])
set rkx=uoe[oqx]
call m1o(MFo,500.)
set mNv[(MFo)]=((Tue[rkx])*1.)
set mCv[(MFo)]=XHx((function SEr))
call m8o(MFo,850.)
call M3o((MFo),(Twe[rkx]),.0,.0,.0,(null))
endfunction
function SRr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer OHx=inx()
set ge[(OHx)]=(MFo)
call icx(OHx,NWr("delay",uie),false,function SOr)
return true
endfunction
function SIr takes integer oqx returns boolean
if((uae[((oqx))])>0)then
return false
endif
set uVe=uVe+1
set une[uVe]=oqx
set uae[oqx]=uVe+1
return(uVe==0)
endfunction
function SAr takes nothing returns nothing
local integer olx=uVe
loop
exitwhen(olx<0)
set uXe[olx]=une[olx]
set olx=olx-1
endloop
set uOe=uVe
endfunction
function SNr takes nothing returns integer
local integer o4x
if(uOe<0)then
return w
endif
set o4x=uXe[0]
set uXe[0]=uXe[uOe]
set uOe=uOe-1
return o4x
endfunction
function Sbr takes nothing returns nothing
local integer oqx
local real O1o
local integer CMx
local real NIo
local integer MFo
local integer Q7o
local integer Ixx
call SAr()
loop
set oqx=SNr()
exitwhen(oqx==w)
set O1o=Tue[uoe[oqx]]
set CMx=Twe[uoe[oqx]]
set NIo=TWe[uoe[oqx]]
set MFo=uxe[oqx]
set Q7o=ure[oqx]
set OPe=Q7o
set Hf=(ze[(CMx)])
call Vjr(TEe,(mFv[(MFo)]),(mgv[(MFo)]),(mGv[(MFo)]),O1o,TXe)
set Ixx=Nao(TEe)
if(Ixx!=w)then
loop
call RUx((Abx((Ixx),(uRe),(uIe),(Bi))))
call dpx(Q7o,Ixx)
call nJo((CMx),(Ixx),((NIo)*1.),(false),(true))
set Ixx=Nao(TEe)
exitwhen(Ixx==w)
endloop
endif
endloop
endfunction
function SBr takes integer oqx returns integer
set uce[oqx]=true
set uCe[oqx]=false
set Tae[((oqx))]=(Ve[(GetRandomInt((0),(Ee)))])
call rax(Wy)
return oqx
endfunction
function Scr takes nothing returns integer
local integer oqx
if(uAe==8190)then
call oYx("MissileCheckpoint_Allocation_allocCustom","call DebugEx(MissileCheckpoint.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",yy+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(uNe[(w)]==w)then
set ube=ube+1
set oqx=ube
else
set oqx=uNe[(w)]
set uNe[(w)]=uNe[uNe[(w)]]
endif
set uNe[oqx]=Z
set uBe[oqx]=1
call SBr(oqx)
return oqx
endfunction
function SCr takes integer oqx returns nothing
set Tne[(oqx)]=(uDe+oqx)
endfunction
function Sdr takes real x,real y,real z returns integer
local integer oqx=Scr()
call SCr(oqx)
set m5v[(oqx)]=((x)*1.)
set m6v[(oqx)]=((y)*1.)
set m7v[(oqx)]=((z)*1.)
return oqx
endfunction
function SDr takes integer oqx,integer MWo returns nothing
local integer rdx=rEx((YY[((oqx))]))
local integer olx
local integer rIx
local integer rlx
set WY[(rdx)]=(oqx)
set hz[(rdx)]=(MWo)
set olx=Xv
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=MXo((oqx),uY,rIx)
loop
exitwhen(rlx<q)
call rCx(MOo((oqx),uY,rIx,rlx),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function Sfr takes integer oqx,integer MWo returns boolean
local boolean o4x
if(oz[oqx]==w)then
set oz[oqx]=M0x()
call Mvx((oqx),wY)
endif
set o4x=sLo(oz[oqx],MWo)
call SDr(oqx,MWo)
return o4x
endfunction
function SFr takes integer oqx,real x,real y,real z returns integer
local integer o4x=Sdr(x,y,z)
call Sfr(oqx,o4x)
return o4x
endfunction
function Sgr takes integer oqx,integer oQx,integer oSx returns nothing
call SaveInteger(o[((V[(E[((Tae[(oqx)]))])]))],((((Tne[((oqx))])))),(((oQx))),(((oSx))))
endfunction
function SGr takes integer oqx returns integer
set Cu[oqx]=true
set uge[oqx]=false
call rax(mt)
return oqx
endfunction
function Shr takes nothing returns integer
local integer oqx
if(ufe==8190)then
call oYx("FolderLightning_StructFromSpotToDummyUnit_Allocation_allocCustom","call DebugEx(FolderLightning_StructFromSpotToDummyUnit.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Mt+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(cu[(w)]==w)then
set uFe=uFe+1
set oqx=uFe
else
set oqx=cu[(w)]
set cu[(w)]=cu[cu[(w)]]
endif
set cu[oqx]=Z
set Bu[oqx]=1
call SGr(oqx)
return oqx
endfunction
function SHr takes integer oqx returns boolean
set Gu=Gu+1
set gu[Gu]=oqx
set Fu[oqx]=Gu+1
return(Gu==0)
endfunction
function Sjr takes nothing returns nothing
local integer olx=Gu
local integer oqx
local integer Ixx
local real dix
local real dax
local real Mpx
loop
set oqx=gu[olx]
set Ixx=Hu[oqx]
if(Ixx==w)then
set dix=uJe[oqx]
set dax=uke[oqx]
set Mpx=uKe[oqx]
else
set dix=(oJ[(Ixx)])
set dax=(nJ[(Ixx)])
set Mpx=(Vu[(Ixx)])
endif
call cfo(ju[oqx],uGe[oqx],uhe[oqx],uHe[oqx],dix,dax,Mpx)
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function SJr takes integer oqx,real jlx,real jLx,real cho,integer Ixx returns nothing
local integer rkx=oqx
local real dix=(oJ[(Ixx)])
local real dax=(nJ[(Ixx)])
local real Mpx=(Vu[(Ixx)])
call cco(rkx)
set oqx=Shr()
set ju[oqx]=rkx
set uGe[oqx]=jlx
set uhe[oqx]=jLx
set uHe[oqx]=cho
set Hu[oqx]=Ixx
call cDo(rkx,bu,oqx)
call Kqx(rkx,Au)
if QPo(Ixx,Du,oqx)then
call Mxx(Ixx,fu)
endif
call cfo(rkx,jlx,jLx,cho,dix,dax,Mpx)
if SHr(oqx)then
call icx(hu,uje,true,function Sjr)
endif
endfunction
function Skr takes integer oqx returns integer
set mu[oqx]=true
set ume[oqx]=false
call rax(pt)
return oqx
endfunction
function SKr takes nothing returns integer
local integer oqx
if(ule==8190)then
call oYx("FolderLightning_StructFromSpotToSpot_Allocation_allocCustom","call DebugEx(FolderLightning_StructFromSpotToSpot.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Pt+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(Lu[(w)]==w)then
set uLe=uLe+1
set oqx=uLe
else
set oqx=Lu[(w)]
set Lu[(w)]=Lu[Lu[(w)]]
endif
set Lu[oqx]=Z
set lu[oqx]=1
call Skr(oqx)
return oqx
endfunction
function Slr takes integer oqx,real jlx,real jLx,real cho,real dix,real dax,real Mpx returns nothing
local integer rkx=oqx
call cco(rkx)
set oqx=SKr()
set uMe[oqx]=rkx
set upe[oqx]=jlx
set uPe[oqx]=jLx
set uqe[oqx]=cho
set uQe[oqx]=dix
set use[oqx]=dax
set uSe[oqx]=Mpx
call cDo(rkx,Ku,oqx)
call Kqx(rkx,Ju)
call cfo(rkx,jlx,jLx,cho,dix,dax,Mpx)
endfunction
function SLr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=Twe[uoe[oqx]]
local real x=(GetUnitX(C[((CMx))]))
local real y=(GetUnitY(C[((CMx))]))
local real z=fwx(CMx)
local integer Smr=SFr(uxe[oqx],x,y,z)
local integer SMr
local integer Spr=cBo(t6e)
call Sgr(Smr,TVe,Spr)
if(Smr==(zY[(oz[(uxe[oqx])])]))then
call SJr(Spr,x,y,z,(Xz[(uxe[oqx])]))
else
set SMr=(pHx(oz[(uxe[oqx])],(Smr)))
call Slr(Spr,x,y,z,(m5v[(SMr)]),(m6v[(SMr)]),(m7v[(SMr)]))
endif
call cGo(uee[oqx],x,y,z,CMx)
endfunction
function SPr takes integer oqx,real N8x,real Sqr returns nothing
local integer rkx=oqx
local real jlx=T0e[rkx]
local real jLx=T1e[rkx]
local real cho=T2e[rkx]
local integer SXr
local integer hzr
local integer MFo
set oqx=Sor()
set SXr=inx()
set hzr=cBo(t6e)
set MFo=Mvo()
set uve[oqx]=SXr
set uee[oqx]=hzr
set uxe[oqx]=MFo
set uoe[oqx]=rkx
set ure[oqx]=JIx("FolderRazorBladeDrawBack_StructBlade_StartBlade: set this.targetGroup = UnitList.Create()")
set ge[(SXr)]=(oqx)
call Mvx(MFo,Tie)
call m1o(MFo,NWr("acc",.0))
set mNv[(MFo)]=((.0)*1.)
set mCv[(MFo)]=XHx((function SRr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,NWr("speed",600.))
call Mto(MFo,jlx,jLx,cho)
call o6r(MFo,jlx+Sqr*(Cos(((((N8x)*1.))*1.))),jLx+Sqr*(Sin(((((N8x)*1.))*1.))),cho)
call Mro(MFo,'qRBD',1.)
call PNr(hzr,(Xz[(MFo)]),.0,Twe[rkx])
if SIr(oqx)then
call icx(TOe,uEe,true,function Sbr)
endif
call icx(SXr,NWr("smooth",.5),true,function SLr)
endfunction
function SQr takes integer oqx returns nothing
set TUe[oqx]=TUe[oqx]-1
if(TUe[oqx]==0)then
call iHx(Tye[oqx])
call KLx(Tze[oqx],$FF,$FF,$FF,0)
endif
call oqr((Xz[(TZe[oqx])]),T_e[oqx])
call SPr(oqx,df*1./ Tee[TYe[oqx]]*TUe[oqx],ute)
endfunction
function Ssr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
call SQr(oqx)
endfunction
function SSr takes integer Str,integer STr,integer CMx,integer rwx,real jlx,real jLx,real cho returns nothing
local integer oqx=Ser()
local integer p0x=inx()
set Tue[oqx]=t9e[rwx]
set TUe[oqx]=Tee[rwx]
set Twe[oqx]=CMx
set TWe[oqx]=Txe[rwx]
set Tye[oqx]=p0x
set TYe[oqx]=rwx
set Tze[oqx]=Str
set TZe[oqx]=STr
set T_e[oqx]=-(ly[((Xz[(STr)]))])*1./ Tee[rwx]
set T0e[oqx]=jlx
set T1e[oqx]=jLx
set T2e[oqx]=cho
set T3e[oqx]=Tee[rwx]
call icx(p0x,NWr("interval",Tve[rwx]),true,function Ssr)
call SQr(oqx)
endfunction
function Sur takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=TJe[oqx]
local integer rwx=TLe[oqx]
local integer Q6o=TPe[oqx]
local real x=(mFv[(MFo)])
local real y=(mgv[(MFo)])
local real z=(mGv[(MFo)])
call ijx(Q6o)
call s9r((oqx))
call SSr(Tle[oqx],MFo,CMx,rwx,x,y,z)
return true
endfunction
function SUr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=TJe[oqx]
local integer MFo=TKe[oqx]
local integer Q7o=Tme[oqx]
local real dix=TMe[oqx]
local real dax=Tpe[oqx]
local integer Ixx
local real NIo
set OPe=Q7o
set Hf=(ze[(CMx)])
call Vjr(TDe,(mFv[(MFo)]),(mgv[(MFo)]),(mGv[(MFo)]),(Cpx((gmv),u6v+(TLe[oqx]))),Tfe)
set Ixx=Nao(TDe)
if(Ixx!=w)then
set NIo=Tke[oqx]
loop
if not(I5x((Q7o),Rb,(Ixx)))then
call RUx((Abx((Ixx),(uue),(uUe),(Bi))))
call OSr(Ixx,650.,-200.,(Atan2(((dax-(GetUnitY(C[((Ixx))])))*1.),((dix-(GetUnitX(C[((Ixx))])))*1.))),1.)
call dpx(Q7o,Ixx)
call nJo((CMx),(Ixx),((NIo)*1.),(false),(true))
endif
set Ixx=Nao(TDe)
exitwhen(Ixx==w)
endloop
endif
endfunction
function Swr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real rmr=Tbe[rwx]
local real N8x=UCx(CMx,dix-wpo,dax-wPo)
local integer oqx
local integer hzr
local integer MFo
local integer Q6o
set dix=wpo+rmr*(Cos(((((N8x)*1.))*1.)))
set dax=wPo+rmr*(Sin(((((N8x)*1.))*1.)))
set oqx=s6r()
set hzr=w
set MFo=Mvo()
set Q6o=inx()
set TJe[oqx]=CMx
set Tke[oqx]=TBe[rwx]
set TKe[oqx]=MFo
set Tle[oqx]=hzr
set TLe[oqx]=rwx
set Tme[oqx]=JIx("RazorBlade_Event_SpellEffect: set this.targetGroup = UnitList.Create()")
set TMe[oqx]=dix
set Tpe[oqx]=dax
set TPe[oqx]=Q6o
set ge[(Q6o)]=(oqx)
call m1o(MFo,-400.)
set mNv[(MFo)]=(((Cpx((gmv),u6v+(rwx))))*1.)
set mCv[(MFo)]=XHx((function Sur))
set mWv[(MFo)]=(oqx)
call m8o(MFo,1100.)
call M9o(MFo,CMx)
call o6r(MFo,dix,dax,XYx(dix,dax)+60.)
call Mro(MFo,'qRaz',2.)
call icx(Q6o,uTe,true,function SUr)
return true
endfunction
function SWr takes nothing returns boolean
local integer rdx=(bv)
call Q8o((Vv[(rdx)]),TRe,(Mv[(rdx)]))
return true
endfunction
function Syr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),TRe)
return true
endfunction
function SYr takes nothing returns nothing
call meo(gmv,XBx("FolderRazorBlade_StructVamp_Init: call RazorBlade.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function FolderRazorBlade_StructVamp.Event_Learn))",Pv,pI,function SWr))
call meo(gmv,XBx("FolderRazorBlade_StructVamp_Init: call RazorBlade.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderRazorBlade_StructVamp.Event_Learn))",pv,pI,function SWr))
call meo(gmv,XBx("FolderRazorBlade_StructVamp_Init: call RazorBlade.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderRazorBlade_StructVamp.Event_Unlearn))",Av,pI,function Syr))
endfunction
function Szr takes nothing returns boolean
set TDe=O2x()
set Tfe=XLx(function s4r)
call meo(gmv,XBx("RazorBlade_Init: call RazorBlade.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RazorBlade.Event_SpellEffect))",ah,pI,function Swr))
call SYr()
return true
endfunction
function SZr takes nothing returns boolean
call FOr(function Szr,"RazorBlade_Init")
return true
endfunction
function S_r takes nothing returns boolean
set uwe=lQx(uWe+" (coldnessBuff)")
set qc[(uwe)]=(true)
return true
endfunction
function S0r takes nothing returns boolean
set uye[1]=2
set uye[2]=2.5
set uye[3]=3
set uYe[1]=4
set uYe[2]=5
set uYe[3]=6
return true
endfunction
function S1r takes nothing returns boolean
call VRx(Ma,(function S_r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RelentlessShiver.page\\RelentlessShiver.struct\\Buff\\obj_coldnessBuff_wc3buff.j"))
call VRx(ea,(function S0r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RelentlessShiver.page\\RelentlessShiver.struct\\Buff\\obj_this_wc3obj.j"))
return true
endfunction
function S2r takes nothing returns boolean
set uze=Vnx(uWe)
return true
endfunction
function S3r takes nothing returns boolean
set uZe[1]=$A
set uZe[2]=20
set uZe[3]=30
return true
endfunction
function S4r takes nothing returns boolean
call VRx(ea,(function S3r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RelentlessShiver.page\\RelentlessShiver.struct\\Missile\\obj_this_wc3obj.j"))
return true
endfunction
function S5r takes nothing returns boolean
set u_e=Vnx(u0e)
return true
endfunction
function S6r takes nothing returns boolean
call LZx('AReS',false)
set GCv=Lzo('AReS')
set G6[(GCv)]=(c6)
set j6[(GCv)]=(3)
set sH[(GCv)]=("Relentless Shiver")
set Ih[(GCv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00F9)))),(((Oj))))))
set x6v[(GCv)]=(0)
set xzv[(GCv)]=("spell")
call LZo((GCv),u6v+(1),((500)*1.))
call LZo((GCv),fH+(1),((80)*1.))
call LZo((GCv),QH+(1),(($A)*1.))
call LZo((GCv),Lvv+(1),((750)*1.))
call LZo((GCv),u6v+(2),((500)*1.))
call LZo((GCv),fH+(2),((80)*1.))
call LZo((GCv),QH+(2),(($A)*1.))
call LZo((GCv),Lvv+(2),((750)*1.))
call LZo((GCv),u6v+(3),((500)*1.))
call LZo((GCv),fH+(3),((80)*1.))
call LZo((GCv),QH+(3),(($A)*1.))
call LZo((GCv),Lvv+(3),((750)*1.))
set Mnv[(GCv)]=("ReplaceableTextures\\CommandButtons\\BTNAnimateDead.blp")
call ccr(GCv,'FRS0',3,'VRS0','LPRS','LRRS')
set u1e[1]=20
set u1e[2]=30
set u1e[3]=40
return true
endfunction
function S7r takes nothing returns boolean
call LZx('ARSR',false)
set u2e=Lzo('ARSR')
set G6[(u2e)]=(c6)
set j6[(u2e)]=(3)
set sH[(u2e)]=("Relentless Shiver (Revert)")
set Ih[(u2e)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00F9)))),(((Oj))))))
set x6v[(u2e)]=(0)
set xzv[(u2e)]=("spell")
call LZo((u2e),Lvv+(1),((750)*1.))
call LZo((u2e),Lvv+(2),((750)*1.))
call LZo((u2e),Lvv+(3),((750)*1.))
set Mnv[(u2e)]=("ReplaceableTextures\\CommandButtons\\BTNCorpseExplode.blp")
call ccr(u2e,'FRR0',3,'VRR0','LPRR','LRRR')
return true
endfunction
function S8r takes nothing returns boolean
set u3e=WTx('BReS',"Relentless Shiver",'bReS')
set avv[(u3e)]=(true)
set qc[(u3e)]=(true)
set aev[(u3e)]=("ReplaceableTextures\\CommandButtons\\BTNDoom.blp")
call lux(u3e,"RelentlessShiver_page\\RelentlessShiver_struct\\Aura.mdx","origin",ri)
set SU=lYx()
call l_x(SU,DJv,5)
call l_x(SU,nvv,.1)
call l0x(((u3e)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,DJv,5)
call l_x(SU,nvv,.2)
call l0x(((u3e)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,DJv,5)
call l_x(SU,nvv,.3)
call l0x(((u3e)),vc+(3),(SU))
return true
endfunction
function S9r takes nothing returns boolean
set u4e[1]=5
set u4e[2]=5
set u4e[3]=5
set u5e[1]=.1
set u5e[2]=.2
set u5e[3]=.3
return true
endfunction
function tvr takes nothing returns boolean
call VRx(qa,(function S6r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RelentlessShiver.page\\RelentlessShiver.struct\\obj_thisSpell_wc3spell.j"))
call VRx(qa,(function S7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RelentlessShiver.page\\RelentlessShiver.struct\\obj_revertSpell_wc3spell.j"))
call VRx(Ma,(function S8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RelentlessShiver.page\\RelentlessShiver.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function S9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RelentlessShiver.page\\RelentlessShiver.struct\\obj_this_wc3obj.j"))
return true
endfunction
function ter takes nothing returns boolean
set u6e=Vnx(u7e)
return true
endfunction
function txr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,yd)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function tor takes integer oqx returns integer
set UOe[oqx]=true
set URe[oqx]=false
call rax(u_e)
return oqx
endfunction
function trr takes nothing returns integer
local integer oqx
if(Une==8190)then
call oYx("FolderRelentlessShiver_StructMissile_Allocation_allocCustom","call DebugEx(FolderRelentlessShiver_StructMissile.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",u0e+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(UVe[(w)]==w)then
set UEe=UEe+1
set oqx=UEe
else
set oqx=UVe[(w)]
set UVe[(w)]=UVe[UVe[(w)]]
endif
set UVe[oqx]=Z
set UXe[oqx]=1
call tor(oqx)
return oqx
endfunction
function tir takes integer oqx returns nothing
set UOe[oqx]=false
call rgx(u_e)
endfunction
function tar takes integer oqx returns nothing
if(UXe[oqx]>0)then
return
endif
if(UVe[oqx]!=Z)then
call oYx("FolderRelentlessShiver_StructMissile_Allocation_deallocCustom_confirm","call DebugEx(FolderRelentlessShiver_StructMissile.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",u0e+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set UVe[oqx]=UVe[(w)]
set UVe[(w)]=oqx
call tir(oqx)
endfunction
function tnr takes integer oqx returns nothing
set UXe[oqx]=UXe[oqx]-1
call tar(oqx)
endfunction
function tVr takes integer CMx,integer rwx,integer Ixx returns nothing
local real ilx
if I6x(Ixx,yd)then
set ilx=uye[rwx]
else
set ilx=uYe[rwx]
endif
call NIx((Ixx),(uwe),(rwx),w,((ilx)*1.))
endfunction
function tEr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=UIe[oqx]
local integer rwx=UAe[oqx]
call tnr((oqx))
call Mdo(MFo)
call tVr(CMx,rwx,Ixx)
call nJo((CMx),(Ixx),((uZe[rwx])*1.),(true),(false))
return true
endfunction
function tXr takes integer CMx,integer rwx,integer Ixx returns nothing
local integer oqx=trr()
local integer MFo=Mvo()
set UIe[oqx]=CMx
set UAe[oqx]=rwx
set mAv[((MFo))]=((b6v*((.06)*1.))*1.)
set mNv[(MFo)]=((8.)*1.)
call Mro(MFo,'qReS',.75)
set mCv[(MFo)]=XHx((function tEr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,500.)
call M9o(MFo,CMx)
call M3o((MFo),(Ixx),.0,.0,.0,(function M5o))
endfunction
function tOr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=oqx
local real O1o=Uve[oqx]
local integer rwx=Uxe[oqx]
local real tRr=Uoe[oqx]
local integer Ixx
call Ybo(CMx,tRr)
if((LF[(CMx)])<Uae)then
call Ayx(CMx,u3e)
endif
set Hf=(ze[(CMx)])
call Nio(u8e,(GetUnitX(C[((CMx))])),(GetUnitY(C[((CMx))])),O1o,u9e)
set Ixx=Nao(u8e)
if(Ixx!=w)then
loop
call tXr(CMx,rwx,Ixx)
set Ixx=Nao(u8e)
exitwhen(Ixx==w)
endloop
endif
endfunction
function tIr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer oqx=CMx
local integer p0x=inx()
set Uve[oqx]=(Cpx((GCv),u6v+(rwx)))
set Uee[oqx]=p0x
set Uxe[oqx]=rwx
set Uoe[oqx]=Ure[rwx]
set ge[(p0x)]=(oqx)
call icx(p0x,Uie,true,function tOr)
call LOr((G6[(GCv)]),u2e,CMx)
return true
endfunction
function tAr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer oqx=CMx
local integer p0x=Uee[oqx]
call ijx(p0x)
call LOr((G6[(u2e)]),GCv,CMx)
return true
endfunction
function tNr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),u3e)
return true
endfunction
function tbr takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(u3e),((Mv[(rdx)])),w)
return true
endfunction
function tBr takes nothing returns nothing
endfunction
function tcr takes nothing returns boolean
local integer olx
set u8e=O2x()
set u9e=XLx(function txr)
call l9x(u3e,XBx("RelentlessShiver_Init: call RelentlessShiver.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RelentlessShiver.Event_BuffGain))",Bd,pI,function tIr))
call l9x(u3e,XBx("RelentlessShiver_Init: call RelentlessShiver.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RelentlessShiver.Event_BuffLose))",Jc,pI,function tAr))
call meo(u2e,XBx("RelentlessShiver_Init: call RelentlessShiver.REVERT_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RelentlessShiver.Event_RevertSpellEffect))",ah,pI,function tNr))
call meo(GCv,XBx("RelentlessShiver_Init: call RelentlessShiver.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RelentlessShiver.Event_SpellEffect))",ah,pI,function tbr))
set olx=(j6[(GCv)])
loop
exitwhen(olx<1)
set Ure[olx]=u1e[olx]*Uie
set olx=olx-1
endloop
call W_x(nxv,uwe)
call tBr()
return true
endfunction
function tCr takes nothing returns boolean
call FOr(function tcr,"RelentlessShiver_Init")
return true
endfunction
function tdr takes nothing returns boolean
set UNe=lQx(Ube+" (dummyBuff)")
return true
endfunction
function tDr takes nothing returns boolean
call VRx(Ma,(function tdr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RigorMortis.page\\RigorMortis.struct\\AfterBuff\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function tfr takes nothing returns boolean
set UBe=Vnx(Ube)
return true
endfunction
function tFr takes nothing returns boolean
call LZx('ARig',false)
set Grv=Lzo('ARig')
set G6[(Grv)]=(c6)
set j6[(Grv)]=(3)
set sH[(Grv)]=("Rigor Mortis")
set Ih[(Grv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00C0)))),(((Oj))))))
set x6v[(Grv)]=(0)
set xzv[(Grv)]=("spell")
call LZo((Grv),fH+(1),(($B4)*1.))
call LZo((Grv),QH+(1),(('d')*1.))
call LZo((Grv),Lvv+(1),((750)*1.))
call LZo((Grv),fH+(2),(($A0)*1.))
call LZo((Grv),QH+(2),(($96)*1.))
call LZo((Grv),Lvv+(2),((750)*1.))
call LZo((Grv),fH+(3),(($8C)*1.))
call LZo((Grv),QH+(3),(($C8)*1.))
call LZo((Grv),Lvv+(3),((750)*1.))
set Mnv[(Grv)]=("ReplaceableTextures\\CommandButtons\\BTNStatUp.blp")
call ccr(Grv,'FRe0',3,'VRe0','LPRe','LRRe')
set Uce[1]=.3
set Uce[2]=.5
set Uce[3]=.7
set UCe[1]=.3
set UCe[2]=.5
set UCe[3]=.7
return true
endfunction
function tgr takes nothing returns boolean
call VRx(qa,(function tFr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RigorMortis.page\\RigorMortis.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function tGr takes nothing returns boolean
set Ude=Vnx(UDe)
return true
endfunction
function thr takes integer oqx,integer ibx,integer Ixx returns nothing
local integer akr=UFe[oqx]
call iHx(ibx)
call mFo(akr)
call Rmx(Ixx,Ufe)
endfunction
function tHr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call thr(oqx,Uge[oqx],Ixx)
return true
endfunction
function tjr takes integer oqx,integer rJx returns nothing
endfunction
function tJr takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local integer rwx=Uhe[oqx]
local integer Ixx=oqx
local real tkr=Uje[oqx]
local real Pdr=UJe[oqx]
local real dix=Uke[oqx]
local real dax=UKe[oqx]
call thr(oqx,ibx,Ixx)
call RUx((Abx((Ixx),(ULe),(Ume),(ri))))
call qLo(Ixx,dix,UKe[oqx])
call cFx(Ixx,tkr)
call BOx(Ixx,Pdr)
call Emo(Ixx,(ze[(Ixx)]),true)
call NIx(((Ixx)),(UNe),((rwx)),w,((UMe)*1.))
endfunction
function tKr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real dix=(GetUnitX(C[((CMx))]))
local real dax=(GetUnitY(C[((CMx))]))
local integer oqx
local integer ibx
call mFo((mHo(((dix)*1.),((dax)*1.),(UGe),(Bi))))
set oqx=CMx
set ibx=inx()
set Uge[oqx]=ibx
set Uhe[oqx]=rwx
set UFe[oqx]=(mHo(((dix)*1.),((dax)*1.),(UHe),(ri)))
set Uje[oqx]=(rG[(CMx)])+(iG[(CMx)])*UCe[rwx]
set UJe[oqx]=(LF[(CMx)])+(mF[(CMx)])*Uce[rwx]-(Cpx((Grv),QH+(rwx)))
set Uke[oqx]=dix
set UKe[oqx]=dax
call I7x(CMx,Ufe)
set ge[(ibx)]=(oqx)
call tjr(CMx,Grv)
set Nnv[(CMx)]=(true)
call icx(ibx,Ule,false,function tJr)
call Cex((CMx),w)
return true
endfunction
function tlr takes nothing returns nothing
call W_x(nTv,UNe)
call W_x(nMv,UNe)
call W_x(XVv,UNe)
endfunction
function tLr takes nothing returns boolean
set Ufe=XBx("RigorMortis_Init: set RigorMortis.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RigorMortis.Event_Revive)",XP,pI,function tHr)
call meo(Grv,XBx("RigorMortis_Init: call RigorMortis.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RigorMortis.Event_SpellEffect))",ah,pI,function tKr))
call tlr()
return true
endfunction
function tmr takes nothing returns boolean
call FOr(function tLr,"RigorMortis_Init")
return true
endfunction
function tMr takes nothing returns boolean
return true
endfunction
function tpr takes nothing returns boolean
set Upe=Vnx(UPe)
return true
endfunction
function tPr takes nothing returns boolean
call LZx('ASaB',false)
set G3v=Lzo('ASaB')
set G6[(G3v)]=(N6)
set j6[(G3v)]=(6)
set sH[(G3v)]=("Sake Bomb")
set Ih[(G3v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0080)))),(((Oj))))))
set x6v[(G3v)]=(2)
set xzv[(G3v)]=("spell")
call LZo((G3v),u6v+(1),(($C8)*1.))
call LZo((G3v),fH+(1),((4)*1.))
call LZo((G3v),QH+(1),((35)*1.))
call LZo((G3v),Lvv+(1),((700)*1.))
call LZo((G3v),u6v+(2),(($E1)*1.))
call LZo((G3v),fH+(2),((4)*1.))
call LZo((G3v),QH+(2),((40)*1.))
call LZo((G3v),Lvv+(2),((700)*1.))
call LZo((G3v),u6v+(3),(($FA)*1.))
call LZo((G3v),fH+(3),((4)*1.))
call LZo((G3v),QH+(3),((50)*1.))
call LZo((G3v),Lvv+(3),((700)*1.))
call LZo((G3v),u6v+(4),((275)*1.))
call LZo((G3v),fH+(4),((4)*1.))
call LZo((G3v),QH+(4),((65)*1.))
call LZo((G3v),Lvv+(4),((700)*1.))
call LZo((G3v),u6v+(5),((300)*1.))
call LZo((G3v),fH+(5),((4)*1.))
call LZo((G3v),QH+(5),((85)*1.))
call LZo((G3v),Lvv+(5),((700)*1.))
call LZo((G3v),u6v+(6),((325)*1.))
call LZo((G3v),fH+(6),((4)*1.))
call LZo((G3v),QH+(6),((95)*1.))
call LZo((G3v),Lvv+(6),((700)*1.))
set Mnv[(G3v)]=("ReplaceableTextures\\CommandButtons\\BTNDrum.blp")
call ccr(G3v,'FSB0',6,'VSB0','LPSB','LRSB')
set Uqe[1]=7.5
set Uqe[2]=8
set Uqe[3]=8.5
set Uqe[4]=9
set Uqe[5]=9.5
set Uqe[6]=$A
set UQe[1]=.03
set UQe[2]=.03
set UQe[3]=.04
set UQe[4]=.04
set UQe[5]=.05
set UQe[6]=.05
set Use[1]=25
set Use[2]=45
set Use[3]=65
set Use[4]=85
set Use[5]='i'
set Use[6]='}'
return true
endfunction
function tqr takes nothing returns boolean
set USe=WTx('BSBP',"Poisoned",'bSBP')
set qc[(USe)]=(true)
set qU[(USe)]=(true)
set aev[(USe)]=("ReplaceableTextures\\CommandButtons\\BTNDrum.blp")
return true
endfunction
function tQr takes nothing returns boolean
call VRx(qa,(function tPr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SakeBomb.page\\SakeBomb.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function tqr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SakeBomb.page\\SakeBomb.struct\\obj_poisonBuff_wc3buff.j"))
return true
endfunction
function tsr takes nothing returns boolean
set Ute=Vnx(UTe)
return true
endfunction
function tSr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function ttr takes integer oqx returns integer
set Uze[oqx]=true
set UZe[oqx]=false
call rax(Upe)
return oqx
endfunction
function tTr takes nothing returns integer
local integer oqx
if(Uwe==8190)then
call oYx("FolderSakeBomb_StructMissile_Allocation_allocCustom","call DebugEx(FolderSakeBomb_StructMissile.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",UPe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(UWe[(w)]==w)then
set Uye=Uye+1
set oqx=Uye
else
set oqx=UWe[(w)]
set UWe[(w)]=UWe[UWe[(w)]]
endif
set UWe[oqx]=Z
set UYe[oqx]=1
call ttr(oqx)
return oqx
endfunction
function tur takes integer oqx returns nothing
set Uze[oqx]=false
call rgx(Upe)
endfunction
function tUr takes integer oqx returns nothing
if(UYe[oqx]>0)then
return
endif
if(UWe[oqx]!=Z)then
call oYx("FolderSakeBomb_StructMissile_Allocation_deallocCustom_confirm","call DebugEx(FolderSakeBomb_StructMissile.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",UPe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set UWe[oqx]=UWe[(w)]
set UWe[(w)]=oqx
call tur(oqx)
endfunction
function twr takes integer oqx returns nothing
set UYe[oqx]=UYe[oqx]-1
call tUr(oqx)
endfunction
function tWr takes integer oqx returns integer
set U8e[oqx]=true
set U9e[oqx]=false
call rax(Ute)
return oqx
endfunction
function tyr takes nothing returns integer
local integer oqx
if(U4e==8190)then
call oYx("SakeBomb_Allocation_allocCustom","call DebugEx(SakeBomb.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",UTe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(U5e[(w)]==w)then
set U6e=U6e+1
set oqx=U6e
else
set oqx=U5e[(w)]
set U5e[(w)]=U5e[U5e[(w)]]
endif
set U5e[oqx]=Z
set U7e[oqx]=1
call tWr(oqx)
return oqx
endfunction
function tYr takes integer oqx returns nothing
set U8e[oqx]=false
call rgx(Ute)
endfunction
function tzr takes integer oqx returns nothing
if(U7e[oqx]>0)then
return
endif
if(U5e[oqx]!=Z)then
call oYx("SakeBomb_Allocation_deallocCustom_confirm","call DebugEx(SakeBomb.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",UTe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set U5e[oqx]=U5e[(w)]
set U5e[(w)]=oqx
call tYr(oqx)
endfunction
function tZr takes integer oqx returns nothing
set U7e[oqx]=U7e[oqx]-1
call tzr(oqx)
endfunction
function t_r takes nothing returns nothing
local integer p0x=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(p0x)])
local integer zgo=wie[oqx]-1
local integer t0r
local real O1o
local integer CMx
local real NIo
local integer HOx
local real hvr
local integer CQx
local real x
local real y
local integer rwx
local integer Ixx
local real d
local real dJr
if(zgo==0)then
set t0r=wve[oqx]
set O1o=wee[oqx]
set CMx=wxe[oqx]
set NIo=woe[oqx]
set HOx=wre[oqx]
set hvr=wne[oqx]
set CQx=wOe[oqx]
set x=wVe[oqx]
set y=wEe[oqx]
set rwx=(XH[(CQx)])
call tZr((oqx))
call MCx(t0r)
call Mfx(HOx)
call ijx(p0x)
call dRx(CQx)
call mFo((mHo(((x)*1.),((y)*1.),(wRe),(Bi))))
set Hf=(ze[(CMx)])
call Nio(Uue,x,y,O1o,UUe)
set Ixx=Nao(Uue)
if(Ixx!=w)then
loop
set d=jjx((GetUnitX(C[((Ixx))]))-x,(GetUnitY(C[((Ixx))]))-y)
set dJr=dBr(.0,wIe,O1o,wAe,d)
call YBo(CMx,Ixx,(mF[(Ixx)])*UQe[rwx])
call nJo((CMx),(Ixx),((dJr*NIo*(1.+RJo((XBv[(Ixx)]))*wNe))*1.),(true),(true))
call NIx((Ixx),(USe),(rwx),w,((hvr)*1.))
set Ixx=Nao(Uue)
exitwhen(Ixx==w)
endloop
endif
else
set wie[oqx]=zgo
call cNx(iqx((I2S((zgo))),iwx(1.-zgo*.05,.25,.0,.0)),.034-zgo*.003,wVe[oqx],wEe[oqx],wXe[oqx]+60.,(0))
endif
endfunction
function t1r takes integer CMx,integer rwx,real dix,real dax,integer CQx returns nothing
local real O1o=(Cpx((G3v),u6v+(rwx)))
local real hvr=Uqe[rwx]
local real Mpx=XYx(dix,dax)
local integer oqx=tyr()
local integer t0r=mcx('qSBA',dix,dax,Mpx,Kf)
local integer HOx=mcx('qSaB',dix,dax,Mpx,Kf)
local integer p0x=inx()
local integer Ixx
set wve[oqx]=t0r
set wee[oqx]=O1o
set wxe[oqx]=CMx
set woe[oqx]=Use[rwx]
set wre[oqx]=HOx
set wie[oqx]=(R2I(((wae)*1.)))
set wne[oqx]=hvr
set wVe[oqx]=dix
set wEe[oqx]=dax
set wXe[oqx]=Mpx
set wOe[oqx]=CQx
set ge[(p0x)]=(oqx)
call k2o(t0r,O1o*1./(256.*1./ 5))
call mBx(t0r,$FF,$FF,$FF,$7F)
call icx(p0x,1.,true,function t_r)
set Hf=(ze[(CMx)])
call Nio(Uue,dix,dax,O1o,UUe)
set Ixx=Nao(Uue)
if(Ixx!=w)then
loop
call RUx((Abx((Ixx),(wbe),(wBe),(Bi))))
call NIx((Ixx),(USe),(rwx),w,((hvr)*1.))
set Ixx=Nao(Uue)
exitwhen(Ixx==w)
endloop
endif
endfunction
function t2r takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=U_e[oqx]
local integer rwx=U0e[oqx]
local real dix=U1e[oqx]
local real dax=U2e[oqx]
local integer CQx=U3e[oqx]
call twr((oqx))
call Mdo(MFo)
call t1r(CMx,rwx,dix,dax,CQx)
return true
endfunction
function t3r takes integer CMx,integer rwx,real dix,real dax,integer CQx returns nothing
local integer oqx=tTr()
local integer MFo=Mvo()
set U_e[oqx]=CMx
set U0e[oqx]=rwx
set U1e[oqx]=dix
set U2e[oqx]=dax
set U3e[oqx]=CQx
set mAv[((MFo))]=((b6v*((.5)*1.))*1.)
set mNv[(MFo)]=((32.)*1.)
call Mro(MFo,'qSBM',1.)
set mCv[(MFo)]=XHx((function t2r))
set mWv[(MFo)]=(oqx)
call m8o(MFo,700.)
call M9o(MFo,CMx)
call o6r(MFo,dix,dax,XYx(dix,dax))
endfunction
function t4r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
call t3r(CMx,(Mv[(rdx)]),(UH[(rdx)]),(wH[(rdx)]),Cmx(CMx,G3v))
return true
endfunction
function t5r takes nothing returns boolean
set Uue=O2x()
set UUe=XLx(function tSr)
call meo(G3v,XBx("SakeBomb_Init: call SakeBomb.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SakeBomb.Event_SpellEffect))",ah,pI,function t4r))
call W_x(XNv,USe)
return true
endfunction
function t6r takes nothing returns boolean
call FOr(function t5r,"SakeBomb_Init")
return true
endfunction
function t7r takes nothing returns boolean
call LZx('ASaE',false)
set Gdv=Lzo('ASaE')
set G6[(Gdv)]=(C6)
set j6[(Gdv)]=(3)
set sH[(Gdv)]=("Sanguine Eyes")
set Ih[(Gdv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0215)))),(((Oj))))))
set x6v[(Gdv)]=(4)
set xzv[(Gdv)]=("spell")
call LZo((Gdv),fH+(1),(($96)*1.))
call LZo((Gdv),QH+(1),(($8C)*1.))
call LZo((Gdv),Lvv+(1),(($7D0)*1.))
call LZo((Gdv),fH+(2),(($96)*1.))
call LZo((Gdv),QH+(2),(($AA)*1.))
call LZo((Gdv),Lvv+(2),(($7D0)*1.))
call LZo((Gdv),fH+(3),(($96)*1.))
call LZo((Gdv),QH+(3),(($C8)*1.))
call LZo((Gdv),Lvv+(3),(($7D0)*1.))
set Mnv[(Gdv)]=("ReplaceableTextures\\CommandButtons\\BTNOrbofSlowness.blp")
call ccr(Gdv,'FSE0',3,'VSE0','LPSE','LRSE')
set wce[1]=.3
set wce[2]=.5
set wce[3]=.7
set wCe[1]=20
set wCe[2]=20
set wCe[3]=20
return true
endfunction
function t8r takes nothing returns boolean
set wde=WTx('BSaE',"Sanguine Eyes",'bSaE')
set avv[(wde)]=(true)
set qU[(wde)]=(true)
set aev[(wde)]=("ReplaceableTextures\\CommandButtons\\BTNOrbofSlowness.blp")
call lux(wde,"Abilities\\Spells\\Other\\Doom\\DoomTarget.mdl","origin",ri)
return true
endfunction
function t9r takes nothing returns boolean
call VRx(qa,(function t7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SanguineEyes.page\\SanguineEyes.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function t8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SanguineEyes.page\\SanguineEyes.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function Tvr takes nothing returns boolean
set wDe=Vnx(wfe)
return true
endfunction
function Ter takes nothing returns boolean
local integer rdx=(bv)
local real NIo=(Eyv[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call moo(wge[oqx],wge[oqx],NIo*wGe[oqx])
return true
endfunction
function Txr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(mc[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
set wge[oqx]=CMx
set wGe[oqx]=wce[rwx]
call I7x(Ixx,wFe)
return true
endfunction
function Tor takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call Rmx(Ixx,wFe)
call Dnx((wge[oqx]),(Gdv))
return true
endfunction
function Trr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
call NIx(Ixx,wde,rwx,CMx,wCe[rwx])
return true
endfunction
function Tir takes nothing returns boolean
set wFe=XBx("SanguineEyes_Init: set SanguineEyes.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.SPELLS, function SanguineEyes.Event_Damage)",Ezv,pI,function Ter)
call l9x(wde,XBx("SanguineEyes_Init: call SanguineEyes.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SanguineEyes.Event_BuffGain))",Bd,pI,function Txr))
call l9x(wde,XBx("SanguineEyes_Init: call SanguineEyes.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SanguineEyes.Event_BuffLose))",Jc,pI,function Tor))
call meo(Gdv,XBx("SanguineEyes_Init: call SanguineEyes.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SanguineEyes.Event_SpellEffect))",ah,pI,function Trr))
call W_x(Elv,wde)
call W_x(r9v,wde)
call W_x(x_v,wde)
return true
endfunction
function Tar takes nothing returns boolean
call FOr(function Tir,"SanguineEyes_Init")
return true
endfunction
function Tnr takes nothing returns boolean
set whe=WTx('BBub',"Protected by a bubble",'bBub')
set avv[(whe)]=(true)
set qc[(whe)]=(true)
set aev[(whe)]=("ReplaceableTextures\\CommandButtons\\BTNBigBadVoodooSpell.blp")
call lux(whe,"Abilities\\Spells\\Orc\\Voodoo\\VoodooAuraTarget.mdl","overhead",ri)
set SU=lYx()
call vOr(SU,DEv,true)
call l0x(((whe)),vc+(1),(SU))
set SU=lYx()
call vOr(SU,DEv,true)
call l0x(((whe)),vc+(2),(SU))
set SU=lYx()
call vOr(SU,DEv,true)
call l0x(((whe)),vc+(3),(SU))
return true
endfunction
function TVr takes nothing returns boolean
call VRx(Ma,(function Tnr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ShamanicBubble.page\\ShamanicBubble.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function TEr takes nothing returns boolean
set wHe=Vnx(wje)
return true
endfunction
function TXr takes nothing returns boolean
set wJe=lQx(wke+" (dummyBuff)")
set qc[(wJe)]=(true)
call lux(wJe,"Abilities\\Spells\\Human\\Polymorph\\PolyMorphTarget.mdl","origin",ri)
return true
endfunction
function TOr takes nothing returns boolean
call VRx(Ma,(function TXr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ShamanicBubble.page\\ShamanicBubble.struct\\Transition\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function TRr takes nothing returns boolean
set wKe=Vnx(wke)
return true
endfunction
function TIr takes nothing returns boolean
set wle=lQx(wLe+" (dummyBuff)")
call lux(wle,"Abilities\\Spells\\Other\\Doom\\DoomTarget.mdl","origin",ri)
call lux(wle,"Abilities\\Spells\\Undead\\Unsummon\\UnsummonTarget.mdl","origin",Bi)
set SU=lYx()
call l_x(SU,Ecv,.2)
call l0x(((wle)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,Ecv,.3)
call l0x(((wle)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,Ecv,.4)
call l0x(((wle)),vc+(3),(SU))
return true
endfunction
function TAr takes nothing returns boolean
call LZx('ABub',false)
set gYv=Lzo('ABub')
set G6[(gYv)]=(c6)
set j6[(gYv)]=(3)
set sH[(gYv)]=("ShamanicBubble")
set Ih[(gYv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0217)))),(((Oj))))))
set x6v[(gYv)]=(2)
set xzv[(gYv)]=("spell")
call LZo((gYv),u6v+(1),((500)*1.))
call LZo((gYv),BH+(1),(($A)*1.))
call LZo((gYv),fH+(1),((90)*1.))
call LZo((gYv),QH+(1),(($FA)*1.))
call LZo((gYv),Lvv+(1),((675)*1.))
call LZo((gYv),u6v+(2),((600)*1.))
call LZo((gYv),BH+(2),(($D)*1.))
call LZo((gYv),fH+(2),((80)*1.))
call LZo((gYv),QH+(2),(($FA)*1.))
call LZo((gYv),Lvv+(2),((675)*1.))
call LZo((gYv),u6v+(3),((700)*1.))
call LZo((gYv),BH+(3),((16)*1.))
call LZo((gYv),fH+(3),((70)*1.))
call LZo((gYv),QH+(3),(($FA)*1.))
call LZo((gYv),Lvv+(3),((675)*1.))
set Mnv[(gYv)]=("ReplaceableTextures\\CommandButtons\\BTNBigBadVoodooSpell.blp")
call ccr(gYv,'FBu0',3,'VBu0','LPBu','LRBu')
set wme[1]=.2
set wme[2]=.3
set wme[3]=.4
return true
endfunction
function TNr takes nothing returns boolean
call VRx(Ma,(function TIr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ShamanicBubble.page\\ShamanicBubble.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function TAr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ShamanicBubble.page\\ShamanicBubble.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Tbr takes nothing returns boolean
set wMe=Vnx(wLe)
return true
endfunction
function TBr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if not(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function Tcr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer XSr=Xpr(Ixx)
set wPe[oqx]=XSr
set wqe[oqx]=rwx
set Eee[(XSr)]=(oqx)
set vme[(XSr)]=(((Cpx((gYv),u6v+(rwx))))*1.)
set vMe[(XSr)]=(wpe)
call XPr(XSr,wQe)
call XPr(XSr,wse)
call XQr(XSr)
return true
endfunction
function TCr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer XSr=wPe[oqx]
call X2r(XSr)
return true
endfunction
function Tdr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
call Ayx(CMx,wJe)
call Ayx(CMx,wle)
return true
endfunction
function TDr takes integer CQx returns nothing
set wSe=CQx
call NIx(((aH[(CQx)])),(wJe),(1),w,((wte)*1.))
endfunction
function Tfr takes nothing returns boolean
local integer rdx=(bv)
call TDr((uH[(rdx)]))
return true
endfunction
function TFr takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer rkx=(Eee[(XSr)])
call UJx(Ixx,whe)
return true
endfunction
function Tgr takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer CMx=(vhe[(XSr)])
local integer rkx=(Eee[(XSr)])
local integer rwx=wqe[rkx]
call DSx((Ixx),(whe),(rwx),w)
return true
endfunction
function TGr takes nothing returns nothing
set wQe=XBx("FolderShamanicBubble_StructTarget_Init: set FolderShamanicBubble_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderShamanicBubble_StructTarget.Event_Ending)",vQe,pI,function TFr)
set wse=XBx("FolderShamanicBubble_StructTarget_Init: set FolderShamanicBubble_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderShamanicBubble_StructTarget.Event_Start)",vse,pI,function Tgr)
endfunction
function Thr takes integer CQx returns nothing
local integer CMx=(aH[(CQx)])
local integer rwx=(XH[(CQx)])
local real dix=(wh[(CQx)])
local real dax=(Wh[(CQx)])
call JLr(CMx,dix,dax,XYx(dix,dax))
call DSx((CMx),(wle),(rwx),w)
endfunction
function THr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
call Ayx(Ixx,wJe)
call Thr(wUe[oqx])
endfunction
function Tjr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer TJr=wSe
local real D7x=(ob[(Ixx)])
local integer oqx=Ixx
local integer OHx=inx()
set wTe[oqx]=OHx
set wue[oqx]=D7x
set wUe[oqx]=TJr
set ge[(OHx)]=(oqx)
call D6x((Ixx),-((D7x)*1.),((wte)*1.))
call icx(OHx,wte,false,function THr)
return true
endfunction
function Tkr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer OHx=wTe[oqx]
local real D7x=wue[oqx]
call ijx(OHx)
call D6x(Ixx,D7x,wte)
return true
endfunction
function TKr takes nothing returns nothing
call l9x(wJe,XBx("FolderShamanicBubble_StructTransition_Init: call FolderShamanicBubble_StructTransition.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderShamanicBubble_StructTransition.Event_BuffGain))",Bd,pI,function Tjr))
call l9x(wJe,XBx("FolderShamanicBubble_StructTransition_Init: call FolderShamanicBubble_StructTransition.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderShamanicBubble_StructTransition.Event_BuffLose))",Jc,pI,function Tkr))
endfunction
function Tlr takes nothing returns boolean
set wpe=XLx(function TBr)
call l9x(wle,XBx("ShamanicBubble_Init: call ShamanicBubble.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ShamanicBubble.Event_BuffGain))",Bd,pI,function Tcr))
call l9x(wle,XBx("ShamanicBubble_Init: call ShamanicBubble.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ShamanicBubble.Event_BuffLose))",Jc,pI,function TCr))
call meo(gYv,XBx("ShamanicBubble_Init: call ShamanicBubble.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ShamanicBubble.Event_EndCast))",oev,pI,function Tdr))
call meo(gYv,XBx("ShamanicBubble_Init: call ShamanicBubble.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ShamanicBubble.Event_SpellEffect))",ah,pI,function Tfr))
call TGr()
call TKr()
return true
endfunction
function TLr takes nothing returns boolean
call FOr(function Tlr,"ShamanicBubble_Init")
return true
endfunction
function Tmr takes nothing returns boolean
set wwe=lQx(wWe+" (coldnessBuff)")
set qc[(wwe)]=(true)
return true
endfunction
function TMr takes nothing returns boolean
set wye=WTx('BSDA',"Sleeping Draft",'bSDA')
set avv[(wye)]=(true)
set aev[(wye)]=("ReplaceableTextures\\CommandButtons\\BTNGreaterInvulneralbility.blp")
call lux(wye,"Abilities\\Spells\\Items\\VampiricPotion\\VampPotionCaster.mdl","origin",ri)
set SU=lYx()
call l_x(SU,nev,.3)
call l0x(((wye)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,nev,.4)
call l0x(((wye)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,nev,.5)
call l0x(((wye)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,nev,.6)
call l0x(((wye)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,nev,.7)
call l0x(((wye)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,nev,.8)
call l0x(((wye)),vc+(6),(SU))
return true
endfunction
function Tpr takes nothing returns boolean
set wYe[1]=3
set wYe[2]=3
set wYe[3]=3
set wYe[4]=3
set wYe[5]=3
set wYe[6]=3
set wze[1]=6
set wze[2]=6
set wze[3]=6
set wze[4]=6
set wze[5]=6
set wze[6]=6
return true
endfunction
function TPr takes nothing returns boolean
call VRx(Ma,(function Tmr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SleepingDraft.page\\SleepingDraft.struct\\Buff\\obj_coldnessBuff_wc3buff.j"))
call VRx(Ma,(function TMr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SleepingDraft.page\\SleepingDraft.struct\\Buff\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function Tpr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SleepingDraft.page\\SleepingDraft.struct\\Buff\\obj_this_wc3obj.j"))
return true
endfunction
function Tqr takes nothing returns boolean
set wZe=Vnx(wWe)
return true
endfunction
function TQr takes nothing returns boolean
set w_e=WTx('BSDB',"Sleep",'bSDB')
set qc[(w_e)]=(true)
set qU[(w_e)]=(true)
set aev[(w_e)]=("ReplaceableTextures\\CommandButtons\\BTNPotionOfClarity.blp")
return true
endfunction
function Tsr takes nothing returns boolean
call LZx('ASlD',false)
set G2v=Lzo('ASlD')
set G6[(G2v)]=(i6)
set j6[(G2v)]=(6)
set sH[(G2v)]=("Sleeping Draft")
set Ih[(G2v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0103)))),(((Oj))))))
set x6v[(G2v)]=(4)
set xzv[(G2v)]=("spell")
call LZo((G2v),u6v+(1),((350)*1.))
call LZo((G2v),fH+(1),((16)*1.))
call LZo((G2v),QH+(1),(('x')*1.))
call LZo((G2v),Lvv+(1),((700)*1.))
call LZo((G2v),u6v+(2),((350)*1.))
call LZo((G2v),fH+(2),(($F)*1.))
call LZo((G2v),QH+(2),(('x')*1.))
call LZo((G2v),Lvv+(2),((700)*1.))
call LZo((G2v),u6v+(3),((350)*1.))
call LZo((G2v),fH+(3),(($E)*1.))
call LZo((G2v),QH+(3),(('x')*1.))
call LZo((G2v),Lvv+(3),((700)*1.))
call LZo((G2v),u6v+(4),((350)*1.))
call LZo((G2v),fH+(4),(($D)*1.))
call LZo((G2v),QH+(4),(('x')*1.))
call LZo((G2v),Lvv+(4),((700)*1.))
call LZo((G2v),u6v+(5),((350)*1.))
call LZo((G2v),fH+(5),(($C)*1.))
call LZo((G2v),QH+(5),(('x')*1.))
call LZo((G2v),Lvv+(5),((700)*1.))
call LZo((G2v),u6v+(6),((350)*1.))
call LZo((G2v),fH+(6),(($B)*1.))
call LZo((G2v),QH+(6),(('x')*1.))
call LZo((G2v),Lvv+(6),((700)*1.))
set Mnv[(G2v)]=("ReplaceableTextures\\CommandButtons\\BTNPotionOfClarity.blp")
call ccr(G2v,'FSD0',6,'VSD0','LPSD','LRSD')
set w0e[1]=3
set w0e[2]=4
set w0e[3]=5
set w0e[4]=6
set w0e[5]=7
set w0e[6]=8
set w1e[1]=6
set w1e[2]=8
set w1e[3]=$A
set w1e[4]=$C
set w1e[5]=$E
set w1e[6]=16
set w2e[1]=25
set w2e[2]=35
set w2e[3]=45
set w2e[4]=55
set w2e[5]=60
set w2e[6]=65
set w3e[1]=2
set w3e[2]=3
set w3e[3]=4
set w3e[4]=5
set w3e[5]=6
set w3e[6]=7
return true
endfunction
function TSr takes nothing returns boolean
call VRx(Ma,(function TQr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SleepingDraft.page\\SleepingDraft.struct\\obj_sleepBuff_wc3buff.j"))
call VRx(qa,(function Tsr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SleepingDraft.page\\SleepingDraft.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Ttr takes nothing returns boolean
set w4e=Vnx(w5e)
return true
endfunction
function TTr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function Tur takes integer oqx returns integer
set Wxe[oqx]=true
set Woe[oqx]=false
call rax(w4e)
return oqx
endfunction
function TUr takes nothing returns integer
local integer oqx
if(w8e==8190)then
call oYx("SleepingDraft_Allocation_allocCustom","call DebugEx(SleepingDraft.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",w5e+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(w9e[(w)]==w)then
set Wve=Wve+1
set oqx=Wve
else
set oqx=w9e[(w)]
set w9e[(w)]=w9e[w9e[(w)]]
endif
set w9e[oqx]=Z
set Wee[oqx]=1
call Tur(oqx)
return oqx
endfunction
function Twr takes integer oqx returns nothing
set Wxe[oqx]=false
call rgx(w4e)
endfunction
function TWr takes integer oqx returns nothing
if(Wee[oqx]>0)then
return
endif
if(w9e[oqx]!=Z)then
call oYx("SleepingDraft_Allocation_deallocCustom_confirm","call DebugEx(SleepingDraft.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",w5e+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set w9e[oqx]=w9e[(w)]
set w9e[(w)]=oqx
call Twr(oqx)
endfunction
function Tyr takes integer oqx returns nothing
set Wee[oqx]=Wee[oqx]-1
call TWr(oqx)
endfunction
function TYr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local real x=(mFv[(MFo)])
local real y=(mgv[(MFo)])
local integer CMx=Wre[oqx]
local integer rwx=Wie[oqx]
local integer Ecr
local integer Ixx
local integer olx
call Tyr((oqx))
call Mdo(MFo)
set Hf=(ze[(CMx)])
call Nio(w6e,x,y,(Cpx((G2v),u6v+(rwx))),w7e)
set Ecr=w0e[rwx]
if(Ecr>0)then
set Ixx=(mjo((w6e),((x)*1.),((y)*1.)))
if(Ixx!=w)then
set olx=1
loop
call GroupRemoveUnit(Kb[(w6e)],C[(Ixx)])
call RUx((Abx((Ixx),(Wae),(Wne),(ri))))
if I6x(Ixx,yd)then
call NIx((Ixx),(w_e),(rwx),w,((w3e[rwx])*1.))
else
call NIx((Ixx),(w_e),(rwx),w,((w1e[rwx])*1.))
endif
set olx=olx+1
exitwhen(olx>Ecr)
set Ixx=(mjo((w6e),((x)*1.),((y)*1.)))
exitwhen(Ixx==w)
endloop
endif
endif
return true
endfunction
function Tzr takes integer rwx,integer Ixx returns nothing
call NIx((Ixx),(wye),(rwx),w,((wze[rwx])*1.))
endfunction
function TZr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer oqx=TUr()
local integer MFo=Mvo()
set Wre[oqx]=CMx
set Wie[oqx]=rwx
set mAv[((MFo))]=((b6v*((.2)*1.))*1.)
set mNv[(MFo)]=((10.)*1.)
call Mro(MFo,'qSle',1.5)
set mCv[(MFo)]=XHx((function TYr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,700.)
call MPo((MFo),(CMx),.0,.0,.0)
call M3o((MFo),(Ixx),.0,.0,.0,(null))
call Tzr(rwx,CMx)
call mio(CMx,CMx,(Nqv[(CMx)])*WVe+w2e[rwx])
return true
endfunction
function T_r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(EYv[(rdx)])
local integer w_o=(WH[(rdx)])
local integer oqx=Ixx
local integer rwx=WXe[oqx]
call NIx((w_o),(wwe),(rwx),w,((wYe[rwx])*1.))
call RUx((Abx((w_o),("Abilities\\Weapons\\LichMissile\\LichMissile.mdl"),("chest"),(Bi))))
return true
endfunction
function T0r takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
set WXe[oqx]=rwx
call I7x(Ixx,WEe)
return true
endfunction
function T1r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call Rmx(Ixx,WEe)
return true
endfunction
function T2r takes nothing returns nothing
set WEe=XBx("FolderSleepingDraft_StructBuff_Init: set FolderSleepingDraft_StructBuff.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function FolderSleepingDraft_StructBuff.Event_Damage)",EZv,pI,function T_r)
call l9x(wye,XBx("FolderSleepingDraft_StructBuff_Init: call FolderSleepingDraft_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSleepingDraft_StructBuff.Event_BuffGain))",Bd,pI,function T0r))
call l9x(wye,XBx("FolderSleepingDraft_StructBuff_Init: call FolderSleepingDraft_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSleepingDraft_StructBuff.Event_BuffLose))",Jc,pI,function T1r))
call W_x(nxv,wwe)
endfunction
function T3r takes nothing returns boolean
set w6e=O2x()
set w7e=XLx(function TTr)
call meo(G2v,XBx("SleepingDraft_Init: call SleepingDraft.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SleepingDraft.Event_SpellEffect))",ah,pI,function TZr))
call W_x(XKv,w_e)
call T2r()
return true
endfunction
function T4r takes nothing returns boolean
call FOr(function T3r,"SleepingDraft_Init")
return true
endfunction
function T5r takes nothing returns boolean
return true
endfunction
function T6r takes nothing returns boolean
set WOe=Vnx(WRe)
return true
endfunction
function T7r takes nothing returns boolean
call LZx('ASoU',false)
set G5v=Lzo('ASoU')
set G6[(G5v)]=(C6)
set j6[(G5v)]=(3)
set sH[(G5v)]=("Sober up")
set Ih[(G5v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00C4)))),(((Oj))))))
set x6v[(G5v)]=(0)
set xzv[(G5v)]=("spell")
call LZo((G5v),u6v+(1),((750)*1.))
call LZo((G5v),BH+(1),((.5)*1.))
call LZo((G5v),fH+(1),(('x')*1.))
call LZo((G5v),QH+(1),(($96)*1.))
call LZo((G5v),Lvv+(1),((750)*1.))
call LZo((G5v),u6v+(2),((750)*1.))
call LZo((G5v),BH+(2),((.5)*1.))
call LZo((G5v),fH+(2),(('d')*1.))
call LZo((G5v),QH+(2),(($96)*1.))
call LZo((G5v),Lvv+(2),((750)*1.))
call LZo((G5v),u6v+(3),((750)*1.))
call LZo((G5v),BH+(3),((.5)*1.))
call LZo((G5v),fH+(3),((80)*1.))
call LZo((G5v),QH+(3),(($96)*1.))
call LZo((G5v),Lvv+(3),((750)*1.))
set Mnv[(G5v)]=("ReplaceableTextures\\CommandButtons\\BTNStormEarth&Fire.blp")
call ccr(G5v,'FSU0',3,'VSU0','LPSU','LRSU')
set WIe[1]=35
set WIe[2]=50
set WIe[3]=65
set WAe[1]=3.5
set WAe[2]=5
set WAe[3]=6.5
set WNe[1]=5
set WNe[2]=7
set WNe[3]=9
set Wbe[1]=$F
set Wbe[2]=30
set Wbe[3]=35
return true
endfunction
function T8r takes nothing returns boolean
set WBe=lQx(Wce+" (banishBuff)")
set qc[(WBe)]=(true)
return true
endfunction
function T9r takes nothing returns boolean
call VRx(qa,(function T7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SoberUp.page\\SoberUp.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function T8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SoberUp.page\\SoberUp.struct\\obj_banishBuff_wc3buff.j"))
return true
endfunction
function uvr takes nothing returns boolean
set WCe=Vnx(Wce)
return true
endfunction
function uer takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
return true
return true
endfunction
function uxr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real O1o=(Cpx((G5v),u6v+(rwx)))
local real x=(GetUnitX(C[((CMx))]))
local real y=(GetUnitY(C[((CMx))]))
local integer oqx
call A7o(Nvo(x,y,Wfe,ri,O1o*1./ WFe))
set oqx=CMx
set Wge[oqx]=rwx
set WGe[oqx]=x
set Whe[oqx]=y
return true
endfunction
function uor takes integer oqx returns integer
set WJe[oqx]=true
set Wke[oqx]=false
call rax(WOe)
return oqx
endfunction
function urr takes integer oqx returns nothing
set WJe[oqx]=false
call rgx(WOe)
endfunction
function uir takes integer CMx,integer rwx,integer nyx returns nothing
call RUx((Abx((CMx),(Wme),(WMe),(ri))))
call moo(CMx,CMx,Wbe[rwx]*nyx)
endfunction
function uar takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer nyx=WKe[oqx]
local integer CMx=Wle[oqx]
local integer rwx=WLe[oqx]
call urr(oqx)
call Mdo(MFo)
call uir(CMx,rwx,nyx)
return true
endfunction
function unr takes integer CMx,integer rwx,integer ozx,integer nyx returns nothing
local integer MFo=Mvo()
local integer oqx=uor(MFo)
set WKe[oqx]=nyx
set Wle[oqx]=CMx
set WLe[oqx]=rwx
set mAv[((MFo))]=((b6v*((.4)*1.))*1.)
set mNv[(MFo)]=((32.)*1.)
set mCv[(MFo)]=XHx((function uar))
set mWv[(MFo)]=(oqx)
call m8o(MFo,600.)
call M9o(MFo,ozx)
call M3o((MFo),(CMx),.0,.0,.0,(null))
call Mro(MFo,'qSUH',1+(nyx*.2))
endfunction
function uVr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local boolean Eko=(ovv[(rdx)])
local integer oqx=CMx
local integer rwx=Wge[oqx]
local real x=WGe[oqx]
local real y=Whe[oqx]
local real O1o=(Cpx((G5v),u6v+(rwx)))
local integer Ixx
local integer C0o
local real uEr
local integer nyx
local real BNr
if not Eko then
call Dnx((CMx),(G5v))
call BRx(CMx,(Cpx((G5v),QH+(rwx))))
return true
endif
call A7o(Nvo(x,y,WHe,Bi,O1o*1./ Wje))
call Nio(Wde,x,y,O1o,WDe)
set Ixx=Nao(Wde)
if(Ixx!=w)then
set C0o=(ze[(CMx)])
set uEr=WIe[rwx]
loop
if(IsUnitAlly(C[(Ixx)],vx[(C0o)]))then
set nyx=wbo(Ixx,true,false,true)
if(nyx>0)then
call unr(CMx,rwx,Ixx,nyx)
endif
else
call RUx((Abx((Ixx),(Wpe),(WPe),(ri))))
if I6x(Ixx,yd)then
set BNr=WAe[rwx]
else
set BNr=WNe[rwx]
endif
call NIx((Ixx),(WBe),(rwx),w,((BNr)*1.))
set nyx=apr(Ixx,true,false)
if(nyx>0)then
call nJo((CMx),(Ixx),((nyx*uEr)*1.),(true),(false))
endif
endif
set Ixx=Nao(Wde)
exitwhen(Ixx==w)
endloop
endif
return true
endfunction
function uXr takes nothing returns boolean
set Wde=O2x()
set WDe=XLx(function uer)
call meo(G5v,XBx("SoberUp_Init: call SoberUp.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoberUp.Event_SpellEffect))",ah,pI,function uxr))
call meo(G5v,XBx("SoberUp_Init: call SoberUp.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoberUp.Event_EndCast))",oev,pI,function uVr))
call W_x(Eav,WBe)
return true
endfunction
function uOr takes nothing returns boolean
call FOr(function uXr,"SoberUp_Init")
return true
endfunction
function uRr takes nothing returns boolean
set Wqe[1]=5
set Wqe[2]=7.5
set Wqe[3]=$A
return true
endfunction
function uIr takes nothing returns boolean
set WQe=WTx('BStI',"Steel Impalement",'bStI')
set qU[(WQe)]=(true)
set aev[(WQe)]=("ReplaceableTextures\\CommandButtons\\BTNImpale.blp")
call lux(WQe,"SteelImpalement_page\\SteelImpalement_struct\\Target\\spear.mdx","origin",ri)
return true
endfunction
function uAr takes nothing returns boolean
call VRx(ea,(function uRr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SteelImpalement.page\\SteelImpalement.struct\\Target\\obj_this_wc3obj.j"))
call VRx(Ma,(function uIr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SteelImpalement.page\\SteelImpalement.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function uNr takes nothing returns boolean
set Wse=Vnx(WSe)
return true
endfunction
function ubr takes nothing returns boolean
call LZx('AStI',false)
set gPv=Lzo('AStI')
set G6[(gPv)]=(C6)
set j6[(gPv)]=(3)
set sH[(gPv)]=("Steel Impalement")
set Ih[(gPv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00C4)))),(((Oj))))))
set x6v[(gPv)]=(0)
set xzv[(gPv)]=("slam")
call LZo((gPv),u6v+(1),(($BB8)*1.))
call LZo((gPv),BH+(1),(($C)*1.))
call LZo((gPv),fH+(1),(('d')*1.))
call LZo((gPv),QH+(1),(($B4)*1.))
call LZo((gPv),Lvv+(1),((750)*1.))
call LZo((gPv),u6v+(2),(($BB8)*1.))
call LZo((gPv),BH+(2),(($C)*1.))
call LZo((gPv),fH+(2),(('d')*1.))
call LZo((gPv),QH+(2),(($E1)*1.))
call LZo((gPv),Lvv+(2),((750)*1.))
call LZo((gPv),u6v+(3),(($BB8)*1.))
call LZo((gPv),BH+(3),(($C)*1.))
call LZo((gPv),fH+(3),(('d')*1.))
call LZo((gPv),QH+(3),((270)*1.))
call LZo((gPv),Lvv+(3),((750)*1.))
set Mnv[(gPv)]=("ReplaceableTextures\\CommandButtons\\BTNImpale.blp")
call ccr(gPv,'FSI0',3,'VSI0','LPSI','LRSI')
set Wte[1]=50
set Wte[2]='d'
set Wte[3]=$96
set WTe[1]=3
set WTe[2]=3
set WTe[3]=3
return true
endfunction
function uBr takes nothing returns boolean
set Wue=lQx(WUe+" (dummyBuff)")
return true
endfunction
function ucr takes nothing returns boolean
call VRx(qa,(function ubr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SteelImpalement.page\\SteelImpalement.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function uBr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SteelImpalement.page\\SteelImpalement.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function uCr takes nothing returns boolean
set Wwe=Vnx(WUe)
return true
endfunction
function udr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(I5x((OPe),Rb,(Ixx)))then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function uDr takes integer Ixx,integer CMx,integer rwx returns nothing
call RUx((Abx((Ixx),(W6e),(W7e),(ri))))
call nZr(Ixx)
call NIx(Ixx,WQe,rwx,CMx,Wqe[rwx])
endfunction
function ufr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=oqx
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real O1o=Wze[oqx]+WZe[oqx]
local integer rwx=(XH[(W3e[oqx])])
local integer Q7o=W0e[oqx]
local real uFr
local real N8x
local integer ugr
local real iXr
local integer Ixx
set Wze[oqx]=O1o
set uFr=Cf*O1o
set N8x=(GetRandomReal(((.0)*1.),((df)*1.)))
set ugr=(R2I(((uFr*1./ NWr("sfxdist",W4e))*1.)))
set iXr=df*1./ ugr
loop
exitwhen(ugr<1)
set N8x=N8x+iXr
call mFo((mHo(((wpo+O1o*(Cos(((((N8x)*1.))*1.))))*1.),((wPo+O1o*(Sin(((((N8x)*1.))*1.))))*1.),(W5e),(ri))))
set ugr=ugr-1
endloop
set Hf=(ze[(CMx)])
set OPe=Q7o
call Nio(WWe,wpo,wPo,O1o,Wye)
set Ixx=Nao(WWe)
if(Ixx!=w)then
loop
call dpx(Q7o,Ixx)
call uDr(Ixx,CMx,rwx)
call nJo((CMx),(Ixx),((W_e[oqx])*1.),(false),(false))
set Ixx=Nao(WWe)
exitwhen(Ixx==w)
endloop
endif
endfunction
function uGr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
set Wze[oqx]=.0
call dux((W0e[oqx]),Rb)
endfunction
function uhr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer CQx=(mc[(rdx)])
local real uHr=NWr("animspeed",.5)*1.2*1./(Cpx((gPv),BH+(rwx)))-1
local real KAr=1.5*1./ WTe[rwx]
local integer oqx=CMx
local integer Q6o=inx()
local integer ujr=inx()
set WYe[oqx]=uHr
set Wze[oqx]=.0
set WZe[oqx]=(Cpx((gPv),u6v+(rwx)))*1./(Cpx((gPv),BH+(rwx)))*WTe[rwx]*KAr
set W_e[oqx]=Wte[rwx]
set W0e[oqx]=JIx("SteelImpalement_Event_BuffGain: set this.targetGroup = UnitList.Create()")
set W1e[oqx]=Q6o
set W2e[oqx]=ujr
set W3e[oqx]=CQx
set ge[(Q6o)]=(oqx)
set ge[(ujr)]=(oqx)
call QKr(CMx,uHr)
call DSx((((CMx))),(iiv),(1),w)
call icx(Q6o,KAr,true,function ufr)
call icx(ujr,(Cpx((gPv),BH+(rwx)))*1./ WTe[rwx],true,function uGr)
return true
endfunction
function uJr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer oqx=CMx
local real uHr=WYe[oqx]
local integer Q6o=W1e[oqx]
local integer ujr=W2e[oqx]
call ijx(Q6o)
call ijx(ujr)
call Q9r(CMx,uHr)
call UJx(((CMx)),iiv)
return true
endfunction
function ukr takes nothing returns boolean
local integer rdx=(bv)
call DSx((Vv[(rdx)]),Wue,(Mv[(rdx)]),(uH[(rdx)]))
return true
endfunction
function uKr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),Wue)
return true
endfunction
function ulr takes nothing returns nothing
call W_x(Emv,WQe)
call W_x(x_v,WQe)
endfunction
function uLr takes nothing returns boolean
set WWe=O2x()
set Wye=XLx(function udr)
call l9x(Wue,XBx("SteelImpalement_Init: call SteelImpalement.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SteelImpalement.Event_BuffGain))",Bd,pI,function uhr))
call l9x(Wue,XBx("SteelImpalement_Init: call SteelImpalement.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SteelImpalement.Event_BuffLose))",Jc,pI,function uJr))
call meo(gPv,XBx("SteelImpalement_Init: call SteelImpalement.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SteelImpalement.Event_SpellEffect))",ah,pI,function ukr))
call meo(gPv,XBx("SteelImpalement_Init: call SteelImpalement.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SteelImpalement.Event_EndCast))",oev,pI,function uKr))
call ulr()
return true
endfunction
function umr takes nothing returns boolean
call FOr(function uLr,"SteelImpalement_Init")
return true
endfunction
function uMr takes nothing returns boolean
set W8e=Vnx(W9e)
return true
endfunction
function upr takes nothing returns boolean
call LZx('ATau',false)
set yve=Lzo('ATau')
set G6[(yve)]=(D6)
set j6[(yve)]=(1)
set sH[(yve)]=("Taunt")
set xzv[(yve)]=("spell")
call LZo((yve),u6v+(1),((450)*1.))
call LZo((yve),Lvv+(1),((750)*1.))
return true
endfunction
function uPr takes nothing returns boolean
set yee[1]=hGo('uPoB')
call hho(((yee[1])),Apv,(INv))
set Tj[(yee[1])]=((.95)*1.)
set Nav[(yee[1])]=((60)*1.)
set Ntv[(yee[1])]=((60)*1.)
set Nlv[(yee[1])]=((270)*1.)
set I3v[(yee[1])]=((2)*1.)
set Axv[(yee[1])]=(2)
set NJv[(yee[1])]=((400)*1.)
set Njv[(yee[1])]=((400)*1.)
set Nhv[(yee[1])]=((.3)*1.)
set NKv[(yee[1])]=((80)*1.)
set Nkv[(yee[1])]=((80)*1.)
set NHv[(yee[1])]=((.1)*1.)
set NIv[(yee[1])]=(($578)*1.)
set NOv[(yee[1])]=(($578)*1.)
set Ndv[(yee[1])]=((45)*1.)
set ANv[(yee[1])]=(gHv)
set Adv[(yee[1])]=((153.6)*1.)
set ADv[((yee[1]))]=((1.*1./((1.35)*1.))*1.)
set Atv[(yee[1])]=((.63)*1.)
set AQv[(yee[1])]=(($E)*1.)
set Asv[(yee[1])]=(($E)*1.)
set Auv[(yee[1])]=(1)
set AWv[(yee[1])]=(5)
set Azv[(yee[1])]=(0)
set Aqv[(yee[1])]=((48)*1.)
return true
endfunction
function uqr takes nothing returns boolean
set yee[2]=hGo('uPB2')
call hho(((yee[2])),Apv,(INv))
set Tj[(yee[2])]=((1.15)*1.)
set Nav[(yee[2])]=((60)*1.)
set Ntv[(yee[2])]=((60)*1.)
set Nlv[(yee[2])]=((270)*1.)
set I3v[(yee[2])]=((3)*1.)
set Axv[(yee[2])]=(2)
set NJv[(yee[2])]=((500)*1.)
set Njv[(yee[2])]=((500)*1.)
set Nhv[(yee[2])]=((.4)*1.)
set NKv[(yee[2])]=(('d')*1.)
set Nkv[(yee[2])]=(('d')*1.)
set NHv[(yee[2])]=((.15)*1.)
set NIv[(yee[2])]=(($578)*1.)
set NOv[(yee[2])]=(($578)*1.)
set Ndv[(yee[2])]=((55)*1.)
set ANv[(yee[2])]=(gHv)
set Adv[(yee[2])]=((153.6)*1.)
set ADv[((yee[2]))]=((1.*1./((1.35)*1.))*1.)
set Atv[(yee[2])]=((.63)*1.)
set AQv[(yee[2])]=((18)*1.)
set Asv[(yee[2])]=((18)*1.)
set Auv[(yee[2])]=(1)
set AWv[(yee[2])]=(6)
set Azv[(yee[2])]=(0)
set Aqv[(yee[2])]=((48)*1.)
return true
endfunction
function uQr takes nothing returns boolean
call LZx('ASGC',false)
set yxe=Lzo('ASGC')
set G6[(yxe)]=(N6)
set j6[(yxe)]=(6)
set sH[(yxe)]=("Callback")
set Ih[(yxe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0272)))),(((Oj))))))
set x6v[(yxe)]=(0)
set xzv[(yxe)]=("spell")
call LZo((yxe),fH+(1),((0)*1.))
call LZo((yxe),QH+(1),((5)*1.))
call LZo((yxe),Lvv+(1),((750)*1.))
call LZo((yxe),fH+(2),((0)*1.))
call LZo((yxe),QH+(2),((5)*1.))
call LZo((yxe),Lvv+(2),((750)*1.))
call LZo((yxe),fH+(3),((0)*1.))
call LZo((yxe),QH+(3),((5)*1.))
call LZo((yxe),Lvv+(3),((750)*1.))
call LZo((yxe),fH+(4),((0)*1.))
call LZo((yxe),QH+(4),((5)*1.))
call LZo((yxe),Lvv+(4),((750)*1.))
call LZo((yxe),fH+(5),((0)*1.))
call LZo((yxe),QH+(5),((5)*1.))
call LZo((yxe),Lvv+(5),((750)*1.))
call LZo((yxe),fH+(6),((0)*1.))
call LZo((yxe),QH+(6),((5)*1.))
call LZo((yxe),Lvv+(6),((750)*1.))
set Mnv[(yxe)]=("ReplaceableTextures\\CommandButtons\\BTNLifeDrain.blp")
call ccr(yxe,'FSC0',6,'VSC0','LPSC','LRSC')
set yoe[1]=.3
set yoe[2]=.3
set yoe[3]=.3
set yoe[4]=.3
set yoe[5]=.3
set yoe[6]=.3
set yre[1]=$A
set yre[2]=20
set yre[3]=30
set yre[4]=40
set yre[5]=50
set yre[6]=60
return true
endfunction
function usr takes nothing returns boolean
set yee[3]=hGo('uPB3')
call hho(((yee[3])),Apv,(INv))
set Tj[(yee[3])]=((1.25)*1.)
set Nav[(yee[3])]=((60)*1.)
set Ntv[(yee[3])]=((60)*1.)
set Nlv[(yee[3])]=((270)*1.)
set I3v[(yee[3])]=((4)*1.)
set Axv[(yee[3])]=(2)
set NJv[(yee[3])]=((620)*1.)
set Njv[(yee[3])]=((620)*1.)
set Nhv[(yee[3])]=((.5)*1.)
set NKv[(yee[3])]=(('x')*1.)
set Nkv[(yee[3])]=(('x')*1.)
set NHv[(yee[3])]=((.2)*1.)
set NIv[(yee[3])]=(($578)*1.)
set NOv[(yee[3])]=(($578)*1.)
set Ndv[(yee[3])]=((65)*1.)
set ANv[(yee[3])]=(gHv)
set Adv[(yee[3])]=((153.6)*1.)
set ADv[((yee[3]))]=((1.*1./((1.35)*1.))*1.)
set Atv[(yee[3])]=((.63)*1.)
set AQv[(yee[3])]=((24)*1.)
set Asv[(yee[3])]=((24)*1.)
set Auv[(yee[3])]=(2)
set AWv[(yee[3])]=(4)
set Azv[(yee[3])]=(0)
set Aqv[(yee[3])]=((48)*1.)
return true
endfunction
function uSr takes nothing returns boolean
set yee[4]=hGo('uPB4')
call hho(((yee[4])),Apv,(INv))
set Tj[(yee[4])]=((1.35)*1.)
set Nav[(yee[4])]=((60)*1.)
set Ntv[(yee[4])]=((60)*1.)
set Nlv[(yee[4])]=((270)*1.)
set I3v[(yee[4])]=((5)*1.)
set Axv[(yee[4])]=(2)
set NJv[(yee[4])]=((750)*1.)
set Njv[(yee[4])]=((750)*1.)
set Nhv[(yee[4])]=((.5)*1.)
set NKv[(yee[4])]=(($8C)*1.)
set Nkv[(yee[4])]=(($8C)*1.)
set NHv[(yee[4])]=((.25)*1.)
set NIv[(yee[4])]=(($578)*1.)
set NOv[(yee[4])]=(($578)*1.)
set Ndv[(yee[4])]=((75)*1.)
set ANv[(yee[4])]=(gHv)
set Adv[(yee[4])]=((153.6)*1.)
set ADv[((yee[4]))]=((1.*1./((1.35)*1.))*1.)
set Atv[(yee[4])]=((.63)*1.)
set AQv[(yee[4])]=((26)*1.)
set Asv[(yee[4])]=((26)*1.)
set Auv[(yee[4])]=(3)
set AWv[(yee[4])]=(4)
set Azv[(yee[4])]=(0)
set Aqv[(yee[4])]=((48)*1.)
return true
endfunction
function utr takes nothing returns boolean
set yee[5]=hGo('uPB5')
call hho(((yee[5])),Apv,(INv))
set Tj[(yee[5])]=((1.45)*1.)
set Nav[(yee[5])]=((60)*1.)
set Ntv[(yee[5])]=((60)*1.)
set Nlv[(yee[5])]=((270)*1.)
set I3v[(yee[5])]=((6)*1.)
set Axv[(yee[5])]=(2)
set NJv[(yee[5])]=((900)*1.)
set Njv[(yee[5])]=((900)*1.)
set Nhv[(yee[5])]=((.5)*1.)
set NKv[(yee[5])]=(($A0)*1.)
set Nkv[(yee[5])]=(($A0)*1.)
set NHv[(yee[5])]=((.3)*1.)
set NIv[(yee[5])]=(($578)*1.)
set NOv[(yee[5])]=(($578)*1.)
set Ndv[(yee[5])]=((85)*1.)
set ANv[(yee[5])]=(gHv)
set Adv[(yee[5])]=((153.6)*1.)
set ADv[((yee[5]))]=((1.*1./((1.35)*1.))*1.)
set Atv[(yee[5])]=((.63)*1.)
set AQv[(yee[5])]=((27)*1.)
set Asv[(yee[5])]=((27)*1.)
set Auv[(yee[5])]=(4)
set AWv[(yee[5])]=(4)
set Azv[(yee[5])]=(0)
set Aqv[(yee[5])]=((48)*1.)
return true
endfunction
function uTr takes nothing returns boolean
set yie[1]=3
set yie[2]=3.5
set yie[3]=4
set yie[4]=4.5
set yie[5]=5
set yie[6]=5.5
set yae[1]=30
set yae[2]=30
set yae[3]=30
set yae[4]=30
set yae[5]=30
set yae[6]=30
return true
endfunction
function uur takes nothing returns boolean
call VRx(qa,(function upr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\obj_tauntSpell_wc3spell.j"))
call VRx(Sa,(function uPr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\obj_summonUnitType[1]_wc3unit.j"))
call VRx(Sa,(function uqr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\obj_summonUnitType[2]_wc3unit.j"))
call VRx(qa,(function uQr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\obj_callbackSpell_wc3spell.j"))
call VRx(Sa,(function usr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\obj_summonUnitType[3]_wc3unit.j"))
call VRx(Sa,(function uSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\obj_summonUnitType[4]_wc3unit.j"))
call VRx(Sa,(function utr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\obj_summonUnitType[5]_wc3unit.j"))
call VRx(ea,(function uTr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\obj_this_wc3obj.j"))
return true
endfunction
function uUr takes nothing returns boolean
set yne=Vnx(yVe)
return true
endfunction
function uwr takes nothing returns boolean
call LZx('ASuG',false)
set hAv=Lzo('ASuG')
set G6[(hAv)]=(N6)
set j6[(hAv)]=(6)
set sH[(hAv)]=("Polar Pal")
set Ih[(hAv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0272)))),(((Oj))))))
set x6v[(hAv)]=(4)
set xzv[(hAv)]=("spell")
call LZo((hAv),fH+(1),((25)*1.))
call LZo((hAv),QH+(1),((85)*1.))
call LZo((hAv),Lvv+(1),((650)*1.))
call LZo((hAv),fH+(2),((23)*1.))
call LZo((hAv),QH+(2),(('d')*1.))
call LZo((hAv),Lvv+(2),((650)*1.))
call LZo((hAv),fH+(3),((21)*1.))
call LZo((hAv),QH+(3),(('s')*1.))
call LZo((hAv),Lvv+(3),((650)*1.))
call LZo((hAv),fH+(4),((19)*1.))
call LZo((hAv),QH+(4),(($82)*1.))
call LZo((hAv),Lvv+(4),((650)*1.))
call LZo((hAv),fH+(5),((17)*1.))
call LZo((hAv),QH+(5),(($91)*1.))
call LZo((hAv),Lvv+(5),((650)*1.))
call LZo((hAv),fH+(6),(($F)*1.))
call LZo((hAv),QH+(6),(($A0)*1.))
call LZo((hAv),Lvv+(6),((650)*1.))
set Mnv[(hAv)]=("ReplaceableTextures\\CommandButtons\\BTNFrostBear.blp")
call ccr(hAv,'FSP0',6,'VSP0','LPSP','LRSP')
return true
endfunction
function uWr takes nothing returns boolean
call VRx(qa,(function uwr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function uyr takes nothing returns boolean
set yEe=Vnx(yXe)
return true
endfunction
function uYr takes integer oqx returns integer
set yNe[oqx]=true
set ybe[oqx]=false
call rax(yEe)
return oqx
endfunction
function uzr takes nothing returns integer
local integer oqx
if(yOe==8190)then
call oYx("SummonPolarBear_Allocation_allocCustom","call DebugEx(SummonPolarBear.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",yXe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(yRe[(w)]==w)then
set yIe=yIe+1
set oqx=yIe
else
set oqx=yRe[(w)]
set yRe[(w)]=yRe[yRe[(w)]]
endif
set yRe[oqx]=Z
set yAe[oqx]=1
call uYr(oqx)
return oqx
endfunction
function uZr takes integer oqx returns nothing
set yNe[oqx]=false
call rgx(yEe)
endfunction
function u_r takes integer oqx returns nothing
if(yAe[oqx]>0)then
return
endif
if(yRe[oqx]!=Z)then
call oYx("SummonPolarBear_Allocation_deallocCustom_confirm","call DebugEx(SummonPolarBear.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",yXe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set yRe[oqx]=yRe[(w)]
set yRe[(w)]=oqx
call uZr(oqx)
endfunction
function u0r takes integer oqx returns nothing
set yAe[oqx]=yAe[oqx]-1
call u_r(oqx)
endfunction
function u1r takes integer oqx returns nothing
local integer u2r=yDe[oqx]
local integer CMx=yfe[oqx]
local integer rwx=yFe[oqx]
local real u3r=(rG[(u2r)])
call RXr(u2r)
call moo(CMx,CMx,yre[rwx]+u3r*yoe[rwx])
endfunction
function u4r takes integer oqx returns integer
set yje[oqx]=true
set yJe[oqx]=false
call rax(yne)
return oqx
endfunction
function u5r takes nothing returns integer
local integer oqx
if(yge==8190)then
call oYx("FolderSummonPolarBear_StructSummon_Allocation_allocCustom","call DebugEx(FolderSummonPolarBear_StructSummon.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",yVe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(yGe[(w)]==w)then
set yhe=yhe+1
set oqx=yhe
else
set oqx=yGe[(w)]
set yGe[(w)]=yGe[yGe[(w)]]
endif
set yGe[oqx]=Z
set yHe[oqx]=1
call u4r(oqx)
return oqx
endfunction
function u6r takes integer CMx,integer rwx,integer Ixx,real x,real y returns nothing
local integer oqx=oPx(CMx,yde)
local integer u2r
local integer C0o
if(oqx!=w)then
call u1r(oqx)
endif
set C0o=(ze[(CMx)])
set u2r=Uzo(yee[rwx],C0o,x,y,Kf,yae[rwx])
set oqx=u5r()
set yDe[oqx]=u2r
set yfe[oqx]=CMx
set yFe[oqx]=rwx
call rTx(u2r,yde,oqx)
call I7x(u2r,yke)
call rTx(CMx,yde,oqx)
call I7x(CMx,yKe)
call LOr(N6,yxe,CMx)
call NIx((u2r),(i9v),(rwx),w,((yie[rwx])*1.))
call rzx(((u2r)),((yve)),(1))
call Qzx((C0o),B[(yve)],(true))
call O9x(u2r,c4)
call Qzx((C0o),B[(yve)],(false))
if(IsUnitAlly(C[(Ixx)],vx[(C0o)]))then
call rzx((u2r),(yle),(rwx))
call NIx((Ixx),(i9v),(rwx),w,((yie[rwx])*1.))
else
call rzx((u2r),(yle),(rwx+1))
call Lvx((u2r),(Ih[((yle))]),(Ixx))
endif
endfunction
function u7r takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=yBe[oqx]
local integer rwx=yce[oqx]
local integer Ixx=yCe[oqx]
local real dix=(mFv[(MFo)])
local real dax=(mgv[(MFo)])
call u0r((oqx))
call Mdo(MFo)
call u6r(CMx,rwx,Ixx,dix,dax)
return true
endfunction
function u8r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real dix=(GetUnitX(C[((Ixx))]))
local real dax=(GetUnitY(C[((Ixx))]))
local integer oqx=uzr()
local integer MFo=Mvo()
local integer u9r
set yBe[oqx]=CMx
set yce[oqx]=rwx
set yCe[oqx]=Ixx
set u9r=yee[rwx]
set mAv[((MFo))]=((b6v*((.06)*1.))*1.)
set mNv[(MFo)]=((2*(Aqv[(u9r)]))*1.)
call Mro(MFo,'qSuB',.25)
set mCv[(MFo)]=XHx((function u7r))
set mWv[(MFo)]=(oqx)
call m8o(MFo,(Nlv[(u9r)])*4.)
call M9o(MFo,CMx)
call o6r(MFo,dix,dax,XYx(dix,dax))
return true
endfunction
function Uvr takes integer oqx returns nothing
set yje[oqx]=false
call rgx(yne)
endfunction
function Uer takes integer oqx returns nothing
if(yHe[oqx]>0)then
return
endif
if(yGe[oqx]!=Z)then
call oYx("FolderSummonPolarBear_StructSummon_Allocation_deallocCustom_confirm","call DebugEx(FolderSummonPolarBear_StructSummon.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",yVe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set yGe[oqx]=yGe[(w)]
set yGe[(w)]=oqx
call Uvr(oqx)
endfunction
function Uxr takes integer oqx returns nothing
set yHe[oqx]=yHe[oqx]-1
call Uer(oqx)
endfunction
function Uor takes nothing returns boolean
local integer rdx=(bv)
local integer u2r=(Vv[(rdx)])
local integer oqx=oPx(u2r,yde)
local integer CMx=yfe[oqx]
call Uxr((oqx))
call rix(u2r,yde)
call Rmx(u2r,yke)
call rix(CMx,yde)
call Rmx(CMx,yKe)
call LOr(N6,hAv,CMx)
return true
endfunction
function Urr takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=oPx((Vv[(rdx)]),yde)
call RXr(yDe[oqx])
return true
endfunction
function Uir takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer oqx=oPx(CMx,yde)
call u1r(oqx)
return true
endfunction
function Uar takes nothing returns nothing
set yke=XBx("FolderSummonPolarBear_StructSummon_Init: set FolderSummonPolarBear_StructSummon.BEAR_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSummonPolarBear_StructSummon.Event_Bear_Death)",VP,pI,function Uor)
set yKe=XBx("FolderSummonPolarBear_StructSummon_Init: set FolderSummonPolarBear_StructSummon.CASTER_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSummonPolarBear_StructSummon.Event_Caster_Death)",VP,pI,function Urr)
call meo(yxe,XBx("FolderSummonPolarBear_StructSummon_Init: call FolderSummonPolarBear_StructSummon.CALLBACK_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSummonPolarBear_StructSummon.Event_SpellEffect))",ah,pI,function Uir))
endfunction
function Unr takes nothing returns boolean
call meo(hAv,XBx("SummonPolarBear_Init: call SummonPolarBear.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SummonPolarBear.Event_SpellEffect))",ah,pI,function u8r))
call Uar()
return true
endfunction
function UVr takes nothing returns boolean
call FOr(function Unr,"SummonPolarBear_Init")
return true
endfunction
function UEr takes nothing returns boolean
call LZx('AArB',false)
set yle=Lzo('AArB')
set G6[(yle)]=(D6)
set j6[(yle)]=(1)
set sH[(yle)]=("Arctic Blink")
set Ih[(yle)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D007F)))),(((Oj))))))
set x6v[(yle)]=(4)
set xzv[(yle)]=("spell")
call LZo((yle),fH+(1),((9)*1.))
call LZo((yle),QH+(1),((40)*1.))
call LZo((yle),Lvv+(1),((800)*1.))
set Mnv[(yle)]=("ReplaceableTextures\\CommandButtons\\BTNBearBlink.blp")
set yLe[1]=30
return true
endfunction
function UXr takes nothing returns boolean
call VRx(qa,(function UEr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\ArcticBlink.page\\ArcticBlink.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function UOr takes nothing returns boolean
set yme=Vnx(yMe)
return true
endfunction
function URr takes integer oqx returns integer
set yse[oqx]=true
set ySe[oqx]=false
call rax(yme)
return oqx
endfunction
function UIr takes nothing returns integer
local integer oqx
if(ype==8190)then
call oYx("ArcticBlink_Allocation_allocCustom","call DebugEx(ArcticBlink.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",yMe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(yPe[(w)]==w)then
set yqe=yqe+1
set oqx=yqe
else
set oqx=yPe[(w)]
set yPe[(w)]=yPe[yPe[(w)]]
endif
set yPe[oqx]=Z
set yQe[oqx]=1
call URr(oqx)
return oqx
endfunction
function UAr takes integer oqx returns nothing
set yse[oqx]=false
call rgx(yme)
endfunction
function UNr takes integer oqx returns nothing
if(yQe[oqx]>0)then
return
endif
if(yPe[oqx]!=Z)then
call oYx("ArcticBlink_Allocation_deallocCustom_confirm","call DebugEx(ArcticBlink.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",yMe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set yPe[oqx]=yPe[(w)]
set yPe[(w)]=oqx
call UAr(oqx)
endfunction
function Ubr takes integer oqx returns nothing
set yQe[oqx]=yQe[oqx]-1
call UNr(oqx)
endfunction
function UBr takes integer CMx,integer Ixx returns boolean
return( not(Ixx==w))and( not(IsUnitAlly(C[(Ixx)],vx[((ze[(CMx)]))])))and( not(nIo(Ixx)))
endfunction
function Ucr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=yte[oqx]
local integer rwx=yTe[oqx]
local integer Ixx=yue[oqx]
call Ubr((oqx))
call Mdo(MFo)
if UBr(CMx,Ixx)then
call NIx((Ixx),(Xsv),(rwx),w,((yUe)*1.))
call nJo((CMx),(Ixx),((yLe[rwx])*1.),(true),(false))
endif
return true
endfunction
function UCr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer oqx=UIr()
local integer MFo=Mvo()
set yte[oqx]=CMx
set yTe[oqx]=rwx
set yue[oqx]=Ixx
call SetUnitPosition(C[((CMx))],(((GetUnitX(C[((Ixx))])))*1.),(((GetUnitY(C[((Ixx))])))*1.))
call OLr(CMx,Ixx)
set mNv[(MFo)]=((10.)*1.)
call Mro(MFo,'qArB',2.)
set mCv[(MFo)]=XHx((function Ucr))
call M9o(MFo,CMx)
set mWv[(MFo)]=(oqx)
call m8o(MFo,700.)
call M3o((MFo),(Ixx),.0,.0,.0,(null))
return true
endfunction
function Udr takes nothing returns boolean
call meo(yle,XBx("ArcticBlink_Init: call ArcticBlink.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ArcticBlink.Event_SpellEffect))",ah,pI,function UCr))
return true
endfunction
function UDr takes nothing returns boolean
call mvo(function Udr,"ArcticBlink_Init")
return true
endfunction
function Ufr takes nothing returns boolean
call LZx('ADev',false)
set ywe=Lzo('ADev')
set G6[(ywe)]=(D6)
set j6[(ywe)]=(1)
set sH[(ywe)]=("Devour")
set Ih[(ywe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0089)))),(((Oj))))))
set x6v[(ywe)]=(4)
set xzv[(ywe)]=("spell")
call LZo((ywe),fH+(1),(('x')*1.))
call LZo((ywe),Lvv+(1),(($96)*1.))
set Mnv[(ywe)]=("ReplaceableTextures\\CommandButtons\\BTNDevour.blp")
return true
endfunction
function UFr takes nothing returns boolean
call VRx(qa,(function Ufr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\Devour.page\\Devour.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Ugr takes nothing returns boolean
set yWe=Vnx(yye)
return true
endfunction
function UGr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
call DSx(((Ixx)),Oyv,1,(CMx))
return true
endfunction
function Uhr takes nothing returns boolean
call meo(ywe,XBx("Devour_Init: call Devour.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Devour.Event_SpellEffect))",ah,pI,function UGr))
return true
endfunction
function UHr takes nothing returns boolean
call mvo(function Uhr,"Devour_Init")
return true
endfunction
function Ujr takes nothing returns boolean
set yYe=WTx('BSuB',"Susanoo",'bSuB')
set avv[(yYe)]=(true)
set aev[(yYe)]=("ReplaceableTextures\\CommandButtons\\BTNHowlOfTerror.blp")
call lux(yYe,"Susanoo_page\\Susanoo_struct\\Buff.mdx","overhead",ri)
set SU=lYx()
call l_x(SU,Edv,.5)
call l_x(SU,nev,.35)
call l0x(((yYe)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,Edv,1)
call l_x(SU,nev,.6)
call l0x(((yYe)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,Edv,.5)
call l_x(SU,nev,.35)
call l0x(((yYe)),vc+(3),(SU))
return true
endfunction
function UJr takes nothing returns boolean
call LZx('ASus',false)
set yze=Lzo('ASus')
set G6[(yze)]=(C6)
set j6[(yze)]=(3)
set sH[(yze)]=("Susanoo")
set Ih[(yze)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D026D)))),(((Oj))))))
set x6v[(yze)]=(0)
set xzv[(yze)]=("spell")
call LZo((yze),fH+(1),((60)*1.))
call LZo((yze),QH+(1),(('n')*1.))
call LZo((yze),Lvv+(1),((750)*1.))
call LZo((yze),fH+(2),((60)*1.))
call LZo((yze),QH+(2),(($AA)*1.))
call LZo((yze),Lvv+(2),((750)*1.))
set Mnv[(yze)]=("ReplaceableTextures\\CommandButtons\\BTNHowlOfTerror.blp")
call ccr(yze,'FSa0',3,'VSa0','LPSa','LRSa')
set yZe[1]=.35
set yZe[2]=.45
set y_e[1]=.5
set y_e[2]=1
set y0e[1]=$C
set y0e[2]=$C
set y1e[1]=2
set y1e[2]=2
set y2e[1]=.35
set y2e[2]=.6
return true
endfunction
function Ukr takes nothing returns boolean
call VRx(Ma,(function Ujr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Susanoo.page\\Susanoo.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function UJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Susanoo.page\\Susanoo.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function UKr takes nothing returns boolean
set y3e=Vnx(y4e)
return true
endfunction
function Ulr takes integer oqx,integer Iox returns integer
return oPx((oqx),zb+Iox)
endfunction
function ULr takes integer oqx,integer Iox,real ilx returns nothing
local integer rkx=oqx
local integer ibx
set oqx=(Ifx(E[((X))],(dd),(((rkx))),((Iox)),((Ulr((oqx),Iox))),(w)))
set ibx=Jd[oqx]
call A9x((rkx),Iox)
set ilx=ilx+(TimerGetRemaining(Oe[(ibx)]))
call icx(ibx,ilx,false,function Nox)
if not(wd[(Iox)])then
if(I6x(rkx,yd)or(Yd[(Iox)]))then
call NOx((rkx),Iox,ilx)
endif
endif
endfunction
function Umr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(FG[(rdx)])
local integer oqx=Ixx
local real UMr=y6e[oqx]
set y6e[oqx]=UMr*(1.+y7e)
call RUx((Abx((Ixx),(y8e),(y9e),(Bi))))
call ULr(Ixx,yYe,UMr)
return true
endfunction
function Upr takes integer oqx,real oSx returns nothing
set I8v[(oqx)]=(((I8v[(oqx)])+oSx)*1.)
endfunction
function UPr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local real Uqr
local integer oqx
call mFo((mHo((((GetUnitX(C[((Ixx))])))*1.),(((GetUnitY(C[((Ixx))])))*1.),(Yve),(ri))))
set Uqr=yZe[rwx]
set oqx=Ixx
set Yee[oqx]=Uqr
set y6e[oqx]=y1e[rwx]
call Upr(Ixx,Uqr)
call I7x(Ixx,y5e)
return true
endfunction
function UQr takes integer oqx,real oSx returns nothing
set I8v[(oqx)]=(((I8v[(oqx)])-oSx)*1.)
endfunction
function Usr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local real Uqr=Yee[oqx]
call UQr(Ixx,Uqr)
call Rmx(Ixx,y5e)
return true
endfunction
function USr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Mv[(rdx)])
call NIx(((Vv[(rdx)])),(yYe),(rwx),w,((y0e[rwx])*1.))
return true
endfunction
function Utr takes nothing returns boolean
set y5e=XBx("Susanoo_Init: set Susanoo.DEATH_EVENT = Event.Create(UNIT.Death.Events.KILLER_EVENT_TYPE, EventPriority.SPELLS, function Susanoo.Event_Death)",Bkv,pI,function Umr)
call l9x(yYe,XBx("Susanoo_Init: call Susanoo.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Susanoo.Event_BuffGain))",Bd,pI,function UPr))
call l9x(yYe,XBx("Susanoo_Init: call Susanoo.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Susanoo.Event_BuffLose))",Jc,pI,function Usr))
call meo(yze,XBx("Susanoo_Init: call Susanoo.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Susanoo.Event_SpellEffect))",ah,pI,function USr))
return true
endfunction
function UTr takes nothing returns boolean
call FOr(function Utr,"Susanoo_Init")
return true
endfunction
function Uur takes nothing returns boolean
set sJ[1]=WTx('BSW1',"Swiftness 1",'bSW1')
set avv[(sJ[1])]=(true)
set aev[(sJ[1])]=("ReplaceableTextures\\CommandButtons\\BTNBuff1.blp")
call lux(sJ[1],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)
call lux(sJ[1],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)
call lux(sJ[1],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)
call lux(sJ[1],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)
return true
endfunction
function UUr takes nothing returns boolean
set Yxe[1]=35
set Yxe[2]=60
set Yxe[3]=85
set Yxe[4]='n'
set Yxe[5]=$87
set Yxe[6]=$A0
set Yoe[1]=5
set Yoe[2]=8
set Yoe[3]=8
set Yoe[4]=8
set Yoe[5]=8
set Yoe[6]=8
return true
endfunction
function Uwr takes nothing returns boolean
set qJ=lQx(Yre+" (timerBuff)")
return true
endfunction
function UWr takes nothing returns boolean
set sJ[2]=WTx('BSW2',"Swiftness 2",'bSW2')
set avv[(sJ[2])]=(true)
set aev[(sJ[2])]=("ReplaceableTextures\\CommandButtons\\BTNBuff2.blp")
call lux(sJ[2],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)
call lux(sJ[2],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)
call lux(sJ[2],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)
call lux(sJ[2],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)
return true
endfunction
function Uyr takes nothing returns boolean
set sJ[3]=WTx('BSW3',"Swiftness 3",'bSW3')
set avv[(sJ[3])]=(true)
set aev[(sJ[3])]=("ReplaceableTextures\\CommandButtons\\BTNBuff3.blp")
call lux(sJ[3],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)
call lux(sJ[3],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)
call lux(sJ[3],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)
call lux(sJ[3],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)
return true
endfunction
function UYr takes nothing returns boolean
call VRx(Ma,(function Uur),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Swiftness.page\\Swiftness.struct\\obj_ChargeBuff[1]_wc3buff.j"))
call VRx(ea,(function UUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Swiftness.page\\Swiftness.struct\\obj_this_wc3obj.j"))
call VRx(Ma,(function Uwr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Swiftness.page\\Swiftness.struct\\obj_timerBuff_wc3buff.j"))
call VRx(Ma,(function UWr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Swiftness.page\\Swiftness.struct\\obj_ChargeBuff[2]_wc3buff.j"))
call VRx(Ma,(function Uyr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Swiftness.page\\Swiftness.struct\\obj_ChargeBuff[3]_wc3buff.j"))
return true
endfunction
function Uzr takes nothing returns boolean
set Yie=Vnx(Yre)
return true
endfunction
function UZr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
local integer o7x=QJ[oqx]
call Ayx(Ixx,sJ[o7x])
set QJ[oqx]=o7x-1
if(o7x==1)then
call Ayx(Ixx,qJ)
endif
endfunction
function U_r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=inx()
set Yae[oqx]=p0x
set ge[(p0x)]=(oqx)
call icx(p0x,Yoe[1],true,function UZr)
return true
endfunction
function U0r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer o7x=QJ[oqx]
local integer p0x=Yae[oqx]
call ijx(p0x)
loop
exitwhen(o7x<1)
call Ayx(Ixx,sJ[o7x])
set o7x=o7x-1
endloop
return true
endfunction
function U1r takes nothing returns boolean
call l9x(qJ,XBx("Swiftness_Init: call Swiftness.TIMER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Swiftness.Event_Timer_BuffGain))",Bd,pI,function U_r))
call l9x(qJ,XBx("Swiftness_Init: call Swiftness.TIMER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Swiftness.Event_Timer_BuffLose))",Jc,pI,function U0r))
return true
endfunction
function U2r takes nothing returns boolean
call FOr(function U1r,"Swiftness_Init")
return true
endfunction
function U3r takes nothing returns boolean
set Yne[1]=.25
set Yne[2]=.4
set Yne[3]=.65
set Yne[4]=.8
set Yne[5]=.95
set Yne[6]=1.1
return true
endfunction
function U4r takes nothing returns boolean
set YVe=WTx('BCrA',"Tempest Strike",'bCrA')
set avv[(YVe)]=(true)
set qU[(YVe)]=(true)
set aev[(YVe)]=("ReplaceableTextures\\CommandButtons\\BTNCleavingAttack.blp")
call lux(YVe,"TempestStrike_page\\TempestStrike_struct\\CriticalAttacks\\Buff.mdx","weapon",ri)
call lux(YVe,"Abilities\\Weapons\\IllidanMissile\\IllidanMissile.mdl","weapon",ri)
set SU=lYx()
call l_x(SU,nev,.25)
call l0x(((YVe)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,nev,.4)
call l0x(((YVe)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,nev,.65)
call l0x(((YVe)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,nev,.8)
call l0x(((YVe)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,nev,.95)
call l0x(((YVe)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,nev,1.1)
call l0x(((YVe)),vc+(6),(SU))
return true
endfunction
function U5r takes nothing returns boolean
call VRx(ea,(function U3r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\TempestStrike.page\\TempestStrike.struct\\CriticalAttacks\\obj_this_wc3obj.j"))
call VRx(Ma,(function U4r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\TempestStrike.page\\TempestStrike.struct\\CriticalAttacks\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function U6r takes nothing returns boolean
set YEe=Vnx(YXe)
return true
endfunction
function U7r takes nothing returns boolean
set YOe=lQx(YRe+" (dummyBuff)")
call lux(YOe,"Abilities\\Weapons\\PhoenixMissile\\Phoenix_Missile_mini.mdl","origin",Bi)
call lux(YOe,"TempestStrike_page\\TempestStrike_struct\\Hurricanwave3.mdx","origin",ri)
set SU=lYx()
call vOr(SU,DVv,true)
call vOr(SU,Dkv,true)
call l0x(((YOe)),vc+(1),(SU))
set SU=lYx()
call vOr(SU,DVv,true)
call vOr(SU,Dkv,true)
call l0x(((YOe)),vc+(2),(SU))
set SU=lYx()
call vOr(SU,DVv,true)
call vOr(SU,Dkv,true)
call l0x(((YOe)),vc+(3),(SU))
set SU=lYx()
call vOr(SU,DVv,true)
call vOr(SU,Dkv,true)
call l0x(((YOe)),vc+(4),(SU))
set SU=lYx()
call vOr(SU,DVv,true)
call vOr(SU,Dkv,true)
call l0x(((YOe)),vc+(5),(SU))
set SU=lYx()
call vOr(SU,DVv,true)
call vOr(SU,Dkv,true)
call l0x(((YOe)),vc+(6),(SU))
return true
endfunction
function U8r takes nothing returns boolean
call LZx('ATeS',false)
set GBv=Lzo('ATeS')
set G6[(GBv)]=(i6)
set j6[(GBv)]=(6)
set sH[(GBv)]=("Tempest Strike")
set Ih[(GBv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0089)))),(((Oj))))))
set x6v[(GBv)]=(2)
set xzv[(GBv)]=("spell")
call LZo((GBv),u6v+(1),((90)*1.))
call LZo((GBv),fH+(1),(($A)*1.))
call LZo((GBv),QH+(1),((70)*1.))
call LZo((GBv),Lvv+(1),((99999)*1.))
call LZo((GBv),u6v+(2),((90)*1.))
call LZo((GBv),fH+(2),(($A)*1.))
call LZo((GBv),QH+(2),((85)*1.))
call LZo((GBv),Lvv+(2),((99999)*1.))
call LZo((GBv),u6v+(3),((90)*1.))
call LZo((GBv),fH+(3),(($A)*1.))
call LZo((GBv),QH+(3),(('d')*1.))
call LZo((GBv),Lvv+(3),((99999)*1.))
call LZo((GBv),u6v+(4),((90)*1.))
call LZo((GBv),fH+(4),(($A)*1.))
call LZo((GBv),QH+(4),(('s')*1.))
call LZo((GBv),Lvv+(4),((99999)*1.))
call LZo((GBv),u6v+(5),((90)*1.))
call LZo((GBv),fH+(5),(($A)*1.))
call LZo((GBv),QH+(5),(($82)*1.))
call LZo((GBv),Lvv+(5),((99999)*1.))
call LZo((GBv),u6v+(6),((90)*1.))
call LZo((GBv),fH+(6),(($A)*1.))
call LZo((GBv),QH+(6),(($91)*1.))
call LZo((GBv),Lvv+(6),((99999)*1.))
set Mnv[(GBv)]=("ReplaceableTextures\\CommandButtons\\BTNCleavingAttack.blp")
call ccr(GBv,'FTe0',6,'VTe0','LPTe','LRTe')
set YIe[1]=30
set YIe[2]=60
set YIe[3]=90
set YIe[4]='x'
set YIe[5]=$96
set YIe[6]=$B4
return true
endfunction
function U9r takes nothing returns boolean
call VRx(Ma,(function U7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\TempestStrike.page\\TempestStrike.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function U8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\TempestStrike.page\\TempestStrike.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function wvr takes nothing returns boolean
set YAe=Vnx(YRe)
return true
endfunction
function wer takes nothing returns boolean
local integer Ixx=jFx()
if(I5x((OPe),Rb,(Ixx)))then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function wxr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=oqx
local integer Q7o=YCe[oqx]
local integer Ixx
local real NIo
call SetUnitAnimationByIndex(C[((CMx))],(0))
set OPe=Q7o
set Hf=(ze[(CMx)])
call Nio(YNe,(GetUnitX(C[((CMx))])),(GetUnitY(C[((CMx))])),(Cpx((GBv),u6v+(Yce[oqx]))),Ybe)
set Ixx=Nao(YNe)
if(Ixx!=w)then
set NIo=YBe[oqx]
loop
call Abx((Ixx),(Yhe),(YHe),(Bi))
call dpx(Q7o,Ixx)
call nJo((CMx),(Ixx),((NIo)*1.),(false),(true))
set Ixx=Nao(YNe)
exitwhen(Ixx==w)
endloop
endif
endfunction
function wor takes nothing returns boolean
local integer rdx=(bv)
local integer nqr=(mc[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer Q6o=inx()
local real dix
local real dax
set YBe[oqx]=YIe[rwx]
set Yce[oqx]=rwx
set YCe[oqx]=JIx("TempestStrike_Event_BuffGain: set this.targetGroup = UnitList.Create()")
set Yde[oqx]=Q6o
set ge[(Q6o)]=(oqx)
set dix=(UH[(nqr)])
set dax=(wH[(nqr)])
call pKo((Abx((Ixx),(YDe),(YDe),(Bi))),Yfe)
set Yfe=NWr("dur",Yfe)
set YFe=NWr("length",YFe)
set Yge=NWr("speedEnd",Yge)
call OSr(Ixx,2.*YFe*1./ Yfe-Yge,2.*1./ Yfe*(Yge-YFe*1./ Yfe),(Atan2(((dax-(GetUnitY(C[((Ixx))])))*1.),((dix-(GetUnitX(C[((Ixx))])))*1.))),Yfe)
call icx(Q6o,YGe,true,function wxr)
call Dnx((Ixx),(SIv))
return true
endfunction
function wrr takes integer rwx,integer Ixx returns nothing
call NIx((Ixx),(YVe),(rwx),w,((Yje)*1.))
endfunction
function wir takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer rwx=Yce[oqx]
local integer Q7o=YCe[oqx]
local integer Q6o=Yde[oqx]
local boolean war=((Otx((Q7o),Rb))!=w)
call XYr(Q7o)
call ijx(Q6o)
call QueueUnitAnimation(C[((Ixx))],("stand"))
if war then
call wrr(rwx,Ixx)
endif
return true
endfunction
function wnr takes nothing returns boolean
local integer rdx=(bv)
call NIx((Vv[(rdx)]),YOe,(Mv[(rdx)]),rdx,Yfe)
return true
endfunction
function wVr takes nothing returns nothing
endfunction
function wEr takes nothing returns boolean
set YNe=O2x()
set Ybe=XLx(function wer)
call l9x(YOe,XBx("TempestStrike_Init: call TempestStrike.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TempestStrike.Event_BuffGain))",Bd,pI,function wor))
call l9x(YOe,XBx("TempestStrike_Init: call TempestStrike.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TempestStrike.Event_BuffLose))",Jc,pI,function wir))
call meo(GBv,XBx("TempestStrike_Init: call TempestStrike.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TempestStrike.Event_SpellEffect))",ah,pI,function wnr))
call wVr()
return true
endfunction
function wXr takes nothing returns boolean
call FOr(function wEr,"TempestStrike_Init")
return true
endfunction
function wOr takes nothing returns boolean
return true
endfunction
function wRr takes nothing returns boolean
set YJe=Vnx(Yke)
return true
endfunction
function wIr takes nothing returns boolean
call LZx('ATsR',false)
set YKe=Lzo('ATsR')
set G6[(YKe)]=(C6)
set j6[(YKe)]=(3)
set sH[(YKe)]=("Relocate")
set Ih[(YKe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0085)))),(((Oj))))))
set x6v[(YKe)]=(2)
set xzv[(YKe)]=("spell")
call LZo((YKe),fH+(1),((0)*1.))
call LZo((YKe),QH+(1),((0)*1.))
call LZo((YKe),Lvv+(1),((99999)*1.))
call LZo((YKe),fH+(2),((0)*1.))
call LZo((YKe),QH+(2),((0)*1.))
call LZo((YKe),Lvv+(2),((99999)*1.))
set Mnv[(YKe)]=("ReplaceableTextures\\CommandButtons\\BTNUndeadUnLoad.blp")
call ccr(YKe,'FTR0',3,'VTR0','LPTR','LRTR')
return true
endfunction
function wAr takes nothing returns boolean
call VRx(qa,(function wIr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Tsukuyomi.page\\Tsukuyomi.struct\\Relocate\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function wNr takes nothing returns boolean
set Yle=Vnx(YLe)
return true
endfunction
function wbr takes nothing returns boolean
set Yme=lQx(YMe+" (dummyBuff)")
set qc[(Yme)]=(true)
return true
endfunction
function wBr takes nothing returns boolean
call VRx(Ma,(function wbr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Tsukuyomi.page\\Tsukuyomi.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function wcr takes nothing returns boolean
set Ype=Vnx(YMe)
return true
endfunction
function wCr takes nothing returns boolean
set YPe=lQx(Yqe+" (dummyBuff)")
return true
endfunction
function wdr takes nothing returns boolean
call LZx('ATsu',false)
set lle=Lzo('ATsu')
set G6[(lle)]=(C6)
set j6[(lle)]=(3)
set sH[(lle)]=("Tsukuyomi")
set Ih[(lle)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0206)))),(((Oj))))))
set x6v[(lle)]=(2)
set xzv[(lle)]=("spell")
call LZo((lle),u6v+(1),((275)*1.))
call LZo((lle),fH+(1),((80)*1.))
call LZo((lle),QH+(1),(($C8)*1.))
call LZo((lle),Lvv+(1),((900)*1.))
call LZo((lle),u6v+(2),((350)*1.))
call LZo((lle),fH+(2),((80)*1.))
call LZo((lle),QH+(2),((300)*1.))
call LZo((lle),Lvv+(2),((900)*1.))
set Mnv[(lle)]=("ReplaceableTextures\\CommandButtons\\BTNBanish.blp")
call ccr(lle,'FTs0',3,'VTs0','LPTs','LRTs')
set YQe[1]=$F
set YQe[2]=20
set Yse[1]=.35
set Yse[2]=.45
set YSe[1]=$A
set YSe[2]=20
return true
endfunction
function wDr takes nothing returns boolean
call VRx(Ma,(function wCr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Tsukuyomi.page\\Tsukuyomi.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function wdr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Tsukuyomi.page\\Tsukuyomi.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function wfr takes nothing returns boolean
set Yte=Vnx(Yqe)
return true
endfunction
function wFr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function wgr takes integer oqx returns boolean
set zW=zW+1
set YW[zW]=oqx
set yW[oqx]=zW+1
return(zW==0)
endfunction
function wGr takes nothing returns nothing
local integer olx=zW
local integer oqx
local real C6x
local real C7x
local real Mqo
local integer Ixx
local real D7x
loop
set oqx=YW[olx]
set C6x=Y6e[oqx]
set C7x=Y7e[oqx]
set Mqo=Y8e[oqx]
set Ixx=vy[oqx]
if Y9e[oqx]then
set D7x=(ly[(Ixx)])
set C6x=C6x*D7x
set C7x=C7x*D7x
set Mqo=Mqo*D7x
endif
call Mko((oqx),(GetUnitX(zj[((Ixx))]))+C6x,(GetUnitY(zj[((Ixx))]))+C7x,(Vu[(Ixx)])+Mqo)
set olx=olx-1
exitwhen(olx<0)
endloop
endfunction
function whr takes integer oqx,integer Ixx,boolean Omx,real C6x,real C7x,real Mqo returns nothing
set Y6e[oqx]=C6x
set Y7e[oqx]=C7x
set Y8e[oqx]=Mqo
set vy[oqx]=Ixx
set Y9e[oqx]=Omx
call Mxx((oqx),UW)
if wgr(oqx)then
call icx(ZW,zve,true,function wGr)
endif
endfunction
function wHr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=oqx
local integer wjr=Yye[oqx]
local real x=(GetUnitX(zj[((wjr))]))
local real y=(GetUnitY(zj[((wjr))]))
local integer C0o=(ze[(CMx)])
local integer Ixx
local real wJr
local real wkr
local real wKr
set Hf=C0o
call Nio(YTe,x,y,(vme[(YWe[oqx])]),Yue)
set Ixx=Nao(YTe)
if(Ixx!=w)then
set wJr=Y0e[oqx]
set wkr=.0
set wKr=Y1e[oqx]
loop
call HKr(Ixx,(NLv[(Ixx)])*wJr,(Atan2(((y-(GetUnitY(C[((Ixx))])))*1.),((x-(GetUnitX(C[((Ixx))])))*1.))),zxe)
if(IsUnitAlly(C[(Ixx)],vx[(C0o)]))then
call Ybo(Ixx,wKr)
else
set Y1e[oqx]=itx((LF[(Ixx)]),wKr)
call YBo(CMx,Ixx,Y1e[oqx])
set wkr=wkr+Y1e[oqx]
endif
set Ixx=Nao(YTe)
exitwhen(Ixx==w)
endloop
if(wkr>.0)then
call mro(CMx,CMx,wkr*zoe)
endif
endif
endfunction
function wlr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local real dix=YUe
local real dax=Ywe
local real Mpx=XYx(dix,dax)
local real O1o=(Cpx((lle),u6v+(rwx)))
local integer oqx=Ixx
local integer XSr=Xpr(Ixx)
local integer HOx=mcx('qTsu',dix,dax,Mpx-80.,.0)
local integer Pyr=mcx('qTs2',dix,dax,Mpx+150.,.0)
local integer p0x=inx()
local integer wjr=mcx('qTsP',dix,dax,Mpx,.0)
set YWe[oqx]=XSr
set Yye[oqx]=HOx
set YYe[oqx]=Pyr
set Yze[oqx]=p0x
set YZe[oqx]=rwx
set Y_e[oqx]=wjr
set Y0e[oqx]=Yse[rwx]
set Y1e[oqx]=YSe[rwx]
set Y2e[oqx]=dix
set Y3e[oqx]=dax
set Eee[(XSr)]=(oqx)
set ge[(p0x)]=(oqx)
set vme[(XSr)]=((O1o)*1.)
set vMe[(XSr)]=(Yue)
call XPr(XSr,Y4e)
call XPr(XSr,Y5e)
call XQr(XSr)
call whr(HOx,wjr,false,.0,.0,-80.)
call mbx(HOx,.0)
call oYr(HOx,O1o*5*1./(3*128.),.25)
call whr(Pyr,wjr,false,.0,.0,150.)
call mbx(Pyr,.0)
call oYr(Pyr,O1o*8*1./(3*128.),.25)
if((uf[(Ixx)])==Ggv)then
call mBx(HOx,.0,200.,255.,200.)
call mBx(Pyr,.0,200.,200.,255.)
elseif((uf[(Ixx)])==g1v)then
call mBx(HOx,255.,255.,255.,200.)
elseif((uf[(Ixx)])==gwv)then
call mBx(HOx,63.,255.,.0,200.)
call mBx(Pyr,63.,255.,.0,255.)
endif
call SetUnitMoveSpeed(zj[(wjr)],((zee)*1.))
call SetUnitPropWindow(zj[(wjr)],((1.)*1.))
call SetUnitTurnSpeed(zj[(wjr)],((df)*1.))
call icx(p0x,zxe,true,function wHr)
call Obo(YKe,Ixx)
return true
endfunction
function wLr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer XSr=YWe[oqx]
local integer HOx=Yye[oqx]
local integer Pyr=YYe[oqx]
local integer p0x=Yze[oqx]
call X2r(XSr)
call MCx(HOx)
call Mfx(Pyr)
call ijx(p0x)
call Obo(lle,Ixx)
return true
endfunction
function wmr takes integer oqx returns integer
set zVe[oqx]=true
set zEe[oqx]=false
call rax(YJe)
return oqx
endfunction
function wMr takes nothing returns integer
local integer oqx
if(zre==8190)then
call oYx("FolderTsukuyomi_StructMissile_Allocation_allocCustom","call DebugEx(FolderTsukuyomi_StructMissile.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Yke+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(zie[(w)]==w)then
set zae=zae+1
set oqx=zae
else
set oqx=zie[(w)]
set zie[(w)]=zie[zie[(w)]]
endif
set zie[oqx]=Z
set zne[oqx]=1
call wmr(oqx)
return oqx
endfunction
function wpr takes integer oqx returns nothing
set zVe[oqx]=false
call rgx(YJe)
endfunction
function wPr takes integer oqx returns nothing
if(zne[oqx]>0)then
return
endif
if(zie[oqx]!=Z)then
call oYx("FolderTsukuyomi_StructMissile_Allocation_deallocCustom_confirm","call DebugEx(FolderTsukuyomi_StructMissile.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Yke+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set zie[oqx]=zie[(w)]
set zie[(w)]=oqx
call wpr(oqx)
endfunction
function wqr takes integer oqx returns nothing
set zne[oqx]=zne[oqx]-1
call wPr(oqx)
endfunction
function wQr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=zXe[oqx]
local integer rwx=zOe[oqx]
local real dix=zRe[oqx]
local real dax=zIe[oqx]
call wqr((oqx))
call Mdo(MFo)
set YUe=dix
set Ywe=dax
call NIx((CMx),(YPe),(rwx),w,((YQe[rwx])*1.))
return true
endfunction
function wsr takes integer CMx,integer rwx,real dix,real dax returns nothing
local integer oqx=wMr()
local integer MFo=Mvo()
set zXe[oqx]=CMx
set zOe[oqx]=rwx
set zRe[oqx]=dix
set zIe[oqx]=dax
call m1o(MFo,2000.)
set mAv[((MFo))]=((b6v*((.2)*1.))*1.)
set mNv[(MFo)]=((48.)*1.)
call Mro(MFo,'qTsM',1.)
set mCv[(MFo)]=XHx((function wQr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,500.)
call M9o(MFo,CMx)
call o6r(MFo,dix,dax,XYx(dix,dax))
endfunction
function wSr takes nothing returns boolean
local integer rdx=(bv)
call wsr((Vv[(rdx)]),(Mv[(rdx)]),(UH[(rdx)]),(wH[(rdx)]))
return true
endfunction
function wtr takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer rkx=(Eee[(XSr)])
call UJx(Ixx,Yme)
return true
endfunction
function wTr takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer CMx=(vhe[(XSr)])
local integer rkx=(Eee[(XSr)])
local integer rwx=YZe[rkx]
call DSx((Ixx),(Yme),(rwx),w)
return true
endfunction
function wur takes nothing returns nothing
set Y4e=XBx("FolderTsukuyomi_StructTarget_Init: set FolderTsukuyomi_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderTsukuyomi_StructTarget.Event_Ending)",vQe,pI,function wtr)
set Y5e=XBx("FolderTsukuyomi_StructTarget_Init: set FolderTsukuyomi_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderTsukuyomi_StructTarget.Event_Start)",vse,pI,function wTr)
call W_x(ENv,Yme)
endfunction
function wUr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local integer rkx=CMx
call IssuePointOrderById(zj[((Y_e[rkx]))],Pb[(ch)],((dix)*1.),((dax)*1.))
return true
endfunction
function wwr takes nothing returns boolean
local integer olx
set YTe=O2x()
set Yue=XLx(function wFr)
call l9x(YPe,XBx("Tsukuyomi_Init: call Tsukuyomi.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Tsukuyomi.Event_BuffGain))",Bd,pI,function wlr))
call l9x(YPe,XBx("Tsukuyomi_Init: call Tsukuyomi.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Tsukuyomi.Event_BuffLose))",Jc,pI,function wLr))
call meo(lle,XBx("Tsukuyomi_Init: call Tsukuyomi.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Tsukuyomi.Event_SpellEffect))",ah,pI,function wSr))
set olx=(j6[(lle)])
loop
set YSe[olx]=YSe[olx]*zxe
set olx=olx-1
exitwhen(olx<1)
endloop
call wur()
call meo(YKe,XBx("FolderTsukuyomi_StructRelocate_Init: call FolderTsukuyomi_StructRelocate.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderTsukuyomi_StructRelocate.Event_SpellEffect))",ah,pI,function wUr))
return true
endfunction
function wWr takes nothing returns boolean
call FOr(function wwr,"Tsukuyomi_Init")
return true
endfunction
function wyr takes nothing returns boolean
return true
endfunction
function wYr takes nothing returns boolean
set zAe=Vnx(zNe)
return true
endfunction
function wzr takes nothing returns boolean
set zbe[1]=-3
set zbe[2]=-5
set zbe[3]=-7
set zbe[4]=-9
set zbe[5]=-$B
set zbe[6]=-$D
set zBe[1]=2
set zBe[2]=3
set zBe[3]=4
set zBe[4]=5
set zBe[5]=6
set zBe[6]=7
set zce[1]=-.4
set zce[2]=-.4
set zce[3]=-.4
set zce[4]=-.4
set zce[5]=-.4
set zce[6]=-.4
set zCe[1]=2
set zCe[2]=3
set zCe[3]=4
set zCe[4]=5
set zCe[5]=6
set zCe[6]=7
set zde[1]=30
set zde[2]=60
set zde[3]=90
set zde[4]='x'
set zde[5]=$96
set zde[6]=$B4
return true
endfunction
function wZr takes nothing returns boolean
set zDe=WTx('BWSh',"Wan Shroud",'bWSh')
set qc[(zDe)]=(true)
set aev[(zDe)]=("ReplaceableTextures\\CommandButtons\\BTNCyclone.blp")
set SU=lYx()
call l_x(SU,dnv,-3)
call l_x(SU,crv,30)
call l_x(SU,ZU,-.4)
call l0x(((zDe)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,dnv,-5)
call l_x(SU,crv,60)
call l_x(SU,ZU,-.4)
call l0x(((zDe)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,dnv,-7)
call l_x(SU,crv,90)
call l_x(SU,ZU,-.4)
call l0x(((zDe)),vc+(3),(SU))
set SU=lYx()
call l_x(SU,dnv,-9)
call l_x(SU,crv,'x')
call l_x(SU,ZU,-.4)
call l0x(((zDe)),vc+(4),(SU))
set SU=lYx()
call l_x(SU,dnv,-$B)
call l_x(SU,crv,$96)
call l_x(SU,ZU,-.4)
call l0x(((zDe)),vc+(5),(SU))
set SU=lYx()
call l_x(SU,dnv,-$D)
call l_x(SU,crv,$B4)
call l_x(SU,ZU,-.4)
call l0x(((zDe)),vc+(6),(SU))
return true
endfunction
function w_r takes nothing returns boolean
call VRx(ea,(function wzr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WanShroud.page\\WanShroud.struct\\Target\\obj_this_wc3obj.j"))
call VRx(Ma,(function wZr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WanShroud.page\\WanShroud.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function w0r takes nothing returns boolean
set zfe=Vnx(zFe)
return true
endfunction
function w1r takes nothing returns boolean
call LZx('AWSh',false)
set gMv=Lzo('AWSh')
set G6[(gMv)]=(N6)
set j6[(gMv)]=(6)
set sH[(gMv)]=("Wan Shroud")
set Ih[(gMv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0206)))),(((Oj))))))
set x6v[(gMv)]=(2)
set xzv[(gMv)]=("spell,channel")
call LZo((gMv),u6v+(1),(($F0)*1.))
call LZo((gMv),fH+(1),((17)*1.))
call LZo((gMv),QH+(1),(('x')*1.))
call LZo((gMv),Lvv+(1),((900)*1.))
call LZo((gMv),u6v+(2),((260)*1.))
call LZo((gMv),fH+(2),((17)*1.))
call LZo((gMv),QH+(2),(($87)*1.))
call LZo((gMv),Lvv+(2),((900)*1.))
call LZo((gMv),u6v+(3),((280)*1.))
call LZo((gMv),fH+(3),((17)*1.))
call LZo((gMv),QH+(3),(($96)*1.))
call LZo((gMv),Lvv+(3),((900)*1.))
call LZo((gMv),u6v+(4),((300)*1.))
call LZo((gMv),fH+(4),((17)*1.))
call LZo((gMv),QH+(4),(($A5)*1.))
call LZo((gMv),Lvv+(4),((900)*1.))
call LZo((gMv),u6v+(5),((320)*1.))
call LZo((gMv),fH+(5),((17)*1.))
call LZo((gMv),QH+(5),(($B4)*1.))
call LZo((gMv),Lvv+(5),((900)*1.))
call LZo((gMv),u6v+(6),((340)*1.))
call LZo((gMv),fH+(6),((17)*1.))
call LZo((gMv),QH+(6),(($C3)*1.))
call LZo((gMv),Lvv+(6),((900)*1.))
set Mnv[(gMv)]=("ReplaceableTextures\\CommandButtons\\BTNCyclone.blp")
call ccr(gMv,'FWS0',6,'VWS0','LPWS','LRWS')
set zge[1]=$A
set zge[2]=$A
set zge[3]=$A
set zge[4]=$A
set zge[5]=$A
set zge[6]=$A
set zGe[1]=3
set zGe[2]=5
set zGe[3]=7
set zGe[4]=9
set zGe[5]=$B
set zGe[6]=$D
return true
endfunction
function w2r takes nothing returns boolean
call VRx(qa,(function w1r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WanShroud.page\\WanShroud.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function w3r takes nothing returns boolean
set zhe=Vnx(zHe)
return true
endfunction
function w4r takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if not I6x(Ixx,INv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function w5r takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if nBo(Ixx)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
if nIo(Ixx)then
return false
endif
return true
return true
endfunction
function w6r takes integer oqx returns integer
set zme[oqx]=true
set zMe[oqx]=false
call rax(zAe)
return oqx
endfunction
function w7r takes nothing returns integer
local integer oqx
if(zke==8190)then
call oYx("FolderWanShroud_StructMissile_Allocation_allocCustom","call DebugEx(FolderWanShroud_StructMissile.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",zNe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(zKe[(w)]==w)then
set zle=zle+1
set oqx=zle
else
set oqx=zKe[(w)]
set zKe[(w)]=zKe[zKe[(w)]]
endif
set zKe[oqx]=Z
set zLe[oqx]=1
call w6r(oqx)
return oqx
endfunction
function w8r takes integer oqx returns nothing
set zme[oqx]=false
call rgx(zAe)
endfunction
function w9r takes integer oqx returns nothing
if(zLe[oqx]>0)then
return
endif
if(zKe[oqx]!=Z)then
call oYx("FolderWanShroud_StructMissile_Allocation_deallocCustom_confirm","call DebugEx(FolderWanShroud_StructMissile.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",zNe+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set zKe[oqx]=zKe[(w)]
set zKe[(w)]=oqx
call w8r(oqx)
endfunction
function Wvr takes integer oqx returns nothing
set zLe[oqx]=zLe[oqx]-1
call w9r(oqx)
endfunction
function Wer takes integer oqx returns integer
set zue[oqx]=true
set zUe[oqx]=false
call rax(zhe)
return oqx
endfunction
function Wxr takes nothing returns integer
local integer oqx
if(zse==8190)then
call oYx("WanShroud_Allocation_allocCustom","call DebugEx(WanShroud.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",zHe+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(zSe[(w)]==w)then
set zte=zte+1
set oqx=zte
else
set oqx=zSe[(w)]
set zSe[(w)]=zSe[zSe[(w)]]
endif
set zSe[oqx]=Z
set zTe[oqx]=1
call Wer(oqx)
return oqx
endfunction
function Wor takes nothing returns boolean
local integer rdx=(bv)
local integer oqx=(mj[(rdx)])
local integer Ixx=(Vv[(rdx)])
call RUx((Abx((Ixx),(z5e),(z6e),(ri))))
call nJo((zye[oqx]),(Ixx),((zYe[oqx])*1.),(true),(false))
return true
endfunction
function Wrr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
call DDx((vLe[(zWe[oqx])]),function Wor,oqx)
endfunction
function Wir takes nothing returns nothing
local integer ibx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer oqx=(ge[(ibx)])
local integer XSr=zWe[oqx]
local integer t0r=zwe[oqx]
local integer p0x=zZe[oqx]
call Mfx(t0r)
call X2r(XSr)
call ijx(ibx)
call ijx(p0x)
endfunction
function War takes integer CMx,integer rwx,real dix,real dax returns nothing
local real O1o=(Cpx((gMv),u6v+(rwx)))
local real Mpx=XYx(dix,dax)
local integer oqx=Wxr()
local integer t0r=mcx('qWSh',dix,dax,Mpx,.0)
local integer XSr=Xpr(CMx)
local integer ibx=inx()
local integer p0x=inx()
set zwe[oqx]=t0r
set zWe[oqx]=XSr
set zye[oqx]=CMx
set zYe[oqx]=zze[rwx]
set zZe[oqx]=p0x
set z_e[oqx]=rwx
set z0e[oqx]=dix
set z1e[oqx]=dax
set Eee[(XSr)]=(oqx)
set ge[(ibx)]=(oqx)
set ge[(p0x)]=(oqx)
call mbx(t0r,O1o*1./ 180.)
set vme[(XSr)]=(((Cpx((gMv),u6v+(rwx))))*1.)
set vMe[(XSr)]=(zje)
call XPr(XSr,z2e)
call XPr(XSr,z3e)
call XQr(XSr)
call icx(p0x,z4e,true,function Wrr)
call icx(ibx,zge[rwx],false,function Wir)
endfunction
function Wnr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=zpe[oqx]
local integer rwx=zPe[oqx]
local real dix=zqe[oqx]
local real dax=zQe[oqx]
call Wvr((oqx))
call Mdo(MFo)
call War(CMx,rwx,dix,dax)
return true
endfunction
function WVr takes integer CMx,integer rwx,real dix,real dax returns nothing
local integer oqx=w7r()
local integer MFo=Mvo()
set zpe[oqx]=CMx
set zPe[oqx]=rwx
set zqe[oqx]=dix
set zQe[oqx]=dax
call m1o(MFo,2000.)
set mAv[((MFo))]=((b6v*((.2)*1.))*1.)
set mNv[(MFo)]=((48.)*1.)
call Mro(MFo,'qWSM',1.)
set mCv[(MFo)]=XHx((function Wnr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,500.)
call M9o(MFo,CMx)
call o6r(MFo,dix,dax,XYx(dix,dax))
endfunction
function WEr takes nothing returns boolean
local integer rdx=(bv)
call WVr((Vv[(rdx)]),(Mv[(rdx)]),(UH[(rdx)]),(wH[(rdx)]))
return true
endfunction
function WXr takes integer oqx,integer Ixx,real o2x returns nothing
local integer rkx=oqx
if(IsUnitAlly(C[(Ixx)],vx[(rkx)]))then
return
endif
if(o2x<=.0)then
return
endif
call OMx(rkx,iqx("+"+(I2S(((R2I(((o2x)*1.)))))),"ffc80000"),.02,80.,.0,3.,(0))
call RUx((Abx((rkx),(dAv),(dNv),(Bi))))
call cGx(rkx,o2x)
endfunction
function WOr takes integer oqx,integer Ixx,real o2x returns nothing
local integer rkx=oqx
if(IsUnitAlly(C[(Ixx)],vx[(rkx)]))then
return
endif
if(o2x<=.0)then
return
endif
call OMx(rkx,iqx("+"+(I2S(((R2I(((o2x)*1.)))))),"ffc80000"),.02,80.,.0,3.,(0))
call RUx((Abx((rkx),(dbv),(dBv),(Bi))))
call BRx(rkx,o2x)
endfunction
function WRr takes nothing returns boolean
local integer rdx=(bv)
local integer AFr=(EYv[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer ALr=(kv[((ze[(AFr)]))])
if((ALr!=w)and not I6x(ALr,sc))then
set AFr=ALr
endif
call WXr(AFr,Ixx,zCe[(oPx(((Ixx)),zb+(zDe)))])
call WOr(AFr,Ixx,zBe[(oPx(((Ixx)),zb+(zDe)))])
return true
endfunction
function WIr takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer rkx=(Eee[(XSr)])
call UJx(Ixx,zDe)
return true
endfunction
function WAr takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer CMx=(vhe[(XSr)])
local integer rkx=(Eee[(XSr)])
local integer rwx=z_e[rkx]
call DSx((Ixx),(zDe),(rwx),w)
return true
endfunction
function WNr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
call I7x(Ixx,z7e)
return true
endfunction
function Wbr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
call Rmx(Ixx,z7e)
return true
endfunction
function WBr takes nothing returns nothing
set z7e=XBx("FolderWanShroud_StructTarget_Init: set FolderWanShroud_StructTarget.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.SPELLS, function FolderWanShroud_StructTarget.Event_Damage)",Ezv,pI,function WRr)
set z2e=XBx("FolderWanShroud_StructTarget_Init: set FolderWanShroud_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderWanShroud_StructTarget.Event_Ending)",vQe,pI,function WIr)
set z3e=XBx("FolderWanShroud_StructTarget_Init: set FolderWanShroud_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderWanShroud_StructTarget.Event_Start)",vse,pI,function WAr)
call l9x(zDe,XBx("FolderWanShroud_StructTarget_Init: call FolderWanShroud_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderWanShroud_StructTarget.Event_BuffGain))",Bd,pI,function WNr))
call l9x(zDe,XBx("FolderWanShroud_StructTarget_Init: call FolderWanShroud_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderWanShroud_StructTarget.Event_BuffLose))",Jc,pI,function Wbr))
endfunction
function Wcr takes nothing returns boolean
local integer rwx
set zje=XLx(function w4r)
set zJe=XLx(function w5r)
call meo(gMv,XBx("WanShroud_Init: call WanShroud.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function WanShroud.Event_SpellEffect))",ah,pI,function WEr))
set rwx=(j6[(gMv)])
loop
exitwhen(rwx<1)
set zze[rwx]=zGe[rwx]*z4e
set rwx=rwx-1
endloop
call WBr()
return true
endfunction
function WCr takes nothing returns boolean
call FOr(function Wcr,"WanShroud_Init")
return true
endfunction
function Wdr takes nothing returns boolean
set z8e=WTx('BWac',"Warcry",'bWac')
set avv[(z8e)]=(true)
set qU[(z8e)]=(true)
set aev[(z8e)]=("ReplaceableTextures\\CommandButtons\\BTNBattleRoar.blp")
call lux(z8e,"Abilities\\Spells\\NightElf\\BattleRoar\\RoarTarget.mdl","overhead",ri)
return true
endfunction
function WDr takes nothing returns boolean
set z9e[1]=20
set z9e[2]=20
set z9e[3]=20
set z9e[4]=20
set z9e[5]=20
set z9e[6]=20
set Zve[1]=.1
set Zve[2]=.1
set Zve[3]=.1
set Zve[4]=.1
set Zve[5]=.1
set Zve[6]=.1
set Zee[1]=3
set Zee[2]=6
set Zee[3]=$A
set Zee[4]=$F
set Zee[5]=21
set Zee[6]=28
return true
endfunction
function Wfr takes nothing returns boolean
call VRx(Ma,(function Wdr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Warcry.page\\Warcry.struct\\Target\\obj_dummyBuff_wc3buff.j"))
call VRx(ea,(function WDr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Warcry.page\\Warcry.struct\\Target\\obj_this_wc3obj.j"))
return true
endfunction
function WFr takes nothing returns boolean
set Zxe=Vnx(Zoe)
return true
endfunction
function Wgr takes nothing returns boolean
call LZx('AWac',false)
set hIv=Lzo('AWac')
set G6[(hIv)]=(i6)
set j6[(hIv)]=(6)
set sH[(hIv)]=("Warcry")
set Ih[(hIv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00C4)))),(((Oj))))))
set x6v[(hIv)]=(0)
set xzv[(hIv)]=("spell")
call LZo((hIv),u6v+(1),((450)*1.))
call LZo((hIv),fH+(1),(($F)*1.))
call LZo((hIv),QH+(1),((80)*1.))
call LZo((hIv),Lvv+(1),((750)*1.))
call LZo((hIv),u6v+(2),((450)*1.))
call LZo((hIv),fH+(2),(($F)*1.))
call LZo((hIv),QH+(2),((92)*1.))
call LZo((hIv),Lvv+(2),((750)*1.))
call LZo((hIv),u6v+(3),((450)*1.))
call LZo((hIv),fH+(3),(($F)*1.))
call LZo((hIv),QH+(3),(('h')*1.))
call LZo((hIv),Lvv+(3),((750)*1.))
call LZo((hIv),u6v+(4),((450)*1.))
call LZo((hIv),fH+(4),(($F)*1.))
call LZo((hIv),QH+(4),(('t')*1.))
call LZo((hIv),Lvv+(4),((750)*1.))
call LZo((hIv),u6v+(5),((450)*1.))
call LZo((hIv),fH+(5),(($F)*1.))
call LZo((hIv),QH+(5),(($80)*1.))
call LZo((hIv),Lvv+(5),((750)*1.))
call LZo((hIv),u6v+(6),((450)*1.))
call LZo((hIv),fH+(6),(($F)*1.))
call LZo((hIv),QH+(6),(($8C)*1.))
call LZo((hIv),Lvv+(6),((750)*1.))
set Mnv[(hIv)]=("ReplaceableTextures\\CommandButtons\\BTNBattleRoar.blp")
call ccr(hIv,'FBR0',6,'VBR0','LPBR','LRBR')
set Zre[1]=2
set Zre[2]=2
set Zre[3]=2
set Zre[4]=2
set Zre[5]=2
set Zre[6]=2
set Zie[1]=.04
set Zie[2]=.05
set Zie[3]=.06
set Zie[4]=.07
set Zie[5]=.08
set Zie[6]=.09
return true
endfunction
function WGr takes nothing returns boolean
call VRx(qa,(function Wgr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Warcry.page\\Warcry.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Whr takes nothing returns boolean
set Zae=Vnx(Zne)
return true
endfunction
function WHr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
return true
return true
endfunction
function Wjr takes integer CMx,integer rwx,integer Ixx returns nothing
call Ayx(Ixx,z8e)
call NIx(Ixx,z8e,rwx,CMx,z9e[rwx])
endfunction
function WJr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real djr
local real O1o
local integer Ixx
local real Wkr
local integer C0o
local real h_r
local real d
local real dJr
call mFo((mHo(((wpo)*1.),((wPo)*1.),(ZXe),(ri))))
set djr=dvx(CMx,true)
set O1o=(Cpx((hIv),u6v+(rwx)))+djr
call Nio(ZVe,wpo,wPo,O1o,ZEe)
set Ixx=Nao(ZVe)
if(Ixx!=w)then
set Wkr=Zre[rwx]
set C0o=(ze[(CMx)])
set h_r=Zie[rwx]
loop
set d=jjx((GetUnitX(C[((Ixx))]))-wpo,(GetUnitY(C[((Ixx))]))-wPo)
set dJr=dBr(djr,ZOe,O1o,ZRe,d)
if(IsUnitAlly(C[(Ixx)],vx[(C0o)]))then
call Wjr(CMx,rwx,Ixx)
else
if not nIo(Ixx)then
call NIx((Ixx),(rSv),(rwx),w,((Wkr)*1.))
call nJo((CMx),(Ixx),(((rG[(Ixx)])*h_r*dJr)*1.),(true),(false))
endif
endif
set Ixx=Nao(ZVe)
exitwhen(Ixx==w)
endloop
endif
return true
endfunction
function WKr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(mc[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer Wlr=lYx()
set ZIe[oqx]=Wlr
call l_x(Wlr,dXv,Zee[rwx]+iOx(0,Zve[rwx]*(sG[(CMx)])))
call I0x(Ixx,Wlr)
return true
endfunction
function WLr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer Wlr=ZIe[oqx]
call Iqx(Ixx,Wlr)
call nrr(Wlr)
return true
endfunction
function Wmr takes nothing returns nothing
call l9x(z8e,XBx("FolderWarcry_StructTarget_Init: call FolderWarcry_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderWarcry_StructTarget.Event_BuffGain))",Bd,pI,function WKr))
call l9x(z8e,XBx("FolderWarcry_StructTarget_Init: call FolderWarcry_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderWarcry_StructTarget.Event_BuffLose))",Jc,pI,function WLr))
endfunction
function WMr takes nothing returns boolean
set ZVe=O2x()
set ZEe=XLx(function WHr)
call meo(hIv,XBx("Warcry_Init: call Warcry.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Warcry.Event_SpellEffect))",ah,pI,function WJr))
call Wmr()
return true
endfunction
function Wpr takes nothing returns boolean
call FOr(function WMr,"Warcry_Init")
return true
endfunction
function WPr takes nothing returns boolean
set ZAe[6]=hGo('uWB6')
call hho(((ZAe[6])),Apv,(INv))
set Tj[(ZAe[6])]=((1.4)*1.)
set Nav[(ZAe[6])]=((148.14814814815)*1.)
set Ntv[(ZAe[6])]=((74.074074074074)*1.)
set nGv[(ZAe[6])]=("Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdx")
set Nlv[(ZAe[6])]=(($E6)*1.)
set I3v[(ZAe[6])]=((4)*1.)
set Axv[(ZAe[6])]=(2)
set NJv[(ZAe[6])]=((925)*1.)
set Njv[(ZAe[6])]=((925)*1.)
set Nhv[(ZAe[6])]=((0)*1.)
set NIv[(ZAe[6])]=(($578)*1.)
set NOv[(ZAe[6])]=(($578)*1.)
set Ndv[(ZAe[6])]=((30)*1.)
set ANv[(ZAe[6])]=(gKv)
set Adv[(ZAe[6])]=((720)*1.)
set ADv[((ZAe[6]))]=((1.*1./((1.6)*1.))*1.)
set Atv[(ZAe[6])]=((.4)*1.)
set Drv[(ZAe[6])]=(($514)*1.)
set AQv[(ZAe[6])]=((34)*1.)
set Asv[(ZAe[6])]=((34)*1.)
set Auv[(ZAe[6])]=(3)
set AWv[(ZAe[6])]=(5)
set Azv[(ZAe[6])]=(1)
set Aqv[(ZAe[6])]=((39.506172839506)*1.)
return true
endfunction
function Wqr takes nothing returns boolean
set ZAe[2]=hGo('uWB2')
call hho(((ZAe[2])),Apv,(INv))
set Tj[(ZAe[2])]=((1)*1.)
set Nav[(ZAe[2])]=((148.14814814815)*1.)
set Ntv[(ZAe[2])]=((74.074074074074)*1.)
set nGv[(ZAe[2])]=("Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdx")
set Nlv[(ZAe[2])]=(($E6)*1.)
set I3v[(ZAe[2])]=((1)*1.)
set Axv[(ZAe[2])]=(2)
set NJv[(ZAe[2])]=((425)*1.)
set Njv[(ZAe[2])]=((425)*1.)
set Nhv[(ZAe[2])]=((0)*1.)
set NIv[(ZAe[2])]=(($578)*1.)
set NOv[(ZAe[2])]=(($578)*1.)
set Ndv[(ZAe[2])]=((30)*1.)
set ANv[(ZAe[2])]=(gKv)
set Adv[(ZAe[2])]=((720)*1.)
set ADv[((ZAe[2]))]=((1.*1./((1.6)*1.))*1.)
set Atv[(ZAe[2])]=((.4)*1.)
set Drv[(ZAe[2])]=(($514)*1.)
set AQv[(ZAe[2])]=((18)*1.)
set Asv[(ZAe[2])]=((18)*1.)
set Auv[(ZAe[2])]=(2)
set AWv[(ZAe[2])]=(3)
set Azv[(ZAe[2])]=(1)
set Aqv[(ZAe[2])]=((39.506172839506)*1.)
return true
endfunction
function WQr takes nothing returns boolean
set ZAe[3]=hGo('uWB3')
call hho(((ZAe[3])),Apv,(INv))
set Tj[(ZAe[3])]=((1.1)*1.)
set Nav[(ZAe[3])]=((148.14814814815)*1.)
set Ntv[(ZAe[3])]=((74.074074074074)*1.)
set nGv[(ZAe[3])]=("Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdx")
set Nlv[(ZAe[3])]=(($E6)*1.)
set I3v[(ZAe[3])]=((2)*1.)
set Axv[(ZAe[3])]=(2)
set NJv[(ZAe[3])]=((550)*1.)
set Njv[(ZAe[3])]=((550)*1.)
set Nhv[(ZAe[3])]=((0)*1.)
set NIv[(ZAe[3])]=(($578)*1.)
set NOv[(ZAe[3])]=(($578)*1.)
set Ndv[(ZAe[3])]=((30)*1.)
set ANv[(ZAe[3])]=(gKv)
set Adv[(ZAe[3])]=((720)*1.)
set ADv[((ZAe[3]))]=((1.*1./((1.6)*1.))*1.)
set Atv[(ZAe[3])]=((.4)*1.)
set Drv[(ZAe[3])]=(($514)*1.)
set AQv[(ZAe[3])]=((22)*1.)
set Asv[(ZAe[3])]=((22)*1.)
set Auv[(ZAe[3])]=(3)
set AWv[(ZAe[3])]=(3)
set Azv[(ZAe[3])]=(1)
set Aqv[(ZAe[3])]=((39.506172839506)*1.)
return true
endfunction
function Wsr takes nothing returns boolean
set ZAe[4]=hGo('uWB4')
call hho(((ZAe[4])),Apv,(INv))
set Tj[(ZAe[4])]=((1.2)*1.)
set Nav[(ZAe[4])]=((148.14814814815)*1.)
set Ntv[(ZAe[4])]=((74.074074074074)*1.)
set nGv[(ZAe[4])]=("Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdx")
set Nlv[(ZAe[4])]=(($E6)*1.)
set I3v[(ZAe[4])]=((2)*1.)
set Axv[(ZAe[4])]=(2)
set NJv[(ZAe[4])]=((675)*1.)
set Njv[(ZAe[4])]=((675)*1.)
set Nhv[(ZAe[4])]=((0)*1.)
set NIv[(ZAe[4])]=(($578)*1.)
set NOv[(ZAe[4])]=(($578)*1.)
set Ndv[(ZAe[4])]=((30)*1.)
set ANv[(ZAe[4])]=(gKv)
set Adv[(ZAe[4])]=((720)*1.)
set ADv[((ZAe[4]))]=((1.*1./((1.6)*1.))*1.)
set Atv[(ZAe[4])]=((.4)*1.)
set Drv[(ZAe[4])]=(($514)*1.)
set AQv[(ZAe[4])]=((26)*1.)
set Asv[(ZAe[4])]=((26)*1.)
set Auv[(ZAe[4])]=(3)
set AWv[(ZAe[4])]=(3)
set Azv[(ZAe[4])]=(1)
set Aqv[(ZAe[4])]=((39.506172839506)*1.)
return true
endfunction
function WSr takes nothing returns boolean
set ZAe[1]=hGo('uWB1')
call hho(((ZAe[1])),Apv,(INv))
set Tj[(ZAe[1])]=((.9)*1.)
set Nav[(ZAe[1])]=((148.14814814815)*1.)
set Ntv[(ZAe[1])]=((74.074074074074)*1.)
set nGv[(ZAe[1])]=("Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdx")
set Nlv[(ZAe[1])]=(($E6)*1.)
set I3v[(ZAe[1])]=((1)*1.)
set Axv[(ZAe[1])]=(2)
set NJv[(ZAe[1])]=((300)*1.)
set Njv[(ZAe[1])]=((300)*1.)
set Nhv[(ZAe[1])]=((0)*1.)
set NIv[(ZAe[1])]=(($578)*1.)
set NOv[(ZAe[1])]=(($578)*1.)
set Ndv[(ZAe[1])]=((30)*1.)
set ANv[(ZAe[1])]=(gKv)
set Adv[(ZAe[1])]=((720)*1.)
set ADv[((ZAe[1]))]=((1.*1./((1.6)*1.))*1.)
set Atv[(ZAe[1])]=((.4)*1.)
set Drv[(ZAe[1])]=(($514)*1.)
set AQv[(ZAe[1])]=(($E)*1.)
set Asv[(ZAe[1])]=(($E)*1.)
set Auv[(ZAe[1])]=(2)
set AWv[(ZAe[1])]=(3)
set Azv[(ZAe[1])]=(1)
set Aqv[(ZAe[1])]=((39.506172839506)*1.)
return true
endfunction
function Wtr takes nothing returns boolean
set ZNe[1]=35
set ZNe[2]=35
set ZNe[3]=35
set ZNe[4]=35
set ZNe[5]=35
set ZNe[6]=35
set Zbe[1]=2
set Zbe[2]=3
set Zbe[3]=4
set Zbe[4]=5
set Zbe[5]=6
set Zbe[6]=7
return true
endfunction
function WTr takes nothing returns boolean
set ZAe[5]=hGo('uWB5')
call hho(((ZAe[5])),Apv,(INv))
set Tj[(ZAe[5])]=((1.3)*1.)
set Nav[(ZAe[5])]=((148.14814814815)*1.)
set Ntv[(ZAe[5])]=((74.074074074074)*1.)
set nGv[(ZAe[5])]=("Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdx")
set Nlv[(ZAe[5])]=(($E6)*1.)
set I3v[(ZAe[5])]=((3)*1.)
set Axv[(ZAe[5])]=(2)
set NJv[(ZAe[5])]=((800)*1.)
set Njv[(ZAe[5])]=((800)*1.)
set Nhv[(ZAe[5])]=((0)*1.)
set NIv[(ZAe[5])]=(($578)*1.)
set NOv[(ZAe[5])]=(($578)*1.)
set Ndv[(ZAe[5])]=((30)*1.)
set ANv[(ZAe[5])]=(gKv)
set Adv[(ZAe[5])]=((720)*1.)
set ADv[((ZAe[5]))]=((1.*1./((1.6)*1.))*1.)
set Atv[(ZAe[5])]=((.4)*1.)
set Drv[(ZAe[5])]=(($514)*1.)
set AQv[(ZAe[5])]=((30)*1.)
set Asv[(ZAe[5])]=((30)*1.)
set Auv[(ZAe[5])]=(3)
set AWv[(ZAe[5])]=(4)
set Azv[(ZAe[5])]=(1)
set Aqv[(ZAe[5])]=((39.506172839506)*1.)
return true
endfunction
function Wur takes nothing returns boolean
call VRx(Sa,(function WPr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Summon\\obj_thisUnitTypes[6]_wc3unit.j"))
call VRx(Sa,(function Wqr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Summon\\obj_thisUnitTypes[2]_wc3unit.j"))
call VRx(Sa,(function WQr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Summon\\obj_thisUnitTypes[3]_wc3unit.j"))
call VRx(Sa,(function Wsr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Summon\\obj_thisUnitTypes[4]_wc3unit.j"))
call VRx(Sa,(function WSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Summon\\obj_thisUnitTypes[1]_wc3unit.j"))
call VRx(ea,(function Wtr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Summon\\obj_this_wc3obj.j"))
call VRx(Sa,(function WTr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Summon\\obj_thisUnitTypes[5]_wc3unit.j"))
return true
endfunction
function WUr takes nothing returns boolean
set ZBe=Vnx(Zce)
return true
endfunction
function Wwr takes nothing returns boolean
call LZx('AWaB',false)
set GGv=Lzo('AWaB')
set G6[(GGv)]=(i6)
set j6[(GGv)]=(6)
set sH[(GGv)]=("Water Bindings")
set Ih[(GGv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0272)))),(((Oj))))))
set x6v[(GGv)]=(0)
set xzv[(GGv)]=("spell")
call LZo((GGv),fH+(1),((20)*1.))
call LZo((GGv),QH+(1),((70)*1.))
call LZo((GGv),Lvv+(1),((650)*1.))
call LZo((GGv),fH+(2),((19)*1.))
call LZo((GGv),QH+(2),((85)*1.))
call LZo((GGv),Lvv+(2),((650)*1.))
call LZo((GGv),fH+(3),((18)*1.))
call LZo((GGv),QH+(3),(('d')*1.))
call LZo((GGv),Lvv+(3),((650)*1.))
call LZo((GGv),fH+(4),((17)*1.))
call LZo((GGv),QH+(4),(('x')*1.))
call LZo((GGv),Lvv+(4),((650)*1.))
call LZo((GGv),fH+(5),((16)*1.))
call LZo((GGv),QH+(5),(($8C)*1.))
call LZo((GGv),Lvv+(5),((650)*1.))
call LZo((GGv),fH+(6),(($F)*1.))
call LZo((GGv),QH+(6),(($A0)*1.))
call LZo((GGv),Lvv+(6),((650)*1.))
set Mnv[(GGv)]=("ReplaceableTextures\\CommandButtons\\BTNSummonWaterElemental.blp")
call ccr(GGv,'FWB0',6,'VWB0','LPWB','LRWB')
return true
endfunction
function WWr takes nothing returns boolean
call VRx(qa,(function Wwr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Wyr takes nothing returns boolean
set ZCe=Vnx(Zde)
return true
endfunction
function WYr takes integer CMx,integer rwx,integer Ixx returns nothing
local integer C0o=(ze[(CMx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local real dix=(GetUnitX(C[((Ixx))]))
local real dax=(GetUnitY(C[((Ixx))]))
local real N8x=UCx(CMx,dix-wpo,dax-wPo)
local integer IVr=Uzo(ZAe[rwx],C0o,wpo+ZDe*(Cos(((((N8x)*1.))*1.))),wPo+ZDe*(Sin(((((N8x)*1.))*1.))),N8x,ZNe[rwx])
local real Wzr
call I7x(IVr,Zfe)
set Wzr=Zbe[rwx]
set ZFe[(IVr)]=Wzr
set Zge[(IVr)]=CMx
call pFo(CMx,Wzr)
call rzx((IVr),(ZGe),(rwx))
return
call rzx((IVr),(Zhe),(rwx))
call Qzx((C0o),B[(Zhe)],(true))
call Lvx((IVr),(Ih[((Zhe))]),(Ixx))
call Qzx((C0o),B[(Zhe)],(false))
endfunction
function WZr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
call WYr(CMx,rwx,Ixx)
return true
endfunction
function W_r takes nothing returns boolean
local integer rdx=(bv)
local integer IVr=(Vv[(rdx)])
local integer oqx=IVr
call Rmx(IVr,Zfe)
call pDo(Zge[oqx],ZFe[oqx])
return true
endfunction
function W0r takes nothing returns boolean
call meo(GGv,XBx("WaterBindings_Init: call WaterBindings.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function WaterBindings.Event_SpellEffect))",ah,pI,function WZr))
set Zfe=XBx("FolderWaterBindings_StructSummon_Init: set FolderWaterBindings_StructSummon.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function FolderWaterBindings_StructSummon.Event_Destroy)",EP,pI,function W_r)
return true
endfunction
function W1r takes nothing returns boolean
call FOr(function W0r,"WaterBindings_Init")
return true
endfunction
function W2r takes nothing returns boolean
set ZHe=lQx(Zje+" (dummyBuff)")
set qc[(ZHe)]=(true)
set SU=lYx()
call vOr(SU,dPv,true)
call vOr(SU,dGv,true)
call l0x(((ZHe)),vc+(1),(SU))
set SU=lYx()
call vOr(SU,dPv,true)
call vOr(SU,dGv,true)
call l0x(((ZHe)),vc+(2),(SU))
set SU=lYx()
call vOr(SU,dPv,true)
call vOr(SU,dGv,true)
call l0x(((ZHe)),vc+(3),(SU))
set SU=lYx()
call vOr(SU,dPv,true)
call vOr(SU,dGv,true)
call l0x(((ZHe)),vc+(4),(SU))
set SU=lYx()
call vOr(SU,dPv,true)
call vOr(SU,dGv,true)
call l0x(((ZHe)),vc+(5),(SU))
set SU=lYx()
call vOr(SU,dPv,true)
call vOr(SU,dGv,true)
call l0x(((ZHe)),vc+(6),(SU))
return true
endfunction
function W3r takes nothing returns boolean
call LZx('AWBS',false)
set Zhe=Lzo('AWBS')
set G6[(Zhe)]=(D6)
set j6[(Zhe)]=(1)
set sH[(Zhe)]=("Water Bindings Lariat")
set Ih[(Zhe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0272)))),(((Oj))))))
set x6v[(Zhe)]=(4)
set xzv[(Zhe)]=("attack")
call LZo((Zhe),BH+(1),((5)*1.))
call LZo((Zhe),fH+(1),((0)*1.))
call LZo((Zhe),QH+(1),((0)*1.))
call LZo((Zhe),Lvv+(1),((99999)*1.))
set ZJe[1]=.25
set Zke[1]=7
return true
endfunction
function W4r takes nothing returns boolean
set ZKe=Vbx("OWBS")
return true
endfunction
function W5r takes nothing returns boolean
call VRx(Ma,(function W2r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Lariat.page\\Lariat.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function W3r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Lariat.page\\Lariat.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ha,(function W4r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Lariat.page\\Lariat.struct\\obj_bolt_wc3bolt.j"))
return true
endfunction
function W6r takes nothing returns boolean
set Zle=Vnx(Zje)
return true
endfunction
function W7r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
return true
endfunction
function W8r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer olx=CXx(Ixx,ZLe)
local integer oqx
local integer CMx
loop
exitwhen(olx<q)
set oqx=COx(Ixx,ZLe,olx)
set CMx=oqx
call Cbx(CMx)
set olx=olx-1
endloop
return true
endfunction
function W9r takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer CMx=oqx
call nJo((CMx),(Zqe[oqx]),((Zme[oqx])*1.),(true),(false))
endfunction
function yvr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer oqx=CMx
local integer clo=cBo(ZKe)
local integer p0x=inx()
set Zme[oqx]=ZMe[rwx]
set Zpe[oqx]=clo
set ZPe[oqx]=p0x
set Zqe[oqx]=Ixx
set ge[(p0x)]=(oqx)
if rtx(Ixx,ZLe,oqx)then
call DSx((Ixx),(ZHe),(1),w)
endif
call EEr(clo,CMx,Ixx)
call icx(p0x,ZJe[rwx],true,function W9r)
return true
endfunction
function yer takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local boolean Eko=(ovv[(rdx)])
local integer oqx=CMx
local integer clo=Zpe[oqx]
local integer p0x=ZPe[oqx]
local integer Ixx=Zqe[oqx]
call Kzx(clo)
call ijx(p0x)
if rrx(Ixx,ZLe,oqx)then
call Ayx(Ixx,ZHe)
endif
if Eko then
call Lvx(CMx,Xw,Ixx)
endif
return true
endfunction
function yxr takes nothing returns boolean
local integer olx
call l9x(ZHe,XBx("Lariat_Init: call Lariat.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Lariat.Event_BuffGain))",Bd,pI,function W7r))
call l9x(ZHe,XBx("Lariat_Init: call Lariat.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Lariat.Event_BuffLose))",Jc,pI,function W8r))
call meo(Zhe,XBx("Lariat_Init: call Lariat.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Lariat.Event_SpellEffect))",ah,pI,function yvr))
call meo(Zhe,XBx("Lariat_Init: call Lariat.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Lariat.Event_EndCast))",oev,pI,function yer))
set olx=(j6[(Zhe)])
loop
set ZMe[olx]=Zke[olx]*ZJe[olx]
set olx=olx-1
exitwhen(olx<1)
endloop
return true
endfunction
function yor takes nothing returns boolean
call FOr(function yxr,"Lariat_Init")
return true
endfunction
function yrr takes nothing returns boolean
set ZQe[1]=WTx('BSA1',"Soaking wet",'bSA1')
set aev[(ZQe[1])]=("ReplaceableTextures\\PassiveButtons\\PASBTNPlagueCloud.blp")
call lux(ZQe[1],"Abilities\\Spells\\Items\\AIob\\AIobTarget.mdl","head",ri)
set SU=lYx()
call l_x(SU,dKv,-35)
call l_x(SU,nev,-.1)
call l0x(((ZQe[1])),vc+(1),(SU))
set SU=lYx()
call l_x(SU,dKv,-35)
call l_x(SU,nev,-.1)
call l0x(((ZQe[1])),vc+(2),(SU))
set SU=lYx()
call l_x(SU,dKv,-35)
call l_x(SU,nev,-.1)
call l0x(((ZQe[1])),vc+(3),(SU))
set SU=lYx()
call l_x(SU,dKv,-35)
call l_x(SU,nev,-.1)
call l0x(((ZQe[1])),vc+(4),(SU))
set SU=lYx()
call l_x(SU,dKv,-35)
call l_x(SU,nev,-.1)
call l0x(((ZQe[1])),vc+(5),(SU))
set SU=lYx()
call l_x(SU,dKv,-35)
call l_x(SU,nev,-.1)
call l0x(((ZQe[1])),vc+(6),(SU))
return true
endfunction
function yir takes nothing returns boolean
set Zse[1]=2
set Zse[2]=2
set Zse[3]=2
set Zse[4]=2
set Zse[5]=2
set Zse[6]=2
set ZSe[1]=6
set ZSe[2]=6
set ZSe[3]=6
set ZSe[4]=6
set ZSe[5]=6
set ZSe[6]=6
set Zte[1]=-35
set Zte[2]=-35
set Zte[3]=-35
set Zte[4]=-35
set Zte[5]=-35
set Zte[6]=-35
set ZTe[1]=-.1
set ZTe[2]=-.1
set ZTe[3]=-.1
set ZTe[4]=-.1
set ZTe[5]=-.1
set ZTe[6]=-.1
return true
endfunction
function yar takes nothing returns boolean
set Zue=lQx(ZUe+" (timerBuff)")
return true
endfunction
function ynr takes nothing returns boolean
set ZQe[2]=WTx('BSA2',"Soaking wet",'bSA2')
set aev[(ZQe[2])]=("ReplaceableTextures\\PassiveButtons\\PASBTNPlagueCloud.blp")
call lux(ZQe[2],"Abilities\\Spells\\Items\\AIob\\AIobTarget.mdl","hand left",ri)
set SU=lYx()
call l_x(SU,dKv,-35)
call l_x(SU,nev,-.1)
call l0x(((ZQe[2])),vc+(1),(SU))
set SU=lYx()
call l_x(SU,dKv,-35)
call l_x(SU,nev,-.1)
call l0x(((ZQe[2])),vc+(2),(SU))
set SU=lYx()
call l_x(SU,dKv,-35)
call l_x(SU,nev,-.1)
call l0x(((ZQe[2])),vc+(3),(SU))
set SU=lYx()
call l_x(SU,dKv,-35)
call l_x(SU,nev,-.1)
call l0x(((ZQe[2])),vc+(4),(SU))
set SU=lYx()
call l_x(SU,dKv,-35)
call l_x(SU,nev,-.1)
call l0x(((ZQe[2])),vc+(5),(SU))
set SU=lYx()
call l_x(SU,dKv,-35)
call l_x(SU,nev,-.1)
call l0x(((ZQe[2])),vc+(6),(SU))
return true
endfunction
function yVr takes nothing returns boolean
set ZQe[3]=WTx('BSA3',"Soaking wet",'bSA3')
set aev[(ZQe[3])]=("ReplaceableTextures\\PassiveButtons\\PASBTNPlagueCloud.blp")
call lux(ZQe[3],"Abilities\\Spells\\Items\\AIob\\AIobTarget.mdl","hand right",ri)
set SU=lYx()
call l_x(SU,dKv,-35)
call l_x(SU,nev,-.1)
call l0x(((ZQe[3])),vc+(1),(SU))
set SU=lYx()
call l_x(SU,dKv,-35)
call l_x(SU,nev,-.1)
call l0x(((ZQe[3])),vc+(2),(SU))
set SU=lYx()
call l_x(SU,dKv,-35)
call l_x(SU,nev,-.1)
call l0x(((ZQe[3])),vc+(3),(SU))
set SU=lYx()
call l_x(SU,dKv,-35)
call l_x(SU,nev,-.1)
call l0x(((ZQe[3])),vc+(4),(SU))
set SU=lYx()
call l_x(SU,dKv,-35)
call l_x(SU,nev,-.1)
call l0x(((ZQe[3])),vc+(5),(SU))
set SU=lYx()
call l_x(SU,dKv,-35)
call l_x(SU,nev,-.1)
call l0x(((ZQe[3])),vc+(6),(SU))
return true
endfunction
function yEr takes nothing returns boolean
call VRx(Ma,(function yrr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\SoakingAttack.page\\SoakingAttack.struct\\Target\\obj_ChargeBuff[1]_wc3buff.j"))
call VRx(ea,(function yir),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\SoakingAttack.page\\SoakingAttack.struct\\Target\\obj_this_wc3obj.j"))
call VRx(Ma,(function yar),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\SoakingAttack.page\\SoakingAttack.struct\\Target\\obj_timerBuff_wc3buff.j"))
call VRx(Ma,(function ynr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\SoakingAttack.page\\SoakingAttack.struct\\Target\\obj_ChargeBuff[2]_wc3buff.j"))
call VRx(Ma,(function yVr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\SoakingAttack.page\\SoakingAttack.struct\\Target\\obj_ChargeBuff[3]_wc3buff.j"))
return true
endfunction
function yXr takes nothing returns boolean
set Zwe=Vnx(ZUe)
return true
endfunction
function yOr takes nothing returns boolean
call LZx('ASoA',false)
set ZGe=Lzo('ASoA')
set G6[(ZGe)]=(D6)
set j6[(ZGe)]=(1)
set sH[(ZGe)]=("Soaking Attack")
set xzv[(ZGe)]=("spell")
call LZo((ZGe),Lvv+(1),((750)*1.))
set Mnv[(ZGe)]=("ReplaceableTextures\\PassiveButtons\\PASBTNPlagueCloud.blp")
return true
endfunction
function yRr takes nothing returns boolean
set ZWe=lQx(Zye+" (dummyBuff)")
call lux(ZWe,"Abilities\\Spells\\Items\\AIob\\AIobTarget.mdl","hand left",ri)
call lux(ZWe,"Abilities\\Spells\\Items\\AIob\\AIobTarget.mdl","hand right",ri)
return true
endfunction
function yIr takes nothing returns boolean
call VRx(qa,(function yOr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\SoakingAttack.page\\SoakingAttack.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function yRr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\SoakingAttack.page\\SoakingAttack.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function yAr takes nothing returns boolean
set ZYe=Vnx(Zye)
return true
endfunction
function yNr takes integer Ixx returns boolean
return( not(I6x(Ixx,IBv)))and( not(I6x(Ixx,ICv)))
endfunction
function ybr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
local integer Ixx=oqx
local integer o7x=ZZe[oqx]
call Ayx(Ixx,ZQe[o7x])
set ZZe[oqx]=o7x-1
call oYx("FolderSoakingAttack_StructTarget_Interval","call DebugEx(\"reduce to \"+I2S(count-1))","reduce to "+I2S(o7x-1))
if(o7x==1)then
call Ayx(Ixx,Zue)
endif
endfunction
function yBr takes integer rwx,integer Ixx returns nothing
local integer oqx=Ixx
local integer p0x=Z_e[oqx]
local real ilx
if I6x(Ixx,yd)then
set ilx=Zse[rwx]
else
set ilx=ZSe[rwx]
endif
call icx(p0x,ilx,true,function ybr)
endfunction
function ycr takes integer CMx,integer rwx,integer Ixx returns nothing
local integer o7x
local integer oqx=Ixx
if((oPx((((Ixx))),(yb+(Zue)))>0)==false)then
set o7x=1
else
set o7x=(R2I(((itx((ZZe[oqx]+1),(3)))*1.)))
endif
set ZZe[oqx]=o7x
call oYx("FolderSoakingAttack_StructTarget_Start","call DebugEx(\"apply \"+I2S(count))","apply "+I2S(o7x))
call DSx((Ixx),(ZQe[o7x]),(rwx),w)
call DSx((Ixx),(Zue),(1),w)
call yBr(rwx,Ixx)
endfunction
function yCr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
if not yNr(Ixx)then
return true
endif
call ycr((EYv[(rdx)]),(oPx((((EYv[(rdx)]))),N+(ZGe))),Ixx)
return true
endfunction
function ydr takes nothing returns boolean
local integer rdx=(bv)
call I7x((Vv[(rdx)]),Zze)
return true
endfunction
function yDr takes nothing returns boolean
local integer rdx=(bv)
call Rmx((Vv[(rdx)]),Zze)
return true
endfunction
function yfr takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(ZWe),((Mv[(rdx)])),w)
return true
endfunction
function yFr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),ZWe)
return true
endfunction
function ygr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer p0x=inx()
set Z_e[oqx]=p0x
set ge[(p0x)]=(oqx)
return true
endfunction
function yGr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer o7x=ZZe[oqx]
local integer p0x=Z_e[oqx]
call ijx(p0x)
loop
exitwhen(o7x<1)
call Ayx(Ixx,ZQe[o7x])
set o7x=o7x-1
endloop
return true
endfunction
function yhr takes nothing returns nothing
call l9x(Zue,XBx("FolderSoakingAttack_StructTarget_Init: call FolderSoakingAttack_StructTarget.TIMER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSoakingAttack_StructTarget.Event_Timer_BuffGain))",Bd,pI,function ygr))
call l9x(Zue,XBx("FolderSoakingAttack_StructTarget_Init: call FolderSoakingAttack_StructTarget.TIMER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSoakingAttack_StructTarget.Event_Timer_BuffLose))",Jc,pI,function yGr))
endfunction
function yHr takes nothing returns boolean
set Zze=XBx("SoakingAttack_Init: set SoakingAttack.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function SoakingAttack.Event_Damage)",EZv,pI,function yCr)
call l9x(ZWe,XBx("SoakingAttack_Init: call SoakingAttack.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoakingAttack.Event_BuffGain))",Bd,pI,function ydr))
call l9x(ZWe,XBx("SoakingAttack_Init: call SoakingAttack.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoakingAttack.Event_BuffLose))",Jc,pI,function yDr))
call meo(ZGe,XBx("SoakingAttack_Init: call SoakingAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoakingAttack.Event_Learn))",pv,pI,function yfr))
call meo(ZGe,XBx("SoakingAttack_Init: call SoakingAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoakingAttack.Event_Unlearn))",Av,pI,function yFr))
call yhr()
return true
endfunction
function yjr takes nothing returns boolean
call FOr(function yHr,"SoakingAttack_Init")
return true
endfunction
function yJr takes nothing returns boolean
set Z0e[1]=.2
set Z0e[2]=.3
set Z0e[3]=.4
return true
endfunction
function ykr takes nothing returns boolean
set Z1e=WTx('BZoW',"Zodiac - winged",'bZoW')
set avv[(Z1e)]=(true)
set aev[(Z1e)]=("ReplaceableTextures\\CommandButtons\\BTNRegenerate.blp")
call lux(Z1e,"Abilities\\Spells\\NightElf\\Tranquility\\TranquilityTarget.mdl","origin",ri)
set SU=lYx()
call l_x(SU,ZU,.2)
call l0x(((Z1e)),vc+(1),(SU))
set SU=lYx()
call l_x(SU,ZU,.3)
call l0x(((Z1e)),vc+(2),(SU))
set SU=lYx()
call l_x(SU,ZU,.4)
call l0x(((Z1e)),vc+(3),(SU))
return true
endfunction
function yKr takes nothing returns boolean
call VRx(ea,(function yJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Zodiac.page\\ZodiacAura.struct\\Target\\obj_this_wc3obj.j"))
call VRx(Ma,(function ykr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Zodiac.page\\ZodiacAura.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function ylr takes nothing returns boolean
set Z2e=Vnx(Z3e)
return true
endfunction
function yLr takes nothing returns boolean
set Z4e[1]=.05
set Z4e[2]=.1
set Z4e[3]=.15
set Z5e[1]=5
set Z5e[2]=$A
set Z5e[3]=$F
return true
endfunction
function ymr takes nothing returns boolean
set Z6e=lQx(Z7e+" (dummyBuff)")
return true
endfunction
function yMr takes nothing returns boolean
call VRx(ea,(function yLr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Zodiac.page\\ZodiacAura.struct\\obj_this_wc3obj.j"))
call VRx(Ma,(function ymr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Zodiac.page\\ZodiacAura.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function ypr takes nothing returns boolean
set Z8e=Vnx(Z7e)
return true
endfunction
function yPr takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if not(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function yqr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=(mj[(rdx)])
call cGx(Ixx,vxx[oqx])
return true
endfunction
function yQr takes nothing returns nothing
local integer oqx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])
call DDx((vLe[(vvx[oqx])]),function yqr,oqx)
endfunction
function ysr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(mc[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer ozx=(Vv[(rdx)])
local integer oqx=ozx
local integer XSr=Xpr(CMx)
local integer p0x=inx()
set vvx[oqx]=XSr
set vex[oqx]=CMx
set vxx[oqx]=vox[rwx]+(og[(CMx)])*Z4e[rwx]*vrx
set vix[oqx]=p0x
set vax[oqx]=rwx
set Eee[(XSr)]=(oqx)
set ge[(p0x)]=(oqx)
set vme[(XSr)]=(((Cpx((GWv),u6v+(rwx))))*1.)
set vMe[(XSr)]=(Z9e)
call XPr(XSr,vnx)
call XPr(XSr,vVx)
call XQr(XSr)
call icx(p0x,vrx,true,function yQr)
return true
endfunction
function ySr takes nothing returns boolean
local integer rdx=(bv)
local integer ozx=(Vv[(rdx)])
local integer oqx=ozx
local integer XSr=vvx[oqx]
local integer p0x=vix[oqx]
call X2r(XSr)
call ijx(p0x)
return true
endfunction
function ytr takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer rkx=(Eee[(XSr)])
call UJx(Ixx,Z1e)
return true
endfunction
function yTr takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer CMx=(vhe[(XSr)])
local integer rkx=(Eee[(XSr)])
local integer rwx=vax[rkx]
call DSx((Ixx),(Z1e),(rwx),w)
return true
endfunction
function yur takes nothing returns nothing
set vnx=XBx("FolderZodiacAura_StructTarget_Init: set FolderZodiacAura_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderZodiacAura_StructTarget.Event_Ending)",vQe,pI,function ytr)
set vVx=XBx("FolderZodiacAura_StructTarget_Init: set FolderZodiacAura_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderZodiacAura_StructTarget.Event_Start)",vse,pI,function yTr)
endfunction
function yUr takes nothing returns boolean
local integer olx
set Z9e=XLx(function yPr)
call l9x(Z6e,XBx("ZodiacAura_Init: call ZodiacAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ZodiacAura.Event_BuffGain))",Bd,pI,function ysr))
call l9x(Z6e,XBx("ZodiacAura_Init: call ZodiacAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ZodiacAura.Event_BuffLose))",Jc,pI,function ySr))
set olx=(j6[(GWv)])
loop
exitwhen(olx<1)
set vox[olx]=Z5e[olx]*vrx
set olx=olx-1
endloop
call yur()
return true
endfunction
function ywr takes nothing returns boolean
call FOr(function yUr,"ZodiacAura_Init")
return true
endfunction
function yWr takes nothing returns boolean
set vEx=WTx('BZod',"Zodiac",'bZod')
set avv[(vEx)]=(true)
set qc[(vEx)]=(true)
set aev[(vEx)]=("ReplaceableTextures\\CommandButtons\\BTNGenericSpellImmunity.blp")
call lux(vEx,"Zodiac_page\\Zodiac_struct\\casterEffect.mdx","origin",ri)
return true
endfunction
function yyr takes nothing returns boolean
call LZx('AZod',false)
set GWv=Lzo('AZod')
set G6[(GWv)]=(C6)
set j6[(GWv)]=(3)
set sH[(GWv)]=("Zodiac")
set Ih[(GWv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0104)))),(((Oj))))))
set x6v[(GWv)]=(4)
set xzv[(GWv)]=("spell")
call LZo((GWv),u6v+(1),((750)*1.))
call LZo((GWv),fH+(1),(($96)*1.))
call LZo((GWv),Lvv+(1),(($3E8)*1.))
call LZo((GWv),u6v+(2),((750)*1.))
call LZo((GWv),fH+(2),(($87)*1.))
call LZo((GWv),Lvv+(2),(($3E8)*1.))
call LZo((GWv),u6v+(3),((750)*1.))
call LZo((GWv),fH+(3),(('x')*1.))
call LZo((GWv),Lvv+(3),(($3E8)*1.))
set Mnv[(GWv)]=("ReplaceableTextures\\CommandButtons\\BTNEnchantedCrows.blp")
call ccr(GWv,'FZo0',3,'VZo0','LPZo','LRZo')
set vXx[1]=$F
set vXx[2]=20
set vXx[3]=25
return true
endfunction
function yYr takes nothing returns boolean
call VRx(Ma,(function yWr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Zodiac.page\\Zodiac.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function yyr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Zodiac.page\\Zodiac.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function yzr takes nothing returns boolean
set vOx=Vnx(vRx)
return true
endfunction
function yZr takes integer oqx returns integer
set vIx[oqx]=true
set vAx[oqx]=false
call rax(vOx)
return oqx
endfunction
function y_r takes integer ozx,integer CMx,integer rwx returns nothing
call DSx(ozx,Z6e,rwx,CMx)
endfunction
function y0r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(mc[(rdx)])
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=yZr(Ixx)
call DSx((((Ixx))),(iiv),(1),w)
call y_r(Ixx,CMx,rwx)
return true
endfunction
function y1r takes integer oqx returns nothing
set vIx[oqx]=false
call rgx(vOx)
endfunction
function y2r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call y1r(oqx)
call UJx(((Ixx)),iiv)
call Ayx(Ixx,Z6e)
return true
endfunction
function y3r takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
call NIx(Ixx,vEx,rwx,CMx,vXx[rwx])
return true
endfunction
function y4r takes nothing returns boolean
call l9x(vEx,XBx("Zodiac_Init: call Zodiac.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Zodiac.Event_BuffGain))",Bd,pI,function y0r))
call l9x(vEx,XBx("Zodiac_Init: call Zodiac.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Zodiac.Event_BuffLose))",Jc,pI,function y2r))
call meo(GWv,XBx("Zodiac_Init: call Zodiac.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Zodiac.Event_SpellEffect))",ah,pI,function y3r))
return true
endfunction
function y5r takes nothing returns boolean
call FOr(function y4r,"Zodiac_Init")
return true
endfunction
function y6r takes nothing returns boolean
call LZx('ABHW',false)
set vNx=Lzo('ABHW')
set j6[(vNx)]=(1)
set sH[(vNx)]=("Big Healing Wave")
set Ih[(vNx)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0215)))),(((Oj))))))
set x6v[(vNx)]=(4)
set xzv[(vNx)]=("spell")
call LZo((vNx),u6v+(1),((99999)*1.))
call LZo((vNx),fH+(1),(($F)*1.))
call LZo((vNx),QH+(1),(('d')*1.))
call LZo((vNx),Lvv+(1),((99999)*1.))
set Mnv[(vNx)]=("ReplaceableTextures\\CommandButtons\\BTNHealingWave.blp")
return true
endfunction
function y7r takes nothing returns boolean
set vbx=Vbx("OHWP")
return true
endfunction
function y8r takes nothing returns boolean
set vBx=Vbx("OHWS")
return true
endfunction
function y9r takes nothing returns boolean
call VRx(qa,(function y6r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\BigHealingWave.page\\BigHealingWave.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ha,(function y7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\BigHealingWave.page\\BigHealingWave.struct\\obj_Bolt_wc3bolt.j"))
call VRx(Ha,(function y8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\BigHealingWave.page\\BigHealingWave.struct\\obj_BoltSec_wc3bolt.j"))
return true
endfunction
function Yvr takes nothing returns boolean
set vcx=Vnx(vCx)
return true
endfunction
function Yer takes nothing returns boolean
local integer Ixx=jFx()
if(I5x((OPe),Rb,(Ixx)))then
return false
endif
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,IBv)then
return false
endif
if I6x(Ixx,Icv)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if((IsUnitAlly(C[(Ixx)],vx[(Hf)]))==false)then
return false
endif
return true
return true
endfunction
function Yxr takes integer oqx returns integer
set vhx[oqx]=true
set vHx[oqx]=false
call rax(vcx)
return oqx
endfunction
function Yor takes nothing returns integer
local integer oqx
if(vfx==8190)then
call oYx("BigHealingWave_Allocation_allocCustom","call DebugEx(BigHealingWave.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",vCx+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(vFx[(w)]==w)then
set vgx=vgx+1
set oqx=vgx
else
set oqx=vFx[(w)]
set vFx[(w)]=vFx[vFx[(w)]]
endif
set vFx[oqx]=Z
set vGx[oqx]=1
call Yxr(oqx)
return oqx
endfunction
function Yrr takes integer oqx returns nothing
set vhx[oqx]=false
call rgx(vcx)
endfunction
function Yir takes integer oqx returns nothing
if(vGx[oqx]>0)then
return
endif
if(vFx[oqx]!=Z)then
call oYx("BigHealingWave_Allocation_deallocCustom_confirm","call DebugEx(BigHealingWave.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",vCx+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set vFx[oqx]=vFx[(w)]
set vFx[(w)]=oqx
call Yrr(oqx)
endfunction
function Yar takes integer oqx returns nothing
set vGx[oqx]=vGx[oqx]-1
call Yir(oqx)
endfunction
function Ynr takes integer oqx returns nothing
call Yar((oqx))
call ijx(vkx[oqx])
call XYr(vlx[oqx])
endfunction
function YVr takes integer oqx,integer pGr,integer Edr returns nothing
local integer clo=pdr((pGr==Edr),vbx,vBx)
set vKx[oqx]=Edr
call moo(vJx[oqx],Edr,vpx*(iG[(Edr)]))
call EEr(clo,pGr,Edr)
call pKo((Abx((Edr),(vPx),(vqx),(ri))),.0)
call dpx(vlx[oqx],Edr)
call cko(clo,.75)
endfunction
function YEr takes nothing returns nothing
local integer CMx
local integer OHx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))
local integer pGr
local real pHr
local real pjr
local integer Edr
local integer oqx=(ge[(OHx)])
local integer Q7o=vlx[oqx]
local integer ECr=vLx[oqx]+1
if(ECr>vMx)then
call Ynr(oqx)
else
set CMx=vJx[oqx]
set pGr=vKx[oqx]
set pHr=(GetUnitX(C[((pGr))]))
set pjr=(GetUnitY(C[((pGr))]))
set OPe=Q7o
set Hf=(ze[(CMx)])
call Nio(vdx,pHr,pjr,vjx[oqx],vDx)
set Edr=(mjo((vdx),((pHr)*1.),((pjr)*1.)))
if(Edr==w)then
call Ynr(oqx)
else
set vLx[oqx]=ECr
call YVr(oqx,pGr,Edr)
endif
endif
endfunction
function YXr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer oqx=Yor()
local integer OHx=inx()
set vjx[oqx]=(Cpx((vNx),u6v+(rwx)))
set vJx[oqx]=CMx
set vkx[oqx]=OHx
set vKx[oqx]=Ixx
set vlx[oqx]=JIx("BigHealingWave_Event_SpellEffect: set this.targetGroup = UnitList.Create()")
set vLx[oqx]=1
set ge[(OHx)]=(oqx)
call icx(OHx,vmx,true,function YEr)
call YVr(oqx,CMx,Ixx)
return true
endfunction
function YOr takes nothing returns boolean
set vdx=O2x()
set vDx=XLx(function Yer)
call meo(vNx,XBx("BigHealingWave_Init: call BigHealingWave.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BigHealingWave.Event_SpellEffect))",ah,pI,function YXr))
return true
endfunction
function YRr takes nothing returns boolean
call mvo(function YOr,"BigHealingWave_Init")
return true
endfunction
function YIr takes nothing returns boolean
call LZx('ABuM',false)
set vQx=Lzo('ABuM')
set j6[(vQx)]=(1)
set sH[(vQx)]=("Burning Spirit (Meteorite)")
set Ih[(vQx)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0085)))),(((Oj))))))
set x6v[(vQx)]=(4)
set xzv[(vQx)]=("spell")
call LZo((vQx),fH+(1),((60)*1.))
call LZo((vQx),QH+(1),((60)*1.))
call LZo((vQx),Lvv+(1),((99999)*1.))
set Mnv[(vQx)]=("ReplaceableTextures\\CommandButtons\\BTNIncinerate.blp")
return true
endfunction
function YAr takes nothing returns boolean
set vsx=WTx('BBu2',"Burning Spirit",'bBu2')
set avv[(vsx)]=(true)
set qU[(vsx)]=(true)
set aev[(vsx)]=("ReplaceableTextures\\CommandButtons\\BTNIncinerate.blp")
call lux(vsx,"Abilities\\Spells\\Orc\\Bloodlust\\BloodlustSpecial.mdl","hand left",ri)
call lux(vsx,"Abilities\\Spells\\Orc\\Bloodlust\\BloodlustSpecial.mdl","hand right",Bi)
set SU=lYx()
call l_x(SU,nev,.25)
call l_x(SU,Bcv,.25)
call l_x(SU,ZU,.25)
call l0x(((vsx)),vc+(1),(SU))
return true
endfunction
function YNr takes nothing returns boolean
call VRx(qa,(function YIr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\BurningSpiritMeteorite.page\\BurningSpiritMeteorite.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function YAr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\BurningSpiritMeteorite.page\\BurningSpiritMeteorite.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function Ybr takes nothing returns boolean
set vSx=Vnx(vtx)
return true
endfunction
function YBr takes integer oqx returns integer
set vTx[oqx]=true
set vux[oqx]=false
call rax(vSx)
return oqx
endfunction
function Ycr takes integer oqx returns nothing
set vTx[oqx]=false
call rgx(vSx)
endfunction
function YCr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=vUx[oqx]
local integer rwx=vwx[oqx]
local integer Ixx=vWx[oqx]
call Ycr(oqx)
call Mdo(MFo)
call NIx((Ixx),(vsx),(rwx),w,((vyx)*1.))
return true
endfunction
function Ydr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local integer Ixx=(WH[(rdx)])
local integer MFo=Mvo()
local integer oqx=YBr(MFo)
set vUx[oqx]=CMx
set vwx[oqx]=rwx
set vWx[oqx]=Ixx
set mNv[(MFo)]=((10.)*1.)
call Mro(MFo,'qBSp',2.)
set mCv[(MFo)]=XHx((function YCr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,900.)
call M9o(MFo,CMx)
call M3o((MFo),(Ixx),.0,.0,.0,(null))
return true
endfunction
function YDr takes nothing returns boolean
call meo(vQx,XBx("BurningSpiritMeteorite_Init: call BurningSpiritMeteorite.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BurningSpiritMeteorite.Event_SpellEffect))",ah,pI,function Ydr))
return true
endfunction
function Yfr takes nothing returns boolean
call mvo(function YDr,"BurningSpiritMeteorite_Init")
return true
endfunction
function YFr takes nothing returns boolean
call LZx('ABuL',false)
set vYx=Lzo('ABuL')
set G6[(vYx)]=(D6)
set j6[(vYx)]=(1)
set sH[(vYx)]=("Burn Lumber")
set Ih[(vYx)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0296)))),(((Oj))))))
set x6v[(vYx)]=(0)
set xzv[(vYx)]=("spell")
call LZo((vYx),fH+(1),(($A)*1.))
call LZo((vYx),QH+(1),((0)*1.))
call LZo((vYx),Lvv+(1),((750)*1.))
set Mnv[(vYx)]=("ReplaceableTextures\\CommandButtons\\BTNOrcLumberUpgradeTwo.blp")
return true
endfunction
function Ygr takes nothing returns boolean
call VRx(qa,(function YFr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\BurnLumber.page\\BurnLumber.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function YGr takes nothing returns boolean
set vzx=Vnx(vZx)
return true
endfunction
function Yhr takes nothing returns boolean
local integer rdx=(bv)
call TriggerRegisterUnitEvent(fA[((v_x))],C[((Vv[(rdx)]))],(EVENT_UNIT_SPELL_EFFECT))
return true
endfunction
function YHr takes nothing returns boolean
local integer CMx=Q_x()
call moo(CMx,CMx,v0x)
call mro(CMx,CMx,v1x)
return true
endfunction
function Yjr takes nothing returns boolean
if((Cjo(GetSpellAbilityId()))!=vYx)then
return false
endif
return true
return true
endfunction
function YJr takes nothing returns boolean
call meo(vYx,XBx("BurnLumber_Init: call BurnLumber.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BurnLumber.Event_Learn))",pv,pI,function Yhr))
set v_x=Xhx(function YHr)
call CKo(v_x,function Yjr)
return true
endfunction
function Ykr takes nothing returns boolean
call mvo(function YJr,"BurnLumber_Init")
return true
endfunction
function YKr takes nothing returns boolean
call LZx('ACoF',false)
set v2x=Lzo('ACoF')
set j6[(v2x)]=(1)
set sH[(v2x)]=("Core Fusion")
set Ih[(v2x)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00FD)))),(((Oj))))))
set x6v[(v2x)]=(0)
set xzv[(v2x)]=("spell")
call LZo((v2x),fH+(1),((60)*1.))
call LZo((v2x),QH+(1),(($96)*1.))
set Mnv[(v2x)]=("ReplaceableTextures\\CommandButtons\\BTNUsedSoulGem.blp")
return true
endfunction
function Ylr takes nothing returns boolean
call VRx(qa,(function YKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\CoreFusion.page\\CoreFusion.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function YLr takes nothing returns boolean
set v3x=Vnx(v4x)
return true
endfunction
function Ymr takes integer oqx,real oSx returns nothing
call cQx(oqx,(kG[(oqx)])-oSx)
endfunction
function YMr takes integer oqx returns nothing
set iG[oqx]=GetUnitState(C[(oqx)],UNIT_STATE_MAX_LIFE)
call cqx(oqx)
endfunction
function Ypr takes nothing returns nothing
set bq=w
call CFx(Ge,PLAYER_STATE_RESOURCE_FOOD_USED,0)
endfunction
function YPr takes integer oqx,real ilx returns nothing
call tNo(oqx)
call icx(Bq,ilx,false,function Ypr)
endfunction
function Yqr takes nothing returns nothing
local real YQr=v7x
local real Ysr=(rG[(hw)])
local real s6o
local boolean YSr=(Ysr<YQr)
if YSr then
call Rmx(hw,v8x)
call Ymr(hw,(YQr-Ysr)*.5)
call YMr(hw)
call I7x(hw,v8x)
endif
set s6o=Ysr*1./(iG[(hw)])
set v7x=Ysr
if(Qbv!=w)then
call s4o((Qbv),(s5o()))
call fGx(hw,255.,s6o*255.,s6o*255.,255.)
endif
call DUx(hw,(Tj[(v9x)])*((1.-.4)*s6o+.4))
if YSr then
call YPr(evx,5.)
call AHx(eex)
endif
endfunction
function Ytr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
call moo(CMx,CMx,v5x*(iG[(CMx)]))
call A7o(Nvo((GetUnitX(C[((CMx))])),(GetUnitY(C[((CMx))])),v6x,ri,5.))
call Yqr()
return true
endfunction
function YTr takes nothing returns boolean
call meo(v2x,XBx("CoreFusion_Init: call CoreFusion.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function CoreFusion.Event_SpellEffect))",ah,pI,function Ytr))
return true
endfunction
function Yur takes nothing returns boolean
call mvo(function YTr,"CoreFusion_Init")
return true
endfunction
function YUr takes nothing returns boolean
set exx=lQx(eox+" (dummyBuff)")
return true
endfunction
function Ywr takes nothing returns boolean
set erx=lQx(eox+" (eclipseBuff)")
set qc[(erx)]=(true)
return true
endfunction
function YWr takes nothing returns boolean
call LZx('ADaA',false)
set gUv=Lzo('ADaA')
set G6[(gUv)]=(D6)
set j6[(gUv)]=(6)
set sH[(gUv)]=("Dark Attack")
set xzv[(gUv)]=("spell")
call LZo((gUv),Lvv+(1),((750)*1.))
call LZo((gUv),Lvv+(2),((750)*1.))
call LZo((gUv),Lvv+(3),((750)*1.))
call LZo((gUv),Lvv+(4),((750)*1.))
call LZo((gUv),Lvv+(5),((750)*1.))
call LZo((gUv),Lvv+(6),((750)*1.))
set Mnv[(gUv)]=("ReplaceableTextures\\CommandButtons\\PASBTNDarkAttack.blp")
set eix[1]=3
set eix[2]=3
set eix[3]=3
set eix[4]=3
set eix[5]=3
set eix[6]=3
set enx[1]=6
set enx[2]=6
set enx[3]=6
set enx[4]=6
set enx[5]=6
set enx[6]=6
return true
endfunction
function Yyr takes nothing returns boolean
call VRx(Ma,(function YUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\DarkAttack.page\\DarkAttack.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(Ma,(function Ywr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\DarkAttack.page\\DarkAttack.struct\\obj_eclipseBuff_wc3buff.j"))
call VRx(qa,(function YWr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\DarkAttack.page\\DarkAttack.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function YYr takes nothing returns boolean
set eVx=Vnx(eox)
return true
endfunction
function Yzr takes integer Ixx returns boolean
return( not(I6x(Ixx,IBv)))and( not(I6x(Ixx,ICv)))and( not(nIo(Ixx)))
endfunction
function YZr takes integer rwx,integer Ixx returns nothing
local real ilx
if I6x(Ixx,yd)then
set ilx=eix[rwx]
else
set ilx=enx[rwx]
endif
call NIx((Ixx),(erx),(rwx),w,((ilx)*1.))
endfunction
function Y_r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
call RUx((Abx((Ixx),(eXx),(eOx),(Bi))))
if not Yzr(Ixx)then
return true
endif
call YZr((oPx((((EYv[(rdx)]))),N+(gUv))),Ixx)
return true
endfunction
function Y0r takes nothing returns boolean
local integer rdx=(bv)
call I7x((Vv[(rdx)]),eEx)
return true
endfunction
function Y1r takes nothing returns boolean
local integer rdx=(bv)
call Rmx((Vv[(rdx)]),eEx)
return true
endfunction
function Y2r takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(exx),((Mv[(rdx)])),w)
return true
endfunction
function Y3r takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),exx)
return true
endfunction
function Y4r takes nothing returns boolean
set eEx=XBx("DarkAttack_Init: set DarkAttack.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function DarkAttack.Event_Damage)",EZv,pI,function Y_r)
call l9x(exx,XBx("DarkAttack_Init: call DarkAttack.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DarkAttack.Event_BuffGain))",Bd,pI,function Y0r))
call l9x(exx,XBx("DarkAttack_Init: call DarkAttack.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DarkAttack.Event_BuffLose))",Jc,pI,function Y1r))
call meo(gUv,XBx("DarkAttack_Init: call DarkAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DarkAttack.Event_Learn))",pv,pI,function Y2r))
call meo(gUv,XBx("DarkAttack_Init: call DarkAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DarkAttack.Event_Unlearn))",Av,pI,function Y3r))
call W_x(ENv,erx)
return true
endfunction
function Y5r takes nothing returns boolean
call mvo(function Y4r,"DarkAttack_Init")
return true
endfunction
function Y6r takes nothing returns boolean
set eRx=WTx('BFoA',"Healed",'bFoA')
set avv[(eRx)]=(true)
set aev[(eRx)]=("ReplaceableTextures\\CommandButtons\\BTNHeal.blp")
call lux(eRx,"Abilities\\Spells\\Other\\ANrm\\ANrmTarget.mdl","origin",Bi)
return true
endfunction
function Y7r takes nothing returns boolean
call VRx(Ma,(function Y6r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\FountainAura.page\\FountainAura.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function Y8r takes nothing returns boolean
set eIx=Vnx(eAx)
return true
endfunction
function Y9r takes nothing returns boolean
set eNx=lQx(ebx+" (dummyBuff)")
return true
endfunction
function zvr takes nothing returns boolean
call LZx('AFoA',false)
set Gtv=Lzo('AFoA')
set G6[(Gtv)]=(D6)
set j6[(Gtv)]=(1)
set sH[(Gtv)]=("Fountain Aura")
set xzv[(Gtv)]=("spell")
call LZo((Gtv),u6v+(1),((575)*1.))
call LZo((Gtv),Lvv+(1),((750)*1.))
set Mnv[(Gtv)]=("ReplaceableTextures\\CommandButtons\\")
return true
endfunction
function zer takes nothing returns boolean
call VRx(Ma,(function Y9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\FountainAura.page\\FountainAura.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function zvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\FountainAura.page\\FountainAura.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function zxr takes nothing returns boolean
set eBx=Vnx(ebx)
return true
endfunction
function zor takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if((rG[(Ixx)])>=(R2I((((iG[(Ixx)]))*1.))))then
return false
endif
return true
return true
endfunction
function zrr takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer XSr=Xpr(Ixx)
set eCx[oqx]=XSr
set edx[oqx]=rwx
set Eee[(XSr)]=(oqx)
set vme[(XSr)]=(((Cpx((Gtv),u6v+(rwx))))*1.)
set vMe[(XSr)]=(ecx)
call XPr(XSr,eDx)
call XPr(XSr,efx)
call XQr(XSr)
return true
endfunction
function zir takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call X2r(eCx[oqx])
return true
endfunction
function zar takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(eNx),((Mv[(rdx)])),w)
return true
endfunction
function znr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),eNx)
return true
endfunction
function zVr takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer rkx=(Eee[(XSr)])
call UJx(Ixx,eRx)
return true
endfunction
function zEr takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer CMx=(vhe[(XSr)])
local integer rkx=(Eee[(XSr)])
local integer rwx=edx[rkx]
call DSx((Ixx),(eRx),(rwx),w)
return true
endfunction
function zXr takes nothing returns nothing
set eDx=XBx("FolderFountainAura_StructTarget_Init: set FolderFountainAura_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderFountainAura_StructTarget.Event_Ending)",vQe,pI,function zVr)
set efx=XBx("FolderFountainAura_StructTarget_Init: set FolderFountainAura_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderFountainAura_StructTarget.Event_Start)",vse,pI,function zEr)
endfunction
function zOr takes nothing returns boolean
set ecx=XLx(function zor)
call l9x(eNx,XBx("FountainAura_Init: call FountainAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FountainAura.Event_BuffGain))",Bd,pI,function zrr))
call l9x(eNx,XBx("FountainAura_Init: call FountainAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FountainAura.Event_BuffLose))",Jc,pI,function zir))
call meo(Gtv,XBx("FountainAura_Init: call FountainAura.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FountainAura.Event_Learn))",pv,pI,function zar))
call meo(Gtv,XBx("FountainAura_Init: call FountainAura.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FountainAura.Event_Unlearn))",Av,pI,function znr))
call zXr()
return true
endfunction
function zRr takes nothing returns boolean
call mvo(function zOr,"FountainAura_Init")
return true
endfunction
function zIr takes nothing returns boolean
set eFx=lQx(egx+" (dummyBuff)")
return true
endfunction
function zAr takes nothing returns boolean
call LZx('AFoH',false)
set hvv=Lzo('AFoH')
set G6[(hvv)]=(D6)
set j6[(hvv)]=(1)
set sH[(hvv)]=("Fountain Heal")
set x6v[(hvv)]=(4)
set xzv[(hvv)]=("spell")
call LZo((hvv),u6v+(1),((0)*1.))
call LZo((hvv),Lvv+(1),((0)*1.))
set Mnv[(hvv)]=("ReplaceableTextures\\CommandButtons\\")
return true
endfunction
function zNr takes nothing returns boolean
call LZx('AFHD',false)
set eGx=Lzo('AFHD')
set G6[(eGx)]=(D6)
set j6[(eGx)]=(1)
set sH[(eGx)]=("Fountain Heal")
set x6v[(eGx)]=(4)
set xzv[(eGx)]=("spell")
call LZo((eGx),Lvv+(1),((384)*1.))
return true
endfunction
function zbr takes nothing returns boolean
call VRx(Ma,(function zIr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\FountainHeal.page\\FountainHeal.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function zAr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\FountainHeal.page\\FountainHeal.struct\\obj_thisSpell_wc3spell.j"))
call VRx(qa,(function zNr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\FountainHeal.page\\FountainHeal.struct\\obj_dummySpell_wc3spell.j"))
return true
endfunction
function zBr takes nothing returns boolean
set ehx=Vnx(egx)
return true
endfunction
function zcr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx
local integer Ixx
local integer sEo
if((Nh[(rdx)])!=E4)then
return true
endif
set CMx=(Vv[(rdx)])
set Ixx=(WH[(rdx)])
set sEo=(ze[(Ixx)])
call rQx(Ixx,'AFHD')
call Qzx(sEo,'AFHD',true)
call Lvx(Ixx,d3,CMx)
call Qzx(sEo,'AFHD',false)
return true
endfunction
function zCr takes nothing returns boolean
local integer rdx=(bv)
call I7x((Vv[(rdx)]),eHx)
return true
endfunction
function zdr takes nothing returns boolean
local integer rdx=(bv)
call Rmx((Vv[(rdx)]),eHx)
return true
endfunction
function zDr takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(eFx),((Mv[(rdx)])),w)
return true
endfunction
function zfr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),eFx)
return true
endfunction
function zFr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(WH[(rdx)])
local integer Ixx=(Vv[(rdx)])
local real zgr=((iG[(Ixx)])-(rG[(Ixx)]))*1./ ejx
local real zGr=((mF[(Ixx)])-(LF[(Ixx)]))*1./ eJx
local real zhr=zgr+zGr
local real zHr=itx((LF[(CMx)]),zhr)
call Cbx(Ixx)
if(zHr<10.)then
call OMx(CMx,iqx((GetUnitName(C[(CMx)]))+" empty or target nearly full","ffff0000"),.024,120.,1.,2.,ekx+CMx)
return true
endif
call RUx((Abx((CMx),(eKx),(elx),(ri))))
if(zgr>.0)then
call RUx((Abx((Ixx),(eLx),(emx),(ri))))
call moo(CMx,Ixx,zHr*zgr*1./ zhr*ejx)
endif
if(zGr>.0)then
call RUx((Abx((Ixx),(eMx),(epx),(ri))))
call mro(CMx,Ixx,zHr*zGr*1./ zhr*eJx)
endif
call Ybo(CMx,zHr)
return true
endfunction
function zjr takes nothing returns boolean
set eHx=XBx("FountainHeal_Init: set FountainHeal.ORDER_EVENT = Event.Create(UNIT.Order.Events.Gain.Target.TARGET_EVENT_TYPE, EventPriority.SPELLS, function FountainHeal.Event_Order)",hj,pI,function zcr)
call l9x(eFx,XBx("FountainHeal_Init: call FountainHeal.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FountainHeal.Event_BuffGain))",Bd,pI,function zCr))
call l9x(eFx,XBx("FountainHeal_Init: call FountainHeal.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FountainHeal.Event_BuffLose))",Jc,pI,function zdr))
call meo(hvv,XBx("FountainHeal_Init: call FountainHeal.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FountainHeal.Event_Learn))",pv,pI,function zDr))
call meo(hvv,XBx("FountainHeal_Init: call FountainHeal.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FountainHeal.Event_Unlearn))",Av,pI,function zfr))
call meo(eGx,XBx("FountainHeal_Init: call FountainHeal.DUMMY_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.PRE_EVENT_TYPE, EventPriority.SPELLS, function FountainHeal.Event_SpellEffect))",div,pI,function zFr))
return true
endfunction
function zJr takes nothing returns boolean
call mvo(function zjr,"FountainHeal_Init")
return true
endfunction
function zkr takes nothing returns boolean
set ePx=lQx(eqx+" (coldnessBuff)")
set qc[(ePx)]=(true)
return true
endfunction
function zKr takes nothing returns boolean
set eQx=lQx(eqx+" (dummyBuff)")
return true
endfunction
function zlr takes nothing returns boolean
call LZx('AFrA',false)
set g0v=Lzo('AFrA')
set G6[(g0v)]=(D6)
set j6[(g0v)]=(6)
set sH[(g0v)]=("Frost Attack")
set xzv[(g0v)]=("spell")
call LZo((g0v),u6v+(1),(($8C)*1.))
call LZo((g0v),Lvv+(1),((750)*1.))
call LZo((g0v),u6v+(2),(($8C)*1.))
call LZo((g0v),Lvv+(2),((750)*1.))
call LZo((g0v),u6v+(3),(($8C)*1.))
call LZo((g0v),Lvv+(3),((750)*1.))
call LZo((g0v),u6v+(4),(($8C)*1.))
call LZo((g0v),Lvv+(4),((750)*1.))
call LZo((g0v),u6v+(5),(($8C)*1.))
call LZo((g0v),Lvv+(5),((750)*1.))
call LZo((g0v),u6v+(6),(($8C)*1.))
call LZo((g0v),Lvv+(6),((750)*1.))
set Mnv[(g0v)]=("ReplaceableTextures\\PassiveButtons\\PASBTNFreezingBreath.blp")
set esx[1]=2
set esx[2]=2.5
set esx[3]=3
set esx[4]=3.5
set esx[5]=4
set esx[6]=4.5
return true
endfunction
function zLr takes nothing returns boolean
call VRx(Ma,(function zkr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\FrostAttack.page\\FrostAttack.struct\\obj_coldnessBuff_wc3buff.j"))
call VRx(Ma,(function zKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\FrostAttack.page\\FrostAttack.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function zlr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\FrostAttack.page\\FrostAttack.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function zmr takes nothing returns boolean
set eSx=Vnx(eqx)
return true
endfunction
function zMr takes integer oqx returns real
local integer olx=(CXx(((oqx)),Alv))
local real o4x=.0
loop
exitwhen(olx<q)
set o4x=iOx(o4x,(Akv[((COx(((oqx)),Alv,(olx))))]))
set olx=olx-1
endloop
return o4x
endfunction
function zpr takes integer Ixx returns boolean
return( not(I6x(Ixx,sc)))and( not(I6x(Ixx,IBv)))and( not(I6x(Ixx,ICv)))and( not(nIo(Ixx)))
endfunction
function zPr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(EYv[(rdx)])
local integer Ixx=(Vv[(rdx)])
local real dix=(GetUnitX(C[((Ixx))]))
local real dax=(GetUnitY(C[((Ixx))]))
local integer rwx=(oPx(((CMx)),N+(g0v)))
local real ilx=esx[rwx]
set Hf=(ze[(CMx)])
call Nio(etx,dix,dax,zMr(CMx),eux)
call GroupRemoveUnit(Kb[(etx)],C[(Ixx)])
if zpr(Ixx)then
call NIx((Ixx),(ePx),(rwx),w,((ilx)*1.))
endif
set Ixx=Nao(etx)
if(Ixx!=w)then
loop
call NIx((Ixx),(ePx),(rwx),w,((ilx)*1.))
set Ixx=Nao(etx)
exitwhen(Ixx==w)
endloop
endif
return true
endfunction
function zqr takes nothing returns boolean
local integer Ixx=jFx()
if zpr(Ixx)then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function zQr takes nothing returns boolean
local integer rdx=(bv)
call I7x((Vv[(rdx)]),eTx)
return true
endfunction
function zsr takes nothing returns boolean
local integer rdx=(bv)
call Rmx((Vv[(rdx)]),eTx)
return true
endfunction
function zSr takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(eQx),((Mv[(rdx)])),w)
return true
endfunction
function ztr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),eQx)
return true
endfunction
function zTr takes nothing returns boolean
set etx=O2x()
set eTx=XBx("FrostAttack_Init: set FrostAttack.GROUND_ATTACK_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function FrostAttack.Event_GroundAttack)",EZv,pI,function zPr)
set eux=XLx(function zqr)
call l9x(eQx,XBx("FrostAttack_Init: call FrostAttack.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FrostAttack.Event_BuffGain))",Bd,pI,function zQr))
call l9x(eQx,XBx("FrostAttack_Init: call FrostAttack.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FrostAttack.Event_BuffLose))",Jc,pI,function zsr))
call meo(g0v,XBx("FrostAttack_Init: call FrostAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FrostAttack.Event_Learn))",pv,pI,function zSr))
call meo(g0v,XBx("FrostAttack_Init: call FrostAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FrostAttack.Event_Unlearn))",Av,pI,function ztr))
call W_x(nxv,ePx)
return true
endfunction
function zur takes nothing returns boolean
call mvo(function zTr,"FrostAttack_Init")
return true
endfunction
function zUr takes nothing returns boolean
set eUx=lQx(ewx+" (dummyBuff)")
return true
endfunction
function zwr takes nothing returns boolean
set YKv=(LYo((ewx+" (thisSpell)")))
set j6[(YKv)]=(1)
set sH[(YKv)]=("Invisibility")
set Ih[(YKv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0278)))),(((Oj))))))
set xzv[(YKv)]=("spell")
return true
endfunction
function zWr takes nothing returns boolean
call VRx(Ma,(function zUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\Invisibility.page\\Invisibility.struct\\obj_dummyBuff_wc3buff.j"))
call VRx(qa,(function zwr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\Invisibility.page\\Invisibility.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function zyr takes nothing returns boolean
set eWx=Vnx(ewx)
return true
endfunction
function zYr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call DSx((((Ixx))),(nLv),(1),w)
return true
endfunction
function zzr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call UJx(((Ixx)),nLv)
return true
endfunction
function zZr takes nothing returns boolean
local integer rdx=(bv)
call Q8o((Vv[(rdx)]),eUx,(Mv[(rdx)]))
return true
endfunction
function z_r takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),eUx)
return true
endfunction
function z0r takes nothing returns boolean
call l9x(eUx,XBx("Invisibility_Init: call Invisibility.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Invisibility.Event_BuffGain))",Bd,pI,function zYr))
call l9x(eUx,XBx("Invisibility_Init: call Invisibility.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Invisibility.Event_BuffLose))",Jc,pI,function zzr))
call meo(YKv,XBx("Invisibility_Init: call Invisibility.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Invisibility.Event_Learn))",pv,pI,function zZr))
call meo(YKv,XBx("Invisibility_Init: call Invisibility.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Invisibility.Event_Unlearn))",Av,pI,function z_r))
return true
endfunction
function z1r takes nothing returns boolean
call mvo(function z0r,"Invisibility_Init")
return true
endfunction
function z2r takes nothing returns boolean
set gQv=(LYo((eyx+" (thisSpell)")))
set j6[(gQv)]=(1)
set sH[(gQv)]=("Invulnerability")
set Ih[(gQv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0278)))),(((Oj))))))
set xzv[(gQv)]=("spell")
return true
endfunction
function z3r takes nothing returns boolean
set eYx=lQx(eyx+" (dummyBuff)")
set SU=lYx()
call l0x(((eYx)),vc+(1),(SU))
return true
endfunction
function z4r takes nothing returns boolean
call VRx(qa,(function z2r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\Invulnerability.page\\Invulnerability.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function z3r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\Invulnerability.page\\Invulnerability.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function z5r takes nothing returns boolean
set ezx=Vnx(eyx)
return true
endfunction
function z6r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
call SetUnitInvulnerable(C[Ixx],true)
return true
endfunction
function z7r takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
call SetUnitInvulnerable(C[Ixx],false)
return true
endfunction
function z8r takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(eYx),((Mv[(rdx)])),w)
return true
endfunction
function z9r takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),eYx)
return true
endfunction
function Zvr takes nothing returns boolean
call l9x(eYx,XBx("Invulnerability_Init: call Invulnerability.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Invulnerability.Event_BuffGain))",Bd,pI,function z6r))
call l9x(eYx,XBx("Invulnerability_Init: call Invulnerability.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Invulnerability.Event_BuffLose))",Jc,pI,function z7r))
call meo(gQv,XBx("Invulnerability_Init: call Invulnerability.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Invulnerability.Event_Learn))",pv,pI,function z8r))
call meo(gQv,XBx("Invulnerability_Init: call Invulnerability.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Invulnerability.Event_Unlearn))",Av,pI,function z9r))
return true
endfunction
function Zer takes nothing returns boolean
call mvo(function Zvr,"Invulnerability_Init")
return true
endfunction
function Zxr takes nothing returns boolean
set eZx=WTx('BLap',"Lapidated",'bLap')
set qU[(eZx)]=(true)
set aev[(eZx)]=("ReplaceableTextures\\CommandButtons\\BTNGolemStormBolt.blp")
call lux(eZx,"Abilities\\Weapons\\RockBoltMissile\\RockBoltMissile.mdl","origin",ri)
call lux(eZx,"Abilities\\Weapons\\RockBoltMissile\\RockBoltMissile.mdl","foot left",Bi)
call lux(eZx,"Abilities\\Weapons\\RockBoltMissile\\RockBoltMissile.mdl","foot right",Bi)
call lux(eZx,"Abilities\\Weapons\\RockBoltMissile\\RockBoltMissile.mdl","hand left",Bi)
call lux(eZx,"Abilities\\Weapons\\RockBoltMissile\\RockBoltMissile.mdl","hand right",Bi)
return true
endfunction
function Zor takes nothing returns boolean
call VRx(Ma,(function Zxr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\Lapidation.page\\Lapidation.struct\\Buff\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function Zrr takes nothing returns boolean
set e_x=Vnx(e0x)
return true
endfunction
function Zir takes nothing returns boolean
call LZx('ALap',false)
set e1x=Lzo('ALap')
set j6[(e1x)]=(1)
set sH[(e1x)]=("Lapidation")
set Ih[(e1x)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0103)))),(((Oj))))))
set x6v[(e1x)]=(2)
set xzv[(e1x)]=("spell")
call LZo((e1x),u6v+(1),((700)*1.))
call LZo((e1x),fH+(1),((60)*1.))
call LZo((e1x),QH+(1),((80)*1.))
call LZo((e1x),Lvv+(1),((99999)*1.))
set Mnv[(e1x)]=("ReplaceableTextures\\CommandButtons\\BTNGolemStormBolt.blp")
return true
endfunction
function Zar takes nothing returns boolean
call VRx(qa,(function Zir),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\Lapidation.page\\Lapidation.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Znr takes nothing returns boolean
set e2x=Vnx(e3x)
return true
endfunction
function ZVr takes integer Ixx returns boolean
return( not(I6x(Ixx,sc)))and(I6x(Ixx,INv))and( not(I6x(Ixx,IBv)))and( not(IsUnitAlly(C[(Ixx)],vx[(Hf)])))
endfunction
function ZEr takes nothing returns boolean
return(ZVr(jFx()))
endfunction
function ZXr takes integer oqx returns integer
set e7x[oqx]=true
set e8x[oqx]=false
call rax(e2x)
return oqx
endfunction
function ZOr takes integer oqx returns nothing
set e7x[oqx]=false
call rgx(e2x)
endfunction
function ZRr takes integer rwx,integer Ixx returns nothing
call NIx((Ixx),(eZx),(rwx),w,((xrx)*1.))
endfunction
function ZIr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=e9x[oqx]
local real NIo=xvx[oqx]
local integer rwx=xxx[oqx]
local integer Ixx=xox[oqx]
call ZOr(oqx)
call Mdo(MFo)
set Hf=(ze[(CMx)])
if ZVr(Ixx)then
call ZRr(rwx,Ixx)
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
endif
return true
endfunction
function ZAr takes integer CMx,integer rwx,integer Ixx returns nothing
local integer MFo=Mvo()
local integer oqx=ZXr(MFo)
set e9x[oqx]=CMx
set xvx[oqx]=xex
set xxx[oqx]=rwx
set xox[oqx]=Ixx
set mAv[((MFo))]=((b6v*((.06)*1.))*1.)
set mNv[(MFo)]=((10.)*1.)
call Mro(MFo,'qLap',2.)
set mCv[(MFo)]=XHx((function ZIr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,1400.)
call M9o(MFo,CMx)
call M3o((MFo),(Ixx),.0,.0,.0,(null))
endfunction
function ZNr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(Vv[(rdx)])
local integer rwx=(Mv[(rdx)])
local real dix=(UH[(rdx)])
local real dax=(wH[(rdx)])
local integer Ixx
local integer olx
set Hf=(ze[(CMx)])
call Nio(e4x,dix,dax,(Cpx((e1x),u6v+(rwx))),e5x)
set Ixx=(onr((e4x)))
if(Ixx!=w)then
set olx=e6x
loop
exitwhen(olx<1)
call GroupRemoveUnit(Kb[(e4x)],C[(Ixx)])
call ZAr(CMx,rwx,Ixx)
set Ixx=(onr((e4x)))
exitwhen(Ixx==w)
set olx=olx-1
endloop
endif
return true
endfunction
function Zbr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call Q9r(Ixx,1.)
return true
endfunction
function ZBr takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call QKr(Ixx,1.)
return true
endfunction
function Zcr takes nothing returns nothing
call l9x(eZx,XBx("FolderLapidation_StructBuff_Init: call FolderLapidation_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderLapidation_StructBuff.Event_BuffGain))",Bd,pI,function Zbr))
call l9x(eZx,XBx("FolderLapidation_StructBuff_Init: call FolderLapidation_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderLapidation_StructBuff.Event_BuffLose))",Jc,pI,function ZBr))
call W_x(Xsv,eZx)
endfunction
function ZCr takes nothing returns boolean
set e4x=O2x()
set e5x=XLx(function ZEr)
call meo(e1x,XBx("Lapidation_Init: call Lapidation.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Lapidation.Event_SpellEffect))",ah,pI,function ZNr))
call Zcr()
return true
endfunction
function Zdr takes nothing returns boolean
call mvo(function ZCr,"Lapidation_Init")
return true
endfunction
function ZDr takes nothing returns boolean
call LZx('ALiA',false)
set Gmv=Lzo('ALiA')
set G6[(Gmv)]=(D6)
set j6[(Gmv)]=(6)
set sH[(Gmv)]=("Lightning Attack")
set xzv[(Gmv)]=("spell")
call LZo((Gmv),u6v+(1),((500)*1.))
call LZo((Gmv),Lvv+(1),((750)*1.))
call LZo((Gmv),u6v+(2),((500)*1.))
call LZo((Gmv),Lvv+(2),((750)*1.))
call LZo((Gmv),u6v+(3),((500)*1.))
call LZo((Gmv),Lvv+(3),((750)*1.))
call LZo((Gmv),u6v+(4),((500)*1.))
call LZo((Gmv),Lvv+(4),((750)*1.))
call LZo((Gmv),u6v+(5),((500)*1.))
call LZo((Gmv),Lvv+(5),((750)*1.))
call LZo((Gmv),u6v+(6),((500)*1.))
call LZo((Gmv),Lvv+(6),((750)*1.))
set Mnv[(Gmv)]=("ReplaceableTextures\\CommandButtons\\PASBTNLightningAttack.blp")
set xix[1]=$A
set xix[2]=$A
set xix[3]=$A
set xix[4]=$A
set xix[5]=$A
set xix[6]=$A
set xax[1]=2
set xax[2]=3
set xax[3]=3
set xax[4]=4
set xax[5]=4
set xax[6]=5
set xnx[1]=1.25
set xnx[2]=1.25
set xnx[3]=1.25
set xnx[4]=1.25
set xnx[5]=1.25
set xnx[6]=1.25
set xVx[1]=.2
set xVx[2]=.2
set xVx[3]=.2
set xVx[4]=.2
set xVx[5]=.2
set xVx[6]=.2
set xEx[1]=20
set xEx[2]=35
set xEx[3]=50
set xEx[4]=65
set xEx[5]=80
set xEx[6]=95
return true
endfunction
function Zfr takes nothing returns boolean
set xXx=Vbx("OLAP")
return true
endfunction
function ZFr takes nothing returns boolean
set xOx=Vbx("OLAS")
return true
endfunction
function Zgr takes nothing returns boolean
set xRx=lQx(xIx+" (dummyBuff)")
return true
endfunction
function ZGr takes nothing returns boolean
call VRx(qa,(function ZDr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\LightningAttack.page\\LightningAttack.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ha,(function Zfr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\LightningAttack.page\\LightningAttack.struct\\obj_boltPrimary_wc3bolt.j"))
call VRx(Ha,(function ZFr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\LightningAttack.page\\LightningAttack.struct\\obj_boltSecondary_wc3bolt.j"))
call VRx(Ma,(function Zgr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\LightningAttack.page\\LightningAttack.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function Zhr takes nothing returns boolean
set xAx=Vnx(xIx)
return true
endfunction
function ZHr takes integer oqx returns integer
set xdx[oqx]=true
set xDx[oqx]=false
call rax(xAx)
return oqx
endfunction
function Zjr takes nothing returns integer
local integer oqx
if(xbx==8190)then
call oYx("LightningAttack_Allocation_allocCustom","call DebugEx(LightningAttack.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",xIx+" - alloc: unable to allocCustom, reached stack limit")
return w
endif
if(xBx[(w)]==w)then
set xcx=xcx+1
set oqx=xcx
else
set oqx=xBx[(w)]
set xBx[(w)]=xBx[xBx[(w)]]
endif
set xBx[oqx]=Z
set xCx[oqx]=1
call ZHr(oqx)
return oqx
endfunction
function ZJr takes integer Ixx returns boolean
return( not(I6x(Ixx,sc)))and( not(I6x(Ixx,IBv)))and( not(IsUnitAlly(C[(Ixx)],vx[(Hf)])))and( not(nIo(Ixx)))
endfunction
function Zkr takes integer oqx returns nothing
set xdx[oqx]=false
call rgx(xAx)
endfunction
function ZKr takes integer oqx returns nothing
if(xCx[oqx]>0)then
return
endif
if(xBx[oqx]!=Z)then
call oYx("LightningAttack_Allocation_deallocCustom_confirm","call DebugEx(LightningAttack.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",xIx+" - alloc: unable to deallocCustom instance "+I2S(oqx))
return
endif
set xBx[oqx]=xBx[(w)]
set xBx[(w)]=oqx
call Zkr(oqx)
endfunction
function Zlr takes integer oqx returns nothing
set xCx[oqx]=xCx[oqx]-1
call ZKr(oqx)
endfunction
function ZLr takes integer oqx returns nothing
call Zlr((oqx))
call XYr(xkx[oqx])
endfunction
function Zmr takes integer oqx,integer ENr,integer Ebr,integer Ixx,integer Q7o returns nothing
set Rd=oqx
set Id=ENr
set Ad=Ebr
set Nd=Ixx
set npe=Q7o
call TriggerEvaluate(xQx)
endfunction
function ZMr takes nothing returns boolean
local integer rdx=(bv)
local integer MFo=(WY[(rdx)])
local integer oqx=(mWv[(MFo)])
local integer CMx=xFx[oqx]
local integer Ecr=xHx[oqx]
local integer ECr=xKx[oqx]
local integer Ixx=xLx[oqx]
local integer Q7o=xkx[oqx]
local integer Zpr
local real NIo
local real dix
local real dax
local integer Edr
if(Ixx!=w)then
set Zpr=Qax(xmx,false,true,true,$A,$A,h5)
call RUx((Abx((Ixx),(xMx),(xpx),(Bi))))
call P5o(Zpr,(GetUnitX(C[((Ixx))])),(GetUnitY(C[((Ixx))])),fwx(Ixx))
call R1x(Zpr,true)
set Hf=(ze[(CMx)])
if ZJr(Ixx)then
set NIo=xgx[oqx]
set xgx[oqx]=NIo*(1.-xGx[oqx])
if(ECr<=xJx[oqx])then
call NIx((Ixx),(Xsv),(xhx[oqx]),w,((xjx[oqx])*1.))
endif
call nJo((CMx),(Ixx),((NIo)*1.),(true),(false))
endif
endif
if(ECr==Ecr)then
call ZLr(oqx)
else
set dix=(GetUnitX(C[((Ixx))]))
set dax=(GetUnitY(C[((Ixx))]))
set OPe=Q7o
set Hf=(ze[(CMx)])
call Nio(xPx,dix,dax,xfx[oqx],xqx)
set Edr=(mjo((xPx),((dix)*1.),((dax)*1.)))
if(Edr==w)then
call ZLr(oqx)
else
set xKx[oqx]=ECr+1
call Zmr(oqx,xOx,Ixx,Edr,Q7o)
endif
endif
call Mdo(MFo)
return true
endfunction
function ZPr takes integer oqx,integer ENr,integer Ebr,integer Ixx,integer Q7o returns nothing
local integer MFo=Mvo()
local integer clo=cBo(ENr)
set xlx[oqx]=MFo
set xLx[oqx]=Ixx
call EEr(clo,Ebr,Ixx)
call GroupAddUnit(Kb[(Q7o)],C[(Ixx)])
call cko(clo,.75)
set mNv[(MFo)]=((10.)*1.)
set mCv[(MFo)]=XHx((function ZMr))
set mWv[(MFo)]=(oqx)
call m8o(MFo,iOx(jjx((GetUnitX(C[((Ixx))]))-(GetUnitX(C[((Ebr))])),(GetUnitY(C[((Ixx))]))-(GetUnitY(C[((Ebr))])))*1./ .25,700.))
call M9o(MFo,Ebr)
call M3o((MFo),(Ixx),.0,.0,.0,(null))
endfunction
function Zqr takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=(EYv[(rdx)])
local integer Ixx=(Vv[(rdx)])
local real wpo=(GetUnitX(C[((CMx))]))
local real wPo=(GetUnitY(C[((CMx))]))
local integer rwx=(oPx(((CMx)),N+(Gmv)))
local integer oqx=Zjr()
local integer Q7o=O2x()
set xfx[oqx]=(Cpx((Gmv),u6v+(rwx)))
set xFx[oqx]=CMx
set xgx[oqx]=xEx[rwx]
set xGx[oqx]=xVx[rwx]
set xhx[oqx]=rwx
set xHx[oqx]=xix[rwx]
set xjx[oqx]=xnx[rwx]
set xJx[oqx]=xax[rwx]
set xkx[oqx]=Q7o
set xKx[oqx]=1
call ZPr(oqx,xXx,CMx,Ixx,Q7o)
return true
endfunction
function ZQr takes nothing returns boolean
local integer Ixx=jFx()
if(I5x((OPe),Rb,(Ixx)))then
return false
endif
if not ZJr(Ixx)then
return false
endif
return true
return true
endfunction
function Zsr takes nothing returns boolean
local integer rdx=(bv)
call I7x((Vv[(rdx)]),xNx)
return true
endfunction
function ZSr takes nothing returns boolean
local integer rdx=(bv)
call Rmx((Vv[(rdx)]),xNx)
return true
endfunction
function Ztr takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(xRx),((Mv[(rdx)])),w)
return true
endfunction
function ZTr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),xRx)
return true
endfunction
function Zur takes nothing returns boolean
set xNx=XBx("LightningAttack_Init: set LightningAttack.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function LightningAttack.Event_Damage)",EZv,pI,function Zqr)
set xPx=O2x()
set xqx=XLx(function ZQr)
call l9x(xRx,XBx("LightningAttack_Init: call LightningAttack.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LightningAttack.Event_BuffGain))",Bd,pI,function Zsr))
call l9x(xRx,XBx("LightningAttack_Init: call LightningAttack.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LightningAttack.Event_BuffLose))",Jc,pI,function ZSr))
call meo(Gmv,XBx("LightningAttack_Init: call LightningAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LightningAttack.Event_Learn))",pv,pI,function Ztr))
call meo(Gmv,XBx("LightningAttack_Init: call LightningAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LightningAttack.Event_Unlearn))",Av,pI,function ZTr))
return true
endfunction
function ZUr takes nothing returns boolean
call mvo(function Zur,"LightningAttack_Init")
return true
endfunction
function Zwr takes nothing returns boolean
set fhe=(LYo((xsx+" (thisSpell)")))
set j6[(fhe)]=(1)
set sH[(fhe)]=("Magic Immunity")
set Ih[(fhe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0278)))),(((Oj))))))
set xzv[(fhe)]=("spell")
return true
endfunction
function ZWr takes nothing returns boolean
set xSx=lQx(xsx+" (dummyBuff)")
set SU=lYx()
call vOr(SU,Dhv,true)
call l0x(((xSx)),vc+(1),(SU))
return true
endfunction
function Zyr takes nothing returns boolean
call VRx(qa,(function Zwr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\MagicImmunity.page\\MagicImmunity.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function ZWr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\MagicImmunity.page\\MagicImmunity.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function ZYr takes nothing returns boolean
set xtx=Vnx(xsx)
return true
endfunction
function Zzr takes nothing returns boolean
local integer rdx=(bv)
call DSx(((Vv[(rdx)])),(xSx),((Mv[(rdx)])),w)
return true
endfunction
function ZZr takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),xSx)
return true
endfunction
function Z_r takes nothing returns boolean
call meo(fhe,XBx("MagicImmunity_Init: call MagicImmunity.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MagicImmunity.Event_Learn))",pv,pI,function Zzr))
call meo(fhe,XBx("MagicImmunity_Init: call MagicImmunity.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MagicImmunity.Event_Unlearn))",Av,pI,function ZZr))
return true
endfunction
function Z0r takes nothing returns boolean
call mvo(function Z_r,"MagicImmunity_Init")
return true
endfunction
function Z1r takes nothing returns boolean
call LZx('AMtP',false)
set Gsv=Lzo('AMtP')
set G6[(Gsv)]=(D6)
set j6[(Gsv)]=(2)
set sH[(Gsv)]=("Meteorite Protection")
set xzv[(Gsv)]=("spell")
call LZo((Gsv),Lvv+(1),((750)*1.))
return true
endfunction
function Z2r takes nothing returns boolean
call VRx(qa,(function Z1r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\MeteoriteProtection.page\\MeteoriteProtection.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Z3r takes nothing returns boolean
set xTx=Vnx(xux)
return true
endfunction
function Z4r takes nothing returns boolean
call LZx('AReM',false)
set xUx=Lzo('AReM')
set j6[(xUx)]=(1)
set sH[(xUx)]=("Refresh Mana")
set Ih[(xUx)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0244)))),(((Oj))))))
set x6v[(xUx)]=(0)
set xzv[(xUx)]=("spell")
call LZo((xUx),fH+(1),((30)*1.))
call LZo((xUx),QH+(1),((90)*1.))
set Mnv[(xUx)]=("ReplaceableTextures\\CommandButtons\\BTNManaRecharge.blp")
return true
endfunction
function Z5r takes nothing returns boolean
call VRx(qa,(function Z4r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\RefreshMana.page\\RefreshMana.struct\\obj_thisSpell_wc3spell.j"))
return true
endfunction
function Z6r takes nothing returns boolean
set xwx=Vnx(xWx)
return true
endfunction
function Z7r takes integer Oqx returns integer
return pwv[(oPx(Oqx,p_v))]
endfunction
function Z8r takes integer oqx,code iDx,boolean Z9r returns nothing
local integer olx=Jh
local integer Ixx
loop
exitwhen(olx<0)
set Ixx=(kv[((kh[olx]))])
if I6x(Ixx,sc)then
if Z9r then
call GroupAddUnit(Kb[(h8v)],C[(Z7r(Ixx))])
endif
else
call GroupAddUnit(Kb[(h8v)],C[(Ixx)])
endif
set olx=olx-1
endloop
call ForGroup(Kb[(h8v)],(iDx))
endfunction
function vvi takes nothing returns boolean
local integer rdx=(bv)
local integer CMx=xyx
local integer Ixx=RVx()
call RUx((Abx((Ixx),(xYx),(xzx),(ri))))
call mro(CMx,Ixx,(mF[(Ixx)])*xZx)
return true
endfunction
function vei takes nothing returns boolean
local integer rdx=(bv)
set xyx=(Vv[(rdx)])
call Z8r(NZ,function vvi,true)
return true
endfunction
function vxi takes nothing returns boolean
call meo(xUx,XBx("RefreshMana_Init: call RefreshMana.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RefreshMana.Event_SpellEffect))",ah,pI,function vei))
return true
endfunction
function voi takes nothing returns boolean
call mvo(function vxi,"RefreshMana_Init")
return true
endfunction
function vri takes nothing returns boolean
set x_x=WTx('BRVA',"Discovered",'bRVA')
set aev[(x_x)]=("ReplaceableTextures\\CommandButtons\\BTNHeal.blp")
return true
endfunction
function vii takes nothing returns boolean
call VRx(Ma,(function vri),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\RevealAura.page\\RevealAura.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function vai takes nothing returns boolean
set x0x=Vnx(x1x)
return true
endfunction
function vni takes nothing returns boolean
call LZx('AReA',false)
set uFv=Lzo('AReA')
set G6[(uFv)]=(D6)
set j6[(uFv)]=(2)
set sH[(uFv)]=("Reveal Aura")
set xzv[(uFv)]=("spell")
call LZo((uFv),u6v+(1),(($C8)*1.))
call LZo((uFv),Lvv+(1),((750)*1.))
call LZo((uFv),u6v+(2),(($5DC)*1.))
call LZo((uFv),Lvv+(2),((750)*1.))
set Mnv[(uFv)]=("ReplaceableTextures\\PassiveButtons\\PASBTNMagicalSentry.blp")
return true
endfunction
function vVi takes nothing returns boolean
set x2x=lQx(x3x+" (dummyBuff)")
call lux(x2x,"Abilities\\Spells\\Human\\MagicSentry\\MagicSentryCaster.mdl","overhead",ri)
return true
endfunction
function vEi takes nothing returns boolean
call VRx(qa,(function vni),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\RevealAura.page\\RevealAura.struct\\obj_thisSpell_wc3spell.j"))
call VRx(Ma,(function vVi),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\RevealAura.page\\RevealAura.struct\\obj_dummyBuff_wc3buff.j"))
return true
endfunction
function vXi takes nothing returns boolean
set x4x=Vnx(x3x)
return true
endfunction
function vOi takes nothing returns boolean
local integer Ixx=jFx()
if I6x(Ixx,sc)then
return false
endif
if I6x(Ixx,ICv)then
return false
endif
if not(xk[(Ixx)])then
return false
endif
if(IsUnitAlly(C[(Ixx)],vx[(Hf)]))then
return false
endif
return true
return true
endfunction
function vRi takes nothing returns boolean
local integer rdx=(bv)
local integer rwx=(Hc[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
local integer XSr=Xpr(Ixx)
set x6x[oqx]=XSr
set x7x[oqx]=rwx
set Eee[(XSr)]=(oqx)
set vme[(XSr)]=(((Cpx((uFv),u6v+(rwx))))*1.)
set vMe[(XSr)]=(x5x)
call XPr(XSr,x8x)
call XPr(XSr,x9x)
call XQr(XSr)
return true
endfunction
function vIi takes nothing returns boolean
local integer rdx=(bv)
local integer Ixx=(Vv[(rdx)])
local integer oqx=Ixx
call X2r(x6x[oqx])
return true
endfunction
function vAi takes nothing returns boolean
local integer rdx=(bv)
call Q8o((Vv[(rdx)]),x2x,(Mv[(rdx)]))
return true
endfunction
function vNi takes nothing returns boolean
local integer rdx=(bv)
call Ayx((Vv[(rdx)]),x2x)
return true
endfunction
function vbi takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer rkx=(Eee[(XSr)])
call UJx(Ixx,x_x)
return true
endfunction
function vBi takes nothing returns boolean
local integer rdx=(bv)
local integer XSr=(vPe[(rdx)])
local integer Ixx=(Vv[(rdx)])
local integer CMx=(vhe[(XSr)])
local integer rkx=(Eee[(XSr)])
local integer rwx=x7x[rkx]
call DSx((Ixx),(x_x),(rwx),w)
return true
endfunction
function vci takes nothing returns nothing
set x8x=XBx("FolderRevealAura_StructTarget_Init: set FolderRevealAura_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderRevealAura_StructTarget.Event_Ending)",vQe,pI,function vbi)
set x9x=XBx("FolderRevealAura_StructTarget_Init: set FolderRevealAura_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderRevealAura_StructTarget.Event_Start)",vse,pI,function vBi)
endfunction
function vCi takes nothing returns boolean
set x5x=XLx(function vOi)
call l9x(x2x,XBx("RevealAura_Init: call RevealAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RevealAura.Event_BuffGain))",Bd,pI,function vRi))
call l9x(x2x,XBx("RevealAura_Init: call RevealAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RevealAura.Event_BuffLose))",Jc,pI,function vIi))
call meo(uFv,XBx("RevealAura_Init: call RevealAura.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RevealAura.Event_Learn))",pv,pI,function vAi))
call meo(uFv,XBx("RevealAura_Init: call RevealAura.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RevealAura.Event_Unlearn))",Av,pI,function vNi))
call vci()
return true
endfunction
function vdi takes nothing returns boolean
call mvo(function vCi,"RevealAura_Init")
return true
endfunction
function vDi takes nothing returns boolean
set v9x=hGo('UMet')
call hLo((v9x),('AInv'),1)
call hho(((v9x)),Apv,(yd))
call hho(((v9x)),Apv,(ICv))
set Tj[(v9x)]=((3)*1.)
set Nav[(v9x)]=((40)*1.)
set Ntv[(v9x)]=((60)*1.)
set I3v[(v9x)]=((0)*1.)
set Axv[(v9x)]=(3)
set NJv[(v9x)]=(($9C4)*1.)
set Njv[(v9x)]=(($9C4)*1.)
set Nhv[(v9x)]=((0)*1.)
set NKv[(v9x)]=(($C8)*1.)
set Nkv[(v9x)]=(($C8)*1.)
set NHv[(v9x)]=((.2)*1.)
set NIv[(v9x)]=(($3E8)*1.)
set NOv[(v9x)]=(($3E8)*1.)
set AQv[(v9x)]=((0)*1.)
set Asv[(v9x)]=((0)*1.)
set Auv[(v9x)]=(0)
set AWv[(v9x)]=(0)
call hLo((v9x),(vNx),1)
call hLo((v9x),(vYx),1)
call hLo((v9x),(vQx),1)
call hLo((v9x),(v2x),1)
call hLo((v9x),(e1x),1)
call hLo((v9x),(xUx),1)
return true
endfunction
function vfi takes nothing returns boolean
call VRx(Sa,(function vDi),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\System\\Meteorite.page\\Meteorite.struct\\obj_thisUnitType_wc3unit.j"))
return true
endfunction
function vFi takes nothing returns boolean
set ovx=Vnx(oex)
return true
endfunction
function vgi takes nothing returns boolean
local integer rdx=(bv)
call Cex((hw),w)
return true
endfunction
function vGi takes nothing returns boolean
local integer rdx=(bv)
call Yqr()
return true
endfunction
function vhi takes nothing returns boolean
local integer rdx=(bv)
call RUx((Abx(((Vv[(rdx)])),("Abilities\\Spells\\Other\\Monsoon\\MonsoonBoltTarget.mdl"),("origin"),(Bi))))
return true
endfunction
function vHi takes nothing returns boolean
local integer rdx=(bv)
local integer AFr=(EYv[(rdx)])
local integer vji=(oPx(((AFr)),N+(Gsv)))
if(vji==1)then
return true
endif
call DSx((((AFr))),(r9v),(1),w)
if(vji==2)then
call nDo(AFr,(iG[(AFr)])*.15)
else
call nDo(AFr,(iG[(AFr)])*.4)
endif
call UJx(((AFr)),r9v)
return true
endfunction
function vJi takes nothing returns nothing
local integer rdx=rEx(0)
local integer olx=Xv
local integer rIx
local integer rlx
loop
exitwhen(olx<0)
set rIx=Ov[olx]
set rlx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((JQv))-1)*Iv+(((rIx))-1)))))))))
loop
exitwhen(rlx<q)
call rCx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((JQv))-1)*Iv+(((rIx))-1))))+((rlx)))))),rdx)
set rlx=rlx-1
endloop
set olx=olx-1
endloop
call rHx(((rdx)))
endfunction
function vki takes nothing returns nothing
local string array vKi
local string vli
local integer vLi
local integer vmi
set jwv=true
set vKi[0]="Leave this grim place"
set vKi[1]="I can see the light"
set vKi[2]="It's too late"
set vKi[3]="The world descends into eternal ice"
set vKi[4]="Eternal fail shall befall you"
set vli=vKi[(GetRandomInt((0),(4)))]
set vLi=Smo()
call SWo(vLi,"I am okay with that",0)
call DialogSetMessage(ep[(vLi)],("The castle has fallen!"))
call SWo(vLi,vli,0)
call Sho(vLi,Ge,true)
set vmi=qAo()
call qao(vmi,0,$80,$80,(R2I(((.3*$FF)*1.))))
set pjv[(vmi)]=("ReplaceableTextures\\CameraMasks\\DreamFilter_Mask.blp")
call qCo(vmi,10.,Ge)
call vJi()
endfunction
function vMi takes nothing returns boolean
local integer rdx=(bv)
call vki()
return true
endfunction
function vpi takes nothing returns boolean
local integer rdx=(bv)
call aNx(hw,(eN[(rdx)]))
return true
endfunction
function vPi takes nothing returns boolean
local integer rdx=(bv)
set hw=(Vv[(rdx)])
set v8x=XBx("Meteorite_Event_Create: set Meteorite.LIFE_EVENT = Event.Create(UNIT.Life.DUMMY_EVENT_TYPE, EventPriority.MISC, function Meteorite.Event_Life)",hG,LI,function vGi)
set evx=S3o($A)
set eex=Qax("Sound\\Interface\\Warning.wav",false,false,false,$A,$A,D5)
set GC[(eex)]=((.5)*1.)
set v7x=(rG[(hw)])
call I7x(hw,XBx("Meteorite_Event_Create: call Meteorite.THIS_UNIT.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.MISC, function Meteorite.Event_Cast))",ah,LI,function vhi))
call I7x(hw,XBx("Meteorite_Event_Create: call Meteorite.THIS_UNIT.Event.Add(Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.MISC, function Meteorite.Event_Damage))",Ezv,LI,function vHi))
call I7x(hw,XBx("Meteorite_Event_Create: call Meteorite.THIS_UNIT.Event.Add(Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function Meteorite.Event_Death))",VP,LI,function vMi))
call I7x(hw,v8x)
call DNx(XBx("Meteorite_Event_Create: call Event.Create(USER.HostAppointment.DUMMY_EVENT_TYPE, EventPriority.MISC, function Meteorite.Event_HostChange).AddToStatics()",HYv,LI,function vpi))
if(Qbv!=w)then
call s4o((Qbv),(s5o()))
endif
call Roo(hw,IDv)
return true
endfunction
function vqi takes nothing returns boolean
set jwv=false
set JQv=(E0x())
call XUx(vN,"killM",XBx("Meteorite_Init: call StringData.Event.Add(\"killM\", Event.Create(User.CHAT_EVENT_TYPE, EventPriority.MISC, function Meteorite.Event_Chat))",LA,LI,function vgi))
call S8o(v9x,XBx("Meteorite_Init: call Meteorite.THIS_UNIT_TYPE.Event.Add(Event.Create(Unit.CREATE_EVENT_TYPE, EventPriority.MISC, function Meteorite.Event_Create))",Igv,LI,function vPi))
return true
endfunction
function vQi takes nothing returns boolean
call kWo(function vqi,"Meteorite_Init")
return true
endfunction
function vsi takes nothing returns boolean
set oxx=Vnx(oox)
return true
endfunction
function vSi takes code c,string rqx returns nothing
set xV=xV+1
set oV[xV]=CreateTrigger()
set rV[xV]=(GetHandleId(Condition((c))))
set iV[xV]=rqx
call TriggerAddCondition(oV[xV],Condition(c))
endfunction
function vti takes nothing returns boolean
local integer rdx=(bv)
call qir((Vv[(rdx)]),"swim")
return true
endfunction
function vTi takes nothing returns boolean
call S8o(hdv,XBx("Pengu_Init: call UnitType.FLYING_PENGUIN.Event.Add(Event.Create(Unit.CREATE_EVENT_TYPE, EventPriority.UNIT_TYPES, function Pengu.Event_Create))",Igv,PI,function vti))
return true
endfunction
function vui takes nothing returns boolean
call vSi(function vTi,"Pengu_Init")
return true
endfunction
function vUi takes nothing returns boolean
set orx=hGo('uSeb')
set Tj[(orx)]=((1)*1.)
set Nav[(orx)]=((60)*1.)
set Ntv[(orx)]=((60)*1.)
set I3v[(orx)]=((0)*1.)
set Axv[(orx)]=(5)
set NJv[(orx)]=(('x')*1.)
set Njv[(orx)]=(('x')*1.)
set Nhv[(orx)]=((0)*1.)
set NIv[(orx)]=((500)*1.)
set NOv[(orx)]=((500)*1.)
set Ndv[(orx)]=((400)*1.)
set AQv[(orx)]=((0)*1.)
set Asv[(orx)]=((0)*1.)
set Auv[(orx)]=(0)
set AWv[(orx)]=(0)
call hLo((orx),(gQv),1)
return true
endfunction
function vwi takes nothing returns boolean
call VRx(Sa,(function vUi),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Units\\Sebastian.page\\Sebastian.struct\\obj_thisUnitType_wc3unit.j"))
return true
endfunction
function vWi takes nothing returns boolean
set oix=Vnx(oax)
return true
endfunction
function vyi takes nothing returns boolean
local integer rdx=(bv)
set onx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((Kr)))))),((((ix))))))
return true
endfunction
function vYi takes nothing returns boolean
call DNx(XBx("Sebastian_Init: call Event.Create(EventType.START, EventPriority.MISC, function Sebastian.Event_Start).AddToStatics()",XE,LI,function vyi))
return true
endfunction
function vzi takes nothing returns boolean
call vSi(function vYi,"Sebastian_Init")
return true
endfunction
function vZi takes nothing returns boolean
set ur=Vnx("<s__Loading_Name>")
return true
endfunction
function v_i takes nothing returns boolean
call Vrx(function VVx,"s"+"__Queue_Allocation__allocInit_autoRun")
call Vrx(function VEx,"s"+"__ObjThread_Allocation__allocInit_autoRun")
call Vrx(function VXx,"s"+"__FolderMath_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function VOx,"s"+"__FolderMath_StructHex_Allocation__allocInit_autoRun")
call Vrx(function Vcx,"s"+"__FolderMath_StructShapes_objInits_autoRun")
call Vrx(function VCx,"s"+"__FolderMath_StructShapes_Allocation__allocInit_autoRun")
call Vrx(function VGx,"s"+"__Math_initializer_Init_autoRun")
call Vrx(function Vhx,"s"+"__FolderGameCache_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function VHx,"s"+"__FolderGameCache_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function Vjx,"s"+"__FolderGameCache_StructReal_Allocation__allocInit_autoRun")
call Vrx(function VJx,"s"+"__FolderGameCache_StructString_Allocation__allocInit_autoRun")
call Vrx(function Vkx,"s"+"__GameCache_Allocation__allocInit_autoRun")
call Vrx(function VKx,"s"+"__FolderHashTable_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function Vlx,"s"+"__FolderHashTable_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function VLx,"s"+"__FolderHashTable_StructReal_Allocation__allocInit_autoRun")
call Vrx(function Vmx,"s"+"__FolderHashTable_StructString_Allocation__allocInit_autoRun")
call Vrx(function VMx,"s"+"__HashTable_Allocation__allocInit_autoRun")
call Vrx(function Vpx,"s"+"__FolderDataTableHead_FolderIntegerKeys_StructD2_Allocation__allocInit_autoRun")
call Vrx(function VPx,"s"+"__FolderDataTableHead_StructIntegerKeys_Allocation__allocInit_autoRun")
call Vrx(function Vqx,"s"+"__FolderDataTableHead_StructStringKeys_Allocation__allocInit_autoRun")
call Vrx(function VQx,"s"+"__DataTableHead_Allocation__allocInit_autoRun")
call Vrx(function Vsx,"s"+"__FolderDataTable_FolderIntegerKeys_FolderD2_StructTable_Allocation__allocInit_autoRun")
call Vrx(function VSx,"s"+"__FolderDataTable_FolderIntegerKeys_StructD2_Allocation__allocInit_autoRun")
call Vrx(function Vtx,"s"+"__FolderDataTable_FolderIntegerKeys_StructTable_Allocation__allocInit_autoRun")
call Vrx(function VTx,"s"+"__FolderDataTable_StructIntegerKeys_Allocation__allocInit_autoRun")
call Vrx(function Vux,"s"+"__FolderDataTable_FolderStringKeys_StructTable_Allocation__allocInit_autoRun")
call Vrx(function VUx,"s"+"__FolderDataTable_StructStringKeys_Allocation__allocInit_autoRun")
call Vrx(function Vwx,"s"+"__FolderDataTable_StructNative_Allocation__allocInit_autoRun")
call Vrx(function VWx,"s"+"__DataTable_Allocation__allocInit_autoRun")
call Vrx(function Erx,"s"+"__DataTable_initializer_Init_autoRun")
call Vrx(function Eix,"s"+"__Animation_Allocation__allocInit_autoRun")
call Vrx(function Eax,"s"+"__AttachPoint_Allocation__allocInit_autoRun")
call Vrx(function Enx,"s"+"__Attack_Allocation__allocInit_autoRun")
call Vrx(function EEx,"s"+"__Attack_initializer_Init_autoRun")
call Vrx(function EXx,"s"+"__FolderEventResponse_StructAct_Allocation__allocInit_autoRun")
call Vrx(function EOx,"s"+"__FolderEventResponse_StructAura_Allocation__allocInit_autoRun")
call Vrx(function ERx,"s"+"__FolderEventResponse_StructBool_Allocation__allocInit_autoRun")
call Vrx(function EIx,"s"+"__FolderEventResponse_StructBuff_Allocation__allocInit_autoRun")
call Vrx(function EAx,"s"+"__FolderEventResponse_StructDefenderSpawnType_Allocation__allocInit_autoRun")
call Vrx(function ENx,"s"+"__FolderEventResponse_StructDestructable_Allocation__allocInit_autoRun")
call Vrx(function Ebx,"s"+"__FolderEventResponse_StructDestructableType_Allocation__allocInit_autoRun")
call Vrx(function EBx,"s"+"__FolderEventResponse_StructDialog_Allocation__allocInit_autoRun")
call Vrx(function Ecx,"s"+"__FolderEventResponse_StructDummyUnit_Allocation__allocInit_autoRun")
call Vrx(function ECx,"s"+"__FolderEventResponse_StructDynamic_Allocation__allocInit_autoRun")
call Vrx(function Edx,"s"+"__FolderEventResponse_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function EDx,"s"+"__FolderEventResponse_StructItem_Allocation__allocInit_autoRun")
call Vrx(function Efx,"s"+"__FolderEventResponse_StructItemType_Allocation__allocInit_autoRun")
call Vrx(function EFx,"s"+"__FolderEventResponse_StructLevel_Allocation__allocInit_autoRun")
call Vrx(function Egx,"s"+"__FolderEventResponse_StructLightning_Allocation__allocInit_autoRun")
call Vrx(function EGx,"s"+"__FolderEventResponse_StructMissile_Allocation__allocInit_autoRun")
call Vrx(function Ehx,"s"+"__FolderEventResponse_StructMissileCheckpoint_Allocation__allocInit_autoRun")
call Vrx(function EHx,"s"+"__FolderEventResponse_StructOrder_Allocation__allocInit_autoRun")
call Vrx(function Ejx,"s"+"__FolderEventResponse_StructReal_Allocation__allocInit_autoRun")
call Vrx(function EJx,"s"+"__FolderEventResponse_StructSpawnType_Allocation__allocInit_autoRun")
call Vrx(function Ekx,"s"+"__FolderEventResponse_StructSpell_Allocation__allocInit_autoRun")
call Vrx(function EKx,"s"+"__FolderEventResponse_StructSpellInstance_Allocation__allocInit_autoRun")
call Vrx(function Elx,"s"+"__FolderEventResponse_StructSpot_Allocation__allocInit_autoRun")
call Vrx(function ELx,"s"+"__FolderEventResponse_StructString_Allocation__allocInit_autoRun")
call Vrx(function Emx,"s"+"__FolderEventResponse_StructTile_Allocation__allocInit_autoRun")
call Vrx(function EMx,"s"+"__FolderEventResponse_StructUbersplat_Allocation__allocInit_autoRun")
call Vrx(function Epx,"s"+"__FolderEventResponse_StructUnit_Allocation__allocInit_autoRun")
call Vrx(function EPx,"s"+"__FolderEventResponse_StructUnitEffect_Allocation__allocInit_autoRun")
call Vrx(function Eqx,"s"+"__FolderEventResponse_StructUnitMod_Allocation__allocInit_autoRun")
call Vrx(function EQx,"s"+"__FolderEventResponse_StructUnitType_Allocation__allocInit_autoRun")
call Vrx(function Esx,"s"+"__FolderEventResponse_StructUser_Allocation__allocInit_autoRun")
call Vrx(function ESx,"s"+"__EventResponse_Allocation__allocInit_autoRun")
call Vrx(function Etx,"s"+"__EventPriority_Allocation__allocInit_autoRun")
call Vrx(function ETx,"s"+"__EventType_Allocation__allocInit_autoRun")
call Vrx(function Eux,"s"+"__FolderEvent_StructId_Allocation__allocInit_autoRun")
call Vrx(function EUx,"s"+"__FolderEvent_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function Ewx,"s"+"__FolderEvent_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function EWx,"s"+"__FolderEvent_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function Eyx,"s"+"__FolderEvent_StructData_Allocation__allocInit_autoRun")
call Vrx(function EYx,"s"+"__FolderEvent_StructLimit_Allocation__allocInit_autoRun")
call Vrx(function Ezx,"s"+"__Event_Allocation__allocInit_autoRun")
call Vrx(function E7x,"s"+"__Event_initializer_Init_autoRun")
call Vrx(function E8x,"s"+"__CharacterSpeech_Allocation__allocInit_autoRun")
call Vrx(function Osx,"s"+"__CharacterSpeech_initializer_Init_autoRun")
call Vrx(function OSx,"s"+"__ClearSpawns_Allocation__allocInit_autoRun")
call Vrx(function Oyx,"s"+"__ClearSpawns_initializer_Init_autoRun")
call Vrx(function OYx,"s"+"__CommandAutoCast_Allocation__allocInit_autoRun")
call Vrx(function RRx,"s"+"__CommandAutoCast_initializer_Init_autoRun")
call Vrx(function RIx,"s"+"__CommandBuff_Allocation__allocInit_autoRun")
call Vrx(function Ndx,"s"+"__CommandBuff_initializer_Init_autoRun")
call Vrx(function NDx,"s"+"__CommandCreateQuake_Allocation__allocInit_autoRun")
call Vrx(function bix,"s"+"__CommandCreateQuake_initializer_Init_autoRun")
call Vrx(function bax,"s"+"__CommandCreateUnit_Allocation__allocInit_autoRun")
call Vrx(function bIx,"s"+"__CommandCreateUnit_initializer_Init_autoRun")
call Vrx(function bAx,"s"+"__CommandDebug_Allocation__allocInit_autoRun")
call Vrx(function bBx,"s"+"__CommandDebug_initializer_Init_autoRun")
call Vrx(function bcx,"s"+"__CommandExp_Allocation__allocInit_autoRun")
call Vrx(function bFx,"s"+"__CommandExp_initializer_Init_autoRun")
call Vrx(function bgx,"s"+"__CommandHeader_Allocation__allocInit_autoRun")
call Vrx(function bGx,"s"+"__CommandHeroAttribute_Allocation__allocInit_autoRun")
call Vrx(function c9x,"s"+"__CommandHeroAttribute_initializer_Init_autoRun")
call Vrx(function Cvx,"s"+"__CommandKillUnit_Allocation__allocInit_autoRun")
call Vrx(function Cax,"s"+"__CommandKillUnit_initializer_Init_autoRun")
call Vrx(function Cnx,"s"+"__CommandRefreshAbility_Allocation__allocInit_autoRun")
call Vrx(function Dhx,"s"+"__CommandRefreshAbility_initializer_Init_autoRun")
call Vrx(function DHx,"s"+"__CommandRemoveUnit_Allocation__allocInit_autoRun")
call Vrx(function DKx,"s"+"__CommandRemoveUnit_initializer_Init_autoRun")
call Vrx(function Dlx,"s"+"__CommandScaleUnit_Allocation__allocInit_autoRun")
call Vrx(function fxx,"s"+"__CommandScaleUnit_initializer_Init_autoRun")
call Vrx(function fox,"s"+"__CommandSpell_Allocation__allocInit_autoRun")
call Vrx(function fXx,"s"+"__CommandSpell_initializer_Init_autoRun")
call Vrx(function fOx,"s"+"__CommandSwift_Allocation__allocInit_autoRun")
call Vrx(function fbx,"s"+"__CommandSwift_initializer_Init_autoRun")
call Vrx(function fBx,"s"+"__CommandTest_Allocation__allocInit_autoRun")
call Vrx(function fdx,"s"+"__CommandTest_initializer_Init_autoRun")
call Vrx(function fDx,"s"+"__CommandVertexColorUnit_Allocation__allocInit_autoRun")
call Vrx(function fSx,"s"+"__CommandVertexColorUnit_initializer_Init_autoRun")
call Vrx(function ftx,"s"+"__MoveUnit_Allocation__allocInit_autoRun")
call Vrx(function fZx,"s"+"__MoveUnit_initializer_Init_autoRun")
call Vrx(function f_x,"s"+"__PingSpawns_Allocation__allocInit_autoRun")
call Vrx(function f6x,"s"+"__PingSpawns_initializer_Init_autoRun")
call Vrx(function f7x,"s"+"__RequestEvent_Allocation__allocInit_autoRun")
call Vrx(function Fvx,"s"+"__RequestEvent_initializer_Init_autoRun")
call Vrx(function Fex,"s"+"__RequestKeyMacro_Allocation__allocInit_autoRun")
call Vrx(function Frx,"s"+"__RequestKeyMacro_initializer_Init_autoRun")
call Vrx(function Fix,"s"+"__RequestTimers_Allocation__allocInit_autoRun")
call Vrx(function FOx,"s"+"__RequestTimers_initializer_Init_autoRun")
call Vrx(function FRx,"s"+"__SetDmgTest_Allocation__allocInit_autoRun")
call Vrx(function Fbx,"s"+"__SetDmgTest_initializer_Init_autoRun")
call Vrx(function FBx,"s"+"__SetVar_Allocation__allocInit_autoRun")
call Vrx(function FDx,"s"+"__SetVar_initializer_Init_autoRun")
call Vrx(function Ffx,"s"+"__FolderVoteHost_StructVotes_Allocation__allocInit_autoRun")
call Vrx(function FFx,"s"+"__VoteHost_Allocation__allocInit_autoRun")
call Vrx(function Fhx,"s"+"__VoteHost_initializer_Init_autoRun")
call Vrx(function FHx,"s"+"__AIAutoCast_Allocation__allocInit_autoRun")
call Vrx(function FUx,"s"+"__AIAutoCast_initializer_Init_autoRun")
call Vrx(function Fwx,"s"+"__BoolExpr_Allocation__allocInit_autoRun")
call Vrx(function Fzx,"s"+"__BoolExpr_initializer_Init_autoRun")
call Vrx(function FZx,"s"+"__FolderBuff_StructId_Allocation__allocInit_autoRun")
call Vrx(function F_x,"s"+"__FolderBuff_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function F0x,"s"+"__FolderBuff_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function F1x,"s"+"__FolderBuff_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function F2x,"s"+"__FolderBuff_FolderData_FolderReal_StructTable_Allocation__allocInit_autoRun")
call Vrx(function F3x,"s"+"__FolderBuff_FolderData_StructReal_Allocation__allocInit_autoRun")
call Vrx(function F4x,"s"+"__FolderBuff_FolderData_FolderString_StructTable_Allocation__allocInit_autoRun")
call Vrx(function F5x,"s"+"__FolderBuff_FolderData_StructString_Allocation__allocInit_autoRun")
call Vrx(function F6x,"s"+"__FolderBuff_StructData_Allocation__allocInit_autoRun")
call Vrx(function F7x,"s"+"__FolderBuff_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function F8x,"s"+"__FolderBuff_StructTargetEffects_Allocation__allocInit_autoRun")
call Vrx(function F9x,"s"+"__FolderBuff_StructLoopSounds_Allocation__allocInit_autoRun")
call Vrx(function gvx,"s"+"__FolderBuff_StructVariants_Allocation__allocInit_autoRun")
call Vrx(function gex,"s"+"__FolderBuff_StructUnitMods_Allocation__allocInit_autoRun")
call Vrx(function gxx,"s"+"__FolderBuff_StructUnitModSets_Allocation__allocInit_autoRun")
call Vrx(function gox,"s"+"__Buff_Allocation__allocInit_autoRun")
call Vrx(function gix,"s"+"__Buff_initializer_Init_autoRun")
call Vrx(function gax,"s"+"__FolderCameraField_StructTimed_Allocation__allocInit_autoRun")
call Vrx(function gnx,"s"+"__CameraField_Allocation__allocInit_autoRun")
call Vrx(function gVx,"s"+"__FolderCamera_StructEye_Allocation__allocInit_autoRun")
call Vrx(function gEx,"s"+"__FolderCamera_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function gXx,"s"+"__FolderCamera_StructPanTimedViaBounds_Allocation__allocInit_autoRun")
call Vrx(function gOx,"s"+"__FolderCamera_StructShake_Allocation__allocInit_autoRun")
call Vrx(function gRx,"s"+"__FolderCamera_StructSeismic_Allocation__allocInit_autoRun")
call Vrx(function gIx,"s"+"__Camera_Allocation__allocInit_autoRun")
call Vrx(function gUx,"s"+"__Camera_initializer_Init_autoRun")
call Vrx(function gwx,"s"+"__FolderDestructableType_StructId_Allocation__allocInit_autoRun")
call Vrx(function gWx,"s"+"__FolderDestructableType_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function gyx,"s"+"__FolderDestructableType_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function gYx,"s"+"__FolderDestructableType_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function gzx,"s"+"__FolderDestructableType_FolderData_FolderReal_StructTable_Allocation__allocInit_autoRun")
call Vrx(function gZx,"s"+"__FolderDestructableType_FolderData_StructReal_Allocation__allocInit_autoRun")
call Vrx(function g_x,"s"+"__FolderDestructableType_StructData_Allocation__allocInit_autoRun")
call Vrx(function g0x,"s"+"__FolderDestructableType_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function g1x,"s"+"__FolderDestructableType_StructPreload_Allocation__allocInit_autoRun")
call Vrx(function Gex,"s"+"__DestructableType_objInits_autoRun")
call Vrx(function Gxx,"s"+"__DestructableType_Allocation__allocInit_autoRun")
call Vrx(function Gox,"s"+"__FolderDestructable_StructId_Allocation__allocInit_autoRun")
call Vrx(function Grx,"s"+"__FolderDestructable_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function Gix,"s"+"__FolderDestructable_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function Gax,"s"+"__FolderDestructable_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function Gnx,"s"+"__FolderDestructable_FolderData_FolderReal_StructTable_Allocation__allocInit_autoRun")
call Vrx(function GVx,"s"+"__FolderDestructable_FolderData_StructReal_Allocation__allocInit_autoRun")
call Vrx(function GEx,"s"+"__FolderDestructable_StructData_Allocation__allocInit_autoRun")
call Vrx(function GXx,"s"+"__FolderDestructable_FolderEvent_StructNative_Allocation__allocInit_autoRun")
call Vrx(function GOx,"s"+"__FolderDestructable_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function GRx,"s"+"__FolderDestructable_StructType_Allocation__allocInit_autoRun")
call Vrx(function GIx,"s"+"__FolderDestructable_StructTimedLife_Allocation__allocInit_autoRun")
call Vrx(function GAx,"s"+"__FolderDestructable_FolderEnum_StructInRange_Allocation__allocInit_autoRun")
call Vrx(function GNx,"s"+"__FolderDestructable_StructEnum_Allocation__allocInit_autoRun")
call Vrx(function Gbx,"s"+"__FolderDestructable_StructLife_Allocation__allocInit_autoRun")
call Vrx(function GBx,"s"+"__Destructable_Allocation__allocInit_autoRun")
call Vrx(function G9x,"s"+"__Destructable_initializer_Init_autoRun")
call Vrx(function hvx,"s"+"__FolderDialogButton_StructId_Allocation__allocInit_autoRun")
call Vrx(function hex,"s"+"__FolderDialogButton_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function hxx,"s"+"__FolderDialogButton_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function hox,"s"+"__FolderDialogButton_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function hrx,"s"+"__FolderDialogButton_FolderData_StructReal_Allocation__allocInit_autoRun")
call Vrx(function hix,"s"+"__FolderDialogButton_StructData_Allocation__allocInit_autoRun")
call Vrx(function hax,"s"+"__FolderDialogButton_FolderEvent_StructNative_Allocation__allocInit_autoRun")
call Vrx(function hnx,"s"+"__FolderDialogButton_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function hVx,"s"+"__DialogButton_Allocation__allocInit_autoRun")
call Vrx(function hEx,"s"+"__FolderDialog_StructId_Allocation__allocInit_autoRun")
call Vrx(function hXx,"s"+"__FolderDialog_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function hOx,"s"+"__FolderDialog_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function hRx,"s"+"__FolderDialog_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function hIx,"s"+"__FolderDialog_FolderData_StructReal_Allocation__allocInit_autoRun")
call Vrx(function hAx,"s"+"__FolderDialog_StructData_Allocation__allocInit_autoRun")
call Vrx(function hNx,"s"+"__FolderDialog_FolderEvent_StructNative_Allocation__allocInit_autoRun")
call Vrx(function hbx,"s"+"__FolderDialog_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function hBx,"s"+"__FolderDialog_StructButtons_Allocation__allocInit_autoRun")
call Vrx(function hcx,"s"+"__Dialog_Allocation__allocInit_autoRun")
call Vrx(function hSx,"s"+"__Dialog_initializer_Init_autoRun")
call Vrx(function htx,"s"+"__EffectLevel_Allocation__allocInit_autoRun")
call Vrx(function hTx,"s"+"__FolderSpotEffectWithSize_StructDestroyTimed_Allocation__allocInit_autoRun")
call Vrx(function hux,"s"+"__SpotEffectWithSize_objInits_autoRun")
call Vrx(function hUx,"s"+"__SpotEffectWithSize_Allocation__allocInit_autoRun")
call Vrx(function hwx,"s"+"__DummyUnitEffect_Allocation__allocInit_autoRun")
call Vrx(function hWx,"s"+"__FolderSpotEffect_StructId_Allocation__allocInit_autoRun")
call Vrx(function hyx,"s"+"__FolderSpotEffect_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function hYx,"s"+"__FolderSpotEffect_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function hzx,"s"+"__FolderSpotEffect_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function hZx,"s"+"__FolderSpotEffect_StructData_Allocation__allocInit_autoRun")
call Vrx(function h_x,"s"+"__FolderSpotEffect_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function h0x,"s"+"__FolderSpotEffect_StructDestroyTimed_Allocation__allocInit_autoRun")
call Vrx(function h1x,"s"+"__SpotEffect_objInits_autoRun")
call Vrx(function h2x,"s"+"__SpotEffect_Allocation__allocInit_autoRun")
call Vrx(function h3x,"s"+"__FolderUnitEffect_StructId_Allocation__allocInit_autoRun")
call Vrx(function h4x,"s"+"__FolderUnitEffect_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function h5x,"s"+"__FolderUnitEffect_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function h6x,"s"+"__FolderUnitEffect_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function h7x,"s"+"__FolderUnitEffect_StructData_Allocation__allocInit_autoRun")
call Vrx(function h8x,"s"+"__FolderUnitEffect_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function h9x,"s"+"__FolderUnitEffect_StructDestroyTimed_Allocation__allocInit_autoRun")
call Vrx(function Hvx,"s"+"__UnitEffect_Allocation__allocInit_autoRun")
call Vrx(function Hex,"s"+"__Effect_Allocation__allocInit_autoRun")
call Vrx(function HHx,"s"+"__Effect_initializer_Init_autoRun")
call Vrx(function Hjx,"s"+"__FolderEventMemoryHead_FolderIntegerKeys_StructD2_Allocation__allocInit_autoRun")
call Vrx(function HJx,"s"+"__FolderEventMemoryHead_StructIntegerKeys_Allocation__allocInit_autoRun")
call Vrx(function Hkx,"s"+"__FolderEventMemory_FolderIntegerKeys_FolderD2_StructTable_Allocation__allocInit_autoRun")
call Vrx(function HKx,"s"+"__FolderEventMemory_FolderIntegerKeys_StructD2_Allocation__allocInit_autoRun")
call Vrx(function Hlx,"s"+"__FolderEventMemory_FolderIntegerKeys_StructTable_Allocation__allocInit_autoRun")
call Vrx(function HLx,"s"+"__FolderEventMemory_StructIntegerKeys_Allocation__allocInit_autoRun")
call Vrx(function HQx,"s"+"__EventMemory_initializer_Init_autoRun")
call Vrx(function Hsx,"s"+"__EventPair_Allocation__allocInit_autoRun")
call Vrx(function HSx,"s"+"__FolderEventCombination_StructId_Allocation__allocInit_autoRun")
call Vrx(function Htx,"s"+"__FolderEventCombination_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function HTx,"s"+"__FolderEventCombination_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function Hux,"s"+"__FolderEventCombination_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function HUx,"s"+"__FolderEventCombination_StructData_Allocation__allocInit_autoRun")
call Vrx(function Hwx,"s"+"__FolderEventCombination_StructRemainingEventsAmount_Allocation__allocInit_autoRun")
call Vrx(function HWx,"s"+"__FolderEventCombination_StructEvents_Allocation__allocInit_autoRun")
call Vrx(function Hyx,"s"+"__FolderEventCombination_StructSubjects_Allocation__allocInit_autoRun")
call Vrx(function HYx,"s"+"__FolderEventCombination_FolderPeriodic_StructSubjectsA_Allocation__allocInit_autoRun")
call Vrx(function Hzx,"s"+"__FolderEventCombination_StructPeriodic_Allocation__allocInit_autoRun")
call Vrx(function HZx,"s"+"__FolderEventCombination_StructPairs_Allocation__allocInit_autoRun")
call Vrx(function H_x,"s"+"__EventCombination_Allocation__allocInit_autoRun")
call Vrx(function H1x,"s"+"__EventCombination_initializer_Init_autoRun")
call Vrx(function H2x,"s"+"__Announcement_Allocation__allocInit_autoRun")
call Vrx(function H3x,"s"+"__GameMessage_Allocation__allocInit_autoRun")
call Vrx(function H4x,"s"+"__CineFilter_Allocation__allocInit_autoRun")
call Vrx(function H5x,"s"+"__FolderGame_StructFloatState_Allocation__allocInit_autoRun")
call Vrx(function H6x,"s"+"__FolderGame_StructTimeOfDay_Allocation__allocInit_autoRun")
call Vrx(function jax,"s"+"__Game_initializer_Init_autoRun")
call Vrx(function jnx,"s"+"__PingColor_Allocation__allocInit_autoRun")
call Vrx(function jVx,"s"+"__Ping_Allocation__allocInit_autoRun")
call Vrx(function jEx,"s"+"__FolderGroup_StructRefs_Allocation__allocInit_autoRun")
call Vrx(function jXx,"s"+"__FolderGroup_StructCountUnits_Allocation__allocInit_autoRun")
call Vrx(function jOx,"s"+"__FolderGroup_StructNearestUnit_Allocation__allocInit_autoRun")
call Vrx(function jRx,"s"+"__FolderGroup_StructOrder_Allocation__allocInit_autoRun")
call Vrx(function jIx,"s"+"__FolderGroup_StructRandomUnit_Allocation__allocInit_autoRun")
call Vrx(function jAx,"s"+"__FolderGroup_FolderEnumUnits_FolderInLine_StructWithCollision_Allocation__allocInit_autoRun")
call Vrx(function jNx,"s"+"__FolderGroup_FolderEnumUnits_StructInLine_Allocation__allocInit_autoRun")
call Vrx(function jbx,"s"+"__FolderGroup_FolderEnumUnits_FolderInRange_StructWithCollision_Allocation__allocInit_autoRun")
call Vrx(function jBx,"s"+"__FolderGroup_FolderEnumUnits_StructInRange_Allocation__allocInit_autoRun")
call Vrx(function jcx,"s"+"__FolderGroup_FolderEnumUnits_FolderInRect_StructWithCollision_Allocation__allocInit_autoRun")
call Vrx(function jCx,"s"+"__FolderGroup_FolderEnumUnits_StructInRect_Allocation__allocInit_autoRun")
call Vrx(function jdx,"s"+"__FolderGroup_StructEnumUnits_Allocation__allocInit_autoRun")
call Vrx(function jDx,"s"+"__Group_Allocation__allocInit_autoRun")
call Vrx(function Jbx,"s"+"__Group_initializer_Init_autoRun")
call Vrx(function JBx,"s"+"__FolderUnitList_StructId_Allocation__allocInit_autoRun")
call Vrx(function Jcx,"s"+"__FolderUnitList_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function JCx,"s"+"__FolderUnitList_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function Jdx,"s"+"__FolderUnitList_StructData_Allocation__allocInit_autoRun")
call Vrx(function JDx,"s"+"__FolderUnitList_StructRefs_Allocation__allocInit_autoRun")
call Vrx(function Jfx,"s"+"__UnitList_Allocation__allocInit_autoRun")
call Vrx(function JFx,"s"+"__FolderItemClass_StructId_Allocation__allocInit_autoRun")
call Vrx(function Jgx,"s"+"__FolderItemClass_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function JGx,"s"+"__FolderItemClass_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function Jhx,"s"+"__FolderItemClass_StructData_Allocation__allocInit_autoRun")
call Vrx(function JHx,"s"+"__ItemClass_Allocation__allocInit_autoRun")
call Vrx(function Jjx,"s"+"__FolderItem_StructId_Allocation__allocInit_autoRun")
call Vrx(function JJx,"s"+"__FolderItem_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function Jkx,"s"+"__FolderItem_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function JKx,"s"+"__FolderItem_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function Jlx,"s"+"__FolderItem_StructData_Allocation__allocInit_autoRun")
call Vrx(function JLx,"s"+"__FolderItem_FolderEvent_StructNative_Allocation__allocInit_autoRun")
call Vrx(function Jmx,"s"+"__FolderItem_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function JMx,"s"+"__FolderItem_StructClasses_Allocation__allocInit_autoRun")
call Vrx(function Jpx,"s"+"__FolderItem_StructType_Allocation__allocInit_autoRun")
call Vrx(function JPx,"s"+"__FolderItem_StructAbilities_Allocation__allocInit_autoRun")
call Vrx(function Jqx,"s"+"__FolderItem_StructChargesAmount_Allocation__allocInit_autoRun")
call Vrx(function JQx,"s"+"__FolderItem_StructPosition_Allocation__allocInit_autoRun")
call Vrx(function Jsx,"s"+"__Item_Allocation__allocInit_autoRun")
call Vrx(function kkx,"s"+"__Item_initializer_Init_autoRun")
call Vrx(function kKx,"s"+"__FolderItemType_StructId_Allocation__allocInit_autoRun")
call Vrx(function klx,"s"+"__FolderItemType_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function kLx,"s"+"__FolderItemType_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function kmx,"s"+"__FolderItemType_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function kMx,"s"+"__FolderItemType_StructData_Allocation__allocInit_autoRun")
call Vrx(function kpx,"s"+"__FolderItemType_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function kPx,"s"+"__FolderItemType_StructAbilities_Allocation__allocInit_autoRun")
call Vrx(function kqx,"s"+"__FolderItemType_StructChargesAmount_Allocation__allocInit_autoRun")
call Vrx(function kQx,"s"+"__FolderItemType_StructClasses_Allocation__allocInit_autoRun")
call Vrx(function ksx,"s"+"__FolderItemType_StructPreload_Allocation__allocInit_autoRun")
call Vrx(function kSx,"s"+"__FolderItemType_StructUsageGoldCost_Allocation__allocInit_autoRun")
call Vrx(function ktx,"s"+"__ItemType_objInits_autoRun")
call Vrx(function kTx,"s"+"__ItemType_Allocation__allocInit_autoRun")
call Vrx(function kux,"s"+"__LightningType_Allocation__allocInit_autoRun")
call Vrx(function kUx,"s"+"__FolderLightning_StructId_Allocation__allocInit_autoRun")
call Vrx(function kwx,"s"+"__FolderLightning_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function kWx,"s"+"__FolderLightning_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function kyx,"s"+"__FolderLightning_StructData_Allocation__allocInit_autoRun")
call Vrx(function kYx,"s"+"__FolderLightning_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function kzx,"s"+"__FolderLightning_FolderColor_StructRed_Allocation__allocInit_autoRun")
call Vrx(function kZx,"s"+"__FolderLightning_FolderColor_StructGreen_Allocation__allocInit_autoRun")
call Vrx(function k_x,"s"+"__FolderLightning_FolderColor_StructBlue_Allocation__allocInit_autoRun")
call Vrx(function k0x,"s"+"__FolderLightning_FolderColor_StructAlpha_Allocation__allocInit_autoRun")
call Vrx(function k1x,"s"+"__FolderLightning_FolderColor_StructTimed_Allocation__allocInit_autoRun")
call Vrx(function k2x,"s"+"__FolderLightning_StructColor_Allocation__allocInit_autoRun")
call Vrx(function k3x,"s"+"__FolderLightning_StructFromDummyUnitToUnit_Allocation__allocInit_autoRun")
call Vrx(function k4x,"s"+"__FolderLightning_StructFromSpotToDummyUnit_Allocation__allocInit_autoRun")
call Vrx(function k5x,"s"+"__FolderLightning_StructFromSpotToSpot_Allocation__allocInit_autoRun")
call Vrx(function k6x,"s"+"__FolderLightning_StructFromSpotToUnit_Allocation__allocInit_autoRun")
call Vrx(function k7x,"s"+"__FolderLightning_StructFromUnitToUnit_Allocation__allocInit_autoRun")
call Vrx(function k8x,"s"+"__FolderLightning_StructDestroyTimed_Allocation__allocInit_autoRun")
call Vrx(function k9x,"s"+"__Lightning_Allocation__allocInit_autoRun")
call Vrx(function lgx,"s"+"__Lightning_initializer_Init_autoRun")
call Vrx(function lGx,"s"+"__LoadingEx_objInits_autoRun")
call Vrx(function lhx,"s"+"__LoadingEx_Allocation__allocInit_autoRun")
call Vrx(function lHx,"s"+"__AICastSpell_Allocation__allocInit_autoRun")
call Vrx(function lLx,"s"+"__AICastSpell_initializer_Init_autoRun")
call Vrx(function l3x,"s"+"__AILetOff_objInits_autoRun")
call Vrx(function l4x,"s"+"__AILetOff_Allocation__allocInit_autoRun")
call Vrx(function LNx,"s"+"__AILetOff_initializer_Init_autoRun")
call Vrx(function Lbx,"s"+"__CustomDrop_Allocation__allocInit_autoRun")
call Vrx(function LBx,"s"+"__FolderDummyUnit_StructId_Allocation__allocInit_autoRun")
call Vrx(function Lcx,"s"+"__FolderDummyUnit_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function LCx,"s"+"__FolderDummyUnit_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function Ldx,"s"+"__FolderDummyUnit_StructData_Allocation__allocInit_autoRun")
call Vrx(function LDx,"s"+"__FolderDummyUnit_FolderEvent_StructNative_Allocation__allocInit_autoRun")
call Vrx(function Lfx,"s"+"__FolderDummyUnit_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function LFx,"s"+"__FolderDummyUnit_StructAbilities_Allocation__allocInit_autoRun")
call Vrx(function Lgx,"s"+"__FolderDummyUnit_StructAnimation_Allocation__allocInit_autoRun")
call Vrx(function LGx,"s"+"__FolderDummyUnit_StructDestroyTimed_Allocation__allocInit_autoRun")
call Vrx(function Lhx,"s"+"__FolderDummyUnit_StructDestruction_Allocation__allocInit_autoRun")
call Vrx(function LHx,"s"+"__FolderDummyUnit_StructFacing_Allocation__allocInit_autoRun")
call Vrx(function Ljx,"s"+"__FolderDummyUnit_StructPlayerColor_Allocation__allocInit_autoRun")
call Vrx(function LJx,"s"+"__FolderDummyUnit_StructOrder_Allocation__allocInit_autoRun")
call Vrx(function Lkx,"s"+"__FolderDummyUnit_StructOwner_Allocation__allocInit_autoRun")
call Vrx(function LKx,"s"+"__FolderDummyUnit_FolderPosition_StructX_Allocation__allocInit_autoRun")
call Vrx(function Llx,"s"+"__FolderDummyUnit_FolderPosition_StructY_Allocation__allocInit_autoRun")
call Vrx(function LLx,"s"+"__FolderDummyUnit_FolderPosition_StructZ_Allocation__allocInit_autoRun")
call Vrx(function Lmx,"s"+"__FolderDummyUnit_StructPosition_Allocation__allocInit_autoRun")
call Vrx(function LMx,"s"+"__FolderDummyUnit_StructFollowDummyUnit_Allocation__allocInit_autoRun")
call Vrx(function Lpx,"s"+"__FolderDummyUnit_StructFollowUnit_Allocation__allocInit_autoRun")
call Vrx(function LPx,"s"+"__FolderDummyUnit_StructRotate_Allocation__allocInit_autoRun")
call Vrx(function Lqx,"s"+"__FolderDummyUnit_FolderScale_StructTimed_Allocation__allocInit_autoRun")
call Vrx(function LQx,"s"+"__FolderDummyUnit_StructScale_Allocation__allocInit_autoRun")
call Vrx(function Lsx,"s"+"__FolderDummyUnit_FolderVertexColor_StructRed_Allocation__allocInit_autoRun")
call Vrx(function LSx,"s"+"__FolderDummyUnit_FolderVertexColor_StructGreen_Allocation__allocInit_autoRun")
call Vrx(function Ltx,"s"+"__FolderDummyUnit_FolderVertexColor_StructBlue_Allocation__allocInit_autoRun")
call Vrx(function LTx,"s"+"__FolderDummyUnit_FolderVertexColor_StructAlpha_Allocation__allocInit_autoRun")
call Vrx(function Lux,"s"+"__FolderDummyUnit_FolderVertexColor_StructTimed_Allocation__allocInit_autoRun")
call Vrx(function LUx,"s"+"__FolderDummyUnit_StructVertexColor_Allocation__allocInit_autoRun")
call Vrx(function L1x,"s"+"__DummyUnit_objInits_autoRun")
call Vrx(function L2x,"s"+"__DummyUnit_Allocation__allocInit_autoRun")
call Vrx(function L3x,"s"+"__TargetFlag_Allocation__allocInit_autoRun")
call Vrx(function L4x,"s"+"__Misc_Allocation__allocInit_autoRun")
call Vrx(function mfx,"s"+"__Misc_initializer_Init_autoRun")
call Vrx(function mFx,"s"+"__FolderMissileCheckpoint_StructId_Allocation__allocInit_autoRun")
call Vrx(function mgx,"s"+"__FolderMissileCheckpoint_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function mGx,"s"+"__FolderMissileCheckpoint_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function mhx,"s"+"__FolderMissileCheckpoint_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function mHx,"s"+"__FolderMissileCheckpoint_StructData_Allocation__allocInit_autoRun")
call Vrx(function mjx,"s"+"__MissileCheckpoint_Allocation__allocInit_autoRun")
call Vrx(function mJx,"s"+"__FolderMissile_StructId_Allocation__allocInit_autoRun")
call Vrx(function mkx,"s"+"__FolderMissile_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function mKx,"s"+"__FolderMissile_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function mlx,"s"+"__FolderMissile_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function mLx,"s"+"__FolderMissile_StructData_Allocation__allocInit_autoRun")
call Vrx(function mmx,"s"+"__FolderMissile_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function mMx,"s"+"__FolderMissile_StructArc_Allocation__allocInit_autoRun")
call Vrx(function mpx,"s"+"__FolderMissile_StructImpact_Allocation__allocInit_autoRun")
call Vrx(function mPx,"s"+"__FolderMissile_StructCollisionSize_Allocation__allocInit_autoRun")
call Vrx(function mqx,"s"+"__FolderMissile_StructDummyUnit_Allocation__allocInit_autoRun")
call Vrx(function mQx,"s"+"__FolderMissile_StructAngle_Allocation__allocInit_autoRun")
call Vrx(function msx,"s"+"__FolderMissile_FolderPosition_StructX_Allocation__allocInit_autoRun")
call Vrx(function mSx,"s"+"__FolderMissile_FolderPosition_StructY_Allocation__allocInit_autoRun")
call Vrx(function mtx,"s"+"__FolderMissile_FolderPosition_StructZ_Allocation__allocInit_autoRun")
call Vrx(function mTx,"s"+"__FolderMissile_StructPosition_Allocation__allocInit_autoRun")
call Vrx(function mux,"s"+"__FolderMissile_StructUpdateTime_Allocation__allocInit_autoRun")
call Vrx(function mUx,"s"+"__FolderMissile_StructAcceleration_Allocation__allocInit_autoRun")
call Vrx(function mwx,"s"+"__FolderMissile_StructSpeed_Allocation__allocInit_autoRun")
call Vrx(function mWx,"s"+"__FolderMissile_StructGoToSpot_Allocation__allocInit_autoRun")
call Vrx(function myx,"s"+"__FolderMissile_StructCheckpoints_Allocation__allocInit_autoRun")
call Vrx(function mYx,"s"+"__FolderMissile_StructGoToUnit_Allocation__allocInit_autoRun")
call Vrx(function mzx,"s"+"__Missile_Allocation__allocInit_autoRun")
call Vrx(function MSx,"s"+"__Missile_initializer_Init_autoRun")
call Vrx(function Mtx,"s"+"__MultiboardItem_Allocation__allocInit_autoRun")
call Vrx(function MTx,"s"+"__FolderMultiboard_StructColumn_Allocation__allocInit_autoRun")
call Vrx(function Mux,"s"+"__FolderMultiboard_StructColumnSpan_Allocation__allocInit_autoRun")
call Vrx(function MUx,"s"+"__FolderMultiboard_StructRow_Allocation__allocInit_autoRun")
call Vrx(function Mwx,"s"+"__FolderMultiboard_StructTitle_Allocation__allocInit_autoRun")
call Vrx(function MWx,"s"+"__FolderMultiboard_FolderShown_FolderControl_StructPageSwitch_Allocation__allocInit_autoRun")
call Vrx(function Myx,"s"+"__FolderMultiboard_FolderShown_StructControl_Allocation__allocInit_autoRun")
call Vrx(function MYx,"s"+"__FolderMultiboard_StructShown_Allocation__allocInit_autoRun")
call Vrx(function Mzx,"s"+"__Multiboard_Allocation__allocInit_autoRun")
call Vrx(function qNx,"s"+"__Multiboard_initializer_Init_autoRun")
call Vrx(function qbx,"s"+"__FolderOrder_StructId_Allocation__allocInit_autoRun")
call Vrx(function qBx,"s"+"__FolderOrder_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function qcx,"s"+"__FolderOrder_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function qCx,"s"+"__FolderOrder_StructData_Allocation__allocInit_autoRun")
call Vrx(function qdx,"s"+"__FolderOrder_FolderEvent_StructNative_Allocation__allocInit_autoRun")
call Vrx(function qDx,"s"+"__FolderOrder_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function qfx,"s"+"__Order_Allocation__allocInit_autoRun")
call Vrx(function qjx,"s"+"__Order_initializer_Init_autoRun")
call Vrx(function qJx,"s"+"__FolderOrderInstance_StructRefs_Allocation__allocInit_autoRun")
call Vrx(function qkx,"s"+"__OrderInstance_Allocation__allocInit_autoRun")
call Vrx(function qKx,"s"+"__FolderReal_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function qlx,"s"+"__FolderString_StructColor_Allocation__allocInit_autoRun")
call Vrx(function qQx,"s"+"__Primitive_initializer_Init_autoRun")
call Vrx(function qsx,"s"+"__FolderRectangle_StructId_Allocation__allocInit_autoRun")
call Vrx(function qSx,"s"+"__FolderRectangle_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function qtx,"s"+"__FolderRectangle_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function qTx,"s"+"__FolderRectangle_StructData_Allocation__allocInit_autoRun")
call Vrx(function qux,"s"+"__Rectangle_Allocation__allocInit_autoRun")
call Vrx(function qUx,"s"+"__FolderRegion_StructId_Allocation__allocInit_autoRun")
call Vrx(function qwx,"s"+"__FolderRegion_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function qWx,"s"+"__FolderRegion_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function qyx,"s"+"__FolderRegion_StructData_Allocation__allocInit_autoRun")
call Vrx(function qYx,"s"+"__FolderRegion_FolderEvent_StructNative_Allocation__allocInit_autoRun")
call Vrx(function qzx,"s"+"__FolderRegion_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function qZx,"s"+"__Region_Allocation__allocInit_autoRun")
call Vrx(function q1x,"s"+"__Region_initializer_Init_autoRun")
call Vrx(function q2x,"s"+"__Music_Allocation__allocInit_autoRun")
call Vrx(function q3x,"s"+"__SoundChannel_Allocation__allocInit_autoRun")
call Vrx(function q4x,"s"+"__SoundEax_Allocation__allocInit_autoRun")
call Vrx(function q5x,"s"+"__SoundType_Allocation__allocInit_autoRun")
call Vrx(function q6x,"s"+"__Sound_Allocation__allocInit_autoRun")
call Vrx(function QAx,"s"+"__Sound_initializer_Init_autoRun")
call Vrx(function QNx,"s"+"__UnitSound_Allocation__allocInit_autoRun")
call Vrx(function QDx,"s"+"__HeroSpell_objInits_autoRun")
call Vrx(function Qfx,"s"+"__HeroSpell_Allocation__allocInit_autoRun")
call Vrx(function QFx,"s"+"__SpellClass_Allocation__allocInit_autoRun")
call Vrx(function Qgx,"s"+"__FolderSpell_StructId_Allocation__allocInit_autoRun")
call Vrx(function QGx,"s"+"__FolderSpell_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function Qhx,"s"+"__FolderSpell_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function QHx,"s"+"__FolderSpell_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function Qjx,"s"+"__FolderSpell_FolderData_StructReal_Allocation__allocInit_autoRun")
call Vrx(function QJx,"s"+"__FolderSpell_StructData_Allocation__allocInit_autoRun")
call Vrx(function Qkx,"s"+"__FolderSpell_FolderEvent_StructNative_Allocation__allocInit_autoRun")
call Vrx(function QKx,"s"+"__FolderSpell_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function Qlx,"s"+"__Spell_objInits_autoRun")
call Vrx(function QLx,"s"+"__Spell_Allocation__allocInit_autoRun")
call Vrx(function Q7x,"s"+"__Spell_initializer_Init_autoRun")
call Vrx(function Q8x,"s"+"__FolderSpellInstance_StructRefs_Allocation__allocInit_autoRun")
call Vrx(function Q9x,"s"+"__SpellInstance_Allocation__allocInit_autoRun")
call Vrx(function svx,"s"+"__FolderSpot_FolderEvent_StructNative_Allocation__allocInit_autoRun")
call Vrx(function sex,"s"+"__FolderSpot_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function sxx,"s"+"__FolderSpot_StructDeformNova_Allocation__allocInit_autoRun")
call Vrx(function sox,"s"+"__Spot_Allocation__allocInit_autoRun")
call Vrx(function sVx,"s"+"__Spot_initializer_Init_autoRun")
call Vrx(function sEx,"s"+"__FolderStringData_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function sXx,"s"+"__FolderStringData_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function sOx,"s"+"__FolderStringData_StructData_Allocation__allocInit_autoRun")
call Vrx(function sRx,"s"+"__FolderStringData_FolderEvent_StructNative_Allocation__allocInit_autoRun")
call Vrx(function sIx,"s"+"__FolderStringData_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function sAx,"s"+"__StringData_Allocation__allocInit_autoRun")
call Vrx(function sbx,"s"+"__StringData_initializer_Init_autoRun")
call Vrx(function sMx,"s"+"__TileType_objInits_autoRun")
call Vrx(function spx,"s"+"__TileType_Allocation__allocInit_autoRun")
call Vrx(function sqx,"s"+"__TileType_initializer_Init_autoRun")
call Vrx(function sQx,"s"+"__FolderTile_StructType_Allocation__allocInit_autoRun")
call Vrx(function ssx,"s"+"__Tile_Allocation__allocInit_autoRun")
call Vrx(function stx,"s"+"__Tile_initializer_Init_autoRun")
call Vrx(function sTx,"s"+"__FolderTileTypeMod_StructDestroyTimed_Allocation__allocInit_autoRun")
call Vrx(function sux,"s"+"__TileTypeMod_Allocation__allocInit_autoRun")
call Vrx(function swx,"s"+"__TileTypeMod_initializer_Init_autoRun")
call Vrx(function s_x,"s"+"__UbersplatType_objInits_autoRun")
call Vrx(function s0x,"s"+"__UbersplatType_Allocation__allocInit_autoRun")
call Vrx(function s1x,"s"+"__FolderUbersplat_StructId_Allocation__allocInit_autoRun")
call Vrx(function s2x,"s"+"__FolderUbersplat_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function s3x,"s"+"__FolderUbersplat_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function s4x,"s"+"__FolderUbersplat_StructData_Allocation__allocInit_autoRun")
call Vrx(function s5x,"s"+"__FolderUbersplat_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function s6x,"s"+"__FolderUbersplat_StructDestroyTimed_Allocation__allocInit_autoRun")
call Vrx(function s7x,"s"+"__FolderUbersplat_FolderColor_StructRed_Allocation__allocInit_autoRun")
call Vrx(function s8x,"s"+"__FolderUbersplat_FolderColor_StructGreen_Allocation__allocInit_autoRun")
call Vrx(function s9x,"s"+"__FolderUbersplat_FolderColor_StructBlue_Allocation__allocInit_autoRun")
call Vrx(function Svx,"s"+"__FolderUbersplat_FolderColor_StructAlpha_Allocation__allocInit_autoRun")
call Vrx(function Sex,"s"+"__FolderUbersplat_FolderColor_StructTimed_Allocation__allocInit_autoRun")
call Vrx(function Sxx,"s"+"__FolderUbersplat_StructColor_Allocation__allocInit_autoRun")
call Vrx(function Sox,"s"+"__FolderUbersplat_FolderPosition_StructX_Allocation__allocInit_autoRun")
call Vrx(function Srx,"s"+"__FolderUbersplat_FolderPosition_StructY_Allocation__allocInit_autoRun")
call Vrx(function Six,"s"+"__FolderUbersplat_StructPosition_Allocation__allocInit_autoRun")
call Vrx(function Sax,"s"+"__Ubersplat_Allocation__allocInit_autoRun")
call Vrx(function SCx,"s"+"__Ubersplat_initializer_Init_autoRun")
call Vrx(function Sdx,"s"+"__FolderTextTag_StructPosition_Allocation__allocInit_autoRun")
call Vrx(function SDx,"s"+"__FolderTextTag_StructText_Allocation__allocInit_autoRun")
call Vrx(function Sfx,"s"+"__FolderTextTag_StructCreateJumping_Allocation__allocInit_autoRun")
call Vrx(function SFx,"s"+"__FolderTextTag_StructCreateMoving_Allocation__allocInit_autoRun")
call Vrx(function Sgx,"s"+"__FolderTextTag_StructCreateRising_Allocation__allocInit_autoRun")
call Vrx(function SGx,"s"+"__FolderTextTag_FolderFadingOut_StructDelay_Allocation__allocInit_autoRun")
call Vrx(function Shx,"s"+"__FolderTextTag_StructFadingOut_Allocation__allocInit_autoRun")
call Vrx(function SHx,"s"+"__TextTag_Allocation__allocInit_autoRun")
call Vrx(function SJx,"s"+"__TextTag_initializer_Init_autoRun")
call Vrx(function Skx,"s"+"__TimerDialog_Allocation__allocInit_autoRun")
call Vrx(function SKx,"s"+"__FolderTriggerTimer_StructId_Allocation__allocInit_autoRun")
call Vrx(function Slx,"s"+"__FolderTriggerTimer_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function SLx,"s"+"__FolderTriggerTimer_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function Smx,"s"+"__FolderTriggerTimer_StructData_Allocation__allocInit_autoRun")
call Vrx(function SMx,"s"+"__TriggerTimer_Allocation__allocInit_autoRun")
call Vrx(function Spx,"s"+"__FolderTimer_StructId_Allocation__allocInit_autoRun")
call Vrx(function SPx,"s"+"__FolderTimer_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function Sqx,"s"+"__FolderTimer_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function SQx,"s"+"__FolderTimer_StructData_Allocation__allocInit_autoRun")
call Vrx(function Ssx,"s"+"__Timer_Allocation__allocInit_autoRun")
call Vrx(function Sux,"s"+"__Timer_initializer_Init_autoRun")
call Vrx(function SUx,"s"+"__FolderTrigger_StructId_Allocation__allocInit_autoRun")
call Vrx(function Swx,"s"+"__FolderTrigger_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function SWx,"s"+"__FolderTrigger_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function Syx,"s"+"__FolderTrigger_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function SYx,"s"+"__FolderTrigger_StructData_Allocation__allocInit_autoRun")
call Vrx(function Szx,"s"+"__FolderTrigger_FolderEvent_StructNative_Allocation__allocInit_autoRun")
call Vrx(function SZx,"s"+"__FolderTrigger_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function S_x,"s"+"__FolderTrigger_StructRegisterEvent_Allocation__allocInit_autoRun")
call Vrx(function S0x,"s"+"__Trigger_Allocation__allocInit_autoRun")
call Vrx(function S4x,"s"+"__Trigger_initializer_Init_autoRun")
call Vrx(function tXx,"s"+"__FolderBJUnit_FolderArmor_StructBonus_objInits_autoRun")
call Vrx(function tOx,"s"+"__FolderBJUnit_FolderArmor_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function tRx,"s"+"__FolderBJUnit_StructArmor_Allocation__allocInit_autoRun")
call Vrx(function tmx,"s"+"__FolderBJUnit_FolderAttack_FolderSpeed_StructBonusA_objInits_autoRun")
call Vrx(function tMx,"s"+"__FolderBJUnit_FolderAttack_FolderSpeed_StructBonusA_Allocation__allocInit_autoRun")
call Vrx(function tpx,"s"+"__FolderBJUnit_FolderAttack_StructSpeed_Allocation__allocInit_autoRun")
call Vrx(function tqx,"s"+"__FolderBJUnit_StructAttack_objInits_autoRun")
call Vrx(function tQx,"s"+"__FolderBJUnit_StructAttack_Allocation__allocInit_autoRun")
call Vrx(function t2x,"s"+"__FolderBJUnit_FolderDamage_StructBonus_objInits_autoRun")
call Vrx(function t3x,"s"+"__FolderBJUnit_FolderDamage_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function THx,"s"+"__FolderBJUnit_StructDamage_objInits_autoRun")
call Vrx(function Tjx,"s"+"__FolderBJUnit_StructDamage_Allocation__allocInit_autoRun")
call Vrx(function Tkx,"s"+"__FolderBJUnit_StructMovement_objInits_autoRun")
call Vrx(function TKx,"s"+"__FolderBJUnit_StructMovement_Allocation__allocInit_autoRun")
call Vrx(function TWx,"s"+"__FolderBJUnit_FolderHero_FolderAgility_StructBonusA_objInits_autoRun")
call Vrx(function Tyx,"s"+"__FolderBJUnit_FolderHero_FolderAgility_StructBonusA_Allocation__allocInit_autoRun")
call Vrx(function TYx,"s"+"__FolderBJUnit_FolderHero_StructAgility_Allocation__allocInit_autoRun")
call Vrx(function uxx,"s"+"__FolderBJUnit_FolderHero_FolderIntelligence_StructBonusA_objInits_autoRun")
call Vrx(function uox,"s"+"__FolderBJUnit_FolderHero_FolderIntelligence_StructBonusA_Allocation__allocInit_autoRun")
call Vrx(function urx,"s"+"__FolderBJUnit_FolderHero_StructIntelligence_Allocation__allocInit_autoRun")
call Vrx(function udx,"s"+"__FolderBJUnit_FolderHero_FolderStrength_StructBonusA_objInits_autoRun")
call Vrx(function uDx,"s"+"__FolderBJUnit_FolderHero_FolderStrength_StructBonusA_Allocation__allocInit_autoRun")
call Vrx(function ufx,"s"+"__FolderBJUnit_FolderHero_StructStrength_Allocation__allocInit_autoRun")
call Vrx(function uFx,"s"+"__FolderBJUnit_StructHero_Allocation__allocInit_autoRun")
call Vrx(function uhx,"s"+"__BJUnit_objInits_autoRun")
call Vrx(function uHx,"s"+"__UnitAttackSplash_Allocation__allocInit_autoRun")
call Vrx(function ujx,"s"+"__FolderUnitClass_StructId_Allocation__allocInit_autoRun")
call Vrx(function uJx,"s"+"__FolderUnitClass_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function ukx,"s"+"__FolderUnitClass_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function uKx,"s"+"__FolderUnitClass_StructData_Allocation__allocInit_autoRun")
call Vrx(function ulx,"s"+"__UnitClass_Allocation__allocInit_autoRun")
call Vrx(function uLx,"s"+"__FolderUnitTypePool_StructId_Allocation__allocInit_autoRun")
call Vrx(function umx,"s"+"__FolderUnitTypePool_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function uMx,"s"+"__FolderUnitTypePool_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function upx,"s"+"__FolderUnitTypePool_FolderData_StructReal_Allocation__allocInit_autoRun")
call Vrx(function uPx,"s"+"__FolderUnitTypePool_StructData_Allocation__allocInit_autoRun")
call Vrx(function uqx,"s"+"__UnitTypePool_Allocation__allocInit_autoRun")
call Vrx(function uQx,"s"+"__FolderUnit_StructId_Allocation__allocInit_autoRun")
call Vrx(function usx,"s"+"__FolderUnit_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function uSx,"s"+"__FolderUnit_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function utx,"s"+"__FolderUnit_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function uTx,"s"+"__FolderUnit_FolderData_FolderReal_StructTable_Allocation__allocInit_autoRun")
call Vrx(function uux,"s"+"__FolderUnit_FolderData_StructReal_Allocation__allocInit_autoRun")
call Vrx(function uUx,"s"+"__FolderUnit_StructData_Allocation__allocInit_autoRun")
call Vrx(function uwx,"s"+"__FolderUnit_FolderEvent_StructCombination_Allocation__allocInit_autoRun")
call Vrx(function uWx,"s"+"__FolderUnit_FolderEvent_StructCounted_Allocation__allocInit_autoRun")
call Vrx(function uyx,"s"+"__FolderUnit_FolderEvent_StructNative_Allocation__allocInit_autoRun")
call Vrx(function uYx,"s"+"__FolderUnit_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function uzx,"s"+"__FolderUnit_FolderAbilities_StructCooldown_Allocation__allocInit_autoRun")
call Vrx(function uZx,"s"+"__FolderUnit_FolderAbilities_FolderEvents_StructBegin_Allocation__allocInit_autoRun")
call Vrx(function u4x,"s"+"__FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_objInits_autoRun")
call Vrx(function u5x,"s"+"__FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Allocation__allocInit_autoRun")
call Vrx(function USx,"s"+"__FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_initializer_Buff_Init_autoRun")
call Vrx(function Uwx,"s"+"__FolderUnit_FolderAbilities_FolderEvents_StructEffect_objInits_autoRun")
call Vrx(function UWx,"s"+"__FolderUnit_FolderAbilities_FolderEvents_StructEffect_Allocation__allocInit_autoRun")
call Vrx(function Uyx,"s"+"__FolderUnit_FolderAbilities_FolderEvents_StructFinish_Allocation__allocInit_autoRun")
call Vrx(function UYx,"s"+"__FolderUnit_FolderAbilities_FolderEvents_StructLearn_Allocation__allocInit_autoRun")
call Vrx(function Uzx,"s"+"__FolderUnit_FolderAbilities_FolderEvents_StructUnlearn_Allocation__allocInit_autoRun")
call Vrx(function UZx,"s"+"__FolderUnit_FolderAbilities_StructEvents_Allocation__allocInit_autoRun")
call Vrx(function U_x,"s"+"__FolderUnit_FolderAbilities_StructAutoCast_Allocation__allocInit_autoRun")
call Vrx(function U0x,"s"+"__FolderUnit_StructAbilities_Allocation__allocInit_autoRun")
call Vrx(function U1x,"s"+"__FolderUnit_StructEffects_Allocation__allocInit_autoRun")
call Vrx(function U2x,"s"+"__FolderUnit_StructSounds_Allocation__allocInit_autoRun")
call Vrx(function U3x,"s"+"__FolderUnit_StructAttachments_Allocation__allocInit_autoRun")
call Vrx(function U4x,"s"+"__FolderUnit_FolderBuffs_FolderEvents_StructChangeLevel_Allocation__allocInit_autoRun")
call Vrx(function U5x,"s"+"__FolderUnit_FolderBuffs_FolderEvents_StructGain_Allocation__allocInit_autoRun")
call Vrx(function U6x,"s"+"__FolderUnit_FolderBuffs_FolderEvents_StructLose_Allocation__allocInit_autoRun")
call Vrx(function U7x,"s"+"__FolderUnit_FolderBuffs_StructEvents_Allocation__allocInit_autoRun")
call Vrx(function U8x,"s"+"__FolderUnit_FolderBuffs_FolderTimed_StructCountdown_Allocation__allocInit_autoRun")
call Vrx(function U9x,"s"+"__FolderUnit_FolderBuffs_StructTimed_Allocation__allocInit_autoRun")
call Vrx(function wvx,"s"+"__FolderUnit_StructBuffs_Allocation__allocInit_autoRun")
call Vrx(function wex,"s"+"__FolderUnit_StructModSets_Allocation__allocInit_autoRun")
call Vrx(function wxx,"s"+"__FolderUnit_FolderItems_FolderEvents_StructGain_Allocation__allocInit_autoRun")
call Vrx(function wox,"s"+"__FolderUnit_FolderItems_FolderEvents_StructLose_Allocation__allocInit_autoRun")
call Vrx(function wrx,"s"+"__FolderUnit_FolderItems_FolderEvents_StructMoveInInventory_Allocation__allocInit_autoRun")
call Vrx(function wix,"s"+"__FolderUnit_FolderItems_FolderEvents_StructSell_Allocation__allocInit_autoRun")
call Vrx(function wax,"s"+"__FolderUnit_FolderItems_FolderEvents_StructUse_Allocation__allocInit_autoRun")
call Vrx(function wnx,"s"+"__FolderUnit_FolderItems_StructEvents_Allocation__allocInit_autoRun")
call Vrx(function wVx,"s"+"__FolderUnit_StructItems_Allocation__allocInit_autoRun")
call Vrx(function wEx,"s"+"__FolderUnit_StructClasses_Allocation__allocInit_autoRun")
call Vrx(function wIx,"s"+"__FolderUnit_StructType_objInits_autoRun")
call Vrx(function wAx,"s"+"__FolderUnit_StructType_Allocation__allocInit_autoRun")
call Vrx(function wNx,"s"+"__FolderUnit_StructColor_Allocation__allocInit_autoRun")
call Vrx(function wbx,"s"+"__FolderUnit_StructOwner_Allocation__allocInit_autoRun")
call Vrx(function wBx,"s"+"__FolderUnit_FolderArmor_StructBase_Allocation__allocInit_autoRun")
call Vrx(function wcx,"s"+"__FolderUnit_FolderArmor_FolderBonus_StructDisplayed_Allocation__allocInit_autoRun")
call Vrx(function wCx,"s"+"__FolderUnit_FolderArmor_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function wdx,"s"+"__FolderUnit_FolderArmor_FolderIgnoreDamage_StructRelative_Allocation__allocInit_autoRun")
call Vrx(function wDx,"s"+"__FolderUnit_FolderArmor_StructIgnoreDamage_Allocation__allocInit_autoRun")
call Vrx(function wfx,"s"+"__FolderUnit_FolderArmor_FolderRelative_StructInvisible_Allocation__allocInit_autoRun")
call Vrx(function wFx,"s"+"__FolderUnit_FolderArmor_StructRelative_Allocation__allocInit_autoRun")
call Vrx(function wgx,"s"+"__FolderUnit_FolderArmor_StructResistance_Allocation__allocInit_autoRun")
call Vrx(function wGx,"s"+"__FolderUnit_FolderArmor_StructSpell_Allocation__allocInit_autoRun")
call Vrx(function whx,"s"+"__FolderUnit_FolderArmor_StructTypeA_Allocation__allocInit_autoRun")
call Vrx(function wHx,"s"+"__FolderUnit_StructArmor_Allocation__allocInit_autoRun")
call Vrx(function wjx,"s"+"__FolderUnit_FolderAttack_FolderEvents_StructAcquire2_Allocation__allocInit_autoRun")
call Vrx(function wJx,"s"+"__FolderUnit_FolderAttack_FolderEvents_StructGround_objInits_autoRun")
call Vrx(function wkx,"s"+"__FolderUnit_FolderAttack_FolderEvents_StructGround_Allocation__allocInit_autoRun")
call Vrx(function wKx,"s"+"__FolderUnit_FolderAttack_StructEvents_Allocation__allocInit_autoRun")
call Vrx(function wlx,"s"+"__FolderUnit_FolderAttack_FolderMissile_StructSpeed_Allocation__allocInit_autoRun")
call Vrx(function wLx,"s"+"__FolderUnit_FolderAttack_StructMissile_Allocation__allocInit_autoRun")
call Vrx(function wmx,"s"+"__FolderUnit_FolderAttack_StructRange_Allocation__allocInit_autoRun")
call Vrx(function wMx,"s"+"__FolderUnit_FolderAttack_FolderSpeed_StructBaseA_Allocation__allocInit_autoRun")
call Vrx(function wpx,"s"+"__FolderUnit_FolderAttack_FolderSpeed_FolderBonusA_StructDisplayedA_Allocation__allocInit_autoRun")
call Vrx(function wPx,"s"+"__FolderUnit_FolderAttack_FolderSpeed_StructBonusA_Allocation__allocInit_autoRun")
call Vrx(function wqx,"s"+"__FolderUnit_FolderAttack_StructSpeed_Allocation__allocInit_autoRun")
call Vrx(function wQx,"s"+"__FolderUnit_FolderAttack_FolderSplash_StructTargetFlag_Allocation__allocInit_autoRun")
call Vrx(function wsx,"s"+"__FolderUnit_FolderAttack_StructSplash_Allocation__allocInit_autoRun")
call Vrx(function wUx,"s"+"__FolderUnit_StructAttack_objInits_autoRun")
call Vrx(function wwx,"s"+"__FolderUnit_StructAttack_Allocation__allocInit_autoRun")
call Vrx(function wzx,"s"+"__FolderUnit_StructAttack_initializer_Buff_Init_autoRun")
call Vrx(function wZx,"s"+"__FolderUnit_StructBlood_Allocation__allocInit_autoRun")
call Vrx(function w_x,"s"+"__FolderUnit_StructBloodExplosion_Allocation__allocInit_autoRun")
call Vrx(function w0x,"s"+"__FolderUnit_StructCollisionSize_Allocation__allocInit_autoRun")
call Vrx(function w1x,"s"+"__FolderUnit_FolderCriticalChanceDefense_StructBase_Allocation__allocInit_autoRun")
call Vrx(function w2x,"s"+"__FolderUnit_FolderCriticalChanceDefense_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function w3x,"s"+"__FolderUnit_StructCriticalChanceDefense_Allocation__allocInit_autoRun")
call Vrx(function w4x,"s"+"__FolderUnit_FolderCriticalChance_StructBase_Allocation__allocInit_autoRun")
call Vrx(function w5x,"s"+"__FolderUnit_FolderCriticalChance_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function w6x,"s"+"__FolderUnit_StructCriticalChance_Allocation__allocInit_autoRun")
call Vrx(function w8x,"s"+"__FolderUnit_FolderDeath_StructExplosion_objInits_autoRun")
call Vrx(function w9x,"s"+"__FolderUnit_FolderDeath_StructExplosion_Allocation__allocInit_autoRun")
call Vrx(function Wox,"s"+"__FolderUnit_FolderDeath_StructExplosion_initializer_Buff_Init_autoRun")
call Vrx(function Wrx,"s"+"__FolderUnit_FolderDeath_StructEvents_Allocation__allocInit_autoRun")
call Vrx(function Wax,"s"+"__FolderUnit_FolderDeath_StructProtection_objInits_autoRun")
call Vrx(function Wnx,"s"+"__FolderUnit_FolderDeath_StructProtection_Allocation__allocInit_autoRun")
call Vrx(function WOx,"s"+"__FolderUnit_FolderDeath_StructProtection_initializer_Buff_Init_autoRun")
call Vrx(function WRx,"s"+"__FolderUnit_StructDeath_Allocation__allocInit_autoRun")
call Vrx(function WIx,"s"+"__FolderUnit_FolderDecay_StructDuration_Allocation__allocInit_autoRun")
call Vrx(function WAx,"s"+"__FolderUnit_FolderDecay_StructEvents_Allocation__allocInit_autoRun")
call Vrx(function WNx,"s"+"__FolderUnit_FolderDecay_StructTimed_Allocation__allocInit_autoRun")
call Vrx(function Wbx,"s"+"__FolderUnit_StructDecay_Allocation__allocInit_autoRun")
call Vrx(function Wcx,"s"+"__FolderUnit_StructDisplay_objInits_autoRun")
call Vrx(function WCx,"s"+"__FolderUnit_StructDisplay_Allocation__allocInit_autoRun")
call Vrx(function Wdx,"s"+"__FolderUnit_FolderDrop_StructExp_Allocation__allocInit_autoRun")
call Vrx(function WDx,"s"+"__FolderUnit_FolderDrop_StructSupply_Allocation__allocInit_autoRun")
call Vrx(function Wfx,"s"+"__FolderUnit_StructDrop_Allocation__allocInit_autoRun")
call Vrx(function WFx,"s"+"__FolderUnit_StructEvasion_Allocation__allocInit_autoRun")
call Vrx(function Wgx,"s"+"__FolderUnit_FolderEvasionChanceDefense_StructBase_Allocation__allocInit_autoRun")
call Vrx(function WGx,"s"+"__FolderUnit_FolderEvasionChanceDefense_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function Whx,"s"+"__FolderUnit_StructEvasionChanceDefense_Allocation__allocInit_autoRun")
call Vrx(function WHx,"s"+"__FolderUnit_FolderEvasionChance_StructBase_Allocation__allocInit_autoRun")
call Vrx(function Wjx,"s"+"__FolderUnit_FolderEvasionChance_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function WJx,"s"+"__FolderUnit_StructEvasionChance_Allocation__allocInit_autoRun")
call Vrx(function Wkx,"s"+"__FolderUnit_FolderImpact_StructX_Allocation__allocInit_autoRun")
call Vrx(function WKx,"s"+"__FolderUnit_FolderImpact_StructY_Allocation__allocInit_autoRun")
call Vrx(function Wlx,"s"+"__FolderUnit_FolderImpact_StructZ_Allocation__allocInit_autoRun")
call Vrx(function WLx,"s"+"__FolderUnit_StructImpact_Allocation__allocInit_autoRun")
call Vrx(function Wmx,"s"+"__FolderUnit_StructExp_Allocation__allocInit_autoRun")
call Vrx(function WMx,"s"+"__FolderUnit_FolderOutpact_StructX_Allocation__allocInit_autoRun")
call Vrx(function Wpx,"s"+"__FolderUnit_FolderOutpact_StructY_Allocation__allocInit_autoRun")
call Vrx(function WPx,"s"+"__FolderUnit_FolderOutpact_StructZ_Allocation__allocInit_autoRun")
call Vrx(function Wqx,"s"+"__FolderUnit_StructOutpact_Allocation__allocInit_autoRun")
call Vrx(function WQx,"s"+"__FolderUnit_StructLifeLeech_objInits_autoRun")
call Vrx(function Wsx,"s"+"__FolderUnit_StructLifeLeech_Allocation__allocInit_autoRun")
call Vrx(function WSx,"s"+"__FolderUnit_StructManaLeech_objInits_autoRun")
call Vrx(function Wtx,"s"+"__FolderUnit_StructManaLeech_Allocation__allocInit_autoRun")
call Vrx(function WWx,"s"+"__FolderUnit_StructInvulnerability_objInits_autoRun")
call Vrx(function Wyx,"s"+"__FolderUnit_StructInvulnerability_Allocation__allocInit_autoRun")
call Vrx(function W2x,"s"+"__FolderUnit_StructInvulnerability_initializer_Buff_Init_autoRun")
call Vrx(function W3x,"s"+"__FolderUnit_FolderDamage_FolderBase_StructDisplayed_Allocation__allocInit_autoRun")
call Vrx(function W4x,"s"+"__FolderUnit_FolderDamage_StructBase_Allocation__allocInit_autoRun")
call Vrx(function W5x,"s"+"__FolderUnit_FolderDamage_FolderBonus_StructDisplayed_Allocation__allocInit_autoRun")
call Vrx(function W6x,"s"+"__FolderUnit_FolderDamage_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function W7x,"s"+"__FolderUnit_FolderDamage_StructDelay_Allocation__allocInit_autoRun")
call Vrx(function W8x,"s"+"__FolderUnit_FolderDamage_StructDices_Allocation__allocInit_autoRun")
call Vrx(function W9x,"s"+"__FolderUnit_FolderDamage_StructEvents_Allocation__allocInit_autoRun")
call Vrx(function yvx,"s"+"__FolderUnit_FolderDamage_FolderRelative_StructInvisible_Allocation__allocInit_autoRun")
call Vrx(function yex,"s"+"__FolderUnit_FolderDamage_StructRelative_Allocation__allocInit_autoRun")
call Vrx(function yxx,"s"+"__FolderUnit_FolderDamage_StructSides_Allocation__allocInit_autoRun")
call Vrx(function yox,"s"+"__FolderUnit_FolderDamage_StructSpellRelative_Allocation__allocInit_autoRun")
call Vrx(function yrx,"s"+"__FolderUnit_FolderDamage_StructTypeA_Allocation__allocInit_autoRun")
call Vrx(function yix,"s"+"__FolderUnit_StructDamage_Allocation__allocInit_autoRun")
call Vrx(function yVx,"s"+"__FolderUnit_FolderMagicImmunity_StructSpellShield_objInits_autoRun")
call Vrx(function yEx,"s"+"__FolderUnit_FolderMagicImmunity_StructSpellShield_Allocation__allocInit_autoRun")
call Vrx(function yIx,"s"+"__FolderUnit_FolderMagicImmunity_StructSpellShield_initializer_Buff_Init_autoRun")
call Vrx(function ybx,"s"+"__FolderUnit_StructMagicImmunity_objInits_autoRun")
call Vrx(function yBx,"s"+"__FolderUnit_StructMagicImmunity_Allocation__allocInit_autoRun")
call Vrx(function yDx,"s"+"__FolderUnit_StructMagicImmunity_initializer_Buff_Init_autoRun")
call Vrx(function yfx,"s"+"__FolderUnit_FolderScale_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function yFx,"s"+"__FolderUnit_FolderScale_StructTimed_Allocation__allocInit_autoRun")
call Vrx(function rFo,"s"+"__FolderUnit_StructScale_objInits_autoRun")
call Vrx(function rgo,"s"+"__FolderUnit_StructScale_Allocation__allocInit_autoRun")
call Vrx(function rKo,"s"+"__FolderUnit_StructScale_initializer_Buff_Init_autoRun")
call Vrx(function rlo,"s"+"__FolderUnit_FolderVertexColor_StructRed_Allocation__allocInit_autoRun")
call Vrx(function rLo,"s"+"__FolderUnit_FolderVertexColor_StructGreen_Allocation__allocInit_autoRun")
call Vrx(function rmo,"s"+"__FolderUnit_FolderVertexColor_StructBlue_Allocation__allocInit_autoRun")
call Vrx(function rMo,"s"+"__FolderUnit_FolderVertexColor_StructAlpha_Allocation__allocInit_autoRun")
call Vrx(function rpo,"s"+"__FolderUnit_FolderVertexColor_StructTimed_Allocation__allocInit_autoRun")
call Vrx(function rPo,"s"+"__FolderUnit_StructVertexColor_Allocation__allocInit_autoRun")
call Vrx(function rYo,"s"+"__FolderUnit_StructCold_objInits_autoRun")
call Vrx(function rzo,"s"+"__FolderUnit_StructCold_Allocation__allocInit_autoRun")
call Vrx(function r1o,"s"+"__FolderUnit_StructCold_initializer_Buff_Init_autoRun")
call Vrx(function r4o,"s"+"__FolderUnit_StructFrost_objInits_autoRun")
call Vrx(function r5o,"s"+"__FolderUnit_StructFrost_Allocation__allocInit_autoRun")
call Vrx(function r9o,"s"+"__FolderUnit_StructFrost_initializer_Buff_Init_autoRun")
call Vrx(function ieo,"s"+"__FolderUnit_FolderInvisibility_StructReveal_objInits_autoRun")
call Vrx(function ixo,"s"+"__FolderUnit_FolderInvisibility_StructReveal_Allocation__allocInit_autoRun")
call Vrx(function iao,"s"+"__FolderUnit_FolderInvisibility_StructReveal_initializer_Buff_Init_autoRun")
call Vrx(function iOo,"s"+"__FolderUnit_StructInvisibility_objInits_autoRun")
call Vrx(function iRo,"s"+"__FolderUnit_StructInvisibility_Allocation__allocInit_autoRun")
call Vrx(function iDo,"s"+"__FolderUnit_StructInvisibility_initializer_Buff_Init_autoRun")
call Vrx(function igo,"s"+"__FolderUnit_StructGhost_objInits_autoRun")
call Vrx(function iGo,"s"+"__FolderUnit_StructGhost_Allocation__allocInit_autoRun")
call Vrx(function iJo,"s"+"__FolderUnit_StructGhost_initializer_Buff_Init_autoRun")
call Vrx(function iko,"s"+"__FolderUnit_StructHealAbility_Allocation__allocInit_autoRun")
call Vrx(function iKo,"s"+"__FolderUnit_FolderMaxLife_StructBase_Allocation__allocInit_autoRun")
call Vrx(function ilo,"s"+"__FolderUnit_FolderMaxLife_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function iLo,"s"+"__FolderUnit_FolderMaxLife_StructRelative_Allocation__allocInit_autoRun")
call Vrx(function ipo,"s"+"__FolderUnit_StructMaxLife_objInits_autoRun")
call Vrx(function iPo,"s"+"__FolderUnit_StructMaxLife_Allocation__allocInit_autoRun")
call Vrx(function iqo,"s"+"__FolderUnit_StructLife_Allocation__allocInit_autoRun")
call Vrx(function iQo,"s"+"__FolderUnit_FolderLifeRegeneration_StructBase_Allocation__allocInit_autoRun")
call Vrx(function iso,"s"+"__FolderUnit_FolderLifeRegeneration_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function ito,"s"+"__FolderUnit_FolderLifeRegeneration_StructDisablement_objInits_autoRun")
call Vrx(function iTo,"s"+"__FolderUnit_FolderLifeRegeneration_StructDisablement_Allocation__allocInit_autoRun")
call Vrx(function iWo,"s"+"__FolderUnit_FolderLifeRegeneration_StructDisablement_initializer_Buff_Init_autoRun")
call Vrx(function iyo,"s"+"__FolderUnit_FolderLifeRegeneration_StructRelative_Allocation__allocInit_autoRun")
call Vrx(function iYo,"s"+"__FolderUnit_StructLifeRegeneration_Allocation__allocInit_autoRun")
call Vrx(function izo,"s"+"__FolderUnit_FolderMaxMana_StructBase_Allocation__allocInit_autoRun")
call Vrx(function iZo,"s"+"__FolderUnit_FolderMaxMana_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function i_o,"s"+"__FolderUnit_FolderMaxMana_StructRelative_Allocation__allocInit_autoRun")
call Vrx(function i2o,"s"+"__FolderUnit_StructMaxMana_objInits_autoRun")
call Vrx(function i3o,"s"+"__FolderUnit_StructMaxMana_Allocation__allocInit_autoRun")
call Vrx(function i4o,"s"+"__FolderUnit_StructMana_Allocation__allocInit_autoRun")
call Vrx(function i5o,"s"+"__FolderUnit_FolderManaRegeneration_StructBase_Allocation__allocInit_autoRun")
call Vrx(function i6o,"s"+"__FolderUnit_FolderManaRegeneration_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function i8o,"s"+"__FolderUnit_FolderManaRegeneration_StructDisablement_objInits_autoRun")
call Vrx(function i9o,"s"+"__FolderUnit_FolderManaRegeneration_StructDisablement_Allocation__allocInit_autoRun")
call Vrx(function aoo,"s"+"__FolderUnit_FolderManaRegeneration_StructDisablement_initializer_Buff_Init_autoRun")
call Vrx(function aro,"s"+"__FolderUnit_FolderManaRegeneration_StructRelative_Allocation__allocInit_autoRun")
call Vrx(function aio,"s"+"__FolderUnit_StructManaRegeneration_Allocation__allocInit_autoRun")
call Vrx(function aao,"s"+"__FolderUnit_FolderMovement_FolderEvents_StructEnterRegion_Allocation__allocInit_autoRun")
call Vrx(function ano,"s"+"__FolderUnit_FolderMovement_FolderEvents_StructInterval_Allocation__allocInit_autoRun")
call Vrx(function aVo,"s"+"__FolderUnit_FolderMovement_FolderEvents_StructLeaveRegion_Allocation__allocInit_autoRun")
call Vrx(function aEo,"s"+"__FolderUnit_FolderMovement_StructEvents_Allocation__allocInit_autoRun")
call Vrx(function aXo,"s"+"__FolderUnit_FolderMovement_FolderSpeed_StructBaseA_Allocation__allocInit_autoRun")
call Vrx(function aIo,"s"+"__FolderUnit_FolderMovement_FolderSpeed_StructBonusA_objInits_autoRun")
call Vrx(function aAo,"s"+"__FolderUnit_FolderMovement_FolderSpeed_StructBonusA_Allocation__allocInit_autoRun")
call Vrx(function aNo,"s"+"__FolderUnit_FolderMovement_FolderSpeed_StructRelativeA_Allocation__allocInit_autoRun")
call Vrx(function abo,"s"+"__FolderUnit_FolderMovement_StructSpeed_Allocation__allocInit_autoRun")
call Vrx(function aco,"s"+"__FolderUnit_StructMovement_objInits_autoRun")
call Vrx(function aCo,"s"+"__FolderUnit_StructMovement_Allocation__allocInit_autoRun")
call Vrx(function aFo,"s"+"__FolderUnit_StructMovement_initializer_Buff_Init_autoRun")
call Vrx(function ago,"s"+"__FolderUnit_FolderOrder_FolderEvents_StructLose_Allocation__allocInit_autoRun")
call Vrx(function aGo,"s"+"__FolderUnit_FolderOrder_FolderEvents_FolderGain_StructImmediate_Allocation__allocInit_autoRun")
call Vrx(function aho,"s"+"__FolderUnit_FolderOrder_FolderEvents_FolderGain_StructPoint_Allocation__allocInit_autoRun")
call Vrx(function aHo,"s"+"__FolderUnit_FolderOrder_FolderEvents_FolderGain_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function ajo,"s"+"__FolderUnit_FolderOrder_FolderEvents_StructGain_Allocation__allocInit_autoRun")
call Vrx(function aJo,"s"+"__FolderUnit_FolderOrder_FolderEvents_StructIdle_Allocation__allocInit_autoRun")
call Vrx(function ako,"s"+"__FolderUnit_FolderOrder_StructEvents_Allocation__allocInit_autoRun")
call Vrx(function aKo,"s"+"__FolderUnit_StructOrder_Allocation__allocInit_autoRun")
call Vrx(function apo,"s"+"__FolderUnit_StructBanish_objInits_autoRun")
call Vrx(function aPo,"s"+"__FolderUnit_StructBanish_Allocation__allocInit_autoRun")
call Vrx(function aSo,"s"+"__FolderUnit_StructBanish_initializer_Buff_Init_autoRun")
call Vrx(function auo,"s"+"__FolderUnit_StructMadness_objInits_autoRun")
call Vrx(function aUo,"s"+"__FolderUnit_StructMadness_Allocation__allocInit_autoRun")
call Vrx(function azo,"s"+"__FolderUnit_StructMadness_initializer_Buff_Init_autoRun")
call Vrx(function a0o,"s"+"__FolderUnit_StructEclipse_objInits_autoRun")
call Vrx(function a1o,"s"+"__FolderUnit_StructEclipse_Allocation__allocInit_autoRun")
call Vrx(function a5o,"s"+"__FolderUnit_StructEclipse_initializer_Buff_Init_autoRun")
call Vrx(function neo,"s"+"__FolderUnit_StructWhirl_objInits_autoRun")
call Vrx(function nxo,"s"+"__FolderUnit_StructWhirl_Allocation__allocInit_autoRun")
call Vrx(function nao,"s"+"__FolderUnit_StructWhirl_initializer_Buff_Init_autoRun")
call Vrx(function nno,"s"+"__FolderUnit_StructFacing_Allocation__allocInit_autoRun")
call Vrx(function nXo,"s"+"__FolderUnit_StructBleeding_objInits_autoRun")
call Vrx(function nOo,"s"+"__FolderUnit_StructBleeding_Allocation__allocInit_autoRun")
call Vrx(function npo,"s"+"__FolderUnit_StructBleeding_initializer_Buff_Init_autoRun")
call Vrx(function nQo,"s"+"__FolderUnit_StructIgnited_objInits_autoRun")
call Vrx(function nso,"s"+"__FolderUnit_StructIgnited_Allocation__allocInit_autoRun")
call Vrx(function nUo,"s"+"__FolderUnit_StructIgnited_initializer_Buff_Init_autoRun")
call Vrx(function nwo,"s"+"__FolderUnit_StructKnockup_Allocation__allocInit_autoRun")
call Vrx(function nyo,"s"+"__FolderUnit_StructKnockup_initializer_Buff_Init_autoRun")
call Vrx(function nzo,"s"+"__FolderUnit_StructPathing_objInits_autoRun")
call Vrx(function nZo,"s"+"__FolderUnit_StructPathing_Allocation__allocInit_autoRun")
call Vrx(function n2o,"s"+"__FolderUnit_StructPathing_initializer_Buff_Init_autoRun")
call Vrx(function n5o,"s"+"__FolderUnit_StructPoisoned_objInits_autoRun")
call Vrx(function n6o,"s"+"__FolderUnit_StructPoisoned_Allocation__allocInit_autoRun")
call Vrx(function Vvo,"s"+"__FolderUnit_StructPoisoned_initializer_Buff_Init_autoRun")
call Vrx(function Veo,"s"+"__FolderUnit_FolderRevival_StructAble_Allocation__allocInit_autoRun")
call Vrx(function Vxo,"s"+"__FolderUnit_FolderRevival_StructEvents_Allocation__allocInit_autoRun")
call Vrx(function Vro,"s"+"__FolderUnit_StructRevival_objInits_autoRun")
call Vrx(function Vio,"s"+"__FolderUnit_StructRevival_Allocation__allocInit_autoRun")
call Vrx(function VXo,"s"+"__FolderUnit_StructSilence_objInits_autoRun")
call Vrx(function VOo,"s"+"__FolderUnit_StructSilence_Allocation__allocInit_autoRun")
call Vrx(function VNo,"s"+"__FolderUnit_StructSilence_initializer_Buff_Init_autoRun")
call Vrx(function VCo,"s"+"__FolderUnit_StructSleep_objInits_autoRun")
call Vrx(function Vdo,"s"+"__FolderUnit_StructSleep_Allocation__allocInit_autoRun")
call Vrx(function VHo,"s"+"__FolderUnit_StructSleep_initializer_Buff_Init_autoRun")
call Vrx(function Vjo,"s"+"__FolderUnit_FolderStun_StructCancel_Allocation__allocInit_autoRun")
call Vrx(function Vlo,"s"+"__FolderUnit_StructStun_objInits_autoRun")
call Vrx(function VLo,"s"+"__FolderUnit_StructStun_Allocation__allocInit_autoRun")
call Vrx(function VPo,"s"+"__FolderUnit_StructStun_initializer_Buff_Init_autoRun")
call Vrx(function Vqo,"s"+"__FolderUnit_FolderAnimation_StructLoop_Allocation__allocInit_autoRun")
call Vrx(function VQo,"s"+"__FolderUnit_FolderAnimation_StructSpeed_Allocation__allocInit_autoRun")
call Vrx(function Vso,"s"+"__FolderUnit_StructAnimation_Allocation__allocInit_autoRun")
call Vrx(function VSo,"s"+"__FolderUnit_StructSkillPoints_Allocation__allocInit_autoRun")
call Vrx(function Vto,"s"+"__FolderUnit_FolderSpellPower_StructBase_Allocation__allocInit_autoRun")
call Vrx(function VTo,"s"+"__FolderUnit_FolderSpellPower_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function Vuo,"s"+"__FolderUnit_FolderSpellPower_StructRelative_Allocation__allocInit_autoRun")
call Vrx(function VUo,"s"+"__FolderUnit_StructSpellPower_Allocation__allocInit_autoRun")
call Vrx(function Vwo,"s"+"__FolderUnit_FolderSpellVamp_StructBase_Allocation__allocInit_autoRun")
call Vrx(function VWo,"s"+"__FolderUnit_FolderSpellVamp_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function Vyo,"s"+"__FolderUnit_FolderSpellVamp_StructRelative_Allocation__allocInit_autoRun")
call Vrx(function VYo,"s"+"__FolderUnit_StructSpellVamp_Allocation__allocInit_autoRun")
call Vrx(function Vzo,"s"+"__FolderUnit_FolderMaxRage_StructBase_Allocation__allocInit_autoRun")
call Vrx(function VZo,"s"+"__FolderUnit_FolderMaxRage_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function V_o,"s"+"__FolderUnit_FolderMaxRage_StructRelative_Allocation__allocInit_autoRun")
call Vrx(function V0o,"s"+"__FolderUnit_StructMaxRage_Allocation__allocInit_autoRun")
call Vrx(function V1o,"s"+"__FolderUnit_StructRage_Allocation__allocInit_autoRun")
call Vrx(function V2o,"s"+"__FolderUnit_FolderRageRegeneration_StructBase_Allocation__allocInit_autoRun")
call Vrx(function V3o,"s"+"__FolderUnit_FolderRageRegeneration_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function V4o,"s"+"__FolderUnit_FolderRageRegeneration_StructRelative_Allocation__allocInit_autoRun")
call Vrx(function V5o,"s"+"__FolderUnit_StructRageRegeneration_Allocation__allocInit_autoRun")
call Vrx(function V6o,"s"+"__FolderUnit_FolderMaxStamina_StructBase_Allocation__allocInit_autoRun")
call Vrx(function V7o,"s"+"__FolderUnit_FolderMaxStamina_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function V8o,"s"+"__FolderUnit_FolderMaxStamina_StructRelative_Allocation__allocInit_autoRun")
call Vrx(function V9o,"s"+"__FolderUnit_StructMaxStamina_Allocation__allocInit_autoRun")
call Vrx(function Eeo,"s"+"__FolderUnit_FolderStamina_StructExhaustion_objInits_autoRun")
call Vrx(function Exo,"s"+"__FolderUnit_FolderStamina_StructExhaustion_Allocation__allocInit_autoRun")
call Vrx(function Ero,"s"+"__FolderUnit_FolderStamina_StructExhaustion_initializer_Buff_Init_autoRun")
call Vrx(function Eio,"s"+"__FolderUnit_StructStamina_Allocation__allocInit_autoRun")
call Vrx(function Eao,"s"+"__FolderUnit_FolderStaminaRegeneration_StructBase_Allocation__allocInit_autoRun")
call Vrx(function Eno,"s"+"__FolderUnit_FolderStaminaRegeneration_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function EVo,"s"+"__FolderUnit_FolderStaminaRegeneration_StructRelative_Allocation__allocInit_autoRun")
call Vrx(function EEo,"s"+"__FolderUnit_StructStaminaRegeneration_Allocation__allocInit_autoRun")
call Vrx(function EXo,"s"+"__FolderUnit_FolderBars_StructExpiringCondition_Allocation__allocInit_autoRun")
call Vrx(function EOo,"s"+"__FolderUnit_StructBars_objInits_autoRun")
call Vrx(function ERo,"s"+"__FolderUnit_StructBars_Allocation__allocInit_autoRun")
call Vrx(function EAo,"s"+"__FolderUnit_StructTimedLife_objInits_autoRun")
call Vrx(function ENo,"s"+"__FolderUnit_StructTimedLife_Allocation__allocInit_autoRun")
call Vrx(function Edo,"s"+"__FolderUnit_StructTimedLife_initializer_Buff_Init_autoRun")
call Vrx(function Ego,"s"+"__FolderUnit_StructTransport_objInits_autoRun")
call Vrx(function EGo,"s"+"__FolderUnit_StructTransport_Allocation__allocInit_autoRun")
call Vrx(function Eqo,"s"+"__FolderUnit_StructTransport_initializer_Buff_Init_autoRun")
call Vrx(function EQo,"s"+"__FolderUnit_StructHero_Allocation__allocInit_autoRun")
call Vrx(function Eso,"s"+"__FolderUnit_FolderPosition_FolderTimed_StructAccelerated_Allocation__allocInit_autoRun")
call Vrx(function ESo,"s"+"__FolderUnit_FolderPosition_StructTimed_Allocation__allocInit_autoRun")
call Vrx(function Eto,"s"+"__FolderUnit_FolderPosition_StructX_Allocation__allocInit_autoRun")
call Vrx(function ETo,"s"+"__FolderUnit_FolderPosition_StructY_Allocation__allocInit_autoRun")
call Vrx(function Euo,"s"+"__FolderUnit_FolderPosition_StructZ_Allocation__allocInit_autoRun")
call Vrx(function Ewo,"s"+"__FolderUnit_StructPosition_objInits_autoRun")
call Vrx(function EWo,"s"+"__FolderUnit_StructPosition_Allocation__allocInit_autoRun")
call Vrx(function EYo,"s"+"__FolderUnit_FolderSelection_StructCircle_objInits_autoRun")
call Vrx(function Ezo,"s"+"__FolderUnit_FolderSelection_StructCircle_Allocation__allocInit_autoRun")
call Vrx(function E_o,"s"+"__FolderUnit_StructSelection_objInits_autoRun")
call Vrx(function E0o,"s"+"__FolderUnit_StructSelection_Allocation__allocInit_autoRun")
call Vrx(function E1o,"s"+"__FolderUnit_FolderSightRange_StructBase_Allocation__allocInit_autoRun")
call Vrx(function E2o,"s"+"__FolderUnit_FolderSightRange_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function E3o,"s"+"__FolderUnit_FolderSightRange_StructRelative_Allocation__allocInit_autoRun")
call Vrx(function E6o,"s"+"__FolderUnit_StructSightRange_objInits_autoRun")
call Vrx(function E7o,"s"+"__FolderUnit_StructSightRange_Allocation__allocInit_autoRun")
call Vrx(function E8o,"s"+"__FolderUnit_FolderLevel_StructEvents_Allocation__allocInit_autoRun")
call Vrx(function E9o,"s"+"__FolderUnit_StructLevel_objInits_autoRun")
call Vrx(function Xvo,"s"+"__FolderUnit_StructLevel_Allocation__allocInit_autoRun")
call Vrx(function Xeo,"s"+"__FolderUnit_FolderAgility_StructBase_Allocation__allocInit_autoRun")
call Vrx(function Xxo,"s"+"__FolderUnit_FolderAgility_FolderBonus_StructDisplayed_Allocation__allocInit_autoRun")
call Vrx(function Xoo,"s"+"__FolderUnit_FolderAgility_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function Xro,"s"+"__FolderUnit_FolderAgility_StructRelative_Allocation__allocInit_autoRun")
call Vrx(function Xio,"s"+"__FolderUnit_StructAgility_objInits_autoRun")
call Vrx(function Xao,"s"+"__FolderUnit_StructAgility_Allocation__allocInit_autoRun")
call Vrx(function Xno,"s"+"__FolderUnit_FolderIntelligence_StructBase_Allocation__allocInit_autoRun")
call Vrx(function XVo,"s"+"__FolderUnit_FolderIntelligence_FolderBonus_StructDisplayed_Allocation__allocInit_autoRun")
call Vrx(function XEo,"s"+"__FolderUnit_FolderIntelligence_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function XXo,"s"+"__FolderUnit_FolderIntelligence_StructRelative_Allocation__allocInit_autoRun")
call Vrx(function XOo,"s"+"__FolderUnit_StructIntelligence_objInits_autoRun")
call Vrx(function XRo,"s"+"__FolderUnit_StructIntelligence_Allocation__allocInit_autoRun")
call Vrx(function XIo,"s"+"__FolderUnit_FolderStrength_StructBase_Allocation__allocInit_autoRun")
call Vrx(function XAo,"s"+"__FolderUnit_FolderStrength_FolderBonus_StructDisplayed_Allocation__allocInit_autoRun")
call Vrx(function XNo,"s"+"__FolderUnit_FolderStrength_StructBonus_Allocation__allocInit_autoRun")
call Vrx(function Xbo,"s"+"__FolderUnit_FolderStrength_StructRelative_Allocation__allocInit_autoRun")
call Vrx(function XBo,"s"+"__FolderUnit_StructStrength_objInits_autoRun")
call Vrx(function Xco,"s"+"__FolderUnit_StructStrength_Allocation__allocInit_autoRun")
call Vrx(function XCo,"s"+"__FolderUnit_StructRefs_Allocation__allocInit_autoRun")
call Vrx(function Xgo,"s"+"__Unit_objInits_autoRun")
call Vrx(function XGo,"s"+"__Unit_Allocation__allocInit_autoRun")
call Vrx(function XLo,"s"+"__Unit_initializer_InitPreplaced_autoRun")
call Vrx(function gWo,"s"+"__Unit_initializer_Init_autoRun")
call Vrx(function gyo,"s"+"__UnitState_Allocation__allocInit_autoRun")
call Vrx(function gYo,"s"+"__UnitMod_Allocation__allocInit_autoRun")
call Vrx(function gzo,"s"+"__FolderUnitModSet_StructId_Allocation__allocInit_autoRun")
call Vrx(function gZo,"s"+"__FolderUnitModSet_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function g_o,"s"+"__FolderUnitModSet_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function g0o,"s"+"__FolderUnitModSet_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function g1o,"s"+"__FolderUnitModSet_FolderData_FolderReal_StructTable_Allocation__allocInit_autoRun")
call Vrx(function g2o,"s"+"__FolderUnitModSet_FolderData_StructReal_Allocation__allocInit_autoRun")
call Vrx(function g3o,"s"+"__FolderUnitModSet_FolderData_FolderString_StructTable_Allocation__allocInit_autoRun")
call Vrx(function g4o,"s"+"__FolderUnitModSet_FolderData_StructString_Allocation__allocInit_autoRun")
call Vrx(function g5o,"s"+"__FolderUnitModSet_StructData_Allocation__allocInit_autoRun")
call Vrx(function g6o,"s"+"__FolderUnitModSet_StructBoolMods_Allocation__allocInit_autoRun")
call Vrx(function g7o,"s"+"__FolderUnitModSet_StructRealMods_Allocation__allocInit_autoRun")
call Vrx(function g8o,"s"+"__FolderUnitModSet_StructCustomMods_Allocation__allocInit_autoRun")
call Vrx(function g9o,"s"+"__FolderUnitModSet_StructMods_Allocation__allocInit_autoRun")
call Vrx(function Gvo,"s"+"__UnitModSet_Allocation__allocInit_autoRun")
call Vrx(function Geo,"s"+"__BuffRef_Allocation__allocInit_autoRun")
call Vrx(function Gxo,"s"+"__FolderUnitType_StructId_Allocation__allocInit_autoRun")
call Vrx(function Goo,"s"+"__FolderUnitType_FolderData_FolderBoolean_StructTable_Allocation__allocInit_autoRun")
call Vrx(function Gro,"s"+"__FolderUnitType_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function Gio,"s"+"__FolderUnitType_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function Gao,"s"+"__FolderUnitType_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function Gno,"s"+"__FolderUnitType_FolderData_FolderReal_StructTable_Allocation__allocInit_autoRun")
call Vrx(function GVo,"s"+"__FolderUnitType_FolderData_StructReal_Allocation__allocInit_autoRun")
call Vrx(function GEo,"s"+"__FolderUnitType_FolderData_FolderString_StructTable_Allocation__allocInit_autoRun")
call Vrx(function GXo,"s"+"__FolderUnitType_FolderData_StructString_Allocation__allocInit_autoRun")
call Vrx(function GOo,"s"+"__FolderUnitType_StructData_Allocation__allocInit_autoRun")
call Vrx(function GRo,"s"+"__FolderUnitType_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function GIo,"s"+"__FolderUnitType_FolderAbilities_StructArrayBuild_Allocation__allocInit_autoRun")
call Vrx(function GAo,"s"+"__FolderUnitType_FolderAbilities_StructHero_Allocation__allocInit_autoRun")
call Vrx(function GNo,"s"+"__FolderUnitType_StructAbilities_Allocation__allocInit_autoRun")
call Vrx(function Gbo,"s"+"__FolderUnitType_FolderArmor_StructType_Allocation__allocInit_autoRun")
call Vrx(function GBo,"s"+"__FolderUnitType_StructArmor_Allocation__allocInit_autoRun")
call Vrx(function Gco,"s"+"__FolderUnitType_StructAttachments_Allocation__allocInit_autoRun")
call Vrx(function GCo,"s"+"__FolderUnitType_FolderAttack_FolderMissile_StructSpeed_Allocation__allocInit_autoRun")
call Vrx(function Gdo,"s"+"__FolderUnitType_FolderAttack_StructMissile_Allocation__allocInit_autoRun")
call Vrx(function GDo,"s"+"__FolderUnitType_FolderAttack_StructRange_Allocation__allocInit_autoRun")
call Vrx(function Gfo,"s"+"__FolderUnitType_FolderAttack_StructSpeed_Allocation__allocInit_autoRun")
call Vrx(function GFo,"s"+"__FolderUnitType_FolderAttack_FolderSplash_StructTargetFlag_Allocation__allocInit_autoRun")
call Vrx(function Ggo,"s"+"__FolderUnitType_FolderAttack_StructSplash_Allocation__allocInit_autoRun")
call Vrx(function GGo,"s"+"__FolderUnitType_StructAttack_Allocation__allocInit_autoRun")
call Vrx(function Gho,"s"+"__FolderUnitType_StructBlood_Allocation__allocInit_autoRun")
call Vrx(function GHo,"s"+"__FolderUnitType_StructBloodExplosion_Allocation__allocInit_autoRun")
call Vrx(function Gjo,"s"+"__FolderUnitType_StructClasses_Allocation__allocInit_autoRun")
call Vrx(function GJo,"s"+"__FolderUnitType_StructCollisionSize_Allocation__allocInit_autoRun")
call Vrx(function Gko,"s"+"__FolderUnitType_FolderDamage_StructDelay_Allocation__allocInit_autoRun")
call Vrx(function GKo,"s"+"__FolderUnitType_FolderDamage_StructDices_Allocation__allocInit_autoRun")
call Vrx(function Glo,"s"+"__FolderUnitType_FolderDamage_StructSides_Allocation__allocInit_autoRun")
call Vrx(function GLo,"s"+"__FolderUnitType_FolderDamage_StructType_Allocation__allocInit_autoRun")
call Vrx(function Gmo,"s"+"__FolderUnitType_StructDamage_Allocation__allocInit_autoRun")
call Vrx(function GMo,"s"+"__FolderUnitType_FolderDecay_StructDuration_Allocation__allocInit_autoRun")
call Vrx(function Gpo,"s"+"__FolderUnitType_StructDecay_Allocation__allocInit_autoRun")
call Vrx(function GPo,"s"+"__FolderUnitType_FolderDrop_StructExp_Allocation__allocInit_autoRun")
call Vrx(function Gqo,"s"+"__FolderUnitType_FolderDrop_StructSupply_Allocation__allocInit_autoRun")
call Vrx(function GQo,"s"+"__FolderUnitType_StructDrop_Allocation__allocInit_autoRun")
call Vrx(function Gso,"s"+"__FolderUnitType_FolderImpact_StructZ_Allocation__allocInit_autoRun")
call Vrx(function GSo,"s"+"__FolderUnitType_StructImpact_Allocation__allocInit_autoRun")
call Vrx(function Gto,"s"+"__FolderUnitType_FolderOutpact_StructZ_Allocation__allocInit_autoRun")
call Vrx(function GTo,"s"+"__FolderUnitType_StructOutpact_Allocation__allocInit_autoRun")
call Vrx(function Guo,"s"+"__FolderUnitType_StructLife_Allocation__allocInit_autoRun")
call Vrx(function GUo,"s"+"__FolderUnitType_StructLifeRegeneration_Allocation__allocInit_autoRun")
call Vrx(function Gwo,"s"+"__FolderUnitType_StructMana_Allocation__allocInit_autoRun")
call Vrx(function GWo,"s"+"__FolderUnitType_StructManaRegeneration_Allocation__allocInit_autoRun")
call Vrx(function Gyo,"s"+"__FolderUnitType_StructPreload_Allocation__allocInit_autoRun")
call Vrx(function GYo,"s"+"__FolderUnitType_StructRevivalable_Allocation__allocInit_autoRun")
call Vrx(function Gzo,"s"+"__FolderUnitType_StructScale_Allocation__allocInit_autoRun")
call Vrx(function GZo,"s"+"__FolderUnitType_StructSightRange_Allocation__allocInit_autoRun")
call Vrx(function G_o,"s"+"__FolderUnitType_StructSpeed_Allocation__allocInit_autoRun")
call Vrx(function G0o,"s"+"__FolderUnitType_StructSpellPower_Allocation__allocInit_autoRun")
call Vrx(function G1o,"s"+"__FolderUnitType_StructSpellVamp_Allocation__allocInit_autoRun")
call Vrx(function G2o,"s"+"__FolderUnitType_FolderVertexColor_StructRed_Allocation__allocInit_autoRun")
call Vrx(function G3o,"s"+"__FolderUnitType_FolderVertexColor_StructGreen_Allocation__allocInit_autoRun")
call Vrx(function G4o,"s"+"__FolderUnitType_FolderVertexColor_StructBlue_Allocation__allocInit_autoRun")
call Vrx(function G5o,"s"+"__FolderUnitType_FolderVertexColor_StructAlpha_Allocation__allocInit_autoRun")
call Vrx(function G6o,"s"+"__FolderUnitType_StructVertexColor_Allocation__allocInit_autoRun")
call Vrx(function G7o,"s"+"__FolderUnitType_FolderHero_StructPrimaryAttribute_Allocation__allocInit_autoRun")
call Vrx(function G8o,"s"+"__FolderUnitType_FolderHero_FolderAgility_StructPerLevel_Allocation__allocInit_autoRun")
call Vrx(function G9o,"s"+"__FolderUnitType_FolderHero_StructAgility_Allocation__allocInit_autoRun")
call Vrx(function hvo,"s"+"__FolderUnitType_FolderHero_StructArmorPerLevel_Allocation__allocInit_autoRun")
call Vrx(function heo,"s"+"__FolderUnitType_FolderHero_FolderIntelligence_StructPerLevel_Allocation__allocInit_autoRun")
call Vrx(function hxo,"s"+"__FolderUnitType_FolderHero_StructIntelligence_Allocation__allocInit_autoRun")
call Vrx(function hoo,"s"+"__FolderUnitType_FolderHero_FolderStrength_StructPerLevel_Allocation__allocInit_autoRun")
call Vrx(function hro,"s"+"__FolderUnitType_FolderHero_StructStrength_Allocation__allocInit_autoRun")
call Vrx(function hio,"s"+"__FolderUnitType_StructHero_Allocation__allocInit_autoRun")
call Vrx(function HPo,"s"+"__UnitType_objInits_autoRun")
call Vrx(function Hqo,"s"+"__UnitType_Allocation__allocInit_autoRun")
call Vrx(function HQo,"s"+"__Force_Allocation__allocInit_autoRun")
call Vrx(function Hso,"s"+"__PlayerController_Allocation__allocInit_autoRun")
call Vrx(function HSo,"s"+"__PlayerSlotState_Allocation__allocInit_autoRun")
call Vrx(function Hto,"s"+"__Team_Allocation__allocInit_autoRun")
call Vrx(function HTo,"s"+"__FolderUser_StructId_Allocation__allocInit_autoRun")
call Vrx(function Huo,"s"+"__FolderUser_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function HUo,"s"+"__FolderUser_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function Hwo,"s"+"__FolderUser_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function HWo,"s"+"__FolderUser_StructData_Allocation__allocInit_autoRun")
call Vrx(function Hyo,"s"+"__FolderUser_FolderEvent_StructNative_Allocation__allocInit_autoRun")
call Vrx(function HYo,"s"+"__FolderUser_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function Hzo,"s"+"__FolderUser_StructController_Allocation__allocInit_autoRun")
call Vrx(function HZo,"s"+"__FolderUser_StructHostAppointment_Allocation__allocInit_autoRun")
call Vrx(function H_o,"s"+"__FolderUser_StructHero_Allocation__allocInit_autoRun")
call Vrx(function H0o,"s"+"__FolderUser_FolderKeyEvent_StructDownArrow_Allocation__allocInit_autoRun")
call Vrx(function H1o,"s"+"__FolderUser_FolderKeyEvent_StructLeftArrow_Allocation__allocInit_autoRun")
call Vrx(function H2o,"s"+"__FolderUser_FolderKeyEvent_StructRightArrow_Allocation__allocInit_autoRun")
call Vrx(function H3o,"s"+"__FolderUser_FolderKeyEvent_StructUpArrow_Allocation__allocInit_autoRun")
call Vrx(function H4o,"s"+"__FolderUser_StructKeyEvent_Allocation__allocInit_autoRun")
call Vrx(function H5o,"s"+"__FolderUser_StructSlotState_Allocation__allocInit_autoRun")
call Vrx(function H6o,"s"+"__FolderUser_StructState_Allocation__allocInit_autoRun")
call Vrx(function H7o,"s"+"__FolderUser_StructTeam_Allocation__allocInit_autoRun")
call Vrx(function H8o,"s"+"__User_objInits_autoRun")
call Vrx(function H9o,"s"+"__User_Allocation__allocInit_autoRun")
call Vrx(function Juo,"s"+"__User_initializer_Init_autoRun")
call Vrx(function JUo,"s"+"__WeatherType_Allocation__allocInit_autoRun")
call Vrx(function Jzo,"s"+"__WeatherEffect_objInits_autoRun")
call Vrx(function JZo,"s"+"__WeatherEffect_Allocation__allocInit_autoRun")
call Vrx(function J6o,"s"+"__WeatherEffect_initializer_Init_autoRun")
call Vrx(function J7o,"s"+"__Initialization_Allocation__allocInit_autoRun")
call Vrx(function J8o,"s"+"__FolderAct_StructId_Allocation__allocInit_autoRun")
call Vrx(function J9o,"s"+"__FolderAct_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function kvo,"s"+"__FolderAct_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function keo,"s"+"__FolderAct_StructData_Allocation__allocInit_autoRun")
call Vrx(function kxo,"s"+"__FolderAct_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function koo,"s"+"__FolderAct_StructLevelSets_Allocation__allocInit_autoRun")
call Vrx(function kro,"s"+"__Act_Allocation__allocInit_autoRun")
call Vrx(function kpo,"s"+"__Act_initializer_Init_autoRun")
call Vrx(function kPo,"s"+"__ActUpgrades_Allocation__allocInit_autoRun")
call Vrx(function kUo,"s"+"__ActUpgrades_initializer_Init_autoRun")
call Vrx(function kwo,"s"+"__AfterIntro_Allocation__allocInit_autoRun")
call Vrx(function kYo,"s"+"__AfterIntro_initializer_Init_autoRun")
call Vrx(function kzo,"s"+"__BrazierOracle_Allocation__allocInit_autoRun")
call Vrx(function KVo,"s"+"__BrazierOracle_initializer_Init_autoRun")
call Vrx(function KEo,"s"+"__CameraQuickPosition_Allocation__allocInit_autoRun")
call Vrx(function KAo,"s"+"__CameraQuickPosition_initializer_Init_autoRun")
call Vrx(function Kbo,"s"+"__MarkOfThePaw_objInits_autoRun")
call Vrx(function KBo,"s"+"__MarkOfThePaw_Allocation__allocInit_autoRun")
call Vrx(function Kdo,"s"+"__MarkOfThePaw_initializer_Init_autoRun")
call Vrx(function KDo,"s"+"__CreepLoot_Allocation__allocInit_autoRun")
call Vrx(function Kfo,"s"+"__Creep_Allocation__allocInit_autoRun")
call Vrx(function KFo,"s"+"__CreepLocation_Allocation__allocInit_autoRun")
call Vrx(function Kgo,"s"+"__FolderCreepSet_StructId_Allocation__allocInit_autoRun")
call Vrx(function KGo,"s"+"__FolderCreepSet_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function Kho,"s"+"__FolderCreepSet_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function KHo,"s"+"__FolderCreepSet_StructData_Allocation__allocInit_autoRun")
call Vrx(function Kjo,"s"+"__FolderCreepSet_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function KJo,"s"+"__CreepSet_Allocation__allocInit_autoRun")
call Vrx(function lDo,"s"+"__CreepSet_initializer_Init_autoRun")
call Vrx(function lfo,"s"+"__DefenderSpawnLocation_Allocation__allocInit_autoRun")
call Vrx(function lFo,"s"+"__FolderDefenderSpawnType_StructId_Allocation__allocInit_autoRun")
call Vrx(function lgo,"s"+"__FolderDefenderSpawnType_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function lGo,"s"+"__FolderDefenderSpawnType_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function lho,"s"+"__FolderDefenderSpawnType_StructData_Allocation__allocInit_autoRun")
call Vrx(function lHo,"s"+"__FolderDefenderSpawnType_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function ljo,"s"+"__DefenderSpawnType_Allocation__allocInit_autoRun")
call Vrx(function lJo,"s"+"__FolderDefenderSpawnGroup_StructId_Allocation__allocInit_autoRun")
call Vrx(function lko,"s"+"__FolderDefenderSpawnGroup_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function lKo,"s"+"__FolderDefenderSpawnGroup_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function llo,"s"+"__FolderDefenderSpawnGroup_StructData_Allocation__allocInit_autoRun")
call Vrx(function lLo,"s"+"__DefenderSpawnGroup_Allocation__allocInit_autoRun")
call Vrx(function lmo,"s"+"__FolderDefenderSpawnWave_StructId_Allocation__allocInit_autoRun")
call Vrx(function lMo,"s"+"__FolderDefenderSpawnWave_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function lpo,"s"+"__FolderDefenderSpawnWave_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function lPo,"s"+"__FolderDefenderSpawnWave_StructData_Allocation__allocInit_autoRun")
call Vrx(function lqo,"s"+"__FolderDefenderSpawnWave_StructGroups_Allocation__allocInit_autoRun")
call Vrx(function lQo,"s"+"__DefenderSpawnWave_Allocation__allocInit_autoRun")
call Vrx(function lso,"s"+"__DefenderSpawn_Allocation__allocInit_autoRun")
call Vrx(function Lfo,"s"+"__DefenderSpawn_initializer_Init_autoRun")
call Vrx(function LFo,"s"+"__Difficulty_Allocation__allocInit_autoRun")
call Vrx(function Lgo,"s"+"__Drop_objInits_autoRun")
call Vrx(function LGo,"s"+"__Drop_Allocation__allocInit_autoRun")
call Vrx(function Luo,"s"+"__Drop_initializer_Init_autoRun")
call Vrx(function L8o,"s"+"__EternalVial_objInits_autoRun")
call Vrx(function L9o,"s"+"__EternalVial_Allocation__allocInit_autoRun")
call Vrx(function mVo,"s"+"__EternalVial_initializer_Init_autoRun")
call Vrx(function mEo,"s"+"__Explosive_objInits_autoRun")
call Vrx(function mXo,"s"+"__Explosive_Allocation__allocInit_autoRun")
call Vrx(function mto,"s"+"__Explosive_initializer_Init_autoRun")
call Vrx(function muo,"s"+"__GarbageCollector_objInits_autoRun")
call Vrx(function mUo,"s"+"__GarbageCollector_Allocation__allocInit_autoRun")
call Vrx(function myo,"s"+"__BoomerangStone_objInits_autoRun")
call Vrx(function mYo,"s"+"__BoomerangStone_Allocation__allocInit_autoRun")
call Vrx(function pxo,"s"+"__BoomerangStone_initializer_Init_autoRun")
call Vrx(function pro,"s"+"__Mallet_objInits_autoRun")
call Vrx(function pio,"s"+"__Mallet_Allocation__allocInit_autoRun")
call Vrx(function pAo,"s"+"__Mallet_initializer_Init_autoRun")
call Vrx(function pBo,"s"+"__PenguinFeather_objInits_autoRun")
call Vrx(function pco,"s"+"__PenguinFeather_Allocation__allocInit_autoRun")
call Vrx(function pmo,"s"+"__PenguinFeather_initializer_Init_autoRun")
call Vrx(function ppo,"s"+"__RabbitsFoot_objInits_autoRun")
call Vrx(function pPo,"s"+"__RabbitsFoot_Allocation__allocInit_autoRun")
call Vrx(function pto,"s"+"__RabbitsFoot_initializer_Init_autoRun")
call Vrx(function puo,"s"+"__RamblersStick_objInits_autoRun")
call Vrx(function pUo,"s"+"__RamblersStick_Allocation__allocInit_autoRun")
call Vrx(function pzo,"s"+"__RamblersStick_initializer_Init_autoRun")
call Vrx(function p_o,"s"+"__GruntAxe_objInits_autoRun")
call Vrx(function p0o,"s"+"__GruntAxe_Allocation__allocInit_autoRun")
call Vrx(function p5o,"s"+"__GruntAxe_initializer_Init_autoRun")
call Vrx(function p7o,"s"+"__RobynsHood_objInits_autoRun")
call Vrx(function p8o,"s"+"__RobynsHood_Allocation__allocInit_autoRun")
call Vrx(function Pio,"s"+"__RobynsHood_initializer_Init_autoRun")
call Vrx(function Pno,"s"+"__ElfinDagger_objInits_autoRun")
call Vrx(function PVo,"s"+"__ElfinDagger_Allocation__allocInit_autoRun")
call Vrx(function PNo,"s"+"__ElfinDagger_initializer_Init_autoRun")
call Vrx(function PBo,"s"+"__FolderSpearOfTheDefender_StructBuff_objInits_autoRun")
call Vrx(function Pco,"s"+"__FolderSpearOfTheDefender_StructBuff_Allocation__allocInit_autoRun")
call Vrx(function Pdo,"s"+"__SpearOfTheDefender_objInits_autoRun")
call Vrx(function PDo,"s"+"__SpearOfTheDefender_Allocation__allocInit_autoRun")
call Vrx(function PLo,"s"+"__SpearOfTheDefender_initializer_Init_autoRun")
call Vrx(function PMo,"s"+"__MeteoriteShard_objInits_autoRun")
call Vrx(function Ppo,"s"+"__MeteoriteShard_Allocation__allocInit_autoRun")
call Vrx(function PTo,"s"+"__MeteoriteShard_initializer_Init_autoRun")
call Vrx(function Pwo,"s"+"__GoldCoin_objInits_autoRun")
call Vrx(function PWo,"s"+"__GoldCoin_Allocation__allocInit_autoRun")
call Vrx(function P9o,"s"+"__GoldCoin_initializer_Init_autoRun")
call Vrx(function qxo,"s"+"__HeroRevival_objInits_autoRun")
call Vrx(function qoo,"s"+"__HeroRevival_Allocation__allocInit_autoRun")
call Vrx(function qPo,"s"+"__HeroRevival_initializer_Init_autoRun")
call Vrx(function qqo,"s"+"__HeroSelection_objInits_autoRun")
call Vrx(function qQo,"s"+"__HeroSelection_Allocation__allocInit_autoRun")
call Vrx(function QAo,"s"+"__HeroSelection_initializer_Init_autoRun")
call Vrx(function QNo,"s"+"__Hint_Allocation__allocInit_autoRun")
call Vrx(function QFo,"s"+"__Hint_initializer_Init_autoRun")
call Vrx(function QGo,"s"+"__FolderHorseRide_StructTarget_objInits_autoRun")
call Vrx(function Qho,"s"+"__FolderHorseRide_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function QJo,"s"+"__HorseRide_objInits_autoRun")
call Vrx(function Qko,"s"+"__HorseRide_Allocation__allocInit_autoRun")
call Vrx(function sBo,"s"+"__HorseRide_initializer_Init_autoRun")
call Vrx(function sco,"s"+"__FolderInfoboard_StructUser_Allocation__allocInit_autoRun")
call Vrx(function sCo,"s"+"__Infoboard_Allocation__allocInit_autoRun")
call Vrx(function SVo,"s"+"__Infoboard_initializer_Init_autoRun")
call Vrx(function SEo,"s"+"__Infocard_Allocation__allocInit_autoRun")
call Vrx(function Sco,"s"+"__Infocard_initializer_Init_autoRun")
call Vrx(function SCo,"s"+"__Intro_Allocation__allocInit_autoRun")
call Vrx(function Two,"s"+"__Intro_initializer_Init_autoRun")
call Vrx(function TWo,"s"+"__FolderLevelSet_StructId_Allocation__allocInit_autoRun")
call Vrx(function Tyo,"s"+"__FolderLevelSet_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function TYo,"s"+"__FolderLevelSet_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function Tzo,"s"+"__FolderLevelSet_StructData_Allocation__allocInit_autoRun")
call Vrx(function TZo,"s"+"__FolderLevelSet_StructLevels_Allocation__allocInit_autoRun")
call Vrx(function T_o,"s"+"__FolderLevelSet_StructQuery_Allocation__allocInit_autoRun")
call Vrx(function T0o,"s"+"__LevelSet_Allocation__allocInit_autoRun")
call Vrx(function T1o,"s"+"__FolderLevel_StructId_Allocation__allocInit_autoRun")
call Vrx(function T2o,"s"+"__FolderLevel_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function T3o,"s"+"__FolderLevel_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function T4o,"s"+"__FolderLevel_FolderData_StructReal_Allocation__allocInit_autoRun")
call Vrx(function T5o,"s"+"__FolderLevel_StructData_Allocation__allocInit_autoRun")
call Vrx(function T6o,"s"+"__FolderLevel_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function T7o,"s"+"__Level_Allocation__allocInit_autoRun")
call Vrx(function uto,"s"+"__Level_initializer_Init_autoRun")
call Vrx(function uuo,"s"+"__Library_objInits_autoRun")
call Vrx(function uUo,"s"+"__Library_Allocation__allocInit_autoRun")
call Vrx(function uyo,"s"+"__Library_initializer_Init_autoRun")
call Vrx(function uZo,"s"+"__Lumber_objInits_autoRun")
call Vrx(function u_o,"s"+"__Lumber_Allocation__allocInit_autoRun")
call Vrx(function Uvo,"s"+"__Lumber_initializer_Init_autoRun")
call Vrx(function Ueo,"s"+"__FolderNullboard_StructQuestLog_Allocation__allocInit_autoRun")
call Vrx(function Uxo,"s"+"__Nullboard_Allocation__allocInit_autoRun")
call Vrx(function UEo,"s"+"__Nullboard_initializer_Init_autoRun")
call Vrx(function UXo,"s"+"__FolderOptionsBoard_StructCameraSmoothing_Allocation__allocInit_autoRun")
call Vrx(function UOo,"s"+"__FolderOptionsBoard_StructCameraZoom_Allocation__allocInit_autoRun")
call Vrx(function URo,"s"+"__FolderOptionsBoard_StructEffectLevel_Allocation__allocInit_autoRun")
call Vrx(function UIo,"s"+"__FolderOptionsBoard_StructHint_Allocation__allocInit_autoRun")
call Vrx(function UAo,"s"+"__FolderOptionsBoard_StructMusicVolume_Allocation__allocInit_autoRun")
call Vrx(function UNo,"s"+"__FolderOptionsBoard_StructSoundVolume_Allocation__allocInit_autoRun")
call Vrx(function Ubo,"s"+"__OptionsBoard_Allocation__allocInit_autoRun")
call Vrx(function Ulo,"s"+"__OptionsBoard_initializer_Init_autoRun")
call Vrx(function Umo,"s"+"__Pharmacy_objInits_autoRun")
call Vrx(function UMo,"s"+"__Pharmacy_Allocation__allocInit_autoRun")
call Vrx(function Uqo,"s"+"__EmergencyProvisions_objInits_autoRun")
call Vrx(function UQo,"s"+"__EmergencyProvisions_Allocation__allocInit_autoRun")
call Vrx(function Uto,"s"+"__EmergencyProvisions_initializer_Init_autoRun")
call Vrx(function Uwo,"s"+"__EyeOfTheFlame_objInits_autoRun")
call Vrx(function UWo,"s"+"__EyeOfTheFlame_Allocation__allocInit_autoRun")
call Vrx(function U0o,"s"+"__EyeOfTheFlame_initializer_Init_autoRun")
call Vrx(function U4o,"s"+"__TorchLight_objInits_autoRun")
call Vrx(function U5o,"s"+"__TorchLight_Allocation__allocInit_autoRun")
call Vrx(function wEo,"s"+"__TorchLight_initializer_Init_autoRun")
call Vrx(function wIo,"s"+"__HerbalOintment_objInits_autoRun")
call Vrx(function wAo,"s"+"__HerbalOintment_Allocation__allocInit_autoRun")
call Vrx(function wGo,"s"+"__HerbalOintment_initializer_Init_autoRun")
call Vrx(function wHo,"s"+"__FolderScrollOfProtection_StructTarget_objInits_autoRun")
call Vrx(function wjo,"s"+"__FolderScrollOfProtection_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function wKo,"s"+"__ScrollOfProtection_objInits_autoRun")
call Vrx(function wlo,"s"+"__ScrollOfProtection_Allocation__allocInit_autoRun")
call Vrx(function wso,"s"+"__ScrollOfProtection_initializer_Init_autoRun")
call Vrx(function wto,"s"+"__FolderFireWater_StructBuff_objInits_autoRun")
call Vrx(function wTo,"s"+"__FolderFireWater_StructBuff_Allocation__allocInit_autoRun")
call Vrx(function wwo,"s"+"__FireWater_objInits_autoRun")
call Vrx(function wWo,"s"+"__FireWater_Allocation__allocInit_autoRun")
call Vrx(function w4o,"s"+"__FireWater_initializer_Init_autoRun")
call Vrx(function w9o,"s"+"__IceTea_objInits_autoRun")
call Vrx(function Wvo,"s"+"__IceTea_Allocation__allocInit_autoRun")
call Vrx(function Woo,"s"+"__IceTea_initializer_Init_autoRun")
call Vrx(function Wao,"s"+"__Meat_objInits_autoRun")
call Vrx(function Wno,"s"+"__Meat_Allocation__allocInit_autoRun")
call Vrx(function WCo,"s"+"__Meat_initializer_Init_autoRun")
call Vrx(function WFo,"s"+"__TeleportScroll_objInits_autoRun")
call Vrx(function Wgo,"s"+"__TeleportScroll_Allocation__allocInit_autoRun")
call Vrx(function Wso,"s"+"__TeleportScroll_initializer_Init_autoRun")
call Vrx(function Wto,"s"+"__Rune_objInits_autoRun")
call Vrx(function WTo,"s"+"__Rune_Allocation__allocInit_autoRun")
call Vrx(function W8o,"s"+"__Rune_initializer_Init_autoRun")
call Vrx(function yxo,"s"+"__Snowmen_objInits_autoRun")
call Vrx(function yoo,"s"+"__Snowmen_Allocation__allocInit_autoRun")
call Vrx(function yXo,"s"+"__Snowmen_initializer_Init_autoRun")
call Vrx(function yOo,"s"+"__SpawnLocation_Allocation__allocInit_autoRun")
call Vrx(function yRo,"s"+"__FolderSpawnGroup_StructId_Allocation__allocInit_autoRun")
call Vrx(function yIo,"s"+"__FolderSpawnGroup_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function yAo,"s"+"__FolderSpawnGroup_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function yNo,"s"+"__FolderSpawnGroup_StructData_Allocation__allocInit_autoRun")
call Vrx(function ybo,"s"+"__SpawnGroup_Allocation__allocInit_autoRun")
call Vrx(function yBo,"s"+"__FolderSpawnWave_StructId_Allocation__allocInit_autoRun")
call Vrx(function yco,"s"+"__FolderSpawnWave_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function yCo,"s"+"__FolderSpawnWave_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function ydo,"s"+"__FolderSpawnWave_FolderData_FolderReal_StructTable_Allocation__allocInit_autoRun")
call Vrx(function yDo,"s"+"__FolderSpawnWave_FolderData_StructReal_Allocation__allocInit_autoRun")
call Vrx(function yfo,"s"+"__FolderSpawnWave_StructData_Allocation__allocInit_autoRun")
call Vrx(function yFo,"s"+"__FolderSpawnWave_StructGroups_Allocation__allocInit_autoRun")
call Vrx(function ygo,"s"+"__SpawnWave_Allocation__allocInit_autoRun")
call Vrx(function yGo,"s"+"__FolderSpawn_StructQueue_Allocation__allocInit_autoRun")
call Vrx(function yHo,"s"+"__FolderSpawn_StructShadow_objInits_autoRun")
call Vrx(function yjo,"s"+"__FolderSpawn_StructShadow_Allocation__allocInit_autoRun")
call Vrx(function yJo,"s"+"__Spawn_Allocation__allocInit_autoRun")
call Vrx(function zpo,"s"+"__Spawn_initializer_Init_autoRun")
call Vrx(function zPo,"s"+"__FolderSpawnType_StructId_Allocation__allocInit_autoRun")
call Vrx(function zqo,"s"+"__FolderSpawnType_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function zQo,"s"+"__FolderSpawnType_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function zso,"s"+"__FolderSpawnType_StructData_Allocation__allocInit_autoRun")
call Vrx(function zSo,"s"+"__FolderSpawnType_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function zto,"s"+"__FolderSpawnType_StructChampion_Allocation__allocInit_autoRun")
call Vrx(function zTo,"s"+"__FolderSpawnType_StructItems_Allocation__allocInit_autoRun")
call Vrx(function zuo,"s"+"__SpawnType_Allocation__allocInit_autoRun")
call Vrx(function zUo,"s"+"__StructInfo_Allocation__allocInit_autoRun")
call Vrx(function z0o,"s"+"__StructInfo_initializer_Init_autoRun")
call Vrx(function z2o,"s"+"__Tavern_objInits_autoRun")
call Vrx(function z3o,"s"+"__Tavern_Allocation__allocInit_autoRun")
call Vrx(function z7o,"s"+"__TropicalRainbow_objInits_autoRun")
call Vrx(function z8o,"s"+"__TropicalRainbow_Allocation__allocInit_autoRun")
call Vrx(function Zeo,"s"+"__TropicalRainbow_initializer_Init_autoRun")
call Vrx(function Zoo,"s"+"__FolderTomes_StructAgi_objInits_autoRun")
call Vrx(function Zro,"s"+"__FolderTomes_StructAgi_Allocation__allocInit_autoRun")
call Vrx(function Zao,"s"+"__FolderTomes_StructInt_objInits_autoRun")
call Vrx(function Zno,"s"+"__FolderTomes_StructInt_Allocation__allocInit_autoRun")
call Vrx(function ZEo,"s"+"__FolderTomes_StructStr_objInits_autoRun")
call Vrx(function ZXo,"s"+"__FolderTomes_StructStr_Allocation__allocInit_autoRun")
call Vrx(function ZOo,"s"+"__Tomes_Allocation__allocInit_autoRun")
call Vrx(function Zdo,"s"+"__Tomes_initializer_Init_autoRun")
call Vrx(function ZDo,"s"+"__UnitNameTag_Allocation__allocInit_autoRun")
call Vrx(function Zho,"s"+"__UnitNameTag_initializer_Init_autoRun")
call Vrx(function ZHo,"s"+"__UnitStatus_Allocation__allocInit_autoRun")
call Vrx(function ver,"s"+"__UnitStatus_initializer_Init_autoRun")
call Vrx(function vor,"s"+"__VictoryRush_objInits_autoRun")
call Vrx(function vrr,"s"+"__VictoryRush_Allocation__allocInit_autoRun")
call Vrx(function vVr,"s"+"__VictoryRush_initializer_Init_autoRun")
call Vrx(function vIr,"s"+"__FolderWaypoint_FolderRegionCheck_StructRetreat_objInits_autoRun")
call Vrx(function vAr,"s"+"__FolderWaypoint_FolderRegionCheck_StructRetreat_Allocation__allocInit_autoRun")
call Vrx(function vNr,"s"+"__FolderWaypoint_StructRegionCheck_Allocation__allocInit_autoRun")
call Vrx(function vBr,"s"+"__FolderWaypoint_StructSpawns_objInits_autoRun")
call Vrx(function vcr,"s"+"__FolderWaypoint_StructSpawns_Allocation__allocInit_autoRun")
call Vrx(function vCr,"s"+"__Waypoint_Allocation__allocInit_autoRun")
call Vrx(function vYr,"s"+"__Waypoint_initializer_Init_autoRun")
call Vrx(function vzr,"s"+"__Zoom_Allocation__allocInit_autoRun")
call Vrx(function eVr,"s"+"__Zoom_initializer_Init_autoRun")
call Vrx(function eEr,"s"+"__AxeFighter_Allocation__allocInit_autoRun")
call Vrx(function eBr,"s"+"__AxeFighter_initializer_Init_autoRun")
call Vrx(function ecr,"s"+"__Balduir_Allocation__allocInit_autoRun")
call Vrx(function eDr,"s"+"__Balduir_initializer_Init_autoRun")
call Vrx(function efr,"s"+"__FolderAura_StructId_Allocation__allocInit_autoRun")
call Vrx(function eFr,"s"+"__FolderAura_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vrx(function egr,"s"+"__FolderAura_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function eGr,"s"+"__FolderAura_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function ehr,"s"+"__FolderAura_StructData_Allocation__allocInit_autoRun")
call Vrx(function eHr,"s"+"__FolderAura_StructEvent_Allocation__allocInit_autoRun")
call Vrx(function ejr,"s"+"__FolderAura_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function eJr,"s"+"__Aura_Allocation__allocInit_autoRun")
call Vrx(function e_r,"s"+"__Aura_initializer_Init_autoRun")
call Vrx(function e0r,"s"+"__AIBoost_Allocation__allocInit_autoRun")
call Vrx(function x6r,"s"+"__AIBoost_initializer_Init_autoRun")
call Vrx(function x9r,"s"+"__Boost_objInits_autoRun")
call Vrx(function ovr,"s"+"__Boost_Allocation__allocInit_autoRun")
call Vrx(function orr,"s"+"__Boost_initializer_Init_autoRun")
call Vrx(function oir,"s"+"__AIBurningSpirit_Allocation__allocInit_autoRun")
call Vrx(function ofr,"s"+"__AIBurningSpirit_initializer_Init_autoRun")
call Vrx(function oGr,"s"+"__BurningSpirit_objInits_autoRun")
call Vrx(function ohr,"s"+"__BurningSpirit_Allocation__allocInit_autoRun")
call Vrx(function oHr,"s"+"__AIChaosBall_Allocation__allocInit_autoRun")
call Vrx(function oKr,"s"+"__AIChaosBall_initializer_Init_autoRun")
call Vrx(function omr,"s"+"__ChaosBall_objInits_autoRun")
call Vrx(function oMr,"s"+"__ChaosBall_Allocation__allocInit_autoRun")
call Vrx(function rvr,"s"+"__ChaosBall_initializer_Init_autoRun")
call Vrx(function rxr,"s"+"__FolderEnergyCharge_StructTarget_objInits_autoRun")
call Vrx(function ror,"s"+"__FolderEnergyCharge_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function rar,"s"+"__EnergyCharge_objInits_autoRun")
call Vrx(function rnr,"s"+"__EnergyCharge_Allocation__allocInit_autoRun")
call Vrx(function rDr,"s"+"__EnergyCharge_initializer_Init_autoRun")
call Vrx(function rfr,"s"+"__AIFlamelet_Allocation__allocInit_autoRun")
call Vrx(function rhr,"s"+"__AIFlamelet_initializer_Init_autoRun")
call Vrx(function rJr,"s"+"__Flamelet_objInits_autoRun")
call Vrx(function rkr,"s"+"__Flamelet_Allocation__allocInit_autoRun")
call Vrx(function rur,"s"+"__Flamelet_initializer_Init_autoRun")
call Vrx(function rwr,"s"+"__FuzzyAttack_objInits_autoRun")
call Vrx(function rWr,"s"+"__FuzzyAttack_Allocation__allocInit_autoRun")
call Vrx(function r8r,"s"+"__FuzzyAttack_initializer_Init_autoRun")
call Vrx(function ivr,"s"+"__FolderGreenNova_StructBuff_objInits_autoRun")
call Vrx(function ier,"s"+"__FolderGreenNova_StructBuff_Allocation__allocInit_autoRun")
call Vrx(function ior,"s"+"__GreenNova_objInits_autoRun")
call Vrx(function irr,"s"+"__GreenNova_Allocation__allocInit_autoRun")
call Vrx(function iNr,"s"+"__GreenNova_initializer_Init_autoRun")
call Vrx(function ibr,"s"+"__AIHeal_Allocation__allocInit_autoRun")
call Vrx(function idr,"s"+"__AIHeal_initializer_Init_autoRun")
call Vrx(function ifr,"s"+"__Heal_objInits_autoRun")
call Vrx(function iFr,"s"+"__Heal_Allocation__allocInit_autoRun")
call Vrx(function ihr,"s"+"__Heal_initializer_Init_autoRun")
call Vrx(function iHr,"s"+"__AIHealExplosion_Allocation__allocInit_autoRun")
call Vrx(function ikr,"s"+"__AIHealExplosion_initializer_Init_autoRun")
call Vrx(function ilr,"s"+"__HealExplosion_objInits_autoRun")
call Vrx(function iLr,"s"+"__HealExplosion_Allocation__allocInit_autoRun")
call Vrx(function isr,"s"+"__HealExplosion_initializer_Init_autoRun")
call Vrx(function iur,"s"+"__IceArrows_objInits_autoRun")
call Vrx(function iUr,"s"+"__IceArrows_Allocation__allocInit_autoRun")
call Vrx(function i2r,"s"+"__IceArrows_initializer_Init_autoRun")
call Vrx(function i5r,"s"+"__LightningShield_objInits_autoRun")
call Vrx(function i6r,"s"+"__LightningShield_Allocation__allocInit_autoRun")
call Vrx(function arr,"s"+"__LightningShield_initializer_Init_autoRun")
call Vrx(function aar,"s"+"__FolderLunarRestoration_StructRevival_objInits_autoRun")
call Vrx(function anr,"s"+"__FolderLunarRestoration_StructRevival_Allocation__allocInit_autoRun")
call Vrx(function aOr,"s"+"__LunarRestoration_objInits_autoRun")
call Vrx(function aRr,"s"+"__LunarRestoration_Allocation__allocInit_autoRun")
call Vrx(function aLr,"s"+"__LunarRestoration_initializer_Init_autoRun")
call Vrx(function amr,"s"+"__AIPurge_Allocation__allocInit_autoRun")
call Vrx(function asr,"s"+"__AIPurge_initializer_Init_autoRun")
call Vrx(function aTr,"s"+"__Purge_objInits_autoRun")
call Vrx(function aur,"s"+"__Purge_Allocation__allocInit_autoRun")
call Vrx(function nEr,"s"+"__Purge_initializer_Init_autoRun")
call Vrx(function nOr,"s"+"__FolderSoakingPoison_StructTarget_objInits_autoRun")
call Vrx(function nRr,"s"+"__FolderSoakingPoison_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function nNr,"s"+"__SoakingPoison_objInits_autoRun")
call Vrx(function nbr,"s"+"__SoakingPoison_Allocation__allocInit_autoRun")
call Vrx(function nJr,"s"+"__SoakingPoison_initializer_Init_autoRun")
call Vrx(function nlr,"s"+"__Stampede_objInits_autoRun")
call Vrx(function nLr,"s"+"__Stampede_Allocation__allocInit_autoRun")
call Vrx(function ntr,"s"+"__Stampede_initializer_Init_autoRun")
call Vrx(function nTr,"s"+"__AIStomp_Allocation__allocInit_autoRun")
call Vrx(function nwr,"s"+"__AIStomp_initializer_Init_autoRun")
call Vrx(function nyr,"s"+"__Stomp_objInits_autoRun")
call Vrx(function nYr,"s"+"__Stomp_Allocation__allocInit_autoRun")
call Vrx(function n3r,"s"+"__Stomp_initializer_Init_autoRun")
call Vrx(function n9r,"s"+"__Barrage_objInits_autoRun")
call Vrx(function Vvr,"s"+"__Barrage_Allocation__allocInit_autoRun")
call Vrx(function VEr,"s"+"__Barrage_initializer_Init_autoRun")
call Vrx(function VXr,"s"+"__AIBouncyBomb_Allocation__allocInit_autoRun")
call Vrx(function VAr,"s"+"__AIBouncyBomb_initializer_Init_autoRun")
call Vrx(function Vbr,"s"+"__BouncyBomb_objInits_autoRun")
call Vrx(function VBr,"s"+"__BouncyBomb_Allocation__allocInit_autoRun")
call Vrx(function Vqr,"s"+"__BouncyBomb_initializer_Init_autoRun")
call Vrx(function Vtr,"s"+"__BurningOil_objInits_autoRun")
call Vrx(function VTr,"s"+"__BurningOil_Allocation__allocInit_autoRun")
call Vrx(function V5r,"s"+"__BurningOil_initializer_Init_autoRun")
call Vrx(function V9r,"s"+"__ChainLightning_objInits_autoRun")
call Vrx(function Evr,"s"+"__ChainLightning_Allocation__allocInit_autoRun")
call Vrx(function Egr,"s"+"__ChainLightning_initializer_Init_autoRun")
call Vrx(function EGr,"s"+"__FolderCleaver_StructId_Allocation__allocInit_autoRun")
call Vrx(function Ehr,"s"+"__FolderCleaver_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function EHr,"s"+"__FolderCleaver_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function Ejr,"s"+"__FolderCleaver_StructData_Allocation__allocInit_autoRun")
call Vrx(function EJr,"s"+"__FolderCleaver_StructWave_objInits_autoRun")
call Vrx(function Ekr,"s"+"__FolderCleaver_StructWave_Allocation__allocInit_autoRun")
call Vrx(function Elr,"s"+"__Cleaver_objInits_autoRun")
call Vrx(function ELr,"s"+"__Cleaver_Allocation__allocInit_autoRun")
call Vrx(function E6r,"s"+"__Cleaver_initializer_Init_autoRun")
call Vrx(function E9r,"s"+"__ColdResistance_objInits_autoRun")
call Vrx(function Xvr,"s"+"__ColdResistance_Allocation__allocInit_autoRun")
call Vrx(function Xrr,"s"+"__ColdResistance_initializer_Init_autoRun")
call Vrx(function Xar,"s"+"__DeathAxe_objInits_autoRun")
call Vrx(function Xnr,"s"+"__DeathAxe_Allocation__allocInit_autoRun")
call Vrx(function Xgr,"s"+"__DeathAxe_initializer_Init_autoRun")
call Vrx(function Xhr,"s"+"__FolderDrumRoll_StructTarget_objInits_autoRun")
call Vrx(function XHr,"s"+"__FolderDrumRoll_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function Xkr,"s"+"__DrumRoll_objInits_autoRun")
call Vrx(function XKr,"s"+"__DrumRoll_Allocation__allocInit_autoRun")
call Vrx(function Ovr,"s"+"__DrumRoll_initializer_Init_autoRun")
call Vrx(function Oxr,"s"+"__FolderEnvenomedSpears_StructTarget_objInits_autoRun")
call Vrx(function Oor,"s"+"__FolderEnvenomedSpears_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function Oar,"s"+"__EnvenomedSpears_objInits_autoRun")
call Vrx(function Onr,"s"+"__EnvenomedSpears_Allocation__allocInit_autoRun")
call Vrx(function Odr,"s"+"__EnvenomedSpears_initializer_Init_autoRun")
call Vrx(function ODr,"s"+"__AIKnockout_Allocation__allocInit_autoRun")
call Vrx(function OGr,"s"+"__AIKnockout_initializer_Init_autoRun")
call Vrx(function OHr,"s"+"__FolderKnockout_StructTarget_objInits_autoRun")
call Vrx(function Ojr,"s"+"__FolderKnockout_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function Okr,"s"+"__Knockout_objInits_autoRun")
call Vrx(function OKr,"s"+"__Knockout_Allocation__allocInit_autoRun")
call Vrx(function OWr,"s"+"__Knockout_initializer_Init_autoRun")
call Vrx(function Oyr,"s"+"__AIMedipack_Allocation__allocInit_autoRun")
call Vrx(function O_r,"s"+"__AIMedipack_initializer_Init_autoRun")
call Vrx(function O1r,"s"+"__Medipack_objInits_autoRun")
call Vrx(function O2r,"s"+"__Medipack_Allocation__allocInit_autoRun")
call Vrx(function O5r,"s"+"__Medipack_initializer_Init_autoRun")
call Vrx(function O8r,"s"+"__MutingShout_objInits_autoRun")
call Vrx(function O9r,"s"+"__MutingShout_Allocation__allocInit_autoRun")
call Vrx(function Ror,"s"+"__MutingShout_initializer_Init_autoRun")
call Vrx(function Rir,"s"+"__Realplex_objInits_autoRun")
call Vrx(function Rar,"s"+"__Realplex_Allocation__allocInit_autoRun")
call Vrx(function Ryr,"s"+"__Realplex_initializer_Init_autoRun")
call Vrx(function RZr,"s"+"__SerpentWard_objInits_autoRun")
call Vrx(function R_r,"s"+"__SerpentWard_Allocation__allocInit_autoRun")
call Vrx(function R9r,"s"+"__SerpentWard_initializer_Init_autoRun")
call Vrx(function Ixr,"s"+"__SpiritWolves_objInits_autoRun")
call Vrx(function Ior,"s"+"__SpiritWolves_Allocation__allocInit_autoRun")
call Vrx(function Icr,"s"+"__SpiritWolves_initializer_Init_autoRun")
call Vrx(function Idr,"s"+"__Stormbolt_objInits_autoRun")
call Vrx(function IDr,"s"+"__Stormbolt_Allocation__allocInit_autoRun")
call Vrx(function IHr,"s"+"__Stormbolt_initializer_Init_autoRun")
call Vrx(function Ikr,"s"+"__SummonMinions_objInits_autoRun")
call Vrx(function IKr,"s"+"__SummonMinions_Allocation__allocInit_autoRun")
call Vrx(function Izr,"s"+"__SummonMinions_initializer_Init_autoRun")
call Vrx(function I_r,"s"+"__Artifact_objInits_autoRun")
call Vrx(function I0r,"s"+"__Artifact_Allocation__allocInit_autoRun")
call Vrx(function I2r,"s"+"__Artifact_initializer_Init_autoRun")
call Vrx(function I3r,"s"+"__FolderBatSwarm_StructMissile_objInits_autoRun")
call Vrx(function I4r,"s"+"__FolderBatSwarm_StructMissile_Allocation__allocInit_autoRun")
call Vrx(function I7r,"s"+"__BatSwarm_objInits_autoRun")
call Vrx(function I8r,"s"+"__BatSwarm_Allocation__allocInit_autoRun")
call Vrx(function Abr,"s"+"__BatSwarm_initializer_Init_autoRun")
call Vrx(function Adr,"s"+"__HawkEye_objInits_autoRun")
call Vrx(function ADr,"s"+"__HawkEye_Allocation__allocInit_autoRun")
call Vrx(function Asr,"s"+"__HawkEye_initializer_Init_autoRun")
call Vrx(function ATr,"s"+"__FolderMagicBottle_StructBuff_objInits_autoRun")
call Vrx(function Aur,"s"+"__FolderMagicBottle_StructBuff_Allocation__allocInit_autoRun")
call Vrx(function Awr,"s"+"__MagicBottle_objInits_autoRun")
call Vrx(function AWr,"s"+"__MagicBottle_Allocation__allocInit_autoRun")
call Vrx(function A6r,"s"+"__MagicBottle_initializer_Init_autoRun")
call Vrx(function A8r,"s"+"__FolderRedwoodValkyrie_StructAir_objInits_autoRun")
call Vrx(function A9r,"s"+"__FolderRedwoodValkyrie_StructAir_Allocation__allocInit_autoRun")
call Vrx(function Nxr,"s"+"__RedwoodValkyrie_objInits_autoRun")
call Vrx(function Nor,"s"+"__RedwoodValkyrie_Allocation__allocInit_autoRun")
call Vrx(function NGr,"s"+"__RedwoodValkyrie_initializer_Init_autoRun")
call Vrx(function NJr,"s"+"__SapphireblueDagger_objInits_autoRun")
call Vrx(function Nkr,"s"+"__SapphireblueDagger_Allocation__allocInit_autoRun")
call Vrx(function NQr,"s"+"__SapphireblueDagger_initializer_Init_autoRun")
call Vrx(function Ntr,"s"+"__SilentBoots_objInits_autoRun")
call Vrx(function NTr,"s"+"__SilentBoots_Allocation__allocInit_autoRun")
call Vrx(function bGr,"s"+"__SilentBoots_initializer_Init_autoRun")
call Vrx(function bjr,"s"+"__StoneShield_objInits_autoRun")
call Vrx(function bJr,"s"+"__StoneShield_Allocation__allocInit_autoRun")
call Vrx(function bsr,"s"+"__StoneShield_initializer_Init_autoRun")
call Vrx(function bUr,"s"+"__TaintedLeaf_objInits_autoRun")
call Vrx(function bwr,"s"+"__TaintedLeaf_Allocation__allocInit_autoRun")
call Vrx(function b4r,"s"+"__TaintedLeaf_initializer_Init_autoRun")
call Vrx(function Ber,"s"+"__FolderVioletEarring_StructCharge_objInits_autoRun")
call Vrx(function Bxr,"s"+"__FolderVioletEarring_StructCharge_Allocation__allocInit_autoRun")
call Vrx(function Brr,"s"+"__FolderVioletEarring_StructPort_objInits_autoRun")
call Vrx(function Bir,"s"+"__FolderVioletEarring_StructPort_Allocation__allocInit_autoRun")
call Vrx(function Bnr,"s"+"__VioletEarring_objInits_autoRun")
call Vrx(function BVr,"s"+"__VioletEarring_Allocation__allocInit_autoRun")
call Vrx(function BKr,"s"+"__VioletEarring_initializer_Init_autoRun")
call Vrx(function Bmr,"s"+"__FolderVomit_StructTarget_objInits_autoRun")
call Vrx(function BMr,"s"+"__FolderVomit_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function BPr,"s"+"__Vomit_objInits_autoRun")
call Vrx(function Bqr,"s"+"__Vomit_Allocation__allocInit_autoRun")
call Vrx(function B3r,"s"+"__Vomit_initializer_Init_autoRun")
call Vrx(function B6r,"s"+"__FolderWhiteStaff_StructTarget_objInits_autoRun")
call Vrx(function B7r,"s"+"__FolderWhiteStaff_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function cer,"s"+"__WhiteStaff_objInits_autoRun")
call Vrx(function cxr,"s"+"__WhiteStaff_Allocation__allocInit_autoRun")
call Vrx(function cRr,"s"+"__WhiteStaff_initializer_Init_autoRun")
call Vrx(function cAr,"s"+"__FolderBarrier_StructKnockback_objInits_autoRun")
call Vrx(function cNr,"s"+"__FolderBarrier_StructKnockback_Allocation__allocInit_autoRun")
call Vrx(function clr,"s"+"__Barrier_objInits_autoRun")
call Vrx(function cLr,"s"+"__Barrier_Allocation__allocInit_autoRun")
call Vrx(function cyr,"s"+"__Barrier_initializer_Init_autoRun")
call Vrx(function czr,"s"+"__FolderBlizzard_StructWave_objInits_autoRun")
call Vrx(function cZr,"s"+"__FolderBlizzard_StructWave_Allocation__allocInit_autoRun")
call Vrx(function c1r,"s"+"__Blizzard_objInits_autoRun")
call Vrx(function c2r,"s"+"__Blizzard_Allocation__allocInit_autoRun")
call Vrx(function CEr,"s"+"__Blizzard_initializer_Init_autoRun")
call Vrx(function CRr,"s"+"__FolderChillyBreath_StructBuff_objInits_autoRun")
call Vrx(function CIr,"s"+"__FolderChillyBreath_StructBuff_Allocation__allocInit_autoRun")
call Vrx(function Cbr,"s"+"__ChillyBreath_objInits_autoRun")
call Vrx(function CBr,"s"+"__ChillyBreath_Allocation__allocInit_autoRun")
call Vrx(function C4r,"s"+"__ChillyBreath_initializer_Init_autoRun")
call Vrx(function C5r,"s"+"__ElementalSpellToHero_Allocation__allocInit_autoRun")
call Vrx(function dor,"s"+"__ElementalSpellToHero_initializer_Init_autoRun")
call Vrx(function dar,"s"+"__FolderFireburst_StructShot_objInits_autoRun")
call Vrx(function dnr,"s"+"__FolderFireburst_StructShot_Allocation__allocInit_autoRun")
call Vrx(function dXr,"s"+"__Fireburst_objInits_autoRun")
call Vrx(function dOr,"s"+"__Fireburst_Allocation__allocInit_autoRun")
call Vrx(function dTr,"s"+"__Fireburst_initializer_Init_autoRun")
call Vrx(function dwr,"s"+"__FlameTongue_objInits_autoRun")
call Vrx(function dWr,"s"+"__FlameTongue_Allocation__allocInit_autoRun")
call Vrx(function Drr,"s"+"__FlameTongue_initializer_Init_autoRun")
call Vrx(function Dnr,"s"+"__FolderFrozenStar_StructTarget_objInits_autoRun")
call Vrx(function DVr,"s"+"__FolderFrozenStar_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function DXr,"s"+"__FolderFrozenStar_StructExplosion_objInits_autoRun")
call Vrx(function DOr,"s"+"__FolderFrozenStar_StructExplosion_Allocation__allocInit_autoRun")
call Vrx(function DIr,"s"+"__FrozenStar_objInits_autoRun")
call Vrx(function DAr,"s"+"__FrozenStar_Allocation__allocInit_autoRun")
call Vrx(function DLr,"s"+"__FrozenStar_initializer_Init_autoRun")
call Vrx(function Dtr,"s"+"__FolderGhostSword_StructSword_objInits_autoRun")
call Vrx(function DTr,"s"+"__FolderGhostSword_StructSword_Allocation__allocInit_autoRun")
call Vrx(function Dwr,"s"+"__GhostSword_objInits_autoRun")
call Vrx(function DWr,"s"+"__GhostSword_Allocation__allocInit_autoRun")
call Vrx(function fVr,"s"+"__GhostSword_initializer_Init_autoRun")
call Vrx(function fOr,"s"+"__FolderHackNSlay_StructTarget_objInits_autoRun")
call Vrx(function fRr,"s"+"__FolderHackNSlay_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function fNr,"s"+"__HackNSlay_objInits_autoRun")
call Vrx(function fbr,"s"+"__HackNSlay_Allocation__allocInit_autoRun")
call Vrx(function fHr,"s"+"__HackNSlay_initializer_Init_autoRun")
call Vrx(function fkr,"s"+"__IceBlock_objInits_autoRun")
call Vrx(function fKr,"s"+"__IceBlock_Allocation__allocInit_autoRun")
call Vrx(function fmr,"s"+"__IceBlock_initializer_Init_autoRun")
call Vrx(function fqr,"s"+"__IceShock_objInits_autoRun")
call Vrx(function fQr,"s"+"__IceShock_Allocation__allocInit_autoRun")
call Vrx(function fTr,"s"+"__IceShock_initializer_Init_autoRun")
call Vrx(function fwr,"s"+"__FolderInnerForce_StructCrit_objInits_autoRun")
call Vrx(function fWr,"s"+"__FolderInnerForce_StructCrit_Allocation__allocInit_autoRun")
call Vrx(function fYr,"s"+"__InnerForce_objInits_autoRun")
call Vrx(function fzr,"s"+"__InnerForce_Allocation__allocInit_autoRun")
call Vrx(function Far,"s"+"__InnerForce_initializer_Init_autoRun")
call Vrx(function FEr,"s"+"__Monolith_objInits_autoRun")
call Vrx(function FXr,"s"+"__Monolith_Allocation__allocInit_autoRun")
call Vrx(function FHr,"s"+"__Monolith_initializer_Init_autoRun")
call Vrx(function Fkr,"s"+"__FolderSacredAura_StructTarget_objInits_autoRun")
call Vrx(function FKr,"s"+"__FolderSacredAura_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function Fmr,"s"+"__SacredAura_objInits_autoRun")
call Vrx(function FMr,"s"+"__SacredAura_Allocation__allocInit_autoRun")
call Vrx(function FTr,"s"+"__SacredAura_initializer_Init_autoRun")
call Vrx(function Fwr,"s"+"__FolderSeverance_StructBuff_objInits_autoRun")
call Vrx(function FWr,"s"+"__FolderSeverance_StructBuff_Allocation__allocInit_autoRun")
call Vrx(function FYr,"s"+"__Severance_objInits_autoRun")
call Vrx(function Fzr,"s"+"__Severance_Allocation__allocInit_autoRun")
call Vrx(function gxr,"s"+"__Severance_initializer_Init_autoRun")
call Vrx(function grr,"s"+"__FolderSnowySphere_StructParticle_objInits_autoRun")
call Vrx(function gir,"s"+"__FolderSnowySphere_StructParticle_Allocation__allocInit_autoRun")
call Vrx(function gnr,"s"+"__SnowySphere_objInits_autoRun")
call Vrx(function gVr,"s"+"__SnowySphere_Allocation__allocInit_autoRun")
call Vrx(function gJr,"s"+"__SnowySphere_initializer_Init_autoRun")
call Vrx(function gKr,"s"+"__Thunderstrike_objInits_autoRun")
call Vrx(function glr,"s"+"__Thunderstrike_Allocation__allocInit_autoRun")
call Vrx(function gZr,"s"+"__Thunderstrike_initializer_Init_autoRun")
call Vrx(function g7r,"s"+"__TwinWolves_objInits_autoRun")
call Vrx(function g8r,"s"+"__TwinWolves_Allocation__allocInit_autoRun")
call Vrx(function GIr,"s"+"__TwinWolves_initializer_Init_autoRun")
call Vrx(function Gbr,"s"+"__Brotherhood_objInits_autoRun")
call Vrx(function GBr,"s"+"__Brotherhood_Allocation__allocInit_autoRun")
call Vrx(function GHr,"s"+"__Brotherhood_initializer_Init_autoRun")
call Vrx(function GKr,"s"+"__Carnivore_objInits_autoRun")
call Vrx(function Glr,"s"+"__Carnivore_Allocation__allocInit_autoRun")
call Vrx(function Gpr,"s"+"__Carnivore_initializer_Init_autoRun")
call Vrx(function GQr,"s"+"__WolfsMark_objInits_autoRun")
call Vrx(function Gsr,"s"+"__WolfsMark_Allocation__allocInit_autoRun")
call Vrx(function Gtr,"s"+"__WolfsMark_initializer_Init_autoRun")
call Vrx(function GTr,"s"+"__FolderVividMeteor_StructEffects_objInits_autoRun")
call Vrx(function Gur,"s"+"__FolderVividMeteor_StructEffects_Allocation__allocInit_autoRun")
call Vrx(function GWr,"s"+"__VividMeteor_objInits_autoRun")
call Vrx(function Gyr,"s"+"__VividMeteor_Allocation__allocInit_autoRun")
call Vrx(function hrr,"s"+"__VividMeteor_initializer_Init_autoRun")
call Vrx(function hVr,"s"+"__WarmthMagnetism_objInits_autoRun")
call Vrx(function hEr,"s"+"__WarmthMagnetism_Allocation__allocInit_autoRun")
call Vrx(function hdr,"s"+"__WarmthMagnetism_initializer_Init_autoRun")
call Vrx(function hfr,"s"+"__FolderAmaterasu_StructTarget_objInits_autoRun")
call Vrx(function hFr,"s"+"__FolderAmaterasu_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function hhr,"s"+"__Amaterasu_objInits_autoRun")
call Vrx(function hHr,"s"+"__Amaterasu_Allocation__allocInit_autoRun")
call Vrx(function hpr,"s"+"__Amaterasu_initializer_Init_autoRun")
call Vrx(function hsr,"s"+"__FolderArcaneAttractor_StructTarget_objInits_autoRun")
call Vrx(function hSr,"s"+"__FolderArcaneAttractor_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function hur,"s"+"__ArcaneAttractor_objInits_autoRun")
call Vrx(function hUr,"s"+"__ArcaneAttractor_Allocation__allocInit_autoRun")
call Vrx(function h4r,"s"+"__ArcaneAttractor_initializer_Init_autoRun")
call Vrx(function Hvr,"s"+"__ArcticWolf_objInits_autoRun")
call Vrx(function Her,"s"+"__ArcticWolf_Allocation__allocInit_autoRun")
call Vrx(function Hfr,"s"+"__ArcticWolf_initializer_Init_autoRun")
call Vrx(function Hgr,"s"+"__FolderBoulderCrash_StructVisuals_objInits_autoRun")
call Vrx(function HGr,"s"+"__FolderBoulderCrash_StructVisuals_Allocation__allocInit_autoRun")
call Vrx(function Hjr,"s"+"__BoulderCrash_objInits_autoRun")
call Vrx(function HJr,"s"+"__BoulderCrash_Allocation__allocInit_autoRun")
call Vrx(function H3r,"s"+"__BoulderCrash_initializer_Init_autoRun")
call Vrx(function H9r,"s"+"__Conflagration_objInits_autoRun")
call Vrx(function jvr,"s"+"__Conflagration_Allocation__allocInit_autoRun")
call Vrx(function jhr,"s"+"__Conflagration_initializer_Init_autoRun")
call Vrx(function jjr,"s"+"__FolderCyclone_StructRelocate_objInits_autoRun")
call Vrx(function jJr,"s"+"__FolderCyclone_StructRelocate_Allocation__allocInit_autoRun")
call Vrx(function jlr,"s"+"__Cyclone_objInits_autoRun")
call Vrx(function jLr,"s"+"__Cyclone_Allocation__allocInit_autoRun")
call Vrx(function jzr,"s"+"__Cyclone_initializer_Init_autoRun")
call Vrx(function j_r,"s"+"__FolderWindDance_StructTarget_objInits_autoRun")
call Vrx(function j0r,"s"+"__FolderWindDance_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function j4r,"s"+"__WindDance_objInits_autoRun")
call Vrx(function j5r,"s"+"__WindDance_Allocation__allocInit_autoRun")
call Vrx(function Jer,"s"+"__DeprivingShock_objInits_autoRun")
call Vrx(function Jxr,"s"+"__DeprivingShock_Allocation__allocInit_autoRun")
call Vrx(function JRr,"s"+"__DeprivingShock_initializer_Init_autoRun")
call Vrx(function JNr,"s"+"__FolderDoppelganger_StructBigBoom_objInits_autoRun")
call Vrx(function Jbr,"s"+"__FolderDoppelganger_StructBigBoom_Allocation__allocInit_autoRun")
call Vrx(function JCr,"s"+"__FolderDoppelganger_StructFireBuff_objInits_autoRun")
call Vrx(function Jdr,"s"+"__FolderDoppelganger_StructFireBuff_Allocation__allocInit_autoRun")
call Vrx(function Jgr,"s"+"__FolderDoppelganger_StructIceBuff_objInits_autoRun")
call Vrx(function JGr,"s"+"__FolderDoppelganger_StructIceBuff_Allocation__allocInit_autoRun")
call Vrx(function Jkr,"s"+"__Doppelganger_objInits_autoRun")
call Vrx(function JKr,"s"+"__Doppelganger_Allocation__allocInit_autoRun")
call Vrx(function J9r,"s"+"__Doppelganger_initializer_Init_autoRun")
call Vrx(function kxr,"s"+"__EbonyShot_objInits_autoRun")
call Vrx(function kor,"s"+"__EbonyShot_Allocation__allocInit_autoRun")
call Vrx(function kCr,"s"+"__EbonyShot_initializer_Init_autoRun")
call Vrx(function kfr,"s"+"__FolderEmphaticBite_StructBuff_objInits_autoRun")
call Vrx(function kFr,"s"+"__FolderEmphaticBite_StructBuff_Allocation__allocInit_autoRun")
call Vrx(function kjr,"s"+"__EmphaticBite_objInits_autoRun")
call Vrx(function kJr,"s"+"__EmphaticBite_Allocation__allocInit_autoRun")
call Vrx(function kWr,"s"+"__EmphaticBite_initializer_Init_autoRun")
call Vrx(function kYr,"s"+"__EnchantedArrow_objInits_autoRun")
call Vrx(function kzr,"s"+"__EnchantedArrow_Allocation__allocInit_autoRun")
call Vrx(function KBr,"s"+"__EnchantedArrow_initializer_Init_autoRun")
call Vrx(function Kdr,"s"+"__FolderFairyShape_StructRevert_objInits_autoRun")
call Vrx(function KDr,"s"+"__FolderFairyShape_StructRevert_Allocation__allocInit_autoRun")
call Vrx(function Klr,"s"+"__FairyShape_objInits_autoRun")
call Vrx(function KLr,"s"+"__FairyShape_Allocation__allocInit_autoRun")
call Vrx(function K_r,"s"+"__FairyShape_initializer_Init_autoRun")
call Vrx(function K3r,"s"+"__FolderFairysTears_StructTarget_objInits_autoRun")
call Vrx(function K4r,"s"+"__FolderFairysTears_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function K7r,"s"+"__FairysTears_objInits_autoRun")
call Vrx(function K8r,"s"+"__FairysTears_Allocation__allocInit_autoRun")
call Vrx(function lOr,"s"+"__FairysTears_initializer_Init_autoRun")
call Vrx(function lAr,"s"+"__FountainOfLifeAndDeath_objInits_autoRun")
call Vrx(function lNr,"s"+"__FountainOfLifeAndDeath_Allocation__allocInit_autoRun")
call Vrx(function lFr,"s"+"__FountainOfLifeAndDeath_initializer_Init_autoRun")
call Vrx(function lhr,"s"+"__FolderDecayAura_StructTarget_objInits_autoRun")
call Vrx(function lHr,"s"+"__FolderDecayAura_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function lKr,"s"+"__DecayAura_objInits_autoRun")
call Vrx(function llr,"s"+"__DecayAura_Allocation__allocInit_autoRun")
call Vrx(function ltr,"s"+"__DecayAura_initializer_Init_autoRun")
call Vrx(function lTr,"s"+"__AIPalingenesis_Allocation__allocInit_autoRun")
call Vrx(function lzr,"s"+"__AIPalingenesis_initializer_Init_autoRun")
call Vrx(function l0r,"s"+"__Palingenesis_objInits_autoRun")
call Vrx(function l1r,"s"+"__Palingenesis_Allocation__allocInit_autoRun")
call Vrx(function l8r,"s"+"__Palingenesis_initializer_Init_autoRun")
call Vrx(function Ler,"s"+"__FolderGarmentsOfTheSalamander_StructRegen_objInits_autoRun")
call Vrx(function Lxr,"s"+"__FolderGarmentsOfTheSalamander_StructRegen_Allocation__allocInit_autoRun")
call Vrx(function LEr,"s"+"__GarmentsOfTheSalamander_objInits_autoRun")
call Vrx(function LXr,"s"+"__GarmentsOfTheSalamander_Allocation__allocInit_autoRun")
call Vrx(function LGr,"s"+"__GarmentsOfTheSalamander_initializer_Init_autoRun")
call Vrx(function Lhr,"s"+"__FolderHandOfNature_StructId_Allocation__allocInit_autoRun")
call Vrx(function LHr,"s"+"__FolderHandOfNature_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vrx(function Ljr,"s"+"__FolderHandOfNature_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vrx(function LJr,"s"+"__FolderHandOfNature_StructData_Allocation__allocInit_autoRun")
call Vrx(function LKr,"s"+"__FolderHandOfNature_StructPrison_objInits_autoRun")
call Vrx(function Llr,"s"+"__FolderHandOfNature_StructPrison_Allocation__allocInit_autoRun")
call Vrx(function LMr,"s"+"__FolderHandOfNature_FolderRoots_StructBuff_objInits_autoRun")
call Vrx(function Lpr,"s"+"__FolderHandOfNature_FolderRoots_StructBuff_Allocation__allocInit_autoRun")
call Vrx(function LPr,"s"+"__FolderHandOfNature_StructRoots_objInits_autoRun")
call Vrx(function Lqr,"s"+"__FolderHandOfNature_StructRoots_Allocation__allocInit_autoRun")
call Vrx(function LQr,"s"+"__FolderHandOfNature_StructNova_objInits_autoRun")
call Vrx(function Lsr,"s"+"__FolderHandOfNature_StructNova_Allocation__allocInit_autoRun")
call Vrx(function LYr,"s"+"__HandOfNature_objInits_autoRun")
call Vrx(function Lzr,"s"+"__HandOfNature_Allocation__allocInit_autoRun")
call Vrx(function mHr,"s"+"__HandOfNature_initializer_Init_autoRun")
call Vrx(function mkr,"s"+"__FolderSlowPoison_StructTarget_objInits_autoRun")
call Vrx(function mKr,"s"+"__FolderSlowPoison_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function mmr,"s"+"__SlowPoison_objInits_autoRun")
call Vrx(function mMr,"s"+"__SlowPoison_Allocation__allocInit_autoRun")
call Vrx(function myr,"s"+"__SlowPoison_initializer_Init_autoRun")
call Vrx(function mZr,"s"+"__FolderHopNDrop_FolderSetMines_StructMine_objInits_autoRun")
call Vrx(function m_r,"s"+"__FolderHopNDrop_FolderSetMines_StructMine_Allocation__allocInit_autoRun")
call Vrx(function m2r,"s"+"__FolderHopNDrop_StructSetMines_objInits_autoRun")
call Vrx(function m3r,"s"+"__FolderHopNDrop_StructSetMines_Allocation__allocInit_autoRun")
call Vrx(function m6r,"s"+"__HopNDrop_objInits_autoRun")
call Vrx(function m7r,"s"+"__HopNDrop_Allocation__allocInit_autoRun")
call Vrx(function Mbr,"s"+"__HopNDrop_initializer_Init_autoRun")
call Vrx(function Mcr,"s"+"__FolderInfection_StructCone_objInits_autoRun")
call Vrx(function MCr,"s"+"__FolderInfection_StructCone_Allocation__allocInit_autoRun")
call Vrx(function Mfr,"s"+"__FolderInfection_FolderSummon_StructFuniculusUmbilicalis_objInits_autoRun")
call Vrx(function MFr,"s"+"__FolderInfection_FolderSummon_StructFuniculusUmbilicalis_Allocation__allocInit_autoRun")
call Vrx(function MKr,"s"+"__FolderInfection_StructSummon_objInits_autoRun")
call Vrx(function Mlr,"s"+"__FolderInfection_StructSummon_Allocation__allocInit_autoRun")
call Vrx(function MMr,"s"+"__FolderInfection_StructTarget_objInits_autoRun")
call Vrx(function Mpr,"s"+"__FolderInfection_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function MQr,"s"+"__Infection_objInits_autoRun")
call Vrx(function Msr,"s"+"__Infection_Allocation__allocInit_autoRun")
call Vrx(function pxr,"s"+"__Infection_initializer_Init_autoRun")
call Vrx(function pir,"s"+"__FolderKhakiRecovery_StructRestoration_objInits_autoRun")
call Vrx(function par,"s"+"__FolderKhakiRecovery_StructRestoration_Allocation__allocInit_autoRun")
call Vrx(function pOr,"s"+"__KhakiRecovery_objInits_autoRun")
call Vrx(function pRr,"s"+"__KhakiRecovery_Allocation__allocInit_autoRun")
call Vrx(function pPr,"s"+"__KhakiRecovery_initializer_Init_autoRun")
call Vrx(function pTr,"s"+"__ManaColossus_objInits_autoRun")
call Vrx(function pur,"s"+"__ManaColossus_Allocation__allocInit_autoRun")
call Vrx(function pWr,"s"+"__ManaColossus_initializer_Init_autoRun")
call Vrx(function pzr,"s"+"__FolderTheurgicVessel_StructTarget_objInits_autoRun")
call Vrx(function pZr,"s"+"__FolderTheurgicVessel_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function p1r,"s"+"__TheurgicVessel_objInits_autoRun")
call Vrx(function p2r,"s"+"__TheurgicVessel_Allocation__allocInit_autoRun")
call Vrx(function p9r,"s"+"__TheurgicVessel_initializer_Init_autoRun")
call Vrx(function Pxr,"s"+"__FolderManaLaser_StructRevert_objInits_autoRun")
call Vrx(function Por,"s"+"__FolderManaLaser_StructRevert_Allocation__allocInit_autoRun")
call Vrx(function Par,"s"+"__ManaLaser_objInits_autoRun")
call Vrx(function Pnr,"s"+"__ManaLaser_Allocation__allocInit_autoRun")
call Vrx(function Plr,"s"+"__ManaLaser_initializer_Init_autoRun")
call Vrx(function Pmr,"s"+"__FolderMassMimesis_StructCharm_objInits_autoRun")
call Vrx(function PMr,"s"+"__FolderMassMimesis_StructCharm_Allocation__allocInit_autoRun")
call Vrx(function Ppr,"s"+"__FolderMassMimesis_StructMissile_objInits_autoRun")
call Vrx(function PPr,"s"+"__FolderMassMimesis_StructMissile_Allocation__allocInit_autoRun")
call Vrx(function Psr,"s"+"__MassMimesis_objInits_autoRun")
call Vrx(function PSr,"s"+"__MassMimesis_Allocation__allocInit_autoRun")
call Vrx(function P7r,"s"+"__MassMimesis_initializer_Init_autoRun")
call Vrx(function qor,"s"+"__MountainKing_objInits_autoRun")
call Vrx(function qrr,"s"+"__MountainKing_Allocation__allocInit_autoRun")
call Vrx(function qIr,"s"+"__MountainKing_initializer_Init_autoRun")
call Vrx(function qNr,"s"+"__Thunderbringer_objInits_autoRun")
call Vrx(function qbr,"s"+"__Thunderbringer_Allocation__allocInit_autoRun")
call Vrx(function qdr,"s"+"__Thunderbringer_initializer_Init_autoRun")
call Vrx(function qgr,"s"+"__NegationWave_objInits_autoRun")
call Vrx(function qGr,"s"+"__NegationWave_Allocation__allocInit_autoRun")
call Vrx(function qtr,"s"+"__NegationWave_initializer_Init_autoRun")
call Vrx(function qyr,"s"+"__FolderNurturingGrounds_StructEgg_objInits_autoRun")
call Vrx(function qYr,"s"+"__FolderNurturingGrounds_StructEgg_Allocation__allocInit_autoRun")
call Vrx(function qZr,"s"+"__NurturingGrounds_objInits_autoRun")
call Vrx(function q_r,"s"+"__NurturingGrounds_Allocation__allocInit_autoRun")
call Vrx(function QNr,"s"+"__NurturingGrounds_initializer_Init_autoRun")
call Vrx(function QBr,"s"+"__FolderPandaPaw_FolderArrival_StructTarget_objInits_autoRun")
call Vrx(function Qcr,"s"+"__FolderPandaPaw_FolderArrival_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function QDr,"s"+"__FolderPandaPaw_StructArrival_objInits_autoRun")
call Vrx(function Qfr,"s"+"__FolderPandaPaw_StructArrival_Allocation__allocInit_autoRun")
call Vrx(function QGr,"s"+"__FolderPandaPaw_StructLeech_objInits_autoRun")
call Vrx(function Qhr,"s"+"__FolderPandaPaw_StructLeech_Allocation__allocInit_autoRun")
call Vrx(function QJr,"s"+"__PandaPaw_objInits_autoRun")
call Vrx(function Qkr,"s"+"__PandaPaw_Allocation__allocInit_autoRun")
call Vrx(function sXr,"s"+"__PandaPaw_initializer_Init_autoRun")
call Vrx(function sRr,"s"+"__FolderPurgingRain_StructWave_objInits_autoRun")
call Vrx(function sIr,"s"+"__FolderPurgingRain_StructWave_Allocation__allocInit_autoRun")
call Vrx(function sbr,"s"+"__PurgingRain_objInits_autoRun")
call Vrx(function sBr,"s"+"__PurgingRain_Allocation__allocInit_autoRun")
call Vrx(function smr,"s"+"__PurgingRain_initializer_Init_autoRun")
call Vrx(function spr,"s"+"__FolderRazorBladeDrawBack_StructBlade_objInits_autoRun")
call Vrx(function sPr,"s"+"__FolderRazorBladeDrawBack_StructBlade_Allocation__allocInit_autoRun")
call Vrx(function sQr,"s"+"__RazorBladeDrawBack_objInits_autoRun")
call Vrx(function ssr,"s"+"__RazorBladeDrawBack_Allocation__allocInit_autoRun")
call Vrx(function syr,"s"+"__RazorBladeDrawBack_initializer_Init_autoRun")
call Vrx(function sZr,"s"+"__FolderRazorBlade_StructVamp_objInits_autoRun")
call Vrx(function s_r,"s"+"__FolderRazorBlade_StructVamp_Allocation__allocInit_autoRun")
call Vrx(function s2r,"s"+"__RazorBlade_objInits_autoRun")
call Vrx(function s3r,"s"+"__RazorBlade_Allocation__allocInit_autoRun")
call Vrx(function SZr,"s"+"__RazorBlade_initializer_Init_autoRun")
call Vrx(function S1r,"s"+"__FolderRelentlessShiver_StructBuff_objInits_autoRun")
call Vrx(function S2r,"s"+"__FolderRelentlessShiver_StructBuff_Allocation__allocInit_autoRun")
call Vrx(function S4r,"s"+"__FolderRelentlessShiver_StructMissile_objInits_autoRun")
call Vrx(function S5r,"s"+"__FolderRelentlessShiver_StructMissile_Allocation__allocInit_autoRun")
call Vrx(function tvr,"s"+"__RelentlessShiver_objInits_autoRun")
call Vrx(function ter,"s"+"__RelentlessShiver_Allocation__allocInit_autoRun")
call Vrx(function tCr,"s"+"__RelentlessShiver_initializer_Init_autoRun")
call Vrx(function tDr,"s"+"__FolderRigorMortis_StructAfterBuff_objInits_autoRun")
call Vrx(function tfr,"s"+"__FolderRigorMortis_StructAfterBuff_Allocation__allocInit_autoRun")
call Vrx(function tgr,"s"+"__RigorMortis_objInits_autoRun")
call Vrx(function tGr,"s"+"__RigorMortis_Allocation__allocInit_autoRun")
call Vrx(function tmr,"s"+"__RigorMortis_initializer_Init_autoRun")
call Vrx(function tMr,"s"+"__FolderSakeBomb_StructMissile_objInits_autoRun")
call Vrx(function tpr,"s"+"__FolderSakeBomb_StructMissile_Allocation__allocInit_autoRun")
call Vrx(function tQr,"s"+"__SakeBomb_objInits_autoRun")
call Vrx(function tsr,"s"+"__SakeBomb_Allocation__allocInit_autoRun")
call Vrx(function t6r,"s"+"__SakeBomb_initializer_Init_autoRun")
call Vrx(function t9r,"s"+"__SanguineEyes_objInits_autoRun")
call Vrx(function Tvr,"s"+"__SanguineEyes_Allocation__allocInit_autoRun")
call Vrx(function Tar,"s"+"__SanguineEyes_initializer_Init_autoRun")
call Vrx(function TVr,"s"+"__FolderShamanicBubble_StructTarget_objInits_autoRun")
call Vrx(function TEr,"s"+"__FolderShamanicBubble_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function TOr,"s"+"__FolderShamanicBubble_StructTransition_objInits_autoRun")
call Vrx(function TRr,"s"+"__FolderShamanicBubble_StructTransition_Allocation__allocInit_autoRun")
call Vrx(function TNr,"s"+"__ShamanicBubble_objInits_autoRun")
call Vrx(function Tbr,"s"+"__ShamanicBubble_Allocation__allocInit_autoRun")
call Vrx(function TLr,"s"+"__ShamanicBubble_initializer_Init_autoRun")
call Vrx(function TPr,"s"+"__FolderSleepingDraft_StructBuff_objInits_autoRun")
call Vrx(function Tqr,"s"+"__FolderSleepingDraft_StructBuff_Allocation__allocInit_autoRun")
call Vrx(function TSr,"s"+"__SleepingDraft_objInits_autoRun")
call Vrx(function Ttr,"s"+"__SleepingDraft_Allocation__allocInit_autoRun")
call Vrx(function T4r,"s"+"__SleepingDraft_initializer_Init_autoRun")
call Vrx(function T5r,"s"+"__FolderSoberUp_StructHealMissile_objInits_autoRun")
call Vrx(function T6r,"s"+"__FolderSoberUp_StructHealMissile_Allocation__allocInit_autoRun")
call Vrx(function T9r,"s"+"__SoberUp_objInits_autoRun")
call Vrx(function uvr,"s"+"__SoberUp_Allocation__allocInit_autoRun")
call Vrx(function uOr,"s"+"__SoberUp_initializer_Init_autoRun")
call Vrx(function uAr,"s"+"__FolderSteelImpalement_StructTarget_objInits_autoRun")
call Vrx(function uNr,"s"+"__FolderSteelImpalement_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function ucr,"s"+"__SteelImpalement_objInits_autoRun")
call Vrx(function uCr,"s"+"__SteelImpalement_Allocation__allocInit_autoRun")
call Vrx(function umr,"s"+"__SteelImpalement_initializer_Init_autoRun")
call Vrx(function uMr,"s"+"__FolderSummonPolarBear_FolderSummon_StructCallback_Allocation__allocInit_autoRun")
call Vrx(function uur,"s"+"__FolderSummonPolarBear_StructSummon_objInits_autoRun")
call Vrx(function uUr,"s"+"__FolderSummonPolarBear_StructSummon_Allocation__allocInit_autoRun")
call Vrx(function uWr,"s"+"__SummonPolarBear_objInits_autoRun")
call Vrx(function uyr,"s"+"__SummonPolarBear_Allocation__allocInit_autoRun")
call Vrx(function UVr,"s"+"__SummonPolarBear_initializer_Init_autoRun")
call Vrx(function UXr,"s"+"__ArcticBlink_objInits_autoRun")
call Vrx(function UOr,"s"+"__ArcticBlink_Allocation__allocInit_autoRun")
call Vrx(function UDr,"s"+"__ArcticBlink_initializer_Init_autoRun")
call Vrx(function UFr,"s"+"__Devour_objInits_autoRun")
call Vrx(function Ugr,"s"+"__Devour_Allocation__allocInit_autoRun")
call Vrx(function UHr,"s"+"__Devour_initializer_Init_autoRun")
call Vrx(function Ukr,"s"+"__Susanoo_objInits_autoRun")
call Vrx(function UKr,"s"+"__Susanoo_Allocation__allocInit_autoRun")
call Vrx(function UTr,"s"+"__Susanoo_initializer_Init_autoRun")
call Vrx(function UYr,"s"+"__Swiftness_objInits_autoRun")
call Vrx(function Uzr,"s"+"__Swiftness_Allocation__allocInit_autoRun")
call Vrx(function U2r,"s"+"__Swiftness_initializer_Init_autoRun")
call Vrx(function U5r,"s"+"__FolderTempestStrike_StructCriticalAttacks_objInits_autoRun")
call Vrx(function U6r,"s"+"__FolderTempestStrike_StructCriticalAttacks_Allocation__allocInit_autoRun")
call Vrx(function U9r,"s"+"__TempestStrike_objInits_autoRun")
call Vrx(function wvr,"s"+"__TempestStrike_Allocation__allocInit_autoRun")
call Vrx(function wXr,"s"+"__TempestStrike_initializer_Init_autoRun")
call Vrx(function wOr,"s"+"__FolderTsukuyomi_StructMissile_objInits_autoRun")
call Vrx(function wRr,"s"+"__FolderTsukuyomi_StructMissile_Allocation__allocInit_autoRun")
call Vrx(function wAr,"s"+"__FolderTsukuyomi_StructRelocate_objInits_autoRun")
call Vrx(function wNr,"s"+"__FolderTsukuyomi_StructRelocate_Allocation__allocInit_autoRun")
call Vrx(function wBr,"s"+"__FolderTsukuyomi_StructTarget_objInits_autoRun")
call Vrx(function wcr,"s"+"__FolderTsukuyomi_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function wDr,"s"+"__Tsukuyomi_objInits_autoRun")
call Vrx(function wfr,"s"+"__Tsukuyomi_Allocation__allocInit_autoRun")
call Vrx(function wWr,"s"+"__Tsukuyomi_initializer_Init_autoRun")
call Vrx(function wyr,"s"+"__FolderWanShroud_StructMissile_objInits_autoRun")
call Vrx(function wYr,"s"+"__FolderWanShroud_StructMissile_Allocation__allocInit_autoRun")
call Vrx(function w_r,"s"+"__FolderWanShroud_StructTarget_objInits_autoRun")
call Vrx(function w0r,"s"+"__FolderWanShroud_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function w2r,"s"+"__WanShroud_objInits_autoRun")
call Vrx(function w3r,"s"+"__WanShroud_Allocation__allocInit_autoRun")
call Vrx(function WCr,"s"+"__WanShroud_initializer_Init_autoRun")
call Vrx(function Wfr,"s"+"__FolderWarcry_StructTarget_objInits_autoRun")
call Vrx(function WFr,"s"+"__FolderWarcry_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function WGr,"s"+"__Warcry_objInits_autoRun")
call Vrx(function Whr,"s"+"__Warcry_Allocation__allocInit_autoRun")
call Vrx(function Wpr,"s"+"__Warcry_initializer_Init_autoRun")
call Vrx(function Wur,"s"+"__FolderWaterBindings_StructSummon_objInits_autoRun")
call Vrx(function WUr,"s"+"__FolderWaterBindings_StructSummon_Allocation__allocInit_autoRun")
call Vrx(function WWr,"s"+"__WaterBindings_objInits_autoRun")
call Vrx(function Wyr,"s"+"__WaterBindings_Allocation__allocInit_autoRun")
call Vrx(function W1r,"s"+"__WaterBindings_initializer_Init_autoRun")
call Vrx(function W5r,"s"+"__Lariat_objInits_autoRun")
call Vrx(function W6r,"s"+"__Lariat_Allocation__allocInit_autoRun")
call Vrx(function yor,"s"+"__Lariat_initializer_Init_autoRun")
call Vrx(function yEr,"s"+"__FolderSoakingAttack_StructTarget_objInits_autoRun")
call Vrx(function yXr,"s"+"__FolderSoakingAttack_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function yIr,"s"+"__SoakingAttack_objInits_autoRun")
call Vrx(function yAr,"s"+"__SoakingAttack_Allocation__allocInit_autoRun")
call Vrx(function yjr,"s"+"__SoakingAttack_initializer_Init_autoRun")
call Vrx(function yKr,"s"+"__FolderZodiacAura_StructTarget_objInits_autoRun")
call Vrx(function ylr,"s"+"__FolderZodiacAura_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function yMr,"s"+"__ZodiacAura_objInits_autoRun")
call Vrx(function ypr,"s"+"__ZodiacAura_Allocation__allocInit_autoRun")
call Vrx(function ywr,"s"+"__ZodiacAura_initializer_Init_autoRun")
call Vrx(function yYr,"s"+"__Zodiac_objInits_autoRun")
call Vrx(function yzr,"s"+"__Zodiac_Allocation__allocInit_autoRun")
call Vrx(function y5r,"s"+"__Zodiac_initializer_Init_autoRun")
call Vrx(function y9r,"s"+"__BigHealingWave_objInits_autoRun")
call Vrx(function Yvr,"s"+"__BigHealingWave_Allocation__allocInit_autoRun")
call Vrx(function YRr,"s"+"__BigHealingWave_initializer_Init_autoRun")
call Vrx(function YNr,"s"+"__BurningSpiritMeteorite_objInits_autoRun")
call Vrx(function Ybr,"s"+"__BurningSpiritMeteorite_Allocation__allocInit_autoRun")
call Vrx(function Yfr,"s"+"__BurningSpiritMeteorite_initializer_Init_autoRun")
call Vrx(function Ygr,"s"+"__BurnLumber_objInits_autoRun")
call Vrx(function YGr,"s"+"__BurnLumber_Allocation__allocInit_autoRun")
call Vrx(function Ykr,"s"+"__BurnLumber_initializer_Init_autoRun")
call Vrx(function Ylr,"s"+"__CoreFusion_objInits_autoRun")
call Vrx(function YLr,"s"+"__CoreFusion_Allocation__allocInit_autoRun")
call Vrx(function Yur,"s"+"__CoreFusion_initializer_Init_autoRun")
call Vrx(function Yyr,"s"+"__DarkAttack_objInits_autoRun")
call Vrx(function YYr,"s"+"__DarkAttack_Allocation__allocInit_autoRun")
call Vrx(function Y5r,"s"+"__DarkAttack_initializer_Init_autoRun")
call Vrx(function Y7r,"s"+"__FolderFountainAura_StructTarget_objInits_autoRun")
call Vrx(function Y8r,"s"+"__FolderFountainAura_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function zer,"s"+"__FountainAura_objInits_autoRun")
call Vrx(function zxr,"s"+"__FountainAura_Allocation__allocInit_autoRun")
call Vrx(function zRr,"s"+"__FountainAura_initializer_Init_autoRun")
call Vrx(function zbr,"s"+"__FountainHeal_objInits_autoRun")
call Vrx(function zBr,"s"+"__FountainHeal_Allocation__allocInit_autoRun")
call Vrx(function zJr,"s"+"__FountainHeal_initializer_Init_autoRun")
call Vrx(function zLr,"s"+"__FrostAttack_objInits_autoRun")
call Vrx(function zmr,"s"+"__FrostAttack_Allocation__allocInit_autoRun")
call Vrx(function zur,"s"+"__FrostAttack_initializer_Init_autoRun")
call Vrx(function zWr,"s"+"__Invisibility_objInits_autoRun")
call Vrx(function zyr,"s"+"__Invisibility_Allocation__allocInit_autoRun")
call Vrx(function z1r,"s"+"__Invisibility_initializer_Init_autoRun")
call Vrx(function z4r,"s"+"__Invulnerability_objInits_autoRun")
call Vrx(function z5r,"s"+"__Invulnerability_Allocation__allocInit_autoRun")
call Vrx(function Zer,"s"+"__Invulnerability_initializer_Init_autoRun")
call Vrx(function Zor,"s"+"__FolderLapidation_StructBuff_objInits_autoRun")
call Vrx(function Zrr,"s"+"__FolderLapidation_StructBuff_Allocation__allocInit_autoRun")
call Vrx(function Zar,"s"+"__Lapidation_objInits_autoRun")
call Vrx(function Znr,"s"+"__Lapidation_Allocation__allocInit_autoRun")
call Vrx(function Zdr,"s"+"__Lapidation_initializer_Init_autoRun")
call Vrx(function ZGr,"s"+"__LightningAttack_objInits_autoRun")
call Vrx(function Zhr,"s"+"__LightningAttack_Allocation__allocInit_autoRun")
call Vrx(function ZUr,"s"+"__LightningAttack_initializer_Init_autoRun")
call Vrx(function Zyr,"s"+"__MagicImmunity_objInits_autoRun")
call Vrx(function ZYr,"s"+"__MagicImmunity_Allocation__allocInit_autoRun")
call Vrx(function Z0r,"s"+"__MagicImmunity_initializer_Init_autoRun")
call Vrx(function Z2r,"s"+"__MeteoriteProtection_objInits_autoRun")
call Vrx(function Z3r,"s"+"__MeteoriteProtection_Allocation__allocInit_autoRun")
call Vrx(function Z5r,"s"+"__RefreshMana_objInits_autoRun")
call Vrx(function Z6r,"s"+"__RefreshMana_Allocation__allocInit_autoRun")
call Vrx(function voi,"s"+"__RefreshMana_initializer_Init_autoRun")
call Vrx(function vii,"s"+"__FolderRevealAura_StructTarget_objInits_autoRun")
call Vrx(function vai,"s"+"__FolderRevealAura_StructTarget_Allocation__allocInit_autoRun")
call Vrx(function vEi,"s"+"__RevealAura_objInits_autoRun")
call Vrx(function vXi,"s"+"__RevealAura_Allocation__allocInit_autoRun")
call Vrx(function vdi,"s"+"__RevealAura_initializer_Init_autoRun")
call Vrx(function vfi,"s"+"__Meteorite_objInits_autoRun")
call Vrx(function vFi,"s"+"__Meteorite_Allocation__allocInit_autoRun")
call Vrx(function vQi,"s"+"__Meteorite_initializer_Init_autoRun")
call Vrx(function vsi,"s"+"__Pengu_Allocation__allocInit_autoRun")
call Vrx(function vui,"s"+"__Pengu_initializer_Init_autoRun")
call Vrx(function vwi,"s"+"__Sebastian_objInits_autoRun")
call Vrx(function vWi,"s"+"__Sebastian_Allocation__allocInit_autoRun")
call Vrx(function vzi,"s"+"__Sebastian_initializer_Init_autoRun")
call Vrx(function vZi,"s"+"__Loading_Allocation__allocInit_autoRun")
return true
endfunction
function v0i takes nothing returns nothing
call AUx(Rd,Id,Ad,Nd)
endfunction
function v1i takes nothing returns nothing
set cd=Ayx(Rd,Id)
endfunction
function v2i takes nothing returns nothing
call Urx(Rd)
endfunction
function v3i takes nothing returns nothing
call cKo(Rd)
endfunction
function v4i takes nothing returns nothing
call Mto(Rd,m8v,m9v,Mvv)
endfunction
function v5i takes nothing returns nothing
call EDr(Rd,Id,Ad,Nd,npe)
endfunction
function v6i takes nothing returns nothing
call F9r(Rd,m8v,m9v,Mvv,Id)
endfunction
function v7i takes nothing returns nothing
call ZPr(Rd,Id,Ad,Nd,npe)
endfunction
function v8i takes nothing returns boolean
set bd=CreateTrigger()
call TriggerAddCondition(bd,Condition(function v0i))
set Cd=CreateTrigger()
call TriggerAddCondition(Cd,Condition(function v1i))
set xTv=CreateTrigger()
call TriggerAddCondition(xTv,Condition(function v2i))
set Ccv=CreateTrigger()
call TriggerAddCondition(Ccv,Condition(function v3i))
set Mev=CreateTrigger()
call TriggerAddCondition(Mev,Condition(function v4i))
set nPe=CreateTrigger()
call TriggerAddCondition(nPe,Condition(function v5i))
set FHe=CreateTrigger()
call TriggerAddCondition(FHe,Condition(function v6i))
set xQx=CreateTrigger()
call TriggerAddCondition(xQx,Condition(function v7i))
return true
endfunction
function main takes nothing returns nothing
local weathereffect we
local destructable d
local trigger t
local real life
local integer itemID
call Vrx(function Vex,"DebugExScope__init_debugInittest")
call Vrx(function Vix,"funcsTableInitFunctest")
call Vrx(function v8i,"evalsInitFunctest")
call Vrx(function Vax,"keyMacrosInitFunctest")
call Vrx(function v_i,"autoRunsFunctest")
set e=CreateTrigger()
call TriggerRegisterPlayerChatEvent(e,Player(0),"-a ",false)
call TriggerRegisterPlayerChatEvent(e,Player(0),"-r ",false)
call TriggerAddAction(e,function r0x)
set qv=CreateTrigger()
call TriggerRegisterPlayerChatEvent(qv,Player(0),"-get ",false)
call TriggerAddAction(qv,function r9x)
set sv=CreateTrigger()
call TriggerRegisterPlayerChatEvent(sv,Player(0),"-add ",false)
call TriggerRegisterPlayerChatEvent(sv,Player(0),"-rem ",false)
call TriggerAddAction(sv,function iex)
set tv=CreateTrigger()
call TriggerRegisterPlayerChatEvent(tv,Player(0),"say ",false)
call TriggerAddAction(tv,function aox)
set me=CreateTrigger()
call TriggerRegisterPlayerChatEvent(me,Player(0),"-sethp ",false)
call TriggerAddAction(me,function arx)
set Pe=CreateTrigger()
call TriggerRegisterPlayerChatEvent(Pe,Player(0),"-l ",false)
call TriggerAddAction(Pe,function aRx)
set Ye=CreateTrigger()
call TriggerRegisterPlayerChatEvent(Ye,Player(0),"-take",true)
call TriggerAddAction(Ye,function aCx)
set ax=CreateTrigger()
call TriggerRegisterPlayerChatEvent(ax,Player(0),"-rpgcam ",false)
call TriggerAddAction(ax,function adx)
call SetCameraBounds(-7680.+GetCameraMargin(CAMERA_MARGIN_LEFT),-7680.+GetCameraMargin(CAMERA_MARGIN_BOTTOM),7680.-GetCameraMargin(CAMERA_MARGIN_RIGHT),7680.-GetCameraMargin(CAMERA_MARGIN_TOP),-7680.+GetCameraMargin(CAMERA_MARGIN_LEFT),7680.-GetCameraMargin(CAMERA_MARGIN_TOP),7680.-GetCameraMargin(CAMERA_MARGIN_RIGHT),-7680.+GetCameraMargin(CAMERA_MARGIN_BOTTOM))
call SetDayNightModels("UI\\LightEnvTerrain.mdx","UI\\LightEnvUnit.mdx")
call NewSoundEnvironment("Default")
call SetMapMusic("Music",true,0)
set Ex=Rect(-4352.,-896.,4352.,3968.)
set Xx=Rect(5056.,-6720.,5184.,-6592.)
set Ox=Rect(5056.,-5696.,5184.,-5568.)
set Rx=Rect(704.,384.,1152.,832.)
set we=AddWeatherEffect(Rx,'FDgh')
call EnableWeatherEffect(we,true)
set Ix=Rect(-1152.,384.,-704.,832.)
set we=AddWeatherEffect(Ix,'FDgh')
call EnableWeatherEffect(we,true)
set Ax=Rect(-1920.,6112.,-1856.,6176.)
set Nx=Rect(-1568.,5824.,-1504.,5888.)
set bx=Rect(-1600.,6240.,-1536.,6304.)
set Bx=Rect(-2016.,5792.,-1952.,5856.)
set cx=Rect(-1792.,6208.,-1728.,6272.)
set Cx=Rect(-1152.,5792.,-1088.,5856.)
set Dx=Rect(-1152.,5952.,-1088.,6016.)
set fx=Rect(-1152.,5632.,-1088.,5696.)
set Fx=Rect(2208.,5408.,2272.,5472.)
set gx=Rect(2208.,4768.,2272.,4832.)
set Gx=Rect(1760.,4704.,1824.,4768.)
set hx=Rect(2656.,4704.,2720.,4768.)
set Hx=Rect(2912.,5952.,2976.,6016.)
set jx=Rect(2944.,5312.,3008.,5376.)
set Jx=Rect(2560.,5216.,2624.,5280.)
set kx=Rect(1856.,5216.,1920.,5280.)
set Kx=Rect(2016.,5344.,2080.,5408.)
set lx=Rect(2400.,5344.,2464.,5408.)
set Lx=Rect(3136.,5024.,3200.,5088.)
set mx=Rect(1120.,4672.,1184.,4736.)
set Mx=Rect(1696.,4864.,1760.,4928.)
set px=Rect(-704.,-6784.,32.,-5984.)
set Px=Rect(-640.,1152.,640.,2432.)
set qx=Rect(-320.,3424.,288.,4000.)
set Qx=Rect(-7648.,1600.,-7040.,2304.)
set sx=Rect(7008.,1344.,7616.,2240.)
set Sx=Rect(-768.,-224.,-704.,-160.)
set tx=Rect(704.,-224.,768.,-160.)
set Tx=Rect(1024.,3968.,3456.,5632.)
set ux=Rect(3136.,3360.,3296.,3424.)
set we=AddWeatherEffect(ux,'FDrl')
call EnableWeatherEffect(we,true)
set Ux=Rect(1088.,352.,1184.,448.)
set wx=Rect(-4992.,-1216.,-4576.,-832.)
set Wx=Rect(5312.,-2272.,6272.,-1568.)
set yx=Rect(-6400.,-2208.,-5536.,-1600.)
set Yx=Rect(-800.,5504.,-512.,5792.)
set zx=Rect(512.,5504.,800.,5792.)
set Zx=Rect(-1888.,6720.,-1312.,6976.)
set vo=Rect(2560.,3168.,2816.,3456.)
set eo=Rect(3808.,-6368.,4672.,-5792.)
set xo=Rect(5664.,3968.,5920.,4224.)
set oo=Rect(6592.,4704.,6816.,4928.)
set ro=Rect(6336.,2816.,6560.,3072.)
set io=Rect(1792.,-3328.,2048.,-3072.)
set ao=Rect(-3168.,-3200.,-2912.,-2944.)
set no=Rect(-3360.,-3136.,-3104.,-2880.)
set Vo=Rect(-6560.,800.,-6304.,1056.)
set Eo=Rect(-6912.,2144.,-6656.,2400.)
set Xo=Rect(-5824.,2336.,-5568.,2592.)
set Oo=Rect(-992.,-5408.,-736.,-5152.)
set Ro=Rect(160.,-6112.,416.,-5856.)
set Io=Rect(704.,-6944.,960.,-6688.)
set Ao=Rect(1408.,-6016.,1664.,-5760.)
set No=Rect(-7712.,160.,8192.,4000.)
set bo=Rect(-1216.,-8192.,1216.,160.)
set Bo=Rect(-3200.,-960.,-2784.,-576.)
set co=Rect(-1760.,-1600.,-1344.,-1216.)
set Co=Rect(1472.,-1664.,1888.,-1280.)
set do=Rect(3008.,-1184.,3424.,-800.)
set Do=Rect(4544.,-2848.,4960.,-2464.)
set fo=Rect(-2016.,5984.,-1952.,6048.)
set Fo=Rect(-1984.,5632.,-1920.,5696.)
set go=Rect(-384.,1408.,384.,2176.)
set Go=Rect(-4096.,1536.,-3712.,2048.)
set ho=Rect(3584.,1536.,3968.,2048.)
set Ho=Rect(-256.,-832.,256.,-448.)
set jo=Rect(-1024.,3968.,1024.,6336.)
set Jo=CreateCameraSetup()
call CameraSetupSetField(Jo,CAMERA_FIELD_ZOFFSET,.0,.0)
call CameraSetupSetField(Jo,CAMERA_FIELD_ROTATION,90.,.0)
call CameraSetupSetField(Jo,CAMERA_FIELD_ANGLE_OF_ATTACK,304.,.0)
call CameraSetupSetField(Jo,CAMERA_FIELD_TARGET_DISTANCE,2923.1,.0)
call CameraSetupSetField(Jo,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(Jo,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)
call CameraSetupSetField(Jo,CAMERA_FIELD_FARZ,5000.,.0)
call CameraSetupSetDestPosition(Jo,.0,1792.,.0)
set ko=CreateCameraSetup()
call CameraSetupSetField(ko,CAMERA_FIELD_ZOFFSET,.0,.0)
call CameraSetupSetField(ko,CAMERA_FIELD_ROTATION,247.8,.0)
call CameraSetupSetField(ko,CAMERA_FIELD_ANGLE_OF_ATTACK,332.4,.0)
call CameraSetupSetField(ko,CAMERA_FIELD_TARGET_DISTANCE,1127.,.0)
call CameraSetupSetField(ko,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(ko,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)
call CameraSetupSetField(ko,CAMERA_FIELD_FARZ,5000.,.0)
call CameraSetupSetDestPosition(ko,2190.2,4567.3,.0)
set Ko=CreateCameraSetup()
call CameraSetupSetField(Ko,CAMERA_FIELD_ZOFFSET,.0,.0)
call CameraSetupSetField(Ko,CAMERA_FIELD_ROTATION,128.9,.0)
call CameraSetupSetField(Ko,CAMERA_FIELD_ANGLE_OF_ATTACK,335.8,.0)
call CameraSetupSetField(Ko,CAMERA_FIELD_TARGET_DISTANCE,525.7,.0)
call CameraSetupSetField(Ko,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(Ko,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)
call CameraSetupSetField(Ko,CAMERA_FIELD_FARZ,5000.,.0)
call CameraSetupSetDestPosition(Ko,1801.1,5290.,.0)
set lo=CreateCameraSetup()
call CameraSetupSetField(lo,CAMERA_FIELD_ZOFFSET,.0,.0)
call CameraSetupSetField(lo,CAMERA_FIELD_ROTATION,99.3,.0)
call CameraSetupSetField(lo,CAMERA_FIELD_ANGLE_OF_ATTACK,328.4,.0)
call CameraSetupSetField(lo,CAMERA_FIELD_TARGET_DISTANCE,578.3,.0)
call CameraSetupSetField(lo,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(lo,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)
call CameraSetupSetField(lo,CAMERA_FIELD_FARZ,5000.,.0)
call CameraSetupSetDestPosition(lo,2041.2,5365.6,.0)
set Lo=CreateCameraSetup()
call CameraSetupSetField(Lo,CAMERA_FIELD_ZOFFSET,.0,.0)
call CameraSetupSetField(Lo,CAMERA_FIELD_ROTATION,100.6,.0)
call CameraSetupSetField(Lo,CAMERA_FIELD_ANGLE_OF_ATTACK,322.6,.0)
call CameraSetupSetField(Lo,CAMERA_FIELD_TARGET_DISTANCE,846.7,.0)
call CameraSetupSetField(Lo,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(Lo,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)
call CameraSetupSetField(Lo,CAMERA_FIELD_FARZ,5000.,.0)
call CameraSetupSetDestPosition(Lo,2089.8,5374.8,.0)
set mo=CreateCameraSetup()
call CameraSetupSetField(mo,CAMERA_FIELD_ZOFFSET,.0,.0)
call CameraSetupSetField(mo,CAMERA_FIELD_ROTATION,135.9,.0)
call CameraSetupSetField(mo,CAMERA_FIELD_ANGLE_OF_ATTACK,348.2,.0)
call CameraSetupSetField(mo,CAMERA_FIELD_TARGET_DISTANCE,636.2,.0)
call CameraSetupSetField(mo,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(mo,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)
call CameraSetupSetField(mo,CAMERA_FIELD_FARZ,5000.,.0)
call CameraSetupSetDestPosition(mo,2020.8,5276.,.0)
set Mo=CreateCameraSetup()
call CameraSetupSetField(Mo,CAMERA_FIELD_ZOFFSET,.0,.0)
call CameraSetupSetField(Mo,CAMERA_FIELD_ROTATION,97.4,.0)
call CameraSetupSetField(Mo,CAMERA_FIELD_ANGLE_OF_ATTACK,336.4,.0)
call CameraSetupSetField(Mo,CAMERA_FIELD_TARGET_DISTANCE,846.7,.0)
call CameraSetupSetField(Mo,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(Mo,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)
call CameraSetupSetField(Mo,CAMERA_FIELD_FARZ,5000.,.0)
call CameraSetupSetDestPosition(Mo,2106.9,5300.4,.0)
set po=CreateCameraSetup()
call CameraSetupSetField(po,CAMERA_FIELD_ZOFFSET,.0,.0)
call CameraSetupSetField(po,CAMERA_FIELD_ROTATION,94.8,.0)
call CameraSetupSetField(po,CAMERA_FIELD_ANGLE_OF_ATTACK,334.7,.0)
call CameraSetupSetField(po,CAMERA_FIELD_TARGET_DISTANCE,846.7,.0)
call CameraSetupSetField(po,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(po,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)
call CameraSetupSetField(po,CAMERA_FIELD_FARZ,5000.,.0)
call CameraSetupSetDestPosition(po,2172.6,5304.4,.0)
set Po=CreateCameraSetup()
call CameraSetupSetField(Po,CAMERA_FIELD_ZOFFSET,.0,.0)
call CameraSetupSetField(Po,CAMERA_FIELD_ROTATION,58.4,.0)
call CameraSetupSetField(Po,CAMERA_FIELD_ANGLE_OF_ATTACK,327.2,.0)
call CameraSetupSetField(Po,CAMERA_FIELD_TARGET_DISTANCE,846.7,.0)
call CameraSetupSetField(Po,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(Po,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)
call CameraSetupSetField(Po,CAMERA_FIELD_FARZ,5000.,.0)
call CameraSetupSetDestPosition(Po,3204.7,5098.2,.0)
set qo=CreateCameraSetup()
call CameraSetupSetField(qo,CAMERA_FIELD_ZOFFSET,.0,.0)
call CameraSetupSetField(qo,CAMERA_FIELD_ROTATION,69.2,.0)
call CameraSetupSetField(qo,CAMERA_FIELD_ANGLE_OF_ATTACK,325.5,.0)
call CameraSetupSetField(qo,CAMERA_FIELD_TARGET_DISTANCE,931.4,.0)
call CameraSetupSetField(qo,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(qo,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)
call CameraSetupSetField(qo,CAMERA_FIELD_FARZ,5000.,.0)
call CameraSetupSetDestPosition(qo,3078.6,5167.7,.0)
set Qo=CreateCameraSetup()
call CameraSetupSetField(Qo,CAMERA_FIELD_ZOFFSET,.0,.0)
call CameraSetupSetField(Qo,CAMERA_FIELD_ROTATION,45.8,.0)
call CameraSetupSetField(Qo,CAMERA_FIELD_ANGLE_OF_ATTACK,330.6,.0)
call CameraSetupSetField(Qo,CAMERA_FIELD_TARGET_DISTANCE,1239.7,.0)
call CameraSetupSetField(Qo,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(Qo,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)
call CameraSetupSetField(Qo,CAMERA_FIELD_FARZ,5000.,.0)
call CameraSetupSetDestPosition(Qo,2045.9,4927.9,.0)
set so=CreateCameraSetup()
call CameraSetupSetField(so,CAMERA_FIELD_ZOFFSET,.0,.0)
call CameraSetupSetField(so,CAMERA_FIELD_ROTATION,63.6,.0)
call CameraSetupSetField(so,CAMERA_FIELD_ANGLE_OF_ATTACK,291.5,.0)
call CameraSetupSetField(so,CAMERA_FIELD_TARGET_DISTANCE,3215.4,.0)
call CameraSetupSetField(so,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(so,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)
call CameraSetupSetField(so,CAMERA_FIELD_FARZ,5000.,.0)
call CameraSetupSetDestPosition(so,2138.4,4966.5,.0)
set So=CreateCameraSetup()
call CameraSetupSetField(So,CAMERA_FIELD_ZOFFSET,.0,.0)
call CameraSetupSetField(So,CAMERA_FIELD_ROTATION,90.,.0)
call CameraSetupSetField(So,CAMERA_FIELD_ANGLE_OF_ATTACK,304.,.0)
call CameraSetupSetField(So,CAMERA_FIELD_TARGET_DISTANCE,1650.,.0)
call CameraSetupSetField(So,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(So,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)
call CameraSetupSetField(So,CAMERA_FIELD_FARZ,5000.,.0)
call CameraSetupSetDestPosition(So,.0,.0,.0)
set to=CreateCameraSetup()
call CameraSetupSetField(to,CAMERA_FIELD_ZOFFSET,.0,.0)
call CameraSetupSetField(to,CAMERA_FIELD_ROTATION,309.3,.0)
call CameraSetupSetField(to,CAMERA_FIELD_ANGLE_OF_ATTACK,328.8,.0)
call CameraSetupSetField(to,CAMERA_FIELD_TARGET_DISTANCE,2657.3,.0)
call CameraSetupSetField(to,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(to,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)
call CameraSetupSetField(to,CAMERA_FIELD_FARZ,5000.,.0)
call CameraSetupSetDestPosition(to,-5540.3,-6175.3,.0)
set To=CreateCameraSetup()
call CameraSetupSetField(To,CAMERA_FIELD_ZOFFSET,.0,.0)
call CameraSetupSetField(To,CAMERA_FIELD_ROTATION,86.6,.0)
call CameraSetupSetField(To,CAMERA_FIELD_ANGLE_OF_ATTACK,270.,.0)
call CameraSetupSetField(To,CAMERA_FIELD_TARGET_DISTANCE,1996.5,.0)
call CameraSetupSetField(To,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(To,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)
call CameraSetupSetField(To,CAMERA_FIELD_FARZ,5000.,.0)
call CameraSetupSetDestPosition(To,24.,6408.5,.0)
set uo=CreateDestructable('C005',3328.,4992.,90.,1.,0)
set Uo=CreateDestructable('C00H',-3136.,-3584.,270.,1.,0)
set wo=CreateDestructable('C00H',-6976.,2560.,270.,1.,0)
set Wo=CreateDestructable('C00H',-3392.,-3520.,270.,1.,0)
set yo=CreateDestructable('C00H',-6720.,960.,270.,1.,0)
set Yo=CreateDestructable('C00H',-5888.,3008.,270.,1.,0)
set zo=CreateDestructable('C00H',-1216.,-5120.,270.,1.,0)
set Zo=CreateDestructable('C00H',1280.,-7104.,270.,1.,0)
set vr=CreateDestructable('C00H',1216.,-5632.,270.,1.,0)
set er=CreateDestructable('C00H',576.,-5632.,270.,1.,0)
set xr=CreateDestructable('C00H',1984.,-3840.,270.,1.,0)
set rr=CreateDestructable('C00H',6784.,5056.,270.,1.,0)
set ir=CreateDestructable('C00H',6720.,2816.,270.,1.,0)
set ar=CreateDestructable('C00H',5504.,4352.,270.,1.,0)
call CreateItem('IRun',3.2,4995.9)
call CreateItem('ISno',6004.3,2240.)
call CreateItem('ISno',-6400.1,1533.)
call CreateItem('ISno',4.6,-2574.6)
call aFx()
call agx()
call aGx()
call ahx()
call aHx(function nzx)
call ajx("init ok")
endfunction
