globalstrigger e=nullhashtable array ointeger array Vinteger array Einteger Xinteger O=-$7FFFFFFD
constant integer R=O+476
integer array Iinteger array Aconstant integer N=O+8192+290*8192integer array Bunit array C
integer array Dinteger f=0constant integer F=0-1integer G=Fstring array hinteger H=Fhashtable jinteger array Jinteger k=0integer K=500timer l=CreateTimer()integer L=-1
string M="<StructTable>"
hashtable Pconstant integer q=0+1constant integer Q=O+8192+288*8192integer S=0string T="<EventResponse>"constant integer U=1-1constant integer w=U
integer array Winteger Y=Uconstant integer Z=U-1integer array vv
boolean array ev
boolean array xv
integer ovtrigger rvinteger ivinteger array av
integer array nv
integer array Vv
integer array Ev
integer Xv=F
integer array Ov
integer array Rv
integer Ivinteger Avinteger Nvinteger bvboolexpr array Bvinteger array cv
integer Cv=0
trigger array dv
string Dv="<Trigger>"integer array fv
string array Fvstring array gvstring array Gvinteger array hv
integer array Hv
integer jvtrigger Jvinteger array kv
gamecache array Kvinteger array lv
constant integer Lv=$DFconstant integer mv=O+Lv
integer array Mv
integer pvinteger Pvtrigger qv=nullconstant integer Qv=-1trigger sv=nullconstant integer Sv=O+8192+28*8192trigger tv=nullinteger Tv=0
string uv="<GameMessage>"integer array Uv
integer wv=U
integer array Wv
boolean array yv
boolean array Yv
integer zvinteger Zv=F
integer ve=0
string ee="<Timer>"integer array xe
integer oe=U
integer array re
boolean array ie
boolean array ae
integer array ne
integer array Ve
integer Eeinteger Xetimer array Oeconstant integer Re=$F8integer array Ie
constant integer Ae=$F6constant integer Ne=O+8192+Ae*8192integer array be
string array Bereal array ceboolean array Ce
integer array de
boolean array De
integer array fe
string array Feinteger array ge
integer Geinteger he=F
integer array He
integer array je
integer array Je
integer array ke
integer Ke=F
integer array le
string array Letrigger me=nullreal array Meinteger petrigger Pe=nullinteger qe=w
integer array Qe
integer array se
constant integer Se=O+20
integer teinteger array Te
integer array ue
string array Ueinteger Weinteger array ye
trigger Ye=nullinteger array ze
boolean array Ze
player array vxinteger explayercolor array xx
playercolor array ox
integer rxconstant integer ix=O+402trigger ax=nullboolean nx=false
real Vxrect Ex=null
rect Xx=null
rect Ox=null
rect Rx=null
rect Ix=null
rect Ax=null
rect Nx=null
rect bx=null
rect Bx=null
rect cx=null
rect Cx=null
rect Dx=null
rect fx=null
rect Fx=null
rect gx=null
rect Gx=null
rect hx=null
rect Hx=null
rect jx=null
rect Jx=null
rect kx=null
rect Kx=null
rect lx=null
rect Lx=null
rect mx=null
rect Mx=null
rect px=null
rect Px=null
rect qx=null
rect Qx=null
rect sx=null
rect Sx=null
rect tx=null
rect Tx=null
rect ux=null
rect Ux=null
rect wx=null
rect Wx=null
rect yx=null
rect Yx=null
rect zx=null
rect Zx=null
rect vo=null
rect eo=null
rect xo=null
rect oo=null
rect ro=null
rect io=null
rect ao=null
rect no=null
rect Vo=null
rect Eo=null
rect Xo=null
rect Oo=null
rect Ro=null
rect Io=null
rect Ao=null
rect No=null
rect bo=null
rect Bo=null
rect co=null
rect Co=null
rect do=null
rect Do=null
rect fo=null
rect Fo=null
rect go=null
rect Go=null
rect ho=null
rect Ho=null
rect jo=null
camerasetup Jo=nullcamerasetup ko=nullcamerasetup Ko=nullcamerasetup lo=nullcamerasetup Lo=nullcamerasetup mo=nullcamerasetup Mo=nullcamerasetup po=nullcamerasetup Po=nullcamerasetup qo=nullcamerasetup Qo=nullcamerasetup so=nullcamerasetup So=nullcamerasetup to=nullcamerasetup To=nulldestructable uo=null
destructable Uo=null
destructable wo=null
destructable Wo=null
destructable yo=null
destructable Yo=null
destructable zo=null
destructable Zo=null
destructable vr=null
destructable er=null
destructable xr=null
destructable rr=null
destructable ir=null
destructable ar=null
integer nr=0
unit Vr=null
unit Er=null
unit Xr=null
unit Rr=null
unit Ir=null
unit Ar=null
unit Nr=null
unit br=null
unit Br=null
unit cr=null
unit Cr=null
unit dr=null
unit Dr=null
unit fr=null
unit Fr=null
unit gr=null
unit Gr=null
unit hr=null
unit Hr=null
unit jr=null
unit Jr=null
unit kr=null
unit Kr=null
triggeraction lr=nulltrigger Lr=CreateTrigger()boolean mr=false
real Mrsound pr
integer Pr=F
integer qr=0
integer array Qr
integer sr=U
integer array Sr
boolean array tr
boolean array Tr
integer urinteger Ur=0
integer array wr
string array Wrtrigger array yr
integer Yr=w
integer array zr
integer array Zr
integer vi=w
trigger array ei
integer array xi
string array oiinteger riinteger ii=0
string ai="<EffectLevel>"integer array ni
integer Vi=U
integer array Ei
boolean array Xi
boolean array Oi
integer Ristring array Iiinteger Ai=F
integer array Ni
integer array bi
integer Biinteger ciinteger Ci=F
trigger array di
integer array Di
string array fiinteger Fi=F
trigger array gi
integer array Gi
string array hiinteger Hi=F
trigger array ji
integer array Ji
string array kiinteger Kihashtable li=nullinteger Li=0
string mi="<ObjThread>"integer array Mi
integer pi=U
integer array Pi
boolean array qi
boolean array Qi
integer sistring array Siinteger ti=F
integer array Ti
integer array ui
timer Ui=nullboolean wi=trueinteger Wiinteger yiinteger Yihashtable zi=nullhashtable Zi=nullconstant integer va=O+8192+258*8192integer ea=F
trigger array xa
integer array oa
string array rainteger ia=F
trigger array aa
integer array na
string array Vainteger Ea=F
trigger array Xa
integer array Oa
string array Rainteger Ia=F
trigger array Aa
integer array Na
string array bainteger Ba=F
trigger array ca
integer array Ca
string array dainteger Da=F
trigger array fa
integer array Fa
string array gaconstant integer Ga=$A0constant integer ha=O+8192+Ga*8192constant integer Ha=O+8192+478*8192constant integer ja=$EBconstant integer Ja=O+8192+ja*8192constant integer ka=$EAconstant integer Ka=O+8192+ka*8192constant integer la=$D7constant integer La=O+8192+la*8192constant integer ma=O+8192+58*8192constant integer Ma=O+8192+66*8192constant integer pa=$E8constant integer Pa=O+8192+pa*8192constant integer qa=$9Econstant integer Qa=O+8192+qa*8192constant integer sa=O+8192+442*8192integer Sa=F
trigger array ta
integer array Ta
string array uainteger Ua=F
trigger array wa
integer array Wa
string array yainteger Ya=F
trigger array za
integer array Za
string array vninteger en=F
trigger array xn
integer array on
string array rninteger in=F
trigger array an
integer array nn
string array Vninteger En=F
trigger array Xn
integer array On
string array Rninteger In=F
trigger array An
integer array Nn
string array bninteger Bn=F
trigger array cn
integer array Cn
string array dninteger Dn=F
trigger array fn
integer array Fn
string array gninteger Gn=F
trigger array hn
integer array Hn
string array jninteger Jn=F
trigger array kn
integer array Kn
string array lninteger Ln=F
trigger array mn
integer array Mn
string array pninteger Pn=F
trigger array qn
integer array Qn
string array sninteger Sn=F
trigger array tn
integer array Tn
string array uninteger Un=F
trigger array wn
integer array Wn
string array yninteger Yn=F
trigger array zn
integer array Zn
string array vVinteger eV=F
trigger array xV
integer array oV
string array rVinteger iV=F
trigger array aV
integer array nV
string array VVinteger EV=F
trigger array XV
integer array OV
string array RVinteger IV=F
trigger array AV
integer array NV
string array bVinteger BV=F
trigger array cV
integer array CV
string array dVinteger DV=F
trigger array fV
integer array FV
string array gVinteger GV=F
trigger array hV
integer array HV
string array jVinteger JV=F
trigger array kV
integer array KV
string array lVinteger LV=F
trigger array mV
integer array MV
string array pVinteger PV=F
trigger array qV
integer array QV
string array sVinteger SV=F
trigger array tV
integer array TV
string array uVinteger UV=F
trigger array wV
integer array WV
string array yVinteger YV=F
trigger array zV
integer array ZV
string array vEreal eEreal xEreal oEreal rEreal iEreal aEreal nEreal VEinteger EEinteger XEtimer OE
trigger REinteger IEinteger AE=F
integer array NE
integer bEinteger array BE
integer array cE
integer array CE
integer array dE
integer DE=F
integer fE=0
integer FEinteger gE=0
integer GE=F
string array hEstring HE="<Queue>"integer jEstring JE="<StructInteger>"integer kEstring KE="<StructHex>"hashtable lE=nullinteger LEinteger mE=0
string ME="<LightningType>"integer array pE
integer PE=U
integer array qE
boolean array QE
boolean array sE
integer SEstring array tEinteger TEstring uE="<StructShapes>"integer array UE
integer wEconstant integer WE=$400
integer yEinteger array YE
integer zEstring ZE="<StructBoolean>"integer vXstring eX="<StructInteger>"integer xXstring oX="<StructReal>"
integer rXstring iX="<StructString>"integer aXstring nX="<GameCache>"integer VXstring EX="<StructBoolean>"integer XXstring OX="<StructInteger>"integer RXstring IX="<StructReal>"
integer AXstring NX="<StructString>"integer bXstring BX="<HashTable>"integer cXstring CX="<StructD2>"integer DXstring fX="<StructIntegerKeys>"integer FXstring gX="<StructStringKeys>"integer GXstring hX="<DataTableHead>"integer HXstring jX="<StructTable>"integer JXstring kX="<StructD2>"integer KXinteger lXstring LX="<StructIntegerKeys>"integer mXstring MX="<StructTable>"integer pXstring PX="<StructStringKeys>"integer qXstring QX="<StructNative>"integer sXstring SX="<DataTable>"integer tXinteger TX=0
integer array uX
integer UX=U
integer array wX
boolean array WX
boolean array yX
integer YX=0
integer array zX
integer ZX=U
integer array vO
boolean array eO
boolean array xO
integer oO=0
integer array rO
integer iO=U
integer array aO
boolean array nO
boolean array VO
integer array EO
integer XO=0
integer array OO
integer RO=U
integer array IO
boolean array AO
boolean array NO
integer array bO
integer array BO
integer array cO
integer array CO
integer array dO
integer array DO
hashtable array fOinteger FOstring gO="<Animation>"integer GOstring hO="<AttachPoint>"integer HOstring jO="<Attack>"
real array JOinteger kOstring KO="<StructAct>"integer lOstring LO="<StructAura>"
integer mOstring MO="<StructBool>"
integer pOstring PO="<StructBuff>"
integer qOstring QO="<StructDefenderSpawnType>"integer sOstring SO="<StructDestructable>"
integer tOstring TO="<StructDestructableType>"
integer uOstring UO="<StructDialog>"integer wOstring WO="<StructDummyUnit>"integer yOstring YO="<StructDynamic>"integer zOstring ZO="<StructEvent>"integer vRstring eR="<StructItem>"
integer xRstring oR="<StructItemType>"
integer rRstring iR="<StructLevel>"integer aRstring nR="<StructLightning>"integer VRstring ER="<StructMissile>"integer XRstring OR="<StructMissileCheckpoint>"integer RRstring IR="<StructOrder>"integer ARstring NR="<StructReal>"
integer bRstring BR="<StructSpawnType>"integer cRstring CR="<StructSpell>"integer dRstring DR="<StructSpellInstance>"integer fRstring FR="<StructSpot>"
integer gRstring GR="<StructString>"integer hRstring HR="<StructTile>"
integer jRstring JR="<StructUbersplat>"integer kRstring KR="<StructUnit>"
integer lRstring LR="<StructUnitEffect>"integer mRstring MR="<StructUnitMod>"integer pRstring PR="<StructUnitType>"
integer qRstring QR="<StructUser>"
integer sRstring SR="<EventPriority>"integer tRstring TR="<EventType>"integer uRstring UR="<StructId>"integer wRstring WR="<StructBoolean>"integer yRstring YR="<StructTable>"integer zRstring ZR="<StructInteger>"integer vIstring eI="<StructData>"
integer oIstring rI="<StructLimit>"integer iIstring aI="<Event>"integer nIinteger VI=0
integer array EI
integer XI=U
integer array OI
boolean array RI
boolean array II
integer AIinteger array NI
integer bIinteger BI=0
integer array cI
integer CI=U
integer array dI
boolean array DI
boolean array fI
string array FIinteger array gI
integer GIinteger hIinteger HIinteger jIinteger JIinteger kIinteger KIinteger lIinteger LIinteger mIinteger MIinteger pIinteger PIstring qI="<CharacterSpeech>"integer QI=0
string sI="<CommandHeader>"integer array SI
integer tI=U
integer array TI
boolean array uI
boolean array UI
integer wIinteger WI=0
integer array YI
integer zI=U
integer array ZI
boolean array vA
boolean array eA
integer array xA
integer array oA
integer array rA
integer array iA
integer array aA
constant integer nA=$Econstant integer VA=O+8192+nA*8192boolean array EA
integer array XA
limitop array OA
integer RA=0
integer array IA
integer AA=U
integer array NA
boolean array bA
boolean array BA
integer array cA
integer CAtrigger array dA
trigger array DA
constant integer fA=$FEconstant integer FA=O+fA
integer array gA
constant integer GA=$FAconstant integer hA=O+8192+GA*8192boolexpr HAstring array jAconstant integer JA=O+16
constant integer kA=8190+1integer KAstring array lAstring array LAconstant integer mA=O+22
integer array MA
integer pAconstant integer PA=$FCconstant integer qA=O+PA
integer QAconstant integer sA=O+34
integer SA=0
string tA="<BoolExpr>"integer array TA
integer uA=U
integer array UA
boolean array wA
boolean array WA
integer yAconstant integer YA=-1integer zA=w
integer array ZA
boolean array vN
real array eNreal array xNreal array oNstring array rNtexttag array iN
location array aNinteger nNconstant integer VN=$F0constant integer EN=O+VN
integer XN=0
integer ON=0
string RN="<TextTag>"integer array IN
integer AN=U
integer array NN
boolean array bN
boolean array BN
integer cNinteger array CN
real array dNstring array DNreal array fNconstant real FN=(2*1.)*1./ 32integer array gN
boolean array GN
real array hNinteger HN=F
integer array jN
integer array JN
integer kNboolean array KN
integer array lN
integer array LN
integer mN=F
integer MNinteger array pN
boolean array PN
integer array qN
integer array QN
integer sN=F
integer SNinteger array tN
integer array TN
integer array uN
integer UN=F
integer wNreal array WNconstant real yN=(2*1.)*1./ 32real array YNinteger array zN
real array ZNreal array vbreal array ebstring array xbstring array obreal rb=.023
integer ibstring ab="<ClearSpawns>"integer array nb
integer array Vb
integer Ebconstant integer Xb=$86constant integer Ob=O+8192+Xb*8192integer Rbinteger Ibinteger Abstring Nb="<CommandAutoCast>"integer bbinteger array Bb
integer array cb
constant integer Cb=O+8192+401*8192integer db=kAinteger Db=F
integer fb=0
string Fb="<Group>"integer array gb
integer Gb=U
integer array hb
boolean array Hb
boolean array jb
integer Jbgroup array kbinteger array Kb
integer array lb
boolean array Lb
integer array mb
integer Mbinteger array pb
integer array Pb
integer array qb
integer Qbinteger array sb
integer Sbstring tb="<CommandBuff>"constant integer Tb=O+56
integer ubinteger Ubreal wbconstant integer Wb=O+8192+308*8192integer array yb
constant integer Yb=O+8192+310*8192integer array zb
constant integer Zb=O+314constant integer vB=O+8192+306*8192integer eBinteger xBconstant integer oB=O+304boolean array rB
integer array iB
integer array aB
integer array nB
integer VBboolean array EB
effect array XBeffect array OBinteger array RB
integer array IB
integer AB=F
integer array NB
integer array bB
string BB="<UnitEffect>"
boolean array cB
integer array CB
integer dBconstant integer DB=O+312boolean array fB
sound array FBinteger array gB
integer array GB
boolean array hB
boolean array HB
integer array jB
string JB="<Sound>"boolean array kB
integer KBboolean array lB
integer array LB
integer array mB
integer array MB
string pB="<UnitSound>"boolean array PB
integer qBconstant integer QB=O+425integer array sB
integer array SB
integer array tB
boolean array TB
integer array uB
integer array UB
string wB="<BuffRef>"boolean array WB
integer yBinteger array YB
integer array zB
constant integer ZB=O+8192+54*8192constant integer vc=O+8192+318*8192integer array ec
integer array xc
constant integer oc=O+8192+409*8192boolean array rc
integer array ic
constant integer ac=O+8192+410*8192constant integer nc=O+8192+411*8192real array Vcconstant integer Ec=O+8192+412*8192constant integer Xc=O+8192+413*8192constant integer Oc=O+419constant integer Rc=$Cconstant integer Ic=O+Rc
constant integer Ac=O+415constant integer Nc=O+420constant integer bc=O+416constant integer Bc=O+421constant integer cc=O+417constant integer Cc=O+422constant integer dc=O+418boolean array Dc
constant integer fc=O+8192+423*8192integer array Fc
integer array Gc
integer array hc
integer array Hc
integer jcinteger array Jc
constant integer kc=O+8192+46*8192constant integer Kc=O+316integer array lc
integer array Lc
integer array mc
integer Mcboolean array pc
boolean array Pc
integer array qc
integer Qcboolean array sc
constant integer Sc=O+8192+42*8192integer tc=0
integer Tc=U
string array ucboolean array Uc
integer array wc
string array Wcinteger array yc
constant integer Yc=O+8192+'n'*8192integer zcinteger Zcinteger vCinteger eCconstant integer xC=O+8192+'j'*8192integer oCconstant integer rC=O+8192+38*8192constant integer iC=O+8192+40*8192constant integer aC=O+8192+44*8192integer nC=0
integer VC=U
boolean array EC
integer XC=0
integer OC=U
string array RCstring array ICinteger array AC
integer array NC
integer array bC
integer array BC
real array cCreal array CCreal array dCreal array DCinteger array fC
integer array FC
real array gCreal array GCreal array hCreal array HCreal array jCreal array JCboolean array kC
boolean array KC
boolean array lC
boolean array LC
boolean array mC
real array MCreal array pCreal array PCreal array qCreal array QCreal array sCreal array SCreal array tCreal array TCreal array uCreal array UCreal array wCreal array WCreal array yCreal array YCreal array zCreal array ZCreal array vdstring array edreal array xdreal od=1.constant integer rd=O+8192+48*8192integer ad=0
integer nd=U
boolean array Vd
integer array Ed
integer array Xd
integer Odinteger Rdinteger Idinteger Adtrigger Ndinteger bdboolean Bdtrigger cdconstant integer Cd=O+298integer dd=0
string Dd="<StructTimed>"integer array fd
integer Fd=U
integer array gd
boolean array Gd
boolean array hd
integer Hdinteger array jd
integer array Jd
integer array kd
constant integer Kd=O+8192+296*8192integer array ld
integer array Ld
integer array md
integer array Md
string pd="<StructCountdown>"boolean array Pd
integer qdconstant integer Qd=O+8192+294*8192integer sdinteger array Sd
constant integer td=O+8192+300*8192integer Tdinteger udboolean array Ud
constant real wd=-1.
integer Wdboolean array yd
integer Yd=0
integer zd=U
boolean array Zd
integer array vD
boolean array eD
integer array xD
string array oDinteger rD=F
integer array iD
integer aDstring nD="<CommandCreateQuake>"
integer VD=0
string ED="<StructSeismic>"integer array XD
integer OD=U
integer array RD
boolean array ID
boolean array AD
integer NDinteger array bD
real array BDreal array cDreal array CDconstant real dD=(4*1.)*1./ 32real array DDreal array fDinteger array FD
integer gD=F
integer GD=0
string hD="<Force>"integer array HD
integer jD=U
integer array JD
boolean array kD
boolean array KD
integer lDforce array LDinteger array mD
real array MDreal array pDreal array PDinteger array qD
integer array QD
integer sD=F
integer SDtrigger tDstring TD="<User>"real array uDreal array UDconstant real wD=(2*1.)*1./ 32integer array WD
integer yD=F
integer array YD
integer ZDreal array vfconstant real ef=(1*1.)*1./ 32real array xfinteger array of
boolean array rf
integer array af
integer array nf
integer Vf=F
integer Efboolean array Xf
boolean array Of
boolean array Rf
boolean array If
code Afreal array Nfreal array bfreal array Bfconstant real cf=2*3.141592654constant real Cf=cfinteger dfstring Df="<CommandCreateUnit>"constant integer ff=O+440real Ffreal gfreal Gfinteger hfinteger Hfinteger jfconstant real Jf=1.5*3.141592654
real kf=Jfinteger Kfstring lf="<CommandDebug>"integer Lfstring mf="<CommandExp>"
real Mfreal array pfinteger Pfstring qf="<CommandHeroAttribute>"string Qfreal sfreal array Sfinteger array tf
integer array Tf
real array ufreal array Ufreal array wfinteger Wf=0
real array yfreal array Yfreal array zfreal array Zfreal array vFreal array eFreal array xFreal array oFreal array rFreal array iFreal array aFinteger nF=1
real array VFreal array EFreal array XFboolean array OF
integer RFinteger IF=6
integer array AF
integer NF=6
integer array bF
integer array BF
integer cF=w
real array CFreal array dFreal array DFreal array fFreal array FFreal array gFinteger GFinteger array hF
integer HF=F
integer array jF
integer JFinteger array kF
integer KF=F
real array lFreal array LFinteger mFreal array MFreal array pFreal PF=.2real array qFinteger QF=256integer sF='TM73'integer array SF
integer tF=256integer TF='SM73'integer array uF
real array UFreal array wFinteger WF=$Freal array yFreal array YFreal array zFreal array ZFreal array vginteger eg=2
real array xgreal array ogreal array rgboolean array ig
integer aginteger ng=6
integer array Vg
integer Eg=6
integer array Xg
integer array Og
integer Rg=w
real array Igreal array Agreal array Ngreal array bgreal array Bgreal array cgboolean array Cg
integer dginteger Dginteger fginteger Fg=7
integer array gg
item array Gginteger hg=7
item array Hginteger jg=w
real array Jgreal array kgreal array Kgreal array lgreal array Lgreal array mgreal array Mgboolean array pg
integer Pginteger qg=6
integer array Qg
integer sg=6
integer array Sg
integer array tg
integer Tg=w
real array ugreal Ug=.5real array wgreal array Wginteger yginteger array Yg
integer zg=F
integer array Zg
integer vGinteger array eG
integer xG=F
real array oGreal array rGboolean array iG
real array aGreal array nGconstant real VG=2*1./ 1.5*(.25+SquareRoot(.25*(.25-.0)))constant real EG=(1*1.)*1./ 32real array XGconstant real OG=-.5*VG*VG*1./ .25real array RGreal array IGreal array AGreal array NGconstant real bG=2*1./ 1.5*(100.+SquareRoot(100.*(100.-25.)))real array BGconstant real cG=-.5*bG*bG*1./ 100.constant integer CG=O+8192+336*8192constant real dG=.405+1.
integer DG=w
integer array fG
integer FGinteger gGinteger GGreal array hGreal array HGreal jG=.25real array JGinteger kG=256integer KG='TL73'integer array lG
integer LG=256integer mG='SL73'integer array MG
real array pGreal array PGinteger qG=25real array QGreal array sGreal array SGboolean array tG
integer TGinteger uG=6
integer array UG
integer wG=6
integer array WG
integer array yG
integer YG=w
real array zGreal array ZGinteger vhstring eh="<CommandKillUnit>"integer xhstring oh="<CommandRefreshAbility>"integer rhinteger ihconstant integer ah=O+8192+282*8192boolean array nh
boolean array Vh
boolean array Eh
integer array Xh
integer array Oh
integer array Rh
integer array Ih
integer array Ah
constant real Nh=3.141592654*1./ 180.integer bhinteger Bhinteger chinteger Chinteger dhconstant integer Dh=O+8192+322*8192integer array fh
integer array Fh
item array ghconstant integer Gh=$92constant integer hh=O+Gh
integer array Hh
constant integer jh=O+8192+389*8192integer Jh=F
integer array kh
integer array Kh
integer array lh
constant integer Lh=$8Cconstant integer mh=O+8192+Lh*8192integer Mhboolean array ph
integer array Ph
integer array qh
integer array Qh
integer array sh
integer Shconstant integer Th=$8Econstant integer uh=O+8192+Th*8192integer array Uh
integer array wh
integer array Wh
real array yhreal array Yhconstant integer zh=$90constant integer Zh=O+8192+zh*8192integer vH=0
string eH="<SpellInstance>"integer array xH
integer oH=U
integer array rH
boolean array iH
boolean array aH
integer nHreal array VHinteger array EH
integer array XH
real array OHreal array RHinteger array IH
integer array AH
real array NHinteger array bH
boolean array BH
integer array cH
constant integer CH=$E4constant integer dH=O+8192+CH*8192integer DHreal fHinteger FHconstant integer gH=$E5constant integer GH=O+8192+gH*8192integer hH=0
string HH="<StructCooldown>"
integer array jH
integer JH=U
integer array kH
boolean array KH
boolean array lH
integer LHinteger array mH
integer array MH
integer array pH
constant integer PH=O+8192+280*8192integer qHinteger QHinteger sHconstant integer SH=$E6constant integer tH=O+8192+SH*8192string array THinteger uHreal array UHinteger array wH
integer array WH
real array yHreal array YHinteger array zH
boolean ZH=false
integer vjinteger array ej
integer array xj
boolean array oj
integer array rj
integer array ij
string aj="<OrderInstance>"boolean array nj
integer Vjinteger Ejinteger Xjconstant real Oj=1.*1./ 64constant real Rj=Oj*16constant integer Ij=$D2constant integer Aj=O+Ij
string Nj="<UnitList>"string array bjinteger Bjinteger array cj
integer Cjinteger array dj
integer array Dj
real array fjreal array Fjinteger gjinteger array Gj
integer array hj
integer array Hj
integer jjinteger Jjinteger kjboolean Kj=false
constant integer lj=O+18
integer Lj=-1integer array mj
integer array Mj
integer array pj
integer Pjinteger qjstring Qj="<CommandRemoveUnit>"integer sjstring Sj="<CommandScaleUnit>"real tjreal Tjreal array ujreal array Ujinteger wjinteger array Wj
integer yj=-5real Yj=.02integer zj=0
integer Zj=500unit array vJinteger eJconstant real xJ=-8192constant real oJ=8192string rJ="<StructX>"real array iJconstant real aJ=-8192constant real nJ=8192string VJ="<StructY>"real array EJinteger XJinteger OJconstant real RJ=(2*1.)*1./ 32integer IJ=0
string AJ="<StructTimed>"integer array NJ
integer bJ=U
integer array BJ
boolean array cJ
boolean array CJ
integer dJinteger array DJ
integer array fJ
real array FJconstant integer gJ=O+8192+352*8192integer GJinteger hJ=F
integer array HJ
integer array jJ
integer JJinteger kJstring KJ="<CommandSpell>"integer lJinteger LJinteger mJ=F
integer array MJ
integer pJstring PJ="<CommandSwift>"real qJinteger QJinteger sJinteger array SJ
integer array tJ
integer TJstring uJ="<CommandTest>"integer UJstring wJ="<CommandVertexColorUnit>"
real WJreal yJreal YJreal zJreal ZJreal array vkreal array ekreal array xkreal array okboolean array rk
constant integer ik=$80constant integer ak=O+8192+366*8192constant integer nk=O+8192+368*8192constant integer Vk=O+8192+370*8192constant integer Ek=O+8192+372*8192constant real Xk=Oj*16integer Ok=0
string Rk="<StructTimed>"integer array Ik
integer Ak=U
integer array Nk
boolean array bk
boolean array Bk
integer ckreal array Ckreal array dkreal array Dkreal array fkinteger array Fk
integer array gk
constant integer Gk=O+8192+360*8192integer hkinteger Hk=F
integer array jk
integer array Jk
integer kkinteger Kkstring lk="<MoveUnit>"real Lkreal mkstring Mk="<StructX>"string pk="<StructY>"integer Pkstring qk="<PingSpawns>"
boolean Qkinteger skstring Sk="<RequestEvent>"integer tkstring Tk="<RequestKeyMacro>"integer ukstring Uk="<RequestTimers>"integer array wk
integer Wk=F
integer ykstring Yk="<SetDmgTest>"
real zkinteger Zkstring vK="<SetVar>"
integer eKstring xK="<StructVotes>"integer oKstring rK="<VoteHost>"integer iKboolean aK=false
boolean nK=false
integer VKinteger EKstring XK="<AIAutoCast>"
integer OKconstant integer RK=O+8192+272*8192constant integer IK=O+270integer AK=w
integer array NK
integer array bK
constant integer BK=O+8192+32*8192integer cKconstant integer CK=O+'v'integer dKinteger DKinteger fKinteger FKinteger gKinteger GKinteger hKstring HK="<StructId>"integer jKstring JK="<StructBoolean>"integer kKstring KK="<StructTable>"integer lKstring LK="<StructInteger>"integer mKstring MK="<StructTable>"integer pKstring PK="<StructReal>"
integer qKstring QK="<StructTable>"integer sKstring SK="<StructString>"integer tKstring TK="<StructData>"
integer uKstring UK="<StructEvent>"integer wKstring WK="<StructTargetEffects>"integer yKstring YK="<StructLoopSounds>"integer zKstring ZK="<StructVariants>"
integer vlstring xl="<StructUnitMods>"
integer olstring rl="<StructUnitModSets>"integer ilstring al="<Buff>"integer nlstring Vl="<StructTimed>"integer Elstring Xl="<CameraField>"integer Olstring Rl="<StructEye>"integer Ilstring Al="<StructTarget>"integer Nlstring bl="<StructPanTimedViaBounds>"integer Blstring cl="<StructShake>"integer Clstring dl="<Camera>"
integer Dl=-1integer array fl
integer array Fl
integer glinteger Glboolean hl=false
integer Hl=F
integer array jl
string array Jlstring array klstring array Klinteger llinteger Llinteger ml=0
integer array Ml
integer pl=U
integer array Pl
boolean array ql
boolean array Ql
camerafield array sl
integer Slinteger tlinteger Tlinteger ulinteger Ulinteger wlinteger Wlstring yl="<StructId>"integer Ylstring zl="<StructBoolean>"integer Zlstring vL="<StructTable>"integer eLstring xL="<StructInteger>"integer oLstring rL="<StructTable>"integer iLstring aL="<StructReal>"
integer nLstring VL="<StructData>"
integer ELstring XL="<StructEvent>"integer OLstring RL="<StructPreload>"integer ILinteger AL=0
string NL="<DestructableType>"integer array bL
integer BL=U
integer array cL
boolean array CL
boolean array dL
integer array DL
integer array fL
integer FLinteger array gL
constant integer GL=O+64
string array hLinteger array HL
constant integer jL=O+8192+62*8192integer JLinteger kLstring KL="<StructId>"integer lLstring LL="<StructBoolean>"integer mLstring ML="<StructTable>"integer pLstring PL="<StructInteger>"integer qLstring QL="<StructTable>"integer sLstring SL="<StructReal>"
integer tLstring TL="<StructData>"
integer uLstring UL="<StructNative>"integer wLstring WL="<StructEvent>"integer yLstring YL="<StructType>"
integer zLstring ZL="<StructTimedLife>"integer vmstring em="<StructInRange>"integer xmstring om="<StructEnum>"
integer rmstring im="<StructLife>"
integer amstring nm="<Destructable>"integer Vminteger Eminteger Xminteger Ominteger array Rm
integer array Im
integer array Am
constant integer Nm=O+72
rect array bminteger Bminteger cm=0
integer array Cm
integer dm=U
integer array Dm
boolean array fm
boolean array Fm
integer array gm
destructable array Gmreal array hmreal array Hmreal array jmconstant integer Jm=O+8192+68*8192integer array km
integer array Km
integer lminteger Lm=0
string mm="<Rectangle>"integer array Mm
integer pm=U
integer array Pm
boolean array qm
boolean array Qm
integer array sm
integer Smreal array tmreal array Tmreal array umreal array Umreal array wmreal array Wminteger array ym
constant integer Ym=$D4constant integer zm=O+8192+Ym*8192integer Zminteger vMconstant integer eM=O+70
integer array xM
integer array oM
boolean array rM
integer array iM
integer aMstring nM="<StructId>"integer VMstring EM="<StructTable>"integer XMstring OM="<StructBoolean>"integer RMstring IM="<StructInteger>"integer AMstring NM="<StructReal>"
integer bMstring BM="<StructData>"
integer cMstring CM="<StructNative>"integer dMstring DM="<StructEvent>"integer fMstring FM="<DialogButton>"integer gMstring GM="<StructId>"integer hMstring HM="<StructTable>"integer jMstring JM="<StructBoolean>"integer kMstring KM="<StructInteger>"integer lMstring LM="<StructReal>"
integer mMstring MM="<StructData>"
integer pMstring PM="<StructNative>"integer qMstring QM="<StructEvent>"integer sMstring SM="<StructButtons>"integer tMstring TM="<Dialog>"
integer uMinteger UMconstant integer wM=O+78
constant integer WM=O+86
constant integer yM=O+8192+94*8192integer array YM
integer array zM
constant integer ZM=O+88
constant integer vp=O+8192+90*8192dialog array epinteger array xp
multiboard array opinteger array rp
integer array ip
integer array ap
integer npstring Vp="<StructDestroyTimed>"
integer Epstring Xp="<SpotEffectWithSize>"
integer Opstring Rp="<DummyUnitEffect>"integer Ipstring Ap="<StructId>"integer Npstring bp="<StructTable>"integer Bpstring cp="<StructBoolean>"integer Cpstring dp="<StructInteger>"integer Dpstring fp="<StructData>"
integer Fpstring gp="<StructEvent>"integer Gpstring hp="<StructDestroyTimed>"
integer Hpstring jp="<SpotEffect>"
integer Jpstring kp="<StructId>"integer Kpstring lp="<StructTable>"integer Lpstring mp="<StructBoolean>"integer Mpstring pp="<StructInteger>"integer Ppstring qp="<StructData>"
integer Qpstring sp="<StructEvent>"integer Spstring tp="<StructDestroyTimed>"
integer Tpstring up="<Effect>"
integer Upinteger wpinteger array Wp
integer array yp
integer array Yp
constant integer zp=O+8192+98*8192integer array Zp
effect array vPinteger array eP
integer array xP
boolean array oP
integer array rP
integer iPinteger aPinteger nPinteger VPinteger EPinteger XPinteger OPinteger RPstring IP="<StructD2>"integer APstring NP="<StructIntegerKeys>"integer bPstring BP="<StructTable>"integer cPstring CP="<StructD2>"integer dPstring DP="<StructTable>"integer fPstring FP="<StructIntegerKeys>"integer gPinteger GPinteger hPinteger HPinteger jPinteger JPinteger kPinteger KPinteger lPinteger LPstring mP="<EventPair>"integer MPstring pP="<StructId>"integer PPstring qP="<StructBoolean>"integer QPstring sP="<StructTable>"integer SPstring tP="<StructInteger>"integer TPstring uP="<StructData>"
integer UPstring wP="<StructRemainingEventsAmount>"integer WPstring yP="<StructEvents>"integer YPstring zP="<StructSubjects>"
integer ZPstring vq="<StructSubjectsA>"integer eqstring xq="<StructPeriodic>"
integer oqstring rq="<StructPairs>"integer iqstring aq="<EventCombination>"integer nqstring Vq="<Announcement>"integer Eqstring Xq="<CineFilter>"
integer Oqstring Rq="<StructFloatState>"integer Iqstring Aq="<StructTimeOfDay>"real Nqinteger bqinteger Bqboolean cq=false
integer Cqinteger dqinteger Dq=0
string fq="<PingColor>"integer array Fq
integer gq=U
integer array Gq
boolean array hq
boolean array Hq
integer jqboolean array Jq
string array kqinteger array Kq
integer array lq
integer array Lq
integer array mq
integer Mq=F
integer array pq
integer Pqinteger qqinteger Qqinteger sqinteger Sqinteger tqstring Tq="<Ping>"integer uqstring Uq="<StructRefs>"
integer wqstring Wq="<StructCountUnits>"integer yqstring Yq="<StructNearestUnit>"integer zqstring Zq="<StructOrder>"integer vQstring eQ="<StructRandomUnit>"integer xQstring oQ="<StructWithCollision>"integer rQstring iQ="<StructInLine>"integer aQstring nQ="<StructWithCollision>"integer VQstring EQ="<StructInRange>"integer XQstring OQ="<StructWithCollision>"integer RQstring IQ="<StructInRect>"integer AQstring NQ="<StructEnumUnits>"integer bQinteger BQinteger cQreal CQreal dQreal DQreal fQreal FQreal gQinteger GQinteger hQreal HQreal jQreal JQreal kQreal KQreal lQinteger LQinteger mQinteger MQreal pQreal PQreal qQinteger QQreal sQinteger SQinteger tQreal TQreal uQreal UQreal wQinteger WQinteger yQinteger YQinteger zQ=0
integer array ZQ
integer vs=U
integer array es
boolean array xs
boolean array os
integer rsconstant integer is=$84constant integer as=O+8192+is*8192integer array ns
boolean array Vs
integer Esstring Xs="<StructId>"integer Osstring Rs="<StructTable>"integer Isstring As="<StructInteger>"integer Nsstring bs="<StructData>"
integer Bsstring cs="<StructRefs>"
integer Csstring ds="<StructId>"integer Dsstring fs="<StructTable>"integer Fsstring gs="<StructInteger>"integer Gsstring hs="<StructData>"
integer Hsstring js="<ItemClass>"integer Jsstring ks="<StructId>"integer Ksstring ls="<StructBoolean>"integer Lsstring ms="<StructTable>"integer Msstring ps="<StructInteger>"integer Psstring qs="<StructData>"
integer Qsstring ss="<StructNative>"integer Ssstring ts="<StructEvent>"integer Tsstring us="<StructClasses>"integer Usstring ws="<StructType>"
integer Wsstring ys="<StructAbilities>"integer Ysstring zs="<StructChargesAmount>"integer Zsstring vS="<StructPosition>"
integer eSstring xS="<Item>"integer oS=0
integer array rS
integer iS=U
integer array aS
boolean array nS
boolean array VS
integer array ES
integer XS=F
integer array OS
integer array RS
integer array IS
constant integer AS=$88constant integer NS=O+8192+AS*8192integer bSinteger BSinteger cSinteger CSinteger dS=0
integer array DS
integer fS=U
integer array FS
boolean array gS
boolean array GS
integer array hS
integer array HS
constant integer jS=$8Aconstant integer JS=O+8192+jS*8192constant integer kS=$9Cconstant integer KS=O+kS
integer array lS
constant integer LS=$96constant integer mS=O+8192+LS*8192integer MSconstant integer pS=$98constant integer PS=O+8192+pS*8192integer array qS
integer QSinteger array sS
constant integer SS=$9Aconstant integer tS=O+8192+SS*8192integer TSinteger uSstring US="<StructId>"integer wSstring WS="<StructBoolean>"integer ySstring YS="<StructTable>"integer zSstring ZS="<StructInteger>"integer vtstring et="<StructData>"
integer xtstring ot="<StructEvent>"integer rtstring it="<StructAbilities>"integer atstring nt="<StructChargesAmount>"integer Vtstring Et="<StructClasses>"integer Xtstring Ot="<StructPreload>"integer Rtstring It="<StructUsageGoldCost>"integer Atstring Nt="<ItemType>"integer btstring Bt="<StructId>"integer ctstring Ct="<StructTable>"integer dtstring Dt="<StructInteger>"integer ftstring Ft="<StructData>"
integer gtstring Gt="<StructEvent>"integer htstring Ht="<StructRed>"integer jtstring Jt="<StructGreen>"integer ktstring Kt="<StructBlue>"
integer ltstring Lt="<StructAlpha>"integer mtstring Mt="<StructTimed>"integer ptstring Pt="<StructColor>"integer qtstring Qt="<StructFromDummyUnitToUnit>"integer Ststring tt="<StructFromSpotToDummyUnit>"integer Ttstring ut="<StructFromSpotToSpot>"integer Utstring wt="<StructFromSpotToUnit>"integer Wtstring yt="<StructFromUnitToUnit>"integer Ytstring zt="<StructDestroyTimed>"
integer Ztstring vT="<Lightning>"integer eTinteger xTinteger oTinteger array rT
integer array iT
integer array aT
constant integer nT=$A6constant integer VT=O+8192+nT*8192integer array ET
integer array XT
boolean array OT
integer array RT
integer array IT
integer array AT
integer NT=F
integer bTinteger array BT
integer cTconstant integer CT=$BAconstant integer dT=O+CT
integer array DT
integer array fT
boolean array FT
integer array gT
integer GTconstant integer hT=$A8constant integer HT=O+8192+hT*8192integer array jT
integer array JT
boolean array kT
constant integer KT=$AAconstant integer lT=O+8192+KT*8192integer LTinteger mTinteger array MT
boolean array pT
integer array PT
integer array qT
integer QT=F
integer sTinteger array ST
integer array tT
integer array TT
boolean array uT
real array UTreal array wTreal array WTreal array yTlightning array YTconstant real zT=Oj*4integer ZT=0
integer vu=U
boolean array eu
real array xureal array oureal array rureal array iuinteger array au
real nu=.35integer array Vu
integer array Eu
boolean array Xu
real array Oureal array Rureal array Iureal array Aureal array Nureal array bureal array Bureal array cureal array Cuinteger duconstant integer Du=$ACconstant integer fu=O+8192+Du*8192integer array Fu
integer array gu
boolean array Gu
constant integer hu=$AEconstant integer Hu=O+8192+hu*8192integer juinteger array Ju
integer array ku
integer Ku=F
integer luinteger array Lu
integer array mu
integer Muconstant integer pu=$B0constant integer Pu=O+8192+pu*8192integer array qu
integer array Qu
boolean array su
integer Suconstant integer tu=$B2constant integer Tu=O+8192+tu*8192integer array uu
integer array Uu
boolean array wu
constant integer Wu=$B4constant integer yu=O+8192+Wu*8192integer Yuinteger array zu
integer array Zu
integer vU=F
integer eUinteger array xU
integer array oU
integer rUconstant integer iU=$B6constant integer aU=O+iU
integer array nU
integer array VU
boolean array EU
constant integer XU=$B8constant integer OU=O+8192+XU*8192integer RUinteger array IU
integer array AU
integer NU=F
integer bUinteger array BU
integer array cU
integer array CU
real array dUreal array DUreal array fUreal array FUreal array gUreal array GUinteger hUstring HU="<LoadingEx>"integer jUstring JU="<AICastSpell>"integer kUconstant integer KU=$BEconstant integer lU=O+8192+KU*8192integer LUinteger mUinteger MUinteger pUinteger PU=0
integer array qU
integer QU=U
integer array sU
boolean array SU
boolean array tU
constant integer TU=O+8192+36*8192boolean array uU
integer array UU
string wU="<AILetOff>"integer WUinteger yU=0
string YU="<UnitModSet>"
integer array zU
integer ZU=U
integer array vw
boolean array ew
boolean array xw
integer owconstant integer rw=O+8192+408*8192integer iwinteger awinteger nwinteger Vwinteger Ewinteger Xwinteger Owinteger Rwinteger array Iw
constant integer Aw=$C0constant integer Nw=O+8192+Aw*8192integer bwinteger array Bw
integer cw=F
integer array Cw
integer array dw
integer Dw=F
integer fw=675constant real Fw=fw*fwinteger array gw
boolean Gwinteger hwinteger array Hw
boolean array jw
integer array Jw
integer array kw
constant integer Kw=O+570integer lw=w
integer array Lw
integer mwstring Mw="<CustomDrop>"
integer pwstring Pw="<StructId>"integer qwstring Qw="<StructTable>"integer swstring Sw="<StructInteger>"integer twstring Tw="<StructData>"
integer uwstring Uw="<StructNative>"integer wwstring Ww="<StructEvent>"integer ywstring Yw="<StructAbilities>"integer zwstring Zw="<StructAnimation>"integer vWstring eW="<StructDestroyTimed>"
integer xWstring oW="<StructDestruction>"integer rWstring iW="<StructFacing>"integer aWstring nW="<StructPlayerColor>"integer VWstring EW="<StructOrder>"integer XWstring OW="<StructOwner>"integer RWinteger IWinteger AWstring NW="<StructZ>"integer bWstring BW="<StructPosition>"
integer cWstring CW="<StructFollowDummyUnit>"integer dWstring DW="<StructFollowUnit>"integer fWstring FW="<StructRotate>"integer gWstring GW="<StructTimed>"integer hWstring HW="<StructScale>"integer jWstring JW="<StructRed>"integer kWstring KW="<StructGreen>"integer lWstring LW="<StructBlue>"
integer mWstring MW="<StructAlpha>"integer pWstring PW="<StructTimed>"integer qWstring QW="<StructVertexColor>"constant integer sW=$Bconstant integer SW=O+8192+sW*8192boolean tW=false
string array TWunit uW=null
integer UWstring wW="<DummyUnit>"integer WWstring yW="<TargetFlag>"
integer YWstring zW="<Misc>"integer ZWconstant integer vy=$C4constant integer ey=O+vy
integer array xy
integer array oy
integer ry=F
integer iyinteger array ay
integer nyconstant integer Vy=$C5constant integer Ey=O+Vy
integer array Xy
integer array Oy
integer Ry=F
integer Iyinteger array Ay
integer Nyinteger byinteger array By
integer array cy
integer Cy=F
integer Dyinteger fyinteger Fy=0
integer array gy
integer Gy=U
integer array hy
boolean array Hy
boolean array jy
integer Jyconstant real ky=180.*1./ 3.141592654integer array Ky
constant integer ly=$CAconstant integer Ly=O+ly
constant integer my=$C1constant integer My=O+8192+my*8192real array pyinteger array Py
real array qyreal array Qyreal array syreal array Syreal array tyinteger Tystring uy="<StructId>"integer Uystring wy="<StructBoolean>"integer Wystring yy="<StructTable>"integer Yystring zy="<StructInteger>"integer Zystring vY="<StructData>"
integer eYstring xY="<MissileCheckpoint>"integer oYstring rY="<StructId>"integer iYstring aY="<StructBoolean>"integer nYstring VY="<StructTable>"integer EYstring XY="<StructInteger>"integer OYstring RY="<StructData>"
integer IYstring AY="<StructEvent>"integer NYstring bY="<StructArc>"integer BYstring cY="<StructImpact>"integer CYstring DY="<StructCollisionSize>"integer fYstring FY="<StructDummyUnit>"integer gYstring GY="<StructAngle>"integer hYstring HY="<StructX>"integer jYstring JY="<StructY>"integer kYstring KY="<StructZ>"integer lYstring LY="<StructPosition>"
integer mYstring MY="<StructUpdateTime>"integer pYstring PY="<StructAcceleration>"
integer qYstring QY="<StructSpeed>"integer sYstring SY="<StructGoToSpot>"
integer tYstring TY="<StructCheckpoints>"integer uYstring UY="<StructGoToUnit>"
integer wYstring WY="<Missile>"integer yYinteger YYinteger zYinteger ZYinteger vzinteger array ez
integer array xz
integer array oz
integer array rz
constant integer iz=9*8192integer array az
constant integer nz=$Aconstant integer Vz=nz*8192integer array Ez
integer array Xz
integer array Oz
boolean array Rz
integer Izconstant integer Az=$CDconstant integer Nz=O+Az
integer array bz
integer Bzinteger cz=0
integer array Cz
integer dz=U
integer array Dz
boolean array fz
boolean array Fz
integer array gz
integer Gzinteger array hz
integer array Hz
integer jz=F
integer Jzinteger kzinteger array Kz
integer array lz
integer Lzconstant integer mz=$CEconstant integer Mz=O+8192+mz*8192integer pzinteger Pzinteger array qz
integer array Qz
integer sz=F
integer Szinteger array tz
real array Tzreal array uzreal array Uzreal array wzreal array Wzreal array yzinteger array Yz
integer zzinteger Zzstring vZ="<MultiboardItem>"
integer eZstring xZ="<StructColumn>"integer oZstring rZ="<StructColumnSpan>"integer iZstring aZ="<StructRow>"integer nZstring VZ="<StructTitle>"integer EZstring XZ="<StructPageSwitch>"integer OZstring RZ="<StructControl>"integer IZstring AZ="<StructShown>"integer NZstring bZ="<Multiboard>"
integer array BZ
integer cZ=0
integer CZ=U
boolean array DZ
integer fZ=kAinteger FZboolean array gZ
integer GZ=0
integer array hZ
boolean array HZ
integer array jZ
integer array JZ
integer array kZ
integer array KZ
integer array lZ
integer array LZ
integer array mZ
integer array MZ
string array pZmultiboarditem array PZreal array qZconstant integer QZ=$D0constant integer sZ=O+8192+QZ*8192string array SZinteger tZ=w
integer TZstring array uZinteger UZstring array wZinteger WZinteger array yZ
integer YZ=F
integer array zZ
string array ZZinteger v0integer array e0
integer array x0
boolean array o0
integer array r0
integer array i0
integer array n0
integer array V0
integer array E0
integer X0=w
integer O0string array R0integer I0string array A0integer array N0
boolean array b0
integer array B0
integer c0integer C0string array d0integer D0integer f0=0
string F0="<StructDownArrow>"integer array g0
integer G0=U
integer array h0
boolean array H0
boolean array j0
integer J0real array k0integer array K0
real array l0integer array L0
integer array m0
constant integer M0=O+8192+460*8192integer p0constant integer P0=O+458integer q0=F
integer array Q0
integer s0real array S0integer t0integer array T0
constant integer u0=0+8integer U0integer array w0
integer array W0
constant integer y0=0+$B
real Y0=2450.integer z0integer Z0string array v1integer e1constant integer o1=0+1boolean r1=false
integer i1='d'integer array n1
integer V1integer E1='d'integer X1=F
volumegroup array O1
integer array R1
integer I1integer A1integer N1=0
string b1="<StructLeftArrow>"integer array B1
integer c1=U
integer array C1
boolean array d1
boolean array D1
integer f1real array F1integer array g1
real array G1integer array h1
integer array H1
constant integer j1=O+8192+464*8192integer J1constant integer k1=O+462real array K1integer l1integer L1=0
string m1="<StructRightArrow>"integer array M1
integer p1=U
integer array P1
boolean array q1
boolean array Q1
integer s1real array S1integer array t1
real array T1integer array u1
integer array U1
constant integer w1=O+8192+468*8192integer W1constant integer Y1=O+466integer z1integer Z1=0
string v2="<StructUpArrow>"integer array e2
integer o2=U
integer array r2
boolean array i2
boolean array n2
integer V2real array E2integer array X2
real array O2integer array R2
integer array I2
constant integer A2=O+8192+472*8192integer N2constant integer b2=O+470integer B2=F
integer array c2
integer C2integer array D2
integer array f2
integer F2integer g2integer G2constant real h2=(2*1.)*1./ 32integer H2string j2="<StructId>"integer J2string k2="<StructTable>"integer K2string l2="<StructInteger>"integer L2string m2="<StructData>"
integer M2string p2="<StructNative>"integer P2string q2="<StructEvent>"integer Q2string S2="<Order>"integer t2integer T2=0
integer array u2
integer U2=U
integer array w2
boolean array W2
boolean array Y2
integer array Z2
constant integer v3=$D1constant integer e3=O+8192+v3*8192string array o3integer r3integer i3integer n3integer V3integer E3integer X3integer O3integer R3integer I3integer A3integer N3integer b3integer B3integer c3integer C3integer d3integer D3integer f3integer F3integer g3integer G3integer h3integer H3integer j3integer J3integer k3integer K3integer l3integer L3integer m3integer M3integer p3integer P3integer q3integer Q3integer s3integer S3integer t3integer T3integer u3integer U3integer w3integer W3integer Y3integer z3integer Z3integer v4integer e4integer o4integer r4integer i4integer n4integer V4integer E4integer X4integer O4integer R4integer I4integer A4integer N4integer b4integer B4integer c4integer C4integer d4integer D4integer f4integer F4integer g4integer G4integer h4integer H4integer j4integer J4integer k4integer K4integer l4integer L4integer m4string M4="<StructRefs>"
integer p4string P4="<StructEvent>"integer q4string Q4="<StructColor>"hashtable s4
integer S4string t4="<StructId>"integer T4string u4="<StructTable>"integer U4string w4="<StructInteger>"integer W4string Y4="<StructData>"
integer z4string Z4="<StructId>"integer v5string e5="<StructTable>"integer x5string o5="<StructInteger>"integer r5string i5="<StructData>"
integer a5string n5="<StructNative>"integer V5string E5="<StructEvent>"integer X5string O5="<Region>"
integer R5string I5="<Music>"integer A5string N5="<SoundChannel>"integer b5string B5="<SoundEax>"integer c5string C5="<SoundType>"integer d5integer D5=0
integer array f5
integer F5=U
integer array g5
boolean array G5
boolean array h5
integer H5integer j5integer J5integer k5integer K5integer l5integer array L5
constant integer m5=$Aconstant integer M5=$Bconstant integer p5=$Dconstant integer P5=$Cconstant integer q5=$Einteger Q5integer array s5
integer S5string t5="<HeroSpell>"integer T5string u5="<SpellClass>"
integer U5string w5="<StructId>"integer W5string y5="<StructTable>"integer Y5string z5="<StructBoolean>"integer Z5string v6="<StructInteger>"integer e6string x6="<StructReal>"
integer o6string r6="<StructData>"
integer i6string a6="<StructNative>"integer n6string V6="<StructEvent>"integer E6string X6="<Spell>"integer O6integer R6=0
integer array I6
integer A6=U
integer array N6
boolean array b6
boolean array B6
integer array c6
integer array C6
boolean array d6
integer D6integer f6integer F6integer g6integer G6integer h6integer H6integer j6=5
integer J6integer array k6
integer array K6
integer array l6
integer L6='AHS0'integer array m6
integer M6integer p6integer P6constant integer q6=$D8constant integer Q6=O+q6
integer s6string S6="<StructRefs>"
integer t6string T6="<StructNative>"integer u6string U6="<StructEvent>"integer w6string W6="<StructDeformNova>"integer y6string Y6="<Spot>"integer z6=0
integer array Z6
integer v7=U
integer array e7
boolean array x7
boolean array o7
integer r7integer i7integer a7string n7="<StructTable>"integer V7string E7="<StructInteger>"integer X7string O7="<StructData>"
integer R7string I7="<StructNative>"integer A7string N7="<StructEvent>"integer b7string B7="<StringData>"
integer c7integer C7=0
string d7="<TileType>"integer array D7
integer f7=U
integer array F7
boolean array g7
boolean array G7
integer h7integer array H7
constant integer j7=$E9constant integer J7=O+j7
integer k7integer K7integer l7integer L7integer m7integer M7integer p7integer P7integer q7integer Q7integer s7integer S7integer t7string T7="<StructType>"
integer u7string U7="<Tile>"integer w7integer W7string y7="<StructDestroyTimed>"
integer Y7string z7="<TileTypeMod>"integer Z7integer v8=0
string e8="<UbersplatType>"integer array x8
integer o8=U
integer array r8
boolean array i8
boolean array a8
integer n8string array V8integer E8string X8="<StructId>"integer O8string R8="<StructTable>"integer I8string A8="<StructInteger>"integer N8string b8="<StructData>"
integer B8string c8="<StructEvent>"integer C8string d8="<StructDestroyTimed>"
integer D8string f8="<StructRed>"integer F8string g8="<StructGreen>"integer G8string h8="<StructBlue>"
integer H8string j8="<StructAlpha>"integer J8string k8="<StructTimed>"integer K8string l8="<StructColor>"integer L8string m8="<StructX>"integer M8string p8="<StructY>"integer P8string q8="<StructPosition>"
integer Q8string s8="<Ubersplat>"integer S8integer t8integer array T8
integer array u8
integer array U8
constant integer w8=$EEconstant integer W8=O+8192+w8*8192integer array y8
integer array Y8
boolean array z8
integer array Z8
integer array vvvinteger array vevinteger vxv=Finteger vovinteger array vrvinteger vivstring vav="<StructPosition>"integer vnvstring vVv="<StructText>"integer vEvstring vXv="<StructCreateJumping>"integer vOvstring vRv="<StructCreateMoving>"integer vIvstring vAv="<StructCreateRising>"integer vNvstring vbv="<StructDelay>"integer vBvstring vcv="<StructFadingOut>"integer vCvstring vdv="<TimerDialog>"integer vDvstring vfv="<StructId>"integer vFvstring vgv="<StructTable>"integer vGvstring vhv="<StructInteger>"
integer vHvstring vjv="<StructData>"integer vJvstring vkv="<TriggerTimer>"integer vKvstring vlv="<StructId>"integer vLvstring vmv="<StructTable>"integer vMvstring vpv="<StructInteger>"
integer vPvstring vqv="<StructData>"integer vQvstring vsv="<StructId>"integer vSvstring vtv="<StructBoolean>"
integer vTvstring vuv="<StructTable>"integer vUvstring vwv="<StructInteger>"
integer vWvstring vyv="<StructData>"integer vYvstring vzv="<StructNative>"integer vZvstring v_v="<StructEvent>"integer v0vstring v1v="<StructRegisterEvent>"integer array v2vinteger array v3vinteger array v4vinteger v5vstring v6v="<StructBonus>"integer v7vstring v8v="<StructArmor>"integer array v9vinteger array evvinteger array eevinteger exvstring eov="<StructBonusA>"integer ervstring eiv="<StructSpeed>"integer eavstring env="<StructAttack>"integer eVvstring eEv="<StructBonus>"integer array eXvinteger array eOvinteger array eRvinteger array eIvinteger eAvstring eNv="<StructDamage>"integer ebvstring eBv="<StructMovement>"integer ecvstring eCv="<StructBonusA>"integer edvstring eDv="<StructAgility>"
integer efvstring eFv="<StructBonusA>"integer egvstring eGv="<StructIntelligence>"integer ehvstring eHv="<StructBonusA>"integer ejvstring eJv="<StructStrength>"integer ekvstring eKv="<StructHero>"integer elvstring eLv="<UnitAttackSplash>"integer emvstring eMv="<StructId>"integer epvstring ePv="<StructTable>"integer eqvstring eQv="<StructInteger>"
integer esvstring eSv="<StructData>"integer etvstring eTv="<UnitClass>"
integer euvstring eUv="<StructId>"integer ewvstring eWv="<StructTable>"integer eyvstring eYv="<StructInteger>"
integer ezvstring eZv="<StructReal>"integer e_vstring e0v="<StructData>"integer e1vstring e2v="<UnitTypePool>"integer e3vstring e4v="<StructId>"integer e5vstring e6v="<StructBoolean>"
integer e7vstring e8v="<StructTable>"integer e9vstring xvv="<StructInteger>"
integer xevstring xxv="<StructTable>"integer xovstring xrv="<StructReal>"integer xivstring xav="<StructData>"integer xnvstring xVv="<StructCombination>"
integer xEvstring xXv="<StructCounted>"
integer xOvstring xRv="<StructNative>"integer xIvstring xAv="<StructEvent>"integer xNvstring xbv="<StructBegin>"integer xBvinteger xcv=0integer array xCvinteger xdv=Uinteger array xDvboolean array xfvboolean array xFvstring xgv="<StructChanneling>"integer xGvinteger array xhvboolean array xHvinteger array xjvinteger xJvinteger xkvinteger xKvinteger xlvinteger xLvinteger xmvconstant integer xMv=O+8192+284*8192
integer xpvinteger xPvconstant integer xqv=O+392integer array xQvinteger array xsvstring xSv="<StructLoop>"boolean array xtvinteger xTvinteger xuvinteger array xUvinteger array xwvinteger xWv=Finteger xyvtrigger xYvinteger array xzvinteger xZv=0integer x_v=Uboolean array x0vstring array x1v
constant real x2v=Oj*32string array x3v
integer x4vinteger x5vinteger array x6vinteger x7v=Finteger array x8vinteger x9vinteger array ovvinteger oev=Finteger array oxvinteger array oovlightning array orvlightning array oivboolean array oavinteger onvinteger oVvinteger oEvstring oXv="<StructEffect>"integer oOvstring oRv="<StructFinish>"integer oIvstring oAv="<StructLearn>"integer oNvstring obv="<StructUnlearn>"
integer oBvstring ocv="<StructEvents>"integer oCvstring odv="<StructAutoCast>"integer oDvstring ofv="<StructAbilities>"integer oFvstring ogv="<StructEffects>"
integer oGvstring ohv="<StructSounds>"integer oHvstring ojv="<StructAttachments>"
integer oJvstring okv="<StructChangeLevel>"
integer oKvstring olv="<StructGain>"integer oLvstring omv="<StructLose>"integer oMvstring opv="<StructEvents>"integer oPvstring oqv="<StructBuffs>"integer oQvstring osv="<StructModSets>"
integer oSvstring otv="<StructGain>"integer oTvstring ouv="<StructLose>"integer oUvstring owv="<StructMoveInInventory>"
integer oWvstring oyv="<StructSell>"integer oYvstring ozv="<StructUse>"
integer oZvstring o_v="<StructEvents>"integer o0vstring o1v="<StructItems>"integer o2vstring o3v="<StructClasses>"
integer o4vstring o5v="<StructType>"integer o6vstring o7v="<StructColor>"integer o8vstring o9v="<StructOwner>"integer rvvstring rev="<StructBase>"integer rxvstring rov="<StructDisplayed>"integer rrvstring riv="<StructBonus>"integer ravstring rnv="<StructRelative>"integer rVvstring rEv="<StructIgnoreDamage>"integer rXvstring rOv="<StructInvisible>"integer rRvstring rIv="<StructRelative>"integer rAvstring rNv="<StructResistance>"integer rbvstring rBv="<StructSpell>"integer rcvstring rCv="<StructTypeA>"integer rdvstring rDv="<StructArmor>"integer rfvstring rFv="<StructAcquire2>"integer rgvstring rGv="<StructGround>"integer rhvstring rHv="<StructEvents>"integer rjvstring rJv="<StructSpeed>"integer rkvstring rKv="<StructMissile>"
integer rlvstring rLv="<StructRange>"integer rmvstring rMv="<StructBaseA>"integer rpvstring rPv="<StructDisplayedA>"integer rqvstring rQv="<StructBonusA>"integer rsvstring rSv="<StructSpeed>"integer rtvstring rTv="<StructTargetFlag>"integer ruvstring rUv="<StructSplash>"string rwv="<StructAttack>"integer rWvinteger ryvboolean array rYvinteger rzvstring rZv="<StructBlood>"integer r_vstring r0v="<StructBloodExplosion>"integer r1vstring r2v="<StructCollisionSize>"integer r3vstring r4v="<StructBase>"integer r5vstring r6v="<StructBonus>"integer r7vstring r8v="<StructCriticalChanceDefense>"integer r9vstring ivv="<StructBase>"integer ievstring ixv="<StructBonus>"integer iovstring irv="<StructCriticalChance>"integer iivstring iav="<StructExplosion>"integer invboolean array iVvinteger iEvstring iXv="<StructEvents>"integer iOvstring iRv="<StructProtection>"integer iIvinteger iAvstring iNv="<StructDeath>"integer ibvstring iBv="<StructDuration>"integer icvstring iCv="<StructEvents>"integer idvstring iDv="<StructTimed>"integer ifvstring iFv="<StructDecay>"integer igvstring iGv="<StructDisplay>"
integer ihvstring iHv="<StructExp>"
integer ijvstring iJv="<StructSupply>"integer ikvstring iKv="<StructDrop>"integer ilvstring iLv="<StructEvasion>"
integer imvstring iMv="<StructBase>"integer ipvstring iPv="<StructBonus>"integer iqvstring iQv="<StructEvasionChanceDefense>"integer isvstring iSv="<StructBase>"integer itvstring iTv="<StructBonus>"integer iuvstring iUv="<StructEvasionChance>"integer iwvstring iWv="<StructX>"integer iyvstring iYv="<StructY>"integer izvstring iZv="<StructZ>"integer i_vstring i0v="<StructImpact>"integer i1vstring i2v="<StructExp>"
integer i3vstring i4v="<StructX>"integer i5vstring i6v="<StructY>"integer i7vstring i8v="<StructZ>"integer i9vstring avv="<StructOutpact>"
integer aevstring axv="<StructLifeLeech>"integer aovstring arv="<StructManaLeech>"integer aivboolean array aavstring array anv
integer aVvstring aEv="<StructInvulnerability>"
integer aXvinteger aOvboolean array aRvinteger aIvstring aAv="<StructDisplayed>"integer aNvstring abv="<StructBase>"integer aBvstring acv="<StructDisplayed>"integer aCvstring adv="<StructBonus>"integer aDvstring afv="<StructDelay>"integer aFvstring agv="<StructDices>"integer aGvstring ahv="<StructEvents>"integer aHvstring ajv="<StructInvisible>"integer aJvstring akv="<StructRelative>"integer aKvstring alv="<StructSides>"integer aLvstring amv="<StructSpellRelative>"integer aMvstring apv="<StructTypeA>"integer aPvstring aqv="<StructDamage>"integer aQvstring asv="<StructSpellShield>"
integer aSvinteger atvboolean array aTvconstant integer auv=O+8192+346*8192
integer aUvstring awv="<StructMagicImmunity>"integer aWvinteger ayvboolean array aYvinteger azvstring aZv="<StructBonus>"string a_v="<StructScale>"integer a0vinteger a1vinteger a2vinteger array a3vinteger a4vstring a5v="<StructRed>"
integer a6vstring a7v="<StructGreen>"integer a8vstring a9v="<StructBlue>"integer nvvstring nev="<StructAlpha>"integer nxvstring nov="<StructVertexColor>"
integer nrvstring niv="<StructCold>"integer navinteger nnvinteger nVvinteger nEv=0string nXv="<UnitMod>"integer array nOvinteger nRv=Uinteger array nIvboolean array nAvboolean array nNvinteger nbvinteger array nBvinteger ncvreal array nCvreal array ndvreal array nDvreal array nfvinteger nFvboolean array ngvinteger nGvinteger nhvstring nHv="<StructFrost>"integer njvstring array nJv
string nkv="Unit_page\\Unit_struct\\Frost\\finished\\BurstingIce.mdx"string array nKv
integer nlvinteger nLvstring nmv="<StructReveal>"integer nMvboolean array npvstring nPv="Abilities\\Spells\\NightElf\\FaerieDragonInvis\\FaerieDragon_Invis.mdx"string nqv="AttachPoint.HEAD"integer nQvstring nsv="<StructInvisibility>"integer nSvinteger ntvinteger nTvinteger array nuvinteger nUvinteger nwvinteger nWvboolean array nyvinteger nYvstring nzv="<StructGhost>"integer nZvboolean array n_vinteger n0vstring n1v="<StructHealAbility>"
integer n2vstring n3v="<StructBase>"integer n4vstring n5v="<StructBonus>"integer n6vstring n7v="<StructRelative>"integer array n8vinteger array n9vinteger Vvvstring Vev="<StructMaxLife>"
integer Vxvstring Vov="<StructLife>"integer Vrvstring Viv="<StructBase>"integer Vavstring Vnv="<StructBonus>"string VVv="<StructDisablement>"
integer VEvboolean array VXvinteger VOvstring VRv="<StructRelative>"integer VIvstring VAv="<StructLifeRegeneration>"integer VNvstring Vbv="<StructBase>"integer VBvstring Vcv="<StructBonus>"integer VCvstring Vdv="<StructRelative>"integer array VDvinteger array Vfvinteger VFvstring Vgv="<StructMaxMana>"
integer VGvstring Vhv="<StructMana>"integer VHvstring Vjv="<StructBase>"integer VJvstring Vkv="<StructBonus>"string VKv="<StructDisablement>"
integer Vlvboolean array VLvinteger Vmvstring VMv="<StructRelative>"integer Vpvstring VPv="<StructManaRegeneration>"integer Vqvstring VQv="<StructEnterRegion>"
integer Vsvstring VSv="<StructInterval>"integer Vtvstring VTv="<StructLeaveRegion>"
integer Vuvstring VUv="<StructEvents>"integer Vwvstring VWv="<StructBaseA>"integer Vyvstring VYv="<StructBonusA>"integer Vzvstring VZv="<StructRelativeA>"integer V_vstring V0v="<StructSpeed>"string V1v="<StructMovement>"integer V2vboolean array V3vinteger V4vstring V5v="<StructLose>"integer V6vstring V7v="<StructImmediate>"integer V8vstring V9v="<StructPoint>"integer Evvstring Eev="<StructTarget>"integer Exvstring Eov="<StructGain>"integer Ervstring Eiv="<StructIdle>"integer Eavstring Env="<StructEvents>"integer EVvstring EEv="<StructOrder>"integer EXvstring EOv="<StructBanish>"integer ERvinteger EIvinteger EAvboolean array ENvinteger Ebvinteger EBvstring Ecv="<StructMadness>"
integer ECvinteger Edvinteger EDvinteger Efvstring EFv="<StructEclipse>"
integer Egvinteger EGvinteger Ehvinteger EHvboolean array Ejvinteger EJvstring Ekv="<StructWhirl>"integer EKvinteger Elvinteger ELvboolean array Emvinteger EMvinteger Epvstring EPv="<StructFacing>"integer Eqvstring EQv="<StructBleeding>"integer Esvinteger ESvboolean array Etvinteger array ETvinteger array Euvstring array EUv
constant integer Ewv=O+8192+348*8192
constant real EWv=1.*1./ 10.
real array Eyvreal array EYvboolean array Ezvreal array EZvconstant integer E_v=O+8192+342*8192
real array E0vreal array E1vinteger array E2vinteger E3vinteger E4vreal array E5vconstant integer E6v=O+8192+393*8192
real E7v=.01
constant real E8v=E7v*1.
real E9v=.02
constant real Xvv=E9v*1.
integer Xevinteger Xxvstring Xov="<StructIgnited>"
integer Xrvboolean array Xivinteger array Xavinteger array Xnvreal XVv=.01
constant real XEv=XVv*1.
real XXv=.02
constant real XOv=XXv*1.
integer XRvstring XIv="<StructKnockup>"
integer XAvstring XNv="<StructPathing>"
integer Xbvboolean array XBvinteger Xcvstring XCv="<StructPoisoned>"integer Xdvinteger XDvinteger Xfvboolean array XFvinteger Xgvstring XGv="<StructAble>"integer Xhvstring XHv="<StructEvents>"integer Xjvstring XJv="<StructRevival>"
integer Xkvstring XKv="<StructSilence>"
integer Xlvinteger XLvinteger Xmvboolean array XMvinteger Xpvinteger XPvstring Xqv="<StructSleep>"integer XQvinteger Xsvinteger XSvinteger Xtvinteger XTvstring Xuv="<StructCancel>"string XUv="<StructStun>"integer Xwvinteger XWvinteger Xyvstring XYv="<StructSpeed>"integer Xzvstring XZv="<StructAnimation>"integer X_vstring X0v="<StructSkillPoints>"
integer X1vstring X2v="<StructBase>"integer X3vstring X4v="<StructBonus>"integer X5vstring X6v="<StructRelative>"integer X7vstring X8v="<StructSpellPower>"integer X9vstring Ovv="<StructBase>"integer Oevstring Oxv="<StructBonus>"integer Oovstring Orv="<StructRelative>"integer Oivstring Oav="<StructSpellVamp>"integer Onvstring OVv="<StructBase>"integer OEvstring OXv="<StructBonus>"integer OOvstring ORv="<StructRelative>"integer OIvstring OAv="<StructMaxRage>"
integer ONvstring Obv="<StructRage>"integer OBvstring Ocv="<StructBase>"integer OCvstring Odv="<StructBonus>"integer ODvstring Ofv="<StructRelative>"integer OFvstring Ogv="<StructRageRegeneration>"integer OGvstring Ohv="<StructBase>"integer OHvstring Ojv="<StructBonus>"integer OJvstring Okv="<StructRelative>"integer OKvstring Olv="<StructMaxStamina>"integer OLvstring Omv="<StructExhaustion>"integer OMvinteger Opvstring OPv="<StructStamina>"
integer Oqvstring OQv="<StructBase>"integer Osvstring OSv="<StructBonus>"integer Otvstring OTv="<StructRelative>"integer Ouvstring OUv="<StructStaminaRegeneration>"
integer Owvstring OWv="<StructExpiringCondition>"integer Oyvstring OYv="<StructBars>"integer Ozvstring OZv="<StructTimedLife>"integer O_vinteger array O0vinteger O1vstring O2v="<StructTransport>"integer O3vinteger array O4vinteger array O5vboolean array O6vinteger O7vinteger O8vinteger O9vstring Rvv="<StructHero>"integer Revstring Rxv="<StructAccelerated>"
integer Rovstring Rrv="<StructTimed>"integer Rivinteger Ravinteger Rnvstring RVv="<StructZ>"integer REvinteger RXvstring ROv="<StructPosition>"string array RRv
integer RIvstring RAv="<StructCircle>"integer RNvstring Rbv="<StructSelection>"integer RBvinteger Rcvstring RCv="<StructBase>"integer Rdvstring RDv="<StructBonus>"integer Rfvstring RFv="<StructRelative>"integer array Rgvinteger array RGvinteger array Rhvinteger array RHvinteger Rjvstring RJv="<StructSightRange>"integer Rkvstring RKv="<StructEvents>"integer Rlvstring RLv="<StructLevel>"integer Rmvstring RMv="<StructBase>"integer Rpvstring RPv="<StructDisplayed>"integer Rqvstring RQv="<StructBonus>"integer Rsvstring RSv="<StructRelative>"integer Rtvstring RTv="<StructAgility>"
integer Ruvstring RUv="<StructBase>"integer Rwvstring RWv="<StructDisplayed>"integer Ryvstring RYv="<StructBonus>"integer Rzvstring RZv="<StructRelative>"integer R_vstring R0v="<StructIntelligence>"integer R1vstring R2v="<StructBase>"integer R3vstring R4v="<StructDisplayed>"integer R5vstring R6v="<StructBonus>"integer R7vstring R8v="<StructRelative>"integer R9vstring Ivv="<StructStrength>"integer Ievstring Ixv="<StructRefs>"integer Iovstring Irv="<Unit>"integer Iivinteger Iavinteger Inv=0integer array IVvinteger IEv=Uinteger array IXvboolean array IOvboolean array IRvinteger array IIvstring array IAv
integer INv=Finteger array Ibvinteger array IBvinteger array Icvconstant integer ICv=O+8192+262*8192
integer Idvinteger IDvinteger Ifvinteger IFvinteger Igvinteger IGvinteger Ihvinteger IHvinteger Ijvinteger IJvinteger array Ikvinteger IKv=0integer array Ilvinteger ILv=Uinteger array Imvboolean array IMvboolean array Ipvreal array IPvreal array Iqvreal array IQvreal array Isvreal array ISvreal array Itvreal array ITvreal array Iuvreal array IUvconstant integer Iwv=O+8192+427*8192
constant integer IWv=O+8192+428*8192
integer Iyvinteger IYvinteger Izvinteger array IZvconstant integer I_v=$DA
constant integer I0v=O+8192+I_v*8192
constant integer I1v=$D9
constant integer I2v=O+8192+I1v*8192
integer array I3vconstant integer I4v=O+8192+429*8192
real array I5vreal array I6vreal array I7vreal array I8vreal array I9vreal array Avvreal array Aevboolean array Axvreal array Aovreal array Arvreal array Aivinteger array Aavinteger array Anvinteger AVvinteger AEv=6integer AXv=6integer AOv=wconstant integer ARv=O+8192+432*8192
constant integer AIv=O+8192+430*8192
constant integer AAv=O+8192+431*8192
integer ANvinteger Abvinteger ABvboolean array Acvinteger ACvinteger array Advinteger ADv=4integer Afvinteger AFvreal array Agvreal array AGvreal array Ahvconstant integer AHv=O+8192+434*8192
constant integer Ajv=O+8192+334*8192
integer AJv=0integer array Akvinteger AKv=Uinteger array Alvboolean array ALvboolean array Amvreal array AMvreal array Apvconstant integer APv=O+8192+332*8192
constant integer Aqv=O+8192+435*8192
string array AQv
string array Asv
constant integer ASv=O+8192+436*8192
integer Atvreal array ATvreal array Auvreal array AUvreal array Awvreal array AWvinteger array Ayvinteger array AYvinteger Azvinteger array AZvinteger array A_vreal array A0vinteger array A1vinteger array A2vinteger A3vreal array A4vreal array A5vinteger A6vconstant integer A7v=O+8192+438*8192
constant integer A8v=O+8192+340*8192
integer A9vinteger array Nvvstring array Nev
string array Nxv
integer array Novinteger array Nrvinteger array Nivinteger array Navinteger array Nnvinteger array NVvreal array NEvreal array NXvreal array NOvboolean array NRvinteger array NIvboolean array NAvreal array NNvreal array Nbvreal array NBvreal array Ncvreal array NCvreal array Ndvinteger NDv=256integer Nfv='TS73'integer NFv=256integer Ngv='SS73'real array NGvreal array Nhvreal array NHvreal array Njvreal array NJvreal array Nkvreal array NKvreal array Nlvreal array NLvreal array Nmvreal array NMvreal array Npvreal array NPvreal array Nqvreal array NQvreal array Nsvreal array NSvreal array Ntvreal array NTvreal array Nuvreal array NUvreal array Nwvreal array NWvreal array Nyvreal array NYvreal array Nzvreal array NZvreal array N_vreal array N0vreal array N1vreal N2v=.2constant integer N3v=O+8192+394*8192
integer N4vconstant integer N5v=O+8192+388*8192
constant integer N6v=O+386integer N7vinteger N8vconstant real N9v=Oj*16real array bvvreal array bevinteger bxvinteger bovconstant real brv=.1*.1real array bivinteger bavinteger bnvinteger bVvinteger bEvinteger array bXvinteger bOv=Finteger array bRvinteger bIvinteger array bAvinteger bNv=Freal array bbvreal array bBvreal array bcvreal array bCvreal array bdvreal array bDvreal array bfvreal array bFvinteger array bgvinteger array bGvinteger array bhvreal bHv=.01
real array bjvreal array bJvreal array bkvreal array bKvinteger blvinteger bLvconstant integer bmv=O+8192+384*8192
integer bMv=0integer array bpvinteger bPv=Uinteger array bqvboolean array bQvboolean array bsvreal array bSvinteger array btvinteger array bTvinteger array buvconstant integer bUv=O+8192+382*8192
integer bwvinteger bWvinteger byvlightning array bYvlightning array bzvlightning array bZvlightning array b_vlightning array b0vlightning array b1vinteger b2vinteger b3vinteger b4vinteger b5v=Finteger array b6vinteger array b7vinteger b8vconstant real b9v=(1*1.)*1./ 32constant real Bvv=3.141592654*1./ 2constant real Bev=Bvvreal array Bxvreal array Bovconstant real Brv=(.1*32)*b9vconstant real Biv=(.15-1.)*1./(.9-.7)constant real Bav=(1.*1./ .7-.15*1./ .9)*1./(1*1./ .7-1*1./ .9)real array Bnvinteger BVvinteger BEvinteger BXvinteger BOvinteger BRvinteger BIvinteger BAvboolean BNv=true
integer array Bbvinteger array BBvinteger Bcvinteger BCvinteger array Bdvinteger array BDvinteger Bfvinteger BFvinteger Bgv=0string BGv="<UnitState>"
integer array Bhvinteger BHv=Uinteger array Bjvboolean array BJvboolean array Bkvinteger BKvstring array Blv
integer BLvboolean Bmv=falseinteger BMvreal Bpv=.6integer array BPveffect array Bqv
integer array BQvinteger array Bsvboolean array BSvinteger Btv=0integer BTv=Uboolean array Buvconstant real BUv=Jf
string Bwv="Unit_page\\Unit_struct\\Death\\Explosion\\CommonBloodExplosion.mdx"integer array BWvinteger Byvinteger BYvinteger Bzvconstant real BZv=$80integer B_vinteger B0v=0integer array B1vinteger B2v=Uinteger array B3vboolean array B4vboolean array B5vinteger array B6vinteger B7v=0integer array B8vinteger B9v=Uinteger array cvvboolean array cevboolean array cxvinteger array covinteger array crvconstant integer civ=O+338integer cavinteger cnvinteger cVvinteger cEvinteger cXvconstant integer cOv=O+8192+274*8192
constant integer cRv=O+8192+276*8192
integer cIvboolean cAv=falseinteger cNvinteger cbvinteger cBvinteger ccvinteger cCvinteger cdvinteger cDvinteger cfvconstant integer cFv=O+8192+364*8192
constant integer cgv=O+362integer cGvreal array chvreal array cHvreal array cjvreal array cJvreal array ckvinteger cKvunit array clvinteger cLv=0integer cmv=Uboolean array cMvinteger array cpvinteger cPvconstant integer cqv=O+8192+390*8192
integer array cQvinteger array csvinteger cSv=Finteger array ctvinteger array cTvinteger cuv=Finteger cUvinteger cwvinteger cWvinteger cyvinteger array cYvinteger array czvinteger cZv=Finteger c_vconstant integer c0v=O+8192+398*8192
integer array c1vinteger array c2vboolean array c3vinteger c4vinteger array c5vinteger array c6vinteger c7v=Finteger c8vconstant real c9v=Oj*4integer Cvv=0integer array Cevinteger Cxv=Uinteger array Covboolean array Crvboolean array Civinteger array Cavinteger array Cnvreal array CVvreal array CEvreal array CXvreal array COvreal array CRvreal array CIvconstant integer CAv=O+8192+396*8192
integer CNvinteger Cbvinteger CBv=Finteger array Ccvinteger array CCvinteger Cdvtrigger CDvinteger Cfv=0integer CFv=Uboolean array Cgvboolean array CGvconstant integer Chv=$A2
constant integer CHv=O+8192+Chv*8192
integer Cjv=0integer CJv=Uboolean array Ckvreal array CKvreal array Clvreal array CLvconstant real Cmv=(2*1.)*1./ 32real array CMvreal array Cpvreal array CPvinteger Cqv=0integer CQv=Uboolean array Csvinteger array CSvinteger array Ctvinteger CTvconstant integer Cuv=O+8192+400*8192
integer array CUvconstant integer Cwv=O+399integer array CWvinteger array Cyvinteger array CYvinteger array Czvboolean array CZvinteger C_vinteger C0vinteger C1vinteger C2vinteger C3vinteger C4vinteger C5v=0integer C6v=Uboolean array C7vstring C8v="origin"integer C9vinteger dvvinteger devinteger dxvinteger dovinteger drvinteger divboolean array davinteger array dnvinteger dVvinteger dEvinteger dXvinteger dOvinteger dRvinteger dIvinteger dAvboolean dNv=falseconstant integer dbv=O+8192+344*8192
string dBv="Abilities\\Spells\\Undead\\VampiricAura\\VampiricAuraTarget.mdl"
string dcv="origin"string dCv="Abilities\\Spells\\Undead\\VampiricAura\\VampiricAuraTarget.mdl"
string ddv="origin"constant integer dDv=O+8192+433*8192
integer dfvboolean dFvinteger dgvinteger dGvinteger dhvinteger dHvinteger djvinteger dJvinteger dkvreal array dKvreal array dlvinteger dLvinteger dmvinteger dMvinteger dpvreal array dPvreal array dqvconstant real dQv=20.*.125integer dsvinteger array dSvinteger array dtvinteger dTvinteger duvinteger dUvinteger dwvinteger dWvinteger dyvconstant integer dYv=O+326integer array dzvinteger array dZvinteger array d_vboolean array d0vinteger d1vconstant integer d2v=O+8192+328*8192
integer d3vinteger d4vinteger d5vinteger d6vinteger d7v=0integer d8v=Uboolean array d9vinteger Dvv=0integer array Devinteger Dxv=Uinteger array Dovboolean array Drvboolean array Divinteger array Davreal array Dnvinteger DVv=9integer DEv=9integer DXv=winteger DOvinteger DRvinteger DIvboolean DAv=falseinteger DNvconstant integer Dbv=O+8192+324*8192
integer array DBvinteger Dcvboolean DCv=falseinteger Ddvinteger DDvconstant integer Dfv=O+320integer array DFvinteger Dgvinteger DGvinteger Dhvinteger DHvinteger Djvinteger DJvinteger Dkvinteger DKvinteger Dlvinteger DLvinteger Dmvconstant integer DMv=O+391integer Dpv=0integer array DPvinteger Dqv=Uinteger array DQvboolean array Dsvboolean array DSvinteger array Dtvinteger array DTvinteger Duvstring DUv="<StructId>"integer Dwvstring DWv="<StructBoolean>"
integer Dyvstring DYv="<StructTable>"integer Dzvstring DZv="<StructInteger>"
integer D_vstring D0v="<StructTable>"integer D1vstring D2v="<StructReal>"integer D3vstring D4v="<StructTable>"integer D5vstring D6v="<StructString>"integer D7vstring D8v="<StructData>"integer D9vstring fvv="<StructBoolMods>"integer fevstring fxv="<StructRealMods>"integer fovstring frv="<StructCustomMods>"integer fivstring fav="<StructMods>"integer fnvstring fVv="<StructId>"integer fEvstring fXv="<StructTable>"integer fOvstring fRv="<StructBoolean>"
integer fIvstring fAv="<StructTable>"integer fNvstring fbv="<StructInteger>"
integer fBvstring fcv="<StructTable>"integer fCvstring fdv="<StructReal>"integer fDvstring ffv="<StructTable>"integer fFvstring fgv="<StructString>"integer fGvstring fhv="<StructData>"integer fHvstring fjv="<StructEvent>"integer fJvstring fkv="<StructArrayBuild>"integer fKvstring flv="<StructHero>"integer fLvstring fmv="<StructAbilities>"integer fMvstring fpv="<StructType>"integer fPvstring fqv="<StructArmor>"integer fQvstring fsv="<StructAttachments>"
integer fSvstring ftv="<StructSpeed>"integer fTvstring fuv="<StructMissile>"
integer fUvstring fwv="<StructRange>"integer fWvstring fyv="<StructSpeed>"integer fYvstring fzv="<StructTargetFlag>"integer fZvstring f_v="<StructSplash>"integer f0vstring f1v="<StructAttack>"integer f2vstring f3v="<StructBlood>"integer f4vstring f5v="<StructBloodExplosion>"integer f6vstring f7v="<StructClasses>"
integer f8vstring f9v="<StructCollisionSize>"integer Fvvstring Fev="<StructDelay>"integer Fxvstring Fov="<StructDices>"integer Frvstring Fiv="<StructSides>"integer Favstring Fnv="<StructType>"integer FVvstring FEv="<StructDamage>"integer FXvstring FOv="<StructDuration>"integer FRvstring FIv="<StructDecay>"integer FAvstring FNv="<StructExp>"
integer Fbvstring FBv="<StructSupply>"integer Fcvstring FCv="<StructDrop>"integer Fdvstring FDv="<StructZ>"integer Ffvstring FFv="<StructImpact>"integer Fgvstring FGv="<StructZ>"integer Fhvstring FHv="<StructOutpact>"
integer Fjvstring FJv="<StructLife>"integer Fkvstring FKv="<StructLifeRegeneration>"integer Flvstring FLv="<StructMana>"integer Fmvstring FMv="<StructManaRegeneration>"integer Fpvstring FPv="<StructPreload>"
integer Fqvstring FQv="<StructRevivalable>"
integer Fsvstring FSv="<StructScale>"integer Ftvstring FTv="<StructSightRange>"integer Fuvstring FUv="<StructSpeed>"integer Fwvstring FWv="<StructSpellPower>"integer Fyvstring FYv="<StructSpellVamp>"integer Fzvstring FZv="<StructRed>"
integer F_vstring F0v="<StructGreen>"integer F1vstring F2v="<StructBlue>"integer F3vstring F4v="<StructAlpha>"integer F5vstring F6v="<StructVertexColor>"
integer F7vstring F8v="<StructPrimaryAttribute>"integer F9vstring gvv="<StructPerLevel>"integer gevstring gxv="<StructAgility>"
integer govstring grv="<StructArmorPerLevel>"integer givstring gav="<StructPerLevel>"integer gnvstring gVv="<StructIntelligence>"integer gEvstring gXv="<StructPerLevel>"integer gOvstring gRv="<StructStrength>"integer gIvstring gAv="<StructHero>"integer gNvinteger gbv=0string gBv="<UnitType>"integer array gcvinteger gCv=Uinteger array gdvboolean array gDvboolean array gfvinteger gFvstring array ggv
constant integer gGv=O+8192+426*8192
boolean array ghvinteger gHv=Finteger array gjvinteger array gJvinteger gkv=1integer gKvinteger glvinteger gLvinteger gmv=2integer gMvinteger gpvinteger gPvinteger gqvinteger gQvinteger gsvinteger gSvinteger gtvinteger gTvinteger guv=3integer gUvinteger gwvinteger gWvinteger gyvinteger gYvinteger gzvinteger gZvinteger g_vinteger g0vinteger g1vinteger g2vinteger g3vinteger g4vinteger g5vinteger g6vinteger g7vinteger g8vinteger g9vinteger Gvvinteger Gevinteger Gxvinteger Govinteger Grvinteger Givinteger Gavinteger Gnvinteger GVvinteger GEvinteger GXvinteger GOvinteger GRvinteger GIvinteger GAvinteger GNvinteger Gbvinteger GBvinteger Gcvinteger GCvinteger Gdvinteger GDvinteger Gfvinteger GFvinteger Ggvinteger GGvinteger Ghvinteger GHvinteger Gjvinteger GJvinteger Gkvinteger GKvinteger Glvinteger GLvinteger Gmvinteger GMvinteger Gpvinteger GPvinteger Gqvinteger GQvinteger Gsvinteger GSvinteger Gtvinteger GTvinteger Guvinteger GUvinteger Gwvinteger GWvinteger Gyvinteger GYvinteger Gzvinteger GZvinteger G_vinteger G0vinteger G1vinteger G2vinteger G3vinteger G4vinteger G5vinteger G6vinteger G7vinteger G8vinteger G9vinteger hvvinteger hevinteger hxvinteger hovinteger hrvinteger hivinteger havinteger hnvinteger hVvinteger hEvinteger hXvinteger hOvinteger hRvinteger hIvinteger hAvinteger hNvinteger hbvinteger hBvinteger hcvinteger hCvinteger hdvinteger hDvinteger hfvinteger hFvinteger hgvinteger hGvinteger hhvinteger hHvinteger hjvstring hJv="<PlayerController>"integer hkvstring hKv="<PlayerSlotState>"integer hlvstring hLv="<Team>"integer hmvstring hMv="<StructId>"integer hpvstring hPv="<StructBoolean>"
integer hqvstring hQv="<StructTable>"integer hsvstring hSv="<StructInteger>"
integer htvstring hTv="<StructData>"integer huvstring hUv="<StructNative>"integer hwvstring hWv="<StructEvent>"integer hyvstring hYv="<StructController>"integer hzvstring hZv="<StructHostAppointment>"
integer h_vstring h0v="<StructHero>"integer h1vstring h2v="<StructKeyEvent>"integer h3vstring h4v="<StructSlotState>"integer h5vstring h6v="<StructState>"integer h7vstring h8v="<StructTeam>"integer h9vinteger Hvvinteger Hevinteger Hxvinteger Hov=0integer array Hrvinteger Hiv=Uinteger array Havboolean array Hnvboolean array HVvmapcontrol array HEv
constant integer HXv=O+8192+446*8192
constant integer HOv=O+444integer HRvinteger HIvinteger HAv=0integer array HNvinteger Hbv=Uinteger array HBvboolean array Hcvboolean array HCvplayerslotstate array Hdvconstant integer HDv=O+8192+450*8192
constant integer Hfv=O+448integer HFvinteger Hgvinteger HGvinteger Hhv=0integer array HHvinteger Hjv=Uinteger array HJvboolean array Hkvboolean array HKvinteger Hlvinteger HLv=0integer array Hmvinteger HMv=Uinteger array Hpvboolean array HPvboolean array Hqvinteger array HQvinteger array Hsvinteger HSv=Finteger array Htvconstant integer HTv=O+8192+456*8192
integer array Huvconstant integer HUv=O+474constant integer Hwv=O+8192+454*8192
constant integer HWv=O+8192+452*8192
string Hyv="User_page\\User_struct\\lala.ai"
integer HYvinteger Hzvinteger HZvinteger H_vinteger H0vgamecache H1vinteger H2v=winteger H3vinteger H4vinteger H5vinteger H6vinteger H7vinteger H8vinteger H9vstring jvv="<WeatherType>"integer jevinteger jxv=0integer array jovinteger jrv=Uinteger array jivboolean array javboolean array jnvinteger array jVvinteger jEvstring jXv="<WeatherEffect>"
integer jOvinteger jRv=0integer array jIvinteger jAv=Uinteger array jNvboolean array jbvboolean array jBvweathereffect array jcvinteger jCvinteger jdvstring jDv="<Initialization>"integer jfvstring jFv="<StructId>"integer jgvstring jGv="<StructTable>"integer jhvstring jHv="<StructInteger>"
integer jjvstring jJv="<StructData>"integer jkvstring jKv="<StructEvent>"integer jlvstring jLv="<StructLevelSets>"integer jmvstring jMv="<Act>"integer jpvinteger jPvinteger jqvinteger jQv=wboolean jsv=falseinteger jSvinteger jtvinteger jTvstring array juv
integer jUvinteger array jwvinteger array jWvconstant integer jyv=O+8192+486*8192
boolean jYvinteger jzvinteger jZvinteger j_vinteger j0vinteger j1vinteger j2vstring array j3v
integer j4vinteger j5v=0integer array j6vinteger j7v=Uinteger array j8vboolean array j9vboolean array Jvvinteger array Jevinteger array Jxvinteger Jov=Finteger array Jrvinteger array Jivinteger array Javinteger array Jnvconstant integer JVv=O+8192+484*8192
boolean array JEvstring array JXv
integer JOvinteger JRvinteger JIvinteger JAvinteger JNvinteger Jbvinteger JBvinteger Jcvinteger JCvinteger array Jdvinteger array JDvconstant integer Jfv=O+8192+532*8192
integer array JFvinteger Jgvstring JGv="<ActUpgrades>"integer Jhvstring JHv="<AfterIntro>"integer Jjvinteger JJvinteger Jkvstring JKv="<BrazierOracle>"
real Jlv
real JLv
real Jmv
real JMv
constant integer Jpv=O+562integer JPv=winteger Jqv=wreal array JQvconstant real Jsv=(2*1.)*1./ 32integer array JSvinteger Jtvinteger JTvstring Juv="<CameraQuickPosition>"integer JUvinteger Jwvinteger JWvinteger Jyvstring JYv="<MarkOfThePaw>"integer Jzvstring JZv="<CreepLoot>"
integer J_vstring J0v="<Creep>"
integer J1vstring J2v="<CreepLocation>"
integer J3vstring J4v="<StructId>"integer J5vstring J6v="<StructTable>"integer J7vstring J8v="<StructInteger>"
integer J9vstring kvv="<StructData>"integer kevstring kxv="<StructEvent>"integer kovstring krv="<CreepSet>"integer kivconstant integer kav=O+488integer array knvinteger array kVvinteger array kEvinteger array kXvboolean array kOvinteger array kRvinteger array kIvinteger kAv=Finteger array kNvinteger kbvinteger kBv=0integer array kcvinteger kCv=Uinteger array kdvboolean array kDvboolean array kfvinteger array kFvinteger kgvinteger kGvinteger khvinteger kHvinteger kjvinteger kJvconstant integer kkv=O+8192+494*8192
integer array kKvinteger klv=0integer kLv=Uboolean array kmvinteger array kMvinteger array kpvinteger array kPvreal array kqvreal array kQvstring array ksv
boolean array kSvinteger array ktvinteger array kTvconstant integer kuv=O+8192+492*8192
integer array kUvreal array kwvreal array kWvreal array kyvinteger array kYvinteger kzv=0integer array kZvinteger k_v=Uinteger array k0vboolean array k1vboolean array k2vinteger array k3vconstant integer k4v=O+8192+490*8192
integer k5vinteger k6v=0integer array k7vinteger k8v=Uinteger array k9vboolean array Kvvboolean array Kevinteger Kxvinteger Kovinteger Krvinteger Kivinteger Kavinteger Knvinteger KVvstring KEv="<DefenderSpawnLocation>"
integer KXvstring KOv="<StructId>"integer KRvstring KIv="<StructTable>"integer KAvstring KNv="<StructInteger>"
integer Kbvstring KBv="<StructData>"integer Kcvstring KCv="<StructEvent>"integer Kdvstring KDv="<DefenderSpawnType>"
integer Kfvstring KFv="<StructId>"integer Kgvstring KGv="<StructTable>"integer Khvstring KHv="<StructInteger>"
integer Kjvstring KJv="<StructData>"integer Kkvstring KKv="<DefenderSpawnGroup>"integer Klvstring KLv="<StructId>"integer Kmvstring KMv="<StructTable>"integer Kpvstring KPv="<StructInteger>"
integer Kqvstring KQv="<StructData>"integer Ksvstring KSv="<StructGroups>"integer Ktvstring KTv="<DefenderSpawnWave>"
integer Kuvstring KUv="<DefenderSpawn>"
integer Kwvinteger KWvconstant integer Kyv=O+508integer array KYvinteger array Kzvconstant integer KZv=O+8192+506*8192
integer array K_vinteger array K0vinteger array K1vinteger array K2vinteger array K3vconstant integer K4v=O+8192+502*8192
integer array K5vinteger array K6vinteger array K7vinteger array K8vinteger K9vinteger lvv=0integer array levinteger lxv=Uinteger array lovboolean array lrvboolean array livinteger lav=Finteger array lnvinteger array lVvinteger lEvinteger lXvinteger lOvinteger lRv=0integer array lIvinteger lAv=Uinteger array lNvboolean array lbvboolean array lBvinteger array lcvinteger lCv=Finteger array ldvinteger array lDvconstant integer lfv=O+8192+496*8192
integer lFvinteger lgvinteger lGv=Fboolean array lhvinteger lHv=0integer array ljvinteger lJv=Uinteger array lkvboolean array lKvboolean array llvinteger array lLvreal array lmvconstant integer lMv=O+8192+504*8192
integer lpv=0integer array lPvinteger lqv=Uinteger array lQvboolean array lsvboolean array lSvconstant integer ltv=O+8192+500*8192
integer lTvstring luv="<Difficulty>"integer lUvstring lwv="<Drop>"integer lWvinteger lyvstring lYv="Abilities\\Spells\\Items\\ResourceItems\\ResourceEffectTarget.mdx"string lzv="origin"constant integer lZv=O+8192+514*8192
constant integer l_v=O+8192+512*8192
real l0v=1.integer l1vinteger l2v=0integer array l3vinteger l4v=Uinteger array l5vboolean array l6vboolean array l7vboolean array l8vconstant integer l9v=$DB
constant integer Lvv=O+8192+l9v*8192
integer array Levconstant integer Lxv=$E7
constant integer Lov=O+8192+Lxv*8192
integer Lrvinteger Liv=0integer array Lavinteger Lnv=Uinteger array LVvboolean array LEvboolean array LXvconstant integer LOv=$94
constant integer LRv=O+8192+LOv*8192
string array LIv
integer LAvstring LNv="<EternalVial>"string Lbv="Abilities\\Spells\\Items\\AIre\\AIreTarget.mdl"string LBv="origin"constant integer Lcv=O+8192+404*8192
real array LCvreal Ldv=.5constant integer LDv=O+8192+406*8192
real Lfv=.5constant integer LFv=O+8192+407*8192
real Lgv=.5integer LGvstring Lhv="<Explosive>"
integer LHvinteger Ljvinteger LJv=0integer array Lkvinteger LKv=Uinteger array Llvboolean array LLvboolean array Lmvreal array LMvreal array Lpveffect array LPv
integer array Lqvinteger array LQvboolean array Lsvinteger array LSvinteger array Ltvinteger array LTvinteger Luv=0integer LUv=Uboolean array Lwvinteger array LWvstring array Lyv
real array LYvreal array Lzvstring LZv="Objects\\Spawnmodels\\Other\\NeutralBuildingExplosion\\NeutralBuildingExplosion.mdl"
integer L_vinteger L0vinteger L1vinteger L2vstring L3v="<GarbageCollector>"integer L4vinteger L5vinteger L6vstring L7v="<BoomerangStone>"integer L8v=0integer array L9vinteger mvv=Uinteger array mevboolean array mxvboolean array movinteger array mrvboolean array mivreal array mavreal array mnvreal array mVvconstant real mEv=(1*1.)*1./ 32real array mXvreal array mOvreal array mRvreal array mIvreal array mAvreal array mNvreal array mbvreal array mBvreal array mcvreal array mCvboolean array mdvconstant integer mDv=$CC
constant integer mfv=O+8192+mDv*8192
integer array mFvinteger array mgvinteger array mGvinteger array mhvreal array mHvreal array mjvreal array mJvreal array mkvboolean array mKvreal array mlvreal array mLvreal array mmvreal array mMvreal array mpvreal array mPvreal array mqvreal array mQvinteger msv=0integer array mSvinteger mtv=Uinteger array mTvboolean array muvboolean array mUvinteger array mwvinteger array mWvreal array myvreal array mYvreal array mzvinteger array mZvinteger m_v=3integer m0v=70real array m1vreal array m2vreal array m3vboolean array m4vreal array m5vreal array m6vinteger array m7vinteger m8v=Freal array m9vreal array Mvvreal array Mevreal Mxv
real Mov
real Mrv
trigger Mivreal array Mavinteger Mnvinteger MVvstring MEv="<Mallet>"integer MXvstring array MOv
integer MRvinteger MIvstring MAv="<PenguinFeather>"real MNv=.35
integer Mbv=3integer MBv=0integer array Mcvinteger MCv=Uinteger array Mdvboolean array MDvboolean array Mfvinteger array MFvstring Mgv="Abilities\\Spells\\Human\\Resurrect\\ResurrectTarget.mdl"string MGv="origin"integer Mhv='x'integer MHvinteger Mjvstring MJv="<RabbitsFoot>"integer Mkvinteger MKvstring Mlv="<RamblersStick>"
integer MLvinteger Mmvstring MMv="<GruntAxe>"integer Mpvinteger MPvstring Mqv="<RobynsHood>"integer MQvinteger Msvstring MSv="<ElfinDagger>"integer Mtvinteger MTvstring Muv="<StructBuff>"integer MUvinteger Mwvstring MWv="<SpearOfTheDefender>"integer Myvinteger MYvconstant integer Mzv=O+518constant real MZv=-.2integer array M_vinteger array M0vconstant integer M1v=$Aconstant real M2v=10.*1./ M1vconstant real M3v=50.*1./ M1vinteger M4vinteger M5vstring M6v="<MeteoriteShard>"integer M7vinteger M8vinteger M9vstring pvv="<GoldCoin>"integer pevinteger pxvinteger pov=0integer array prvinteger piv=Uinteger array pavboolean array pnvboolean array pVvinteger array pEvconstant integer pXv=O+520integer pOvinteger pRvinteger pIvstring pAv="<HeroRevival>"integer pNvinteger pbv=0integer array pBvinteger pcv=Uinteger array pCvboolean array pdvboolean array pDvblendmode array pfvinteger array pFvinteger array pgvinteger array pGvinteger array phvinteger array pHvinteger array pjvinteger array pJvinteger array pkvtexmapflags array pKvstring array plv
real array pLvreal array pmvreal array pMvreal array ppvreal array pPvreal array pqvreal array pQvreal array psvinteger array pSvinteger ptvinteger pTv=0integer puv=0integer array pUvinteger pwv=Uinteger array pWvboolean array pyvboolean array pYvinteger array pzvinteger array pZvstring p_v="Abilities\\Spells\\Undead\\RegenerationAura\\ObsidianRegenAura.mdl"string p0v="origin"integer array p1vinteger array p2vconstant integer p3v=O+522string p4v="Abilities\\Spells\\Undead\\CarrionSwarm\\CarrionSwarmDamage.mdl"
string p5v="chest"integer p6v=$Ainteger p7v='d'integer p8vconstant real p9v=(4*1.)*1./ 32integer Pvvstring Pev="Abilities\\Spells\\Human\\ReviveHuman\\ReviveHuman.mdl"string Pxv="origin"integer Pov=5integer Prv=1real Piv=.5integer Pavinteger Pnvstring PVv="<HeroSelection>"
integer PEvinteger PXvinteger POvinteger array PRvinteger PIvconstant integer PAv=O+524integer array PNvinteger array Pbvreal array PBvreal array Pcvreal array PCvinteger Pdv=0integer array PDvinteger Pfv=Uinteger array PFvboolean array Pgvboolean array PGvinteger array Phvstring PHv="Abilities\\Spells\\NightElf\\Blink\\BlinkTarget.mdl"
string Pjv="Abilities\\Spells\\Items\\TomeOfRetraining\\TomeOfRetrainingCaster.mdl"string PJv="origin"string array Pkv
integer array PKvconstant integer Plv=O+8192+526*8192
real PLv
real Pmv
integer PMvinteger Ppv=0integer array PPvinteger Pqv=Uinteger array PQvboolean array Psvboolean array PSvstring array Ptv
integer array PTvinteger Puvinteger PUvinteger Pwvinteger PWvinteger Pyvinteger PYvinteger Pzvinteger PZvinteger P_vinteger P0vinteger P1vinteger P2vinteger P3vinteger P4vinteger P5vinteger P6vreal P7v
real P8v
integer P9vinteger qvvregion array qev
integer qxv=0integer array qovinteger qrv=Uinteger array qivboolean array qavboolean array qnvinteger array qVvinteger array qEvconstant integer qXv=$D6
constant integer qOv=O+qXvinteger array qRvconstant integer qIv=$D5
constant integer qAv=O+8192+qIv*8192
integer qNvstring qbv="<Hint>"integer qBv=0integer array qcvinteger qCv=Uinteger array qdvboolean array qDvboolean array qfvstring array qFv
integer qgv=Finteger array qGvinteger array qhvinteger qHvstring qjv="<StructTarget>"integer qJvinteger qkvinteger qKvinteger qlvstring qLv="<HorseRide>"
integer qmvgroup qMvinteger qpvinteger qPvinteger array qqvinteger array qQvinteger array qsvinteger array qSvinteger array qtvinteger qTv=-65constant real quv=(2*1.)*1./ 32integer qUv=0integer array qwvinteger qWv=Uinteger array qyvboolean array qYvboolean array qzvreal array qZvreal array q_vreal array q0vreal array q1vinteger array q2vinteger array q3vconstant integer q4v=$C9
constant integer q5v=O+8192+q4v*8192
integer q6v=Finteger array q7vinteger array q8vreal q9v=.5integer array Qvvinteger Qev=$C8integer Qxvinteger array Qovinteger Qrv=0integer Qiv=Uboolean array Qavstring Qnv="UI\\Feedback\\WaypointFlags\\WaypointFlag.mdl"string QVv="origin"string QEv="Abilities\\Spells\\Human\\Polymorph\\PolyMorphDoneGround.mdl"string QXv="origin"integer QOv=2string QRv="Abilities\\Spells\\Human\\Polymorph\\PolyMorphDoneGround.mdl"string QIv="origin"integer QAvstring QNv="<StructUser>"integer Qbvstring QBv="<Infoboard>"
integer Qcvinteger array QCvinteger Qdv=winteger QDvinteger Qfvinteger QFvinteger Qgvinteger QGvinteger Qhvinteger QHvboolean array Qjvinteger array QJvboolean array Qkvboolean array QKvboolean array Qlvboolean array QLvboolean array Qmvboolean array QMvboolean array Qpvinteger QPvstring array Qqv
integer QQvinteger Qsv=0integer array QSvinteger Qtv=Uinteger array QTvboolean array Quvboolean array QUvinteger Qwvinteger QWv=0integer array Qyvinteger QYv=Uinteger array Qzvboolean array QZvboolean array Q_vinteger array Q0vinteger array Q1vconstant integer Q2v=$CF
constant integer Q3v=O+Q2vinteger Q4vstring Q5v="<Infocard>"integer Q6v=0integer array Q7vinteger Q8v=Uinteger array Q9vboolean array svvboolean array sevquest array sxvstring sovstring srv="About month ago, two peculiarly luminescent comets draught across the sky. While one featured a blue color and immediately vanished again behind the horizont, the red one bolted right into the capital of the united species of this planet. The shock wave tore apart buildings and roads and devastated most of the town. Many lost their lives."string siv="As if this was not enough already, the sky darkened the day after and it became bitterly cold. Only the of a strange material consisting meteorite seemed to spend some even weirder soothing warmth. Though, the sky cleared a bit within time, the cold persisted and drove us to leave this place since a reconstruction appeared impossible before we would freeze to death. We fleed to the adjacent shire of count Dracula who there possesses a big castle which is directly worked into the Crystal Mountains. We also brought the meteorite with us whose still thermal energies emitting nature easily mesmerized us."
string sav="Since that time we try to get along with the small rations here and hope that the sun will return to us someday. Yet, the problems pile up: Besides the lack of food and the ongoing frost which we call the "+"\""+"Big Winter"+"\""+", the surrounding forest's inhabitants are becoming very anxious, too. The last three weeks, there were twenty attacks and break-ins by wolves and other confused animals. Most of us refugees do not dare to leave the castle anymore. And how long will the strange stone keep on giving us strength and hope?"
integer snvinteger sVvstring sEv="<Intro>"
integer sXvinteger sOvinteger sRvinteger sIvinteger sAvinteger sNv=0integer array sbvinteger sBv=Uinteger array scvboolean array sCvboolean array sdvconstant integer sDv=O+8192+76*8192integer sfv=0integer array sFvinteger sgv=Uinteger array sGvboolean array shvboolean array sHvstring array sjv
integer array sJvinteger array skvinteger array sKvinteger array slvinteger sLv=0integer array smvinteger sMv=Uinteger array spvboolean array sPvboolean array sqvinteger array sQvconstant integer ssv=O+8192+74*8192integer array sSvstring array stv
constant integer sTv=O+8192+80*8192constant integer suv=O+8192+84*8192constant integer sUv=O+8192+82*8192constant integer swv=O+510integer sWv=Finteger array syvinteger array sYvinteger szvinteger array sZvinteger s_v=0integer array s0vinteger s1v=Uinteger array s2vboolean array s3vboolean array s4vinteger array s5vreal array s6vinteger array s7vinteger s8vconstant integer s9v=O+586integer array Svvinteger Sevboolean Sxvinteger Sov=0string Srv="<Artifact>"integer array Sivinteger Sav=Uinteger array Snvboolean array SVvboolean array SEvinteger SXvinteger SOvinteger SRvinteger SIvinteger SAvinteger SNvinteger Sbvinteger SBvinteger Scvinteger SCvinteger Sdvinteger SDvinteger Sfvinteger SFvinteger Sgvinteger SGvinteger Shvinteger SHvinteger Sjvinteger SJvinteger Skvinteger SKvinteger Slvinteger SLvinteger Smvinteger SMvinteger Spv=0integer array SPvinteger Sqv=Uinteger array SQvboolean array Ssvboolean array SSvcamerasetup array Stvinteger STvinteger Suvinteger SUvinteger Swvinteger SWvinteger Syvinteger SYvinteger Szvinteger SZvinteger S_vinteger S0vinteger S1vinteger S2vinteger S3vinteger S4vinteger S5vinteger S6vinteger S7vinteger S8vinteger S9vinteger tvvinteger tevinteger txvinteger tovinteger trvinteger tivinteger tavinteger tnvinteger tVvinteger tEvinteger tXvinteger tOvinteger tRvinteger tIvconstant real tAv=.5*3.141592654
integer tNvinteger tbvstring tBv="Sound\\Ambient\\DoodadEffects\\LordaeronSummerBrazierLoop1.wav"integer tcvstring tCv="<StructId>"integer tdvstring tDv="<StructTable>"integer tfvstring tFv="<StructInteger>"
integer tgvstring tGv="<StructData>"integer thvstring tHv="<StructLevels>"integer tjvstring tJv="<StructQuery>"integer tkvstring tKv="<LevelSet>"integer tlvstring tLv="<StructId>"integer tmvstring tMv="<StructTable>"integer tpvstring tPv="<StructInteger>"
integer tqvstring tQv="<StructReal>"integer tsvstring tSv="<StructData>"integer ttvstring tTv="<StructEvent>"integer tuvstring tUv="<Level>"
integer twv=0integer array tWvinteger tyv=Uinteger array tYvboolean array tzvboolean array tZvconstant integer t_v=O+8192+534*8192
integer t0vinteger t1vinteger t2vinteger t3vinteger t4vinteger t5vinteger t6vinteger t7vinteger t8vinteger t9vinteger Tvvinteger Tevinteger Txvinteger Tovinteger Trvstring array Tiv
integer Tavinteger array Tnvinteger TVv=0integer array TEvinteger TXv=Uinteger array TOvboolean array TRvboolean array TIvconstant integer TAv=O+8192+530*8192
integer TNvstring Tbv="<Library>"integer TBvinteger Tcvinteger TCvstring Tdv="<Lumber>"integer TDvconstant integer Tfv=O+538integer array TFvreal array Tgvreal array TGvinteger array Thvinteger array THvinteger Tjv=0integer array TJvinteger Tkv=Uinteger array TKvboolean array Tlvboolean array TLvinteger array Tmvinteger array TMvinteger array Tpvconstant integer TPv=$Finteger Tqvstring TQv="<StructQuestLog>"integer Tsvstring TSv="<Nullboard>"
integer Ttvinteger TTvinteger Tuvinteger TUvinteger Twvinteger TWvinteger Tyvinteger TYvinteger Tzvstring array TZv
integer array T_vboolean T0v=falsequest T1vinteger T2vstring T3v="<StructCameraSmoothing>"
integer T4vstring T5v="<StructCameraZoom>"integer T6vstring T7v="<StructEffectLevel>"
integer T8vstring T9v="<StructHint>"integer uvvstring uev="<StructMusicVolume>"
integer uxvstring uov="<StructSoundVolume>"
integer urvstring uiv="<OptionsBoard>"integer uavinteger unvinteger uVvinteger uEv=0integer array uXvinteger uOv=Uinteger array uRvboolean array uIvboolean array uAvinteger uNvinteger ubvstring uBv="<Pharmacy>"integer ucvinteger uCvinteger udvstring uDv="<EmergencyProvisions>"string ufv="Abilities\\Spells\\Human\\Heal\\HealTarget.mdl"string uFv="origin"integer ugv='d'integer uGvinteger uhvinteger uHvinteger ujvinteger uJvinteger ukvstring uKv="<EyeOfTheFlame>"
integer ulv=1integer uLv=40integer umvstring uMv="<TorchLight>"integer upvinteger uPvinteger uqvinteger uQv=2integer usv=5integer uSvinteger array utvinteger uTvinteger uuvinteger uUvinteger uwvstring uWv="<HerbalOintment>"integer uyvinteger uYvinteger uzv=$Ainteger uZv=1integer array u_vinteger array u0vreal u1v
real u2v
integer u3v=$C8integer u4v=$C8integer u5vinteger u6vstring u7v="<StructTarget>"integer u8vconstant integer u9v=$E2
constant integer Uvv=O+8192+u9v*8192
integer Uevinteger Uxvstring Uov="<ScrollOfProtection>"integer Urvinteger Uivstring Uav="Abilities\\Spells\\Items\\AIda\\AIdaCaster.mdl"integer Unv=30integer UVvinteger UEvstring UXv="<StructBuff>"integer UOvinteger URvinteger UIvstring UAv="<FireWater>"
string UNv="Abilities\\Spells\\Items\\AIma\\AImaTarget.mdl"string Ubv="origin"integer UBv=750integer Ucv=$Freal UCv
integer Udv=30real UDv=.35
integer Ufvinteger UFvreal array Ugvinteger array UGvinteger Uhvinteger UHvinteger Ujvinteger array UJvinteger Ukvinteger UKvstring Ulv="<IceTea>"string ULv="Abilities\\Spells\\Items\\AIma\\AImaTarget.mdl"string Umv="origin"integer UMvinteger Upvinteger UPvstring Uqv="<Meat>"integer UQvconstant integer Usv=O+8192+540*8192
integer array USvinteger array Utvinteger array UTvboolean array Uuvinteger array UUvinteger Uwvinteger UWv=$Ainteger Uyv=1integer UYv=0integer Uzv=Uboolean array UZvinteger array U_vstring U0v="Abilities\\Spells\\Human\\Heal\\HealTarget.mdl"string U1v="origin"real U2v
integer U3v=300integer U4vstring U5v="<TeleportScroll>"integer U6vinteger U7vinteger U8vreal U9v
integer wvv=$400
integer wevconstant integer wxv=O+8192+542*8192
integer wovinteger wrvreal wiv
real wav
integer array wnvinteger array wVvstring wEv="Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTo.mdl"string wXv="origin"real array wOvreal array wRvstring wIv="Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl"string wAv="origin"integer wNvinteger wbvstring wBv="<Rune>"integer wcvinteger wCvinteger wdvinteger wDv=0integer wfv=$Cinteger wFv=0integer array wgvinteger wGv=Uinteger array whvboolean array wHvboolean array wjvinteger array wJvinteger array wkvconstant integer wKv=O+544integer wlvinteger wLv=20string wmv="Abilities\\Spells\\Other\\Andt\\Andt.mdl"integer wMv=$C8real wpv=.15
real wPv=.15
integer wqvinteger wQvinteger wsvinteger wSvstring wtv="<Snowmen>"integer wTvinteger wuv=0string wUv="Snowmen_page\\Snowmen_struct\\Possession.mdx"string wwv="origin"integer wWvstring wyv="<SpawnLocation>"
integer wYvstring wzv="<StructId>"integer wZvstring w_v="<StructTable>"integer w0vstring w1v="<StructInteger>"
integer w2vstring w3v="<StructData>"integer w4vstring w5v="<SpawnGroup>"integer w6vstring w7v="<StructId>"integer w8vstring w9v="<StructTable>"integer Wvvstring Wev="<StructInteger>"
integer Wxvstring Wov="<StructTable>"integer Wrvstring Wiv="<StructReal>"integer Wavstring Wnv="<StructData>"integer WVvstring WEv="<StructGroups>"integer WXvstring WOv="<SpawnWave>"
integer WRvstring WIv="<StructQueue>"integer WAvstring WNv="<StructShadow>"integer Wbvinteger WBvstring Wcv="<Spawn>"
integer WCvinteger Wdvboolean array WDvinteger Wfv=Finteger WFvinteger array Wgvinteger array WGvinteger array Whvinteger array WHvconstant integer Wjv=O+8192+558*8192
constant integer WJv=O+8192+560*8192
integer array Wkvinteger WKvtimerdialog array Wlvinteger WLvreal array Wmvreal array WMvreal array Wpvreal array WPvconstant integer Wqv=O+8192+556*8192
integer array WQvinteger array Wsvconstant integer WSv=O+8192+548*8192
real array Wtvreal array WTvreal array Wuvreal array WUvreal array Wwvconstant integer WWv=O+8192+552*8192
constant integer Wyv=O+8192+550*8192
integer WYv=0integer array Wzvinteger WZv=Uinteger array W_vboolean array W0vboolean array W1vinteger array W2vinteger array W3vreal array W4vreal array W5vreal array W6vinteger W7v=winteger array W8vinteger array W9vinteger yvv=winteger yevinteger array yxvinteger yov=Finteger array yrvinteger array yivinteger array yavinteger array ynvinteger array yVvinteger array yEvinteger yXv=Finteger yOv=0integer array yRvinteger yIv=Uinteger array yAvboolean array yNvboolean array ybvinteger yBvconstant integer ycv=O+8192+405*8192
integer yCvconstant integer ydv=O+564integer yDvinteger yfvinteger array yFvinteger ygvinteger yGvinteger yhv=winteger array yHvinteger array yjvinteger yJv=winteger ykvinteger array yKvinteger ylv=Finteger yLvconstant integer ymv=O+574integer yMv=0integer array ypvinteger yPv=Uinteger array yqvboolean array yQvboolean array ysvinteger ySv=0integer ytv=Finteger array yTvinteger array yuvinteger yUvinteger ywvinteger yWvinteger yyvinteger array yYvconstant integer yzv=O+8192+568*8192
integer yZv=0string y_v="<SpawnType>"
integer array y0vinteger y1v=Uinteger array y2vboolean array y3vboolean array y4vinteger y5vinteger y6v=Finteger array y7vinteger array y8vconstant integer y9v=O+8192+566*8192
integer Yvvboolean array Yevinteger Yxvboolean array Yovinteger Yrvboolean array Yivinteger Yavinteger Ynvinteger YVvboolean array YEvboolean array YXvinteger YOvinteger YRvinteger YIvinteger YAvinteger YNvinteger Ybvinteger YBvinteger Ycvinteger YCvinteger Ydvinteger YDvinteger Yfvboolean array YFvinteger Ygvinteger YGvinteger Yhvboolean array YHvinteger Yjvinteger YJvinteger Ykvinteger YKvinteger Ylvinteger YLvinteger Ymvinteger YMvinteger Ypv=0integer array YPvinteger Yqv=Uinteger array YQvboolean array Ysvboolean array YSvconstant integer Ytv=O+8192+554*8192
integer array YTvinteger Yuv=0integer array YUvinteger Ywv=Uinteger array YWvboolean array Yyvboolean array YYvconstant integer Yzv=O+8192+546*8192
boolean array YZvinteger Y_vstring Y0v="<StructId>"integer Y1vstring Y2v="<StructTable>"integer Y3vstring Y4v="<StructInteger>"
integer Y5vstring Y6v="<StructData>"integer Y7vstring Y8v="<StructEvent>"integer Y9vstring zvv="<StructChampion>"integer zevstring zxv="<StructItems>"integer zovstring zrv="<StructInfo>"integer zivinteger zavinteger znvstring zVv="<Tavern>"integer zEvinteger zXvinteger zOvinteger zRvstring zIv="<TropicalRainbow>"integer zAv=60integer zNvinteger zbvstring zBv="<StructAgi>"
integer zcvinteger zCvstring zdv="<StructInt>"
integer zDvinteger zfvstring zFv="<StructStr>"
integer zgvstring zGv="<Tomes>"
constant integer zhv=O+572integer array zHvstring zjv="Abilities\\Spells\\Items\\AIam\\AIamTarget.mdl"string zJv="origin"string zkv="Abilities\\Spells\\Items\\AIsm\\AIsmTarget.mdl"string zKv="origin"string zlv="Abilities\\Spells\\Items\\AIsm\\AIsmTarget.mdl"string zLv="origin"integer zmvstring zMv="<UnitNameTag>"integer zpvinteger array zPvinteger zqvinteger zQvstring zsv="<UnitStatus>"integer zSvinteger ztvinteger zTvinteger array zuvreal zUv=.0real zwv=.0real zWv=.0integer zyvinteger zYvinteger zzvinteger zZvinteger z_vconstant real z0v=(.05*32)*.125integer z1vinteger z2vinteger z3vinteger z4vinteger z5vinteger z6vinteger z7vinteger z8vinteger z9vinteger Zvv=0integer Zevinteger Zxvinteger Zovstring Zrv="<VictoryRush>"integer Zivstring Zav="Abilities\\Spells\\NightElf\\BattleRoar\\RoarCaster.mdx"
integer Znvinteger ZVv=400integer ZEvinteger ZXv=$Finteger ZOvstring ZRv="<StructRetreat>"
integer ZIvinteger ZAvstring ZNv="<StructRegionCheck>"
integer Zbvstring ZBv="<StructSpawns>"integer Zcvstring ZCv="<Waypoint>"integer Zdv=0integer array ZDvinteger Zfv=Uinteger array ZFvboolean array Zgvboolean array ZGvinteger array Zhvinteger ZHvinteger array Zjvinteger ZJv=5integer Zkvinteger ZKvinteger Zlvinteger ZLvinteger Zmvinteger ZMv=Finteger array Zpvinteger array ZPvinteger Zqv=Finteger ZQvstring Zsv="<Zoom>"integer ZSvreal array Ztvreal array ZTvinteger Zuv=Finteger array ZUvinteger array Zwvconstant real ZWv=20*Ojconstant integer Zyv=O+8192+60*8192integer array ZYvinteger array Zzvboolean array ZZvinteger array Z_vinteger array Z0vinteger Z1v=Finteger array Z2vinteger Z3v=0integer Z4v=Uboolean array Z5vinteger array Z6vreal array Z7vconstant real Z8v=(1*1.)*1./ 32real array Z9vinteger array vvereal array veeinteger vxestring voe="<AxeFighter>"integer vreinteger vieinteger vaestring vne="<Balduir>"integer vVeinteger vEeinteger vXestring vOe="<StructId>"integer vRestring vIe="<StructBoolean>"
integer vAestring vNe="<StructTable>"integer vbestring vBe="<StructInteger>"
integer vcestring vCe="<StructData>"integer vdestring vDe="<StructEvent>"integer vfestring vFe="<StructTarget>"integer vgestring vGe="<Aura>"integer vheinteger vHeinteger vjeconstant integer vJe=O+8192+579*8192
integer array vkeinteger array vKeinteger vle=Finteger array vLeinteger vmeinteger array vMeinteger vpe=Finteger array vPereal array vqeinteger array vQeinteger array vseinteger array vSeinteger array vteinteger vTeinteger vueinteger vUeinteger vwestring vWe="<AIBoost>"integer vye=0integer array vYeinteger vze=Uinteger array vZeboolean array v_eboolean array v0einteger array v1econstant integer v2e=O+8192+'r'*8192
integer array v3econstant integer v4e=O+'p'constant integer v5e=O+8192+'t'*8192
constant integer v6e=$7E
constant integer v7e=O+8192+v6e*8192
integer array v8einteger array v9econstant integer eve=O+8192+'|'*8192
timer array eeereal array exeboolean array eoeinteger ere=0integer array eieinteger eae=Uinteger array eneboolean array eVeboolean array eEeinteger array eXeinteger array eOeinteger array eReinteger eIe=kAconstant integer eAe=$80
constant integer eNe=O+8192+eAe*8192
constant integer ebe=O+8192+'z'*8192
constant integer eBe=$BC
constant integer ece=O+8192+eBe*8192
constant integer eCe=O+8192+'x'*8192
integer edeinteger eDeinteger efestring eFe="<Boost>"
integer ege=3integer eGestring ehe="<AIBurningSpirit>"integer eHeinteger ejeinteger eJe=0integer array ekeinteger eKe=Uinteger array eleboolean array eLeboolean array emeconstant integer eMe=$F4
constant integer epe=O+eMeconstant integer ePe=$F2
constant integer eqe=O+8192+ePe*8192
integer array eQeinteger esestring eSe="<BurningSpirit>"
integer etestring eTe="<AIChaosBall>"integer eueinteger eUestring ewe="<ChaosBall>"
integer eWeinteger eyeinteger eYeboolean array ezeboolean array eZeinteger array e_einteger array e0einteger array e1econstant integer e2e=O+580integer e3e=80constant real e4e=(1*1.)*1./ 32integer e5e=0integer array e6einteger e7e=Uinteger array e8eboolean array e9eboolean array xvereal array xeeinteger array xxeinteger array xoeconstant integer xre=$C7
constant integer xie=O+8192+xre*8192
integer xae=Finteger array xneinteger array xVereal array xEeinteger array xXestring xOe="Objects\\Spawnmodels\\Undead\\UCancelDeath\\UCancelDeath.mdl"integer xRe=65integer xIe=2integer xAe=3real array xNereal array xbereal array xBeinteger array xceinteger xCe=Finteger xde=300integer xDeinteger xfestring xFe="<StructTarget>"integer xgestring xGe="<EnergyCharge>"integer xheinteger xHeinteger array xjeinteger xJe=3integer array xkeinteger array xKestring xle="Abilities\\Spells\\Orc\\SpiritLink\\SpiritLinkTarget.mdx"string xLe="chest"string xme="Abilities\\Weapons\\WitchDoctorMissile\\WitchDoctorMissile.mdx"string xMe="hand right"integer xpeinteger xPe=30integer xqestring xQe="<AIFlamelet>"integer xseinteger xSeinteger xtestring xTe="<Flamelet>"integer xueinteger xUeinteger array xwestring xWe="Abilities\\Spells\\Other\\Incinerate\\IncinerateBuff.mdl"string xye="weapon"integer array xYestring xze="Abilities\\Spells\\Other\\BreathOfFire\\BreathOfFireDamage.mdl"string xZe="origin"integer x_e=0integer array x0einteger x1e=Uinteger array x2eboolean array x3eboolean array x4ereal array x5einteger x6e=40integer array x7ereal array x8ereal array x9ereal array oveinteger oee=900real oxe=1.5
integer ooe=5integer orestring oie="<FuzzyAttack>"real oae
real one=2.5
integer oVe=7constant integer oEe=O+8192+581*8192
integer array oXeinteger array oOeinteger array oReinteger array oIeinteger array oAeboolean array oNeinteger obe=0integer oBe=Uboolean array oceinteger array oCeinteger array odeinteger oDe=50integer ofeinteger oFestring oge="<StructBuff>"integer oGestring ohe="<GreenNova>"
real oHe
real oje=.125integer oJe=$Ainteger okereal oKe
integer ole=600integer oLeinteger ome=0integer array oMeinteger ope=Uinteger array oPeboolean array oqeboolean array oQereal array oseinteger array oSeinteger array oteinteger array oTereal array ouereal array oUereal array owereal array oWeinteger oye=$C8string oYe="Abilities\\Spells\\NightElf\\EntanglingRoots\\EntanglingRootsTarget.mdl"
integer oze=3integer oZe=6integer o_estring o0e="<AIHeal>"integer o1einteger o2e=50integer o3estring o4e="<Heal>"string o5e="Abilities\\Spells\\Human\\HolyBolt\\HolyBoltSpecialArt.mdl"string o6e="origin"integer o7estring o8e="<AIHealExplosion>"integer o9einteger rveinteger reestring rxe="<HealExplosion>"
integer roeinteger array rrestring rie="HealExplosion_page\\HealExplosion_struct\\Charge2.mdx"string rae="weapon"integer array rnestring rVe="Abilities\\Spells\\Items\\StaffOfPurification\\PurificationCaster.mdl"string rEe="chest"string rXe="Abilities\\Spells\\Human\\MarkOfChaos\\MarkOfChaosDone.mdl"string rOe="chest"integer rRe=40integer rIe=$Fstring rAe="Abilities\\Spells\\Items\\StaffOfPurification\\PurificationTarget.mdl"string rNe="chest"integer rbestring rBe="<IceArrows>"
integer rceinteger rCeinteger rdestring rDe="Abilities\\Spells\\Undead\\FrostNova\\FrostNovaTarget.mdl"string rfe="origin"integer rFe=3integer rge=6integer rGe=25integer rheinteger rHestring rje="<LightningShield>"real rJe
integer rke=20real rKe=.5integer rleinteger rLereal array rmeinteger array rMeinteger array rpeinteger rPe=20integer rqestring rQe="<StructRevival>"
integer rseinteger rSestring rte="<LunarRestoration>"integer rTeinteger rueinteger rUeinteger array rweinteger array rWeinteger array ryeinteger array rYeinteger array rzeboolean array rZeinteger r_einteger array r0einteger array r1einteger array r2estring r3e="Abilities\\Spells\\Orc\\Reincarnation\\ReincarnationTarget.mdl"real array r4ereal array r5ereal r6e=4.5
integer r7e=1real r8e=.3integer r9estring ive="<AIPurge>"integer ieeinteger ixeinteger ioestring ire="<Purge>"
integer iiereal iae
integer array ineinteger iVe=6integer array iEeinteger array iXereal iOe=-.7
integer iRe=3integer iIe=6integer iAeinteger iNestring ibe="<StructTarget>"integer iBestring ice="<SoakingPoison>"
integer array iCeinteger array ideinteger iDeinteger ifeinteger iFeinteger ige=2integer iGe=4integer ihereal iHe
integer ije=5real iJe=.5integer array ikereal array iKeinteger array ileinteger iLestring ime="<Stampede>"integer iMereal ipe
real iPe=.2real iqe=.035real iQe
integer ise=500integer iSe=300integer ite=$514
integer iTereal iue
constant real iUe=(2*1.)*1./ 32real iwe
integer iWeinteger array iyereal array iYereal array izeinteger array iZereal array i_ereal array i0ereal array i1ereal array i2estring i3e="Abilities\\Weapons\\AncientProtectorMissile\\AncientProtectorMissile.mdl"real i4e=.5string i5e="Abilities\\Weapons\\HydraliskImpact\\HydraliskImpact.mdl"string i6e="chest"integer i7estring i8e="<AIStomp>"integer i9einteger aveinteger aeestring axe="<Stomp>"
string aoe="Abilities\\Spells\\Orc\\WarStomp\\WarStompCaster.mdl"integer are=2integer aie=25integer aaestring ane="<Barrage>"integer aVereal aEe
integer aXe='d'real aOe=.3integer aReinteger aIereal array aAeinteger array aNeinteger abe=50integer aBestring ace="<AIBouncyBomb>"integer aCeinteger adestring aDe="<BouncyBomb>"integer afeinteger aFeinteger ageinteger aGe=3constant real ahe=(2*1.)*1./ 32real aHe
integer aje=-$3E8integer aJe=0integer array akeinteger aKe=Uinteger array aleboolean array aLeboolean array ameinteger aMe=1integer array apeinteger array aPereal array aqereal array aQereal array aseinteger array aSeinteger array atereal array aTereal array auereal array aUeinteger awe=1string aWe="Objects\\Spawnmodels\\Human\\FragmentationShards\\FragBoomSpawn.mdl"
integer aye='x'integer aYe=40integer azestring aZe="<BurningOil>"integer a_ereal a0e
integer a1e=26real a2e=.75
integer a3einteger a4einteger a5e=0integer array a6einteger a7e=Uinteger array a8eboolean array a9eboolean array nveinteger array neeinteger array nxeinteger array noeinteger array nrestring nie="Abilities\\Spells\\Orc\\LiquidFire\\Liquidfire.mdl"real array naereal array nneinteger nVeinteger nEe=6integer nXeinteger nOeinteger nRestring nIe="<ChainLightning>"integer nAeinteger nNeinteger nbeinteger nBe=0integer array nceinteger nCe=Uinteger array ndeboolean array nDeboolean array nfereal array nFeinteger array ngereal array nGeinteger nhe='x'real array nHereal nje=.1integer array nJeinteger array nkeinteger nKe=6integer array nleinteger array nLeinteger array nmeinteger array nMeinteger npe=0integer nPe=Uboolean array nqeconstant real nQe=(2*1.)*1./ 32string nse="Abilities\\Spells\\Items\\AIlb\\AIlbSpecialArt.mdl"string nSe="chest"integer ntetrigger nTeinteger nuestring nUe="<StructId>"integer nwestring nWe="<StructTable>"integer nyestring nYe="<StructInteger>"
integer nzestring nZe="<StructData>"integer n_estring n0e="<StructWave>"integer n1estring n2e="<Cleaver>"boolean array n3eboolean array n4einteger array n5einteger array n6einteger array n7einteger array n8einteger array n9ereal array Vveinteger Vee=700integer array Vxeinteger array Voeinteger array Vreconstant integer Vie=O+8192+582*8192
real Vae=.035constant integer Vne=O+8192+583*8192
integer VVereal array VEereal array VXeinteger VOe='}'integer VReinteger VIe=40constant real VAe=(2*1.)*1./ 32real array VNereal array Vbeinteger array VBereal Vce
integer array VCeinteger array Vdeboolean array VDeinteger Vfe=0integer VFe=Uboolean array Vgeinteger VGe='}'integer array Vhereal VHe
integer Vje=650integer VJe=600integer Vkeinteger VKestring Vle="<ColdResistance>"integer VLestring Vme="<DeathAxe>"integer VMeinteger Vpe=0integer array VPeinteger Vqe=Uinteger array VQeboolean array Vseboolean array VSeinteger array Vtereal array VTeinteger Vue=70integer array VUeinteger array Vweinteger VWe=1integer Vyeinteger VYe=3string Vze="Abilities\\Weapons\\VengeanceMissile\\VengeanceMissile.mdx"string VZe="origin"integer V_einteger V0einteger V1estring V2e="<StructTarget>"integer V3estring V4e="<DrumRoll>"integer V5einteger V6einteger V7e=0integer array V8einteger V9e=Uinteger array Eveboolean array Eeeboolean array Exeinteger array Eoeconstant integer Ere=O+8192+578*8192
integer array Eieinteger array Eaeinteger array Eneinteger EVeinteger EEeinteger array EXeinteger EOe=Finteger array EReinteger EIeinteger EAestring ENe="<StructTarget>"integer Ebestring EBe="<EnvenomedSpears>"integer Eceinteger ECeinteger Ede=1integer EDe=3real Efe
integer EFe=20real Ege=.5integer array EGereal array Eheinteger array EHeinteger Ejestring EJe="<AIKnockout>"integer Ekeinteger EKeinteger Elestring ELe="<StructTarget>"integer Emestring EMe="<Knockout>"boolean array Epeboolean array EPeinteger array Eqeinteger array EQeinteger array Eseinteger ESe=5integer Ete=30integer ETe=2integer Euestring EUe="<AIMedipack>"integer Ewe=$96integer EWestring Eye="<Medipack>"string EYe="Medipack_page\\Medipack_struct\\Medipack3.mdx"string Eze="chest"integer EZestring E_e="<MutingShout>"integer E0einteger E1einteger E2estring E3e="Abilities\\Spells\\NightElf\\BattleRoar\\RoarCaster.mdl"
integer E4e=4real E5e=.05
integer E6estring E7e="<Realplex>"integer E8econstant integer E9e=O+584integer array Xveinteger array Xeeinteger array Xxeboolean array Xoeinteger array Xreinteger array Xieinteger Xaeinteger Xneinteger XVe='d'integer XEe=2string XXe="Abilities\\Spells\\Orc\\MirrorImage\\MirrorImageCaster.mdl"integer XOe=0integer XRe=Uboolean array XIeconstant real XAe=Oj*4integer XNe=0integer Xbe=Uboolean array XBeinteger array Xcereal array XCereal array Xdereal array XDereal Xfe=.5integer XFe=$Astring Xge="Abilities\\Spells\\Orc\\MirrorImage\\MirrorImageDeathCaster.mdl"
integer XGeinteger Xhestring XHe="<SerpentWard>"integer Xje=0integer array XJeinteger Xke=Uinteger array XKeboolean array Xleboolean array XLeinteger array Xmereal array XMereal array Xpeinteger XPe=3integer Xqe=20integer XQeinteger Xsestring XSe="<SpiritWolves>"integer Xteconstant integer XTe=O+585integer array Xueinteger array XUeinteger array Xweinteger array XWeinteger array Xyeboolean array XYeinteger Xze=2integer XZe=0integer X_e=Uboolean array X0einteger X1e=70integer X2e=40integer X3estring X4e="<Stormbolt>"
boolean array X5eboolean array X6einteger array X7einteger array X8einteger X9e=3integer Ove='d'integer Oeeinteger Oxeinteger Ooestring Ore="<SummonMinions>"
integer Oiereal Oae
integer One=6integer array OVeinteger array OEeinteger OXe=500integer OOe=2real array OReinteger array OIeinteger array OAeconstant integer ONe=O+8192+266*8192
constant integer Obe=O+8192+268*8192
integer OBeinteger Oce=20integer OCe=0integer array Odeinteger ODe=Uinteger array Ofeboolean array OFeboolean array Ogeconstant integer OGe=O+8192+264*8192
integer Ohe=1integer OHe=1integer Ojeinteger OJestring Oke="<StructMissile>"
integer OKestring Ole="<BatSwarm>"integer array OLeinteger array Omeinteger array OMeinteger array Opeinteger array OPeinteger Oqeinteger OQeinteger Oseinteger OSe=0integer array Oteinteger OTe=Uinteger array Oueboolean array OUeboolean array Oweinteger array OWereal array Oyereal array OYeinteger array Ozestring OZe="Abilities\\Weapons\\LocustMissile\\LocustMissile.mdl"string O_e="chest"integer O0estring O1e="<HawkEye>"integer array O2ereal array O3einteger array O4einteger array O5einteger array O6einteger O7einteger O8einteger O9einteger Rveinteger Ree=0integer array Rxeinteger Roe=Uinteger array Rreboolean array Rieboolean array Raereal array Rneinteger RVeinteger REestring RXe="Abilities\\Spells\\Human\\Flare\\FlareCaster.mdl"string ROe="HawkEye_page\\HawkEye_struct\\area.mdx"integer RReinteger array RIereal array RAeinteger RNestring Rbe="<StructBuff>"integer array RBereal array Rceinteger RCestring Rde="<MagicBottle>"integer RDe=0integer array Rfeinteger RFe=Uinteger array Rgeboolean array RGeboolean array Rheinteger array RHeinteger array Rjeinteger array RJestring Rke="Abilities\\Spells\\Items\\AIil\\AIilTarget.mdl"string RKe="origin"integer array Rleinteger array RLeinteger Rmestring RMe="<StructAir>"
integer Rpestring RPe="<RedwoodValkyrie>"integer Rqeinteger array RQereal array Rseinteger array RSeinteger array Rteinteger RTeinteger Rueinteger array RUeinteger array Rwestring RWe="Abilities\\Spells\\Other\\Incinerate\\IncinerateBuff.mdl"string Rye="weapon"boolean array RYeboolean array Rzeinteger array RZestring R_e="Abilities\\Spells\\Other\\BreathOfFire\\BreathOfFireDamage.mdl"string R0e="origin"integer R1einteger R2einteger R3e=1integer R4e=$5DC
integer R5e=0integer array R6einteger R7e=Uinteger array R8eboolean array R9eboolean array Ivereal array Ieereal array Ixereal array Ioereal array Irestring Iie="Abilities\\Spells\\Other\\BreathOfFire\\BreathOfFireDamage.mdl"string Iae="origin"integer Ine=3integer IVe=8integer IEestring IXe="<SapphireblueDagger>"integer array IOeinteger array IReinteger array IIeinteger array IAeinteger INeinteger Ibeinteger IBeinteger Iceinteger ICereal array Idestring IDe="Abilities\\Spells\\NightElf\\Blink\\BlinkCaster.mdl"
constant real Ife=$80string IFe="Abilities\\Spells\\NightElf\\Blink\\BlinkTarget.mdl"
integer array Igeinteger array IGeinteger array Iheinteger array IHeinteger array Ijeinteger IJeinteger Ikestring IKe="<SilentBoots>"integer Ileinteger ILeinteger array Imeinteger array IMeinteger array Ipeinteger IPe=$Ainteger array Iqeinteger array IQeinteger array Iseboolean array ISeubersplat array Iteinteger array ITeinteger array Iueboolean array IUereal array Iwereal array IWereal array Iyereal array IYereal array Izereal array IZeinteger array I_eboolean array I0eboolean array I1econstant real I2e=(2*1.)*1./ 32integer I3e=0integer I4e=Uboolean array I5ereal array I6ereal array I7ereal array I8ereal array I9einteger array Aveinteger Aee=0integer Axe=Uboolean array Aoeconstant integer Are=$EC
constant integer Aie=O+8192+Are*8192
string Aae="Abilities\\Spells\\Items\\AIvi\\AIviTarget.mdl"string Ane="origin"integer array AVeinteger array AEereal array AXeinteger array AOeinteger array AReinteger AIeinteger AAestring ANe="<StoneShield>"integer Abeinteger ABereal array Acereal array ACeconstant real Ade=(2*1.)*1./ 32integer array ADereal array Afereal array AFeconstant real Age=-500.integer array AGereal array Aheinteger array AHeinteger array Ajeinteger AJe=$Ainteger array Akeinteger array AKestring Ale="Abilities\\Weapons\\ChimaeraLightningMissile\\ChimaeraLightningMissile.mdl"integer ALe=32string Ame="Abilities\\Weapons\\WingedSerpentMissile\\WingedSerpentMissile.mdl"string AMe="chest"integer Apestring APe="<TaintedLeaf>"integer array Aqeinteger array AQeinteger array Aseinteger array ASereal array Ateinteger array ATeinteger array Aueinteger AUeinteger Aweinteger AWeinteger Ayeinteger AYeinteger Azereal AZe
real A_e
integer array A0einteger array A1einteger array A2einteger array A3ereal A4e=.75
real array A5estring A6e="TaintedLeaf_page\\TaintedLeaf_struct\\HealFinal.mdx"
real A7e=.7integer array A8ereal array A9einteger array Nveinteger array Neeinteger Nxestring Noe="<StructCharge>"integer Nreinteger Nieinteger Naeinteger Nneinteger NVestring NEe="<StructPort>"integer NXeinteger array NOeinteger NRestring NIe="<VioletEarring>"
string NAe="Abilities\\Spells\\Human\\Invisibility\\InvisibilityTarget.mdl"string NNe="chest"integer Nbe=0integer array NBeinteger Nce=Uinteger array NCeboolean array Ndeboolean array NDeinteger array Nfeinteger NFestring Nge="Abilities\\Spells\\Undead\\Sleep\\SleepSpecialArt.mdl"string NGe="origin"integer Nheboolean array NHeinteger array Njeinteger array NJereal array Nkeinteger NKestring Nle="<StructTarget>"integer NLeinteger Nmeinteger array NMeinteger Npestring NPe="<Vomit>"
integer Nqeinteger NQeinteger array Nseinteger NSeinteger Nte=0integer array NTeinteger Nue=Uinteger array NUeboolean array Nweboolean array NWeinteger array Nyeinteger array NYereal array Nzeinteger array NZeinteger array N_ereal array N0ereal array N1einteger array N2ereal N3e=.5real array N4einteger array N5einteger array N6einteger N7einteger N8estring N9e="<StructTarget>"integer bveinteger beeinteger array bxeinteger boestring bre="<WhiteStaff>"boolean array bieinteger array baeinteger array bneinteger array bVereal array bEereal array bXeinteger array bOeboolean array bReinteger bIe=1real bAe=.25
integer array bNeinteger bbestring bBe="<StructKnockback>"integer bceinteger bCeinteger array bdeinteger bDeinteger array bfeinteger array bFereal array bgeinteger bGestring bhe="<Barrier>"integer bHe=$96real bje=.36*Bev
string bJe="Abilities\\Spells\\Human\\Avatar\\AvatarCaster.mdl"string bke="overhead"integer bKe=260real ble=.4integer bLeinteger bmeinteger array bMeinteger array bpeinteger bPe=80integer array bqeinteger array bQeinteger bsestring bSe="<StructWave>"integer btestring bTe="<Blizzard>"integer bueinteger bUeinteger bweinteger array bWeinteger array byeinteger array bYereal array bzereal array bZereal b_e=.75
integer b0e=0integer array b1einteger b2e=Uinteger array b3eboolean array b4eboolean array b5ereal array b6einteger array b7ereal array b8ereal array b9ereal array Bvestring Bee="Abilities\\Spells\\Human\\Blizzard\\BlizzardTarget.mdl"real Bxe=.8integer Boeinteger Breinteger array Bieinteger Baeinteger Bnestring BVe="<StructBuff>"integer BEeinteger array BXeinteger array BOeinteger BReinteger BIestring BAe="<ChillyBreath>"integer BNeinteger Bbereal array BBeinteger array Bcereal array BCeinteger array Bdereal array BDereal array Bfereal array BFeinteger array Bgereal array BGeinteger array Bheinteger array BHeinteger array Bjereal array BJereal array Bkeconstant real BKe=(2*1.)*1./ 32integer Ble=0integer BLe=300integer Bme=0integer array BMeinteger Bpe=Uinteger array BPeboolean array Bqeboolean array BQeinteger array Bseinteger array BSeinteger array Bteinteger array BTeinteger array Bueinteger array BUeinteger array Bweinteger array BWeinteger array Byeinteger array BYeboolean array Bzeinteger BZe=0integer B_e=Uboolean array B0einteger array B1einteger array B2ereal B3e=.5real array B4einteger B5estring B6e="<ElementalSpellToHero>"integer B7econstant integer B8e=O+588integer array B9einteger cveinteger cee=0integer array cxeinteger coe=Uinteger array creboolean array cieboolean array caeinteger cneinteger cVeinteger cEeinteger cXeinteger cOeinteger cReinteger cIestring cAe="<StructShot>"integer array cNeinteger array cbeinteger cBeinteger array cceinteger cCestring cde="<Fireburst>"
integer cDeinteger cfe=0integer array cFeinteger cge=Uinteger array cGeboolean array cheboolean array cHeinteger array cjeboolean array cJeinteger array ckeinteger array cKeinteger array cleinteger array cLeinteger array cmeinteger array cMeinteger array cpereal array cPereal array cqestring cQe="Abilities\\Spells\\Human\\Polymorph\\PolyMorphTarget.mdl"string cse="origin"real cSe=.75
constant integer cte=O+8192+589*8192
real cTe=.45
integer cue=0integer array cUeinteger cwe=Uinteger array cWeboolean array cyeboolean array cYeinteger array czeinteger cZeinteger c_einteger c0e=1integer c1e=2integer c2einteger c3ereal array c4ereal array c5einteger c6einteger c7e=50integer c8einteger array c9ereal array Cveinteger array Ceeinteger array Cxeinteger array Coereal array Creinteger array Cieinteger Caestring Cne="<FlameTongue>"integer CVeinteger CEeinteger CXe=0integer array COeinteger CRe=Uinteger array CIeboolean array CAeboolean array CNereal array Cbereal array CBeinteger array Ccereal array CCeinteger Cde=1real array CDereal array Cfereal array CFereal array Cgereal array CGereal array Chereal array CHeinteger array Cjereal array CJereal array Ckereal array CKeinteger array Clereal array CLeinteger array Cmereal array CMereal array Cpereal array CPereal array Cqeinteger array CQereal Cse=.2string CSe="Abilities\\Spells\\Other\\Incinerate\\FireLordDeathExplode.mdl"string Cte="Abilities\\Spells\\Human\\FlameStrike\\FlameStrikeEmbers.mdl"real array CTereal array Cueinteger array CUeinteger array Cweinteger CWeinteger Cyestring CYe="<StructTarget>"integer array Czeinteger CZestring C_e="<StructExplosion>"integer C0einteger array C1einteger array C2einteger array C3einteger C4estring C5e="<FrozenStar>"integer C6einteger C7ereal C8e=.1integer C9e=$Areal dve=.25*Bev
integer dee=0integer array dxeinteger doe=Uinteger array dreboolean array dieboolean array daereal array dnereal array dVeinteger array dEereal array dXeinteger array dOereal array dRereal array dIereal array dAereal array dNereal array dbereal array dBereal array dceinteger array dCeinteger array ddeinteger array dDereal array dfereal array dFereal array dgereal array dGeinteger array dheconstant real dHe=(2*1.)*1./ 32string dje="Abilities\\Spells\\Undead\\FreezingBreath\\FreezingBreathMissile.mdl"real array dJestring dke="Units\\NightElf\\Wisp\\WispExplode.mdl"integer dKeinteger dleinteger dLe=400integer dme=4integer array dMeinteger dpestring dPe="<StructSword>"real array dqereal array dQereal array dseinteger array dSeinteger dteinteger array dTeinteger array dueinteger dUestring dwe="<GhostSword>"integer dWeinteger dyeinteger array dYeinteger dze=Finteger array dZeinteger d_econstant real d0e=(1*1.)*1./ 32integer array d1einteger d2e=Freal array d3ereal array d4ereal d5e=1.5
constant integer d6e=O+8192+590*8192
real d7e=2.5
integer d8einteger d9einteger Dveinteger array Deeinteger Dxereal array Doestring Dre="Abilities\\Spells\\Human\\Feedback\\ArcaneTowerAttack.mdl"string Die="origin"real array Daeinteger Dneboolean array DVeinteger array DEestring DXe="Abilities\\Spells\\NightElf\\Blink\\BlinkCaster.mdl"
string DOe="weapon"integer array DReinteger DIe=Finteger array DAestring DNe="Abilities\\Spells\\NightElf\\Blink\\BlinkCaster.mdl"
string Dbe="weapon"integer DBeinteger Dceinteger array DCereal array Ddeinteger DDeinteger Dfestring DFe="<StructTarget>"integer Dgestring DGe="<HackNSlay>"
integer Dheinteger DHeinteger array Djeinteger array DJeinteger array Dkeinteger DKeinteger Dleinteger DLeinteger array Dmereal array DMeinteger Dpeinteger DPestring Dqe="<IceBlock>"integer DQestring Dse="<IceShock>"integer DSeinteger array Dteinteger array DTeinteger array Dueinteger array DUeinteger array Dweinteger array DWeinteger Dyeinteger DYeinteger Dzestring DZe="Abilities\\Spells\\Undead\\FrostNova\\FrostNovaTarget.mdl"integer array D_einteger D0einteger D1estring D2e="<StructCrit>"integer array D3einteger array D4einteger D5estring D6e="<InnerForce>"integer D7einteger D8einteger D9einteger fve=0integer array feeinteger fxe=Uinteger array foeboolean array freboolean array fieboolean array faeinteger array fnereal array fVeinteger array fEereal array fXereal array fOeinteger array fReinteger array fIeinteger array fAereal fNe=1.25string fbe="Abilities\\Spells\\Human\\MarkOfChaos\\MarkOfChaosTarget.mdl"string fBe="origin"real fce=.75
string fCe="Abilities\\Spells\\Orc\\WarStomp\\WarStompCaster.mdl"string fde="origin"integer fDe=600integer ffe=-$4B0real fFe=.5integer fge=3integer array fGeinteger array fheinteger array fHeinteger fjeinteger fJeinteger fkestring fKe="<Monolith>"integer fleinteger fLeinteger fme=0integer array fMeinteger fpe=Uinteger array fPeboolean array fqeboolean array fQeinteger array fsereal array fSeinteger array fteinteger array fTeinteger array fuereal array fUereal array fweinteger array fWeinteger fye=90integer fYeconstant real fze=(2*1.)*1./ 32string fZe="Monolith_page\\Monolith_struct\\TargetDust.mdx"string f_e="chest"integer f0ereal array f1einteger f2estring f3e="<StructTarget>"integer f4einteger f5estring f6e="<SacredAura>"integer f7einteger array f8einteger array f9einteger array Fveinteger Feeinteger Fxeinteger Foeinteger array Freinteger array Fieinteger array Faeinteger Fnestring FVe="<StructBuff>"integer array FEeinteger array FXeinteger FOestring FRe="<Severance>"
integer FIeinteger FAeinteger FNe=0integer array Fbeinteger FBe=Uinteger array Fceboolean array FCeboolean array Fdereal array FDeinteger array Ffereal array FFeinteger array Fgeinteger array FGeinteger array Fheinteger array FHeinteger array Fjereal FJe=.2trigger Fkeinteger array FKeinteger array Fleinteger array FLeinteger array Fmeinteger FMestring Fpe="<StructParticle>"integer FPeinteger array Fqeinteger array FQeinteger array Fseinteger array FSeinteger Ftestring FTe="<SnowySphere>"integer Fue=0integer array FUeinteger Fwe=Uinteger array FWeboolean array Fyeboolean array FYeinteger array Fzereal array FZeinteger array F_einteger array F0einteger array F1ereal array F2ereal array F3ereal array F4ereal array F5einteger F6e=-50real array F7einteger array F8einteger array F9ereal array gvereal array geereal array gxereal array goeinteger gre=0integer array gieinteger gae=Uinteger array gneboolean array gVeboolean array gEereal array gXeinteger array gOereal array gReinteger array gIeinteger array gAeinteger array gNereal array gbereal array gBereal array gceinteger array gCeconstant real gde=(2*1.)*1./ 32integer gDeinteger gfereal array gFeconstant real gge=(2*1.)*1./ 32real array gGereal array ghereal array gHeinteger array gjeinteger gJestring gke="<Thunderstrike>"
integer gKeinteger gleinteger gLe=0integer array gmeinteger gMe=Uinteger array gpeboolean array gPeboolean array gqereal array gQeinteger array gseinteger array gSereal array gteinteger array gTeinteger array guereal array gUereal array gwereal array gWeinteger array gyeinteger gYe=$3E8
integer gze=3real gZe=.5string g_e="Thunderstrike_page\\Thunderstrike_struct\\Bolt.mdx"integer array g0einteger array g1einteger array g2einteger g3estring g4e="<TwinWolves>"integer g5e='d'real g6e=Bev*1./ 3integer g7e=50integer g8ereal g9e=.5integer Gve='}'integer Geeinteger Gxeinteger Goeinteger array Greinteger Gieinteger Gaestring Gne="<Brotherhood>"integer GVeinteger array GEereal GXe=.5integer GOeinteger array GReinteger array GIeinteger GAestring GNe="<Carnivore>"
integer array Gbeinteger array GBeinteger array Gceinteger GCestring Gde="<WolfsMark>"
integer GDestring Gfe="<StructEffects>"
integer GFeinteger array Ggeinteger array GGeinteger array Ghereal array GHeinteger Gjestring GJe="<VividMeteor>"integer Gkeinteger GKeinteger Gleinteger GLe=0integer array Gmeinteger GMe=Uinteger array Gpeboolean array GPeboolean array Gqereal array GQeinteger array Gsereal array GSereal array Gteinteger array GTereal array Guereal array GUeinteger Gwe=0real array GWereal array Gyereal GYe
real array Gzeinteger GZe=$96real array G_ereal array G0einteger G1e=3real G2e
constant integer G3e=O+8192+592*8192
constant integer G4e=O+8192+591*8192
real G5e=1.5
integer G6e=Finteger array G7einteger array G8einteger G9econstant real hve=(1*1.)*1./ 32real hee
real hxe
integer hoe=3real hre=1.43integer hieinteger array haeinteger hneinteger hVestring hEe="<WarmthMagnetism>"integer hXeinteger hOeconstant integer hRe=O+8192+593*8192
integer array hIereal array hAereal array hNereal hbe
integer hBe=300constant real hce=(2*1.)*1./ 32integer hCereal array hdeinteger array hDeinteger array hfeinteger array hFeinteger array hgestring hGe="Abilities\\Spells\\Undead\\Possession\\PossessionMissile.mdl"string hhe="origin"real hHe=.5integer hje='x'integer hJestring hke="<StructTarget>"integer hKeinteger hlestring hLe="<Amaterasu>"
integer hmeinteger array hMeinteger array hpeinteger hPeinteger hqeinteger hQereal array hsereal array hSereal array hteinteger array hTereal array huereal array hUereal hwe=.35
integer hWe=1real hye=.5integer hYeinteger hzereal array hZeinteger array h_ereal array h0einteger h1estring h2e="<StructTarget>"real array h3einteger array h4einteger array h5einteger h6einteger h7estring h8e="<ArcaneAttractor>"integer h9einteger Hveinteger array Heeinteger array Hxeinteger array Hoeinteger Hreinteger Hie=1integer array Haestring Hne="Abilities\\Spells\\Human\\Polymorph\\PolyMorphTarget.mdl"string HVe="origin"integer HEe=350string HXe="ArcaneAttractor_page\\ArcaneAttractor_struct\\Area3.mdx"
real HOe=.25
integer array HRestring HIe="Abilities\\Spells\\Undead\\OrbOfDeath\\AnnihilationMissile.mdl"string HAe="origin"integer array HNeinteger array Hbeinteger array HBeinteger array Hceinteger array HCeinteger array Hdeinteger HDeinteger Hfestring HFe="<ArcticWolf>"integer Hgeinteger HGereal Hhe
integer HHe=400constant real Hje=(1*1.)*1./ 32integer HJeinteger Hke=90integer HKe=0integer array Hleinteger HLe=Uinteger array Hmeboolean array HMeboolean array Hpeinteger HPe=50real array Hqereal array HQeinteger array Hseinteger array HSeinteger array Htestring HTe="ArcticWolf_page\\ArcticWolf_struct\\IceVortex.mdx"string Hue="origin"integer array HUereal array Hweinteger array HWeinteger array Hyereal array HYeinteger array Hzereal array HZeinteger array H_ereal array H0einteger array H1einteger array H2ereal array H3ereal array H4ereal H5e=.5string H6e="ArcticWolf_page\\ArcticWolf_struct\\Explosion.mdx"integer H7estring H8e="<StructVisuals>"
integer H9einteger jvestring jee="<BoulderCrash>"integer array jxeinteger array joeinteger jreinteger jieinteger jaeinteger array jneinteger array jVereal jEe=.25
real array jXeinteger jOe=1real jRe=.5integer array jIeinteger array jAeinteger array jNereal array jbereal array jBereal array jceboolean array jCeboolean array jdeconstant real jDe=(2*1.)*1./ 32integer array jfereal array jFereal array jgereal jGe=.25
real jhe=.5integer jHestring jje="<Conflagration>"
integer jJeinteger jkeinteger jKereal array jleinteger array jLeinteger array jmereal array jMereal array jpeinteger jPeinteger jqeinteger jQeinteger jseinteger jSe=0integer array jteinteger jTe=Uinteger array jueboolean array jUeboolean array jwereal array jWeinteger array jyereal array jYeinteger array jzereal array jZereal array j_ereal array j0einteger array j1ereal array j2einteger array j3einteger array j4ereal array j5ereal array j6einteger array j7einteger array j8einteger array j9einteger array Jveinteger array Jeeinteger array Jxeinteger array Joeinteger array Jreinteger Jie=0integer Jae=300constant real Jne=(2*1.)*1./ 32real array JVeinteger JEeinteger JXestring JOe="<StructRelocate>"integer array JReinteger array JIeinteger array JAeinteger array JNeinteger Jbeinteger JBestring Jce="<Cyclone>"integer JCeinteger array Jdeconstant integer JDe=O+8192+595*8192
integer Jfeinteger JFeinteger Jge=300integer JGe=0integer array Jheinteger JHe=Uinteger array Jjeboolean array JJeboolean array Jkeinteger array JKereal array Jleinteger array JLeinteger array Jmeinteger array JMereal array Jpereal array JPeinteger array Jqeinteger JQe=$80integer Jse=winteger JSeconstant real Jte=(2*1.)*1./ 32integer JTeinteger Juestring JUe="<StructTarget>"integer Jweinteger array JWeinteger Jyestring JYe="<WindDance>"
integer Jzeinteger JZestring J_e="<DeprivingShock>"integer J0einteger array J1ereal array J2einteger array J3einteger array J4ereal array J5einteger J6einteger J7einteger J8econstant integer J9e=O+8192+597*8192
boolean array kvestring kee="Abilities\\Spells\\Undead\\AnimateDead\\AnimateDeadTarget.mdl"string kxe="origin"string koe="Objects\\Spawnmodels\\Undead\\UndeadLargeDeathExplode\\UndeadLargeDeathExplode.mdl"integer array krereal array kiereal kae=.1real array knereal array kVeinteger array kEeinteger array kXeinteger array kOereal kRe=.5string kIe="Abilities\\Weapons\\LichMissile\\LichMissile.mdx"string kAe="chest"integer kNeinteger array kbeinteger array kBeinteger array kceinteger kCestring kde="<StructBigBoom>"
integer kDeinteger kfeinteger array kFeinteger array kgereal array kGeinteger khestring kHe="<StructFireBuff>"integer array kjeinteger kJeinteger kkestring kKe="<StructIceBuff>"
integer kleinteger kLereal array kmeinteger array kMeinteger kpestring kPe="<Doppelganger>"integer kqeinteger kQeinteger kseconstant integer kSe=O+599integer array kteinteger array kTereal array kuereal array kUereal array kweinteger array kWereal array kyereal array kYereal array kzereal array kZeinteger k_e=$C8string k0e="Abilities\\Spells\\Orc\\MirrorImage\\MirrorImageDeathCaster.mdl"
string k1e="Abilities\\Spells\\Human\\Polymorph\\PolyMorphDoneGround.mdl"integer k2einteger k3estring k4e="Objects\\Spawnmodels\\Other\\ToonBoom\\ToonBoom.mdl"
string k5e="Doppelganger_page\\Doppelganger_struct\\BigBoom\\BigBoom.mdx"integer k6einteger array k7einteger k8einteger array k9ereal array Kveinteger array Keeinteger array Kxereal array Koereal array Krereal array Kieinteger array Kaeinteger Knestring KVe="<EbonyShot>"
integer KEeinteger KXeinteger array KOeinteger array KReinteger array KIeinteger array KAeboolean array KNeinteger Kbeinteger array KBestring Kce="Abilities\\Spells\\Other\\Incinerate\\IncinerateBuff.mdl"string KCe="weapon"integer Kde=0integer KDe=Uboolean array Kfereal array KFestring Kge="Abilities\\Spells\\Other\\BreathOfFire\\BreathOfFireDamage.mdl"string KGe="origin"integer Khe=$3E8
string KHe="Abilities\\Spells\\Undead\\CarrionSwarm\\CarrionSwarmDamage.mdl"
string Kje="chest"integer KJereal array Kkeinteger array KKeinteger Klestring KLe="<StructBuff>"integer Kmestring KMe="<EmphaticBite>"integer Kpeinteger array KPeinteger array Kqeinteger array KQeinteger array Kseinteger KSeinteger Ktereal KTe
integer Kue=$3E8
constant real KUe=(1*1.)*1./ 32real Kwe=.2integer array KWeinteger array Kyereal array KYereal array Kzeinteger array KZeinteger array K_ereal array K0ereal array K1einteger K2e='x'string K3e="Abilities\\Spells\\Undead\\Possession\\PossessionMissile.mdl"string K4e="origin"integer array K5einteger array K6einteger array K7einteger array K8einteger K9estring lve="<EnchantedArrow>"integer leeinteger lxeinteger loeinteger array lreinteger array lieinteger array laeinteger array lneinteger array lVeboolean array lEeinteger lXeinteger lOe=0integer lRe=Uboolean array lIereal array lAeinteger array lNereal array lbeinteger array lBereal array lcereal array lCestring lde="Objects\\Spawnmodels\\NightElf\\NECancelDeath\\NECancelDeath.mdl"integer lDe=64string lfe="EnchantedArrow_page\\EnchantedArrow_struct\\arrowEffect.mdx"
string lFe="origin"string lge="EnchantedArrow_page\\EnchantedArrow_struct\\arrowEffect2.mdx"string lGe="origin"integer array lheconstant real lHe=(2*1.)*1./ 32integer ljeinteger lJestring lke="<StructRevert>"integer lKeinteger llestring lLe="<FairyShape>"integer lmeinteger lMeinteger lpereal array lPereal array lqeinteger array lQeinteger array lseinteger array lSereal array lteinteger array lTeinteger lueinteger lUeinteger lweconstant integer lWe=O+8192+601*8192
integer lyereal array lYereal array lzereal array lZeinteger array l_einteger array l0einteger array l1einteger array l2einteger l3e=$7FFFFFFDstring l4e="Abilities\\Spells\\NightElf\\ManaBurn\\ManaBurnTarget.mdl"string l5e="origin"integer l6ereal l7e
real l8e
integer array l9estring Lve="FairyShape_page\\FairyShape_struct\\Revert\\sourceEffect.mdx"real array Leereal array Lxestring Loe="Abilities\\Spells\\Undead\\Possession\\PossessionMissile.mdl"string Lre="Abilities\\Spells\\Undead\\DarkRitual\\DarkRitualTarget.mdl"
integer array Lieinteger array Laeinteger Lnestring LVe="<StructTarget>"integer LEeinteger LXeinteger LOeinteger LRestring LIe="<FairysTears>"integer LAeinteger LNeinteger Lbereal array LBereal array Lceinteger LCe=1integer array Ldeinteger array LDeinteger array Lfereal LFe=.25
integer Lge=2integer array LGereal array Lheinteger array LHeinteger array Ljereal LJe=.9integer Lkeinteger array LKeinteger Llestring LLe="<FountainOfLifeAndDeath>"integer Lme=0integer array LMeinteger Lpe=Uinteger array LPeboolean array Lqeboolean array LQeinteger Lse=400integer LSe=3integer Lteinteger LTeinteger Luereal array LUeinteger Lwestring LWe="<StructTarget>"integer Lyestring LYe="<DecayAura>"
integer array Lzeinteger LZeinteger L_einteger array L0einteger array L1ereal array L2ereal array L3einteger array L4einteger array L5einteger L6einteger L7ereal L8e=.25
integer L9estring mve="<AIPalingenesis>"constant integer mee=O+8192+30*8192integer mxeinteger array moeinteger mrestring mie="<Palingenesis>"integer maeinteger mneinteger array mVeinteger array mEeinteger array mXestring mOe="Abilities\\Spells\\Undead\\AnimateDead\\AnimateDeadTarget.mdl"string mRe="origin"string mIe="Objects\\Spawnmodels\\Undead\\UndeadLargeDeathExplode\\UndeadLargeDeathExplode.mdl"real array mAeinteger mNestring mbe="<StructRegen>"integer mBeinteger mceinteger mCeinteger mdestring mDe="<GarmentsOfTheSalamander>"integer array mfeinteger mFeinteger array mgestring mGe="Abilities\\Spells\\Orc\\FeralSpirit\\feralspiritdone.mdl"string mhe="chest"integer mHeinteger mjeinteger array mJeinteger array mkereal mKe=.5integer mlestring mLe="<StructId>"integer mmestring mMe="<StructTable>"integer mpestring mPe="<StructInteger>"
integer mqestring mQe="<StructData>"integer mseinteger mSestring mte="<StructPrison>"integer array mTereal array mueinteger array mUeinteger array mweinteger mWeinteger myestring mYe="<StructBuff>"integer mzestring mZe="<StructRoots>"integer m_estring m0e="<StructNova>"integer m1einteger array m2einteger array m3einteger array m4einteger array m5einteger m6estring m7e="<HandOfNature>"integer m8einteger m9einteger Mveconstant integer Mee=O+605boolean array Mxeinteger array Moeinteger array Mreinteger array Mieconstant integer Mae=O+8192+607*8192
integer array Mneinteger array MVeinteger array MEeinteger array MXereal array MOeinteger array MReinteger array MIeboolean array MAeinteger MNe=0integer Mbe=Uboolean array MBeconstant integer Mce=O+8192+603*8192
integer array MCestring Mde="Objects\\Spawnmodels\\NightElf\\EntBirthTarget\\EntBirthTarget.mdl"integer MDeinteger Mfe=0integer array MFeinteger Mge=Uinteger array MGeboolean array Mheboolean array MHeinteger array Mjeinteger array MJeinteger array Mkeinteger array MKeinteger array Mleinteger array MLereal Mme=.05
string MMe="Abilities\\Weapons\\TreantMissile\\TreantMissile.mdl"integer Mpe=1real MPe=.125real array Mqereal array MQereal array Msereal array MSereal array Mtereal MTe=.5integer array Muereal array MUeinteger array Mweinteger array MWeinteger Myeinteger array MYeinteger array Mzeinteger MZestring M_e="<StructTarget>"integer M0estring M1e="<SlowPoison>"integer M2einteger M3einteger M4e=2integer M5e=4integer M6ereal M7e
integer M8e=5real M9e=.5integer array pvereal array peeinteger array pxeinteger poeinteger preinteger piestring pae="<StructMine>"integer array pneinteger array pVeinteger pEestring pXe="<StructSetMines>"integer pOeinteger pRestring pIe="<HopNDrop>"integer pAereal pNe
integer pbe=1integer pBeconstant real pce=(1*1.)*1./ 32real pCe
real pde
integer array pDereal array pfereal pFe
real array pgereal array pGereal phe
real array pHereal pje
integer pJeinteger pke=1real pKe
integer ple=900real pLe
integer pme=500real pMe
integer ppe=3real array pPereal array pqeinteger array pQeinteger array psereal array pSeinteger array ptereal array pTeinteger pueinteger pUe=40real pwe=.5real pWe=1.5
integer pyeinteger pYeinteger pze=2integer array pZeinteger p_estring p0e="<StructCone>"integer p1einteger p2estring p3e="<StructFuniculusUmbilicalis>"integer p4einteger array p5einteger array p6einteger array p7einteger p8estring p9e="<StructSummon>"integer Pveinteger Peeinteger array Pxeinteger array Poeinteger array Preinteger Piestring Pae="<StructTarget>"integer array Pneinteger array PVeinteger array PEeinteger PXeinteger POestring PRe="<Infection>"
integer PIeinteger array PAeinteger PNereal Pbe
integer PBe=500integer Pce=650integer PCereal Pde
constant real PDe=(1*1.)*1./ 32integer Pfeinteger PFeinteger array Pgeconstant integer PGe=O+611integer Pheinteger PHeinteger array Pjeinteger array PJereal array Pkereal array PKeinteger array Plereal PLe=.5integer Pmereal PMe=.25
constant integer Ppe=O+8192+609*8192
integer array PPeinteger array Pqeinteger array PQeinteger Psestring PSe="<StructRestoration>"
integer Pteinteger PTeinteger Pueinteger array PUeinteger array Pweinteger array PWeinteger array Pyeinteger array PYeinteger Pzeinteger PZestring P_e="<KhakiRecovery>"
integer P0einteger P1einteger P2e=0integer array P3einteger P4e=Uinteger array P5eboolean array P6eboolean array P7ereal array P8einteger array P9einteger array qvereal array qeeinteger array qxeinteger array qoeinteger array qreinteger array qieinteger array qaestring qne="Abilities\\Spells\\Other\\Drain\\DrainCaster.mdl"string qVe="origin"real qEe=.35
real qXe=-.15string qOe="KhakiRecovery_page\\KhakiRecovery_struct\\Vortex2.mdx"string qRe="origin"string qIe="KhakiRecovery_page\\KhakiRecovery_struct\\Target.mdx"string qAe="origin"integer qNestring qbe="Abilities\\Spells\\Orc\\SpiritLink\\SpiritLinkZapTarget.mdl"
string qBe="overhead"real array qcereal array qCeinteger array qdeinteger array qDeinteger qfestring qFe="<ManaColossus>"integer qge=75integer qGeinteger qhereal array qHereal array qjeinteger qJestring qke="<StructTarget>"integer qKeinteger qlestring qLe="<TheurgicVessel>"integer qmeinteger array qMeinteger array qpeinteger qPeinteger qqeinteger array qQeinteger qsestring qSe="<StructRevert>"integer qteinteger qTeinteger queinteger qUeinteger array qweinteger array qWeinteger array qyeinteger array qYeinteger qzestring qZe="<ManaLaser>"
integer q_einteger q0einteger q1e=90integer q2e=0integer array q3einteger q4e=Uinteger array q5eboolean array q6eboolean array q7einteger q8e=50real array q9ereal array Qveinteger array Qeeinteger array Qxeinteger array Qoeinteger array Qreinteger array Qieinteger array Qaeinteger array Qnereal array QVereal array QEereal array QXeconstant real QOe=(1*1.)*1./ 32integer QRe=0integer QIe=Uboolean array QAeconstant real QNe=(2*1.)*1./ 32string Qbe="Abilities\\Spells\\NightElf\\ManaBurn\\ManaBurnTarget.mdl"string QBe="origin"real array Qcereal QCe
real Qde
integer QDe=5integer array Qfestring QFe="ManaLaser_page\\ManaLaser_struct\\Revert\\SourceEffect.mdx"real array Qgereal array QGestring Qhe="Abilities\\Spells\\Undead\\Possession\\PossessionMissile.mdl"string QHe="Abilities\\Spells\\Undead\\DarkRitual\\DarkRitualTarget.mdl"
integer Qjeinteger QJestring Qke="<StructCharm>"integer QKestring Qle="<StructMissile>"
integer array QLeinteger array Qmeinteger QMestring Qpe="<MassMimesis>"integer QPeinteger Qqeinteger array QQeinteger array Qsereal array QSereal array Qtestring QTe="Abilities\\Spells\\Items\\AIil\\AIilTarget.mdl"string Que="Abilities\\Spells\\Items\\AIil\\AIilTarget.mdl"string QUe="origin"real Qwe
real QWe
real array Qyeinteger array QYeinteger array Qzeinteger QZe=0integer array Q_einteger Q0e=Uinteger array Q1eboolean array Q2eboolean array Q3einteger array Q4einteger array Q5ereal array Q6ereal array Q7estring Q8e="Abilities\\Spells\\NightElf\\Blink\\BlinkTarget.mdl"
string Q9e="Abilities\\Spells\\NightElf\\Blink\\BlinkCaster.mdl"
real array sveinteger array seeinteger array sxereal array soereal array srereal array sieinteger saeinteger sneinteger sVestring sEe="<MountainKing>"integer array sXereal sOe=.125integer sReinteger array sIereal array sAeinteger sNestring sbe="<Thunderbringer>"integer sBeinteger scestring sCe="Abilities\\Weapons\\FarseerMissile\\FarseerMissile.mdx"string sde="weapon"string sDe="Abilities\\Spells\\Human\\ManaFlare\\ManaFlareBoltImpact.mdl"string sfe="Abilities\\Spells\\Other\\Monsoon\\MonsoonBoltTarget.mdl"integer sFeinteger sgestring sGe="<NegationWave>"integer array sheinteger array sHereal array sjereal array sJeinteger skeinteger sKeinteger slestring sLe="Abilities\\Spells\\Other\\Drain\\DrainCaster.mdl"string sme="origin"integer sMe=0integer array speinteger sPe=Uinteger array sqeboolean array sQeboolean array ssereal array sSeinteger array stereal array sTeinteger array sueinteger array sUeinteger array sweinteger array sWeinteger array syeinteger array sYereal sze=.35
string sZe="Abilities\\Weapons\\Bolt\\BoltImpact.mdl"string s_e="chest"constant real s0e=-1.integer array s1einteger s2estring s3e="<StructEgg>"
integer array s4einteger s5einteger array s6einteger s7einteger array s8einteger array s9einteger array Sveinteger Seestring Sxe="<NurturingGrounds>"integer Soe=0integer array Sreinteger Sie=Uinteger array Saeboolean array Sneboolean array SVeinteger array SEereal array SXeinteger array SOereal array SReconstant real SIe=(2*1.)*1./ 32integer array SAereal array SNeinteger array Sbereal array SBereal array Sceinteger array SCeinteger array Sdeconstant integer SDe=$80
integer Sfeinteger array SFeinteger array Sgeinteger array SGeinteger array Shereal array SHeinteger array Sjeinteger SJestring Ske="<StructTarget>"integer SKereal array Sleinteger SLestring Sme="<StructArrival>"
integer SMestring Spe="<StructLeech>"integer array SPeinteger Sqeinteger SQestring Sse="<PandaPaw>"integer array SSeinteger array Steinteger STereal array Sueinteger array SUeinteger array Swereal array SWereal array Syereal array SYereal array Szeinteger array SZeinteger array S_einteger array S0ereal array S1ereal array S2einteger array S3einteger S4e=1real S5e=.125constant real S6e=(2*1.)*1./ 32integer S7e=-75real S8e=.5integer S9e=5string tve="Abilities\\Spells\\Orc\\WarStomp\\WarStompCaster.mdl"integer tee=-'}'
integer txeinteger toereal tre=.65*Bev
integer tie=0integer array taeinteger tne=Uinteger array tVeboolean array tEeboolean array tXereal array tOeinteger array tRereal array tIereal array tAereal array tNereal array tbereal array tBereal array tcereal array tCeconstant integer tde=O+8192+613*8192
integer tDeconstant integer tfe=O+8192+615*8192
integer array tFeinteger tge=Finteger array tGeinteger theconstant real tHe=(2*1.)*1./ 32integer array tjeinteger tJe=Finteger tke=$Astring tKe="Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl"string tle="origin"integer array tLeinteger array tmeinteger array tMeinteger tpestring tPe="<StructWave>"string tqe="<PurgingRain>"integer tQeinteger tseinteger array tSeinteger array tteinteger array tTereal array tuereal array tUereal twe=.75
integer tWe=0integer array tyeinteger tYe=Uinteger array tzeboolean array tZeboolean array t_ereal array t0einteger array t1ereal array t2ereal array t3ereal array t4estring t5e="Abilities\\Spells\\NightElf\\Starfall\\StarfallTarget.mdx"real t6e=.8integer t7einteger t8einteger t9einteger Tvestring Tee="<StructBlade>"integer array Txereal array Toeinteger array Treinteger array Tieinteger Taestring Tne="<RazorBladeDrawBack>"integer TVeinteger array TEeinteger array TXeconstant integer TOe=O+617integer TReinteger TIeinteger TAeinteger TNestring Tbe="<StructVamp>"integer array TBeinteger Tceinteger array TCeinteger array Tdeinteger TDeinteger Tfestring TFe="<RazorBlade>"integer Tgeinteger TGeinteger The=0integer array THeinteger Tje=Uinteger array TJeboolean array Tkeboolean array TKeinteger array Tlereal array TLeinteger array Tmeinteger array TMeinteger array Tpeinteger array TPereal array Tqereal array TQeinteger array Tseinteger TSe=0integer array Tteinteger TTe=Uinteger array Tueboolean array TUeboolean array Twereal array TWeinteger array Tyeinteger array TYereal array Tzeinteger array TZeinteger array T_einteger array T0einteger array T1ereal array T2ereal array T3ereal array T4ereal array T5einteger array T6einteger T7e=0integer array T8einteger T9e=Uinteger array uveboolean array ueeboolean array uxeinteger array uoeinteger array ureinteger array uieinteger array uaeinteger array unereal uVe=.9integer array uEeinteger array uXeinteger uOe=Fconstant real uRe=(2*1.)*1./ 32integer array uIeinteger uAe=Fstring uNe="Objects\\Spawnmodels\\Critters\\Albatross\\CritterBloodAlbatross.mdl"string ube="chest"integer uBe=0integer array uceinteger uCe=Uinteger array udeboolean array uDeboolean array ufeconstant integer uFe=$CB
constant integer uge=O+8192+uFe*8192
integer uGe=0integer uhe=Uboolean array uHereal array ujereal array uJereal array ukeconstant real uKe=(2*1.)*1./ 32real array ulereal array uLereal array umeinteger uMe=0integer upe=Uboolean array uPeinteger array uqereal array uQereal array usereal array uSereal array utereal array uTereal array uueinteger uUe=$96constant real uwe=(2*1.)*1./ 32string uWe="Abilities\\Weapons\\GlaiveMissile\\GlaiveMissileTarget.mdl"string uye="chest"integer uYestring uze="<StructBuff>"real array uZeinteger array u_einteger u0einteger array u1einteger u2estring u3e="<StructMissile>"
integer array u4einteger u5einteger u6einteger array u7ereal array u8einteger u9estring Uve="<RelentlessShiver>"integer Ueeinteger Uxereal array Uoeinteger array Ureinteger array Uiereal array Uaereal array Unereal UVe=.75
integer UEe=$Ainteger UXe=0integer array UOeinteger URe=Uinteger array UIeboolean array UAeboolean array UNeinteger array Ubeinteger array UBeinteger Ucestring UCe="<StructAfterBuff>"integer Udereal array UDereal array Ufeinteger UFestring Uge="<RigorMortis>"integer UGeinteger array Uheinteger array UHestring Uje="Abilities\\Spells\\Demon\\DarkPortal\\DarkPortalTarget.mdl"integer array UJestring Uke="Abilities\\Spells\\Orc\\Reincarnation\\ReincarnationTarget.mdl"real array UKereal array Ulereal array ULereal array Umeinteger UMe=2string Upe="Abilities\\Spells\\Demon\\DarkPortal\\DarkPortalTarget.mdl"string UPe="origin"integer Uqe=20integer UQestring Use="<StructMissile>"
real array USereal array Uteinteger array UTeinteger Uueinteger UUestring Uwe="<SakeBomb>"integer UWeinteger Uyeinteger UYe=0integer array Uzeinteger UZe=Uinteger array U_eboolean array U0eboolean array U1einteger array U2einteger array U3ereal array U4ereal array U5einteger array U6einteger U7e=0integer array U8einteger U9e=Uinteger array wveboolean array weeboolean array wxeinteger array woereal array wreinteger array wiereal array waeinteger array wneinteger array wVeinteger wEe=3real array wXereal array wOereal array wRereal array wIeinteger array wAestring wNe="Abilities\\Spells\\Other\\Volcano\\VolcanoMissile.mdl"real wbe=.5integer wBe=1real wce=.3string wCe="Abilities\\Spells\\Other\\StrongDrink\\BrewmasterTarget.mdl"
string wde="overhead"real array wDeinteger array wfeinteger wFeinteger wgestring wGe="<SanguineEyes>"integer wheinteger array wHereal array wjeinteger wJeinteger wkestring wKe="<StructTarget>"integer wlestring wLe="<StructTransition>"integer wmeinteger wMestring wpe="<ShamanicBubble>"real array wPeinteger wqeinteger wQeinteger array wseinteger array wSeinteger wteinteger wTeinteger wuereal wUe=.5integer array wwereal array wWeinteger array wyeinteger wYestring wze="<StructBuff>"integer wZeinteger array w_einteger array w0einteger w1einteger w2einteger array w3einteger array w4einteger array w5einteger array w6einteger w7estring w8e="<SleepingDraft>"
integer w9einteger Wveinteger Wee=0integer array Wxeinteger Woe=Uinteger array Wreboolean array Wieboolean array Waeinteger array Wneinteger array WVestring WEe="Abilities\\Spells\\Undead\\Sleep\\SleepSpecialArt.mdl"string WXe="origin"real WOe=.05
integer WReinteger array WIeinteger WAestring WNe="<StructHealMissile>"
integer array Wbereal array WBeinteger array Wceinteger array WCeinteger Wdestring WDe="<SoberUp>"integer Wfeinteger WFeinteger Wgestring WGe="Units\\NightElf\\Wisp\\WispExplode.mdx"integer Whe=512integer array WHereal array Wjereal array WJestring Wke="SoberUp_page\\SoberUp_struct\\shockwave.mdx"
integer WKe=512boolean array Wleboolean array WLeinteger array Wmeinteger array WMeinteger array Wpestring WPe="Abilities\\Spells\\Other\\HealingSpray\\HealBottleMissile.mdl"string Wqe="chest"string WQe="Abilities\\Spells\\Human\\Polymorph\\PolyMorphDoneGround.mdl"string Wse="chest"real array WSeinteger Wteinteger WTestring Wue="<StructTarget>"integer array WUeinteger array Wweinteger WWestring Wye="<SteelImpalement>"integer WYeinteger Wzeinteger WZereal array W_ereal array W0ereal array W1ereal array W2einteger array W3einteger array W4einteger array W5einteger array W6einteger W7e='d'string W8e="Abilities\\Spells\\Undead\\Impale\\ImpaleMissTarget.mdl"
string W9e="Abilities\\Spells\\Undead\\Impale\\ImpaleHitTarget.mdl"string yve="origin"integer yeestring yxe="<StructCallback>"integer yoeinteger array yreinteger yiereal array yaeinteger array ynereal array yVeinteger array yEeinteger yXestring yOe="<StructSummon>"integer yRestring yIe="<SummonPolarBear>"integer yAe=0integer array yNeinteger ybe=Uinteger array yBeboolean array yceboolean array yCeinteger array ydeinteger array yDeinteger array yfeconstant integer yFe=O+619integer array ygeinteger array yGeinteger array yheinteger yHe=0integer array yjeinteger yJe=Uinteger array ykeboolean array yKeboolean array yleinteger yLeinteger ymeinteger yMeinteger array ypeinteger yPestring yqe="<ArcticBlink>"integer yQe=0integer array yseinteger ySe=Uinteger array yteboolean array yTeboolean array yueinteger array yUeinteger array yweinteger array yWeinteger yye=2integer yYeinteger yzestring yZe="<Devour>"integer y_einteger y0ereal array y1ereal array y2einteger array y3einteger array y4ereal array y5einteger y6estring y7e="<Susanoo>"integer y8ereal array y9ereal Yve=-.3
string Yee="Abilities\\Spells\\Items\\AIil\\AIilTarget.mdl"string Yxe="origin"string Yoe="Abilities\\Spells\\Other\\HowlOfTerror\\HowlCaster.mdl"real array Yreinteger array Yieinteger array Yaestring Yne="<Swiftness>"
integer YVeinteger array YEereal array YXeinteger YOeinteger YRestring YIe="<StructCriticalAttacks>"
integer YAestring YNe="<TempestStrike>"
integer array Ybeinteger YBeinteger Yceinteger YCereal array Ydeinteger array YDeinteger array Yfeinteger array YFestring Yge="AttachPoint.FOOT"real YGe=1real Yhe=450
real YHe=$6A4constant real Yje=(1*1.)*1./ 32string YJe="Abilities\\Spells\\Other\\Stampede\\StampedeMissileDeath.mdl"string Yke="chest"real YKe=7.5
integer Ylestring YLe="<StructMissile>"
integer Ymeinteger YMestring Ype="<StructRelocate>"integer YPestring Yqe="<StructTarget>"integer YQeinteger Ysestring YSe="<Tsukuyomi>"
integer array Ytereal array YTeinteger array Yueinteger YUeinteger Yweinteger YWereal Yye
real YYe
integer array Yzeinteger array YZeinteger array Y_einteger array Y0einteger array Y1einteger array Y2ereal array Y3ereal array Y4ereal array Y5ereal array Y6einteger Y7einteger Y8ereal array Y9ereal array zvereal array zeeboolean array zxeconstant real zoe=(2*1.)*1./ 32integer zre=300integer zie=1real zae=.15
integer zne=0integer array zVeinteger zEe=Uinteger array zXeboolean array zOeboolean array zReinteger array zIeinteger array zAereal array zNereal array zbeinteger zBestring zce="<StructMissile>"
integer array zCeinteger array zdereal array zDeinteger array zfeinteger array zFeinteger zgeinteger zGestring zhe="<StructTarget>"integer array zHeinteger array zjeinteger zJestring zke="<WanShroud>"
integer zKeinteger zleinteger zLe=0integer array zmeinteger zMe=Uinteger array zpeboolean array zPeboolean array zqeinteger array zQeinteger array zsereal array zSereal array zteinteger zTe=0integer array zueinteger zUe=Uinteger array zweboolean array zWeboolean array zyeinteger array zYeinteger array zzeinteger array zZereal array z_ereal array z0einteger array z1einteger array z2ereal array z3ereal array z4einteger z5einteger z6ereal z7e=.75
string z8e="Abilities\\Spells\\Human\\Feedback\\ArcaneTowerAttack.mdl"string z9e="origin"integer Zveinteger Zeeinteger array Zxereal array Zoeinteger array Zreinteger Ziestring Zae="<StructTarget>"integer array Znereal array ZVeinteger ZEestring ZXe="<Warcry>"integer ZOeinteger ZRestring ZIe="Abilities\\Spells\\NightElf\\BattleRoar\\RoarCaster.mdl"
integer ZAe=1real ZNe=.3integer array Zbeinteger array ZBeinteger array Zceinteger array ZCeinteger Zdestring ZDe="<StructSummon>"integer Zfestring ZFe="<WaterBindings>"
integer Zge=75integer ZGereal array Zheinteger array ZHeinteger Zjeinteger ZJeinteger Zkestring ZKe="<Lariat>"real array Zleinteger array ZLeinteger Zmeinteger ZMeconstant integer Zpe=O+8192+621*8192
real array ZPereal array Zqeinteger array ZQeinteger array Zseinteger array ZSeinteger array Zteinteger array ZTeinteger array Zueinteger array ZUereal array Zweinteger ZWestring Zye="<StructTarget>"integer ZYeinteger Zzestring ZZe="<SoakingAttack>"
integer Z_einteger Z0einteger array Z1einteger array Z2ereal array Z3einteger Z4einteger Z5estring Z6e="<StructTarget>"real array Z7einteger array Z8einteger Z9estring vvx="<ZodiacAura>"integer vexinteger vxxinteger array voxinteger array vrxreal array vixreal array vaxreal vnx=.5integer array vVxinteger array vExinteger vXxinteger vOxinteger vRxinteger array vIxinteger vAxstring vNx="<Zodiac>"boolean array vbxboolean array vBxinteger vcxinteger vCxinteger vdxinteger vDxstring vfx="<BigHealingWave>"integer vFxinteger vgxinteger vGx=0integer array vhxinteger vHx=Uinteger array vjxboolean array vJxboolean array vkxreal array vKxinteger array vlxinteger array vLxinteger array vmxinteger array vMxinteger array vpxreal vPx=.35
integer vqx='d'real vQx=.75
string vsx="BigHealingWave_page\\BigHealingWave_struct\\TargetEffect.mdx"string vSx="origin"integer vtxinteger vTxinteger vuxstring vUx="<BurningSpiritMeteorite>"boolean array vwxboolean array vWxinteger array vyxinteger array vYxinteger array vzxinteger vZx=20integer v_xinteger v0xstring v1x="<BurnLumber>"integer v2xinteger v3x=50integer v4x=50integer v5xinteger v6xstring v7x="<CoreFusion>"real v8x=.2string v9x="Abilities\\Spells\\Other\\Volcano\\VolcanoMissile.mdl"real evx
integer eexinteger exxinteger eoxinteger erxinteger eixstring enx="<DarkAttack>"integer eVxinteger array eExinteger array eXxinteger eOxinteger eRxstring eIx="Abilities\\Spells\\Undead\\DeathCoil\\DeathCoilSpecialArt.mdx"string eAx="origin"integer eNxinteger ebxstring eBx="<StructTarget>"integer ecxstring eCx="<FountainAura>"integer edxinteger eDxinteger array efxinteger array eFxinteger egxinteger eGxinteger ehxstring eHx="<FountainHeal>"integer ejxinteger eJxinteger ekxreal eKx=1.5
real elx=1.5
constant integer eLx=O+8192+623*8192
string emx="Abilities\\Spells\\NightElf\\MoonWell\\MoonWellCasterArt.mdl"string eMx="origin"string epx="Abilities\\Spells\\Human\\Heal\\HealTarget.mdl"string ePx="origin"string eqx="Abilities\\Spells\\Items\\AIma\\AImaTarget.mdl"string eQx="origin"integer esxstring eSx="<FrostAttack>"integer etxreal array eTxinteger euxinteger eUxinteger ewxinteger eWxinteger eyxstring eYx="<Invisibility>"integer ezxstring eZx="<Invulnerability>"integer e_xinteger e0xinteger e1xinteger e2xstring e3x="<StructBuff>"integer e4xinteger e5xstring e6x="<Lapidation>"integer e7xinteger e8xinteger e9x=$Aboolean array xvxboolean array xexinteger array xxxreal array xoxinteger xrx='d'integer array xixinteger array xaxinteger xnx=$Ainteger array xVxinteger array xExreal array xXxreal array xOxinteger array xRxinteger xIxinteger xAxinteger xNxstring xbx="<LightningAttack>"integer xBxinteger xcxinteger xCx=0integer array xdxinteger xDx=Uinteger array xfxboolean array xFxboolean array xgxreal array xGxinteger array xhxreal array xHxreal array xjxinteger array xJxinteger array xkxreal array xKxinteger array xlxinteger array xLxinteger array xmxinteger array xMxinteger array xpxstring xPx="abilities\\Spells\\Orc\\LightningBolt\\LightningBolt.wav"string xqx="Abilities\\Spells\\Items\\AIlb\\AIlbSpecialArt.mdl"string xQx="chest"integer xsxinteger xSxtrigger xtxstring xTx="<MagicImmunity>"
integer xuxinteger xUxinteger xwxstring xWx="<MeteoriteProtection>"integer xyxinteger xYxstring xzx="<RefreshMana>"integer xZxstring x_x="Abilities\\Spells\\Items\\AIre\\AIreTarget.mdl"string x0x="origin"real x1x=.5integer x2xinteger x3xstring x4x="<StructTarget>"integer x5xstring x6x="<RevealAura>"integer x7xinteger x8xinteger array x9xinteger array ovxinteger oexinteger oxxinteger ooxstring orx="<Meteorite>"
integer oixstring oax="<Pengu>"
integer onxinteger oVxstring oEx="<Sebastian>"
integer oXxgroup oNx=nullboolexpr oBx=nullendglobalsfunction odx takes player oDx returns groupset oNx=CreateGroup()call SyncSelections()call GroupEnumUnitsSelected(oNx,oDx,oBx)
return oNxendfunctionfunction config takes nothing returns nothinglocal integer oMxlocal player opx
call SetGamePlacement(MAP_PLACEMENT_USE_MAP_SETTINGS)call SetMapDescription("blub")call SetMapName("Defend Wintercastle")set oMx=6call SetPlayers(oMx+2)call SetTeams(2)
loop
exitwhen(oMx<0)set opx=Player(oMx)call SetPlayerController(opx,MAP_CONTROL_USER)call SetPlayerRacePreference(opx,RACE_PREF_HUMAN)call SetPlayerRaceSelectable(opx,false)call SetPlayerTeam(opx,0)set oMx=oMx-1endloopset opx=Player(7)call SetPlayerColor(opx,PLAYER_COLOR_PINK)call SetPlayerController(opx,MAP_CONTROL_COMPUTER)call SetPlayerRacePreference(opx,RACE_PREF_HUMAN)call SetPlayerRaceSelectable(opx,false)call SetPlayerTeam(opx,1)set opx=Player($B)call SetPlayerColor(opx,PLAYER_COLOR_BROWN)call SetPlayerController(opx,MAP_CONTROL_COMPUTER)call SetPlayerRacePreference(opx,RACE_PREF_ORC)call SetPlayerRaceSelectable(opx,false)call SetPlayerTeam(opx,1)set opx=null
endfunctionfunction oPx takes player oqx returns integerreturn(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((oqx))))),((((R))))))endfunctionfunction oQx takes nothing returns integerreturn oPx(GetTriggerPlayer())endfunctionfunction osx takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((I[(oSx)]))])]))],((((A[((oSx))])))),(((otx)))))endfunctionfunction oTx takes integer otx,integer oux returns integerreturn(oux*8192+(((otx)-O-8192)/ 8192))endfunctionfunction oUx takes string s returns nothingset G=G+1set h[G]=sendfunctionfunction owx takes nothing returns nothinglocal integer i=Hcall oUx("stack trace:")
loop
exitwhen(i<0)call oUx("-> "+(LoadStr(j,(J[i]),0)))set i=i-1endloopendfunctionfunction oWx takes string s returns nothinglocal string s2local integer oyxlocal integer clocal integer iset k=k+1if((k/ K)!=((k-1)/ K))thencall PreloadGenClear()endifset s="#"+I2S(k)+" ("+R2S((TimerGetElapsed(l)))+"): "+sset s2="\")"+sif(StringLength(s2)>259)then
set oyx=StringLength(s)set c=oyx/ 257+1
set i=1call Preload("\")"+":cmd mergeLines="+I2S(c))loop
exitwhen(i>c)if(i==c)then
call Preload("\")"+SubString(s,(i-1)*257,oyx))else
call Preload("\")"+SubString(s,(i-1)*257,i*257+1))endifset i=i+1endloopelse
call Preload(s2)
endifcall PreloadGenEnd("Logs\\Defend Wintercastle\\Session"+I2S(L)+"\\DWC_Errors_"+I2S(k/ K)+".txt")
endfunctionfunction oYx takes string s returns nothinglocal boolean ozx=trueif(s==null)thenset s="null"
endifif ozx thenendifif not ozx thenreturnendifcall oWx("[DEBUG] "+s)endfunctionfunction oZx takes nothing returns nothinglocal integer i=G-1local string sset f=f-1if(f>0)thenreturnendifif(G<0)thenreturnendifset s=h[G]set G=Floop
exitwhen(i<0)set s=h[i]+"
"+"\t"+sset i=i-1endloopcall oYx(s)endfunctionfunction o_x takes string o0x,string o1x,string s returns nothingset f=f+1call oUx("---/")
if(s!=null)thencall oUx(s)endifcall oUx("")
if(o0x!=null)thencall oUx("in ->"+o0x)endifif(o1x!=null)thencall oUx("line ->"+o1x)endifcall oUx("")
call owx()call oUx("/---")
call oZx()endfunctionfunction o2x takes integer otx returns integerlocal integer o3x=(((otx)-O-8192)/ 8192)
if(o3x>0)thenreturn O+8192+o3x*8192endifreturn 0
endfunctionfunction o4x takes integer o5x returns stringlocal integer o3x=(((o5x)-O-8192)/ 8192)
local integer o6x=o2x(o5x)local string o7x
if(o3x>0)thenset o7x=LoadStr(P,0,o6x)
if(o7x==null)thenreturn nullendifreturn((I2S((o6x)))+" (table "+(I2S((o3x)))+"; index "+(I2S((o5x-o6x)))+"): "+o7x)endifset o7x=LoadStr(P,0,o5x)
if(o7x==null)thenreturn nullendifreturn((I2S((o5x)))+" (base "+(I2S((o5x-O)))+"): "+o7x)endfunctionfunction o8x takes integer oSx,integer o9x,integer otx returns nothinglocal integer rvx=(0+(LoadInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx))))))local string rex
local string rxx
local integer oMxlocal integer ouxlocal integer roxset f=f+1call oUx("print table "+I2S(o9x)+";"+I2S(otx)+";"+I2S(rvx))set rex=o4x(o9x)
set rxx=o4x(otx)
if((rex!=null)or(rxx!=null))then
call oUx(rex+";"+rxx)endifcall oUx("--->")
set oMx=rvxloop
exitwhen(oMx<q)set oux=(LoadInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx)+(oMx)))))set rox=(LoadInteger(o[((D[(oSx)]))],((o9x)),(oTx((otx),((oux))))))call oUx("\t"+I2S(oux)+" on "+I2S(oMx)+";"+I2S(rox)+";"+I2S(oTx(otx,(oux))))
if(oMx!=rox)then
call oUx("TABLE CORRUPTED!")
endifcall oUx("\t"+"\t"+o4x(rox))
set oMx=oMx-1endloopcall oZx()endfunctionfunction rrx takes integer oSx,integer o9x,integer otx,integer oux returns booleanlocal integer rvx=(0+(LoadInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx))))))local integer rix=oTx(otx,(oux))
local integer rax=(LoadInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx)+(rvx)))))local integer rox=(LoadInteger(o[((D[oSx]))],(o9x),(rix)))if not((LoadInteger(o[((D[((oSx))]))],(((o9x))),(oTx(((otx)),(((oux)))))))!=0)thencall o_x("FolderDataTable_FolderIntegerKeys_StructTable_RemoveInteger","call DebugEx(FolderDataTable_FolderIntegerKeys_StructTable.NAME + \": \" + \"cannot remove \"+I2S(value) + \" from \" + I2S(missionKey) + \";\" + I2S(key) + \" reverseKey: \"+I2S(reverseKey))",M+": "+"cannot remove "+I2S(oux)+" from "+I2S(o9x)+";"+I2S(otx)+" reverseKey: "+I2S(rix))call o8x(oSx,o9x,otx)return false
endifcall SaveInteger(o[((D[oSx]))],(o9x),(oTx(otx,(rax))),(rox))
call SaveInteger(o[((V[(E[(oSx)])]))],((o9x)),((otx+rox)),((rax)))call SaveInteger(o[(((D[oSx])))],((o9x)),((rix)),(0))call SaveInteger(o[(((V[(E[(oSx)])])))],(((o9x))),(((otx+rvx))),(0))
set rvx=rvx-1call SaveInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx))),(((rvx)-0)))
return(rvx==0)endfunctionfunction rnx takes integer oSx,integer otx,integer oux returns booleanreturn rrx(I[(oSx)],(A[((oSx))]),otx,oux)endfunctionfunction rVx takes integer oSx,integer otx returns nothingcall SaveInteger(o[(((V[(E[((I[(oSx)]))])])))],(((((A[((oSx))]))))),((((otx)))),(0))
endfunctionfunction rEx takes integer oLx returns nothingset ov=oLxif not TriggerEvaluate(rv)thencall o_x("Basic_AllocInc","call DebugEx(\"AllocInc: \" + \"thread broken\")","AllocInc: thread broken")endifendfunctionfunction rXx takes integer oSx returns integerset ev[oSx]=true
set xv[oSx]=falsecall rEx(iv)
return oSxendfunctionfunction rOx takes nothing returns integerlocal integer oSxif(S==8190)thencall o_x("EventResponse_Allocation_allocCustom","call DebugEx(EventResponse.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",T+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(W[(w)]==w)thenset Y=Y+1set oSx=Yelse
set oSx=W[(w)]set W[(w)]=W[W[(w)]]
endifset W[oSx]=Z
set vv[oSx]=1call rXx(oSx)return oSxendfunctionfunction rRx takes integer rIx returns integerlocal integer oSx=rOx()set av[(oSx)]=(rIx)return oSxendfunctionfunction rAx takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((Rv[oSx]))])]))],((((A[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))endfunctionfunction rBx takes integer oSx returns booleanlocal trigger rcxlocal boolean o7xif(oSx==w)thenreturn trueendifset rcx=CreateTrigger()call TriggerAddCondition(rcx,Bv[oSx])set o7x=TriggerEvaluate(rcx)
call DestroyTrigger(rcx)
set rcx=null
return o7xendfunctionfunction rCx takes integer rdx returns nothingset H=H+1set J[H]=rdx
endfunctionfunction rDx takes integer oSx returns nothingset Cv=Cv+1if(dv[oSx]==null)thencall o_x("Trigger_Run","call DebugEx(Trigger.NAME + \": no action\" + \"(\" + I2S(this) + \")\")",Dv+": no action("+I2S(oSx)+")")returnendifif(fv[oSx]==0)thencall o_x("Trigger_Run","call DebugEx(Trigger.NAME + \": no code\" + \"(\" + I2S(this) + \")\")",Dv+": no code("+I2S(oSx)+")")returnendifcall rCx(fv[oSx])if not TriggerEvaluate(dv[oSx])thencall o_x("Trigger_Run","call DebugEx(\"trigThread broken: \" + this.name + \";\" + this.nameId + \" (\" + this.codeNameString + \")\")","trigThread broken: "+Fv[oSx]+";"+gv[oSx]+" ("+Gv[oSx]+")")endifset H=H-1endfunctionfunction rfx takes integer oSx,integer rFx returns nothingset Nv=(oSx)
set bv=(rFx)
if rBx((cv[(oSx)]))thencall rDx((hv[(oSx)]))endifendfunctionfunction rgx takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((Rv[oSx]))])]))],((((A[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))
endfunctionfunction rGx takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((Hv[oSx]))])]))],((((Ev[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))endfunctionfunction rhx takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((Hv[oSx]))])]))],((((Ev[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))endfunctionfunction rHx takes integer oLx returns nothingset jv=oLxif not TriggerEvaluate(Jv)thencall o_x("Basic_AllocDec","call DebugEx(\"AllocDec: \" + \"thread broken\")","AllocDec: thread broken")endifendfunctionfunction rjx takes integer oSx returns nothingset ev[oSx]=falsecall rHx(iv)
endfunctionfunction rJx takes integer oSx returns nothingif(vv[oSx]>0)thenreturnendifif(W[oSx]!=Z)thencall o_x("EventResponse_Allocation_deallocCustom_confirm","call DebugEx(EventResponse.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",T+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset W[oSx]=W[(w)]set W[(w)]=oSxcall rjx(oSx)endfunctionfunction rkx takes integer oSx returns nothingset vv[oSx]=vv[oSx]-1call rJx(oSx)endfunctionfunction rKx takes integer oSx,integer rlx returns nothinglocal integer rLx=oSxlocal integer rFx=rRx((A[(rLx)]))local integer rmxlocal integer oMxlocal integer rbxlocal integer rMxset nv[(rFx)]=(rlx)set Vv[(rFx)]=(rLx)set rmx=rRx((Ev[(rlx)]))
set nv[(rmx)]=(rlx)set Vv[(rmx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,Av,rbx)loop
exitwhen(rMx<q)call rfx(rgx(rLx,Av,rbx,rMx),rFx)set rMx=rMx-1endloopset rMx=rGx(rlx,Av,rbx)loop
exitwhen(rMx<q)call rfx(rhx(rlx,Av,rbx,rMx),rmx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call rkx(((rmx)))endfunctionfunction rpx takes integer oSx,integer rlx returns nothingif not((osx((((oSx))),N+((rlx))))>0)then
returnendifif(B[rlx]!=0)thencall UnitRemoveAbility(C[((oSx))],(B[rlx]))endifcall rnx((oSx),Q,rlx)call rVx((oSx),N+rlx)call rKx((oSx),(rlx))endfunctionfunction rPx takes integer oSx,string o9x,string otx returns integer
if((o9x==null)or(otx==null))then
call o_x("FolderGameCache_StructInteger_Get","call DebugEx(\"GameCache Get: \"+missionKey+\";\"+key)","GameCache Get: "+o9x+";"+otx)
return 0
endifreturn GetStoredInteger(Kv[(oSx)],o9x,otx)endfunctionfunction rqx takes string rQx,integer otx returns integerreturn(rPx(lv[(E[((X))])],((rQx)),(((I2S((otx)))))))
endfunctionfunction rsx takes string rSx returns integerreturn rqx(rSx,mv)endfunctionfunction rtx takes integer oSx,integer rTx returns nothingcall UnitAddAbility(C[(oSx)],rTx)call UnitMakeAbilityPermanent(C[(oSx)],true,rTx)
endfunctionfunction rux takes integer oSx,integer o9x,integer otx,integer oux returns booleanlocal integer rvxif((LoadInteger(o[((D[((oSx))]))],(((o9x))),(oTx(((otx)),(((oux)))))))!=0)thencall o_x("FolderDataTable_FolderIntegerKeys_StructTable_AddInteger","call DebugEx(I2S(value)+\" already in table \"+I2S(missionKey)+\";\"+I2S(key))",I2S(oux)+" already in table "+I2S(o9x)+";"+I2S(otx))call o8x(oSx,o9x,otx)return false
endifset rvx=(0+(LoadInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx))))))+1call SaveInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx))),(((rvx)-0)))
call SaveInteger(o[((D[oSx]))],(o9x),(oTx(otx,(oux))),(rvx))
call SaveInteger(o[((V[(E[(oSx)])]))],((o9x)),((otx+rvx)),((oux)))return(rvx==q)endfunctionfunction rUx takes integer oSx,integer otx,integer oux returns booleanreturn rux(I[(oSx)],(A[((oSx))]),otx,oux)endfunctionfunction rwx takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((I[(oSx)]))])]))],((((A[((oSx))])))),(((otx))),(((oux))))
endfunctionfunction rWx takes integer oSx,integer rlx returns integerreturn osx((oSx),N+rlx)endfunctionfunction ryx takes integer oSx,integer rYx,integer rlx returns nothinglocal integer rmx=rRx((Ev[(rlx)]))local integer oMxlocal integer rbxlocal integer rMxset Mv[(rmx)]=(rYx)set nv[(rmx)]=(rlx)set Vv[(rmx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rGx(rlx,pv,rbx)loop
exitwhen(rMx<q)call rfx(rhx(rlx,pv,rbx,rMx),rmx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rmx)))endfunctionfunction rzx takes integer oSx,integer rlx returns nothinglocal integer rYx=rWx((oSx),rlx)
call ryx(oSx,rYx,rlx)endfunctionfunction rZx takes integer oSx,integer rTx,integer rYx returns nothingif(rYx==0)thencall UnitRemoveAbility(C[((oSx))],(rTx))
returnendifif((GetUnitAbilityLevel(C[((oSx))],(rTx)))==0)thencall rtx(oSx,rTx)endifcall SetUnitAbilityLevel(C[(oSx)],rTx,rYx)endfunctionfunction r_x takes integer oSx,integer rlx,integer rYx returns nothinglocal integer rmx=rRx((Ev[(rlx)]))local integer oMxlocal integer rbxlocal integer rMxset Mv[(rmx)]=(rYx)set nv[(rmx)]=(rlx)set Vv[(rmx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rGx(rlx,Pv,rbx)loop
exitwhen(rMx<q)call rfx(rhx(rlx,Pv,rbx,rMx),rmx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rmx)))endfunctionfunction r0x takes integer oSx,integer rlx,integer rYx returns nothinglocal boolean r1xif(rYx==0)thencall rpx(oSx,rlx)returnendifset r1x=not((osx((((oSx))),N+((rlx))))>0)if r1x thenif(B[rlx]!=0)thencall rtx(oSx,B[rlx])
endifcall rUx((oSx),Q,rlx)call rwx((oSx),N+rlx,rYx)call rzx(oSx,rlx)returnendifcall rwx((oSx),N+rlx,rYx)call rZx(oSx,B[rlx],rYx)
call r_x((oSx),(rlx),(rYx))endfunctionfunction r2x takes integer oSx,integer rlx returns nothingcall r0x((oSx),(rlx),(1))endfunctionfunction r3x takes nothing returns nothinglocal string r4x=GetEventPlayerChatString()local integer oSx=oQx()if(SubString(r4x,0,3)=="-r ")thencall rpx((kv[(oSx)]),rsx(SubString(r4x,3,(StringLength((r4x))))))elseif(SubString(r4x,0,3)=="-a ")thencall r2x((kv[(oSx)]),rsx(SubString(r4x,3,(StringLength((r4x))))))endifendfunctionfunction r5x takes string oqx,integer r6x,integer r7x returns string
local integer r8x=((StringLength(((oqx))))-1)if(r7x>r8x)thencall o_x("String_Sub","call DebugEx(\"String Sub: end above upper limit (\" + self + \";\" + I2S(start) + \";\" + I2S(end) + \")\")","String Sub: end above upper limit ("+oqx+";"+I2S(r6x)+";"+I2S(r7x)+")")set r7x=r8xendifif(r6x<0)thencall o_x("String_Sub","call DebugEx(\"String Sub: start below lower limit (\" + self + \";\" + I2S(start) + \";\" + I2S(end) + \")\")","String Sub: start below lower limit ("+oqx+";"+I2S(r6x)+";"+I2S(r7x)+")")set r6x=0elseif(r6x>r7x)thenreturn nullendifreturn SubString(oqx,r6x,r7x+1)endfunctionfunction r9x takes string oqx,string oux,integer oLx returns integer
local integer oMx=0-1local integer ivx=((StringLength(((oqx))))-1)local integer iex=(StringLength((oux)))loop
exitwhen(oLx<0)set oMx=oMx+1loop
if(oMx>ivx)thenreturn Qvendifexitwhen(r5x(oqx,oMx,oMx+iex-1)==oux)set oMx=oMx+1endloopset oLx=oLx-1endloopreturn oMxendfunctionfunction ixx takes nothing returns nothinglocal string o5x=GetEventPlayerChatString()local integer iox=r9x(o5x,";",0)
call BJDebugMsg("load "+r5x(o5x,5,iox-1))call BJDebugMsg("loadB "+r5x(o5x,iox+1,StringLength(o5x)-1))
call BJDebugMsg(I2S((LoadInteger(o[((V[(E[((X))])]))],(((S2I(r5x(o5x,0,iox-2))))),(((S2I(r5x(o5x,iox,StringLength(o5x))))))))))endfunctionfunction irx takes nothing returns nothinglocal integer i=qlocal integer otx=Sv
local integer o9x=$9C40local integer o5x=S2I(SubString(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString())))if(SubString(GetEventPlayerChatString(),0,4)=="-add")thencall BJDebugMsg("add")call rux(X,o9x,otx,o5x)else
call BJDebugMsg("rem")call rrx(X,o9x,otx,o5x)endifcall BJDebugMsg("count "+I2S((0+(LoadInteger(o[((V[(E[((X))])]))],(((o9x))),(((otx))))))))loop
exitwhen(i>$A)call BJDebugMsg(I2S(i)+" --> "+I2S((LoadInteger(o[((V[(E[((X))])]))],(((o9x))),(((otx)+(i)))))))
set i=i+1endloopendfunctionfunction iix takes integer oSx returns integerset yv[oSx]=true
set Yv[oSx]=falsecall rEx(zv)
return oSxendfunctionfunction iax takes nothing returns integerlocal integer oSxif(Tv==8190)then
call o_x("GameMessage_Allocation_allocCustom","call DebugEx(GameMessage.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",uv+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(Uv[(w)]==w)thenset wv=wv+1set oSx=wvelse
set oSx=Uv[(w)]set Uv[(w)]=Uv[Uv[(w)]]endifset Uv[oSx]=Zset Wv[oSx]=1call iix(oSx)return oSxendfunctionfunction inx takes integer oSx returns integerset ie[oSx]=true
set ae[oSx]=falseset ne[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])call rEx(Xe)
return oSxendfunctionfunction iVx takes nothing returns integerlocal integer oSxif(ve==8190)then
call o_x("Timer_Allocation_allocCustom","call DebugEx(Timer.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",ee+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(xe[(w)]==w)thenset oe=oe+1set oSx=oeelse
set oSx=xe[(w)]set xe[(w)]=xe[xe[(w)]]endifset xe[oSx]=Zset re[oSx]=1call inx(oSx)return oSxendfunctionfunction iEx takes integer oSx returns nothingset Ie[(oSx)]=(Ne+oSx)endfunctionfunction iXx takes nothing returns integerlocal integer oSxlocal timer oqxif(Zv==F)thenset oSx=iVx()set oqx=CreateTimer()set Oe[oSx]=oqxcall SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oqx))))),((((Re)))),((((oSx)))))
set oqx=null
call iEx(oSx)return oSxendifset oSx=be[Zv]set Zv=Zv-1set Be[(oSx)]=(null)
set ce[(oSx)]=((.0)*1.)return oSxendfunctionfunction iOx takes integer oSx returns booleanreturn(oSx==(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetLocalPlayer())))))),((((R)))))))or(oSx==Ge)endfunctionfunction iRx takes integer oSx returns booleanset he=he+1set He[he]=oSxset je[oSx]=he+1
return(he==0)endfunctionfunction iIx takes integer oSx returns booleanlocal integer oMx=(je[(oSx)])-1loop
exitwhen(oMx==he)set He[oMx]=He[oMx+1]set je[He[oMx]]=oMx+1set oMx=oMx+1endloopset je[oSx]=0set he=he-1return(he==F)endfunctionfunction iAx takes real a,real b returns realif(a>b)thenreturn a
endifreturn b
endfunctionfunction iNx takes integer ibx returns nothinglocal integer oMxlocal player plocal integer oSxif not iOx(ibx)thenreturnendifif(he>F+4)thenset De[He[0]]=falsecall iIx(He[0])endifset oMx=(R2I(((iAx((0),(he+1-4)))*1.)))set p=GetLocalPlayer()call ClearTextMessages()
loop
set oSx=He[oMx]if Ce[oSx]thencall DisplayTimedTextToPlayer(p,-.1,1.2,iAx(.001,(TimerGetRemaining(Oe[(de[oSx])]))-3.),Fe[oSx])
else
call DisplayTimedTextToPlayer(p,-.1,1.2,.0,Fe[oSx])endifset oMx=oMx+1exitwhen(oMx>he)
endloopset p=nullendfunctionfunction iBx takes string icx,integer ibx returns integerlocal integer oSx=iax()local integer iCx=iXx()set Ce[oSx]=falseset de[oSx]=iCxset De[oSx]=true
set fe[oSx]=ibxset Fe[oSx]=icxset ge[(iCx)]=(oSx)if iOx(ibx)thencall iRx(oSx)endifcall iNx(ibx)return oSxendfunctionfunction idx takes integer oSx returns booleanif((ke[((oSx))])>0)thenreturn false
endifset Ke=Ke+1set le[Ke]=oSxset ke[oSx]=Ke+1
return(Ke==0)endfunctionfunction iDx takes integer oSx,real ifx,boolean iFx,code igx returns nothing
set Je[(oSx)]=((GetHandleId(Condition((igx)))))set Be[(oSx)]=((LoadStr(j,(GetHandleId(Condition(((igx))))),0)))
set ce[(oSx)]=((ifx)*1.)
call TimerStart(Oe[oSx],ifx,iFx,igx)
if iFx thencall idx(oSx)endifendfunctionfunction iGx takes nothing returns integerreturn(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))endfunctionfunction ihx takes integer oSx returns nothingset yv[oSx]=falsecall rHx(zv)
endfunctionfunction iHx takes integer oSx returns nothingif(Wv[oSx]>0)thenreturnendifif(Uv[oSx]!=Z)thencall o_x("GameMessage_Allocation_deallocCustom_confirm","call DebugEx(GameMessage.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",uv+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Uv[oSx]=Uv[(w)]set Uv[(w)]=oSxcall ihx(oSx)endfunctionfunction ijx takes integer oSx returns nothingset Wv[oSx]=Wv[oSx]-1call iHx(oSx)endfunctionfunction iJx takes integer oSx returns booleanif(((ke[((oSx))])>0)==false)then
return false
endifset ke[le[Ke]]=ke[oSx]set le[ke[oSx]-1]=le[Ke]
set ke[oSx]=0set Ke=Ke-1return(Ke==F)endfunctionfunction ikx takes integer oSx returns nothingcall PauseTimer(Oe[oSx])
call iJx(oSx)endfunctionfunction iKx takes integer oSx returns nothingset Zv=Zv+1set be[Zv]=oSxcall ikx(oSx)endfunctionfunction ilx takes integer oSx returns nothinglocal integer iCx=de[oSx]local integer ibx=fe[oSx]call ijx((oSx))call iKx(iCx)if iOx(ibx)thenif De[oSx]thencall iIx(oSx)endifendifcall iNx(ibx)endfunctionfunction iLx takes nothing returns nothinglocal integer oSx=(ge[(iGx())])call ilx(oSx)endfunctionfunction imx takes integer oSx,real iMx returns nothingset Ce[oSx]=true
call iDx(de[oSx],iMx,false,function iLx)
endfunctionfunction ipx takes integer oDx,string icx,real iMx returns integerlocal integer o7x=iBx(icx,oDx)call imx(o7x,iMx)return o7xendfunctionfunction iPx takes string oux returns integerlocal integer oyx=StringLength(oux)local integer iqxlocal integer oMxlocal integer o7xlocal string iQx
local integer isxif(SubString(oux,0,1)=="-")thenreturn-iPx(SubString(oux,1,oyx))
endifset iqx=1set oMx=oyx-1set o7x=0loop
exitwhen(oMx<0)set iQx=StringCase(SubString(oux,oMx,oMx+1),true)set isx=$Floop
exitwhen(iQx==Le[isx])set isx=isx-1endloopset o7x=o7x+isx*iqxset iqx=iqx*16set oMx=oMx-1endloopreturn o7xendfunctionfunction iSx takes string oqx,string oux returns stringif(oux==null)thenreturn oqxendifreturn("|c"+oux+oqx+"|r")endfunctionfunction itx takes boolean iTx,string oqx returns string
if iTx thenreturn oqxendifreturn""
endfunctionfunction iux takes string oux returns string
return(itx((StringLength((oux)))==1,Le[0])+oux)endfunctionfunction iUx takes real a,real b returns realif(a<b)thenreturn a
endifreturn b
endfunctionfunction iwx takes integer a,integer b returns integerreturn(R2I(((iUx(a,b))*1.)))
endfunctionfunction iWx takes integer iyx returns stringlocal string o7x=""local integer ouxif(iyx<0)thenreturn "-"+iWx(-iyx)
endifloop
exitwhen(iyx<16)
set oux=iwx(iyx/ 16,$F)set iyx=iyx-oux*16set o7x=o7x+Le[oux]endloopreturn(o7x+Le[iyx])endfunctionfunction iYx takes real izx,real iZx,real i_x,real i0x returns stringlocal string o7x=iux(iWx((R2I(((i0x*255.)*1.)))))set o7x=o7x+iux(iWx((R2I(((izx*255.)*1.)))))
set o7x=o7x+iux(iWx((R2I(((iZx*255.)*1.)))))
set o7x=o7x+iux(iWx((R2I(((i_x*255.)*1.)))))
return o7xendfunctionfunction i1x takes string oqx,string i2x,string i3x returns stringlocal integer oyx=(StringLength((oqx)))local integer i4x=(iPx(SubString((i3x),2,4)))local integer i5x=(iPx(SubString((i3x),4,6)))local integer i6x=(iPx(SubString((i3x),6,8)))local integer i7x=(iPx(SubString((i3x),0,2)))local integer i8x=i4xlocal integer i9x=i5xlocal integer avx=i6xlocal integer aex=i7xlocal integer axx=((iPx(SubString((i2x),2,4)))-i4x)/ oyx
local integer aox=((iPx(SubString((i2x),4,6)))-i5x)/ oyx
local integer arx=((iPx(SubString((i2x),6,8)))-i6x)/ oyx
local integer aix=((iPx(SubString((i2x),0,2)))-i7x)/ oyx
local integer r7x=oyx-0-1local integer oMx=r7x-1local string o7x=""loop
exitwhen(oMx<0+1)set i8x=i8x+axxset i9x=i9x+aoxset avx=avx+arxset aex=aex+aixset o7x=iSx(r5x(oqx,oMx,oMx),(iYx(((i8x)*1.)*1./ 255.,((i9x)*1.)*1./ 255.,((avx)*1.)*1./ 255.,((aex)*1.)*1./ 255.)))+o7x
set oMx=oMx-1endloopset o7x=iSx(r5x(oqx,0,0),i2x)+o7xset o7x=o7x+iSx(r5x(oqx,r7x,r7x),i3x)return o7xendfunctionfunction aax takes nothing returns nothingcall ipx(Ge,i1x(GetEventPlayerChatString(),"ffff0000","ffffcc00"),3.)call ipx(oPx(GetTriggerPlayer()),SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString())),3.)endfunctionfunction anx takes nothing returns nothinglocal real oux=S2R(SubStringBJ(GetEventPlayerChatString(),8,StringLength(GetEventPlayerChatString())))if(oux>.5)thenset Me[(pe)]=((oux)*1.)endifendfunctionfunction aVx takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((Te[oSx]))])]))],((((se[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))endfunctionfunction aEx takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((Te[oSx]))])]))],((((se[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))endfunctionfunction aXx takes integer oSx returns nothinglocal integer rFx=rRx(0)
local integer aOxlocal integer oMxlocal integer rbxlocal integer rMxset Qe[(rFx)]=(oSx)set aOx=rRx((se[(oSx)]))
set Qe[(aOx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((te))-1)*Iv+(((rbx))-1)))))))))loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((te))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset rMx=aVx(oSx,te,rbx)loop
exitwhen(rMx<q)call rfx(aEx(oSx,te,rbx,rMx),aOx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((aOx)))call rkx(((rFx)))endfunctionfunction aRx takes integer oSx returns nothingset qe=w
call aXx(oSx)endfunctionfunction aIx takes integer oSx returns nothinglocal integer rFx=rRx(0)
local integer aOxlocal integer oMxlocal integer rbxlocal integer rMxset Qe[(rFx)]=(oSx)set aOx=rRx((se[(oSx)]))
set Qe[(aOx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((We))-1)*Iv+(((rbx))-1)))))))))loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((We))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset rMx=aVx(oSx,We,rbx)loop
exitwhen(rMx<q)call rfx(aEx(oSx,We,rbx,rMx),aOx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((aOx)))call rkx(((rFx)))endfunctionfunction aAx takes integer oSx returns nothingif(qe!=w)thencall aRx(qe)
endifset qe=oSxif((ue[(oSx)])==w)thencall ipx(Ge,"New level begins: "+iSx((Ue[(oSx)]),"ffffcc00"),15.)else
call ipx(Ge,"New level begins: "+iSx((Ue[(oSx)]),"ffffcc00")+", next is "+iSx((Ue[((ue[(oSx)]))]),"ffffcc00"),15.)endifcall aIx(oSx)endfunctionfunction aNx takes nothing returns nothingcall aAx(ye[S2I(SubStringBJ(GetEventPlayerChatString(),4,StringLength(GetEventPlayerChatString())))])endfunctionfunction abx takes integer oSx,playercolor oux returns nothingset xx[oSx]=ouxcall SetUnitColor(C[(oSx)],oux)endfunctionfunction aBx takes integer oSx returns nothinglocal integer rLx=oSxlocal integer rFx=rRx((A[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset Vv[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,rx,rbx)loop
exitwhen(rMx<q)call rfx(rgx(rLx,rx,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction acx takes integer oSx,integer oux returns nothinglocal integer aCx=(ze[(oSx)])set ze[oSx]=ouxif(Ze[((oSx))])thencall SetUnitOwner(C[(oSx)],vx[ex],true)else
call SetUnitOwner(C[(oSx)],vx[oux],true)
endifcall abx((oSx),(ox[(oux)]))if(oux==aCx)then
returnendifcall aBx(oSx)endfunctionfunction adx takes unit oqx returns integerreturn(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((oqx))))),((((ix))))))endfunctionfunction aDx takes nothing returns nothingcall acx(adx(GetEnumUnit()),oPx(GetTriggerPlayer()))
endfunctionfunction afx takes nothing returns nothingcall ForGroupBJ(odx(Player(0)),function aDx)
endfunctionfunction aFx takes nothing returns nothingif nx thenif(GetEventPlayerChatString()=="-rpgcam")thenset nx=false
endifelse
set nx=trueset Vx=S2R(SubStringBJ(GetEventPlayerChatString(),9,StringLength(GetEventPlayerChatString())))endifendfunctionfunction agx takes player p,integer id,real x,real y,real z returns nothingset nr=nr+1endfunctionfunction aGx takes player a0,integer a1,real a2,real a3,real a4 returns unit
call agx(a0,a1,a2,a3,a4)
return CreateUnit(a0,a1,a2,a3,a4)endfunctionfunction ahx takes nothing returns nothinglocal player p=Player($F)local unit u
local integer unitID
local trigger tlocal real lifeset u=aGx(p,'uTav',-6144.,-1984.,.0)
call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uTav',6272.,-1600.,270.)call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uArS',4416.,-5376.,270.)call SetUnitColor(u,ConvertPlayerColor(0))endfunctionfunction aHx takes nothing returns nothinglocal player plocal unit u
local integer unitID
local trigger tlocal real lifeset p=Player(0)set u=aGx(p,'UMet',.0,5760.,270.)call SetUnitColor(u,ConvertPlayerColor(0))set p=Player(7)set u=aGx(p,'uPha',3264.,448.,270.)call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uLib',.0,1792.,270.)call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uFou',2048.,1792.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uFou',-2048.,1792.,270.)call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uPha',-896.,4672.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uGaC',896.,4672.,270.)call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uRes',1024.,3584.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uGaC',-3264.,448.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uRiS',-3520.,2240.,270.)call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uRes',3648.,2688.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uRes',-1088.,3584.,270.)call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uRes',3648.,2432.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uRes',832.,-448.,270.)call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uRes',-3456.,2688.,270.)call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uRes',-3456.,1216.,270.)call SetUnitColor(u,ConvertPlayerColor(0))set Vr=aGx(p,'uRiS',3392.,1088.,270.)call SetUnitColor(Vr,ConvertPlayerColor(0))set p=Player($B)
set u=aGx(p,'uTow',704.,-128.,270.)call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uBTw',-928.,2528.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uBTw',928.,2528.,270.)call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uBTw',-3488.,992.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uBTw',3872.,2528.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uBTw',-544.,-160.,270.)
call SetUnitColor(u,ConvertPlayerColor(0))endfunctionfunction ajx takes nothing returns nothinglocal player p=Player($F)local unit u
local integer unitID
local trigger tlocal real lifeset u=aGx(p,'uPeL',-5590.,-7097.5,149.968)call SetUnitColor(u,ConvertPlayerColor(0))endfunctionfunction aJx takes nothing returns nothinglocal player plocal unit u
local integer unitID
local trigger tlocal real lifeset p=Player(0)set Er=aGx(p,'uPan',-3084.7,-845.3,334.852)call SetUnitColor(Er,ConvertPlayerColor(0))set Xr=aGx(p,'uBDS',-1596.3,-1489.6,126.718)
call SetUnitColor(Xr,ConvertPlayerColor(0))set Rr=aGx(p,'uPan',-2933.7,-710.3,296.948)call SetUnitColor(Rr,ConvertPlayerColor(0))set Ir=aGx(p,'uWol',3092.3,-965.9,258.536)call SetUnitColor(Ir,ConvertPlayerColor(0))set Ar=aGx(p,'uTus',-1575.4,-1256.6,151.12)call SetUnitColor(Ar,ConvertPlayerColor(0))set Nr=aGx(p,'uKoB',1603.1,-1488.,64.906)call SetUnitColor(Nr,ConvertPlayerColor(0))set br=aGx(p,'nogr',-2668.7,-923.6,292.411)call SetUnitColor(br,ConvertPlayerColor(0))set u=aGx(p,'nomg',-4979.7,-1326.4,269.819)call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'nrdk',-1796.3,-1132.5,175.327)call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'nrdk',-1925.2,-1361.5,132.922)call SetUnitColor(u,ConvertPlayerColor(0))set Br=aGx(p,'uFuM',-4761.1,-978.8,231.847)call SetUnitColor(Br,ConvertPlayerColor(0))set cr=aGx(p,'nogr',-2788.8,-1018.3,314.452)
call SetUnitColor(cr,ConvertPlayerColor(0))set Cr=aGx(p,'uTus',-1691.8,-1396.2,150.663)
call SetUnitColor(Cr,ConvertPlayerColor(0))set dr=aGx(p,'uKoR',1582.4,-1361.1,54.808)call SetUnitColor(dr,ConvertPlayerColor(0))set Dr=aGx(p,'uKoR',1774.9,-1418.2,57.589)call SetUnitColor(Dr,ConvertPlayerColor(0))set fr=aGx(p,'uKoM',-4896.2,-1000.4,238.763)
call SetUnitColor(fr,ConvertPlayerColor(0))set Fr=aGx(p,'uKoM',-4719.2,-1132.6,216.197)
call SetUnitColor(Fr,ConvertPlayerColor(0))set gr=aGx(p,'uBDS',-1495.9,-1320.2,164.314)
call SetUnitColor(gr,ConvertPlayerColor(0))set u=aGx(p,'nsra',-5084.4,-1378.6,285.229)call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'nsra',-4874.7,-1395.2,250.933)call SetUnitColor(u,ConvertPlayerColor(0))set Gr=aGx(p,'uWoM',3244.4,-898.1,246.736)call SetUnitColor(Gr,ConvertPlayerColor(0))set hr=aGx(p,'uWol',3295.5,-1068.4,226.954)call SetUnitColor(hr,ConvertPlayerColor(0))set Hr=aGx(p,'uKoB',1686.5,-1549.2,59.667)call SetUnitColor(Hr,ConvertPlayerColor(0))set u=aGx(p,'ohun',-1903.,-1144.9,146.43)call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'ohun',-2026.7,-1301.4,136.268)call SetUnitColor(u,ConvertPlayerColor(0))set jr=aGx(p,'uTrG',4715.,-2739.7,83.518)call SetUnitColor(jr,ConvertPlayerColor(0))set Jr=aGx(p,'uTrP',4603.9,-2603.4,63.699)call SetUnitColor(Jr,ConvertPlayerColor(0))set kr=aGx(p,'uTrP',4842.5,-2666.6,65.853)call SetUnitColor(kr,ConvertPlayerColor(0))set p=Player(7)set Kr=aGx(p,'uSeb',-74.1,1659.5,261.67)
call SetUnitColor(Kr,ConvertPlayerColor(0))set p=Player(8)set u=aGx(p,'uPen',-5808.8,-6672.8,5.757)call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uPen',-4436.6,-6030.5,339.21)call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uPen',-5608.,-5022.6,307.313)call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uPen',-3996.7,-6982.,5.757)
call SetUnitColor(u,ConvertPlayerColor(0))set u=aGx(p,'uPen',-4690.6,-6965.2,161.488)call SetUnitColor(u,ConvertPlayerColor(0))endfunctionfunction akx takes code oqx returns nothingif(lr!=null)then
call TriggerRemoveAction(Lr,lr)endifset lr=TriggerAddAction(Lr,oqx)call rCx((GetHandleId(Condition((oqx)))))call TriggerExecuteWait(Lr)set H=H-1endfunctionfunction aKx takes string s returns nothinglocal boolean ozx=trueif(s==null)thenset s="null"
endifif not ozx thenreturnendifcall oWx("[INFO] "+s)endfunctionfunction alx takes nothing returns nothingcall SetTerrainFogEx(0,10000.,10000.,0,0,0,0)call SetCameraField(CAMERA_FIELD_FARZ,10000.,.0)
loop
exitwhen mrcall SetCameraField(CAMERA_FIELD_ANGLE_OF_ATTACK,270.,.0)call SetCameraField(CAMERA_FIELD_TARGET_DISTANCE,1650.,.0)call SetCameraField(CAMERA_FIELD_ZOFFSET,10000.,.0)call TriggerSleepAction(.035)endloopendfunctionfunction aLx takes nothing returns nothingset Mr=0
loop
exitwhen mrcall TriggerSleepAction(1)set Mr=Mr+1endloopendfunctionfunction amx takes nothing returns nothinglocal real camX=GetCameraTargetPositionX()local real camY=GetCameraTargetPositionY()local real z=3900.call EnableUserUI(false)
call ShowInterface(false,0)call SetCineFilterBlendMode(BLEND_MODE_BLEND)call SetCineFilterTexMapFlags(TEXMAP_FLAG_NONE)call SetCineFilterDuration(0)call SetCineFilterEndColor($FF,$FF,$FF,$FF)call SetCineFilterStartColor($FF,$FF,$FF,$FF)call SetCineFilterEndUV(0,0,1,1)
call SetCineFilterStartUV(0,0,1,1)call SetCineFilterTexture("UI\\LoadingScreenBackground.blp")
call DisplayCineFilter(true)
call FogEnable(false)call FogMaskEnable(false)call ExecuteFunc("alx")call ExecuteFunc("aLx")endfunctionfunction aMx takes integer oSx returns integerset tr[oSx]=true
set Tr[oSx]=falseset oSx=null
set oSx=wset oSx=wset oSx=0set oSx=null
set oSx=null
set oSx=wcall rEx(ur)
return oSxendfunctionfunction apx takes nothing returns integerlocal integer oSxif(qr==8190)then
call o_x("Allocation_allocCustom","call DebugEx(Loading.NAME + \" - alloc: unable to allocCustom, reached stack limit\")","<s__Loading_Name>"+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Qr[(w)]==w)thenset sr=sr+1set oSx=srelse
set oSx=Qr[(w)]set Qr[(w)]=Qr[Qr[(w)]]endifset Qr[oSx]=Zset Sr[oSx]=1call aMx(oSx)return oSxendfunctionfunction aPx takes integer oSx returns booleanreturn(Yr==oSx)or((zr[oSx]!=w)or(Zr[oSx]!=w))endfunctionfunction aqx takes integer oSx returns booleanif aPx(oSx)thenreturn false
endifset Zr[oSx]=wif(Yr==w)thenset vi=oSxset Yr=oSxreturn trueendifset zr[oSx]=viset Zr[vi]=oSxset vi=oSxreturn false
endfunctionfunction aQx takes trigger t,integer rdx,string rSx returns nothinglocal integer oSx=apx()set Ur=Ur+1set wr[oSx]=rdxset Wr[oSx]=rSxset yr[oSx]=tcall aqx(oSx)endfunctionfunction asx takes nothing returns booleanlocal integer oMx=Pr
loop
exitwhen(oMx<0)call aQx(ei[oMx],xi[oMx],oi[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction aSx takes code c returns nothinglocal string rSx=LoadStr(j,(GetHandleId(Condition((c)))),0)local trigger t=CreateTrigger()set Ur=Ur+1call TriggerAddCondition(t,Condition(c))
if(rSx==null)thenset rSx="unknown"endifcall aQx(t,(GetHandleId(Condition((c)))),rSx)set t=nullendfunctionfunction atx takes integer oSx returns integerset Xi[oSx]=true
set Oi[oSx]=falsecall rEx(Ri)
return oSxendfunctionfunction aTx takes nothing returns integerlocal integer oSxif(ii==8190)then
call o_x("EffectLevel_Allocation_allocCustom","call DebugEx(EffectLevel.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",ai+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(ni[(w)]==w)thenset Vi=Vi+1set oSx=Vielse
set oSx=ni[(w)]set ni[(w)]=ni[ni[(w)]]endifset ni[oSx]=Zset Ei[oSx]=1call atx(oSx)return oSxendfunctionfunction aux takes integer oSx returns booleanset Ai=Ai+1set Ni[Ai]=oSxset bi[oSx]=Ai+1
return(Ai==0)endfunctionfunction aUx takes string rSx returns integerlocal integer oSx=aTx()set Ii[(oSx)]=(rSx)call aux(oSx)return oSxendfunctionfunction awx takes nothing returns booleanset ri=aUx("low")set Bi=aUx("normal")
set ci=Bireturn trueendfunctionfunction aWx takes nothing returns booleanlocal integer oMx=Ci
loop
exitwhen(oMx<0)call aQx(di[oMx],Di[oMx],fi[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction ayx takes nothing returns booleanlocal integer oMx=Fi
loop
exitwhen(oMx<0)call aQx(gi[oMx],Gi[oMx],hi[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction aYx takes nothing returns booleanlocal integer oMx=Hi
loop
exitwhen(oMx<0)call aQx(ji[oMx],Ji[oMx],ki[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction azx takes integer oSx returns integerset qi[oSx]=true
set Qi[oSx]=falsecall rEx(si)
return oSxendfunctionfunction aZx takes nothing returns integerlocal integer oSxif(Li==8190)then
call o_x("ObjThread_Allocation_allocCustom","call DebugEx(ObjThread.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",mi+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(Mi[(w)]==w)thenset pi=pi+1set oSx=pielse
set oSx=Mi[(w)]set Mi[(w)]=Mi[Mi[(w)]]endifset Mi[oSx]=Zset Pi[oSx]=1call azx(oSx)return oSxendfunctionfunction a_x takes integer oSx returns booleanset ti=ti+1set Ti[ti]=oSxset ui[oSx]=ti+1
return(ti==0)endfunctionfunction a0x takes integer oSx returns nothingset qi[oSx]=falsecall rHx(si)
endfunctionfunction a1x takes integer oSx returns nothingif(Pi[oSx]>0)thenreturnendifif(Mi[oSx]!=Z)thencall o_x("ObjThread_Allocation_deallocCustom_confirm","call DebugEx(ObjThread.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",mi+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Mi[oSx]=Mi[(w)]set Mi[(w)]=oSxcall a0x(oSx)endfunctionfunction a2x takes integer oSx returns nothingset Pi[oSx]=Pi[oSx]-1call a1x(oSx)endfunctionfunction a3x takes integer oSx returns booleanlocal integer oLx=(ui[(oSx)])set ui[Ti[ti]]=oLxset Ti[oLx-1]=Ti[ti]
set ui[oSx]=0set ti=ti-1return(ti==F)endfunctionfunction a4x takes integer oSx returns nothingcall a2x((oSx))if a3x(oSx)thencall PauseTimer(Ui)endifendfunctionfunction a5x takes nothing returns nothinglocal integer i=tiset f=f+1loop
exitwhen(i<0)call oUx("threadBreak (ObjThread): "+Si[Ti[i]])set wi=false
call a4x(Ti[i])set wi=trueset i=i-1endloopcall oZx()endfunctionfunction a6x takes string rSx returns integerlocal integer oSx=aZx()set Si[oSx]=rSxif a_x(oSx)thenif(Ui==null)then
set Ui=CreateTimer()
endifcall TimerStart(Ui,1,true,function a5x)endifreturn oSxendfunctionfunction a7x takes nothing returns nothinglocal integer a8x=(R2I(((iUx((Wi+Yi),(yi)))*1.)))local integer a9x=Ki
local trigger tlocal integer rdxlocal string rSx
loop
exitwhen(Wi>a8x)
set t=LoadTriggerHandle(li,a9x,Wi)set rdx=LoadInteger(zi,a9x,Wi)set rSx=LoadStr(Zi,a9x,Wi)call aQx(t,rdx,rSx)set Wi=Wi+1endloopendfunctionfunction nvx takes nothing returns nothinglocal integer a9x=Ki
local integer rvx=LoadInteger(li,a9x,0)local integer th=a6x("OBJECT INITS "+I2S(a9x))set Wi=1
set yi=rvxset Yi=$5DCloop
exitwhen(Wi>yi)call akx(function a7x)endloopcall a4x(th)
endfunctionfunction nex takes integer a9x returns nothingset Ki=a9xcall akx(function nvx)endfunctionfunction nxx takes nothing returns booleanlocal integer oMx=ea
loop
exitwhen(oMx<0)call aQx(xa[oMx],oa[oMx],ra[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nox takes nothing returns booleanlocal integer oMx=ia
loop
exitwhen(oMx<0)call aQx(aa[oMx],na[oMx],Va[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nrx takes nothing returns booleanlocal integer oMx=Ea
loop
exitwhen(oMx<0)call aQx(Xa[oMx],Oa[oMx],Ra[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nix takes nothing returns booleanlocal integer oMx=Ia
loop
exitwhen(oMx<0)call aQx(Aa[oMx],Na[oMx],ba[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nax takes nothing returns booleanlocal integer oMx=Ba
loop
exitwhen(oMx<0)call aQx(ca[oMx],Ca[oMx],da[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nnx takes nothing returns booleanlocal integer oMx=Da
loop
exitwhen(oMx<0)call aQx(fa[oMx],Fa[oMx],ga[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nVx takes nothing returns booleanlocal integer oMx=Sa
loop
exitwhen(oMx<0)call aQx(ta[oMx],Ta[oMx],ua[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nEx takes nothing returns booleanlocal integer oMx=Ua
loop
exitwhen(oMx<0)call aQx(wa[oMx],Wa[oMx],ya[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nXx takes nothing returns booleanlocal integer oMx=Ya
loop
exitwhen(oMx<0)call aQx(za[oMx],Za[oMx],vn[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nOx takes nothing returns booleanlocal integer oMx=en
loop
exitwhen(oMx<0)call aQx(xn[oMx],on[oMx],rn[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nRx takes nothing returns booleanlocal integer oMx=in
loop
exitwhen(oMx<0)call aQx(an[oMx],nn[oMx],Vn[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nIx takes nothing returns booleanlocal integer oMx=En
loop
exitwhen(oMx<0)call aQx(Xn[oMx],On[oMx],Rn[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nAx takes nothing returns booleanlocal integer oMx=In
loop
exitwhen(oMx<0)call aQx(An[oMx],Nn[oMx],bn[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nNx takes nothing returns booleanlocal integer oMx=Bn
loop
exitwhen(oMx<0)call aQx(cn[oMx],Cn[oMx],dn[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nbx takes nothing returns booleanlocal integer oMx=Dn
loop
exitwhen(oMx<0)call aQx(fn[oMx],Fn[oMx],gn[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nBx takes nothing returns booleanlocal integer oMx=Gn
loop
exitwhen(oMx<0)call aQx(hn[oMx],Hn[oMx],jn[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction ncx takes nothing returns booleanlocal integer oMx=Jn
loop
exitwhen(oMx<0)call aQx(kn[oMx],Kn[oMx],ln[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nCx takes nothing returns booleanlocal integer oMx=Ln
loop
exitwhen(oMx<0)call aQx(mn[oMx],Mn[oMx],pn[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction ndx takes nothing returns booleanlocal integer oMx=Pn
loop
exitwhen(oMx<0)call aQx(qn[oMx],Qn[oMx],sn[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nDx takes nothing returns booleanlocal integer oMx=Sn
loop
exitwhen(oMx<0)call aQx(tn[oMx],Tn[oMx],un[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nfx takes nothing returns booleanlocal integer oMx=Un
loop
exitwhen(oMx<0)call aQx(wn[oMx],Wn[oMx],yn[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nFx takes nothing returns booleanlocal integer oMx=Yn
loop
exitwhen(oMx<0)call aQx(zn[oMx],Zn[oMx],vV[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction ngx takes nothing returns booleanlocal integer oMx=eV
loop
exitwhen(oMx<0)call aQx(xV[oMx],oV[oMx],rV[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nGx takes nothing returns booleanlocal integer oMx=iV
loop
exitwhen(oMx<0)call aQx(aV[oMx],nV[oMx],VV[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nhx takes nothing returns booleancall SetFloatGameState((GAME_STATE_TIME_OF_DAY),((12.)*1.))return trueendfunctionfunction nHx takes nothing returns booleanlocal integer oMx=EV
loop
exitwhen(oMx<0)call aQx(XV[oMx],OV[oMx],RV[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction njx takes nothing returns booleanlocal integer oMx=IV
loop
exitwhen(oMx<0)call aQx(AV[oMx],NV[oMx],bV[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nJx takes nothing returns booleanlocal integer oMx=BV
loop
exitwhen(oMx<0)call aQx(cV[oMx],CV[oMx],dV[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nkx takes nothing returns booleanlocal integer oMx=DV
loop
exitwhen(oMx<0)call aQx(fV[oMx],FV[oMx],gV[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nKx takes nothing returns booleanlocal integer oMx=GV
loop
exitwhen(oMx<0)call aQx(hV[oMx],HV[oMx],jV[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nlx takes nothing returns booleanlocal integer oMx=JV
loop
exitwhen(oMx<0)call aQx(kV[oMx],KV[oMx],lV[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nLx takes nothing returns booleanlocal integer oMx=LV
loop
exitwhen(oMx<0)call aQx(mV[oMx],MV[oMx],pV[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nmx takes nothing returns booleanlocal integer oMx=PV
loop
exitwhen(oMx<0)call aQx(qV[oMx],QV[oMx],sV[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nMx takes nothing returns booleanlocal integer oMx=SV
loop
exitwhen(oMx<0)call aQx(tV[oMx],TV[oMx],uV[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction npx takes nothing returns booleanlocal integer oMx=UV
loop
exitwhen(oMx<0)call aQx(wV[oMx],WV[oMx],yV[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nPx takes nothing returns booleanlocal integer oMx=YV
loop
exitwhen(oMx<0)call aQx(zV[oMx],ZV[oMx],vE[oMx])set oMx=oMx-1endloopreturn trueendfunctionfunction nqx takes nothing returns nothingcall SetCameraField(CAMERA_FIELD_FARZ,.0,.0)
call SetCineFilterBlendMode(BLEND_MODE_BLEND)call SetCineFilterTexMapFlags(TEXMAP_FLAG_NONE)call SetCineFilterDuration(3.-1.)call SetCineFilterEndColor($FF,$FF,$FF,0)call SetCineFilterStartColor($FF,$FF,$FF,$FF)call SetCineFilterEndUV(0,0,1,1)
call SetCineFilterStartUV(0,0,1,1)call SetCineFilterTexture("UI\\LoadingScreenBackground.blp")
call DisplayCineFilter(true)
call ShowInterface(true,3.-1.)endfunctionfunction nQx takes nothing returns nothingset mr=truecall FogEnable(true)
call FogMaskEnable(true)
call ResetToGameCamera(.0)call ResetTerrainFog()call SetCameraField(CAMERA_FIELD_FARZ,5000.,.0)call DisplayCineFilter(false)call EnableUserUI(true)call aKx("finished loading in "+R2S(Mr)+" seconds")call PauseGame(false)endfunctionfunction nsx takes integer oDx,real x,real y,real x2,real y2,real x3,real y3,real x4,real y4 returns nothing
if iOx(oDx)thenset eE=x
set xE=x2set oE=x3set rE=x4set iE=y
set aE=y2set nE=y3set VE=y4call SetCameraBounds(x,y,x2,y2,x3,y3,x4,y4)endifendfunctionfunction nSx takes nothing returns nothinglocal integer rFx=rRx(0)
local integer oMx=0local integer rbxlocal integer rMxloop
exitwhen(oMx>Xv)
set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((EE))-1)*Iv+(((rbx))-1)))))))))loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((EE))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset oMx=oMx+1endloopcall rkx(((rFx)))endfunctionfunction ntx takes nothing returns nothingcall aKx("start game")call nqx()call StopSound(pr,true,false)set pr=nullcall FogMaskEnable(false)call SetCameraField(CAMERA_FIELD_ANGLE_OF_ATTACK,315.,.0)call SetCameraField(CAMERA_FIELD_TARGET_DISTANCE,1650.,.0)call SetCameraField(CAMERA_FIELD_ZOFFSET,.0,.0)call TriggerSleepAction(((3.)*1.))call nQx()call nsx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetLocalPlayer())))))),((((R)))))),-7680.+GetCameraMargin(CAMERA_MARGIN_LEFT),-7680.+GetCameraMargin(CAMERA_MARGIN_BOTTOM),7680.-GetCameraMargin(CAMERA_MARGIN_RIGHT),7680.-GetCameraMargin(CAMERA_MARGIN_TOP),-7680.+GetCameraMargin(CAMERA_MARGIN_LEFT),7680.-GetCameraMargin(CAMERA_MARGIN_TOP),7680.-GetCameraMargin(CAMERA_MARGIN_RIGHT),-7680.+GetCameraMargin(CAMERA_MARGIN_BOTTOM))call EnableOcclusion(true)call akx(function nSx)endfunctionfunction nTx takes nothing returns booleancall aKx("ingame loading finished")call a5x()call akx(function ntx)return trueendfunctionfunction nux takes nothing returns integerlocal integer oMx=Flocal integer oSx=Yr
loop
exitwhen(oSx==w)
set oSx=Zr[oSx]set oMx=oMx+1endloopreturn oMxendfunctionfunction nUx takes nothing returns booleanlocal gamecache gc=InitGameCache("singlePlayerCheck")local boolean o7xcall StoreBoolean(gc,"blub","moo",true)set o7x=SaveGameCache(gc)call FlushGameCache(gc)set gc=nullreturn o7xendfunctionfunction nwx takes nothing returns integerlocal integer oSx=Yr
if(oSx==w)thenreturn w
endifset Yr=Zr[oSx]set Zr[oSx]=wif(Yr==w)thenset vi=w
else
set zr[Yr]=w
endifreturn oSxendfunctionfunction nWx takes nothing returns nothinglocal integer nyxlocal integer i=XElocal integer nYxlocal integer oSxif(Yr==w)thenreturnendifloop
exitwhen(Yr==w)set oSx=nwx()call rCx(wr[oSx])if not TriggerEvaluate(yr[oSx])thencall o_x("LoadingQueue","Queue_Exec","could not finish init: "+Wr[oSx])endifset H=H-1set yr[oSx]=null
set i=i-1exitwhen(i<1)endloopset nyx=Ur-(nux()-F)
set nYx=Urcall SetCinematicScene(0,null,"Please wait for the map to initialize...",I2S(nyx)+"/"+I2S(nYx)+" assets loaded"+"
"+I2S(R2I(nyx*100./ nYx))+"%",999,0)if(Yr==w)thencall PauseTimer(OE)endifendfunctionfunction nzx takes nothing returns nothinglocal integer nZx=(nux()-F)local integer userCountif(nZx<=0)thenreturnendifset Ur=nZxset XE=R2I(nZx/ 100.)if nUx()then
call aKx("singlePlayer")
call PauseGame(true)
loop
exitwhen mrcall ExecuteFunc("nWx")call ExecuteFunc("nWx")call ExecuteFunc("nWx")call ExecuteFunc("nWx")call ExecuteFunc("nWx")call TriggerSleepAction(0)endloopelse
call aKx("multiPlayer")call TimerStart(OE,1./ $C,true,function nWx)
endifendfunctionfunction n_x takes nothing returns nothingcall aKx("process ingame loading...")call asx()call aSx(function awx)call aWx()call ayx()call aYx()call nex(va)
call nxx()call nox()call nrx()call nix()call nax()call nnx()call nex(ha)
call nex(Ha)
call nex(Ja)
call nex(Ka)
call nex(La)
call nex(ma)
call nex(Ma)
call nex(Pa)
call nex(Qa)
call nex(sa)
call nVx()call nEx()call nXx()call nOx()call nRx()call nIx()call nAx()call nNx()call nbx()call nBx()call ncx()call nCx()call ndx()call nDx()call nfx()call nFx()call ngx()call nGx()call aSx(function nhx)call nHx()call njx()call nJx()call nkx()call nKx()call nlx()call nLx()call nmx()call nMx()call npx()call nPx()call aSx(function nTx)call nzx()endfunctionfunction n0x takes nothing returns nothingcall aKx("start loading")call amx()call SetMapMusic("",false,0)
call TriggerSleepAction(.0)set pr=CreateSound("Sound\\Music\\mp3Music\\War2IntroMusic.mp3",false,false,false,$A,$A,"DefaultEAXOn")call SetSoundPitch(pr,.8)call StartSound(pr)call akx(function n_x)endfunctionfunction n1x takes nothing returns booleanlocal integer n2x=IE
local integer nyx=AE
set n2x=n2x-1loop
exitwhen(n2x<0)set nyx=NE[nyx]set n2x=n2x-1endloopset bE=nyxreturn trueendfunctionfunction n3x takes nothing returns booleanlocal integer oLx=jv
local integer n4x=BE[oLx]local integer n5x=n4x-1local integer n6xlocal integer n7xlocal integer n8xlocal integer n9xlocal integer Vvxlocal integer Vexif(n5x<0)thencall o_x("Basic_AllocDec_Exec","call DebugEx(\"AllocDec: cannot fall below zero\")","AllocDec: cannot fall below zero")return trueendifset BE[oLx]=n5xset n6x=cE[n4x]set n7x=CE[n4x]set n8x=dE[oLx]set n9x=NE[oLx]if(n7x==oLx)then
if(n6x==oLx)then
set CE[n4x]=Felse
set CE[n4x]=n8xendifset Vvx=Felse
set Vvx=n7xendifif(n6x==oLx)then
if(n7x==oLx)then
set cE[n4x]=Felse
set cE[n4x]=n9xendifendifif(Vvx!=F)thenif(n9x!=F)thenset dE[n9x]=n8xendifif(n8x==F)thenset AE=n9xelse
set NE[n8x]=n9xendifset Vex=NE[Vvx]set NE[oLx]=Vexif(Vex==F)thenset DE=oLxelse
set dE[Vex]=oLxendifset NE[Vvx]=oLxset dE[oLx]=Vvxendifif((oLx==DE)or(BE[NE[oLx]]<n5x))then
set CE[n5x]=oLxendifset cE[n5x]=oLxset fE=fE-1return trueendfunctionfunction Vxx takes nothing returns booleanlocal integer oLx=ov
local integer n4x=BE[oLx]local integer n5x=n4x+1local integer n6xlocal integer n7xlocal integer n9xlocal integer n8xlocal integer Vexlocal integer Vvxset BE[oLx]=n5xset n6x=cE[n4x]set n7x=CE[n4x]set n9x=NE[oLx]set n8x=dE[oLx]if(n6x==oLx)then
if(n7x==oLx)then
set cE[n4x]=Felse
set cE[n4x]=n9xendifset Vex=Felse
set Vex=n6xendifif(n7x==oLx)then
if(n6x==oLx)then
set CE[n4x]=Felse
set CE[n4x]=n8xendifendifif(Vex!=F)thenif(n8x!=F)thenset NE[n8x]=n9xendifif(n9x==F)thenset DE=n8xelse
set dE[n9x]=n8xendifset Vvx=dE[Vex]set dE[oLx]=Vvxif(Vvx==F)thenset AE=oLxelse
set NE[Vvx]=oLxendifset dE[Vex]=oLxset NE[oLx]=Vexendifif((oLx==AE)or(BE[dE[oLx]]>n5x))then
set cE[n5x]=oLxendifset CE[n5x]=oLxset fE=fE+1return trueendfunctionfunction Vox takes nothing returns nothingset RE=CreateTrigger()set Jv=CreateTrigger()set rv=CreateTrigger()call TriggerAddCondition(RE,Condition(function n1x))
call TriggerAddCondition(Jv,Condition(function n3x))
call TriggerAddCondition(rv,Condition(function Vxx))
endfunctionfunction Vrx takes nothing returns booleanlocal string Vix=GetPlayerName(GetLocalPlayer())
call TimerStart(l,99999,true,null)call SetPlayerName(GetLocalPlayer(),I2S(L))call Preloader("Logs\\Defend Wintercastle\\index.ini")set L=S2I(GetPlayerName(GetLocalPlayer()))+1
call PreloadGenClear()call PreloadGenStart()call Preload("\")
call SetPlayerName(GetLocalPlayer(), \""+I2S(L)+"\")
call Preload(\"")
call SetPlayerName(GetLocalPlayer(),Vix)
call PreloadGenEnd("Logs\\Defend Wintercastle\\index.ini")call PreloadGenEnd("Logs\\Defend Wintercastle\\signal.ini")call PreloadGenClear()call Preload("\")
"+("DEL \"DWC_Errors.txt\"")+"
REM (\"")call Preload("\")
"+("DEL takeFile.bat")+"
REM (\"")
call Preload("\")
"+("echo	set file=%%~1>>takeFile.bat")+"
REM (\"")
call Preload("\")
"+("echo	echo %%file%%>>takeFile.bat")+"
REM (\"")
call Preload("\")
"+("echo	for /f \"tokens=*\" %%%%A in (%%file%%) do (call takeLine.bat \"%%%%A\")>>takeFile.bat")+"
REM (\"")call Preload("\")
"+("REM echo	DEL %%file%%>>takeFile.bat")+"
REM (\"")call Preload("\")
"+("DEL takeLine.bat")+"
REM (\"")
call Preload("\")
"+("echo	set txt=%%1>>takeLine.bat")+"
REM (\"")call Preload("\")
"+("echo	set txt=%%txt:call Preload( ^\"^\")=%%>>takeLine.bat")+"
REM (\"")call Preload("\")
"+("echo	IF %%txt%%==%%1 goto :eof>>takeLine.bat")+"
REM (\"")
call Preload("\")
"+("echo	set txt=%%txt:^\" )=%%>>takeLine.bat")+"
REM (\"")call Preload("\")
"+("echo	set txt=%%txt:^|=^^^^^^^|%%>>takeLine.bat")+"
REM (\"")call Preload("\")
"+("echo	set txt=%%txt:^>=^^^^^^^>%%>>takeLine.bat")+"
REM (\"")call Preload("\")
"+("echo	set txt=%%txt:^\"='%%>>takeLine.bat")+"
REM (\"")
call Preload("\")
"+("echo	IF \"%%txt%%\"==\"\" goto :eof>>takeLine.bat")+"
REM (\"")call Preload("\")
"+("echo	echo %%txt%%^>^>DWC_Errors.txt>>takeLine.bat")+"
REM (\"")call Preload("\")
"+("pause")+"
REM (\"")call Preload("\")
"+("for /f %%f in ('dir /b /od \"DWC_Errors_*.txt\"') do (call takeFile.bat \"%%f\")")+"
REM (\"")
call Preload("\")
"+("DEL takeFile.bat")+"
REM (\"")
call Preload("\")
"+("DEL takeLine.bat")+"
REM (\"")
call PreloadGenEnd("Logs\\Defend Wintercastle\\Session"+I2S(L)+"\\DWC_Errors_MergeLogs.bat")
call PreloadGenClear()call aKx("private session "+I2S(L))call Vox()return trueendfunctionfunction Vax takes nothing returns nothingset H=H-1endfunctionfunction Vnx takes code c,string rSx returns boolean
local trigger t=CreateTrigger()local boolean o7xcall TriggerAddCondition(t,Condition(c))
call rCx(GetHandleId(Condition(c)))set o7x=TriggerEvaluate(t)if not o7x thencall o_x(null,"runProtFunc","compilefunc "+rSx+" has been broken")endifcall Vax()set t=nullreturn o7xendfunctionfunction VVx takes nothing returns booleanset j=InitHashtable()return trueendfunctionfunction VEx takes nothing returns booleanset P=InitHashtable()call SaveStr(P,0,423,"s__FolderUnitModSet_StructMods_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,96,"s__FolderSpotEffectWithSize_StructDestroyTimed_GetKeyMacro_KEY")call SaveStr(P,0,400,"s__FolderUnit_FolderSelection_StructCircle_GetKeyMacro_KEY_ARRAY_DETAIL")call SaveStr(P,0,$FC,"s__Trigger_GetKeyMacro_CODE_KEY")call SaveStr(P,0,424,"s__FolderUnitModSet_StructMods_GetKeyMacro_KEY_ARRAY_DETAIL_VAL")call SaveStr(P,0,$C9,"s__FolderDummyUnit_FolderVertexColor_StructTimed_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,436,"s__FolderUnitType_StructClasses_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,380,"s__FolderUnit_StructVertexColor_GetKeyMacro_STATE_ALPHA_KEY")call SaveStr(P,0,$E9,"s__TileType_GetKeyMacro_KEY")call SaveStr(P,0,$C5,"s__FolderDummyUnit_StructFollowUnit_GetKeyMacro_KEY")call SaveStr(P,0,364,"s__FolderUnit_StructVertexColor_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$E8,"s__Spell_GetKeyMacro_INIT_KEY_ARRAY")call SaveStr(P,0,334,"s__FolderUnit_FolderAttack_StructSplash_GetKeyMacro_TYPE_BOUND_KEY_ARRAY")
call SaveStr(P,0,24,"s__FolderVoteHost_StructVotes_GetKeyMacro_KEY")
call SaveStr(P,0,504,"s__FolderDefenderSpawnWave_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,342,"s__FolderUnit_StructInvulnerability_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$DF,"s__Spell_GetKeyMacro_KEY")
call SaveStr(P,0,'r',"s__FolderEventCombination_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,32,"s__AIAutoCast_GetKeyMacro_SPELL_KEY")call SaveStr(P,0,318,"s__FolderUnit_StructModSets_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,592,"s__FolderVividMeteor_StructEffects_GetKeyMacro_PARENT_KEY_ARRAY")call SaveStr(P,0,74,"s__FolderDialogButton_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,376,"s__FolderUnit_StructVertexColor_GetKeyMacro_STATE_GREEN_KEY")call SaveStr(P,0,98,"s__DummyUnitEffect_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$DC,"s__Spell_GetKeyMacro_AREA_RANGE_KEY_ARRAY_DETAIL")
call SaveStr(P,0,$C7,"s__FolderDummyUnit_FolderScale_StructTimed_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,'h',"s__SpotEffect_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,496,"s__FolderDefenderSpawnType_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,398,"s__FolderUnit_FolderPosition_StructTimed_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,378,"s__FolderUnit_StructVertexColor_GetKeyMacro_STATE_BLUE_KEY")call SaveStr(P,0,422,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_S_MODS_TABLE_KEY")call SaveStr(P,0,322,"s__FolderUnit_StructItems_GetKeyMacro_KEY_ARRAY_DETAIL")call SaveStr(P,0,407,"s__Unit_GetKeyMacro_HEAL_STAMINA_KEY_ARRAY")call SaveStr(P,0,330,"s__FolderUnit_FolderAttack_FolderSplash_StructTargetFlag_GetKeyMacro_KEY_ARRAY_DETAIL")call SaveStr(P,0,$F0,"s__TextTag_GetKeyMacro_PARENT_KEY")call SaveStr(P,0,421,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_R_MODS_TABLE_KEY")call SaveStr(P,0,562,"s__SpawnWave_GetKeyMacro_KEY")
call SaveStr(P,0,408,"s__FolderUnitModSet_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,'t',"s__FolderEventCombination_StructRemainingEventsAmount_GetKeyMacro_KEY_ARRAY_DETAIL")call SaveStr(P,0,$C,"s__FolderEventResponse_StructDynamic_GetKeyMacro_LOCAL_KEY")call SaveStr(P,0,524,"s__HeroSelection_GetKeyMacro_KEY")
call SaveStr(P,0,284,"s__FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_GetKeyMacro_CASTER_KEY_ARRAY")call SaveStr(P,0,392,"s__FolderUnit_FolderAnimation_StructLoop_GetKeyMacro_KEY")
call SaveStr(P,0,94,"s__Dialog_GetKeyMacro_PLAYER_SHOWN_KEY_ARRAY")call SaveStr(P,0,292,"s__FolderUnit_FolderBuffs_FolderTimed_StructCountdown_GetKeyMacro_KEY")call SaveStr(P,0,$C1,"s__FolderDummyUnit_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,516,"s__Explosive_GetKeyMacro_KEY")
call SaveStr(P,0,396,"s__FolderUnit_FolderPosition_FolderTimed_StructAccelerated_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$D7,"s__SoundType_GetKeyMacro_INIT_KEY_ARRAY")call SaveStr(P,0,372,"s__FolderUnit_StructVertexColor_GetKeyMacro_ALPHA_KEY_ARRAY_DETAIL")call SaveStr(P,0,$E7,"s__Spell_GetKeyMacro_Range_KEY_ARRAY_DETAIL")call SaveStr(P,0,290,"s__FolderUnit_StructAbilities_GetKeyMacro_LEVEL_KEY_ARRAY_DETAIL")
call SaveStr(P,0,552,"s__SpawnGroup_GetKeyMacro_TYPES_KEY_ARRAY")call SaveStr(P,0,414,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_KEY_ARRAY_DETAIL_VAL")call SaveStr(P,0,44,"s__FolderBuff_StructLoopSounds_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,310,"s__FolderUnit_StructBuffs_GetKeyMacro_LEVELS_KEY_ARRAY_DETAIL")call SaveStr(P,0,76,"s__FolderDialog_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,444,"s__PlayerController_GetKeyMacro_KEY")call SaveStr(P,0,26,"s__FolderVoteHost_StructVotes_GetKeyMacro_PLAYER_BUTTON_KEY")call SaveStr(P,0,$AE,"s__FolderLightning_StructFromSpotToDummyUnit_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$7E,"s__FolderEventCombination_StructPeriodic_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,40,"s__FolderBuff_StructTargetEffects_GetKeyMacro_LEVELS_KEY_ARRAY")call SaveStr(P,0,402,"s__Unit_GetKeyMacro_KEY")call SaveStr(P,0,446,"s__PlayerController_GetKeyMacro_PARENT_KEY")call SaveStr(P,0,306,"s__FolderUnit_StructBuffs_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$D1,"s__FolderOrder_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,623,"s__FountainHeal_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,403,"s__Unit_GetKeyMacro_SPELL_TEXT_TAG_KEY_ARRAY")
call SaveStr(P,0,338,"s__FolderUnit_FolderDecay_StructTimed_GetKeyMacro_KEY")call SaveStr(P,0,$BE,"s__AICastSpell_GetKeyMacro_SPELL_KEY")
call SaveStr(P,0,$82,"s__Ping_GetKeyMacro_KEY")call SaveStr(P,0,438,"s__FolderUnitType_StructDrop_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,442,"s__UnitType_GetKeyMacro_INIT_KEY_ARRAY")call SaveStr(P,0,$96,"s__FolderItemType_StructAbilities_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,258,"s__Trigger_GetKeyMacro_INIT_NORMAL_KEY_ARRAY")
call SaveStr(P,0,568,"s__FolderSpawnType_StructItems_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$88,"s__FolderItemClass_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,587,"s__FolderBarrier_StructKnockback_GetKeyMacro_KEY")
call SaveStr(P,0,$84,"s__FolderUnitList_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$86,"s__UnitList_GetKeyMacro_MEMBERS_KEY_ARRAY")call SaveStr(P,0,$DE,"s__Spell_GetKeyMacro_COOLDOWN_KEY_ARRAY_DETAIL")call SaveStr(P,0,'v',"s__FolderEventCombination_StructEvents_GetKeyMacro_KEY")call SaveStr(P,0,$D8,"s__HeroSpell_GetKeyMacro_BASE_SPELL_KEY")call SaveStr(P,0,268,"s__UnitTypePool_GetKeyMacro_WEIGHT_KEY_ARRAY_DETAIL")call SaveStr(P,0,278,"s__FolderUnit_FolderAbilities_StructCooldown_GetKeyMacro_KEY")
call SaveStr(P,0,536,"s__Level_GetKeyMacro_PARENT_KEY")call SaveStr(P,0,$C6,"s__FolderDummyUnit_FolderScale_StructTimed_GetKeyMacro_KEY")call SaveStr(P,0,$92,"s__Item_GetKeyMacro_KEY")call SaveStr(P,0,431,"s__FolderUnitType_StructAttachments_GetKeyMacro_LEVEL_KEY_ARRAY")call SaveStr(P,0,470,"s__FolderUser_FolderKeyEvent_StructUpArrow_GetKeyMacro_KEY")call SaveStr(P,0,260,"s__Trigger_GetKeyMacro_INIT_NATIVE_KEY_ARRAY")
call SaveStr(P,0,'j',"s__FolderUnitEffect_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,488,"s__CreepLocation_GetKeyMacro_KEY")
call SaveStr(P,0,16,"s__Event_GetKeyMacro_KEY")call SaveStr(P,0,324,"s__FolderUnit_StructItems_GetKeyMacro_SLOT_KEY_ARRAY_DETAIL")call SaveStr(P,0,405,"s__Unit_GetKeyMacro_BURN_MANA_KEY_ARRAY")call SaveStr(P,0,$A0,"s__LightningType_GetKeyMacro_INIT_KEY_ARRAY")call SaveStr(P,0,270,"s__FolderUnit_StructId_GetKeyMacro_KEY")call SaveStr(P,0,$DD,"s__Spell_GetKeyMacro_CHANNEL_TIME_KEY_ARRAY_DETAIL")call SaveStr(P,0,56,"s__Buff_GetKeyMacro_KEY")call SaveStr(P,0,419,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_B_MODS_TABLE_KEY")call SaveStr(P,0,619,"s__FolderSummonPolarBear_StructSummon_GetKeyMacro_KEY")call SaveStr(P,0,'x',"s__FolderEventCombination_StructEvents_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$DB,"s__FolderSpell_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,328,"s__FolderUnit_FolderAttack_FolderEvents_StructGround_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,603,"s__FolderHandOfNature_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$CB,"s__FolderMissileCheckpoint_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$D5,"s__FolderRegion_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,548,"s__SpawnGroup_GetKeyMacro_LOCATIONS_KEY_ARRAY")call SaveStr(P,0,'l',"s__FolderUnitEffect_StructDestroyTimed_GetKeyMacro_KEY")call SaveStr(P,0,42,"s__FolderBuff_StructTargetEffects_GetKeyMacro_PATHS_KEY_ARRAY")
call SaveStr(P,0,576,"s__Zoom_GetKeyMacro_KEY")call SaveStr(P,0,476,"s__User_GetKeyMacro_KEY")call SaveStr(P,0,286,"s__FolderUnit_FolderAbilities_FolderEvents_StructEffect_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,597,"s__DeprivingShock_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,490,"s__FolderCreepSet_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,500,"s__FolderDefenderSpawnGroup_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,340,"s__FolderUnit_StructDrop_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,'p',"s__EventPair_GetKeyMacro_PARTNER_KEY")
call SaveStr(P,0,538,"s__Lumber_GetKeyMacro_KEY")call SaveStr(P,0,$B2,"s__FolderLightning_StructFromSpotToUnit_GetKeyMacro_KEY")call SaveStr(P,0,344,"s__FolderUnit_FolderDamage_StructEvents_GetKeyMacro_TEXT_TAG_KEY_ARRAY")call SaveStr(P,0,$E2,"s__Spell_GetKeyMacro_AreaRange_KEY_ARRAY_DETAIL")call SaveStr(P,0,348,"s__FolderUnit_StructMagicImmunity_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,605,"s__HandOfNature_GetKeyMacro_KEY")call SaveStr(P,0,366,"s__FolderUnit_StructVertexColor_GetKeyMacro_RED_KEY_ARRAY_DETAIL")
call SaveStr(P,0,$DA,"s__HeroSpell_GetKeyMacro_KEY_ARRAY_DETAIL")call SaveStr(P,0,$D0,"s__Multiboard_GetKeyMacro_ITEMS_KEY_ARRAY")call SaveStr(P,0,$B,"s__InitAbilityStruct_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,320,"s__FolderUnit_FolderItems_FolderEvents_StructMoveInInventory_GetKeyMacro_KEY")
call SaveStr(P,0,$FE,"s__Trigger_GetKeyMacro_KEY")call SaveStr(P,0,384,"s__FolderUnit_FolderMovement_FolderEvents_StructInterval_GetKeyMacro_KEY_ARRAY_DETAIL")call SaveStr(P,0,410,"s__FolderUnitModSet_StructBoolMods_GetKeyMacro_KEY_ARRAY_DETAIL_VAL")call SaveStr(P,0,280,"s__FolderUnit_FolderAbilities_StructCooldown_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,62,"s__FolderDestructableType_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,302,"s__FolderUnit_FolderBuffs_StructTimed_GetKeyMacro_KEY_ARRAY_DETAIL")call SaveStr(P,0,294,"s__FolderUnit_FolderBuffs_FolderTimed_StructCountdown_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,82,"s__FolderDialog_StructButtons_GetKeyMacro_KEY_ARRAY_DETAIL")call SaveStr(P,0,570,"s__SpawnType_GetKeyMacro_KEY")
call SaveStr(P,0,560,"s__FolderSpawnWave_StructGroups_GetKeyMacro_TIMER_KEY_ARRAY_DETAIL")call SaveStr(P,0,90,"s__Dialog_GetKeyMacro_PLAYER_CUR_SHOWN_KEY_ARRAY")call SaveStr(P,0,416,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_I_MODS_VAL_KEY")call SaveStr(P,0,$C0,"s__AILetOff_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$A2,"s__FolderLightning_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,28,"s__memtableteststruct_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$EE,"s__FolderUbersplat_FolderColor_StructTimed_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,512,"s__Drop_GetKeyMacro_TAG_KEY_ARRAY")call SaveStr(P,0,276,"s__FolderUnit_FolderEvent_StructCounted_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,$EC,"s__FolderUbersplat_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,621,"s__Lariat_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,300,"s__FolderUnit_FolderBuffs_StructTimed_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,582,"s__FolderCleaver_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,615,"s__FolderPandaPaw_FolderArrival_StructTarget_GetKeyMacro_KEY_ARRAY_DETAIL")call SaveStr(P,0,613,"s__FolderPandaPaw_FolderArrival_StructTarget_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,611,"s__FolderInfection_StructSummon_GetKeyMacro_KEY")call SaveStr(P,0,609,"s__FolderInfection_FolderSummon_StructFuniculusUmbilicalis_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,607,"s__HandOfNature_GetKeyMacro_SUMMONS_KEY_ARRAY")call SaveStr(P,0,601,"s__FairyShape_GetKeyMacro_KEY_ARRAY_DETAIL")call SaveStr(P,0,530,"s__FolderLevelSet_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,388,"s__FolderUnit_FolderMovement_StructEvents_GetKeyMacro_KEY_ARRAY_DETAIL")call SaveStr(P,0,590,"s__GhostSword_GetKeyMacro_SWORDS_KEY_ARRAY")call SaveStr(P,0,20,"s__Event_GetKeyMacro_STATICS_PARENT_KEY")call SaveStr(P,0,572,"s__Tomes_GetKeyMacro_KEY")
call SaveStr(P,0,80,"s__FolderDialog_StructButtons_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$CD,"s__FolderMissile_StructDummyUnit_GetKeyMacro_KEY")
call SaveStr(P,0,534,"s__FolderLevel_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$90,"s__FolderItem_StructAbilities_GetKeyMacro_KEY_ARRAY_DETAIL")call SaveStr(P,0,332,"s__FolderUnit_FolderAttack_StructSplash_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,326,"s__FolderUnit_FolderAttack_FolderEvents_StructGround_GetKeyMacro_KEY")
call SaveStr(P,0,435,"s__FolderUnitType_FolderAttack_StructSplash_GetKeyMacro_DAMAGE_KEY_ARRAY")
call SaveStr(P,0,$CF,"s__MultiboardItem_GetKeyMacro_KEY")call SaveStr(P,0,$F4,"s__TriggerTimer_GetKeyMacro_KEY")call SaveStr(P,0,$F2,"s__FolderTriggerTimer_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,362,"s__FolderUnit_StructVertexColor_GetKeyMacro_KEY")call SaveStr(P,0,591,"s__FolderVividMeteor_StructEffects_GetKeyMacro_DUMMY_UNITS_KEY_ARRAY")
call SaveStr(P,0,404,"s__Unit_GetKeyMacro_HEAL_KEY_ARRAY")call SaveStr(P,0,589,"s__Fireburst_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,58,"s__Buff_GetKeyMacro_INIT_KEY_ARRAY")call SaveStr(P,0,586,"s__Artifact_GetKeyMacro_KEY")call SaveStr(P,0,440,"s__UnitType_GetKeyMacro_KEY")call SaveStr(P,0,584,"s__Realplex_GetKeyMacro_KEY")call SaveStr(P,0,$A8,"s__FolderLightning_StructFromDummyUnitToUnit_GetKeyMacro_KEY")
call SaveStr(P,0,$B6,"s__FolderLightning_StructFromUnitToUnit_GetKeyMacro_KEY")call SaveStr(P,0,$CE,"s__FolderMissile_StructGoToUnit_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,460,"s__FolderUser_FolderKeyEvent_StructDownArrow_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$B8,"s__FolderLightning_StructFromUnitToUnit_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,581,"s__FuzzyAttack_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,70,"s__FolderDestructable_StructTimedLife_GetKeyMacro_KEY")
call SaveStr(P,0,$9A,"s__FolderItemType_StructClasses_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,54,"s__FolderBuff_StructUnitModSets_GetKeyMacro_KEY_ARRAY_DETAIL")call SaveStr(P,0,580,"s__ChaosBall_GetKeyMacro_KEY")
call SaveStr(P,0,430,"s__FolderUnitType_StructAttachments_GetKeyMacro_ATTACH_POINT_KEY_ARRAY")call SaveStr(P,0,579,"s__Aura_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,409,"s__FolderUnitModSet_StructBoolMods_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$CC,"s__FolderMissile_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,30,"s__AIAutoCast_GetKeyMacro_KEY")
call SaveStr(P,0,304,"s__FolderUnit_StructBuffs_GetKeyMacro_EFFECTS_KEY")call SaveStr(P,0,574,"s__Waypoint_GetKeyMacro_KEY")call SaveStr(P,0,566,"s__FolderSpawnType_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,564,"s__FolderSpawn_StructShadow_GetKeyMacro_KEY")call SaveStr(P,0,$CA,"s__DummyUnit_GetKeyMacro_KEY")
call SaveStr(P,0,558,"s__FolderSpawnWave_StructGroups_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,556,"s__FolderSpawnWave_StructGroups_GetKeyMacro_DELAY_KEY_ARRAY_DETAIL")call SaveStr(P,0,554,"s__FolderSpawnWave_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$E,"s__FolderEvent_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,'|',"s__FolderEventCombination_FolderPeriodic_StructSubjectsA_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,428,"s__FolderUnitType_FolderAbilities_StructArrayBuild_GetKeyMacro_LEVEL_KEY_ARRAY_DETAIL")call SaveStr(P,0,546,"s__FolderSpawnGroup_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,92,"s__Dialog_GetKeyMacro_PLAYER_SHOWN_KEY")call SaveStr(P,0,542,"s__TeleportScroll_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,540,"s__Meat_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$8C,"s__FolderItem_StructClasses_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,595,"s__Cyclone_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,468,"s__FolderUser_FolderKeyEvent_StructRightArrow_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,532,"s__FolderLevelSet_StructLevels_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,528,"s__FolderInfoboard_StructUser_GetKeyMacro_KEY")call SaveStr(P,0,$9E,"s__ItemType_GetKeyMacro_INIT_KEY_ARRAY")call SaveStr(P,0,425,"s__BuffRef_GetKeyMacro_KEY")call SaveStr(P,0,399,"s__FolderUnit_FolderSelection_StructCircle_GetKeyMacro_KEY")call SaveStr(P,0,522,"s__HeroRevival_GetKeyMacro_KEY")call SaveStr(P,0,520,"s__GoldCoin_GetKeyMacro_AMOUNT_KEY")call SaveStr(P,0,390,"s__FolderUnit_FolderOrder_FolderEvents_StructIdle_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,354,"s__FolderUnit_FolderScale_StructTimed_GetKeyMacro_STATE_SCALE_KEY")call SaveStr(P,0,$8A,"s__FolderItem_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,494,"s__CreepSet_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$ED,"s__FolderUbersplat_FolderColor_StructTimed_GetKeyMacro_KEY")call SaveStr(P,0,514,"s__Drop_GetKeyMacro_HEAL_TAG_KEY_ARRAY")call SaveStr(P,0,510,"s__Difficulty_GetKeyMacro_KEY")call SaveStr(P,0,462,"s__FolderUser_FolderKeyEvent_StructLeftArrow_GetKeyMacro_KEY")
call SaveStr(P,0,550,"s__SpawnGroup_GetKeyMacro_TYPE_AMOUNT_KEY_ARRAY_DETAIL")call SaveStr(P,0,$C8,"s__FolderDummyUnit_FolderVertexColor_StructTimed_GetKeyMacro_KEY")
call SaveStr(P,0,'f',"s__FolderSpotEffect_StructDestroyTimed_GetKeyMacro_KEY")call SaveStr(P,0,$A4,"s__FolderLightning_FolderColor_StructTimed_GetKeyMacro_KEY")call SaveStr(P,0,448,"s__PlayerSlotState_GetKeyMacro_KEY")call SaveStr(P,0,498,"s__DefenderSpawnType_GetKeyMacro_KEY")
call SaveStr(P,0,492,"s__CreepSet_GetKeyMacro_CREEP_KEY_ARRAY")call SaveStr(P,0,66,"s__DestructableType_GetKeyMacro_INIT_KEY_ARRAY")call SaveStr(P,0,346,"s__FolderUnit_FolderMagicImmunity_StructSpellShield_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,46,"s__FolderBuff_StructVariants_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,482,"s__Initialization_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,358,"s__FolderUnit_FolderVertexColor_StructTimed_GetKeyMacro_KEY")call SaveStr(P,0,450,"s__PlayerSlotState_GetKeyMacro_PARENT_KEY")call SaveStr(P,0,52,"s__FolderBuff_StructUnitMods_GetKeyMacro_KEY_ARRAY_DETAIL_VAL")
call SaveStr(P,0,478,"s__WeatherType_GetKeyMacro_INIT_KEY_ARRAY")call SaveStr(P,0,$E4,"s__Spell_GetKeyMacro_ChannelTime_KEY_ARRAY_DETAIL")call SaveStr(P,0,474,"s__FolderUser_StructSlotState_GetKeyMacro_PLAYING_HUMANS_KEY")
call SaveStr(P,0,472,"s__FolderUser_FolderKeyEvent_StructUpArrow_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$94,"s__FolderItemType_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,'z',"s__FolderEventCombination_StructSubjects_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,456,"s__FolderUser_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,464,"s__FolderUser_FolderKeyEvent_StructLeftArrow_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$E1,"s__Spell_GetKeyMacro_RANGE_KEY_ARRAY_DETAIL")call SaveStr(P,0,508,"s__DefenderSpawnWave_GetKeyMacro_KEY")
call SaveStr(P,0,458,"s__FolderUser_FolderKeyEvent_StructDownArrow_GetKeyMacro_KEY")
call SaveStr(P,0,$98,"s__FolderItemType_StructAbilities_GetKeyMacro_KEY_ARRAY_DETAIL")call SaveStr(P,0,88,"s__Dialog_GetKeyMacro_PLAYER_CUR_SHOWN_KEY")call SaveStr(P,0,466,"s__FolderUser_FolderKeyEvent_StructRightArrow_GetKeyMacro_KEY")call SaveStr(P,0,454,"s__Team_GetKeyMacro_PARENT_KEY_ARRAY")
call SaveStr(P,0,452,"s__Team_GetKeyMacro_MEMBERS_KEY_ARRAY")call SaveStr(P,0,585,"s__SpiritWolves_GetKeyMacro_KEY")call SaveStr(P,0,593,"s__WarmthMagnetism_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,$FA,"s__FolderTrigger_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,72,"s__Destructable_GetKeyMacro_KEY")call SaveStr(P,0,$BA,"s__FolderLightning_StructDestroyTimed_GetKeyMacro_KEY")call SaveStr(P,0,312,"s__FolderUnit_StructBuffs_GetKeyMacro_LOOP_SOUNDS_KEY")call SaveStr(P,0,434,"s__FolderUnitType_FolderAttack_StructSplash_GetKeyMacro_AREA_RANGE_KEY_ARRAY")
call SaveStr(P,0,433,"s__FolderUnitType_FolderAttack_FolderSplash_StructTargetFlag_GetKeyMacro_KEY_ARRAY_DETAIL")call SaveStr(P,0,386,"s__FolderUnit_FolderMovement_StructEvents_GetKeyMacro_KEY")call SaveStr(P,0,583,"s__FolderCleaver_StructWave_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$AC,"s__FolderLightning_StructFromSpotToDummyUnit_GetKeyMacro_KEY")
call SaveStr(P,0,314,"s__FolderUnit_StructBuffs_GetKeyMacro_LOCAL_REFS_KEY")
call SaveStr(P,0,282,"s__FolderUnit_FolderAbilities_StructCooldown_GetKeyMacro_KEY_ARRAY_DETAIL")call SaveStr(P,0,18,"s__Event_GetKeyMacro_STATICS_KEY")call SaveStr(P,0,$D3,"s__Code_GetKeyMacro_SELF_TRIGGER_KEY")
call SaveStr(P,0,274,"s__FolderUnit_FolderEvent_StructCounted_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,429,"s__FolderUnitType_FolderAbilities_StructHero_GetKeyMacro_KEY_ARRAY_DETAIL")call SaveStr(P,0,50,"s__FolderBuff_StructUnitMods_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$D9,"s__HeroSpell_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,60,"s__FolderCameraField_StructTimed_GetKeyMacro_KEY_ARRAY_DETAIL")
call SaveStr(P,0,'d',"s__FolderSpotEffect_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,68,"s__FolderDestructable_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,34,"s__BoolExpr_GetKeyMacro_KEY")call SaveStr(P,0,412,"s__FolderUnitModSet_StructRealMods_GetKeyMacro_KEY_ARRAY_DETAIL_VAL")call SaveStr(P,0,389,"s__FolderUnit_FolderOrder_FolderEvents_FolderGain_StructImmediate_GetKeyMacro_CANCEL_ITEM_USAGE_KEY_ARRAY")call SaveStr(P,0,84,"s__FolderDialog_StructButtons_GetKeyMacro_PARENT_KEY_ARRAY")call SaveStr(P,0,599,"s__Doppelganger_GetKeyMacro_KEY")call SaveStr(P,0,427,"s__FolderUnitType_FolderAbilities_StructArrayBuild_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,426,"s__FolderUnitType_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,415,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_B_MODS_VAL_KEY")call SaveStr(P,0,$EB,"s__UbersplatType_GetKeyMacro_INIT_KEY_ARRAY")call SaveStr(P,0,$9C,"s__ItemType_GetKeyMacro_KEY")call SaveStr(P,0,86,"s__Dialog_GetKeyMacro_KEY")
call SaveStr(P,0,$E6,"s__Spell_GetKeyMacro_ManaCost_KEY_ARRAY_DETAIL")call SaveStr(P,0,$C3,"s__FolderDummyUnit_StructDestruction_GetKeyMacro_KEY")
call SaveStr(P,0,$BC,"s__AICastSpell_GetKeyMacro_KEY")call SaveStr(P,0,420,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_I_MODS_TABLE_KEY")call SaveStr(P,0,$E3,"s__Spell_GetKeyMacro_CastTime_KEY_ARRAY_DETAIL")call SaveStr(P,0,256,"s__Trigger_GetKeyMacro_INIT_PARENT_KEY_ARRAY")
call SaveStr(P,0,$A6,"s__FolderLightning_FolderColor_StructTimed_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,418,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_S_MODS_VAL_KEY")call SaveStr(P,0,64,"s__DestructableType_GetKeyMacro_KEY")call SaveStr(P,0,$E0,"s__Spell_GetKeyMacro_MANA_COST_KEY_ARRAY_DETAIL")call SaveStr(P,0,336,"s__FolderUnit_FolderDeath_StructProtection_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,417,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_R_MODS_VAL_KEY")call SaveStr(P,0,544,"s__Rune_GetKeyMacro_KEY")call SaveStr(P,0,$8E,"s__FolderItem_StructAbilities_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$EA,"s__TileType_GetKeyMacro_INIT_KEY_ARRAY")call SaveStr(P,0,288,"s__FolderUnit_StructAbilities_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,262,"s__FolderUnitClass_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$D6,"s__Region_GetKeyMacro_KEY")call SaveStr(P,0,411,"s__FolderUnitModSet_StructRealMods_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,266,"s__UnitTypePool_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$D4,"s__FolderRectangle_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,36,"s__FolderBuff_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,502,"s__DefenderSpawnGroup_GetKeyMacro_TYPES_KEY_ARRAY")call SaveStr(P,0,413,"s__FolderUnitModSet_StructCustomMods_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,588,"s__ElementalSpellToHero_GetKeyMacro_KEY")call SaveStr(P,0,356,"s__FolderUnit_FolderScale_StructTimed_GetKeyMacro_STATE_DURATION_KEY")
call SaveStr(P,0,$C4,"s__FolderDummyUnit_StructFollowDummyUnit_GetKeyMacro_KEY")
call SaveStr(P,0,298,"s__FolderUnit_FolderBuffs_StructTimed_GetKeyMacro_KEY")call SaveStr(P,0,78,"s__FolderDialog_StructButtons_GetKeyMacro_KEY")
call SaveStr(P,0,578,"s__FolderAura_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,406,"s__Unit_GetKeyMacro_HEAL_MANA_KEY_ARRAY")call SaveStr(P,0,391,"s__FolderUnit_FolderStun_StructCancel_GetKeyMacro_KEY")call SaveStr(P,0,401,"s__FolderUnit_StructSelection_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,48,"s__FolderBuff_StructVariants_GetKeyMacro_PARENT_KEY_ARRAY")
call SaveStr(P,0,526,"s__HeroSelection_GetKeyMacro_SOUNDS_KEY_ARRAY")call SaveStr(P,0,382,"s__FolderUnit_FolderMovement_FolderEvents_StructInterval_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,'n',"s__UnitEffect_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,394,"s__FolderUnit_FolderStamina_StructExhaustion_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,296,"s__FolderUnit_FolderBuffs_FolderTimed_StructCountdown_GetKeyMacro_KEY_ARRAY_DETAIL")call SaveStr(P,0,264,"s__FolderUnitTypePool_StructId_GetKeyMacro_KEY_ARRAY")
call SaveStr(P,0,395,"s__FolderUnit_FolderPosition_FolderTimed_StructAccelerated_GetKeyMacro_KEY")call SaveStr(P,0,272,"s__FolderUnit_StructId_GetKeyMacro_PARENT_KEY_ARRAY")call SaveStr(P,0,480,"s__Initialization_GetKeyMacro_KEY")call SaveStr(P,0,$D2,"s__Order_GetKeyMacro_KEY")
call SaveStr(P,0,518,"s__SpearOfTheDefender_GetKeyMacro_KEY")call SaveStr(P,0,38,"s__FolderBuff_StructTargetEffects_GetKeyMacro_ATTACH_POINTS_KEY_ARRAY")
call SaveStr(P,0,393,"s__FolderUnit_StructSpellVamp_GetKeyMacro_TEXT_TAG_KEY_ARRAY")
call SaveStr(P,0,$E5,"s__Spell_GetKeyMacro_Cooldown_KEY_ARRAY_DETAIL")call SaveStr(P,0,397,"s__FolderUnit_FolderPosition_StructTimed_GetKeyMacro_KEY")
call SaveStr(P,0,$F6,"s__FolderTimer_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,374,"s__FolderUnit_StructVertexColor_GetKeyMacro_STATE_RED_KEY")call SaveStr(P,0,370,"s__FolderUnit_StructVertexColor_GetKeyMacro_BLUE_KEY_ARRAY_DETAIL")call SaveStr(P,0,$AA,"s__FolderLightning_StructFromDummyUnitToUnit_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,368,"s__FolderUnit_StructVertexColor_GetKeyMacro_GREEN_KEY_ARRAY_DETAIL")call SaveStr(P,0,484,"s__FolderAct_StructId_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$B0,"s__FolderLightning_StructFromSpotToSpot_GetKeyMacro_KEY")call SaveStr(P,0,316,"s__FolderUnit_StructBuffs_GetKeyMacro_VARIANT_REFS_KEY")call SaveStr(P,0,360,"s__FolderUnit_FolderVertexColor_StructTimed_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,$80,"s__FolderEventCombination_StructPairs_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,352,"s__FolderUnit_FolderScale_StructTimed_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,506,"s__FolderDefenderSpawnWave_StructGroups_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,350,"s__FolderUnit_FolderScale_StructTimed_GetKeyMacro_KEY")call SaveStr(P,0,486,"s__FolderAct_StructLevelSets_GetKeyMacro_KEY_ARRAY")call SaveStr(P,0,432,"s__FolderUnitType_StructAttachments_GetKeyMacro_PATH_KEY_ARRAY")call SaveStr(P,0,617,"s__FolderRazorBladeDrawBack_StructBlade_GetKeyMacro_CHECKPOINT_BOLT_KEY")call SaveStr(P,0,308,"s__FolderUnit_StructBuffs_GetKeyMacro_KEY_ARRAY_DETAIL")call SaveStr(P,0,$C2,"s__FolderDummyUnit_StructDestroyTimed_GetKeyMacro_KEY")call SaveStr(P,0,22,"s__CommandHeader_GetKeyMacro_KEY")call SaveStr(P,0,$B4,"s__FolderLightning_StructFromSpotToUnit_GetKeyMacro_KEY_ARRAY")return trueendfunctionfunction VXx takes string rSx returns integerlocal integer oLxset gE=gE+1set oLx=GE+1
set GE=oLxset BE[oLx]=0set hE[oLx]=rSxif(AE==F)thenset AE=oLxset cE[0]=oLxelse
set NE[DE]=oLxendifset NE[oLx]=Fset dE[oLx]=DEset DE=oLxset CE[0]=oLxreturn oLxendfunctionfunction VOx takes nothing returns booleanset FE=VXx(HE)return trueendfunctionfunction VRx takes nothing returns booleanset si=VXx(mi)return trueendfunctionfunction VIx takes nothing returns booleanset jE=VXx(JE)return trueendfunctionfunction VAx takes nothing returns booleanset kE=VXx(KE)return trueendfunctionfunction VNx takes integer a9x,code c,string rSx returns nothing
local trigger t=CreateTrigger()local integer rvxcall TriggerAddCondition(t,Condition(c))
if(li==null)then
set li=InitHashtable()set zi=InitHashtable()set lE=InitHashtable()set Zi=InitHashtable()endifset rvx=LoadInteger(li,a9x,0)+1call SaveInteger(li,a9x,0,rvx)call SaveTriggerHandle(li,a9x,rvx,t)
call SaveStr(Zi,a9x,rvx,rSx)
call SaveInteger(zi,a9x,rvx,(GetHandleId(Condition((c)))))endfunctionfunction Vbx takes code c,string rSx returns nothing
call VNx(ha,c,rSx)endfunctionfunction VBx takes integer oSx returns integerset QE[oSx]=true
set sE[oSx]=falsecall rEx(SE)
return oSxendfunctionfunction Vcx takes nothing returns integerlocal integer oSxif(mE==8190)then
call o_x("LightningType_Allocation_allocCustom","call DebugEx(LightningType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",ME+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(pE[(w)]==w)thenset PE=PE+1set oSx=PEelse
set oSx=pE[(w)]set pE[(w)]=pE[pE[(w)]]endifset pE[oSx]=Zset qE[oSx]=1call VBx(oSx)return oSxendfunctionfunction VCx takes string oqx returns integerlocal integer oSx=Vcx()set tE[(oSx)]=(oqx)return oSxendfunctionfunction Vdx takes nothing returns booleanset LE=VCx("OTes")return trueendfunctionfunction VDx takes nothing returns booleancall Vbx(function Vdx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Math.page\\Math.struct\\Shapes\\obj_testBolt_wc3bolt.j")
return trueendfunctionfunction Vfx takes nothing returns booleanset TE=VXx(uE)return trueendfunctionfunction VFx takes code c,string rSx returns nothing
set Pr=Pr+1set ei[Pr]=CreateTrigger()set xi[Pr]=(GetHandleId(Condition((c))))
set oi[Pr]=rSxcall TriggerAddCondition(ei[Pr],Condition(c))endfunctionfunction Vgx takes real a,real b returns integer
local integer o7xif(a==0)then
return 0
endifset o7x=0loop
exitwhen(Pow(b,o7x*1./ 10.)>=a)set o7x=o7x+$Aendlooploop
exitwhen(Pow(b,o7x*1./ 10.)<=a)set o7x=o7x-1endloopreturn(o7x/ $A)endfunctionfunction VGx takes nothing returns nothinglocal integer oMx=wE
loop
exitwhen(oMx<0)set YE[oMx]=(Vgx((oMx),(2)))
set oMx=oMx-1set yE=yE+1exitwhen(yE>500)
endloopif(oMx>F)thenset wE=oMxset yE=0
call akx(function VGx)endifendfunctionfunction Vhx takes nothing returns nothingset Le[0]="0"set Le[1]="1"set Le[2]="2"set Le[3]="3"set Le[4]="4"set Le[5]="5"set Le[6]="6"set Le[7]="7"set Le[8]="8"set Le[9]="9"set Le[$A]="A"set Le[$B]="B"set Le[$C]="C"set Le[$D]="D"set Le[$E]="E"set Le[$F]="F"endfunctionfunction VHx takes nothing returns booleanlocal integer oMx=20
loop
exitwhen(oMx<0)set UE[oMx]=(R2I((((Pow((((2))*1.),(((oMx))*1.))))*1.)))
set oMx=oMx-1endloopset wE=WEset yE=0
call akx(function VGx)call Vhx()return trueendfunctionfunction Vjx takes nothing returns booleancall VFx(function VHx,"Math_Init")return trueendfunctionfunction VJx takes nothing returns booleanset zE=VXx(ZE)return trueendfunctionfunction Vkx takes nothing returns booleanset vX=VXx(eX)return trueendfunctionfunction VKx takes nothing returns booleanset xX=VXx(oX)return trueendfunctionfunction Vlx takes nothing returns booleanset rX=VXx(iX)return trueendfunctionfunction VLx takes nothing returns booleanset aX=VXx(nX)return trueendfunctionfunction Vmx takes nothing returns booleanset VX=VXx(EX)return trueendfunctionfunction VMx takes nothing returns booleanset XX=VXx(OX)return trueendfunctionfunction Vpx takes nothing returns booleanset RX=VXx(IX)return trueendfunctionfunction VPx takes nothing returns booleanset AX=VXx(NX)return trueendfunctionfunction Vqx takes nothing returns booleanset bX=VXx(BX)return trueendfunctionfunction VQx takes nothing returns booleanset cX=VXx(CX)return trueendfunctionfunction Vsx takes nothing returns booleanset DX=VXx(fX)return trueendfunctionfunction VSx takes nothing returns booleanset FX=VXx(gX)return trueendfunctionfunction Vtx takes nothing returns booleanset GX=VXx(hX)return trueendfunctionfunction VTx takes nothing returns booleanset HX=VXx(jX)return trueendfunctionfunction Vux takes nothing returns booleanset JX=VXx(kX)return trueendfunctionfunction VUx takes nothing returns booleanset KX=VXx(M)return trueendfunctionfunction Vwx takes nothing returns booleanset lX=VXx(LX)return trueendfunctionfunction VWx takes nothing returns booleanset mX=VXx(MX)return trueendfunctionfunction Vyx takes nothing returns booleanset pX=VXx(PX)return trueendfunctionfunction VYx takes nothing returns booleanset qX=VXx(QX)return trueendfunctionfunction Vzx takes nothing returns booleanset sX=VXx(SX)return trueendfunctionfunction VZx takes nothing returns nothingendfunctionfunction V_x takes integer oSx returns integerset WX[oSx]=true
set yX[oSx]=falsecall rEx(sX)
return oSxendfunctionfunction V0x takes nothing returns integerlocal integer oSxif(TX==8190)then
call o_x("DataTable_Allocation_allocCustom","call DebugEx(DataTable.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",SX+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(uX[(w)]==w)thenset UX=UX+1set oSx=UXelse
set oSx=uX[(w)]set uX[(w)]=uX[uX[(w)]]endifset uX[oSx]=Zset wX[oSx]=1call V_x(oSx)return oSxendfunctionfunction V1x takes integer oSx returns integerset eO[oSx]=true
set xO[oSx]=falsecall rEx(GX)
return oSxendfunctionfunction V2x takes nothing returns integerlocal integer oSxif(YX==8190)then
call o_x("DataTableHead_Allocation_allocCustom","call DebugEx(DataTableHead.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",hX+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(zX[(w)]==w)thenset ZX=ZX+1set oSx=ZXelse
set oSx=zX[(w)]set zX[(w)]=zX[zX[(w)]]endifset zX[oSx]=Zset vO[oSx]=1call V1x(oSx)return oSxendfunctionfunction V3x takes integer oSx returns integerset nO[oSx]=true
set VO[oSx]=falsecall rEx(bX)
return oSxendfunctionfunction V4x takes nothing returns integerlocal integer oSxif(oO==8190)then
call o_x("HashTable_Allocation_allocCustom","call DebugEx(HashTable.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",BX+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(rO[(w)]==w)thenset iO=iO+1set oSx=iOelse
set oSx=rO[(w)]set rO[(w)]=rO[rO[(w)]]endifset rO[oSx]=Zset aO[oSx]=1call V3x(oSx)return oSxendfunctionfunction V5x takes nothing returns integerlocal integer oSx=V4x()set o[oSx]=InitHashtable()return oSxendfunctionfunction V6x takes integer oSx returns nothingset V[oSx]=V5x()
set EO[(oSx)]=V5x()endfunctionfunction V7x takes integer oSx returns integerset AO[oSx]=true
set NO[oSx]=falsecall rEx(aX)
return oSxendfunctionfunction V8x takes nothing returns integerlocal integer oSxif(XO==8190)then
call o_x("GameCache_Allocation_allocCustom","call DebugEx(GameCache.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",nX+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(OO[(w)]==w)thenset RO=RO+1set oSx=ROelse
set oSx=OO[(w)]set OO[(w)]=OO[OO[(w)]]endifset OO[oSx]=Zset IO[oSx]=1call V7x(oSx)return oSxendfunctionfunction V9x takes nothing returns integerlocal integer oSx=V8x()set Kv[oSx]=InitGameCache("bla")
return oSxendfunctionfunction Evx takes nothing returns integerlocal integer oSx=V2x()call V6x(oSx)set lv[(oSx)]=V9x()return oSxendfunctionfunction Eex takes integer oSx returns nothingset bO[oSx]=V5x()set BO[oSx]=V5x()set cO[oSx]=V5x()set CO[oSx]=V5x()set dO[oSx]=V5x()endfunctionfunction Exx takes integer oSx returns nothingset D[oSx]=V5x()
set DO[oSx]=V5x()endfunctionfunction Eox takes integer oSx returns nothingcall Eex((oSx))call Exx(oSx)endfunctionfunction Erx takes nothing returns integerlocal integer oSx=V0x()set E[oSx]=Evx()
call Eox(oSx)set fO[(oSx)]=InitHashtable()return oSxendfunctionfunction Eix takes nothing returns nothinglocal integer iset Ee=$A+Fset i=Ee
loop
exitwhen(i<0)set Ve[i]=Erx()set i=i-1endloopendfunctionfunction Eax takes nothing returns booleancall aKx("memory")call VZx()set tX=Erx()
set X=tX
call Eix()return trueendfunctionfunction Enx takes nothing returns booleancall VFx(function Eax,"DataTable_Init")return trueendfunctionfunction EVx takes nothing returns booleanset FO=VXx(gO)return trueendfunctionfunction EEx takes nothing returns booleanset GO=VXx(hO)return trueendfunctionfunction EXx takes nothing returns booleanset HO=VXx(jO)return trueendfunctionfunction EOx takes nothing returns booleanset JO[(0)*7+(0)]=((1.)*1.)set JO[(0)*7+(1)]=((1.35)*1.)set JO[(0)*7+(2)]=((1.)*1.)set JO[(0)*7+(3)]=((.7)*1.)set JO[(0)*7+(4)]=((1.)*1.)set JO[(0)*7+(5)]=((1.)*1.)set JO[(0)*7+(6)]=((1.)*1.)set JO[(1)*7+(0)]=((1.5)*1.)
set JO[(1)*7+(1)]=((.7)*1.)set JO[(1)*7+(2)]=((1.)*1.)set JO[(1)*7+(3)]=((.35)*1.)
set JO[(1)*7+(4)]=((.5)*1.)set JO[(1)*7+(5)]=((1.35)*1.)set JO[(1)*7+(6)]=((1.)*1.)set JO[(2)*7+(0)]=((1.)*1.)set JO[(2)*7+(1)]=((.65)*1.)
set JO[(2)*7+(2)]=((1.)*1.)set JO[(2)*7+(3)]=((1.5)*1.)
set JO[(2)*7+(4)]=((.35)*1.)
set JO[(2)*7+(5)]=((1.)*1.)set JO[(2)*7+(6)]=((1.)*1.)set JO[(3)*7+(0)]=((1.25)*1.)set JO[(3)*7+(1)]=((.75)*1.)
set JO[(3)*7+(2)]=((1.5)*1.)
set JO[(3)*7+(3)]=((.35)*1.)
set JO[(3)*7+(4)]=((.5)*1.)set JO[(3)*7+(5)]=((1.)*1.)set JO[(3)*7+(6)]=((1.)*1.)set JO[(4)*7+(0)]=((1.)*1.)set JO[(4)*7+(1)]=((1.)*1.)set JO[(4)*7+(2)]=((1.)*1.)set JO[(4)*7+(3)]=((1.)*1.)set JO[(4)*7+(4)]=((1.)*1.)set JO[(4)*7+(5)]=((1.)*1.)set JO[(4)*7+(6)]=((1.)*1.)set JO[(5)*7+(0)]=((1.)*1.)set JO[(5)*7+(1)]=((1.)*1.)set JO[(5)*7+(2)]=((1.)*1.)set JO[(5)*7+(3)]=((1.)*1.)set JO[(5)*7+(4)]=((1.)*1.)set JO[(5)*7+(5)]=((1.)*1.)set JO[(5)*7+(6)]=((1.)*1.)set JO[(6)*7+(0)]=((1.)*1.)set JO[(6)*7+(1)]=((1.)*1.)set JO[(6)*7+(2)]=((1.)*1.)set JO[(6)*7+(3)]=((.5)*1.)set JO[(6)*7+(4)]=((1.)*1.)set JO[(6)*7+(5)]=((1.)*1.)set JO[(6)*7+(6)]=((1.)*1.)return trueendfunctionfunction ERx takes nothing returns booleancall VFx(function EOx,"Attack_Init")
return trueendfunctionfunction EIx takes nothing returns booleanset kO=VXx(KO)return trueendfunctionfunction EAx takes nothing returns booleanset lO=VXx(LO)return trueendfunctionfunction ENx takes nothing returns booleanset mO=VXx(MO)return trueendfunctionfunction Ebx takes nothing returns booleanset pO=VXx(PO)return trueendfunctionfunction EBx takes nothing returns booleanset qO=VXx(QO)return trueendfunctionfunction Ecx takes nothing returns booleanset sO=VXx(SO)return trueendfunctionfunction ECx takes nothing returns booleanset tO=VXx(TO)return trueendfunctionfunction Edx takes nothing returns booleanset uO=VXx(UO)return trueendfunctionfunction EDx takes nothing returns booleanset wO=VXx(WO)return trueendfunctionfunction Efx takes nothing returns booleanset yO=VXx(YO)return trueendfunctionfunction EFx takes nothing returns booleanset zO=VXx(ZO)return trueendfunctionfunction Egx takes nothing returns booleanset vR=VXx(eR)return trueendfunctionfunction EGx takes nothing returns booleanset xR=VXx(oR)return trueendfunctionfunction Ehx takes nothing returns booleanset rR=VXx(iR)return trueendfunctionfunction EHx takes nothing returns booleanset aR=VXx(nR)return trueendfunctionfunction Ejx takes nothing returns booleanset VR=VXx(ER)return trueendfunctionfunction EJx takes nothing returns booleanset XR=VXx(OR)return trueendfunctionfunction Ekx takes nothing returns booleanset RR=VXx(IR)return trueendfunctionfunction EKx takes nothing returns booleanset AR=VXx(NR)return trueendfunctionfunction Elx takes nothing returns booleanset bR=VXx(BR)return trueendfunctionfunction ELx takes nothing returns booleanset cR=VXx(CR)return trueendfunctionfunction Emx takes nothing returns booleanset dR=VXx(DR)return trueendfunctionfunction EMx takes nothing returns booleanset fR=VXx(FR)return trueendfunctionfunction Epx takes nothing returns booleanset gR=VXx(GR)return trueendfunctionfunction EPx takes nothing returns booleanset hR=VXx(HR)return trueendfunctionfunction Eqx takes nothing returns booleanset jR=VXx(JR)return trueendfunctionfunction EQx takes nothing returns booleanset kR=VXx(KR)return trueendfunctionfunction Esx takes nothing returns booleanset lR=VXx(LR)return trueendfunctionfunction ESx takes nothing returns booleanset mR=VXx(MR)return trueendfunctionfunction Etx takes nothing returns booleanset pR=VXx(PR)return trueendfunctionfunction ETx takes nothing returns booleanset qR=VXx(QR)return trueendfunctionfunction Eux takes nothing returns booleanset iv=VXx(T)return trueendfunctionfunction EUx takes nothing returns booleanset sR=VXx(SR)return trueendfunctionfunction Ewx takes nothing returns booleanset tR=VXx(TR)return trueendfunctionfunction EWx takes nothing returns booleanset uR=VXx(UR)return trueendfunctionfunction Eyx takes nothing returns booleanset wR=VXx(WR)return trueendfunctionfunction EYx takes nothing returns booleanset yR=VXx(YR)return trueendfunctionfunction Ezx takes nothing returns booleanset zR=VXx(ZR)return trueendfunctionfunction EZx takes nothing returns booleanset vI=VXx(eI)return trueendfunctionfunction E_x takes nothing returns booleanset oI=VXx(rI)return trueendfunctionfunction E0x takes nothing returns booleanset iI=VXx(aI)return trueendfunctionfunction E1x takes code c,string rSx returns nothing
set Ci=Ci+1set di[Ci]=CreateTrigger()set Di[Ci]=(GetHandleId(Condition((c))))
set fi[Ci]=rSxcall TriggerAddCondition(di[Ci],Condition(c))endfunctionfunction E2x takes integer oSx returns integerset RI[oSx]=true
set II[oSx]=falsecall rEx(tR)
return oSxendfunctionfunction E3x takes nothing returns integerlocal integer oSxif(VI==8190)then
call o_x("EventType_Allocation_allocCustom","call DebugEx(EventType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",TR+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(EI[(w)]==w)thenset XI=XI+1set oSx=XIelse
set oSx=EI[(w)]set EI[(w)]=EI[EI[(w)]]endifset EI[oSx]=Zset OI[oSx]=1call E2x(oSx)return oSxendfunctionfunction E4x takes integer oSx returns integerset DI[oSx]=true
set fI[oSx]=falsecall rEx(sR)
return oSxendfunctionfunction E5x takes nothing returns integerlocal integer oSxif(BI==8190)then
call o_x("EventPriority_Allocation_allocCustom","call DebugEx(EventPriority.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",SR+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(cI[(w)]==w)thenset CI=CI+1set oSx=CIelse
set oSx=cI[(w)]set cI[(w)]=cI[cI[(w)]]endifset cI[oSx]=Zset dI[oSx]=1call E4x(oSx)return oSxendfunctionfunction E6x takes integer oSx returns booleanset Xv=Xv+1set Ov[Xv]=oSxset gI[oSx]=Xv+1
return(Xv==0)endfunctionfunction E7x takes string rSx returns integerlocal integer oSx=E5x()set FI[(oSx)]=(rSx)call E6x(oSx)return oSxendfunctionfunction E8x takes nothing returns nothingset bI=E7x("Header")
set GI=E7x("HeaderTop")set hI=E7x("Combination")set HI=E7x("AI")
set jI=E7x("Events")
set JI=E7x("Content")set kI=E7x("Content2")set KI=JIset lI=JIset LI=kIset mI=JIset MI=JIset pI=JIset Iv=Xv+1endfunctionfunction E9x takes nothing returns booleanlocal integer iset nI=(E3x())set AI=$A+Fset i=AI
loop
exitwhen(i<0)set NI[i]=Erx()set i=i-1endloopcall E8x()set EE=(E3x())return trueendfunctionfunction Xvx takes nothing returns booleancall E1x(function E9x,"Event_Init")return trueendfunctionfunction Xex takes nothing returns booleanset PI=VXx(qI)return trueendfunctionfunction Xxx takes code c,string rSx returns nothing
set Ua=Ua+1set wa[Ua]=CreateTrigger()set Wa[Ua]=(GetHandleId(Condition((c))))
set ya[Ua]=rSxcall TriggerAddCondition(wa[Ua],Condition(c))endfunctionfunction Xox takes integer oSx returns integerset uI[oSx]=true
set UI[oSx]=falsecall rEx(wI)
return oSxendfunctionfunction Xrx takes nothing returns integerlocal integer oSxif(QI==8190)then
call o_x("CommandHeader_Allocation_allocCustom","call DebugEx(CommandHeader.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",sI+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(SI[(w)]==w)thenset tI=tI+1set oSx=tIelse
set oSx=SI[(w)]set SI[(w)]=SI[SI[(w)]]endifset SI[oSx]=Zset TI[oSx]=1call Xox(oSx)return oSxendfunctionfunction Xix takes integer oSx returns integerset vA[oSx]=true
set eA[oSx]=falseset xA[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])call rEx(iI)
return oSxendfunctionfunction Xax takes nothing returns integerlocal integer oSxif(WI==8190)then
call o_x("Event_Allocation_allocCustom","call DebugEx(Event.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",aI+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(YI[(w)]==w)thenset zI=zI+1set oSx=zIelse
set oSx=YI[(w)]set YI[(w)]=YI[YI[(w)]]endifset YI[oSx]=Zset ZI[oSx]=1call Xix(oSx)return oSxendfunctionfunction Xnx takes integer oSx returns nothingset aA[(oSx)]=(VA+oSx)endfunctionfunction XVx takes integer oSx returns nothingset EA[oSx]=falseset XA[oSx]=0set OA[oSx]=null
endfunctionfunction XEx takes nothing returns integerlocal integer oSx=Xax()set hv[oSx]=wset cv[(oSx)]=(w)set oA[(oSx)]=(0)set rA[(oSx)]=(w)set iA[(oSx)]=(w)call Xnx(oSx)call XVx(oSx)return oSxendfunctionfunction XXx takes integer oSx returns integerset bA[oSx]=true
set BA[oSx]=falseset cA[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])call rEx(CA)
return oSxendfunctionfunction XOx takes nothing returns integerlocal integer oSxif(RA==8190)then
call o_x("Trigger_Allocation_allocCustom","call DebugEx(Trigger.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Dv+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(IA[(w)]==w)thenset AA=AA+1set oSx=AAelse
set oSx=IA[(w)]set IA[(w)]=IA[IA[(w)]]endifset IA[oSx]=Zset NA[oSx]=1call XXx(oSx)return oSxendfunctionfunction XRx takes integer oSx returns nothingset gA[(oSx)]=(hA+oSx)endfunctionfunction XIx takes nothing returns integerlocal integer oSx=XOx()local trigger oqx=CreateTrigger()set dv[oSx]=null
set fv[oSx]=0set Gv[oSx]=null
set dA[oSx]=null
set Fv[oSx]="default"set gv[oSx]=null
set DA[oSx]=oqxcall SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oqx))))),((((FA)))),((((oSx)))))
call XRx(oSx)call TriggerAddCondition(oqx,HA)
set oqx=null
return oSxendfunctionfunction XAx takes string rSx returns integerlocal integer oSx=XIx()set Fv[oSx]=rSxreturn oSxendfunctionfunction XNx takes integer oSx returns nothingendfunctionfunction Xbx takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((cA[(oSx)]))])]))],((((gA[((oSx))])))),(((otx))),(((oux))))endfunctionfunction XBx takes integer oSx,code oux returns nothingif(oux==null)thenreturnendifset dv[oSx]=CreateTrigger()set fv[oSx]=(GetHandleId(Condition((oux))))set gv[oSx]=(I2S(((GetHandleId(Condition((oux)))))))
if(Gv[oSx]!=null)thenset Gv[oSx]=Gv[oSx]+";"endifset Gv[oSx]=Gv[oSx]+(LoadStr(j,(GetHandleId(Condition(((oux))))),0))
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((dv[oSx]))))),((((FA)))),((((oSx)))))
call TriggerAddCondition(dv[oSx],Condition(oux))
endfunctionfunction Xcx takes integer oSx,code igx returns nothinglocal integer XCx=(hv[(oSx)])if(XCx!=w)thencall XNx(XCx)endifcall Xbx(XCx,JA,oSx)
call XBx(XCx,igx)endfunctionfunction Xdx takes string rSx,integer rNx,integer rbx,code igx returns integerlocal integer oSx=XEx()local integer XCx=XAx(rSx)set hv[oSx]=XCxset cv[(oSx)]=(w)set oA[(oSx)]=((1+8192*(((rNx)-1)*Iv+((rbx)-1))))set jA[(oSx)]=(rSx)set rA[(oSx)]=(rbx)set iA[(oSx)]=(rNx)call Xcx(oSx,igx)return oSxendfunctionfunction XDx takes string oqx,integer Xfx returns integerlocal integer o5x=S2I(oqx)if(oqx=="0")then
return o5xendifif(o5x==0)thenreturn Xfxendifreturn o5xendfunctionfunction XFx takes string oqx,integer r6x returns string
return r5x(oqx,r6x,((StringLength(((oqx))))-1))endfunctionfunction Xgx takes string oqx,integer r7x returns string
return r5x(oqx,0,r7x)endfunctionfunction XGx takes integer oSx,integer rFx returns nothingset bv=(rFx)
call rDx(oSx)endfunctionfunction Xhx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oSx=rqx((LA[(rFx)]),mA)local integer XHx=r9x(r4x,"^",0)
local integer Xjxif(XHx!=Qv)thenset Xjx=XDx(XFx(r4x,XHx+1),0)set lA[(rFx)]=(Xgx(r4x,XHx-1))call aKx("repeat "+I2S(Xjx)+": "+r4x)loop
exitwhen(Xjx<1)call XGx(MA[oSx],rFx)set Xjx=Xjx-1endloopreturn trueendifcall rDx(MA[oSx])return trueendfunctionfunction XJx takes code XCx returns integerlocal integer oSxif(XCx==null)thenreturn w
endifset oSx=XAx((LoadStr(j,(GetHandleId(Condition(((XCx))))),0)))call XBx(oSx,XCx)return oSxendfunctionfunction Xkx takes code XCx returns integerlocal integer XKx=(GetHandleId(Condition((XCx))))local integer oSx=(LoadInteger(o[((pA))],(XKx),(qA)))if(oSx==0)thencall SaveInteger(o[((pA))],(XKx),(qA),(oSx))
return XJx(XCx)endifreturn oSxendfunctionfunction Xlx takes integer oSx,string o9x,string otx,integer oux returns nothing
if((o9x==null)or(otx==null))then
call o_x("FolderGameCache_StructInteger_Set","call DebugEx(\"GameCache Set: \"+missionKey+\";\"+key)","GameCache Set: "+o9x+";"+otx)
returnendifcall StoreInteger(Kv[(oSx)],o9x,otx,oux)
endfunctionfunction XLx takes string rQx,integer otx,integer oux returns nothingcall Xlx(lv[(E[((X))])],((rQx)),(((I2S((otx))))),((oux)))endfunctionfunction Xmx takes integer oSx returns integerset wA[oSx]=true
set WA[oSx]=falsecall rEx(yA)
return oSxendfunctionfunction XMx takes nothing returns integerlocal integer oSxif(SA==8190)then
call o_x("BoolExpr_Allocation_allocCustom","call DebugEx(BoolExpr.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",tA+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(TA[(w)]==w)thenset uA=uA+1set oSx=uAelse
set oSx=TA[(w)]set TA[(w)]=TA[TA[(w)]]endifset TA[oSx]=Zset UA[oSx]=1call Xmx(oSx)return oSxendfunctionfunction Xpx takes code XPx returns integerlocal integer Xqx=(GetHandleId(Condition((XPx))))local integer oSx=(LoadInteger(o[((QA))],(Xqx),(sA)))if(oSx==0)thenset oSx=XMx()set Bv[oSx]=Condition(XPx)call SaveInteger(o[((QA))],(Xqx),(sA),(oSx))
endifreturn oSxendfunctionfunction XQx takes string oqx,string oux,integer oLx returns integer
local integer oMx=0-1local integer ivx=((StringLength(((oqx))))-1)local integer iex=(StringLength((oux)))loop
exitwhen(oLx<0)set oMx=oMx+1loop
if(oMx>ivx)thenreturn Qvendifexitwhen(r5x(oqx,oMx,oMx+iex-1)!=oux)set oMx=oMx+1endloopset oLx=oLx-1endloopreturn oMxendfunctionfunction Xsx takes string oqx,integer oLx returns string
local integer rox=XQx(oqx," ",0)
local boolean XSxif(rox==Qv)thenreturn nullendifset oqx=XFx(oqx,rox)
set rox=r9x(oqx," ",0)if(oLx==0)thenif(rox==Qv)thenreturn oqxendifreturn(r5x((oqx),0,(rox-1)))
elseif(rox==Qv)thenreturn nullendifset XSx=falseset oLx=oLx-1loop
set oqx=XFx(oqx,rox)
set rox=XQx(oqx," ",0)if(rox==Qv)thenreturn nullendifif(r5x(oqx,rox,rox)=="\"")thenset oqx=XFx(oqx,rox+1)set rox=r9x(oqx,"\"",0)set XSx=true
else
set oqx=XFx(oqx,rox)
set rox=r9x(oqx," ",0)endifif(oLx==0)thenif(rox==Qv)thenreturn oqxendifreturn(r5x((oqx),0,(rox-1)))
elseif(rox==Qv)thenreturn nullendifset oLx=oLx-1exitwhen(oLx<0)if XSx thenset XSx=falseset rox=rox+1endifendloopreturn nullendfunctionfunction Xtx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local string XTx=(LA[(rFx)])
local boolean o7x=(Xsx(r4x,0)==XTx)local string array Xuxlocal integer XUxlocal string Xwx
if o7x thenset XUx=0set Xwx=null
loop
exitwhen(Xsx(r4x,XUx+1)==null)set XUx=XUx+1set Xux[F+XUx]=Xsx(r4x,XUx)if(XUx==1)thenset Xwx=Xux[F+XUx]else
set Xwx=Xwx+" "+Xux[F+XUx]endifendloopif(Xwx==null)thencall aKx("execute "+XTx)
else
call aKx("execute "+XTx+" with "+Xwx)endifendifreturn o7xreturn trueendfunctionfunction XWx takes integer oSx,string o9x,string otx,integer oux returns boolean
local integer rvx=(YA+(rPx(lv[(E[((oSx))])],((o9x)),((otx)))))+1
call Xlx(lv[(E[(oSx)])],(o9x),(otx),(rvx-YA))call Xlx(lv[(E[(oSx)])],(o9x),(otx+I2S(YA+rvx+2)),(oux))
return(rvx==0)endfunctionfunction Xyx takes integer oSx,string oqx,integer XYx returns nothingcall XWx(X,(oqx),(I2S((((oA[(XYx)]))))),(XYx))endfunctionfunction Xzx takes string r4x,code XZx returns nothinglocal integer oSx=Xrx()local integer XYx=Xdx("CommandHeader_RegisterEvent: local Event whichEvent = Event.Create(User.CHAT_EVENT_TYPE, EventPriority.MISC, function CommandHeader.Event_Chat)",KA,lI,function Xhx)set MA[oSx]=Xkx(XZx)
call XLx(r4x,mA,oSx)
set cv[(XYx)]=(Xpx(function Xtx))call Xyx(zA,r4x,XYx)
endfunctionfunction X_x takes real x,real y returns realcall MoveLocation(aN[(nN)],((x)*1.),((y)*1.))return(GetLocationZ(aN[(nN)]))endfunctionfunction X0x takes integer oSx,real x,real y,real z returns nothingif vN[oSx]thenset x=x-(StringLength((rN[(oSx)])))*1./ 2*16.5endifcall SetTextTagPos(iN[(oSx)],x,y,z-X_x(x,y))
endfunctionfunction X1x takes integer oSx,real x,real y,real z returns nothingset eN[oSx]=xset xN[oSx]=yset oN[oSx]=zcall X0x(oSx,x,y,z)endfunctionfunction X2x takes integer oSx returns nothingcall X1x(oSx,eN[oSx],xN[oSx],oN[oSx])endfunctionfunction X3x takes integer oSx returns nothingset vN[oSx]=true
call X2x(oSx)endfunctionfunction X4x takes integer oSx returns integerset bN[oSx]=true
set BN[oSx]=falsecall rEx(cN)
return oSxendfunctionfunction X5x takes nothing returns integerlocal integer oSxif(ON==8190)then
call o_x("TextTag_Allocation_allocCustom","call DebugEx(TextTag.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",RN+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(IN[(w)]==w)thenset AN=AN+1set oSx=ANelse
set oSx=IN[(w)]set IN[(w)]=IN[IN[(w)]]endifset IN[oSx]=Zset NN[oSx]=1call X4x(oSx)return oSxendfunctionfunction X6x takes integer oSx returns nothingset vN[oSx]=falsecall X1x(oSx,.0,.0,.0)endfunctionfunction X7x takes integer id returns integerlocal integer oSxif((id!=0)and((LoadInteger(o[((V[(E[((X))])]))],(((EN))),(((id)))))!=w))then
return w
endifif(XN=='d')thencall o_x("TextTag_Create","call DebugEx(TextTag.Create.name + \": limit exceeded\")","s__TextTag_Create: limit exceeded")return w
endifset XN=XN+1set oSx=X5x()set CN[oSx]=idset iN[oSx]=CreateTextTag()call SaveInteger(o[((V[(E[((X))])]))],(((EN))),(((id))),(((oSx))))set dN[oSx]=.0set DN[(oSx)]=""
call X6x(oSx)return oSxendfunctionfunction X8x takes string oqx returns string
local integer oLx=r9x(oqx,"|c",0)if(oLx!=Qv)thenreturn X8x((r5x((oqx),0,(oLx-1)))+XFx(oqx,oLx+(StringLength(("|c")))+8))
endifset oLx=r9x(oqx,"|r",0)if(oLx!=Qv)thenreturn X8x((r5x((oqx),0,(oLx-1)))+XFx(oqx,oLx+(StringLength(("|r")))))endifreturn oqxendfunctionfunction X9x takes integer oSx,string icx,real Ovx returns nothingset hN[oSx]=Ovxset rN[oSx]=X8x(icx)
set DN[oSx]=icxcall SetTextTagText(iN[(oSx)],icx,Ovx)call X2x((oSx))endfunctionfunction Oex takes integer oSx returns booleanset HN=HN+1set jN[HN]=oSxset JN[oSx]=HN+1
return(HN==0)endfunctionfunction Oxx takes integer oSx,real z returns nothingset oN[oSx]=zcall X0x(oSx,eN[oSx],xN[oSx],z)endfunctionfunction Oox takes integer oSx,real z returns nothingcall Oxx(oSx,(oN[(oSx)])+z)endfunctionfunction Orx takes nothing returns nothinglocal integer oMx=HN
local integer oSxloop
set oSx=jN[oMx]call Oox((oSx),fN[oSx])set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction Oix takes integer oSx returns booleanlocal integer oLx=(JN[(oSx)])set JN[jN[HN]]=oLxset jN[oLx-1]=jN[HN]
set JN[oSx]=0set HN=HN-1return(HN==F)endfunctionfunction Oax takes integer oSx,integer iCx returns nothingset GN[oSx]=falsecall iKx(iCx)if Oix(oSx)thencall ikx(kN)
endifendfunctionfunction Onx takes integer oSx returns booleanlocal integer oLx=(lN[(oSx)])set lN[LN[mN]]=oLxset LN[oLx-1]=LN[mN]
set lN[oSx]=0set mN=mN-1return(mN==F)endfunctionfunction OVx takes integer oSx,integer iCx returns nothingset KN[oSx]=falsecall iKx(iCx)if Onx(oSx)thencall ikx(MN)
endifendfunctionfunction OEx takes integer oSx returns nothingif KN[oSx]thencall OVx(oSx,pN[oSx])endifendfunctionfunction OXx takes integer oSx returns booleanlocal integer oLx=(qN[(oSx)])set qN[QN[sN]]=oLxset QN[oLx-1]=QN[sN]
set qN[oSx]=0set sN=sN-1return(sN==F)endfunctionfunction OOx takes integer oSx,integer iCx returns nothingset PN[oSx]=falsecall iKx(iCx)if OXx(oSx)thencall ikx(SN)
endifendfunctionfunction ORx takes integer oSx returns nothingif PN[oSx]thencall OOx(oSx,tN[oSx])endifendfunctionfunction OIx takes integer oSx returns nothingif GN[oSx]thencall Oax(oSx,gN[oSx])endifendfunctionfunction OAx takes integer oSx returns booleanlocal integer oLx=(TN[(oSx)])set TN[uN[UN]]=oLxset uN[oLx-1]=uN[UN]
set TN[oSx]=0set UN=UN-1return(UN==F)endfunctionfunction ONx takes integer oSx returns nothingif OAx(oSx)thencall ikx(wN)
endifendfunctionfunction Obx takes integer oSx returns nothingif((TN[((oSx))])>0)thencall ONx(oSx)endifendfunctionfunction OBx takes integer oSx returns nothingset bN[oSx]=falsecall rHx(cN)
endfunctionfunction Ocx takes integer oSx returns nothingif(NN[oSx]>0)thenreturnendifif(IN[oSx]!=Z)thencall o_x("TextTag_Allocation_deallocCustom_confirm","call DebugEx(TextTag.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",RN+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset IN[oSx]=IN[(w)]set IN[(w)]=oSxcall OBx(oSx)endfunctionfunction OCx takes integer oSx returns nothingset NN[oSx]=NN[oSx]-1call Ocx(oSx)endfunctionfunction Odx takes integer oSx returns nothinglocal integer id=CN[oSx]
local texttag oqx=iN[oSx]set XN=XN-1call OEx(oSx)call ORx(oSx)call OIx(oSx)call Obx(oSx)call OCx((oSx))call DestroyTextTag(oqx)
call SaveInteger(o[(((V[(E[((X))])])))],((((EN)))),((((id)))),(0))set oqx=null
endfunctionfunction ODx takes nothing returns nothinglocal integer iCx=iGx()local integer oSx=(ge[(iCx)])call Oax(oSx,iCx)call Odx((oSx))endfunctionfunction Ofx takes integer oSx returns booleanset UN=UN+1set uN[UN]=oSxset TN[oSx]=UN+1
return(UN==0)endfunctionfunction OFx takes nothing returns nothinglocal integer oMx=UN
local integer oSxlocal real Ogxloop
set oSx=uN[oMx]set Ogx=YN[oSx]+WN[oSx]set YN[oSx]=Ogxcall SetTextTagColor(iN[(oSx)],$FF,$FF,$FF,(R2I(((Ogx)*1.))))set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction OGx takes integer oSx,real iMx returns nothingset WN[oSx]=-$FF*1./ iMx*yNset YN[oSx]=$FFcall SetTextTagPermanent(iN[(oSx)],false)if Ofx(oSx)thencall iDx(wN,yN,true,function OFx)endifendfunctionfunction Ohx takes nothing returns nothinglocal integer oSx=(ge[(iGx())])call iKx(zN[(oSx)])call OGx((oSx),ZN[oSx])endfunctionfunction OHx takes integer oSx,real Ojx,real OJx returns nothing
local integer Okxif(Ojx<=.0)thencall OGx((oSx),OJx)returnendifset Okx=iXx()set zN[oSx]=Okxset ZN[oSx]=OJx-Ojxset ge[(Okx)]=(oSx)call iDx(Okx,Ojx,false,function Ohx)
endfunctionfunction OKx takes integer oSx,real Ojx,real OJx returns nothing
call OHx(oSx,Ojx,OJx)endfunctionfunction Olx takes string icx,real Ovx,real x,real y,real z,real OLx,real Omx,real iMx,integer id returns integerlocal integer rLxlocal integer oSxlocal integer iCxif(iMx==.0)thenreturn w
endifset rLx=X7x(id)if(rLx==w)thenreturn w
endifset oSx=rLxset iCx=iXx()set fN[oSx]=OLx*FNset gN[oSx]=iCxset GN[oSx]=true
set ge[(iCx)]=(oSx)call X1x(rLx,x,y,z)call X9x(rLx,icx,Ovx)if Oex(oSx)thencall iDx(kN,FN,true,function Orx)endifcall iDx(iCx,iMx,false,function ODx)
call OKx(rLx,Omx,iMx)return rLxendfunctionfunction OMx takes integer oSx,real x,real y returns realreturn(X_x(x,y)+(GetUnitFlyHeight(C[((oSx))])))endfunctionfunction Opx takes integer oSx,boolean OPx returns realif OPx thenreturn(vb[oSx]*(eb[((oSx))]))endifreturn vb[oSx]endfunctionfunction Oqx takes integer oSx,string icx,real Ovx,real OLx,real Omx,real iMx,integer id returns integer
local real x=(GetUnitX(C[((oSx))]))local real y=(GetUnitY(C[((oSx))]))return Olx(icx,Ovx,x,y,OMx(oSx,x,y)+Opx(oSx,true),OLx,Omx,iMx,id)endfunctionfunction OQx takes integer oSx returns stringreturn("|c"+xb[oSx]+ob[oSx]+"|r")endfunctionfunction Osx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])local integer OSx=(kv[(oDx)])set r4x=XFx(r4x,1)if(OSx!=w)thencall X3x(Oqx(OSx,OQx(oDx)+": "+r4x,rb,100.,2.,3.+.1*(StringLength((r4x))),(0)))endifreturn trueendfunctionfunction Otx takes nothing returns booleancall Xzx("!",function Osx)return trueendfunctionfunction OTx takes nothing returns booleancall Xxx(function Otx,"CharacterSpeech_Init")return trueendfunctionfunction Oux takes nothing returns booleanset ib=VXx(ab)return trueendfunctionfunction OUx takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[(((nb[(oSx)])))])]))],(((((Vb[((oSx))]))))),((((otx))+(q)))))endfunctionfunction Owx takes integer oSx returns nothingset Rb=oSxcall rDx(Ib)
endfunctionfunction OWx takes nothing returns nothinglocal integer Oyxloop
set Oyx=(OUx((Eb),Ob))exitwhen(Oyx==w)
call Owx(Oyx)endloopendfunctionfunction OYx takes nothing returns booleanlocal integer rFx=(bv)call OWx()return trueendfunctionfunction Ozx takes nothing returns booleancall Xzx("-clearSpawns",function OYx)return trueendfunctionfunction OZx takes nothing returns booleancall Xxx(function Ozx,"ClearSpawns_Init")return trueendfunctionfunction O_x takes nothing returns booleanset Ab=VXx(Nb)return trueendfunctionfunction O0x takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((Bb[(oSx)]))])]))],((((cb[((oSx))])))),(((otx))))))endfunctionfunction O1x takes integer oSx,integer oDx returns integerreturn O0x(oDx,Cb)endfunctionfunction O2x takes integer oSx returns integerset Hb[oSx]=true
set jb[oSx]=falsecall rEx(Jb)
return oSxendfunctionfunction O3x takes nothing returns integerlocal integer oSxif(fb==8190)then
call o_x("Group_Allocation_allocCustom","call DebugEx(Group.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Fb+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(gb[(w)]==w)thenset Gb=Gb+1set oSx=Gbelse
set oSx=gb[(w)]set gb[(w)]=gb[gb[(w)]]endifset gb[oSx]=Zset hb[oSx]=1call O2x(oSx)return oSxendfunctionfunction O4x takes integer oSx returns nothingset lb[oSx]=0set Lb[oSx]=falseendfunctionfunction O5x takes nothing returns integerlocal integer oSxif(Db==F)thenset oSx=O3x()set kb[oSx]=CreateGroup()else
set oSx=Kb[Db]set Db=Db-1endifcall O4x(oSx)return oSxendfunctionfunction O6x takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((Bb[(oSx)]))])]))],((((cb[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction O7x takes integer oSx,integer oDx,integer oLx returns integerreturn O6x(oDx,Cb,oLx)endfunctionfunction O8x takes integer oSx returns booleanif((lb[(oSx)])>0)thenset Lb[oSx]=true
return false
endifreturn trueendfunctionfunction O9x takes integer oSx returns nothingif not O8x(oSx)thenreturnendifset Db=Db+1set Kb[Db]=oSxcall GroupClear(kb[oSx])
endfunctionfunction Rvx takes integer oSx,code XCx returns nothinglocal integer oMx=O1x(db,oSx)local integer Rexif(oMx<q)thenreturnendifset Rex=O5x()loop
call GroupAddUnit(kb[(Rex)],C[(O7x(db,oSx,oMx))])set oMx=oMx-1exitwhen(oMx<q)endloopcall ForGroup(kb[(Rex)],(XCx))call O9x(Rex)endfunctionfunction Rxx takes integer oSx,integer Rox returns booleanreturn(IssueImmediateOrderById(C[(oSx)],pb[Rox]))endfunctionfunction Rrx takes integer oSx,integer Rox returns booleanlocal boolean o7xcall DisableTrigger(DA[(Mb)])set o7x=Rxx(oSx,Rox)
call EnableTrigger(DA[(Mb)])
return o7xendfunctionfunction Rix takes integer oSx,integer Rax,integer rlx returns nothinglocal integer rLx=oSxlocal integer Rnx=rRx((A[(rLx)]))local integer rmxlocal integer oMxlocal integer rbxlocal integer rMxset qb[(Rnx)]=(Rax)set nv[(Rnx)]=(rlx)set Vv[(Rnx)]=(oSx)set rmx=rRx((Ev[(rlx)]))
set qb[(rmx)]=(Rax)set nv[(rmx)]=(rlx)set Vv[(rmx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rGx(rlx,Qb,rbx)loop
exitwhen(rMx<q)call rfx(rhx(rlx,Qb,rbx,rMx),rmx)set rMx=rMx-1endloopset rMx=rAx(rLx,Qb,rbx)loop
exitwhen(rMx<q)call rfx(rgx(rLx,Qb,rbx,rMx),Rnx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((Rnx)))call rkx(((rmx)))endfunctionfunction RVx takes integer oSx,integer rlx returns nothinglocal integer REx=(mb[(oSx)])if(rlx==REx)then
returnendifset mb[oSx]=rlxcall Rix(oSx,REx,rlx)endfunctionfunction RXx takes integer oSx,integer rlx returns nothingif(rlx==w)thenif((mb[(oSx)])!=w)thenif Rrx((oSx),(Pb[(rlx)]))thencall RVx(oSx,w)endifendifelse
if Rrx((oSx),(sb[(rlx)]))thencall RVx(oSx,rlx)endifendifendfunctionfunction ROx takes nothing returns integerlocal unit oqx=GetEnumUnit()
local integer o7xif(GetUnitAbilityLevel(oqx,'aLoc')>0)thenset oqx=null
return Z
endifset o7x=adx(oqx)
set oqx=null
return o7xendfunctionfunction RRx takes nothing returns booleanlocal integer rFx=(bv)call RXx(ROx(),bb)return trueendfunctionfunction RIx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])local integer rlx=rsx(Xsx(r4x,1))if(rlx==w)thencall o_x("CommandAutoCast_Event_Chat","call DebugEx(\"invalid spell\")","invalid spell")
return trueendifset bb=rlxcall Rvx(oDx,function RRx)return trueendfunctionfunction RAx takes nothing returns booleancall Xzx("-autocast",function RIx)return trueendfunctionfunction RNx takes nothing returns booleancall Xxx(function RAx,"CommandAutoCast_Init")return trueendfunctionfunction Rbx takes nothing returns booleanset Sb=VXx(tb)return trueendfunctionfunction RBx takes string rSx returns integerreturn rqx(rSx,Tb)endfunctionfunction Rcx takes integer RCx,integer Rdx,integer RDx returns integerlocal integer Rfxset RCx=RCx-Oset Rfx=(RCx/ 64*8192*8192+Rdx*8192+RDx)
return Rfxendfunctionfunction RFx takes integer RCx,integer Rgx,integer RGx returns integerlocal integer Rfxset RCx=RCx-Oset Rfx=((RCx-RCx/ 64*64)*8192*8192+Rgx*8192+RGx)return Rfxendfunctionfunction Rhx takes integer oSx,integer RHx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer RGx returns integerreturn(LoadInteger(o[((RHx))],(Rcx(RCx,Rdx,RDx)),(RFx(RCx,Rgx,RGx))))endfunctionfunction Rjx takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx returns integerreturn Rhx(E[(oSx)],bO[oSx],RCx,Rdx,RDx,Rgx,0)endfunctionfunction RJx takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer oux returns integerreturn Rhx(E[(oSx)],cO[oSx],RCx,Rdx,RDx,Rgx,(oux))endfunctionfunction Rkx takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer oux returns integerreturn Rhx(E[(oSx)],CO[oSx],RCx,Rdx,RDx,Rgx,(oux))endfunctionfunction RKx takes integer oSx,integer RHx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer RGx,integer oux returns nothingcall SaveInteger(o[((RHx))],(Rcx(RCx,Rdx,RDx)),(RFx(RCx,Rgx,RGx)),(oux))
endfunctionfunction Rlx takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer oux returns nothinglocal integer RLx=RJx(oSx,RCx,Rdx,RDx,Rgx,oux)local integer Rmx=Rkx(oSx,RCx,Rdx,RDx,Rgx,oux)if((Rmx==0)and(RLx==0))thenif(Rjx(oSx,RCx,Rdx,RDx,Rgx)!=oux)thenreturnendifendifif(RLx==0)thencall RKx(E[(oSx)],BO[oSx],RCx,Rdx,RDx,Rgx,0,Rmx)
else
call RKx(E[(oSx)],CO[oSx],RCx,Rdx,RDx,Rgx,(RLx),Rmx)
endifif(Rmx==0)thencall RKx(E[(oSx)],bO[oSx],RCx,Rdx,RDx,Rgx,0,RLx)
else
call RKx(E[(oSx)],cO[oSx],RCx,Rdx,RDx,Rgx,(Rmx),RLx)
endifendfunctionfunction RMx takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx returns integerlocal integer oux=Rjx(oSx,RCx,Rdx,RDx,Rgx)if(oux==0)thenreturn 0
endifcall Rlx(oSx,RCx,Rdx,RDx,Rgx,oux)return ouxendfunctionfunction Rpx takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx returns nothingloop
exitwhen(RMx(oSx,RCx,Rdx,RDx,Rgx)==0)endloopendfunctionfunction RPx takes integer oSx,integer XYx returns nothingif not((LoadInteger(o[((D[((Rv[oSx]))]))],((((A[((oSx))])))),(oTx((((oA[(XYx)]))),(((XYx)))))))!=0)thencall o_x("FolderUnit_StructEvent_Remove","call DebugEx(\"subject \"+I2S(Unit(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((A[((oSx))]))+" has not "+(jA[(XYx)]))returnendifcall rrx(Rv[oSx],(A[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction Rqx takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((nB[oSx]))])]))],((((iB[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))endfunctionfunction RQx takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((nB[oSx]))])]))],((((iB[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))endfunctionfunction Rsx takes integer oSx returns nothinglocal integer rFx=rRx((iB[(oSx)]))local integer oMxlocal integer rbxlocal integer rMxset aB[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=Rqx(oSx,VB,rbx)loop
exitwhen(rMx<q)call rfx(RQx(oSx,VB,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction RSx takes integer oSx returns nothingif EB[oSx]thenreturnendifset EB[oSx]=true
if(XB[oSx]==null)thencall DestroyEffect(OB[oSx])set OB[oSx]=null
else
call DestroyEffect(XB[oSx])set XB[oSx]=null
endifendfunctionfunction Rtx takes integer oSx returns booleanlocal integer oLx=(RB[(oSx)])set RB[IB[AB]]=oLxset IB[oLx-1]=IB[AB]
set RB[oSx]=0set AB=AB-1return(AB==F)endfunctionfunction RTx takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((CB[oSx]))])])],((((iB[((oSx))])))))endfunctionfunction Rux takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((nB[oSx]))])])],((((iB[((oSx))])))))endfunctionfunction RUx takes integer oSx returns nothingset cB[oSx]=falsecall RTx((oSx))call Rux(((oSx)))call rHx(dB)
endfunctionfunction Rwx takes integer oSx returns nothingif(NB[oSx]>0)thenreturnendifif(bB[oSx]!=Z)thencall o_x("UnitEffect_Allocation_deallocCustom_confirm","call DebugEx(UnitEffect.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",BB+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset bB[oSx]=bB[(w)]set bB[(w)]=oSxcall RUx(oSx)endfunctionfunction RWx takes integer oSx returns nothingset NB[oSx]=NB[oSx]-1call Rwx(oSx)endfunctionfunction Ryx takes integer oSx returns booleanif rB[oSx]thenreturn trueendifset rB[oSx]=true
call Rsx(oSx)call RSx(oSx)call Rtx(oSx)call RWx(oSx)return trueendfunctionfunction RYx takes integer oSx returns nothingset GB[oSx]=GB[oSx]+1endfunctionfunction Rzx takes integer oSx returns nothingset kB[oSx]=falsecall rHx(KB)
endfunctionfunction RZx takes integer oSx returns nothingif(GB[oSx]>0)thenreturnendifif(jB[oSx]!=Z)thencall o_x("Sound_Allocation_deallocCustom_confirm","call DebugEx(Sound.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",JB+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset jB[oSx]=jB[(w)]set jB[(w)]=oSxcall Rzx(oSx)endfunctionfunction R_x takes integer oSx returns nothingset GB[oSx]=GB[oSx]-1call RZx(oSx)endfunctionfunction R0x takes nothing returns nothinglocal integer Okx=iGx()local integer oSx=(ge[(Okx)])set gB[oSx]=wcall StopSound(FB[oSx],hB[oSx],HB[oSx])call R_x(oSx)endfunctionfunction R1x takes integer oSx,boolean R2x,boolean R3x returns nothinglocal integer Okx=gB[oSx]if(Okx==w)thenset Okx=iXx()set ge[(Okx)]=(oSx)call RYx(oSx)endifset gB[oSx]=Okxset hB[oSx]=R2xset HB[oSx]=R3xcall iDx(Okx,.07,false,function R0x)
endfunctionfunction R4x takes integer oSx,boolean R5x returns booleanlocal sound oqxif fB[oSx]thenreturn trueendifset fB[oSx]=true
set oqx=FB[oSx]if R5x thencall R1x(oSx,true,true)else
if(lB[(oSx)])thencall R1x(oSx,true,R5x)else
call KillSoundWhenDone(oqx)endifendifset oqx=null
call R_x(oSx)return trueendfunctionfunction R6x takes integer oSx returns nothingset PB[oSx]=falsecall rHx(qB)
endfunctionfunction R7x takes integer oSx returns nothingif(mB[oSx]>0)thenreturnendifif(MB[oSx]!=Z)thencall o_x("UnitSound_Allocation_deallocCustom_confirm","call DebugEx(UnitSound.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",pB+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset MB[oSx]=MB[(w)]set MB[(w)]=oSxcall R6x(oSx)endfunctionfunction R8x takes integer oSx returns nothingset mB[oSx]=mB[oSx]-1call R7x(oSx)endfunctionfunction R9x takes integer oSx returns nothingcall R4x(LB[oSx],true)call R8x((oSx))endfunctionfunction Ivx takes integer oSx returns nothingset WB[oSx]=falsecall rHx(yB)
endfunctionfunction Iex takes integer oSx returns nothingif(uB[oSx]>0)thenreturnendifif(UB[oSx]!=Z)thencall o_x("BuffRef_Allocation_deallocCustom_confirm","call DebugEx(BuffRef.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",wB+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset UB[oSx]=UB[(w)]set UB[(w)]=oSxcall Ivx(oSx)endfunctionfunction Ixx takes integer oSx returns nothingset uB[oSx]=uB[oSx]-1call Iex(oSx)endfunctionfunction Iox takes integer oSx returns nothingif not TB[oSx]thenreturnendifif(sB[oSx]>0)thenreturnendifcall Ixx((oSx))endfunctionfunction Irx takes integer oSx returns nothinglocal integer Iix=SB[oSx]local integer Iax=tB[oSx]if TB[oSx]thenreturnendifset TB[oSx]=true
set sB[oSx]=sB[oSx]-1if(sB[oSx]==0)thencall Iox(oSx)endifcall Rlx(X,QB,Iix,Iax,w,oSx)
endfunctionfunction Inx takes integer Iax,integer Iix returns nothinglocal integer oSx=Rjx(X,QB,Iix,Iax,w)loop
exitwhen(oSx==w)
set sB[oSx]=sB[oSx]+1call Irx(oSx)set oSx=Rjx(X,QB,Iix,Iax,w)endloopendfunctionfunction IVx takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((YB[(oSx)]))])]))],((((zB[((oSx))])))),(((otx)))))endfunctionfunction IEx takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((ec[(oSx)]))])]))],((((xc[((oSx))])))),(((otx))))))endfunctionfunction IXx takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((ec[(oSx)]))])]))],((((xc[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction IOx takes integer oSx,integer Iix,boolean o5x returns nothinglocal integer rFx=rRx(0)
set rc[(rFx)]=(o5x)set Vv[(rFx)]=(Iix)call XGx((ic[(oSx)]),rFx)call rkx(((rFx)))endfunctionfunction IRx takes integer oSx,integer IIx,boolean o5x returns nothingcall IOx(IIx,oSx,o5x)endfunctionfunction IAx takes integer oSx,integer otx returns booleanreturn(LoadBoolean(o[((V[(E[((ec[(oSx)]))])]))],((((xc[((oSx))])))),(((otx)))))endfunctionfunction INx takes integer oSx,integer Iix returns nothinglocal integer oMx=(IEx(((oSx)),oc))local integer Ibxloop
exitwhen(oMx<q)set Ibx=(IXx(((oSx)),oc,(oMx)))call IRx((Iix),(Ibx),not((IAx(((oSx)),ac+(Ibx)))))set oMx=oMx-1endloopendfunctionfunction IBx takes integer oSx,integer Iix,real nZx returns nothinglocal integer rFx=rRx(0)
set Vc[(rFx)]=((nZx)*1.)
set Vv[(rFx)]=(Iix)call XGx((ic[(oSx)]),rFx)call rkx(((rFx)))endfunctionfunction Icx takes integer oSx,integer IIx,real oux returns nothingcall IBx(IIx,oSx,oux)endfunctionfunction ICx takes integer oSx,integer otx returns realreturn(LoadReal(o[((V[(E[((ec[(oSx)]))])]))],((((xc[((oSx))])))),(((otx)))))
endfunctionfunction Idx takes integer oSx,integer Iix returns nothinglocal integer oMx=(IEx(((oSx)),nc))local integer Ibxloop
exitwhen(oMx<q)set Ibx=(IXx(((oSx)),nc,(oMx)))call Icx((Iix),(Ibx),-(((ICx(((oSx)),Ec+(Ibx))))*1.))set oMx=oMx-1endloopendfunctionfunction IDx takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer RGx,boolean oux returns nothingcall SaveBoolean(o[((EO[oSx]))],(Rcx(RCx,Rdx,RDx)),(RFx(RCx,Rgx,RGx)),(oux))
endfunctionfunction Ifx takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer RGx returns booleanreturn(LoadBoolean(o[((EO[oSx]))],(Rcx(RCx,Rdx,RDx)),(RFx(RCx,Rgx,RGx))))endfunctionfunction IFx takes integer oSx,integer rFx,integer Ibx returns nothinglocal integer otx=Rjx(X,Oc,oSx,Ibx,w)loop
exitwhen(otx==w)
call IDx(E[((X))],(Ic),((rFx)),((otx)),(w),(w),(((Ifx(E[((X))],(Ac),(oSx),(Ibx),(otx),(w))))))set otx=RJx(X,Oc,oSx,Ibx,w,otx)endloopendfunctionfunction Igx takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer RGx,integer oux returns nothingcall SaveInteger(o[((EO[oSx]))],(Rcx(RCx,Rdx,RDx)),(RFx(RCx,Rgx,RGx)),(oux))
endfunctionfunction IGx takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer RGx returns integerreturn(LoadInteger(o[((EO[oSx]))],(Rcx(RCx,Rdx,RDx)),(RFx(RCx,Rgx,RGx))))endfunctionfunction Ihx takes integer oSx,integer rFx,integer Ibx returns nothinglocal integer otx=Rjx(X,Nc,oSx,Ibx,w)loop
exitwhen(otx==w)
call Igx(E[((X))],(Ic),((rFx)),((otx)),(w),(w),(((IGx(E[((X))],(bc),(oSx),(Ibx),(otx),(w))))))set otx=RJx(X,Nc,oSx,Ibx,w,otx)endloopendfunctionfunction IHx takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer RGx,real oux returns nothingcall SaveReal(o[((EO[oSx]))],(Rcx(RCx,Rdx,RDx)),(RFx(RCx,Rgx,RGx)),((oux)*1.))endfunctionfunction Ijx takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer RGx returns realreturn(LoadReal(o[((EO[oSx]))],(Rcx(RCx,Rdx,RDx)),(RFx(RCx,Rgx,RGx))))endfunctionfunction IJx takes integer oSx,integer rFx,integer Ibx returns nothinglocal integer otx=Rjx(X,Bc,oSx,Ibx,w)loop
exitwhen(otx==w)
call IHx(E[((X))],(Ic),((rFx)),((otx)),(w),(w),(((((Ijx(E[((X))],(cc),(oSx),(Ibx),(otx),(w))))*1.))*1.))
set otx=RJx(X,Bc,oSx,Ibx,w,otx)endloopendfunctionfunction Ikx takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer RGx,string oux returns nothingcall SaveStr(o[((EO[oSx]))],(Rcx(RCx,Rdx,RDx)),(RFx(RCx,Rgx,RGx)),(oux))
endfunctionfunction IKx takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer RGx returns stringreturn(LoadStr(o[((EO[oSx]))],(Rcx(RCx,Rdx,RDx)),(RFx(RCx,Rgx,RGx))))endfunctionfunction Ilx takes integer oSx,integer rFx,integer Ibx returns nothinglocal integer otx=Rjx(X,Cc,oSx,Ibx,w)loop
exitwhen(otx==w)
call Ikx(E[((X))],(Ic),((rFx)),((otx)),(w),(w),(((IKx(E[((X))],(dc),(oSx),(Ibx),(otx),(w))))))set otx=RJx(X,Cc,oSx,Ibx,w,otx)endloopendfunctionfunction ILx takes integer oSx,integer Ibx returns integerlocal integer rFx=rRx((xc[((oSx))]))
call IFx(oSx,rFx,Ibx)call Ihx(oSx,rFx,Ibx)call IJx(oSx,rFx,Ibx)call Ilx(oSx,rFx,Ibx)return rFxendfunctionfunction Imx takes integer oSx,integer Iix,integer rFx,boolean IMx returns nothingset Dc[(rFx)]=(IMx)set Vv[(rFx)]=(Iix)call XGx((ic[(oSx)]),rFx)endfunctionfunction Ipx takes integer oSx,integer Iix returns nothinglocal integer oMx=(IEx(((oSx)),Xc))local integer Ibxlocal integer rFxloop
exitwhen(oMx<q)set Ibx=(IXx(((oSx)),Xc,(oMx)))set rFx=ILx(oSx,Ibx)
call Imx(Ibx,Iix,rFx,false)call rkx(((rFx)))set oMx=oMx-1endloopendfunctionfunction IPx takes integer oSx,integer Iix returns nothinglocal integer rFx=rRx(0)
set Vv[(rFx)]=(Iix)set Fc[(rFx)]=(oSx)call XGx((Gc[(oSx)]),rFx)call rkx(((rFx)))endfunctionfunction Iqx takes integer oSx,integer Iix returns nothinglocal integer oMx=(IEx(((oSx)),fc))local integer IQxloop
exitwhen(oMx<q)set IQx=(IXx(((oSx)),fc,(oMx)))call IPx(IQx,Iix)set oMx=oMx-1endloopendfunctionfunction Isx takes integer oSx,integer Iix returns nothingcall INx(oSx,Iix)call Idx(oSx,Iix)call Ipx(oSx,Iix)call Iqx(oSx,Iix)endfunctionfunction ISx takes integer oSx,integer o5x returns nothingcall rnx((oSx),vc,o5x)call Isx(o5x,oSx)endfunctionfunction Itx takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((Jc[oSx]))])]))],((((zB[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))endfunctionfunction ITx takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((Jc[oSx]))])]))],((((zB[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))endfunctionfunction Iux takes integer oSx,integer Iax,integer rYx returns nothinglocal integer rLx=oSxlocal integer IUx=rRx((zB[(Iax)]))local integer rFxlocal integer oMxlocal integer rbxlocal integer rMxset hc[(IUx)]=(rYx)set Hc[(IUx)]=(Iax)set Vv[(IUx)]=(rLx)set rFx=rRx((A[(rLx)]))set hc[(rFx)]=(rYx)set Hc[(rFx)]=(Iax)set Vv[(rFx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,jc,rbx)loop
exitwhen(rMx<q)call rfx(rgx(rLx,jc,rbx,rMx),rFx)set rMx=rMx-1endloopset rMx=Itx(Iax,jc,rbx)loop
exitwhen(rMx<q)call rfx(ITx(Iax,jc,rbx,rMx),IUx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((IUx)))call rkx(((rFx)))endfunctionfunction Iwx takes integer oSx,integer Iax,integer rYx returns nothinglocal integer IWx=(IVx(((Iax)),ZB+(rYx)))if(IWx!=w)thencall ISx((oSx),IWx)endifcall Iux(oSx,Iax,rYx)endfunctionfunction Iyx takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((YB[(oSx)]))])]))],((((zB[((oSx))])))),(((otx))))))endfunctionfunction IYx takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((YB[(oSx)]))])]))],((((zB[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction Izx takes integer oSx,integer Iix returns nothinglocal integer oMx=(IEx(((oSx)),oc))local integer Ibxloop
exitwhen(oMx<q)set Ibx=(IXx(((oSx)),oc,(oMx)))call IRx(Iix,Ibx,(IAx(((oSx)),ac+(Ibx))))set oMx=oMx-1endloopendfunctionfunction IZx takes integer oSx,integer Iix returns nothinglocal integer oMx=(IEx(((oSx)),nc))local integer Ibxloop
exitwhen(oMx<q)set Ibx=(IXx(((oSx)),nc,(oMx)))call Icx(Iix,Ibx,(ICx(((oSx)),Ec+(Ibx))))set oMx=oMx-1endloopendfunctionfunction I_x takes integer oSx,integer Iix returns nothinglocal integer oMx=(IEx(((oSx)),Xc))local integer Ibxlocal integer rFxloop
exitwhen(oMx<q)set Ibx=(IXx(((oSx)),Xc,(oMx)))set rFx=ILx(oSx,Ibx)
call Imx(Ibx,Iix,rFx,true)call rkx(((rFx)))set oMx=oMx-1endloopendfunctionfunction I0x takes integer oSx,integer Iix returns nothinglocal integer rFx=rRx(0)
set Vv[(rFx)]=(Iix)set Fc[(rFx)]=(oSx)call XGx((lc[(oSx)]),rFx)call rkx(((rFx)))endfunctionfunction I1x takes integer oSx,integer Iix returns nothinglocal integer oMx=(IEx(((oSx)),fc))local integer IQxloop
exitwhen(oMx<q)set IQx=(IXx(((oSx)),fc,(oMx)))call I0x(IQx,Iix)set oMx=oMx-1endloopendfunctionfunction I2x takes integer oSx,integer Iix returns nothingcall Izx(oSx,Iix)call IZx(oSx,Iix)call I_x(oSx,Iix)call I1x(oSx,Iix)endfunctionfunction I3x takes integer oSx,integer o5x returns nothingcall rUx((oSx),vc,o5x)call I2x(o5x,oSx)endfunctionfunction I4x takes integer oSx,integer Iax,integer I5x,integer rYx,integer I6x returns nothinglocal integer IUx=rRx((zB[(Iax)]))local integer oMxlocal integer rbxlocal integer rMxset Lc[(IUx)]=(I6x)set hc[(IUx)]=(rYx)set mc[(IUx)]=(I5x)set Hc[(IUx)]=(Iax)set Vv[(IUx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=Itx(Iax,Mc,rbx)loop
exitwhen(rMx<q)call rfx(ITx(Iax,Mc,rbx,rMx),IUx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((IUx)))endfunctionfunction I7x takes integer oSx,integer Iax,integer I5x,integer rYx,integer I6x returns nothinglocal integer IWx=(IVx(((Iax)),ZB+(I5x)))if(IWx!=w)thencall ISx((oSx),IWx)endifset IWx=(IVx(((Iax)),ZB+(rYx)))if(IWx!=w)thencall I3x((oSx),IWx)endifcall I4x(oSx,Iax,I5x,rYx,I6x)endfunctionfunction I8x takes integer oSx,integer otx,integer oux returns booleanreturn((LoadInteger(o[((D[((nb[(oSx)]))]))],((((Vb[((oSx))])))),(oTx(((otx)),(((oux)))))))!=0)endfunctionfunction I9x takes integer oSx,integer rNx returns booleanreturn(I8x((qc[(rNx)]),Ob,(oSx)))endfunctionfunction Avx takes integer oSx,integer XYx returns nothingif(Rv[oSx]==w)thencall o_x("FolderUnit_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oSx)+";"+(jA[(XYx)]))set Rv[oSx]=Xendifcall rux(Rv[oSx],(A[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction Aex takes integer oSx,integer otx,integer oux returns booleanlocal integer aCx=osx(oSx,otx)call rwx(oSx,otx,aCx+oux)if(aCx!=0)thenreturn false
endifreturn(oux!=0)endfunctionfunction Axx takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((YB[(oSx)]))])]))],((((zB[((oSx))])))),(((otx))))))endfunctionfunction Aox takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx returns integerreturn Rhx(E[(oSx)],BO[oSx],RCx,Rdx,RDx,Rgx,0)endfunctionfunction Arx takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer oux returns integerreturn Rhx(E[(oSx)],dO[oSx],RCx,Rdx,RDx,Rgx,(oux))endfunctionfunction Aix takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer Rmx,integer oux returns booleanlocal integer RLxif(Rmx==0)thenset RLx=Rjx(oSx,RCx,Rdx,RDx,Rgx)
call RKx(E[(oSx)],bO[oSx],RCx,Rdx,RDx,Rgx,0,oux)
else
set RLx=RJx(oSx,RCx,Rdx,RDx,Rgx,Rmx)
call RKx(E[(oSx)],cO[oSx],RCx,Rdx,RDx,Rgx,(Rmx),oux)
endifif(RLx==0)thencall RKx(E[(oSx)],BO[oSx],RCx,Rdx,RDx,Rgx,0,oux)
else
call RKx(E[(oSx)],CO[oSx],RCx,Rdx,RDx,Rgx,(RLx),oux)
endifcall RKx(E[(oSx)],cO[oSx],RCx,Rdx,RDx,Rgx,(oux),RLx)
call RKx(E[(oSx)],CO[oSx],RCx,Rdx,RDx,Rgx,(oux),Rmx)
return trueendfunctionfunction Aax takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer oux,integer Anx returns booleanlocal integer AVx=Aox(oSx,RCx,Rdx,RDx,Rgx)loop
exitwhen(AVx==0)
exitwhen(Anx<=Arx(oSx,RCx,Rdx,RDx,Rgx,AVx))set AVx=Rkx(oSx,RCx,Rdx,RDx,Rgx,AVx)
endloopif not Aix(oSx,RCx,Rdx,RDx,Rgx,AVx,oux)thenreturn false
endifcall RKx(E[(oSx)],dO[oSx],RCx,Rdx,RDx,Rgx,(oux),Anx)
return trueendfunctionfunction AEx takes integer oSx returns integerset cB[oSx]=true
set rB[oSx]=falseset CB[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set nB[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(dB)
return oSxendfunctionfunction AXx takes nothing returns integerlocal integer oSxif(tc==8190)then
call o_x("UnitEffect_Allocation_allocCustom","call DebugEx(UnitEffect.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",BB+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(bB[(w)]==w)thenset Tc=Tc+1set oSx=Tcelse
set oSx=bB[(w)]set bB[(w)]=bB[bB[(w)]]endifset bB[oSx]=Zset NB[oSx]=1call AEx(oSx)return oSxendfunctionfunction AOx takes integer oSx returns nothingset iB[(oSx)]=(xC+oSx)endfunctionfunction ARx takes integer oSx,integer XYx returns nothingif(nB[oSx]==w)thencall o_x("FolderUnitEffect_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oSx)+";"+(jA[(XYx)]))
set nB[oSx]=Xendifcall rux(nB[oSx],(iB[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction AIx takes integer oSx returns booleanset AB=AB+1set IB[AB]=oSxset RB[oSx]=AB+1
return(AB==0)endfunctionfunction AAx takes integer OSx,string ANx,string Abx,integer rYx returns integer
local boolean ABx=I9x(OSx,Qc)local integer oSx=AXx()set uc[oSx]=Abxset Uc[oSx]=ABxset EB[oSx]=true
set XB[oSx]=null
set wc[oSx]=rYxset Wc[oSx]=ANxset OB[oSx]=null
set yc[oSx]=OSxif rUx(OSx,Yc,oSx)thenif ABx thencall Avx(OSx,zc)
else
call Avx(OSx,Zc)
endifcall Avx(OSx,vC)
call Avx(OSx,eC)
endifcall AOx(oSx)call ARx(oSx,oC)
call AIx(oSx)return oSxendfunctionfunction Acx takes integer oSx returns nothingif not EB[oSx]thenreturnendifset EB[oSx]=falseif(ci>=wc[oSx])thenset OB[oSx]=AddSpecialEffectTarget(Wc[oSx],C[yc[oSx]],uc[oSx])if(OB[oSx]==null)thenendifelse
set XB[oSx]=AddSpecialEffectTarget(null,C[yc[oSx]],uc[oSx])endifendfunctionfunction ACx takes integer OSx,string ANx,string Abx,integer rYx returns integer
local boolean Adx=I9x(OSx,Qc)local integer oSx=AAx(OSx,ANx,Abx,rYx)if not Adx thencall Acx(oSx)endifreturn oSxendfunctionfunction ADx takes integer oSx,integer otx,integer oLx returns stringreturn(LoadStr(o[((V[(E[((YB[(oSx)]))])]))],((((zB[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction Afx takes integer oSx returns integerset PB[oSx]=true
set EC[oSx]=falsecall rEx(qB)
return oSxendfunctionfunction AFx takes nothing returns integerlocal integer oSxif(nC==8190)then
call o_x("UnitSound_Allocation_allocCustom","call DebugEx(UnitSound.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",pB+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(MB[(w)]==w)thenset VC=VC+1set oSx=VCelse
set oSx=MB[(w)]set MB[(w)]=MB[MB[(w)]]endifset MB[oSx]=Zset mB[oSx]=1call Afx(oSx)return oSxendfunctionfunction Agx takes integer oSx returns integerset kB[oSx]=true
set fB[oSx]=falsecall rEx(KB)
return oSxendfunctionfunction AGx takes nothing returns integerlocal integer oSxif(XC==8190)then
call o_x("Sound_Allocation_allocCustom","call DebugEx(Sound.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",JB+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(jB[(w)]==w)thenset OC=OC+1set oSx=OCelse
set oSx=jB[(w)]set jB[(w)]=jB[jB[(w)]]endifset jB[oSx]=Zset GB[oSx]=1call Agx(oSx)return oSxendfunctionfunction Ahx takes integer oSx,integer o5x returns nothingset AC[(oSx)]=(o5x)if(FB[oSx]!=null)thencall SetSoundChannel(FB[oSx],o5x)endifendfunctionfunction AHx takes integer oSx returns nothinglocal string Ajx=(ed[((bC[(oSx)]))])
if(Ajx==null)thenset Ajx=""endifset FB[oSx]=CreateSound((RC[(oSx)]),(lB[(oSx)]),(LC[(oSx)]),(KC[(oSx)]),(R2I((((hC[(oSx)]))*1.))),(R2I((((jC[(oSx)]))*1.))),Ajx)
endfunctionfunction AJx takes integer rNx returns integerlocal integer oSx=AGx()set gB[oSx]=wset RC[(oSx)]=((IC[(rNx)]))call Ahx(oSx,(NC[(rNx)]))set bC[(oSx)]=((BC[(rNx)]))set cC[(oSx)]=(((CC[(rNx)]))*1.)
set dC[(oSx)]=(((DC[(rNx)]))*1.)
set fC[(oSx)]=((FC[(rNx)]))set gC[(oSx)]=(((GC[(rNx)]))*1.)
set hC[(oSx)]=(((HC[(rNx)]))*1.)
set jC[(oSx)]=(((JC[(rNx)]))*1.)
set lB[(oSx)]=((kC[(rNx)]))set KC[(oSx)]=((lC[(rNx)]))set LC[(oSx)]=((mC[(rNx)]))set MC[(oSx)]=(((pC[(rNx)]))*1.)
set PC[(oSx)]=(((qC[(rNx)]))*1.)
set QC[(oSx)]=(((sC[(rNx)]))*1.)
set SC[(oSx)]=(((tC[(rNx)]))*1.)
set TC[(oSx)]=(((uC[(rNx)]))*1.)
set UC[(oSx)]=(((wC[(rNx)]))*1.)
set WC[(oSx)]=(((yC[(rNx)]))*1.)
set YC[(oSx)]=(((zC[(rNx)]))*1.)
set ZC[(oSx)]=(((vd[(rNx)]))*1.)
call AHx(oSx)return oSxendfunctionfunction Akx takes integer oSx returns nothingcall SetSoundVolume(FB[oSx],(R2I(((gC[oSx]*(xd[((AC[(oSx)]))])*od*127.)*1.))))call StartSound(FB[oSx])
endfunctionfunction AKx takes integer oSx,integer Iix returns nothingcall AttachSoundToUnit(FB[oSx],C[Iix])call Akx(oSx)endfunctionfunction Alx takes integer OSx,integer ALx returns integerlocal integer oSx=AFx()local integer Amx=AJx(ALx)set LB[oSx]=Amxcall AKx(Amx,OSx)return oSxendfunctionfunction AMx takes integer oSx returns integerset WB[oSx]=true
set Vd[oSx]=falsecall rEx(yB)
return oSxendfunctionfunction Apx takes nothing returns integerlocal integer oSxif(ad==8190)then
call o_x("BuffRef_Allocation_allocCustom","call DebugEx(BuffRef.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",wB+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(UB[(w)]==w)thenset nd=nd+1set oSx=ndelse
set oSx=UB[(w)]set UB[(w)]=UB[UB[(w)]]endifset UB[oSx]=Zset uB[oSx]=1call AMx(oSx)return oSxendfunctionfunction APx takes integer oSx,integer Iax,integer rYx,integer I6x returns nothingset Od=oSxset Rd=Iaxset Id=rYxset Ad=I6xcall TriggerEvaluate(Nd)
endfunctionfunction Aqx takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx returns integerlocal integer oux=Rjx(oSx,RCx,Rdx,RDx,Rgx)local integer o7x=0local integer Anxloop
exitwhen(oux==0)
set Anx=Arx(oSx,RCx,Rdx,RDx,Rgx,oux)
if(Anx>o7x)thenset o7x=Anxendifset oux=RJx(oSx,RCx,Rdx,RDx,Rgx,oux)
endloopreturn o7xendfunctionfunction AQx takes integer Iax,integer rYx,integer Iix,integer I6x returns integerlocal integer oSx=Apx()set Ed[oSx]=I6xset TB[oSx]=falseset Xd[oSx]=rYxset sB[oSx]=0set SB[oSx]=Iixset tB[oSx]=Iaxcall Aax(X,QB,Iix,Iax,w,oSx,rYx)
call APx(Iix,Iax,Aqx(X,QB,Iix,Iax,w),I6x)return oSxendfunctionfunction Asx takes integer oSx,integer Iax,integer rYx,integer I6x returns integerlocal integer ASx=AQx(Iax,rYx,oSx,I6x)return ASxendfunctionfunction Atx takes integer oSx,integer Iax,integer rYx,integer I6x returns nothinglocal integer oMx=(Iyx(((Iax)),rd))loop
exitwhen(oMx<q)call Aax((X),(Kc),(oSx),(Iax),(w),(Asx(oSx,(IYx(((Iax)),rd,(oMx))),rYx,I6x)),0)set oMx=oMx-1endloopendfunctionfunction ATx takes integer oSx,integer Iax,integer rYx,integer I6x returns nothinglocal integer IUx=rRx((zB[(Iax)]))local integer oMxlocal integer rbxlocal integer rMxset Lc[(IUx)]=(I6x)set hc[(IUx)]=(rYx)set Hc[(IUx)]=(Iax)set Vv[(IUx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=Itx(Iax,bd,rbx)loop
exitwhen(rMx<q)call rfx(ITx(Iax,bd,rbx,rMx),IUx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((IUx)))endfunctionfunction Aux takes integer oSx,integer Iax,integer rYx,integer I6x returns nothinglocal integer IWx=(IVx(((Iax)),ZB+(rYx)))if(IWx!=w)thencall I3x((oSx),IWx)endifcall ATx(oSx,Iax,rYx,I6x)endfunctionfunction AUx takes integer oSx,integer Iax,integer rYx,integer I6x returns booleanlocal integer I5xlocal integer Awxlocal integer oMxif(osx((((oSx))),(Wb+(Iax)))>0)thenset I5x=(osx(((oSx)),Yb+(Iax)))if(rYx!=I5x)then
call rwx((oSx),Yb+Iax,rYx)call I7x(oSx,Iax,I5x,rYx,I6x)endifreturn false
endifif(pc[((oSx))])thenreturn false
endifif((Pc[(Iax)])and I9x((oSx),Qc))then
return false
endifif rUx((oSx),vB,Iax)then
call Avx((oSx),eB)call Avx((oSx),xB)endifcall Aex((oSx),Wb+Iax,1)
call rwx((oSx),Yb+Iax,rYx)set Awx=(yb[(Iax)])if(Awx!=0)thencall rtx((oSx),Awx)call rZx((oSx),Awx,rYx)endifif(sc[(Iax)])thenset oMx=(Axx(((Iax)),Sc))loop
exitwhen(oMx<q)call Aax((X),(oB),(oSx),(Iax),(w),((ACx(((oSx)),((ADx(((Iax)),Sc,(oMx)))),((ADx(((Iax)),rC,(oMx)))),((IYx(((Iax)),iC,(oMx))))))),0)set oMx=oMx-1endloopendifset oMx=(Axx(((Iax)),aC))loop
exitwhen(oMx<q)call Aax((X),(DB),(oSx),(Iax),(w),((Alx(((oSx)),((IYx(((Iax)),aC,(oMx))))))),0)set oMx=oMx-1endloopcall Atx(oSx,Iax,rYx,I6x)call Aux(oSx,Iax,rYx,I6x)return trueendfunctionfunction AWx takes integer oSx,integer Iax returns booleanset Od=oSxset Rd=Iaxcall TriggerEvaluate(cd)
return Bdendfunctionfunction Ayx takes integer oSx,integer Iax,integer rYx,integer I6x returns nothinglocal integer I5x=(osx(((oSx)),Yb+(Iax)))if(I5x==rYx)then
returnendifif(rYx>0)thencall AUx(oSx,Iax,rYx,I6x)else
call AWx(oSx,Iax)endifendfunctionfunction AYx takes integer oSx returns nothingif TB[oSx]thenreturnendifcall Irx(oSx)call Ayx(SB[oSx],tB[oSx],Aqx(X,QB,SB[oSx],tB[oSx],w),Ed[oSx])endfunctionfunction Azx takes integer oSx,integer Iax returns nothinglocal integer ASx=RMx(X,Kc,oSx,Iax,w)loop
exitwhen(ASx==w)
call AYx(ASx)set ASx=RMx(X,Kc,oSx,Iax,w)endloopendfunctionfunction AZx takes integer oSx,integer Iax returns booleanlocal integer Awxlocal integer rYxlocal integer A_xlocal integer A0xlocal integer oMxif not(osx((((oSx))),(Wb+(Iax)))>0)thenreturn false
endifset Awx=(yb[(Iax)])set rYx=(osx(((oSx)),Yb+(Iax)))if(Awx!=0)thencall UnitRemoveAbility(C[(((oSx)))],(Awx))call UnitRemoveAbility(C[(((oSx)))],(zb[Iax]))endifcall rVx((oSx),Wb+Iax)call rVx((oSx),Yb+Iax)call Rpx(X,Zb,oSx,Iax,w)
if rnx((oSx),vB,Iax)then
call RPx((oSx),eB)call RPx((oSx),xB)endifset A_x=RMx(X,oB,oSx,Iax,w)loop
exitwhen(A_x==w)
call Ryx(A_x)set A_x=RMx(X,oB,oSx,Iax,w)endloopset A0x=RMx(X,DB,oSx,Iax,w)loop
exitwhen(A0x==w)
call R9x(A0x)set A0x=RMx(X,DB,oSx,Iax,w)endloopcall Inx(Iax,oSx)call Iwx(oSx,Iax,rYx)set oMx=(Iyx(((Iax)),kc))loop
exitwhen(oMx<q)call AZx(oSx,(IYx(((Iax)),kc,(oMx))))set oMx=oMx-1endloopcall Azx(oSx,Iax)return trueendfunctionfunction A1x takes integer oSx returns integerset Gd[oSx]=true
set hd[oSx]=falsecall rEx(Hd)
return oSxendfunctionfunction A2x takes nothing returns integerlocal integer oSxif(dd==8190)then
call o_x("FolderUnit_FolderBuffs_StructTimed_Allocation_allocCustom","call DebugEx(FolderUnit_FolderBuffs_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Dd+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(fd[(w)]==w)thenset Fd=Fd+1set oSx=Fdelse
set oSx=fd[(w)]set fd[(w)]=fd[fd[(w)]]endifset fd[oSx]=Zset gd[oSx]=1call A1x(oSx)return oSxendfunctionfunction A3x takes integer oSx returns nothingset Gd[oSx]=falsecall rHx(Hd)
endfunctionfunction A4x takes integer oSx returns nothingif(gd[oSx]>0)thenreturnendifif(fd[oSx]!=Z)thencall o_x("FolderUnit_FolderBuffs_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderBuffs_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Dd+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset fd[oSx]=fd[(w)]set fd[(w)]=oSxcall A3x(oSx)endfunctionfunction A5x takes integer oSx returns nothingset gd[oSx]=gd[oSx]-1call A4x(oSx)endfunctionfunction A6x takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer RGx returns nothingcall SaveInteger(o[(((EO[oSx])))],((Rcx(RCx,Rdx,RDx))),((RFx(RCx,Rgx,RGx))),(0))
endfunctionfunction A7x takes integer oSx returns nothingset Pd[oSx]=falsecall rHx(qd)
endfunctionfunction A8x takes integer oSx returns nothingif(md[oSx]>0)thenreturnendifif(Md[oSx]!=Z)thencall o_x("FolderUnit_FolderBuffs_FolderTimed_StructCountdown_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderBuffs_FolderTimed_StructCountdown.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",pd+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Md[oSx]=Md[(w)]set Md[(w)]=oSxcall A7x(oSx)endfunctionfunction A9x takes integer oSx returns nothingset md[oSx]=md[oSx]-1call A8x(oSx)endfunctionfunction Nvx takes integer oSx,integer iCx,integer rLx returns nothinglocal integer Nex=ld[oSx]local integer Iax=Ld[oSx]call A9x((oSx))call iKx(Nex)call iKx(iCx)if rnx(rLx,Qd,oSx)thencall RPx(rLx,sd)
endifcall rVx(rLx,Kd+Iax)
endfunctionfunction Nxx takes integer oSx,integer Iax returns nothinglocal integer rLx=oSxset oSx=osx(rLx,Kd+Iax)if(oSx!=w)thencall Nvx(oSx,Sd[oSx],rLx)endifendfunctionfunction Nox takes integer oSx returns nothingset sB[oSx]=sB[oSx]-1endfunctionfunction Nrx takes integer oSx returns nothinglocal integer iCx=jd[oSx]local integer rLx=Jd[oSx]local integer Nix=kd[oSx]local integer rYx=Xd[Nix]local integer Iax=tB[Nix]call A5x((oSx))call iKx(iCx)call A6x(E[((X))],(Cd),(rLx),(Iax),(rYx),(w))call Nxx((rLx),Iax)if rnx(rLx,td,oSx)thencall RPx(rLx,Td)
call RPx(rLx,ud)
endifcall AYx(Nix)call Nox(Nix)endfunctionfunction Nax takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])call Nrx(oSx)endfunctionfunction Nnx takes integer oSx returns nothingset sB[oSx]=sB[oSx]+1endfunctionfunction NVx takes integer oSx returns integerset Pd[oSx]=true
set Zd[oSx]=falsecall rEx(qd)
return oSxendfunctionfunction NEx takes nothing returns integerlocal integer oSxif(Yd==8190)then
call o_x("FolderUnit_FolderBuffs_FolderTimed_StructCountdown_Allocation_allocCustom","call DebugEx(FolderUnit_FolderBuffs_FolderTimed_StructCountdown.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",pd+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Md[(w)]==w)thenset zd=zd+1set oSx=zdelse
set oSx=Md[(w)]set Md[(w)]=Md[Md[(w)]]endifset Md[oSx]=Zset md[oSx]=1call NVx(oSx)return oSxendfunctionfunction NXx takes nothing returns nothingendfunctionfunction NOx takes integer oSx returns nothinglocal integer rvx=vD[oSx]local boolean NRx=eD[oSx]if NRx thenset eD[oSx]=falsecall Oqx(xD[oSx],iSx((oD[(Ld[oSx])])+" vanishes in "+"
"+(I2S((rvx))),"ff00ffff"),.022,120.,1.,2.,(0))else
call Oqx(xD[oSx],iSx((I2S((rvx))),"ff00ffff"),.022,120.,1.,2.,(0))endifset vD[oSx]=rvx-1endfunctionfunction NIx takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])call Nvx(oSx,iCx,xD[oSx])endfunctionfunction NAx takes integer oSx,integer Iax,real iMx returns nothinglocal integer rLx=oSxlocal integer rvxlocal integer Nexlocal integer iCxlocal real NNxset oSx=osx(rLx,Kd+Iax)if(oSx!=w)thencall Nvx(oSx,Sd[oSx],rLx)endifset rvx=(R2I(((iUx(((R2I(((iMx)*1.)))),(3)))*1.)))set Nex=iXx()set iCx=iXx()set oSx=NEx()set NNx=iMx-rvx-1.set vD[oSx]=rvxset ld[oSx]=Nexset Sd[oSx]=iCxset eD[oSx]=true
set xD[oSx]=rLxset Ld[oSx]=Iaxset ge[(Nex)]=(oSx)set ge[(iCx)]=(oSx)if rUx(rLx,Qd,oSx)thencall Avx(rLx,sd)
endifcall rwx(rLx,Kd+Iax,oSx)
call iDx(Nex,NNx,false,function NXx)
if(NNx<.0)thencall NOx(oSx)endifcall iDx(iCx,iMx-1+.01,false,function NIx)endfunctionfunction Nbx takes integer oSx,integer Iax,integer rYx,integer I6x,real iMx returns integerlocal integer rLx=oSxlocal integer iCxlocal integer Nixset oSx=(IGx(E[((X))],(Cd),((oSx)),((Iax)),((rYx)),(w)))
if(oSx==w)thenset Nix=Asx(rLx,Iax,rYx,I6x)
if(Nix==w)thenreturn w
endifset iCx=iXx()set oSx=A2x()set jd[oSx]=iCxset Jd[oSx]=rLxset kd[oSx]=Nixset ge[(iCx)]=(oSx)call Igx(E[((X))],(Cd),(rLx),(Iax),(rYx),(w),(oSx))call iDx(iCx,iMx,false,function Nax)
if rUx(rLx,td,oSx)thencall Avx(rLx,Td)
call Avx(rLx,ud)
endifcall Nnx(Nix)else
set iCx=jd[oSx]if(iMx>(TimerGetRemaining(Oe[(iCx)])))thencall iDx(iCx,iMx,false,function Nax)
endifreturn w
endifif not(Ud[(Iax)])thenif(iMx!=wd)thenif(I9x(rLx,Wd)or(yd[(Iax)]))then
call NAx((rLx),Iax,iMx)endifendifendifreturn Nixendfunctionfunction NBx takes integer oSx,integer Iax,integer rYx,integer I6x,real iMx returns integerreturn Nbx(oSx,Iax,rYx,I6x,iMx)endfunctionfunction Ncx takes nothing returns booleanlocal integer rFx=(bv)if(ub==0)thencall AZx(ROx(),Ub)return trueendifif(wb==0)thencall Ayx(ROx(),Ub,ub,w)else
call NBx(ROx(),Ub,ub,w,wb)endifreturn trueendfunctionfunction NCx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])local string Ndx=Xsx(r4x,1)local integer Iax=RBx(Ndx)local integer rYx=(S2I((Xsx(r4x,2))))local real iMx=(S2R((Xsx(r4x,3))))if(Iax==w)thenset Iax=XDx(Ndx,F)if(Iax==F)thencall o_x("CommandBuff_Event_Chat","call DebugEx(\"invalid buff\")","invalid buff")return trueendifendifset ub=rYxset Ub=Iaxset wb=iMxcall Rvx(oDx,function Ncx)return trueendfunctionfunction NDx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oMx=rD
local integer oDx=(ZA[(rFx)])call PreloadGenStart()loop
exitwhen(oMx<0)call o_x("CommandBuff_Event_ListAll_Chat","call DebugEx(Buff.ALL[iteration].GetName())",(oD[(iD[oMx])]))
set oMx=oMx-1endloopreturn trueendfunctionfunction Nfx takes nothing returns booleancall Xzx("-buff",function NCx)call Xzx("-buffListAll",function NDx)return trueendfunctionfunction NFx takes nothing returns booleancall Xxx(function Nfx,"CommandBuff_Init")return trueendfunctionfunction Ngx takes nothing returns booleanset aD=VXx(nD)return trueendfunctionfunction NGx takes integer oSx returns integerset ID[oSx]=true
set AD[oSx]=falsecall rEx(ND)
return oSxendfunctionfunction Nhx takes nothing returns integerlocal integer oSxif(VD==8190)then
call o_x("FolderCamera_StructSeismic_Allocation_allocCustom","call DebugEx(FolderCamera_StructSeismic.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",ED+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(XD[(w)]==w)thenset OD=OD+1set oSx=ODelse
set oSx=XD[(w)]set XD[(w)]=XD[XD[(w)]]endifset XD[oSx]=Zset RD[oSx]=1call NGx(oSx)return oSxendfunctionfunction NHx takes integer oSx returns integerset kD[oSx]=true
set KD[oSx]=falsecall rEx(lD)
return oSxendfunctionfunction Njx takes nothing returns integerlocal integer oSxif(GD==8190)then
call o_x("Force_Allocation_allocCustom","call DebugEx(Force.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",hD+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(HD[(w)]==w)thenset jD=jD+1set oSx=jDelse
set oSx=HD[(w)]set HD[(w)]=HD[HD[(w)]]endifset HD[oSx]=Zset JD[oSx]=1call NHx(oSx)return oSxendfunctionfunction NJx takes nothing returns integerlocal integer oSxif(gD==F)thenset oSx=Njx()set LD[oSx]=CreateForce()return oSxendifset oSx=mD[gD]set gD=gD-1return oSxendfunctionfunction Nkx takes real NKx,real Nlx,real NLx returns reallocal real o7xif(NLx==.0)thenif(Nlx==.0)thenif(NKx==.0)thenreturn .0endifreturn-1.endifreturn(NKx*1./ Nlx)endifset o7x=-Nlx*1./ NLx-(SquareRoot(((Nlx*Nlx*1./ NLx*1./ NLx+2*NKx*1./ NLx)*1.)))if(o7x<.0)thenreturn(-Nlx*1./ NLx+(SquareRoot(((Nlx*Nlx*1./ NLx*1./ NLx+2*NKx*1./ NLx)*1.))))endifreturn o7xendfunctionfunction Nmx takes integer oSx returns nothingset gD=gD+1set mD[gD]=oSxcall ForceClear(LD[oSx])
endfunctionfunction NMx takes integer oSx returns nothingset ID[oSx]=falsecall rHx(ND)
endfunctionfunction Npx takes integer oSx returns nothingif(RD[oSx]>0)thenreturnendifif(XD[oSx]!=Z)thencall o_x("FolderCamera_StructSeismic_Allocation_deallocCustom_confirm","call DebugEx(FolderCamera_StructSeismic.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",ED+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset XD[oSx]=XD[(w)]set XD[(w)]=oSxcall NMx(oSx)endfunctionfunction NPx takes integer oSx returns nothingset RD[oSx]=RD[oSx]-1call Npx(oSx)endfunctionfunction Nqx takes integer oSx returns booleanif(((qD[((oSx))])>0)==false)then
return false
endifset qD[QD[sD]]=qD[oSx]set QD[qD[oSx]-1]=QD[sD]
set qD[oSx]=0set sD=sD-1return(sD==F)endfunctionfunction NQx takes integer oSx returns nothinglocal integer iCx=bD[oSx]local integer Nsx=FD[oSx]call iKx(iCx)call Nmx(Nsx)call NPx((oSx))if Nqx(oSx)thencall ikx(SD)
endifendfunctionfunction NSx takes nothing returns nothinglocal integer oSx=(ge[(iGx())])call NQx(oSx)endfunctionfunction Ntx takes integer oSx returns booleanif((qD[((oSx))])>0)thenreturn false
endifset sD=sD+1set QD[sD]=oSxset qD[oSx]=sD+1
return(sD==0)endfunctionfunction NTx takes nothing returns nothingcall TriggerExecute(tD)endfunctionfunction Nux takes real x,real y,real z,real NUx,real Nwx,real NWx,real Nlx returns nothinglocal integer oSx=Nhx()local integer iCx=iXx()set bD[oSx]=iCxset BD[oSx]=NWxset cD[oSx]=.0set CD[oSx]=Nlx*dDset DD[oSx]=NUxset fD[oSx]=Nwxset FD[oSx]=NJx()set MD[oSx]=xset pD[oSx]=yset PD[oSx]=zset ge[(iCx)]=(oSx)call iDx(iCx,Nkx(NWx,Nlx,.0),false,function NSx)
if Ntx(oSx)thencall iDx(SD,dD,true,function NTx)endifendfunctionfunction Nyx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])local real x=(S2R((Xsx(r4x,1))))
local real y=(S2R((Xsx(r4x,2))))
local real z=(S2R((Xsx(r4x,3))))
local real NUx=(S2R((Xsx(r4x,4))))local real Nwx=(S2R((Xsx(r4x,5))))local real NWx=(S2R((Xsx(r4x,6))))local real Nlx=(S2R((Xsx(r4x,7))))if(NUx==.0)thenset NUx=1000.endifif(NWx==.0)thenset NWx=99999.endifif(Nlx==.0)thenset Nlx=1000.endifcall Nux(x,y,z,NUx,Nwx,NWx,Nlx)return trueendfunctionfunction NYx takes integer Nzx returns integerlocal integer oSxif((Nzx<0)or(Nzx>16-1))thencall o_x("User_GetFromNativeIndex","call DebugEx(User.NAME + \"GetFromNativeIndex: \" + Integer.ToString(nativeIndex) + \" out of bounds\")",TD+"GetFromNativeIndex: "+(I2S((Nzx)))+" out of bounds")return w
endifset oSx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((Player(Nzx))))))),((((R))))))if(oSx==w)thencall o_x("User_GetFromNativeIndex","call DebugEx(User.NAME + \"GetFromNativeIndex: \" + Integer.ToString(nativeIndex) + \" not assigned\")",TD+"GetFromNativeIndex: "+(I2S((Nzx)))+" not assigned")return w
endifreturn oSxendfunctionfunction NZx takes integer oSx returns booleanif((WD[((oSx))])>0)thenreturn false
endifset yD=yD+1set YD[yD]=oSxset WD[oSx]=yD+1
return(yD==0)endfunctionfunction N_x takes integer oSx returns booleanif(((af[((oSx))])>0)==false)then
return false
endifset af[nf[Vf]]=af[oSx]set nf[af[oSx]-1]=nf[Vf]
set af[oSx]=0set Vf=Vf-1return(Vf==F)endfunctionfunction N0x takes integer oDx returns nothingif iOx(oDx)thencall SetCameraBounds(eE,iE,xE,aE,oE,nE,rE,VE)endifendfunctionfunction N1x takes nothing returns nothinglocal integer oSx=(ge[(iGx())])local integer oDx=oSxset rf[oSx]=falseif N_x(oSx)thencall ikx(Ef)
endifcall N0x(oDx)endfunctionfunction N2x takes integer oSx returns booleanif((af[((oSx))])>0)thenreturn false
endifset Vf=Vf+1set nf[Vf]=oSxset af[oSx]=Vf+1
return(Vf==0)endfunctionfunction N3x takes nothing returns nothinglocal integer i=Vflocal integer oSxlocal integer oDxloop
exitwhen(i<0)set oSx=nf[i]set oDx=oSxif iOx(oDx)thencall N0x(oDx)endifset i=i-1endloopcall iDx(iGx(),.03,false,Af)
endfunctionfunction N4x takes nothing returns nothinglocal integer i=Vflocal integer oSxlocal integer oDxlocal real N5xlocal real N6xlocal real x
local real y
loop
exitwhen(i<0)set oSx=nf[i]set oDx=oSxset N5x=vf[oSx]set N6x=xf[oSx]set x=(GetCameraTargetPositionX())+N5xset y=(GetCameraTargetPositionY())+N6xif iOx(oDx)thenif(Xf[(oDx)])thenset x=x-6000*efendifif(Of[(oDx)])thenset x=x+6000*efendifif(Rf[(oDx)])thenset y=y-6000*efendifif(If[(oDx)])thenset y=y+6000*efendifendifif iOx(oDx)thencall SetCameraBounds(x,y,x,y,x,y,x,y)endifset i=i-1endloopcall iDx(iGx(),.03,false,function N3x)endfunctionfunction N7x takes integer oDx,real x,real y,real iMx returns nothinglocal real dX=x-(GetCameraTargetPositionX())
local real dY=y-(GetCameraTargetPositionY())
local integer oSx=oDxset vf[oSx]=dX*ef*1./ iMxset xf[oSx]=dY*ef*1./ iMxcall iDx(of[oSx],iMx,false,function N1x)
if rf[oSx]thenreturnendifset rf[oSx]=true
if N2x(oSx)thencall iDx(Ef,ef,true,function N4x)endifendfunctionfunction N8x takes integer oSx returns booleanif(((WD[((oSx))])>0)==false)then
return false
endifset WD[YD[yD]]=WD[oSx]set YD[WD[oSx]-1]=YD[yD]
set WD[oSx]=0set yD=yD-1return(yD==F)endfunctionfunction N9x takes nothing returns nothinglocal integer i=yDlocal integer oSxlocal integer oDxlocal real bvxlocal real bexlocal real nyxlocal real bxxloop
exitwhen(i<0)set oSx=YD[i]set oDx=oSxset bvx=uD[oSx]+UD[oSx]if(bvx<1)thencall N7x(oDx,(GetCameraTargetPositionX())-Nf[oSx],(GetCameraTargetPositionY())-bf[oSx],1.)set Bf[oSx]=.0set uD[oSx]=.0set Nf[oSx]=.0set bf[oSx]=.0if N8x(oSx)thencall ikx(ZD)
endifelse
set bex=(GetRandomReal(((.0)*1.),((Cf)*1.)))
set nyx=Bf[oSx]+.9set bxx=(Sin(((((nyx)*1.))*1.)))
set Bf[oSx]=nyxset uD[oSx]=bvxset Nf[oSx]=(Cos(((((bex)*1.))*1.)))*bxx*bvx
set bf[oSx]=(Sin(((((bex)*1.))*1.)))*bxx*bvx
call N7x(oDx,(GetCameraTargetPositionX())+Nf[oSx],(GetCameraTargetPositionY())+bf[oSx],1.)endifset i=i-1endloopendfunctionfunction box takes integer oDx,real bvx,real iMx returns nothing
local integer oSx=oDxset uD[oSx]=uD[oSx]+bvxset UD[oSx]=UD[oSx]+(-bvx*1./ iMx*wD)if NZx(oSx)thencall iDx(ZD,wD,true,function N9x)endifendfunctionfunction brx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])local real bvx=(S2R((Xsx(r4x,1))))local string bix=Xsx(r4x,2)local real iMx=(S2R((Xsx(r4x,3))))local integer baxif(bix==null)thenset bax=oDxelse
set bax=NYx((S2I((bix))))endifif(bvx==.0)thenset bvx=10.endifif(iMx==.0)thenset iMx=5.endifif(bax!=w)thencall box(oDx,bvx,iMx)endifreturn trueendfunctionfunction bnx takes nothing returns booleancall Xzx("-quake",function Nyx)call Xzx("-shake",function brx)return trueendfunctionfunction bVx takes nothing returns booleancall Xxx(function bnx,"CommandCreateQuake_Init")
return trueendfunctionfunction bEx takes nothing returns booleanset df=VXx(Df)return trueendfunctionfunction bXx takes string rSx returns integerreturn(rPx(lv[(E[((X))])],(((rSx))),(((I2S(((ff))))))))endfunctionfunction bOx takes integer rNx,integer oDx,real x,real y,real bex returns integerset Ff=x
set gf=y
set Gf=bexset hf=oDxset Hf=rNxcall rDx(jf)
return Rbendfunctionfunction bRx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])local integer rNx=bXx(Xsx(r4x,1))local integer bIxlocal string bAx=Xsx(r4x,2)local real x=(S2R((Xsx(r4x,3))))
local real y=(S2R((Xsx(r4x,4))))
if(bAx==null)thenset bIx=oDxelse
set bIx=NYx((S2I((bAx))))endifif(rNx==w)thencall aKx("invalid unit type")return trueendifcall bOx(rNx,bIx,x,y,kf)
return trueendfunctionfunction bNx takes nothing returns booleancall Xzx("-create",function bRx)
return trueendfunctionfunction bbx takes nothing returns booleancall Xxx(function bNx,"CommandCreateUnit_Init")return trueendfunctionfunction bBx takes nothing returns booleanset Kf=VXx(lf)return trueendfunctionfunction bcx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])call o_x("CommandDebug_Event_Chat","call DebugEx(String.Word(input, 1))",Xsx(r4x,1))
return trueendfunctionfunction bCx takes nothing returns booleancall Xzx("-debug",function bcx)return trueendfunctionfunction bdx takes nothing returns booleancall Xxx(function bCx,"CommandDebug_Init")return trueendfunctionfunction bDx takes nothing returns booleanset Lf=VXx(mf)return trueendfunctionfunction bfx takes integer oSx,real oux returns nothingset pf[oSx]=ouxcall SetHeroXP(C[(oSx)],(R2I(((oux)*1.))),false)
endfunctionfunction bFx takes nothing returns booleanlocal integer rFx=(bv)call bfx(ROx(),Mf)return trueendfunctionfunction bgx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])local real o5x=(S2R((Xsx(r4x,1))))set Mf=o5xcall Rvx(oDx,function bFx)return trueendfunctionfunction bGx takes nothing returns booleancall Xzx("-exp",function bgx)return trueendfunctionfunction bhx takes nothing returns booleancall Xxx(function bGx,"CommandExp_Init")
return trueendfunctionfunction bHx takes nothing returns booleanset wI=VXx(sI)return trueendfunctionfunction bjx takes nothing returns booleanset Pf=VXx(qf)return trueendfunctionfunction bJx takes integer oSx returns nothingset Uf[(oSx)]=(((uf[(oSx)])+(wf[(oSx)]))*1.)
endfunctionfunction bkx takes integer oSx,real oux returns nothingset uf[oSx]=ouxcall bJx((oSx))endfunctionfunction bKx takes integer oSx,real oux returns nothingcall bkx(oSx,(uf[(oSx)])+oux)endfunctionfunction blx takes real oux,real bLx,real nYx returns realreturn iUx(iAx(bLx,oux),nYx)
endfunctionfunction bmx takes integer oSx returns nothingset vF[(oSx)]=(((eF[(oSx)])+(Zf[(oSx)]))*1.)
endfunctionfunction bMx takes integer oSx,real oux returns nothingset Zf[oSx]=ouxcall bmx((oSx))endfunctionfunction bpx takes integer oSx,real oux returns nothingcall bMx(oSx,(Zf[(oSx)])+oux)endfunctionfunction bPx takes integer oSx returns nothingset oF[(oSx)]=(((rF[(oSx)])+(xF[(oSx)]))*1.)
endfunctionfunction bqx takes integer oSx,real oux returns nothingset xF[oSx]=ouxcall bPx((oSx))endfunctionfunction bQx takes integer oSx,real oux returns nothingcall bqx(oSx,(xF[(oSx)])+oux)endfunctionfunction bsx takes integer oSx,real oux returns nothinglocal real nYx=(Yf[((oSx))])
local real aCx=(zf[(oSx)])set oux=blx(oux,.0,(Yf[((oSx))]))set zf[oSx]=ouxcall bpx((oSx),oux-aCx)call bQx((oSx),oux-aCx)endfunctionfunction bSx takes integer oSx,real oux returns nothinglocal real aCx=(Yf[(oSx)])set Yf[oSx]=ouxif(aCx==.0)thenreturnendifcall bsx((oSx),(zf[((oSx))])*1./ aCx*oux)endfunctionfunction btx takes integer oSx returns nothingcall bSx(oSx,(yf[(oSx)])*(iF[(oSx)])+(aF[(oSx)]))endfunctionfunction bTx takes integer oSx,real oux returns nothingset yf[oSx]=ouxcall btx((oSx))endfunctionfunction bux takes integer oSx,real oux returns nothingcall bTx(oSx,(yf[(oSx)])+oux)endfunctionfunction bUx takes integer oSx,real nZx returns nothingif((tf[((Tf[((oSx))]))])==1)then
set nZx=1.25*nZx
endifcall bKx((oSx),nZx*Wf)call bux((oSx),nZx*nF)endfunctionfunction bwx takes integer oSx,integer otx returns booleanreturn((LoadInteger(o[((V[(E[((I[(oSx)]))])]))],((((A[((oSx))])))),(((otx)))))==0)endfunctionfunction bWx takes integer a returns integer
if(a>WE)then
return(Vgx((a),(2)))
endifreturn YE[a]
endfunctionfunction byx takes real a returns realif(a<0)thenreturn-a
endifreturn a
endfunctionfunction bYx takes integer oSx,unit oqx,real nZx,real bzx returns nothinglocal integer bZxlocal integer b_xset nZx=nZx*1set bzx=bzx*1if(nZx*bzx<=.0)thenif(bzx<.0)thenset b_x=IFloop
call UnitRemoveAbility(oqx,AF[b_x])set b_x=b_x-1exitwhen(b_x<0)endloopelse
set b_x=NFloop
call UnitRemoveAbility(oqx,bF[b_x])set b_x=b_x-1exitwhen(b_x<0)endloopendifif(nZx<.0)thenset nZx=-nZx
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(IF)))*1.)))loop
exitwhen(nZx<1.)
set bZx=BF[b_x]if(bZx<=nZx)then
set nZx=nZx-bZxcall UnitAddAbility(oqx,AF[b_x])
endifset b_x=b_x-1endloopelse
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(NF)))*1.)))loop
exitwhen(nZx<1.)
set bZx=BF[b_x]if(bZx<=nZx)then
set nZx=nZx-bZxcall UnitAddAbility(oqx,bF[b_x])
endifset b_x=b_x-1endloopendifelse
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(IF)))*1.)))if(nZx<.0)thenset nZx=-nZx
loop
exitwhen(b_x<0)set bZx=BF[b_x]if(bZx<=nZx)then
set nZx=nZx-bZxcall UnitAddAbility(oqx,AF[b_x])
else
call UnitRemoveAbility(oqx,AF[b_x])endifset b_x=b_x-1endloopelse
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(NF)))*1.)))loop
exitwhen(b_x<0)set bZx=BF[b_x]if(bZx<=nZx)then
set nZx=nZx-bZxelse
call UnitRemoveAbility(oqx,bF[b_x])endifset b_x=b_x-1endloopendifendifendfunctionfunction b0x takes integer oSx,real oux,real aCx returns nothing
set XF[oSx]=ouxcall bYx(cF,C[(oSx)],oux,aCx)endfunctionfunction b1x takes integer oSx,real oux returns nothinglocal real b2x=XF[oSx]set EF[oSx]=ouxif(oux==b2x)then
if OF[oSx]thenset OF[oSx]=falsecall RPx((oSx),RF)endifreturnendifif(bwx((((oSx))),Cb))thenif not OF[oSx]thenset OF[oSx]=true
call Avx((oSx),RF)endifelse
call b0x(oSx,oux,b2x)endifendfunctionfunction b3x takes integer oSx returns nothingset CF[oSx]=(wf[((oSx))])endfunctionfunction b4x takes integer oSx,real oux returns nothingset wf[oSx]=(wf[(oSx)])+ouxcall b3x(oSx)endfunctionfunction b5x takes integer oSx,real oux returns nothingset aF[oSx]=ouxcall btx((oSx))endfunctionfunction b6x takes integer oSx,real oux returns nothingcall b5x(oSx,(aF[(oSx)])+oux)endfunctionfunction b7x takes integer oSx,real nZx returns nothingif((tf[((Tf[((oSx))]))])==1)then
set nZx=1.25*nZx
endifcall b4x((oSx),nZx*Wf)call b6x((oSx),nZx*nF)endfunctionfunction b8x takes integer oSx,real oux returns nothinglocal integer b9x=(R2I((((EF[(oSx)]))*1.)))local integer Bvx=(R2I(((oux)*1.)))call b1x(oSx,oux)call b7x(oSx,Bvx-b9x)endfunctionfunction Bex takes integer oSx returns nothingcall b8x(oSx,(Sf[((oSx))])*((dF[((oSx))])-1)+(DF[((oSx))]))endfunctionfunction Bxx takes integer oSx,real oux returns nothingset VF[oSx]=ouxcall Bex(oSx)endfunctionfunction Box takes integer oSx returns nothingcall Bxx(oSx,(Sf[(oSx)])*(dF[(oSx)])+(DF[(oSx)]))endfunctionfunction Brx takes integer oSx,real oux returns nothinglocal integer b9x=(R2I((((Sf[(oSx)]))*1.)))local integer Bvx=(R2I(((oux)*1.)))set Sf[oSx]=ouxcall SetHeroAgi(C[(oSx)],Bvx,true)call bUx(oSx,Bvx-b9x)call Box((oSx))endfunctionfunction Bix takes integer oSx,real oux returns nothingcall Brx(oSx,(Sf[(oSx)])+oux)endfunctionfunction Bax takes integer oSx returns booleanif((hF[((oSx))])>0)thenreturn false
endifset HF=HF+1set jF[HF]=oSxset hF[oSx]=HF+1
return(HF==0)endfunctionfunction Bnx takes nothing returns nothinglocal integer oMx=HF
loop
exitwhen(oMx<0)set kF[oMx]=jF[oMx]set oMx=oMx-1endloopset KF=HFendfunctionfunction BVx takes nothing returns integerlocal integer o7xif(KF<0)then
return w
endifset o7x=kF[0]set kF[0]=kF[KF]
set KF=KF-1return o7xendfunctionfunction BEx takes real a,limitop BXx,real b returns boolean
if(BXx==LESS_THAN)thenif(a<b)thenreturn trueendifelseif(BXx==LESS_THAN_OR_EQUAL)thenif(a<=b)then
return trueendifelseif(BXx==EQUAL)thenif(a==b)then
return trueendifelseif(BXx==NOT_EQUAL)thenif(a!=b)then
return trueendifelseif(BXx==GREATER_THAN)thenif(a>b)thenreturn trueendifelseif(BXx==GREATER_THAN_OR_EQUAL)thenif(a>=b)then
return trueendifendifreturn false
endfunctionfunction BOx takes integer rLx,real aCx,real oux returns nothing
local integer rFx=rRx((A[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxlocal integer XYxlocal limitop BRxlocal integer BIxset Vv[(rFx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,mF,rbx)loop
exitwhen(rMx<q)set XYx=rgx(rLx,mF,rbx,rMx)set BRx=(OA[(XYx)])set BIx=(XA[(XYx)])if(BEx(oux,BRx,BIx)and not BEx(aCx,BRx,BIx))then
call rfx(XYx,rFx)endifset rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction BAx takes integer oSx,real oux returns nothinglocal real aCx=(lF[(oSx)])set oux=blx(oux,.0,(LF[((oSx))]))set lF[oSx]=ouxcall SetUnitState(C[(oSx)],UNIT_STATE_MANA,oux)call BOx(oSx,aCx,oux)endfunctionfunction BNx takes integer oSx,real oux returns nothingcall BAx(oSx,(lF[(oSx)])+oux)endfunctionfunction Bbx takes nothing returns nothinglocal integer oSxcall Bnx()loop
set oSx=BVx()exitwhen(oSx==w)
call BNx((oSx),(gF[(oSx)])*1.5)endloopendfunctionfunction BBx takes integer oSx returns nothingif Bax(oSx)thencall iDx(JF,1.5,true,function Bbx)endifendfunctionfunction Bcx takes integer oSx returns booleanif(((hF[((oSx))])>0)==false)then
return false
endifset hF[jF[HF]]=hF[oSx]set jF[hF[oSx]-1]=jF[HF]
set hF[oSx]=0set HF=HF-1return(HF==F)endfunctionfunction BCx takes integer oSx returns nothingif Bcx(oSx)thencall ikx(JF)
endifendfunctionfunction Bdx takes integer oSx,real oux returns nothinglocal real aCx=gF[oSx]set gF[oSx]=ouxif((aCx>.0)==(oux>.0))thenreturnendifif(osx(((((oSx)))),(Wb+(GF)))>0)then
returnendifif(oux>.0)thencall BBx(oSx)else
call BCx(oSx)endifendfunctionfunction BDx takes integer oSx returns nothingcall Bdx(oSx,(FF[(oSx)])*(MF[(oSx)])+(pF[(oSx)]))endfunctionfunction Bfx takes integer oSx,real oux returns nothingset FF[oSx]=ouxcall BDx((oSx))endfunctionfunction BFx takes integer oSx,real oux returns nothingcall Bfx(oSx,(FF[(oSx)])+oux)endfunctionfunction Bgx takes integer oSx,integer nZx returns nothinglocal integer BGxlocal integer Bhxif(nZx<0)thenset nZx=-nZx
set BGx=nZx/ QFset nZx=nZx-BGx*QFloop
exitwhen(BGx<1)call rtx((oSx),sF)call rZx((oSx),sF,2)
call UnitRemoveAbility(C[(((oSx)))],(sF))set BGx=BGx-1endloopset Bhx=SF[nZx]call rtx((oSx),Bhx)call rZx((oSx),Bhx,2)call UnitRemoveAbility(C[(((oSx)))],(Bhx))else
set BGx=nZx/ tFset nZx=nZx-BGx*tFloop
exitwhen(BGx<1)call rtx((oSx),TF)call rZx((oSx),TF,2)
call UnitRemoveAbility(C[(((oSx)))],(TF))set BGx=BGx-1endloopset Bhx=uF[nZx]call rtx((oSx),Bhx)call rZx((oSx),Bhx,2)call UnitRemoveAbility(C[(((oSx)))],(Bhx))endifendfunctionfunction BHx takes integer oSx,real aCx,real oux returns nothing
if((lF[((oSx))])==.0)thenreturnendifcall BAx((oSx),(lF[((oSx))])*1./ aCx*oux)endfunctionfunction Bjx takes integer oSx,real oux returns nothinglocal real aCx=LF[oSx]if(aCx==oux)then
returnendifset LF[oSx]=ouxcall Bgx(oSx,(R2I(((oux-aCx)*1.))))if(aCx!=.0)thencall BHx(oSx,aCx,oux)endifendfunctionfunction BJx takes integer oSx returns nothingcall Bjx(oSx,(qF[(oSx)])*(UF[(oSx)])+(wF[(oSx)]))endfunctionfunction Bkx takes integer oSx,real oux returns nothingset qF[oSx]=ouxcall BJx((oSx))endfunctionfunction BKx takes integer oSx,real oux returns nothingcall Bkx(oSx,(qF[(oSx)])+oux)endfunctionfunction Blx takes integer oSx,real oux returns nothingset YF[oSx]=oux-(yF[(oSx)])set zF[oSx]=ouxendfunctionfunction BLx takes integer oSx returns nothingcall Blx(oSx,(yF[(oSx)])*(ZF[(oSx)])+(vg[(oSx)]))endfunctionfunction Bmx takes integer oSx,real oux returns nothingset yF[oSx]=ouxcall BLx((oSx))endfunctionfunction BMx takes integer oSx,real oux returns nothingcall Bmx(oSx,(yF[(oSx)])+oux)endfunctionfunction Bpx takes integer oSx,real nZx returns nothingif((tf[((Tf[((oSx))]))])==2)then
set nZx=1.25*nZx
endifcall BFx((oSx),nZx*PF)call BKx((oSx),nZx*WF)call BMx((oSx),nZx*eg)endfunctionfunction BPx takes integer oSx,unit oqx,real nZx,real bzx returns nothinglocal integer bZxlocal integer b_xset nZx=nZx*1set bzx=bzx*1if(nZx*bzx<=.0)thenif(bzx<.0)thenset b_x=ngloop
call UnitRemoveAbility(oqx,Vg[b_x])set b_x=b_x-1exitwhen(b_x<0)endloopelse
set b_x=Egloop
call UnitRemoveAbility(oqx,Xg[b_x])set b_x=b_x-1exitwhen(b_x<0)endloopendifif(nZx<.0)thenset nZx=-nZx
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(ng)))*1.)))loop
exitwhen(nZx<1.)
set bZx=Og[b_x]if(bZx<=nZx)then
set nZx=nZx-bZxcall UnitAddAbility(oqx,Vg[b_x])
endifset b_x=b_x-1endloopelse
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(Eg)))*1.)))loop
exitwhen(nZx<1.)
set bZx=Og[b_x]if(bZx<=nZx)then
set nZx=nZx-bZxcall UnitAddAbility(oqx,Xg[b_x])
endifset b_x=b_x-1endloopendifelse
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(ng)))*1.)))if(nZx<.0)thenset nZx=-nZx
loop
exitwhen(b_x<0)set bZx=Og[b_x]if(bZx<=nZx)then
set nZx=nZx-bZxcall UnitAddAbility(oqx,Vg[b_x])
else
call UnitRemoveAbility(oqx,Vg[b_x])endifset b_x=b_x-1endloopelse
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(Eg)))*1.)))loop
exitwhen(b_x<0)set bZx=Og[b_x]if(bZx<=nZx)then
set nZx=nZx-bZxelse
call UnitRemoveAbility(oqx,Xg[b_x])endifset b_x=b_x-1endloopendifendifendfunctionfunction Bqx takes integer oSx,real oux,real aCx returns nothing
set rg[oSx]=ouxcall BPx(Rg,C[(oSx)],oux,aCx)endfunctionfunction BQx takes integer oSx,real oux returns nothinglocal real b2x=rg[oSx]set og[oSx]=ouxif(oux==b2x)then
if ig[oSx]thenset ig[oSx]=falsecall RPx((oSx),ag)endifreturnendifif(bwx((((oSx))),Cb))thenif not ig[oSx]thenset ig[oSx]=true
call Avx((oSx),ag)endifelse
call Bqx(oSx,oux,b2x)endifendfunctionfunction Bsx takes integer oSx,real oux returns nothingset pF[oSx]=ouxcall BDx((oSx))endfunctionfunction BSx takes integer oSx,real oux returns nothingcall Bsx(oSx,(pF[(oSx)])+oux)endfunctionfunction Btx takes integer oSx,real oux returns nothingset wF[oSx]=ouxcall BJx((oSx))endfunctionfunction BTx takes integer oSx,real oux returns nothingcall Btx(oSx,(wF[(oSx)])+oux)endfunctionfunction Bux takes integer oSx,real oux returns nothingset vg[oSx]=ouxcall BLx((oSx))endfunctionfunction BUx takes integer oSx,real oux returns nothingcall Bux(oSx,(vg[(oSx)])+oux)endfunctionfunction Bwx takes integer oSx,real nZx returns nothingif((tf[((Tf[((oSx))]))])==2)then
set nZx=1.25*nZx
endifcall BSx((oSx),nZx*PF)call BTx((oSx),nZx*WF)call BUx((oSx),nZx*eg)endfunctionfunction BWx takes integer oSx,real oux returns nothinglocal integer b9x=(R2I((((og[(oSx)]))*1.)))local integer Bvx=(R2I(((oux)*1.)))call BQx(oSx,oux)call Bwx(oSx,Bvx-b9x)endfunctionfunction Byx takes integer oSx returns nothingcall BWx(oSx,(fF[((oSx))])*((Ig[((oSx))])-1)+(Ag[((oSx))]))endfunctionfunction BYx takes integer oSx,real oux returns nothingset xg[oSx]=ouxcall Byx(oSx)endfunctionfunction Bzx takes integer oSx returns nothingcall BYx(oSx,(fF[(oSx)])*(Ig[(oSx)])+(Ag[(oSx)]))endfunctionfunction BZx takes integer oSx,real oux returns nothinglocal integer b9x=(R2I((((fF[(oSx)]))*1.)))local integer Bvx=(R2I(((oux)*1.)))set fF[oSx]=ouxcall SetHeroInt(C[(oSx)],Bvx,true)call Bpx(oSx,Bvx-b9x)call Bzx((oSx))endfunctionfunction B_x takes integer oSx,real oux returns nothingcall BZx(oSx,(fF[(oSx)])+oux)endfunctionfunction B0x takes integer oSx returns booleanreturn bwx((oSx),Cb)
endfunctionfunction B1x takes integer oSx,unit oqx,real nZx returns nothing
local boolean B2x=(UnitInventorySize(oqx)>0)
local integer bZxlocal integer b_xif not B2x thencall UnitAddAbility(oqx,'AInv')endifif(nZx<0)thenset nZx=-nZx
set b_x=Fgloop
exitwhen(nZx<1)set bZx=gg[b_x]loop
exitwhen(nZx<bZx)call UnitAddItem(oqx,Gg[b_x])set nZx=nZx-bZxendloopset b_x=b_x-1endloopelse
set b_x=hgloop
exitwhen(nZx<1)set bZx=gg[b_x]loop
exitwhen(nZx<bZx)call UnitAddItem(oqx,Hg[b_x])set nZx=nZx-bZxendloopset b_x=b_x-1endloopendifif not B2x thencall UnitRemoveAbility(oqx,'AInv')endifendfunctionfunction B3x takes integer oSx,real oux,real aCx returns boolean
if IsUnitPaused(C[(oSx)])thenreturn false
endifset Bg[oSx]=ouxcall DisableTrigger(DA[(Dg)])call DisableTrigger(DA[(fg)])call B1x(jg,C[(oSx)],(R2I(((oux)*1.)))-(R2I(((aCx)*1.))))call EnableTrigger(DA[(Dg)])
call EnableTrigger(DA[(fg)])
return trueendfunctionfunction B4x takes integer oSx,real oux returns nothinglocal real b2x=Bg[oSx]set cg[oSx]=ouxif(oux==b2x)then
if Cg[oSx]thenset Cg[oSx]=falsecall RPx((oSx),dg)endifreturnendifif B0x((oSx))thenif not Cg[oSx]thenset Cg[oSx]=true
call Avx((oSx),dg)endifelse
call B3x(oSx,oux,b2x)endifendfunctionfunction B5x takes integer oSx returns nothingcall B4x(oSx,(bg[((oSx))]))endfunctionfunction B6x takes integer oSx,unit oqx,real nZx,real bzx returns nothinglocal integer bZxlocal integer b_xset nZx=nZx*1set bzx=bzx*1if(nZx*bzx<=.0)thenif(bzx<.0)thenset b_x=qgloop
call UnitRemoveAbility(oqx,Qg[b_x])set b_x=b_x-1exitwhen(b_x<0)endloopelse
set b_x=sgloop
call UnitRemoveAbility(oqx,Sg[b_x])set b_x=b_x-1exitwhen(b_x<0)endloopendifif(nZx<.0)thenset nZx=-nZx
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(qg)))*1.)))loop
exitwhen(nZx<1.)
set bZx=tg[b_x]if(bZx<=nZx)then
set nZx=nZx-bZxcall UnitAddAbility(oqx,Qg[b_x])
endifset b_x=b_x-1endloopelse
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(sg)))*1.)))loop
exitwhen(nZx<1.)
set bZx=tg[b_x]if(bZx<=nZx)then
set nZx=nZx-bZxcall UnitAddAbility(oqx,Sg[b_x])
endifset b_x=b_x-1endloopendifelse
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(qg)))*1.)))if(nZx<.0)thenset nZx=-nZx
loop
exitwhen(b_x<0)set bZx=tg[b_x]if(bZx<=nZx)then
set nZx=nZx-bZxcall UnitAddAbility(oqx,Qg[b_x])
else
call UnitRemoveAbility(oqx,Qg[b_x])endifset b_x=b_x-1endloopelse
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(sg)))*1.)))loop
exitwhen(b_x<0)set bZx=tg[b_x]if(bZx<=nZx)then
set nZx=nZx-bZxelse
call UnitRemoveAbility(oqx,Sg[b_x])endifset b_x=b_x-1endloopendifendifendfunctionfunction B7x takes integer oSx,real oux,real aCx returns nothing
set mg[oSx]=ouxcall B6x(Tg,C[(oSx)],oux,aCx)endfunctionfunction B8x takes integer oSx,real oux returns nothinglocal real b2x=mg[oSx]set Mg[oSx]=ouxif(oux==b2x)then
if pg[oSx]thenset pg[oSx]=falsecall RPx((oSx),Pg)endifreturnendifif B0x((oSx))thenif not pg[oSx]thenset pg[oSx]=true
call Avx((oSx),Pg)endifelse
call B7x(oSx,oux,b2x)endifendfunctionfunction B9x takes integer oSx returns nothingcall B8x((oSx),(((bg[((oSx))])*((kg[((oSx))])-1)+(Jg[((oSx))]))*1.))
endfunctionfunction cvx takes integer oSx,real oux returns nothingset Lg[oSx]=ouxcall B9x(oSx)endfunctionfunction cex takes integer oSx returns nothinglocal real cxx=(bg[(oSx)])local real cox=(Jg[(oSx)])local real crx=(kg[(oSx)])set Kg[oSx]=cxx*crx+coxset lg[oSx]=cxx*(crx-1)+coxcall cvx(oSx,cxx*crx*(ug[(oSx)])+cox)endfunctionfunction cix takes integer oSx,real oux returns nothingset bg[oSx]=ouxcall B5x(oSx)call cex((oSx))endfunctionfunction cax takes integer oSx,real oux returns nothingcall cix(oSx,(bg[(oSx)])+oux)endfunctionfunction cnx takes integer oSx returns booleanif((Yg[((oSx))])>0)thenreturn false
endifset zg=zg+1set Zg[zg]=oSxset Yg[oSx]=zg+1
return(zg==0)endfunctionfunction cVx takes nothing returns nothinglocal integer oMx=zg
loop
exitwhen(oMx<0)set eG[oMx]=Zg[oMx]set oMx=oMx-1endloopset xG=zgendfunctionfunction cEx takes nothing returns integerlocal integer o7xif(xG<0)then
return w
endifset o7x=eG[0]set eG[0]=eG[xG]
set xG=xG-1return o7xendfunctionfunction cXx takes integer oSx returns booleanset mN=mN+1set LN[mN]=oSxset lN[oSx]=mN+1
return(mN==0)endfunctionfunction cOx takes integer oSx,real x,real y,real z returns nothingcall X1x(oSx,(eN[(oSx)])+x,(xN[(oSx)])+y,(oN[(oSx)])+z)endfunctionfunction cRx takes integer oSx,real oux returns nothingset hN[oSx]=ouxcall SetTextTagText(iN[(oSx)],DN[oSx],oux)endfunctionfunction cIx takes nothing returns nothinglocal integer oMx=mN
local integer oSxlocal real cAxlocal real cNxlocal real cbxloop
set oSx=LN[oMx]set cAx=nG[oSx]+XG[oSx]set cNx=NG[oSx]+BG[oSx]set cbx=aG[oSx]+cAxset aG[oSx]=cbxset nG[oSx]=cAxset NG[oSx]=cNxcall cOx((oSx),IG[oSx],AG[oSx],cNx)call cRx((oSx),cbx*RG[oSx])set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction cBx takes nothing returns nothinglocal integer iCx=iGx()local integer oSx=(ge[(iCx)])call OVx(oSx,iCx)call Odx((oSx))endfunctionfunction ccx takes string icx,real Ovx,real x,real y,real z,integer id returns integerlocal integer rLx=X7x(id)local real bexlocal integer oSxlocal integer iCxif(rLx==w)thenreturn w
endifset bex=(GetRandomReal(((.0)*1.),((Cf)*1.)))
set oSx=rLxset iCx=iXx()set aG[oSx]=1.set nG[oSx]=VG*EGset XG[oSx]=OG*EG*EG
set RG[oSx]=Ovxset IG[oSx]=(Cos(((((bex)*1.))*1.)))*20.*EGset AG[oSx]=(Sin(((((bex)*1.))*1.)))*20.*EGset NG[oSx]=bG*EGset BG[oSx]=cG*EG*EG
set pN[oSx]=iCxset KN[oSx]=true
set ge[(iCx)]=(oSx)call X1x(rLx,x,y,z)call X9x(rLx,icx,Ovx)if cXx(oSx)thencall iDx(MN,EG,true,function cIx)endifcall iDx(iCx,1.5,false,function cBx)
call OKx(rLx,.75,1.5)return rLxendfunctionfunction cCx takes integer oSx,string icx,real Ovx,integer id returns integerlocal real x=(GetUnitX(C[((oSx))]))local real y=(GetUnitY(C[((oSx))]))return ccx(icx,Ovx,x,y,OMx(oSx,x,y)+Opx(oSx,true),id)endfunctionfunction cdx takes integer oSx returns booleanif not(iG[(oSx)])thenreturn false
endifcall cCx((oSx),iSx("Immortal!!","ff777777"),.02,CG+oSx)return trueendfunctionfunction cDx takes integer oSx,integer cfx returns nothinglocal integer rFx=rRx(0)
local integer oMxlocal integer rbxlocal integer rMxset fG[(rFx)]=(cfx)set Vv[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((FG))-1)*Iv+(((rbx))-1)))))))))loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((FG))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction cFx takes integer oSx,integer cfx returns nothingcall cDx(oSx,cfx)set gG=cfxendfunctionfunction cgx takes integer oSx returns nothinglocal integer cfx=DG
set DG=w
call cFx((oSx),cfx)endfunctionfunction cGx takes integer rLx,real aCx,real oux returns nothing
local integer rFx=rRx((A[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxlocal integer XYxlocal limitop BRxlocal integer BIxset Vv[(rFx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,GG,rbx)loop
exitwhen(rMx<q)set XYx=rgx(rLx,GG,rbx,rMx)if(EA[(XYx)])thenset BRx=(OA[(XYx)])set BIx=(XA[(XYx)])if(BEx(oux,BRx,BIx)and not BEx(aCx,BRx,BIx))then
call rfx(XYx,rFx)endifelse
call rfx(XYx,rFx)endifset rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction chx takes integer oSx,real oux returns nothinglocal real aCx=(oG[(oSx)])local boolean cHx=(not I9x((oSx),Qc)and(oux<.405))set oux=blx(oux,.0,(rG[((oSx))]))set oG[oSx]=ouxif cHx thenif cdx((oSx))thenset cHx=falseset oux=dGelse
call cgx(oSx)endifendifcall SetWidgetLife(C[(oSx)],oux)
call cGx(oSx,aCx,oux)endfunctionfunction cjx takes integer oSx,real oux returns nothingcall chx(oSx,(oG[(oSx)])+oux)endfunctionfunction cJx takes nothing returns nothinglocal integer oSxcall cVx()loop
set oSx=cEx()exitwhen(oSx==w)
call cjx((oSx),(Wg[(oSx)])*1.5)endloopendfunctionfunction ckx takes integer oSx returns nothingif cnx(oSx)thencall iDx(vG,1.5,true,function cJx)endifendfunctionfunction cKx takes integer oSx returns booleanif(((Yg[((oSx))])>0)==false)then
return false
endifset Yg[Zg[zg]]=Yg[oSx]set Zg[Yg[oSx]-1]=Zg[zg]
set Yg[oSx]=0set zg=zg-1return(zg==F)endfunctionfunction clx takes integer oSx returns nothingif cKx(oSx)thencall ikx(vG)
endifendfunctionfunction cLx takes integer oSx,real oux returns nothinglocal real aCx=Wg[oSx]set Wg[oSx]=ouxif((aCx>.0)==(oux>.0))thenreturnendifif(osx(((((oSx)))),(Wb+(yg)))>0)then
returnendifif(oux>.0)thencall ckx(oSx)else
call clx(oSx)endifendfunctionfunction cmx takes integer oSx returns nothingcall cLx(oSx,(wg[(oSx)])*(hG[(oSx)])+(HG[(oSx)]))endfunctionfunction cMx takes integer oSx,real oux returns nothingset wg[oSx]=ouxcall cmx((oSx))endfunctionfunction cpx takes integer oSx,real oux returns nothingcall cMx(oSx,(wg[(oSx)])+oux)endfunctionfunction cPx takes integer oSx,integer nZx returns nothinglocal integer BGxlocal integer Bhxif(nZx<0)thenset nZx=-nZx
set BGx=nZx/ kGset nZx=nZx-BGx*kGloop
exitwhen(BGx<1)call rtx((oSx),KG)call rZx((oSx),KG,2)
call UnitRemoveAbility(C[(((oSx)))],(KG))set BGx=BGx-1endloopset Bhx=lG[nZx]call rtx((oSx),Bhx)call rZx((oSx),Bhx,2)call UnitRemoveAbility(C[(((oSx)))],(Bhx))else
set BGx=nZx/ LGset nZx=nZx-BGx*LGloop
exitwhen(BGx<1)call rtx((oSx),mG)call rZx((oSx),mG,2)
call UnitRemoveAbility(C[(((oSx)))],(mG))set BGx=BGx-1endloopset Bhx=MG[nZx]call rtx((oSx),Bhx)call rZx((oSx),Bhx,2)call UnitRemoveAbility(C[(((oSx)))],(Bhx))endifendfunctionfunction cqx takes integer oSx,real aCx,real oux returns nothing
local real cQx=(oG[((oSx))])
if(cQx==.0)thenreturnendifcall chx((oSx),cQx*1./ aCx*oux)endfunctionfunction csx takes integer oSx,real oux returns nothinglocal real aCx=rG[oSx]if(aCx==oux)then
returnendifset rG[oSx]=ouxcall cPx(oSx,(R2I(((oux-aCx)*1.))))if(aCx!=.0)thencall cqx(oSx,aCx,oux)endifendfunctionfunction cSx takes integer oSx returns nothingcall csx(oSx,(JG[(oSx)])*(pG[(oSx)])+(PG[(oSx)]))endfunctionfunction ctx takes integer oSx,real oux returns nothingset JG[oSx]=ouxcall cSx((oSx))endfunctionfunction cTx takes integer oSx,real oux returns nothingcall ctx(oSx,(JG[(oSx)])+oux)endfunctionfunction cux takes integer oSx,real nZx returns nothingif((tf[((Tf[((oSx))]))])==3)then
set nZx=1.25*nZx
endifcall cax((oSx),nZx*Ug)call cpx((oSx),nZx*jG)call cTx((oSx),nZx*qG)endfunctionfunction cUx takes integer oSx,unit oqx,real nZx,real bzx returns nothinglocal integer bZxlocal integer b_xset nZx=nZx*1set bzx=bzx*1if(nZx*bzx<=.0)thenif(bzx<.0)thenset b_x=uGloop
call UnitRemoveAbility(oqx,UG[b_x])set b_x=b_x-1exitwhen(b_x<0)endloopelse
set b_x=wGloop
call UnitRemoveAbility(oqx,WG[b_x])set b_x=b_x-1exitwhen(b_x<0)endloopendifif(nZx<.0)thenset nZx=-nZx
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(uG)))*1.)))loop
exitwhen(nZx<1.)
set bZx=yG[b_x]if(bZx<=nZx)then
set nZx=nZx-bZxcall UnitAddAbility(oqx,UG[b_x])
endifset b_x=b_x-1endloopelse
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(wG)))*1.)))loop
exitwhen(nZx<1.)
set bZx=yG[b_x]if(bZx<=nZx)then
set nZx=nZx-bZxcall UnitAddAbility(oqx,WG[b_x])
endifset b_x=b_x-1endloopendifelse
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(uG)))*1.)))if(nZx<.0)thenset nZx=-nZx
loop
exitwhen(b_x<0)set bZx=yG[b_x]if(bZx<=nZx)then
set nZx=nZx-bZxcall UnitAddAbility(oqx,UG[b_x])
else
call UnitRemoveAbility(oqx,UG[b_x])endifset b_x=b_x-1endloopelse
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(wG)))*1.)))loop
exitwhen(b_x<0)set bZx=yG[b_x]if(bZx<=nZx)then
set nZx=nZx-bZxelse
call UnitRemoveAbility(oqx,WG[b_x])endifset b_x=b_x-1endloopendifendifendfunctionfunction cwx takes integer oSx,real oux,real aCx returns nothing
set SG[oSx]=ouxcall cUx(YG,C[(oSx)],oux,aCx)endfunctionfunction cWx takes integer oSx,real oux returns nothinglocal real b2x=SG[oSx]set sG[oSx]=ouxif(oux==b2x)then
if tG[oSx]thenset tG[oSx]=falsecall RPx((oSx),TG)endifreturnendifif(bwx((((oSx))),Cb))thenif not tG[oSx]thenset tG[oSx]=true
call Avx((oSx),TG)endifelse
call cwx(oSx,oux,b2x)endifendfunctionfunction cyx takes integer oSx,real oux returns nothingset Jg[oSx]=ouxcall cex((oSx))endfunctionfunction cYx takes integer oSx,real oux returns nothingcall cyx(oSx,(Jg[(oSx)])+oux)endfunctionfunction czx takes integer oSx,real oux returns nothingset HG[oSx]=ouxcall cmx((oSx))endfunctionfunction cZx takes integer oSx,real oux returns nothingcall czx(oSx,(HG[(oSx)])+oux)endfunctionfunction c_x takes integer oSx,real oux returns nothingset PG[oSx]=ouxcall cSx((oSx))endfunctionfunction c0x takes integer oSx,real oux returns nothingcall c_x(oSx,(PG[(oSx)])+oux)endfunctionfunction c1x takes integer oSx,real nZx returns nothingif((tf[((Tf[((oSx))]))])==3)then
set nZx=1.25*nZx
endifcall cYx((oSx),nZx*Ug)call cZx((oSx),nZx*jG)call c0x((oSx),nZx*qG)endfunctionfunction c2x takes integer oSx,real oux returns nothinglocal integer b9x=(R2I((((sG[(oSx)]))*1.)))local integer Bvx=(R2I(((oux)*1.)))call cWx(oSx,oux)call c1x(oSx,Bvx-b9x)endfunctionfunction c3x takes integer oSx returns nothingcall c2x(oSx,(Ng[((oSx))])*((zG[((oSx))])-1)+(ZG[((oSx))]))endfunctionfunction c4x takes integer oSx,real oux returns nothingset QG[oSx]=ouxcall c3x(oSx)endfunctionfunction c5x takes integer oSx returns nothingcall c4x(oSx,(Ng[(oSx)])*(zG[(oSx)])+(ZG[(oSx)]))endfunctionfunction c6x takes integer oSx,real oux returns nothinglocal integer b9x=(R2I((((Ng[(oSx)]))*1.)))local integer Bvx=(R2I(((oux)*1.)))set Ng[oSx]=ouxcall SetHeroStr(C[(oSx)],Bvx,true)call cux(oSx,Bvx-b9x)call c5x((oSx))endfunctionfunction c7x takes integer oSx,real oux returns nothingcall c6x(oSx,(Ng[(oSx)])+oux)endfunctionfunction c8x takes nothing returns booleanlocal integer rFx=(bv)if(Qf=="-agi")thencall Bix(ROx(),sf)elseif(Qf=="-int")thencall B_x(ROx(),sf)elseif(Qf=="-str")thencall c7x(ROx(),sf)else
call o_x("CommandHeroAttribute_Enum","call DebugEx(\"unrecognized\")","unrecognized")endifreturn trueendfunctionfunction c9x takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])local string Cvx=(LA[(rFx)])
local real o5x=(S2R((Xsx(r4x,1))))set Qf=Cvxset sf=o5xcall Rvx(oDx,function c8x)return trueendfunctionfunction Cex takes nothing returns booleancall Xzx("-agi",function c9x)call Xzx("-int",function c9x)call Xzx("-str",function c9x)return trueendfunctionfunction Cxx takes nothing returns booleancall Xxx(function Cex,"CommandHeroAttribute_Init")return trueendfunctionfunction Cox takes nothing returns booleanset vh=VXx(eh)return trueendfunctionfunction Crx takes integer oSx,integer cfx returns nothingif cdx(oSx)thenreturnendifset gG=cfxcall KillUnit(C[(oSx)])endfunctionfunction Cix takes integer oSx returns nothingcall Crx(oSx,w)endfunctionfunction Cax takes nothing returns booleanlocal integer rFx=(bv)call Cix(ROx())return trueendfunctionfunction Cnx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])call Rvx(oDx,function Cax)return trueendfunctionfunction CVx takes nothing returns booleancall Xzx("-kill",function Cnx)return trueendfunctionfunction CEx takes nothing returns booleancall Xxx(function CVx,"CommandKillUnit_Init")return trueendfunctionfunction CXx takes nothing returns booleanset xh=VXx(oh)return trueendfunctionfunction COx takes integer oSx returns nothingset nh[(oSx)]=trueset Vh[(oSx)]=trueset Eh[(oSx)]=trueendfunctionfunction CRx takes integer oSx,integer rTx returns nothingcall UnitRemoveAbility(C[(oSx)],rTx)
endfunctionfunction CIx takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((I[(oSx)]))])]))],((((A[((oSx))])))),(((otx))))))endfunctionfunction CAx takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((I[(oSx)]))])]))],((((A[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction CNx takes integer oSx,integer Rox returns integerlocal integer oMx=(CIx(((oSx)),Q))local integer rlxloop
exitwhen(oMx<q)set rlx=(CAx(((oSx)),Q,(oMx)))if(((Rh[(rlx)])==Rox)or((Pb[(rlx)])==Rox)or((sb[(rlx)])==Rox))thenreturn rlxendifset oMx=oMx-1endloopreturn w
endfunctionfunction Cbx takes integer oSx,integer rFx returns booleanset bv=(rFx)
return rBx(oSx)endfunctionfunction CBx takes integer oSx,integer Rox,real x,real y returns boolean
return(IssuePointOrderById(C[(oSx)],pb[Rox],x,y))endfunctionfunction Ccx takes integer oSx,integer Rox,real x,real y returns boolean
local boolean o7xcall DisableTrigger(DA[(bh)])set o7x=CBx(oSx,Rox,x,y)
call EnableTrigger(DA[(bh)])
return o7xendfunctionfunction CCx takes integer oSx returns nothinglocal real bex=(GetUnitFacing(C[((oSx))])*Nh)if Ccx(oSx,Bh,(GetUnitX(C[((oSx))]))+.01*(Cos(((((bex)*1.))*1.))),(GetUnitY(C[((oSx))]))+.01*(Sin(((((bex)*1.))*1.))))thenreturnendifcall Rrx(oSx,ch)
endfunctionfunction Cdx takes integer oSx returns booleanreturn((oSx>=Ch)and(oSx<=dh))endfunctionfunction CDx takes integer oSx,playerstate Cfx returns integerreturn GetPlayerState(vx[(oSx)],Cfx)
endfunctionfunction CFx takes integer oSx,integer Cgx returns nothingcall UnitAddItem(C[(oSx)],gh[Cgx])endfunctionfunction CGx takes integer oSx,integer bIx returns nothinglocal item oqx=gh[oSx]local real x=(GetItemX(gh[((oSx))]))
local real y=(GetItemY(gh[((oSx))]))
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oqx))))),((((hh)))),((((oSx)))))
call RemoveItem(oqx)
set oqx=CreateItem(Hh[(Fh[(oSx)])],x,y)set gh[oSx]=oqxcall SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oqx))))),((((hh)))),((((oSx)))))
if(bIx!=w)thencall CFx(bIx,oSx)endifset oqx=null
endfunctionfunction Chx takes integer oSx,playerstate Cfx,integer oux returns nothinglocal integer oMxif(oSx==Ge)thenset oMx=Jhloop
call Chx(kh[oMx],Cfx,oux)set oMx=oMx-1exitwhen(oMx<0)endloopelse
call SetPlayerState(vx[(oSx)],Cfx,oux)endifendfunctionfunction CHx takes integer oSx,playerstate Cfx,integer oux returns nothingcall Chx(oSx,Cfx,(GetPlayerState(vx[((oSx))],(Cfx)))-oux)endfunctionfunction Cjx takes integer oSx,integer otx,integer oux returns booleanreturn((LoadInteger(o[((D[((Kh[(oSx)]))]))],((((lh[((oSx))])))),(oTx(((otx)),(((oux)))))))!=0)endfunctionfunction CJx takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((sh[oSx]))])]))],((((Ph[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))endfunctionfunction Ckx takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((sh[oSx]))])]))],((((Ph[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))endfunctionfunction CKx takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((Kh[(oSx)]))])]))],((((lh[((oSx))])))),(((otx))))))endfunctionfunction Clx takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((Kh[(oSx)]))])]))],((((lh[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction CLx takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((Kh[(oSx)]))])]))],((((lh[((oSx))])))),(((otx)))))endfunctionfunction Cmx takes integer oSx returns integerset iH[oSx]=true
set aH[oSx]=falsecall rEx(nH)
return oSxendfunctionfunction CMx takes nothing returns integerlocal integer oSxif(vH==8190)then
call o_x("SpellInstance_Allocation_allocCustom","call DebugEx(SpellInstance.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",eH+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(xH[(w)]==w)thenset oH=oH+1set oSx=oHelse
set oSx=xH[(w)]set xH[(w)]=xH[xH[(w)]]endifset xH[oSx]=Zset rH[oSx]=1call Cmx(oSx)return oSxendfunctionfunction Cpx takes integer oSx returns nothingset bH[oSx]=0set BH[oSx]=falseendfunctionfunction CPx takes integer Cqx,integer rlx returns integerlocal integer oSx=CMx()set VH[(oSx)]=((.0)*1.)set EH[(oSx)]=(Cqx)set XH[(oSx)]=(0)set OH[(oSx)]=(((Lg[(Cqx)]))*1.)
set RH[(oSx)]=((.0)*1.)set IH[(oSx)]=(rWx(Cqx,rlx))
set AH[(oSx)]=(rlx)set NH[(oSx)]=(((zF[(Cqx)]))*1.)
set wh[(oSx)]=(w)set Wh[(oSx)]=(w)set yh[(oSx)]=((.0)*1.)set Yh[(oSx)]=((.0)*1.)call Cpx(oSx)return oSxendfunctionfunction CQx takes integer oSx,integer otx returns realreturn(LoadReal(o[((V[(E[((cH[(oSx)]))])]))],((((Ev[((oSx))])))),(((otx)))))
endfunctionfunction Csx takes integer oSx,integer Iax,integer rYx,real iMx returns integerreturn Nbx(oSx,Iax,rYx,w,iMx)endfunctionfunction CSx takes integer Ctx returns nothinglocal real iMx=(CQx(((AH[(Ctx)])),dH+((IH[(Ctx)]))))
if(iMx==.0)thenreturnendifcall AZx((EH[(Ctx)]),DH)
set fH=iMxset FH=Ctxcall Csx((EH[(Ctx)]),DH,1,iMx)endfunctionfunction CTx takes integer oSx returns integerset KH[oSx]=true
set lH[oSx]=falsecall rEx(LH)
return oSxendfunctionfunction Cux takes nothing returns integerlocal integer oSxif(hH==8190)then
call o_x("FolderUnit_FolderAbilities_StructCooldown_Allocation_allocCustom","call DebugEx(FolderUnit_FolderAbilities_StructCooldown.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",HH+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(jH[(w)]==w)thenset JH=JH+1set oSx=JHelse
set oSx=jH[(w)]set jH[(w)]=jH[jH[(w)]]endifset jH[oSx]=Zset kH[oSx]=1call CTx(oSx)return oSxendfunctionfunction CUx takes integer oSx,integer otx,integer oux returns booleanreturn rux(cH[(oSx)],(Ev[((oSx))]),otx,oux)endfunctionfunction Cwx takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((cH[(oSx)]))])]))],((((Ev[((oSx))])))),(((otx))),(((oux))))endfunctionfunction CWx takes integer oSx returns nothingset KH[oSx]=falsecall rHx(LH)
endfunctionfunction Cyx takes integer oSx returns nothingif(kH[oSx]>0)thenreturnendifif(jH[oSx]!=Z)thencall o_x("FolderUnit_FolderAbilities_StructCooldown_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderAbilities_StructCooldown.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",HH+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset jH[oSx]=jH[(w)]set jH[(w)]=oSxcall CWx(oSx)endfunctionfunction CYx takes integer oSx returns nothingset kH[oSx]=kH[oSx]-1call Cyx(oSx)endfunctionfunction Czx takes integer oSx,integer otx,integer oux returns booleanreturn rrx(cH[(oSx)],(Ev[((oSx))]),otx,oux)endfunctionfunction CZx takes integer oSx,integer otx returns nothingcall SaveInteger(o[(((V[(E[((cH[(oSx)]))])])))],(((((Ev[((oSx))]))))),((((otx)))),(0))endfunctionfunction C_x takes integer rLx,integer rlx returns nothinglocal integer rFx=rRx((A[(rLx)]))local integer rmxlocal integer oMxlocal integer rbxlocal integer rMxset nv[(rFx)]=(rlx)set Vv[(rFx)]=(rLx)set rmx=rRx((Ev[(rlx)]))
set nv[(rmx)]=(rlx)set Vv[(rmx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,QH,rbx)loop
exitwhen(rMx<q)call rfx(rgx(rLx,QH,rbx,rMx),rFx)set rMx=rMx-1endloopset rMx=rGx(rlx,QH,rbx)loop
exitwhen(rMx<q)call rfx(rhx(rlx,QH,rbx,rMx),rmx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call rkx(((rmx)))endfunctionfunction C0x takes integer oSx,integer iCx,integer rLx,integer rlx returns nothingcall CYx((oSx))call iKx(iCx)if rnx(rLx,PH,oSx)thencall RPx(rLx,qH)
endifcall rVx(rLx,ah+rlx)
if Czx(rlx,PH,oSx)thenendifcall CZx(rlx,ah+rLx)
call C_x(rLx,rlx)endfunctionfunction C1x takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])call C0x(oSx,iCx,MH[oSx],pH[oSx])endfunctionfunction C2x takes integer rLx,integer rlx returns nothinglocal integer rFx=rRx((A[(rLx)]))local integer rmxlocal integer oMxlocal integer rbxlocal integer rMxset nv[(rFx)]=(rlx)set Vv[(rFx)]=(rLx)set rmx=rRx((Ev[(rlx)]))
set nv[(rmx)]=(rlx)set Vv[(rmx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,sH,rbx)loop
exitwhen(rMx<q)call rfx(rgx(rLx,sH,rbx,rMx),rFx)set rMx=rMx-1endloopset rMx=rGx(rlx,sH,rbx)loop
exitwhen(rMx<q)call rfx(rhx(rlx,sH,rbx,rMx),rmx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call rkx(((rmx)))endfunctionfunction C3x takes integer oSx,integer rlx returns nothinglocal integer rLx=oSxlocal real iMx=(CQx((rlx),GH+(rWx(rLx,rlx))))local integer iCxif(iMx==.0)thenreturnendifset oSx=Cux()set iCx=iXx()set mH[oSx]=iCxset MH[oSx]=rLxset pH[oSx]=rlxset ge[(iCx)]=(oSx)if rUx(rLx,PH,oSx)thencall Avx(rLx,qH)
endifcall rwx(rLx,ah+rlx,oSx)
if CUx(rlx,PH,oSx)thenendifcall Cwx(rlx,ah+rLx,oSx)
call iDx(iCx,iMx,false,function C1x)
call C2x(rLx,rlx)endfunctionfunction C4x takes integer oSx,real oux returns nothinglocal real aCx=(lF[(oSx)])set oux=blx(aCx-oux,.0,(LF[((oSx))]))set lF[oSx]=ouxcall BOx(oSx,aCx,oux)endfunctionfunction C5x takes string oqx,string C6x returns stringlocal integer ivx=Qv
local integer rox=((StringLength(((oqx))))-1)loop
exitwhen(rox<0+1)if(r5x(oqx,rox-(StringLength(("ff000000")))-(StringLength(("|c")))+1,rox-(StringLength(("ff000000"))))=="|c")thenset rox=rox-(StringLength(("ff000000")))-(StringLength(("|c")))elseif(r5x(oqx,rox-(StringLength(("|r")))+1,rox)=="|r")thenset rox=rox-(StringLength(("|r")))else
if(ivx!=Qv)thenset oqx=(r5x((oqx),0,(ivx-1)))+C6x+XFx(oqx,ivx)endifset ivx=roxset rox=rox-1endifendloopreturn oqxendfunctionfunction C7x takes integer oSx,string icx,real Ovx,integer id,boolean C8x,real C9x,real dvx returns integerlocal real x=(GetUnitX(C[((oSx))]))+C9xlocal real y=(GetUnitY(C[((oSx))]))+dvxlocal real z=OMx(oSx,x,y)if C8x thenset icx=C5x(icx,"
")
endifreturn ccx(icx,Ovx,x,y,z,id)
endfunctionfunction dex takes integer oSx,string o9x,string otx returns stringif((o9x==null)or(otx==null))then
call o_x("FolderGameCache_StructString_Get","call DebugEx(\"GameCache Get: \"+missionKey+\";\"+key)","GameCache Get: "+o9x+";"+otx)return nullendifreturn GetStoredString(Kv[(oSx)],o9x,otx)endfunctionfunction dxx takes string rSx,string Xfx returns stringif(HaveStoredString(Kv[((uH))],(rSx),("var")))thenreturn(dex(uH,(rSx),"var"))endifreturn Xfxendfunctionfunction dox takes integer oSx,boolean OPx returns realif OPx thenreturn(UH[oSx]*(eb[((oSx))]))endifreturn UH[oSx]endfunctionfunction drx takes integer Ctx,integer dix returns nothinglocal integer Cqx=(EH[(Ctx)])local integer rYx=(IH[(Ctx)])local integer dax=(wh[(Ctx)])local integer dnx=(Wh[(Ctx)])local real dVx=(yh[(Ctx)])local real dEx=(Yh[(Ctx)])local integer rlx=(AH[(Ctx)])local integer dXx=rRx((A[(Cqx)]))local integer rmxlocal integer oMxlocal integer rbxlocal integer rMxset wH[(dXx)]=(dax)set qh[(dXx)]=(dix)set Mv[(dXx)]=(rYx)set nv[(dXx)]=(rlx)set WH[(dXx)]=(Ctx)set yH[(dXx)]=((dVx)*1.)
set YH[(dXx)]=((dEx)*1.)
set zH[(dXx)]=(dnx)set Vv[(dXx)]=(Cqx)set rmx=rRx((Ev[(rlx)]))
set wH[(rmx)]=(dax)set qh[(rmx)]=(dix)set Mv[(rmx)]=(rYx)set nv[(rmx)]=(rlx)set WH[(rmx)]=(Ctx)set yH[(rmx)]=((dVx)*1.)
set YH[(rmx)]=((dEx)*1.)
set zH[(rmx)]=(dnx)set Vv[(rmx)]=(Cqx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((ih))-1)*Iv+(((rbx))-1)))))))))loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((ih))-1)*Iv+(((rbx))-1))))+((rMx)))))),dXx)set rMx=rMx-1endloopset rMx=rAx(Cqx,ih,rbx)loop
exitwhen(rMx<q)call rfx(rgx(Cqx,ih,rbx,rMx),dXx)set rMx=rMx-1endloopset rMx=rGx(rlx,ih,rbx)loop
exitwhen(rMx<q)call rfx(rhx(rlx,ih,rbx,rMx),rmx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((dXx)))call rkx(((rmx)))endfunctionfunction dOx takes integer oSx returns booleanif((bH[(oSx)])>0)thenset BH[oSx]=true
return false
endifreturn trueendfunctionfunction dRx takes integer oSx returns nothingset iH[oSx]=falsecall rHx(nH)
endfunctionfunction dIx takes integer oSx returns nothingif(rH[oSx]>0)thenreturnendifif(xH[oSx]!=Z)thencall o_x("SpellInstance_Allocation_deallocCustom_confirm","call DebugEx(SpellInstance.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",eH+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset xH[oSx]=xH[(w)]set xH[(w)]=oSxcall dRx(oSx)endfunctionfunction dAx takes integer oSx returns nothingset rH[oSx]=rH[oSx]-1call dIx(oSx)endfunctionfunction dNx takes integer oSx returns nothingif not dOx(oSx)thenreturnendifcall dAx((oSx))endfunctionfunction dbx takes integer Ctx,integer dix returns nothinglocal integer Cqx=(EH[(Ctx)])local integer rYx=(IH[(Ctx)])local integer dnx=(Wh[(Ctx)])local integer rlx=(AH[(Ctx)])local boolean dBx=(dnx!=w)local integer oSx=Cqxlocal boolean dcxcall CSx(Ctx)call C3x(Cqx,rlx)call C4x(Cqx,(CQx((rlx),tH+(rYx))))if dBx thenset dcx=not(IsUnitAlly(C[(Cqx)],vx[((ze[(dnx)]))]))endifif I9x(Cqx,Wd)thencall C7x(Cqx,iSx((TH[((AH[(Ctx)]))]),"ff00ffff"),S2R(dxx("size","0.021")),(0),false,-dox(Cqx,true),.0)endifcall drx(Ctx,dix)if dBx thenif dcx thenset ZH=trueendifendifcall dNx(Ctx)set Uh[oSx]=wendfunctionfunction dCx takes integer oSx,integer Ctx,integer Cgx returns nothingcall dbx(Ctx,Cgx)endfunctionfunction ddx takes integer oSx,integer Cgx,integer rlx,integer rYx,integer dax,integer dnx,real dVx,real dEx returns nothing
local integer Ctx=CPx(oSx,rlx)set IH[(Ctx)]=(rYx)set wh[(Ctx)]=(dax)set Wh[(Ctx)]=(dnx)set yh[(Ctx)]=((dVx)*1.)
set Yh[(Ctx)]=((dEx)*1.)
call dCx((oSx),Ctx,Cgx)endfunctionfunction dDx takes integer oSx,integer Cgx returns nothinglocal integer oMx=(CKx(((Cgx)),uh))local integer rYxlocal integer dfx=(Uh[((oSx))])local integer rlxlocal integer dax=(wh[(dfx)])local integer dnx=(Wh[(dfx)])local real dVx=(yh[(dfx)])local real dEx=(Yh[(dfx)])loop
exitwhen(oMx<q)set rlx=(Clx(((Cgx)),uh,(oMx)))set rYx=(CLx(((Cgx)),Zh+(rlx)))call ddx(oSx,Cgx,rlx,rYx,dax,dnx,dVx,dEx)set oMx=oMx-1endloopendfunctionfunction dFx takes integer oSx,integer Cgx returns nothinglocal integer dgx=(Fh[(Cgx)])local integer dGx=rRx((Ph[(dgx)]))local integer oMxlocal integer rbxlocal integer rMxset qh[(dGx)]=(Cgx)set Qh[(dGx)]=(dgx)set Vv[(dGx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=CJx(dgx,Sh,rbx)loop
exitwhen(rMx<q)call rfx(Ckx(dgx,Sh,rbx,rMx),dGx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((dGx)))call dDx(oSx,Cgx)endfunctionfunction dhx takes integer oSx returns booleanif((xj[(oSx)])>0)thenset oj[oSx]=true
return false
endifreturn trueendfunctionfunction dHx takes integer oSx returns nothingset nj[oSx]=falsecall rHx(Vj)
endfunctionfunction djx takes integer oSx returns nothingif(rj[oSx]>0)thenreturnendifif(ij[oSx]!=Z)thencall o_x("OrderInstance_Allocation_deallocCustom_confirm","call DebugEx(OrderInstance.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",aj+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset ij[oSx]=ij[(w)]set ij[(w)]=oSxcall dHx(oSx)endfunctionfunction dJx takes integer oSx returns nothingset rj[oSx]=rj[oSx]-1call djx(oSx)endfunctionfunction dkx takes integer oSx returns nothingif not dhx(oSx)thenreturnendifcall dJx((oSx))endfunctionfunction dKx takes integer oSx returns nothinglocal integer I6x=(ej[(oSx)])if(I6x==w)thenreturnendifset ej[oSx]=wcall dkx(I6x)endfunctionfunction dlx takes integer oSx returns nothinglocal integer rLx=oSxendfunctionfunction dLx takes integer oSx returns nothingcall dKx((oSx))call dlx(oSx)endfunctionfunction dmx takes integer oSx,integer otx returns booleanreturn((LoadInteger(o[((V[(E[((nb[(oSx)]))])]))],((((Vb[((oSx))])))),(((otx)))))==0)
endfunctionfunction dMx takes integer oSx,integer o9x,integer otx returns integerlocal integer rvx=(0+(LoadInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx))))))local integer ouxif(rvx==0)thenreturn 0
endifset oux=(LoadInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx)+(rvx)))))call SaveInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx))),(((rvx-1)-0)))call SaveInteger(o[(((D[oSx])))],((o9x)),((oTx(otx,(oux)))),(0))
call SaveInteger(o[(((V[(E[(oSx)])])))],(((o9x))),(((otx+rvx))),(0))
return ouxendfunctionfunction dpx takes integer oSx,integer otx returns integerreturn dMx(nb[(oSx)],(Vb[((oSx))]),otx)endfunctionfunction dPx takes integer oSx returns integerreturn(LoadInteger(o[((V[(E[((X))])]))],((((GetUnitCurrentOrder(C[(oSx)]))))),(((Aj)))))
endfunctionfunction dqx takes integer oSx,integer otx,integer oux returns booleanreturn rux(nb[(oSx)],(Vb[((oSx))]),otx,oux)endfunctionfunction dQx takes integer oSx,integer oux returns nothingif(I8x((oSx),Ob,(oux)))thencall o_x("UnitList_Add","call DebugEx(UnitList.NAME + \" Add: \" + value.GetName() + \" already in \" + this.GetName())",Nj+" Add: "+(GetUnitName(C[(oux)]))+" already in "+(bj[(oSx)]))
returnendifcall dqx(oSx,Ob,oux)
endfunctionfunction dsx takes integer oSx,integer o9x,integer otx,integer dSx,integer dtx,integer dTx returns nothinglocal integer rvx=(0+(LoadInteger(o[((V[(E[(((dSx)))])]))],(((dtx))),(((dTx))))))local integer duxlocal integer oMxlocal integer n4xlocal integer ouxif(rvx==0)thenreturnendifset dux=0set oMx=qset n4x=(0+(LoadInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx))))))loop
set oux=(LoadInteger(o[((V[(E[(((dSx)))])]))],(((dtx))),(((dTx)+(oMx)))))if not((LoadInteger(o[((D[((oSx))]))],(((o9x))),(oTx(((otx)),(((oux)))))))!=0)thenset dux=dux+1call SaveInteger(o[((D[oSx]))],(o9x),(oTx(otx,(oux))),(n4x+dux))
call SaveInteger(o[((V[(E[(oSx)])]))],((o9x)),((otx+n4x+dux)),((oux)))endifset oMx=oMx+1exitwhen(oMx>rvx)endloopcall SaveInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx))),(((n4x+dux)-0)))
endfunctionfunction dUx takes integer oSx,integer otx,integer dSx returns nothingcall dsx(nb[(oSx)],(Vb[((oSx))]),otx,nb[(dSx)],(Vb[((dSx))]),otx)endfunctionfunction dwx takes integer oSx,integer o9x,integer otx returns nothinglocal integer oMx=(0+(LoadInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx))))))local integer ouxloop
exitwhen(oMx<q)set oux=(LoadInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx)+(oMx)))))call SaveInteger(o[(((V[(E[(oSx)])])))],(((o9x))),(((otx+oMx))),(0))
call SaveInteger(o[(((D[oSx])))],((o9x)),((oTx(otx,(oux)))),(0))
set oMx=oMx-1endloopcall SaveInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx))),(((0)-0)))endfunctionfunction dWx takes integer oSx,integer otx returns nothingcall dwx((nb[(oSx)]),((Vb[((oSx))])),(otx))endfunctionfunction dyx takes integer oSx,integer oux returns nothingcall dUx(oSx,Ob,oux)
call dWx((oux),Ob)endfunctionfunction dYx takes nothing returns nothinglocal integer rLxloop
set rLx=(dpx((Ej),Ob))exitwhen(rLx==w)
if(dPx(rLx)==w)thencall dLx((rLx))else
call dQx(Bj,rLx)
endifendloopif(dmx((Bj),Ob))then
call ikx(Xj)
else
call dyx(Ej,Bj)endifendfunctionfunction dzx takes integer oSx returns nothingif(I8x((Ej),Ob,(oSx)))thenreturnendifif(dmx((Ej),Ob))then
call iDx(Xj,Rj,true,function dYx)endifcall dQx(Ej,oSx)
endfunctionfunction dZx takes integer oSx,integer d_x returns nothingif not(I8x((vj),Ob,(oSx)))thenreturnendifcall dLx(oSx)set ej[((oSx))]=(d_x)call dzx(oSx)endfunctionfunction d0x takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((dj[oSx]))])]))],((((cj[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))endfunctionfunction d1x takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((dj[oSx]))])]))],((((cj[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))endfunctionfunction d2x takes integer oSx,integer I6x returns nothinglocal integer rLx=oSxlocal integer Rox=(Oh[(I6x)])local integer d3x=rRx((cj[(Rox)]))local integer rFxlocal integer oMxlocal integer rbxlocal integer rMxset Ah[(d3x)]=(Rox)set Vv[(d3x)]=(rLx)set rFx=rRx((A[(rLx)]))set Ah[(rFx)]=(Rox)set Vv[(rFx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,Cj,rbx)loop
exitwhen(rMx<q)call rfx(rgx(rLx,Cj,rbx,rMx),rFx)set rMx=rMx-1endloopset rMx=d0x(Rox,Cj,rbx)loop
exitwhen(rMx<q)call rfx(d1x(Rox,Cj,rbx,rMx),d3x)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((d3x)))call rkx(((rFx)))endfunctionfunction d4x takes integer oSx,integer I6x returns nothinglocal integer Rox=(Oh[(I6x)])local integer d5x=CNx((oSx),Rox)
local boolean d6x=falselocal integer d7xlocal integer rFxlocal integer d8xlocal integer d9xlocal integer Dvxif(d5x!=w)thenif((Pb[(d5x)])==Rox)then
call RVx((oSx),w)elseif((sb[(d5x)])==Rox)then
call RVx((oSx),d5x)else
set d7x=(Ih[(d5x)])if(d7x!=w)thenset rFx=rRx(0)set Ah[(rFx)]=(Rox)set Vv[(rFx)]=(oSx)set Mv[(rFx)]=((osx((((oSx))),N+(d5x))))
set nv[(rFx)]=(d5x)if not Cbx(d7x,rFx)thencall CCx((oSx))set d6x=true
endifcall rkx(((rFx)))if d6x thenreturnendifendifendifendifif Cdx(Rox)thenset d8x=(ze[((oSx))])set d9x=(osx((((oSx))),Dh+(((Rox)-Ch))))
set Dvx=(fh[((Fh[(d9x)]))])if(Dvx>CDx(d8x,PLAYER_STATE_RESOURCE_GOLD))thencall CGx(d9x,oSx)call cCx((oSx),iSx("Not enough gold!","ffff0000"),.022,jh+oSx)returnendifcall CHx(d8x,PLAYER_STATE_RESOURCE_GOLD,Dvx)
if((Cjx(((d9x)),mh,(Mh)))and(ph[((oSx))]))thencall dFx((oSx),d9x)endifendifcall dZx((oSx),I6x)call d2x(oSx,I6x)endfunctionfunction Dex takes integer oSx returns nothinglocal integer I6xset nh[oSx]=falseset I6x=Xh[oSx]if(I6x==w)thenreturnendifset Xh[oSx]=wcall d4x(oSx,I6x)endfunctionfunction Dxx takes integer oSx,integer I6x returns nothinglocal integer rLx=oSxlocal integer Rox=(Oh[(I6x)])local real dVx=(fj[(I6x)])local real dEx=(Fj[(I6x)])local integer d3x=rRx((cj[(Rox)]))local integer rFxlocal integer oMxlocal integer rbxlocal integer rMxset Ah[(d3x)]=(Rox)set yH[(d3x)]=((dVx)*1.)
set YH[(d3x)]=((dEx)*1.)
set Vv[(d3x)]=(rLx)set rFx=rRx((A[(rLx)]))set Ah[(rFx)]=(Rox)set yH[(rFx)]=((dVx)*1.)
set YH[(rFx)]=((dEx)*1.)
set Vv[(rFx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,gj,rbx)loop
exitwhen(rMx<q)call rfx(rgx(rLx,gj,rbx,rMx),rFx)set rMx=rMx-1endloopset rMx=d0x(Rox,gj,rbx)loop
exitwhen(rMx<q)call rfx(d1x(Rox,gj,rbx,rMx),d3x)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((d3x)))call rkx(((rFx)))endfunctionfunction Dox takes integer oSx,integer I6x returns nothingcall dZx((oSx),I6x)call Dxx(oSx,I6x)endfunctionfunction Drx takes integer oSx returns nothinglocal integer I6xset Vh[oSx]=falseset I6x=Dj[oSx]if(I6x==w)thenreturnendifset Dj[oSx]=wcall Dox(oSx,I6x)endfunctionfunction Dix takes integer oSx,integer I6x returns nothinglocal integer rLx=oSxlocal integer Rox=(Oh[(I6x)])local integer dax=(hj[(I6x)])local integer dnx=(Hj[(I6x)])local integer d3x=rRx((cj[(Rox)]))local integer rFxlocal integer Daxlocal integer oMxlocal integer rbxlocal integer rMxset wH[(d3x)]=(dax)set Ah[(d3x)]=(Rox)set zH[(d3x)]=(dnx)set Vv[(d3x)]=(rLx)set rFx=rRx((A[(rLx)]))set wH[(rFx)]=(dax)set Ah[(rFx)]=(Rox)set zH[(rFx)]=(dnx)set Vv[(rFx)]=(rLx)set Dax=rRx((A[(dnx)]))set wH[(Dax)]=(dax)set Ah[(Dax)]=(Rox)set zH[(Dax)]=(rLx)set Vv[(Dax)]=(dnx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,jj,rbx)loop
exitwhen(rMx<q)call rfx(rgx(rLx,jj,rbx,rMx),rFx)set rMx=rMx-1endloopset rMx=d0x(Rox,jj,rbx)loop
exitwhen(rMx<q)call rfx(d1x(Rox,jj,rbx,rMx),d3x)set rMx=rMx-1endloopset rMx=rAx(dnx,Jj,rbx)loop
exitwhen(rMx<q)call rfx(rgx(dnx,Jj,rbx,rMx),Dax)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((d3x)))call rkx(((rFx)))call rkx(((Dax)))endfunctionfunction Dnx takes integer oSx,integer I6x returns nothingcall dZx((oSx),I6x)call Dix(oSx,I6x)endfunctionfunction DVx takes integer oSx returns nothinglocal integer I6xset Eh[oSx]=falseset I6x=Gj[oSx]if(I6x==w)thenreturnendifset Gj[oSx]=wcall Dnx(oSx,I6x)endfunctionfunction DEx takes integer oSx returns nothingcall Dex(oSx)call Drx(oSx)call DVx(oSx)endfunctionfunction DXx takes integer oSx,integer rlx returns nothinglocal integer rLx=oSxlocal integer DOx=B[rlx]
local integer rYxset oSx=osx(rLx,ah+rlx)if(oSx==w)thenreturnendifset rYx=rWx(rLx,rlx)
call COx(rLx)call CRx(rLx,DOx)call rtx(rLx,DOx)call rZx(rLx,DOx,rYx)call DEx(rLx)call C0x(oSx,mH[oSx],rLx,rlx)endfunctionfunction DRx takes integer oSx,integer rlx returns nothingcall DXx(oSx,rlx)endfunctionfunction DIx takes nothing returns booleanlocal integer rFx=(bv)call DRx((Vv[(rFx)]),(nv[(rFx)]))return trueendfunctionfunction DAx takes integer oSx returns nothinglocal integer oMx=(CIx(((oSx)),Q))loop
exitwhen(oMx<q)call DXx((oSx),((CAx(((oSx)),Q,(oMx)))))
set oMx=oMx-1endloopendfunctionfunction DNx takes nothing returns booleanlocal integer rFx=(bv)if(kj==w)thencall DAx(ROx())else
call DRx(ROx(),kj)endifreturn trueendfunctionfunction Dbx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])local integer rlx=rsx(Xsx(r4x,1))if(rlx==w)thenif(Xsx(r4x,1)!="all")thencall o_x("CommandRefreshAbility_Event_Chat","call DebugEx(\"invalid spell\")","invalid spell")return trueendifendifset kj=rlxcall Rvx(oDx,function DNx)return trueendfunctionfunction DBx takes integer oSx,integer otx,boolean oux returns nothingcall SaveBoolean(o[((V[(E[((xA[(oSx)]))])]))],((((aA[((oSx))])))),(((otx))),(((oux))))endfunctionfunction Dcx takes integer oSx returns nothingif(oSx==w)thencall o_x("Event_AddToStatics","call DebugEx(\"event is null\")","event is null")
endifcall DBx(oSx,lj,true)call rux(X,Se,(oA[(oSx)]),oSx)endfunctionfunction DCx takes integer oSx returns nothingcall DBx(oSx,lj,false)call rrx(X,Se,(oA[(oSx)]),oSx)endfunctionfunction Ddx takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((nb[(oSx)]))])]))],((((Vb[((oSx))])))),(((otx))))))endfunctionfunction DDx takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((nb[(oSx)]))])]))],((((Vb[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction Dfx takes nothing returns nothinglocal integer rFx=rRx(0)
set Vv[(rFx)]=(ROx())set pj[(rFx)]=(mj[Lj])call XGx(Mj[Lj],rFx)
call rkx(((rFx)))endfunctionfunction DFx takes integer oSx,code XCx,integer I6x returns nothingset Lj=Lj+1set mj[Lj]=I6xset Mj[Lj]=Xkx(XCx)call ForGroup(kb[oSx],function Dfx)set Lj=Lj-1endfunctionfunction Dgx takes integer oSx,code XCx,integer I6x returns nothinglocal integer oMx=Ddx(oSx,Ob)local integer Rexif(oMx<q)thenreturnendifset Rex=O5x()loop
call GroupAddUnit(kb[(Rex)],C[(DDx(oSx,Ob,oMx))])set oMx=oMx-1exitwhen(oMx<q)endloopcall DFx(Rex,XCx,I6x)call O9x(Rex)endfunctionfunction DGx takes integer oSx,code XCx returns nothingcall Dgx(oSx,XCx,w)endfunctionfunction Dhx takes nothing returns booleanlocal integer rFx=(bv)call DAx(ROx())return trueendfunctionfunction DHx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])set Kj=not Kjif Kj thencall Dcx(rh)
else
call DCx(rh)
endifcall DGx(Pj,function Dhx)return trueendfunctionfunction Djx takes nothing returns booleanset rh=Xdx("CommandRefreshAbility_Init: set CommandRefreshAbility.NO_CD_CAST_EVENT = Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function CommandRefreshAbility.Event_NoCd_Cast)",ih,MI,function DIx)call Xzx("-refresh",function Dbx)call Xzx("-nocd",function DHx)return trueendfunctionfunction DJx takes nothing returns booleancall Xxx(function Djx,"CommandRefreshAbility_Init")return trueendfunctionfunction Dkx takes nothing returns booleanset qj=VXx(Qj)return trueendfunctionfunction DKx takes nothing returns booleanlocal integer rFx=(bv)call Owx(ROx())return trueendfunctionfunction Dlx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])call Rvx(oDx,function DKx)return trueendfunctionfunction DLx takes nothing returns booleancall Xzx("-remove",function Dlx)
return trueendfunctionfunction Dmx takes nothing returns booleancall Xxx(function DLx,"CommandRemoveUnit_Init")return trueendfunctionfunction DMx takes nothing returns booleanset sj=VXx(Sj)return trueendfunctionfunction Dpx takes integer oSx returns realreturn((eb[(oSx)])+(uj[(oSx)]))endfunctionfunction DPx takes integer oSx returns nothinglocal real o5x=Dpx(oSx)call SetUnitScale(C[(oSx)],o5x,o5x,o5x)endfunctionfunction Dqx takes integer oux,integer bLx,integer nYx returns integerreturn(R2I(((iUx(((R2I(((iAx((bLx),(oux)))*1.)))),(nYx)))*1.)))endfunctionfunction DQx takes integer oSx,real o5x returns nothingif((o5x<xJ)or(o5x>oJ))thencall o_x("FolderDummyUnit_FolderPosition_StructX_Set","call DebugEx(FolderDummyUnit_FolderPosition_StructX.NAME + \" out of bounds \" + DummyUnit(this).GetName() + \" \" + R2S(val))",rJ+" out of bounds "+(GetUnitName(vJ[((oSx))]))+" "+R2S(o5x))
returnendifset iJ[oSx]=o5xcall SetUnitX(vJ[(oSx)],o5x)
endfunctionfunction Dsx takes integer oSx returns realreturn GetUnitX(C[(oSx)])endfunctionfunction DSx takes integer oSx,real o5x returns nothingif((o5x<aJ)or(o5x>nJ))thencall o_x("FolderDummyUnit_FolderPosition_StructY_Set","call DebugEx(FolderDummyUnit_FolderPosition_StructY.NAME + \" out of bounds \" + DummyUnit(this).GetName() + \" \" + R2S(val))",VJ+" out of bounds "+(GetUnitName(vJ[((oSx))]))+" "+R2S(o5x))
returnendifset EJ[oSx]=o5xcall SetUnitY(vJ[(oSx)],o5x)
endfunctionfunction Dtx takes integer oSx returns realreturn GetUnitY(C[(oSx)])endfunctionfunction DTx takes integer oSx,integer Rox,integer Iix returns booleancall DQx((oSx),Dsx(Iix))
call DSx((oSx),Dtx(Iix))
return(IssueTargetOrderById(vJ[((oSx))],pb[(Rox)],C[((Iix))]))endfunctionfunction Dux takes integer oSx,integer Iax,integer rYx,integer I6x returns booleanlocal integer ASx=Asx(oSx,Iax,rYx,I6x)if(ASx==w)thenreturn false
endifcall Aax((X),(Zb),(oSx),(Iax),(w),(ASx),0)return trueendfunctionfunction DUx takes integer oSx returns nothingendfunctionfunction Dwx takes integer oSx returns nothinglocal real DWx=Dpx(oSx)-(Uj[((Tf[((oSx))]))])local integer Awxcall UnitRemoveAbility(C[(((((oSx)))))],(('BUSC')))if(DWx==0)thencall AZx((oSx),wj)call DPx(oSx)returnendifif I9x((oSx),Qc)then
call DPx(oSx)returnendifset Awx=Wj[Dqx((R2I(((((DWx)-yj)*1./ Yj)*1.))),zj,Zj)]call UnitAddAbility(vJ[((eJ))],(Awx))call DTx(eJ,XJ,oSx)call UnitRemoveAbility(vJ[((eJ))],(Awx))
call DPx(oSx)call Dux(((oSx)),(wj),(1),w)
call Dux(((oSx)),(OJ),(1),w)
call DUx((oSx))endfunctionfunction Dyx takes integer oSx,real o5x returns nothingset eb[oSx]=o5xcall Dwx(oSx)endfunctionfunction DYx takes integer oSx,real oux returns nothingcall Dyx(oSx,(eb[(oSx)])+oux)endfunctionfunction Dzx takes integer oSx returns integerset cJ[oSx]=true
set CJ[oSx]=falsecall rEx(dJ)
return oSxendfunctionfunction DZx takes nothing returns integerlocal integer oSxif(IJ==8190)then
call o_x("FolderUnit_FolderScale_StructTimed_Allocation_allocCustom","call DebugEx(FolderUnit_FolderScale_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",AJ+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(NJ[(w)]==w)thenset bJ=bJ+1set oSx=bJelse
set oSx=NJ[(w)]set NJ[(w)]=NJ[NJ[(w)]]endifset NJ[oSx]=Zset BJ[oSx]=1call Dzx(oSx)return oSxendfunctionfunction D_x takes integer oSx returns booleanset hJ=hJ+1set HJ[hJ]=oSxset jJ[oSx]=hJ+1
return(hJ==0)endfunctionfunction D0x takes integer oSx,real o5x returns nothingset eb[oSx]=o5xcall DPx(oSx)endfunctionfunction D1x takes integer oSx,real o5x returns nothingcall D0x(oSx,(eb[(oSx)])+o5x)endfunctionfunction D2x takes nothing returns nothinglocal integer oMx=hJ
local integer oSxloop
set oSx=HJ[oMx]call D1x(fJ[oSx],FJ[oSx])set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction D3x takes integer oSx returns nothingset cJ[oSx]=falsecall rHx(dJ)
endfunctionfunction D4x takes integer oSx returns nothingif(BJ[oSx]>0)thenreturnendifif(NJ[oSx]!=Z)thencall o_x("FolderUnit_FolderScale_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderScale_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",AJ+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset NJ[oSx]=NJ[(w)]set NJ[(w)]=oSxcall D3x(oSx)endfunctionfunction D5x takes integer oSx returns nothingset BJ[oSx]=BJ[oSx]-1call D4x(oSx)endfunctionfunction D6x takes integer oSx returns booleanlocal integer oLx=(jJ[(oSx)])set jJ[HJ[hJ]]=oLxset HJ[oLx-1]=HJ[hJ]
set jJ[oSx]=0set hJ=hJ-1return(hJ==F)endfunctionfunction D7x takes integer oSx,integer iCx,integer rLx returns nothingcall D5x((oSx))call iKx(iCx)if rnx(rLx,gJ,oSx)thencall RPx(rLx,GJ)
endifif D6x(oSx)thencall ikx(JJ)
endifendfunctionfunction D8x takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])call D7x(oSx,iCx,fJ[oSx])call Dwx(fJ[oSx])endfunctionfunction D9x takes integer oSx,real fvx,real iMx returns nothing
local integer rLx=oSxlocal integer fexlocal integer iCxif(iMx==.0)thencall DYx((oSx),fvx)returnendifset fex=(R2I(((iMx*1./ RJ)*1.)))
set oSx=DZx()set iCx=iXx()set DJ[oSx]=iCxset fJ[oSx]=rLxset FJ[oSx]=fvx*1./ fexset ge[(iCx)]=(oSx)if rUx(rLx,gJ,oSx)thencall Avx(rLx,GJ)
endifif D_x(oSx)thencall iDx(JJ,RJ,true,function D2x)endifcall iDx(iCx,iMx,false,function D8x)
endfunctionfunction fxx takes nothing returns booleanlocal integer rFx=(bv)call D9x(ROx(),Tj,tj)return trueendfunctionfunction fox takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])local real fvx=(S2R((Xsx(r4x,1))))local real iMx=(S2R((Xsx(r4x,2))))set tj=iMxset Tj=fvxcall Rvx(oDx,function fxx)return trueendfunctionfunction frx takes nothing returns booleancall Xzx("-scale",function fox)return trueendfunctionfunction fix takes nothing returns booleancall Xxx(function frx,"CommandScaleUnit_Init")return trueendfunctionfunction fax takes nothing returns booleanset kJ=VXx(KJ)return trueendfunctionfunction fnx takes integer oSx,integer rlx,integer rYx returns nothingcall r0x(oSx,rlx,rYx)endfunctionfunction fVx takes nothing returns booleanlocal integer rFx=(bv)call fnx(ROx(),LJ,lJ)return trueendfunctionfunction fEx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])local string fXx=Xsx(r4x,1)local integer rlx=rsx(fXx)local integer rYx=(S2I((Xsx(r4x,2))))if(rlx==w)thenset rlx=XDx(fXx,F)if(rlx==F)thencall o_x("CommandSpell_Event_Chat","call DebugEx(\"invalid spell\")","invalid spell")return trueendifendifset lJ=rYxset LJ=rlxcall Rvx(oDx,function fVx)return trueendfunctionfunction fOx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oMx=mJ
local integer oDx=(ZA[(rFx)])call PreloadGenStart()loop
exitwhen(oMx<0)call o_x("CommandSpell_Event_ListAll_Chat","call DebugEx(Spell.ALL[iteration].GetName())",(TH[(MJ[oMx])]))set oMx=oMx-1endloopreturn trueendfunctionfunction fRx takes nothing returns booleancall Xzx("-spell",function fEx)call Xzx("-spellListAll",function fOx)return trueendfunctionfunction fIx takes nothing returns booleancall Xxx(function fRx,"CommandSpell_Init")return trueendfunctionfunction fAx takes nothing returns booleanset pJ=VXx(PJ)return trueendfunctionfunction fNx takes integer Iix,integer rYx returns nothinglocal integer oSx=Iixlocal integer rvxif not(osx((((Iix))),(Wb+(sJ)))>0)thenset rvx=1else
set rvx=SJ[oSx]+1endifset SJ[oSx]=rvxcall Dux((Iix),(sJ),(1),w)call Dux((Iix),(tJ[rvx]),(rYx),w)endfunctionfunction fbx takes nothing returns booleanlocal integer rFx=(bv)call fNx(ROx(),QJ)return trueendfunctionfunction fBx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])local integer rYx=(S2I((Xsx(r4x,1))))local real iMx=(S2R((Xsx(r4x,2))))set qJ=iMxset QJ=rYxcall Rvx(oDx,function fbx)return trueendfunctionfunction fcx takes nothing returns booleancall Xzx("-swift",function fBx)return trueendfunctionfunction fCx takes nothing returns booleancall Xxx(function fcx,"CommandSwift_Init")return trueendfunctionfunction fdx takes nothing returns booleanset TJ=VXx(uJ)return trueendfunctionfunction fDx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])local integer o5xcall Aax((X),(-$7FFFFEF0),(45),(53),(0),($BA),0)
set o5x=RMx(X,-$7FFFFEF0,47,'{',0)call o_x("CommandTest_Event_Chat","call DebugEx(\"TEST: \" + I2S(val))","TEST: "+I2S(o5x))return trueendfunctionfunction ffx takes nothing returns booleancall Xzx("-test",function fDx)return trueendfunctionfunction fFx takes nothing returns booleancall Xxx(function ffx,"CommandTest_Init")return trueendfunctionfunction fgx takes nothing returns booleanset UJ=VXx(wJ)return trueendfunctionfunction fGx takes string oqx,real Xfx returns reallocal real o5x=S2R(oqx)if(o5x!=.0)thenreturn o5xendifif((oqx=="0")or(oqx=="0."))thenreturn o5xendifset oqx=XFx(oqx,0+1)
if(XQx(oqx,"0",0)==Qv)thenreturn o5xendifreturn Xfxendfunctionfunction fhx takes nothing returns integerreturn(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetLocalPlayer())))))),((((R))))))endfunctionfunction fHx takes integer oSx,integer otx returns realreturn(LoadReal(o[((V[(E[((I[(oSx)]))])]))],((((A[((oSx))])))),(((otx)))))endfunctionfunction fjx takes integer oSx,real izx,real iZx,real i_x,real i0x returns nothinglocal integer oDx=fhx()set vk[(oSx)]=((izx)*1.)
set ek[(oSx)]=((iZx)*1.)
set xk[(oSx)]=((i_x)*1.)
set ok[(oSx)]=((i0x)*1.)
if(rk[((oSx))])thenset i0x=ikendifcall SetUnitVertexColor(C[(oSx)],(R2I(((izx+(fHx(((oSx)),ak+(oDx))))*1.))),(R2I(((iZx+(fHx(((oSx)),nk+(oDx))))*1.))),(R2I(((i_x+(fHx(((oSx)),Vk+(oDx))))*1.))),(R2I(((i0x+(fHx(((oSx)),Ek+(oDx))))*1.))))endfunctionfunction fJx takes integer oSx,real izx,real iZx,real i_x,real i0x returns nothingcall fjx(oSx,(vk[(oSx)])+izx,(ek[(oSx)])+iZx,(xk[(oSx)])+i_x,(ok[(oSx)])+i0x)endfunctionfunction fkx takes integer oSx returns integerset bk[oSx]=true
set Bk[oSx]=falsecall rEx(ck)
return oSxendfunctionfunction fKx takes nothing returns integerlocal integer oSxif(Ok==8190)then
call o_x("FolderUnit_FolderVertexColor_StructTimed_Allocation_allocCustom","call DebugEx(FolderUnit_FolderVertexColor_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Rk+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Ik[(w)]==w)thenset Ak=Ak+1set oSx=Akelse
set oSx=Ik[(w)]set Ik[(w)]=Ik[Ik[(w)]]endifset Ik[oSx]=Zset Nk[oSx]=1call fkx(oSx)return oSxendfunctionfunction flx takes integer oSx returns booleanset Hk=Hk+1set jk[Hk]=oSxset Jk[oSx]=Hk+1
return(Hk==0)endfunctionfunction fLx takes nothing returns nothinglocal integer oMx=Hk
local integer oSxloop
set oSx=jk[oMx]call fJx(gk[oSx],Ck[oSx],dk[oSx],Dk[oSx],fk[oSx])set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction fmx takes integer oSx returns nothingset bk[oSx]=falsecall rHx(ck)
endfunctionfunction fMx takes integer oSx returns nothingif(Nk[oSx]>0)thenreturnendifif(Ik[oSx]!=Z)thencall o_x("FolderUnit_FolderVertexColor_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderVertexColor_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Rk+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Ik[oSx]=Ik[(w)]set Ik[(w)]=oSxcall fmx(oSx)endfunctionfunction fpx takes integer oSx returns nothingset Nk[oSx]=Nk[oSx]-1call fMx(oSx)endfunctionfunction fPx takes integer oSx returns booleanlocal integer oLx=(Jk[(oSx)])set Jk[jk[Hk]]=oLxset jk[oLx-1]=jk[Hk]
set Jk[oSx]=0set Hk=Hk-1return(Hk==F)endfunctionfunction fqx takes integer oSx,integer iCx,integer rLx returns nothingcall fpx((oSx))call iKx(iCx)if rnx(rLx,Gk,oSx)thencall RPx(rLx,hk)
endifif fPx(oSx)thencall ikx(kk)
endifendfunctionfunction fQx takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])call fqx(oSx,iCx,gk[oSx])endfunctionfunction fsx takes integer oSx,real izx,real iZx,real i_x,real i0x,real iMx returns nothinglocal integer rLx=oSxlocal integer fexlocal integer iCxif(iMx==.0)thencall fJx((oSx),izx,iZx,i_x,i0x)returnendifset fex=(R2I(((iMx*1./ Xk)*1.)))
set oSx=fKx()set iCx=iXx()set Ck[oSx]=izx*1./ fexset dk[oSx]=iZx*1./ fexset Dk[oSx]=i_x*1./ fexset fk[oSx]=i0x*1./ fexset Fk[oSx]=iCxset gk[oSx]=rLxset ge[(iCx)]=(oSx)if rUx(rLx,Gk,oSx)thencall Avx(rLx,hk)
endifif flx(oSx)thencall iDx(kk,Xk,true,function fLx)endifcall iDx(iCx,iMx,false,function fQx)
endfunctionfunction fSx takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=ROx()local real izx=WJlocal real iZx=yJlocal real i_x=YJlocal real i0x=zJif(izx==-1)thenset izx=(vk[(Iix)])endifif(iZx==-1)thenset iZx=(ek[(Iix)])endifif(i_x==-1)thenset i_x=(xk[(Iix)])endifif(i0x==-1)thenset i0x=(ok[(Iix)])endifcall fsx(Iix,izx,iZx,i_x,i0x,ZJ)
return trueendfunctionfunction ftx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])local real izx=fGx(Xsx(r4x,1),-1)local real iZx=fGx(Xsx(r4x,2),-1)local real i_x=fGx(Xsx(r4x,3),-1)local real i0x=fGx(Xsx(r4x,4),-1)local real iMx=(S2R((Xsx(r4x,5))))set WJ=izxset yJ=iZxset YJ=i_xset zJ=i0xset ZJ=iMxcall Rvx(oDx,function fSx)return trueendfunctionfunction fTx takes nothing returns booleancall Xzx("-vertexcolor",function ftx)return trueendfunctionfunction fux takes nothing returns booleancall Xxx(function fTx,"CommandVertexColorUnit_Init")
return trueendfunctionfunction fUx takes nothing returns booleanset Kk=VXx(lk)return trueendfunctionfunction fwx takes integer oSx,real o5x returns nothingif((o5x<xJ)or(o5x>oJ))thencall o_x("FolderUnit_FolderPosition_StructX_Set","call DebugEx(FolderUnit_FolderPosition_StructX.NAME + \" out of bounds \" + Unit(this).GetName() + \" \" + R2S(val))",Mk+" out of bounds "+(GetUnitName(C[((oSx))]))+" "+R2S(o5x))
returnendifcall SetUnitX(C[(oSx)],o5x)endfunctionfunction fWx takes integer oSx,real o5x returns nothingif((o5x<aJ)or(o5x>nJ))thencall o_x("FolderUnit_FolderPosition_StructY_Set","call DebugEx(FolderUnit_FolderPosition_StructY.NAME + \" out of bounds \" + Unit(this).GetName() + \" \" + R2S(val))",pk+" out of bounds "+(GetUnitName(C[((oSx))]))+" "+R2S(o5x))
returnendifcall SetUnitY(C[(oSx)],o5x)endfunctionfunction fyx takes integer oSx,real x,real y,real z returns nothingcall SetUnitFlyHeight(C[(oSx)],z-X_x(x,y),.0)endfunctionfunction fYx takes integer oSx returns realreturn OMx(oSx,(GetUnitX(C[(((oSx)))])),(GetUnitY(C[(((oSx)))])))endfunctionfunction fzx takes integer oSx,real x,real y returns nothing
call fwx(oSx,x)call fWx(oSx,y)call fyx(oSx,x,y,fYx(oSx))endfunctionfunction fZx takes nothing returns booleanlocal integer rFx=(bv)call fzx(ROx(),Lk,mk)return trueendfunctionfunction f_x takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])local real x=(S2R((Xsx(r4x,1))))
local real y=(S2R((Xsx(r4x,2))))
set Lk=x
set mk=y
call Rvx(oDx,function fZx)return trueendfunctionfunction f0x takes nothing returns booleancall Xzx("-move",function f_x)return trueendfunctionfunction f1x takes nothing returns booleancall Xxx(function f0x,"MoveUnit_Init")return trueendfunctionfunction f2x takes nothing returns booleanset Pk=VXx(qk)return trueendfunctionfunction f3x takes string oqx returns booleanreturn(oqx=="true")endfunctionfunction f4x takes integer oSx,boolean f5x returns nothinglocal real x=(GetUnitX(C[((oSx))]))local real y=(GetUnitY(C[((oSx))]))if f5x thencall aKx("ping unit "+(GetUnitName(C[(oSx)]))+" at "+R2S(x)+";"+R2S(y))endifcall PingMinimapEx(x,y,5,(GetRandomInt((0),($FF))),(GetRandomInt((0),($FF))),(GetRandomInt((0),($FF))),true)
endfunctionfunction f6x takes nothing returns booleanlocal integer rFx=(bv)call f4x(ROx(),Qk)return trueendfunctionfunction f7x takes nothing returns booleanlocal integer rFx=(bv)set Qk=f3x(Xsx((lA[(rFx)]),1))call DGx(Eb,function f6x)return trueendfunctionfunction f8x takes nothing returns booleancall Xzx("-pingSpawns",function f7x)
return trueendfunctionfunction f9x takes nothing returns booleancall Xxx(function f8x,"PingSpawns_Init")
return trueendfunctionfunction Fvx takes nothing returns booleanset sk=VXx(Sk)return trueendfunctionfunction Fex takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer id=(S2I((Xsx(r4x,1))))
call o_x("RequestEvent_Event_Chat","call DebugEx(Event(id).GetName())",(jA[((id))]))
return trueendfunctionfunction Fxx takes nothing returns booleancall Xzx("-event",function Fex)return trueendfunctionfunction Fox takes nothing returns booleancall Xxx(function Fxx,"RequestEvent_Init")return trueendfunctionfunction Frx takes nothing returns booleanset tk=VXx(Tk)return trueendfunctionfunction Fix takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local string oux=Xsx(r4x,1)local integer Bvxlocal string o7x
if(oux==null)thencall o_x("RequestKeyMacro_Event_Chat","call DebugEx(\"invalid syntax\")","invalid syntax")return trueendifset Bvx=(S2I((oux)))
if(Bvx==0)thencall o_x("RequestKeyMacro_Event_Chat","call DebugEx(\"invalid syntax\")","invalid syntax")return trueendifset o7x=o4x(Bvx)
if(o7x==null)thencall o_x("RequestKeyMacro_Event_Chat","call DebugEx(\"no key found under \" + Integer.ToString(valueI))","no key found under "+(I2S((Bvx))))
return trueendifcall o_x("RequestKeyMacro_Event_Chat","call DebugEx(result)",o7x)return trueendfunctionfunction Fax takes nothing returns booleancall Xzx("-key",function Fix)return trueendfunctionfunction Fnx takes nothing returns booleancall Xxx(function Fax,"RequestKeyMacro_Init")return trueendfunctionfunction FVx takes nothing returns booleanset uk=VXx(Uk)return trueendfunctionfunction FEx takes nothing returns nothinglocal integer oMx=Ke
loop
exitwhen(oMx<0)set wk[oMx]=le[oMx]set oMx=oMx-1endloopset Wk=Keendfunctionfunction FXx takes nothing returns integerlocal integer o7xif(Wk<0)then
return w
endifset o7x=wk[0]set wk[0]=wk[Wk]
set Wk=Wk-1return o7xendfunctionfunction FOx takes nothing returns nothinglocal integer oSxcall o_x("Timer_RequestRunningList","call DebugEx(Timer.NAME + \" Request running list:\")",ee+" Request running list:")
call FEx()loop
set oSx=FXx()exitwhen(oSx==w)
call o_x("Timer_RequestRunningList","call DebugEx(Code.GetNameById(this.GetActionFunc()))",(LoadStr(j,((Je[(oSx)])),0)))
endloopcall o_x("Timer_RequestRunningList","call DebugEx(Timer.NAME + \" end of Request running list\")",ee+" end of Request running list")
endfunctionfunction FRx takes nothing returns booleanlocal integer rFx=(bv)call FOx()return trueendfunctionfunction FIx takes nothing returns booleancall Xzx("-timers",function FRx)
return trueendfunctionfunction FAx takes nothing returns booleancall Xxx(function FIx,"RequestTimers_Init")return trueendfunctionfunction FNx takes nothing returns booleanset yk=VXx(Yk)return trueendfunctionfunction Fbx takes nothing returns booleanlocal integer rFx=(bv)call B1x(jg,C[ROx()],zk)
return trueendfunctionfunction FBx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])local real o5x=(S2R((Xsx(r4x,1))))set zk=o5xcall Rvx(oDx,function Fbx)return trueendfunctionfunction Fcx takes nothing returns booleancall Xzx("-dmgtest",function FBx)return trueendfunctionfunction FCx takes nothing returns booleancall Xxx(function Fcx,"SetDmgTest_Init")
return trueendfunctionfunction Fdx takes nothing returns booleanset Zk=VXx(vK)return trueendfunctionfunction FDx takes integer oSx,string o9x,string otx,string oux returns nothingif((o9x==null)or(otx==null))then
call o_x("FolderGameCache_StructString_Set","call DebugEx(\"GameCache Set: \"+missionKey+\";\"+key)","GameCache Set: "+o9x+";"+otx)returnendifcall StoreString(Kv[(oSx)],o9x,otx,oux)endfunctionfunction Ffx takes nothing returns booleanlocal integer rFx=(bv)local string r4x=(lA[(rFx)])
local integer oDx=(ZA[(rFx)])local string rSx=Xsx(r4x,1)local string o5x=Xsx(r4x,2)if(rSx==null)thencall o_x("SetVar_Event_Chat","call DebugEx(\"SetVar: no name given\")","SetVar: no name given")return trueendifcall FDx(uH,rSx,"var",o5x)call o_x("SetVar_Event_Chat","call DebugEx(\"SetVar: value of \" + name + \":\" + SetVar.GetVal(name))","SetVar: value of "+rSx+":"+(dex(uH,(rSx),"var")))return trueendfunctionfunction FFx takes nothing returns booleanset uH=V9x()
call Xzx("-var",function Ffx)return trueendfunctionfunction Fgx takes nothing returns booleancall Xxx(function FFx,"SetVar_Init")
return trueendfunctionfunction FGx takes nothing returns booleanset eK=VXx(xK)return trueendfunctionfunction Fhx takes nothing returns booleanset oK=VXx(rK)return trueendfunctionfunction FHx takes nothing returns booleanlocal integer rFx=(bv)local integer oDx=(ZA[(rFx)])if aK thencall ipx(oDx,"A vote is already in process.",5.)
return trueelseif nK thencall ipx(oDx,"The vote option is on cooldown for another "+(R2S((((TimerGetRemaining(Oe[(iK)])))*1.)))+"seconds.",5.)return trueendifset aK=truecall Xyx(zA,"-vote",VK)return trueendfunctionfunction Fjx takes nothing returns booleanset iK=iXx()
call Xzx("-votehost",function FHx)return trueendfunctionfunction FJx takes nothing returns booleancall Xxx(function Fjx,"VoteHost_Init")return trueendfunctionfunction Fkx takes nothing returns booleanset EK=VXx(XK)return trueendfunctionfunction FKx takes code c,string rSx returns nothing
set PV=PV+1set qV[PV]=CreateTrigger()set QV[PV]=(GetHandleId(Condition((c))))
set sV[PV]=rSxcall TriggerAddCondition(qV[PV],Condition(c))endfunctionfunction Flx takes integer id returns integerreturn(LoadInteger(o[((V[(E[((X))])]))],(((RK+(id)))),(((IK)))))
endfunctionfunction FLx takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((cH[(oSx)]))])]))],((((Ev[((oSx))])))),(((otx)))))endfunctionfunction Fmx takes integer oSx,integer rlx returns booleanreturn(FLx(rlx,ah+oSx)!=w)endfunctionfunction FMx takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((NK[(oSx)]))])]))],((((bK[((oSx))])))),(((otx)))))endfunctionfunction Fpx takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=Flx((av[(rFx)]))local integer FPx=(AK)if Fmx(Cqx,FMx(FPx,BK))thenreturn false
endifreturn truereturn trueendfunctionfunction Fqx takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((xA[(oSx)]))])]))],((((aA[((oSx))])))),(((otx)))))endfunctionfunction FQx takes integer XYx returns integerreturn Fqx(XYx,CK)endfunctionfunction Fsx takes nothing returns booleanlocal integer rFx=(bv)local integer FPx=FQx((Nv))if((nv[(rFx)])!=FMx(FPx,BK))then
return false
endifreturn truereturn trueendfunctionfunction FSx takes nothing returns booleanlocal integer rFx=(bv)local integer FPx=FQx((Nv))if((nv[(rFx)])!=FMx(FPx,BK))then
return false
endifreturn truereturn trueendfunctionfunction Ftx takes integer oSx,integer oLx returns realreturn CQx(oSx,tH+oLx)endfunctionfunction FTx takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=Flx((av[(rFx)]))local integer rlx=FMx((AK),BK)if((lF[(Cqx)])<Ftx(rlx,1))thenreturn false
endifreturn truereturn trueendfunctionfunction Fux takes nothing returns booleanlocal integer rFx=(bv)local integer Rax=(qb[(rFx)])local integer FPx=FQx((Nv))local integer rlx=FMx(FPx,BK)return(Rax==rlx)
return trueendfunctionfunction FUx takes nothing returns booleanlocal integer rFx=(bv)local integer d5x=(nv[(rFx)])local integer FPx=FQx((Nv))local integer rlx=FMx(FPx,BK)return(d5x==rlx)
return trueendfunctionfunction Fwx takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=Flx((av[(rFx)]))local integer rlx=FMx((AK),BK)return((mb[(Cqx)])==rlx)
return trueendfunctionfunction FWx takes nothing returns booleanset OK=Xpx(function Fpx)
set cK=Xpx(function Fsx)
set dK=Xpx(function FSx)
set DK=Xpx(function FTx)
set fK=Xpx(function Fux)
set FK=Xpx(function FUx)
set gK=Xpx(function Fwx)
return trueendfunctionfunction Fyx takes nothing returns booleancall FKx(function FWx,"AIAutoCast_Init")
return trueendfunctionfunction FYx takes nothing returns booleanset yA=VXx(tA)return trueendfunctionfunction Fzx takes code c,string rSx returns nothing
set Fi=Fi+1set gi[Fi]=CreateTrigger()set Gi[Fi]=(GetHandleId(Condition((c))))
set hi[Fi]=rSxcall TriggerAddCondition(gi[Fi],Condition(c))endfunctionfunction FZx takes nothing returns booleanreturn trueendfunctionfunction F_x takes nothing returns booleanset QA=V5x()
set Bv[(w)]=null
set GK=Xpx(function FZx)
return trueendfunctionfunction F0x takes nothing returns booleancall Fzx(function F_x,"BoolExpr_Init")return trueendfunctionfunction F1x takes nothing returns booleanset hK=VXx(HK)return trueendfunctionfunction F2x takes nothing returns booleanset jK=VXx(JK)return trueendfunctionfunction F3x takes nothing returns booleanset kK=VXx(KK)return trueendfunctionfunction F4x takes nothing returns booleanset lK=VXx(LK)return trueendfunctionfunction F5x takes nothing returns booleanset mK=VXx(MK)return trueendfunctionfunction F6x takes nothing returns booleanset pK=VXx(PK)return trueendfunctionfunction F7x takes nothing returns booleanset qK=VXx(QK)return trueendfunctionfunction F8x takes nothing returns booleanset sK=VXx(SK)return trueendfunctionfunction F9x takes nothing returns booleanset tK=VXx(TK)return trueendfunctionfunction gvx takes nothing returns booleanset uK=VXx(UK)return trueendfunctionfunction gex takes nothing returns booleanset wK=VXx(WK)return trueendfunctionfunction gxx takes nothing returns booleanset yK=VXx(YK)return trueendfunctionfunction gox takes nothing returns booleanset zK=VXx(ZK)return trueendfunctionfunction grx takes nothing returns booleanset vl=VXx(xl)return trueendfunctionfunction gix takes nothing returns booleanset ol=VXx(rl)return trueendfunctionfunction gax takes nothing returns booleanset il=VXx(al)return trueendfunctionfunction gnx takes nothing returns booleanreturn trueendfunctionfunction gVx takes nothing returns booleancall Fzx(function gnx,"Buff_Init")return trueendfunctionfunction gEx takes nothing returns booleanset nl=VXx(Vl)return trueendfunctionfunction gXx takes nothing returns booleanset El=VXx(Xl)return trueendfunctionfunction gOx takes nothing returns booleanset Ol=VXx(Rl)return trueendfunctionfunction gRx takes nothing returns booleanset Il=VXx(Al)return trueendfunctionfunction gIx takes nothing returns booleanset Nl=VXx(bl)return trueendfunctionfunction gAx takes nothing returns booleanset Bl=VXx(cl)return trueendfunctionfunction gNx takes nothing returns booleanset ND=VXx(ED)return trueendfunctionfunction gbx takes nothing returns booleanset Cl=VXx(dl)return trueendfunctionfunction gBx takes code c,string rSx returns nothing
set ia=ia+1set aa[ia]=CreateTrigger()set na[ia]=(GetHandleId(Condition((c))))
set Va[ia]=rSxcall TriggerAddCondition(aa[ia],Condition(c))endfunctionfunction gcx takes nothing returns integerreturn oPx(GetEnumPlayer())endfunctionfunction gCx takes nothing returns nothinglocal integer rFx=rRx(0)
set ZA[(rFx)]=(gcx())set pj[(rFx)]=(fl[Dl])call XGx(Fl[Dl],rFx)
call rkx(((rFx)))endfunctionfunction gdx takes integer oSx,code XCx,integer I6x returns nothingset Dl=Dl+1set fl[Dl]=I6xset Fl[Dl]=Xkx(XCx)call ForForce(LD[oSx],function gCx)set Dl=Dl-1endfunctionfunction gDx takes nothing returns booleanlocal integer rFx=(bv)local integer oDx=(ZA[(rFx)])local integer oSx=oDxlocal integer iCx=iXx()set of[oSx]=iCxset rf[oSx]=falseset ge[(iCx)]=(oSx)return trueendfunctionfunction gfx takes nothing returns nothingset Af=function N4xset Ef=iXx()
call gdx(gl,function gDx,w)endfunctionfunction gFx takes integer oSx,string o9x,string otx,real oux returns nothingif((o9x==null)or(otx==null))then
call o_x("FolderGameCache_StructReal_Set","call DebugEx(\"GameCache Set: \"+missionKey+\";\"+key)","GameCache Set: "+o9x+";"+otx)returnendifcall StoreReal(Kv[(oSx)],o9x,otx,oux)endfunctionfunction ggx takes integer oSx,string o9x,string otx,real oux returns nothingcall gFx(oSx,o9x,otx,oux)call SyncStoredReal(Kv[((oSx))],(o9x),(otx))
endfunctionfunction gGx takes integer oSx,string o9x,string otx returns realif((o9x==null)or(otx==null))then
call o_x("FolderGameCache_StructReal_Get","call DebugEx(\"GameCache Get: \"+missionKey+\";\"+key)","GameCache Get: "+o9x+";"+otx)return .0endifreturn GetStoredReal(Kv[(oSx)],o9x,otx)endfunctionfunction ghx takes integer oSx,integer oDx returns booleanreturn IsPlayerInForce(vx[oDx],LD[oSx])endfunctionfunction gHx takes real x,real y,real z returns real
return(SquareRoot(((x*x+y*y+z*z)*1.)))endfunctionfunction gjx takes nothing returns nothinglocal real gJx=(GetCameraEyePositionX())
local real gkx=(GetCameraEyePositionY())
local real gKx=(GetCameraEyePositionZ())
local real array glx
local real array gLx
local real array gmx
local real oyxlocal integer oSxlocal integer oDxlocal string gMx
local string gpx
local string gPx
local integer i=sDlocal integer gqxlocal real gQxloop
exitwhen(i<0)set oSx=QD[i]set oyx=cD[oSx]+CD[oSx]set cD[oSx]=oyxset i=i-1endloopif hl thenreturnendifset i=Hl
loop
exitwhen(i<0)set oDx=jl[i]if iOx(oDx)thenset gMx=Jl[oDx]set gpx=kl[oDx]set gPx=Kl[oDx]call ggx(Gl,gMx,gMx,(GetCameraEyePositionX()))call ggx(Gl,gpx,gpx,(GetCameraEyePositionY()))call ggx(Gl,gPx,gPx,(GetCameraEyePositionZ()))endifset i=i-1endloopset hl=truecall TriggerSyncStart()call TriggerSyncReady()set hl=false
set i=Hl
loop
exitwhen(i<0)set oDx=jl[i]set gMx=Jl[oDx]set gpx=kl[oDx]set gPx=Kl[oDx]set glx[oDx]=gGx(Gl,gMx,gMx)
set gLx[oDx]=gGx(Gl,gpx,gpx)
set gmx[oDx]=gGx(Gl,gPx,gPx)
set i=i-1endloopset i=sD
loop
exitwhen(i<0)set oSx=QD[i]set oyx=cD[oSx]set gqx=Hlloop
exitwhen(gqx<0)set oDx=jl[i]if(ghx(FD[oSx],oDx)==false)thenset gJx=glx[oDx]
set gkx=gLx[oDx]
set gKx=gmx[oDx]
set gQx=gHx(MD[oSx]-gJx,pD[oSx]-gkx,PD[oSx]-gKx)-oyx*oyx
if(gQx<BD[oSx])thencall box(jl[oDx],(1.-byx(gQx-oyx)*1./ BD[oSx])*(fD[oSx]+(DD[oSx]-fD[oSx])*(1-oyx*1./ BD[oSx])),5.)endifendifset gqx=gqx-1endloopset i=i-1endloopendfunctionfunction gsx takes nothing returns nothinglocal integer ilocal integer oDxset tD=CreateTrigger()set Gl=V9x()
set SD=iXx()
call TriggerAddAction(tD,function gjx)set i=Hl
loop
exitwhen(i<0)set oDx=jl[i]set Jl[oDx]="x"+(I2S((oDx)))
set kl[oDx]="y"+(I2S((oDx)))
set Kl[oDx]="z"+(I2S((oDx)))
set i=i-1endloopendfunctionfunction gSx takes nothing returns booleanlocal integer rFx=(bv)local integer oDx=(ZA[(rFx)])local integer oSx=oDxset Bf[oSx]=.0set uD[oSx]=.0set UD[oSx]=.0set Nf[oSx]=.0set bf[oSx]=.0return trueendfunctionfunction gtx takes nothing returns nothingset ZD=iXx()
call gdx(gl,function gSx,w)endfunctionfunction gTx takes integer oSx returns integerset ql[oSx]=true
set Ql[oSx]=falsecall rEx(El)
return oSxendfunctionfunction gux takes nothing returns integerlocal integer oSxif(ml==8190)then
call o_x("CameraField_Allocation_allocCustom","call DebugEx(CameraField.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Xl+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(Ml[(w)]==w)thenset pl=pl+1set oSx=plelse
set oSx=Ml[(w)]set Ml[(w)]=Ml[Ml[(w)]]endifset Ml[oSx]=Zset Pl[oSx]=1call gTx(oSx)return oSxendfunctionfunction gUx takes camerafield oqx returns integerlocal integer oSx=gux()set sl[oSx]=oqxreturn oSxendfunctionfunction gwx takes nothing returns nothingset ll=iXx()
set Ll=gUx(CAMERA_FIELD_FARZ)set Sl=gUx(CAMERA_FIELD_FIELD_OF_VIEW)set tl=gUx(CAMERA_FIELD_ANGLE_OF_ATTACK)
set Tl=gUx(CAMERA_FIELD_ROLL)set ul=gUx(CAMERA_FIELD_TARGET_DISTANCE)
set Ul=gUx(CAMERA_FIELD_ROTATION)set wl=gUx(CAMERA_FIELD_ZOFFSET)
endfunctionfunction gWx takes nothing returns booleancall gfx()call gsx()call gtx()call gwx()return trueendfunctionfunction gyx takes nothing returns booleancall gBx(function gWx,"Camera_Init")
return trueendfunctionfunction gYx takes nothing returns booleanset Wl=VXx(yl)return trueendfunctionfunction gzx takes nothing returns booleanset Yl=VXx(zl)return trueendfunctionfunction gZx takes nothing returns booleanset Zl=VXx(vL)return trueendfunctionfunction g_x takes nothing returns booleanset eL=VXx(xL)return trueendfunctionfunction g0x takes nothing returns booleanset oL=VXx(rL)return trueendfunctionfunction g1x takes nothing returns booleanset iL=VXx(aL)return trueendfunctionfunction g2x takes nothing returns booleanset nL=VXx(VL)return trueendfunctionfunction g3x takes nothing returns booleanset EL=VXx(XL)return trueendfunctionfunction g4x takes nothing returns booleanset OL=VXx(RL)return trueendfunctionfunction g5x takes code c,string rSx returns nothing
call VNx(Ma,c,rSx)endfunctionfunction g6x takes integer oSx returns integerset CL[oSx]=true
set dL[oSx]=falseset DL[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set fL[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(FL)
return oSxendfunctionfunction g7x takes nothing returns integerlocal integer oSxif(AL==8190)then
call o_x("DestructableType_Allocation_allocCustom","call DebugEx(DestructableType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",NL+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(bL[(w)]==w)thenset BL=BL+1set oSx=BLelse
set oSx=bL[(w)]set bL[(w)]=bL[bL[(w)]]endifset bL[oSx]=Zset cL[oSx]=1call g6x(oSx)return oSxendfunctionfunction g8x takes integer oSx returns nothinglocal destructable g9x=CreateDestructable(gL[oSx],.0,.0,.0,.0,0)
set hL[oSx]=GetDestructableName(g9x)
call RemoveDestructable(g9x)
set g9x=null
endfunctionfunction Gvx takes integer oSx returns nothingset HL[(oSx)]=(jL+oSx)endfunctionfunction Gex takes integer oqx returns integerlocal integer oSx=g7x()set gL[oSx]=oqxcall SaveInteger(o[((V[(E[((X))])]))],(((oqx))),(((GL))),(((oSx))))call g8x(oSx)call Gvx(oSx)call RemoveDestructable(CreateDestructable(gL[((oSx))],.0,.0,.0,.0,0))return oSxendfunctionfunction Gxx takes nothing returns booleanset IL=Gex('CKeg')return trueendfunctionfunction Gox takes nothing returns booleanset JL=Gex('CExp')return trueendfunctionfunction Grx takes nothing returns booleancall g5x(function Gxx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Destructable.page\\DestructableType.struct\\Destructables.pack\\Keg\\obj_keg_wc3dest.j")
call g5x(function Gox,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Destructable.page\\DestructableType.struct\\obj_explosive_wc3dest.j")return trueendfunctionfunction Gix takes nothing returns booleanset FL=VXx(NL)return trueendfunctionfunction Gax takes nothing returns booleanset kL=VXx(KL)return trueendfunctionfunction Gnx takes nothing returns booleanset lL=VXx(LL)return trueendfunctionfunction GVx takes nothing returns booleanset mL=VXx(ML)return trueendfunctionfunction GEx takes nothing returns booleanset pL=VXx(PL)return trueendfunctionfunction GXx takes nothing returns booleanset qL=VXx(QL)return trueendfunctionfunction GOx takes nothing returns booleanset sL=VXx(SL)return trueendfunctionfunction GRx takes nothing returns booleanset tL=VXx(TL)return trueendfunctionfunction GIx takes nothing returns booleanset uL=VXx(UL)return trueendfunctionfunction GAx takes nothing returns booleanset wL=VXx(WL)return trueendfunctionfunction GNx takes nothing returns booleanset yL=VXx(YL)return trueendfunctionfunction Gbx takes nothing returns booleanset zL=VXx(ZL)return trueendfunctionfunction GBx takes nothing returns booleanset vm=VXx(em)return trueendfunctionfunction Gcx takes nothing returns booleanset xm=VXx(om)return trueendfunctionfunction GCx takes nothing returns booleanset rm=VXx(im)return trueendfunctionfunction Gdx takes nothing returns booleanset am=VXx(nm)return trueendfunctionfunction GDx takes code c,string rSx returns nothing
set Ea=Ea+1set Xa[Ea]=CreateTrigger()set Oa[Ea]=(GetHandleId(Condition((c))))
set Ra[Ea]=rSxcall TriggerAddCondition(Xa[Ea],Condition(c))endfunctionfunction Gfx takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((Am[oSx]))])]))],((((Rm[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))endfunctionfunction GFx takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((Am[oSx]))])]))],((((Rm[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))endfunctionfunction Ggx takes integer oSx returns nothinglocal integer rFx=rRx((Rm[(oSx)]))local integer oMxlocal integer rbxlocal integer rMxset Im[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=Gfx(oSx,Em,rbx)loop
exitwhen(rMx<q)call rfx(GFx(oSx,Em,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction GGx takes destructable oqx returns integerreturn(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((oqx))))),((((Nm))))))endfunctionfunction Ghx takes nothing returns booleancall Ggx((GGx(GetDyingDestructable())))return trueendfunctionfunction GHx takes integer oSx returns integerset fm[oSx]=true
set Fm[oSx]=falseset gm[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set Am[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(am)
return oSxendfunctionfunction Gjx takes nothing returns integerlocal integer oSxif(cm==8190)then
call o_x("Destructable_Allocation_allocCustom","call DebugEx(Destructable.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",nm+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Cm[(w)]==w)thenset dm=dm+1set oSx=dmelse
set oSx=Cm[(w)]set Cm[(w)]=Cm[Cm[(w)]]endifset Cm[oSx]=Zset Dm[oSx]=1call GHx(oSx)return oSxendfunctionfunction GJx takes integer oSx returns nothingset Rm[(oSx)]=(Jm+oSx)endfunctionfunction Gkx takes integer oSx returns nothingset km[(oSx)]=((LoadInteger(o[((V[(E[((X))])]))],((((GetDestructableTypeId(Gm[(oSx)]))))),(((GL))))))endfunctionfunction GKx takes integer oSx,integer Glx returns nothingcall TriggerRegisterDeathEvent(DA[(oSx)],Gm[Glx])endfunctionfunction GLx takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((fL[oSx]))])]))],((((HL[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))endfunctionfunction Gmx takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((fL[oSx]))])]))],((((HL[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))endfunctionfunction GMx takes integer oSx returns nothinglocal integer Gpx=(km[(oSx)])local integer rFx=rRx(0)
local integer GPxlocal integer oMxlocal integer rbxlocal integer rMxset Im[(rFx)]=(oSx)set Km[(rFx)]=(Gpx)set GPx=rRx((HL[(Gpx)]))
set Im[(GPx)]=(oSx)set Km[(GPx)]=(Gpx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Vm))-1)*Iv+(((rbx))-1)))))))))loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Vm))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset rMx=GLx(Gpx,Vm,rbx)loop
exitwhen(rMx<q)call rfx(Gmx(Gpx,Vm,rbx,rMx),GPx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call rkx(((GPx)))endfunctionfunction Gqx takes destructable oqx returns integerlocal integer oSx=Gjx()set Gm[oSx]=oqxset hm[oSx]=GetDestructableX(oqx)set Hm[oSx]=GetDestructableY(oqx)set jm[oSx]=.0call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oqx))))),((((Nm)))),((((oSx)))))
call GJx(oSx)call Gkx(oSx)call GKx(Om,oSx)
call GMx(oSx)return oSxendfunctionfunction GQx takes nothing returns booleanlocal integer rFx=(bv)local destructable Gsx=GetEnumDestructable()
if((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((Gsx)))))),((((Nm))))))==w)thencall Gqx(Gsx)endifset Gsx=null
return trueendfunctionfunction GSx takes nothing returns booleanlocal integer rFx=(bv)call EnumDestructablesInRect(bm[Bm],null,function GQx)return trueendfunctionfunction Gtx takes integer oSx returns integerset qm[oSx]=true
set Qm[oSx]=falseset sm[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])call rEx(Sm)
return oSxendfunctionfunction GTx takes nothing returns integerlocal integer oSxif(Lm==8190)then
call o_x("Rectangle_Allocation_allocCustom","call DebugEx(Rectangle.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",mm+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(Mm[(w)]==w)thenset pm=pm+1set oSx=pmelse
set oSx=Mm[(w)]set Mm[(w)]=Mm[Mm[(w)]]endifset Mm[oSx]=Zset Pm[oSx]=1call Gtx(oSx)return oSxendfunctionfunction Gux takes real GUx,real Gwx,real GWx,real Gyx returns integerlocal integer oSx=GTx()set tm[oSx]=(GUx+GWx)*1./ 2set Tm[oSx]=(Gwx+Gyx)*1./ 2set um[oSx]=GWxset Um[oSx]=Gyxset wm[oSx]=GUxset Wm[oSx]=Gwxreturn oSxendfunctionfunction GYx takes integer oSx returns nothingset ym[(oSx)]=(zm+oSx)endfunctionfunction Gzx takes real GUx,real Gwx,real GWx,real Gyx returns integerlocal integer oSx=Gux(GUx,Gwx,GWx,Gyx)set bm[oSx]=Rect(GUx,Gwx,GWx,Gyx)call GYx(oSx)return oSxendfunctionfunction GZx takes real x,real y returns realreturn(x*x+y*y)endfunctionfunction G_x takes nothing returns booleanlocal integer G0x=(GGx(GetFilterDestructable()))
if(GZx(hm[G0x]-Ff,Hm[G0x]-gf)>Gf)thenreturn false
endifreturn trueendfunctionfunction G1x takes nothing returns nothingset lm=Gzx(.0,.0,.0,.0)set Zm=Xpx(function G_x)
endfunctionfunction G2x takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((gm[(oSx)]))])]))],((((Rm[((oSx))])))),(((otx)))))endfunctionfunction G3x takes integer oSx returns nothingset rM[oSx]=falsecall rHx(zL)
endfunctionfunction G4x takes integer oSx returns nothingif(xM[oSx]>0)thenreturnendifif(oM[oSx]!=Z)thencall o_x("FolderDestructable_StructTimedLife_Allocation_deallocCustom_confirm","call DebugEx(FolderDestructable_StructTimedLife.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",ZL+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset oM[oSx]=oM[(w)]set oM[(w)]=oSxcall G3x(oSx)endfunctionfunction G5x takes integer oSx returns nothingset xM[oSx]=xM[oSx]-1call G4x(oSx)endfunctionfunction G6x takes integer oSx,integer otx returns nothingcall SaveInteger(o[(((V[(E[((gm[(oSx)]))])])))],(((((Rm[((oSx))]))))),((((otx)))),(0))endfunctionfunction G7x takes integer oSx,integer XYx returns nothingif not((LoadInteger(o[((D[((Am[oSx]))]))],((((Rm[((oSx))])))),(oTx((((oA[(XYx)]))),(((XYx)))))))!=0)then
call o_x("FolderDestructable_StructEvent_Remove","call DebugEx(\"subject \"+I2S(Destructable(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((Rm[((oSx))]))+" has not "+(jA[(XYx)]))
returnendifcall rrx(Am[oSx],(Rm[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction G8x takes integer oSx,integer iCx,integer rLx returns nothingcall G5x((oSx))call iKx(iCx)call G6x(rLx,eM)
call G7x(rLx,vM)
endfunctionfunction G9x takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Im[(rFx)])local integer oSx=G2x(rLx,eM)call G8x(oSx,iM[oSx],rLx)return trueendfunctionfunction hvx takes nothing returns nothingendfunctionfunction hex takes nothing returns booleanset Vm=(E3x())set Em=(E3x())set Xm=(E3x())set Om=XJx(function Ghx)
call Dcx(Xdx("Destructable_Init: call Event.Create(EventType.START, EventPriority.HEADER, function Destructable.Event_Start).AddToStatics()",EE,bI,function GSx))call G1x()set vM=Xdx("FolderDestructable_StructTimedLife_Init: set FolderDestructable_StructTimedLife.DEATH_EVENT = Event.Create(Destructable.DEATH_EVENT_TYPE, EventPriority.HEADER, function FolderDestructable_StructTimedLife.Event_Death)",Em,bI,function G9x)call hvx()return trueendfunctionfunction hxx takes nothing returns booleancall GDx(function hex,"Destructable_Init")return trueendfunctionfunction hox takes nothing returns booleanset aM=VXx(nM)return trueendfunctionfunction hrx takes nothing returns booleanset VM=VXx(EM)return trueendfunctionfunction hix takes nothing returns booleanset XM=VXx(OM)return trueendfunctionfunction hax takes nothing returns booleanset RM=VXx(IM)return trueendfunctionfunction hnx takes nothing returns booleanset AM=VXx(NM)return trueendfunctionfunction hVx takes nothing returns booleanset bM=VXx(BM)return trueendfunctionfunction hEx takes nothing returns booleanset cM=VXx(CM)return trueendfunctionfunction hXx takes nothing returns booleanset dM=VXx(DM)return trueendfunctionfunction hOx takes nothing returns booleanset fM=VXx(FM)return trueendfunctionfunction hRx takes nothing returns booleanset gM=VXx(GM)return trueendfunctionfunction hIx takes nothing returns booleanset hM=VXx(HM)return trueendfunctionfunction hAx takes nothing returns booleanset jM=VXx(JM)return trueendfunctionfunction hNx takes nothing returns booleanset kM=VXx(KM)return trueendfunctionfunction hbx takes nothing returns booleanset lM=VXx(LM)return trueendfunctionfunction hBx takes nothing returns booleanset mM=VXx(MM)return trueendfunctionfunction hcx takes nothing returns booleanset pM=VXx(PM)return trueendfunctionfunction hCx takes nothing returns booleanset qM=VXx(QM)return trueendfunctionfunction hdx takes nothing returns booleanset sM=VXx(SM)return trueendfunctionfunction hDx takes nothing returns booleanset tM=VXx(TM)return trueendfunctionfunction hfx takes dialog oqx returns integerreturn(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((oqx))))),((((WM))))))endfunctionfunction hFx takes integer oSx,integer otx,integer oux returns booleanreturn((LoadInteger(o[((D[((Bb[(oSx)]))]))],((((cb[((oSx))])))),(oTx(((otx)),(((oux)))))))!=0)endfunctionfunction hgx takes integer oSx,integer otx,integer oux returns booleanreturn rrx(YM[(oSx)],(zM[((oSx))]),otx,oux)endfunctionfunction hGx takes integer oSx,integer otx,integer oux returns booleanreturn rrx(Bb[(oSx)],(cb[((oSx))]),otx,oux)endfunctionfunction hhx takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((Bb[(oSx)]))])]))],((((cb[((oSx))])))),(((otx)))))endfunctionfunction hHx takes integer oSx,integer otx returns booleanreturn((LoadInteger(o[((V[(E[((Bb[(oSx)]))])]))],((((cb[((oSx))])))),(((otx)))))==0)
endfunctionfunction hjx takes integer oSx,integer otx returns nothingcall SaveInteger(o[(((V[(E[((Bb[(oSx)]))])])))],(((((cb[((oSx))]))))),((((otx)))),(0))endfunctionfunction hJx takes integer oDx returns nothinglocal integer oSxif not iOx(oDx)thenreturnendifset oSx=oDxif(xp[oSx]==w)thenreturnendifcall MultiboardDisplay(op[xp[oSx]],true)
endfunctionfunction hkx takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[(((Bb[(oSx)])))])]))],(((((cb[((oSx))]))))),((((otx))+(q)))))endfunctionfunction hKx takes integer oSx,integer otx,integer oux returns booleanreturn rux(YM[(oSx)],(zM[((oSx))]),otx,oux)endfunctionfunction hlx takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((Bb[(oSx)]))])]))],((((cb[((oSx))])))),(((otx))),(((oux))))endfunctionfunction hLx takes integer oSx,integer oDx returns nothinglocal boolean hasNextlocal integer oMxif(oDx==Ge)thenset oMx=Hlloop
call hLx(oSx,jl[oMx])set oMx=oMx-1exitwhen(oMx<0)endloopreturnendifif(hFx(oDx,yM,oSx)==false)thenreturnendifcall hgx(oSx,yM,oDx)
call hGx(oDx,yM,oSx)
if((hhx((oDx),ZM))==oSx)then
call hgx(oSx,vp,oDx)
if hHx(oDx,yM)thencall hjx(oDx,ZM)
call DialogDisplay(vx[oDx],ep[oSx],false)call hJx(oDx)else
set oSx=hkx(oDx,yM)call hKx(oSx,vp,oDx)
call hlx(oDx,ZM,oSx)
call DialogDisplay(vx[oDx],ep[oSx],true)
endifendifendfunctionfunction hmx takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((ap[oSx]))])]))],((((zM[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))endfunctionfunction hMx takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((ap[oSx]))])]))],((((zM[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))endfunctionfunction hpx takes integer oSx,integer hPx returns nothinglocal integer oMx=Xv
local integer rMxlocal integer rbxlocal integer rFx=rRx((zM[(oSx)]))set rp[(rFx)]=(oSx)set ip[(rFx)]=(hPx)loop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=hmx(oSx,uM,rbx)loop
exitwhen(rMx<q)call rfx(hMx(oSx,uM,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction hqx takes integer oSx,integer otx,integer oux returns booleanreturn rux(Bb[(oSx)],(cb[((oSx))]),otx,oux)endfunctionfunction hQx takes integer oSx,integer oDx returns nothinglocal boolean hsxlocal integer oMxif(oDx==Ge)thenset oMx=Hlloop
call hQx(oSx,jl[oMx])set oMx=oMx-1exitwhen(oMx<0)endloopreturnendifset hsx=hHx(oDx,yM)if((hsx==false)and hFx(oDx,yM,oSx))thenreturnendifcall hKx(oSx,yM,oDx)
call hqx(oDx,yM,oSx)
if hsx thencall hKx(oSx,vp,oDx)
call hlx(oDx,ZM,oSx)
call DialogDisplay(vx[oDx],ep[oSx],true)
endifendfunctionfunction hSx takes nothing returns booleanlocal integer hPx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((GetClickedButton()))))),((((wM))))))local integer oSx=(hfx(GetClickedDialog()))local integer oDx=oQx()call hLx(oSx,oDx)call hpx(oSx,hPx)if not hHx(oDx,yM)thencall hQx((hkx(oDx,yM)),oDx)endifreturn trueendfunctionfunction htx takes nothing returns nothingendfunctionfunction hTx takes nothing returns booleanset uM=(E3x())set UM=XJx(function hSx)
call htx()return trueendfunctionfunction hux takes nothing returns booleancall gBx(function hTx,"Dialog_Init")
return trueendfunctionfunction hUx takes nothing returns booleanset Ri=VXx(ai)return trueendfunctionfunction hwx takes nothing returns booleanset np=VXx(Vp)return trueendfunctionfunction hWx takes nothing returns booleanreturn trueendfunctionfunction hyx takes nothing returns booleanset Ep=VXx(Xp)return trueendfunctionfunction hYx takes nothing returns booleanset Op=VXx(Rp)return trueendfunctionfunction hzx takes nothing returns booleanset Ip=VXx(Ap)return trueendfunctionfunction hZx takes nothing returns booleanset Np=VXx(bp)return trueendfunctionfunction h_x takes nothing returns booleanset Bp=VXx(cp)return trueendfunctionfunction h0x takes nothing returns booleanset Cp=VXx(dp)return trueendfunctionfunction h1x takes nothing returns booleanset Dp=VXx(fp)return trueendfunctionfunction h2x takes nothing returns booleanset Fp=VXx(gp)return trueendfunctionfunction h3x takes nothing returns booleanset Gp=VXx(hp)return trueendfunctionfunction h4x takes nothing returns booleanreturn trueendfunctionfunction h5x takes nothing returns booleanset Hp=VXx(jp)return trueendfunctionfunction h6x takes nothing returns booleanset Jp=VXx(kp)return trueendfunctionfunction h7x takes nothing returns booleanset Kp=VXx(lp)return trueendfunctionfunction h8x takes nothing returns booleanset Lp=VXx(mp)return trueendfunctionfunction h9x takes nothing returns booleanset Mp=VXx(pp)return trueendfunctionfunction Hvx takes nothing returns booleanset Pp=VXx(qp)return trueendfunctionfunction Hex takes nothing returns booleanset Qp=VXx(sp)return trueendfunctionfunction Hxx takes nothing returns booleanset Sp=VXx(tp)return trueendfunctionfunction Hox takes nothing returns booleanset dB=VXx(BB)return trueendfunctionfunction Hrx takes nothing returns booleanset Tp=VXx(up)return trueendfunctionfunction Hix takes code c,string rSx returns nothing
set Ba=Ba+1set ca[Ba]=CreateTrigger()set Ca[Ba]=(GetHandleId(Condition((c))))
set da[Ba]=rSxcall TriggerAddCondition(ca[Ba],Condition(c))endfunctionfunction Hax takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((yp[(oSx)]))])]))],((((Yp[((oSx))])))),(((otx))))))endfunctionfunction Hnx takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((yp[(oSx)]))])]))],((((Yp[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction HVx takes integer oSx returns nothingset oP[oSx]=falsecall rHx(Op)
endfunctionfunction HEx takes integer oSx returns nothingif(eP[oSx]>0)thenreturnendifif(xP[oSx]!=Z)thencall o_x("DummyUnitEffect_Allocation_deallocCustom_confirm","call DebugEx(DummyUnitEffect.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Rp+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset xP[oSx]=xP[(w)]set xP[(w)]=oSxcall HVx(oSx)endfunctionfunction HXx takes integer oSx returns nothingset eP[oSx]=eP[oSx]-1call HEx(oSx)endfunctionfunction HOx takes integer oSx,integer otx,integer oux returns booleanreturn rrx(yp[(oSx)],(Yp[((oSx))]),otx,oux)endfunctionfunction HRx takes integer oSx,integer XYx returns nothingif not((LoadInteger(o[((D[((rP[oSx]))]))],((((Yp[((oSx))])))),(oTx((((oA[(XYx)]))),(((XYx)))))))!=0)then
call o_x("FolderDummyUnit_StructEvent_Remove","call DebugEx(\"subject \"+I2S(DummyUnit(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((Yp[((oSx))]))+" has not "+(jA[(XYx)]))returnendifcall rrx(rP[oSx],(Yp[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction HIx takes integer oSx returns nothinglocal integer HAx=Zp[oSx]local effect oqx=vP[oSx]
call HXx((oSx))call DestroyEffect(oqx)set oqx=null
if HOx(HAx,zp,oSx)thencall HRx(HAx,Up)
call HRx(HAx,iP)
endifendfunctionfunction HNx takes nothing returns booleanlocal integer rFx=(bv)local integer HAx=(Wp[(rFx)])local integer oMx=Hax(HAx,zp)local integer oSxloop
set oSx=Hnx(HAx,zp,oMx)call HIx(oSx)set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction Hbx takes nothing returns booleanlocal integer rFx=(bv)local integer HAx=(Wp[(rFx)])local integer oMx=Hax(HAx,zp)local integer oSxloop
set oSx=Hnx(HAx,zp,oMx)call HIx(oSx)set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction HBx takes nothing returns nothingset Up=Xdx("DummyUnitEffect_Init: set DummyUnitEffect.DEATH_EVENT = Event.Create(DummyUnit.DEATH_EVENT_TYPE, EventPriority.HEADER, function DummyUnitEffect.Event_Death)",wp,bI,function HNx)set iP=Xdx("DummyUnitEffect_Init: set DummyUnitEffect.DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function DummyUnitEffect.Event_Destroy)",aP,bI,function Hbx)endfunctionfunction Hcx takes nothing returns nothingendfunctionfunction HCx takes integer oSx,integer XYx returns nothingif not((LoadInteger(o[((D[((nB[oSx]))]))],((((iB[((oSx))])))),(oTx((((oA[(XYx)]))),(((XYx)))))))!=0)then
call o_x("FolderUnitEffect_StructEvent_Remove","call DebugEx(\"subject \"+I2S(UnitEffect(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((iB[((oSx))]))+" has not "+(jA[(XYx)]))
returnendifcall rrx(nB[oSx],(iB[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction Hdx takes integer oSx,integer OSx returns nothingcall HCx(oSx,oC)
if rnx(OSx,Yc,oSx)thencall RPx(OSx,vC)
call RPx(OSx,eC)
if Uc[oSx]thencall RPx(OSx,zc)
else
call RPx(OSx,Zc)
endifendifendfunctionfunction HDx takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=(aB[(rFx)])local integer OSx=yc[oSx]call Hdx(oSx,OSx)return trueendfunctionfunction Hfx takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])local integer oMx=CIx(OSx,Yc)local integer oSxloop
set oSx=CAx(OSx,Yc,oMx)call RSx(oSx)set Uc[oSx]=true
set oMx=oMx-1exitwhen(oMx<q)endloopcall RPx(OSx,Zc)
call Avx(OSx,zc)
return trueendfunctionfunction HFx takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])local integer oMx=CIx(OSx,Yc)local integer oSxloop
set oSx=CAx(OSx,Yc,oMx)call Ryx(oSx)set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction Hgx takes integer oSx returns nothingcall SetUnitColor(C[(oSx)],(xx[(oSx)]))endfunctionfunction HGx takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])local integer oMx=CIx(OSx,Yc)local integer oSxloop
set oSx=CAx(OSx,Yc,oMx)call Acx(oSx)set Uc[oSx]=falseset oMx=oMx-1exitwhen(oMx<q)endloopcall RPx(OSx,zc)
call Avx(OSx,Zc)
call Hgx(OSx)return trueendfunctionfunction Hhx takes integer oSx returns nothingif EB[oSx]thenreturnendifif(XB[oSx]==null)thencall DestroyEffect(OB[oSx])set OB[oSx]=null
else
call DestroyEffect(XB[oSx])set XB[oSx]=null
endifif(ci>=wc[oSx])thenset OB[oSx]=AddSpecialEffectTarget(Wc[oSx],C[yc[oSx]],uc[oSx])if(OB[oSx]==null)thenset OB[oSx]=AddSpecialEffect(null,.0,.0)
endifelse
set XB[oSx]=AddSpecialEffect(null,.0,.0)
endifendfunctionfunction HHx takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])local integer oMx=CIx(OSx,Yc)local integer oSxloop
set oSx=CAx(OSx,Yc,oMx)call Hhx(oSx)set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction Hjx takes nothing returns nothingset VB=(E3x())set oC=Xdx("UnitEffect_Init: set UnitEffect.DESTROY_EVENT = Event.Create(UnitEffect.DESTROY_EVENT_TYPE, EventPriority.HEADER, function UnitEffect.Event_Destroy)",VB,bI,function HDx)set Zc=Xdx("UnitEffect_Init: set UnitEffect.UNIT_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function UnitEffect.Event_Unit_Death)",VP,bI,function Hfx)
set vC=Xdx("UnitEffect_Init: set UnitEffect.UNIT_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function UnitEffect.Event_Unit_Destroy)",EP,bI,function HFx)set zc=Xdx("UnitEffect_Init: set UnitEffect.UNIT_REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function UnitEffect.Event_Unit_Revive)",XP,bI,function HGx)
set eC=Xdx("UnitEffect_Init: set UnitEffect.UNIT_TYPE_CHANGE_EVENT = Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function UnitEffect.Event_Unit_TypeChange)",OP,bI,function HHx)endfunctionfunction HJx takes nothing returns booleancall HBx()set nP=(E3x())call Hcx()call Hjx()return trueendfunctionfunction Hkx takes nothing returns booleancall Hix(function HJx,"Effect_Init")
return trueendfunctionfunction HKx takes nothing returns booleanset RP=VXx(IP)return trueendfunctionfunction Hlx takes nothing returns booleanset AP=VXx(NP)return trueendfunctionfunction HLx takes nothing returns booleanset bP=VXx(BP)return trueendfunctionfunction Hmx takes nothing returns booleanset cP=VXx(CP)return trueendfunctionfunction HMx takes nothing returns booleanset dP=VXx(DP)return trueendfunctionfunction Hpx takes nothing returns booleanset fP=VXx(FP)return trueendfunctionfunction HPx takes nothing returns nothingset gP=V5x()
set GP=V5x()
endfunctionfunction Hqx takes nothing returns nothingset hP=V5x()
set HP=V5x()
set jP=V5x()
set JP=V5x()
set kP=V5x()
endfunctionfunction HQx takes nothing returns nothingset KP=V5x()
set lP=V5x()
endfunctionfunction Hsx takes nothing returns nothingcall Hqx()call HQx()endfunctionfunction HSx takes nothing returns booleancall HPx()call Hsx()return trueendfunctionfunction Htx takes nothing returns booleancall E1x(function HSx,"EventMemory_Init")return trueendfunctionfunction HTx takes nothing returns booleanset LP=VXx(mP)return trueendfunctionfunction Hux takes nothing returns booleanset MP=VXx(pP)return trueendfunctionfunction HUx takes nothing returns booleanset PP=VXx(qP)return trueendfunctionfunction Hwx takes nothing returns booleanset QP=VXx(sP)return trueendfunctionfunction HWx takes nothing returns booleanset SP=VXx(tP)return trueendfunctionfunction Hyx takes nothing returns booleanset TP=VXx(uP)return trueendfunctionfunction HYx takes nothing returns booleanset UP=VXx(wP)return trueendfunctionfunction Hzx takes nothing returns booleanset WP=VXx(yP)return trueendfunctionfunction HZx takes nothing returns booleanset YP=VXx(zP)return trueendfunctionfunction H_x takes nothing returns booleanset ZP=VXx(vq)return trueendfunctionfunction H0x takes nothing returns booleanset eq=VXx(xq)return trueendfunctionfunction H1x takes nothing returns booleanset oq=VXx(rq)return trueendfunctionfunction H2x takes nothing returns booleanset iq=VXx(aq)return trueendfunctionfunction H3x takes nothing returns booleanreturn trueendfunctionfunction H4x takes nothing returns booleancall GDx(function H3x,"EventCombination_Init")return trueendfunctionfunction H5x takes nothing returns booleanset nq=VXx(Vq)return trueendfunctionfunction H6x takes nothing returns booleanset zv=VXx(uv)return trueendfunctionfunction H7x takes nothing returns booleanset Eq=VXx(Xq)return trueendfunctionfunction H8x takes nothing returns booleanset Oq=VXx(Rq)return trueendfunctionfunction H9x takes nothing returns booleanset Iq=VXx(Aq)return trueendfunctionfunction jvx takes nothing returns nothingset bq=w
set Bq=iXx()
endfunctionfunction jex takes nothing returns nothingset Cq=iXx()
endfunctionfunction jxx takes integer oSx returns integerset hq[oSx]=true
set Hq[oSx]=falsecall rEx(jq)
return oSxendfunctionfunction jox takes nothing returns integerlocal integer oSxif(Dq==8190)then
call o_x("PingColor_Allocation_allocCustom","call DebugEx(PingColor.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",fq+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(Fq[(w)]==w)thenset gq=gq+1set oSx=gqelse
set oSx=Fq[(w)]set Fq[(w)]=Fq[Fq[(w)]]endifset Fq[oSx]=Zset Gq[oSx]=1call jxx(oSx)return oSxendfunctionfunction jrx takes real izx,real iZx,real i_x,real i0x returns stringreturn iYx(izx*1./ 255.,iZx*1./ 255.,i_x*1./ 255.,i0x*1./ 255.)endfunctionfunction jix takes integer oSx returns booleanif((mq[((oSx))])>0)thenreturn false
endifset Mq=Mq+1set pq[Mq]=oSxset mq[oSx]=Mq+1
return(Mq==0)endfunctionfunction jax takes string rSx,integer izx,integer iZx,integer i_x returns integerlocal integer oSx=jox()set Jq[oSx]=falseset kq[(oSx)]=(iSx(rSx,jrx(izx,iZx,i_x,$FF)))set Kq[(oSx)]=(izx)set lq[(oSx)]=(iZx)set Lq[(oSx)]=(i_x)call jix(oSx)return oSxendfunctionfunction jnx takes nothing returns nothingset dq=jax("Blue",0,0,$FF)set Pq=jax("Green",0,$FF,0)set qq=jax("Red",$FF,0,0)set Qq=jax("Magenta",$FF,0,$FF)set sq=jax("Teal",0,$FF,$FF)
set Sq=jax("Yellow",$FF,$FF,0)endfunctionfunction jVx takes nothing returns booleanset Nq=GetTimeOfDayScale()call jvx()set cq=truecall jex()call jnx()return trueendfunctionfunction jEx takes nothing returns booleancall gBx(function jVx,"Game_Init")return trueendfunctionfunction jXx takes nothing returns booleanset jq=VXx(fq)return trueendfunctionfunction jOx takes nothing returns booleanset tq=VXx(Tq)return trueendfunctionfunction jRx takes nothing returns booleanset uq=VXx(Uq)return trueendfunctionfunction jIx takes nothing returns booleanset wq=VXx(Wq)return trueendfunctionfunction jAx takes nothing returns booleanset yq=VXx(Yq)return trueendfunctionfunction jNx takes nothing returns booleanset zq=VXx(Zq)return trueendfunctionfunction jbx takes nothing returns booleanset vQ=VXx(eQ)return trueendfunctionfunction jBx takes nothing returns booleanset xQ=VXx(oQ)return trueendfunctionfunction jcx takes nothing returns booleanset rQ=VXx(iQ)return trueendfunctionfunction jCx takes nothing returns booleanset aQ=VXx(nQ)return trueendfunctionfunction jdx takes nothing returns booleanset VQ=VXx(EQ)return trueendfunctionfunction jDx takes nothing returns booleanset XQ=VXx(OQ)return trueendfunctionfunction jfx takes nothing returns booleanset RQ=VXx(IQ)return trueendfunctionfunction jFx takes nothing returns booleanset AQ=VXx(NQ)return trueendfunctionfunction jgx takes nothing returns booleanset Jb=VXx(Fb)return trueendfunctionfunction jGx takes code c,string rSx returns nothing
set Hi=Hi+1set ji[Hi]=CreateTrigger()set Ji[Hi]=(GetHandleId(Condition((c))))
set ki[Hi]=rSxcall TriggerAddCondition(ji[Hi],Condition(c))endfunctionfunction jhx takes nothing returns integerlocal unit oqx=GetFilterUnit()local integer o7xif(GetUnitAbilityLevel(oqx,'aLoc')>0)thenset oqx=null
return Z
endifset o7x=adx(oqx)
set oqx=null
return o7xendfunctionfunction jHx takes real jjx,real jJx returns reallocal real o7xif(jJx==0)thenset o7x=-1else
set o7x=jjx-(R2I(((jjx*1./ jJx)*1.)))*jJxif(o7x<0)thenset o7x=o7x+jJxendifendifreturn o7xendfunctionfunction jkx takes real a,real b returns reallocal real o7xset a=jHx(a,Cf)set b=jHx(b,Cf)set o7x=byx(a-b)
if(o7x>3.141592654)thenreturn(Cf-o7x)endifreturn o7xendfunctionfunction jKx takes real x,real y returns realreturn(SquareRoot(((x*x+y*y)*1.)))endfunctionfunction jlx takes real x returns realreturn(Cos(((x)*1.)))endfunctionfunction jLx takes real x returns realreturn(Sin(((x)*1.)))endfunctionfunction jmx takes real jMx,real jpx,real oyx,real bex,real jPx,real jqx,real x,real y returns booleanlocal real dX=x-jMxlocal real dY=y-jpxlocal real jQx=jkx(bex,(Atan2(((dY)*1.),((dX)*1.))))
local real d=jKx(dX,dY)local real jsx=jlx(jQx)*dlocal real jSx=jLx(jQx)*dlocal real jtx=jPx+(jqx-jPx)*(jsx*1./ oyx)if((jsx>=.0)and(jsx<=oyx)and(jSx<=jtx))thenreturn trueendifreturn false
endfunctionfunction jTx takes nothing returns booleanlocal integer jux=jhx()if not jmx(CQ,dQ,DQ,fQ,FQ,gQ,Dsx(jux),Dtx(jux))thenreturn false
endifif(C[jux]==vJ[eJ])thenreturn false
endifreturn trueendfunctionfunction jUx takes real o0x,real Iix returns reallocal real o7x=jkx(o0x,Iix)set o0x=jHx(o0x,Cf)set Iix=jHx(Iix,Cf)set o7x=Iix-o0xif(o7x>3.141592654)thenreturn-(Cf-o7x)endifif(o7x<-3.141592654)then
return(Cf+o7x)endifreturn o7xendfunctionfunction jwx takes real a returns integerif(a<0)thenreturn-1
endifif(a>0)thenreturn 1
endifreturn 0
endfunctionfunction jWx takes real jMx,real jpx,real oyx,real bex,real jPx,real jqx,real x,real y returns reallocal real dX=x-jMxlocal real dY=y-jpxlocal real jyx=jUx(bex,(Atan2(((dY)*1.),((dX)*1.))))
local real d=jKx(dX,dY)local real jQx=byx(jyx)local real dirFactor=jwx(jyx)local real jsx=jlx(jQx)*dlocal real jSx=jLx(jQx)*dlocal real jYx=(Atan2((((jqx-jPx))*1.),((oyx)*1.)))local real jzx=(Atan2((((jSx-jPx))*1.),((jsx)*1.)))local real jZx=jzx-jYxlocal real j_x=byx(jZx)local real j0x=jKx(jSx-jPx,jsx)local real j1xlocal real j2xlocal real j3xif jmx(jMx,jpx,oyx,bex,jPx,jqx,x,y)thenreturn .0endifset j1x=jlx(j_x)*j0x
set j2x=jLx(j_x)*j0x
set j3x=jKx(jqx-jPx,oyx)
if(j1x<0)thenif(jSx<jPx)thenreturn(-jsx)
endifreturn j0xendifif(j1x>j3x)thenif(jSx<jqx)thenreturn(jsx-oyx)endifreturn jKx(j1x-j3x,j2x)endifif(jsx<0)thenif(jSx<jPx)thenreturn(-jsx)
endifreturn j2xendifif(jsx>oyx)thenif(jSx<jqx)thenreturn(jsx-oyx)endifreturn j2xendifreturn j2xendfunctionfunction j4x takes integer oSx,real jMx,real jpx,real oyx,real bex,real jPx,real jqx returns realreturn iAx(.0,jWx(jMx,jpx,oyx,bex,jPx,jqx,(GetUnitX(C[((oSx))])),(GetUnitY(C[((oSx))])))-dox((oSx),true))endfunctionfunction j5x takes integer oSx,real jMx,real jpx,real oyx,real bex,real jPx,real jqx returns boolean
return(j4x(oSx,jMx,jpx,oyx,bex,jPx,jqx)==.0)
endfunctionfunction j6x takes nothing returns booleanlocal integer jux=jhx()if not j5x(jux,HQ,jQ,JQ,kQ,KQ,lQ)thenreturn false
endifif(C[jux]==vJ[eJ])thenreturn false
endifreturn trueendfunctionfunction j7x takes nothing returns nothingset hQ=Xpx(function j6x)
set LQ=Gzx(.0,.0,.0,.0)endfunctionfunction j8x takes nothing returns nothingset cQ=Xpx(function jTx)
set GQ=Gzx(.0,.0,.0,.0)call j7x()endfunctionfunction j9x takes nothing returns booleanreturn( not(C[jhx()]==vJ[eJ]))endfunctionfunction Jvx takes integer oSx,real x,real y,real Jex returns booleanlocal real dX=x-(GetUnitX(C[(((oSx)))]))
local real dY=y-(GetUnitY(C[(((oSx)))]))
set Jex=(Jex+dox((oSx),true))return(dX*dX+dY*dY<Jex*Jex)endfunctionfunction Jxx takes nothing returns booleanlocal integer jux=jhx()if not Jvx(jux,pQ,PQ,qQ)then
return false
endifif(C[jux]==vJ[eJ])thenreturn false
endifreturn trueendfunctionfunction Jox takes integer oSx,real x,real y,real z,real Jex returns boolean
local real dX=x-(GetUnitX(C[((oSx))]))local real dY=y-(GetUnitY(C[((oSx))]))local real dZ=z-fYx(oSx)
set Jex=(Jex+dox((oSx),true))return(dX*dX+dY*dY+dZ*dZ<Jex*Jex)endfunctionfunction Jrx takes nothing returns booleanlocal integer jux=jhx()if not Jox(jux,pQ,PQ,sQ,qQ)thenreturn false
endifif(C[jux]==vJ[eJ])thenreturn false
endifreturn trueendfunctionfunction Jix takes nothing returns nothingset MQ=Xpx(function Jxx)
set QQ=Xpx(function Jrx)
endfunctionfunction Jax takes nothing returns nothingset mQ=Xpx(function j9x)
call Jix()endfunctionfunction Jnx takes nothing returns booleanreturn( not(C[jhx()]==vJ[eJ]))endfunctionfunction JVx takes nothing returns booleanlocal integer jux=jhx()local real GWx=TQlocal real Gyx=uQlocal real GUx=UQlocal real Gwx=wQlocal real x=Dsx(jux)local real y=Dtx(jux)if((x<=GWx)and(y<=Gyx)and(x>=GUx)and(y>=Gwx))thenreturn trueendifif(Jvx(jux,iUx(iAx(GUx,x),GWx),iUx(iAx(Gwx,y),Gyx),.0))thenreturn trueendifif(C[jux]==vJ[eJ])thenreturn false
endifreturn false
endfunctionfunction JEx takes nothing returns nothingset tQ=Xpx(function JVx)
set WQ=Gzx(.0,.0,.0,.0)endfunctionfunction JXx takes nothing returns nothingset SQ=Xpx(function Jnx)
call JEx()endfunctionfunction JOx takes nothing returns nothingcall j8x()call Jax()call JXx()endfunctionfunction JRx takes integer oSx returns integerset xs[oSx]=true
set os[oSx]=falseset nb[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])call rEx(rs)
return oSxendfunctionfunction JIx takes nothing returns integerlocal integer oSxif(zQ==8190)then
call o_x("UnitList_Allocation_allocCustom","call DebugEx(UnitList.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Nj+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(ZQ[(w)]==w)thenset vs=vs+1set oSx=vselse
set oSx=ZQ[(w)]set ZQ[(w)]=ZQ[ZQ[(w)]]endifset ZQ[oSx]=Zset es[oSx]=1call JRx(oSx)return oSxendfunctionfunction JAx takes integer oSx returns nothingset Vb[(oSx)]=(as+oSx)endfunctionfunction JNx takes integer oSx returns nothingset ns[oSx]=0set Vs[oSx]=falseendfunctionfunction Jbx takes string rSx returns integerlocal integer oSx=JIx()set bj[(oSx)]=(rSx)call JAx(oSx)call JNx(oSx)return oSxendfunctionfunction JBx takes nothing returns nothingset Pj=Jbx("world")endfunctionfunction Jcx takes nothing returns booleanset bQ=O5x()
set BQ=O5x()
call JOx()set yQ=O5x()
set YQ=O5x()
call JBx()return trueendfunctionfunction JCx takes nothing returns booleancall jGx(function Jcx,"Group_Init")return trueendfunctionfunction Jdx takes nothing returns booleanset Es=VXx(Xs)return trueendfunctionfunction JDx takes nothing returns booleanset Os=VXx(Rs)return trueendfunctionfunction Jfx takes nothing returns booleanset Is=VXx(As)return trueendfunctionfunction JFx takes nothing returns booleanset Ns=VXx(bs)return trueendfunctionfunction Jgx takes nothing returns booleanset Bs=VXx(cs)return trueendfunctionfunction JGx takes nothing returns booleanset rs=VXx(Nj)return trueendfunctionfunction Jhx takes nothing returns booleanset Cs=VXx(ds)return trueendfunctionfunction JHx takes nothing returns booleanset Ds=VXx(fs)return trueendfunctionfunction Jjx takes nothing returns booleanset Fs=VXx(gs)return trueendfunctionfunction JJx takes nothing returns booleanset Gs=VXx(hs)return trueendfunctionfunction Jkx takes nothing returns booleanset Hs=VXx(js)return trueendfunctionfunction JKx takes nothing returns booleanset Js=VXx(ks)return trueendfunctionfunction Jlx takes nothing returns booleanset Ks=VXx(ls)return trueendfunctionfunction JLx takes nothing returns booleanset Ls=VXx(ms)return trueendfunctionfunction Jmx takes nothing returns booleanset Ms=VXx(ps)return trueendfunctionfunction JMx takes nothing returns booleanset Ps=VXx(qs)return trueendfunctionfunction Jpx takes nothing returns booleanset Qs=VXx(ss)return trueendfunctionfunction JPx takes nothing returns booleanset Ss=VXx(ts)return trueendfunctionfunction Jqx takes nothing returns booleanset Ts=VXx(us)return trueendfunctionfunction JQx takes nothing returns booleanset Us=VXx(ws)return trueendfunctionfunction Jsx takes nothing returns booleanset Ws=VXx(ys)return trueendfunctionfunction JSx takes nothing returns booleanset Ys=VXx(zs)return trueendfunctionfunction Jtx takes nothing returns booleanset Zs=VXx(vS)return trueendfunctionfunction JTx takes nothing returns booleanset eS=VXx(xS)return trueendfunctionfunction Jux takes integer oSx returns integerset nS[oSx]=true
set VS[oSx]=falseset ES[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])call rEx(Hs)
return oSxendfunctionfunction JUx takes nothing returns integerlocal integer oSxif(oS==8190)then
call o_x("ItemClass_Allocation_allocCustom","call DebugEx(ItemClass.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",js+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(rS[(w)]==w)thenset iS=iS+1set oSx=iSelse
set oSx=rS[(w)]set rS[(w)]=rS[rS[(w)]]endifset rS[oSx]=Zset aS[oSx]=1call Jux(oSx)return oSxendfunctionfunction Jwx takes integer oSx returns booleanset XS=XS+1set OS[XS]=oSxset RS[oSx]=XS+1
return(XS==0)endfunctionfunction JWx takes integer oSx returns nothingset IS[(oSx)]=(NS+oSx)endfunctionfunction Jyx takes nothing returns integerlocal integer oSx=JUx()call Jwx(oSx)call JWx(oSx)return oSxendfunctionfunction JYx takes nothing returns nothingset Mh=Jyx()
set bS=Jyx()
endfunctionfunction Jzx takes integer oSx returns integerset gS[oSx]=true
set GS[oSx]=falseset Kh[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set hS[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(eS)
return oSxendfunctionfunction JZx takes nothing returns integerlocal integer oSxif(dS==8190)then
call o_x("Item_Allocation_allocCustom","call DebugEx(Item.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",xS+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(DS[(w)]==w)thenset fS=fS+1set oSx=fSelse
set oSx=DS[(w)]set DS[(w)]=DS[DS[(w)]]endifset DS[oSx]=Zset FS[oSx]=1call Jzx(oSx)return oSxendfunctionfunction J_x takes integer oSx returns nothingset lh[(oSx)]=(JS+oSx)endfunctionfunction J0x takes integer oqx returns integerreturn(LoadInteger(o[((V[(E[((X))])]))],(((oqx))),(((KS)))))
endfunctionfunction J1x takes integer oSx returns nothingset Fh[oSx]=J0x(GetItemTypeId(gh[(oSx)]))endfunctionfunction J2x takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((lS[(oSx)]))])]))],((((Ph[((oSx))])))),(((otx))))))endfunctionfunction J3x takes integer oSx returns integerreturn J2x((oSx),mS)
endfunctionfunction J4x takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((lS[(oSx)]))])]))],((((Ph[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction J5x takes integer oSx,integer oLx returns integerreturn J4x((oSx),mS,oLx)
endfunctionfunction J6x takes integer oSx,integer otx,integer oux returns booleanreturn rrx(Kh[(oSx)],(lh[((oSx))]),otx,oux)endfunctionfunction J7x takes integer oSx,integer XYx returns nothingif not((LoadInteger(o[((D[((hS[oSx]))]))],((((lh[((oSx))])))),(oTx((((oA[(XYx)]))),(((XYx)))))))!=0)then
call o_x("FolderItem_StructEvent_Remove","call DebugEx(\"subject \"+I2S(Item(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((lh[((oSx))]))+" has not "+(jA[(XYx)]))
returnendifcall rrx(hS[oSx],(lh[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction J8x takes integer oSx,integer otx returns nothingcall SaveInteger(o[(((V[(E[((Kh[(oSx)]))])])))],(((((lh[((oSx))]))))),((((otx)))),(0))endfunctionfunction J9x takes integer oSx,integer rlx returns nothingif J6x((oSx),uh,rlx)then
call J7x((oSx),MS)endifcall J8x((oSx),Zh+rlx)endfunctionfunction kvx takes integer oSx,integer otx,integer oux returns booleanreturn rux(Kh[(oSx)],(lh[((oSx))]),otx,oux)endfunctionfunction kex takes integer oSx,integer XYx returns nothingif(hS[oSx]==w)thencall o_x("FolderItem_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oSx)+";"+(jA[(XYx)]))set hS[oSx]=Xendifcall rux(hS[oSx],(lh[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction kxx takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((Kh[(oSx)]))])]))],((((lh[((oSx))])))),(((otx))),(((oux))))endfunctionfunction kox takes integer oSx,integer rlx returns nothingif kvx((oSx),uh,rlx)then
call kex((oSx),MS)endifcall kxx((oSx),Zh+rlx,1)
endfunctionfunction krx takes integer oSx,integer rlx,integer rYx returns nothingif(rYx==0)thencall J9x(oSx,rlx)returnendifif((CLx(((oSx)),Zh+(rlx)))==0)thencall kox(oSx,rlx)endifcall kxx((oSx),Zh+rlx,rYx)endfunctionfunction kix takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((lS[(oSx)]))])]))],((((Ph[((oSx))])))),(((otx)))))endfunctionfunction kax takes integer oSx,integer rlx returns integerreturn kix((oSx),PS+rlx)
endfunctionfunction knx takes integer oSx returns nothinglocal integer Gpx=(Fh[((oSx))])local integer oMx=J3x(Gpx)local integer rlxloop
exitwhen(oMx<q)set rlx=J5x(Gpx,oMx)
call krx(oSx,rlx,kax(Gpx,rlx))set oMx=oMx-1endloopendfunctionfunction kVx takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((hS[oSx]))])]))],((((lh[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))endfunctionfunction kEx takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((hS[oSx]))])]))],((((lh[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))endfunctionfunction kXx takes integer oSx,integer nZx returns nothinglocal integer rLx=oSxlocal integer rFx=rRx((lh[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset qh[(rFx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=kVx(rLx,QS,rbx)loop
exitwhen(rMx<q)call rfx(kEx(rLx,QS,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction kOx takes integer oSx returns nothinglocal integer rFx=rRx((lh[(oSx)]))local integer oMxlocal integer rbxlocal integer rMxset qh[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=kVx(oSx,CS,rbx)loop
exitwhen(rMx<q)call rfx(kEx(oSx,CS,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction kRx takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((Kh[oSx]))])])],((((lh[((oSx))])))))endfunctionfunction kIx takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((hS[oSx]))])])],((((lh[((oSx))])))))endfunctionfunction kAx takes integer oSx returns nothingset gS[oSx]=falsecall kRx((oSx))call kIx(((oSx)))call rHx(eS)
endfunctionfunction kNx takes integer oSx returns nothingif(FS[oSx]>0)thenreturnendifif(DS[oSx]!=Z)thencall o_x("Item_Allocation_deallocCustom_confirm","call DebugEx(Item.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",xS+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset DS[oSx]=DS[(w)]set DS[(w)]=oSxcall kAx(oSx)endfunctionfunction kbx takes integer oSx returns nothingset FS[oSx]=FS[oSx]-1call kNx(oSx)endfunctionfunction kBx takes integer oSx returns nothinglocal item oqx=gh[oSx]call SetItemPosition(oqx,.0,.0)call kOx(oSx)call kbx((oSx))call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oqx))))),((((hh)))),((((oSx)))))
call RemoveItem(oqx)
set oqx=null
endfunctionfunction kcx takes integer oSx,integer nZx returns nothingset qS[oSx]=nZxcall SetItemCharges(gh[(oSx)],nZx)call kXx(oSx,nZx)if((nZx==0)and((sS[((Fh[((oSx))]))])>0))then
call kBx((oSx))endifendfunctionfunction kCx takes integer oSx returns nothingcall kcx(oSx,(sS[((Fh[((oSx))]))]))endfunctionfunction kdx takes integer oSx returns integerreturn J2x((oSx),tS)
endfunctionfunction kDx takes integer oSx,integer rNx returns nothingif kvx((oSx),mh,rNx)then
call kex((oSx),TS)endifendfunctionfunction kfx takes integer oSx,integer oLx returns integerreturn J4x((oSx),tS,oLx)
endfunctionfunction kFx takes integer oSx returns nothinglocal integer Gpx=(Fh[((oSx))])local integer oMx=kdx(Gpx)loop
exitwhen(oMx<q)call kDx(oSx,kfx(Gpx,oMx))set oMx=oMx-1endloopendfunctionfunction kgx takes integer oSx returns nothinglocal integer Gpx=(Fh[((oSx))])local integer rFx=rRx((Ph[(Gpx)]))local integer oMxlocal integer rbxlocal integer rMxset qh[(rFx)]=(oSx)set Qh[(rFx)]=(Gpx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=CJx(Gpx,BS,rbx)loop
exitwhen(rMx<q)call rfx(Ckx(Gpx,BS,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction kGx takes item oqx returns integerlocal integer oSx=JZx()set gh[oSx]=oqxcall SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oqx))))),((((hh)))),((((oSx)))))
set HS[(oSx)]=(-1)call J_x(oSx)call J1x(oSx)call knx(oSx)call kCx(oSx)call kFx(oSx)call kgx(oSx)return oSxendfunctionfunction khx takes nothing returns nothingcall kGx(GetEnumItem())endfunctionfunction kHx takes nothing returns booleanlocal integer rFx=(bv)call EnumItemsInRect(bm[Bm],null,function khx)return trueendfunctionfunction kjx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(qh[(rFx)])local integer oMx=CKx(rLx,uh)local integer rlxloop
exitwhen(oMx<q)set rlx=Clx(rLx,uh,oMx)call J6x(rLx,uh,rlx)
call J8x(rLx,Zh+rlx)
set oMx=oMx-1endloopcall J7x(rLx,MS)
return trueendfunctionfunction kJx takes integer oSx,integer otx returns nothingcall dwx((Kh[(oSx)]),((lh[((oSx))])),(otx))endfunctionfunction kkx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(qh[(rFx)])call kJx(rLx,mh)
call J7x(rLx,TS)
return trueendfunctionfunction kKx takes nothing returns nothingendfunctionfunction klx takes nothing returns booleancall JYx()set BS=(E3x())set cS=(E3x())set CS=(E3x())call Dcx(Xdx("Item_Init: call Event.Create(EventType.START, EventPriority.HEADER, function Item.Event_Start).AddToStatics()",EE,bI,function kHx))set MS=Xdx("FolderItem_StructAbilities_Init: set FolderItem_StructAbilities.DESTROY_EVENT = Event.Create(Item.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderItem_StructAbilities.Event_Destroy)",CS,bI,function kjx)set QS=(E3x())set TS=Xdx("FolderItem_StructClasses_Init: set FolderItem_StructClasses.DESTROY_EVENT = Event.Create(Item.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderItem_StructClasses.Event_Destroy)",CS,bI,function kkx)call kKx()return trueendfunctionfunction kLx takes nothing returns booleancall GDx(function klx,"Item_Init")return trueendfunctionfunction kmx takes nothing returns booleanset uS=VXx(US)return trueendfunctionfunction kMx takes nothing returns booleanset wS=VXx(WS)return trueendfunctionfunction kpx takes nothing returns booleanset yS=VXx(YS)return trueendfunctionfunction kPx takes nothing returns booleanset zS=VXx(ZS)return trueendfunctionfunction kqx takes nothing returns booleanset vt=VXx(et)return trueendfunctionfunction kQx takes nothing returns booleanset xt=VXx(ot)return trueendfunctionfunction ksx takes nothing returns booleanset rt=VXx(it)return trueendfunctionfunction kSx takes nothing returns booleanset at=VXx(nt)return trueendfunctionfunction ktx takes nothing returns booleanset Vt=VXx(Et)return trueendfunctionfunction kTx takes nothing returns booleanset Xt=VXx(Ot)return trueendfunctionfunction kux takes nothing returns booleanset Rt=VXx(It)return trueendfunctionfunction kUx takes nothing returns booleanreturn trueendfunctionfunction kwx takes nothing returns booleanset At=VXx(Nt)return trueendfunctionfunction kWx takes nothing returns booleanset SE=VXx(ME)return trueendfunctionfunction kyx takes nothing returns booleanset bt=VXx(Bt)return trueendfunctionfunction kYx takes nothing returns booleanset ct=VXx(Ct)return trueendfunctionfunction kzx takes nothing returns booleanset dt=VXx(Dt)return trueendfunctionfunction kZx takes nothing returns booleanset ft=VXx(Ft)return trueendfunctionfunction k_x takes nothing returns booleanset gt=VXx(Gt)return trueendfunctionfunction k0x takes nothing returns booleanset ht=VXx(Ht)return trueendfunctionfunction k1x takes nothing returns booleanset jt=VXx(Jt)return trueendfunctionfunction k2x takes nothing returns booleanset kt=VXx(Kt)return trueendfunctionfunction k3x takes nothing returns booleanset lt=VXx(Lt)return trueendfunctionfunction k4x takes nothing returns booleanset mt=VXx(Mt)return trueendfunctionfunction k5x takes nothing returns booleanset pt=VXx(Pt)return trueendfunctionfunction k6x takes nothing returns booleanset qt=VXx(Qt)return trueendfunctionfunction k7x takes nothing returns booleanset St=VXx(tt)return trueendfunctionfunction k8x takes nothing returns booleanset Tt=VXx(ut)return trueendfunctionfunction k9x takes nothing returns booleanset Ut=VXx(wt)return trueendfunctionfunction Kvx takes nothing returns booleanset Wt=VXx(yt)return trueendfunctionfunction Kex takes nothing returns booleanset Yt=VXx(zt)return trueendfunctionfunction Kxx takes nothing returns booleanset Zt=VXx(vT)return trueendfunctionfunction Kox takes nothing returns nothingendfunctionfunction Krx takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((iT[(oSx)]))])]))],((((aT[((oSx))])))),(((otx))))))endfunctionfunction Kix takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((iT[(oSx)]))])]))],((((aT[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction Kax takes integer oSx returns nothingset OT[oSx]=falsecall rHx(mt)
endfunctionfunction Knx takes integer oSx returns nothingif(ET[oSx]>0)thenreturnendifif(XT[oSx]!=Z)thencall o_x("FolderLightning_FolderColor_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderLightning_FolderColor_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Mt+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset XT[oSx]=XT[(w)]set XT[(w)]=oSxcall Kax(oSx)endfunctionfunction KVx takes integer oSx returns nothingset ET[oSx]=ET[oSx]-1call Knx(oSx)endfunctionfunction KEx takes integer oSx,integer otx,integer oux returns booleanreturn rrx(iT[(oSx)],(aT[((oSx))]),otx,oux)endfunctionfunction KXx takes integer oSx,integer XYx returns nothingif not((LoadInteger(o[((D[((RT[oSx]))]))],((((aT[((oSx))])))),(oTx((((oA[(XYx)]))),(((XYx)))))))!=0)then
call o_x("FolderLightning_StructEvent_Remove","call DebugEx(\"subject \"+I2S(Lightning(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((aT[((oSx))]))+" has not "+(jA[(XYx)]))returnendifcall rrx(RT[oSx],(aT[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction KOx takes integer oSx returns booleanlocal integer oLx=(IT[(oSx)])set IT[AT[NT]]=oLxset AT[oLx-1]=AT[NT]
set IT[oSx]=0set NT=NT-1return(NT==F)endfunctionfunction KRx takes integer oSx,integer iCx,integer rLx returns nothingcall KVx((oSx))call iKx(iCx)if KEx(rLx,VT,oSx)thencall KXx(rLx,oT)
endifif KOx(oSx)thencall ikx(bT)
endifendfunctionfunction KIx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(rT[(rFx)])local integer oMx=Krx(rLx,VT)local integer oSxloop
set oSx=Kix(rLx,VT,oMx)call KRx(oSx,BT[oSx],rLx)set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction KAx takes nothing returns nothingset oT=Xdx("FolderLightning_FolderColor_StructTimed_Init: set FolderLightning_FolderColor_StructTimed.DESTROY_EVENT = Event.Create(Lightning.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_FolderColor_StructTimed.Event_Destroy)",eT,bI,function KIx)set bT=iXx()
endfunctionfunction KNx takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((iT[(oSx)]))])]))],((((aT[((oSx))])))),(((otx)))))endfunctionfunction Kbx takes integer oSx returns nothingset FT[oSx]=falsecall rHx(Yt)
endfunctionfunction KBx takes integer oSx returns nothingif(DT[oSx]>0)thenreturnendifif(fT[oSx]!=Z)thencall o_x("FolderLightning_StructDestroyTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderLightning_StructDestroyTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",zt+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset fT[oSx]=fT[(w)]set fT[(w)]=oSxcall Kbx(oSx)endfunctionfunction Kcx takes integer oSx returns nothingset DT[oSx]=DT[oSx]-1call KBx(oSx)endfunctionfunction KCx takes integer oSx,integer otx returns nothingcall SaveInteger(o[(((V[(E[((iT[(oSx)]))])])))],(((((aT[((oSx))]))))),((((otx)))),(0))endfunctionfunction Kdx takes integer oSx,integer iCx,integer rLx returns nothingcall Kcx((oSx))call iKx(iCx)call KCx(rLx,dT)
call KXx(rLx,cT)
endfunctionfunction KDx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(rT[(rFx)])local integer oSx=KNx(rLx,dT)call Kdx(oSx,gT[oSx],rLx)return trueendfunctionfunction Kfx takes integer oSx returns nothingset kT[oSx]=falsecall rHx(qt)
endfunctionfunction KFx takes integer oSx returns nothingif(jT[oSx]>0)thenreturnendifif(JT[oSx]!=Z)thencall o_x("FolderLightning_StructFromDummyUnitToUnit_Allocation_deallocCustom_confirm","call DebugEx(FolderLightning_StructFromDummyUnitToUnit.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Qt+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset JT[oSx]=JT[(w)]set JT[(w)]=oSxcall Kfx(oSx)endfunctionfunction Kgx takes integer oSx returns nothingset jT[oSx]=jT[oSx]-1call KFx(oSx)endfunctionfunction KGx takes integer oSx,integer o0x returns nothingif HOx(o0x,lT,oSx)thencall HRx(o0x,LT)
endifendfunctionfunction Khx takes integer oSx returns nothinglocal integer oux=(MT[(oSx)])-1set MT[oSx]=ouxif((oux==0)and pT[oSx])thencall Owx((oSx))endifendfunctionfunction KHx takes integer oSx,integer Iix returns nothingif rnx(Iix,lT,oSx)thencall RPx(Iix,mT)
call Khx(Iix)endifendfunctionfunction Kjx takes integer oSx returns booleanlocal integer oLx=(PT[(oSx)])set PT[qT[QT]]=oLxset qT[oLx-1]=qT[QT]
set PT[oSx]=0set QT=QT-1return(QT==F)endfunctionfunction KJx takes integer oSx,integer rLx,integer o0x,integer Iix returns nothingcall Kgx((oSx))call KCx(rLx,HT)
call KXx(rLx,GT)
if(o0x!=w)thencall KGx(oSx,o0x)endifif(Iix!=w)thencall KHx(oSx,Iix)endifif Kjx(oSx)thencall ikx(sT)
endifendfunctionfunction Kkx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(rT[(rFx)])local integer oSx=KNx(rLx,HT)call KJx(oSx,rLx,ST[oSx],tT[oSx])return trueendfunctionfunction KKx takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((RT[oSx]))])]))],((((aT[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))endfunctionfunction Klx takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((RT[oSx]))])]))],((((aT[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))endfunctionfunction KLx takes integer oSx returns nothinglocal integer rFx=rRx((aT[(oSx)]))local integer oMxlocal integer rbxlocal integer rMxset rT[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=KKx(oSx,xT,rbx)loop
exitwhen(rMx<q)call rfx(Klx(oSx,xT,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction Kmx takes integer oSx returns nothingif uT[oSx]thenset uT[oSx]=falsecall KLx(oSx)endifendfunctionfunction KMx takes integer oSx returns nothinglocal integer rFx=rRx((aT[(oSx)]))local integer oMxlocal integer rbxlocal integer rMxset rT[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=KKx(oSx,eT,rbx)loop
exitwhen(rMx<q)call rfx(Klx(oSx,eT,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction Kpx takes integer oSx,real izx,real iZx,real i_x,real i0x returns nothinglocal integer oDx=fhx()set UT[(oSx)]=((izx)*1.)
set wT[(oSx)]=((iZx)*1.)
set WT[(oSx)]=((i_x)*1.)
set yT[(oSx)]=((i0x)*1.)
set izx=blx(izx,.0,1.)set iZx=blx(iZx,.0,1.)set i_x=blx(i_x,.0,1.)set i0x=blx(i0x,.0,1.)call SetLightningColor(YT[(oSx)],izx,iZx,i_x,i0x)endfunctionfunction KPx takes integer oSx,real izx,real iZx,real i_x,real i0x returns nothingcall Kpx(oSx,(UT[(oSx)])+izx,(wT[(oSx)])+iZx,(WT[(oSx)])+i_x,(yT[(oSx)])+i0x)endfunctionfunction Kqx takes integer oSx returns integerset OT[oSx]=true
set eu[oSx]=falsecall rEx(mt)
return oSxendfunctionfunction KQx takes nothing returns integerlocal integer oSxif(ZT==8190)then
call o_x("FolderLightning_FolderColor_StructTimed_Allocation_allocCustom","call DebugEx(FolderLightning_FolderColor_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Mt+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(XT[(w)]==w)thenset vu=vu+1set oSx=vuelse
set oSx=XT[(w)]set XT[(w)]=XT[XT[(w)]]endifset XT[oSx]=Zset ET[oSx]=1call Kqx(oSx)return oSxendfunctionfunction Ksx takes integer oSx,integer otx,integer oux returns booleanreturn rux(iT[(oSx)],(aT[((oSx))]),otx,oux)endfunctionfunction KSx takes integer oSx,integer XYx returns nothingif(RT[oSx]==w)thencall o_x("FolderLightning_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oSx)+";"+(jA[(XYx)]))set RT[oSx]=Xendifcall rux(RT[oSx],(aT[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction Ktx takes integer oSx returns booleanset NT=NT+1set AT[NT]=oSxset IT[oSx]=NT+1
return(NT==0)endfunctionfunction KTx takes nothing returns nothinglocal integer oMx=NT
local integer oSxloop
set oSx=AT[oMx]call KPx(au[oSx],xu[oSx],ou[oSx],ru[oSx],iu[oSx])set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction Kux takes nothing returns nothinglocal integer iCx=iGx()local integer oSx=(ge[(iCx)])call KRx(oSx,iCx,au[oSx])endfunctionfunction KUx takes integer oSx,real izx,real iZx,real i_x,real i0x,real iMx returns nothinglocal integer rLx=oSxlocal integer fexlocal integer iCxif(iMx==.0)thencall KPx((oSx),izx,iZx,i_x,i0x)returnendifset fex=(R2I(((iMx*1./ zT)*1.)))
set oSx=KQx()set iCx=iXx()set xu[oSx]=izx*1./ fexset ou[oSx]=iZx*1./ fexset ru[oSx]=i_x*1./ fexset iu[oSx]=i0x*1./ fexset BT[oSx]=iCxset au[oSx]=rLxset ge[(iCx)]=(oSx)if Ksx(rLx,VT,oSx)thencall KSx(rLx,oT)
endifif Ktx(oSx)thencall iDx(bT,zT,true,function KTx)endifcall iDx(iCx,iMx,false,function Kux)
endfunctionfunction Kwx takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((iT[oSx]))])])],((((aT[((oSx))])))))endfunctionfunction KWx takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((RT[oSx]))])])],((((aT[((oSx))])))))endfunctionfunction Kyx takes integer oSx returns nothingset Xu[oSx]=falsecall Kwx((oSx))call KWx(((oSx)))call rHx(Zt)
endfunctionfunction KYx takes integer oSx returns nothingif(Vu[oSx]>0)thenreturnendifif(Eu[oSx]!=Z)thencall o_x("Lightning_Allocation_deallocCustom_confirm","call DebugEx(Lightning.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",vT+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Eu[oSx]=Eu[(w)]set Eu[(w)]=oSxcall Kyx(oSx)endfunctionfunction Kzx takes integer oSx returns nothingset Vu[oSx]=Vu[oSx]-1call KYx(oSx)endfunctionfunction KZx takes nothing returns nothinglocal integer K_x=iGx()local integer oSx=(ge[(K_x)])local lightning oqx=YT[oSx]call iKx(K_x)call Kzx((oSx))call DestroyLightning(oqx)set oqx=null
endfunctionfunction K0x takes integer oSx returns nothinglocal integer K_xcall Kmx(oSx)set K_x=iXx()set ge[(K_x)]=(oSx)call KMx(oSx)call KUx((oSx),-((.0)*1.),-((.0)*1.),-((.0)*1.),-(((yT[(oSx)]))*1.),((nu)*1.))call iDx(K_x,nu,false,function KZx)endfunctionfunction K1x takes nothing returns booleanlocal integer rFx=(bv)local integer o0x=(Wp[(rFx)])local integer oMx=Hax(o0x,lT)local integer oSxloop
set oSx=Hnx(o0x,lT,oMx)if(tT[oSx]==w)thencall KJx(oSx,TT[oSx],o0x,w)call K0x(TT[oSx])else
call KGx(oSx,o0x)set ST[oSx]=wset Ou[oSx]=(iJ[(o0x)])set Ru[oSx]=(EJ[(o0x)])set Iu[oSx]=(Au[(o0x)])+Nu[oSx]endifset oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction K2x takes integer oSx,boolean OPx returns realif OPx thenreturn(Cu[oSx]*(eb[((oSx))]))endifreturn Cu[oSx]endfunctionfunction K3x takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oMx=CIx(Iix,lT)local integer oSxlocal real dVxlocal real dExloop
set oSx=CAx(Iix,lT,oMx)if(ST[oSx]==w)thencall KJx(oSx,TT[oSx],w,Iix)call K0x(TT[oSx])else
set dVx=Dsx(Iix)
set dEx=Dtx(Iix)
call KHx(oSx,Iix)set tT[oSx]=wset bu[oSx]=dVxset Bu[oSx]=dExset cu[oSx]=OMx(Iix,dVx,dEx)+K2x(Iix,true)endifset oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction K4x takes nothing returns nothingset GT=Xdx("FolderLightning_StructFromDummyUnitToUnit_Init: set FolderLightning_StructFromDummyUnitToUnit.PARENT_STOP_EVENT = Event.Create(Lightning.STOP_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromDummyUnitToUnit.Event_Parent_Stop)",xT,bI,function Kkx)set LT=Xdx("FolderLightning_StructFromDummyUnitToUnit_Init: set FolderLightning_StructFromDummyUnitToUnit.SOURCE_DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromDummyUnitToUnit.Event_Source_Destroy)",aP,bI,function K1x)set mT=Xdx("FolderLightning_StructFromDummyUnitToUnit_Init: set FolderLightning_StructFromDummyUnitToUnit.TARGET_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromDummyUnitToUnit.Event_Target_Destroy)",EP,bI,function K3x)set sT=iXx()
endfunctionfunction K5x takes integer oSx returns nothingset Gu[oSx]=falsecall rHx(St)
endfunctionfunction K6x takes integer oSx returns nothingif(Fu[oSx]>0)thenreturnendifif(gu[oSx]!=Z)thencall o_x("FolderLightning_StructFromSpotToDummyUnit_Allocation_deallocCustom_confirm","call DebugEx(FolderLightning_StructFromSpotToDummyUnit.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",tt+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset gu[oSx]=gu[(w)]set gu[(w)]=oSxcall K5x(oSx)endfunctionfunction K7x takes integer oSx returns nothingset Fu[oSx]=Fu[oSx]-1call K6x(oSx)endfunctionfunction K8x takes integer oSx returns booleanlocal integer oLx=(Ju[(oSx)])set Ju[ku[Ku]]=oLxset ku[oLx-1]=ku[Ku]
set Ju[oSx]=0set Ku=Ku-1return(Ku==F)endfunctionfunction K9x takes integer oSx,integer rLx,integer Iix returns nothingcall K7x((oSx))call KCx(rLx,fu)
call KXx(rLx,du)
if HOx(Iix,Hu,oSx)thencall HRx(Iix,ju)
endifif K8x(oSx)thencall ikx(lu)
endifendfunctionfunction lvx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(rT[(rFx)])local integer oSx=KNx(rLx,fu)call K9x(oSx,rLx,Lu[oSx])return trueendfunctionfunction lex takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Wp[(rFx)])local integer oMx=Hax(Iix,Hu)local integer oSxloop
set oSx=Hnx(Iix,Hu,oMx)call K9x(oSx,mu[oSx],Iix)call K0x(mu[oSx])set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction lxx takes nothing returns nothingset du=Xdx("FolderLightning_StructFromSpotToDummyUnit_Init: set FolderLightning_StructFromSpotToDummyUnit.PARENT_STOP_EVENT = Event.Create(Lightning.STOP_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromSpotToDummyUnit.Event_Parent_Stop)",xT,bI,function lvx)set ju=Xdx("FolderLightning_StructFromSpotToDummyUnit_Init: set FolderLightning_StructFromSpotToDummyUnit.TARGET_DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromSpotToDummyUnit.Event_Target_Destroy)",aP,bI,function lex)set lu=iXx()
endfunctionfunction lox takes integer oSx returns nothingset su[oSx]=falsecall rHx(Tt)
endfunctionfunction lrx takes integer oSx returns nothingif(qu[oSx]>0)thenreturnendifif(Qu[oSx]!=Z)thencall o_x("FolderLightning_StructFromSpotToSpot_Allocation_deallocCustom_confirm","call DebugEx(FolderLightning_StructFromSpotToSpot.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",ut+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Qu[oSx]=Qu[(w)]set Qu[(w)]=oSxcall lox(oSx)endfunctionfunction lix takes integer oSx returns nothingset qu[oSx]=qu[oSx]-1call lrx(oSx)endfunctionfunction lax takes integer oSx,integer rLx returns nothingcall lix((oSx))call KCx(rLx,Pu)
call KXx(rLx,Mu)
endfunctionfunction lnx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(rT[(rFx)])local integer oSx=KNx(rLx,Pu)call lax(oSx,rLx)return trueendfunctionfunction lVx takes integer oSx returns nothingset wu[oSx]=falsecall rHx(Ut)
endfunctionfunction lEx takes integer oSx returns nothingif(uu[oSx]>0)thenreturnendifif(Uu[oSx]!=Z)thencall o_x("FolderLightning_StructFromSpotToUnit_Allocation_deallocCustom_confirm","call DebugEx(FolderLightning_StructFromSpotToUnit.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",wt+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Uu[oSx]=Uu[(w)]set Uu[(w)]=oSxcall lVx(oSx)endfunctionfunction lXx takes integer oSx returns nothingset uu[oSx]=uu[oSx]-1call lEx(oSx)endfunctionfunction lOx takes integer oSx returns booleanlocal integer oLx=(zu[(oSx)])set zu[Zu[vU]]=oLxset Zu[oLx-1]=Zu[vU]
set zu[oSx]=0set vU=vU-1return(vU==F)endfunctionfunction lRx takes integer oSx,integer rLx,integer Iix returns nothingcall lXx((oSx))call KCx(rLx,Tu)
call KXx(rLx,Su)
if rnx(Iix,yu,oSx)thencall RPx(Iix,Yu)
call Khx(Iix)endifif lOx(oSx)thencall ikx(eU)
endifendfunctionfunction lIx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(rT[(rFx)])local integer oSx=KNx(rLx,Tu)call lRx(oSx,rLx,xU[oSx])return trueendfunctionfunction lAx takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oMx=CIx(Iix,yu)local integer oSxloop
set oSx=CAx(Iix,yu,oMx)call lRx(oSx,oU[oSx],Iix)call K0x(oU[oSx])set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction lNx takes nothing returns nothingset Su=Xdx("FolderLightning_StructFromSpotToUnit_Init: set FolderLightning_StructFromSpotToUnit.PARENT_STOP_EVENT = Event.Create(Lightning.STOP_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromSpotToUnit.Event_Parent_Stop)",xT,bI,function lIx)set Yu=Xdx("FolderLightning_StructFromSpotToUnit_Init: set FolderLightning_StructFromSpotToUnit.TARGET_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromSpotToUnit.Event_Target_Destroy)",EP,bI,function lAx)set eU=iXx()
endfunctionfunction lbx takes integer oSx returns nothingset EU[oSx]=falsecall rHx(Wt)
endfunctionfunction lBx takes integer oSx returns nothingif(nU[oSx]>0)thenreturnendifif(VU[oSx]!=Z)thencall o_x("FolderLightning_StructFromUnitToUnit_Allocation_deallocCustom_confirm","call DebugEx(FolderLightning_StructFromUnitToUnit.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",yt+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset VU[oSx]=VU[(w)]set VU[(w)]=oSxcall lbx(oSx)endfunctionfunction lcx takes integer oSx returns nothingset nU[oSx]=nU[oSx]-1call lBx(oSx)endfunctionfunction lCx takes integer oSx,integer ldx returns nothingif rnx(ldx,OU,oSx)thencall RPx(ldx,RU)
call Khx(ldx)endifendfunctionfunction lDx takes integer oSx returns booleanlocal integer oLx=(IU[(oSx)])set IU[AU[NU]]=oLxset AU[oLx-1]=AU[NU]
set IU[oSx]=0set NU=NU-1return(NU==F)endfunctionfunction lfx takes integer oSx,integer rLx,integer o0x,integer Iix returns nothingcall lcx((oSx))call KCx(rLx,aU)
call KXx(rLx,rU)
if(o0x!=w)thencall lCx(oSx,o0x)endifif(Iix!=w)thencall lCx(oSx,Iix)endifif lDx(oSx)thencall ikx(bU)
endifendfunctionfunction lFx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(rT[(rFx)])local integer oSx=KNx(rLx,aU)call lfx(oSx,rLx,BU[oSx],cU[oSx])return trueendfunctionfunction lgx takes nothing returns booleanlocal integer rFx=(bv)local integer ldx=(Vv[(rFx)])local integer oMx=CIx(ldx,OU)local integer oSxloop
set oSx=CAx(ldx,OU,oMx)if(ldx==BU[oSx])then
if(cU[oSx]==w)thencall lfx(oSx,CU[oSx],ldx,w)call K0x(CU[oSx])else
call lCx(oSx,ldx)set BU[oSx]=wset dU[oSx]=Dsx(ldx)
set DU[oSx]=Dtx(ldx)
set fU[oSx]=fYx(ldx)+Opx(ldx,true)endifelse
if(BU[oSx]==w)thencall lfx(oSx,CU[oSx],w,ldx)call K0x(CU[oSx])else
call lCx(oSx,ldx)set cU[oSx]=wset FU[oSx]=Dsx(ldx)
set gU[oSx]=Dtx(ldx)
set GU[oSx]=fYx(ldx)+K2x(ldx,true)endifendifset oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction lGx takes nothing returns nothingset rU=Xdx("FolderLightning_StructFromUnitToUnit_Init: set FolderLightning_StructFromUnitToUnit.PARENT_STOP_EVENT = Event.Create(Lightning.STOP_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromUnitToUnit.Event_Parent_Stop)",xT,bI,function lFx)set RU=Xdx("FolderLightning_StructFromUnitToUnit_Init: set FolderLightning_StructFromUnitToUnit.POST_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromUnitToUnit.Event_Post_Destroy)",EP,bI,function lgx)set bU=iXx()
endfunctionfunction lhx takes nothing returns booleancall Kox()set eT=(E3x())set xT=(E3x())call KAx()set cT=Xdx("FolderLightning_StructDestroyTimed_Init: set FolderLightning_StructDestroyTimed.DESTROY_EVENT = Event.Create(Lightning.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructDestroyTimed.Event_Destroy)",eT,bI,function KDx)
call K4x()call lxx()set Mu=Xdx("FolderLightning_StructFromSpotToSpot_Init: set FolderLightning_StructFromSpotToSpot.PARENT_STOP_EVENT = Event.Create(Lightning.STOP_EVENT_TYPE, EventPriority.HEADER, function FolderLightning_StructFromSpotToSpot.Event_Parent_Stop)",xT,bI,function lnx)call lNx()call lGx()return trueendfunctionfunction lHx takes nothing returns booleancall Hix(function lhx,"Lightning_Init")return trueendfunctionfunction ljx takes nothing returns booleanreturn trueendfunctionfunction lJx takes nothing returns booleanset hU=VXx(HU)return trueendfunctionfunction lkx takes nothing returns booleanset jU=VXx(JU)return trueendfunctionfunction lKx takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=Flx((av[(rFx)]))local integer FPx=(AK)if Fmx(Cqx,FMx(FPx,lU))thenreturn false
endifreturn truereturn trueendfunctionfunction llx takes nothing returns booleanlocal integer rFx=(bv)local integer FPx=(Fqx(((Nv)),CK))if((nv[(rFx)])!=FMx(FPx,lU))then
return false
endifreturn truereturn trueendfunctionfunction lLx takes nothing returns booleanlocal integer rFx=(bv)local integer FPx=(Fqx(((Nv)),CK))if((nv[(rFx)])!=FMx(FPx,lU))then
return false
endifreturn truereturn trueendfunctionfunction lmx takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=Flx((av[(rFx)]))local integer rlx=FMx((AK),lU)if((lF[(Cqx)])<Ftx(rlx,1))thenreturn false
endifreturn truereturn trueendfunctionfunction lMx takes nothing returns booleanset kU=Xpx(function lKx)
set LU=Xpx(function llx)
set mU=Xpx(function lLx)
set MU=Xpx(function lmx)
return trueendfunctionfunction lpx takes nothing returns booleancall FKx(function lMx,"AICastSpell_Init")return trueendfunctionfunction lPx takes integer oSx returns integerset SU[oSx]=true
set tU[oSx]=falseset YB[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set Jc[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(il)
return oSxendfunctionfunction lqx takes nothing returns integerlocal integer oSxif(PU==8190)then
call o_x("Buff_Allocation_allocCustom","call DebugEx(Buff.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",al+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(qU[(w)]==w)thenset QU=QU+1set oSx=QUelse
set oSx=qU[(w)]set qU[(w)]=qU[qU[(w)]]endifset qU[oSx]=Zset sU[oSx]=1call lPx(oSx)return oSxendfunctionfunction lQx takes integer oSx returns nothingset zB[(oSx)]=(TU+oSx)endfunctionfunction lsx takes integer oSx returns nothingendfunctionfunction lSx takes integer oSx returns booleanset rD=rD+1set iD[rD]=oSxset UU[oSx]=rD+1
return(rD==0)endfunctionfunction ltx takes string rSx returns integerlocal integer oSx=lqx()call lQx(oSx)set Ud[(oSx)]=(true)
set Pc[(oSx)]=(false)set uU[(oSx)]=(false)set oD[(oSx)]=(rSx+" (hidden)")set sc[((oSx))]=(true)call lsx(oSx)call XLx((oD[(oSx)]),Tb,oSx)
call lSx(oSx)return oSxendfunctionfunction lTx takes integer oSx,integer o9x,integer otx,string oux returns booleanlocal integer rvx=(0+(LoadInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx))))))+1call SaveInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx))),(((rvx)-0)))
call SaveStr(o[((V[(E[(oSx)])]))],((o9x)),((otx+rvx)),((oux)))return(rvx==q)endfunctionfunction lux takes integer oSx,integer otx,string oux returns booleanreturn lTx(YB[(oSx)],(zB[((oSx))]),otx,oux)endfunctionfunction lUx takes integer oSx,integer o9x,integer otx,integer oux returns booleanlocal integer rvx=(0+(LoadInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx))))))+1call SaveInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx))),(((rvx)-0)))
call SaveInteger(o[((V[(E[(oSx)])]))],((o9x)),((otx+rvx)),((oux)))return(rvx==q)endfunctionfunction lwx takes integer oSx,integer otx,integer oux returns booleanreturn lUx(YB[(oSx)],(zB[((oSx))]),otx,oux)endfunctionfunction lWx takes integer oSx,string lyx,string Abx,integer rYx returns nothing
call lux((oSx),rC,Abx)call lwx((oSx),iC,rYx)call lux((oSx),Sc,lyx)call DestroyEffect(AddSpecialEffect((lyx),.0,.0))endfunctionfunction lYx takes integer oSx returns integerset ew[oSx]=true
set xw[oSx]=falseset ec[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])call rEx(ow)
return oSxendfunctionfunction lzx takes nothing returns integerlocal integer oSxif(yU==8190)then
call o_x("UnitModSet_Allocation_allocCustom","call DebugEx(UnitModSet.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",YU+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(zU[(w)]==w)thenset ZU=ZU+1set oSx=ZUelse
set oSx=zU[(w)]set zU[(w)]=zU[zU[(w)]]endifset zU[oSx]=Zset vw[oSx]=1call lYx(oSx)return oSxendfunctionfunction lZx takes integer oSx returns nothingset xc[(oSx)]=(rw+oSx)endfunctionfunction l_x takes nothing returns integerlocal integer oSx=lzx()call lZx(oSx)return oSxendfunctionfunction l0x takes integer oSx,integer otx,integer oux returns booleanreturn rux(ec[(oSx)],(xc[((oSx))]),otx,oux)endfunctionfunction l1x takes integer oSx,integer otx,real oux returns nothingcall SaveReal(o[((V[(E[((ec[(oSx)]))])]))],((((xc[((oSx))])))),(((otx))),((((((oux)*1.))*1.))*1.))endfunctionfunction l2x takes integer oSx,integer Ibx,real o5x returns nothingcall l0x((oSx),nc,Ibx)call l1x((oSx),Ec+Ibx,o5x)endfunctionfunction l3x takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((YB[(oSx)]))])]))],((((zB[((oSx))])))),(((otx))),(((oux))))endfunctionfunction l4x takes nothing returns booleanset pU=ltx(wU+" (dummyBuff)")call lWx(pU,"Abilities\\Spells\\Other\\GeneralAuraTarget\\GeneralAuraTarget.mdl","origin",ri)set WU=l_x()
call l2x(WU,iw,.5)call l3x(((pU)),ZB+(1),(WU))
return trueendfunctionfunction l5x takes nothing returns booleanset aw=ltx(wU+" (targetBuff)")set Pc[(aw)]=(true)return trueendfunctionfunction l6x takes nothing returns booleancall VNx(ma,(function l4x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\AI\\LetOff.page\\AILetOff.struct\\obj_dummyBuff_wc3buff.j"))call VNx(ma,(function l5x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\AI\\LetOff.page\\AILetOff.struct\\obj_targetBuff_wc3buff.j"))return trueendfunctionfunction l7x takes nothing returns booleanset nw=VXx(wU)return trueendfunctionfunction l8x takes code c,string rSx returns nothing
set UV=UV+1set wV[UV]=CreateTrigger()set WV[UV]=(GetHandleId(Condition((c))))
set yV[UV]=rSxcall TriggerAddCondition(wV[UV],Condition(c))endfunctionfunction l9x takes integer oSx,integer Iax,integer rYx returns booleanreturn Dux(oSx,Iax,rYx,w)endfunctionfunction Lvx takes nothing returns booleanlocal integer rFx=(bv)local integer o0x=(Vv[(rFx)])local integer Iix=(zH[(rFx)])if not I9x(Iix,Wd)thenreturn trueendifset Xw=Iixcall l9x(o0x,pU,1)return trueendfunctionfunction Lex takes nothing returns booleanlocal integer rFx=(bv)local integer o0x=(Vv[(rFx)])call Avx(o0x,Vw)
return trueendfunctionfunction Lxx takes integer oSx,integer XYx returns nothingif(Jc[oSx]==w)thencall o_x("FolderBuff_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oSx)+";"+(jA[(XYx)]))set Jc[oSx]=Xendifcall rux(Jc[oSx],(zB[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction Lox takes integer oSx,integer Rox,integer Iix returns booleanreturn(IssueTargetOrderById(C[(oSx)],pb[Rox],C[(Iix)]))endfunctionfunction Lrx takes integer oSx returns booleanif((Bw[((oSx))])>0)thenreturn false
endifset cw=cw+1set Cw[cw]=oSxset Bw[oSx]=cw+1
return(cw==0)endfunctionfunction Lix takes nothing returns nothinglocal integer oMx=cw
loop
exitwhen(oMx<0)set dw[oMx]=Cw[oMx]set oMx=oMx-1endloopset Dw=cwendfunctionfunction Lax takes nothing returns integerlocal integer o7xif(Dw<0)then
return w
endifset o7x=dw[0]set dw[0]=dw[Dw]
set Dw=Dw-1return o7xendfunctionfunction Lnx takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((Jw[(oSx)]))])]))],((((kw[((oSx))])))),(((otx)))))endfunctionfunction LVx takes integer oSx returns realreturn(tm[((Lw[(oSx)]))])endfunctionfunction LEx takes integer oSx returns realreturn(Tm[((Lw[(oSx)]))])endfunctionfunction LXx takes integer OSx returns nothinglocal integer oSx=OSxlocal integer rLx=gw[oSx]local integer RLxlocal real x
local real y
if Gw thenreturnendifif(rLx==w)thenset RLx=hwelse
set RLx=(Hw[(rLx)])endifif(RLx==w)thenif(jw[((Lnx(((Tf[(OSx)])),Kw)))])thencall Lox(OSx,bw,lw)else
call CBx(OSx,bw,(GetUnitX(C[((lw))])),(GetUnitY(C[((lw))])))
endifelse
set x=LVx(RLx)set y=LEx(RLx)if(jw[((Lnx(((Tf[(OSx)])),Kw)))])thencall CBx(OSx,Bh,x,y)
else
call CBx(OSx,bw,x,y)
endifendifendfunctionfunction LOx takes nothing returns nothinglocal integer oSxlocal integer o0xlocal integer Iixcall Lix()loop
set oSx=Lax()exitwhen(oSx==w)
set o0x=oSxset Iix=Iw[oSx]if(GZx(Dtx(Iix)-Dtx(o0x),Dsx(Iix)-Dsx(o0x))>Fw)thencall AZx(o0x,pU)
call LXx(o0x)endifendloopendfunctionfunction LRx takes nothing returns booleanlocal integer rFx=(bv)local integer o0x=(Vv[(rFx)])local integer Iix=Xw
local integer oSx=o0xset Iw[oSx]=Iixcall Avx(o0x,Vw)
if rUx(Iix,Nw,oSx)thencall l9x(Iix,aw,1)endifcall Lox(o0x,bw,Iix)
if Lrx(oSx)thencall iDx(Ow,3.,true,function LOx)endifreturn trueendfunctionfunction LIx takes integer oSx returns booleanif(((Bw[((oSx))])>0)==false)then
return false
endifset Bw[Cw[cw]]=Bw[oSx]set Cw[Bw[oSx]-1]=Cw[cw]
set Bw[oSx]=0set cw=cw-1return(cw==F)endfunctionfunction LAx takes nothing returns booleanlocal integer rFx=(bv)local integer o0x=(Vv[(rFx)])local integer oSx=o0xlocal integer Iix=Iw[oSx]call RPx(o0x,Vw)
if rnx(Iix,Nw,oSx)thencall AZx(Iix,aw)
endifif LIx(oSx)thencall ikx(Ow)
endifreturn trueendfunctionfunction LNx takes nothing returns booleanlocal integer rFx=(bv)return trueendfunctionfunction Lbx takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSxloop
set oSx=CAx(Iix,Nw,q)exitwhen(oSx==w)
call AZx((oSx),pU)endloopreturn trueendfunctionfunction LBx takes nothing returns booleanset Vw=Xdx("AILetOff_Init: set AILetOff.ACQUIRE_EVENT = Event.Create(UNIT.Attack.Events.ACQUIRE_EVENT_TYPE, EventPriority.AI, function AILetOff.Event_Acquire)",Ew,HI,function Lvx)set Ow=iXx()
call Dcx(Xdx("AILetOff_Init: call Event.Create(Spawn.DUMMY_EVENT_TYPE, EventPriority.AI, function AILetOff.Event_Spawn).AddToStatics()",Rw,HI,function Lex))
call Lxx(pU,Xdx("AILetOff_Init: call AILetOff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.AI, function AILetOff.Event_BuffGain))",bd,HI,function LRx))call Lxx(pU,Xdx("AILetOff_Init: call AILetOff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.AI, function AILetOff.Event_BuffLose))",jc,HI,function LAx))call Lxx(aw,Xdx("AILetOff_Init: call AILetOff.TARGET_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.AI, function AILetOff.Event_TargetBuffGain))",bd,HI,function LNx))call Lxx(aw,Xdx("AILetOff_Init: call AILetOff.TARGET_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.AI, function AILetOff.Event_TargetBuffLose))",jc,HI,function Lbx))return trueendfunctionfunction Lcx takes nothing returns booleancall l8x(function LBx,"AILetOff_Init")return trueendfunctionfunction LCx takes nothing returns booleanset mw=VXx(Mw)return trueendfunctionfunction Ldx takes nothing returns booleanset pw=VXx(Pw)return trueendfunctionfunction LDx takes nothing returns booleanset qw=VXx(Qw)return trueendfunctionfunction Lfx takes nothing returns booleanset sw=VXx(Sw)return trueendfunctionfunction LFx takes nothing returns booleanset tw=VXx(Tw)return trueendfunctionfunction Lgx takes nothing returns booleanset uw=VXx(Uw)return trueendfunctionfunction LGx takes nothing returns booleanset ww=VXx(Ww)return trueendfunctionfunction Lhx takes nothing returns booleanset yw=VXx(Yw)return trueendfunctionfunction LHx takes nothing returns booleanset zw=VXx(Zw)return trueendfunctionfunction Ljx takes nothing returns booleanset vW=VXx(eW)return trueendfunctionfunction LJx takes nothing returns booleanset xW=VXx(oW)return trueendfunctionfunction Lkx takes nothing returns booleanset rW=VXx(iW)return trueendfunctionfunction LKx takes nothing returns booleanset aW=VXx(nW)return trueendfunctionfunction Llx takes nothing returns booleanset VW=VXx(EW)return trueendfunctionfunction LLx takes nothing returns booleanset XW=VXx(OW)return trueendfunctionfunction Lmx takes nothing returns booleanset RW=VXx(rJ)return trueendfunctionfunction LMx takes nothing returns booleanset IW=VXx(VJ)return trueendfunctionfunction Lpx takes nothing returns booleanset AW=VXx(NW)return trueendfunctionfunction LPx takes nothing returns booleanset bW=VXx(BW)return trueendfunctionfunction Lqx takes nothing returns booleanset cW=VXx(CW)return trueendfunctionfunction LQx takes nothing returns booleanset dW=VXx(DW)return trueendfunctionfunction Lsx takes nothing returns booleanset fW=VXx(FW)return trueendfunctionfunction LSx takes nothing returns booleanset gW=VXx(GW)return trueendfunctionfunction Ltx takes nothing returns booleanset hW=VXx(HW)return trueendfunctionfunction LTx takes nothing returns booleanset jW=VXx(JW)return trueendfunctionfunction Lux takes nothing returns booleanset kW=VXx(KW)return trueendfunctionfunction LUx takes nothing returns booleanset lW=VXx(LW)return trueendfunctionfunction Lwx takes nothing returns booleanset mW=VXx(MW)return trueendfunctionfunction LWx takes nothing returns booleanset pW=VXx(PW)return trueendfunctionfunction Lyx takes nothing returns booleanset qW=VXx(QW)return trueendfunctionfunction LYx takes code c,string rSx returns nothing
call VNx(Pa,c,rSx)endfunctionfunction Lzx takes integer jjx,integer jJx returns integerreturn(jjx-jjx/ jJx*jJx)
endfunctionfunction LZx takes integer oLx returns stringif(tW==false)thenset tW=trueset TW[0]="{0}"set TW[1]="{1}"set TW[2]="{2}"set TW[3]="{3}"set TW[4]="{4}"set TW[5]="{5}"set TW[6]="{6}"set TW[7]="{7}"set TW[8]="{8}"set TW[9]="{9}"set TW[$A]="{10}"set TW[$B]="{11}"set TW[$C]="{12}"set TW[$D]="{13}"set TW[$E]="{14}"set TW[$F]="{15}"set TW[16]="{16}"set TW[17]="{17}"set TW[18]="{18}"set TW[19]="{19}"set TW[20]="{20}"set TW[21]="{21}"set TW[22]="{22}"set TW[23]="{23}"set TW[24]="{24}"set TW[25]="{25}"set TW[26]="{26}"set TW[27]="{27}"set TW[28]="{28}"set TW[29]="{29}"set TW[30]="{30}"set TW[31]="{31}"set TW[32]=" "set TW[33]="!"set TW[34]="\""set TW[35]="#"set TW[36]="$"set TW[37]="%"set TW[38]="&"set TW[39]="'"set TW[40]="("set TW[41]=")"set TW[42]="*"set TW[43]="+"set TW[44]=","set TW[45]="-"set TW[46]="."set TW[47]="/"set TW[48]="0"set TW[49]="1"set TW[50]="2"set TW[51]="3"set TW[52]="4"set TW[53]="5"set TW[54]="6"set TW[55]="7"set TW[56]="8"set TW[57]="9"set TW[58]=":"set TW[59]=";"set TW[60]="<"set TW[61]="="set TW[62]=">"set TW[63]="?"set TW[64]="@"set TW[65]="A"set TW[66]="B"set TW[67]="C"set TW[68]="D"set TW[69]="E"set TW[70]="F"set TW[71]="G"set TW[72]="H"set TW[73]="I"set TW[74]="J"set TW[75]="K"set TW[76]="L"set TW[77]="M"set TW[78]="N"set TW[79]="O"set TW[80]="P"set TW[81]="Q"set TW[82]="R"set TW[83]="S"set TW[84]="T"set TW[85]="U"set TW[86]="V"set TW[87]="W"set TW[88]="X"set TW[89]="Y"set TW[90]="Z"set TW[91]="["set TW[92]="\\"set TW[93]="]"set TW[94]="^"set TW[95]="_"set TW[96]="`"set TW[97]="a"set TW[98]="b"set TW[99]="c"set TW['d']="d"set TW['e']="e"set TW['f']="f"set TW['g']="g"set TW['h']="h"set TW['i']="i"set TW['j']="j"set TW['k']="k"set TW['l']="l"set TW['m']="m"set TW['n']="n"set TW['o']="o"set TW['p']="p"set TW['q']="q"set TW['r']="r"set TW['s']="s"set TW['t']="t"set TW['u']="u"set TW['v']="v"set TW['w']="w"set TW['x']="x"set TW['y']="y"set TW['z']="z"set TW['{']="{"set TW['|']="|"set TW['}']="}"set TW[$7E]="~"set TW[$7F]="{DEL}"set TW[$80]="€"set TW[$81]="{129}"set TW[$82]="‚"set TW[$83]="ƒ"
set TW[$84]="„"set TW[$85]="…"set TW[$86]="†"set TW[$87]="‡"set TW[$88]="ˆ"
set TW[$89]="‰"set TW[$8A]="Š"
set TW[$8B]="‹"set TW[$8C]="Œ"
set TW[$8D]="{141}"set TW[$8E]="Ž"
set TW[$8F]="{143}"set TW[$90]="{144}"set TW[$91]="‘"set TW[$92]="’"set TW[$93]="“"set TW[$94]="”"set TW[$95]="•"set TW[$96]="–"set TW[$97]="—"set TW[$98]="˜"
set TW[$99]="™"set TW[$9A]="š"
set TW[$9B]="›"set TW[$9C]="œ"
set TW[$9D]="{157}"set TW[$9E]="ž"
set TW[$9F]="Ÿ"
set TW[$A0]=" "
set TW[$A1]="¡"
set TW[$A2]="¢"
set TW[$A3]="£"
set TW[$A4]="¤"
set TW[$A5]="¥"
set TW[$A6]="¦"
set TW[$A7]="§"
set TW[$A8]="¨"
set TW[$A9]="©"
set TW[$AA]="ª"
set TW[$AB]="«"
set TW[$AC]="¬"
set TW[$AD]="{173}"set TW[$AE]="®"
set TW[$AF]="¯"
set TW[$B0]="°"
set TW[$B1]="±"
set TW[$B2]="²"
set TW[$B3]="³"
set TW[$B4]="´"
set TW[$B5]="µ"
set TW[$B6]="¶"
set TW[$B7]="·"
set TW[$B8]="¸"
set TW[$B9]="¹"
set TW[$BA]="º"
set TW[$BB]="»"
set TW[$BC]="¼"
set TW[$BD]="½"
set TW[$BE]="¾"
set TW[$BF]="¿"
set TW[$C0]="À"
set TW[$C1]="Á"
set TW[$C2]="Â"
set TW[$C3]="Ã"
set TW[$C4]="Ä"
set TW[$C5]="Å"
set TW[$C6]="Æ"
set TW[$C7]="Ç"
set TW[$C8]="È"
set TW[$C9]="É"
set TW[$CA]="Ê"
set TW[$CB]="Ë"
set TW[$CC]="Ì"
set TW[$CD]="Í"
set TW[$CE]="Î"
set TW[$CF]="Ï"
set TW[$D0]="Ð"
set TW[$D1]="Ñ"
set TW[$D2]="Ò"
set TW[$D3]="Ó"
set TW[$D4]="Ô"
set TW[$D5]="Õ"
set TW[$D6]="Ö"
set TW[$D7]="×"
set TW[$D8]="Ø"
set TW[$D9]="Ù"
set TW[$DA]="Ú"
set TW[$DB]="Û"
set TW[$DC]="Ü"
set TW[$DD]="Ý"
set TW[$DE]="Þ"
set TW[$DF]="ß"
set TW[$E0]="à"
set TW[$E1]="á"
set TW[$E2]="â"
set TW[$E3]="ã"
set TW[$E4]="ä"
set TW[$E5]="å"
set TW[$E6]="æ"
set TW[$E7]="ç"
set TW[$E8]="è"
set TW[$E9]="é"
set TW[$EA]="ê"
set TW[$EB]="ë"
set TW[$EC]="ì"
set TW[$ED]="í"
set TW[$EE]="î"
set TW[$EF]="ï"
set TW[$F0]="ð"
set TW[$F1]="ñ"
set TW[$F2]="ò"
set TW[$F3]="ó"
set TW[$F4]="ô"
set TW[$F5]="õ"
set TW[$F6]="ö"
set TW[$F7]="÷"
set TW[$F8]="ø"
set TW[$F9]="ù"
set TW[$FA]="ú"
set TW[$FB]="û"
set TW[$FC]="ü"
set TW[$FD]="ý"
set TW[$FE]="þ"
set TW[$FF]="ÿ"
endifreturn TW[oLx]endfunctionfunction L_x takes integer oqx returns stringlocal integer rox=-1
local string s=""local integer L0xloop
set L0x=Lzx(oqx,256)
set s=(LZx((L0x)))+s
set rox=rox+1set oqx=(oqx-L0x)/ 256exitwhen(oqx==0)
endloopreturn s
endfunctionfunction L1x takes integer id,boolean L2x returns nothingif(LoadBoolean(o[((V[(E[((X))])]))],(((SW))),(((id)))))thencall o_x("InitAbility","call DebugEx(\"spell \" + GetObjectName(id) + \"(\" + Integer.ToAscii(id) + \") already preloaded\")","spell "+GetObjectName(id)+"("+L_x(id)+") already preloaded")returnendifcall SaveBoolean(o[((V[(E[((X))])]))],(((SW))),(((id))),(((true))))if(id==0)thenreturnendifcall GetObjectName((id))
if not L2x thenreturnendifif(uW==null)then
set uW=aGx(Player($F),'QPrL',0,0,0)endifif UnitAddAbility(uW,id)then
call UnitRemoveAbility(uW,id)endifendfunctionfunction L3x takes nothing returns booleancall L1x('aLoc',false)return trueendfunctionfunction L4x takes nothing returns booleancall LYx(function L3x,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Misc.page\\DummyUnit.struct\\obj_locustSpell_wc3spell.j")return trueendfunctionfunction L5x takes nothing returns booleanset UW=VXx(wW)return trueendfunctionfunction L6x takes nothing returns booleanset WW=VXx(yW)return trueendfunctionfunction L7x takes nothing returns booleanset YW=VXx(zW)return trueendfunctionfunction L8x takes integer oSx,integer otx returns nothingcall SaveInteger(o[(((V[(E[((yp[(oSx)]))])])))],(((((Yp[((oSx))]))))),((((otx)))),(0))endfunctionfunction L9x takes integer oSx returns booleanlocal integer oLx=(xy[(oSx)])set xy[oy[ry]]=oLxset oy[oLx-1]=oy[ry]
set xy[oSx]=0set ry=ry-1return(ry==F)endfunctionfunction mvx takes integer oSx,integer rLx,integer Iix returns nothingcall HRx(rLx,ZW)
call L8x(Iix,ey)
if L9x(oSx)thencall ikx(iy)
endifendfunctionfunction mex takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Wp[(rFx)])local integer oSx=rLxcall mvx(oSx,rLx,ay[oSx])return trueendfunctionfunction mxx takes nothing returns nothingset ZW=Xdx("FolderDummyUnit_StructFollowDummyUnit_Init: set FolderDummyUnit_StructFollowDummyUnit.PARENT_DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderDummyUnit_StructFollowDummyUnit.Event_ParentDestroy)",aP,bI,function mex)set iy=iXx()
endfunctionfunction mox takes integer oSx returns booleanlocal integer oLx=(Xy[(oSx)])set Xy[Oy[Ry]]=oLxset Oy[oLx-1]=Oy[Ry]
set Xy[oSx]=0set Ry=Ry-1return(Ry==F)endfunctionfunction mrx takes integer oSx,integer rLx,integer Iix returns nothingcall HRx(rLx,ny)
call rVx(Iix,Ey)
if mox(oSx)thencall ikx(Iy)
endifendfunctionfunction mix takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Wp[(rFx)])local integer oSx=rLxcall mrx(oSx,rLx,Ay[oSx])return trueendfunctionfunction mnx takes nothing returns nothingset ny=Xdx("FolderDummyUnit_StructFollowUnit_Init: set FolderDummyUnit_StructFollowUnit.PARENT_DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderDummyUnit_StructFollowUnit.Event_ParentDestroy)",aP,bI,function mix)set Iy=iXx()
endfunctionfunction mVx takes integer oSx returns booleanlocal integer oLx=(By[(oSx)])set By[cy[Cy]]=oLxset cy[oLx-1]=cy[Cy]
set By[oSx]=0set Cy=Cy-1return(Cy==F)endfunctionfunction mEx takes integer oSx returns nothingcall HRx((oSx),by)if mVx(oSx)thencall ikx(Dy)
endifendfunctionfunction mXx takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=(Wp[(rFx)])call mEx(oSx)return trueendfunctionfunction mOx takes nothing returns nothingset by=Xdx("FolderDummyUnit_StructRotate_Init: set FolderDummyUnit_StructRotate.DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderDummyUnit_StructRotate.Event_Destroy)",aP,bI,function mXx)set Dy=iXx()
endfunctionfunction mRx takes integer oSx returns integerset Hy[oSx]=true
set jy[oSx]=falseset yp[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set rP[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(UW)
return oSxendfunctionfunction mIx takes nothing returns integerlocal integer oSxif(Fy==8190)then
call o_x("DummyUnit_Allocation_allocCustom","call DebugEx(DummyUnit.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",wW+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(gy[(w)]==w)thenset Gy=Gy+1set oSx=Gyelse
set oSx=gy[(w)]set gy[(w)]=gy[gy[(w)]]endifset gy[oSx]=Zset hy[oSx]=1call mRx(oSx)return oSxendfunctionfunction mAx takes integer oSx returns nothingset Yp[(oSx)]=(My+oSx)endfunctionfunction mNx takes integer oSx,real oux returns nothingset py[oSx]=ouxcall SetUnitFacing(vJ[(oSx)],oux*ky)
endfunctionfunction mbx takes integer oSx,integer bIx returns nothingset Py[oSx]=bIxcall SetUnitOwner(vJ[(oSx)],vx[bIx],true)endfunctionfunction mBx takes integer oSx,real x,real y,real z returns nothingset Au[oSx]=zcall SetUnitFlyHeight(vJ[(oSx)],z-X_x(x,y),.0)endfunctionfunction mcx takes integer oSx,real x,real y,real z returns nothingcall UnitAddAbility(vJ[(((oSx)))],('aFly'))call UnitRemoveAbility(vJ[(((oSx)))],('aFly'))call mBx(oSx,x,y,z)endfunctionfunction mCx takes integer oSx,real oux returns nothingset qy[oSx]=ouxcall SetUnitScale(vJ[(oSx)],oux,oux,oux)
endfunctionfunction mdx takes integer oSx,real izx,real iZx,real i_x,real i0x returns nothingset Qy[(oSx)]=((izx)*1.)
set sy[(oSx)]=((iZx)*1.)
set Sy[(oSx)]=((i_x)*1.)
set ty[(oSx)]=((i0x)*1.)
call SetUnitVertexColor(vJ[(oSx)],(R2I(((izx)*1.))),(R2I(((iZx)*1.))),(R2I(((i_x)*1.))),(R2I(((i0x)*1.))))endfunctionfunction mDx takes integer mfx,real x,real y,real z,real bex returns integer
local integer oSx=mIx()local unit oqx=aGx(vx[Jy],mfx,.0,.0,bex*ky)set vJ[oSx]=oqxset Ky[oSx]=mfxcall SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oqx))))),((((Ly)))),((((oSx)))))
call mAx(oSx)set oqx=null
call mNx(oSx,bex)call mbx(oSx,Jy)
call DQx(oSx,x)call DSx(oSx,y)call mcx(oSx,x,y,z)call mCx((oSx),1.)call mdx((oSx),255.,255.,255.,255.)return oSxendfunctionfunction mFx takes nothing returns nothingset wp=(E3x())set aP=(E3x())call mxx()call mnx()set Ny=iXx()
call mOx()set fy=iXx()
set eJ=mDx('qWoC',.0,.0,.0,.0)endfunctionfunction mgx takes nothing returns booleancall EOx()call mFx()return trueendfunctionfunction mGx takes nothing returns booleancall GDx(function mgx,"Misc_Init")return trueendfunctionfunction mhx takes nothing returns booleanset Ty=VXx(uy)return trueendfunctionfunction mHx takes nothing returns booleanset Uy=VXx(wy)return trueendfunctionfunction mjx takes nothing returns booleanset Wy=VXx(yy)return trueendfunctionfunction mJx takes nothing returns booleanset Yy=VXx(zy)return trueendfunctionfunction mkx takes nothing returns booleanset Zy=VXx(vY)return trueendfunctionfunction mKx takes nothing returns booleanset eY=VXx(xY)return trueendfunctionfunction mlx takes nothing returns booleanset oY=VXx(rY)return trueendfunctionfunction mLx takes nothing returns booleanset iY=VXx(aY)return trueendfunctionfunction mmx takes nothing returns booleanset nY=VXx(VY)return trueendfunctionfunction mMx takes nothing returns booleanset EY=VXx(XY)return trueendfunctionfunction mpx takes nothing returns booleanset OY=VXx(RY)return trueendfunctionfunction mPx takes nothing returns booleanset IY=VXx(AY)return trueendfunctionfunction mqx takes nothing returns booleanset NY=VXx(bY)return trueendfunctionfunction mQx takes nothing returns booleanset BY=VXx(cY)return trueendfunctionfunction msx takes nothing returns booleanset CY=VXx(DY)return trueendfunctionfunction mSx takes nothing returns booleanset fY=VXx(FY)return trueendfunctionfunction mtx takes nothing returns booleanset gY=VXx(GY)return trueendfunctionfunction mTx takes nothing returns booleanset hY=VXx(HY)return trueendfunctionfunction mux takes nothing returns booleanset jY=VXx(JY)return trueendfunctionfunction mUx takes nothing returns booleanset kY=VXx(KY)return trueendfunctionfunction mwx takes nothing returns booleanset lY=VXx(LY)return trueendfunctionfunction mWx takes nothing returns booleanset mY=VXx(MY)return trueendfunctionfunction myx takes nothing returns booleanset pY=VXx(PY)return trueendfunctionfunction mYx takes nothing returns booleanset qY=VXx(QY)return trueendfunctionfunction mzx takes nothing returns booleanset sY=VXx(SY)return trueendfunctionfunction mZx takes nothing returns booleanset tY=VXx(TY)return trueendfunctionfunction m_x takes nothing returns booleanset uY=VXx(UY)return trueendfunctionfunction m0x takes nothing returns booleanset wY=VXx(WY)return trueendfunctionfunction m1x takes integer oSx,integer XYx returns nothingif not((LoadInteger(o[((D[((xz[oSx]))]))],((((oz[((oSx))])))),(oTx((((oA[(XYx)]))),(((XYx)))))))!=0)then
call o_x("FolderMissile_StructEvent_Remove","call DebugEx(\"subject \"+I2S(Missile(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((oz[((oSx))]))+" has not "+(jA[(XYx)]))returnendifcall rrx(xz[oSx],(oz[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction m2x takes integer oSx,integer o9x,integer otx returns integerreturn(LoadInteger(o[((V[(E[(oSx)])]))],((o9x)),((otx))))endfunctionfunction m3x takes integer oSx,integer o9x,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[(oSx)])]))],((o9x)),((otx)),((oux)))endfunctionfunction m4x takes integer oSx returns integerlocal integer el=(rz[(oSx)])
if(el==w)thenreturn w
endifset rz[oSx]=m2x(X,el,iz+oSx)
call m3x(X,el,iz+oSx,w)if((rz[(oSx)])==w)thenset az[oSx]=welse
call m3x(X,(rz[(oSx)]),Vz+oSx,w)
endifreturn elendfunctionfunction m5x takes integer oSx returns nothingloop
exitwhen(m4x(oSx)==w)endloopendfunctionfunction m6x takes integer oSx returns nothingset Rz[oSx]=falsecall rHx(FE)
endfunctionfunction m7x takes integer oSx returns nothingif(Xz[oSx]>0)thenreturnendifif(Oz[oSx]!=Z)thencall o_x("Queue_Allocation_deallocCustom_confirm","call DebugEx(Queue.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",HE+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Oz[oSx]=Oz[(w)]set Oz[(w)]=oSxcall m6x(oSx)endfunctionfunction m8x takes integer oSx returns nothingset Xz[oSx]=Xz[oSx]-1call m7x(oSx)endfunctionfunction m9x takes integer oSx returns nothingcall m5x(oSx)call m8x((oSx))endfunctionfunction Mvx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(ez[(rFx)])local integer oSx=rLxcall m1x(rLx,vz)
call m5x(Ez[(oSx)])call m9x(Ez[oSx])return trueendfunctionfunction Mex takes nothing returns nothingset zY=(E3x())set ZY=(E3x())set vz=Xdx("FolderMissile_StructCheckpoints_Init: set FolderMissile_StructCheckpoints.DESTROY_EVENT = Event.Create(Missile.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderMissile_StructCheckpoints.Event_Destroy)",yY,bI,function Mvx)endfunctionfunction Mxx takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((yp[(oSx)]))])]))],((((Yp[((oSx))])))),(((otx)))))endfunctionfunction Mox takes integer oSx,integer XYx returns nothingif(xz[oSx]==w)thencall o_x("FolderMissile_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oSx)+";"+(jA[(XYx)]))set xz[oSx]=Xendifcall rux(xz[oSx],(oz[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction Mrx takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((yp[(oSx)]))])]))],((((Yp[((oSx))])))),(((otx))),(((oux))))endfunctionfunction Mix takes integer oSx,integer XYx returns nothingif(rP[oSx]==w)thencall o_x("FolderDummyUnit_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oSx)+";"+(jA[(XYx)]))set rP[oSx]=Xendifcall rux(rP[oSx],(Yp[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction Max takes integer oSx,integer oux returns nothinglocal integer aCx=(bz[(oSx)])if(aCx!=w)thencall L8x(aCx,Nz)
call HRx(aCx,Iz)
call m1x((oSx),Bz)endifset bz[oSx]=ouxif(oux!=w)thencall Mox((oSx),Bz)call Mrx(oux,Nz,oSx)
call Mix(oux,Iz)
endifendfunctionfunction Mnx takes nothing returns booleanlocal integer rFx=(bv)local integer oux=(Wp[(rFx)])local integer oSx=Mxx(oux,Nz)call Max(oSx,w)return trueendfunctionfunction MVx takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((rP[oSx]))])]))],((((Yp[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))endfunctionfunction MEx takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((rP[oSx]))])]))],((((Yp[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))endfunctionfunction MXx takes integer oSx returns integerset fz[oSx]=true
set Fz[oSx]=falsecall rEx(xW)
return oSxendfunctionfunction MOx takes nothing returns integerlocal integer oSxif(cz==8190)then
call o_x("FolderDummyUnit_StructDestruction_Allocation_allocCustom","call DebugEx(FolderDummyUnit_StructDestruction.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",oW+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(Cz[(w)]==w)thenset dz=dz+1set oSx=dzelse
set oSx=Cz[(w)]set Cz[(w)]=Cz[Cz[(w)]]endifset Cz[oSx]=Zset Dz[oSx]=1call MXx(oSx)return oSxendfunctionfunction MRx takes integer oSx returns nothingset fz[oSx]=falsecall rHx(xW)
endfunctionfunction MIx takes integer oSx returns nothingif(Dz[oSx]>0)thenreturnendifif(Cz[oSx]!=Z)thencall o_x("FolderDummyUnit_StructDestruction_Allocation_deallocCustom_confirm","call DebugEx(FolderDummyUnit_StructDestruction.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",oW+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Cz[oSx]=Cz[(w)]set Cz[(w)]=oSxcall MRx(oSx)endfunctionfunction MAx takes integer oSx returns nothingset Dz[oSx]=Dz[oSx]-1call MIx(oSx)endfunctionfunction MNx takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((yp[oSx]))])])],((((Yp[((oSx))])))))endfunctionfunction Mbx takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((rP[oSx]))])])],((((Yp[((oSx))])))))endfunctionfunction MBx takes integer oSx returns nothingset Hy[oSx]=falsecall MNx((oSx))call Mbx(((oSx)))call rHx(UW)
endfunctionfunction Mcx takes integer oSx returns nothingif(hy[oSx]>0)thenreturnendifif(gy[oSx]!=Z)thencall o_x("DummyUnit_Allocation_deallocCustom_confirm","call DebugEx(DummyUnit.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",wW+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset gy[oSx]=gy[(w)]set gy[(w)]=oSxcall MBx(oSx)endfunctionfunction MCx takes integer oSx returns nothingset hy[oSx]=hy[oSx]-1call Mcx(oSx)endfunctionfunction Mdx takes unit u returns nothingif(u==null)thencall o_x("Basic_onRemoveUnit","call DebugEx(\"Basic.onRemoveUnit: invalid unit\")","Basic.onRemoveUnit: invalid unit")returnendifset nr=nr-1endfunctionfunction MDx takes unit a0 returns nothingcall Mdx(a0)
call RemoveUnit(a0)endfunctionfunction Mfx takes integer oSx returns nothinglocal integer rFx=rRx((Yp[(oSx)]))local integer oMxlocal integer rbxlocal integer rMxlocal unit oqxset Wp[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=MVx(oSx,aP,rbx)loop
exitwhen(rMx<q)call rfx(MEx(oSx,aP,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))set oqx=vJ[oSx]call MCx((oSx))call MDx(oqx)set oqx=null
endfunctionfunction MFx takes nothing returns nothinglocal integer iCx=iGx()local integer oSx=(ge[(iCx)])local integer rLx=gz[oSx]call MAx((oSx))call iKx(iCx)call Mfx(rLx)endfunctionfunction Mgx takes integer oSx returns nothinglocal integer rLx=oSxlocal integer iCxset oSx=MOx()set iCx=iXx()set gz[oSx]=rLxset ge[(iCx)]=(oSx)call iDx(iCx,5.,false,function MFx)endfunctionfunction MGx takes integer oSx returns nothinglocal integer rFx=rRx((Yp[(oSx)]))local integer oMxlocal integer rbxlocal integer rMxset Wp[(rFx)]=(oSx)if(GetUnitAbilityLevel(vJ[oSx],'aLoc')==0)thencall o_x("DummyUnit_Destroy","call DebugEx(GetUnitName(this.self) + \" had no locust\")",GetUnitName(vJ[oSx])+" had no locust")endifset oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=MVx(oSx,wp,rbx)loop
exitwhen(rMx<q)call rfx(MEx(oSx,wp,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call SetUnitAnimation(vJ[((oSx))],("death"))
call QueueUnitAnimation(vJ[((oSx))],(null))call Mgx(oSx)endfunctionfunction Mhx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(ez[(rFx)])local integer oSx=rLxlocal integer oux=(bz[(oSx)])call Max(oSx,w)call MGx(oux)return trueendfunctionfunction MHx takes nothing returns nothingset Iz=Xdx("FolderMissile_StructDummyUnit_Init: set FolderMissile_StructDummyUnit.DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderMissile_StructDummyUnit.Event_Destroy)",aP,bI,function Mnx)set Bz=Xdx("FolderMissile_StructDummyUnit_Init: set FolderMissile_StructDummyUnit.PARENT_DESTROY_EVENT = Event.Create(Missile.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderMissile_StructDummyUnit.Event_ParentDestroy)",yY,bI,function Mhx)
endfunctionfunction Mjx takes integer oSx returns booleanif(((hz[((oSx))])>0)==false)then
return false
endifset hz[Hz[jz]]=hz[oSx]set Hz[hz[oSx]-1]=Hz[jz]
set hz[oSx]=0set jz=jz-1return(jz==F)endfunctionfunction MJx takes integer oSx returns nothingcall m1x((oSx),Gz)if Mjx(oSx)thencall ikx(Jz)
endifendfunctionfunction Mkx takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=(ez[(rFx)])call MJx(oSx)return trueendfunctionfunction MKx takes nothing returns nothingset Gz=Xdx("FolderMissile_StructGoToSpot_Init: set FolderMissile_StructGoToSpot.STOP_EVENT = Event.Create(Missile.STOP_EVENT_TYPE, EventPriority.HEADER, function FolderMissile_StructGoToSpot.Event_Stop)",YY,bI,function Mkx)set Jz=iXx()
endfunctionfunction Mlx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(ez[(rFx)])if(Kz[(rLx)]!=w)then
return trueendifset Kz[(rLx)]=(lz[(rFx)])return trueendfunctionfunction MLx takes integer oSx,integer Iix returns nothingif rnx(Iix,Mz,oSx)thencall RPx(Iix,pz)
call RPx(Iix,Pz)
call Khx(Iix)endifendfunctionfunction Mmx takes integer oSx returns booleanif(((qz[((oSx))])>0)==false)then
return false
endifset qz[Qz[sz]]=qz[oSx]set Qz[qz[oSx]-1]=Qz[sz]
set qz[oSx]=0set sz=sz-1return(sz==F)endfunctionfunction MMx takes integer oSx,integer Iix returns nothingif(Iix!=w)thencall MLx(oSx,Iix)endifcall m1x((oSx),kz)call m1x((oSx),Lz)if Mmx(oSx)thencall ikx(Sz)
endifendfunctionfunction Mpx takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=(ez[(rFx)])call MMx(oSx,tz[oSx])return trueendfunctionfunction MPx takes integer Iix,integer Mqx returns nothinglocal real dVx=Dsx(Iix)local real dEx=Dtx(Iix)local real MQx=OMx(Iix,dVx,dEx)+K2x(Iix,true)local integer oMx=CIx(Iix,Mz)local integer oSxloop
set oSx=CAx(Iix,Mz,oMx)call MLx(oSx,Iix)set tz[oSx]=wset Tz[oSx]=dVx+uz[oSx]set Uz[oSx]=dEx+wz[oSx]set Wz[oSx]=MQx+yz[oSx]if(Yz[oSx]!=w)thenset ez[(Mqx)]=(oSx)call XGx(Yz[oSx],Mqx)endifset oMx=oMx-1exitwhen(oMx<q)endloopendfunctionfunction Msx takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])call MPx(Iix,rFx)return trueendfunctionfunction MSx takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])call MPx(Iix,rFx)return trueendfunctionfunction Mtx takes nothing returns nothingset kz=Xdx("FolderMissile_StructGoToUnit_Init: set FolderMissile_StructGoToUnit.CHECKPOINT_ADD_EVENT = Event.Create(MISSILE.Checkpoints.ADD_EVENT_TYPE, EventPriority.HEADER, function FolderMissile_StructGoToUnit.Event_CheckpointAdd)",zY,bI,function Mlx)set Lz=Xdx("FolderMissile_StructGoToUnit_Init: set FolderMissile_StructGoToUnit.STOP_EVENT = Event.Create(Missile.STOP_EVENT_TYPE, EventPriority.HEADER, function FolderMissile_StructGoToUnit.Event_Stop)",YY,bI,function Mpx)set pz=Xdx("FolderMissile_StructGoToUnit_Init: set FolderMissile_StructGoToUnit.TARGET_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderMissile_StructGoToUnit.Event_TargetDeath)",VP,bI,function Msx)set Pz=Xdx("FolderMissile_StructGoToUnit_Init: set FolderMissile_StructGoToUnit.TARGET_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderMissile_StructGoToUnit.Event_TargetDestroy)",EP,bI,function MSx)set Sz=iXx()
endfunctionfunction MTx takes nothing returns booleanset yY=(E3x())set YY=(E3x())call Mex()call MHx()call MKx()call Mtx()set zz=O5x()
return trueendfunctionfunction Mux takes nothing returns booleancall Hix(function MTx,"Missile_Init")return trueendfunctionfunction MUx takes nothing returns booleanset Zz=VXx(vZ)return trueendfunctionfunction Mwx takes nothing returns booleanset eZ=VXx(xZ)return trueendfunctionfunction MWx takes nothing returns booleanset oZ=VXx(rZ)return trueendfunctionfunction Myx takes nothing returns booleanset iZ=VXx(aZ)return trueendfunctionfunction MYx takes nothing returns booleanset nZ=VXx(VZ)return trueendfunctionfunction Mzx takes nothing returns booleanset EZ=VXx(XZ)return trueendfunctionfunction MZx takes nothing returns booleanset OZ=VXx(RZ)return trueendfunctionfunction M_x takes nothing returns booleanset IZ=VXx(AZ)return trueendfunctionfunction M0x takes nothing returns booleanset NZ=VXx(bZ)return trueendfunctionfunction M1x takes integer oSx returns integerset Rz[oSx]=true
set DZ[oSx]=falsecall rEx(FE)
return oSxendfunctionfunction M2x takes nothing returns integerlocal integer oSxif(cZ==8190)then
call o_x("Queue_Allocation_allocCustom","call DebugEx(Queue.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",HE+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(Oz[(w)]==w)thenset CZ=CZ+1set oSx=CZelse
set oSx=Oz[(w)]set Oz[(w)]=Oz[Oz[(w)]]endifset Oz[oSx]=Zset Xz[oSx]=1call M1x(oSx)return oSxendfunctionfunction M3x takes nothing returns integerlocal integer oSx=M2x()set rz[oSx]=wset az[oSx]=wreturn oSxendfunctionfunction M4x takes integer oDx returns integerlocal integer oSx=oDxset BZ[oSx]=M3x()set xp[oSx]=wreturn oSxendfunctionfunction M5x takes nothing returns nothinglocal integer oMx=Hl
local integer M6xloop
exitwhen(oMx<0)set M6x=jl[oMx]call M4x(M6x)set oMx=oMx-1endloopendfunctionfunction M7x takes integer oDx returns nothingif iOx(oDx)thenset GZ=GZ-1if(GZ==0)thencall SetCameraBounds(eE,iE,xE,aE,oE,nE,rE,VE)endifendifendfunctionfunction M8x takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((xA[(oSx)]))])]))],((((aA[((oSx))])))),(((otx))))))endfunctionfunction M9x takes integer oSx,integer rNx,integer rbx returns integerreturn M8x((oSx),(1+8192*(((rNx)-1)*Iv+((rbx)-1))))endfunctionfunction pvx takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((xA[(oSx)]))])]))],((((aA[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction pex takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn pvx((oSx),(1+8192*(((rNx)-1)*Iv+((rbx)-1))),oLx)endfunctionfunction pxx takes integer oSx returns nothinglocal integer oMx=Xv
local integer rMxlocal integer rFx=rRx((aA[(oSx)]))local integer rbxset jZ[(rFx)]=(oSx)loop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=M9x(oSx,nI,rbx)loop
exitwhen(rMx<q)call rfx(pex(oSx,nI,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction pox takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((xA[oSx]))])])],((((aA[((oSx))])))))endfunctionfunction prx takes integer oSx returns nothingset vA[oSx]=falsecall pox((oSx))call rHx(iI)
endfunctionfunction pix takes integer oSx returns nothingif(ZI[oSx]>0)thenreturnendifif(YI[oSx]!=Z)thencall o_x("Event_Allocation_deallocCustom_confirm","call DebugEx(Event.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",aI+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset YI[oSx]=YI[(w)]set YI[(w)]=oSxcall prx(oSx)endfunctionfunction pax takes integer oSx returns nothingset ZI[oSx]=ZI[oSx]-1call pix(oSx)endfunctionfunction pnx takes integer oSx returns nothingcall pxx(oSx)call pax((oSx))endfunctionfunction pVx takes integer oSx,string oux returns nothingset pZ[oSx]=ouxif(oux==null)thencall MultiboardSetItemStyle(PZ[oSx],true,false)else
call MultiboardSetItemIcon(PZ[oSx],oux)call MultiboardSetItemStyle(PZ[oSx],true,true)endifendfunctionfunction pEx takes integer oSx,real oux returns nothingset qZ[oSx]=ouxcall MultiboardSetItemWidth(PZ[oSx],oux)
endfunctionfunction pXx takes integer oSx returns nothingcall pVx(oSx,null)call pEx(oSx,.0)
endfunctionfunction pOx takes integer oSx,integer rvx returns nothinglocal integer pRx=(mZ[(oSx)])local integer pIx=(MZ[(oSx)])local multiboard oqx=op[oSx]
local integer pAxlocal integer pNxset mZ[oSx]=rvxif(rvx>pRx)thenset pAx=pRx+1call MultiboardSetColumnCount(oqx,rvx+1)
loop
exitwhen(pAx>rvx)set pNx=pIxloop
exitwhen(pNx<0)call pXx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((op[((oSx))]))))),((((sZ+((pNx))*50+((pAx)))))))))set pNx=pNx-1endloopset pAx=pAx+1endloopelseif(rvx<pRx)thenset pAx=pRxloop
exitwhen(pAx<0)set pNx=pIxloop
exitwhen(pNx<0)call pXx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((op[((oSx))]))))),((((sZ+((pNx))*50+((pAx)))))))))set pNx=pNx-1endloopset pAx=pAx-1endloopcall MultiboardSetColumnCount(oqx,rvx+1)
endifset oqx=null
endfunctionfunction pbx takes integer oSx,integer rvx returns nothinglocal integer pRx=(mZ[(oSx)])local integer pNx=(MZ[(oSx)])local multiboard oqx=op[oSx]
local integer pAxlocal integer iset MZ[oSx]=rvxif(rvx>pNx)thenset pNx=pNx+1set i=pNxloop
exitwhen(i>rvx)call MultiboardSetRowCount(oqx,i+1)set i=i+1endlooploop
exitwhen(pNx>rvx)set pAx=pRxloop
exitwhen(pAx<0)call pXx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((op[((oSx))]))))),((((sZ+((pNx))*50+((pAx)))))))))set pAx=pAx-1endloopset pNx=pNx+1endloopelseif(rvx<pNx)thenset pNx=pNx-1loop
exitwhen(pNx<rvx)call MultiboardSetRowCount(oqx,pNx+1)set pNx=pNx-1endloopendifset oqx=null
endfunctionfunction pBx takes integer oSx,integer pNx,integer pAx returns nothingif(pAx>mZ[oSx])thencall pOx(oSx,pAx)endifif(pNx>MZ[oSx])thencall pbx(oSx,pNx)endifendfunctionfunction pcx takes integer oSx,string oux returns nothingset SZ[oSx]=ouxcall MultiboardSetItemValue(PZ[oSx],oux)
endfunctionfunction pCx takes integer oSx,integer pNx,integer pAx,string oux returns nothingcall pBx(oSx,pNx,pAx)call pcx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((op[(oSx)]))))),((((sZ+(pNx)*50+(pAx))))))),oux)
endfunctionfunction pdx takes integer oSx returns nothinglocal integer oMx=yZ[oSx]local boolean pDxif(oMx==F)thenreturnendifset yZ[oSx]=Fset pDx=(oMx==YZ)set YZ=YZ-1loop
exitwhen(oMx>YZ)
set zZ[oMx]=zZ[oMx+1]set yZ[zZ[oMx+1]]=oMxset oMx=oMx+1endloopif pDx thenif(YZ>F)then
call StopMusic(false)call PlayMusic(ZZ[zZ[YZ]])else
call StopMusic(true)
endifendifendfunctionfunction pfx takes integer oSx,integer oLx returns nothinglocal integer pNxif(oLx==F)thenreturnendifset pNx=LZ[oLx]if iOx(hZ[oSx])thencall pCx(tZ,pNx,TZ,uZ[oLx])call pCx(tZ,pNx,UZ,wZ[oLx])endifif(pNx==WZ)thencall pdx(v0)
endifendfunctionfunction pFx takes integer oSx returns nothinglocal integer bIx=hZ[oSx]if not HZ[oSx]thenreturnendifset HZ[oSx]=falsecall pnx(JZ[oSx])call pnx(kZ[oSx])call pnx(KZ[oSx])call pnx(lZ[oSx])call pfx(oSx,e0[oSx])endfunctionfunction pgx takes integer bIx returns nothinglocal integer oSx=bIxcall pFx(oSx)endfunctionfunction pGx takes integer oSx,integer oLx returns nothinglocal integer pNxif(oLx==F)thenreturnendifset pNx=E0[oLx]if iOx(x0[oSx])thencall pCx(X0,pNx,O0,R0[oLx])call pCx(X0,pNx,I0,A0[oLx])endifendfunctionfunction phx takes integer oSx returns nothinglocal integer bIx=x0[oSx]if not o0[oSx]thenreturnendifset o0[oSx]=falsecall pnx(r0[oSx])call pnx(i0[oSx])call pnx(n0[oSx])call pnx(V0[oSx])call pGx(oSx,N0[oSx])endfunctionfunction pHx takes integer bIx returns nothinglocal integer oSx=bIxcall phx(oSx)endfunctionfunction pjx takes integer oSx,integer XYx returns nothingif not((LoadInteger(o[((D[((B0[oSx]))]))],((((cb[((oSx))])))),(oTx((((oA[(XYx)]))),(((XYx)))))))!=0)then
call o_x("FolderUser_StructEvent_Remove","call DebugEx(\"subject \"+I2S(User(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((cb[((oSx))]))+" has not "+(jA[(XYx)]))
returnendifcall rrx(B0[oSx],(cb[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction pJx takes integer oDx returns integerlocal integer oSx=oDxreturn xp[oSx]endfunctionfunction pkx takes integer oSx,integer el returns integerreturn m2x(X,el,Vz+oSx)endfunctionfunction pKx takes integer oSx,integer el returns integerreturn m2x(X,el,iz+oSx)endfunctionfunction plx takes integer oSx,integer el returns booleanreturn((rz[(oSx)])==el)or((pkx(oSx,el)!=w)or(pKx(oSx,el)!=w))endfunctionfunction pLx takes integer oSx,integer el returns integerlocal integer oMxif(plx(oSx,el)==false)thenreturn F
endifset oMx=0loop
set el=pkx(oSx,el)exitwhen(el==w)set oMx=oMx+1endloopreturn oMxendfunctionfunction pmx takes integer oSx returns integerlocal integer oMx=Flocal integer el=(rz[(oSx)])
loop
exitwhen(el==w)set el=pKx(oSx,el)set oMx=oMx+1endloopreturn oMxendfunctionfunction pMx takes nothing returns booleanlocal integer oDx=fhx()local integer rLx=pJx(oDx)local integer oSx=oDxif(b0[((oDx))])thencall MultiboardSetTitleText(op[rLx],iSx("<<<","ffffcc00")+" "+(I2S((pLx(BZ[oSx],rLx)+1)))+"/"+(I2S((pmx(BZ[oSx])+1)))+" - "+iSx((d0[(rLx)]),"ff00ff00")+" "+iSx(">>>","ffffcc00"))return trueendifreturn false
endfunctionfunction ppx takes string oqx,integer nZx returns string
local string o7x=""loop
exitwhen(nZx<1)set o7x=o7x+oqxset nZx=nZx-1endloopreturn o7xendfunctionfunction pPx takes string oqx,integer pqx returns string
local integer pQx=((StringLength(((oqx))))-1)return r5x(oqx,pQx-pqx+1,pQx)endfunctionfunction psx takes real oqx,integer pSx returns stringlocal integer oMxlocal integer ptxlocal string o7x
if(oqx==.0)thenreturn("0."+ppx("0",pSx))endifset oMx=pSxset ptx=(R2I(((oqx)*1.)))loop
exitwhen(oMx<1)set oqx=oqx*$Aset oMx=oMx-1endloopset o7x=(I2S(((R2I(((oqx)*1.))))))set o7x=((I2S((ptx)))+"."+pPx(o7x,pSx))return o7xendfunctionfunction pTx takes integer oSx returns nothingif pMx()then
returnendifcall MultiboardSetTitleText(op[(oSx)],iSx("["+psx((TimerGetElapsed(l)),0)+"]
","ff00bfff")+"\t"+(d0[(oSx)]))
endfunctionfunction pux takes integer oDx returns nothinglocal integer oSx=oDxif not b0[oSx]thenreturnendifset b0[oSx]=falsecall pjx(oDx,c0)
call pjx(oDx,C0)
call pTx(pJx(fhx()))
endfunctionfunction pUx takes integer oDx returns nothinglocal integer oSx=oDxif not gZ[oSx]thenreturnendifset gZ[oSx]=falsecall M7x(oDx)call pgx(oDx)call pHx(oDx)call pux(oDx)endfunctionfunction pwx takes integer oDx returns nothinglocal real x
local real y
if iOx(oDx)thenset GZ=GZ+1if(GZ==1)thenset x=(GetCameraTargetPositionX())set y=(GetCameraTargetPositionY())call SetCameraBounds(x,y,x,y,x,y,x,y)endifendifendfunctionfunction pWx takes integer oSx returns integerset H0[oSx]=true
set j0[oSx]=falsecall rEx(J0)
return oSxendfunctionfunction pyx takes nothing returns integerlocal integer oSxif(f0==8190)then
call o_x("FolderUser_FolderKeyEvent_StructDownArrow_Allocation_allocCustom","call DebugEx(FolderUser_FolderKeyEvent_StructDownArrow.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",F0+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(g0[(w)]==w)thenset G0=G0+1set oSx=G0else
set oSx=g0[(w)]set g0[(w)]=g0[g0[(w)]]endifset g0[oSx]=Zset h0[oSx]=1call pWx(oSx)return oSxendfunctionfunction pYx takes integer oSx,integer otx,integer oux returns booleanreturn rux(xA[(oSx)],(aA[((oSx))]),otx,oux)endfunctionfunction pzx takes integer oSx,integer XYx returns nothingcall pYx((oSx),(oA[(XYx)]),XYx)endfunctionfunction pZx takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((xA[(oSx)]))])]))],((((aA[((oSx))])))),(((otx))),(((oux))))endfunctionfunction p_x takes integer oSx,integer XYx returns nothingif(B0[oSx]==w)thencall o_x("FolderUser_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oSx)+";"+(jA[(XYx)]))set B0[oSx]=Xendifcall rux(B0[oSx],(cb[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction p0x takes integer oSx,integer rbx,code igx,real p1x,real p2x returns integerlocal integer rLx=oSxlocal integer o7x=Xdx("FolderUser_FolderKeyEvent_StructDownArrow_RegisterPress: local Event result = Event.Create(FolderUser_FolderKeyEvent_StructDownArrow.PRESS_EVENT_TYPE, priority, actionFunction)",D0,rbx,igx)
local integer p3xif(p1x>.0)thenset oSx=pyx()set p3x=iXx()set k0[oSx]=p1xset K0[oSx]=p3xset l0[oSx]=p2xset L0[oSx]=o7xset m0[oSx]=rLxset ge[(p3x)]=(oSx)call hqx(rLx,M0,oSx)
call pzx(o7x,p0)
call pZx(o7x,P0,oSx)
endifcall p_x(rLx,o7x)return o7xendfunctionfunction p4x takes integer oDx returns nothinglocal integer oSx=oDxif b0[oSx]thenreturnendifset b0[oSx]=true
call p_x(oDx,c0)
call p_x(oDx,C0)
call pTx(pJx(fhx()))
endfunctionfunction p5x takes integer oDx,real oux returns nothingif iOx(oDx)thencall CameraSetSmoothingFactor(oux)endifendfunctionfunction p6x takes integer oSx returns nothinglocal string s=psx(S0[t0],1)
set wZ[T0[s0]]=s
if(Q0[(oSx)]==s0)thenset s=itx((t0>0),iSx("<<< ","ffffcc00"))+iSx(s,"ff00ff00")+itx((t0<u0),iSx(" >>>","ffffcc00"))endifcall pCx(tZ,s0,UZ,s)
call p5x((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetLocalPlayer())))))),((((R)))))),S0[t0])
endfunctionfunction p7x takes integer oSx returns nothingif iOx(hZ[(oSx)])thencall p6x(oSx)endifendfunctionfunction p8x takes integer oSx returns nothinglocal string s=(I2S((w0[W0[oSx]])))set wZ[T0[U0]]=s
if(Q0[(oSx)]==U0)thenset s=itx((W0[oSx]>0),iSx("<<< ","ffffcc00"))+iSx(s,"ff00ff00")+itx((W0[oSx]<y0),iSx(" >>>","ffffcc00"))
endifcall pCx(tZ,U0,UZ,s)
set Y0=w0[W0[oSx]]endfunctionfunction p9x takes integer oSx returns nothingif iOx(hZ[(oSx)])thencall p8x(oSx)endifendfunctionfunction Pvx takes integer oSx returns nothinglocal string s=(Ii[(ci)])set wZ[T0[z0]]=s
if(Q0[(oSx)]==z0)thenset s=itx(((bi[(ci)]-1)>0),iSx("<<< ","ffffcc00"))+iSx(s,"ff00ff00")+itx(((bi[(ci)]-1)<Ai),iSx(" >>>","ffffcc00"))endifcall pCx(tZ,z0,UZ,s)
endfunctionfunction Pex takes integer oSx returns nothingif iOx(hZ[(oSx)])thencall Pvx(oSx)endifendfunctionfunction Pxx takes integer oqx returns booleanreturn(oqx>0)endfunctionfunction Pox takes integer oSx returns nothinglocal string s=v1[e1]set wZ[T0[Z0]]=s
if(Q0[(oSx)]==Z0)thenset s=itx((e1>0),iSx("<<< ","ffffcc00"))+iSx(s,"ff00ff00")+itx((e1<o1),iSx(" >>>","ffffcc00"))endifcall pCx(tZ,Z0,UZ,s)
set r1=Pxx(e1)endfunctionfunction Prx takes integer oSx returns nothingif iOx(hZ[(oSx)])thencall Pox(oSx)endifendfunctionfunction Pix takes integer oSx returns nothinglocal integer rbxlocal integer oMxif(yZ[oSx]!=F)thenreturnendifset rbx=n1[oSx]set oMx=YZset YZ=oMx+1
loop
exitwhen(n1[zZ[oMx]]<rbx)set yZ[zZ[oMx]]=oMx+1set zZ[oMx+1]=zZ[oMx]set oMx=oMx-1endloopset oMx=oMx+1set zZ[oMx]=oSxset yZ[oSx]=oMxif(oMx==YZ)thencall PlayMusic(ZZ[oSx])endifendfunctionfunction Pax takes integer oSx,boolean Pnx returns nothinglocal string s=ppx("l",(R2I(((iUx(i1*25*1./ 100.,25))*1.))))
local string s2=" "+iSx("("+(I2S((i1)))+"%"+")","ffffcc00")set wZ[T0[WZ]]=s+s2call SetMusicVolume((R2I(((((i1*1./ 100.)*1.)*127.)*1.))))if(Q0[(oSx)]==WZ)thenset s=iSx(s,"ff00ff00")endifset s=s+s2if Pnx thencall Pix(v0)
endifcall pCx(tZ,WZ,UZ,s)
endfunctionfunction PVx takes integer oSx,boolean Pnx returns nothingif iOx(hZ[(oSx)])thencall Pax(oSx,Pnx)endifendfunctionfunction PEx takes real oux returns nothinglocal integer oMx=X1
set od=ouxloop
exitwhen(oMx<0)call VolumeGroupSetVolume(O1[R1[oMx]],oux)set oMx=oMx-1endloopendfunctionfunction PXx takes integer oSx,boolean POx returns nothinglocal string s=ppx("l",(R2I(((iUx(E1*25*1./ 100.,25))*1.))))
local string s2=" "+iSx("("+(I2S((E1)))+"%"+")","ffffcc00")set wZ[T0[V1]]=s+s2call PEx(E1*1./ 100.)if(Q0[(oSx)]==V1)thenset s=iSx(s,"ff00ff00")endifset s=s+s2if POx thencall Akx(I1)
endifcall pCx(tZ,V1,UZ,s)
endfunctionfunction PRx takes integer oSx,boolean POx returns nothingif iOx(hZ[(oSx)])thencall PXx(oSx,POx)endifendfunctionfunction PIx takes integer oSx,integer oLx returns nothinglocal integer PAx=e0[oSx]local integer PNxif(oLx==PAx)then
returnendifcall pfx(oSx,PAx)set e0[oSx]=oLxif(oLx==F)thenset PNx=welse
set PNx=LZ[oLx]endifset Q0[oSx]=PNxif(PNx==w)thencall p4x(hZ[oSx])else
call pux(hZ[oSx])endifif not iOx(hZ[oSx])thenreturnendifif(PNx==s0)thencall p7x(oSx)endifif(PNx==U0)thencall p9x(oSx)endifif(PNx==z0)thencall Pex(oSx)endifif(PNx==Z0)thencall Prx(oSx)endifif(PNx==WZ)thencall PVx(oSx,false)endifif(PNx==V1)thencall PRx(oSx,false)endifendfunctionfunction Pbx takes nothing returns booleanlocal integer rFx=(bv)local integer bIx=(ZA[(rFx)])local integer oSx=bIxif(e0[oSx]==q0)thencall PIx(oSx,F)else
call PIx(oSx,e0[oSx]+1)endifreturn trueendfunctionfunction PBx takes integer oSx returns integerset d1[oSx]=true
set D1[oSx]=falsecall rEx(f1)
return oSxendfunctionfunction Pcx takes nothing returns integerlocal integer oSxif(N1==8190)then
call o_x("FolderUser_FolderKeyEvent_StructLeftArrow_Allocation_allocCustom","call DebugEx(FolderUser_FolderKeyEvent_StructLeftArrow.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",b1+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(B1[(w)]==w)thenset c1=c1+1set oSx=c1else
set oSx=B1[(w)]set B1[(w)]=B1[B1[(w)]]endifset B1[oSx]=Zset C1[oSx]=1call PBx(oSx)return oSxendfunctionfunction PCx takes integer oSx,integer rbx,code igx,real p1x,real p2x returns integerlocal integer rLx=oSxlocal integer o7x=Xdx("FolderUser_FolderKeyEvent_StructLeftArrow_RegisterPress: local Event result = Event.Create(FolderUser_FolderKeyEvent_StructLeftArrow.PRESS_EVENT_TYPE, priority, actionFunction)",A1,rbx,igx)
local integer p3xif(p1x>.0)thenset oSx=Pcx()set p3x=iXx()set F1[oSx]=p1xset g1[oSx]=p3xset G1[oSx]=p2xset h1[oSx]=o7xset H1[oSx]=rLxset ge[(p3x)]=(oSx)call hqx(rLx,j1,oSx)
call pzx(o7x,J1)
call pZx(o7x,k1,oSx)
endifcall p_x(rLx,o7x)return o7xendfunctionfunction Pdx takes integer oSx,real p2x returns nothingif(W0[oSx]>0)thenset W0[oSx]=W0[oSx]-1else
if(p2x==1.)thencall ipx(hZ[(oSx)],iSx("Penguin perspective is not supported","ffffcc00"),10.)endifendifcall p9x(oSx)endfunctionfunction PDx takes integer oSx returns nothingif(t0>0)then
set t0=t0-1endifcall p7x(oSx)endfunctionfunction Pfx takes integer oSx returns nothingset ci=(Ni[(R2I(((iAx((0),((bi[(ci)]-1)-1)))*1.)))])
call Pex(oSx)endfunctionfunction PFx takes integer oSx returns nothingset e1=(R2I(((iAx((0),(e1-1)))*1.)))
call Prx(oSx)endfunctionfunction Pgx takes integer oSx,real p2x returns nothingset i1=(R2I(((iAx((0),((R2I(((i1-1.*p2x)*1.))))))*1.)))call PVx(oSx,true)endfunctionfunction PGx takes integer oSx,real p2x returns nothingset E1=(R2I(((iAx((0),((R2I(((E1-1.*p2x)*1.))))))*1.)))call PRx(oSx,true)endfunctionfunction Phx takes nothing returns booleanlocal integer rFx=(bv)local real p2x=(K1[(rFx)])local integer bIx=(ZA[(rFx)])local integer oSx=bIxlocal integer PNx=Q0[oSx]if(PNx==U0)thencall Pdx(oSx,p2x)endifif not iOx(bIx)thenreturn trueendifif(PNx==s0)thencall PDx(oSx)endifif(PNx==z0)thencall Pfx(oSx)endifif(PNx==Z0)thencall PFx(oSx)endifif(PNx==WZ)thencall Pgx(oSx,p2x)endifif(PNx==V1)thencall PGx(oSx,p2x)endifreturn trueendfunctionfunction PHx takes integer oSx returns integerset q1[oSx]=true
set Q1[oSx]=falsecall rEx(s1)
return oSxendfunctionfunction Pjx takes nothing returns integerlocal integer oSxif(L1==8190)then
call o_x("FolderUser_FolderKeyEvent_StructRightArrow_Allocation_allocCustom","call DebugEx(FolderUser_FolderKeyEvent_StructRightArrow.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",m1+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(M1[(w)]==w)thenset p1=p1+1set oSx=p1else
set oSx=M1[(w)]set M1[(w)]=M1[M1[(w)]]endifset M1[oSx]=Zset P1[oSx]=1call PHx(oSx)return oSxendfunctionfunction PJx takes integer oSx,integer rbx,code igx,real p1x,real p2x returns integerlocal integer rLx=oSxlocal integer o7x=Xdx("FolderUser_FolderKeyEvent_StructRightArrow_RegisterPress: local Event result = Event.Create(FolderUser_FolderKeyEvent_StructRightArrow.PRESS_EVENT_TYPE, priority, actionFunction)",l1,rbx,igx)local integer p3xif(p1x>.0)thenset oSx=Pjx()set p3x=iXx()set S1[oSx]=p1xset t1[oSx]=p3xset T1[oSx]=p2xset u1[oSx]=o7xset U1[oSx]=rLxset ge[(p3x)]=(oSx)call hqx(rLx,w1,oSx)
call pzx(o7x,W1)
call pZx(o7x,Y1,oSx)
endifcall p_x(rLx,o7x)return o7xendfunctionfunction Pkx takes integer oSx returns nothingif(W0[oSx]<y0)thenset W0[oSx]=W0[oSx]+1endifcall p9x(oSx)endfunctionfunction PKx takes integer oSx returns nothingif(t0<u0)thenset t0=t0+1endifcall p7x(oSx)endfunctionfunction Plx takes integer oSx returns nothingset ci=(Ni[(R2I(((iUx(((bi[(ci)]-1)+1),(Ai)))*1.)))])call Pex(oSx)endfunctionfunction PLx takes integer oSx returns nothingset e1=(R2I(((iUx((e1+1),(1)))*1.)))
call Prx(oSx)endfunctionfunction Pmx takes integer oSx,real p2x returns nothingset i1=(R2I(((iUx(((R2I(((i1+1.*p2x)*1.)))),('d')))*1.)))call PVx(oSx,true)endfunctionfunction PMx takes integer oSx,real p2x returns nothingset E1=(R2I(((iUx(((R2I(((E1+1.*p2x)*1.)))),('d')))*1.)))call PRx(oSx,true)endfunctionfunction Ppx takes nothing returns booleanlocal integer rFx=(bv)local real p2x=(K1[(rFx)])local integer bIx=(ZA[(rFx)])local integer oSx=bIxlocal integer PNx=Q0[oSx]if(PNx==U0)thencall Pkx(oSx)endifif not iOx(bIx)thenreturn trueendifif(PNx==s0)thencall PKx(oSx)endifif(PNx==z0)thencall Plx(oSx)endifif(PNx==Z0)thencall PLx(oSx)endifif(PNx==WZ)thencall Pmx(oSx,p2x)endifif(PNx==V1)thencall PMx(oSx,p2x)endifreturn trueendfunctionfunction PPx takes integer oSx returns integerset i2[oSx]=true
set n2[oSx]=falsecall rEx(V2)
return oSxendfunctionfunction Pqx takes nothing returns integerlocal integer oSxif(Z1==8190)then
call o_x("FolderUser_FolderKeyEvent_StructUpArrow_Allocation_allocCustom","call DebugEx(FolderUser_FolderKeyEvent_StructUpArrow.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",v2+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(e2[(w)]==w)thenset o2=o2+1set oSx=o2else
set oSx=e2[(w)]set e2[(w)]=e2[e2[(w)]]endifset e2[oSx]=Zset r2[oSx]=1call PPx(oSx)return oSxendfunctionfunction PQx takes integer oSx,integer rbx,code igx,real p1x,real p2x returns integerlocal integer rLx=oSxlocal integer o7x=Xdx("FolderUser_FolderKeyEvent_StructUpArrow_RegisterPress: local Event result = Event.Create(FolderUser_FolderKeyEvent_StructUpArrow.PRESS_EVENT_TYPE, priority, actionFunction)",z1,rbx,igx)
local integer p3xif(p1x>.0)thenset oSx=Pqx()set p3x=iXx()set E2[oSx]=p1xset X2[oSx]=p3xset O2[oSx]=p2xset R2[oSx]=o7xset I2[oSx]=rLxset ge[(p3x)]=(oSx)call hqx(rLx,A2,oSx)
call pzx(o7x,N2)
call pZx(o7x,b2,oSx)
endifcall p_x(rLx,o7x)return o7xendfunctionfunction Psx takes nothing returns booleanlocal integer rFx=(bv)local integer bIx=(ZA[(rFx)])local integer oSx=bIxif(e0[oSx]==F)thencall PIx(oSx,q0)
else
call PIx(oSx,e0[oSx]-1)endifreturn trueendfunctionfunction PSx takes integer oSx returns nothinglocal integer bIx=hZ[oSx]if HZ[oSx]thenreturnendifset HZ[oSx]=true
set JZ[oSx]=p0x(bIx,lI,function Pbx,.5,1.)set kZ[oSx]=PCx(bIx,lI,function Phx,.1,4.)set KZ[oSx]=PJx(bIx,lI,function Ppx,.1,4.)set lZ[oSx]=PQx(bIx,lI,function Psx,.5,1.)set Q0[oSx]=Fset e0[oSx]=Fendfunctionfunction Ptx takes integer bIx returns nothinglocal integer oSx=bIxif(pJx(bIx)==tZ)then
call PSx(oSx)endifendfunctionfunction PTx takes integer oSx returns nothinglocal integer Pux=D2[C2]
local integer oLxlocal string scall pCx(X0,C2,O0,R0[Pux])set oLx=f2[oSx]set s=(I2S((oLx+1)))+"/"+(I2S((F2+1)))set A0[Pux]=sif(c2[oSx]==C2)thenset s=itx((oLx>0),iSx("<<< ","ffffcc00"))+iSx(s,"ff00ff00")+itx((oLx<F2),iSx(" >>>","ffffcc00"))
endifcall pCx(X0,C2,I0,s)
endfunctionfunction PUx takes integer oSx,integer oLx returns nothinglocal integer PAx=N0[oSx]local integer PNxif(oLx==PAx)then
returnendifcall pGx(oSx,PAx)set N0[oSx]=oLxif(oLx==F)thenset PNx=Felse
set PNx=E0[oLx]endifset c2[oSx]=PNxif(PNx==F)thencall p4x(x0[oSx])else
call pux(x0[oSx])endifif not iOx(x0[oSx])thenreturnendifif(PNx==C2)thencall PTx(oSx)endifendfunctionfunction Pwx takes nothing returns booleanlocal integer rFx=(bv)local integer bIx=(ZA[(rFx)])local integer oSx=bIxif(N0[oSx]==B2)thencall PUx(oSx,F)else
call PUx(oSx,N0[oSx]+1)endifreturn trueendfunctionfunction PWx takes integer oSx returns nothinglocal integer pRx=(mZ[(oSx)])local integer pIx=(MZ[(oSx)])local integer Pyx=pRxlocal integer pNxloop
exitwhen(Pyx<0)set pNx=pIxloop
exitwhen(pNx<0)call pcx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((op[(oSx)]))))),((((sZ+(pNx)*50+(Pyx))))))),"")set pNx=pNx-1endloopset Pyx=Pyx-1endloopendfunctionfunction PYx takes integer oSx,integer pNx,integer pAx,real oux returns nothingcall pBx(oSx,pNx,pAx)call pEx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((op[(oSx)]))))),((((sZ+(pNx)*50+(pAx))))))),oux)
endfunctionfunction Pzx takes integer oSx,integer pAx,real oux returns nothinglocal integer pNx=(MZ[((oSx))])loop
exitwhen(pNx<0)call PYx((oSx),pNx,pAx,oux)set pNx=pNx-1endloopendfunctionfunction PZx takes integer n2x returns integerset IE=n2xif not TriggerEvaluate(RE)thencall o_x("Basic_GetAllocModuleFromQueue","call DebugEx(\"GetAllocModuleFromQueue: \" + \"thread broken\")","GetAllocModuleFromQueue: thread broken")
endifreturn bEendfunctionfunction P_x takes integer oSx,integer oLx returns nothinglocal integer ilocal integer a8xlocal integer clocal integer P0xcall PWx(X0)
set f2[oSx]=oLxcall PTx(oSx)set i=0+oLx*30set a8x=0+(oLx+1)*30-1set c=0call pbx(X0,g2+(R2I(((iUx((30),(GE-i+1)))*1.)))-1)call Pzx(X0,O0,.2)call Pzx(X0,I0,.05)loop
exitwhen(i>a8x)exitwhen(i>GE)set P0x=PZx(i)call pCx(X0,g2+c,O0,(hE[(P0x)]))
call pCx(X0,g2+c,I0,(I2S(((BE[(P0x)])))))set i=i+1set c=c+1endloopendfunctionfunction P1x takes nothing returns booleanlocal integer rFx=(bv)local real p2x=(K1[(rFx)])local integer bIx=(ZA[(rFx)])local integer oSx=bIxlocal integer PNx=c2[oSx]if(PNx==C2)thenif(f2[oSx]>0)thencall P_x(oSx,f2[oSx]-1)endifendifif not iOx(bIx)thenreturn trueendifreturn trueendfunctionfunction P2x takes nothing returns booleanlocal integer rFx=(bv)local real p2x=(K1[(rFx)])local integer bIx=(ZA[(rFx)])local integer oSx=bIxlocal integer PNx=c2[oSx]if(PNx==C2)thenif(f2[oSx]<F2)thencall P_x(oSx,f2[oSx]+1)endifendifif not iOx(bIx)thenreturn trueendifreturn trueendfunctionfunction P3x takes nothing returns booleanlocal integer rFx=(bv)local integer bIx=(ZA[(rFx)])local integer oSx=bIxif(N0[oSx]==F)thencall PUx(oSx,B2)
else
call PUx(oSx,N0[oSx]-1)endifreturn trueendfunctionfunction P4x takes integer oSx returns nothinglocal integer bIx=x0[oSx]if o0[oSx]thenreturnendifset o0[oSx]=true
set r0[oSx]=p0x(bIx,lI,function Pwx,.5,1.)set i0[oSx]=PCx(bIx,lI,function P1x,.125,1.)
set n0[oSx]=PJx(bIx,lI,function P2x,.125,1.)
set V0[oSx]=PQx(bIx,lI,function P3x,.5,1.)set c2[oSx]=Fset N0[oSx]=Fendfunctionfunction P5x takes integer bIx returns nothinglocal integer oSx=bIxif(pJx(bIx)==X0)then
call P4x(oSx)endifendfunctionfunction P6x takes integer oDx returns nothinglocal integer oSx=oDxif gZ[oSx]thenreturnendifset gZ[oSx]=true
call pwx(oDx)call Ptx(oDx)call P5x(oDx)call p4x(oDx)endfunctionfunction P7x takes nothing returns booleanlocal integer rFx=(bv)local integer oDx=(ZA[(rFx)])local integer oSx=oDxif gZ[oSx]thencall pUx(oDx)return trueendifcall P6x(oDx)return trueendfunctionfunction P8x takes integer oDx returns integerlocal integer oSx=oDxset gZ[oSx]=falsereturn oSxendfunctionfunction P9x takes nothing returns nothinglocal integer oMx=Hl
local integer M6xloop
exitwhen(oMx<0)set M6x=jl[oMx]call P8x(M6x)set oMx=oMx-1endloopendfunctionfunction qvx takes integer oDx returns integerlocal integer oSx=oDxreturn BZ[oSx]endfunctionfunction qex takes integer oSx,integer oDx returns nothinglocal integer rLx=oSxset oSx=oDxset xp[oSx]=rLxif not iOx(oDx)thenreturnendifcall MultiboardDisplay(op[rLx],true)
call MultiboardMinimize(op[rLx],false)call pTx(rLx)endfunctionfunction qxx takes integer qox,integer bIx returns nothinglocal integer oSx=bIxif(qox==tZ)thencall PSx(oSx)else
call pFx(oSx)endifendfunctionfunction qrx takes integer qox,integer bIx returns nothinglocal integer oSx=bIxif(qox==X0)thencall P4x(oSx)else
call phx(oSx)endifendfunctionfunction qix takes integer rLx,integer oDx returns nothingcall qex(rLx,oDx)call qxx(rLx,oDx)call qrx(rLx,oDx)endfunctionfunction qax takes nothing returns booleanlocal integer rFx=(bv)local integer oDx=(ZA[(rFx)])local integer qnx=qvx(oDx)local integer rLx=pkx(qnx,pJx(oDx))if(rLx==w)thenset rLx=(az[(qnx)])endifcall qix(rLx,oDx)return trueendfunctionfunction qVx takes nothing returns booleanlocal integer rFx=(bv)local integer oDx=(ZA[(rFx)])local integer qnx=qvx(oDx)local integer rLx=pKx(qnx,pJx(oDx))if(rLx==w)thenset rLx=(rz[(qnx)])endifcall qix(rLx,oDx)return trueendfunctionfunction qEx takes integer oDx returns integerlocal integer oSx=oDxset b0[oSx]=falsereturn oSxendfunctionfunction qXx takes nothing returns nothinglocal integer oMx=Hl
local integer M6xloop
exitwhen(oMx<0)set M6x=jl[oMx]call qEx(M6x)set oMx=oMx-1endloopendfunctionfunction qOx takes nothing returns nothingset c0=Xdx("FolderMultiboard_FolderShown_FolderControl_StructPageSwitch_Init: set FolderMultiboard_FolderShown_FolderControl_StructPageSwitch.LEFT_EVENT = Event.Create(USER.KeyEvent.LeftArrow.PRESS_EVENT_TYPE, EventPriority.HEADER, function FolderMultiboard_FolderShown_FolderControl_StructPageSwitch.Event_Left)",A1,bI,function qax)set C0=Xdx("FolderMultiboard_FolderShown_FolderControl_StructPageSwitch_Init: set FolderMultiboard_FolderShown_FolderControl_StructPageSwitch.RIGHT_EVENT = Event.Create(USER.KeyEvent.RightArrow.PRESS_EVENT_TYPE, EventPriority.HEADER, function FolderMultiboard_FolderShown_FolderControl_StructPageSwitch.Event_Right)",l1,bI,function qVx)
call qXx()endfunctionfunction qRx takes nothing returns nothingcall Dcx(Xdx("FolderMultiboard_FolderShown_StructControl_Init: call Event.Create(USER.KeyEvent.ESC_EVENT_TYPE, EventPriority.HEADER, function FolderMultiboard_FolderShown_StructControl.Event_Esc).AddToStatics()",FZ,bI,function P7x))
call P9x()call qOx()endfunctionfunction qIx takes nothing returns nothingcall M5x()call qRx()endfunctionfunction qAx takes nothing returns nothinglocal integer oSx=pJx(fhx())
if(oSx==w)thenreturnendifcall pTx(oSx)endfunctionfunction qNx takes nothing returns booleanlocal integer rFx=(bv)call iDx(G2,h2,true,function qAx)return trueendfunctionfunction qbx takes nothing returns nothingset G2=iXx()
call Dcx(Xdx("FolderMultiboard_StructTitle_Init: call Event.Create(EventType.START, EventPriority.HEADER, function FolderMultiboard_StructTitle.Event_Start).AddToStatics()",EE,bI,function qNx))endfunctionfunction qBx takes nothing returns booleancall qIx()call qbx()return trueendfunctionfunction qcx takes nothing returns booleancall GDx(function qBx,"Multiboard_Init")
return trueendfunctionfunction qCx takes nothing returns booleanset H2=VXx(j2)return trueendfunctionfunction qdx takes nothing returns booleanset J2=VXx(k2)return trueendfunctionfunction qDx takes nothing returns booleanset K2=VXx(l2)return trueendfunctionfunction qfx takes nothing returns booleanset L2=VXx(m2)return trueendfunctionfunction qFx takes nothing returns booleanset M2=VXx(p2)return trueendfunctionfunction qgx takes nothing returns booleanset P2=VXx(q2)return trueendfunctionfunction qGx takes nothing returns booleanset Q2=VXx(S2)return trueendfunctionfunction qhx takes integer oSx returns integerset W2[oSx]=true
set Y2[oSx]=falseset Z2[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set dj[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(Q2)
return oSxendfunctionfunction qHx takes nothing returns integerlocal integer oSxif(T2==8190)then
call o_x("Order_Allocation_allocCustom","call DebugEx(Order.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",S2+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(u2[(w)]==w)thenset U2=U2+1set oSx=U2else
set oSx=u2[(w)]set u2[(w)]=u2[u2[(w)]]endifset u2[oSx]=Zset w2[oSx]=1call qhx(oSx)return oSxendfunctionfunction qjx takes integer oSx returns nothingset cj[(oSx)]=(e3+oSx)endfunctionfunction qJx takes string rSx,integer oqx returns integerlocal integer oSx=qHx()set pb[oSx]=oqxcall SaveInteger(o[((V[(E[((X))])]))],(((oqx))),(((Aj))),(((oSx))))call qjx(oSx)set o3[(oSx)]=(rSx)return oSxendfunctionfunction qkx takes nothing returns booleanset t2=qJx("acid bomb",$D02B6)set r3=qJx("ancestral spirit",$D020A)set i3=qJx("animate dead",$D00F9)set bw=qJx("attack",$D000F)set n3=qJx("avatar",$D0076)set V3=qJx("banish",$D0206)set E3=qJx("berserk",$D0084)
set X3=qJx("blizzard",$D0079)set XJ=qJx("blood lust",$D0085)set O3=qJx("breath of fire",$D0264)set R3=qJx("breath of frost",$D0250)
set I3=qJx("cannibalize",$D00DC)
set A3=qJx("carrion swarm",$D00FA)set N3=qJx("chain lightning",$D0097)
set b3=qJx("channel",$D0278)
set B3=qJx("cluster rockets",$D02AC)
set c3=qJx("cripple",$D00DD)
set C3=qJx("cyclone",$D00B0)
set d3=qJx("dark conversion",$D0104)
set D3=qJx("dark portal",$D0105)
set f3=qJx("death and decay",$D00FD)
set F3=qJx("death coil",$D00FE)set g3=qJx("doom",$D0267)set G3=qJx("drunken haze",$D0269)set h3=qJx("eat tree",$D00B2)set H3=qJx("ensnare",$D008A)
set j3=qJx("entangling roots",$D00CB)set J3=qJx("evil eye",$D0089)set k3=qJx("firebolt",$D0107)set K3=qJx("frenzy",$D0251)set l3=qJx("frenzyOff",$D0253)set L3=qJx("frenzyOn",$D0252)set m3=qJx("heal",$D005F)set M3=qJx("healing wave",$D0215)set p3=qJx("hex",$D0216)
set P3=qJx("hold position",$D0019)set q3=qJx("howl of terror",$D026C)set Q3=qJx("impale",$D024B)set s3=qJx("inferno",$D0108)
set S3=qJx("inner fire",$D0062)set t3=qJx("lightning shield",$D008E)set T3=qJx("load",$D004E)set u3=qJx("mana burn",$D00D3)set U3=qJx("mana shield on",$D026D)set w3=qJx("mirror image",$D009B)set W3=qJx("monsoon",$CFE87)
set Bh=qJx("move",$D0012)set Y3=qJx("move item to slot 0",$D0022)
set z3=qJx("move item to slot 1",$D0023)
set Z3=qJx("move item to slot 2",$D0024)
set v4=qJx("move item to slot 3",$D0025)
set e4=qJx("move item to slot 4",$D0026)
set o4=qJx("move item to slot 5",$D0027)
set r4=qJx("phase shift",$D0016)
set i4=qJx("phase shift",$D0222)
set n4=qJx("purge",$D008F)set V4=qJx("raise dead",$D00E5)set E4=qJx("resurrection",$D007E)set X4=qJx("roar",$D00C4)set O4=qJx("self destruct",$D0048)set R4=qJx("sanctuary",$D0259)set I4=qJx("shock wave",$D009D)set A4=qJx("sleep",$D0103)set N4=qJx("smart",$D0003)set b4=qJx("soulburn",$D02BC)set B4=qJx("spirit wolf",$D009E)
set c4=qJx("star fall",$D00D7)set C4=qJx("stasis trap",$D0092)
set ch=qJx("stop",$D0004)set d4=qJx("stunned",$D0005)
set D4=qJx("summon factory",$D02B2)set f4=qJx("summon grizzly",$D0272)set F4=qJx("summon war eagle",$D0274)set g4=qJx("taunt",$D0228)set G4=qJx("thunder bolt",$D007F)set h4=qJx("tunder clap",$D0080)
set Ch=qJx("use item in slot 0",$D0028)set H4=qJx("use item in slot 1",$D0029)set j4=qJx("use item in slot 2",$D002A)set J4=qJx("use item in slot 3",$D002B)set k4=qJx("use item in slot 4",$D002C)set dh=qJx("use item in slot 5",$D002D)set K4=qJx("voodoo",$D0217)set l4=qJx("ward",$D0218)set L4=qJx("wind walk",$D00A1)return trueendfunctionfunction qKx takes nothing returns booleancall Fzx(function qkx,"Order_Init")return trueendfunctionfunction qlx takes nothing returns booleanset m4=VXx(M4)return trueendfunctionfunction qLx takes nothing returns booleanset Vj=VXx(aj)return trueendfunctionfunction qmx takes nothing returns booleanset p4=VXx(P4)return trueendfunctionfunction qMx takes nothing returns booleanset q4=VXx(Q4)return trueendfunctionfunction qpx takes nothing returns nothingendfunctionfunction qPx takes nothing returns nothingendfunctionfunction qqx takes nothing returns nothingendfunctionfunction qQx takes nothing returns nothingendfunctionfunction qsx takes nothing returns nothingendfunctionfunction qSx takes nothing returns booleancall qpx()call qPx()set s4=InitHashtable()call qqx()call qQx()call qsx()return trueendfunctionfunction qtx takes nothing returns booleancall VFx(function qSx,"Primitive_Init")return trueendfunctionfunction qTx takes nothing returns booleanset S4=VXx(t4)return trueendfunctionfunction qux takes nothing returns booleanset T4=VXx(u4)return trueendfunctionfunction qUx takes nothing returns booleanset U4=VXx(w4)return trueendfunctionfunction qwx takes nothing returns booleanset W4=VXx(Y4)return trueendfunctionfunction qWx takes nothing returns booleanset Sm=VXx(mm)return trueendfunctionfunction qyx takes nothing returns booleanset z4=VXx(Z4)return trueendfunctionfunction qYx takes nothing returns booleanset v5=VXx(e5)return trueendfunctionfunction qzx takes nothing returns booleanset x5=VXx(o5)return trueendfunctionfunction qZx takes nothing returns booleanset r5=VXx(i5)return trueendfunctionfunction q_x takes nothing returns booleanset a5=VXx(n5)return trueendfunctionfunction q0x takes nothing returns booleanset V5=VXx(E5)return trueendfunctionfunction q1x takes nothing returns booleanset X5=VXx(O5)return trueendfunctionfunction q2x takes rect oqx returns integerlocal integer oSx=Gux(GetRectMinX(oqx),GetRectMinY(oqx),GetRectMaxX(oqx),GetRectMaxY(oqx))set bm[oSx]=oqxcall GYx(oSx)return oSxendfunctionfunction q3x takes nothing returns booleanset Bm=q2x(GetWorldBounds())
return trueendfunctionfunction q4x takes nothing returns booleancall Fzx(function q3x,"Region_Init")
return trueendfunctionfunction q5x takes nothing returns booleanset R5=VXx(I5)return trueendfunctionfunction q6x takes nothing returns booleanset A5=VXx(N5)return trueendfunctionfunction q7x takes nothing returns booleanset b5=VXx(B5)return trueendfunctionfunction q8x takes nothing returns booleanset c5=VXx(C5)return trueendfunctionfunction q9x takes nothing returns booleanset KB=VXx(JB)return trueendfunctionfunction Qvx takes integer oSx returns integerset G5[oSx]=true
set h5[oSx]=falsecall rEx(b5)
return oSxendfunctionfunction Qex takes nothing returns integerlocal integer oSxif(D5==8190)then
call o_x("SoundEax_Allocation_allocCustom","call DebugEx(SoundEax.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",B5+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(f5[(w)]==w)thenset F5=F5+1set oSx=F5else
set oSx=f5[(w)]set f5[(w)]=f5[f5[(w)]]endifset f5[oSx]=Zset g5[oSx]=1call Qvx(oSx)return oSxendfunctionfunction Qxx takes string oqx returns integerlocal integer oSx=Qex()set ed[(oSx)]=(oqx)return oSxendfunctionfunction Qox takes nothing returns nothingset d5=Qxx("CombatSoundsEAX")set H5=Qxx("DefaultEAXON")set j5=Qxx("DoodadsEAX")
set J5=Qxx("HeroAcksEAX")set k5=Qxx("KotoDrumsEAX")set K5=Qxx("MissilesEAX")set l5=Qxx("SpellsEAX")endfunctionfunction Qrx takes integer oSx,real oux returns nothingset xd[oSx]=ouxcall VolumeGroupSetVolume(O1[oSx],oux)endfunctionfunction Qix takes integer oSx returns booleanset X1=X1+1set R1[X1]=oSxset L5[oSx]=X1+1
return(X1==0)endfunctionfunction Qax takes integer oSx,volumegroup Qnx returns integerset O1[oSx]=Qnxcall Qrx(oSx,1.)
call Qix(oSx)return oSxendfunctionfunction QVx takes nothing returns nothingcall Qax(m5,SOUND_VOLUMEGROUP_AMBIENTSOUNDS)
call Qax(M5,null)call Qax(p5,null)call Qax(5,SOUND_VOLUMEGROUP_COMBAT)
call Qax(P5,null)call Qax(6,SOUND_VOLUMEGROUP_UI)
call Qax(q5,SOUND_VOLUMEGROUP_FIRE)call Qax(0,null)
call Qax(9,SOUND_VOLUMEGROUP_UNITMOVEMENT)call Qax(8,SOUND_VOLUMEGROUP_UI)
call Qax(2,SOUND_VOLUMEGROUP_UNITSOUNDS)
call Qax(3,SOUND_VOLUMEGROUP_UNITSOUNDS)
call Qax(4,SOUND_VOLUMEGROUP_UNITSOUNDS)
call Qax(1,SOUND_VOLUMEGROUP_UNITSOUNDS)
endfunctionfunction QEx takes string QXx,boolean QOx,boolean QRx,boolean QIx,real QAx,real R3x,integer Ajx returns integerlocal integer oSx=AGx()set gB[oSx]=wset RC[(oSx)]=(QXx)call Ahx(oSx,0)set bC[(oSx)]=(Ajx)set gC[(oSx)]=((1.)*1.)set hC[(oSx)]=((QAx)*1.)
set jC[(oSx)]=((R3x)*1.)
set lB[(oSx)]=(QOx)set KC[(oSx)]=(QIx)set LC[(oSx)]=(QRx)call AHx(oSx)return oSxendfunctionfunction QNx takes nothing returns nothingendfunctionfunction Qbx takes nothing returns booleancall Qox()call QVx()set Q5=QEx("Sound\\Interface\\Error.wav",false,false,false,$A,$A,w)call Ahx(Q5,8)call QNx()return trueendfunctionfunction QBx takes nothing returns booleancall Fzx(function Qbx,"Sound_Init")return trueendfunctionfunction Qcx takes nothing returns booleanset qB=VXx(pB)return trueendfunctionfunction QCx takes nothing returns booleanset s5[0]='AHS0'
call L1x('AHS0',true)return trueendfunctionfunction Qdx takes nothing returns booleanset s5[4]='AHS4'
call L1x('AHS4',true)return trueendfunctionfunction QDx takes nothing returns booleanset s5[1]='AHS1'
call L1x('AHS1',true)return trueendfunctionfunction Qfx takes nothing returns booleanset s5[3]='AHS3'
call L1x('AHS3',true)return trueendfunctionfunction QFx takes nothing returns booleanset s5[2]='AHS2'
call L1x('AHS2',true)return trueendfunctionfunction Qgx takes nothing returns booleancall LYx(function QCx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Spell.page\\HeroSpell.struct\\obj_slots[0]_wc3spell.j")call LYx(function Qdx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Spell.page\\HeroSpell.struct\\obj_slots[4]_wc3spell.j")call LYx(function QDx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Spell.page\\HeroSpell.struct\\obj_slots[1]_wc3spell.j")call LYx(function Qfx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Spell.page\\HeroSpell.struct\\obj_slots[3]_wc3spell.j")call LYx(function QFx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Spell.page\\HeroSpell.struct\\obj_slots[2]_wc3spell.j")return trueendfunctionfunction QGx takes nothing returns booleanset S5=VXx(t5)return trueendfunctionfunction Qhx takes nothing returns booleanset T5=VXx(u5)return trueendfunctionfunction QHx takes nothing returns booleanset U5=VXx(w5)return trueendfunctionfunction Qjx takes nothing returns booleanset W5=VXx(y5)return trueendfunctionfunction QJx takes nothing returns booleanset Y5=VXx(z5)return trueendfunctionfunction Qkx takes nothing returns booleanset Z5=VXx(v6)return trueendfunctionfunction QKx takes nothing returns booleanset e6=VXx(x6)return trueendfunctionfunction Qlx takes nothing returns booleanset o6=VXx(r6)return trueendfunctionfunction QLx takes nothing returns booleanset i6=VXx(a6)return trueendfunctionfunction Qmx takes nothing returns booleanset n6=VXx(V6)return trueendfunctionfunction QMx takes nothing returns booleanreturn trueendfunctionfunction Qpx takes nothing returns booleanset E6=VXx(X6)return trueendfunctionfunction QPx takes integer oSx returns integerset b6[oSx]=true
set B6[oSx]=falsecall rEx(T5)
return oSxendfunctionfunction Qqx takes nothing returns integerlocal integer oSxif(R6==8190)then
call o_x("SpellClass_Allocation_allocCustom","call DebugEx(SpellClass.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",u5+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(I6[(w)]==w)thenset A6=A6+1set oSx=A6else
set oSx=I6[(w)]set I6[(w)]=I6[I6[(w)]]endifset I6[oSx]=Zset N6[oSx]=1call QPx(oSx)return oSxendfunctionfunction QQx takes boolean Qsx,integer QSx,integer Qtx returns integerlocal integer oSx=Qqx()if(Qtx!=0)thenset Qtx=Qtx-'F000'endifset c6[(oSx)]=(QSx)set C6[(oSx)]=(Qtx)set d6[(oSx)]=(Qsx)return oSxendfunctionfunction QTx takes nothing returns nothingset O6=QQx(true,0,'F000')set D6=QQx(true,1,'G000')set f6=QQx(false,0,0)set F6=QQx(true,4,'K000')set g6=QQx(true,2,'H000')set G6=QQx(true,3,'J000')set h6=QQx(false,0,0)set H6=QQx(false,0,0)endfunctionfunction Qux takes integer oSx,integer rTx returns integerreturn GetUnitAbilityLevel(C[(oSx)],rTx)
endfunctionfunction QUx takes integer rlx returns integerreturn((k6[((rlx))])+(c6[((K6[(rlx)]))]))endfunctionfunction Qwx takes integer rlx,integer rYx returns integerreturn((C6[((K6[(rlx)]))])+(l6[((rlx))])+rYx)endfunctionfunction QWx takes integer rYx,integer rlx,integer OSx returns nothinglocal integer Qyx=Qux(OSx,QUx(rlx))-1local integer QYx=Qwx(rlx,Qyx)call CRx(OSx,QUx(rlx))call rZx(OSx,QYx,0)call rZx(OSx,L6+(c6[((K6[(rlx)]))]),rYx)
if(rYx<(m6[(rlx)]))thencall rZx(OSx,QUx(rlx),rYx+1)
else
call CRx(OSx,QUx(rlx))endifendfunctionfunction Qzx takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(Mv[(rFx)])local integer rlx=(nv[(rFx)])local integer OSx=(Vv[(rFx)])call QWx(rYx,rlx,OSx)return trueendfunctionfunction QZx takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(Mv[(rFx)])local integer rlx=(nv[(rFx)])local integer OSx=(Vv[(rFx)])call QWx(rYx,rlx,OSx)return trueendfunctionfunction Q_x takes nothing returns booleanlocal integer rFx=(bv)local integer rlx=(nv[(rFx)])local integer OSx=(Vv[(rFx)])call QWx(0,rlx,OSx)return trueendfunctionfunction Q0x takes integer oSx,integer Q1x,boolean iTx returns nothinglocal integer oMxif(oSx==Ge)thenset oMx=Jhloop
call Q0x(kh[oMx],Q1x,iTx)set oMx=oMx-1exitwhen(oMx<0)endloopelse
call SetPlayerAbilityAvailable(vx[oSx],Q1x,iTx)endifendfunctionfunction Q2x takes nothing returns integerlocal unit oqx=GetTriggerUnit()local integer o7xif(GetUnitAbilityLevel(oqx,'aLoc')>0)thenset oqx=null
return Z
endifset o7x=adx(oqx)
set oqx=null
return o7xendfunctionfunction Q3x takes nothing returns booleanlocal integer Q4x=GetLearnedSkill()local integer rYx=GetLearnedSkillLevel()
local integer OSx=Q2x()local integer rlx=(LoadInteger(o[((V[(E[((X))])]))],(((Q4x))),(((Q6)))))
call r0x(OSx,rlx,rYx)return trueendfunctionfunction Q5x takes integer oSx,integer oDx,playerunitevent Q6x,code Q7x returns nothinglocal integer oMxif(oDx==Ge)thenset oMx=Jhloop
call Q5x(oSx,kh[oMx],Q6x,Q7x)set oMx=oMx-1exitwhen(oMx<0)endloopendifcall TriggerRegisterPlayerUnitEvent(DA[(oSx)],vx[oDx],Q6x,Condition(Q7x))endfunctionfunction Q8x takes nothing returns nothinglocal integer oMx=j6-1set J6=Xdx("HeroSpell_Init: set HeroSpell.LEARN_EVENT = Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.HEADER, function HeroSpell.Event_Learn)",pv,bI,function Qzx)set M6=Xdx("HeroSpell_Init: set HeroSpell.LEVEL_CHANGE_EVENT = Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.HEADER, function HeroSpell.Event_LevelChange)",Pv,bI,function QZx)set p6=Xdx("HeroSpell_Init: set HeroSpell.SPELL_REMOVE_EVENT = Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.HEADER, function HeroSpell.Event_SpellRemove)",Av,bI,function Q_x)
loop
exitwhen(oMx<0)call Q0x(Ge,L6+oMx,false)set oMx=oMx-1endloopset P6=XJx(function Q3x)
call Q5x(P6,Ge,EVENT_PLAYER_HERO_SKILL,null)
endfunctionfunction Q9x takes nothing returns booleancall QTx()call Q8x()return trueendfunctionfunction svx takes nothing returns booleancall Hix(function Q9x,"Spell_Init")return trueendfunctionfunction sex takes nothing returns booleanset s6=VXx(S6)return trueendfunctionfunction sxx takes nothing returns booleanset nH=VXx(eH)return trueendfunctionfunction sox takes nothing returns booleanset t6=VXx(T6)return trueendfunctionfunction srx takes nothing returns booleanset u6=VXx(U6)return trueendfunctionfunction six takes nothing returns booleanset w6=VXx(W6)return trueendfunctionfunction sax takes nothing returns booleanset y6=VXx(Y6)return trueendfunctionfunction snx takes integer oSx returns integerset x7[oSx]=true
set o7[oSx]=falsecall rEx(y6)
return oSxendfunctionfunction sVx takes nothing returns integerlocal integer oSxif(z6==8190)then
call o_x("Spot_Allocation_allocCustom","call DebugEx(Spot.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Y6+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Z6[(w)]==w)thenset v7=v7+1set oSx=v7else
set oSx=Z6[(w)]set Z6[(w)]=Z6[Z6[(w)]]endifset Z6[oSx]=Zset e7[oSx]=1call snx(oSx)return oSxendfunctionfunction sEx takes location oqx returns integerlocal integer oSx=sVx()set aN[oSx]=oqxreturn oSxendfunctionfunction sXx takes nothing returns booleanset nN=(sEx(Location(((.0)*1.),((.0)*1.))))set r7=O5x()
set i7=iXx()
return trueendfunctionfunction sOx takes nothing returns booleancall Fzx(function sXx,"Spot_Init")return trueendfunctionfunction sRx takes nothing returns booleanset a7=VXx(n7)return trueendfunctionfunction sIx takes nothing returns booleanset V7=VXx(E7)return trueendfunctionfunction sAx takes nothing returns booleanset X7=VXx(O7)return trueendfunctionfunction sNx takes nothing returns booleanset R7=VXx(I7)return trueendfunctionfunction sbx takes nothing returns booleanset A7=VXx(N7)return trueendfunctionfunction sBx takes nothing returns booleanset b7=VXx(B7)return trueendfunctionfunction scx takes nothing returns booleanreturn trueendfunctionfunction sCx takes nothing returns booleancall VFx(function scx,"StringData_Init")
return trueendfunctionfunction sdx takes code c,string rSx returns nothing
call VNx(Ka,c,rSx)endfunctionfunction sDx takes integer oSx returns integerset g7[oSx]=true
set G7[oSx]=falsecall rEx(h7)
return oSxendfunctionfunction sFx takes nothing returns integerlocal integer oSxif(C7==8190)then
call o_x("TileType_Allocation_allocCustom","call DebugEx(TileType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",d7+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(D7[(w)]==w)thenset f7=f7+1set oSx=f7else
set oSx=D7[(w)]set D7[(w)]=D7[D7[(w)]]endifset D7[oSx]=Zset F7[oSx]=1call sDx(oSx)return oSxendfunctionfunction sgx takes integer oqx returns integerlocal integer oSx=sFx()set H7[oSx]=oqxcall SaveInteger(o[((V[(E[((X))])]))],(((oqx))),(((J7))),(((oSx))))return oSxendfunctionfunction sGx takes nothing returns booleanset c7=sgx('Iice')return trueendfunctionfunction shx takes nothing returns booleanset k7=sgx('Ibsq')return trueendfunctionfunction sHx takes nothing returns booleanset K7=sgx('Idtr')return trueendfunctionfunction sjx takes nothing returns booleanset l7=sgx('Ibkb')return trueendfunctionfunction sJx takes nothing returns booleanset L7=sgx('cIc1')return trueendfunctionfunction skx takes nothing returns booleanset m7=sgx('cIc2')return trueendfunctionfunction sKx takes nothing returns booleanset M7=sgx('Itbk')return trueendfunctionfunction slx takes nothing returns booleanset p7=sgx('Isnw')return trueendfunctionfunction sLx takes nothing returns booleanset P7=sgx('Idrt')return trueendfunctionfunction smx takes nothing returns booleanset q7=sgx('Idki')return trueendfunctionfunction sMx takes nothing returns booleanset Q7=sgx('Ggrs')return trueendfunctionfunction spx takes nothing returns booleanset s7=sgx('Irbk')return trueendfunctionfunction sPx takes nothing returns booleanset S7=sgx('Jgsb')return trueendfunctionfunction sqx takes nothing returns booleancall sdx(function sGx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_ice_wc3tile.j")call sdx(function shx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_blackSquares_wc3tile.j")call sdx(function sHx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_dirtRough_wc3tile.j")
call sdx(function sjx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_blackBricks_wc3tile.j")call sdx(function sJx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_snowCliff_wc3tile.j")
call sdx(function skx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_runedBricksCliff_wc3tile.j")call sdx(function sKx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_tiledBricks_wc3tile.j")call sdx(function slx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_snow_wc3tile.j")call sdx(function sLx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_dirt_wc3tile.j")call sdx(function smx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_darkIce_wc3tile.j")call sdx(function sMx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_greyStones_wc3tile.j")call sdx(function spx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_runeBricks_wc3tile.j")call sdx(function sPx,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\TileType.struct\\obj_grass_wc3tile.j")
return trueendfunctionfunction sQx takes nothing returns booleanset h7=VXx(d7)return trueendfunctionfunction ssx takes nothing returns booleanreturn trueendfunctionfunction sSx takes nothing returns booleancall GDx(function ssx,"TileType_Init")return trueendfunctionfunction stx takes nothing returns booleanset t7=VXx(T7)return trueendfunctionfunction sTx takes nothing returns booleanset u7=VXx(U7)return trueendfunctionfunction sux takes nothing returns booleanset w7=V5x()
return trueendfunctionfunction sUx takes nothing returns booleancall GDx(function sux,"Tile_Init")return trueendfunctionfunction swx takes nothing returns booleanset W7=VXx(y7)return trueendfunctionfunction sWx takes nothing returns booleanset Y7=VXx(z7)return trueendfunctionfunction syx takes nothing returns booleanreturn trueendfunctionfunction sYx takes nothing returns booleancall GDx(function syx,"TileTypeMod_Init")return trueendfunctionfunction szx takes code c,string rSx returns nothing
call VNx(Ja,c,rSx)endfunctionfunction sZx takes integer oSx returns integerset i8[oSx]=true
set a8[oSx]=falsecall rEx(n8)
return oSxendfunctionfunction s_x takes nothing returns integerlocal integer oSxif(v8==8190)then
call o_x("UbersplatType_Allocation_allocCustom","call DebugEx(UbersplatType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",e8+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(x8[(w)]==w)thenset o8=o8+1set oSx=o8else
set oSx=x8[(w)]set x8[(w)]=x8[x8[(w)]]endifset x8[oSx]=Zset r8[oSx]=1call sZx(oSx)return oSxendfunctionfunction s0x takes string oqx returns integerlocal integer oSx=s_x()set V8[oSx]=oqxreturn oSxendfunctionfunction s1x takes nothing returns booleanset Z7=s0x("pSnw")return trueendfunctionfunction s2x takes nothing returns booleancall szx(function s1x,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Terrain.page\\UbersplatType.struct\\obj_snow_wc3ubersplat.j")return trueendfunctionfunction s3x takes nothing returns booleanset n8=VXx(e8)return trueendfunctionfunction s4x takes nothing returns booleanset E8=VXx(X8)return trueendfunctionfunction s5x takes nothing returns booleanset O8=VXx(R8)return trueendfunctionfunction s6x takes nothing returns booleanset I8=VXx(A8)return trueendfunctionfunction s7x takes nothing returns booleanset N8=VXx(b8)return trueendfunctionfunction s8x takes nothing returns booleanset B8=VXx(c8)return trueendfunctionfunction s9x takes nothing returns booleanset C8=VXx(d8)return trueendfunctionfunction Svx takes nothing returns booleanset D8=VXx(f8)return trueendfunctionfunction Sex takes nothing returns booleanset F8=VXx(g8)return trueendfunctionfunction Sxx takes nothing returns booleanset G8=VXx(h8)return trueendfunctionfunction Sox takes nothing returns booleanset H8=VXx(j8)return trueendfunctionfunction Srx takes nothing returns booleanset J8=VXx(k8)return trueendfunctionfunction Six takes nothing returns booleanset K8=VXx(l8)return trueendfunctionfunction Sax takes nothing returns booleanset L8=VXx(m8)return trueendfunctionfunction Snx takes nothing returns booleanset M8=VXx(p8)return trueendfunctionfunction SVx takes nothing returns booleanset P8=VXx(q8)return trueendfunctionfunction SEx takes nothing returns booleanset Q8=VXx(s8)return trueendfunctionfunction SXx takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((u8[(oSx)]))])]))],((((U8[((oSx))])))),(((otx))))))endfunctionfunction SOx takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((u8[(oSx)]))])]))],((((U8[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction SRx takes integer oSx returns nothingset z8[oSx]=falsecall rHx(J8)
endfunctionfunction SIx takes integer oSx returns nothingif(y8[oSx]>0)thenreturnendifif(Y8[oSx]!=Z)thencall o_x("FolderUbersplat_FolderColor_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderUbersplat_FolderColor_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",k8+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Y8[oSx]=Y8[(w)]set Y8[(w)]=oSxcall SRx(oSx)endfunctionfunction SAx takes integer oSx returns nothingset y8[oSx]=y8[oSx]-1call SIx(oSx)endfunctionfunction SNx takes integer oSx,integer otx,integer oux returns booleanreturn rrx(u8[(oSx)],(U8[((oSx))]),otx,oux)endfunctionfunction Sbx takes integer oSx,integer XYx returns nothingif not((LoadInteger(o[((D[((Z8[oSx]))]))],((((U8[((oSx))])))),(oTx((((oA[(XYx)]))),(((XYx)))))))!=0)then
call o_x("FolderUbersplat_StructEvent_Remove","call DebugEx(\"subject \"+I2S(Ubersplat(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((U8[((oSx))]))+" has not "+(jA[(XYx)]))returnendifcall rrx(Z8[oSx],(U8[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction SBx takes integer oSx returns booleanlocal integer oLx=(vvv[(oSx)])set vvv[vev[vxv]]=oLxset vev[oLx-1]=vev[vxv]set vvv[oSx]=0set vxv=vxv-1return(vxv==F)endfunctionfunction Scx takes integer oSx,integer iCx,integer rLx returns nothingcall SAx((oSx))call iKx(iCx)call SNx(rLx,W8,oSx)
call Sbx(rLx,t8)
if SBx(oSx)thencall ikx(vov)endifendfunctionfunction SCx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(T8[(rFx)])local integer oMx=SXx(rLx,W8)local integer oSxif(oMx>0)thenloop
set oSx=SOx(rLx,W8,oMx)call Scx(oSx,vrv[oSx],rLx)set oMx=oMx-1exitwhen(oMx<q)endloopendifreturn trueendfunctionfunction Sdx takes nothing returns nothingset t8=Xdx("FolderUbersplat_FolderColor_StructTimed_Init: set FolderUbersplat_FolderColor_StructTimed.DESTROY_EVENT = Event.Create(Ubersplat.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUbersplat_FolderColor_StructTimed.Event_Destroy)",S8,bI,function SCx)set vov=iXx()endfunctionfunction SDx takes nothing returns booleanset S8=(E3x())call Sdx()return trueendfunctionfunction Sfx takes nothing returns booleancall GDx(function SDx,"Ubersplat_Init")return trueendfunctionfunction SFx takes nothing returns booleanset viv=VXx(vav)
return trueendfunctionfunction Sgx takes nothing returns booleanset vnv=VXx(vVv)
return trueendfunctionfunction SGx takes nothing returns booleanset vEv=VXx(vXv)
return trueendfunctionfunction Shx takes nothing returns booleanset vOv=VXx(vRv)
return trueendfunctionfunction SHx takes nothing returns booleanset vIv=VXx(vAv)
return trueendfunctionfunction Sjx takes nothing returns booleanset vNv=VXx(vbv)
return trueendfunctionfunction SJx takes nothing returns booleanset vBv=VXx(vcv)
return trueendfunctionfunction Skx takes nothing returns booleanset cN=VXx(RN)return trueendfunctionfunction SKx takes nothing returns booleanset MN=iXx()
set SN=iXx()
set kN=iXx()
set wN=iXx()
return trueendfunctionfunction Slx takes nothing returns booleancall Fzx(function SKx,"TextTag_Init")return trueendfunctionfunction SLx takes nothing returns booleanset vCv=VXx(vdv)
return trueendfunctionfunction Smx takes nothing returns booleanset vDv=VXx(vfv)
return trueendfunctionfunction SMx takes nothing returns booleanset vFv=VXx(vgv)
return trueendfunctionfunction Spx takes nothing returns booleanset vGv=VXx(vhv)
return trueendfunctionfunction SPx takes nothing returns booleanset vHv=VXx(vjv)
return trueendfunctionfunction Sqx takes nothing returns booleanset vJv=VXx(vkv)
return trueendfunctionfunction SQx takes nothing returns booleanset vKv=VXx(vlv)
return trueendfunctionfunction Ssx takes nothing returns booleanset vLv=VXx(vmv)
return trueendfunctionfunction SSx takes nothing returns booleanset vMv=VXx(vpv)
return trueendfunctionfunction Stx takes nothing returns booleanset vPv=VXx(vqv)
return trueendfunctionfunction STx takes nothing returns booleanset Xe=VXx(ee)return trueendfunctionfunction Sux takes nothing returns nothingendfunctionfunction SUx takes nothing returns nothingendfunctionfunction Swx takes nothing returns booleancall Sux()call SUx()return trueendfunctionfunction SWx takes nothing returns booleancall Fzx(function Swx,"Timer_Init")return trueendfunctionfunction Syx takes nothing returns booleanset vQv=VXx(vsv)
return trueendfunctionfunction SYx takes nothing returns booleanset vSv=VXx(vtv)
return trueendfunctionfunction Szx takes nothing returns booleanset vTv=VXx(vuv)
return trueendfunctionfunction SZx takes nothing returns booleanset vUv=VXx(vwv)
return trueendfunctionfunction S_x takes nothing returns booleanset vWv=VXx(vyv)
return trueendfunctionfunction S0x takes nothing returns booleanset vYv=VXx(vzv)
return trueendfunctionfunction S1x takes nothing returns booleanset vZv=VXx(v_v)
return trueendfunctionfunction S2x takes nothing returns booleanset v0v=VXx(v1v)
return trueendfunctionfunction S3x takes nothing returns booleanset CA=VXx(Dv)return trueendfunctionfunction S4x takes trigger oqx returns integerreturn(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((oqx))))),((((FA))))))endfunctionfunction S5x takes nothing returns nothinglocal integer oSx=(S4x(GetTriggeringTrigger()))if(dA[oSx]!=null)thenif not TriggerEvaluate(dA[oSx])thenreturnendifendifcall rDx(oSx)endfunctionfunction S6x takes nothing returns booleanset pA=V5x()
set HA=Condition(function S5x)return trueendfunctionfunction S7x takes nothing returns booleancall Fzx(function S6x,"Trigger_Init")return trueendfunctionfunction S8x takes nothing returns booleanset v2v[4]='Ada4'call L1x('Ada4',false)return trueendfunctionfunction S9x takes nothing returns booleanset v3v[5]='Aia5'call L1x('Aia5',false)return trueendfunctionfunction tvx takes nothing returns booleanset v2v[0]='Ada0'call L1x('Ada0',false)return trueendfunctionfunction tex takes nothing returns booleanset v2v[6]='Ada6'call L1x('Ada6',false)return trueendfunctionfunction txx takes nothing returns booleanset v2v[5]='Ada5'call L1x('Ada5',false)return trueendfunctionfunction tox takes nothing returns booleanset v3v[2]='Aia2'call L1x('Aia2',false)return trueendfunctionfunction trx takes nothing returns booleanset v3v[0]='Aia0'call L1x('Aia0',false)return trueendfunctionfunction tix takes nothing returns booleanset v2v[2]='Ada2'call L1x('Ada2',false)return trueendfunctionfunction tax takes nothing returns booleanset v3v[4]='Aia4'call L1x('Aia4',false)return trueendfunctionfunction tnx takes nothing returns booleanset v4v[0]=1
set v4v[1]=2
set v4v[2]=4
set v4v[3]=8
set v4v[4]=16set v4v[5]=32set v4v[6]=64return trueendfunctionfunction tVx takes nothing returns booleanset v3v[6]='Aia6'call L1x('Aia6',false)return trueendfunctionfunction tEx takes nothing returns booleanset v3v[3]='Aia3'call L1x('Aia3',false)return trueendfunctionfunction tXx takes nothing returns booleanset v3v[1]='Aia1'call L1x('Aia1',false)return trueendfunctionfunction tOx takes nothing returns booleanset v2v[3]='Ada3'call L1x('Ada3',false)return trueendfunctionfunction tRx takes nothing returns booleanset v2v[1]='Ada1'call L1x('Ada1',false)return trueendfunctionfunction tIx takes nothing returns booleancall VNx(Pa,(function S8x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_decreasingSpells[4]_wc3spell.j"))call VNx(Pa,(function S9x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_increasingSpells[5]_wc3spell.j"))call VNx(Pa,(function tvx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_decreasingSpells[0]_wc3spell.j"))call VNx(Pa,(function tex),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_decreasingSpells[6]_wc3spell.j"))call VNx(Pa,(function txx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_decreasingSpells[5]_wc3spell.j"))call VNx(Pa,(function tox),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_increasingSpells[2]_wc3spell.j"))call VNx(Pa,(function trx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_increasingSpells[0]_wc3spell.j"))call VNx(Pa,(function tix),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_decreasingSpells[2]_wc3spell.j"))call VNx(Pa,(function tax),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_increasingSpells[4]_wc3spell.j"))call VNx(va,(function tnx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_this_wc3obj.j"))call VNx(Pa,(function tVx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_increasingSpells[6]_wc3spell.j"))call VNx(Pa,(function tEx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_increasingSpells[3]_wc3spell.j"))call VNx(Pa,(function tXx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_increasingSpells[1]_wc3spell.j"))call VNx(Pa,(function tOx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_decreasingSpells[3]_wc3spell.j"))call VNx(Pa,(function tRx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Armor\\Bonus\\obj_decreasingSpells[1]_wc3spell.j"))return trueendfunctionfunction tAx takes nothing returns booleanset v5v=VXx(v6v)
return trueendfunctionfunction tNx takes nothing returns booleanset v7v=VXx(v8v)
return trueendfunctionfunction tbx takes nothing returns booleanset v9v[2]='AiR2'call L1x('AiR2',false)return trueendfunctionfunction tBx takes nothing returns booleanset v9v[6]='AiR6'call L1x('AiR6',false)return trueendfunctionfunction tcx takes nothing returns booleanset evv[1]='AdR1'call L1x('AdR1',false)return trueendfunctionfunction tCx takes nothing returns booleanset v9v[1]='AiR1'call L1x('AiR1',false)return trueendfunctionfunction tdx takes nothing returns booleanset evv[3]='AdR3'call L1x('AdR3',false)return trueendfunctionfunction tDx takes nothing returns booleanset v9v[8]='AiR8'call L1x('AiR8',false)return trueendfunctionfunction tfx takes nothing returns booleanset evv[6]='AdR6'call L1x('AdR6',false)return trueendfunctionfunction tFx takes nothing returns booleanset evv[0]='AdR0'call L1x('AdR0',false)return trueendfunctionfunction tgx takes nothing returns booleanset evv[4]='AdR4'call L1x('AdR4',false)return trueendfunctionfunction tGx takes nothing returns booleanset v9v[0]='AiR0'call L1x('AiR0',false)return trueendfunctionfunction thx takes nothing returns booleanset v9v[5]='AiR5'call L1x('AiR5',false)return trueendfunctionfunction tHx takes nothing returns booleanset v9v[7]='AiR7'call L1x('AiR7',false)return trueendfunctionfunction tjx takes nothing returns booleanset evv[2]='AdR2'call L1x('AdR2',false)return trueendfunctionfunction tJx takes nothing returns booleanset evv[8]='AdR8'call L1x('AdR8',false)return trueendfunctionfunction tkx takes nothing returns booleanset evv[9]='AdR9'call L1x('AdR9',false)return trueendfunctionfunction tKx takes nothing returns booleanset v9v[4]='AiR4'call L1x('AiR4',false)return trueendfunctionfunction tlx takes nothing returns booleanset evv[7]='AdR7'call L1x('AdR7',false)return trueendfunctionfunction tLx takes nothing returns booleanset eev[0]=1
set eev[1]=2
set eev[2]=4
set eev[3]=8
set eev[4]=16set eev[5]=32set eev[6]=64set eev[7]=$80set eev[8]=256set eev[9]=512return trueendfunctionfunction tmx takes nothing returns booleanset evv[5]='AdR5'call L1x('AdR5',false)return trueendfunctionfunction tMx takes nothing returns booleanset v9v[9]='AiR9'call L1x('AiR9',false)return trueendfunctionfunction tpx takes nothing returns booleanset v9v[3]='AiR3'call L1x('AiR3',false)return trueendfunctionfunction tPx takes nothing returns booleancall VNx(Pa,(function tbx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[2]_wc3spell.j"))
call VNx(Pa,(function tBx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[6]_wc3spell.j"))
call VNx(Pa,(function tcx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[1]_wc3spell.j"))
call VNx(Pa,(function tCx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[1]_wc3spell.j"))
call VNx(Pa,(function tdx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[3]_wc3spell.j"))
call VNx(Pa,(function tDx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[8]_wc3spell.j"))
call VNx(Pa,(function tfx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[6]_wc3spell.j"))
call VNx(Pa,(function tFx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[0]_wc3spell.j"))
call VNx(Pa,(function tgx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[4]_wc3spell.j"))
call VNx(Pa,(function tGx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[0]_wc3spell.j"))
call VNx(Pa,(function thx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[5]_wc3spell.j"))
call VNx(Pa,(function tHx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[7]_wc3spell.j"))
call VNx(Pa,(function tjx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[2]_wc3spell.j"))
call VNx(Pa,(function tJx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[8]_wc3spell.j"))
call VNx(Pa,(function tkx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[9]_wc3spell.j"))
call VNx(Pa,(function tKx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[4]_wc3spell.j"))
call VNx(Pa,(function tlx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[7]_wc3spell.j"))
call VNx(va,(function tLx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_this_wc3obj.j"))call VNx(Pa,(function tmx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_decreasingSpells[5]_wc3spell.j"))
call VNx(Pa,(function tMx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[9]_wc3spell.j"))
call VNx(Pa,(function tpx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\Speed\\BonusA\\obj_increasingSpells[3]_wc3spell.j"))
return trueendfunctionfunction tqx takes nothing returns booleanset exv=VXx(eov)
return trueendfunctionfunction tQx takes nothing returns booleanset erv=VXx(eiv)
return trueendfunctionfunction tsx takes nothing returns booleancall L1x('Aatk',false)return trueendfunctionfunction tSx takes nothing returns booleancall VNx(Pa,(function tsx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Attack\\obj_attack_wc3spell.j"))
return trueendfunctionfunction ttx takes nothing returns booleanset eav=VXx(env)
return trueendfunctionfunction tTx takes nothing returns booleanset Qg[2]='AdD2'
call L1x('AdD2',false)return trueendfunctionfunction tux takes nothing returns booleanset Sg[5]='AiD5'
call L1x('AiD5',false)return trueendfunctionfunction tUx takes nothing returns booleanset Sg[6]='AiD6'
call L1x('AiD6',false)return trueendfunctionfunction twx takes nothing returns booleanset Sg[2]='AiD2'
call L1x('AiD2',false)return trueendfunctionfunction tWx takes nothing returns booleanset Qg[3]='AdD3'
call L1x('AdD3',false)return trueendfunctionfunction tyx takes nothing returns booleanset Sg[4]='AiD4'
call L1x('AiD4',false)return trueendfunctionfunction tYx takes nothing returns booleanset Qg[5]='AdD5'
call L1x('AdD5',false)return trueendfunctionfunction tzx takes nothing returns booleanset Qg[4]='AdD4'
call L1x('AdD4',false)return trueendfunctionfunction tZx takes nothing returns booleanset Sg[3]='AiD3'
call L1x('AiD3',false)return trueendfunctionfunction t_x takes nothing returns booleanset Sg[0]='AiD0'
call L1x('AiD0',false)return trueendfunctionfunction t0x takes nothing returns booleanset tg[0]=1set tg[1]=2set tg[2]=4set tg[3]=8set tg[4]=16
set tg[5]=32
set tg[6]=64
return trueendfunctionfunction t1x takes nothing returns booleanset Qg[1]='AdD1'
call L1x('AdD1',false)return trueendfunctionfunction t2x takes nothing returns booleanset Qg[6]='AdD6'
call L1x('AdD6',false)return trueendfunctionfunction t3x takes nothing returns booleanset Sg[1]='AiD1'
call L1x('AiD1',false)return trueendfunctionfunction t4x takes nothing returns booleanset Qg[0]='AdD0'
call L1x('AdD0',false)return trueendfunctionfunction t5x takes nothing returns booleancall VNx(Pa,(function tTx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_decreasingSpells[2]_wc3spell.j"))
call VNx(Pa,(function tux),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_increasingSpells[5]_wc3spell.j"))
call VNx(Pa,(function tUx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_increasingSpells[6]_wc3spell.j"))
call VNx(Pa,(function twx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_increasingSpells[2]_wc3spell.j"))
call VNx(Pa,(function tWx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_decreasingSpells[3]_wc3spell.j"))
call VNx(Pa,(function tyx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_increasingSpells[4]_wc3spell.j"))
call VNx(Pa,(function tYx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_decreasingSpells[5]_wc3spell.j"))
call VNx(Pa,(function tzx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_decreasingSpells[4]_wc3spell.j"))
call VNx(Pa,(function tZx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_increasingSpells[3]_wc3spell.j"))
call VNx(Pa,(function t_x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_increasingSpells[0]_wc3spell.j"))
call VNx(va,(function t0x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_this_wc3obj.j"))call VNx(Pa,(function t1x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_decreasingSpells[1]_wc3spell.j"))
call VNx(Pa,(function t2x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_decreasingSpells[6]_wc3spell.j"))
call VNx(Pa,(function t3x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_increasingSpells[1]_wc3spell.j"))
call VNx(Pa,(function t4x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\Bonus\\obj_decreasingSpells[0]_wc3spell.j"))
return trueendfunctionfunction t6x takes nothing returns booleanset eVv=VXx(eEv)
return trueendfunctionfunction t7x takes nothing returns booleanset eXv[0]='Adz0'call L1x('Adz0',false)return trueendfunctionfunction t8x takes nothing returns booleanset eOv[6]='Aiz6'call L1x('Aiz6',false)return trueendfunctionfunction t9x takes nothing returns booleanset eOv[2]='Aiz2'call L1x('Aiz2',false)return trueendfunctionfunction Tvx takes nothing returns booleanset eOv[0]='Aiz0'call L1x('Aiz0',false)return trueendfunctionfunction Tex takes nothing returns booleanset eOv[5]='Aiz5'call L1x('Aiz5',false)return trueendfunctionfunction Txx takes nothing returns booleanset eOv[1]='Aiz1'call L1x('Aiz1',false)return trueendfunctionfunction Tox takes nothing returns booleanset eXv[2]='Adz2'call L1x('Adz2',false)return trueendfunctionfunction Trx takes nothing returns booleanset eXv[3]='Adz3'call L1x('Adz3',false)return trueendfunctionfunction Tix takes nothing returns booleanset eXv[4]='Adz4'call L1x('Adz4',false)return trueendfunctionfunction Tax takes nothing returns booleanset eXv[7]='Adz7'call L1x('Adz7',false)return trueendfunctionfunction Tnx takes nothing returns booleanset eRv[0]='Iid0'return trueendfunctionfunction TVx takes nothing returns booleanset eOv[7]='Aiz7'call L1x('Aiz7',false)return trueendfunctionfunction TEx takes nothing returns booleanset eOv[4]='Aiz4'call L1x('Aiz4',false)return trueendfunctionfunction TXx takes nothing returns booleanset eXv[5]='Adz5'call L1x('Adz5',false)return trueendfunctionfunction TOx takes nothing returns booleanset eXv[6]='Adz6'call L1x('Adz6',false)return trueendfunctionfunction TRx takes nothing returns booleanset eIv[0]='Idd0'return trueendfunctionfunction TIx takes nothing returns booleanset eIv[2]='Idd2'return trueendfunctionfunction TAx takes nothing returns booleanset eIv[7]='Idd7'return trueendfunctionfunction TNx takes nothing returns booleanset eIv[3]='Idd3'return trueendfunctionfunction Tbx takes nothing returns booleanset eOv[3]='Aiz3'call L1x('Aiz3',false)return trueendfunctionfunction TBx takes nothing returns booleanset eIv[4]='Idd4'return trueendfunctionfunction Tcx takes nothing returns booleanset eRv[1]='Iid1'return trueendfunctionfunction TCx takes nothing returns booleanset eIv[6]='Idd6'return trueendfunctionfunction Tdx takes nothing returns booleanset eRv[2]='Iid2'return trueendfunctionfunction TDx takes nothing returns booleanset eRv[3]='Iid3'return trueendfunctionfunction Tfx takes nothing returns booleanset gg[0]=1set gg[1]=2set gg[2]=4set gg[3]=8set gg[4]=16
set gg[5]=32
set gg[6]=64
set gg[7]=$80return trueendfunctionfunction TFx takes nothing returns booleanset eRv[5]='Iid5'return trueendfunctionfunction Tgx takes nothing returns booleanset eRv[6]='Iid6'return trueendfunctionfunction TGx takes nothing returns booleanset eRv[7]='Iid7'return trueendfunctionfunction Thx takes nothing returns booleanset eRv[4]='Iid4'return trueendfunctionfunction THx takes nothing returns booleanset eIv[5]='Idd5'return trueendfunctionfunction Tjx takes nothing returns booleanset eIv[1]='Idd1'return trueendfunctionfunction TJx takes nothing returns booleanset eXv[1]='Adz1'call L1x('Adz1',false)return trueendfunctionfunction Tkx takes nothing returns booleancall VNx(Pa,(function t7x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingSpells[0]_wc3spell.j"))call VNx(Pa,(function t8x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingSpells[6]_wc3spell.j"))call VNx(Pa,(function t9x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingSpells[2]_wc3spell.j"))call VNx(Pa,(function Tvx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingSpells[0]_wc3spell.j"))call VNx(Pa,(function Tex),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingSpells[5]_wc3spell.j"))call VNx(Pa,(function Txx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingSpells[1]_wc3spell.j"))call VNx(Pa,(function Tox),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingSpells[2]_wc3spell.j"))call VNx(Pa,(function Trx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingSpells[3]_wc3spell.j"))call VNx(Pa,(function Tix),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingSpells[4]_wc3spell.j"))call VNx(Pa,(function Tax),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingSpells[7]_wc3spell.j"))call VNx(Qa,(function Tnx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingItemTypes[0]_wc3item.j"))call VNx(Pa,(function TVx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingSpells[7]_wc3spell.j"))call VNx(Pa,(function TEx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingSpells[4]_wc3spell.j"))call VNx(Pa,(function TXx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingSpells[5]_wc3spell.j"))call VNx(Pa,(function TOx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingSpells[6]_wc3spell.j"))call VNx(Qa,(function TRx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingItemTypes[0]_wc3item.j"))call VNx(Qa,(function TIx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingItemTypes[2]_wc3item.j"))call VNx(Qa,(function TAx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingItemTypes[7]_wc3item.j"))call VNx(Qa,(function TNx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingItemTypes[3]_wc3item.j"))call VNx(Pa,(function Tbx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingSpells[3]_wc3spell.j"))call VNx(Qa,(function TBx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingItemTypes[4]_wc3item.j"))call VNx(Qa,(function Tcx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingItemTypes[1]_wc3item.j"))call VNx(Qa,(function TCx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingItemTypes[6]_wc3item.j"))call VNx(Qa,(function Tdx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingItemTypes[2]_wc3item.j"))call VNx(Qa,(function TDx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingItemTypes[3]_wc3item.j"))call VNx(va,(function Tfx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_this_wc3obj.j"))
call VNx(Qa,(function TFx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingItemTypes[5]_wc3item.j"))call VNx(Qa,(function Tgx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingItemTypes[6]_wc3item.j"))call VNx(Qa,(function TGx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingItemTypes[7]_wc3item.j"))call VNx(Qa,(function Thx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_increasingItemTypes[4]_wc3item.j"))call VNx(Qa,(function THx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingItemTypes[5]_wc3item.j"))call VNx(Qa,(function Tjx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingItemTypes[1]_wc3item.j"))call VNx(Pa,(function TJx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Damage\\obj_decreasingSpells[1]_wc3spell.j"))return trueendfunctionfunction TKx takes nothing returns booleanset eAv=VXx(eNv)
return trueendfunctionfunction Tlx takes nothing returns booleancall L1x('Amov',false)return trueendfunctionfunction TLx takes nothing returns booleancall VNx(Pa,(function Tlx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Movement\\obj_move_wc3spell.j"))
return trueendfunctionfunction Tmx takes nothing returns booleanset ebv=VXx(eBv)
return trueendfunctionfunction TMx takes nothing returns booleanset bF[0]='AiG0'
call L1x('AiG0',false)return trueendfunctionfunction Tpx takes nothing returns booleanset AF[3]='AdG3'
call L1x('AdG3',false)return trueendfunctionfunction TPx takes nothing returns booleanset AF[1]='AdG1'
call L1x('AdG1',false)return trueendfunctionfunction Tqx takes nothing returns booleanset bF[5]='AiG5'
call L1x('AiG5',false)return trueendfunctionfunction TQx takes nothing returns booleanset AF[2]='AdG2'
call L1x('AdG2',false)return trueendfunctionfunction Tsx takes nothing returns booleanset AF[5]='AdG5'
call L1x('AdG5',false)return trueendfunctionfunction TSx takes nothing returns booleanset bF[2]='AiG2'
call L1x('AiG2',false)return trueendfunctionfunction Ttx takes nothing returns booleanset bF[4]='AiG4'
call L1x('AiG4',false)return trueendfunctionfunction TTx takes nothing returns booleanset AF[4]='AdG4'
call L1x('AdG4',false)return trueendfunctionfunction Tux takes nothing returns booleanset BF[0]=1set BF[1]=2set BF[2]=4set BF[3]=8set BF[4]=16
set BF[5]=32
set BF[6]=64
return trueendfunctionfunction TUx takes nothing returns booleanset bF[6]='AiG6'
call L1x('AiG6',false)return trueendfunctionfunction Twx takes nothing returns booleanset bF[1]='AiG1'
call L1x('AiG1',false)return trueendfunctionfunction TWx takes nothing returns booleanset AF[0]='AdG0'
call L1x('AdG0',false)return trueendfunctionfunction Tyx takes nothing returns booleanset AF[6]='AdG6'
call L1x('AdG6',false)return trueendfunctionfunction TYx takes nothing returns booleanset bF[3]='AiG3'
call L1x('AiG3',false)return trueendfunctionfunction Tzx takes nothing returns booleancall VNx(Pa,(function TMx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_increasingSpells[0]_wc3spell.j"))
call VNx(Pa,(function Tpx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_decreasingSpells[3]_wc3spell.j"))
call VNx(Pa,(function TPx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_decreasingSpells[1]_wc3spell.j"))
call VNx(Pa,(function Tqx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_increasingSpells[5]_wc3spell.j"))
call VNx(Pa,(function TQx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_decreasingSpells[2]_wc3spell.j"))
call VNx(Pa,(function Tsx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_decreasingSpells[5]_wc3spell.j"))
call VNx(Pa,(function TSx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_increasingSpells[2]_wc3spell.j"))
call VNx(Pa,(function Ttx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_increasingSpells[4]_wc3spell.j"))
call VNx(Pa,(function TTx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_decreasingSpells[4]_wc3spell.j"))
call VNx(va,(function Tux),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_this_wc3obj.j"))call VNx(Pa,(function TUx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_increasingSpells[6]_wc3spell.j"))
call VNx(Pa,(function Twx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_increasingSpells[1]_wc3spell.j"))
call VNx(Pa,(function TWx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_decreasingSpells[0]_wc3spell.j"))
call VNx(Pa,(function Tyx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_decreasingSpells[6]_wc3spell.j"))
call VNx(Pa,(function TYx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Agility\\BonusA\\obj_increasingSpells[3]_wc3spell.j"))
return trueendfunctionfunction TZx takes nothing returns booleanset ecv=VXx(eCv)
return trueendfunctionfunction T_x takes nothing returns booleanset edv=VXx(eDv)
return trueendfunctionfunction T0x takes nothing returns booleanset Xg[0]='AiI0'
call L1x('AiI0',false)return trueendfunctionfunction T1x takes nothing returns booleanset Xg[4]='AiI4'
call L1x('AiI4',false)return trueendfunctionfunction T2x takes nothing returns booleanset Vg[0]='AdI0'
call L1x('AdI0',false)return trueendfunctionfunction T3x takes nothing returns booleanset Vg[1]='AdI1'
call L1x('AdI1',false)return trueendfunctionfunction T4x takes nothing returns booleanset Vg[4]='AdI4'
call L1x('AdI4',false)return trueendfunctionfunction T5x takes nothing returns booleanset Xg[5]='AiI5'
call L1x('AiI5',false)return trueendfunctionfunction T6x takes nothing returns booleanset Xg[6]='AiI6'
call L1x('AiI6',false)return trueendfunctionfunction T7x takes nothing returns booleanset Xg[1]='AiI1'
call L1x('AiI1',false)return trueendfunctionfunction T8x takes nothing returns booleanset Vg[6]='AdI6'
call L1x('AdI6',false)return trueendfunctionfunction T9x takes nothing returns booleanset Vg[5]='AdI5'
call L1x('AdI5',false)return trueendfunctionfunction uvx takes nothing returns booleanset Vg[2]='AdI2'
call L1x('AdI2',false)return trueendfunctionfunction uex takes nothing returns booleanset Xg[2]='AiI2'
call L1x('AiI2',false)return trueendfunctionfunction uxx takes nothing returns booleanset Xg[3]='AiI3'
call L1x('AiI3',false)return trueendfunctionfunction uox takes nothing returns booleanset Vg[3]='AdI3'
call L1x('AdI3',false)return trueendfunctionfunction urx takes nothing returns booleanset Og[0]=1set Og[1]=2set Og[2]=4set Og[3]=8set Og[4]=16
set Og[5]=32
set Og[6]=64
return trueendfunctionfunction uix takes nothing returns booleancall VNx(Pa,(function T0x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_increasingSpells[0]_wc3spell.j"))call VNx(Pa,(function T1x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_increasingSpells[4]_wc3spell.j"))call VNx(Pa,(function T2x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_decreasingSpells[0]_wc3spell.j"))call VNx(Pa,(function T3x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_decreasingSpells[1]_wc3spell.j"))call VNx(Pa,(function T4x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_decreasingSpells[4]_wc3spell.j"))call VNx(Pa,(function T5x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_increasingSpells[5]_wc3spell.j"))call VNx(Pa,(function T6x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_increasingSpells[6]_wc3spell.j"))call VNx(Pa,(function T7x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_increasingSpells[1]_wc3spell.j"))call VNx(Pa,(function T8x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_decreasingSpells[6]_wc3spell.j"))call VNx(Pa,(function T9x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_decreasingSpells[5]_wc3spell.j"))call VNx(Pa,(function uvx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_decreasingSpells[2]_wc3spell.j"))call VNx(Pa,(function uex),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_increasingSpells[2]_wc3spell.j"))call VNx(Pa,(function uxx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_increasingSpells[3]_wc3spell.j"))call VNx(Pa,(function uox),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_decreasingSpells[3]_wc3spell.j"))call VNx(va,(function urx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Intelligence\\BonusA\\obj_this_wc3obj.j"))
return trueendfunctionfunction uax takes nothing returns booleanset efv=VXx(eFv)
return trueendfunctionfunction unx takes nothing returns booleanset egv=VXx(eGv)
return trueendfunctionfunction uVx takes nothing returns booleanset UG[6]='AdS6'
call L1x('AdS6',false)return trueendfunctionfunction uEx takes nothing returns booleanset UG[0]='AdS0'
call L1x('AdS0',false)return trueendfunctionfunction uXx takes nothing returns booleanset WG[6]='AiS6'
call L1x('AiS6',false)return trueendfunctionfunction uOx takes nothing returns booleanset WG[4]='AiS4'
call L1x('AiS4',false)return trueendfunctionfunction uRx takes nothing returns booleanset WG[3]='AiS3'
call L1x('AiS3',false)return trueendfunctionfunction uIx takes nothing returns booleanset UG[2]='AdS2'
call L1x('AdS2',false)return trueendfunctionfunction uAx takes nothing returns booleanset UG[1]='AdS1'
call L1x('AdS1',false)return trueendfunctionfunction uNx takes nothing returns booleanset yG[0]=1set yG[1]=2set yG[2]=4set yG[3]=8set yG[4]=16
set yG[5]=32
set yG[6]=64
return trueendfunctionfunction ubx takes nothing returns booleanset WG[5]='AiS5'
call L1x('AiS5',false)return trueendfunctionfunction uBx takes nothing returns booleanset UG[4]='AdS4'
call L1x('AdS4',false)return trueendfunctionfunction ucx takes nothing returns booleanset UG[3]='AdS3'
call L1x('AdS3',false)return trueendfunctionfunction uCx takes nothing returns booleanset WG[1]='AiS1'
call L1x('AiS1',false)return trueendfunctionfunction udx takes nothing returns booleanset WG[2]='AiS2'
call L1x('AiS2',false)return trueendfunctionfunction uDx takes nothing returns booleanset WG[0]='AiS0'
call L1x('AiS0',false)return trueendfunctionfunction ufx takes nothing returns booleanset UG[5]='AdS5'
call L1x('AdS5',false)return trueendfunctionfunction uFx takes nothing returns booleancall VNx(Pa,(function uVx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_decreasingSpells[6]_wc3spell.j"))call VNx(Pa,(function uEx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_decreasingSpells[0]_wc3spell.j"))call VNx(Pa,(function uXx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_increasingSpells[6]_wc3spell.j"))call VNx(Pa,(function uOx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_increasingSpells[4]_wc3spell.j"))call VNx(Pa,(function uRx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_increasingSpells[3]_wc3spell.j"))call VNx(Pa,(function uIx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_decreasingSpells[2]_wc3spell.j"))call VNx(Pa,(function uAx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_decreasingSpells[1]_wc3spell.j"))call VNx(va,(function uNx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_this_wc3obj.j"))
call VNx(Pa,(function ubx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_increasingSpells[5]_wc3spell.j"))call VNx(Pa,(function uBx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_decreasingSpells[4]_wc3spell.j"))call VNx(Pa,(function ucx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_decreasingSpells[3]_wc3spell.j"))call VNx(Pa,(function uCx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_increasingSpells[1]_wc3spell.j"))call VNx(Pa,(function udx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_increasingSpells[2]_wc3spell.j"))call VNx(Pa,(function uDx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_increasingSpells[0]_wc3spell.j"))call VNx(Pa,(function ufx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\Hero\\Strength\\BonusA\\obj_decreasingSpells[5]_wc3spell.j"))return trueendfunctionfunction ugx takes nothing returns booleanset ehv=VXx(eHv)
return trueendfunctionfunction uGx takes nothing returns booleanset ejv=VXx(eJv)
return trueendfunctionfunction uhx takes nothing returns booleanset ekv=VXx(eKv)
return trueendfunctionfunction uHx takes nothing returns booleancall L1x('AHer',false)return trueendfunctionfunction ujx takes nothing returns booleancall L1x('aFly',false)return trueendfunctionfunction uJx takes nothing returns booleancall VNx(Pa,(function uHx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\obj_skillMenuSpell_wc3spell.j"))
call VNx(Pa,(function ujx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\BJUnit.struct\\obj_zEnablerSpell_wc3spell.j"))return trueendfunctionfunction ukx takes nothing returns booleanset elv=VXx(eLv)
return trueendfunctionfunction uKx takes nothing returns booleanset emv=VXx(eMv)
return trueendfunctionfunction ulx takes nothing returns booleanset epv=VXx(ePv)
return trueendfunctionfunction uLx takes nothing returns booleanset eqv=VXx(eQv)
return trueendfunctionfunction umx takes nothing returns booleanset esv=VXx(eSv)
return trueendfunctionfunction uMx takes nothing returns booleanset etv=VXx(eTv)
return trueendfunctionfunction upx takes nothing returns booleanset euv=VXx(eUv)
return trueendfunctionfunction uPx takes nothing returns booleanset ewv=VXx(eWv)
return trueendfunctionfunction uqx takes nothing returns booleanset eyv=VXx(eYv)
return trueendfunctionfunction uQx takes nothing returns booleanset ezv=VXx(eZv)
return trueendfunctionfunction usx takes nothing returns booleanset e_v=VXx(e0v)
return trueendfunctionfunction uSx takes nothing returns booleanset e1v=VXx(e2v)
return trueendfunctionfunction utx takes nothing returns booleanset e3v=VXx(e4v)
return trueendfunctionfunction uTx takes nothing returns booleanset e5v=VXx(e6v)
return trueendfunctionfunction uux takes nothing returns booleanset e7v=VXx(e8v)
return trueendfunctionfunction uUx takes nothing returns booleanset e9v=VXx(xvv)
return trueendfunctionfunction uwx takes nothing returns booleanset xev=VXx(xxv)
return trueendfunctionfunction uWx takes nothing returns booleanset xov=VXx(xrv)
return trueendfunctionfunction uyx takes nothing returns booleanset xiv=VXx(xav)
return trueendfunctionfunction uYx takes nothing returns booleanset xnv=VXx(xVv)
return trueendfunctionfunction uzx takes nothing returns booleanset xEv=VXx(xXv)
return trueendfunctionfunction uZx takes nothing returns booleanset xOv=VXx(xRv)
return trueendfunctionfunction u_x takes nothing returns booleanset xIv=VXx(xAv)
return trueendfunctionfunction u0x takes nothing returns booleanset LH=VXx(HH)return trueendfunctionfunction u1x takes nothing returns booleanset xNv=VXx(xbv)
return trueendfunctionfunction u2x takes integer oSx returns integerset xfv[oSx]=trueset xFv[oSx]=falsecall rEx(c5)
return oSxendfunctionfunction u3x takes nothing returns integerlocal integer oSxif(xcv==8190)thencall o_x("SoundType_Allocation_allocCustom","call DebugEx(SoundType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",C5+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(xCv[(w)]==w)thenset xdv=xdv+1set oSx=xdvelse
set oSx=xCv[(w)]
set xCv[(w)]=xCv[xCv[(w)]]endifset xCv[oSx]=Zset xDv[oSx]=1call u2x(oSx)return oSxendfunctionfunction u4x takes nothing returns integerlocal integer oSx=u3x()set IC[(oSx)]=(null)
set NC[(oSx)]=(0)set BC[(oSx)]=(H5)set CC[(oSx)]=((1.)*1.)set DC[(oSx)]=((1.)*1.)set FC[(oSx)]=(1)set GC[(oSx)]=((127.)*1.)set HC[(oSx)]=((10.)*1.)
set JC[(oSx)]=((10.)*1.)
set kC[(oSx)]=(false)set lC[(oSx)]=(false)set mC[(oSx)]=(false)set pC[(oSx)]=((.0)*1.)set qC[(oSx)]=((.0)*1.)set sC[(oSx)]=((.0)*1.)set tC[(oSx)]=((.0)*1.)set uC[(oSx)]=((.0)*1.)set wC[(oSx)]=((.0)*1.)set yC[(oSx)]=((.0)*1.)set zC[(oSx)]=((.0)*1.)set vd[(oSx)]=((.0)*1.)return oSxendfunctionfunction u5x takes nothing returns booleanset xBv=u4x()set IC[(xBv)]=("Sound\\Ambient\\DoodadEffects\\FrostmourneLoopUndead01.wav")
set NC[(xBv)]=(M5)set BC[(xBv)]=(l5)set CC[(xBv)]=((1)*1.)set DC[(xBv)]=((1)*1.)set FC[(xBv)]=($A)set GC[(xBv)]=((1)*1.)set kC[(xBv)]=(true)
set mC[(xBv)]=(true)
set pC[(xBv)]=((600)*1.)
set qC[(xBv)]=(($186A0)*1.)set sC[(xBv)]=(($7D0)*1.)return trueendfunctionfunction u6x takes nothing returns booleanset DH=ltx(xgv+" (dummyBuff)")call lWx(DH,"Unit_page\\Unit_struct\\Abilities\\Events\\Effect\\Channeling\\special.mdx","origin",ri)call lwx(((DH)),aC,(xBv))return trueendfunctionfunction u7x takes nothing returns booleancall VNx(La,(function u5x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Abilities\\Events\\Effect\\Channeling\\obj_loopSound_wc3sound.j"))
call VNx(ma,(function u6x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Abilities\\Events\\Effect\\Channeling\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction u8x takes nothing returns booleanset xGv=VXx(xgv)
return trueendfunctionfunction u9x takes code c,string rSx returns nothing
set Sa=Sa+1set ta[Sa]=CreateTrigger()set Ta[Sa]=(GetHandleId(Condition((c))))
set ua[Sa]=rSxcall TriggerAddCondition(ta[Sa],Condition(c))endfunctionfunction Uvx takes integer oSx returns nothingset xtv[oSx]=falsecall rHx(xTv)endfunctionfunction Uex takes integer oSx returns nothingif(xQv[oSx]>0)thenreturnendifif(xsv[oSx]!=Z)thencall o_x("FolderUnit_FolderAnimation_StructLoop_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderAnimation_StructLoop.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",xSv+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset xsv[oSx]=xsv[(w)]set xsv[(w)]=oSx
call Uvx(oSx)endfunctionfunction Uxx takes integer oSx returns nothingset xQv[oSx]=xQv[oSx]-1call Uex(oSx)endfunctionfunction Uox takes integer oSx returns booleanlocal integer oLx=(xUv[(oSx)])set xUv[xwv[xWv]]=oLxset xwv[oLx-1]=xwv[xWv]set xUv[oSx]=0set xWv=xWv-1return(xWv==F)endfunctionfunction Urx takes integer oSx returns nothingset Od=oSxcall TriggerEvaluate(xYv)endfunctionfunction Uix takes integer oSx returns nothingcall Urx(oSx)call SetUnitAnimation(C[((oSx))],("stand"))call QueueUnitAnimation(C[((oSx))],("stand"))endfunctionfunction Uax takes integer oSx,integer rLx returns nothingcall Uxx((oSx))call rVx(rLx,xqv)call RPx(rLx,xuv)if Uox(oSx)thencall ikx(xyv)endifcall Uix(xzv[oSx])endfunctionfunction Unx takes integer oSx returns nothinglocal integer rLx=oSxset oSx=osx(rLx,xqv)
if(oSx!=w)thencall Uax(oSx,rLx)endifendfunctionfunction UVx takes integer oSx returns integerset xtv[oSx]=trueset x0v[oSx]=falsecall rEx(xTv)return oSxendfunctionfunction UEx takes nothing returns integerlocal integer oSxif(xZv==8190)thencall o_x("FolderUnit_FolderAnimation_StructLoop_Allocation_allocCustom","call DebugEx(FolderUnit_FolderAnimation_StructLoop.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",xSv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(xsv[(w)]==w)thenset x_v=x_v+1set oSx=x_velse
set oSx=xsv[(w)]
set xsv[(w)]=xsv[xsv[(w)]]endifset xsv[oSx]=Zset xQv[oSx]=1call UVx(oSx)return oSxendfunctionfunction UXx takes integer oSx returns booleanset xWv=xWv+1set xwv[xWv]=oSx
set xUv[oSx]=xWv+1return(xWv==0)endfunctionfunction UOx takes integer oSx,string URx returns nothingcall QueueUnitAnimation(C[(oSx)],URx)endfunctionfunction UIx takes nothing returns nothinglocal integer oMx=xWvlocal integer oSxloop
set oSx=xwv[oMx]
call UOx(xzv[oSx],x1v[oSx])set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction UAx takes integer oSx,string URx returns nothingcall SetUnitAnimation(C[(oSx)],URx)endfunctionfunction UNx takes integer oSx,string URx returns nothinglocal integer rLx=oSxcall Unx((rLx))set oSx=UEx()set xzv[oSx]=rLx
set x1v[oSx]=URx
call rwx(rLx,xqv,oSx)call Avx(rLx,xuv)if UXx(oSx)thencall iDx(xyv,x2v,true,function UIx)endifcall UAx(rLx,URx)endfunctionfunction Ubx takes integer oSx returns nothingcall Dux(((oSx)),(x4v),(1),w)endfunctionfunction UBx takes integer oSx returns nothingcall Dux(((oSx)),(x5v),(1),w)endfunctionfunction Ucx takes integer oSx returns nothingset bH[oSx]=(bH[(oSx)])+1endfunctionfunction UCx takes integer oSx returns booleanif((x6v[((oSx))])>0)then
return false
endifset x7v=x7v+1set x8v[x7v]=oSx
set x6v[oSx]=x7v+1return(x7v==0)endfunctionfunction Udx takes nothing returns nothinglocal integer oMx=x7vloop
exitwhen(oMx<0)set ovv[oMx]=x8v[oMx]set oMx=oMx-1endloopset oev=x7vendfunctionfunction UDx takes nothing returns integerlocal integer o7xif(oev<0)thenreturn w
endifset o7x=ovv[0]set ovv[0]=ovv[oev]set oev=oev-1return o7xendfunctionfunction Ufx takes integer oSx,real dX,real dY returns realif(GZx(dX,dY)<1.)thenreturn(GetUnitFacing(C[((oSx))])*Nh)
endifreturn(Atan2(((dY)*1.),((dX)*1.)))endfunctionfunction UFx takes integer oSx returns reallocal integer dax=(wh[(oSx)])local integer dnxif(dax!=w)thenreturn(GetItemX(gh[((dax))]))endifset dnx=(Wh[(oSx)])if(dnx!=w)thenreturn Dsx(dnx)endifreturn(yh[(oSx)])endfunctionfunction Ugx takes integer oSx returns reallocal integer dax=(wh[(oSx)])local integer dnxif(dax!=w)thenreturn(GetItemY(gh[((dax))]))endifset dnx=(Wh[(oSx)])if(dnx!=w)thenreturn Dtx(dnx)endifreturn(Yh[(oSx)])endfunctionfunction UGx takes integer oSx returns realreturn(GetUnitFacing(C[(oSx)])*Nh)endfunctionfunction Uhx takes integer oSx,real oux returns nothingcall SetUnitFacing(C[(oSx)],oux*ky)endfunctionfunction UHx takes integer oSx returns nothinglocal integer Cqx=oSxlocal integer Ctx=xjv[oSx]local real bexif((oxv[((AH[(Ctx)]))])!=0)thenset bex=Ufx(Cqx,UFx(Ctx)-Dsx(Cqx),Ugx(Ctx)-Dtx(Cqx))
if(UGx(Cqx)!=bex)thencall Uhx(Cqx,bex)endifendifendfunctionfunction Ujx takes nothing returns nothinglocal integer oSxcall Udx()loop
set oSx=UDx()exitwhen(oSx==w)
call UHx(oSx)endloopendfunctionfunction UJx takes integer oSx,real iMx returns nothingcall iDx(oov[oSx],iMx,false,null)endfunctionfunction Ukx takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local real iMx=fHlocal integer Ctx=FH
local integer Iix=(Wh[(Ctx)])local integer oSx=Cqxlocal integer iCx=iXx()set xhv[oSx]=iCx
set xHv[oSx]=trueset xjv[oSx]=Ctx
call Avx(Cqx,xJv)call Avx(Cqx,xkv)call Avx(Cqx,xKv)call Avx(Cqx,xlv)call Avx(Cqx,xLv)call Avx(Cqx,xmv)if(Iix!=w)thenif rUx(Iix,xMv,Cqx)thencall Avx(Iix,xpv)call Avx(Iix,xPv)endifendifcall iDx(iCx,iMx+.01,false,null)
call UNx((oSx),(x3v[((AH[(Ctx)]))]))
call Ubx((oSx))call UBx((oSx))call Ucx(Ctx)if UCx(oSx)thencall iDx(x9v,.25,true,function Ujx)endifcall UHx(oSx)call UJx(Cqx,iMx)return trueendfunctionfunction UKx takes integer oSx returns booleanif(((x6v[((oSx))])>0)==false)thenreturn false
endifset x6v[x8v[x7v]]=x6v[oSx]set x8v[x6v[oSx]-1]=x8v[x7v]
set x6v[oSx]=0set x7v=x7v-1return(x7v==F)endfunctionfunction Ulx takes integer oSx,integer Iax returns booleanlocal integer ASx=RMx(X,Zb,oSx,Iax,w)if(ASx==w)thenreturn false
endifif Iax!=tB[ASx]thencall o_x("FolderUnit_StructBuffs_Subtract","call DebugEx(I2S(LOCAL_REFS_KEY)+\"\t\t subtract CORRUPT buffref\"+whichBuff.GetName()+\";\"+I2S(whichBuff)+\";\"+I2S(whichRef)+\";\"+I2S(whichRef.whichBuff))",I2S(Zb)+"\t\t subtract CORRUPT buffref"+(oD[(Iax)])+";"+I2S(Iax)+";"+I2S(ASx)+";"+I2S(tB[ASx]))endifcall AYx(ASx)return trueendfunctionfunction ULx takes integer oSx returns nothingcall Ulx((oSx),x4v)endfunctionfunction Umx takes integer oSx returns nothingcall Ulx((oSx),x5v)endfunctionfunction UMx takes integer oSx returns nothingcall ikx(oSx)set ce[(oSx)]=((.0)*1.)endfunctionfunction Upx takes integer oSx returns nothingcall MoveLightningEx(orv[oSx],false,.0,.0,.0,.0,.0,.0)call MoveLightningEx(oiv[oSx],false,.0,.0,.0,.0,.0,.0)call UMx(oov[oSx])endfunctionfunction UPx takes integer Ctx,boolean Uqx returns nothinglocal integer Cqx=(EH[(Ctx)])local integer rYx=(IH[(Ctx)])local integer dax=(wh[(Ctx)])local integer dnx=(Wh[(Ctx)])local real dVx=(yh[(Ctx)])local real dEx=(Yh[(Ctx)])local integer rlx=(AH[(Ctx)])local integer dXx=rRx((A[(Cqx)]))local integer rmxlocal integer oMxlocal integer rbxlocal integer rMxset oav[(dXx)]=(Uqx)
set Mv[(dXx)]=(rYx)set nv[(dXx)]=(rlx)set WH[(dXx)]=(Ctx)set Vv[(dXx)]=(Cqx)set rmx=rRx((Ev[(rlx)]))
set oav[(rmx)]=(Uqx)
set Mv[(rmx)]=(rYx)set nv[(rmx)]=(rlx)set WH[(rmx)]=(Ctx)set Vv[(rmx)]=(Cqx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rGx(rlx,onv,rbx)
loop
exitwhen(rMx<q)call rfx(rhx(rlx,onv,rbx,rMx),rmx)set rMx=rMx-1endloopset rMx=rGx(rlx,oVv,rbx)
if Uqx thenloop
exitwhen(rMx<q)call rfx(rhx(rlx,oVv,rbx,rMx),rmx)set rMx=rMx-1endloopendifset rMx=rAx(Cqx,onv,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(Cqx,onv,rbx,rMx),dXx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((dXx)))call rkx(((rmx)))endfunctionfunction UQx takes integer Ctx,boolean Uqx returns nothingcall UPx(Ctx,Uqx)endfunctionfunction Usx takes integer oSx returns nothinglocal integer oux=(bH[(oSx)])-1set bH[oSx]=ouxif((oux==0)and(BH[oSx]))then
call dNx((oSx))endifendfunctionfunction USx takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oSx=Cqxlocal integer iCx=xhv[oSx]local integer Ctx=xjv[oSx]local boolean Utx=((TimerGetRemaining(Oe[(iCx)]))<.1)local integer Iix=(Wh[(Ctx)])call iKx(iCx)if UKx(oSx)thencall ikx(x9v)endifset xHv[oSx]=falsecall RPx(Cqx,xJv)call RPx(Cqx,xkv)call RPx(Cqx,xKv)call RPx(Cqx,xlv)call RPx(Cqx,xLv)call RPx(Cqx,xmv)if(Iix!=w)thenif rnx(Iix,xMv,Cqx)thencall RPx(Iix,xpv)call RPx(Iix,xPv)endifendifcall Uix(Cqx)call ULx(Cqx)call Umx(Cqx)call Upx(Cqx)call UQx(Ctx,Utx)call Usx(Ctx)return trueendfunctionfunction UTx takes nothing returns booleancall Lxx(DH,Xdx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Buff_Init: call FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_BuffGain))",bd,MI,function Ukx))call Lxx(DH,Xdx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Buff_Init: call FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_BuffLose))",jc,MI,function USx))return trueendfunctionfunction Uux takes nothing returns booleancall u9x(function UTx,"FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Buff_Init")
return trueendfunctionfunction UUx takes nothing returns booleancall L1x('AUCU',false)return trueendfunctionfunction Uwx takes nothing returns booleancall L1x('AUCQ',false)return trueendfunctionfunction UWx takes nothing returns booleancall L1x('AUCP',false)return trueendfunctionfunction Uyx takes nothing returns booleancall L1x('AUCI',false)return trueendfunctionfunction UYx takes nothing returns booleancall VNx(Pa,(function UUx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Abilities\\Events\\Effect\\obj_unitDummySpell_wc3spell.j"))call VNx(Pa,(function Uwx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Abilities\\Events\\Effect\\obj_pointOrUnitDummySpell_wc3spell.j"))
call VNx(Pa,(function UWx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Abilities\\Events\\Effect\\obj_pointDummySpell_wc3spell.j"))call VNx(Pa,(function Uyx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Abilities\\Events\\Effect\\obj_immediateDummySpell_wc3spell.j"))return trueendfunctionfunction Uzx takes nothing returns booleanset oEv=VXx(oXv)
return trueendfunctionfunction UZx takes nothing returns booleanset oOv=VXx(oRv)
return trueendfunctionfunction U_x takes nothing returns booleanset oIv=VXx(oAv)
return trueendfunctionfunction U0x takes nothing returns booleanset oNv=VXx(obv)
return trueendfunctionfunction U1x takes nothing returns booleanset oBv=VXx(ocv)
return trueendfunctionfunction U2x takes nothing returns booleanset oCv=VXx(odv)
return trueendfunctionfunction U3x takes nothing returns booleanset oDv=VXx(ofv)
return trueendfunctionfunction U4x takes nothing returns booleanset oFv=VXx(ogv)
return trueendfunctionfunction U5x takes nothing returns booleanset oGv=VXx(ohv)
return trueendfunctionfunction U6x takes nothing returns booleanset oHv=VXx(ojv)
return trueendfunctionfunction U7x takes nothing returns booleanset oJv=VXx(okv)
return trueendfunctionfunction U8x takes nothing returns booleanset oKv=VXx(olv)
return trueendfunctionfunction U9x takes nothing returns booleanset oLv=VXx(omv)
return trueendfunctionfunction wvx takes nothing returns booleanset oMv=VXx(opv)
return trueendfunctionfunction wex takes nothing returns booleanset qd=VXx(pd)return trueendfunctionfunction wxx takes nothing returns booleanset Hd=VXx(Dd)return trueendfunctionfunction wox takes nothing returns booleanset oPv=VXx(oqv)
return trueendfunctionfunction wrx takes nothing returns booleanset oQv=VXx(osv)
return trueendfunctionfunction wix takes nothing returns booleanset oSv=VXx(otv)
return trueendfunctionfunction wax takes nothing returns booleanset oTv=VXx(ouv)
return trueendfunctionfunction wnx takes nothing returns booleanset oUv=VXx(owv)
return trueendfunctionfunction wVx takes nothing returns booleanset oWv=VXx(oyv)
return trueendfunctionfunction wEx takes nothing returns booleanset oYv=VXx(ozv)
return trueendfunctionfunction wXx takes nothing returns booleanset oZv=VXx(o_v)
return trueendfunctionfunction wOx takes nothing returns booleanset o0v=VXx(o1v)
return trueendfunctionfunction wRx takes nothing returns booleanset o2v=VXx(o3v)
return trueendfunctionfunction wIx takes nothing returns booleancall L1x('Abrf',false)return trueendfunctionfunction wAx takes nothing returns booleancall L1x('Aetf',false)return trueendfunctionfunction wNx takes nothing returns booleancall L1x('Acpf',false)return trueendfunctionfunction wbx takes nothing returns booleancall VNx(Pa,(function wIx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Type\\obj_changerBase_wc3spell.j"))call VNx(Pa,(function wAx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Type\\obj_changerCorporalRevert_wc3spell.j"))call VNx(Pa,(function wNx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Type\\obj_changerCorporal_wc3spell.j"))return trueendfunctionfunction wBx takes nothing returns booleanset o4v=VXx(o5v)
return trueendfunctionfunction wcx takes nothing returns booleanset o6v=VXx(o7v)
return trueendfunctionfunction wCx takes nothing returns booleanset o8v=VXx(o9v)
return trueendfunctionfunction wdx takes nothing returns booleanset rvv=VXx(rev)
return trueendfunctionfunction wDx takes nothing returns booleanset rxv=VXx(rov)
return trueendfunctionfunction wfx takes nothing returns booleanset rrv=VXx(riv)
return trueendfunctionfunction wFx takes nothing returns booleanset rav=VXx(rnv)
return trueendfunctionfunction wgx takes nothing returns booleanset rVv=VXx(rEv)
return trueendfunctionfunction wGx takes nothing returns booleanset rXv=VXx(rOv)
return trueendfunctionfunction whx takes nothing returns booleanset rRv=VXx(rIv)
return trueendfunctionfunction wHx takes nothing returns booleanset rAv=VXx(rNv)
return trueendfunctionfunction wjx takes nothing returns booleanset rbv=VXx(rBv)
return trueendfunctionfunction wJx takes nothing returns booleanset rcv=VXx(rCv)
return trueendfunctionfunction wkx takes nothing returns booleanset rdv=VXx(rDv)
return trueendfunctionfunction wKx takes nothing returns booleanset rfv=VXx(rFv)
return trueendfunctionfunction wlx takes nothing returns booleanreturn trueendfunctionfunction wLx takes nothing returns booleanset rgv=VXx(rGv)
return trueendfunctionfunction wmx takes nothing returns booleanset rhv=VXx(rHv)
return trueendfunctionfunction wMx takes nothing returns booleanset rjv=VXx(rJv)
return trueendfunctionfunction wpx takes nothing returns booleanset rkv=VXx(rKv)
return trueendfunctionfunction wPx takes nothing returns booleanset rlv=VXx(rLv)
return trueendfunctionfunction wqx takes nothing returns booleanset rmv=VXx(rMv)
return trueendfunctionfunction wQx takes nothing returns booleanset rpv=VXx(rPv)
return trueendfunctionfunction wsx takes nothing returns booleanset rqv=VXx(rQv)
return trueendfunctionfunction wSx takes nothing returns booleanset rsv=VXx(rSv)
return trueendfunctionfunction wtx takes nothing returns booleanset rtv=VXx(rTv)
return trueendfunctionfunction wTx takes nothing returns booleanset ruv=VXx(rUv)
return trueendfunctionfunction wux takes nothing returns booleanset x4v=ltx(rwv+" (disableBuff)")return trueendfunctionfunction wUx takes nothing returns booleanset rWv=ltx(rwv+" (normalBuff)")
call lWx(rWv,"Abilities\\Spells\\Orc\\StasisTrap\\StasisTotemTarget.mdl","overhead",ri)return trueendfunctionfunction wwx takes nothing returns booleancall L1x('ADAI',false)return trueendfunctionfunction wWx takes nothing returns booleancall L1x('Abun',false)return trueendfunctionfunction wyx takes nothing returns booleancall VNx(ma,(function wux),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Attack\\obj_disableBuff_wc3buff.j"))call VNx(ma,(function wUx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Attack\\obj_normalBuff_wc3buff.j"))call VNx(Pa,(function wwx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Attack\\obj_iconSpell_wc3spell.j"))call VNx(Pa,(function wWx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Attack\\obj_disableSpell_wc3spell.j"))
return trueendfunctionfunction wYx takes nothing returns booleanset ryv=VXx(rwv)
return trueendfunctionfunction wzx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set rYv[((rLx))]=(false)
call rtx(rLx,'Abun')
call rtx(rLx,'ADAI')
return trueendfunctionfunction wZx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set rYv[((rLx))]=(true)call UnitRemoveAbility(C[((rLx))],('Abun'))call UnitRemoveAbility(C[((rLx))],('ADAI'))return trueendfunctionfunction w_x takes nothing returns booleancall Lxx(x4v,Xdx("FolderUnit_StructAttack_Buff_Init: call FolderUnit_StructAttack.DISABLE_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructAttack.Event_BuffGain))",bd,MI,function wzx))
call Lxx(x4v,Xdx("FolderUnit_StructAttack_Buff_Init: call FolderUnit_StructAttack.DISABLE_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructAttack.Event_BuffLose))",jc,MI,function wZx))
call Lxx(rWv,Xdx("FolderUnit_StructAttack_Buff_Init: call FolderUnit_StructAttack.NORMAL_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructAttack.Event_BuffGain))",bd,MI,function wzx))call Lxx(rWv,Xdx("FolderUnit_StructAttack_Buff_Init: call FolderUnit_StructAttack.NORMAL_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructAttack.Event_BuffLose))",jc,MI,function wZx))return trueendfunctionfunction w0x takes nothing returns booleancall u9x(function w_x,"FolderUnit_StructAttack_Buff_Init")return trueendfunctionfunction w1x takes nothing returns booleanset rzv=VXx(rZv)
return trueendfunctionfunction w2x takes nothing returns booleanset r_v=VXx(r0v)
return trueendfunctionfunction w3x takes nothing returns booleanset r1v=VXx(r2v)
return trueendfunctionfunction w4x takes nothing returns booleanset r3v=VXx(r4v)
return trueendfunctionfunction w5x takes nothing returns booleanset r5v=VXx(r6v)
return trueendfunctionfunction w6x takes nothing returns booleanset r7v=VXx(r8v)
return trueendfunctionfunction w7x takes nothing returns booleanset r9v=VXx(ivv)
return trueendfunctionfunction w8x takes nothing returns booleanset iev=VXx(ixv)
return trueendfunctionfunction w9x takes nothing returns booleanset iov=VXx(irv)
return trueendfunctionfunction Wvx takes nothing returns booleanset iiv=ltx(iav+" (dummyBuff)")return trueendfunctionfunction Wex takes nothing returns booleancall VNx(ma,(function Wvx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Death\\Explosion\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction Wxx takes nothing returns booleanset inv=VXx(iav)
return trueendfunctionfunction Wox takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=rLxset iVv[(oSx)]=(true)return trueendfunctionfunction Wrx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=rLxset iVv[(oSx)]=(false)return trueendfunctionfunction Wix takes nothing returns booleancall Lxx(iiv,Xdx("FolderUnit_FolderDeath_StructExplosion_Buff_Init: call FolderUnit_FolderDeath_StructExplosion.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderDeath_StructExplosion.Event_BuffGain))",bd,MI,function Wox))call Lxx(iiv,Xdx("FolderUnit_FolderDeath_StructExplosion_Buff_Init: call FolderUnit_FolderDeath_StructExplosion.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderDeath_StructExplosion.Event_BuffLose))",jc,MI,function Wrx))return trueendfunctionfunction Wax takes nothing returns booleancall u9x(function Wix,"FolderUnit_FolderDeath_StructExplosion_Buff_Init")return trueendfunctionfunction Wnx takes nothing returns booleanset iEv=VXx(iXv)
return trueendfunctionfunction WVx takes nothing returns booleanset iOv=ltx(iRv+" (dummyBuff)")call lWx(iOv,"Unit_page\\Unit_struct\\Death\\Protection\\buff.mdx","chest",ri)return trueendfunctionfunction WEx takes nothing returns booleancall VNx(ma,(function WVx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Death\\Protection\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction WXx takes nothing returns booleanset iIv=VXx(iRv)
return trueendfunctionfunction WOx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set iG[((rLx))]=(true)return trueendfunctionfunction WRx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set iG[((rLx))]=(false)return trueendfunctionfunction WIx takes nothing returns booleancall Lxx(iOv,Xdx("FolderUnit_FolderDeath_StructProtection_Buff_Init: call FolderUnit_FolderDeath_StructProtection.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderDeath_StructProtection.Event_BuffGain))",bd,MI,function WOx))call Lxx(iOv,Xdx("FolderUnit_FolderDeath_StructProtection_Buff_Init: call FolderUnit_FolderDeath_StructProtection.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderDeath_StructProtection.Event_BuffLose))",jc,MI,function WRx))return trueendfunctionfunction WAx takes nothing returns booleancall u9x(function WIx,"FolderUnit_FolderDeath_StructProtection_Buff_Init")return trueendfunctionfunction WNx takes nothing returns booleanset iAv=VXx(iNv)
return trueendfunctionfunction Wbx takes nothing returns booleanset ibv=VXx(iBv)
return trueendfunctionfunction WBx takes nothing returns booleanset icv=VXx(iCv)
return trueendfunctionfunction Wcx takes nothing returns booleanset idv=VXx(iDv)
return trueendfunctionfunction WCx takes nothing returns booleanset ifv=VXx(iFv)
return trueendfunctionfunction Wdx takes nothing returns booleancall L1x('AUUD',false)return trueendfunctionfunction WDx takes nothing returns booleancall VNx(Pa,(function Wdx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Display\\obj_dummySpell_wc3spell.j"))return trueendfunctionfunction Wfx takes nothing returns booleanset igv=VXx(iGv)
return trueendfunctionfunction WFx takes nothing returns booleanset ihv=VXx(iHv)
return trueendfunctionfunction Wgx takes nothing returns booleanset ijv=VXx(iJv)
return trueendfunctionfunction WGx takes nothing returns booleanset ikv=VXx(iKv)
return trueendfunctionfunction Whx takes nothing returns booleanset ilv=VXx(iLv)
return trueendfunctionfunction WHx takes nothing returns booleanset imv=VXx(iMv)
return trueendfunctionfunction Wjx takes nothing returns booleanset ipv=VXx(iPv)
return trueendfunctionfunction WJx takes nothing returns booleanset iqv=VXx(iQv)
return trueendfunctionfunction Wkx takes nothing returns booleanset isv=VXx(iSv)
return trueendfunctionfunction WKx takes nothing returns booleanset itv=VXx(iTv)
return trueendfunctionfunction Wlx takes nothing returns booleanset iuv=VXx(iUv)
return trueendfunctionfunction WLx takes nothing returns booleanset iwv=VXx(iWv)
return trueendfunctionfunction Wmx takes nothing returns booleanset iyv=VXx(iYv)
return trueendfunctionfunction WMx takes nothing returns booleanset izv=VXx(iZv)
return trueendfunctionfunction Wpx takes nothing returns booleanset i_v=VXx(i0v)
return trueendfunctionfunction WPx takes nothing returns booleanset i1v=VXx(i2v)
return trueendfunctionfunction Wqx takes nothing returns booleanset i3v=VXx(i4v)
return trueendfunctionfunction WQx takes nothing returns booleanset i5v=VXx(i6v)
return trueendfunctionfunction Wsx takes nothing returns booleanset i7v=VXx(i8v)
return trueendfunctionfunction WSx takes nothing returns booleanset i9v=VXx(avv)
return trueendfunctionfunction Wtx takes nothing returns booleanreturn trueendfunctionfunction WTx takes nothing returns booleanset aev=VXx(axv)
return trueendfunctionfunction Wux takes nothing returns booleanreturn trueendfunctionfunction WUx takes nothing returns booleanset aov=VXx(arv)
return trueendfunctionfunction Wwx takes integer oqx,string rSx,integer Q1x returns integerlocal integer oSx=lqx()set zb[oSx]=oqxcall SaveInteger(o[((V[(E[((X))])]))],(((oqx))),(((Tb))),(((oSx))))call lQx(oSx)set yb[(oSx)]=(Q1x)set Ud[(oSx)]=(false)set Pc[(oSx)]=(false)set uU[(oSx)]=(false)set oD[(oSx)]=(rSx)set yd[(oSx)]=(false)set sc[((oSx))]=(true)call lsx(oSx)call GetObjectName(((oqx)))call L1x(Q1x,false)call XLx((oD[(oSx)]),Tb,oSx)
call lSx(oSx)return oSxendfunctionfunction WWx takes nothing returns booleanset aiv=Wwx('BIvu',"Invulnerable",'bIvu')set aav[(aiv)]=(true)set anv[(aiv)]=("ReplaceableTextures\\CommandButtons\\BTNInvulnerable.blp")call lWx(aiv,"Abilities\\Spells\\Human\\DivineShield\\DivineShieldTarget.mdl","origin",ri)return trueendfunctionfunction Wyx takes nothing returns booleanset aVv=ltx(aEv+" (dummyBuff)")return trueendfunctionfunction WYx takes nothing returns booleanset aXv=ltx(aEv+" (noneBuff)")return trueendfunctionfunction Wzx takes nothing returns booleancall VNx(ma,(function WWx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Invulnerability\\obj_normalBuff_wc3buff.j"))call VNx(ma,(function Wyx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Invulnerability\\obj_dummyBuff_wc3buff.j"))call VNx(ma,(function WYx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Invulnerability\\obj_noneBuff_wc3buff.j"))
return trueendfunctionfunction WZx takes nothing returns booleanset aOv=VXx(aEv)
return trueendfunctionfunction W_x takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set aRv[((rLx))]=(true)return trueendfunctionfunction W0x takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set aRv[((rLx))]=(false)
return trueendfunctionfunction W1x takes integer oSx,integer otx,integer oux returns booleanreturn rux(YB[(oSx)],(zB[((oSx))]),otx,oux)endfunctionfunction W2x takes integer oSx,integer W3x returns nothinglocal integer rLx=oSxcall W1x(W3x,rd,rLx)
call W1x(rLx,kc,W3x)
endfunctionfunction W4x takes nothing returns booleancall Lxx(aVv,Xdx("FolderUnit_StructInvulnerability_Buff_Init: call FolderUnit_StructInvulnerability.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructInvulnerability.Event_BuffGain))",bd,bI,function W_x))call Lxx(aVv,Xdx("FolderUnit_StructInvulnerability_Buff_Init: call FolderUnit_StructInvulnerability.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructInvulnerability.Event_BuffLose))",jc,bI,function W0x))call W2x(aVv,aiv)return trueendfunctionfunction W5x takes nothing returns booleancall u9x(function W4x,"FolderUnit_StructInvulnerability_Buff_Init")return trueendfunctionfunction W6x takes nothing returns booleanset aIv=VXx(aAv)
return trueendfunctionfunction W7x takes nothing returns booleanset aNv=VXx(abv)
return trueendfunctionfunction W8x takes nothing returns booleanset aBv=VXx(acv)
return trueendfunctionfunction W9x takes nothing returns booleanset aCv=VXx(adv)
return trueendfunctionfunction yvx takes nothing returns booleanset aDv=VXx(afv)
return trueendfunctionfunction yex takes nothing returns booleanset aFv=VXx(agv)
return trueendfunctionfunction yxx takes nothing returns booleanset aGv=VXx(ahv)
return trueendfunctionfunction yox takes nothing returns booleanset aHv=VXx(ajv)
return trueendfunctionfunction yrx takes nothing returns booleanset aJv=VXx(akv)
return trueendfunctionfunction yix takes nothing returns booleanset aKv=VXx(alv)
return trueendfunctionfunction yax takes nothing returns booleanset aLv=VXx(amv)
return trueendfunctionfunction ynx takes nothing returns booleanset aMv=VXx(apv)
return trueendfunctionfunction yVx takes nothing returns booleanset aPv=VXx(aqv)
return trueendfunctionfunction yEx takes nothing returns booleanset aQv=ltx(asv+" (dummyBuff)")return trueendfunctionfunction yXx takes nothing returns booleanset aSv=Wwx('BMSP',"Spell Shield",'bMSP')set aav[(aSv)]=(true)set anv[(aSv)]=("ReplaceableTextures\\CommandButtons\\BTNRejuvenation.blp")call lWx(aSv,"Abilities\\Spells\\Items\\StaffOfSanctuary\\Staff_Sanctuary_Target.mdl","chest",ri)return trueendfunctionfunction yOx takes nothing returns booleancall VNx(ma,(function yEx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\MagicImmunity\\SpellShield\\obj_dummyBuff_wc3buff.j"))
call VNx(ma,(function yXx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\MagicImmunity\\SpellShield\\obj_normalBuff_wc3buff.j"))return trueendfunctionfunction yRx takes nothing returns booleanset atv=VXx(asv)
return trueendfunctionfunction yIx takes nothing returns booleanlocal integer rFx=(bv)local integer Iax=(Lc[(rFx)])local integer rLx=(Vv[(rFx)])local integer oSx=rLxset aTv[(oSx)]=(true)call rUx(rLx,auv,Iax)return trueendfunctionfunction yAx takes nothing returns booleanlocal integer rFx=(bv)local integer Iax=(Lc[(rFx)])local integer rLx=(Vv[(rFx)])local integer oSx=rLxset aTv[(oSx)]=(false)call rnx(rLx,auv,Iax)return trueendfunctionfunction yNx takes nothing returns booleancall Lxx(aQv,Xdx("FolderUnit_FolderMagicImmunity_StructSpellShield_Buff_Init: call FolderUnit_FolderMagicImmunity_StructSpellShield.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderMagicImmunity_StructSpellShield.Event_BuffGain))",bd,bI,function yIx))call Lxx(aQv,Xdx("FolderUnit_FolderMagicImmunity_StructSpellShield_Buff_Init: call FolderUnit_FolderMagicImmunity_StructSpellShield.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderMagicImmunity_StructSpellShield.Event_BuffLose))",jc,bI,function yAx))call W2x(aQv,aSv)return trueendfunctionfunction ybx takes nothing returns booleancall u9x(function yNx,"FolderUnit_FolderMagicImmunity_StructSpellShield_Buff_Init")return trueendfunctionfunction yBx takes nothing returns booleanset aUv=ltx(awv+" (dummyBuff)")return trueendfunctionfunction ycx takes nothing returns booleanset aWv=Wwx('BMaI',"Magic immune",'bMaI')set aav[(aWv)]=(true)set anv[(aWv)]=("ReplaceableTextures\\CommandButtons\\BTNAntiMagicShell.blp")call lWx(aWv,"Abilities\\Spells\\Undead\\AntiMagicShell\\AntiMagicShell.mdl","overhead",ri)return trueendfunctionfunction yCx takes nothing returns booleancall VNx(ma,(function yBx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\MagicImmunity\\obj_dummyBuff_wc3buff.j"))call VNx(ma,(function ycx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\MagicImmunity\\obj_normalBuff_wc3buff.j"))
return trueendfunctionfunction ydx takes nothing returns booleanset ayv=VXx(awv)
return trueendfunctionfunction yDx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set aYv[((rLx))]=(true)return trueendfunctionfunction yfx takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set aYv[((rLx))]=(false)
return trueendfunctionfunction yFx takes nothing returns booleancall Lxx(aUv,Xdx("FolderUnit_StructMagicImmunity_Buff_Init: call FolderUnit_StructMagicImmunity.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructMagicImmunity.Event_BuffGain))",bd,bI,function yDx))call Lxx(aUv,Xdx("FolderUnit_StructMagicImmunity_Buff_Init: call FolderUnit_StructMagicImmunity.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructMagicImmunity.Event_BuffLose))",jc,bI,function yfx))call W2x(aUv,aWv)return trueendfunctionfunction ygx takes nothing returns booleancall u9x(function yFx,"FolderUnit_StructMagicImmunity_Buff_Init")return trueendfunctionfunction yGx takes nothing returns booleanset azv=VXx(aZv)
return trueendfunctionfunction yhx takes nothing returns booleanset dJ=VXx(AJ)return trueendfunctionfunction yHx takes nothing returns booleanset Wj[20]='AC0K'call L1x('AC0K',false)return trueendfunctionfunction yjx takes nothing returns booleanset Wj[$C]='AC0C'call L1x('AC0C',false)return trueendfunctionfunction yJx takes nothing returns booleanset Wj[$86]='AC3Q'call L1x('AC3Q',false)return trueendfunctionfunction ykx takes nothing returns booleanset Wj['v']='AC3A'call L1x('AC3A',false)return trueendfunctionfunction yKx takes nothing returns booleanset Wj[$88]='AC3S'call L1x('AC3S',false)return trueendfunctionfunction ylx takes nothing returns booleanset Wj[$8A]='AC3U'call L1x('AC3U',false)return trueendfunctionfunction yLx takes nothing returns booleanset Wj['f']='AC2U'call L1x('AC2U',false)return trueendfunctionfunction ymx takes nothing returns booleanset Wj[$8C]='AC3W'call L1x('AC3W',false)return trueendfunctionfunction yMx takes nothing returns booleanset Wj[19]='AC0J'call L1x('AC0J',false)return trueendfunctionfunction ypx takes nothing returns booleanset Wj[$8F]='AC3Z'call L1x('AC3Z',false)return trueendfunctionfunction yPx takes nothing returns booleanset Wj[$91]='AC41'call L1x('AC41',false)return trueendfunctionfunction yqx takes nothing returns booleanset Wj[$92]='AC42'call L1x('AC42',false)return trueendfunctionfunction yQx takes nothing returns booleanset Wj['l']='AC30'call L1x('AC30',false)return trueendfunctionfunction ysx takes nothing returns booleanset Wj[$98]='AC48'call L1x('AC48',false)return trueendfunctionfunction ySx takes nothing returns booleanset Wj[$9A]='AC4A'call L1x('AC4A',false)return trueendfunctionfunction ytx takes nothing returns booleanset Wj[$9C]='AC4C'call L1x('AC4C',false)return trueendfunctionfunction yTx takes nothing returns booleanset Wj[$9D]='AC4D'call L1x('AC4D',false)return trueendfunctionfunction yux takes nothing returns booleanset Wj[$9E]='AC4E'call L1x('AC4E',false)return trueendfunctionfunction yUx takes nothing returns booleanset Wj[$93]='AC43'call L1x('AC43',false)return trueendfunctionfunction ywx takes nothing returns booleanset Wj[$A0]='AC4G'call L1x('AC4G',false)return trueendfunctionfunction yWx takes nothing returns booleanset Wj[$A5]='AC4L'call L1x('AC4L',false)return trueendfunctionfunction yyx takes nothing returns booleanset Wj[$A7]='AC4N'call L1x('AC4N',false)return trueendfunctionfunction yYx takes nothing returns booleanset Wj['k']='AC2Z'call L1x('AC2Z',false)return trueendfunctionfunction yzx takes nothing returns booleanset Wj[$A9]='AC4P'call L1x('AC4P',false)return trueendfunctionfunction yZx takes nothing returns booleanset Wj[$AA]='AC4Q'call L1x('AC4Q',false)return trueendfunctionfunction y_x takes nothing returns booleanset Wj[$AD]='AC4T'call L1x('AC4T',false)return trueendfunctionfunction y0x takes nothing returns booleanset Wj[$B3]='AC4Z'call L1x('AC4Z',false)return trueendfunctionfunction y1x takes nothing returns booleanset Wj[$B5]='AC51'call L1x('AC51',false)return trueendfunctionfunction y2x takes nothing returns booleanset Wj['p']='AC34'call L1x('AC34',false)return trueendfunctionfunction y3x takes nothing returns booleanset Wj[$B6]='AC52'call L1x('AC52',false)return trueendfunctionfunction y4x takes nothing returns booleanset Wj['h']='AC2W'call L1x('AC2W',false)return trueendfunctionfunction y5x takes nothing returns booleanset Wj[$BD]='AC59'call L1x('AC59',false)return trueendfunctionfunction y6x takes nothing returns booleanset Wj[$96]='AC46'call L1x('AC46',false)return trueendfunctionfunction y7x takes nothing returns booleanset Wj[$BE]='AC5A'call L1x('AC5A',false)return trueendfunctionfunction y8x takes nothing returns booleanset Wj[$C0]='AC5C'call L1x('AC5C',false)return trueendfunctionfunction y9x takes nothing returns booleanset Wj[$C1]='AC5D'call L1x('AC5D',false)return trueendfunctionfunction Yvx takes nothing returns booleanset Wj[$C2]='AC5E'call L1x('AC5E',false)return trueendfunctionfunction Yex takes nothing returns booleanset Wj[$C3]='AC5F'call L1x('AC5F',false)return trueendfunctionfunction Yxx takes nothing returns booleanset Wj[$C8]='AC5K'call L1x('AC5K',false)return trueendfunctionfunction Yox takes nothing returns booleanset Wj[$CC]='AC5O'call L1x('AC5O',false)return trueendfunctionfunction Yrx takes nothing returns booleanset Wj[$CF]='AC5R'call L1x('AC5R',false)return trueendfunctionfunction Yix takes nothing returns booleanset Wj[$D0]='AC5S'call L1x('AC5S',false)return trueendfunctionfunction Yax takes nothing returns booleanset Wj[$D2]='AC5U'call L1x('AC5U',false)return trueendfunctionfunction Ynx takes nothing returns booleanset Wj[$D3]='AC5V'call L1x('AC5V',false)return trueendfunctionfunction YVx takes nothing returns booleanset Wj[$DC]='AC64'call L1x('AC64',false)return trueendfunctionfunction YEx takes nothing returns booleanset Wj[$DE]='AC66'call L1x('AC66',false)return trueendfunctionfunction YXx takes nothing returns booleanset Wj[$E1]='AC69'call L1x('AC69',false)return trueendfunctionfunction YOx takes nothing returns booleanset Wj[$E2]='AC6A'call L1x('AC6A',false)return trueendfunctionfunction YRx takes nothing returns booleanset Wj[$E3]='AC6B'call L1x('AC6B',false)return trueendfunctionfunction YIx takes nothing returns booleanset Wj[$E6]='AC6E'call L1x('AC6E',false)return trueendfunctionfunction YAx takes nothing returns booleanset Wj[$E8]='AC6G'call L1x('AC6G',false)return trueendfunctionfunction YNx takes nothing returns booleanset Wj[$E9]='AC6H'call L1x('AC6H',false)return trueendfunctionfunction Ybx takes nothing returns booleanset Wj[$EA]='AC6I'call L1x('AC6I',false)return trueendfunctionfunction YBx takes nothing returns booleanset Wj[$EB]='AC6J'call L1x('AC6J',false)return trueendfunctionfunction Ycx takes nothing returns booleanset Wj[$EE]='AC6M'call L1x('AC6M',false)return trueendfunctionfunction YCx takes nothing returns booleanset Wj[$F2]='AC6Q'call L1x('AC6Q',false)return trueendfunctionfunction Ydx takes nothing returns booleanset Wj[$F3]='AC6R'call L1x('AC6R',false)return trueendfunctionfunction YDx takes nothing returns booleanset Wj[$F4]='AC6S'call L1x('AC6S',false)return trueendfunctionfunction Yfx takes nothing returns booleanset Wj[$F5]='AC6T'call L1x('AC6T',false)return trueendfunctionfunction YFx takes nothing returns booleanset Wj[$F6]='AC6U'call L1x('AC6U',false)return trueendfunctionfunction Ygx takes nothing returns booleanset Wj[$F7]='AC6V'call L1x('AC6V',false)return trueendfunctionfunction YGx takes nothing returns booleanset Wj[$FA]='AC6Y'call L1x('AC6Y',false)return trueendfunctionfunction Yhx takes nothing returns booleanset Wj[$FB]='AC6Z'call L1x('AC6Z',false)return trueendfunctionfunction YHx takes nothing returns booleanset Wj[$FC]='AC70'call L1x('AC70',false)return trueendfunctionfunction Yjx takes nothing returns booleanset Wj[$FE]='AC72'call L1x('AC72',false)return trueendfunctionfunction YJx takes nothing returns booleanset Wj[256]='AC74'call L1x('AC74',false)return trueendfunctionfunction Ykx takes nothing returns booleanset Wj[257]='AC75'call L1x('AC75',false)return trueendfunctionfunction YKx takes nothing returns booleanset Wj[258]='AC76'call L1x('AC76',false)return trueendfunctionfunction Ylx takes nothing returns booleanset Wj[259]='AC77'call L1x('AC77',false)return trueendfunctionfunction YLx takes nothing returns booleanset Wj[260]='AC78'call L1x('AC78',false)return trueendfunctionfunction Ymx takes nothing returns booleanset Wj[261]='AC79'call L1x('AC79',false)return trueendfunctionfunction YMx takes nothing returns booleanset Wj[263]='AC7B'call L1x('AC7B',false)return trueendfunctionfunction Ypx takes nothing returns booleanset Wj[266]='AC7E'call L1x('AC7E',false)return trueendfunctionfunction YPx takes nothing returns booleanset Wj[267]='AC7F'call L1x('AC7F',false)return trueendfunctionfunction Yqx takes nothing returns booleanset Wj[268]='AC7G'call L1x('AC7G',false)return trueendfunctionfunction YQx takes nothing returns booleanset Wj[269]='AC7H'call L1x('AC7H',false)return trueendfunctionfunction Ysx takes nothing returns booleanset Wj[270]='AC7I'call L1x('AC7I',false)return trueendfunctionfunction YSx takes nothing returns booleanset Wj[275]='AC7N'call L1x('AC7N',false)return trueendfunctionfunction Ytx takes nothing returns booleanset Wj[427]='ACBV'call L1x('ACBV',false)return trueendfunctionfunction YTx takes nothing returns booleanset Wj[276]='AC7O'call L1x('AC7O',false)return trueendfunctionfunction Yux takes nothing returns booleanset Wj[277]='AC7P'call L1x('AC7P',false)return trueendfunctionfunction YUx takes nothing returns booleanset Wj[278]='AC7Q'call L1x('AC7Q',false)return trueendfunctionfunction Ywx takes nothing returns booleanset Wj[279]='AC7R'call L1x('AC7R',false)return trueendfunctionfunction YWx takes nothing returns booleanset Wj[27]='AC0R'call L1x('AC0R',false)return trueendfunctionfunction Yyx takes nothing returns booleanset Wj[282]='AC7U'call L1x('AC7U',false)return trueendfunctionfunction YYx takes nothing returns booleanset Wj[284]='AC7W'call L1x('AC7W',false)return trueendfunctionfunction Yzx takes nothing returns booleanset Wj['d']='AC2S'call L1x('AC2S',false)return trueendfunctionfunction YZx takes nothing returns booleanset Wj[286]='AC7Y'call L1x('AC7Y',false)return trueendfunctionfunction Y_x takes nothing returns booleanset Wj[289]='AC81'call L1x('AC81',false)return trueendfunctionfunction Y0x takes nothing returns booleanset Wj[290]='AC82'call L1x('AC82',false)return trueendfunctionfunction Y1x takes nothing returns booleanset Wj[291]='AC83'call L1x('AC83',false)return trueendfunctionfunction Y2x takes nothing returns booleanset Wj[292]='AC84'call L1x('AC84',false)return trueendfunctionfunction Y3x takes nothing returns booleanset Wj[$E]='AC0E'call L1x('AC0E',false)return trueendfunctionfunction Y4x takes nothing returns booleanset Wj[294]='AC86'call L1x('AC86',false)return trueendfunctionfunction Y5x takes nothing returns booleanset Wj[295]='AC87'call L1x('AC87',false)return trueendfunctionfunction Y6x takes nothing returns booleanset Wj[298]='AC8A'call L1x('AC8A',false)return trueendfunctionfunction Y7x takes nothing returns booleanset Wj[299]='AC8B'call L1x('AC8B',false)return trueendfunctionfunction Y8x takes nothing returns booleanset Wj[301]='AC8D'call L1x('AC8D',false)return trueendfunctionfunction Y9x takes nothing returns booleanset Wj[302]='AC8E'call L1x('AC8E',false)return trueendfunctionfunction zvx takes nothing returns booleanset Wj['g']='AC2V'call L1x('AC2V',false)return trueendfunctionfunction zex takes nothing returns booleanset Wj[303]='AC8F'call L1x('AC8F',false)return trueendfunctionfunction zxx takes nothing returns booleanset Wj[304]='AC8G'call L1x('AC8G',false)return trueendfunctionfunction zox takes nothing returns booleanset Wj[305]='AC8H'call L1x('AC8H',false)return trueendfunctionfunction zrx takes nothing returns booleanset Wj[306]='AC8I'call L1x('AC8I',false)return trueendfunctionfunction zix takes nothing returns booleanset Wj[307]='AC8J'call L1x('AC8J',false)return trueendfunctionfunction zax takes nothing returns booleanset Wj[308]='AC8K'call L1x('AC8K',false)return trueendfunctionfunction znx takes nothing returns booleanset Wj[30]='AC0U'call L1x('AC0U',false)return trueendfunctionfunction zVx takes nothing returns booleanset Wj[310]='AC8M'call L1x('AC8M',false)return trueendfunctionfunction zEx takes nothing returns booleanset Wj[311]='AC8N'call L1x('AC8N',false)return trueendfunctionfunction zXx takes nothing returns booleanset Wj[312]='AC8O'call L1x('AC8O',false)return trueendfunctionfunction zOx takes nothing returns booleanset Wj[313]='AC8P'call L1x('AC8P',false)return trueendfunctionfunction zRx takes nothing returns booleanset Wj['i']='AC2X'call L1x('AC2X',false)return trueendfunctionfunction zIx takes nothing returns booleanset Wj[317]='AC8T'call L1x('AC8T',false)return trueendfunctionfunction zAx takes nothing returns booleanset Wj[319]='AC8V'call L1x('AC8V',false)return trueendfunctionfunction zNx takes nothing returns booleanset Wj[83]='AC2B'call L1x('AC2B',false)return trueendfunctionfunction zbx takes nothing returns booleanset Wj[321]='AC8X'call L1x('AC8X',false)return trueendfunctionfunction zBx takes nothing returns booleanset Wj[322]='AC8Y'call L1x('AC8Y',false)return trueendfunctionfunction zcx takes nothing returns booleanset Wj[323]='AC8Z'call L1x('AC8Z',false)return trueendfunctionfunction zCx takes nothing returns booleanset Wj[326]='AC92'call L1x('AC92',false)return trueendfunctionfunction zdx takes nothing returns booleanset Wj['j']='AC2Y'call L1x('AC2Y',false)return trueendfunctionfunction zDx takes nothing returns booleanset Wj[1]='AC01'
call L1x('AC01',false)return trueendfunctionfunction zfx takes nothing returns booleanset Wj[327]='AC93'call L1x('AC93',false)return trueendfunctionfunction zFx takes nothing returns booleanset Wj[9]='AC09'
call L1x('AC09',false)return trueendfunctionfunction zgx takes nothing returns booleanset Wj[331]='AC97'call L1x('AC97',false)return trueendfunctionfunction zGx takes nothing returns booleanset Wj[335]='AC9B'call L1x('AC9B',false)return trueendfunctionfunction zhx takes nothing returns booleanset Wj[336]='AC9C'call L1x('AC9C',false)return trueendfunctionfunction zHx takes nothing returns booleanset Wj[337]='AC9D'call L1x('AC9D',false)return trueendfunctionfunction zjx takes nothing returns booleanset Wj[339]='AC9F'call L1x('AC9F',false)return trueendfunctionfunction zJx takes nothing returns booleanset Wj[340]='AC9G'call L1x('AC9G',false)return trueendfunctionfunction zkx takes nothing returns booleanset OJ=ltx(a_v+" (transBuff)")set Pc[(OJ)]=(true)return trueendfunctionfunction zKx takes nothing returns booleanset Wj[341]='AC9H'call L1x('AC9H',false)return trueendfunctionfunction zlx takes nothing returns booleanset Wj[346]='AC9M'call L1x('AC9M',false)return trueendfunctionfunction zLx takes nothing returns booleanset Wj[347]='AC9N'call L1x('AC9N',false)return trueendfunctionfunction zmx takes nothing returns booleanset Wj[34]='AC0Y'call L1x('AC0Y',false)return trueendfunctionfunction zMx takes nothing returns booleanset Wj[350]='AC9Q'call L1x('AC9Q',false)return trueendfunctionfunction zpx takes nothing returns booleanset Wj[351]='AC9R'call L1x('AC9R',false)return trueendfunctionfunction zPx takes nothing returns booleanset Wj[352]='AC9S'call L1x('AC9S',false)return trueendfunctionfunction zqx takes nothing returns booleanset Wj[355]='AC9V'call L1x('AC9V',false)return trueendfunctionfunction zQx takes nothing returns booleanset Wj[358]='AC9Y'call L1x('AC9Y',false)return trueendfunctionfunction zsx takes nothing returns booleanset Wj[359]='AC9Z'call L1x('AC9Z',false)return trueendfunctionfunction zSx takes nothing returns booleanset Wj[$D]='AC0D'call L1x('AC0D',false)return trueendfunctionfunction ztx takes nothing returns booleanset Wj[35]='AC0Z'call L1x('AC0Z',false)return trueendfunctionfunction zTx takes nothing returns booleanset Wj[360]='ACA0'call L1x('ACA0',false)return trueendfunctionfunction zux takes nothing returns booleanset Wj[361]='ACA1'call L1x('ACA1',false)return trueendfunctionfunction zUx takes nothing returns booleanset Wj[364]='ACA4'call L1x('ACA4',false)return trueendfunctionfunction zwx takes nothing returns booleanset Wj[367]='ACA7'call L1x('ACA7',false)return trueendfunctionfunction zWx takes nothing returns booleanset Wj[36]='AC10'call L1x('AC10',false)return trueendfunctionfunction zyx takes nothing returns booleanset Wj[370]='ACAA'call L1x('ACAA',false)return trueendfunctionfunction zYx takes nothing returns booleanset Wj[371]='ACAB'call L1x('ACAB',false)return trueendfunctionfunction zzx takes nothing returns booleanset Wj[372]='ACAC'call L1x('ACAC',false)return trueendfunctionfunction zZx takes nothing returns booleanset Wj[375]='ACAF'call L1x('ACAF',false)return trueendfunctionfunction z_x takes nothing returns booleanset Wj[376]='ACAG'call L1x('ACAG',false)return trueendfunctionfunction z0x takes nothing returns booleanset Wj[37]='AC11'call L1x('AC11',false)return trueendfunctionfunction z1x takes nothing returns booleanset Wj['u']='AC39'call L1x('AC39',false)return trueendfunctionfunction z2x takes nothing returns booleanset Wj[380]='ACAK'call L1x('ACAK',false)return trueendfunctionfunction z3x takes nothing returns booleanset Wj[381]='ACAL'call L1x('ACAL',false)return trueendfunctionfunction z4x takes nothing returns booleanset Wj[382]='ACAM'call L1x('ACAM',false)return trueendfunctionfunction z5x takes nothing returns booleanset Wj[383]='ACAN'call L1x('ACAN',false)return trueendfunctionfunction z6x takes nothing returns booleanset Wj[384]='ACAO'call L1x('ACAO',false)return trueendfunctionfunction z7x takes nothing returns booleanset Wj[385]='ACAP'call L1x('ACAP',false)return trueendfunctionfunction z8x takes nothing returns booleanset Wj[387]='ACAR'call L1x('ACAR',false)return trueendfunctionfunction z9x takes nothing returns booleanset Wj[388]='ACAS'call L1x('ACAS',false)return trueendfunctionfunction Zvx takes nothing returns booleanset Wj[389]='ACAT'call L1x('ACAT',false)return trueendfunctionfunction Zex takes nothing returns booleanset Wj[38]='AC12'call L1x('AC12',false)return trueendfunctionfunction Zxx takes nothing returns booleanset Wj[391]='ACAV'call L1x('ACAV',false)return trueendfunctionfunction Zox takes nothing returns booleanset Wj[392]='ACAW'call L1x('ACAW',false)return trueendfunctionfunction Zrx takes nothing returns booleanset Wj[393]='ACAX'call L1x('ACAX',false)return trueendfunctionfunction Zix takes nothing returns booleanset Wj[395]='ACAZ'call L1x('ACAZ',false)return trueendfunctionfunction Zax takes nothing returns booleanset Wj[396]='ACB0'call L1x('ACB0',false)return trueendfunctionfunction Znx takes nothing returns booleanset Wj[296]='AC88'call L1x('AC88',false)return trueendfunctionfunction ZVx takes nothing returns booleanset Wj[280]='AC7S'call L1x('AC7S',false)return trueendfunctionfunction ZEx takes nothing returns booleanset Wj[400]='ACB4'call L1x('ACB4',false)return trueendfunctionfunction ZXx takes nothing returns booleanset Wj[403]='ACB7'call L1x('ACB7',false)return trueendfunctionfunction ZOx takes nothing returns booleanset Wj[404]='ACB8'call L1x('ACB8',false)return trueendfunctionfunction ZRx takes nothing returns booleanset Wj[405]='ACB9'call L1x('ACB9',false)return trueendfunctionfunction ZIx takes nothing returns booleanset Wj[40]='AC14'call L1x('AC14',false)return trueendfunctionfunction ZAx takes nothing returns booleanset Wj[413]='ACBH'call L1x('ACBH',false)return trueendfunctionfunction ZNx takes nothing returns booleanset Wj[417]='ACBL'call L1x('ACBL',false)return trueendfunctionfunction Zbx takes nothing returns booleanset Wj[419]='ACBN'call L1x('ACBN',false)return trueendfunctionfunction ZBx takes nothing returns booleanset Wj[41]='AC15'call L1x('AC15',false)return trueendfunctionfunction Zcx takes nothing returns booleanset Wj[420]='ACBO'call L1x('ACBO',false)return trueendfunctionfunction ZCx takes nothing returns booleanset Wj[285]='AC7X'call L1x('AC7X',false)return trueendfunctionfunction Zdx takes nothing returns booleanset Wj[421]='ACBP'call L1x('ACBP',false)return trueendfunctionfunction ZDx takes nothing returns booleanset Wj[422]='ACBQ'call L1x('ACBQ',false)return trueendfunctionfunction Zfx takes nothing returns booleanset Wj[423]='ACBR'call L1x('ACBR',false)return trueendfunctionfunction ZFx takes nothing returns booleanset Wj[424]='ACBS'call L1x('ACBS',false)return trueendfunctionfunction Zgx takes nothing returns booleanset Wj[425]='ACBT'call L1x('ACBT',false)return trueendfunctionfunction ZGx takes nothing returns booleanset Wj[429]='ACBX'call L1x('ACBX',false)return trueendfunctionfunction Zhx takes nothing returns booleanset Wj[42]='AC16'call L1x('AC16',false)return trueendfunctionfunction ZHx takes nothing returns booleanset Wj[431]='ACBZ'call L1x('ACBZ',false)return trueendfunctionfunction Zjx takes nothing returns booleanset Wj[433]='ACC1'call L1x('ACC1',false)return trueendfunctionfunction ZJx takes nothing returns booleanset Wj[436]='ACC4'call L1x('ACC4',false)return trueendfunctionfunction Zkx takes nothing returns booleanset Wj[$A]='AC0A'call L1x('AC0A',false)return trueendfunctionfunction ZKx takes nothing returns booleanset Wj[43]='AC17'call L1x('AC17',false)return trueendfunctionfunction Zlx takes nothing returns booleanset Wj[442]='ACCA'call L1x('ACCA',false)return trueendfunctionfunction ZLx takes nothing returns booleanset Wj[5]='AC05'
call L1x('AC05',false)return trueendfunctionfunction Zmx takes nothing returns booleanset Wj[$7F]='AC3J'call L1x('AC3J',false)return trueendfunctionfunction ZMx takes nothing returns booleanset Wj[445]='ACCD'call L1x('ACCD',false)return trueendfunctionfunction Zpx takes nothing returns booleanset Wj[447]='ACCF'call L1x('ACCF',false)return trueendfunctionfunction ZPx takes nothing returns booleanset Wj[363]='ACA3'call L1x('ACA3',false)return trueendfunctionfunction Zqx takes nothing returns booleanset Wj[44]='AC18'call L1x('AC18',false)return trueendfunctionfunction ZQx takes nothing returns booleanset Wj[452]='ACCK'call L1x('ACCK',false)return trueendfunctionfunction Zsx takes nothing returns booleanset Wj[456]='ACCO'call L1x('ACCO',false)return trueendfunctionfunction ZSx takes nothing returns booleanset Wj[458]='ACCQ'call L1x('ACCQ',false)return trueendfunctionfunction Ztx takes nothing returns booleanset Wj[459]='ACCR'call L1x('ACCR',false)return trueendfunctionfunction ZTx takes nothing returns booleanset Wj[460]='ACCS'call L1x('ACCS',false)return trueendfunctionfunction Zux takes nothing returns booleanset Wj[461]='ACCT'call L1x('ACCT',false)return trueendfunctionfunction ZUx takes nothing returns booleanset Wj[462]='ACCU'call L1x('ACCU',false)return trueendfunctionfunction Zwx takes nothing returns booleanset Wj[463]='ACCV'call L1x('ACCV',false)return trueendfunctionfunction ZWx takes nothing returns booleanset Wj[464]='ACCW'call L1x('ACCW',false)return trueendfunctionfunction Zyx takes nothing returns booleanset Wj[465]='ACCX'call L1x('ACCX',false)return trueendfunctionfunction ZYx takes nothing returns booleanset Wj[467]='ACCZ'call L1x('ACCZ',false)return trueendfunctionfunction Zzx takes nothing returns booleanset Wj[8]='AC08'
call L1x('AC08',false)return trueendfunctionfunction ZZx takes nothing returns booleanset Wj[468]='ACD0'call L1x('ACD0',false)return trueendfunctionfunction Z_x takes nothing returns booleanset Wj[470]='ACD2'call L1x('ACD2',false)return trueendfunctionfunction Z0x takes nothing returns booleanset Wj[471]='ACD3'call L1x('ACD3',false)return trueendfunctionfunction Z1x takes nothing returns booleanset Wj[473]='ACD5'call L1x('ACD5',false)return trueendfunctionfunction Z2x takes nothing returns booleanset Wj[475]='ACD7'call L1x('ACD7',false)return trueendfunctionfunction Z3x takes nothing returns booleanset Wj[476]='ACD8'call L1x('ACD8',false)return trueendfunctionfunction Z4x takes nothing returns booleanset Wj[478]='ACDA'call L1x('ACDA',false)return trueendfunctionfunction Z5x takes nothing returns booleanset Wj[479]='ACDB'call L1x('ACDB',false)return trueendfunctionfunction Z6x takes nothing returns booleanset Wj[47]='AC1B'call L1x('AC1B',false)return trueendfunctionfunction Z7x takes nothing returns booleanset Wj[480]='ACDC'call L1x('ACDC',false)return trueendfunctionfunction Z8x takes nothing returns booleanset Wj[482]='ACDE'call L1x('ACDE',false)return trueendfunctionfunction Z9x takes nothing returns booleanset Wj[484]='ACDG'call L1x('ACDG',false)return trueendfunctionfunction vvo takes nothing returns booleanset Wj[487]='ACDJ'call L1x('ACDJ',false)return trueendfunctionfunction veo takes nothing returns booleanset Wj[488]='ACDK'call L1x('ACDK',false)return trueendfunctionfunction vxo takes nothing returns booleanset Wj[489]='ACDL'call L1x('ACDL',false)return trueendfunctionfunction voo takes nothing returns booleanset Wj[48]='AC1C'call L1x('AC1C',false)return trueendfunctionfunction vro takes nothing returns booleanset Wj[490]='ACDM'call L1x('ACDM',false)return trueendfunctionfunction vio takes nothing returns booleanset Wj[491]='ACDN'call L1x('ACDN',false)return trueendfunctionfunction vao takes nothing returns booleanset Wj['x']='AC3C'call L1x('AC3C',false)return trueendfunctionfunction vno takes nothing returns booleanset Wj[492]='ACDO'call L1x('ACDO',false)return trueendfunctionfunction vVo takes nothing returns booleanset Wj[493]='ACDP'call L1x('ACDP',false)return trueendfunctionfunction vEo takes nothing returns booleanset Wj[494]='ACDQ'call L1x('ACDQ',false)return trueendfunctionfunction vXo takes nothing returns booleanset Wj[495]='ACDR'call L1x('ACDR',false)return trueendfunctionfunction vOo takes nothing returns booleanset Wj[498]='ACDU'call L1x('ACDU',false)return trueendfunctionfunction vRo takes nothing returns booleanset Wj[500]='ACDW'call L1x('ACDW',false)return trueendfunctionfunction vIo takes nothing returns booleanset Wj[50]='AC1E'call L1x('AC1E',false)return trueendfunctionfunction vAo takes nothing returns booleanset Wj[52]='AC1G'call L1x('AC1G',false)return trueendfunctionfunction vNo takes nothing returns booleanset Wj[53]='AC1H'call L1x('AC1H',false)return trueendfunctionfunction vbo takes nothing returns booleanset Wj[54]='AC1I'call L1x('AC1I',false)return trueendfunctionfunction vBo takes nothing returns booleanset Wj[55]='AC1J'call L1x('AC1J',false)return trueendfunctionfunction vco takes nothing returns booleanset Wj[57]='AC1L'call L1x('AC1L',false)return trueendfunctionfunction vCo takes nothing returns booleanset Wj[58]='AC1M'call L1x('AC1M',false)return trueendfunctionfunction vdo takes nothing returns booleanset Wj[59]='AC1N'call L1x('AC1N',false)return trueendfunctionfunction vDo takes nothing returns booleanset Wj[362]='ACA2'call L1x('ACA2',false)return trueendfunctionfunction vfo takes nothing returns booleanset Wj[60]='AC1O'call L1x('AC1O',false)return trueendfunctionfunction vFo takes nothing returns booleanset Wj[63]='AC1R'call L1x('AC1R',false)return trueendfunctionfunction vgo takes nothing returns booleanset Wj[65]='AC1T'call L1x('AC1T',false)return trueendfunctionfunction vGo takes nothing returns booleanset Wj[67]='AC1V'call L1x('AC1V',false)return trueendfunctionfunction vho takes nothing returns booleanset Wj[71]='AC1Z'call L1x('AC1Z',false)return trueendfunctionfunction vHo takes nothing returns booleanset Wj[72]='AC20'call L1x('AC20',false)return trueendfunctionfunction vjo takes nothing returns booleanset Wj[74]='AC22'call L1x('AC22',false)return trueendfunctionfunction vJo takes nothing returns booleanset Wj[79]='AC27'call L1x('AC27',false)return trueendfunctionfunction vko takes nothing returns booleanset Wj[82]='AC2A'call L1x('AC2A',false)return trueendfunctionfunction vKo takes nothing returns booleanset Wj[85]='AC2D'call L1x('AC2D',false)return trueendfunctionfunction vlo takes nothing returns booleanset Wj[86]='AC2E'call L1x('AC2E',false)return trueendfunctionfunction vLo takes nothing returns booleanset Wj[88]='AC2G'call L1x('AC2G',false)return trueendfunctionfunction vmo takes nothing returns booleanset Wj[89]='AC2H'call L1x('AC2H',false)return trueendfunctionfunction vMo takes nothing returns booleanset Wj[90]='AC2I'call L1x('AC2I',false)return trueendfunctionfunction vpo takes nothing returns booleanset Wj[70]='AC1Y'call L1x('AC1Y',false)return trueendfunctionfunction vPo takes nothing returns booleanset Wj[93]='AC2L'call L1x('AC2L',false)return trueendfunctionfunction vqo takes nothing returns booleanset Wj[94]='AC2M'call L1x('AC2M',false)return trueendfunctionfunction vQo takes nothing returns booleanset Wj[96]='AC2O'call L1x('AC2O',false)return trueendfunctionfunction vso takes nothing returns booleanset Wj[$AC]='AC4S'call L1x('AC4S',false)return trueendfunctionfunction vSo takes nothing returns booleanset Wj[$A6]='AC4M'call L1x('AC4M',false)return trueendfunctionfunction vto takes nothing returns booleanset Wj[330]='AC96'call L1x('AC96',false)return trueendfunctionfunction vTo takes nothing returns booleanset Wj[$BF]='AC5B'call L1x('AC5B',false)return trueendfunctionfunction vuo takes nothing returns booleanset Wj[7]='AC07'
call L1x('AC07',false)return trueendfunctionfunction vUo takes nothing returns booleanset Wj[32]='AC0W'call L1x('AC0W',false)return trueendfunctionfunction vwo takes nothing returns booleanset Wj[374]='ACAE'call L1x('ACAE',false)return trueendfunctionfunction vWo takes nothing returns booleanset Wj[287]='AC7Z'call L1x('AC7Z',false)return trueendfunctionfunction vyo takes nothing returns booleanset Wj[16]='AC0G'call L1x('AC0G',false)return trueendfunctionfunction vYo takes nothing returns booleanset Wj[$F9]='AC6X'call L1x('AC6X',false)return trueendfunctionfunction vzo takes nothing returns booleanset Wj[$FF]='AC73'call L1x('AC73',false)return trueendfunctionfunction vZo takes nothing returns booleanset Wj[80]='AC28'call L1x('AC28',false)return trueendfunctionfunction v_o takes nothing returns booleanset Wj[$89]='AC3T'call L1x('AC3T',false)return trueendfunctionfunction v0o takes nothing returns booleanset Wj[450]='ACCI'call L1x('ACCI',false)return trueendfunctionfunction v1o takes nothing returns booleanset Wj[99]='AC2R'call L1x('AC2R',false)return trueendfunctionfunction v2o takes nothing returns booleanset Wj[469]='ACD1'call L1x('ACD1',false)return trueendfunctionfunction v3o takes nothing returns booleanset Wj[$E7]='AC6F'call L1x('AC6F',false)return trueendfunctionfunction v4o takes nothing returns booleanset Wj[281]='AC7T'call L1x('AC7T',false)return trueendfunctionfunction v5o takes nothing returns booleanset Wj[377]='ACAH'call L1x('ACAH',false)return trueendfunctionfunction v6o takes nothing returns booleanset Wj[333]='AC99'call L1x('AC99',false)return trueendfunctionfunction v7o takes nothing returns booleanset Wj[84]='AC2C'call L1x('AC2C',false)return trueendfunctionfunction v8o takes nothing returns booleanset Wj[397]='ACB1'call L1x('ACB1',false)return trueendfunctionfunction v9o takes nothing returns booleanset Wj[$DF]='AC67'call L1x('AC67',false)return trueendfunctionfunction evo takes nothing returns booleanset Wj[$82]='AC3M'call L1x('AC3M',false)return trueendfunctionfunction eeo takes nothing returns booleanset Wj['z']='AC3E'call L1x('AC3E',false)return trueendfunctionfunction exo takes nothing returns booleanset Wj[$D4]='AC5W'call L1x('AC5W',false)return trueendfunctionfunction eoo takes nothing returns booleanset Wj[$8B]='AC3V'call L1x('AC3V',false)return trueendfunctionfunction ero takes nothing returns booleanset Wj[437]='ACC5'call L1x('ACC5',false)return trueendfunctionfunction eio takes nothing returns booleanset Wj[21]='AC0L'call L1x('AC0L',false)return trueendfunctionfunction eao takes nothing returns booleanset Wj[$E5]='AC6D'call L1x('AC6D',false)return trueendfunctionfunction eno takes nothing returns booleanset Wj[446]='ACCE'call L1x('ACCE',false)return trueendfunctionfunction eVo takes nothing returns booleanset Wj[$F]='AC0F'call L1x('AC0F',false)return trueendfunctionfunction eEo takes nothing returns booleanset Wj[453]='ACCL'call L1x('ACCL',false)return trueendfunctionfunction eXo takes nothing returns booleanset Wj[64]='AC1S'call L1x('AC1S',false)return trueendfunctionfunction eOo takes nothing returns booleanset Wj[0]='AC00'
call L1x('AC00',false)return trueendfunctionfunction eRo takes nothing returns booleanset Wj[24]='AC0O'call L1x('AC0O',false)return trueendfunctionfunction eIo takes nothing returns booleanset Wj[$B]='AC0B'call L1x('AC0B',false)return trueendfunctionfunction eAo takes nothing returns booleanset Wj[455]='ACCN'call L1x('ACCN',false)return trueendfunctionfunction eNo takes nothing returns booleanset Wj[288]='AC80'call L1x('AC80',false)return trueendfunctionfunction ebo takes nothing returns booleanset Wj[3]='AC03'
call L1x('AC03',false)return trueendfunctionfunction eBo takes nothing returns booleanset Wj[78]='AC26'call L1x('AC26',false)return trueendfunctionfunction eco takes nothing returns booleanset Wj[$C9]='AC5L'call L1x('AC5L',false)return trueendfunctionfunction eCo takes nothing returns booleanset Wj[472]='ACD4'call L1x('ACD4',false)return trueendfunctionfunction edo takes nothing returns booleanset Wj[325]='AC91'call L1x('AC91',false)return trueendfunctionfunction eDo takes nothing returns booleanset Wj[$85]='AC3P'call L1x('AC3P',false)return trueendfunctionfunction efo takes nothing returns booleanset Wj[81]='AC29'call L1x('AC29',false)return trueendfunctionfunction eFo takes nothing returns booleanset Wj[$D9]='AC61'call L1x('AC61',false)return trueendfunctionfunction ego takes nothing returns booleanset Wj[357]='AC9X'call L1x('AC9X',false)return trueendfunctionfunction eGo takes nothing returns booleanset Wj[$CE]='AC5Q'call L1x('AC5Q',false)return trueendfunctionfunction eho takes nothing returns booleanset Wj[95]='AC2N'call L1x('AC2N',false)return trueendfunctionfunction eHo takes nothing returns booleanset Wj['e']='AC2T'call L1x('AC2T',false)return trueendfunctionfunction ejo takes nothing returns booleanset Wj[448]='ACCG'call L1x('ACCG',false)return trueendfunctionfunction eJo takes nothing returns booleanset Wj[428]='ACBW'call L1x('ACBW',false)return trueendfunctionfunction eko takes nothing returns booleanset Wj[$B0]='AC4W'call L1x('AC4W',false)return trueendfunctionfunction eKo takes nothing returns booleanset Wj[69]='AC1X'call L1x('AC1X',false)return trueendfunctionfunction elo takes nothing returns booleanset Wj[$CD]='AC5P'call L1x('AC5P',false)return trueendfunctionfunction eLo takes nothing returns booleanset Wj[271]='AC7J'call L1x('AC7J',false)return trueendfunctionfunction emo takes nothing returns booleanset Wj[481]='ACDD'call L1x('ACDD',false)return trueendfunctionfunction eMo takes nothing returns booleanset Wj[$8D]='AC3X'call L1x('AC3X',false)return trueendfunctionfunction epo takes nothing returns booleanset Wj[412]='ACBG'call L1x('ACBG',false)return trueendfunctionfunction ePo takes nothing returns booleanset Wj[$99]='AC49'call L1x('AC49',false)return trueendfunctionfunction eqo takes nothing returns booleanset Wj[443]='ACCB'call L1x('ACCB',false)return trueendfunctionfunction eQo takes nothing returns booleanset Wj[328]='AC94'call L1x('AC94',false)return trueendfunctionfunction eso takes nothing returns booleanset Wj[390]='ACAU'call L1x('ACAU',false)return trueendfunctionfunction eSo takes nothing returns booleanset Wj[369]='ACA9'call L1x('ACA9',false)return trueendfunctionfunction eto takes nothing returns booleanset Wj[39]='AC13'call L1x('AC13',false)return trueendfunctionfunction eTo takes nothing returns booleanset Wj[418]='ACBM'call L1x('ACBM',false)return trueendfunctionfunction euo takes nothing returns booleanset Wj[474]='ACD6'call L1x('ACD6',false)return trueendfunctionfunction eUo takes nothing returns booleanset wj=ltx(a_v+" (moddedBuff)")return trueendfunctionfunction ewo takes nothing returns booleanset Wj[410]='ACBE'call L1x('ACBE',false)return trueendfunctionfunction eWo takes nothing returns booleanset Wj['n']='AC32'call L1x('AC32',false)return trueendfunctionfunction eyo takes nothing returns booleanset Wj[76]='AC24'call L1x('AC24',false)return trueendfunctionfunction eYo takes nothing returns booleanset Wj[342]='AC9I'call L1x('AC9I',false)return trueendfunctionfunction ezo takes nothing returns booleanset Wj[402]='ACB6'call L1x('ACB6',false)return trueendfunctionfunction eZo takes nothing returns booleanset Wj[$AF]='AC4V'call L1x('AC4V',false)return trueendfunctionfunction e_o takes nothing returns booleanset Wj[$FD]='AC71'call L1x('AC71',false)return trueendfunctionfunction e0o takes nothing returns booleanset Wj['o']='AC33'call L1x('AC33',false)return trueendfunctionfunction e1o takes nothing returns booleanset Wj['q']='AC35'call L1x('AC35',false)return trueendfunctionfunction e2o takes nothing returns booleanset Wj[373]='ACAD'call L1x('ACAD',false)return trueendfunctionfunction e3o takes nothing returns booleanset Wj[332]='AC98'call L1x('AC98',false)return trueendfunctionfunction e4o takes nothing returns booleanset Wj[$ED]='AC6L'call L1x('AC6L',false)return trueendfunctionfunction e5o takes nothing returns booleanset Wj[66]='AC1U'call L1x('AC1U',false)return trueendfunctionfunction e6o takes nothing returns booleanset Wj[324]='AC90'call L1x('AC90',false)return trueendfunctionfunction e7o takes nothing returns booleanset Wj[61]='AC1P'call L1x('AC1P',false)return trueendfunctionfunction e8o takes nothing returns booleanset Wj['}']='AC3H'call L1x('AC3H',false)return trueendfunctionfunction e9o takes nothing returns booleanset Wj[87]='AC2F'call L1x('AC2F',false)return trueendfunctionfunction xvo takes nothing returns booleanset Wj[379]='ACAJ'call L1x('ACAJ',false)return trueendfunctionfunction xeo takes nothing returns booleanset Wj[366]='ACA6'call L1x('ACA6',false)return trueendfunctionfunction xxo takes nothing returns booleanset Wj[407]='ACBB'call L1x('ACBB',false)return trueendfunctionfunction xoo takes nothing returns booleanset Wj[$A4]='AC4K'call L1x('AC4K',false)return trueendfunctionfunction xro takes nothing returns booleanset Wj[338]='AC9E'call L1x('AC9E',false)return trueendfunctionfunction xio takes nothing returns booleanset Wj[73]='AC21'call L1x('AC21',false)return trueendfunctionfunction xao takes nothing returns booleanset Wj[406]='ACBA'call L1x('ACBA',false)return trueendfunctionfunction xno takes nothing returns booleanset Wj[348]='AC9O'call L1x('AC9O',false)return trueendfunctionfunction xVo takes nothing returns booleanset Wj[$84]='AC3O'call L1x('AC3O',false)return trueendfunctionfunction xEo takes nothing returns booleanset Wj[$F1]='AC6P'call L1x('AC6P',false)return trueendfunctionfunction xXo takes nothing returns booleanset Wj[$DA]='AC62'call L1x('AC62',false)return trueendfunctionfunction xOo takes nothing returns booleanset Wj[439]='ACC7'call L1x('ACC7',false)return trueendfunctionfunction xRo takes nothing returns booleanset Wj[$A2]='AC4I'call L1x('AC4I',false)return trueendfunctionfunction xIo takes nothing returns booleanset Wj[399]='ACB3'call L1x('ACB3',false)return trueendfunctionfunction xAo takes nothing returns booleanset Wj[297]='AC89'call L1x('AC89',false)return trueendfunctionfunction xNo takes nothing returns booleanset Wj[51]='AC1F'call L1x('AC1F',false)return trueendfunctionfunction xbo takes nothing returns booleanset Wj[497]='ACDT'call L1x('ACDT',false)return trueendfunctionfunction xBo takes nothing returns booleanset Wj[272]='AC7K'call L1x('AC7K',false)return trueendfunctionfunction xco takes nothing returns booleanset Wj[$E4]='AC6C'call L1x('AC6C',false)return trueendfunctionfunction xCo takes nothing returns booleanset Wj[25]='AC0P'call L1x('AC0P',false)return trueendfunctionfunction xdo takes nothing returns booleanset Wj[98]='AC2Q'call L1x('AC2Q',false)return trueendfunctionfunction xDo takes nothing returns booleanset Wj[409]='ACBD'call L1x('ACBD',false)return trueendfunctionfunction xfo takes nothing returns booleanset Wj[28]='AC0S'call L1x('AC0S',false)return trueendfunctionfunction xFo takes nothing returns booleanset Wj[365]='ACA5'call L1x('ACA5',false)return trueendfunctionfunction xgo takes nothing returns booleanset Wj[45]='AC19'call L1x('AC19',false)return trueendfunctionfunction xGo takes nothing returns booleanset Wj[320]='AC8W'call L1x('AC8W',false)return trueendfunctionfunction xho takes nothing returns booleanset Wj[334]='AC9A'call L1x('AC9A',false)return trueendfunctionfunction xHo takes nothing returns booleanset Wj[426]='ACBU'call L1x('ACBU',false)return trueendfunctionfunction xjo takes nothing returns booleanset Wj[435]='ACC3'call L1x('ACC3',false)return trueendfunctionfunction xJo takes nothing returns booleanset Wj[$A1]='AC4H'call L1x('AC4H',false)return trueendfunctionfunction xko takes nothing returns booleanset Wj[75]='AC23'call L1x('AC23',false)return trueendfunctionfunction xKo takes nothing returns booleanset Wj[329]='AC95'call L1x('AC95',false)return trueendfunctionfunction xlo takes nothing returns booleanset Wj[31]='AC0V'call L1x('AC0V',false)return trueendfunctionfunction xLo takes nothing returns booleanset Wj[4]='AC04'
call L1x('AC04',false)return trueendfunctionfunction xmo takes nothing returns booleanset Wj[309]='AC8L'call L1x('AC8L',false)return trueendfunctionfunction xMo takes nothing returns booleanset Wj[2]='AC02'
call L1x('AC02',false)return trueendfunctionfunction xpo takes nothing returns booleanset Wj[33]='AC0X'call L1x('AC0X',false)return trueendfunctionfunction xPo takes nothing returns booleanset Wj[430]='ACBY'call L1x('ACBY',false)return trueendfunctionfunction xqo takes nothing returns booleanset Wj[457]='ACCP'call L1x('ACCP',false)return trueendfunctionfunction xQo takes nothing returns booleanset Wj[68]='AC1W'call L1x('AC1W',false)return trueendfunctionfunction xso takes nothing returns booleanset Wj[62]='AC1Q'call L1x('AC1Q',false)return trueendfunctionfunction xSo takes nothing returns booleanset Wj[262]='AC7A'call L1x('AC7A',false)return trueendfunctionfunction xto takes nothing returns booleanset Wj[274]='AC7M'call L1x('AC7M',false)return trueendfunctionfunction xTo takes nothing returns booleanset Wj[23]='AC0N'call L1x('AC0N',false)return trueendfunctionfunction xuo takes nothing returns booleanset Wj[414]='ACBI'call L1x('ACBI',false)return trueendfunctionfunction xUo takes nothing returns booleanset Wj[$EC]='AC6K'call L1x('AC6K',false)return trueendfunctionfunction xwo takes nothing returns booleanset Wj[432]='ACC0'call L1x('ACC0',false)return trueendfunctionfunction xWo takes nothing returns booleanset Wj[22]='AC0M'call L1x('AC0M',false)return trueendfunctionfunction xyo takes nothing returns booleanset Wj[451]='ACCJ'call L1x('ACCJ',false)return trueendfunctionfunction xYo takes nothing returns booleanset Wj[$80]='AC3K'call L1x('AC3K',false)return trueendfunctionfunction xzo takes nothing returns booleanset Wj[$C7]='AC5J'call L1x('AC5J',false)return trueendfunctionfunction xZo takes nothing returns booleanset Wj[483]='ACDF'call L1x('ACDF',false)return trueendfunctionfunction x_o takes nothing returns booleanset Wj[$A8]='AC4O'call L1x('AC4O',false)return trueendfunctionfunction x0o takes nothing returns booleanset Wj[264]='AC7C'call L1x('AC7C',false)return trueendfunctionfunction x1o takes nothing returns booleanset Wj[$C6]='AC5I'call L1x('AC5I',false)return trueendfunctionfunction x2o takes nothing returns booleanset Wj[273]='AC7L'call L1x('AC7L',false)return trueendfunctionfunction x3o takes nothing returns booleanset Wj[345]='AC9L'call L1x('AC9L',false)return trueendfunctionfunction x4o takes nothing returns booleanset Wj[46]='AC1A'call L1x('AC1A',false)return trueendfunctionfunction x5o takes nothing returns booleanset Wj[$B9]='AC55'call L1x('AC55',false)return trueendfunctionfunction x6o takes nothing returns booleanset Wj[$E0]='AC68'call L1x('AC68',false)return trueendfunctionfunction x7o takes nothing returns booleanset Wj[77]='AC25'call L1x('AC25',false)return trueendfunctionfunction x8o takes nothing returns booleanset Wj[$8E]='AC3Y'call L1x('AC3Y',false)return trueendfunctionfunction x9o takes nothing returns booleanset Wj[18]='AC0I'call L1x('AC0I',false)return trueendfunctionfunction ovo takes nothing returns booleanset Wj[454]='ACCM'call L1x('ACCM',false)return trueendfunctionfunction oeo takes nothing returns booleanset Wj[415]='ACBJ'call L1x('ACBJ',false)return trueendfunctionfunction oxo takes nothing returns booleanset Wj[92]='AC2K'call L1x('AC2K',false)return trueendfunctionfunction ooo takes nothing returns booleanset Wj[378]='ACAI'call L1x('ACAI',false)return trueendfunctionfunction oro takes nothing returns booleanset Wj[$97]='AC47'call L1x('AC47',false)return trueendfunctionfunction oio takes nothing returns booleanset Wj[$D8]='AC60'call L1x('AC60',false)return trueendfunctionfunction oao takes nothing returns booleanset Wj[368]='ACA8'call L1x('ACA8',false)return trueendfunctionfunction ono takes nothing returns booleanset Wj[485]='ACDH'call L1x('ACDH',false)return trueendfunctionfunction oVo takes nothing returns booleanset Wj[$AE]='AC4U'call L1x('AC4U',false)return trueendfunctionfunction oEo takes nothing returns booleanset Wj[394]='ACAY'call L1x('ACAY',false)return trueendfunctionfunction oXo takes nothing returns booleanset Wj[$D1]='AC5T'call L1x('AC5T',false)return trueendfunctionfunction oOo takes nothing returns booleanset Wj[343]='AC9J'call L1x('AC9J',false)return trueendfunctionfunction oRo takes nothing returns booleanset Wj[411]='ACBF'call L1x('ACBF',false)return trueendfunctionfunction oIo takes nothing returns booleanset Wj[$CA]='AC5M'call L1x('AC5M',false)return trueendfunctionfunction oAo takes nothing returns booleanset Wj[$B4]='AC50'call L1x('AC50',false)return trueendfunctionfunction oNo takes nothing returns booleanset Wj[$C4]='AC5G'call L1x('AC5G',false)return trueendfunctionfunction obo takes nothing returns booleanset Wj[$BB]='AC57'call L1x('AC57',false)return trueendfunctionfunction oBo takes nothing returns booleanset Wj[$D6]='AC5Y'call L1x('AC5Y',false)return trueendfunctionfunction oco takes nothing returns booleanset Wj[$B7]='AC53'call L1x('AC53',false)return trueendfunctionfunction oCo takes nothing returns booleanset Wj[$B2]='AC4Y'call L1x('AC4Y',false)return trueendfunctionfunction odo takes nothing returns booleanset Wj['{']='AC3F'call L1x('AC3F',false)return trueendfunctionfunction oDo takes nothing returns booleanset Wj[318]='AC8U'call L1x('AC8U',false)return trueendfunctionfunction ofo takes nothing returns booleanset Wj[56]='AC1K'call L1x('AC1K',false)return trueendfunctionfunction oFo takes nothing returns booleanset Wj[$C5]='AC5H'call L1x('AC5H',false)return trueendfunctionfunction ogo takes nothing returns booleanset Wj[496]='ACDS'call L1x('ACDS',false)return trueendfunctionfunction oGo takes nothing returns booleanset Wj[$A3]='AC4J'call L1x('AC4J',false)return trueendfunctionfunction oho takes nothing returns booleanset Wj[449]='ACCH'call L1x('ACCH',false)return trueendfunctionfunction oHo takes nothing returns booleanset Wj[91]='AC2J'call L1x('AC2J',false)return trueendfunctionfunction ojo takes nothing returns booleanset Wj[$AB]='AC4R'call L1x('AC4R',false)return trueendfunctionfunction oJo takes nothing returns booleanset Wj[486]='ACDI'call L1x('ACDI',false)return trueendfunctionfunction oko takes nothing returns booleanset Wj[398]='ACB2'call L1x('ACB2',false)return trueendfunctionfunction oKo takes nothing returns booleanset Wj[97]='AC2P'call L1x('AC2P',false)return trueendfunctionfunction olo takes nothing returns booleanset Wj[416]='ACBK'call L1x('ACBK',false)return trueendfunctionfunction oLo takes nothing returns booleanset Wj[283]='AC7V'call L1x('AC7V',false)return trueendfunctionfunction omo takes nothing returns booleanset Wj[315]='AC8R'call L1x('AC8R',false)return trueendfunctionfunction oMo takes nothing returns booleanset Wj[316]='AC8S'call L1x('AC8S',false)return trueendfunctionfunction opo takes nothing returns booleanset Wj[$9B]='AC4B'call L1x('AC4B',false)return trueendfunctionfunction oPo takes nothing returns booleanset Wj[26]='AC0Q'call L1x('AC0Q',false)return trueendfunctionfunction oqo takes nothing returns booleanset Wj['t']='AC38'call L1x('AC38',false)return trueendfunctionfunction oQo takes nothing returns booleanset Wj['y']='AC3D'call L1x('AC3D',false)return trueendfunctionfunction oso takes nothing returns booleanset Wj[314]='AC8Q'call L1x('AC8Q',false)return trueendfunctionfunction oSo takes nothing returns booleanset Wj[441]='ACC9'call L1x('ACC9',false)return trueendfunctionfunction oto takes nothing returns booleanset Wj[$BA]='AC56'call L1x('AC56',false)return trueendfunctionfunction oTo takes nothing returns booleanset Wj[$9F]='AC4F'call L1x('AC4F',false)return trueendfunctionfunction ouo takes nothing returns booleanset Wj[466]='ACCY'call L1x('ACCY',false)return trueendfunctionfunction oUo takes nothing returns booleanset Wj[6]='AC06'
call L1x('AC06',false)return trueendfunctionfunction owo takes nothing returns booleanset Wj[29]='AC0T'call L1x('AC0T',false)return trueendfunctionfunction oWo takes nothing returns booleanset Wj[401]='ACB5'call L1x('ACB5',false)return trueendfunctionfunction oyo takes nothing returns booleanset Wj[$87]='AC3R'call L1x('AC3R',false)return trueendfunctionfunction oYo takes nothing returns booleanset Wj[$83]='AC3N'call L1x('AC3N',false)return trueendfunctionfunction ozo takes nothing returns booleanset Wj[$EF]='AC6N'call L1x('AC6N',false)return trueendfunctionfunction oZo takes nothing returns booleanset Wj[353]='AC9T'call L1x('AC9T',false)return trueendfunctionfunction o_o takes nothing returns booleanset Wj[$F8]='AC6W'call L1x('AC6W',false)return trueendfunctionfunction o0o takes nothing returns booleanset Wj[$D7]='AC5Z'call L1x('AC5Z',false)return trueendfunctionfunction o1o takes nothing returns booleanset Wj[$90]='AC40'call L1x('AC40',false)return trueendfunctionfunction o2o takes nothing returns booleanset Wj[17]='AC0H'call L1x('AC0H',false)return trueendfunctionfunction o3o takes nothing returns booleanset Wj[293]='AC85'call L1x('AC85',false)return trueendfunctionfunction o4o takes nothing returns booleanset Wj[265]='AC7D'call L1x('AC7D',false)return trueendfunctionfunction o5o takes nothing returns booleanset Wj[349]='AC9P'call L1x('AC9P',false)return trueendfunctionfunction o6o takes nothing returns booleanset Wj[477]='ACD9'call L1x('ACD9',false)return trueendfunctionfunction o7o takes nothing returns booleanset Wj[$94]='AC44'call L1x('AC44',false)return trueendfunctionfunction o8o takes nothing returns booleanset Wj[440]='ACC8'call L1x('ACC8',false)return trueendfunctionfunction o9o takes nothing returns booleanset Wj[$D5]='AC5X'call L1x('AC5X',false)return trueendfunctionfunction rvo takes nothing returns booleanset Wj[$B1]='AC4X'call L1x('AC4X',false)return trueendfunctionfunction reo takes nothing returns booleanset Wj[386]='ACAQ'call L1x('ACAQ',false)return trueendfunctionfunction rxo takes nothing returns booleanset Wj[$DD]='AC65'call L1x('AC65',false)return trueendfunctionfunction roo takes nothing returns booleanset Wj[408]='ACBC'call L1x('ACBC',false)return trueendfunctionfunction rro takes nothing returns booleanset Wj[$CB]='AC5N'call L1x('AC5N',false)return trueendfunctionfunction rio takes nothing returns booleanset Wj[$DB]='AC63'call L1x('AC63',false)return trueendfunctionfunction rao takes nothing returns booleanset Wj[499]='ACDV'call L1x('ACDV',false)return trueendfunctionfunction rno takes nothing returns booleanset Wj[344]='AC9K'call L1x('AC9K',false)return trueendfunctionfunction rVo takes nothing returns booleanset Wj[438]='ACC6'call L1x('ACC6',false)return trueendfunctionfunction rEo takes nothing returns booleanset Wj['s']='AC37'call L1x('AC37',false)return trueendfunctionfunction rXo takes nothing returns booleanset Wj[356]='AC9W'call L1x('AC9W',false)return trueendfunctionfunction rOo takes nothing returns booleanset Wj[354]='AC9U'call L1x('AC9U',false)return trueendfunctionfunction rRo takes nothing returns booleanset Wj[$F0]='AC6O'call L1x('AC6O',false)return trueendfunctionfunction rIo takes nothing returns booleanset Wj[$BC]='AC58'call L1x('AC58',false)return trueendfunctionfunction rAo takes nothing returns booleanset Wj[$81]='AC3L'call L1x('AC3L',false)return trueendfunctionfunction rNo takes nothing returns booleanset Wj['w']='AC3B'call L1x('AC3B',false)return trueendfunctionfunction rbo takes nothing returns booleanset Wj[$7E]='AC3I'call L1x('AC3I',false)return trueendfunctionfunction rBo takes nothing returns booleanset Wj[300]='AC8C'call L1x('AC8C',false)return trueendfunctionfunction rco takes nothing returns booleanset Wj[49]='AC1D'call L1x('AC1D',false)return trueendfunctionfunction rCo takes nothing returns booleanset Wj['|']='AC3G'call L1x('AC3G',false)return trueendfunctionfunction rdo takes nothing returns booleanset Wj[444]='ACCC'call L1x('ACCC',false)return trueendfunctionfunction rDo takes nothing returns booleanset Wj['m']='AC31'call L1x('AC31',false)return trueendfunctionfunction rfo takes nothing returns booleanset Wj['r']='AC36'call L1x('AC36',false)return trueendfunctionfunction rFo takes nothing returns booleanset Wj[$95]='AC45'call L1x('AC45',false)return trueendfunctionfunction rgo takes nothing returns booleanset Wj[434]='ACC2'call L1x('ACC2',false)return trueendfunctionfunction rGo takes nothing returns booleanset Wj[$B8]='AC54'call L1x('AC54',false)return trueendfunctionfunction rho takes nothing returns booleancall VNx(Pa,(function yHx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[20]_wc3spell.j"))call VNx(Pa,(function yjx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[12]_wc3spell.j"))call VNx(Pa,(function yJx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[134]_wc3spell.j"))call VNx(Pa,(function ykx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[118]_wc3spell.j"))call VNx(Pa,(function yKx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[136]_wc3spell.j"))call VNx(Pa,(function ylx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[138]_wc3spell.j"))call VNx(Pa,(function yLx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[102]_wc3spell.j"))call VNx(Pa,(function ymx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[140]_wc3spell.j"))call VNx(Pa,(function yMx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[19]_wc3spell.j"))call VNx(Pa,(function ypx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[143]_wc3spell.j"))call VNx(Pa,(function yPx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[145]_wc3spell.j"))call VNx(Pa,(function yqx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[146]_wc3spell.j"))call VNx(Pa,(function yQx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[108]_wc3spell.j"))call VNx(Pa,(function ysx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[152]_wc3spell.j"))call VNx(Pa,(function ySx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[154]_wc3spell.j"))call VNx(Pa,(function ytx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[156]_wc3spell.j"))call VNx(Pa,(function yTx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[157]_wc3spell.j"))call VNx(Pa,(function yux),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[158]_wc3spell.j"))call VNx(Pa,(function yUx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[147]_wc3spell.j"))call VNx(Pa,(function ywx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[160]_wc3spell.j"))call VNx(Pa,(function yWx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[165]_wc3spell.j"))call VNx(Pa,(function yyx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[167]_wc3spell.j"))call VNx(Pa,(function yYx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[107]_wc3spell.j"))call VNx(Pa,(function yzx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[169]_wc3spell.j"))call VNx(Pa,(function yZx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[170]_wc3spell.j"))call VNx(Pa,(function y_x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[173]_wc3spell.j"))call VNx(Pa,(function y0x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[179]_wc3spell.j"))call VNx(Pa,(function y1x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[181]_wc3spell.j"))call VNx(Pa,(function y2x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[112]_wc3spell.j"))call VNx(Pa,(function y3x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[182]_wc3spell.j"))call VNx(Pa,(function y4x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[104]_wc3spell.j"))call VNx(Pa,(function y5x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[189]_wc3spell.j"))call VNx(Pa,(function y6x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[150]_wc3spell.j"))call VNx(Pa,(function y7x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[190]_wc3spell.j"))call VNx(Pa,(function y8x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[192]_wc3spell.j"))call VNx(Pa,(function y9x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[193]_wc3spell.j"))call VNx(Pa,(function Yvx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[194]_wc3spell.j"))call VNx(Pa,(function Yex),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[195]_wc3spell.j"))call VNx(Pa,(function Yxx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[200]_wc3spell.j"))call VNx(Pa,(function Yox),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[204]_wc3spell.j"))call VNx(Pa,(function Yrx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[207]_wc3spell.j"))call VNx(Pa,(function Yix),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[208]_wc3spell.j"))call VNx(Pa,(function Yax),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[210]_wc3spell.j"))call VNx(Pa,(function Ynx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[211]_wc3spell.j"))call VNx(Pa,(function YVx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[220]_wc3spell.j"))call VNx(Pa,(function YEx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[222]_wc3spell.j"))call VNx(Pa,(function YXx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[225]_wc3spell.j"))call VNx(Pa,(function YOx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[226]_wc3spell.j"))call VNx(Pa,(function YRx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[227]_wc3spell.j"))call VNx(Pa,(function YIx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[230]_wc3spell.j"))call VNx(Pa,(function YAx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[232]_wc3spell.j"))call VNx(Pa,(function YNx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[233]_wc3spell.j"))call VNx(Pa,(function Ybx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[234]_wc3spell.j"))call VNx(Pa,(function YBx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[235]_wc3spell.j"))call VNx(Pa,(function Ycx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[238]_wc3spell.j"))call VNx(Pa,(function YCx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[242]_wc3spell.j"))call VNx(Pa,(function Ydx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[243]_wc3spell.j"))call VNx(Pa,(function YDx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[244]_wc3spell.j"))call VNx(Pa,(function Yfx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[245]_wc3spell.j"))call VNx(Pa,(function YFx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[246]_wc3spell.j"))call VNx(Pa,(function Ygx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[247]_wc3spell.j"))call VNx(Pa,(function YGx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[250]_wc3spell.j"))call VNx(Pa,(function Yhx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[251]_wc3spell.j"))call VNx(Pa,(function YHx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[252]_wc3spell.j"))call VNx(Pa,(function Yjx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[254]_wc3spell.j"))call VNx(Pa,(function YJx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[256]_wc3spell.j"))call VNx(Pa,(function Ykx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[257]_wc3spell.j"))call VNx(Pa,(function YKx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[258]_wc3spell.j"))call VNx(Pa,(function Ylx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[259]_wc3spell.j"))call VNx(Pa,(function YLx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[260]_wc3spell.j"))call VNx(Pa,(function Ymx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[261]_wc3spell.j"))call VNx(Pa,(function YMx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[263]_wc3spell.j"))call VNx(Pa,(function Ypx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[266]_wc3spell.j"))call VNx(Pa,(function YPx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[267]_wc3spell.j"))call VNx(Pa,(function Yqx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[268]_wc3spell.j"))call VNx(Pa,(function YQx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[269]_wc3spell.j"))call VNx(Pa,(function Ysx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[270]_wc3spell.j"))call VNx(Pa,(function YSx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[275]_wc3spell.j"))call VNx(Pa,(function Ytx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[427]_wc3spell.j"))call VNx(Pa,(function YTx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[276]_wc3spell.j"))call VNx(Pa,(function Yux),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[277]_wc3spell.j"))call VNx(Pa,(function YUx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[278]_wc3spell.j"))call VNx(Pa,(function Ywx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[279]_wc3spell.j"))call VNx(Pa,(function YWx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[27]_wc3spell.j"))call VNx(Pa,(function Yyx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[282]_wc3spell.j"))call VNx(Pa,(function YYx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[284]_wc3spell.j"))call VNx(Pa,(function Yzx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[100]_wc3spell.j"))call VNx(Pa,(function YZx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[286]_wc3spell.j"))call VNx(Pa,(function Y_x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[289]_wc3spell.j"))call VNx(Pa,(function Y0x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[290]_wc3spell.j"))call VNx(Pa,(function Y1x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[291]_wc3spell.j"))call VNx(Pa,(function Y2x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[292]_wc3spell.j"))call VNx(Pa,(function Y3x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[14]_wc3spell.j"))call VNx(Pa,(function Y4x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[294]_wc3spell.j"))call VNx(Pa,(function Y5x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[295]_wc3spell.j"))call VNx(Pa,(function Y6x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[298]_wc3spell.j"))call VNx(Pa,(function Y7x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[299]_wc3spell.j"))call VNx(Pa,(function Y8x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[301]_wc3spell.j"))call VNx(Pa,(function Y9x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[302]_wc3spell.j"))call VNx(Pa,(function zvx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[103]_wc3spell.j"))call VNx(Pa,(function zex),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[303]_wc3spell.j"))call VNx(Pa,(function zxx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[304]_wc3spell.j"))call VNx(Pa,(function zox),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[305]_wc3spell.j"))call VNx(Pa,(function zrx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[306]_wc3spell.j"))call VNx(Pa,(function zix),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[307]_wc3spell.j"))call VNx(Pa,(function zax),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[308]_wc3spell.j"))call VNx(Pa,(function znx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[30]_wc3spell.j"))call VNx(Pa,(function zVx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[310]_wc3spell.j"))call VNx(Pa,(function zEx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[311]_wc3spell.j"))call VNx(Pa,(function zXx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[312]_wc3spell.j"))call VNx(Pa,(function zOx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[313]_wc3spell.j"))call VNx(Pa,(function zRx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[105]_wc3spell.j"))call VNx(Pa,(function zIx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[317]_wc3spell.j"))call VNx(Pa,(function zAx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[319]_wc3spell.j"))call VNx(Pa,(function zNx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[83]_wc3spell.j"))call VNx(Pa,(function zbx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[321]_wc3spell.j"))call VNx(Pa,(function zBx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[322]_wc3spell.j"))call VNx(Pa,(function zcx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[323]_wc3spell.j"))call VNx(Pa,(function zCx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[326]_wc3spell.j"))call VNx(Pa,(function zdx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[106]_wc3spell.j"))call VNx(Pa,(function zDx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[1]_wc3spell.j"))call VNx(Pa,(function zfx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[327]_wc3spell.j"))call VNx(Pa,(function zFx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[9]_wc3spell.j"))call VNx(Pa,(function zgx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[331]_wc3spell.j"))call VNx(Pa,(function zGx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[335]_wc3spell.j"))call VNx(Pa,(function zhx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[336]_wc3spell.j"))call VNx(Pa,(function zHx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[337]_wc3spell.j"))call VNx(Pa,(function zjx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[339]_wc3spell.j"))call VNx(Pa,(function zJx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[340]_wc3spell.j"))call VNx(ma,(function zkx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_transBuff_wc3buff.j"))call VNx(Pa,(function zKx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[341]_wc3spell.j"))call VNx(Pa,(function zlx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[346]_wc3spell.j"))call VNx(Pa,(function zLx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[347]_wc3spell.j"))call VNx(Pa,(function zmx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[34]_wc3spell.j"))call VNx(Pa,(function zMx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[350]_wc3spell.j"))call VNx(Pa,(function zpx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[351]_wc3spell.j"))call VNx(Pa,(function zPx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[352]_wc3spell.j"))call VNx(Pa,(function zqx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[355]_wc3spell.j"))call VNx(Pa,(function zQx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[358]_wc3spell.j"))call VNx(Pa,(function zsx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[359]_wc3spell.j"))call VNx(Pa,(function zSx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[13]_wc3spell.j"))call VNx(Pa,(function ztx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[35]_wc3spell.j"))call VNx(Pa,(function zTx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[360]_wc3spell.j"))call VNx(Pa,(function zux),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[361]_wc3spell.j"))call VNx(Pa,(function zUx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[364]_wc3spell.j"))call VNx(Pa,(function zwx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[367]_wc3spell.j"))call VNx(Pa,(function zWx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[36]_wc3spell.j"))call VNx(Pa,(function zyx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[370]_wc3spell.j"))call VNx(Pa,(function zYx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[371]_wc3spell.j"))call VNx(Pa,(function zzx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[372]_wc3spell.j"))call VNx(Pa,(function zZx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[375]_wc3spell.j"))call VNx(Pa,(function z_x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[376]_wc3spell.j"))call VNx(Pa,(function z0x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[37]_wc3spell.j"))call VNx(Pa,(function z1x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[117]_wc3spell.j"))call VNx(Pa,(function z2x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[380]_wc3spell.j"))call VNx(Pa,(function z3x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[381]_wc3spell.j"))call VNx(Pa,(function z4x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[382]_wc3spell.j"))call VNx(Pa,(function z5x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[383]_wc3spell.j"))call VNx(Pa,(function z6x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[384]_wc3spell.j"))call VNx(Pa,(function z7x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[385]_wc3spell.j"))call VNx(Pa,(function z8x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[387]_wc3spell.j"))call VNx(Pa,(function z9x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[388]_wc3spell.j"))call VNx(Pa,(function Zvx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[389]_wc3spell.j"))call VNx(Pa,(function Zex),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[38]_wc3spell.j"))call VNx(Pa,(function Zxx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[391]_wc3spell.j"))call VNx(Pa,(function Zox),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[392]_wc3spell.j"))call VNx(Pa,(function Zrx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[393]_wc3spell.j"))call VNx(Pa,(function Zix),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[395]_wc3spell.j"))call VNx(Pa,(function Zax),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[396]_wc3spell.j"))call VNx(Pa,(function Znx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[296]_wc3spell.j"))call VNx(Pa,(function ZVx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[280]_wc3spell.j"))call VNx(Pa,(function ZEx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[400]_wc3spell.j"))call VNx(Pa,(function ZXx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[403]_wc3spell.j"))call VNx(Pa,(function ZOx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[404]_wc3spell.j"))call VNx(Pa,(function ZRx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[405]_wc3spell.j"))call VNx(Pa,(function ZIx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[40]_wc3spell.j"))call VNx(Pa,(function ZAx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[413]_wc3spell.j"))call VNx(Pa,(function ZNx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[417]_wc3spell.j"))call VNx(Pa,(function Zbx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[419]_wc3spell.j"))call VNx(Pa,(function ZBx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[41]_wc3spell.j"))call VNx(Pa,(function Zcx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[420]_wc3spell.j"))call VNx(Pa,(function ZCx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[285]_wc3spell.j"))call VNx(Pa,(function Zdx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[421]_wc3spell.j"))call VNx(Pa,(function ZDx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[422]_wc3spell.j"))call VNx(Pa,(function Zfx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[423]_wc3spell.j"))call VNx(Pa,(function ZFx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[424]_wc3spell.j"))call VNx(Pa,(function Zgx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[425]_wc3spell.j"))call VNx(Pa,(function ZGx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[429]_wc3spell.j"))call VNx(Pa,(function Zhx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[42]_wc3spell.j"))call VNx(Pa,(function ZHx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[431]_wc3spell.j"))call VNx(Pa,(function Zjx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[433]_wc3spell.j"))call VNx(Pa,(function ZJx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[436]_wc3spell.j"))call VNx(Pa,(function Zkx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[10]_wc3spell.j"))call VNx(Pa,(function ZKx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[43]_wc3spell.j"))call VNx(Pa,(function Zlx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[442]_wc3spell.j"))call VNx(Pa,(function ZLx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[5]_wc3spell.j"))call VNx(Pa,(function Zmx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[127]_wc3spell.j"))call VNx(Pa,(function ZMx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[445]_wc3spell.j"))call VNx(Pa,(function Zpx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[447]_wc3spell.j"))call VNx(Pa,(function ZPx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[363]_wc3spell.j"))call VNx(Pa,(function Zqx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[44]_wc3spell.j"))call VNx(Pa,(function ZQx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[452]_wc3spell.j"))call VNx(Pa,(function Zsx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[456]_wc3spell.j"))call VNx(Pa,(function ZSx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[458]_wc3spell.j"))call VNx(Pa,(function Ztx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[459]_wc3spell.j"))call VNx(Pa,(function ZTx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[460]_wc3spell.j"))call VNx(Pa,(function Zux),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[461]_wc3spell.j"))call VNx(Pa,(function ZUx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[462]_wc3spell.j"))call VNx(Pa,(function Zwx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[463]_wc3spell.j"))call VNx(Pa,(function ZWx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[464]_wc3spell.j"))call VNx(Pa,(function Zyx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[465]_wc3spell.j"))call VNx(Pa,(function ZYx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[467]_wc3spell.j"))call VNx(Pa,(function Zzx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[8]_wc3spell.j"))call VNx(Pa,(function ZZx),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[468]_wc3spell.j"))call VNx(Pa,(function Z_x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[470]_wc3spell.j"))call VNx(Pa,(function Z0x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[471]_wc3spell.j"))call VNx(Pa,(function Z1x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[473]_wc3spell.j"))call VNx(Pa,(function Z2x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[475]_wc3spell.j"))call VNx(Pa,(function Z3x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[476]_wc3spell.j"))call VNx(Pa,(function Z4x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[478]_wc3spell.j"))call VNx(Pa,(function Z5x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[479]_wc3spell.j"))call VNx(Pa,(function Z6x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[47]_wc3spell.j"))call VNx(Pa,(function Z7x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[480]_wc3spell.j"))call VNx(Pa,(function Z8x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[482]_wc3spell.j"))call VNx(Pa,(function Z9x),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[484]_wc3spell.j"))call VNx(Pa,(function vvo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[487]_wc3spell.j"))call VNx(Pa,(function veo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[488]_wc3spell.j"))call VNx(Pa,(function vxo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[489]_wc3spell.j"))call VNx(Pa,(function voo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[48]_wc3spell.j"))call VNx(Pa,(function vro),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[490]_wc3spell.j"))call VNx(Pa,(function vio),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[491]_wc3spell.j"))call VNx(Pa,(function vao),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[120]_wc3spell.j"))call VNx(Pa,(function vno),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[492]_wc3spell.j"))call VNx(Pa,(function vVo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[493]_wc3spell.j"))call VNx(Pa,(function vEo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[494]_wc3spell.j"))call VNx(Pa,(function vXo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[495]_wc3spell.j"))call VNx(Pa,(function vOo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[498]_wc3spell.j"))call VNx(Pa,(function vRo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[500]_wc3spell.j"))call VNx(Pa,(function vIo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[50]_wc3spell.j"))call VNx(Pa,(function vAo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[52]_wc3spell.j"))call VNx(Pa,(function vNo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[53]_wc3spell.j"))call VNx(Pa,(function vbo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[54]_wc3spell.j"))call VNx(Pa,(function vBo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[55]_wc3spell.j"))call VNx(Pa,(function vco),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[57]_wc3spell.j"))call VNx(Pa,(function vCo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[58]_wc3spell.j"))call VNx(Pa,(function vdo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[59]_wc3spell.j"))call VNx(Pa,(function vDo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[362]_wc3spell.j"))call VNx(Pa,(function vfo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[60]_wc3spell.j"))call VNx(Pa,(function vFo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[63]_wc3spell.j"))call VNx(Pa,(function vgo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[65]_wc3spell.j"))call VNx(Pa,(function vGo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[67]_wc3spell.j"))call VNx(Pa,(function vho),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[71]_wc3spell.j"))call VNx(Pa,(function vHo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[72]_wc3spell.j"))call VNx(Pa,(function vjo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[74]_wc3spell.j"))call VNx(Pa,(function vJo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[79]_wc3spell.j"))call VNx(Pa,(function vko),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[82]_wc3spell.j"))call VNx(Pa,(function vKo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[85]_wc3spell.j"))call VNx(Pa,(function vlo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[86]_wc3spell.j"))call VNx(Pa,(function vLo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[88]_wc3spell.j"))call VNx(Pa,(function vmo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[89]_wc3spell.j"))call VNx(Pa,(function vMo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[90]_wc3spell.j"))call VNx(Pa,(function vpo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[70]_wc3spell.j"))call VNx(Pa,(function vPo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[93]_wc3spell.j"))call VNx(Pa,(function vqo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[94]_wc3spell.j"))call VNx(Pa,(function vQo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[96]_wc3spell.j"))call VNx(Pa,(function vso),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[172]_wc3spell.j"))call VNx(Pa,(function vSo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[166]_wc3spell.j"))call VNx(Pa,(function vto),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[330]_wc3spell.j"))call VNx(Pa,(function vTo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[191]_wc3spell.j"))call VNx(Pa,(function vuo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[7]_wc3spell.j"))call VNx(Pa,(function vUo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[32]_wc3spell.j"))call VNx(Pa,(function vwo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[374]_wc3spell.j"))call VNx(Pa,(function vWo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[287]_wc3spell.j"))call VNx(Pa,(function vyo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[16]_wc3spell.j"))call VNx(Pa,(function vYo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[249]_wc3spell.j"))call VNx(Pa,(function vzo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[255]_wc3spell.j"))call VNx(Pa,(function vZo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[80]_wc3spell.j"))call VNx(Pa,(function v_o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[137]_wc3spell.j"))call VNx(Pa,(function v0o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[450]_wc3spell.j"))call VNx(Pa,(function v1o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[99]_wc3spell.j"))call VNx(Pa,(function v2o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[469]_wc3spell.j"))call VNx(Pa,(function v3o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[231]_wc3spell.j"))call VNx(Pa,(function v4o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[281]_wc3spell.j"))call VNx(Pa,(function v5o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[377]_wc3spell.j"))call VNx(Pa,(function v6o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[333]_wc3spell.j"))call VNx(Pa,(function v7o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[84]_wc3spell.j"))call VNx(Pa,(function v8o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[397]_wc3spell.j"))call VNx(Pa,(function v9o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[223]_wc3spell.j"))call VNx(Pa,(function evo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[130]_wc3spell.j"))call VNx(Pa,(function eeo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[122]_wc3spell.j"))call VNx(Pa,(function exo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[212]_wc3spell.j"))call VNx(Pa,(function eoo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[139]_wc3spell.j"))call VNx(Pa,(function ero),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[437]_wc3spell.j"))call VNx(Pa,(function eio),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[21]_wc3spell.j"))call VNx(Pa,(function eao),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[229]_wc3spell.j"))call VNx(Pa,(function eno),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[446]_wc3spell.j"))call VNx(Pa,(function eVo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[15]_wc3spell.j"))call VNx(Pa,(function eEo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[453]_wc3spell.j"))call VNx(Pa,(function eXo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[64]_wc3spell.j"))call VNx(Pa,(function eOo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[0]_wc3spell.j"))call VNx(Pa,(function eRo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[24]_wc3spell.j"))call VNx(Pa,(function eIo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[11]_wc3spell.j"))call VNx(Pa,(function eAo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[455]_wc3spell.j"))call VNx(Pa,(function eNo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[288]_wc3spell.j"))call VNx(Pa,(function ebo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[3]_wc3spell.j"))call VNx(Pa,(function eBo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[78]_wc3spell.j"))call VNx(Pa,(function eco),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[201]_wc3spell.j"))call VNx(Pa,(function eCo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[472]_wc3spell.j"))call VNx(Pa,(function edo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[325]_wc3spell.j"))call VNx(Pa,(function eDo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[133]_wc3spell.j"))call VNx(Pa,(function efo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[81]_wc3spell.j"))call VNx(Pa,(function eFo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[217]_wc3spell.j"))call VNx(Pa,(function ego),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[357]_wc3spell.j"))call VNx(Pa,(function eGo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[206]_wc3spell.j"))call VNx(Pa,(function eho),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[95]_wc3spell.j"))call VNx(Pa,(function eHo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[101]_wc3spell.j"))call VNx(Pa,(function ejo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[448]_wc3spell.j"))call VNx(Pa,(function eJo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[428]_wc3spell.j"))call VNx(Pa,(function eko),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[176]_wc3spell.j"))call VNx(Pa,(function eKo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[69]_wc3spell.j"))call VNx(Pa,(function elo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[205]_wc3spell.j"))call VNx(Pa,(function eLo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[271]_wc3spell.j"))call VNx(Pa,(function emo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[481]_wc3spell.j"))call VNx(Pa,(function eMo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[141]_wc3spell.j"))call VNx(Pa,(function epo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[412]_wc3spell.j"))call VNx(Pa,(function ePo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[153]_wc3spell.j"))call VNx(Pa,(function eqo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[443]_wc3spell.j"))call VNx(Pa,(function eQo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[328]_wc3spell.j"))call VNx(Pa,(function eso),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[390]_wc3spell.j"))call VNx(Pa,(function eSo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[369]_wc3spell.j"))call VNx(Pa,(function eto),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[39]_wc3spell.j"))call VNx(Pa,(function eTo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[418]_wc3spell.j"))call VNx(Pa,(function euo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[474]_wc3spell.j"))call VNx(ma,(function eUo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_moddedBuff_wc3buff.j"))
call VNx(Pa,(function ewo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[410]_wc3spell.j"))call VNx(Pa,(function eWo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[110]_wc3spell.j"))call VNx(Pa,(function eyo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[76]_wc3spell.j"))call VNx(Pa,(function eYo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[342]_wc3spell.j"))call VNx(Pa,(function ezo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[402]_wc3spell.j"))call VNx(Pa,(function eZo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[175]_wc3spell.j"))call VNx(Pa,(function e_o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[253]_wc3spell.j"))call VNx(Pa,(function e0o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[111]_wc3spell.j"))call VNx(Pa,(function e1o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[113]_wc3spell.j"))call VNx(Pa,(function e2o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[373]_wc3spell.j"))call VNx(Pa,(function e3o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[332]_wc3spell.j"))call VNx(Pa,(function e4o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[237]_wc3spell.j"))call VNx(Pa,(function e5o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[66]_wc3spell.j"))call VNx(Pa,(function e6o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[324]_wc3spell.j"))call VNx(Pa,(function e7o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[61]_wc3spell.j"))call VNx(Pa,(function e8o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[125]_wc3spell.j"))call VNx(Pa,(function e9o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[87]_wc3spell.j"))call VNx(Pa,(function xvo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[379]_wc3spell.j"))call VNx(Pa,(function xeo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[366]_wc3spell.j"))call VNx(Pa,(function xxo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[407]_wc3spell.j"))call VNx(Pa,(function xoo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[164]_wc3spell.j"))call VNx(Pa,(function xro),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[338]_wc3spell.j"))call VNx(Pa,(function xio),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[73]_wc3spell.j"))call VNx(Pa,(function xao),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[406]_wc3spell.j"))call VNx(Pa,(function xno),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[348]_wc3spell.j"))call VNx(Pa,(function xVo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[132]_wc3spell.j"))call VNx(Pa,(function xEo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[241]_wc3spell.j"))call VNx(Pa,(function xXo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[218]_wc3spell.j"))call VNx(Pa,(function xOo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[439]_wc3spell.j"))call VNx(Pa,(function xRo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[162]_wc3spell.j"))call VNx(Pa,(function xIo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[399]_wc3spell.j"))call VNx(Pa,(function xAo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[297]_wc3spell.j"))call VNx(Pa,(function xNo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[51]_wc3spell.j"))call VNx(Pa,(function xbo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[497]_wc3spell.j"))call VNx(Pa,(function xBo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[272]_wc3spell.j"))call VNx(Pa,(function xco),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[228]_wc3spell.j"))call VNx(Pa,(function xCo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[25]_wc3spell.j"))call VNx(Pa,(function xdo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[98]_wc3spell.j"))call VNx(Pa,(function xDo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[409]_wc3spell.j"))call VNx(Pa,(function xfo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[28]_wc3spell.j"))call VNx(Pa,(function xFo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[365]_wc3spell.j"))call VNx(Pa,(function xgo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[45]_wc3spell.j"))call VNx(Pa,(function xGo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[320]_wc3spell.j"))call VNx(Pa,(function xho),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[334]_wc3spell.j"))call VNx(Pa,(function xHo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[426]_wc3spell.j"))call VNx(Pa,(function xjo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[435]_wc3spell.j"))call VNx(Pa,(function xJo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[161]_wc3spell.j"))call VNx(Pa,(function xko),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[75]_wc3spell.j"))call VNx(Pa,(function xKo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[329]_wc3spell.j"))call VNx(Pa,(function xlo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[31]_wc3spell.j"))call VNx(Pa,(function xLo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[4]_wc3spell.j"))call VNx(Pa,(function xmo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[309]_wc3spell.j"))call VNx(Pa,(function xMo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[2]_wc3spell.j"))call VNx(Pa,(function xpo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[33]_wc3spell.j"))call VNx(Pa,(function xPo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[430]_wc3spell.j"))call VNx(Pa,(function xqo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[457]_wc3spell.j"))call VNx(Pa,(function xQo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[68]_wc3spell.j"))call VNx(Pa,(function xso),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[62]_wc3spell.j"))call VNx(Pa,(function xSo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[262]_wc3spell.j"))call VNx(Pa,(function xto),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[274]_wc3spell.j"))call VNx(Pa,(function xTo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[23]_wc3spell.j"))call VNx(Pa,(function xuo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[414]_wc3spell.j"))call VNx(Pa,(function xUo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[236]_wc3spell.j"))call VNx(Pa,(function xwo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[432]_wc3spell.j"))call VNx(Pa,(function xWo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[22]_wc3spell.j"))call VNx(Pa,(function xyo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[451]_wc3spell.j"))call VNx(Pa,(function xYo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[128]_wc3spell.j"))call VNx(Pa,(function xzo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[199]_wc3spell.j"))call VNx(Pa,(function xZo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[483]_wc3spell.j"))call VNx(Pa,(function x_o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[168]_wc3spell.j"))call VNx(Pa,(function x0o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[264]_wc3spell.j"))call VNx(Pa,(function x1o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[198]_wc3spell.j"))call VNx(Pa,(function x2o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[273]_wc3spell.j"))call VNx(Pa,(function x3o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[345]_wc3spell.j"))call VNx(Pa,(function x4o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[46]_wc3spell.j"))call VNx(Pa,(function x5o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[185]_wc3spell.j"))call VNx(Pa,(function x6o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[224]_wc3spell.j"))call VNx(Pa,(function x7o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[77]_wc3spell.j"))call VNx(Pa,(function x8o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[142]_wc3spell.j"))call VNx(Pa,(function x9o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[18]_wc3spell.j"))call VNx(Pa,(function ovo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[454]_wc3spell.j"))call VNx(Pa,(function oeo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[415]_wc3spell.j"))call VNx(Pa,(function oxo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[92]_wc3spell.j"))call VNx(Pa,(function ooo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[378]_wc3spell.j"))call VNx(Pa,(function oro),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[151]_wc3spell.j"))call VNx(Pa,(function oio),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[216]_wc3spell.j"))call VNx(Pa,(function oao),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[368]_wc3spell.j"))call VNx(Pa,(function ono),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[485]_wc3spell.j"))call VNx(Pa,(function oVo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[174]_wc3spell.j"))call VNx(Pa,(function oEo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[394]_wc3spell.j"))call VNx(Pa,(function oXo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[209]_wc3spell.j"))call VNx(Pa,(function oOo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[343]_wc3spell.j"))call VNx(Pa,(function oRo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[411]_wc3spell.j"))call VNx(Pa,(function oIo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[202]_wc3spell.j"))call VNx(Pa,(function oAo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[180]_wc3spell.j"))call VNx(Pa,(function oNo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[196]_wc3spell.j"))call VNx(Pa,(function obo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[187]_wc3spell.j"))call VNx(Pa,(function oBo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[214]_wc3spell.j"))call VNx(Pa,(function oco),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[183]_wc3spell.j"))call VNx(Pa,(function oCo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[178]_wc3spell.j"))call VNx(Pa,(function odo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[123]_wc3spell.j"))call VNx(Pa,(function oDo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[318]_wc3spell.j"))call VNx(Pa,(function ofo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[56]_wc3spell.j"))call VNx(Pa,(function oFo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[197]_wc3spell.j"))call VNx(Pa,(function ogo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[496]_wc3spell.j"))call VNx(Pa,(function oGo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[163]_wc3spell.j"))call VNx(Pa,(function oho),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[449]_wc3spell.j"))call VNx(Pa,(function oHo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[91]_wc3spell.j"))call VNx(Pa,(function ojo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[171]_wc3spell.j"))call VNx(Pa,(function oJo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[486]_wc3spell.j"))call VNx(Pa,(function oko),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[398]_wc3spell.j"))call VNx(Pa,(function oKo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[97]_wc3spell.j"))call VNx(Pa,(function olo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[416]_wc3spell.j"))call VNx(Pa,(function oLo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[283]_wc3spell.j"))call VNx(Pa,(function omo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[315]_wc3spell.j"))call VNx(Pa,(function oMo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[316]_wc3spell.j"))call VNx(Pa,(function opo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[155]_wc3spell.j"))call VNx(Pa,(function oPo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[26]_wc3spell.j"))call VNx(Pa,(function oqo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[116]_wc3spell.j"))call VNx(Pa,(function oQo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[121]_wc3spell.j"))call VNx(Pa,(function oso),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[314]_wc3spell.j"))call VNx(Pa,(function oSo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[441]_wc3spell.j"))call VNx(Pa,(function oto),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[186]_wc3spell.j"))call VNx(Pa,(function oTo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[159]_wc3spell.j"))call VNx(Pa,(function ouo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[466]_wc3spell.j"))call VNx(Pa,(function oUo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[6]_wc3spell.j"))call VNx(Pa,(function owo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[29]_wc3spell.j"))call VNx(Pa,(function oWo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[401]_wc3spell.j"))call VNx(Pa,(function oyo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[135]_wc3spell.j"))call VNx(Pa,(function oYo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[131]_wc3spell.j"))call VNx(Pa,(function ozo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[239]_wc3spell.j"))call VNx(Pa,(function oZo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[353]_wc3spell.j"))call VNx(Pa,(function o_o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[248]_wc3spell.j"))call VNx(Pa,(function o0o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[215]_wc3spell.j"))call VNx(Pa,(function o1o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[144]_wc3spell.j"))call VNx(Pa,(function o2o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[17]_wc3spell.j"))call VNx(Pa,(function o3o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[293]_wc3spell.j"))call VNx(Pa,(function o4o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[265]_wc3spell.j"))call VNx(Pa,(function o5o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[349]_wc3spell.j"))call VNx(Pa,(function o6o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[477]_wc3spell.j"))call VNx(Pa,(function o7o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[148]_wc3spell.j"))call VNx(Pa,(function o8o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[440]_wc3spell.j"))call VNx(Pa,(function o9o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[213]_wc3spell.j"))call VNx(Pa,(function rvo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[177]_wc3spell.j"))call VNx(Pa,(function reo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[386]_wc3spell.j"))call VNx(Pa,(function rxo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[221]_wc3spell.j"))call VNx(Pa,(function roo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[408]_wc3spell.j"))call VNx(Pa,(function rro),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[203]_wc3spell.j"))call VNx(Pa,(function rio),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[219]_wc3spell.j"))call VNx(Pa,(function rao),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[499]_wc3spell.j"))call VNx(Pa,(function rno),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[344]_wc3spell.j"))call VNx(Pa,(function rVo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[438]_wc3spell.j"))call VNx(Pa,(function rEo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[115]_wc3spell.j"))call VNx(Pa,(function rXo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[356]_wc3spell.j"))call VNx(Pa,(function rOo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[354]_wc3spell.j"))call VNx(Pa,(function rRo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[240]_wc3spell.j"))call VNx(Pa,(function rIo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[188]_wc3spell.j"))call VNx(Pa,(function rAo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[129]_wc3spell.j"))call VNx(Pa,(function rNo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[119]_wc3spell.j"))call VNx(Pa,(function rbo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[126]_wc3spell.j"))call VNx(Pa,(function rBo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[300]_wc3spell.j"))call VNx(Pa,(function rco),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[49]_wc3spell.j"))call VNx(Pa,(function rCo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[124]_wc3spell.j"))call VNx(Pa,(function rdo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[444]_wc3spell.j"))call VNx(Pa,(function rDo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[109]_wc3spell.j"))call VNx(Pa,(function rfo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[114]_wc3spell.j"))call VNx(Pa,(function rFo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[149]_wc3spell.j"))call VNx(Pa,(function rgo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[434]_wc3spell.j"))call VNx(Pa,(function rGo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Scale\\obj_dummySpells[184]_wc3spell.j"))return trueendfunctionfunction rHo takes nothing returns booleanset a0v=VXx(a_v)
return trueendfunctionfunction rjo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=rLxcall Avx((oSx),a1v)call Avx((oSx),a2v)return trueendfunctionfunction rJo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=rLxcall RPx((oSx),a1v)call RPx((oSx),a2v)return trueendfunctionfunction rko takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])call AZx((oSx),OJ)call DPx(oSx)endfunctionfunction rKo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=rLxlocal integer Okx=iXx()set a3v[oSx]=Okx
set ge[(Okx)]=(oSx)call iDx(Okx,1.01,false,function rko)return trueendfunctionfunction rlo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=rLxlocal integer Okx=a3v[oSx]call iKx(Okx)return trueendfunctionfunction rLo takes nothing returns booleancall Lxx(wj,Xdx("FolderUnit_StructScale_Buff_Init: call FolderUnit_StructScale.MODDED_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructScale.Event_Modded_BuffGain))",bd,bI,function rjo))call Lxx(wj,Xdx("FolderUnit_StructScale_Buff_Init: call FolderUnit_StructScale.MODDED_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructScale.Event_Modded_BuffLose))",jc,bI,function rJo))call Lxx(OJ,Xdx("FolderUnit_StructScale_Buff_Init: call FolderUnit_StructScale.TRANS_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructScale.Event_Trans_BuffGain))",bd,bI,function rKo))
call Lxx(OJ,Xdx("FolderUnit_StructScale_Buff_Init: call FolderUnit_StructScale.TRANS_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructScale.Event_Trans_BuffLose))",jc,bI,function rlo))
return trueendfunctionfunction rmo takes nothing returns booleancall u9x(function rLo,"FolderUnit_StructScale_Buff_Init")return trueendfunctionfunction rMo takes nothing returns booleanset a4v=VXx(a5v)
return trueendfunctionfunction rpo takes nothing returns booleanset a6v=VXx(a7v)
return trueendfunctionfunction rPo takes nothing returns booleanset a8v=VXx(a9v)
return trueendfunctionfunction rqo takes nothing returns booleanset nvv=VXx(nev)
return trueendfunctionfunction rQo takes nothing returns booleanset ck=VXx(Rk)return trueendfunctionfunction rso takes nothing returns booleanset nxv=VXx(nov)
return trueendfunctionfunction rSo takes nothing returns booleanset nrv=ltx(niv+" (dummyBuff)")set WU=l_x()
call l2x(WU,nav,-.15)call l2x(WU,nnv,-.1)
call l2x(WU,iw,-.2)call l3x(((nrv)),ZB+(1),(WU))return trueendfunctionfunction rto takes integer oSx,integer o5x returns nothingcall l0x((oSx),fc,o5x)endfunctionfunction rTo takes integer oSx returns integerset nAv[oSx]=trueset nNv[oSx]=falsecall rEx(nbv)return oSxendfunctionfunction ruo takes nothing returns integerlocal integer oSxif(nEv==8190)thencall o_x("UnitMod_Allocation_allocCustom","call DebugEx(UnitMod.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",nXv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(nOv[(w)]==w)thenset nRv=nRv+1set oSx=nRvelse
set oSx=nOv[(w)]
set nOv[(w)]=nOv[nOv[(w)]]endifset nOv[oSx]=Zset nIv[oSx]=1call rTo(oSx)return oSxendfunctionfunction rUo takes integer IIx,code rwo,code rWo returns integer
local integer oSx=ruo()set nBv[(oSx)]=(IIx)
set lc[(oSx)]=(Xkx(rwo))
set Gc[(oSx)]=(Xkx(rWo))
return oSxendfunctionfunction ryo takes nothing returns booleanlocal integer rFx=(bv)local integer IQx=(Fc[(rFx)])call fJx(((Vv[(rFx)])),nCv[(IQx)],ndv[(IQx)],nDv[(IQx)],nfv[(IQx)])return trueendfunctionfunction rYo takes nothing returns booleanlocal integer rFx=(bv)local integer IQx=(Fc[(rFx)])call fJx((((Vv[(rFx)]))),-((nCv[(IQx)])*1.),-((ndv[(IQx)])*1.),-((nDv[(IQx)])*1.),-((nfv[(IQx)])*1.))return trueendfunctionfunction rzo takes integer oSx,real izx,real iZx,real i_x,real i0x returns integerlocal integer IQx=rUo(ncv,function ryo,function rYo)
set nCv[(IQx)]=izxset ndv[(IQx)]=iZxset nDv[(IQx)]=i_xset nfv[(IQx)]=i0xreturn IQxendfunctionfunction rZo takes nothing returns booleanset nVv=Wwx('BCol',"Cold",'bCol')set anv[(nVv)]=("ReplaceableTextures\\CommandButtons\\BTNFrost.blp")
call lWx(nVv,"Abilities\\Spells\\Other\\FrostDamage\\FrostDamage.mdl","chest",ri)set WU=l_x()
call rto(WU,rzo(db,-'}',-'}',0,0))call l3x(((nVv)),ZB+(1),(WU))return trueendfunctionfunction r_o takes nothing returns booleancall VNx(ma,(function rSo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Cold\\obj_dummyBuff_wc3buff.j"))call VNx(ma,(function rZo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Cold\\obj_normalBuff_wc3buff.j"))return trueendfunctionfunction r0o takes nothing returns booleanset nFv=VXx(niv)
return trueendfunctionfunction r1o takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set ngv[((rLx))]=(true)return trueendfunctionfunction r2o takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set ngv[((rLx))]=(false)
return trueendfunctionfunction r3o takes nothing returns booleancall Lxx(nrv,Xdx("FolderUnit_StructCold_Buff_Init: call FolderUnit_StructCold.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructCold.Event_BuffGain))",bd,MI,function r1o))
call Lxx(nrv,Xdx("FolderUnit_StructCold_Buff_Init: call FolderUnit_StructCold.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructCold.Event_BuffLose))",jc,MI,function r2o))
return trueendfunctionfunction r4o takes nothing returns booleancall u9x(function r3o,"FolderUnit_StructCold_Buff_Init")
return trueendfunctionfunction r5o takes nothing returns booleanset nGv=Wwx('BFro',"Frost",'bFro')set anv[(nGv)]=("ReplaceableTextures\\CommandButtons\\BTNFreezingBreath.blp")call lWx(nGv,"Unit_page\\Unit_struct\\Frost\\FreezingBreathTargetArt.mdx","origin",ri)return trueendfunctionfunction r6o takes nothing returns booleanset nhv=ltx(nHv+" (dummyBuff)")return trueendfunctionfunction r7o takes nothing returns booleancall VNx(ma,(function r5o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Frost\\obj_normalBuff_wc3buff.j"))
call VNx(ma,(function r6o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Frost\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction r8o takes nothing returns booleanset njv=VXx(nHv)
return trueendfunctionfunction r9o takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set nJv[(rLx)]=(nkv)
return trueendfunctionfunction ivo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set nJv[(rLx)]=((nKv[((Tf[(rLx)]))]))return trueendfunctionfunction ieo takes nothing returns booleancall Lxx(nhv,Xdx("FolderUnit_StructFrost_Buff_Init: call FolderUnit_StructFrost.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructFrost.Event_BuffGain))",bd,MI,function r9o))call Lxx(nhv,Xdx("FolderUnit_StructFrost_Buff_Init: call FolderUnit_StructFrost.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructFrost.Event_BuffLose))",jc,MI,function ivo))call W2x(nhv,nGv)call W2x(nrv,nhv)call W2x(iiv,nhv)call W2x(nlv,nhv)return trueendfunctionfunction ixo takes nothing returns booleancall u9x(function ieo,"FolderUnit_StructFrost_Buff_Init")return trueendfunctionfunction ioo takes nothing returns booleanset nLv=ltx(nmv+" (dummyBuff)")return trueendfunctionfunction iro takes nothing returns booleancall VNx(ma,(function ioo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Invisibility\\Reveal\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction iio takes nothing returns booleanset nMv=VXx(nmv)
return trueendfunctionfunction iao takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set npv[((rLx))]=(true)if(rk[(rLx)])thencall UnitRemoveAbility(C[((rLx))],('Apiv'))call Ryx((ACx((rLx),(nPv),(nqv),(ri))))call SetUnitVertexColor(C[rLx],(R2I((((vk[(rLx)]))*1.))),(R2I((((ek[(rLx)]))*1.))),(R2I((((xk[(rLx)]))*1.))),ik)
endifreturn trueendfunctionfunction ino takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set npv[((rLx))]=(false)
if(rk[(rLx)])thencall rtx(rLx,'Apiv')
endifreturn trueendfunctionfunction iVo takes nothing returns booleancall Lxx(nLv,Xdx("FolderUnit_FolderInvisibility_StructReveal_Buff_Init: call FolderUnit_FolderInvisibility_StructReveal.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderInvisibility_StructReveal.Event_BuffGain))",bd,MI,function iao))call Lxx(nLv,Xdx("FolderUnit_FolderInvisibility_StructReveal_Buff_Init: call FolderUnit_FolderInvisibility_StructReveal.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderInvisibility_StructReveal.Event_BuffLose))",jc,MI,function ino))return trueendfunctionfunction iEo takes nothing returns booleancall u9x(function iVo,"FolderUnit_FolderInvisibility_StructReveal_Buff_Init")return trueendfunctionfunction iXo takes nothing returns booleanset nQv=ltx(nsv+" (dummyBuff)")return trueendfunctionfunction iOo takes nothing returns booleanset nSv=ltx(nsv+" (permBuff)")return trueendfunctionfunction iRo takes nothing returns booleancall L1x('Apiv',false)return trueendfunctionfunction iIo takes nothing returns booleanset ntv=ltx(nsv+" (timedBuff)")return trueendfunctionfunction iAo takes nothing returns booleancall VNx(ma,(function iXo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Invisibility\\obj_dummyBuff_wc3buff.j"))call VNx(ma,(function iOo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Invisibility\\obj_permBuff_wc3buff.j"))call VNx(Pa,(function iRo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Invisibility\\obj_dummySpell_wc3spell.j"))
call VNx(ma,(function iIo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Invisibility\\obj_timedBuff_wc3buff.j"))return trueendfunctionfunction iNo takes nothing returns booleanset nTv=VXx(nsv)
return trueendfunctionfunction ibo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=rLxlocal integer iBoset rk[(oSx)]=(true)
set iBo=iXx()set nuv[oSx]=iBo
set ge[(iBo)]=(oSx)call Avx(rLx,nUv)call Avx(rLx,nwv)if not(npv[(oSx)])thencall rtx(rLx,'Apiv')
endifreturn trueendfunctionfunction ico takes integer oSx returns nothingcall fjx(oSx,(vk[(oSx)]),(ek[(oSx)]),(xk[(oSx)]),(ok[(oSx)]))endfunctionfunction iCo takes integer oSx returns nothinglocal integer rLx=oSxlocal integer rFx=rRx((A[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset Vv[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,nWv,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(rLx,nWv,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction ido takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=rLxset rk[(oSx)]=(false)call RPx(rLx,nUv)call RPx(rLx,nwv)call iKx(nuv[oSx])call UnitRemoveAbility(C[((rLx))],('Apiv'))call ico(rLx)call iCo(oSx)return trueendfunctionfunction iDo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set nyv[((rLx))]=(true)call Dux(((((rLx)))),(nQv),(1),w)return trueendfunctionfunction ifo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set nyv[((rLx))]=(false)
call Ulx((((rLx))),nQv)return trueendfunctionfunction iFo takes nothing returns booleancall Lxx(nQv,Xdx("FolderUnit_StructInvisibility_Buff_Init: call FolderUnit_StructInvisibility.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructInvisibility.Event_BuffGain))",bd,MI,function ibo))
call Lxx(nQv,Xdx("FolderUnit_StructInvisibility_Buff_Init: call FolderUnit_StructInvisibility.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructInvisibility.Event_BuffLose))",jc,MI,function ido))
call Lxx(ntv,Xdx("FolderUnit_StructInvisibility_Buff_Init: call FolderUnit_StructInvisibility.TIMED_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructInvisibility.Event_BuffGain))",bd,MI,function ibo))
call Lxx(ntv,Xdx("FolderUnit_StructInvisibility_Buff_Init: call FolderUnit_StructInvisibility.TIMED_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructInvisibility.Event_BuffLose))",jc,MI,function ido))
call Lxx(nSv,Xdx("FolderUnit_StructInvisibility_Buff_Init: call FolderUnit_StructInvisibility.PERM_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructInvisibility.Event_PermBuffGain))",bd,MI,function iDo))call Lxx(nSv,Xdx("FolderUnit_StructInvisibility_Buff_Init: call FolderUnit_StructInvisibility.PERM_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructInvisibility.Event_PermBuffLose))",jc,MI,function ifo))return trueendfunctionfunction igo takes nothing returns booleancall u9x(function iFo,"FolderUnit_StructInvisibility_Buff_Init")
return trueendfunctionfunction iGo takes nothing returns booleanset nYv=ltx(nzv+" (dummyBuff)")return trueendfunctionfunction iho takes nothing returns booleancall L1x('Aeth',false)return trueendfunctionfunction iHo takes nothing returns booleancall VNx(ma,(function iGo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Ghost\\obj_dummyBuff_wc3buff.j"))call VNx(Pa,(function iho),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Ghost\\obj_dummySpell_wc3spell.j"))return trueendfunctionfunction ijo takes nothing returns booleanset nZv=VXx(nzv)
return trueendfunctionfunction iJo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set n_v[((rLx))]=(true)call rtx(rLx,'Aeth')
return trueendfunctionfunction iko takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set n_v[((rLx))]=(false)
call UnitRemoveAbility(C[((rLx))],('Aeth'))call ico(rLx)return trueendfunctionfunction iKo takes nothing returns booleancall Lxx(nYv,Xdx("FolderUnit_StructGhost_Buff_Init: call FolderUnit_StructGhost.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructGhost.Event_BuffGain))",bd,MI,function iJo))call Lxx(nYv,Xdx("FolderUnit_StructGhost_Buff_Init: call FolderUnit_StructGhost.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructGhost.Event_BuffLose))",jc,MI,function iko))return trueendfunctionfunction ilo takes nothing returns booleancall u9x(function iKo,"FolderUnit_StructGhost_Buff_Init")return trueendfunctionfunction iLo takes nothing returns booleanset n0v=VXx(n1v)
return trueendfunctionfunction imo takes nothing returns booleanset n2v=VXx(n3v)
return trueendfunctionfunction iMo takes nothing returns booleanset n4v=VXx(n5v)
return trueendfunctionfunction ipo takes nothing returns booleanset n6v=VXx(n7v)
return trueendfunctionfunction iPo takes nothing returns booleanset MG[1]='SL00'
set MG[2]='SL01'
set MG[3]='SL02'
set MG[4]='SL03'
set MG[5]='SL04'
set MG[6]='SL05'
set MG[7]='SL06'
set MG[8]='SL07'
set MG[9]='SL08'
set MG[$A]='SL09'set MG[$B]='SL0A'set MG[$C]='SL0B'set MG[$D]='SL0C'set MG[$E]='SL0D'set MG[$F]='SL0E'set MG[16]='SL0F'set MG[17]='SL0G'set MG[18]='SL0H'set MG[19]='SL0I'set MG[20]='SL0J'set MG[21]='SL0K'set MG[22]='SL0L'set MG[23]='SL0M'set MG[24]='SL0N'set MG[25]='SL0O'set MG[26]='SL0P'set MG[27]='SL0Q'set MG[28]='SL0R'set MG[29]='SL0S'set MG[30]='SL0T'set MG[31]='SL0U'set MG[32]='SL0V'set MG[33]='SL0W'set MG[34]='SL0X'set MG[35]='SL0Y'set MG[36]='SL0Z'set MG[37]='SL10'set MG[38]='SL11'set MG[39]='SL12'set MG[40]='SL13'set MG[41]='SL14'set MG[42]='SL15'set MG[43]='SL16'set MG[44]='SL17'set MG[45]='SL18'set MG[46]='SL19'set MG[47]='SL1A'set MG[48]='SL1B'set MG[49]='SL1C'set MG[50]='SL1D'set MG[51]='SL1E'set MG[52]='SL1F'set MG[53]='SL1G'set MG[54]='SL1H'set MG[55]='SL1I'set MG[56]='SL1J'set MG[57]='SL1K'set MG[58]='SL1L'set MG[59]='SL1M'set MG[60]='SL1N'set MG[61]='SL1O'set MG[62]='SL1P'set MG[63]='SL1Q'set MG[64]='SL1R'set MG[65]='SL1S'set MG[66]='SL1T'set MG[67]='SL1U'set MG[68]='SL1V'set MG[69]='SL1W'set MG[70]='SL1X'set MG[71]='SL1Y'set MG[72]='SL1Z'set MG[73]='SL20'set MG[74]='SL21'set MG[75]='SL22'set MG[76]='SL23'set MG[77]='SL24'set MG[78]='SL25'set MG[79]='SL26'set MG[80]='SL27'set MG[81]='SL28'set MG[82]='SL29'set MG[83]='SL2A'set MG[84]='SL2B'set MG[85]='SL2C'set MG[86]='SL2D'set MG[87]='SL2E'set MG[88]='SL2F'set MG[89]='SL2G'set MG[90]='SL2H'set MG[91]='SL2I'set MG[92]='SL2J'set MG[93]='SL2K'set MG[94]='SL2L'set MG[95]='SL2M'set MG[96]='SL2N'set MG[97]='SL2O'set MG[98]='SL2P'set MG[99]='SL2Q'set MG['d']='SL2R'set MG['e']='SL2S'set MG['f']='SL2T'set MG['g']='SL2U'set MG['h']='SL2V'set MG['i']='SL2W'set MG['j']='SL2X'set MG['k']='SL2Y'set MG['l']='SL2Z'set MG['m']='SL30'set MG['n']='SL31'set MG['o']='SL32'set MG['p']='SL33'set MG['q']='SL34'set MG['r']='SL35'set MG['s']='SL36'set MG['t']='SL37'set MG['u']='SL38'set MG['v']='SL39'set MG['w']='SL3A'set MG['x']='SL3B'set MG['y']='SL3C'set MG['z']='SL3D'set MG['{']='SL3E'set MG['|']='SL3F'set MG['}']='SL3G'set MG[$7E]='SL3H'set MG[$7F]='SL3I'set MG[$80]='SL3J'set MG[$81]='SL3K'set MG[$82]='SL3L'set MG[$83]='SL3M'set MG[$84]='SL3N'set MG[$85]='SL3O'set MG[$86]='SL3P'set MG[$87]='SL3Q'set MG[$88]='SL3R'set MG[$89]='SL3S'set MG[$8A]='SL3T'set MG[$8B]='SL3U'set MG[$8C]='SL3V'set MG[$8D]='SL3W'set MG[$8E]='SL3X'set MG[$8F]='SL3Y'set MG[$90]='SL3Z'set MG[$91]='SL40'set MG[$92]='SL41'set MG[$93]='SL42'set MG[$94]='SL43'set MG[$95]='SL44'set MG[$96]='SL45'set MG[$97]='SL46'set MG[$98]='SL47'set MG[$99]='SL48'set MG[$9A]='SL49'set MG[$9B]='SL4A'set MG[$9C]='SL4B'set MG[$9D]='SL4C'set MG[$9E]='SL4D'set MG[$9F]='SL4E'set MG[$A0]='SL4F'set MG[$A1]='SL4G'set MG[$A2]='SL4H'set MG[$A3]='SL4I'set MG[$A4]='SL4J'set MG[$A5]='SL4K'set MG[$A6]='SL4L'set MG[$A7]='SL4M'set MG[$A8]='SL4N'set MG[$A9]='SL4O'set MG[$AA]='SL4P'set MG[$AB]='SL4Q'set MG[$AC]='SL4R'set MG[$AD]='SL4S'set MG[$AE]='SL4T'set MG[$AF]='SL4U'set MG[$B0]='SL4V'set MG[$B1]='SL4W'set MG[$B2]='SL4X'set MG[$B3]='SL4Y'set MG[$B4]='SL4Z'set MG[$B5]='SL50'set MG[$B6]='SL51'set MG[$B7]='SL52'set MG[$B8]='SL53'set MG[$B9]='SL54'set MG[$BA]='SL55'set MG[$BB]='SL56'set MG[$BC]='SL57'set MG[$BD]='SL58'set MG[$BE]='SL59'set MG[$BF]='SL5A'set MG[$C0]='SL5B'set MG[$C1]='SL5C'set MG[$C2]='SL5D'set MG[$C3]='SL5E'set MG[$C4]='SL5F'set MG[$C5]='SL5G'set MG[$C6]='SL5H'set MG[$C7]='SL5I'set MG[$C8]='SL5J'set MG[$C9]='SL5K'set MG[$CA]='SL5L'set MG[$CB]='SL5M'set MG[$CC]='SL5N'set MG[$CD]='SL5O'set MG[$CE]='SL5P'set MG[$CF]='SL5Q'set MG[$D0]='SL5R'set MG[$D1]='SL5S'set MG[$D2]='SL5T'set MG[$D3]='SL5U'set MG[$D4]='SL5V'set MG[$D5]='SL5W'set MG[$D6]='SL5X'set MG[$D7]='SL5Y'set MG[$D8]='SL5Z'set MG[$D9]='SL60'set MG[$DA]='SL61'set MG[$DB]='SL62'set MG[$DC]='SL63'set MG[$DD]='SL64'set MG[$DE]='SL65'set MG[$DF]='SL66'set MG[$E0]='SL67'set MG[$E1]='SL68'set MG[$E2]='SL69'set MG[$E3]='SL6A'set MG[$E4]='SL6B'set MG[$E5]='SL6C'set MG[$E6]='SL6D'set MG[$E7]='SL6E'set MG[$E8]='SL6F'set MG[$E9]='SL6G'set MG[$EA]='SL6H'set MG[$EB]='SL6I'set MG[$EC]='SL6J'set MG[$ED]='SL6K'set MG[$EE]='SL6L'set MG[$EF]='SL6M'set MG[$F0]='SL6N'set MG[$F1]='SL6O'set MG[$F2]='SL6P'set MG[$F3]='SL6Q'set MG[$F4]='SL6R'set MG[$F5]='SL6S'set MG[$F6]='SL6T'set MG[$F7]='SL6U'set MG[$F8]='SL6V'set MG[$F9]='SL6W'set MG[$FA]='SL6X'set MG[$FB]='SL6Y'set MG[$FC]='SL6Z'set MG[$FD]='SL70'set MG[$FE]='SL71'set MG[$FF]='SL72'set MG[256]='SL73'set lG[1]='TL00'
set lG[2]='TL01'
set lG[3]='TL02'
set lG[4]='TL03'
set lG[5]='TL04'
set lG[6]='TL05'
set lG[7]='TL06'
set lG[8]='TL07'
set lG[9]='TL08'
set lG[$A]='TL09'set lG[$B]='TL0A'set lG[$C]='TL0B'set lG[$D]='TL0C'set lG[$E]='TL0D'set lG[$F]='TL0E'set lG[16]='TL0F'set lG[17]='TL0G'set lG[18]='TL0H'set lG[19]='TL0I'set lG[20]='TL0J'set lG[21]='TL0K'set lG[22]='TL0L'set lG[23]='TL0M'set lG[24]='TL0N'set lG[25]='TL0O'set lG[26]='TL0P'set lG[27]='TL0Q'set lG[28]='TL0R'set lG[29]='TL0S'set lG[30]='TL0T'set lG[31]='TL0U'set lG[32]='TL0V'set lG[33]='TL0W'set lG[34]='TL0X'set lG[35]='TL0Y'set lG[36]='TL0Z'set lG[37]='TL10'set lG[38]='TL11'set lG[39]='TL12'set lG[40]='TL13'set lG[41]='TL14'set lG[42]='TL15'set lG[43]='TL16'set lG[44]='TL17'set lG[45]='TL18'set lG[46]='TL19'set lG[47]='TL1A'set lG[48]='TL1B'set lG[49]='TL1C'set lG[50]='TL1D'set lG[51]='TL1E'set lG[52]='TL1F'set lG[53]='TL1G'set lG[54]='TL1H'set lG[55]='TL1I'set lG[56]='TL1J'set lG[57]='TL1K'set lG[58]='TL1L'set lG[59]='TL1M'set lG[60]='TL1N'set lG[61]='TL1O'set lG[62]='TL1P'set lG[63]='TL1Q'set lG[64]='TL1R'set lG[65]='TL1S'set lG[66]='TL1T'set lG[67]='TL1U'set lG[68]='TL1V'set lG[69]='TL1W'set lG[70]='TL1X'set lG[71]='TL1Y'set lG[72]='TL1Z'set lG[73]='TL20'set lG[74]='TL21'set lG[75]='TL22'set lG[76]='TL23'set lG[77]='TL24'set lG[78]='TL25'set lG[79]='TL26'set lG[80]='TL27'set lG[81]='TL28'set lG[82]='TL29'set lG[83]='TL2A'set lG[84]='TL2B'set lG[85]='TL2C'set lG[86]='TL2D'set lG[87]='TL2E'set lG[88]='TL2F'set lG[89]='TL2G'set lG[90]='TL2H'set lG[91]='TL2I'set lG[92]='TL2J'set lG[93]='TL2K'set lG[94]='TL2L'set lG[95]='TL2M'set lG[96]='TL2N'set lG[97]='TL2O'set lG[98]='TL2P'set lG[99]='TL2Q'set lG['d']='TL2R'set lG['e']='TL2S'set lG['f']='TL2T'set lG['g']='TL2U'set lG['h']='TL2V'set lG['i']='TL2W'set lG['j']='TL2X'set lG['k']='TL2Y'set lG['l']='TL2Z'set lG['m']='TL30'set lG['n']='TL31'set lG['o']='TL32'set lG['p']='TL33'set lG['q']='TL34'set lG['r']='TL35'set lG['s']='TL36'set lG['t']='TL37'set lG['u']='TL38'set lG['v']='TL39'set lG['w']='TL3A'set lG['x']='TL3B'set lG['y']='TL3C'set lG['z']='TL3D'set lG['{']='TL3E'set lG['|']='TL3F'set lG['}']='TL3G'set lG[$7E]='TL3H'set lG[$7F]='TL3I'set lG[$80]='TL3J'set lG[$81]='TL3K'set lG[$82]='TL3L'set lG[$83]='TL3M'set lG[$84]='TL3N'set lG[$85]='TL3O'set lG[$86]='TL3P'set lG[$87]='TL3Q'set lG[$88]='TL3R'set lG[$89]='TL3S'set lG[$8A]='TL3T'set lG[$8B]='TL3U'set lG[$8C]='TL3V'set lG[$8D]='TL3W'set lG[$8E]='TL3X'set lG[$8F]='TL3Y'set lG[$90]='TL3Z'set lG[$91]='TL40'set lG[$92]='TL41'set lG[$93]='TL42'set lG[$94]='TL43'set lG[$95]='TL44'set lG[$96]='TL45'set lG[$97]='TL46'set lG[$98]='TL47'set lG[$99]='TL48'set lG[$9A]='TL49'set lG[$9B]='TL4A'set lG[$9C]='TL4B'set lG[$9D]='TL4C'set lG[$9E]='TL4D'set lG[$9F]='TL4E'set lG[$A0]='TL4F'set lG[$A1]='TL4G'set lG[$A2]='TL4H'set lG[$A3]='TL4I'set lG[$A4]='TL4J'set lG[$A5]='TL4K'set lG[$A6]='TL4L'set lG[$A7]='TL4M'set lG[$A8]='TL4N'set lG[$A9]='TL4O'set lG[$AA]='TL4P'set lG[$AB]='TL4Q'set lG[$AC]='TL4R'set lG[$AD]='TL4S'set lG[$AE]='TL4T'set lG[$AF]='TL4U'set lG[$B0]='TL4V'set lG[$B1]='TL4W'set lG[$B2]='TL4X'set lG[$B3]='TL4Y'set lG[$B4]='TL4Z'set lG[$B5]='TL50'set lG[$B6]='TL51'set lG[$B7]='TL52'set lG[$B8]='TL53'set lG[$B9]='TL54'set lG[$BA]='TL55'set lG[$BB]='TL56'set lG[$BC]='TL57'set lG[$BD]='TL58'set lG[$BE]='TL59'set lG[$BF]='TL5A'set lG[$C0]='TL5B'set lG[$C1]='TL5C'set lG[$C2]='TL5D'set lG[$C3]='TL5E'set lG[$C4]='TL5F'set lG[$C5]='TL5G'set lG[$C6]='TL5H'set lG[$C7]='TL5I'set lG[$C8]='TL5J'set lG[$C9]='TL5K'set lG[$CA]='TL5L'set lG[$CB]='TL5M'set lG[$CC]='TL5N'set lG[$CD]='TL5O'set lG[$CE]='TL5P'set lG[$CF]='TL5Q'set lG[$D0]='TL5R'set lG[$D1]='TL5S'set lG[$D2]='TL5T'set lG[$D3]='TL5U'set lG[$D4]='TL5V'set lG[$D5]='TL5W'set lG[$D6]='TL5X'set lG[$D7]='TL5Y'set lG[$D8]='TL5Z'set lG[$D9]='TL60'set lG[$DA]='TL61'set lG[$DB]='TL62'set lG[$DC]='TL63'set lG[$DD]='TL64'set lG[$DE]='TL65'set lG[$DF]='TL66'set lG[$E0]='TL67'set lG[$E1]='TL68'set lG[$E2]='TL69'set lG[$E3]='TL6A'set lG[$E4]='TL6B'set lG[$E5]='TL6C'set lG[$E6]='TL6D'set lG[$E7]='TL6E'set lG[$E8]='TL6F'set lG[$E9]='TL6G'set lG[$EA]='TL6H'set lG[$EB]='TL6I'set lG[$EC]='TL6J'set lG[$ED]='TL6K'set lG[$EE]='TL6L'set lG[$EF]='TL6M'set lG[$F0]='TL6N'set lG[$F1]='TL6O'set lG[$F2]='TL6P'set lG[$F3]='TL6Q'set lG[$F4]='TL6R'set lG[$F5]='TL6S'set lG[$F6]='TL6T'set lG[$F7]='TL6U'set lG[$F8]='TL6V'set lG[$F9]='TL6W'set lG[$FA]='TL6X'set lG[$FB]='TL6Y'set lG[$FC]='TL6Z'set lG[$FD]='TL70'set lG[$FE]='TL71'set lG[$FF]='TL72'set lG[256]='TL73'return trueendfunctionfunction iqo takes nothing returns booleanset n8v[1]='SL00'call L1x('SL00',false)set n8v[2]='SL01'call L1x('SL01',false)set n8v[3]='SL02'call L1x('SL02',false)set n8v[4]='SL03'call L1x('SL03',false)set n8v[5]='SL04'call L1x('SL04',false)set n8v[6]='SL05'call L1x('SL05',false)set n8v[7]='SL06'call L1x('SL06',false)set n8v[8]='SL07'call L1x('SL07',false)set n8v[9]='SL08'call L1x('SL08',false)set n8v[$A]='SL09'call L1x('SL09',false)set n8v[$B]='SL0A'call L1x('SL0A',false)set n8v[$C]='SL0B'call L1x('SL0B',false)set n8v[$D]='SL0C'call L1x('SL0C',false)set n8v[$E]='SL0D'call L1x('SL0D',false)set n8v[$F]='SL0E'call L1x('SL0E',false)set n8v[16]='SL0F'call L1x('SL0F',false)set n8v[17]='SL0G'call L1x('SL0G',false)set n8v[18]='SL0H'call L1x('SL0H',false)set n8v[19]='SL0I'call L1x('SL0I',false)set n8v[20]='SL0J'call L1x('SL0J',false)set n8v[21]='SL0K'call L1x('SL0K',false)set n8v[22]='SL0L'call L1x('SL0L',false)set n8v[23]='SL0M'call L1x('SL0M',false)set n8v[24]='SL0N'call L1x('SL0N',false)set n8v[25]='SL0O'call L1x('SL0O',false)set n8v[26]='SL0P'call L1x('SL0P',false)set n8v[27]='SL0Q'call L1x('SL0Q',false)set n8v[28]='SL0R'call L1x('SL0R',false)set n8v[29]='SL0S'call L1x('SL0S',false)set n8v[30]='SL0T'call L1x('SL0T',false)set n8v[31]='SL0U'call L1x('SL0U',false)set n8v[32]='SL0V'call L1x('SL0V',false)set n8v[33]='SL0W'call L1x('SL0W',false)set n8v[34]='SL0X'call L1x('SL0X',false)set n8v[35]='SL0Y'call L1x('SL0Y',false)set n8v[36]='SL0Z'call L1x('SL0Z',false)set n8v[37]='SL10'call L1x('SL10',false)set n8v[38]='SL11'call L1x('SL11',false)set n8v[39]='SL12'call L1x('SL12',false)set n8v[40]='SL13'call L1x('SL13',false)set n8v[41]='SL14'call L1x('SL14',false)set n8v[42]='SL15'call L1x('SL15',false)set n8v[43]='SL16'call L1x('SL16',false)set n8v[44]='SL17'call L1x('SL17',false)set n8v[45]='SL18'call L1x('SL18',false)set n8v[46]='SL19'call L1x('SL19',false)set n8v[47]='SL1A'call L1x('SL1A',false)set n8v[48]='SL1B'call L1x('SL1B',false)set n8v[49]='SL1C'call L1x('SL1C',false)set n8v[50]='SL1D'call L1x('SL1D',false)set n8v[51]='SL1E'call L1x('SL1E',false)set n8v[52]='SL1F'call L1x('SL1F',false)set n8v[53]='SL1G'call L1x('SL1G',false)set n8v[54]='SL1H'call L1x('SL1H',false)set n8v[55]='SL1I'call L1x('SL1I',false)set n8v[56]='SL1J'call L1x('SL1J',false)set n8v[57]='SL1K'call L1x('SL1K',false)set n8v[58]='SL1L'call L1x('SL1L',false)set n8v[59]='SL1M'call L1x('SL1M',false)set n8v[60]='SL1N'call L1x('SL1N',false)set n8v[61]='SL1O'call L1x('SL1O',false)set n8v[62]='SL1P'call L1x('SL1P',false)set n8v[63]='SL1Q'call L1x('SL1Q',false)set n8v[64]='SL1R'call L1x('SL1R',false)set n8v[65]='SL1S'call L1x('SL1S',false)set n8v[66]='SL1T'call L1x('SL1T',false)set n8v[67]='SL1U'call L1x('SL1U',false)set n8v[68]='SL1V'call L1x('SL1V',false)set n8v[69]='SL1W'call L1x('SL1W',false)set n8v[70]='SL1X'call L1x('SL1X',false)set n8v[71]='SL1Y'call L1x('SL1Y',false)set n8v[72]='SL1Z'call L1x('SL1Z',false)set n8v[73]='SL20'call L1x('SL20',false)set n8v[74]='SL21'call L1x('SL21',false)set n8v[75]='SL22'call L1x('SL22',false)set n8v[76]='SL23'call L1x('SL23',false)set n8v[77]='SL24'call L1x('SL24',false)set n8v[78]='SL25'call L1x('SL25',false)set n8v[79]='SL26'call L1x('SL26',false)set n8v[80]='SL27'call L1x('SL27',false)set n8v[81]='SL28'call L1x('SL28',false)set n8v[82]='SL29'call L1x('SL29',false)set n8v[83]='SL2A'call L1x('SL2A',false)set n8v[84]='SL2B'call L1x('SL2B',false)set n8v[85]='SL2C'call L1x('SL2C',false)set n8v[86]='SL2D'call L1x('SL2D',false)set n8v[87]='SL2E'call L1x('SL2E',false)set n8v[88]='SL2F'call L1x('SL2F',false)set n8v[89]='SL2G'call L1x('SL2G',false)set n8v[90]='SL2H'call L1x('SL2H',false)set n8v[91]='SL2I'call L1x('SL2I',false)set n8v[92]='SL2J'call L1x('SL2J',false)set n8v[93]='SL2K'call L1x('SL2K',false)set n8v[94]='SL2L'call L1x('SL2L',false)set n8v[95]='SL2M'call L1x('SL2M',false)set n8v[96]='SL2N'call L1x('SL2N',false)set n8v[97]='SL2O'call L1x('SL2O',false)set n8v[98]='SL2P'call L1x('SL2P',false)set n8v[99]='SL2Q'call L1x('SL2Q',false)set n8v['d']='SL2R'call L1x('SL2R',false)set n8v['e']='SL2S'call L1x('SL2S',false)set n8v['f']='SL2T'call L1x('SL2T',false)set n8v['g']='SL2U'call L1x('SL2U',false)set n8v['h']='SL2V'call L1x('SL2V',false)set n8v['i']='SL2W'call L1x('SL2W',false)set n8v['j']='SL2X'call L1x('SL2X',false)set n8v['k']='SL2Y'call L1x('SL2Y',false)set n8v['l']='SL2Z'call L1x('SL2Z',false)set n8v['m']='SL30'call L1x('SL30',false)set n8v['n']='SL31'call L1x('SL31',false)set n8v['o']='SL32'call L1x('SL32',false)set n8v['p']='SL33'call L1x('SL33',false)set n8v['q']='SL34'call L1x('SL34',false)set n8v['r']='SL35'call L1x('SL35',false)set n8v['s']='SL36'call L1x('SL36',false)set n8v['t']='SL37'call L1x('SL37',false)set n8v['u']='SL38'call L1x('SL38',false)set n8v['v']='SL39'call L1x('SL39',false)set n8v['w']='SL3A'call L1x('SL3A',false)set n8v['x']='SL3B'call L1x('SL3B',false)set n8v['y']='SL3C'call L1x('SL3C',false)set n8v['z']='SL3D'call L1x('SL3D',false)set n8v['{']='SL3E'call L1x('SL3E',false)set n8v['|']='SL3F'call L1x('SL3F',false)set n8v['}']='SL3G'call L1x('SL3G',false)set n8v[$7E]='SL3H'call L1x('SL3H',false)set n8v[$7F]='SL3I'call L1x('SL3I',false)set n8v[$80]='SL3J'call L1x('SL3J',false)set n8v[$81]='SL3K'call L1x('SL3K',false)set n8v[$82]='SL3L'call L1x('SL3L',false)set n8v[$83]='SL3M'call L1x('SL3M',false)set n8v[$84]='SL3N'call L1x('SL3N',false)set n8v[$85]='SL3O'call L1x('SL3O',false)set n8v[$86]='SL3P'call L1x('SL3P',false)set n8v[$87]='SL3Q'call L1x('SL3Q',false)set n8v[$88]='SL3R'call L1x('SL3R',false)set n8v[$89]='SL3S'call L1x('SL3S',false)set n8v[$8A]='SL3T'call L1x('SL3T',false)set n8v[$8B]='SL3U'call L1x('SL3U',false)set n8v[$8C]='SL3V'call L1x('SL3V',false)set n8v[$8D]='SL3W'call L1x('SL3W',false)set n8v[$8E]='SL3X'call L1x('SL3X',false)set n8v[$8F]='SL3Y'call L1x('SL3Y',false)set n8v[$90]='SL3Z'call L1x('SL3Z',false)set n8v[$91]='SL40'call L1x('SL40',false)set n8v[$92]='SL41'call L1x('SL41',false)set n8v[$93]='SL42'call L1x('SL42',false)set n8v[$94]='SL43'call L1x('SL43',false)set n8v[$95]='SL44'call L1x('SL44',false)set n8v[$96]='SL45'call L1x('SL45',false)set n8v[$97]='SL46'call L1x('SL46',false)set n8v[$98]='SL47'call L1x('SL47',false)set n8v[$99]='SL48'call L1x('SL48',false)set n8v[$9A]='SL49'call L1x('SL49',false)set n8v[$9B]='SL4A'call L1x('SL4A',false)set n8v[$9C]='SL4B'call L1x('SL4B',false)set n8v[$9D]='SL4C'call L1x('SL4C',false)set n8v[$9E]='SL4D'call L1x('SL4D',false)set n8v[$9F]='SL4E'call L1x('SL4E',false)set n8v[$A0]='SL4F'call L1x('SL4F',false)set n8v[$A1]='SL4G'call L1x('SL4G',false)set n8v[$A2]='SL4H'call L1x('SL4H',false)set n8v[$A3]='SL4I'call L1x('SL4I',false)set n8v[$A4]='SL4J'call L1x('SL4J',false)set n8v[$A5]='SL4K'call L1x('SL4K',false)set n8v[$A6]='SL4L'call L1x('SL4L',false)set n8v[$A7]='SL4M'call L1x('SL4M',false)set n8v[$A8]='SL4N'call L1x('SL4N',false)set n8v[$A9]='SL4O'call L1x('SL4O',false)set n8v[$AA]='SL4P'call L1x('SL4P',false)set n8v[$AB]='SL4Q'call L1x('SL4Q',false)set n8v[$AC]='SL4R'call L1x('SL4R',false)set n8v[$AD]='SL4S'call L1x('SL4S',false)set n8v[$AE]='SL4T'call L1x('SL4T',false)set n8v[$AF]='SL4U'call L1x('SL4U',false)set n8v[$B0]='SL4V'call L1x('SL4V',false)set n8v[$B1]='SL4W'call L1x('SL4W',false)set n8v[$B2]='SL4X'call L1x('SL4X',false)set n8v[$B3]='SL4Y'call L1x('SL4Y',false)set n8v[$B4]='SL4Z'call L1x('SL4Z',false)set n8v[$B5]='SL50'call L1x('SL50',false)set n8v[$B6]='SL51'call L1x('SL51',false)set n8v[$B7]='SL52'call L1x('SL52',false)set n8v[$B8]='SL53'call L1x('SL53',false)set n8v[$B9]='SL54'call L1x('SL54',false)set n8v[$BA]='SL55'call L1x('SL55',false)set n8v[$BB]='SL56'call L1x('SL56',false)set n8v[$BC]='SL57'call L1x('SL57',false)set n8v[$BD]='SL58'call L1x('SL58',false)set n8v[$BE]='SL59'call L1x('SL59',false)set n8v[$BF]='SL5A'call L1x('SL5A',false)set n8v[$C0]='SL5B'call L1x('SL5B',false)set n8v[$C1]='SL5C'call L1x('SL5C',false)set n8v[$C2]='SL5D'call L1x('SL5D',false)set n8v[$C3]='SL5E'call L1x('SL5E',false)set n8v[$C4]='SL5F'call L1x('SL5F',false)set n8v[$C5]='SL5G'call L1x('SL5G',false)set n8v[$C6]='SL5H'call L1x('SL5H',false)set n8v[$C7]='SL5I'call L1x('SL5I',false)set n8v[$C8]='SL5J'call L1x('SL5J',false)set n8v[$C9]='SL5K'call L1x('SL5K',false)set n8v[$CA]='SL5L'call L1x('SL5L',false)set n8v[$CB]='SL5M'call L1x('SL5M',false)set n8v[$CC]='SL5N'call L1x('SL5N',false)set n8v[$CD]='SL5O'call L1x('SL5O',false)set n8v[$CE]='SL5P'call L1x('SL5P',false)set n8v[$CF]='SL5Q'call L1x('SL5Q',false)set n8v[$D0]='SL5R'call L1x('SL5R',false)set n8v[$D1]='SL5S'call L1x('SL5S',false)set n8v[$D2]='SL5T'call L1x('SL5T',false)set n8v[$D3]='SL5U'call L1x('SL5U',false)set n8v[$D4]='SL5V'call L1x('SL5V',false)set n8v[$D5]='SL5W'call L1x('SL5W',false)set n8v[$D6]='SL5X'call L1x('SL5X',false)set n8v[$D7]='SL5Y'call L1x('SL5Y',false)set n8v[$D8]='SL5Z'call L1x('SL5Z',false)set n8v[$D9]='SL60'call L1x('SL60',false)set n8v[$DA]='SL61'call L1x('SL61',false)set n8v[$DB]='SL62'call L1x('SL62',false)set n8v[$DC]='SL63'call L1x('SL63',false)set n8v[$DD]='SL64'call L1x('SL64',false)set n8v[$DE]='SL65'call L1x('SL65',false)set n8v[$DF]='SL66'call L1x('SL66',false)set n8v[$E0]='SL67'call L1x('SL67',false)set n8v[$E1]='SL68'call L1x('SL68',false)set n8v[$E2]='SL69'call L1x('SL69',false)set n8v[$E3]='SL6A'call L1x('SL6A',false)set n8v[$E4]='SL6B'call L1x('SL6B',false)set n8v[$E5]='SL6C'call L1x('SL6C',false)set n8v[$E6]='SL6D'call L1x('SL6D',false)set n8v[$E7]='SL6E'call L1x('SL6E',false)set n8v[$E8]='SL6F'call L1x('SL6F',false)set n8v[$E9]='SL6G'call L1x('SL6G',false)set n8v[$EA]='SL6H'call L1x('SL6H',false)set n8v[$EB]='SL6I'call L1x('SL6I',false)set n8v[$EC]='SL6J'call L1x('SL6J',false)set n8v[$ED]='SL6K'call L1x('SL6K',false)set n8v[$EE]='SL6L'call L1x('SL6L',false)set n8v[$EF]='SL6M'call L1x('SL6M',false)set n8v[$F0]='SL6N'call L1x('SL6N',false)set n8v[$F1]='SL6O'call L1x('SL6O',false)set n8v[$F2]='SL6P'call L1x('SL6P',false)set n8v[$F3]='SL6Q'call L1x('SL6Q',false)set n8v[$F4]='SL6R'call L1x('SL6R',false)set n8v[$F5]='SL6S'call L1x('SL6S',false)set n8v[$F6]='SL6T'call L1x('SL6T',false)set n8v[$F7]='SL6U'call L1x('SL6U',false)set n8v[$F8]='SL6V'call L1x('SL6V',false)set n8v[$F9]='SL6W'call L1x('SL6W',false)set n8v[$FA]='SL6X'call L1x('SL6X',false)set n8v[$FB]='SL6Y'call L1x('SL6Y',false)set n8v[$FC]='SL6Z'call L1x('SL6Z',false)set n8v[$FD]='SL70'call L1x('SL70',false)set n8v[$FE]='SL71'call L1x('SL71',false)set n8v[$FF]='SL72'call L1x('SL72',false)set n8v[256]='SL73'call L1x('SL73',false)set n9v[1]='TL00'call L1x('TL00',false)set n9v[2]='TL01'call L1x('TL01',false)set n9v[3]='TL02'call L1x('TL02',false)set n9v[4]='TL03'call L1x('TL03',false)set n9v[5]='TL04'call L1x('TL04',false)set n9v[6]='TL05'call L1x('TL05',false)set n9v[7]='TL06'call L1x('TL06',false)set n9v[8]='TL07'call L1x('TL07',false)set n9v[9]='TL08'call L1x('TL08',false)set n9v[$A]='TL09'call L1x('TL09',false)set n9v[$B]='TL0A'call L1x('TL0A',false)set n9v[$C]='TL0B'call L1x('TL0B',false)set n9v[$D]='TL0C'call L1x('TL0C',false)set n9v[$E]='TL0D'call L1x('TL0D',false)set n9v[$F]='TL0E'call L1x('TL0E',false)set n9v[16]='TL0F'call L1x('TL0F',false)set n9v[17]='TL0G'call L1x('TL0G',false)set n9v[18]='TL0H'call L1x('TL0H',false)set n9v[19]='TL0I'call L1x('TL0I',false)set n9v[20]='TL0J'call L1x('TL0J',false)set n9v[21]='TL0K'call L1x('TL0K',false)set n9v[22]='TL0L'call L1x('TL0L',false)set n9v[23]='TL0M'call L1x('TL0M',false)set n9v[24]='TL0N'call L1x('TL0N',false)set n9v[25]='TL0O'call L1x('TL0O',false)set n9v[26]='TL0P'call L1x('TL0P',false)set n9v[27]='TL0Q'call L1x('TL0Q',false)set n9v[28]='TL0R'call L1x('TL0R',false)set n9v[29]='TL0S'call L1x('TL0S',false)set n9v[30]='TL0T'call L1x('TL0T',false)set n9v[31]='TL0U'call L1x('TL0U',false)set n9v[32]='TL0V'call L1x('TL0V',false)set n9v[33]='TL0W'call L1x('TL0W',false)set n9v[34]='TL0X'call L1x('TL0X',false)set n9v[35]='TL0Y'call L1x('TL0Y',false)set n9v[36]='TL0Z'call L1x('TL0Z',false)set n9v[37]='TL10'call L1x('TL10',false)set n9v[38]='TL11'call L1x('TL11',false)set n9v[39]='TL12'call L1x('TL12',false)set n9v[40]='TL13'call L1x('TL13',false)set n9v[41]='TL14'call L1x('TL14',false)set n9v[42]='TL15'call L1x('TL15',false)set n9v[43]='TL16'call L1x('TL16',false)set n9v[44]='TL17'call L1x('TL17',false)set n9v[45]='TL18'call L1x('TL18',false)set n9v[46]='TL19'call L1x('TL19',false)set n9v[47]='TL1A'call L1x('TL1A',false)set n9v[48]='TL1B'call L1x('TL1B',false)set n9v[49]='TL1C'call L1x('TL1C',false)set n9v[50]='TL1D'call L1x('TL1D',false)set n9v[51]='TL1E'call L1x('TL1E',false)set n9v[52]='TL1F'call L1x('TL1F',false)set n9v[53]='TL1G'call L1x('TL1G',false)set n9v[54]='TL1H'call L1x('TL1H',false)set n9v[55]='TL1I'call L1x('TL1I',false)set n9v[56]='TL1J'call L1x('TL1J',false)set n9v[57]='TL1K'call L1x('TL1K',false)set n9v[58]='TL1L'call L1x('TL1L',false)set n9v[59]='TL1M'call L1x('TL1M',false)set n9v[60]='TL1N'call L1x('TL1N',false)set n9v[61]='TL1O'call L1x('TL1O',false)set n9v[62]='TL1P'call L1x('TL1P',false)set n9v[63]='TL1Q'call L1x('TL1Q',false)set n9v[64]='TL1R'call L1x('TL1R',false)set n9v[65]='TL1S'call L1x('TL1S',false)set n9v[66]='TL1T'call L1x('TL1T',false)set n9v[67]='TL1U'call L1x('TL1U',false)set n9v[68]='TL1V'call L1x('TL1V',false)set n9v[69]='TL1W'call L1x('TL1W',false)set n9v[70]='TL1X'call L1x('TL1X',false)set n9v[71]='TL1Y'call L1x('TL1Y',false)set n9v[72]='TL1Z'call L1x('TL1Z',false)set n9v[73]='TL20'call L1x('TL20',false)set n9v[74]='TL21'call L1x('TL21',false)set n9v[75]='TL22'call L1x('TL22',false)set n9v[76]='TL23'call L1x('TL23',false)set n9v[77]='TL24'call L1x('TL24',false)set n9v[78]='TL25'call L1x('TL25',false)set n9v[79]='TL26'call L1x('TL26',false)set n9v[80]='TL27'call L1x('TL27',false)set n9v[81]='TL28'call L1x('TL28',false)set n9v[82]='TL29'call L1x('TL29',false)set n9v[83]='TL2A'call L1x('TL2A',false)set n9v[84]='TL2B'call L1x('TL2B',false)set n9v[85]='TL2C'call L1x('TL2C',false)set n9v[86]='TL2D'call L1x('TL2D',false)set n9v[87]='TL2E'call L1x('TL2E',false)set n9v[88]='TL2F'call L1x('TL2F',false)set n9v[89]='TL2G'call L1x('TL2G',false)set n9v[90]='TL2H'call L1x('TL2H',false)set n9v[91]='TL2I'call L1x('TL2I',false)set n9v[92]='TL2J'call L1x('TL2J',false)set n9v[93]='TL2K'call L1x('TL2K',false)set n9v[94]='TL2L'call L1x('TL2L',false)set n9v[95]='TL2M'call L1x('TL2M',false)set n9v[96]='TL2N'call L1x('TL2N',false)set n9v[97]='TL2O'call L1x('TL2O',false)set n9v[98]='TL2P'call L1x('TL2P',false)set n9v[99]='TL2Q'call L1x('TL2Q',false)set n9v['d']='TL2R'call L1x('TL2R',false)set n9v['e']='TL2S'call L1x('TL2S',false)set n9v['f']='TL2T'call L1x('TL2T',false)set n9v['g']='TL2U'call L1x('TL2U',false)set n9v['h']='TL2V'call L1x('TL2V',false)set n9v['i']='TL2W'call L1x('TL2W',false)set n9v['j']='TL2X'call L1x('TL2X',false)set n9v['k']='TL2Y'call L1x('TL2Y',false)set n9v['l']='TL2Z'call L1x('TL2Z',false)set n9v['m']='TL30'call L1x('TL30',false)set n9v['n']='TL31'call L1x('TL31',false)set n9v['o']='TL32'call L1x('TL32',false)set n9v['p']='TL33'call L1x('TL33',false)set n9v['q']='TL34'call L1x('TL34',false)set n9v['r']='TL35'call L1x('TL35',false)set n9v['s']='TL36'call L1x('TL36',false)set n9v['t']='TL37'call L1x('TL37',false)set n9v['u']='TL38'call L1x('TL38',false)set n9v['v']='TL39'call L1x('TL39',false)set n9v['w']='TL3A'call L1x('TL3A',false)set n9v['x']='TL3B'call L1x('TL3B',false)set n9v['y']='TL3C'call L1x('TL3C',false)set n9v['z']='TL3D'call L1x('TL3D',false)set n9v['{']='TL3E'call L1x('TL3E',false)set n9v['|']='TL3F'call L1x('TL3F',false)set n9v['}']='TL3G'call L1x('TL3G',false)set n9v[$7E]='TL3H'call L1x('TL3H',false)set n9v[$7F]='TL3I'call L1x('TL3I',false)set n9v[$80]='TL3J'call L1x('TL3J',false)set n9v[$81]='TL3K'call L1x('TL3K',false)set n9v[$82]='TL3L'call L1x('TL3L',false)set n9v[$83]='TL3M'call L1x('TL3M',false)set n9v[$84]='TL3N'call L1x('TL3N',false)set n9v[$85]='TL3O'call L1x('TL3O',false)set n9v[$86]='TL3P'call L1x('TL3P',false)set n9v[$87]='TL3Q'call L1x('TL3Q',false)set n9v[$88]='TL3R'call L1x('TL3R',false)set n9v[$89]='TL3S'call L1x('TL3S',false)set n9v[$8A]='TL3T'call L1x('TL3T',false)set n9v[$8B]='TL3U'call L1x('TL3U',false)set n9v[$8C]='TL3V'call L1x('TL3V',false)set n9v[$8D]='TL3W'call L1x('TL3W',false)set n9v[$8E]='TL3X'call L1x('TL3X',false)set n9v[$8F]='TL3Y'call L1x('TL3Y',false)set n9v[$90]='TL3Z'call L1x('TL3Z',false)set n9v[$91]='TL40'call L1x('TL40',false)set n9v[$92]='TL41'call L1x('TL41',false)set n9v[$93]='TL42'call L1x('TL42',false)set n9v[$94]='TL43'call L1x('TL43',false)set n9v[$95]='TL44'call L1x('TL44',false)set n9v[$96]='TL45'call L1x('TL45',false)set n9v[$97]='TL46'call L1x('TL46',false)set n9v[$98]='TL47'call L1x('TL47',false)set n9v[$99]='TL48'call L1x('TL48',false)set n9v[$9A]='TL49'call L1x('TL49',false)set n9v[$9B]='TL4A'call L1x('TL4A',false)set n9v[$9C]='TL4B'call L1x('TL4B',false)set n9v[$9D]='TL4C'call L1x('TL4C',false)set n9v[$9E]='TL4D'call L1x('TL4D',false)set n9v[$9F]='TL4E'call L1x('TL4E',false)set n9v[$A0]='TL4F'call L1x('TL4F',false)set n9v[$A1]='TL4G'call L1x('TL4G',false)set n9v[$A2]='TL4H'call L1x('TL4H',false)set n9v[$A3]='TL4I'call L1x('TL4I',false)set n9v[$A4]='TL4J'call L1x('TL4J',false)set n9v[$A5]='TL4K'call L1x('TL4K',false)set n9v[$A6]='TL4L'call L1x('TL4L',false)set n9v[$A7]='TL4M'call L1x('TL4M',false)set n9v[$A8]='TL4N'call L1x('TL4N',false)set n9v[$A9]='TL4O'call L1x('TL4O',false)set n9v[$AA]='TL4P'call L1x('TL4P',false)set n9v[$AB]='TL4Q'call L1x('TL4Q',false)set n9v[$AC]='TL4R'call L1x('TL4R',false)set n9v[$AD]='TL4S'call L1x('TL4S',false)set n9v[$AE]='TL4T'call L1x('TL4T',false)set n9v[$AF]='TL4U'call L1x('TL4U',false)set n9v[$B0]='TL4V'call L1x('TL4V',false)set n9v[$B1]='TL4W'call L1x('TL4W',false)set n9v[$B2]='TL4X'call L1x('TL4X',false)set n9v[$B3]='TL4Y'call L1x('TL4Y',false)set n9v[$B4]='TL4Z'call L1x('TL4Z',false)set n9v[$B5]='TL50'call L1x('TL50',false)set n9v[$B6]='TL51'call L1x('TL51',false)set n9v[$B7]='TL52'call L1x('TL52',false)set n9v[$B8]='TL53'call L1x('TL53',false)set n9v[$B9]='TL54'call L1x('TL54',false)set n9v[$BA]='TL55'call L1x('TL55',false)set n9v[$BB]='TL56'call L1x('TL56',false)set n9v[$BC]='TL57'call L1x('TL57',false)set n9v[$BD]='TL58'call L1x('TL58',false)set n9v[$BE]='TL59'call L1x('TL59',false)set n9v[$BF]='TL5A'call L1x('TL5A',false)set n9v[$C0]='TL5B'call L1x('TL5B',false)set n9v[$C1]='TL5C'call L1x('TL5C',false)set n9v[$C2]='TL5D'call L1x('TL5D',false)set n9v[$C3]='TL5E'call L1x('TL5E',false)set n9v[$C4]='TL5F'call L1x('TL5F',false)set n9v[$C5]='TL5G'call L1x('TL5G',false)set n9v[$C6]='TL5H'call L1x('TL5H',false)set n9v[$C7]='TL5I'call L1x('TL5I',false)set n9v[$C8]='TL5J'call L1x('TL5J',false)set n9v[$C9]='TL5K'call L1x('TL5K',false)set n9v[$CA]='TL5L'call L1x('TL5L',false)set n9v[$CB]='TL5M'call L1x('TL5M',false)set n9v[$CC]='TL5N'call L1x('TL5N',false)set n9v[$CD]='TL5O'call L1x('TL5O',false)set n9v[$CE]='TL5P'call L1x('TL5P',false)set n9v[$CF]='TL5Q'call L1x('TL5Q',false)set n9v[$D0]='TL5R'call L1x('TL5R',false)set n9v[$D1]='TL5S'call L1x('TL5S',false)set n9v[$D2]='TL5T'call L1x('TL5T',false)set n9v[$D3]='TL5U'call L1x('TL5U',false)set n9v[$D4]='TL5V'call L1x('TL5V',false)set n9v[$D5]='TL5W'call L1x('TL5W',false)set n9v[$D6]='TL5X'call L1x('TL5X',false)set n9v[$D7]='TL5Y'call L1x('TL5Y',false)set n9v[$D8]='TL5Z'call L1x('TL5Z',false)set n9v[$D9]='TL60'call L1x('TL60',false)set n9v[$DA]='TL61'call L1x('TL61',false)set n9v[$DB]='TL62'call L1x('TL62',false)set n9v[$DC]='TL63'call L1x('TL63',false)set n9v[$DD]='TL64'call L1x('TL64',false)set n9v[$DE]='TL65'call L1x('TL65',false)set n9v[$DF]='TL66'call L1x('TL66',false)set n9v[$E0]='TL67'call L1x('TL67',false)set n9v[$E1]='TL68'call L1x('TL68',false)set n9v[$E2]='TL69'call L1x('TL69',false)set n9v[$E3]='TL6A'call L1x('TL6A',false)set n9v[$E4]='TL6B'call L1x('TL6B',false)set n9v[$E5]='TL6C'call L1x('TL6C',false)set n9v[$E6]='TL6D'call L1x('TL6D',false)set n9v[$E7]='TL6E'call L1x('TL6E',false)set n9v[$E8]='TL6F'call L1x('TL6F',false)set n9v[$E9]='TL6G'call L1x('TL6G',false)set n9v[$EA]='TL6H'call L1x('TL6H',false)set n9v[$EB]='TL6I'call L1x('TL6I',false)set n9v[$EC]='TL6J'call L1x('TL6J',false)set n9v[$ED]='TL6K'call L1x('TL6K',false)set n9v[$EE]='TL6L'call L1x('TL6L',false)set n9v[$EF]='TL6M'call L1x('TL6M',false)set n9v[$F0]='TL6N'call L1x('TL6N',false)set n9v[$F1]='TL6O'call L1x('TL6O',false)set n9v[$F2]='TL6P'call L1x('TL6P',false)set n9v[$F3]='TL6Q'call L1x('TL6Q',false)set n9v[$F4]='TL6R'call L1x('TL6R',false)set n9v[$F5]='TL6S'call L1x('TL6S',false)set n9v[$F6]='TL6T'call L1x('TL6T',false)set n9v[$F7]='TL6U'call L1x('TL6U',false)set n9v[$F8]='TL6V'call L1x('TL6V',false)set n9v[$F9]='TL6W'call L1x('TL6W',false)set n9v[$FA]='TL6X'call L1x('TL6X',false)set n9v[$FB]='TL6Y'call L1x('TL6Y',false)set n9v[$FC]='TL6Z'call L1x('TL6Z',false)set n9v[$FD]='TL70'call L1x('TL70',false)set n9v[$FE]='TL71'call L1x('TL71',false)set n9v[$FF]='TL72'call L1x('TL72',false)set n9v[256]='TL73'call L1x('TL73',false)return trueendfunctionfunction iQo takes nothing returns booleancall VNx(va,(function iPo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\MaxLife\\obj_spells_wc3objLuainits.j"))call VNx(Pa,(function iqo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\MaxLife\\obj_spells_wc3objLuaspells.j"))return trueendfunctionfunction iso takes nothing returns booleanset Vvv=VXx(Vev)
return trueendfunctionfunction iSo takes nothing returns booleanset Vxv=VXx(Vov)
return trueendfunctionfunction ito takes nothing returns booleanset Vrv=VXx(Viv)
return trueendfunctionfunction iTo takes nothing returns booleanset Vav=VXx(Vnv)
return trueendfunctionfunction iuo takes nothing returns booleanset yg=ltx(VVv+" (dummyBuff)")return trueendfunctionfunction iUo takes nothing returns booleancall VNx(ma,(function iuo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\LifeRegeneration\\Disablement\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction iwo takes nothing returns booleanset VEv=VXx(VVv)
return trueendfunctionfunction iWo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set VXv[((rLx))]=(true)call clx(rLx)return trueendfunctionfunction iyo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set VXv[((rLx))]=(false)
if((Wg[(rLx)])>.0)thencall ckx(rLx)endifreturn trueendfunctionfunction iYo takes nothing returns booleancall Lxx(yg,Xdx("FolderUnit_FolderLifeRegeneration_StructDisablement_Buff_Init: call FolderUnit_FolderLifeRegeneration_StructDisablement.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderLifeRegeneration_StructDisablement.Event_BuffGain))",bd,MI,function iWo))call Lxx(yg,Xdx("FolderUnit_FolderLifeRegeneration_StructDisablement_Buff_Init: call FolderUnit_FolderLifeRegeneration_StructDisablement.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderLifeRegeneration_StructDisablement.Event_BuffLose))",jc,MI,function iyo))return trueendfunctionfunction izo takes nothing returns booleancall u9x(function iYo,"FolderUnit_FolderLifeRegeneration_StructDisablement_Buff_Init")return trueendfunctionfunction iZo takes nothing returns booleanset VOv=VXx(VRv)
return trueendfunctionfunction i_o takes nothing returns booleanset VIv=VXx(VAv)
return trueendfunctionfunction i0o takes nothing returns booleanset VNv=VXx(Vbv)
return trueendfunctionfunction i1o takes nothing returns booleanset VBv=VXx(Vcv)
return trueendfunctionfunction i2o takes nothing returns booleanset VCv=VXx(Vdv)
return trueendfunctionfunction i3o takes nothing returns booleanset uF[1]='SM00'
set uF[2]='SM01'
set uF[3]='SM02'
set uF[4]='SM03'
set uF[5]='SM04'
set uF[6]='SM05'
set uF[7]='SM06'
set uF[8]='SM07'
set uF[9]='SM08'
set uF[$A]='SM09'set uF[$B]='SM0A'set uF[$C]='SM0B'set uF[$D]='SM0C'set uF[$E]='SM0D'set uF[$F]='SM0E'set uF[16]='SM0F'set uF[17]='SM0G'set uF[18]='SM0H'set uF[19]='SM0I'set uF[20]='SM0J'set uF[21]='SM0K'set uF[22]='SM0L'set uF[23]='SM0M'set uF[24]='SM0N'set uF[25]='SM0O'set uF[26]='SM0P'set uF[27]='SM0Q'set uF[28]='SM0R'set uF[29]='SM0S'set uF[30]='SM0T'set uF[31]='SM0U'set uF[32]='SM0V'set uF[33]='SM0W'set uF[34]='SM0X'set uF[35]='SM0Y'set uF[36]='SM0Z'set uF[37]='SM10'set uF[38]='SM11'set uF[39]='SM12'set uF[40]='SM13'set uF[41]='SM14'set uF[42]='SM15'set uF[43]='SM16'set uF[44]='SM17'set uF[45]='SM18'set uF[46]='SM19'set uF[47]='SM1A'set uF[48]='SM1B'set uF[49]='SM1C'set uF[50]='SM1D'set uF[51]='SM1E'set uF[52]='SM1F'set uF[53]='SM1G'set uF[54]='SM1H'set uF[55]='SM1I'set uF[56]='SM1J'set uF[57]='SM1K'set uF[58]='SM1L'set uF[59]='SM1M'set uF[60]='SM1N'set uF[61]='SM1O'set uF[62]='SM1P'set uF[63]='SM1Q'set uF[64]='SM1R'set uF[65]='SM1S'set uF[66]='SM1T'set uF[67]='SM1U'set uF[68]='SM1V'set uF[69]='SM1W'set uF[70]='SM1X'set uF[71]='SM1Y'set uF[72]='SM1Z'set uF[73]='SM20'set uF[74]='SM21'set uF[75]='SM22'set uF[76]='SM23'set uF[77]='SM24'set uF[78]='SM25'set uF[79]='SM26'set uF[80]='SM27'set uF[81]='SM28'set uF[82]='SM29'set uF[83]='SM2A'set uF[84]='SM2B'set uF[85]='SM2C'set uF[86]='SM2D'set uF[87]='SM2E'set uF[88]='SM2F'set uF[89]='SM2G'set uF[90]='SM2H'set uF[91]='SM2I'set uF[92]='SM2J'set uF[93]='SM2K'set uF[94]='SM2L'set uF[95]='SM2M'set uF[96]='SM2N'set uF[97]='SM2O'set uF[98]='SM2P'set uF[99]='SM2Q'set uF['d']='SM2R'set uF['e']='SM2S'set uF['f']='SM2T'set uF['g']='SM2U'set uF['h']='SM2V'set uF['i']='SM2W'set uF['j']='SM2X'set uF['k']='SM2Y'set uF['l']='SM2Z'set uF['m']='SM30'set uF['n']='SM31'set uF['o']='SM32'set uF['p']='SM33'set uF['q']='SM34'set uF['r']='SM35'set uF['s']='SM36'set uF['t']='SM37'set uF['u']='SM38'set uF['v']='SM39'set uF['w']='SM3A'set uF['x']='SM3B'set uF['y']='SM3C'set uF['z']='SM3D'set uF['{']='SM3E'set uF['|']='SM3F'set uF['}']='SM3G'set uF[$7E]='SM3H'set uF[$7F]='SM3I'set uF[$80]='SM3J'set uF[$81]='SM3K'set uF[$82]='SM3L'set uF[$83]='SM3M'set uF[$84]='SM3N'set uF[$85]='SM3O'set uF[$86]='SM3P'set uF[$87]='SM3Q'set uF[$88]='SM3R'set uF[$89]='SM3S'set uF[$8A]='SM3T'set uF[$8B]='SM3U'set uF[$8C]='SM3V'set uF[$8D]='SM3W'set uF[$8E]='SM3X'set uF[$8F]='SM3Y'set uF[$90]='SM3Z'set uF[$91]='SM40'set uF[$92]='SM41'set uF[$93]='SM42'set uF[$94]='SM43'set uF[$95]='SM44'set uF[$96]='SM45'set uF[$97]='SM46'set uF[$98]='SM47'set uF[$99]='SM48'set uF[$9A]='SM49'set uF[$9B]='SM4A'set uF[$9C]='SM4B'set uF[$9D]='SM4C'set uF[$9E]='SM4D'set uF[$9F]='SM4E'set uF[$A0]='SM4F'set uF[$A1]='SM4G'set uF[$A2]='SM4H'set uF[$A3]='SM4I'set uF[$A4]='SM4J'set uF[$A5]='SM4K'set uF[$A6]='SM4L'set uF[$A7]='SM4M'set uF[$A8]='SM4N'set uF[$A9]='SM4O'set uF[$AA]='SM4P'set uF[$AB]='SM4Q'set uF[$AC]='SM4R'set uF[$AD]='SM4S'set uF[$AE]='SM4T'set uF[$AF]='SM4U'set uF[$B0]='SM4V'set uF[$B1]='SM4W'set uF[$B2]='SM4X'set uF[$B3]='SM4Y'set uF[$B4]='SM4Z'set uF[$B5]='SM50'set uF[$B6]='SM51'set uF[$B7]='SM52'set uF[$B8]='SM53'set uF[$B9]='SM54'set uF[$BA]='SM55'set uF[$BB]='SM56'set uF[$BC]='SM57'set uF[$BD]='SM58'set uF[$BE]='SM59'set uF[$BF]='SM5A'set uF[$C0]='SM5B'set uF[$C1]='SM5C'set uF[$C2]='SM5D'set uF[$C3]='SM5E'set uF[$C4]='SM5F'set uF[$C5]='SM5G'set uF[$C6]='SM5H'set uF[$C7]='SM5I'set uF[$C8]='SM5J'set uF[$C9]='SM5K'set uF[$CA]='SM5L'set uF[$CB]='SM5M'set uF[$CC]='SM5N'set uF[$CD]='SM5O'set uF[$CE]='SM5P'set uF[$CF]='SM5Q'set uF[$D0]='SM5R'set uF[$D1]='SM5S'set uF[$D2]='SM5T'set uF[$D3]='SM5U'set uF[$D4]='SM5V'set uF[$D5]='SM5W'set uF[$D6]='SM5X'set uF[$D7]='SM5Y'set uF[$D8]='SM5Z'set uF[$D9]='SM60'set uF[$DA]='SM61'set uF[$DB]='SM62'set uF[$DC]='SM63'set uF[$DD]='SM64'set uF[$DE]='SM65'set uF[$DF]='SM66'set uF[$E0]='SM67'set uF[$E1]='SM68'set uF[$E2]='SM69'set uF[$E3]='SM6A'set uF[$E4]='SM6B'set uF[$E5]='SM6C'set uF[$E6]='SM6D'set uF[$E7]='SM6E'set uF[$E8]='SM6F'set uF[$E9]='SM6G'set uF[$EA]='SM6H'set uF[$EB]='SM6I'set uF[$EC]='SM6J'set uF[$ED]='SM6K'set uF[$EE]='SM6L'set uF[$EF]='SM6M'set uF[$F0]='SM6N'set uF[$F1]='SM6O'set uF[$F2]='SM6P'set uF[$F3]='SM6Q'set uF[$F4]='SM6R'set uF[$F5]='SM6S'set uF[$F6]='SM6T'set uF[$F7]='SM6U'set uF[$F8]='SM6V'set uF[$F9]='SM6W'set uF[$FA]='SM6X'set uF[$FB]='SM6Y'set uF[$FC]='SM6Z'set uF[$FD]='SM70'set uF[$FE]='SM71'set uF[$FF]='SM72'set uF[256]='SM73'set SF[1]='TM00'
set SF[2]='TM01'
set SF[3]='TM02'
set SF[4]='TM03'
set SF[5]='TM04'
set SF[6]='TM05'
set SF[7]='TM06'
set SF[8]='TM07'
set SF[9]='TM08'
set SF[$A]='TM09'set SF[$B]='TM0A'set SF[$C]='TM0B'set SF[$D]='TM0C'set SF[$E]='TM0D'set SF[$F]='TM0E'set SF[16]='TM0F'set SF[17]='TM0G'set SF[18]='TM0H'set SF[19]='TM0I'set SF[20]='TM0J'set SF[21]='TM0K'set SF[22]='TM0L'set SF[23]='TM0M'set SF[24]='TM0N'set SF[25]='TM0O'set SF[26]='TM0P'set SF[27]='TM0Q'set SF[28]='TM0R'set SF[29]='TM0S'set SF[30]='TM0T'set SF[31]='TM0U'set SF[32]='TM0V'set SF[33]='TM0W'set SF[34]='TM0X'set SF[35]='TM0Y'set SF[36]='TM0Z'set SF[37]='TM10'set SF[38]='TM11'set SF[39]='TM12'set SF[40]='TM13'set SF[41]='TM14'set SF[42]='TM15'set SF[43]='TM16'set SF[44]='TM17'set SF[45]='TM18'set SF[46]='TM19'set SF[47]='TM1A'set SF[48]='TM1B'set SF[49]='TM1C'set SF[50]='TM1D'set SF[51]='TM1E'set SF[52]='TM1F'set SF[53]='TM1G'set SF[54]='TM1H'set SF[55]='TM1I'set SF[56]='TM1J'set SF[57]='TM1K'set SF[58]='TM1L'set SF[59]='TM1M'set SF[60]='TM1N'set SF[61]='TM1O'set SF[62]='TM1P'set SF[63]='TM1Q'set SF[64]='TM1R'set SF[65]='TM1S'set SF[66]='TM1T'set SF[67]='TM1U'set SF[68]='TM1V'set SF[69]='TM1W'set SF[70]='TM1X'set SF[71]='TM1Y'set SF[72]='TM1Z'set SF[73]='TM20'set SF[74]='TM21'set SF[75]='TM22'set SF[76]='TM23'set SF[77]='TM24'set SF[78]='TM25'set SF[79]='TM26'set SF[80]='TM27'set SF[81]='TM28'set SF[82]='TM29'set SF[83]='TM2A'set SF[84]='TM2B'set SF[85]='TM2C'set SF[86]='TM2D'set SF[87]='TM2E'set SF[88]='TM2F'set SF[89]='TM2G'set SF[90]='TM2H'set SF[91]='TM2I'set SF[92]='TM2J'set SF[93]='TM2K'set SF[94]='TM2L'set SF[95]='TM2M'set SF[96]='TM2N'set SF[97]='TM2O'set SF[98]='TM2P'set SF[99]='TM2Q'set SF['d']='TM2R'set SF['e']='TM2S'set SF['f']='TM2T'set SF['g']='TM2U'set SF['h']='TM2V'set SF['i']='TM2W'set SF['j']='TM2X'set SF['k']='TM2Y'set SF['l']='TM2Z'set SF['m']='TM30'set SF['n']='TM31'set SF['o']='TM32'set SF['p']='TM33'set SF['q']='TM34'set SF['r']='TM35'set SF['s']='TM36'set SF['t']='TM37'set SF['u']='TM38'set SF['v']='TM39'set SF['w']='TM3A'set SF['x']='TM3B'set SF['y']='TM3C'set SF['z']='TM3D'set SF['{']='TM3E'set SF['|']='TM3F'set SF['}']='TM3G'set SF[$7E]='TM3H'set SF[$7F]='TM3I'set SF[$80]='TM3J'set SF[$81]='TM3K'set SF[$82]='TM3L'set SF[$83]='TM3M'set SF[$84]='TM3N'set SF[$85]='TM3O'set SF[$86]='TM3P'set SF[$87]='TM3Q'set SF[$88]='TM3R'set SF[$89]='TM3S'set SF[$8A]='TM3T'set SF[$8B]='TM3U'set SF[$8C]='TM3V'set SF[$8D]='TM3W'set SF[$8E]='TM3X'set SF[$8F]='TM3Y'set SF[$90]='TM3Z'set SF[$91]='TM40'set SF[$92]='TM41'set SF[$93]='TM42'set SF[$94]='TM43'set SF[$95]='TM44'set SF[$96]='TM45'set SF[$97]='TM46'set SF[$98]='TM47'set SF[$99]='TM48'set SF[$9A]='TM49'set SF[$9B]='TM4A'set SF[$9C]='TM4B'set SF[$9D]='TM4C'set SF[$9E]='TM4D'set SF[$9F]='TM4E'set SF[$A0]='TM4F'set SF[$A1]='TM4G'set SF[$A2]='TM4H'set SF[$A3]='TM4I'set SF[$A4]='TM4J'set SF[$A5]='TM4K'set SF[$A6]='TM4L'set SF[$A7]='TM4M'set SF[$A8]='TM4N'set SF[$A9]='TM4O'set SF[$AA]='TM4P'set SF[$AB]='TM4Q'set SF[$AC]='TM4R'set SF[$AD]='TM4S'set SF[$AE]='TM4T'set SF[$AF]='TM4U'set SF[$B0]='TM4V'set SF[$B1]='TM4W'set SF[$B2]='TM4X'set SF[$B3]='TM4Y'set SF[$B4]='TM4Z'set SF[$B5]='TM50'set SF[$B6]='TM51'set SF[$B7]='TM52'set SF[$B8]='TM53'set SF[$B9]='TM54'set SF[$BA]='TM55'set SF[$BB]='TM56'set SF[$BC]='TM57'set SF[$BD]='TM58'set SF[$BE]='TM59'set SF[$BF]='TM5A'set SF[$C0]='TM5B'set SF[$C1]='TM5C'set SF[$C2]='TM5D'set SF[$C3]='TM5E'set SF[$C4]='TM5F'set SF[$C5]='TM5G'set SF[$C6]='TM5H'set SF[$C7]='TM5I'set SF[$C8]='TM5J'set SF[$C9]='TM5K'set SF[$CA]='TM5L'set SF[$CB]='TM5M'set SF[$CC]='TM5N'set SF[$CD]='TM5O'set SF[$CE]='TM5P'set SF[$CF]='TM5Q'set SF[$D0]='TM5R'set SF[$D1]='TM5S'set SF[$D2]='TM5T'set SF[$D3]='TM5U'set SF[$D4]='TM5V'set SF[$D5]='TM5W'set SF[$D6]='TM5X'set SF[$D7]='TM5Y'set SF[$D8]='TM5Z'set SF[$D9]='TM60'set SF[$DA]='TM61'set SF[$DB]='TM62'set SF[$DC]='TM63'set SF[$DD]='TM64'set SF[$DE]='TM65'set SF[$DF]='TM66'set SF[$E0]='TM67'set SF[$E1]='TM68'set SF[$E2]='TM69'set SF[$E3]='TM6A'set SF[$E4]='TM6B'set SF[$E5]='TM6C'set SF[$E6]='TM6D'set SF[$E7]='TM6E'set SF[$E8]='TM6F'set SF[$E9]='TM6G'set SF[$EA]='TM6H'set SF[$EB]='TM6I'set SF[$EC]='TM6J'set SF[$ED]='TM6K'set SF[$EE]='TM6L'set SF[$EF]='TM6M'set SF[$F0]='TM6N'set SF[$F1]='TM6O'set SF[$F2]='TM6P'set SF[$F3]='TM6Q'set SF[$F4]='TM6R'set SF[$F5]='TM6S'set SF[$F6]='TM6T'set SF[$F7]='TM6U'set SF[$F8]='TM6V'set SF[$F9]='TM6W'set SF[$FA]='TM6X'set SF[$FB]='TM6Y'set SF[$FC]='TM6Z'set SF[$FD]='TM70'set SF[$FE]='TM71'set SF[$FF]='TM72'set SF[256]='TM73'return trueendfunctionfunction i4o takes nothing returns booleanset VDv[1]='SM00'call L1x('SM00',false)set VDv[2]='SM01'call L1x('SM01',false)set VDv[3]='SM02'call L1x('SM02',false)set VDv[4]='SM03'call L1x('SM03',false)set VDv[5]='SM04'call L1x('SM04',false)set VDv[6]='SM05'call L1x('SM05',false)set VDv[7]='SM06'call L1x('SM06',false)set VDv[8]='SM07'call L1x('SM07',false)set VDv[9]='SM08'call L1x('SM08',false)set VDv[$A]='SM09'call L1x('SM09',false)set VDv[$B]='SM0A'call L1x('SM0A',false)set VDv[$C]='SM0B'call L1x('SM0B',false)set VDv[$D]='SM0C'call L1x('SM0C',false)set VDv[$E]='SM0D'call L1x('SM0D',false)set VDv[$F]='SM0E'call L1x('SM0E',false)set VDv[16]='SM0F'call L1x('SM0F',false)set VDv[17]='SM0G'call L1x('SM0G',false)set VDv[18]='SM0H'call L1x('SM0H',false)set VDv[19]='SM0I'call L1x('SM0I',false)set VDv[20]='SM0J'call L1x('SM0J',false)set VDv[21]='SM0K'call L1x('SM0K',false)set VDv[22]='SM0L'call L1x('SM0L',false)set VDv[23]='SM0M'call L1x('SM0M',false)set VDv[24]='SM0N'call L1x('SM0N',false)set VDv[25]='SM0O'call L1x('SM0O',false)set VDv[26]='SM0P'call L1x('SM0P',false)set VDv[27]='SM0Q'call L1x('SM0Q',false)set VDv[28]='SM0R'call L1x('SM0R',false)set VDv[29]='SM0S'call L1x('SM0S',false)set VDv[30]='SM0T'call L1x('SM0T',false)set VDv[31]='SM0U'call L1x('SM0U',false)set VDv[32]='SM0V'call L1x('SM0V',false)set VDv[33]='SM0W'call L1x('SM0W',false)set VDv[34]='SM0X'call L1x('SM0X',false)set VDv[35]='SM0Y'call L1x('SM0Y',false)set VDv[36]='SM0Z'call L1x('SM0Z',false)set VDv[37]='SM10'call L1x('SM10',false)set VDv[38]='SM11'call L1x('SM11',false)set VDv[39]='SM12'call L1x('SM12',false)set VDv[40]='SM13'call L1x('SM13',false)set VDv[41]='SM14'call L1x('SM14',false)set VDv[42]='SM15'call L1x('SM15',false)set VDv[43]='SM16'call L1x('SM16',false)set VDv[44]='SM17'call L1x('SM17',false)set VDv[45]='SM18'call L1x('SM18',false)set VDv[46]='SM19'call L1x('SM19',false)set VDv[47]='SM1A'call L1x('SM1A',false)set VDv[48]='SM1B'call L1x('SM1B',false)set VDv[49]='SM1C'call L1x('SM1C',false)set VDv[50]='SM1D'call L1x('SM1D',false)set VDv[51]='SM1E'call L1x('SM1E',false)set VDv[52]='SM1F'call L1x('SM1F',false)set VDv[53]='SM1G'call L1x('SM1G',false)set VDv[54]='SM1H'call L1x('SM1H',false)set VDv[55]='SM1I'call L1x('SM1I',false)set VDv[56]='SM1J'call L1x('SM1J',false)set VDv[57]='SM1K'call L1x('SM1K',false)set VDv[58]='SM1L'call L1x('SM1L',false)set VDv[59]='SM1M'call L1x('SM1M',false)set VDv[60]='SM1N'call L1x('SM1N',false)set VDv[61]='SM1O'call L1x('SM1O',false)set VDv[62]='SM1P'call L1x('SM1P',false)set VDv[63]='SM1Q'call L1x('SM1Q',false)set VDv[64]='SM1R'call L1x('SM1R',false)set VDv[65]='SM1S'call L1x('SM1S',false)set VDv[66]='SM1T'call L1x('SM1T',false)set VDv[67]='SM1U'call L1x('SM1U',false)set VDv[68]='SM1V'call L1x('SM1V',false)set VDv[69]='SM1W'call L1x('SM1W',false)set VDv[70]='SM1X'call L1x('SM1X',false)set VDv[71]='SM1Y'call L1x('SM1Y',false)set VDv[72]='SM1Z'call L1x('SM1Z',false)set VDv[73]='SM20'call L1x('SM20',false)set VDv[74]='SM21'call L1x('SM21',false)set VDv[75]='SM22'call L1x('SM22',false)set VDv[76]='SM23'call L1x('SM23',false)set VDv[77]='SM24'call L1x('SM24',false)set VDv[78]='SM25'call L1x('SM25',false)set VDv[79]='SM26'call L1x('SM26',false)set VDv[80]='SM27'call L1x('SM27',false)set VDv[81]='SM28'call L1x('SM28',false)set VDv[82]='SM29'call L1x('SM29',false)set VDv[83]='SM2A'call L1x('SM2A',false)set VDv[84]='SM2B'call L1x('SM2B',false)set VDv[85]='SM2C'call L1x('SM2C',false)set VDv[86]='SM2D'call L1x('SM2D',false)set VDv[87]='SM2E'call L1x('SM2E',false)set VDv[88]='SM2F'call L1x('SM2F',false)set VDv[89]='SM2G'call L1x('SM2G',false)set VDv[90]='SM2H'call L1x('SM2H',false)set VDv[91]='SM2I'call L1x('SM2I',false)set VDv[92]='SM2J'call L1x('SM2J',false)set VDv[93]='SM2K'call L1x('SM2K',false)set VDv[94]='SM2L'call L1x('SM2L',false)set VDv[95]='SM2M'call L1x('SM2M',false)set VDv[96]='SM2N'call L1x('SM2N',false)set VDv[97]='SM2O'call L1x('SM2O',false)set VDv[98]='SM2P'call L1x('SM2P',false)set VDv[99]='SM2Q'call L1x('SM2Q',false)set VDv['d']='SM2R'call L1x('SM2R',false)set VDv['e']='SM2S'call L1x('SM2S',false)set VDv['f']='SM2T'call L1x('SM2T',false)set VDv['g']='SM2U'call L1x('SM2U',false)set VDv['h']='SM2V'call L1x('SM2V',false)set VDv['i']='SM2W'call L1x('SM2W',false)set VDv['j']='SM2X'call L1x('SM2X',false)set VDv['k']='SM2Y'call L1x('SM2Y',false)set VDv['l']='SM2Z'call L1x('SM2Z',false)set VDv['m']='SM30'call L1x('SM30',false)set VDv['n']='SM31'call L1x('SM31',false)set VDv['o']='SM32'call L1x('SM32',false)set VDv['p']='SM33'call L1x('SM33',false)set VDv['q']='SM34'call L1x('SM34',false)set VDv['r']='SM35'call L1x('SM35',false)set VDv['s']='SM36'call L1x('SM36',false)set VDv['t']='SM37'call L1x('SM37',false)set VDv['u']='SM38'call L1x('SM38',false)set VDv['v']='SM39'call L1x('SM39',false)set VDv['w']='SM3A'call L1x('SM3A',false)set VDv['x']='SM3B'call L1x('SM3B',false)set VDv['y']='SM3C'call L1x('SM3C',false)set VDv['z']='SM3D'call L1x('SM3D',false)set VDv['{']='SM3E'call L1x('SM3E',false)set VDv['|']='SM3F'call L1x('SM3F',false)set VDv['}']='SM3G'call L1x('SM3G',false)set VDv[$7E]='SM3H'call L1x('SM3H',false)set VDv[$7F]='SM3I'call L1x('SM3I',false)set VDv[$80]='SM3J'call L1x('SM3J',false)set VDv[$81]='SM3K'call L1x('SM3K',false)set VDv[$82]='SM3L'call L1x('SM3L',false)set VDv[$83]='SM3M'call L1x('SM3M',false)set VDv[$84]='SM3N'call L1x('SM3N',false)set VDv[$85]='SM3O'call L1x('SM3O',false)set VDv[$86]='SM3P'call L1x('SM3P',false)set VDv[$87]='SM3Q'call L1x('SM3Q',false)set VDv[$88]='SM3R'call L1x('SM3R',false)set VDv[$89]='SM3S'call L1x('SM3S',false)set VDv[$8A]='SM3T'call L1x('SM3T',false)set VDv[$8B]='SM3U'call L1x('SM3U',false)set VDv[$8C]='SM3V'call L1x('SM3V',false)set VDv[$8D]='SM3W'call L1x('SM3W',false)set VDv[$8E]='SM3X'call L1x('SM3X',false)set VDv[$8F]='SM3Y'call L1x('SM3Y',false)set VDv[$90]='SM3Z'call L1x('SM3Z',false)set VDv[$91]='SM40'call L1x('SM40',false)set VDv[$92]='SM41'call L1x('SM41',false)set VDv[$93]='SM42'call L1x('SM42',false)set VDv[$94]='SM43'call L1x('SM43',false)set VDv[$95]='SM44'call L1x('SM44',false)set VDv[$96]='SM45'call L1x('SM45',false)set VDv[$97]='SM46'call L1x('SM46',false)set VDv[$98]='SM47'call L1x('SM47',false)set VDv[$99]='SM48'call L1x('SM48',false)set VDv[$9A]='SM49'call L1x('SM49',false)set VDv[$9B]='SM4A'call L1x('SM4A',false)set VDv[$9C]='SM4B'call L1x('SM4B',false)set VDv[$9D]='SM4C'call L1x('SM4C',false)set VDv[$9E]='SM4D'call L1x('SM4D',false)set VDv[$9F]='SM4E'call L1x('SM4E',false)set VDv[$A0]='SM4F'call L1x('SM4F',false)set VDv[$A1]='SM4G'call L1x('SM4G',false)set VDv[$A2]='SM4H'call L1x('SM4H',false)set VDv[$A3]='SM4I'call L1x('SM4I',false)set VDv[$A4]='SM4J'call L1x('SM4J',false)set VDv[$A5]='SM4K'call L1x('SM4K',false)set VDv[$A6]='SM4L'call L1x('SM4L',false)set VDv[$A7]='SM4M'call L1x('SM4M',false)set VDv[$A8]='SM4N'call L1x('SM4N',false)set VDv[$A9]='SM4O'call L1x('SM4O',false)set VDv[$AA]='SM4P'call L1x('SM4P',false)set VDv[$AB]='SM4Q'call L1x('SM4Q',false)set VDv[$AC]='SM4R'call L1x('SM4R',false)set VDv[$AD]='SM4S'call L1x('SM4S',false)set VDv[$AE]='SM4T'call L1x('SM4T',false)set VDv[$AF]='SM4U'call L1x('SM4U',false)set VDv[$B0]='SM4V'call L1x('SM4V',false)set VDv[$B1]='SM4W'call L1x('SM4W',false)set VDv[$B2]='SM4X'call L1x('SM4X',false)set VDv[$B3]='SM4Y'call L1x('SM4Y',false)set VDv[$B4]='SM4Z'call L1x('SM4Z',false)set VDv[$B5]='SM50'call L1x('SM50',false)set VDv[$B6]='SM51'call L1x('SM51',false)set VDv[$B7]='SM52'call L1x('SM52',false)set VDv[$B8]='SM53'call L1x('SM53',false)set VDv[$B9]='SM54'call L1x('SM54',false)set VDv[$BA]='SM55'call L1x('SM55',false)set VDv[$BB]='SM56'call L1x('SM56',false)set VDv[$BC]='SM57'call L1x('SM57',false)set VDv[$BD]='SM58'call L1x('SM58',false)set VDv[$BE]='SM59'call L1x('SM59',false)set VDv[$BF]='SM5A'call L1x('SM5A',false)set VDv[$C0]='SM5B'call L1x('SM5B',false)set VDv[$C1]='SM5C'call L1x('SM5C',false)set VDv[$C2]='SM5D'call L1x('SM5D',false)set VDv[$C3]='SM5E'call L1x('SM5E',false)set VDv[$C4]='SM5F'call L1x('SM5F',false)set VDv[$C5]='SM5G'call L1x('SM5G',false)set VDv[$C6]='SM5H'call L1x('SM5H',false)set VDv[$C7]='SM5I'call L1x('SM5I',false)set VDv[$C8]='SM5J'call L1x('SM5J',false)set VDv[$C9]='SM5K'call L1x('SM5K',false)set VDv[$CA]='SM5L'call L1x('SM5L',false)set VDv[$CB]='SM5M'call L1x('SM5M',false)set VDv[$CC]='SM5N'call L1x('SM5N',false)set VDv[$CD]='SM5O'call L1x('SM5O',false)set VDv[$CE]='SM5P'call L1x('SM5P',false)set VDv[$CF]='SM5Q'call L1x('SM5Q',false)set VDv[$D0]='SM5R'call L1x('SM5R',false)set VDv[$D1]='SM5S'call L1x('SM5S',false)set VDv[$D2]='SM5T'call L1x('SM5T',false)set VDv[$D3]='SM5U'call L1x('SM5U',false)set VDv[$D4]='SM5V'call L1x('SM5V',false)set VDv[$D5]='SM5W'call L1x('SM5W',false)set VDv[$D6]='SM5X'call L1x('SM5X',false)set VDv[$D7]='SM5Y'call L1x('SM5Y',false)set VDv[$D8]='SM5Z'call L1x('SM5Z',false)set VDv[$D9]='SM60'call L1x('SM60',false)set VDv[$DA]='SM61'call L1x('SM61',false)set VDv[$DB]='SM62'call L1x('SM62',false)set VDv[$DC]='SM63'call L1x('SM63',false)set VDv[$DD]='SM64'call L1x('SM64',false)set VDv[$DE]='SM65'call L1x('SM65',false)set VDv[$DF]='SM66'call L1x('SM66',false)set VDv[$E0]='SM67'call L1x('SM67',false)set VDv[$E1]='SM68'call L1x('SM68',false)set VDv[$E2]='SM69'call L1x('SM69',false)set VDv[$E3]='SM6A'call L1x('SM6A',false)set VDv[$E4]='SM6B'call L1x('SM6B',false)set VDv[$E5]='SM6C'call L1x('SM6C',false)set VDv[$E6]='SM6D'call L1x('SM6D',false)set VDv[$E7]='SM6E'call L1x('SM6E',false)set VDv[$E8]='SM6F'call L1x('SM6F',false)set VDv[$E9]='SM6G'call L1x('SM6G',false)set VDv[$EA]='SM6H'call L1x('SM6H',false)set VDv[$EB]='SM6I'call L1x('SM6I',false)set VDv[$EC]='SM6J'call L1x('SM6J',false)set VDv[$ED]='SM6K'call L1x('SM6K',false)set VDv[$EE]='SM6L'call L1x('SM6L',false)set VDv[$EF]='SM6M'call L1x('SM6M',false)set VDv[$F0]='SM6N'call L1x('SM6N',false)set VDv[$F1]='SM6O'call L1x('SM6O',false)set VDv[$F2]='SM6P'call L1x('SM6P',false)set VDv[$F3]='SM6Q'call L1x('SM6Q',false)set VDv[$F4]='SM6R'call L1x('SM6R',false)set VDv[$F5]='SM6S'call L1x('SM6S',false)set VDv[$F6]='SM6T'call L1x('SM6T',false)set VDv[$F7]='SM6U'call L1x('SM6U',false)set VDv[$F8]='SM6V'call L1x('SM6V',false)set VDv[$F9]='SM6W'call L1x('SM6W',false)set VDv[$FA]='SM6X'call L1x('SM6X',false)set VDv[$FB]='SM6Y'call L1x('SM6Y',false)set VDv[$FC]='SM6Z'call L1x('SM6Z',false)set VDv[$FD]='SM70'call L1x('SM70',false)set VDv[$FE]='SM71'call L1x('SM71',false)set VDv[$FF]='SM72'call L1x('SM72',false)set VDv[256]='SM73'call L1x('SM73',false)set Vfv[1]='TM00'call L1x('TM00',false)set Vfv[2]='TM01'call L1x('TM01',false)set Vfv[3]='TM02'call L1x('TM02',false)set Vfv[4]='TM03'call L1x('TM03',false)set Vfv[5]='TM04'call L1x('TM04',false)set Vfv[6]='TM05'call L1x('TM05',false)set Vfv[7]='TM06'call L1x('TM06',false)set Vfv[8]='TM07'call L1x('TM07',false)set Vfv[9]='TM08'call L1x('TM08',false)set Vfv[$A]='TM09'call L1x('TM09',false)set Vfv[$B]='TM0A'call L1x('TM0A',false)set Vfv[$C]='TM0B'call L1x('TM0B',false)set Vfv[$D]='TM0C'call L1x('TM0C',false)set Vfv[$E]='TM0D'call L1x('TM0D',false)set Vfv[$F]='TM0E'call L1x('TM0E',false)set Vfv[16]='TM0F'call L1x('TM0F',false)set Vfv[17]='TM0G'call L1x('TM0G',false)set Vfv[18]='TM0H'call L1x('TM0H',false)set Vfv[19]='TM0I'call L1x('TM0I',false)set Vfv[20]='TM0J'call L1x('TM0J',false)set Vfv[21]='TM0K'call L1x('TM0K',false)set Vfv[22]='TM0L'call L1x('TM0L',false)set Vfv[23]='TM0M'call L1x('TM0M',false)set Vfv[24]='TM0N'call L1x('TM0N',false)set Vfv[25]='TM0O'call L1x('TM0O',false)set Vfv[26]='TM0P'call L1x('TM0P',false)set Vfv[27]='TM0Q'call L1x('TM0Q',false)set Vfv[28]='TM0R'call L1x('TM0R',false)set Vfv[29]='TM0S'call L1x('TM0S',false)set Vfv[30]='TM0T'call L1x('TM0T',false)set Vfv[31]='TM0U'call L1x('TM0U',false)set Vfv[32]='TM0V'call L1x('TM0V',false)set Vfv[33]='TM0W'call L1x('TM0W',false)set Vfv[34]='TM0X'call L1x('TM0X',false)set Vfv[35]='TM0Y'call L1x('TM0Y',false)set Vfv[36]='TM0Z'call L1x('TM0Z',false)set Vfv[37]='TM10'call L1x('TM10',false)set Vfv[38]='TM11'call L1x('TM11',false)set Vfv[39]='TM12'call L1x('TM12',false)set Vfv[40]='TM13'call L1x('TM13',false)set Vfv[41]='TM14'call L1x('TM14',false)set Vfv[42]='TM15'call L1x('TM15',false)set Vfv[43]='TM16'call L1x('TM16',false)set Vfv[44]='TM17'call L1x('TM17',false)set Vfv[45]='TM18'call L1x('TM18',false)set Vfv[46]='TM19'call L1x('TM19',false)set Vfv[47]='TM1A'call L1x('TM1A',false)set Vfv[48]='TM1B'call L1x('TM1B',false)set Vfv[49]='TM1C'call L1x('TM1C',false)set Vfv[50]='TM1D'call L1x('TM1D',false)set Vfv[51]='TM1E'call L1x('TM1E',false)set Vfv[52]='TM1F'call L1x('TM1F',false)set Vfv[53]='TM1G'call L1x('TM1G',false)set Vfv[54]='TM1H'call L1x('TM1H',false)set Vfv[55]='TM1I'call L1x('TM1I',false)set Vfv[56]='TM1J'call L1x('TM1J',false)set Vfv[57]='TM1K'call L1x('TM1K',false)set Vfv[58]='TM1L'call L1x('TM1L',false)set Vfv[59]='TM1M'call L1x('TM1M',false)set Vfv[60]='TM1N'call L1x('TM1N',false)set Vfv[61]='TM1O'call L1x('TM1O',false)set Vfv[62]='TM1P'call L1x('TM1P',false)set Vfv[63]='TM1Q'call L1x('TM1Q',false)set Vfv[64]='TM1R'call L1x('TM1R',false)set Vfv[65]='TM1S'call L1x('TM1S',false)set Vfv[66]='TM1T'call L1x('TM1T',false)set Vfv[67]='TM1U'call L1x('TM1U',false)set Vfv[68]='TM1V'call L1x('TM1V',false)set Vfv[69]='TM1W'call L1x('TM1W',false)set Vfv[70]='TM1X'call L1x('TM1X',false)set Vfv[71]='TM1Y'call L1x('TM1Y',false)set Vfv[72]='TM1Z'call L1x('TM1Z',false)set Vfv[73]='TM20'call L1x('TM20',false)set Vfv[74]='TM21'call L1x('TM21',false)set Vfv[75]='TM22'call L1x('TM22',false)set Vfv[76]='TM23'call L1x('TM23',false)set Vfv[77]='TM24'call L1x('TM24',false)set Vfv[78]='TM25'call L1x('TM25',false)set Vfv[79]='TM26'call L1x('TM26',false)set Vfv[80]='TM27'call L1x('TM27',false)set Vfv[81]='TM28'call L1x('TM28',false)set Vfv[82]='TM29'call L1x('TM29',false)set Vfv[83]='TM2A'call L1x('TM2A',false)set Vfv[84]='TM2B'call L1x('TM2B',false)set Vfv[85]='TM2C'call L1x('TM2C',false)set Vfv[86]='TM2D'call L1x('TM2D',false)set Vfv[87]='TM2E'call L1x('TM2E',false)set Vfv[88]='TM2F'call L1x('TM2F',false)set Vfv[89]='TM2G'call L1x('TM2G',false)set Vfv[90]='TM2H'call L1x('TM2H',false)set Vfv[91]='TM2I'call L1x('TM2I',false)set Vfv[92]='TM2J'call L1x('TM2J',false)set Vfv[93]='TM2K'call L1x('TM2K',false)set Vfv[94]='TM2L'call L1x('TM2L',false)set Vfv[95]='TM2M'call L1x('TM2M',false)set Vfv[96]='TM2N'call L1x('TM2N',false)set Vfv[97]='TM2O'call L1x('TM2O',false)set Vfv[98]='TM2P'call L1x('TM2P',false)set Vfv[99]='TM2Q'call L1x('TM2Q',false)set Vfv['d']='TM2R'call L1x('TM2R',false)set Vfv['e']='TM2S'call L1x('TM2S',false)set Vfv['f']='TM2T'call L1x('TM2T',false)set Vfv['g']='TM2U'call L1x('TM2U',false)set Vfv['h']='TM2V'call L1x('TM2V',false)set Vfv['i']='TM2W'call L1x('TM2W',false)set Vfv['j']='TM2X'call L1x('TM2X',false)set Vfv['k']='TM2Y'call L1x('TM2Y',false)set Vfv['l']='TM2Z'call L1x('TM2Z',false)set Vfv['m']='TM30'call L1x('TM30',false)set Vfv['n']='TM31'call L1x('TM31',false)set Vfv['o']='TM32'call L1x('TM32',false)set Vfv['p']='TM33'call L1x('TM33',false)set Vfv['q']='TM34'call L1x('TM34',false)set Vfv['r']='TM35'call L1x('TM35',false)set Vfv['s']='TM36'call L1x('TM36',false)set Vfv['t']='TM37'call L1x('TM37',false)set Vfv['u']='TM38'call L1x('TM38',false)set Vfv['v']='TM39'call L1x('TM39',false)set Vfv['w']='TM3A'call L1x('TM3A',false)set Vfv['x']='TM3B'call L1x('TM3B',false)set Vfv['y']='TM3C'call L1x('TM3C',false)set Vfv['z']='TM3D'call L1x('TM3D',false)set Vfv['{']='TM3E'call L1x('TM3E',false)set Vfv['|']='TM3F'call L1x('TM3F',false)set Vfv['}']='TM3G'call L1x('TM3G',false)set Vfv[$7E]='TM3H'call L1x('TM3H',false)set Vfv[$7F]='TM3I'call L1x('TM3I',false)set Vfv[$80]='TM3J'call L1x('TM3J',false)set Vfv[$81]='TM3K'call L1x('TM3K',false)set Vfv[$82]='TM3L'call L1x('TM3L',false)set Vfv[$83]='TM3M'call L1x('TM3M',false)set Vfv[$84]='TM3N'call L1x('TM3N',false)set Vfv[$85]='TM3O'call L1x('TM3O',false)set Vfv[$86]='TM3P'call L1x('TM3P',false)set Vfv[$87]='TM3Q'call L1x('TM3Q',false)set Vfv[$88]='TM3R'call L1x('TM3R',false)set Vfv[$89]='TM3S'call L1x('TM3S',false)set Vfv[$8A]='TM3T'call L1x('TM3T',false)set Vfv[$8B]='TM3U'call L1x('TM3U',false)set Vfv[$8C]='TM3V'call L1x('TM3V',false)set Vfv[$8D]='TM3W'call L1x('TM3W',false)set Vfv[$8E]='TM3X'call L1x('TM3X',false)set Vfv[$8F]='TM3Y'call L1x('TM3Y',false)set Vfv[$90]='TM3Z'call L1x('TM3Z',false)set Vfv[$91]='TM40'call L1x('TM40',false)set Vfv[$92]='TM41'call L1x('TM41',false)set Vfv[$93]='TM42'call L1x('TM42',false)set Vfv[$94]='TM43'call L1x('TM43',false)set Vfv[$95]='TM44'call L1x('TM44',false)set Vfv[$96]='TM45'call L1x('TM45',false)set Vfv[$97]='TM46'call L1x('TM46',false)set Vfv[$98]='TM47'call L1x('TM47',false)set Vfv[$99]='TM48'call L1x('TM48',false)set Vfv[$9A]='TM49'call L1x('TM49',false)set Vfv[$9B]='TM4A'call L1x('TM4A',false)set Vfv[$9C]='TM4B'call L1x('TM4B',false)set Vfv[$9D]='TM4C'call L1x('TM4C',false)set Vfv[$9E]='TM4D'call L1x('TM4D',false)set Vfv[$9F]='TM4E'call L1x('TM4E',false)set Vfv[$A0]='TM4F'call L1x('TM4F',false)set Vfv[$A1]='TM4G'call L1x('TM4G',false)set Vfv[$A2]='TM4H'call L1x('TM4H',false)set Vfv[$A3]='TM4I'call L1x('TM4I',false)set Vfv[$A4]='TM4J'call L1x('TM4J',false)set Vfv[$A5]='TM4K'call L1x('TM4K',false)set Vfv[$A6]='TM4L'call L1x('TM4L',false)set Vfv[$A7]='TM4M'call L1x('TM4M',false)set Vfv[$A8]='TM4N'call L1x('TM4N',false)set Vfv[$A9]='TM4O'call L1x('TM4O',false)set Vfv[$AA]='TM4P'call L1x('TM4P',false)set Vfv[$AB]='TM4Q'call L1x('TM4Q',false)set Vfv[$AC]='TM4R'call L1x('TM4R',false)set Vfv[$AD]='TM4S'call L1x('TM4S',false)set Vfv[$AE]='TM4T'call L1x('TM4T',false)set Vfv[$AF]='TM4U'call L1x('TM4U',false)set Vfv[$B0]='TM4V'call L1x('TM4V',false)set Vfv[$B1]='TM4W'call L1x('TM4W',false)set Vfv[$B2]='TM4X'call L1x('TM4X',false)set Vfv[$B3]='TM4Y'call L1x('TM4Y',false)set Vfv[$B4]='TM4Z'call L1x('TM4Z',false)set Vfv[$B5]='TM50'call L1x('TM50',false)set Vfv[$B6]='TM51'call L1x('TM51',false)set Vfv[$B7]='TM52'call L1x('TM52',false)set Vfv[$B8]='TM53'call L1x('TM53',false)set Vfv[$B9]='TM54'call L1x('TM54',false)set Vfv[$BA]='TM55'call L1x('TM55',false)set Vfv[$BB]='TM56'call L1x('TM56',false)set Vfv[$BC]='TM57'call L1x('TM57',false)set Vfv[$BD]='TM58'call L1x('TM58',false)set Vfv[$BE]='TM59'call L1x('TM59',false)set Vfv[$BF]='TM5A'call L1x('TM5A',false)set Vfv[$C0]='TM5B'call L1x('TM5B',false)set Vfv[$C1]='TM5C'call L1x('TM5C',false)set Vfv[$C2]='TM5D'call L1x('TM5D',false)set Vfv[$C3]='TM5E'call L1x('TM5E',false)set Vfv[$C4]='TM5F'call L1x('TM5F',false)set Vfv[$C5]='TM5G'call L1x('TM5G',false)set Vfv[$C6]='TM5H'call L1x('TM5H',false)set Vfv[$C7]='TM5I'call L1x('TM5I',false)set Vfv[$C8]='TM5J'call L1x('TM5J',false)set Vfv[$C9]='TM5K'call L1x('TM5K',false)set Vfv[$CA]='TM5L'call L1x('TM5L',false)set Vfv[$CB]='TM5M'call L1x('TM5M',false)set Vfv[$CC]='TM5N'call L1x('TM5N',false)set Vfv[$CD]='TM5O'call L1x('TM5O',false)set Vfv[$CE]='TM5P'call L1x('TM5P',false)set Vfv[$CF]='TM5Q'call L1x('TM5Q',false)set Vfv[$D0]='TM5R'call L1x('TM5R',false)set Vfv[$D1]='TM5S'call L1x('TM5S',false)set Vfv[$D2]='TM5T'call L1x('TM5T',false)set Vfv[$D3]='TM5U'call L1x('TM5U',false)set Vfv[$D4]='TM5V'call L1x('TM5V',false)set Vfv[$D5]='TM5W'call L1x('TM5W',false)set Vfv[$D6]='TM5X'call L1x('TM5X',false)set Vfv[$D7]='TM5Y'call L1x('TM5Y',false)set Vfv[$D8]='TM5Z'call L1x('TM5Z',false)set Vfv[$D9]='TM60'call L1x('TM60',false)set Vfv[$DA]='TM61'call L1x('TM61',false)set Vfv[$DB]='TM62'call L1x('TM62',false)set Vfv[$DC]='TM63'call L1x('TM63',false)set Vfv[$DD]='TM64'call L1x('TM64',false)set Vfv[$DE]='TM65'call L1x('TM65',false)set Vfv[$DF]='TM66'call L1x('TM66',false)set Vfv[$E0]='TM67'call L1x('TM67',false)set Vfv[$E1]='TM68'call L1x('TM68',false)set Vfv[$E2]='TM69'call L1x('TM69',false)set Vfv[$E3]='TM6A'call L1x('TM6A',false)set Vfv[$E4]='TM6B'call L1x('TM6B',false)set Vfv[$E5]='TM6C'call L1x('TM6C',false)set Vfv[$E6]='TM6D'call L1x('TM6D',false)set Vfv[$E7]='TM6E'call L1x('TM6E',false)set Vfv[$E8]='TM6F'call L1x('TM6F',false)set Vfv[$E9]='TM6G'call L1x('TM6G',false)set Vfv[$EA]='TM6H'call L1x('TM6H',false)set Vfv[$EB]='TM6I'call L1x('TM6I',false)set Vfv[$EC]='TM6J'call L1x('TM6J',false)set Vfv[$ED]='TM6K'call L1x('TM6K',false)set Vfv[$EE]='TM6L'call L1x('TM6L',false)set Vfv[$EF]='TM6M'call L1x('TM6M',false)set Vfv[$F0]='TM6N'call L1x('TM6N',false)set Vfv[$F1]='TM6O'call L1x('TM6O',false)set Vfv[$F2]='TM6P'call L1x('TM6P',false)set Vfv[$F3]='TM6Q'call L1x('TM6Q',false)set Vfv[$F4]='TM6R'call L1x('TM6R',false)set Vfv[$F5]='TM6S'call L1x('TM6S',false)set Vfv[$F6]='TM6T'call L1x('TM6T',false)set Vfv[$F7]='TM6U'call L1x('TM6U',false)set Vfv[$F8]='TM6V'call L1x('TM6V',false)set Vfv[$F9]='TM6W'call L1x('TM6W',false)set Vfv[$FA]='TM6X'call L1x('TM6X',false)set Vfv[$FB]='TM6Y'call L1x('TM6Y',false)set Vfv[$FC]='TM6Z'call L1x('TM6Z',false)set Vfv[$FD]='TM70'call L1x('TM70',false)set Vfv[$FE]='TM71'call L1x('TM71',false)set Vfv[$FF]='TM72'call L1x('TM72',false)set Vfv[256]='TM73'call L1x('TM73',false)return trueendfunctionfunction i5o takes nothing returns booleancall VNx(va,(function i3o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\MaxMana\\obj_spells_wc3objLuainits.j"))call VNx(Pa,(function i4o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\MaxMana\\obj_spells_wc3objLuaspells.j"))return trueendfunctionfunction i6o takes nothing returns booleanset VFv=VXx(Vgv)
return trueendfunctionfunction i7o takes nothing returns booleanset VGv=VXx(Vhv)
return trueendfunctionfunction i8o takes nothing returns booleanset VHv=VXx(Vjv)
return trueendfunctionfunction i9o takes nothing returns booleanset VJv=VXx(Vkv)
return trueendfunctionfunction avo takes nothing returns booleanset GF=ltx(VKv+" (dummyBuff)")return trueendfunctionfunction aeo takes nothing returns booleancall VNx(ma,(function avo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\ManaRegeneration\\Disablement\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction axo takes nothing returns booleanset Vlv=VXx(VKv)
return trueendfunctionfunction aoo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set VLv[((rLx))]=(true)call BCx(rLx)return trueendfunctionfunction aro takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set VLv[((rLx))]=(false)
if((gF[(rLx)])>.0)thencall BBx(rLx)endifreturn trueendfunctionfunction aio takes nothing returns booleancall Lxx(GF,Xdx("FolderUnit_FolderManaRegeneration_StructDisablement_Buff_Init: call FolderUnit_FolderManaRegeneration_StructDisablement.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderManaRegeneration_StructDisablement.Event_BuffGain))",bd,MI,function aoo))call Lxx(GF,Xdx("FolderUnit_FolderManaRegeneration_StructDisablement_Buff_Init: call FolderUnit_FolderManaRegeneration_StructDisablement.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_FolderManaRegeneration_StructDisablement.Event_BuffLose))",jc,MI,function aro))return trueendfunctionfunction aao takes nothing returns booleancall u9x(function aio,"FolderUnit_FolderManaRegeneration_StructDisablement_Buff_Init")return trueendfunctionfunction ano takes nothing returns booleanset Vmv=VXx(VMv)
return trueendfunctionfunction aVo takes nothing returns booleanset Vpv=VXx(VPv)
return trueendfunctionfunction aEo takes nothing returns booleanset Vqv=VXx(VQv)
return trueendfunctionfunction aXo takes nothing returns booleanset Vsv=VXx(VSv)
return trueendfunctionfunction aOo takes nothing returns booleanset Vtv=VXx(VTv)
return trueendfunctionfunction aRo takes nothing returns booleanset Vuv=VXx(VUv)
return trueendfunctionfunction aIo takes nothing returns booleanset Vwv=VXx(VWv)
return trueendfunctionfunction aAo takes nothing returns booleancall L1x('AmSp',false)return trueendfunctionfunction aNo takes nothing returns booleancall L1x('AmSx',false)return trueendfunctionfunction abo takes nothing returns booleancall VNx(Pa,(function aAo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Movement\\Speed\\BonusA\\obj_dummySpell_wc3spell.j"))call VNx(Pa,(function aNo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Movement\\Speed\\BonusA\\obj_storageSpell_wc3spell.j"))return trueendfunctionfunction aBo takes nothing returns booleanset Vyv=VXx(VYv)
return trueendfunctionfunction aco takes nothing returns booleanset Vzv=VXx(VZv)
return trueendfunctionfunction aCo takes nothing returns booleanset V_v=VXx(V0v)
return trueendfunctionfunction ado takes nothing returns booleanset x5v=ltx(V1v+" (disableBuff)")return trueendfunctionfunction aDo takes nothing returns booleancall VNx(ma,(function ado),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Movement\\obj_disableBuff_wc3buff.j"))
return trueendfunctionfunction afo takes nothing returns booleanset V2v=VXx(V1v)
return trueendfunctionfunction aFo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set V3v[((rLx))]=(false)
call SetUnitPropWindow(C[rLx],.0)return trueendfunctionfunction ago takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set V3v[((rLx))]=(true)call SetUnitPropWindow(C[rLx],60.)return trueendfunctionfunction aGo takes nothing returns booleancall Lxx(x5v,Xdx("FolderUnit_StructMovement_Buff_Init: call FolderUnit_StructMovement.DISABLE_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructMovement.Event_BuffGain))",bd,MI,function aFo))call Lxx(x5v,Xdx("FolderUnit_StructMovement_Buff_Init: call FolderUnit_StructMovement.DISABLE_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructMovement.Event_BuffLose))",jc,MI,function ago))return trueendfunctionfunction aho takes nothing returns booleancall u9x(function aGo,"FolderUnit_StructMovement_Buff_Init")
return trueendfunctionfunction aHo takes nothing returns booleanset V4v=VXx(V5v)
return trueendfunctionfunction ajo takes nothing returns booleanset V6v=VXx(V7v)
return trueendfunctionfunction aJo takes nothing returns booleanset V8v=VXx(V9v)
return trueendfunctionfunction ako takes nothing returns booleanset Evv=VXx(Eev)
return trueendfunctionfunction aKo takes nothing returns booleanset Exv=VXx(Eov)
return trueendfunctionfunction alo takes nothing returns booleanset Erv=VXx(Eiv)
return trueendfunctionfunction aLo takes nothing returns booleanset Eav=VXx(Env)
return trueendfunctionfunction amo takes nothing returns booleanset EVv=VXx(EEv)
return trueendfunctionfunction aMo takes nothing returns booleanset EXv=ltx(EOv+" (noneBuff)")return trueendfunctionfunction apo takes nothing returns booleancall L1x('aBan',false)return trueendfunctionfunction aPo takes nothing returns booleanset ERv=ltx(EOv+" (normalBuff)")
return trueendfunctionfunction aqo takes nothing returns booleanset EIv=ltx(EOv+" (dummyBuff)")return trueendfunctionfunction aQo takes nothing returns booleancall VNx(ma,(function aMo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Banish\\obj_noneBuff_wc3buff.j"))call VNx(Pa,(function apo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Banish\\obj_banSpell_wc3spell.j"))
call VNx(ma,(function aPo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Banish\\obj_normalBuff_wc3buff.j"))call VNx(ma,(function aqo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Banish\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction aso takes nothing returns booleanset EAv=VXx(EOv)
return trueendfunctionfunction aSo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set ENv[((rLx))]=(true)call Avx(rLx,Ebv)call DTx(eJ,V3,rLx)return trueendfunctionfunction ato takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set ENv[((rLx))]=(false)
call RPx(rLx,Ebv)call UnitRemoveAbility(C[((((rLx))))],(('bBan')))return trueendfunctionfunction aTo takes nothing returns booleancall Lxx(EIv,Xdx("FolderUnit_StructBanish_Buff_Init: call FolderUnit_StructBanish.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructBanish.Event_BuffGain))",bd,bI,function aSo))call Lxx(EIv,Xdx("FolderUnit_StructBanish_Buff_Init: call FolderUnit_StructBanish.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructBanish.Event_BuffLose))",jc,bI,function ato))call W2x(EIv,ERv)return trueendfunctionfunction auo takes nothing returns booleancall u9x(function aTo,"FolderUnit_StructBanish_Buff_Init")return trueendfunctionfunction aUo takes nothing returns booleanset EBv=ltx(Ecv+" (dummyBuff)")return trueendfunctionfunction awo takes nothing returns booleanset ECv=Wwx('BCof',"Confused",'bCof')set anv[(ECv)]=("ReplaceableTextures\\CommandButtons\\BTNBerserkForTrolls.blp")call lWx(ECv,"Abilities\\Spells\\NightElf\\shadowstrike\\shadowstrike.mdl","overhead",ri)set WU=l_x()
call rto(WU,rzo(db,0,-$AF,-$AF,0))call l3x(((ECv)),ZB+(1),(WU))return trueendfunctionfunction aWo takes nothing returns booleancall VNx(ma,(function aUo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Madness\\obj_dummyBuff_wc3buff.j"))call VNx(ma,(function awo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Madness\\obj_normalBuff_wc3buff.j"))return trueendfunctionfunction ayo takes nothing returns booleanset Edv=VXx(Ecv)
return trueendfunctionfunction aYo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set Ze[((rLx))]=(true)call SetUnitOwner(C[rLx],vx[ex],false)call CCx(rLx)return trueendfunctionfunction azo takes integer oSx returns nothingcall acx(oSx,(ze[(oSx)]))endfunctionfunction aZo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set Ze[((rLx))]=(false)call azo(rLx)return trueendfunctionfunction a_o takes nothing returns booleancall Lxx(EBv,Xdx("FolderUnit_StructMadness_Buff_Init: call FolderUnit_StructMadness.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructMadness.Event_BuffGain))",bd,bI,function aYo))call Lxx(EBv,Xdx("FolderUnit_StructMadness_Buff_Init: call FolderUnit_StructMadness.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructMadness.Event_BuffLose))",jc,bI,function aZo))call W2x(EBv,ECv)return trueendfunctionfunction a0o takes nothing returns booleancall u9x(function a_o,"FolderUnit_StructMadness_Buff_Init")return trueendfunctionfunction a1o takes nothing returns booleanset EDv=Wwx('BEcl',"Eclipse",'bEcl')
set anv[(EDv)]=("ReplaceableTextures\\CommandButtons\\BTNSoulGem.blp")call lWx(EDv,"Unit_page\\Unit_struct\\Eclipse\\TargetEffect.mdx","origin",Bi)set WU=l_x()
call rto(WU,rzo(db,-50,-$96,-50,0))call l3x(((EDv)),ZB+(1),(WU))return trueendfunctionfunction a2o takes nothing returns booleanset Efv=ltx(EFv+" (dummyBuff)")set WU=l_x()
call l2x(WU,Egv,-.3)
call l2x(WU,EGv,-.5)
call l2x(WU,iw,-.3)call l2x(WU,Ehv,-.5)
call l3x(((Efv)),ZB+(1),(WU))return trueendfunctionfunction a3o takes nothing returns booleancall VNx(ma,(function a1o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Eclipse\\obj_normalBuff_wc3buff.j"))call VNx(ma,(function a2o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Eclipse\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction a4o takes nothing returns booleanset EHv=VXx(EFv)
return trueendfunctionfunction a5o takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set Ejv[((rLx))]=(true)return trueendfunctionfunction a6o takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set Ejv[((rLx))]=(false)
return trueendfunctionfunction a7o takes nothing returns booleancall Lxx(Efv,Xdx("FolderUnit_StructEclipse_Buff_Init: call FolderUnit_StructEclipse.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructEclipse.Event_BuffGain))",bd,MI,function a5o))call Lxx(Efv,Xdx("FolderUnit_StructEclipse_Buff_Init: call FolderUnit_StructEclipse.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructEclipse.Event_BuffLose))",jc,MI,function a6o))return trueendfunctionfunction a8o takes nothing returns booleancall u9x(function a7o,"FolderUnit_StructEclipse_Buff_Init")return trueendfunctionfunction a9o takes nothing returns booleanset EJv=ltx(Ekv+" (normalBuff)")
return trueendfunctionfunction nvo takes nothing returns booleancall L1x('aWhI',false)return trueendfunctionfunction neo takes nothing returns booleanset EKv=ltx(Ekv+" (noneBuff)")return trueendfunctionfunction nxo takes nothing returns booleancall L1x('aWhC',false)return trueendfunctionfunction noo takes nothing returns booleanset Elv=ltx(Ekv+" (dummyBuff)")return trueendfunctionfunction nro takes nothing returns booleancall VNx(ma,(function a9o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Whirl\\obj_normalBuff_wc3buff.j"))
call VNx(Pa,(function nvo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Whirl\\obj_impaleSpell_wc3spell.j"))call VNx(ma,(function neo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Whirl\\obj_noneBuff_wc3buff.j"))call VNx(Pa,(function nxo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Whirl\\obj_cycloneSpell_wc3spell.j"))call VNx(ma,(function noo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Whirl\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction nio takes nothing returns booleanset ELv=VXx(Ekv)
return trueendfunctionfunction nao takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local real x
local real y
set Emv[((rLx))]=(true)call Avx(rLx,EMv)set x=Dsx(rLx)set y=Dtx(rLx)call UnitAddType(C[rLx],UNIT_TYPE_SAPPER)call DTx(eJ,Q3,rLx)call UnitRemoveType(C[rLx],UNIT_TYPE_SAPPER)
return trueendfunctionfunction nno takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set Emv[((rLx))]=(false)
call RPx(rLx,EMv)call UnitRemoveAbility(C[((((rLx))))],(('bWhX')))return trueendfunctionfunction nVo takes nothing returns booleancall Lxx(Elv,Xdx("FolderUnit_StructWhirl_Buff_Init: call FolderUnit_StructWhirl.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructWhirl.Event_BuffGain))",bd,bI,function nao))call Lxx(Elv,Xdx("FolderUnit_StructWhirl_Buff_Init: call FolderUnit_StructWhirl.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructWhirl.Event_BuffLose))",jc,bI,function nno))call W2x(Elv,EJv)return trueendfunctionfunction nEo takes nothing returns booleancall u9x(function nVo,"FolderUnit_StructWhirl_Buff_Init")return trueendfunctionfunction nXo takes nothing returns booleanset Epv=VXx(EPv)
return trueendfunctionfunction nOo takes nothing returns booleanset Eqv=ltx(EQv+" (dummyBuff)")return trueendfunctionfunction nRo takes nothing returns booleanset Esv=ltx(EQv+" (normalBuff)")
call lWx(Esv,"Unit_page\\Unit_struct\\Bleeding\\buff2.mdx","chest",ri)return trueendfunctionfunction nIo takes nothing returns booleancall VNx(ma,(function nOo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Bleeding\\obj_dummyBuff_wc3buff.j"))call VNx(ma,(function nRo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Bleeding\\obj_normalBuff_wc3buff.j"))return trueendfunctionfunction nAo takes nothing returns booleanset ESv=VXx(EQv)
return trueendfunctionfunction nNo takes integer oSx returns booleanif not(aTv[(oSx)])thenreturn false
endifcall cCx((oSx),iSx("Blocked!!","d4e019aa"),.02,auv+oSx)call Ryx((ACx(((oSx)),("Abilities\\Spells\\Other\\HealingSpray\\HealBottleMissile.mdl"),("chest"),(ri))))call AZx((oSx),CAx((oSx),auv,q))
return trueendfunctionfunction nbo takes integer oSx returns booleanif not(aYv[(oSx)])thenreturn nNo(oSx)endifcall cCx((oSx),iSx("Magic immune!!","d4e019aa"),.02,Ewv+oSx)
return trueendfunctionfunction nBo takes real oux returns real
if(oux<.0)thenreturn(2.-(Pow((((1.-.06))*1.),((-oux*EWv)*1.))))endifreturn(1.*1./(1.+.06*oux*EWv))endfunctionfunction nco takes real oux returns real
if(oux<.0)thenreturn(2.-(Pow((((1.-.06))*1.),((-oux)*1.))))endifreturn(1.*1./(1.+.06*oux))endfunctionfunction nCo takes integer oSx,integer Iix returns booleanif((rk[((oSx))])and not(npv[((oSx))]))thenreturn trueendifif(Ezv[(Iix)])thenreturn trueendifreturn((GetRandomReal(((.0)*1.),((1.)*1.)))<=(blx(((vF[((oSx))])-(EZv[((Iix))]))*1./ 'd',.0,1.)))endfunctionfunction ndo takes integer oSx returns booleanif not(aRv[(oSx)])thenreturn false
endifcall cCx((oSx),iSx("Invulnerable!!","ffff0000"),.02,E_v+oSx)
return trueendfunctionfunction nDo takes integer oSx,real nZx,integer Iix,boolean nfo returns real
local integer rLx=oSxlocal integer rFx=rRx((A[(rLx)]))local integer nFolocal integer oMxlocal integer rbxlocal integer rMxset E1v[(rFx)]=((nZx)*1.)set E2v[(rFx)]=(rLx)
set zH[(rFx)]=(Iix)set Vv[(rFx)]=(Iix)set nFo=rRx((A[(Iix)]))set E1v[(nFo)]=((nZx)*1.)set E2v[(nFo)]=(rLx)
set Vv[(nFo)]=(Iix)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(Iix,E3v,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(Iix,E3v,rbx,rMx),nFo)set E1v[(rFx)]=(((E1v[(nFo)]))*1.)set rMx=rMx-1endloopset rMx=rAx(rLx,E4v,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(rLx,E4v,rbx,rMx),rFx)set E1v[(nFo)]=(((E1v[(rFx)]))*1.)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call rkx(((nFo)))set nZx=(E1v[(rFx)])
return nZxendfunctionfunction ngo takes integer oSx,real oux returns nothingcall chx(oSx,(oG[(oSx)])-oux)endfunctionfunction nGo takes integer oSx,integer Iix,real nZx,boolean nho returns real
if ndo(Iix)thenreturn .0endifset nZx=nZx*(1.-(E0v[(Iix)]))if(nZx>.0)thenif nho thenset nZx=nDo(oSx,nZx,Iix,false)endifset nZx=iUx(nZx,(oG[(Iix)]))
call UnitDamageTarget(C[(oSx)],C[Iix],.0,false,false,null,null,null)
set DG=oSxcall ngo(Iix,nZx)return nZxendifreturn .0endfunctionfunction nHo takes integer oSx,string icx,real Ovx,real OLx,real Omx,real iMx,integer id,real oux returns integerlocal integer njo=(LoadInteger(o[((V[(E[((X))])]))],(((EN))),((((id))))))if((njo==w)or((dN[(njo)])<oux))thenif(njo!=w)thencall Odx(njo)endifset njo=Oqx(oSx,icx,Ovx,OLx,Omx,iMx,id)set dN[(njo)]=((oux)*1.)
endifreturn njoendfunctionfunction nJo takes real dX,real dY,real bLx,real nYx returns realif(dY==.0)thenreturn((nYx+bLx)*1./ 2)endifreturn blx(bLx+dX*1./ dY*(nYx-bLx),bLx,nYx)endfunctionfunction nko takes integer oSx,real nZx,boolean nKo returns nothingset nZx=nZx*(E5v[(oSx)])*.01
if(nZx<=.0)thenreturnendifcall nHo((oSx),i1x("~"+(I2S(((R2I(((((nZx)*1.))*1.))))))+itx(nKo,"!")+"~",(xb[((ze[((oSx))]))]),"ff20b2aa"),nJo(nZx,(rG[((oSx))])*1./ 2.,.016,.022),160.,.0,1.,E6v+oSx,nZx*1./ 2)call cjx((oSx),nZx)endfunctionfunction nlo takes integer oSx,integer Iix,real nZx,boolean nLo,boolean nho returns real
local boolean nKo=falseif(nZx>.0)thenif nLo thenif nbo(Iix)thenreturn .0endifset nZx=nZx*nBo((zF[(Iix)])-(zF[((oSx))]))*(1.-(Eyv[(Iix)]))*(GetRandomReal(((.9)*1.),((1.1)*1.)))else
set nZx=nZx*nco((EYv[(Iix)]))endifif(not nLo and nCo((oSx),Iix))thenset nZx=nZx*2.set nKo=true
endifendifset nZx=nGo(oSx,Iix,nZx,nho)
call nko((oSx),nZx,nKo)return nZxendfunctionfunction nmo takes integer oSx,integer Iix,real nZx,boolean nLo,boolean nho returns real
return nlo(oSx,Iix,nZx,nLo,nho)endfunctionfunction nMo takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxcall Ryx((ACx((Iix),((EUv[(Iix)])),("chest"),(Bi))))
if I9x(Iix,Wd)thencall nmo(ETv[oSx],Iix,E8v*(rG[(Iix)]),false,false)else
call nmo(ETv[oSx],Iix,Xvv*(rG[(Iix)]),false,false)endifendfunctionfunction npo takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Lc[(rFx)])local integer rLx=(Vv[(rFx)])local integer oSx=rLxlocal integer p3xset Etv[(oSx)]=(true)set p3x=iXx()set ETv[oSx]=Cqx
set Euv[oSx]=p3x
set ge[(p3x)]=(oSx)call Dux((((rLx))),(nLv),(1),w)call iDx(p3x,1.,true,function nMo)return trueendfunctionfunction nPo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=rLxset Etv[(oSx)]=(false)call iKx(Euv[oSx])call Ulx(((rLx)),nLv)return trueendfunctionfunction nqo takes nothing returns booleancall Lxx(Eqv,Xdx("FolderUnit_StructBleeding_Buff_Init: call FolderUnit_StructBleeding.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructBleeding.Event_BuffGain))",bd,MI,function npo))
call Lxx(Eqv,Xdx("FolderUnit_StructBleeding_Buff_Init: call FolderUnit_StructBleeding.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructBleeding.Event_BuffLose))",jc,MI,function nPo))
call W2x(Eqv,Esv)return trueendfunctionfunction nQo takes nothing returns booleancall u9x(function nqo,"FolderUnit_StructBleeding_Buff_Init")
return trueendfunctionfunction nso takes nothing returns booleanset Xev=Wwx('BIgn',"Ignited",'bIgn')
set anv[(Xev)]=("ReplaceableTextures\\CommandButtons\\BTNSelfDestruct.blp")call lWx(Xev,"Abilities\\Spells\\Other\\BreathOfFire\\BreathOfFireDamage.mdx","overhead",ri)
call lWx(Xev,"Unit_page\\Unit_struct\\Ignited\\Target.mdx","foot left",Bi)call lWx(Xev,"Unit_page\\Unit_struct\\Ignited\\Target.mdx","foot right",Bi)call lWx(Xev,"Unit_page\\Unit_struct\\Ignited\\Target.mdx","hand left",Bi)call lWx(Xev,"Unit_page\\Unit_struct\\Ignited\\Target.mdx","chest",Bi)call lWx(Xev,"Unit_page\\Unit_struct\\Ignited\\Target.mdx","head",Bi)return trueendfunctionfunction nSo takes nothing returns booleanset Xxv=ltx(Xov+" (dummyBuff)")return trueendfunctionfunction nto takes nothing returns booleancall VNx(ma,(function nso),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Ignited\\obj_normalBuff_wc3buff.j"))call VNx(ma,(function nSo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Ignited\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction nTo takes nothing returns booleanset Xrv=VXx(Xov)
return trueendfunctionfunction nuo takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxif I9x(Iix,Wd)thencall nmo(Xav[oSx],Iix,XEv*(rG[(Iix)]),true,false)else
call nmo(Xav[oSx],Iix,XOv*(rG[(Iix)]),true,false)endifendfunctionfunction nUo takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Lc[(rFx)])local integer rLx=(Vv[(rFx)])local integer oSx=rLxlocal integer p3xset Xiv[(oSx)]=(true)set p3x=iXx()set Xav[oSx]=Cqx
set Xnv[oSx]=p3x
set ge[(p3x)]=(oSx)call Dux((((rLx))),(nLv),(1),w)call iDx(p3x,1.,true,function nuo)return trueendfunctionfunction nwo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=rLxset Xiv[(oSx)]=(false)call iKx(Xnv[oSx])call Ulx(((rLx)),nLv)return trueendfunctionfunction nWo takes nothing returns booleancall Lxx(Xxv,Xdx("FolderUnit_StructIgnited_Buff_Init: call FolderUnit_StructIgnited.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructIgnited.Event_BuffGain))",bd,MI,function nUo))call Lxx(Xxv,Xdx("FolderUnit_StructIgnited_Buff_Init: call FolderUnit_StructIgnited.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructIgnited.Event_BuffLose))",jc,MI,function nwo))call W2x(Xxv,Xev)return trueendfunctionfunction nyo takes nothing returns booleancall u9x(function nWo,"FolderUnit_StructIgnited_Buff_Init")return trueendfunctionfunction nYo takes nothing returns booleanset XRv=VXx(XIv)
return trueendfunctionfunction nzo takes nothing returns booleanreturn trueendfunctionfunction nZo takes nothing returns booleancall u9x(function nzo,"FolderUnit_StructKnockup_Buff_Init")return trueendfunctionfunction n_o takes nothing returns booleanset XAv=ltx(XNv+" (dummyBuff)")return trueendfunctionfunction n0o takes nothing returns booleancall VNx(ma,(function n_o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Pathing\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction n1o takes nothing returns booleanset Xbv=VXx(XNv)
return trueendfunctionfunction n2o takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set XBv[((rLx))]=(false)
call SetUnitPathing(C[rLx],false)return trueendfunctionfunction n3o takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set XBv[((rLx))]=(true)call SetUnitPathing(C[rLx],true)
return trueendfunctionfunction n4o takes nothing returns booleancall Lxx(XAv,Xdx("FolderUnit_StructPathing_Buff_Init: call FolderUnit_StructPathing.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructPathing.Event_BuffGain))",bd,MI,function n2o))call Lxx(XAv,Xdx("FolderUnit_StructPathing_Buff_Init: call FolderUnit_StructPathing.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructPathing.Event_BuffLose))",jc,MI,function n3o))return trueendfunctionfunction n5o takes nothing returns booleancall u9x(function n4o,"FolderUnit_StructPathing_Buff_Init")return trueendfunctionfunction n6o takes nothing returns booleanset Xcv=ltx(XCv+" (dummyBuff)")set WU=l_x()
call l2x(WU,nnv,-.25)call l2x(WU,Egv,-.5)
call l2x(WU,Xdv,-.5)
call l2x(WU,iw,-.1)call l3x(((Xcv)),ZB+(1),(WU))return trueendfunctionfunction n7o takes nothing returns booleanset XDv=Wwx('BPoi',"Poisoned",'bPoi')set anv[(XDv)]=("ReplaceableTextures\\CommandButtons\\BTNCorrosiveBreath.blp")call lWx(XDv,"Abilities\\Spells\\Undead\\Curse\\CurseTarget.mdl","overhead",Bi)set WU=l_x()
call rto(WU,rzo(db,-'d',0,-'d',0))call l3x(((XDv)),ZB+(1),(WU))return trueendfunctionfunction n8o takes nothing returns booleancall VNx(ma,(function n6o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Poisoned\\obj_dummyBuff_wc3buff.j"))call VNx(ma,(function n7o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Poisoned\\obj_normalBuff_wc3buff.j"))return trueendfunctionfunction n9o takes nothing returns booleanset Xfv=VXx(XCv)
return trueendfunctionfunction Vvo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set XFv[((rLx))]=(true)return trueendfunctionfunction Veo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set XFv[((rLx))]=(false)
return trueendfunctionfunction Vxo takes nothing returns booleancall Lxx(Xcv,Xdx("FolderUnit_StructPoisoned_Buff_Init: call FolderUnit_StructPoisoned.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructPoisoned.Event_BuffGain))",bd,MI,function Vvo))
call Lxx(Xcv,Xdx("FolderUnit_StructPoisoned_Buff_Init: call FolderUnit_StructPoisoned.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructPoisoned.Event_BuffLose))",jc,MI,function Veo))
call W2x(Xcv,XDv)return trueendfunctionfunction Voo takes nothing returns booleancall u9x(function Vxo,"FolderUnit_StructPoisoned_Buff_Init")
return trueendfunctionfunction Vro takes nothing returns booleanset Xgv=VXx(XGv)
return trueendfunctionfunction Vio takes nothing returns booleanset Xhv=VXx(XHv)
return trueendfunctionfunction Vao takes nothing returns booleancall L1x('ARev',false)return trueendfunctionfunction Vno takes nothing returns booleancall VNx(Pa,(function Vao),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Revival\\obj_dummySpell_wc3spell.j"))return trueendfunctionfunction VVo takes nothing returns booleanset Xjv=VXx(XJv)
return trueendfunctionfunction VEo takes nothing returns booleanset Xkv=ltx(XKv+" (dummyBuff)")return trueendfunctionfunction VXo takes nothing returns booleanset Xlv=ltx(XKv+" (normalBuff)")
call lWx(Xlv,"Abilities\\Spells\\Other\\Silence\\SilenceTarget.mdl","overhead",ri)return trueendfunctionfunction VOo takes nothing returns booleanset XLv=ltx(XKv+" (noneBuff)")return trueendfunctionfunction VRo takes nothing returns booleancall L1x('aSil',false)return trueendfunctionfunction VIo takes nothing returns booleancall VNx(ma,(function VEo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Silence\\obj_dummyBuff_wc3buff.j"))call VNx(ma,(function VXo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Silence\\obj_normalBuff_wc3buff.j"))call VNx(ma,(function VOo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Silence\\obj_noneBuff_wc3buff.j"))
call VNx(Pa,(function VRo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Silence\\obj_silSpell_wc3spell.j"))return trueendfunctionfunction VAo takes nothing returns booleanset Xmv=VXx(XKv)
return trueendfunctionfunction VNo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set XMv[((rLx))]=(true)call Avx(rLx,Xpv)call DTx(eJ,b4,rLx)return trueendfunctionfunction Vbo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set XMv[((rLx))]=(false)
call RPx(rLx,Xpv)call UnitRemoveAbility(C[((((rLx))))],(('bSil')))return trueendfunctionfunction VBo takes nothing returns booleancall Lxx(Xkv,Xdx("FolderUnit_StructSilence_Buff_Init: call FolderUnit_StructSilence.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructSilence.Event_BuffGain))",bd,bI,function VNo))call Lxx(Xkv,Xdx("FolderUnit_StructSilence_Buff_Init: call FolderUnit_StructSilence.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructSilence.Event_BuffLose))",jc,bI,function Vbo))call W2x(Xkv,Xlv)return trueendfunctionfunction Vco takes nothing returns booleancall u9x(function VBo,"FolderUnit_StructSilence_Buff_Init")return trueendfunctionfunction VCo takes nothing returns booleancall L1x('ACsl',false)return trueendfunctionfunction Vdo takes nothing returns booleanset XPv=ltx(Xqv+" (normalBuff)")
call lWx(XPv,"Abilities\\Spells\\Undead\\Sleep\\SleepTarget.mdl","overhead",ri)return trueendfunctionfunction VDo takes nothing returns booleanset XQv=ltx(Xqv+" (dummyBuff)")return trueendfunctionfunction Vfo takes nothing returns booleancall VNx(Pa,(function VCo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Sleep\\obj_sleepSpell_wc3spell.j"))call VNx(ma,(function Vdo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Sleep\\obj_normalBuff_wc3buff.j"))
call VNx(ma,(function VDo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Sleep\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction VFo takes nothing returns booleanset Xsv=VXx(Xqv)
return trueendfunctionfunction Vgo takes integer oSx returns nothingcall Dux(((oSx)),(nlv),(1),w)endfunctionfunction VGo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=rLxset Ezv[((rLx))]=(true)call Avx(rLx,XSv)call Vgo(rLx)call DTx(eJ,A4,rLx)call UnitRemoveAbility(C[((((rLx))))],(('BSlp')))return trueendfunctionfunction Vho takes integer oSx returns nothingcall Ulx((oSx),nlv)endfunctionfunction VHo takes integer oSx returns nothinglocal integer rLx=oSxlocal integer rFx=rRx((A[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset Vv[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,Xtv,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(rLx,Xtv,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction Vjo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set Ezv[((rLx))]=(false)
call RPx(rLx,XSv)call Vho(rLx)call UnitRemoveAbility(C[((((rLx))))],(('BSlp')))call UnitRemoveAbility(C[((((rLx))))],(('BUsl')))call VHo((rLx))return trueendfunctionfunction VJo takes nothing returns booleancall Lxx(XQv,Xdx("FolderUnit_StructSleep_Buff_Init: call FolderUnit_StructSleep.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructSleep.Event_BuffGain))",bd,bI,function VGo))call Lxx(XQv,Xdx("FolderUnit_StructSleep_Buff_Init: call FolderUnit_StructSleep.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructSleep.Event_BuffLose))",jc,bI,function Vjo))call W2x(XQv,XPv)return trueendfunctionfunction Vko takes nothing returns booleancall u9x(function VJo,"FolderUnit_StructSleep_Buff_Init")return trueendfunctionfunction VKo takes nothing returns booleanset XTv=VXx(Xuv)
return trueendfunctionfunction Vlo takes nothing returns booleancall L1x('AStn',false)return trueendfunctionfunction VLo takes nothing returns booleanset nlv=ltx(XUv+" (dummyBuff)")return trueendfunctionfunction Vmo takes nothing returns booleanset Xwv=Wwx('BStd',"Stunned",'bStd')
set anv[(Xwv)]=("ReplaceableTextures\\CommandButtons\\BTNStun.blp")call lWx(Xwv,"Abilities\\Spells\\Human\\Thunderclap\\ThunderclapTarget.mdl","overhead",ri)return trueendfunctionfunction VMo takes nothing returns booleancall VNx(Pa,(function Vlo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Stun\\obj_stunSpell_wc3spell.j"))call VNx(ma,(function VLo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Stun\\obj_dummyBuff_wc3buff.j"))call VNx(ma,(function Vmo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Stun\\obj_normalBuff_wc3buff.j"))return trueendfunctionfunction Vpo takes nothing returns booleanset XWv=VXx(XUv)
return trueendfunctionfunction VPo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set ph[((rLx))]=(true)call DTx(eJ,G4,rLx)return trueendfunctionfunction Vqo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])set ph[((rLx))]=(false)call UnitRemoveAbility(C[((((rLx))))],(('bStu')))return trueendfunctionfunction VQo takes nothing returns booleancall Lxx(nlv,Xdx("FolderUnit_StructStun_Buff_Init: call FolderUnit_StructStun.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructStun.Event_BuffGain))",bd,bI,function VPo))
call Lxx(nlv,Xdx("FolderUnit_StructStun_Buff_Init: call FolderUnit_StructStun.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructStun.Event_BuffLose))",jc,bI,function Vqo))
call W2x(nlv,Xwv)return trueendfunctionfunction Vso takes nothing returns booleancall u9x(function VQo,"FolderUnit_StructStun_Buff_Init")
return trueendfunctionfunction VSo takes nothing returns booleanset xTv=VXx(xSv)
return trueendfunctionfunction Vto takes nothing returns booleanset Xyv=VXx(XYv)
return trueendfunctionfunction VTo takes nothing returns booleanset Xzv=VXx(XZv)
return trueendfunctionfunction Vuo takes nothing returns booleanset X_v=VXx(X0v)
return trueendfunctionfunction VUo takes nothing returns booleanset X1v=VXx(X2v)
return trueendfunctionfunction Vwo takes nothing returns booleanset X3v=VXx(X4v)
return trueendfunctionfunction VWo takes nothing returns booleanset X5v=VXx(X6v)
return trueendfunctionfunction Vyo takes nothing returns booleanset X7v=VXx(X8v)
return trueendfunctionfunction VYo takes nothing returns booleanset X9v=VXx(Ovv)
return trueendfunctionfunction Vzo takes nothing returns booleanset Oev=VXx(Oxv)
return trueendfunctionfunction VZo takes nothing returns booleanset Oov=VXx(Orv)
return trueendfunctionfunction V_o takes nothing returns booleanset Oiv=VXx(Oav)
return trueendfunctionfunction V0o takes nothing returns booleanset Onv=VXx(OVv)
return trueendfunctionfunction V1o takes nothing returns booleanset OEv=VXx(OXv)
return trueendfunctionfunction V2o takes nothing returns booleanset OOv=VXx(ORv)
return trueendfunctionfunction V3o takes nothing returns booleanset OIv=VXx(OAv)
return trueendfunctionfunction V4o takes nothing returns booleanset ONv=VXx(Obv)
return trueendfunctionfunction V5o takes nothing returns booleanset OBv=VXx(Ocv)
return trueendfunctionfunction V6o takes nothing returns booleanset OCv=VXx(Odv)
return trueendfunctionfunction V7o takes nothing returns booleanset ODv=VXx(Ofv)
return trueendfunctionfunction V8o takes nothing returns booleanset OFv=VXx(Ogv)
return trueendfunctionfunction V9o takes nothing returns booleanset OGv=VXx(Ohv)
return trueendfunctionfunction Evo takes nothing returns booleanset OHv=VXx(Ojv)
return trueendfunctionfunction Eeo takes nothing returns booleanset OJv=VXx(Okv)
return trueendfunctionfunction Exo takes nothing returns booleanset OKv=VXx(Olv)
return trueendfunctionfunction Eoo takes nothing returns booleanset OLv=ltx(Omv+" (dummyBuff)")call lWx(OLv,"Abilities\\Spells\\Human\\slow\\slowtarget.mdl","origin",ri)return trueendfunctionfunction Ero takes nothing returns booleancall VNx(ma,(function Eoo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Stamina\\Exhaustion\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction Eio takes nothing returns booleanset OMv=VXx(Omv)
return trueendfunctionfunction Eao takes nothing returns booleanreturn trueendfunctionfunction Eno takes nothing returns booleancall u9x(function Eao,"FolderUnit_FolderStamina_StructExhaustion_Buff_Init")
return trueendfunctionfunction EVo takes nothing returns booleanset Opv=VXx(OPv)
return trueendfunctionfunction EEo takes nothing returns booleanset Oqv=VXx(OQv)
return trueendfunctionfunction EXo takes nothing returns booleanset Osv=VXx(OSv)
return trueendfunctionfunction EOo takes nothing returns booleanset Otv=VXx(OTv)
return trueendfunctionfunction ERo takes nothing returns booleanset Ouv=VXx(OUv)
return trueendfunctionfunction EIo takes nothing returns booleanset Owv=VXx(OWv)
return trueendfunctionfunction EAo takes nothing returns booleanreturn trueendfunctionfunction ENo takes nothing returns booleanset Oyv=VXx(OYv)
return trueendfunctionfunction Ebo takes nothing returns booleanset Ozv=ltx(OZv+" (dummyBuff)")return trueendfunctionfunction EBo takes nothing returns booleancall VNx(ma,(function Ebo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\TimedLife\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction Eco takes nothing returns booleanset O_v=VXx(OZv)
return trueendfunctionfunction ECo takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer rLx=oSxcall AZx(rLx,Ozv)call Cix(rLx)endfunctionfunction Edo takes nothing returns booleanlocal integer rFx=(bv)local real iMx=Fflocal integer rLx=(Vv[(rFx)])local integer oSx=rLxlocal integer iCx=iXx()set O0v[oSx]=iCx
set ge[(iCx)]=(oSx)call UnitApplyTimedLife(C[rLx],'RTLF',iMx+.01)call iDx(iCx,iMx,false,function ECo)
return trueendfunctionfunction EDo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=rLxlocal integer iCx=O0v[oSx]call iKx(iCx)return trueendfunctionfunction Efo takes nothing returns booleancall Lxx(Ozv,Xdx("FolderUnit_StructTimedLife_Buff_Init: call FolderUnit_StructTimedLife.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructTimedLife.Event_BuffGain))",bd,MI,function Edo))call Lxx(Ozv,Xdx("FolderUnit_StructTimedLife_Buff_Init: call FolderUnit_StructTimedLife.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructTimedLife.Event_BuffLose))",jc,MI,function EDo))return trueendfunctionfunction EFo takes nothing returns booleancall u9x(function Efo,"FolderUnit_StructTimedLife_Buff_Init")return trueendfunctionfunction Ego takes nothing returns booleancall L1x('ATra',false)return trueendfunctionfunction EGo takes nothing returns booleanset O1v=ltx(O2v+" (dummyBuff)")return trueendfunctionfunction Eho takes nothing returns booleancall L1x('Aloa',false)return trueendfunctionfunction EHo takes nothing returns booleancall VNx(Pa,(function Ego),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Transport\\obj_cargoSpell_wc3spell.j"))call VNx(ma,(function EGo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Transport\\obj_dummyBuff_wc3buff.j"))call VNx(Pa,(function Eho),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Transport\\obj_loadInSpell_wc3spell.j"))return trueendfunctionfunction Ejo takes nothing returns booleanset O3v=VXx(O2v)
return trueendfunctionfunction EJo takes integer oSx returns nothinglocal integer rLx=oSxlocal integer rFx=rRx(0)
local integer Ekolocal integer oMxlocal integer rbxlocal integer rMxset Vv[(rFx)]=(oSx)set Eko=rRx((A[(rLx)]))set Vv[(Eko)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((O7v))-1)*Iv+(((rbx))-1)))))))))
loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((O7v))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset rMx=rAx(rLx,O7v,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(rLx,O7v,rbx,rMx),Eko)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call rkx(((Eko)))endfunctionfunction EKo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer Elo=(Lc[(rFx)])local integer oSx=rLxlocal integer HAx=wlocal boolean ELo=truelocal integer d8xlocal integer Emoif(Elo==w)thenset HAx=mDx('qTra',Dsx(rLx),Dtx(rLx),.0,.0)call UnitAddAbility(vJ[((HAx))],('ATra'))call UnitAddAbility(vJ[((HAx))],('Aloa'))call mbx(HAx,(ze[(rLx)]))if not(IssueTargetOrderById(vJ[((HAx))],pb[(T3)],C[((rLx))]))thencall o_x("FolderUnit_StructTransport_Event_BuffGain","call DebugEx(FolderUnit_StructTransport.NAME + \": cannot load in \" + parent.GetName())",O2v+": cannot load in "+(GetUnitName(C[(rLx)])))
set ELo=falseendifelse
set d8x=(ze[(rLx)])set Emo=(ze[(Elo)])call rtx(Elo,'ATra')
call rtx(Elo,'Aloa')
call acx(Elo,d8x)call Q0x(d8x,'Aloa',true)if not Lox(Elo,T3,rLx)thencall o_x("FolderUnit_StructTransport_Event_BuffGain","call DebugEx(FolderUnit_StructTransport.NAME + \": cannot load in \" + parent.GetName() + \" (transporter=\"+transporter.GetName()+\")\")",O2v+": cannot load in "+(GetUnitName(C[(rLx)]))+" (transporter="+(GetUnitName(C[(Elo)]))+")")set ELo=falseendifcall Q0x(d8x,'Aloa',false)call acx(Elo,Emo)endifif ELo thenset O4v[oSx]=HAx
set O5v[oSx]=Elo
set O6v[(oSx)]=(true)else
call AZx(rLx,O1v)endifcall EJo(oSx)return trueendfunctionfunction EMo takes integer oSx,real x,real y returns nothing
call SetUnitPosition(C[(oSx)],x,y)endfunctionfunction Epo takes integer oSx returns nothinglocal integer rLx=oSxlocal integer rFx=rRx(0)
local integer Ekolocal integer oMxlocal integer rbxlocal integer rMxset Vv[(rFx)]=(oSx)set Eko=rRx((A[(rLx)]))set Vv[(Eko)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((O8v))-1)*Iv+(((rbx))-1)))))))))
loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((O8v))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset rMx=rAx(rLx,O8v,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(rLx,O8v,rbx,rMx),Eko)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call rkx(((Eko)))endfunctionfunction EPo takes integer oSx,integer oDx,boolean iTx returns nothingif iOx(oDx)thencall SelectUnit(C[oSx],iTx)endifendfunctionfunction Eqo takes integer oSx returns nothinglocal integer rLx=oSxlocal integer oMx=CIx(rLx,Cb)local integer oDxloop
exitwhen(oMx<q)set oDx=CAx(rLx,Cb,oMx)if not(IsUnitSelected(C[(rLx)],vx[(oDx)]))thencall EPo(rLx,oDx,true)endifset oMx=oMx-1endloopendfunctionfunction EQo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=rLxlocal integer Elolocal integer HAxset O6v[(oSx)]=(false)set Elo=O5v[oSx]
if(Elo==w)thenset HAx=O4v[oSx]
call KillUnit(vJ[(HAx)])
call Mfx(HAx)else
call EMo(rLx,Dsx(Elo),Dtx(Elo))endifif IsUnitHidden(C[rLx])thencall ShowUnit(C[rLx],true)endifcall Epo(oSx)call Eqo(rLx)return trueendfunctionfunction Eso takes nothing returns booleancall Lxx(O1v,Xdx("FolderUnit_StructTransport_Buff_Init: call FolderUnit_StructTransport.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructTransport.Event_BuffGain))",bd,MI,function EKo))call Lxx(O1v,Xdx("FolderUnit_StructTransport_Buff_Init: call FolderUnit_StructTransport.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderUnit_StructTransport.Event_BuffLose))",jc,MI,function EQo))return trueendfunctionfunction ESo takes nothing returns booleancall u9x(function Eso,"FolderUnit_StructTransport_Buff_Init")return trueendfunctionfunction Eto takes nothing returns booleanset O9v=VXx(Rvv)
return trueendfunctionfunction ETo takes nothing returns booleanset Rev=VXx(Rxv)
return trueendfunctionfunction Euo takes nothing returns booleanset Rov=VXx(Rrv)
return trueendfunctionfunction EUo takes nothing returns booleanset Riv=VXx(Mk)return trueendfunctionfunction Ewo takes nothing returns booleanset Rav=VXx(pk)return trueendfunctionfunction EWo takes nothing returns booleanset Rnv=VXx(RVv)
return trueendfunctionfunction Eyo takes nothing returns booleanset REv=VCx("ONud")return trueendfunctionfunction EYo takes nothing returns booleancall VNx(ha,(function Eyo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Position\\obj_nudgeBolt_wc3bolt.j"))return trueendfunctionfunction Ezo takes nothing returns booleanset RXv=VXx(ROv)
return trueendfunctionfunction EZo takes nothing returns booleanset RRv[1]="Unit_page\\Unit_struct\\Selection\\Circle\\circleRed.mdx"set RRv[2]="Unit_page\\Unit_struct\\Selection\\Circle\\circleBlue.mdx"set RRv[3]="Unit_page\\Unit_struct\\Selection\\Circle\\circleTeal.mdx"set RRv[4]="Unit_page\\Unit_struct\\Selection\\Circle\\circlePurple.mdx"
set RRv[5]="Unit_page\\Unit_struct\\Selection\\Circle\\circleYellow.mdx"
set RRv[6]="Unit_page\\Unit_struct\\Selection\\Circle\\circleOrange.mdx"
set RRv[7]="Unit_page\\Unit_struct\\Selection\\Circle\\circleGreen.mdx"set RRv[8]="Unit_page\\Unit_struct\\Selection\\Circle\\circlePink.mdx"set RRv[9]="Unit_page\\Unit_struct\\Selection\\Circle\\circleGray.mdx"set RRv[$A]="Unit_page\\Unit_struct\\Selection\\Circle\\circleLightblue.mdx"
set RRv[$B]="Unit_page\\Unit_struct\\Selection\\Circle\\circleDarkgreen.mdx"
set RRv[$C]="Unit_page\\Unit_struct\\Selection\\Circle\\circleBrown.mdx"
return trueendfunctionfunction E_o takes nothing returns booleancall VNx(va,(function EZo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Selection\\Circle\\obj_this_wc3obj.j"))return trueendfunctionfunction E0o takes nothing returns booleanset RIv=VXx(RAv)
return trueendfunctionfunction E1o takes nothing returns booleanset RNv=ltx(Rbv+" (dummyBuff)")return trueendfunctionfunction E2o takes nothing returns booleancall VNx(ma,(function E1o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\Selection\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction E3o takes nothing returns booleanset RBv=VXx(Rbv)
return trueendfunctionfunction E4o takes nothing returns booleanset Rcv=VXx(RCv)
return trueendfunctionfunction E5o takes nothing returns booleanset Rdv=VXx(RDv)
return trueendfunctionfunction E6o takes nothing returns booleanset Rfv=VXx(RFv)
return trueendfunctionfunction E7o takes nothing returns booleanset Rgv[1]='SS00'call L1x('SS00',false)set Rgv[2]='SS01'call L1x('SS01',false)set Rgv[3]='SS02'call L1x('SS02',false)set Rgv[4]='SS03'call L1x('SS03',false)set Rgv[5]='SS04'call L1x('SS04',false)set Rgv[6]='SS05'call L1x('SS05',false)set Rgv[7]='SS06'call L1x('SS06',false)set Rgv[8]='SS07'call L1x('SS07',false)set Rgv[9]='SS08'call L1x('SS08',false)set Rgv[$A]='SS09'call L1x('SS09',false)set Rgv[$B]='SS0A'call L1x('SS0A',false)set Rgv[$C]='SS0B'call L1x('SS0B',false)set Rgv[$D]='SS0C'call L1x('SS0C',false)set Rgv[$E]='SS0D'call L1x('SS0D',false)set Rgv[$F]='SS0E'call L1x('SS0E',false)set Rgv[16]='SS0F'call L1x('SS0F',false)set Rgv[17]='SS0G'call L1x('SS0G',false)set Rgv[18]='SS0H'call L1x('SS0H',false)set Rgv[19]='SS0I'call L1x('SS0I',false)set Rgv[20]='SS0J'call L1x('SS0J',false)set Rgv[21]='SS0K'call L1x('SS0K',false)set Rgv[22]='SS0L'call L1x('SS0L',false)set Rgv[23]='SS0M'call L1x('SS0M',false)set Rgv[24]='SS0N'call L1x('SS0N',false)set Rgv[25]='SS0O'call L1x('SS0O',false)set Rgv[26]='SS0P'call L1x('SS0P',false)set Rgv[27]='SS0Q'call L1x('SS0Q',false)set Rgv[28]='SS0R'call L1x('SS0R',false)set Rgv[29]='SS0S'call L1x('SS0S',false)set Rgv[30]='SS0T'call L1x('SS0T',false)set Rgv[31]='SS0U'call L1x('SS0U',false)set Rgv[32]='SS0V'call L1x('SS0V',false)set Rgv[33]='SS0W'call L1x('SS0W',false)set Rgv[34]='SS0X'call L1x('SS0X',false)set Rgv[35]='SS0Y'call L1x('SS0Y',false)set Rgv[36]='SS0Z'call L1x('SS0Z',false)set Rgv[37]='SS10'call L1x('SS10',false)set Rgv[38]='SS11'call L1x('SS11',false)set Rgv[39]='SS12'call L1x('SS12',false)set Rgv[40]='SS13'call L1x('SS13',false)set Rgv[41]='SS14'call L1x('SS14',false)set Rgv[42]='SS15'call L1x('SS15',false)set Rgv[43]='SS16'call L1x('SS16',false)set Rgv[44]='SS17'call L1x('SS17',false)set Rgv[45]='SS18'call L1x('SS18',false)set Rgv[46]='SS19'call L1x('SS19',false)set Rgv[47]='SS1A'call L1x('SS1A',false)set Rgv[48]='SS1B'call L1x('SS1B',false)set Rgv[49]='SS1C'call L1x('SS1C',false)set Rgv[50]='SS1D'call L1x('SS1D',false)set Rgv[51]='SS1E'call L1x('SS1E',false)set Rgv[52]='SS1F'call L1x('SS1F',false)set Rgv[53]='SS1G'call L1x('SS1G',false)set Rgv[54]='SS1H'call L1x('SS1H',false)set Rgv[55]='SS1I'call L1x('SS1I',false)set Rgv[56]='SS1J'call L1x('SS1J',false)set Rgv[57]='SS1K'call L1x('SS1K',false)set Rgv[58]='SS1L'call L1x('SS1L',false)set Rgv[59]='SS1M'call L1x('SS1M',false)set Rgv[60]='SS1N'call L1x('SS1N',false)set Rgv[61]='SS1O'call L1x('SS1O',false)set Rgv[62]='SS1P'call L1x('SS1P',false)set Rgv[63]='SS1Q'call L1x('SS1Q',false)set Rgv[64]='SS1R'call L1x('SS1R',false)set Rgv[65]='SS1S'call L1x('SS1S',false)set Rgv[66]='SS1T'call L1x('SS1T',false)set Rgv[67]='SS1U'call L1x('SS1U',false)set Rgv[68]='SS1V'call L1x('SS1V',false)set Rgv[69]='SS1W'call L1x('SS1W',false)set Rgv[70]='SS1X'call L1x('SS1X',false)set Rgv[71]='SS1Y'call L1x('SS1Y',false)set Rgv[72]='SS1Z'call L1x('SS1Z',false)set Rgv[73]='SS20'call L1x('SS20',false)set Rgv[74]='SS21'call L1x('SS21',false)set Rgv[75]='SS22'call L1x('SS22',false)set Rgv[76]='SS23'call L1x('SS23',false)set Rgv[77]='SS24'call L1x('SS24',false)set Rgv[78]='SS25'call L1x('SS25',false)set Rgv[79]='SS26'call L1x('SS26',false)set Rgv[80]='SS27'call L1x('SS27',false)set Rgv[81]='SS28'call L1x('SS28',false)set Rgv[82]='SS29'call L1x('SS29',false)set Rgv[83]='SS2A'call L1x('SS2A',false)set Rgv[84]='SS2B'call L1x('SS2B',false)set Rgv[85]='SS2C'call L1x('SS2C',false)set Rgv[86]='SS2D'call L1x('SS2D',false)set Rgv[87]='SS2E'call L1x('SS2E',false)set Rgv[88]='SS2F'call L1x('SS2F',false)set Rgv[89]='SS2G'call L1x('SS2G',false)set Rgv[90]='SS2H'call L1x('SS2H',false)set Rgv[91]='SS2I'call L1x('SS2I',false)set Rgv[92]='SS2J'call L1x('SS2J',false)set Rgv[93]='SS2K'call L1x('SS2K',false)set Rgv[94]='SS2L'call L1x('SS2L',false)set Rgv[95]='SS2M'call L1x('SS2M',false)set Rgv[96]='SS2N'call L1x('SS2N',false)set Rgv[97]='SS2O'call L1x('SS2O',false)set Rgv[98]='SS2P'call L1x('SS2P',false)set Rgv[99]='SS2Q'call L1x('SS2Q',false)set Rgv['d']='SS2R'call L1x('SS2R',false)set Rgv['e']='SS2S'call L1x('SS2S',false)set Rgv['f']='SS2T'call L1x('SS2T',false)set Rgv['g']='SS2U'call L1x('SS2U',false)set Rgv['h']='SS2V'call L1x('SS2V',false)set Rgv['i']='SS2W'call L1x('SS2W',false)set Rgv['j']='SS2X'call L1x('SS2X',false)set Rgv['k']='SS2Y'call L1x('SS2Y',false)set Rgv['l']='SS2Z'call L1x('SS2Z',false)set Rgv['m']='SS30'call L1x('SS30',false)set Rgv['n']='SS31'call L1x('SS31',false)set Rgv['o']='SS32'call L1x('SS32',false)set Rgv['p']='SS33'call L1x('SS33',false)set Rgv['q']='SS34'call L1x('SS34',false)set Rgv['r']='SS35'call L1x('SS35',false)set Rgv['s']='SS36'call L1x('SS36',false)set Rgv['t']='SS37'call L1x('SS37',false)set Rgv['u']='SS38'call L1x('SS38',false)set Rgv['v']='SS39'call L1x('SS39',false)set Rgv['w']='SS3A'call L1x('SS3A',false)set Rgv['x']='SS3B'call L1x('SS3B',false)set Rgv['y']='SS3C'call L1x('SS3C',false)set Rgv['z']='SS3D'call L1x('SS3D',false)set Rgv['{']='SS3E'call L1x('SS3E',false)set Rgv['|']='SS3F'call L1x('SS3F',false)set Rgv['}']='SS3G'call L1x('SS3G',false)set Rgv[$7E]='SS3H'call L1x('SS3H',false)set Rgv[$7F]='SS3I'call L1x('SS3I',false)set Rgv[$80]='SS3J'call L1x('SS3J',false)set Rgv[$81]='SS3K'call L1x('SS3K',false)set Rgv[$82]='SS3L'call L1x('SS3L',false)set Rgv[$83]='SS3M'call L1x('SS3M',false)set Rgv[$84]='SS3N'call L1x('SS3N',false)set Rgv[$85]='SS3O'call L1x('SS3O',false)set Rgv[$86]='SS3P'call L1x('SS3P',false)set Rgv[$87]='SS3Q'call L1x('SS3Q',false)set Rgv[$88]='SS3R'call L1x('SS3R',false)set Rgv[$89]='SS3S'call L1x('SS3S',false)set Rgv[$8A]='SS3T'call L1x('SS3T',false)set Rgv[$8B]='SS3U'call L1x('SS3U',false)set Rgv[$8C]='SS3V'call L1x('SS3V',false)set Rgv[$8D]='SS3W'call L1x('SS3W',false)set Rgv[$8E]='SS3X'call L1x('SS3X',false)set Rgv[$8F]='SS3Y'call L1x('SS3Y',false)set Rgv[$90]='SS3Z'call L1x('SS3Z',false)set Rgv[$91]='SS40'call L1x('SS40',false)set Rgv[$92]='SS41'call L1x('SS41',false)set Rgv[$93]='SS42'call L1x('SS42',false)set Rgv[$94]='SS43'call L1x('SS43',false)set Rgv[$95]='SS44'call L1x('SS44',false)set Rgv[$96]='SS45'call L1x('SS45',false)set Rgv[$97]='SS46'call L1x('SS46',false)set Rgv[$98]='SS47'call L1x('SS47',false)set Rgv[$99]='SS48'call L1x('SS48',false)set Rgv[$9A]='SS49'call L1x('SS49',false)set Rgv[$9B]='SS4A'call L1x('SS4A',false)set Rgv[$9C]='SS4B'call L1x('SS4B',false)set Rgv[$9D]='SS4C'call L1x('SS4C',false)set Rgv[$9E]='SS4D'call L1x('SS4D',false)set Rgv[$9F]='SS4E'call L1x('SS4E',false)set Rgv[$A0]='SS4F'call L1x('SS4F',false)set Rgv[$A1]='SS4G'call L1x('SS4G',false)set Rgv[$A2]='SS4H'call L1x('SS4H',false)set Rgv[$A3]='SS4I'call L1x('SS4I',false)set Rgv[$A4]='SS4J'call L1x('SS4J',false)set Rgv[$A5]='SS4K'call L1x('SS4K',false)set Rgv[$A6]='SS4L'call L1x('SS4L',false)set Rgv[$A7]='SS4M'call L1x('SS4M',false)set Rgv[$A8]='SS4N'call L1x('SS4N',false)set Rgv[$A9]='SS4O'call L1x('SS4O',false)set Rgv[$AA]='SS4P'call L1x('SS4P',false)set Rgv[$AB]='SS4Q'call L1x('SS4Q',false)set Rgv[$AC]='SS4R'call L1x('SS4R',false)set Rgv[$AD]='SS4S'call L1x('SS4S',false)set Rgv[$AE]='SS4T'call L1x('SS4T',false)set Rgv[$AF]='SS4U'call L1x('SS4U',false)set Rgv[$B0]='SS4V'call L1x('SS4V',false)set Rgv[$B1]='SS4W'call L1x('SS4W',false)set Rgv[$B2]='SS4X'call L1x('SS4X',false)set Rgv[$B3]='SS4Y'call L1x('SS4Y',false)set Rgv[$B4]='SS4Z'call L1x('SS4Z',false)set Rgv[$B5]='SS50'call L1x('SS50',false)set Rgv[$B6]='SS51'call L1x('SS51',false)set Rgv[$B7]='SS52'call L1x('SS52',false)set Rgv[$B8]='SS53'call L1x('SS53',false)set Rgv[$B9]='SS54'call L1x('SS54',false)set Rgv[$BA]='SS55'call L1x('SS55',false)set Rgv[$BB]='SS56'call L1x('SS56',false)set Rgv[$BC]='SS57'call L1x('SS57',false)set Rgv[$BD]='SS58'call L1x('SS58',false)set Rgv[$BE]='SS59'call L1x('SS59',false)set Rgv[$BF]='SS5A'call L1x('SS5A',false)set Rgv[$C0]='SS5B'call L1x('SS5B',false)set Rgv[$C1]='SS5C'call L1x('SS5C',false)set Rgv[$C2]='SS5D'call L1x('SS5D',false)set Rgv[$C3]='SS5E'call L1x('SS5E',false)set Rgv[$C4]='SS5F'call L1x('SS5F',false)set Rgv[$C5]='SS5G'call L1x('SS5G',false)set Rgv[$C6]='SS5H'call L1x('SS5H',false)set Rgv[$C7]='SS5I'call L1x('SS5I',false)set Rgv[$C8]='SS5J'call L1x('SS5J',false)set Rgv[$C9]='SS5K'call L1x('SS5K',false)set Rgv[$CA]='SS5L'call L1x('SS5L',false)set Rgv[$CB]='SS5M'call L1x('SS5M',false)set Rgv[$CC]='SS5N'call L1x('SS5N',false)set Rgv[$CD]='SS5O'call L1x('SS5O',false)set Rgv[$CE]='SS5P'call L1x('SS5P',false)set Rgv[$CF]='SS5Q'call L1x('SS5Q',false)set Rgv[$D0]='SS5R'call L1x('SS5R',false)set Rgv[$D1]='SS5S'call L1x('SS5S',false)set Rgv[$D2]='SS5T'call L1x('SS5T',false)set Rgv[$D3]='SS5U'call L1x('SS5U',false)set Rgv[$D4]='SS5V'call L1x('SS5V',false)set Rgv[$D5]='SS5W'call L1x('SS5W',false)set Rgv[$D6]='SS5X'call L1x('SS5X',false)set Rgv[$D7]='SS5Y'call L1x('SS5Y',false)set Rgv[$D8]='SS5Z'call L1x('SS5Z',false)set Rgv[$D9]='SS60'call L1x('SS60',false)set Rgv[$DA]='SS61'call L1x('SS61',false)set Rgv[$DB]='SS62'call L1x('SS62',false)set Rgv[$DC]='SS63'call L1x('SS63',false)set Rgv[$DD]='SS64'call L1x('SS64',false)set Rgv[$DE]='SS65'call L1x('SS65',false)set Rgv[$DF]='SS66'call L1x('SS66',false)set Rgv[$E0]='SS67'call L1x('SS67',false)set Rgv[$E1]='SS68'call L1x('SS68',false)set Rgv[$E2]='SS69'call L1x('SS69',false)set Rgv[$E3]='SS6A'call L1x('SS6A',false)set Rgv[$E4]='SS6B'call L1x('SS6B',false)set Rgv[$E5]='SS6C'call L1x('SS6C',false)set Rgv[$E6]='SS6D'call L1x('SS6D',false)set Rgv[$E7]='SS6E'call L1x('SS6E',false)set Rgv[$E8]='SS6F'call L1x('SS6F',false)set Rgv[$E9]='SS6G'call L1x('SS6G',false)set Rgv[$EA]='SS6H'call L1x('SS6H',false)set Rgv[$EB]='SS6I'call L1x('SS6I',false)set Rgv[$EC]='SS6J'call L1x('SS6J',false)set Rgv[$ED]='SS6K'call L1x('SS6K',false)set Rgv[$EE]='SS6L'call L1x('SS6L',false)set Rgv[$EF]='SS6M'call L1x('SS6M',false)set Rgv[$F0]='SS6N'call L1x('SS6N',false)set Rgv[$F1]='SS6O'call L1x('SS6O',false)set Rgv[$F2]='SS6P'call L1x('SS6P',false)set Rgv[$F3]='SS6Q'call L1x('SS6Q',false)set Rgv[$F4]='SS6R'call L1x('SS6R',false)set Rgv[$F5]='SS6S'call L1x('SS6S',false)set Rgv[$F6]='SS6T'call L1x('SS6T',false)set Rgv[$F7]='SS6U'call L1x('SS6U',false)set Rgv[$F8]='SS6V'call L1x('SS6V',false)set Rgv[$F9]='SS6W'call L1x('SS6W',false)set Rgv[$FA]='SS6X'call L1x('SS6X',false)set Rgv[$FB]='SS6Y'call L1x('SS6Y',false)set Rgv[$FC]='SS6Z'call L1x('SS6Z',false)set Rgv[$FD]='SS70'call L1x('SS70',false)set Rgv[$FE]='SS71'call L1x('SS71',false)set Rgv[$FF]='SS72'call L1x('SS72',false)set Rgv[256]='SS73'call L1x('SS73',false)set RGv[1]='TS00'call L1x('TS00',false)set RGv[2]='TS01'call L1x('TS01',false)set RGv[3]='TS02'call L1x('TS02',false)set RGv[4]='TS03'call L1x('TS03',false)set RGv[5]='TS04'call L1x('TS04',false)set RGv[6]='TS05'call L1x('TS05',false)set RGv[7]='TS06'call L1x('TS06',false)set RGv[8]='TS07'call L1x('TS07',false)set RGv[9]='TS08'call L1x('TS08',false)set RGv[$A]='TS09'call L1x('TS09',false)set RGv[$B]='TS0A'call L1x('TS0A',false)set RGv[$C]='TS0B'call L1x('TS0B',false)set RGv[$D]='TS0C'call L1x('TS0C',false)set RGv[$E]='TS0D'call L1x('TS0D',false)set RGv[$F]='TS0E'call L1x('TS0E',false)set RGv[16]='TS0F'call L1x('TS0F',false)set RGv[17]='TS0G'call L1x('TS0G',false)set RGv[18]='TS0H'call L1x('TS0H',false)set RGv[19]='TS0I'call L1x('TS0I',false)set RGv[20]='TS0J'call L1x('TS0J',false)set RGv[21]='TS0K'call L1x('TS0K',false)set RGv[22]='TS0L'call L1x('TS0L',false)set RGv[23]='TS0M'call L1x('TS0M',false)set RGv[24]='TS0N'call L1x('TS0N',false)set RGv[25]='TS0O'call L1x('TS0O',false)set RGv[26]='TS0P'call L1x('TS0P',false)set RGv[27]='TS0Q'call L1x('TS0Q',false)set RGv[28]='TS0R'call L1x('TS0R',false)set RGv[29]='TS0S'call L1x('TS0S',false)set RGv[30]='TS0T'call L1x('TS0T',false)set RGv[31]='TS0U'call L1x('TS0U',false)set RGv[32]='TS0V'call L1x('TS0V',false)set RGv[33]='TS0W'call L1x('TS0W',false)set RGv[34]='TS0X'call L1x('TS0X',false)set RGv[35]='TS0Y'call L1x('TS0Y',false)set RGv[36]='TS0Z'call L1x('TS0Z',false)set RGv[37]='TS10'call L1x('TS10',false)set RGv[38]='TS11'call L1x('TS11',false)set RGv[39]='TS12'call L1x('TS12',false)set RGv[40]='TS13'call L1x('TS13',false)set RGv[41]='TS14'call L1x('TS14',false)set RGv[42]='TS15'call L1x('TS15',false)set RGv[43]='TS16'call L1x('TS16',false)set RGv[44]='TS17'call L1x('TS17',false)set RGv[45]='TS18'call L1x('TS18',false)set RGv[46]='TS19'call L1x('TS19',false)set RGv[47]='TS1A'call L1x('TS1A',false)set RGv[48]='TS1B'call L1x('TS1B',false)set RGv[49]='TS1C'call L1x('TS1C',false)set RGv[50]='TS1D'call L1x('TS1D',false)set RGv[51]='TS1E'call L1x('TS1E',false)set RGv[52]='TS1F'call L1x('TS1F',false)set RGv[53]='TS1G'call L1x('TS1G',false)set RGv[54]='TS1H'call L1x('TS1H',false)set RGv[55]='TS1I'call L1x('TS1I',false)set RGv[56]='TS1J'call L1x('TS1J',false)set RGv[57]='TS1K'call L1x('TS1K',false)set RGv[58]='TS1L'call L1x('TS1L',false)set RGv[59]='TS1M'call L1x('TS1M',false)set RGv[60]='TS1N'call L1x('TS1N',false)set RGv[61]='TS1O'call L1x('TS1O',false)set RGv[62]='TS1P'call L1x('TS1P',false)set RGv[63]='TS1Q'call L1x('TS1Q',false)set RGv[64]='TS1R'call L1x('TS1R',false)set RGv[65]='TS1S'call L1x('TS1S',false)set RGv[66]='TS1T'call L1x('TS1T',false)set RGv[67]='TS1U'call L1x('TS1U',false)set RGv[68]='TS1V'call L1x('TS1V',false)set RGv[69]='TS1W'call L1x('TS1W',false)set RGv[70]='TS1X'call L1x('TS1X',false)set RGv[71]='TS1Y'call L1x('TS1Y',false)set RGv[72]='TS1Z'call L1x('TS1Z',false)set RGv[73]='TS20'call L1x('TS20',false)set RGv[74]='TS21'call L1x('TS21',false)set RGv[75]='TS22'call L1x('TS22',false)set RGv[76]='TS23'call L1x('TS23',false)set RGv[77]='TS24'call L1x('TS24',false)set RGv[78]='TS25'call L1x('TS25',false)set RGv[79]='TS26'call L1x('TS26',false)set RGv[80]='TS27'call L1x('TS27',false)set RGv[81]='TS28'call L1x('TS28',false)set RGv[82]='TS29'call L1x('TS29',false)set RGv[83]='TS2A'call L1x('TS2A',false)set RGv[84]='TS2B'call L1x('TS2B',false)set RGv[85]='TS2C'call L1x('TS2C',false)set RGv[86]='TS2D'call L1x('TS2D',false)set RGv[87]='TS2E'call L1x('TS2E',false)set RGv[88]='TS2F'call L1x('TS2F',false)set RGv[89]='TS2G'call L1x('TS2G',false)set RGv[90]='TS2H'call L1x('TS2H',false)set RGv[91]='TS2I'call L1x('TS2I',false)set RGv[92]='TS2J'call L1x('TS2J',false)set RGv[93]='TS2K'call L1x('TS2K',false)set RGv[94]='TS2L'call L1x('TS2L',false)set RGv[95]='TS2M'call L1x('TS2M',false)set RGv[96]='TS2N'call L1x('TS2N',false)set RGv[97]='TS2O'call L1x('TS2O',false)set RGv[98]='TS2P'call L1x('TS2P',false)set RGv[99]='TS2Q'call L1x('TS2Q',false)set RGv['d']='TS2R'call L1x('TS2R',false)set RGv['e']='TS2S'call L1x('TS2S',false)set RGv['f']='TS2T'call L1x('TS2T',false)set RGv['g']='TS2U'call L1x('TS2U',false)set RGv['h']='TS2V'call L1x('TS2V',false)set RGv['i']='TS2W'call L1x('TS2W',false)set RGv['j']='TS2X'call L1x('TS2X',false)set RGv['k']='TS2Y'call L1x('TS2Y',false)set RGv['l']='TS2Z'call L1x('TS2Z',false)set RGv['m']='TS30'call L1x('TS30',false)set RGv['n']='TS31'call L1x('TS31',false)set RGv['o']='TS32'call L1x('TS32',false)set RGv['p']='TS33'call L1x('TS33',false)set RGv['q']='TS34'call L1x('TS34',false)set RGv['r']='TS35'call L1x('TS35',false)set RGv['s']='TS36'call L1x('TS36',false)set RGv['t']='TS37'call L1x('TS37',false)set RGv['u']='TS38'call L1x('TS38',false)set RGv['v']='TS39'call L1x('TS39',false)set RGv['w']='TS3A'call L1x('TS3A',false)set RGv['x']='TS3B'call L1x('TS3B',false)set RGv['y']='TS3C'call L1x('TS3C',false)set RGv['z']='TS3D'call L1x('TS3D',false)set RGv['{']='TS3E'call L1x('TS3E',false)set RGv['|']='TS3F'call L1x('TS3F',false)set RGv['}']='TS3G'call L1x('TS3G',false)set RGv[$7E]='TS3H'call L1x('TS3H',false)set RGv[$7F]='TS3I'call L1x('TS3I',false)set RGv[$80]='TS3J'call L1x('TS3J',false)set RGv[$81]='TS3K'call L1x('TS3K',false)set RGv[$82]='TS3L'call L1x('TS3L',false)set RGv[$83]='TS3M'call L1x('TS3M',false)set RGv[$84]='TS3N'call L1x('TS3N',false)set RGv[$85]='TS3O'call L1x('TS3O',false)set RGv[$86]='TS3P'call L1x('TS3P',false)set RGv[$87]='TS3Q'call L1x('TS3Q',false)set RGv[$88]='TS3R'call L1x('TS3R',false)set RGv[$89]='TS3S'call L1x('TS3S',false)set RGv[$8A]='TS3T'call L1x('TS3T',false)set RGv[$8B]='TS3U'call L1x('TS3U',false)set RGv[$8C]='TS3V'call L1x('TS3V',false)set RGv[$8D]='TS3W'call L1x('TS3W',false)set RGv[$8E]='TS3X'call L1x('TS3X',false)set RGv[$8F]='TS3Y'call L1x('TS3Y',false)set RGv[$90]='TS3Z'call L1x('TS3Z',false)set RGv[$91]='TS40'call L1x('TS40',false)set RGv[$92]='TS41'call L1x('TS41',false)set RGv[$93]='TS42'call L1x('TS42',false)set RGv[$94]='TS43'call L1x('TS43',false)set RGv[$95]='TS44'call L1x('TS44',false)set RGv[$96]='TS45'call L1x('TS45',false)set RGv[$97]='TS46'call L1x('TS46',false)set RGv[$98]='TS47'call L1x('TS47',false)set RGv[$99]='TS48'call L1x('TS48',false)set RGv[$9A]='TS49'call L1x('TS49',false)set RGv[$9B]='TS4A'call L1x('TS4A',false)set RGv[$9C]='TS4B'call L1x('TS4B',false)set RGv[$9D]='TS4C'call L1x('TS4C',false)set RGv[$9E]='TS4D'call L1x('TS4D',false)set RGv[$9F]='TS4E'call L1x('TS4E',false)set RGv[$A0]='TS4F'call L1x('TS4F',false)set RGv[$A1]='TS4G'call L1x('TS4G',false)set RGv[$A2]='TS4H'call L1x('TS4H',false)set RGv[$A3]='TS4I'call L1x('TS4I',false)set RGv[$A4]='TS4J'call L1x('TS4J',false)set RGv[$A5]='TS4K'call L1x('TS4K',false)set RGv[$A6]='TS4L'call L1x('TS4L',false)set RGv[$A7]='TS4M'call L1x('TS4M',false)set RGv[$A8]='TS4N'call L1x('TS4N',false)set RGv[$A9]='TS4O'call L1x('TS4O',false)set RGv[$AA]='TS4P'call L1x('TS4P',false)set RGv[$AB]='TS4Q'call L1x('TS4Q',false)set RGv[$AC]='TS4R'call L1x('TS4R',false)set RGv[$AD]='TS4S'call L1x('TS4S',false)set RGv[$AE]='TS4T'call L1x('TS4T',false)set RGv[$AF]='TS4U'call L1x('TS4U',false)set RGv[$B0]='TS4V'call L1x('TS4V',false)set RGv[$B1]='TS4W'call L1x('TS4W',false)set RGv[$B2]='TS4X'call L1x('TS4X',false)set RGv[$B3]='TS4Y'call L1x('TS4Y',false)set RGv[$B4]='TS4Z'call L1x('TS4Z',false)set RGv[$B5]='TS50'call L1x('TS50',false)set RGv[$B6]='TS51'call L1x('TS51',false)set RGv[$B7]='TS52'call L1x('TS52',false)set RGv[$B8]='TS53'call L1x('TS53',false)set RGv[$B9]='TS54'call L1x('TS54',false)set RGv[$BA]='TS55'call L1x('TS55',false)set RGv[$BB]='TS56'call L1x('TS56',false)set RGv[$BC]='TS57'call L1x('TS57',false)set RGv[$BD]='TS58'call L1x('TS58',false)set RGv[$BE]='TS59'call L1x('TS59',false)set RGv[$BF]='TS5A'call L1x('TS5A',false)set RGv[$C0]='TS5B'call L1x('TS5B',false)set RGv[$C1]='TS5C'call L1x('TS5C',false)set RGv[$C2]='TS5D'call L1x('TS5D',false)set RGv[$C3]='TS5E'call L1x('TS5E',false)set RGv[$C4]='TS5F'call L1x('TS5F',false)set RGv[$C5]='TS5G'call L1x('TS5G',false)set RGv[$C6]='TS5H'call L1x('TS5H',false)set RGv[$C7]='TS5I'call L1x('TS5I',false)set RGv[$C8]='TS5J'call L1x('TS5J',false)set RGv[$C9]='TS5K'call L1x('TS5K',false)set RGv[$CA]='TS5L'call L1x('TS5L',false)set RGv[$CB]='TS5M'call L1x('TS5M',false)set RGv[$CC]='TS5N'call L1x('TS5N',false)set RGv[$CD]='TS5O'call L1x('TS5O',false)set RGv[$CE]='TS5P'call L1x('TS5P',false)set RGv[$CF]='TS5Q'call L1x('TS5Q',false)set RGv[$D0]='TS5R'call L1x('TS5R',false)set RGv[$D1]='TS5S'call L1x('TS5S',false)set RGv[$D2]='TS5T'call L1x('TS5T',false)set RGv[$D3]='TS5U'call L1x('TS5U',false)set RGv[$D4]='TS5V'call L1x('TS5V',false)set RGv[$D5]='TS5W'call L1x('TS5W',false)set RGv[$D6]='TS5X'call L1x('TS5X',false)set RGv[$D7]='TS5Y'call L1x('TS5Y',false)set RGv[$D8]='TS5Z'call L1x('TS5Z',false)set RGv[$D9]='TS60'call L1x('TS60',false)set RGv[$DA]='TS61'call L1x('TS61',false)set RGv[$DB]='TS62'call L1x('TS62',false)set RGv[$DC]='TS63'call L1x('TS63',false)set RGv[$DD]='TS64'call L1x('TS64',false)set RGv[$DE]='TS65'call L1x('TS65',false)set RGv[$DF]='TS66'call L1x('TS66',false)set RGv[$E0]='TS67'call L1x('TS67',false)set RGv[$E1]='TS68'call L1x('TS68',false)set RGv[$E2]='TS69'call L1x('TS69',false)set RGv[$E3]='TS6A'call L1x('TS6A',false)set RGv[$E4]='TS6B'call L1x('TS6B',false)set RGv[$E5]='TS6C'call L1x('TS6C',false)set RGv[$E6]='TS6D'call L1x('TS6D',false)set RGv[$E7]='TS6E'call L1x('TS6E',false)set RGv[$E8]='TS6F'call L1x('TS6F',false)set RGv[$E9]='TS6G'call L1x('TS6G',false)set RGv[$EA]='TS6H'call L1x('TS6H',false)set RGv[$EB]='TS6I'call L1x('TS6I',false)set RGv[$EC]='TS6J'call L1x('TS6J',false)set RGv[$ED]='TS6K'call L1x('TS6K',false)set RGv[$EE]='TS6L'call L1x('TS6L',false)set RGv[$EF]='TS6M'call L1x('TS6M',false)set RGv[$F0]='TS6N'call L1x('TS6N',false)set RGv[$F1]='TS6O'call L1x('TS6O',false)set RGv[$F2]='TS6P'call L1x('TS6P',false)set RGv[$F3]='TS6Q'call L1x('TS6Q',false)set RGv[$F4]='TS6R'call L1x('TS6R',false)set RGv[$F5]='TS6S'call L1x('TS6S',false)set RGv[$F6]='TS6T'call L1x('TS6T',false)set RGv[$F7]='TS6U'call L1x('TS6U',false)set RGv[$F8]='TS6V'call L1x('TS6V',false)set RGv[$F9]='TS6W'call L1x('TS6W',false)set RGv[$FA]='TS6X'call L1x('TS6X',false)set RGv[$FB]='TS6Y'call L1x('TS6Y',false)set RGv[$FC]='TS6Z'call L1x('TS6Z',false)set RGv[$FD]='TS70'call L1x('TS70',false)set RGv[$FE]='TS71'call L1x('TS71',false)set RGv[$FF]='TS72'call L1x('TS72',false)set RGv[256]='TS73'call L1x('TS73',false)return trueendfunctionfunction E8o takes nothing returns booleanset Rhv[1]='SS00'set Rhv[2]='SS01'set Rhv[3]='SS02'set Rhv[4]='SS03'set Rhv[5]='SS04'set Rhv[6]='SS05'set Rhv[7]='SS06'set Rhv[8]='SS07'set Rhv[9]='SS08'set Rhv[$A]='SS09'set Rhv[$B]='SS0A'set Rhv[$C]='SS0B'set Rhv[$D]='SS0C'set Rhv[$E]='SS0D'set Rhv[$F]='SS0E'set Rhv[16]='SS0F'set Rhv[17]='SS0G'set Rhv[18]='SS0H'set Rhv[19]='SS0I'set Rhv[20]='SS0J'set Rhv[21]='SS0K'set Rhv[22]='SS0L'set Rhv[23]='SS0M'set Rhv[24]='SS0N'set Rhv[25]='SS0O'set Rhv[26]='SS0P'set Rhv[27]='SS0Q'set Rhv[28]='SS0R'set Rhv[29]='SS0S'set Rhv[30]='SS0T'set Rhv[31]='SS0U'set Rhv[32]='SS0V'set Rhv[33]='SS0W'set Rhv[34]='SS0X'set Rhv[35]='SS0Y'set Rhv[36]='SS0Z'set Rhv[37]='SS10'set Rhv[38]='SS11'set Rhv[39]='SS12'set Rhv[40]='SS13'set Rhv[41]='SS14'set Rhv[42]='SS15'set Rhv[43]='SS16'set Rhv[44]='SS17'set Rhv[45]='SS18'set Rhv[46]='SS19'set Rhv[47]='SS1A'set Rhv[48]='SS1B'set Rhv[49]='SS1C'set Rhv[50]='SS1D'set Rhv[51]='SS1E'set Rhv[52]='SS1F'set Rhv[53]='SS1G'set Rhv[54]='SS1H'set Rhv[55]='SS1I'set Rhv[56]='SS1J'set Rhv[57]='SS1K'set Rhv[58]='SS1L'set Rhv[59]='SS1M'set Rhv[60]='SS1N'set Rhv[61]='SS1O'set Rhv[62]='SS1P'set Rhv[63]='SS1Q'set Rhv[64]='SS1R'set Rhv[65]='SS1S'set Rhv[66]='SS1T'set Rhv[67]='SS1U'set Rhv[68]='SS1V'set Rhv[69]='SS1W'set Rhv[70]='SS1X'set Rhv[71]='SS1Y'set Rhv[72]='SS1Z'set Rhv[73]='SS20'set Rhv[74]='SS21'set Rhv[75]='SS22'set Rhv[76]='SS23'set Rhv[77]='SS24'set Rhv[78]='SS25'set Rhv[79]='SS26'set Rhv[80]='SS27'set Rhv[81]='SS28'set Rhv[82]='SS29'set Rhv[83]='SS2A'set Rhv[84]='SS2B'set Rhv[85]='SS2C'set Rhv[86]='SS2D'set Rhv[87]='SS2E'set Rhv[88]='SS2F'set Rhv[89]='SS2G'set Rhv[90]='SS2H'set Rhv[91]='SS2I'set Rhv[92]='SS2J'set Rhv[93]='SS2K'set Rhv[94]='SS2L'set Rhv[95]='SS2M'set Rhv[96]='SS2N'set Rhv[97]='SS2O'set Rhv[98]='SS2P'set Rhv[99]='SS2Q'set Rhv['d']='SS2R'set Rhv['e']='SS2S'set Rhv['f']='SS2T'set Rhv['g']='SS2U'set Rhv['h']='SS2V'set Rhv['i']='SS2W'set Rhv['j']='SS2X'set Rhv['k']='SS2Y'set Rhv['l']='SS2Z'set Rhv['m']='SS30'set Rhv['n']='SS31'set Rhv['o']='SS32'set Rhv['p']='SS33'set Rhv['q']='SS34'set Rhv['r']='SS35'set Rhv['s']='SS36'set Rhv['t']='SS37'set Rhv['u']='SS38'set Rhv['v']='SS39'set Rhv['w']='SS3A'set Rhv['x']='SS3B'set Rhv['y']='SS3C'set Rhv['z']='SS3D'set Rhv['{']='SS3E'set Rhv['|']='SS3F'set Rhv['}']='SS3G'set Rhv[$7E]='SS3H'set Rhv[$7F]='SS3I'set Rhv[$80]='SS3J'set Rhv[$81]='SS3K'set Rhv[$82]='SS3L'set Rhv[$83]='SS3M'set Rhv[$84]='SS3N'set Rhv[$85]='SS3O'set Rhv[$86]='SS3P'set Rhv[$87]='SS3Q'set Rhv[$88]='SS3R'set Rhv[$89]='SS3S'set Rhv[$8A]='SS3T'set Rhv[$8B]='SS3U'set Rhv[$8C]='SS3V'set Rhv[$8D]='SS3W'set Rhv[$8E]='SS3X'set Rhv[$8F]='SS3Y'set Rhv[$90]='SS3Z'set Rhv[$91]='SS40'set Rhv[$92]='SS41'set Rhv[$93]='SS42'set Rhv[$94]='SS43'set Rhv[$95]='SS44'set Rhv[$96]='SS45'set Rhv[$97]='SS46'set Rhv[$98]='SS47'set Rhv[$99]='SS48'set Rhv[$9A]='SS49'set Rhv[$9B]='SS4A'set Rhv[$9C]='SS4B'set Rhv[$9D]='SS4C'set Rhv[$9E]='SS4D'set Rhv[$9F]='SS4E'set Rhv[$A0]='SS4F'set Rhv[$A1]='SS4G'set Rhv[$A2]='SS4H'set Rhv[$A3]='SS4I'set Rhv[$A4]='SS4J'set Rhv[$A5]='SS4K'set Rhv[$A6]='SS4L'set Rhv[$A7]='SS4M'set Rhv[$A8]='SS4N'set Rhv[$A9]='SS4O'set Rhv[$AA]='SS4P'set Rhv[$AB]='SS4Q'set Rhv[$AC]='SS4R'set Rhv[$AD]='SS4S'set Rhv[$AE]='SS4T'set Rhv[$AF]='SS4U'set Rhv[$B0]='SS4V'set Rhv[$B1]='SS4W'set Rhv[$B2]='SS4X'set Rhv[$B3]='SS4Y'set Rhv[$B4]='SS4Z'set Rhv[$B5]='SS50'set Rhv[$B6]='SS51'set Rhv[$B7]='SS52'set Rhv[$B8]='SS53'set Rhv[$B9]='SS54'set Rhv[$BA]='SS55'set Rhv[$BB]='SS56'set Rhv[$BC]='SS57'set Rhv[$BD]='SS58'set Rhv[$BE]='SS59'set Rhv[$BF]='SS5A'set Rhv[$C0]='SS5B'set Rhv[$C1]='SS5C'set Rhv[$C2]='SS5D'set Rhv[$C3]='SS5E'set Rhv[$C4]='SS5F'set Rhv[$C5]='SS5G'set Rhv[$C6]='SS5H'set Rhv[$C7]='SS5I'set Rhv[$C8]='SS5J'set Rhv[$C9]='SS5K'set Rhv[$CA]='SS5L'set Rhv[$CB]='SS5M'set Rhv[$CC]='SS5N'set Rhv[$CD]='SS5O'set Rhv[$CE]='SS5P'set Rhv[$CF]='SS5Q'set Rhv[$D0]='SS5R'set Rhv[$D1]='SS5S'set Rhv[$D2]='SS5T'set Rhv[$D3]='SS5U'set Rhv[$D4]='SS5V'set Rhv[$D5]='SS5W'set Rhv[$D6]='SS5X'set Rhv[$D7]='SS5Y'set Rhv[$D8]='SS5Z'set Rhv[$D9]='SS60'set Rhv[$DA]='SS61'set Rhv[$DB]='SS62'set Rhv[$DC]='SS63'set Rhv[$DD]='SS64'set Rhv[$DE]='SS65'set Rhv[$DF]='SS66'set Rhv[$E0]='SS67'set Rhv[$E1]='SS68'set Rhv[$E2]='SS69'set Rhv[$E3]='SS6A'set Rhv[$E4]='SS6B'set Rhv[$E5]='SS6C'set Rhv[$E6]='SS6D'set Rhv[$E7]='SS6E'set Rhv[$E8]='SS6F'set Rhv[$E9]='SS6G'set Rhv[$EA]='SS6H'set Rhv[$EB]='SS6I'set Rhv[$EC]='SS6J'set Rhv[$ED]='SS6K'set Rhv[$EE]='SS6L'set Rhv[$EF]='SS6M'set Rhv[$F0]='SS6N'set Rhv[$F1]='SS6O'set Rhv[$F2]='SS6P'set Rhv[$F3]='SS6Q'set Rhv[$F4]='SS6R'set Rhv[$F5]='SS6S'set Rhv[$F6]='SS6T'set Rhv[$F7]='SS6U'set Rhv[$F8]='SS6V'set Rhv[$F9]='SS6W'set Rhv[$FA]='SS6X'set Rhv[$FB]='SS6Y'set Rhv[$FC]='SS6Z'set Rhv[$FD]='SS70'set Rhv[$FE]='SS71'set Rhv[$FF]='SS72'set Rhv[256]='SS73'set RHv[1]='TS00'set RHv[2]='TS01'set RHv[3]='TS02'set RHv[4]='TS03'set RHv[5]='TS04'set RHv[6]='TS05'set RHv[7]='TS06'set RHv[8]='TS07'set RHv[9]='TS08'set RHv[$A]='TS09'set RHv[$B]='TS0A'set RHv[$C]='TS0B'set RHv[$D]='TS0C'set RHv[$E]='TS0D'set RHv[$F]='TS0E'set RHv[16]='TS0F'set RHv[17]='TS0G'set RHv[18]='TS0H'set RHv[19]='TS0I'set RHv[20]='TS0J'set RHv[21]='TS0K'set RHv[22]='TS0L'set RHv[23]='TS0M'set RHv[24]='TS0N'set RHv[25]='TS0O'set RHv[26]='TS0P'set RHv[27]='TS0Q'set RHv[28]='TS0R'set RHv[29]='TS0S'set RHv[30]='TS0T'set RHv[31]='TS0U'set RHv[32]='TS0V'set RHv[33]='TS0W'set RHv[34]='TS0X'set RHv[35]='TS0Y'set RHv[36]='TS0Z'set RHv[37]='TS10'set RHv[38]='TS11'set RHv[39]='TS12'set RHv[40]='TS13'set RHv[41]='TS14'set RHv[42]='TS15'set RHv[43]='TS16'set RHv[44]='TS17'set RHv[45]='TS18'set RHv[46]='TS19'set RHv[47]='TS1A'set RHv[48]='TS1B'set RHv[49]='TS1C'set RHv[50]='TS1D'set RHv[51]='TS1E'set RHv[52]='TS1F'set RHv[53]='TS1G'set RHv[54]='TS1H'set RHv[55]='TS1I'set RHv[56]='TS1J'set RHv[57]='TS1K'set RHv[58]='TS1L'set RHv[59]='TS1M'set RHv[60]='TS1N'set RHv[61]='TS1O'set RHv[62]='TS1P'set RHv[63]='TS1Q'set RHv[64]='TS1R'set RHv[65]='TS1S'set RHv[66]='TS1T'set RHv[67]='TS1U'set RHv[68]='TS1V'set RHv[69]='TS1W'set RHv[70]='TS1X'set RHv[71]='TS1Y'set RHv[72]='TS1Z'set RHv[73]='TS20'set RHv[74]='TS21'set RHv[75]='TS22'set RHv[76]='TS23'set RHv[77]='TS24'set RHv[78]='TS25'set RHv[79]='TS26'set RHv[80]='TS27'set RHv[81]='TS28'set RHv[82]='TS29'set RHv[83]='TS2A'set RHv[84]='TS2B'set RHv[85]='TS2C'set RHv[86]='TS2D'set RHv[87]='TS2E'set RHv[88]='TS2F'set RHv[89]='TS2G'set RHv[90]='TS2H'set RHv[91]='TS2I'set RHv[92]='TS2J'set RHv[93]='TS2K'set RHv[94]='TS2L'set RHv[95]='TS2M'set RHv[96]='TS2N'set RHv[97]='TS2O'set RHv[98]='TS2P'set RHv[99]='TS2Q'set RHv['d']='TS2R'set RHv['e']='TS2S'set RHv['f']='TS2T'set RHv['g']='TS2U'set RHv['h']='TS2V'set RHv['i']='TS2W'set RHv['j']='TS2X'set RHv['k']='TS2Y'set RHv['l']='TS2Z'set RHv['m']='TS30'set RHv['n']='TS31'set RHv['o']='TS32'set RHv['p']='TS33'set RHv['q']='TS34'set RHv['r']='TS35'set RHv['s']='TS36'set RHv['t']='TS37'set RHv['u']='TS38'set RHv['v']='TS39'set RHv['w']='TS3A'set RHv['x']='TS3B'set RHv['y']='TS3C'set RHv['z']='TS3D'set RHv['{']='TS3E'set RHv['|']='TS3F'set RHv['}']='TS3G'set RHv[$7E]='TS3H'set RHv[$7F]='TS3I'set RHv[$80]='TS3J'set RHv[$81]='TS3K'set RHv[$82]='TS3L'set RHv[$83]='TS3M'set RHv[$84]='TS3N'set RHv[$85]='TS3O'set RHv[$86]='TS3P'set RHv[$87]='TS3Q'set RHv[$88]='TS3R'set RHv[$89]='TS3S'set RHv[$8A]='TS3T'set RHv[$8B]='TS3U'set RHv[$8C]='TS3V'set RHv[$8D]='TS3W'set RHv[$8E]='TS3X'set RHv[$8F]='TS3Y'set RHv[$90]='TS3Z'set RHv[$91]='TS40'set RHv[$92]='TS41'set RHv[$93]='TS42'set RHv[$94]='TS43'set RHv[$95]='TS44'set RHv[$96]='TS45'set RHv[$97]='TS46'set RHv[$98]='TS47'set RHv[$99]='TS48'set RHv[$9A]='TS49'set RHv[$9B]='TS4A'set RHv[$9C]='TS4B'set RHv[$9D]='TS4C'set RHv[$9E]='TS4D'set RHv[$9F]='TS4E'set RHv[$A0]='TS4F'set RHv[$A1]='TS4G'set RHv[$A2]='TS4H'set RHv[$A3]='TS4I'set RHv[$A4]='TS4J'set RHv[$A5]='TS4K'set RHv[$A6]='TS4L'set RHv[$A7]='TS4M'set RHv[$A8]='TS4N'set RHv[$A9]='TS4O'set RHv[$AA]='TS4P'set RHv[$AB]='TS4Q'set RHv[$AC]='TS4R'set RHv[$AD]='TS4S'set RHv[$AE]='TS4T'set RHv[$AF]='TS4U'set RHv[$B0]='TS4V'set RHv[$B1]='TS4W'set RHv[$B2]='TS4X'set RHv[$B3]='TS4Y'set RHv[$B4]='TS4Z'set RHv[$B5]='TS50'set RHv[$B6]='TS51'set RHv[$B7]='TS52'set RHv[$B8]='TS53'set RHv[$B9]='TS54'set RHv[$BA]='TS55'set RHv[$BB]='TS56'set RHv[$BC]='TS57'set RHv[$BD]='TS58'set RHv[$BE]='TS59'set RHv[$BF]='TS5A'set RHv[$C0]='TS5B'set RHv[$C1]='TS5C'set RHv[$C2]='TS5D'set RHv[$C3]='TS5E'set RHv[$C4]='TS5F'set RHv[$C5]='TS5G'set RHv[$C6]='TS5H'set RHv[$C7]='TS5I'set RHv[$C8]='TS5J'set RHv[$C9]='TS5K'set RHv[$CA]='TS5L'set RHv[$CB]='TS5M'set RHv[$CC]='TS5N'set RHv[$CD]='TS5O'set RHv[$CE]='TS5P'set RHv[$CF]='TS5Q'set RHv[$D0]='TS5R'set RHv[$D1]='TS5S'set RHv[$D2]='TS5T'set RHv[$D3]='TS5U'set RHv[$D4]='TS5V'set RHv[$D5]='TS5W'set RHv[$D6]='TS5X'set RHv[$D7]='TS5Y'set RHv[$D8]='TS5Z'set RHv[$D9]='TS60'set RHv[$DA]='TS61'set RHv[$DB]='TS62'set RHv[$DC]='TS63'set RHv[$DD]='TS64'set RHv[$DE]='TS65'set RHv[$DF]='TS66'set RHv[$E0]='TS67'set RHv[$E1]='TS68'set RHv[$E2]='TS69'set RHv[$E3]='TS6A'set RHv[$E4]='TS6B'set RHv[$E5]='TS6C'set RHv[$E6]='TS6D'set RHv[$E7]='TS6E'set RHv[$E8]='TS6F'set RHv[$E9]='TS6G'set RHv[$EA]='TS6H'set RHv[$EB]='TS6I'set RHv[$EC]='TS6J'set RHv[$ED]='TS6K'set RHv[$EE]='TS6L'set RHv[$EF]='TS6M'set RHv[$F0]='TS6N'set RHv[$F1]='TS6O'set RHv[$F2]='TS6P'set RHv[$F3]='TS6Q'set RHv[$F4]='TS6R'set RHv[$F5]='TS6S'set RHv[$F6]='TS6T'set RHv[$F7]='TS6U'set RHv[$F8]='TS6V'set RHv[$F9]='TS6W'set RHv[$FA]='TS6X'set RHv[$FB]='TS6Y'set RHv[$FC]='TS6Z'set RHv[$FD]='TS70'set RHv[$FE]='TS71'set RHv[$FF]='TS72'set RHv[256]='TS73'return trueendfunctionfunction E9o takes nothing returns booleancall VNx(Pa,(function E7o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\SightRange\\obj_spells_wc3objLuaspells.j"))call VNx(va,(function E8o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\SightRange\\obj_spells_wc3objLuainits.j"))
return trueendfunctionfunction Xvo takes nothing returns booleanset Rjv=VXx(RJv)
return trueendfunctionfunction Xeo takes nothing returns booleanset Rkv=VXx(RKv)
return trueendfunctionfunction Xxo takes nothing returns booleanreturn trueendfunctionfunction Xoo takes nothing returns booleanset Rlv=VXx(RLv)
return trueendfunctionfunction Xro takes nothing returns booleanset Rmv=VXx(RMv)
return trueendfunctionfunction Xio takes nothing returns booleanset Rpv=VXx(RPv)
return trueendfunctionfunction Xao takes nothing returns booleanset Rqv=VXx(RQv)
return trueendfunctionfunction Xno takes nothing returns booleanset Rsv=VXx(RSv)
return trueendfunctionfunction XVo takes nothing returns booleanreturn trueendfunctionfunction XEo takes nothing returns booleanset Rtv=VXx(RTv)
return trueendfunctionfunction XXo takes nothing returns booleanset Ruv=VXx(RUv)
return trueendfunctionfunction XOo takes nothing returns booleanset Rwv=VXx(RWv)
return trueendfunctionfunction XRo takes nothing returns booleanset Ryv=VXx(RYv)
return trueendfunctionfunction XIo takes nothing returns booleanset Rzv=VXx(RZv)
return trueendfunctionfunction XAo takes nothing returns booleanreturn trueendfunctionfunction XNo takes nothing returns booleanset R_v=VXx(R0v)
return trueendfunctionfunction Xbo takes nothing returns booleanset R1v=VXx(R2v)
return trueendfunctionfunction XBo takes nothing returns booleanset R3v=VXx(R4v)
return trueendfunctionfunction Xco takes nothing returns booleanset R5v=VXx(R6v)
return trueendfunctionfunction XCo takes nothing returns booleanset R7v=VXx(R8v)
return trueendfunctionfunction Xdo takes nothing returns booleanreturn trueendfunctionfunction XDo takes nothing returns booleanset R9v=VXx(Ivv)
return trueendfunctionfunction Xfo takes nothing returns booleanset Iev=VXx(Ixv)
return trueendfunctionfunction XFo takes nothing returns booleancall L1x('Apit',false)return trueendfunctionfunction Xgo takes nothing returns booleancall L1x('Ane2',false)return trueendfunctionfunction XGo takes nothing returns booleancall L1x('AInv',false)return trueendfunctionfunction Xho takes nothing returns booleancall L1x('Aneu',false)return trueendfunctionfunction XHo takes nothing returns booleancall VNx(Pa,(function XFo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\obj_purchaseItem_wc3spell.j"))
call VNx(Pa,(function Xgo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\obj_sharedShop_wc3spell.j"))call VNx(Pa,(function XGo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\obj_heroInventorySpell_wc3spell.j"))call VNx(Pa,(function Xho),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\Unit.page\\Unit.struct\\obj_selectHero_wc3spell.j"))return trueendfunctionfunction Xjo takes nothing returns booleanset Iov=VXx(Irv)
return trueendfunctionfunction XJo takes code c,string rSx returns nothing
set YV=YV+1set zV[YV]=CreateTrigger()set ZV[YV]=(GetHandleId(Condition((c))))
set vE[YV]=rSxcall TriggerAddCondition(zV[YV],Condition(c))endfunctionfunction Xko takes unit oqx returns integerset C[db]=oqxcall rDx(Iiv)if(Rb==w)thencall MDx(oqx)endifreturn Rbendfunctionfunction XKo takes nothing returns booleanlocal integer rFx=(bv)local unit Xlo=GetEnumUnit()
local integer XLoif(GetUnitTypeId(Xlo)==0)thencall MDx(Xlo)set Xlo=null
return trueendifset XLo=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((Xlo)))))),((((ix))))))if(XLo==w)thenset XLo=Xko(Xlo)
endifif(XLo==w)thenreturn trueendifcall Nbx((XLo),(aiv),(1),w,((10.)*1.))call CCx(XLo)return trueendfunctionfunction Xmo takes nothing returns booleanlocal group XMo=CreateGroup()call GroupEnumUnitsInRect(XMo,bm[Bm],null)call ForGroup(XMo,function XKo)call DestroyGroup(XMo)set XMo=null
return trueendfunctionfunction Xpo takes nothing returns booleancall XJo(function Xmo,"Unit_InitPreplaced")return trueendfunctionfunction XPo takes code c,string rSx returns nothing
set Ia=Ia+1set Aa[Ia]=CreateTrigger()set Na[Ia]=(GetHandleId(Condition((c))))
set ba[Ia]=rSxcall TriggerAddCondition(Aa[Ia],Condition(c))endfunctionfunction Xqo takes nothing returns nothingendfunctionfunction XQo takes nothing returns nothingendfunctionfunction Xso takes nothing returns nothingendfunctionfunction XSo takes nothing returns nothinglocal integer oMx=Fg
loop
exitwhen(oMx<0)set Gg[oMx]=CreateItem('Idd0'+oMx,.0,.0)
set oMx=oMx-1endloopset oMx=hgloop
exitwhen(oMx<0)set Hg[oMx]=CreateItem('Iid0'+oMx,.0,.0)
set oMx=oMx-1endloopcall Xso()endfunctionfunction Xto takes nothing returns nothingendfunctionfunction XTo takes nothing returns nothingendfunctionfunction Xuo takes nothing returns nothingendfunctionfunction XUo takes nothing returns nothingcall Xto()call XTo()call Xuo()endfunctionfunction Xwo takes nothing returns nothingcall Xqo()call XQo()call XSo()call XUo()endfunctionfunction XWo takes integer oSx returns integerset IOv[oSx]=trueset IRv[oSx]=falseset IIv[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])call rEx(etv)return oSxendfunctionfunction Xyo takes nothing returns integerlocal integer oSxif(Inv==8190)thencall o_x("UnitClass_Allocation_allocCustom","call DebugEx(UnitClass.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",eTv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(IVv[(w)]==w)thenset IEv=IEv+1set oSx=IEvelse
set oSx=IVv[(w)]
set IVv[(w)]=IVv[IVv[(w)]]endifset IVv[oSx]=Zset IXv[oSx]=1call XWo(oSx)return oSxendfunctionfunction XYo takes integer oSx returns booleanset INv=INv+1set Ibv[INv]=oSx
set IBv[oSx]=INv+1return(INv==0)endfunctionfunction Xzo takes integer oSx returns nothingset Icv[(oSx)]=(ICv+oSx)
endfunctionfunction XZo takes string rSx returns integerlocal integer oSx=Xyo()set IAv[(oSx)]=(rSx)
call XYo(oSx)call Xzo(oSx)return oSxendfunctionfunction X_o takes nothing returns nothingset Iav=XZo("air")set Qc=XZo("dead")set Idv=XZo("ground")set Wd=XZo("hero")set IDv=XZo("illusion")set Ifv=XZo("mechanical")set IFv=XZo("neutral")set Igv=XZo("structure")
set IGv=XZo("summon")set Ihv=XZo("undecayable")set IHv=XZo("upgraded")set Ijv=XZo("ward")endfunctionfunction X0o takes nothing returns nothingendfunctionfunction X1o takes integer oqx returns integerreturn(LoadInteger(o[((V[(E[((X))])]))],(((oqx))),(((ff)))))
endfunctionfunction X2o takes integer oSx,string oux returns nothingset Si[oSx]=Si[oSx]+";"+ouxendfunctionfunction X3o takes integer oSx returns integerset IMv[oSx]=trueset Ipv[oSx]=falseset I[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set Rv[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(Iov)return oSxendfunctionfunction X4o takes nothing returns integerlocal integer oSxif(IKv==8190)thencall o_x("Unit_Allocation_allocCustom","call DebugEx(Unit.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Irv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Ilv[(w)]==w)thenset ILv=ILv+1set oSx=ILvelse
set oSx=Ilv[(w)]
set Ilv[(w)]=Ilv[Ilv[(w)]]endifset Ilv[oSx]=Zset Imv[oSx]=1call X3o(oSx)return oSxendfunctionfunction X5o takes integer oSx returns nothinglocal integer oux=GetHandleId(C[(oSx)])set A[(oSx)]=(oux)call SaveInteger(o[((V[(E[((X))])]))],(((RK+oux))),(((IK))),(((oSx))))endfunctionfunction X6o takes integer oSx returns nothingset MT[oSx]=0set pT[oSx]=falseendfunctionfunction X7o takes integer oSx,real oux returns nothingset IPv[oSx]=oux
call SetUnitTimeScale(C[(oSx)],oux)endfunctionfunction X8o takes integer oSx returns nothingset vF[oSx]=.0set eF[(oSx)]=.0
set Zf[(oSx)]=.0
call bmx(oSx)endfunctionfunction X9o takes integer oSx returns nothingset EZv[(oSx)]=(((Iqv[(oSx)])+(IQv[(oSx)]))*1.)endfunctionfunction Ovo takes integer oSx returns nothingset EZv[oSx]=.0set Iqv[(oSx)]=.0set IQv[(oSx)]=.0call X9o(oSx)endfunctionfunction Oeo takes integer oSx returns nothingset oF[oSx]=.0set rF[(oSx)]=.0
set xF[(oSx)]=.0
call bPx(oSx)endfunctionfunction Oxo takes integer oSx returns nothingset Isv[(oSx)]=(((ISv[(oSx)])+(Itv[(oSx)]))*1.)endfunctionfunction Ooo takes integer oSx returns nothingset Isv[oSx]=.0set ISv[(oSx)]=.0set Itv[(oSx)]=.0call Oxo(oSx)endfunctionfunction Oro takes integer oSx returns nothingcall bfx(oSx,GetHeroXP(C[(oSx)]))endfunctionfunction Oio takes integer oSx returns nothingset rk[(oSx)]=(false)set nyv[(oSx)]=(false)set npv[((oSx))]=(false)
endfunctionfunction Oao takes integer oSx returns nothingset aYv[(oSx)]=(false)set aTv[((oSx))]=(false)
endfunctionfunction Ono takes integer oSx,integer oux returns nothingset ze[oSx]=ouxcall abx((oSx),(ox[(oux)]))endfunctionfunction OVo takes integer oSx returns nothingcall rtx((oSx),'aFly')call UnitRemoveAbility(C[(((oSx)))],('aFly'))endfunctionfunction OEo takes integer oSx returns nothingset Tf[oSx]=X1o(GetUnitTypeId(C[(oSx)]))
endfunctionfunction OXo takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((Jw[(oSx)]))])]))],((((kw[((oSx))])))),(((otx))))))endfunctionfunction OOo takes integer oSx returns integerreturn(OXo(((oSx)),Iwv))
endfunctionfunction ORo takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((Jw[(oSx)]))])]))],((((kw[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction OIo takes integer oSx,integer oLx returns integerreturn(ORo(((oSx)),Iwv,(oLx)))endfunctionfunction OAo takes integer oSx,integer rlx,integer oux returns nothingcall r0x(oSx,rlx,(osx(((oSx)),N+(rlx)))+oux)
endfunctionfunction ONo takes integer oSx,integer oLx returns integerreturn(Lnx(((oSx)),IWv+(oLx)))endfunctionfunction Obo takes integer oSx returns nothingset Uh[oSx]=wcall dQx(IYv,oSx)set xHv[(oSx)]=false
endfunctionfunction OBo takes integer oSx returns nothingcall dQx(Iyv,(oSx))call Obo(oSx)call dQx(Izv,(oSx))endfunctionfunction Oco takes integer rlx,integer OSx returns nothingcall rnx(OSx,I2v,rlx)call rVx(OSx,I0v+(K6[(rlx)]))call CRx(OSx,QUx(rlx))call rpx(OSx,rlx)call rtx(OSx,(I3v[((rlx))]))
endfunctionfunction OCo takes integer rlx,integer OSx returns nothinglocal integer Odo=(K6[(rlx)])local integer ODo=(osx((OSx),I0v+(Odo)))
local integer rYx=rWx(OSx,ODo)if(ODo!=w)thencall Oco(ODo,OSx)endifcall rUx(OSx,I2v,rlx)call rwx(OSx,I0v+Odo,rlx)call CRx(OSx,(I3v[((rlx))]))
call r0x(OSx,rlx,rYx)if(rYx<(m6[(rlx)]))thencall rZx(OSx,QUx(rlx),rYx+1)
endifendfunctionfunction Ofo takes integer oSx,integer oLx returns integerreturn Lnx((oSx),I4v+oLx)endfunctionfunction OFo takes integer oSx returns nothinglocal integer rlxlocal integer Gpx=(Tf[((oSx))])local integer oMx=OOo(Gpx)set mb[(oSx)]=wloop
exitwhen(oMx<0)set rlx=OIo(Gpx,oMx)
call OAo(oSx,rlx,ONo(Gpx,rlx))set oMx=oMx-1endloopcall OBo(oSx)set oMx=(IZv[(Gpx)])
loop
exitwhen(oMx<0)call OCo(Ofo(Gpx,oMx),oSx)set oMx=oMx-1endloopendfunctionfunction Ogo takes integer oSx returns nothingset I7v[oSx]=(I8v[((Tf[((oSx))]))])endfunctionfunction OGo takes integer oSx returns nothingset Avv[oSx]=.0set Aev[oSx]=.0set Axv[oSx]=falseendfunctionfunction Oho takes integer oSx returns nothingset I9v[oSx]=.0call OGo(oSx)endfunctionfunction OHo takes integer oSx returns nothingset Arv[oSx]=1.set Aiv[(oSx)]=1.endfunctionfunction Ojo takes integer oSx returns nothingset Aav[(oSx)]=((Anv[((Tf[((oSx))]))]))endfunctionfunction OJo takes integer oSx,unit oqx,real nZx,real bzx returns nothinglocal integer bZxlocal integer b_xset nZx=nZx*1set bzx=bzx*1if(nZx*bzx<=.0)thenif(bzx<.0)thenset b_x=AEvloop
call UnitRemoveAbility(oqx,v2v[b_x])
set b_x=b_x-1exitwhen(b_x<0)endloopelse
set b_x=AXvloop
call UnitRemoveAbility(oqx,v3v[b_x])
set b_x=b_x-1exitwhen(b_x<0)endloopendifif(nZx<.0)thenset nZx=-nZx
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(AEv)))*1.)))
loop
exitwhen(nZx<1.)
set bZx=v4v[b_x]
if(bZx<=nZx)then
set nZx=nZx-bZxcall UnitAddAbility(oqx,v2v[b_x])endifset b_x=b_x-1endloopelse
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(AXv)))*1.)))
loop
exitwhen(nZx<1.)
set bZx=v4v[b_x]
if(bZx<=nZx)then
set nZx=nZx-bZxcall UnitAddAbility(oqx,v3v[b_x])endifset b_x=b_x-1endloopendifelse
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(AEv)))*1.)))
if(nZx<.0)thenset nZx=-nZx
loop
exitwhen(b_x<0)set bZx=v4v[b_x]
if(bZx<=nZx)then
set nZx=nZx-bZxcall UnitAddAbility(oqx,v2v[b_x])else
call UnitRemoveAbility(oqx,v2v[b_x])
endifset b_x=b_x-1endloopelse
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(AXv)))*1.)))
loop
exitwhen(b_x<0)set bZx=v4v[b_x]
if(bZx<=nZx)then
set nZx=nZx-bZxelse
call UnitRemoveAbility(oqx,v3v[b_x])
endifset b_x=b_x-1endloopendifendifendfunctionfunction Oko takes integer oSx,real oux,real aCx returns nothing
set Aev[oSx]=oux
call OJo(AOv,C[(oSx)],oux,aCx)endfunctionfunction OKo takes integer oSx,real oux returns nothinglocal real b2x=Aev[oSx]set Avv[oSx]=oux
if(oux==b2x)then
if Axv[oSx]thenset Axv[oSx]=falsecall RPx((oSx),AVv)endifreturnendifif B0x((oSx))thenif not Axv[oSx]thenset Axv[oSx]=truecall Avx((oSx),AVv)endifelse
call Oko(oSx,oux,b2x)endifendfunctionfunction Olo takes integer oSx returns nothingcall OKo((oSx),(((I7v[((oSx))])*((Arv[((oSx))])-1)+(I9v[((oSx))]))*1.))endfunctionfunction OLo takes integer oSx,real oux returns nothingset EYv[oSx]=oux
call Olo(oSx)endfunctionfunction Omo takes integer oSx returns nothinglocal real cxx=(I7v[(oSx)])local real crx=(Arv[(oSx)])local real cox=(I9v[(oSx)])set I5v[oSx]=cxx*crx+cox
set I6v[oSx]=cxx*(crx-1)+cox
call OLo(oSx,cxx*crx*(Aiv[(oSx)])+cox)endfunctionfunction OMo takes integer oSx returns nothingset EYv[oSx]=.0set I5v[oSx]=.0set I6v[oSx]=.0call Ogo(oSx)call Oho(oSx)set Aov[(((oSx)))]=((.0)*1.)
call OHo(oSx)set E0v[((oSx))]=((.0)*1.)set Eyv[((oSx))]=((.0)*1.)call Ojo(oSx)call Omo(oSx)endfunctionfunction Opo takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((Jw[(oSx)]))])]))],((((kw[((oSx))])))),(((otx))))))endfunctionfunction OPo takes integer oSx returns integerreturn Opo((oSx),ARv)endfunctionfunction Oqo takes integer oSx,integer otx,integer oLx returns stringreturn(LoadStr(o[((V[(E[((Jw[(oSx)]))])]))],((((kw[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction OQo takes integer oSx,integer oLx returns stringreturn Oqo((oSx),ARv,oLx)endfunctionfunction Oso takes integer oSx,integer oLx returns stringreturn Oqo((oSx),AIv,oLx)endfunctionfunction OSo takes integer oSx,integer oLx returns integerreturn ORo((oSx),AAv,oLx)endfunctionfunction Oto takes integer oSx returns nothinglocal integer OTo=(Tf[((oSx))])local integer oMx=OPo(OTo)loop
exitwhen(oMx<q)call ACx((((oSx))),((OQo(OTo,oMx))),((Oso(OTo,oMx))),((OSo(OTo,oMx))))set oMx=oMx-1endloopendfunctionfunction Ouo takes integer oSx returns nothingset Acv[oSx]=falsecall Avx((oSx),ACv)endfunctionfunction OUo takes integer oSx returns integerreturn(Adv[((Tf[((oSx))]))])
endfunctionfunction Owo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])if(OUo(rLx)==ADv)thencall Avx(rLx,Afv)call Avx(rLx,AFv)endifreturn trueendfunctionfunction OWo takes integer oSx returns nothingcall TriggerRegisterUnitEvent(DA[((ANv))],C[(oSx)],(EVENT_UNIT_ACQUIRED_TARGET))
call TriggerRegisterUnitEvent(DA[((Abv))],C[(oSx)],(EVENT_UNIT_TARGET_IN_RANGE))
call dQx(ABv,oSx)call Ouo(oSx)call Owo()endfunctionfunction Oyo takes integer oSx returns nothingset Agv[(oSx)]=(((AGv[((Tf[((oSx))]))]))*1.)
endfunctionfunction OYo takes integer oSx returns nothingset uf[oSx]=(Ahv[((Tf[((oSx))]))])endfunctionfunction Ozo takes integer oSx returns nothingset wf[oSx]=.0set CF[(oSx)]=.0
endfunctionfunction OZo takes integer oSx returns nothingcall OYo(oSx)call Ozo(oSx)call bJx(oSx)endfunctionfunction O_o takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((Jw[(oSx)]))])]))],((((kw[((oSx))])))),(((otx))))))endfunctionfunction O0o takes integer oSx returns integerreturn O_o((oSx),AHv)endfunctionfunction O1o takes integer oSx returns integerset ALv[oSx]=trueset Amv[oSx]=falsecall rEx(elv)return oSxendfunctionfunction O2o takes nothing returns integerlocal integer oSxif(AJv==8190)thencall o_x("UnitAttackSplash_Allocation_allocCustom","call DebugEx(UnitAttackSplash.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",eLv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Akv[(w)]==w)thenset AKv=AKv+1set oSx=AKvelse
set oSx=Akv[(w)]
set Akv[(w)]=Akv[Akv[(w)]]endifset Akv[oSx]=Zset Alv[oSx]=1call O1o(oSx)return oSxendfunctionfunction O3o takes real O4o,real O5o returns integer
local integer oSx=O2o()set AMv[oSx]=O4o
set Apv[oSx]=O5o
return oSxendfunctionfunction O6o takes integer oSx,real O4o,real O5o returns integer
local integer O7o=O3o(O4o,O5o)call rUx((oSx),APv,O7o)return O7oendfunctionfunction O8o takes integer oSx,integer otx,integer oLx returns realreturn(LoadReal(o[((V[(E[((Jw[(oSx)]))])]))],((((kw[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction O9o takes integer oSx,integer oLx returns realreturn O8o((oSx),AHv,oLx)endfunctionfunction Rvo takes integer oSx,integer oLx returns realreturn O8o((oSx),Aqv,oLx)endfunctionfunction Reo takes integer oSx returns nothinglocal integer Gpx=(Tf[((oSx))])local integer oMx=O0o(Gpx)loop
exitwhen(oMx<q)call rUx((oSx),Ajv,O6o(oSx,O9o(Gpx,oMx),Rvo(Gpx,oMx)))set oMx=oMx-1endloopendfunctionfunction Rxo takes integer oSx returns nothingset rYv[(oSx)]=(true)call OWo(oSx)call Oyo(oSx)call OZo(oSx)call Reo(oSx)endfunctionfunction Roo takes integer oSx returns nothingset EUv[(oSx)]=((AQv[((Tf[((oSx))]))]))endfunctionfunction Rro takes integer oSx returns nothingset nJv[(oSx)]=((nKv[((Tf[((oSx))]))]))set Asv[(oSx)]=(null)endfunctionfunction Rio takes integer oSx returns integerreturn OXo((oSx),ASv)endfunctionfunction Rao takes integer oSx,integer rNx returns nothingif I9x(oSx,rNx)thencall o_x("FolderUnit_StructClasses_Add","call DebugEx(FolderUnit_StructClasses.NAME + \": \" + Unit(this).GetName() + \" is already of class \" + whichType.GetName())",o3v+": "+(GetUnitName(C[((oSx))]))+" is already of class "+(IAv[(rNx)]))
returnendifcall dQx(qc[(rNx)],oSx)endfunctionfunction Rno takes integer oSx,integer oLx returns integerreturn ORo((oSx),ASv,oLx)endfunctionfunction RVo takes integer oSx returns nothinglocal integer Gpx=(Tf[((oSx))])local integer oMx=Rio(Gpx)call Avx((oSx),Atv)loop
exitwhen(oMx<q)call Rao(oSx,Rno(Gpx,oMx))set oMx=oMx-1endloopendfunctionfunction REo takes integer oSx returns nothingset UH[oSx]=(ATv[((Tf[((oSx))]))])endfunctionfunction RXo takes integer oSx returns nothinglocal integer Gpx=(Tf[((oSx))])set cg[oSx]=(Auv[(Gpx)])
set Bg[oSx]=(AUv[(Gpx)])
set Cg[oSx]=falseendfunctionfunction ROo takes integer oSx returns nothingset bg[oSx]=(Auv[((Tf[((oSx))]))])call RXo(oSx)endfunctionfunction RRo takes integer oSx returns nothingset Mg[oSx]=.0set mg[oSx]=.0set pg[oSx]=falseendfunctionfunction RIo takes integer oSx returns nothingset Jg[oSx]=.0call RRo(oSx)endfunctionfunction RAo takes integer oSx returns nothingset Awv[(oSx)]=(((AWv[((Tf[((oSx))]))]))*1.)
endfunctionfunction RNo takes integer oSx returns nothingset Ayv[(oSx)]=((AYv[((Tf[((oSx))]))]))endfunctionfunction Rbo takes integer oSx returns nothingset kg[oSx]=1.set ug[(oSx)]=1.
endfunctionfunction RBo takes integer oSx returns nothingset AZv[(oSx)]=((A_v[((Tf[((oSx))]))]))endfunctionfunction Rco takes integer oSx returns nothingset A1v[(oSx)]=((A2v[((Tf[((oSx))]))]))endfunctionfunction RCo takes integer oSx returns nothingset Lg[oSx]=.0call ROo(oSx)call RIo(oSx)call RAo(oSx)call RNo(oSx)call TriggerRegisterUnitEvent(DA[((Azv))],C[((oSx))],(EVENT_UNIT_DAMAGED))call Rbo(oSx)call RBo(oSx)set A0v[((oSx))]=((1.)*1.)call Rco(oSx)call cex(oSx)endfunctionfunction Rdo takes integer oSx returns nothingcall dQx(A3v,(oSx))set iG[((oSx))]=(false)endfunctionfunction RDo takes integer oSx returns nothingset A4v[(oSx)]=(((A5v[((Tf[((oSx))]))]))*1.)
endfunctionfunction Rfo takes integer oSx returns nothingcall RDo(oSx)call dQx(A6v,(oSx))endfunctionfunction RFo takes integer oSx returns integerreturn OXo((oSx),A7v)endfunctionfunction Rgo takes integer oSx,integer oux returns nothingif rUx((oSx),A8v,oux)thencall Avx((oSx),A9v)endifcall Avx((oSx),(Nvv[(oux)]))
call ACx(((oSx)),((Nev[(oux)])),((Nxv[(oux)])),((Nov[(oux)])))endfunctionfunction RGo takes integer oSx,integer oLx returns integerreturn ORo((oSx),A7v,oLx)endfunctionfunction Rho takes integer oSx returns nothingset Nrv[(oSx)]=((Niv[((Tf[((oSx))]))]))endfunctionfunction RHo takes integer oSx returns nothingset Nav[(oSx)]=((Nnv[((Tf[((oSx))]))]))endfunctionfunction Rjo takes integer oSx returns nothinglocal integer rNx=(Tf[((oSx))])local integer oMx=RFo(rNx)loop
exitwhen(oMx<q)call Rgo(oSx,RGo(rNx,oMx))set oMx=oMx-1endloopcall Rho(oSx)call RHo(oSx)endfunctionfunction RJo takes integer oSx returns nothingif(I9x((oSx),Igv)or I9x((oSx),Ijv))thenset NVv[(oSx)]=(0)else
set NVv[(oSx)]=(1)endifendfunctionfunction Rko takes integer oSx returns nothingset Cu[oSx]=(NOv[((Tf[((oSx))]))])endfunctionfunction RKo takes integer oSx returns nothingset NEv[(oSx)]=.0set NXv[(oSx)]=.0call Rko(oSx)endfunctionfunction Rlo takes boolean oqx returns integerif oqx thenreturn 1
endifreturn 0
endfunctionfunction RLo takes integer oSx returns nothingset NIv[(oSx)]=(Rlo((NAv[((Tf[((oSx))]))])))
endfunctionfunction Rmo takes integer oSx returns nothingset NRv[oSx]=falsecall RLo(oSx)endfunctionfunction RMo takes integer oSx returns nothingset NBv[oSx]=(Ncv[((Tf[((oSx))]))])endfunctionfunction Rpo takes integer oSx,integer nZx returns nothinglocal integer BGxlocal integer Bhxif(nZx<0)thenset nZx=-nZx
set BGx=nZx/ NDv
set nZx=nZx-BGx*NDvloop
exitwhen(BGx<1)call rtx((oSx),Nfv)call rZx((oSx),Nfv,2)call UnitRemoveAbility(C[(((oSx)))],(Nfv))set BGx=BGx-1endloopset Bhx=RHv[nZx]
call rtx((oSx),Bhx)call rZx((oSx),Bhx,2)call UnitRemoveAbility(C[(((oSx)))],(Bhx))else
set BGx=nZx/ NFv
set nZx=nZx-BGx*NFvloop
exitwhen(BGx<1)call rtx((oSx),Ngv)call rZx((oSx),Ngv,2)call UnitRemoveAbility(C[(((oSx)))],(Ngv))set BGx=BGx-1endloopset Bhx=Rhv[nZx]
call rtx((oSx),Bhx)call rZx((oSx),Bhx,2)call UnitRemoveAbility(C[(((oSx)))],(Bhx))endifendfunctionfunction RPo takes integer oSx,real oux returns nothinglocal real aCx=NNv[oSx]if(aCx==oux)then
returnendifset NNv[oSx]=oux
call Rpo(oSx,(R2I(((oux-aCx)*1.))))endfunctionfunction Rqo takes integer oSx returns nothingcall RPo(oSx,(NBv[(oSx)])*(Ndv[(oSx)])+(NCv[(oSx)]))
endfunctionfunction RQo takes integer oSx returns nothingset NNv[oSx]=(Nbv[((Tf[((oSx))]))])call RMo(oSx)set NCv[(oSx)]=.0set Ndv[(oSx)]=1.call Rqo(oSx)endfunctionfunction Rso takes integer oSx returns nothingset yF[oSx]=(NGv[((Tf[((oSx))]))])endfunctionfunction RSo takes integer oSx returns nothingset YF[oSx]=.0set zF[oSx]=.0call Rso(oSx)set vg[(oSx)]=.0
set ZF[(oSx)]=1.
call BLx(oSx)endfunctionfunction Rto takes integer oSx returns nothingset NHv[oSx]=(Njv[((Tf[((oSx))]))])endfunctionfunction RTo takes integer oSx,real oux returns nothingset Nhv[oSx]=oux-(NHv[(oSx)])set E5v[oSx]=oux
endfunctionfunction Ruo takes integer oSx returns nothingcall RTo(oSx,(NHv[(oSx)])*(Nkv[(oSx)])+(NJv[(oSx)]))
endfunctionfunction RUo takes integer oSx returns nothingset Nhv[oSx]=.0set E5v[oSx]=.0call Rto(oSx)set NJv[(oSx)]=.0set Nkv[(oSx)]=1.call Ruo(oSx)endfunctionfunction Rwo takes integer oSx returns nothingset wg[oSx]=(NKv[((Tf[((oSx))]))])endfunctionfunction RWo takes integer oSx returns nothingset Wg[oSx]=.0call Rwo(oSx)set HG[(oSx)]=.0
set VXv[((oSx))]=(false)
set hG[(oSx)]=1.
call cmx(oSx)endfunctionfunction Ryo takes integer oSx returns nothingset FF[oSx]=(Nlv[((Tf[((oSx))]))])endfunctionfunction RYo takes integer oSx returns nothingset gF[oSx]=.0call Ryo(oSx)set pF[(oSx)]=.0
set VLv[((oSx))]=(false)
set MF[(oSx)]=1.
call BDx(oSx)endfunctionfunction Rzo takes integer oSx returns nothingset JG[oSx]=(Nmv[((Tf[((oSx))]))])endfunctionfunction RZo takes integer oSx returns nothingset rG[oSx]=(NLv[((Tf[((oSx))]))])call Rzo(oSx)set PG[(oSx)]=.0
set pG[(oSx)]=1.
call cSx(oSx)endfunctionfunction R_o takes integer oSx returns nothingset qF[oSx]=(Npv[((Tf[((oSx))]))])endfunctionfunction R0o takes integer oSx returns nothingset LF[oSx]=(NMv[((Tf[((oSx))]))])call R_o(oSx)set wF[(oSx)]=.0
set UF[(oSx)]=1.
call BJx(oSx)endfunctionfunction R1o takes integer oSx returns nothingcall Dux((((oSx))),(x5v),(1),w)call UnitRemoveAbility(C[(((oSx)))],('Amov'))endfunctionfunction R2o takes integer oSx returns nothingset NQv[oSx]=(NPv[((Tf[((oSx))]))])endfunctionfunction R3o takes integer oSx returns nothingset Nsv[oSx]=.0call rtx((oSx),'AmSx')endfunctionfunction R4o takes integer oSx returns reallocal real nYx=(NTv[((oSx))])if(nYx>0)thenreturn((Nuv[(oSx)])*1./ nYx)
endifreturn 1.endfunctionfunction R5o takes integer oSx,real oux returns real
if((NTv[((oSx))])>0)then
set oux=100.+(oux-100.)*((1.2-.6)*R4o((oSx))+.6)
endifset oux=iAx(100.,oux)set oux=iUx(oux,522.)return ouxendfunctionfunction R6o takes integer oSx,real oux returns nothinglocal real cox=oux-(NQv[(oSx)])local real R7o=(NPv[((Tf[((oSx))]))])set Ntv[oSx]=cox
set Nqv[oSx]=oux
call SetUnitMoveSpeed(C[(oSx)],R5o(oSx,oux)-jwx(cox))if(R7o>0)thencall SetUnitTimeScale(C[(oSx)],oux*1./ R7o)endifendfunctionfunction R8o takes integer oSx returns nothingcall R6o(oSx,(NQv[(oSx)])*(NSv[(oSx)])+(Nsv[(oSx)]))
endfunctionfunction R9o takes integer oSx returns nothingset Nqv[oSx]=.0call R2o(oSx)call R3o(oSx)set NSv[(oSx)]=1.call R8o(oSx)endfunctionfunction Ivo takes integer oSx returns nothingif((NPv[((Tf[((oSx))]))])>.0)thenset V3v[(oSx)]=(true)else
call R1o(oSx)endifcall R9o(oSx)endfunctionfunction Ieo takes integer oSx returns nothingset vb[oSx]=(NWv[((Tf[((oSx))]))])endfunctionfunction Ixo takes integer oSx returns nothingset NUv[(oSx)]=.0set Nwv[(oSx)]=60.call Ieo(oSx)endfunctionfunction Ioo takes integer oSx returns nothingset eb[oSx]=(Uj[((Tf[((oSx))]))])set uj[(oSx)]=.0
endfunctionfunction Iro takes integer oSx returns nothinglocal integer Gpx=(Tf[((oSx))])set vk[oSx]=(Nyv[(Gpx)])
set ek[oSx]=(NYv[(Gpx)])
set xk[oSx]=(Nzv[(Gpx)])
set ok[oSx]=(NZv[(Gpx)])
endfunctionfunction Iio takes integer oSx returns nothingcall SetUnitMoveSpeed(C[(oSx)],R5o(oSx,(Nqv[(oSx)]))-jwx((Ntv[(oSx)])))endfunctionfunction Iao takes integer oSx returns nothingcall cCx((oSx),iSx("exhausted","ffffffff"),.021,N3v+oSx)
call Dux(((oSx)),(OLv),(1),w)endfunctionfunction Ino takes integer oSx,real oux returns nothinglocal real nYx=(NTv[((oSx))])local real aCx=(Nuv[(oSx)])set oux=blx(oux,.0,(NTv[((oSx))]))set Nuv[oSx]=oux
call Iio((oSx))if(nYx<=0)thenreturnendifif(((oux*1./ nYx)>N2v)==((aCx*1./ nYx)>N2v))then
returnendifif((oux*1./ nYx)>N2v)thencall Ulx(((oSx)),OLv)else
call Iao(oSx)endifendfunctionfunction IVo takes integer oSx,real oux returns nothinglocal real aCx=(NTv[(oSx)])set NTv[oSx]=oux
if(aCx==.0)thenreturnendifcall Ino((oSx),(Nuv[((oSx))])*1./ aCx*oux)endfunctionfunction IEo takes integer oSx returns nothingcall IVo(oSx,(N_v[(oSx)])*(N1v[(oSx)])+(N0v[(oSx)]))
endfunctionfunction IXo takes integer oSx returns nothingset NTv[oSx]=.0set N_v[(oSx)]=200.set N0v[(oSx)]=.0set N1v[(oSx)]=1.call IEo(oSx)endfunctionfunction IOo takes integer oSx,integer otx,integer oux returns booleanreturn rrx(nb[(oSx)],(Vb[((oSx))]),otx,oux)endfunctionfunction IRo takes integer oSx,integer oux returns nothingif not(I8x((oSx),Ob,(oux)))thencall o_x("UnitList_Remove","call DebugEx(UnitList.NAME + \" Remove: \" + value.GetName() + \" not in \" + this.GetName())",Nj+" Remove: "+(GetUnitName(C[(oux)]))+" not in "+(bj[(oSx)]))returnendifcall IOo(oSx,Ob,oux)
endfunctionfunction IIo takes integer oSx,real IAo returns nothinglocal integer rLx=oSxlocal integer rFx=rRx((A[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset biv[(rFx)]=((IAo)*1.)set Vv[(rFx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,bav,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(rLx,bav,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction INo takes integer oSx,real IAo returns nothinglocal integer rLx=oSxlocal integer rFx=rRx((A[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset biv[(rFx)]=((IAo)*1.)set Vv[(rFx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,bnv,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(rLx,bnv,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction Ibo takes nothing returns nothinglocal integer rLxlocal integer oSxlocal real x
local real y
local real IAoloop
set rLx=(dpx((N7v),Ob))exitwhen(rLx==w)
set oSx=rLxset x=Dsx(rLx)set y=Dtx(rLx)set IAo=GZx(x-bvv[oSx],y-bev[oSx])call dQx(bxv,rLx)if(I8x((bov),Ob,(rLx)))thenif(IAo<brv)thencall IRo(bov,rLx)call IIo(oSx,IAo)endifset bvv[oSx]=xset bev[oSx]=yelse
if(IAo>brv)thenset bvv[oSx]=xset bev[oSx]=ycall dQx(bov,rLx)call INo(oSx,IAo)endifendifendloopcall dyx(N7v,bxv)endfunctionfunction IBo takes integer oSx,integer XYx returns nothinglocal integer rLx=oSxif not Aex(rLx,N5v+XYx,1)thenreturnendifcall Avx(rLx,XYx)if not Aex(rLx,N6v,1)thenreturnendifif(dmx((N7v),Ob))thencall iDx(N8v,N9v,true,function Ibo)endifset bvv[oSx]=Dsx(rLx)set bev[oSx]=Dtx(rLx)call dQx(N7v,rLx)endfunctionfunction Ico takes integer oSx returns booleanif((bXv[((oSx))])>0)then
return false
endifset bOv=bOv+1set bRv[bOv]=oSx
set bXv[oSx]=bOv+1return(bOv==0)endfunctionfunction ICo takes nothing returns nothinglocal integer oMx=bOvloop
exitwhen(oMx<0)set bAv[oMx]=bRv[oMx]set oMx=oMx-1endloopset bNv=bOvendfunctionfunction Ido takes nothing returns integerlocal integer o7xif(bNv<0)thenreturn w
endifset o7x=bAv[0]set bAv[0]=bAv[bNv]set bNv=bNv-1return o7xendfunctionfunction IDo takes integer oSx,real oux returns nothingcall Ino(oSx,(Nuv[(oSx)])+oux)endfunctionfunction Ifo takes nothing returns nothinglocal integer oSxcall ICo()loop
set oSx=Ido()exitwhen(oSx==w)
call IDo((oSx),bbv[oSx])
endloopendfunctionfunction IFo takes integer oSx,real oux returns nothingset bdv[oSx]=oux
set bbv[oSx]=oux*.25
endfunctionfunction Igo takes integer oSx returns nothingcall IFo(oSx,(bBv[(oSx)])*(bCv[(oSx)])+(bcv[(oSx)]))
endfunctionfunction IGo takes integer oSx returns nothingcall Avx((oSx),N4v)call IBo((oSx),bVv)call IBo((oSx),bEv)if Ico(oSx)thencall iDx(bIv,.25,true,function Ifo)endifset bBv[(oSx)]=25.set bcv[(oSx)]=.0set bCv[(oSx)]=1.call Igo(oSx)endfunctionfunction Iho takes integer oSx returns nothinglocal real oux=(bDv[((Tf[((oSx))]))])local integer Bvx=(R2I(((oux)*1.)))set Sf[oSx]=ouxcall SetHeroAgi(C[(oSx)],Bvx,true)call bUx(oSx,Bvx)endfunctionfunction IHo takes integer oSx returns nothingset EF[oSx]=.0set XF[oSx]=.0set OF[oSx]=falseendfunctionfunction Ijo takes integer oSx returns nothingset DF[oSx]=.0call IHo(oSx)endfunctionfunction IJo takes integer oSx returns nothingcall Brx(oSx,(Sf[(oSx)]))endfunctionfunction Iko takes integer oSx returns nothingset VF[oSx]=.0call Iho(oSx)call Ijo(oSx)set dF[(oSx)]=1.
call IJo(oSx)call Bex(oSx)call Box(oSx)endfunctionfunction IKo takes integer oSx returns nothinglocal real oux=(bfv[((Tf[((oSx))]))])local integer Bvx=(R2I(((oux)*1.)))set fF[oSx]=ouxcall SetHeroInt(C[(oSx)],Bvx,true)call Bpx(oSx,Bvx)endfunctionfunction Ilo takes integer oSx returns nothingset og[oSx]=.0set rg[oSx]=.0set ig[oSx]=falseendfunctionfunction ILo takes integer oSx returns nothingset Ag[oSx]=.0call Ilo(oSx)endfunctionfunction Imo takes integer oSx returns nothingcall BZx(oSx,(fF[(oSx)]))endfunctionfunction IMo takes integer oSx returns nothingset xg[oSx]=.0call IKo(oSx)call ILo(oSx)set Ig[(oSx)]=1.
call Imo(oSx)call Byx(oSx)call Bzx(oSx)endfunctionfunction Ipo takes integer oSx returns nothinglocal real oux=(bFv[((Tf[((oSx))]))])local integer Bvx=(R2I(((oux)*1.)))set Ng[oSx]=ouxcall SetHeroStr(C[(oSx)],Bvx,true)call cux(oSx,Bvx)endfunctionfunction IPo takes integer oSx returns nothingset sG[oSx]=.0set SG[oSx]=.0set tG[oSx]=falseendfunctionfunction Iqo takes integer oSx returns nothingset ZG[oSx]=.0call IPo(oSx)endfunctionfunction IQo takes integer oSx returns nothingcall c6x(oSx,(Ng[(oSx)]))endfunctionfunction Iso takes integer oSx returns nothingset QG[oSx]=.0call Ipo(oSx)call Iqo(oSx)set zG[(oSx)]=1.
call IQo(oSx)call c3x(oSx)call c5x(oSx)endfunctionfunction ISo takes integer oSx,integer oux returns nothingif(oux==0)thenreturnendifcall UnitModifySkillPoints(C[(oSx)],oux)
endfunctionfunction Ito takes integer oSx returns nothingset bgv[oSx]=0call ISo(oSx,-GetHeroSkillPoints(C[(oSx)]))endfunctionfunction ITo takes integer oSx,integer oux returns nothinglocal integer aCx=(bgv[(oSx)])set bgv[oSx]=oux
call UnitModifySkillPoints(C[(oSx)],oux-aCx)
endfunctionfunction Iuo takes integer oSx,real oux returns nothingset I7v[oSx]=oux
call Omo((oSx))endfunctionfunction IUo takes integer oSx,real oux returns nothingcall Iuo(oSx,(I7v[(oSx)])+oux)endfunctionfunction Iwo takes integer oSx,integer oux returns nothingcall ITo(oSx,(bgv[(oSx)])+oux)endfunctionfunction IWo takes integer oSx,integer aCx,integer oux returns nothinglocal integer Gpx=(Tf[((oSx))])call bfx((oSx),bhv[0+oux])set oux=oux-aCxcall DYx((oSx),oux*bHv)call Bix((oSx),oux*(bjv[(Gpx)]))
call IUo((oSx),oux*(bJv[(Gpx)]))
call B_x((oSx),oux*(bkv[(Gpx)]))
call Iwo((oSx),oux)call c7x((oSx),oux*(bKv[(Gpx)]))
endfunctionfunction Iyo takes integer oSx returns nothinglocal integer oux=(GetHeroLevel(C[((oSx))]))
call ITo((oSx),1)set bGv[oSx]=oux
call IWo(oSx,1,oux)call dQx(blv,(oSx))endfunctionfunction IYo takes integer oSx returns integerset bQv[oSx]=trueset bsv[oSx]=falsecall rEx(Vsv)return oSxendfunctionfunction Izo takes nothing returns integerlocal integer oSxif(bMv==8190)thencall o_x("FolderUnit_FolderMovement_FolderEvents_StructInterval_Allocation_allocCustom","call DebugEx(FolderUnit_FolderMovement_FolderEvents_StructInterval.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",VSv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(bpv[(w)]==w)thenset bPv=bPv+1set oSx=bPvelse
set oSx=bpv[(w)]
set bpv[(w)]=bpv[bpv[(w)]]endifset bpv[oSx]=Zset bqv[oSx]=1call IYo(oSx)return oSxendfunctionfunction IZo takes integer oSx,integer XYx,real p1x returns nothinglocal integer rLx=oSxlocal integer p3xset oSx=Fqx(XYx,bmv+rLx)
if(oSx!=w)thencall o_x("FolderUnit_FolderMovement_FolderEvents_StructInterval_Add","call DebugEx(\"already listed \" + whichEvent.GetName() + \";\" + parent.GetName())","already listed "+(jA[(XYx)])+";"+(GetUnitName(C[(rLx)])))returnendifset oSx=Izo()set p3x=iXx()set bSv[oSx]=p1x
set btv[oSx]=p3x
set bTv[oSx]=rLx
set buv[oSx]=XYx
set ge[(p3x)]=(oSx)if rUx(rLx,bUv,oSx)thencall IBo(rLx,bwv)call IBo(rLx,bWv)endifcall pZx(XYx,bmv+rLx,oSx)endfunctionfunction I_o takes integer oSx returns nothingset Nuv[oSx]=(NTv[((oSx))])call Avx((oSx),bLv)call IZo((oSx),byv,.125)
endfunctionfunction I0o takes integer oSx returns booleanset b5v=b5v+1set b6v[b5v]=oSx
set b7v[oSx]=b5v+1return(b5v==0)endfunctionfunction I1o takes nothing returns nothinglocal real bex=GetCameraField(CAMERA_FIELD_ROTATION)-Bev
local real I2o=(Cos(((((bex)*1.))*1.)))local real I3o=(Sin(((((bex)*1.))*1.)))local integer oMx=b5vlocal integer oSxlocal real I4olocal real x
local real I5olocal real y
local real I6olocal real I7oloop
set oSx=b6v[oMx]
if I9x((oSx),Qc)then
set Bxv[oSx]=.0set Bov[oSx]=.0call MoveLightningEx(bYv[oSx],false,.0,.0,.0,.0,.0,.0)call MoveLightningEx(bzv[oSx],false,.0,.0,.0,.0,.0,.0)call MoveLightningEx(b0v[oSx],false,.0,.0,.0,.0,.0,.0)call MoveLightningEx(b1v[oSx],false,.0,.0,.0,.0,.0,.0)else
set I4o=fYx((oSx))+175.*(eb[((oSx))])set x=Dsx((oSx))
set I5o=60.*I2oset y=Dtx((oSx))
set I6o=60.*I3oset I7o=(ce[(oov[oSx])])
if(I7o>.0)thenset I7o=(TimerGetRemaining(Oe[(oov[oSx])]))*1./ I7ocall MoveLightningEx(orv[oSx],false,x-I5o*1.5,y-I6o*1.5,I4o+75,x+I5o*1.5,y+I6o*1.5,I4o+75)call SetLightningColor(orv[oSx],1.,1.,1.,1.)
call MoveLightningEx(oiv[oSx],false,x-I5o*1.5,y-I6o*1.5,I4o+75,x+(I7o*2-1)*I5o*1.5,y+(I7o*2-1)*I6o*1.5,I4o+75)call SetLightningColor(oiv[oSx],.0,.75,1.,1.)endifset I7o=(lF[((oSx))])*1./(LF[((oSx))])set I7o=Bxv[oSx]+(I7o-Bxv[oSx])*Brvset Bxv[oSx]=I7o
if(I7o>.9)thencall MoveLightningEx(bYv[oSx],false,.0,.0,.0,.0,.0,.0)call MoveLightningEx(bzv[oSx],false,.0,.0,.0,.0,.0,.0)else
call MoveLightningEx(bYv[oSx],false,x-I5o,y-I6o,I4o+50,x+I5o,y+I6o,I4o+50)call SetLightningColor(bYv[oSx],1.,1.,1.,blx(Biv*I7o+Bav,iUx(1.,.15),iAx(1.,.15)))call MoveLightningEx(bzv[oSx],false,x-I5o,y-I6o,I4o+50,x+(I7o*2-1)*I5o,y+(I7o*2-1)*I6o,I4o+50)call SetLightningColor(bzv[oSx],1.,.0,1.,blx(Biv*I7o+Bav,iUx(1.,.15),iAx(1.,.15)))endifset I7o=(zf[((oSx))])*1./(Yf[((oSx))])set I7o=Bnv[oSx]+(I7o-Bnv[oSx])*Brvset Bnv[oSx]=I7o
if(I7o>.9)thencall MoveLightningEx(bZv[oSx],false,.0,.0,.0,.0,.0,.0)call MoveLightningEx(b_v[oSx],false,.0,.0,.0,.0,.0,.0)else
call MoveLightningEx(bZv[oSx],false,x-I5o,y-I6o,I4o,x+I5o,y+I6o,I4o)
call SetLightningColor(bZv[oSx],1.,1.,1.,blx(Biv*I7o+Bav,iUx(1.,.15),iAx(1.,.15)))call MoveLightningEx(b_v[oSx],false,x-I5o,y-I6o,I4o,x+(I7o*2-1)*I5o,y+(I7o*2-1)*I6o,I4o)
call SetLightningColor(b_v[oSx],.83,.37,.1,blx(Biv*I7o+Bav,iUx(1.,.15),iAx(1.,.15)))
endifset I7o=(Nuv[((oSx))])*1./(NTv[((oSx))])
set I7o=Bov[oSx]+(I7o-Bov[oSx])*Brvset Bov[oSx]=I7o
if(I7o>.9)thencall MoveLightningEx(b0v[oSx],false,.0,.0,.0,.0,.0,.0)call MoveLightningEx(b1v[oSx],false,.0,.0,.0,.0,.0,.0)else
call MoveLightningEx(b0v[oSx],false,x-I5o,y-I6o,I4o,x+I5o,y+I6o,I4o)
call SetLightningColor(b0v[oSx],1.,1.,1.,blx(Biv*I7o+Bav,iUx(1.,.15),iAx(1.,.15)))call MoveLightningEx(b1v[oSx],false,x-I5o,y-I6o,I4o,x+(I7o*2-1)*I5o,y+(I7o*2-1)*I6o,I4o)
call SetLightningColor(b1v[oSx],1.,1.,.0,blx(Biv*I7o+Bav,iUx(1.,.15),iAx(1.,.15)))endifendifset oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction I8o takes integer oSx returns nothingset orv[oSx]=AddLightningEx("oBaB",false,.0,.0,.0,.0,.0,.0)set oiv[oSx]=AddLightningEx("oBaJ",false,.0,.0,.0,.0,.0,.0)set oov[oSx]=iXx()set bYv[oSx]=AddLightningEx("oBaB",false,.0,.0,.0,.0,.0,.0)set bzv[oSx]=AddLightningEx("oBaJ",false,.0,.0,.0,.0,.0,.0)set bZv[oSx]=AddLightningEx("oBaB",false,.0,.0,.0,.0,.0,.0)set b_v[oSx]=AddLightningEx("oBaJ",false,.0,.0,.0,.0,.0,.0)set b0v[oSx]=AddLightningEx("oBaB",false,.0,.0,.0,.0,.0,.0)set b1v[oSx]=AddLightningEx("oBaJ",false,.0,.0,.0,.0,.0,.0)call Avx((oSx),b2v)call Avx((oSx),b3v)call Avx((oSx),b4v)if I0o(oSx)thencall iDx(b8v,b9v,true,function I1o)endifendfunctionfunction I9o takes integer oSx returns nothinglocal real oux=(rG[((oSx))])
set oG[oSx]=ouxcall SetWidgetLife(C[(oSx)],oux)
endfunctionfunction Avo takes integer oSx returns nothinglocal real oux=(LF[((oSx))])
set lF[oSx]=ouxcall SetUnitState(C[(oSx)],UNIT_STATE_MANA,oux)endfunctionfunction Aeo takes integer oSx returns nothingcall dQx(BVv,(oSx))call dQx(BEv,(oSx))call dQx(BXv,(oSx))call dQx(BOv,(oSx))endfunctionfunction Axo takes integer oSx returns nothingset Xh[oSx]=wset nh[oSx]=falsecall TriggerRegisterUnitEvent(DA[((Mb))],C[(oSx)],(EVENT_UNIT_ISSUED_ORDER))
endfunctionfunction Aoo takes integer oSx returns nothingset Dj[oSx]=wset Vh[oSx]=falsecall TriggerRegisterUnitEvent(DA[((bh))],C[(oSx)],(EVENT_UNIT_ISSUED_POINT_ORDER))endfunctionfunction Aro takes integer oSx returns nothingset Gj[oSx]=wset Eh[oSx]=falsecall TriggerRegisterUnitEvent(DA[((BIv))],C[(oSx)],(EVENT_UNIT_ISSUED_TARGET_ORDER))
endfunctionfunction Aio takes integer oSx returns nothingcall Axo(oSx)call Aoo(oSx)call Aro(oSx)endfunctionfunction Aao takes integer oSx returns nothingcall dQx(vj,oSx)
call Avx((oSx),BAv)if(dPx((oSx))==w)thenreturnendifcall dzx(oSx)endfunctionfunction Ano takes integer oSx returns nothingcall Aio(oSx)call Aao(oSx)endfunctionfunction AVo takes integer oSx returns nothingset ej[oSx]=wcall Avx((oSx),BRv)call Ano(oSx)endfunctionfunction AEo takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((BBv[oSx]))])]))],((((kw[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))
endfunctionfunction AXo takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((BBv[oSx]))])]))],((((kw[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))endfunctionfunction AOo takes integer oSx returns nothinglocal integer Gpx=(Tf[(oSx)])local integer rFx=rRx(0)
local integer Ekolocal integer oMxlocal integer rbxlocal integer rMxset Vv[(rFx)]=(oSx)set Bbv[(rFx)]=(Gpx)
set Eko=rRx((A[(oSx)]))set Vv[(Eko)]=(oSx)set Bbv[(Eko)]=(Gpx)
set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((IJv))-1)*Iv+(((rbx))-1)))))))))
loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((IJv))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset rMx=AEo(Gpx,IJv,rbx)
loop
exitwhen(rMx<q)call rfx(AXo(Gpx,IJv,rbx,rMx),Eko)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call rkx(((Eko)))endfunctionfunction ARo takes integer bIx,unit oqx returns integerlocal integer Gpx=X1o(GetUnitTypeId(oqx))local integer oSx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((oqx)))))),((((ix))))))local integer AIo=a6x("Unit.CreateBasic: "+(ob[(bIx)])+";"+GetUnitName(oqx)+";"+I2S(oSx)+";"+(GetObjectName(Ikv[(Gpx)])))local boolean Qsxif(oSx!=0)thencall o_x("Unit_CreateBasic","call DebugEx(\"Unit.CreateBasic: unit \" + this.GetName() + \" already registered\")","Unit.CreateBasic: unit "+(GetUnitName(C[(oSx)]))+" already registered")return oSxendifif(Gpx==w)thencall o_x("Unit_CreateBasic","call DebugEx(\"Unit.CreateBasic: null type\")","Unit.CreateBasic: null type")return w
endifcall X2o(AIo,"A")set oSx=X4o()set pc[oSx]=falseset C[oSx]=oqxcall SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oqx))))),((((ix)))),((((oSx)))))
call dQx(Pj,oSx)
call X5o(oSx)call X6o(oSx)call X2o(AIo,"B")call X7o(((oSx)),1.)
call X8o(oSx)call Ovo(oSx)call Oeo(oSx)call Ooo(oSx)call Oro(oSx)set n_v[((oSx))]=(false)
set ITv[((oSx))]=((1.)*1.)call Oio(oSx)set aRv[((oSx))]=(false)
set Iuv[((oSx))]=((.0)*1.)set Ze[((oSx))]=(false)call Oao(oSx)set IUv[((oSx))]=((.0)*1.)call Ono(oSx,bIx)set XBv[((oSx))]=(true)call OVo((oSx))set XMv[((oSx))]=(false)
set ph[((oSx))]=(false)set O6v[((oSx))]=(false)
call OEo(oSx)call X2o(AIo,"C")call OFo(oSx)call X2o(AIo,"C2")call OMo(oSx)call X2o(AIo,"C3")call Oto(oSx)call X2o(AIo,"C4")call Rxo(oSx)call X2o(AIo,"C5")call Roo(oSx)call X2o(AIo,"C6")call Rro(oSx)call X2o(AIo,"C7")call RVo(oSx)call X2o(AIo,"C8")call REo(oSx)call X2o(AIo,"C9")call RCo(oSx)call X2o(AIo,"C10")call Rdo(oSx)call X2o(AIo,"C11")call Rfo(oSx)call X2o(AIo,"C12")call Rjo(oSx)call X2o(AIo,"C13")call RJo(oSx)call X2o(AIo,"C14")call RKo(oSx)call X2o(AIo,"C15")call Rmo(oSx)call X2o(AIo,"C16")call RQo(oSx)call X2o(AIo,"C17")call RSo(oSx)call X2o(AIo,"C18")call RUo(oSx)call X2o(AIo,"D")call RWo(oSx)call RYo(oSx)call RZo(oSx)call R0o(oSx)call Ivo(oSx)call Ixo(oSx)call Ioo(oSx)call Iro(oSx)call X2o(AIo,"E")set ENv[((oSx))]=(false)
set Etv[((oSx))]=(false)
set ngv[((oSx))]=(false)
set Ejv[((oSx))]=(false)
set Xiv[((oSx))]=(false)
set XFv[((oSx))]=(false)
call DUx((oSx))set Emv[((oSx))]=(false)
set Qsx=I9x(oSx,Wd)call X2o(AIo,"F")if Qsx thencall X2o(AIo,"F1")call IXo(oSx)call IGo(oSx)call X2o(AIo,"F2")call Iko(oSx)call IMo(oSx)call Iso(oSx)call X2o(AIo,"F3")call Ito(oSx)call X2o(AIo,"F4")call Iyo(oSx)call X2o(AIo,"F5")call I_o(oSx)call X2o(AIo,"F6")call I8o(oSx)call X2o(AIo,"F7")else
call X2o(AIo,"F8")if not I9x(oSx,Ijv)thencall X2o(AIo,"F9")call ACx((oSx),("Units\\Aura.mdx"),("origin"),(Bi))call X2o(AIo,"F10")call Hgx(oSx)call X2o(AIo,"F11")endifendifcall X2o(AIo,"G")call I9o(oSx)call Avo(oSx)call X2o(AIo,"H")call Aeo((oSx))call X2o(AIo,"H2")call AVo(oSx)call X2o(AIo,"I")if BNv thencall AOo(oSx)endifcall X2o(AIo,"J")call a4x(AIo)return oSxendfunctionfunction AAo takes nothing returns booleanset Rb=ARo(hf,aGx(vx[hf],Ikv[Hf],Ff,gf,Gf*ky))return trueendfunctionfunction ANo takes nothing returns booleanset Rb=ARo(oPx(GetOwningPlayer(C[db])),C[db])return trueendfunctionfunction Abo takes integer oSx returns nothinglocal integer oMx=(CIx(((oSx)),Q))loop
exitwhen(oMx<q)call rpx(oSx,(CAx(((oSx)),Q,(oMx))))
set oMx=oMx-1endloopendfunctionfunction ABo takes integer oSx returns nothingcall IRo(Iyv,(oSx))call IRo(IYv,(oSx))call IRo(Izv,(oSx))endfunctionfunction Aco takes integer oSx returns nothingcall IRo(BVv,(oSx))call IRo(BEv,(oSx))call IRo(BXv,(oSx))call IRo(BOv,(oSx))endfunctionfunction ACo takes integer oSx returns nothingif not(I8x((blv),Ob,(oSx)))thenreturnendifcall IRo(blv,oSx)endfunctionfunction Ado takes integer oSx returns nothinglocal integer rFx=rRx(0)
local integer Ekolocal integer oMxlocal integer rbxlocal integer rMxset Vv[(rFx)]=(oSx)set Eko=rRx((A[(oSx)]))set Vv[(Eko)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((EP))-1)*Iv+(((rbx))-1)))))))))loop
exitwhen(rMx<q)call aKx("triggerStatic "+(jA[((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((EP))-1)*Iv+(((rbx))-1))))+((rMx)))))))]))call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((EP))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset rMx=rAx(oSx,EP,rbx)loop
exitwhen(rMx<q)call aKx("trigger "+(jA[(rgx(oSx,EP,rbx,rMx))]))
call rfx(rgx(oSx,EP,rbx,rMx),Eko)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call rkx(((Eko)))call ABo(oSx)call IRo(ABv,(oSx))call IRo(A3v,((oSx)))call IRo(A6v,(oSx))call Aco(oSx)call ACo(oSx)endfunctionfunction ADo takes integer oSx returns booleanif((MT[(oSx)])>0)thenset pT[oSx]=true
return false
endifreturn trueendfunctionfunction Afo takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((I[oSx]))])])],((((A[((oSx))])))))
endfunctionfunction AFo takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((Rv[oSx]))])])],((((A[((oSx))])))))endfunctionfunction Ago takes integer oSx returns nothingset IMv[oSx]=falsecall Afo((oSx))call AFo(((oSx)))call rHx(Iov)endfunctionfunction AGo takes integer oSx returns nothingif(Imv[oSx]>0)thenreturnendifif(Ilv[oSx]!=Z)thencall o_x("Unit_Allocation_deallocCustom_confirm","call DebugEx(Unit.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Irv+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset Ilv[oSx]=Ilv[(w)]set Ilv[(w)]=oSx
call Ago(oSx)endfunctionfunction Aho takes integer oSx returns nothingset Imv[oSx]=Imv[oSx]-1call AGo(oSx)endfunctionfunction AHo takes nothing returns booleanlocal integer oSx=Rb
local unit oqxif pc[oSx]thenreturn trueendifset oqx=C[oSx]set pc[oSx]=true
call IRo(Pj,oSx)
call Abo(oSx)call Ado(oSx)if not ADo(oSx)thencall ShowUnit(C[oSx],false)return trueendifcall Aho((oSx))call SaveInteger(o[(((V[((E[((X))]))])))],(((GetHandleId(((oqx)))))),(((((ix))))),(0))call MDx(oqx)set oqx=null
return trueendfunctionfunction Ajo takes nothing returns booleanreturn( not((Tf[(jhx())])!=Hf))endfunctionfunction AJo takes integer oSx,integer Ako,integer AKo returns nothinglocal integer rLx=oSxlocal integer rFx=rRx(0)
local integer Rnxlocal integer oMxlocal integer rbxlocal integer rMxset Vv[(rFx)]=(rLx)set Bdv[(rFx)]=(Ako)
set BDv[(rFx)]=(AKo)
set Bbv[(rFx)]=(AKo)
set Rnx=rRx((A[(rLx)]))set Vv[(Rnx)]=(rLx)set Bdv[(Rnx)]=(Ako)
set BDv[(Rnx)]=(AKo)
set Bbv[(Rnx)]=(AKo)
set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((OP))-1)*Iv+(((rbx))-1)))))))))loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((OP))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset rMx=rAx(rLx,OP,rbx)loop
exitwhen(rMx<q)call rfx(rgx(rLx,OP,rbx,rMx),Rnx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call rkx(((Rnx)))endfunctionfunction Alo takes integer oSx,integer AKo returns nothinglocal integer Ako=(Tf[(oSx)])set Tf[oSx]=AKoif((Ako==w)or(Ako==AKo))then
returnendifcall AJo(oSx,Ako,AKo)endfunctionfunction ALo takes nothing returns booleanlocal integer oSx=adx(GetTriggerUnit())call Alo(oSx,X1o(GetUnitTypeId(GetTriggerUnit())))call CCx((oSx))return trueendfunctionfunction Amo takes nothing returns nothingset OP=(E3x())call Q5x(XJx(function ALo),Ge,EVENT_PLAYER_UNIT_UPGRADE_FINISH,null)
endfunctionfunction AMo takes nothing returns booleanlocal integer rFx=(bv)local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])local integer oMx=OPo(AKo)loop
exitwhen(oMx<q)call ACx((((oSx))),((OQo(AKo,oMx))),((Oso(AKo,oMx))),((OSo(AKo,oMx))))set oMx=oMx-1endloopreturn trueendfunctionfunction Apo takes nothing returns booleanlocal integer rFx=(bv)local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])set EUv[(oSx)]=((AQv[(AKo)]))return trueendfunctionfunction APo takes nothing returns booleanlocal integer rFx=(bv)local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])set nJv[(oSx)]=((nKv[(AKo)]))return trueendfunctionfunction Aqo takes integer oSx,integer rNx returns nothingif not I9x(oSx,rNx)thencall o_x("FolderUnit_StructClasses_Remove","call DebugEx(FolderUnit_StructClasses.NAME + \": cannot remove class \" + whichType.GetName() + \" from \" + Unit(this).GetName())",o3v+": cannot remove class "+(IAv[(rNx)])+" from "+(GetUnitName(C[((oSx))])))returnendifcall IRo(qc[(rNx)],oSx)endfunctionfunction AQo takes integer oSx returns nothinglocal integer oMx=INvloop
exitwhen(oMx<0)if I9x(oSx,Ibv[oMx])then
call Aqo(oSx,Ibv[oMx])endifset oMx=oMx-1endloopendfunctionfunction Aso takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=rLxcall RPx(rLx,Atv)call AQo(oSx)return trueendfunctionfunction ASo takes nothing returns booleanlocal integer rFx=(bv)local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])local integer oMx=Rio(AKo)call AQo(oSx)loop
exitwhen(oMx<q)call Rao(oSx,Rno(AKo,oMx))set oMx=oMx-1endloopreturn trueendfunctionfunction Ato takes integer Odo returns integerlocal integer oSx=Odoset qc[oSx]=Jbx("FolderUnit_StructClasses_Create: set this.dummyGroup = UnitList.Create()")return oSxendfunctionfunction ATo takes nothing returns nothinglocal integer oMx=INvset Atv=Xdx("FolderUnit_StructClasses_Init: set FolderUnit_StructClasses.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructClasses.Event_Destroy)",EP,bI,function Aso)call Dcx(Xdx("FolderUnit_StructClasses_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructClasses.Event_TypeChange).AddToStatics()",OP,bI,function ASo))loop
exitwhen(oMx<0)call Ato(Ibv[oMx])set oMx=oMx-1endloopendfunctionfunction Auo takes integer oSx,real oux,boolean OPx returns nothingset UH[(oSx)]=((dox(oSx,false)+oux)*1.)endfunctionfunction AUo takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])call Auo(oSx,(ATv[(AKo)])-(ATv[(Ako)]),true)
return trueendfunctionfunction Awo takes integer oSx returns integerset BJv[oSx]=trueset Bkv[oSx]=falsecall rEx(BKv)return oSxendfunctionfunction AWo takes nothing returns integerlocal integer oSxif(Bgv==8190)thencall o_x("UnitState_Allocation_allocCustom","call DebugEx(UnitState.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",BGv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Bhv[(w)]==w)thenset BHv=BHv+1set oSx=BHvelse
set oSx=Bhv[(w)]
set Bhv[(w)]=Bhv[Bhv[(w)]]endifset Bhv[oSx]=Zset Bjv[oSx]=1call Awo(oSx)return oSxendfunctionfunction Ayo takes string rSx,code igx returns integerlocal integer oSx=AWo()set ic[(oSx)]=(XJx(igx))
set Blv[(oSx)]=(rSx)
return oSxendfunctionfunction AYo takes nothing returns booleanlocal integer rFx=(bv)call bpx(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction Azo takes nothing returns nothingset Bfv=(E3x())set BFv=Ayo(ixv,function AYo)endfunctionfunction AZo takes integer rLx returns booleanreturn(I8x((A3v),Ob,(rLx)))endfunctionfunction A_o takes integer oSx returns nothingset MT[oSx]=(MT[(oSx)])+1endfunctionfunction A0o takes integer oSx,integer otx returns booleanreturn(LoadBoolean(o[((V[(E[((xA[(oSx)]))])]))],((((aA[((oSx))])))),(((otx)))))endfunctionfunction A1o takes integer oSx,integer XYx returns booleanreturn((LoadInteger(o[((D[((Rv[oSx]))]))],((((A[((oSx))])))),(oTx((((oA[(XYx)]))),(((XYx)))))))!=0)endfunctionfunction A2o takes integer oSx,integer cfx returns nothinglocal integer rLx=oSxlocal integer A3o=rRx((A[(cfx)]))local integer rFxlocal integer Ekolocal integer array A4olocal integer A5olocal integer array A6olocal integer oMxlocal integer rbxlocal integer rMxset zH[(A3o)]=(rLx)set Vv[(A3o)]=(cfx)set rFx=rRx(0)set fG[(rFx)]=(cfx)set Vv[(rFx)]=(rLx)set Eko=rRx((A[(rLx)]))set fG[(Eko)]=(cfx)set Vv[(Eko)]=(rLx)set A5o=Fset oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((VP))-1)*Iv+(((rbx))-1)))))))))loop
exitwhen(rMx<q)set A5o=A5o+1set A4o[A5o]=(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((VP))-1)*Iv+(((rbx))-1))))+((rMx))))))
set A6o[A5o]=0set rMx=rMx-1endloopset rMx=rAx(cfx,BMv,rbx)
loop
exitwhen(rMx<q)set A5o=A5o+1set A4o[A5o]=rgx(cfx,BMv,rbx,rMx)set A6o[A5o]=1set rMx=rMx-1endloopset rMx=rAx(rLx,VP,rbx)loop
exitwhen(rMx<q)set A5o=A5o+1set A4o[A5o]=rgx(rLx,VP,rbx,rMx)
set A6o[A5o]=2set rMx=rMx-1endloopset oMx=oMx-1endloopset oMx=0loop
exitwhen(oMx>A5o)if(A6o[oMx]==0)thenif(A0o((A4o[oMx]),lj))thencall rfx(A4o[oMx],rFx)if not I9x((oSx),Qc)then
returnendifendifelseif(A6o[oMx]==1)thenif A1o(cfx,A4o[oMx])then
call rfx(A4o[oMx],A3o)if not I9x((oSx),Qc)then
returnendifendifelse
if A1o(rLx,A4o[oMx])then
call rfx(A4o[oMx],Eko)if not I9x(rLx,Qc)thenreturnendifendifendifset oMx=oMx+1endloopcall rkx(((A3o)))call rkx(((rFx)))call rkx(((Eko)))endfunctionfunction A7o takes integer oSx returns nothingset BSv[oSx]=falsecall rHx(Ep)
endfunctionfunction A8o takes integer oSx returns nothingif(BQv[oSx]>0)thenreturnendifif(Bsv[oSx]!=Z)thencall o_x("SpotEffectWithSize_Allocation_deallocCustom_confirm","call DebugEx(SpotEffectWithSize.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Xp+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Bsv[oSx]=Bsv[(w)]set Bsv[(w)]=oSx
call A7o(oSx)endfunctionfunction A9o takes integer oSx returns nothingset BQv[oSx]=BQv[oSx]-1call A8o(oSx)endfunctionfunction Nvo takes integer oSx returns nothinglocal integer HAx=BPv[oSx]local effect oqx=Bqv[oSx]call A9o((oSx))call MGx(HAx)call DestroyEffect(oqx)set oqx=null
endfunctionfunction Neo takes integer oSx returns integerset BSv[oSx]=trueset Buv[oSx]=falsecall rEx(Ep)
return oSxendfunctionfunction Nxo takes nothing returns integerlocal integer oSxif(Btv==8190)thencall o_x("SpotEffectWithSize_Allocation_allocCustom","call DebugEx(SpotEffectWithSize.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Xp+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Bsv[(w)]==w)thenset BTv=BTv+1set oSx=BTvelse
set oSx=Bsv[(w)]
set Bsv[(w)]=Bsv[Bsv[(w)]]endifset Bsv[oSx]=Zset BQv[oSx]=1call Neo(oSx)return oSxendfunctionfunction Noo takes real x,real y,string ANx,integer rYx,real Nro returns integer
local integer oSx=Nxo()local integer HAx=mDx('qEWS',x,y,X_x(x,y),BUv)set BPv[oSx]=HAx
set Bqv[oSx]=AddSpecialEffectTarget(itx(ci>=rYx,ANx),vJ[HAx],"origin")call mCx(HAx,Nro)return oSxendfunctionfunction Nio takes integer oSx,real x,real y returns nothing
local string ANx=(nJv[((oSx))])if(ANx!=null)thencall Nvo(Noo(x,y,Bwv,ri,(eb[((oSx))])))endifendfunctionfunction Nao takes integer a,integer b returns integerlocal integer oSx=(LoadInteger(o[((QA))],(a),(b)))if(oSx==0)thenset oSx=XMx()set Bv[oSx]=And(Bv[a],Bv[b])
call SaveInteger(o[((QA))],(a),(b),(oSx))endifreturn oSxendfunctionfunction Nno takes integer oSx,real x,real y,real Jex,integer Q7x returns nothingcall GroupEnumUnitsInRange(kb[(oSx)],x,y,Jex,Bv[Q7x])endfunctionfunction NVo takes integer oSx,real x,real y,real Jex,integer Q7x returns nothingif(Q7x==w)thenset Q7x=GKendifset Q7x=Nao(MQ,Q7x)set qQ=Jexset pQ=x
set PQ=y
call Nno((oSx),x,y,Jex+BZv,Q7x)endfunctionfunction NEo takes integer oSx returns integerlocal integer o7x=(adx(FirstOfGroup(kb[(oSx)])))
if(o7x==w)thenreturn w
endifcall GroupRemoveUnit(kb[(oSx)],C[(o7x)])
return o7xendfunctionfunction NXo takes integer oSx,integer NOo returns nothinglocal integer NRoloop
set NRo=NEo(NOo)
exitwhen(NRo==w)
call GroupAddUnit(kb[(oSx)],C[(NRo)])endloopendfunctionfunction NIo takes integer oSx returns integerlocal integer o7x=0local integer XLoloop
set XLo=NEo((oSx))exitwhen(XLo==w)
call GroupAddUnit(kb[(BQ)],C[(XLo)])
set o7x=o7x+1endloopcall NXo((oSx),BQ)return o7xendfunctionfunction NAo takes integer oSx,integer Iix,real nZx,boolean nho returns real
return nGo(oSx,Iix,nZx,nho)endfunctionfunction NNo takes integer oSx,integer cfx returns nothinglocal real Nbo=(rG[((oSx))])*Bpv
local integer NBo=(ze[(cfx)])local real x=Dsx((oSx))local real y=Dtx((oSx))local integer Ncolocal integer rvxlocal integer Iixcall Nio(oSx,x,y)if(((BWv[(NBo)])!=Byv)or(NBo==BYv)or(NBo==Bzv))thenreturnendifset Nco=O5x()set hf=(ze[(cfx)])call NVo(Nco,x,y,dox((oSx),true)*5,B_v)set rvx=(NIo((Nco)))
if(rvx>0)thenset Nbo=Nbo*1./ rvxloop
set Iix=NEo(Nco)
exitwhen(Iix==w)
call NAo(cfx,Iix,Nbo,false)endloopendifendfunctionfunction NCo takes integer oSx returns integerset B4v[oSx]=trueset B5v[oSx]=falsecall rEx(np)
return oSxendfunctionfunction Ndo takes nothing returns integerlocal integer oSxif(B0v==8190)thencall o_x("FolderSpotEffectWithSize_StructDestroyTimed_Allocation_allocCustom","call DebugEx(FolderSpotEffectWithSize_StructDestroyTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Vp+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(B1v[(w)]==w)thenset B2v=B2v+1set oSx=B2velse
set oSx=B1v[(w)]
set B1v[(w)]=B1v[B1v[(w)]]endifset B1v[oSx]=Zset B3v[oSx]=1call NCo(oSx)return oSxendfunctionfunction NDo takes integer oSx returns nothingset B4v[oSx]=falsecall rHx(np)
endfunctionfunction Nfo takes integer oSx returns nothingif(B3v[oSx]>0)thenreturnendifif(B1v[oSx]!=Z)thencall o_x("FolderSpotEffectWithSize_StructDestroyTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderSpotEffectWithSize_StructDestroyTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Vp+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset B1v[oSx]=B1v[(w)]set B1v[(w)]=oSx
call NDo(oSx)endfunctionfunction NFo takes integer oSx returns nothingset B3v[oSx]=B3v[oSx]-1call Nfo(oSx)endfunctionfunction Ngo takes nothing returns nothinglocal integer iCx=iGx()local integer oSx=(ge[(iCx)])local integer rLx=B6v[oSx]call NFo((oSx))call iKx(iCx)call Nvo(rLx)endfunctionfunction NGo takes integer oSx,real iMx returns nothinglocal integer rLx=oSxlocal integer iCxset oSx=Ndo()set iCx=iXx()set B6v[oSx]=rLx
set ge[(iCx)]=(oSx)call iDx(iCx,iMx,false,function Ngo)
endfunctionfunction Nho takes integer oSx,real x,real y returns nothing
local string ANx=(Asv[((oSx))])if(ANx!=null)thencall NGo(Noo(x,y,ANx,ri,(eb[((oSx))])),5.)endifendfunctionfunction NHo takes integer oSx,integer cfx returns nothingif(iVv[(oSx)])thencall NNo(oSx,cfx)elseif I9x((oSx),IGv)thencall Nho(oSx,Dsx((oSx)),Dtx((oSx)))endifendfunctionfunction Njo takes integer oSx returns nothingcall Owx((oSx))endfunctionfunction NJo takes integer oSx returns integerset cev[oSx]=trueset cxv[oSx]=falsecall rEx(idv)return oSxendfunctionfunction Nko takes nothing returns integerlocal integer oSxif(B7v==8190)thencall o_x("FolderUnit_FolderDecay_StructTimed_Allocation_allocCustom","call DebugEx(FolderUnit_FolderDecay_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",iDv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(B8v[(w)]==w)thenset B9v=B9v+1set oSx=B9velse
set oSx=B8v[(w)]
set B8v[(w)]=B8v[B8v[(w)]]endifset B8v[oSx]=Zset cvv[oSx]=1call NJo(oSx)return oSxendfunctionfunction NKo takes integer oSx returns nothingset cev[oSx]=falsecall rHx(idv)endfunctionfunction Nlo takes integer oSx returns nothingif(cvv[oSx]>0)thenreturnendifif(B8v[oSx]!=Z)thencall o_x("FolderUnit_FolderDecay_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderDecay_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",iDv+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset B8v[oSx]=B8v[(w)]set B8v[(w)]=oSx
call NKo(oSx)endfunctionfunction NLo takes integer oSx returns nothingset cvv[oSx]=cvv[oSx]-1call Nlo(oSx)endfunctionfunction Nmo takes integer oSx,integer iCx,integer rLx returns nothingcall NLo((oSx))call iKx(iCx)call rVx(rLx,civ)call RPx(rLx,cav)call RPx(rLx,cnv)endfunctionfunction NMo takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local integer rLx=crv[oSx]call Nmo(oSx,iCx,rLx)call Njo(rLx)endfunctionfunction Npo takes integer oSx,real iMx returns nothinglocal integer rLx=oSxlocal integer iCxset oSx=Nko()set iCx=iXx()set cov[oSx]=iCx
set crv[oSx]=rLx
set ge[(iCx)]=(oSx)call rwx(rLx,civ,oSx)call Avx(rLx,cav)call Avx(rLx,cnv)call iDx(iCx,iMx,false,function NMo)
endfunctionfunction NPo takes integer oSx,integer Iix returns nothinglocal real o5xreturnif(oSx==w)thenreturnendifif(Iix==w)thenreturnendifif((BWv[((ze[(Iix)]))])!=Byv)thenreturnendifif(IsUnitAlly(C[(Iix)],vx[((ze[((oSx))]))]))then
returnendifif I9x(Iix,Qc)thenreturnendifif I9x(Iix,Ifv)thenreturnendifif I9x(Iix,Igv)thenreturnendifif I9x(Iix,Ijv)thenreturnendifset o5x=(Nrv[(oSx)])
if(o5x<=0)thenreturnendifcall cjx(Iix,o5x)call BNx(Iix,o5x)call IDo(Iix,o5x)endfunctionfunction Nqo takes integer oSx,integer cfx returns nothinglocal boolean NQo=Bmvlocal real Nsocall A_o((oSx))if NQo thenset Bmv=falseendifcall Rao((oSx),Qc)if((I9x((oSx),Wd)and not I9x((oSx),IDv))or I9x((oSx),Ihv))thencall A2o(oSx,cfx)else
set Nso=(A4v[((oSx))])set NQo=(NQo or(iVv[((oSx))])or(Nso==.0))if NQo thencall NHo((oSx),cfx)call A2o(oSx,cfx)if not(pc[((oSx))])thencall Njo((oSx))endifelse
call Npo((oSx),Nso)call A2o(oSx,cfx)endifendifcall NPo((oSx),cfx)call Khx((oSx))endfunctionfunction NSo takes nothing returns booleanlocal integer rLx=Q2x()local integer cfxif not AZo(rLx)thenreturn trueendifset cfx=gGset gG=w
call Nqo((rLx),cfx)return trueendfunctionfunction Nto takes nothing returns nothingset FG=(E3x())set VP=(E3x())set BLv=XJx(function NSo)set BMv=(E3x())set A3v=Jbx("FolderUnit_FolderDeath_StructEvents_Init: set FolderUnit_FolderDeath_StructEvents.REG_GROUP = UnitList.Create()")call Q5x(BLv,Ge,EVENT_PLAYER_UNIT_DEATH,null)endfunctionfunction NTo takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction Nuo takes nothing returns nothingcall Nto()set B_v=Xpx(function NTo)endfunctionfunction NUo takes nothing returns nothingendfunctionfunction Nwo takes integer oSx,integer otx returns nothingcall dwx((I[(oSx)]),((A[((oSx))])),(otx))endfunctionfunction NWo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oMx=CIx(rLx,A8v)local integer ouxcall RPx(rLx,A9v)loop
set oux=CAx(rLx,A8v,oMx)
call RPx(rLx,(Nvv[(oux)]))set oMx=oMx-1exitwhen(oMx<q)endloopcall Nwo(rLx,A8v)return trueendfunctionfunction Nyo takes integer oSx returns nothinglocal integer rLx=oSxlocal integer oMx=CIx(rLx,A8v)local integer ouxif(oMx<q)thenreturnendifcall RPx(rLx,A9v)loop
set oux=CAx(rLx,A8v,oMx)
call RPx(rLx,(Nvv[(oux)]))set oMx=oMx-1exitwhen(oMx<q)endloopcall Nwo(rLx,A8v)endfunctionfunction NYo takes nothing returns booleanlocal integer rFx=(bv)local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])local integer oMxcall Nyo(oSx)set oMx=RFo(AKo)
loop
exitwhen(oMx<q)call Rgo(oSx,RGo(AKo,oMx))set oMx=oMx-1endloopreturn trueendfunctionfunction Nzo takes integer oSx,integer oux returns nothingset Nrv[(oSx)]=((Nrv[(oSx)])+oux)endfunctionfunction NZo takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])call Nzo(oSx,(Niv[(AKo)])-(Niv[(Ako)]))return trueendfunctionfunction N_o takes integer oSx,integer oux returns nothingset Nav[(oSx)]=((Nav[(oSx)])+oux)endfunctionfunction N0o takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])call N_o(oSx,(Nnv[(AKo)])-(Nnv[(Ako)]))return trueendfunctionfunction N1o takes nothing returns nothingset A9v=Xdx("FolderUnit_StructDrop_Init: set FolderUnit_StructDrop.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructDrop.Event_Destroy)",EP,bI,function NWo)call Dcx(Xdx("FolderUnit_StructDrop_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructDrop.Event_TypeChange).AddToStatics()",OP,bI,function NYo))call Dcx(Xdx("FolderUnit_FolderDrop_StructExp_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDrop_StructExp.Event_TypeChange).AddToStatics()",OP,bI,function NZo))call Dcx(Xdx("FolderUnit_FolderDrop_StructSupply_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDrop_StructSupply.Event_TypeChange).AddToStatics()",OP,bI,function N0o))endfunctionfunction N2o takes nothing returns booleanlocal integer rFx=(bv)call bQx(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction N3o takes integer oSx,real oux returns nothingset Itv[oSx]=oux
call Oxo((oSx))endfunctionfunction N4o takes integer oSx,real oux returns nothingcall N3o(oSx,(Itv[(oSx)])+oux)endfunctionfunction N5o takes nothing returns booleanlocal integer rFx=(bv)call N4o(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction N6o takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[(((I[(oSx)])))])]))],(((((A[((oSx))]))))),((((otx))+(q)))))endfunctionfunction N7o takes integer oSx,integer XYx,boolean N8o returns nothingif N8o thencall rVx((oSx),cRv+XYx)endifif rnx((oSx),cOv,XYx)thencall RPx((oSx),cXv)endifcall RPx((oSx),XYx)endfunctionfunction N9o takes nothing returns booleanlocal integer rFx=(bv)local integer bvo=(Vv[(rFx)])local integer XYxloop
set XYx=N6o((bvo),cOv)exitwhen(XYx==w)
call N7o(bvo,XYx,true)endloopreturn trueendfunctionfunction beo takes integer oSx,real oux returns nothingset ITv[(oSx)]=(((ITv[(oSx)])+oux)*1.)endfunctionfunction bxo takes nothing returns booleanlocal integer rFx=(bv)call beo(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction boo takes integer oSx,real oux returns nothingset Cu[(oSx)]=((K2x(oSx,false)+oux)*1.)endfunctionfunction bro takes integer oSx,integer Ako,integer AKo returns nothingcall boo(oSx,(NOv[(AKo)])-(NOv[(Ako)]))endfunctionfunction bio takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])call bro(oSx,Ako,AKo)return trueendfunctionfunction bao takes integer rLx returns booleanreturn(I8x((blv),Ob,(rLx)))endfunctionfunction bno takes integer oSx returns nothinglocal integer aCx=(bGv[(oSx)])local integer oux=(GetHeroLevel(C[((oSx))]))
set bGv[oSx]=oux
call UnitModifySkillPoints(C[(oSx)],aCx-oux)
if(oux==0)thenreturnendifcall IWo(oSx,aCx,oux)endfunctionfunction bVo takes nothing returns booleanlocal integer rLx=Q2x()if not bao(rLx)thenreturn trueendifif cAv thenset cAv=falsereturn trueendifcall bno(rLx)return trueendfunctionfunction bEo takes nothing returns nothingset cIv=XJx(function bVo)set blv=Jbx("FolderUnit_FolderLevel_StructEvents_Init: set FolderUnit_FolderLevel_StructEvents.REG_GROUP = UnitList.Create()")call Q5x(cIv,Ge,EVENT_PLAYER_HERO_LEVEL,null)endfunctionfunction bXo takes nothing returns nothingset bhv[0+1]=0set bhv[0+2]=$96
set bhv[0+3]=400
set bhv[0+4]=750
set bhv[0+5]=$4B0set bhv[0+6]=$6D6set bhv[0+7]=$960set bhv[0+8]=$C4Eset bhv[0+9]=$FA0set bhv[0+$A]=4950set bhv[0+$B]=6000set bhv[0+$C]=7150set bhv[0+$D]=8400set bhv[0+$E]=9750set bhv[0+$F]=$2BC0set bhv[0+16]=$31CEset bhv[0+17]=$3840set bhv[0+18]=$3F16set bhv[0+19]=$4650set bhv[0+20]=$4DEEcall bEo()endfunctionfunction bOo takes integer oSx,real oux returns nothingset Iuv[(oSx)]=(((Iuv[(oSx)])+oux)*1.)endfunctionfunction bRo takes nothing returns booleanlocal integer rFx=(bv)call bOo(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction bIo takes nothing returns nothingendfunctionfunction bAo takes integer oSx,real oux returns nothingset IUv[(oSx)]=(((IUv[(oSx)])+oux)*1.)endfunctionfunction bNo takes nothing returns booleanlocal integer rFx=(bv)call bAo(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction bbo takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])set rG[oSx]=(rG[(oSx)])+(NLv[(AKo)])-(NLv[(Ako)])call cTx(oSx,(Nmv[(AKo)])-(Nmv[(Ako)]))return trueendfunctionfunction bBo takes nothing returns nothingendfunctionfunction bco takes nothing returns booleanlocal integer rFx=(bv)call c0x(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction bCo takes nothing returns nothingcall Dcx(Xdx("FolderUnit_StructMaxLife_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructMaxLife.Event_TypeChange).AddToStatics()",OP,bI,function bbo))call bBo()set cBv=Ayo(n5v,function bco)endfunctionfunction bdo takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])set LF[oSx]=(LF[(oSx)])+(NMv[(AKo)])-(NMv[(Ako)])call BKx(oSx,(Npv[(AKo)])-(Npv[(Ako)]))return trueendfunctionfunction bDo takes nothing returns nothingendfunctionfunction bfo takes nothing returns booleanlocal integer rFx=(bv)call BTx(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction bFo takes nothing returns nothingcall Dcx(Xdx("FolderUnit_StructMaxMana_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructMaxMana.Event_TypeChange).AddToStatics()",OP,bI,function bdo))call bDo()set ccv=Ayo(Vcv,function bfo)endfunctionfunction bgo takes integer oSx,real oux returns nothingset vb[(oSx)]=((Opx(oSx,false)+oux)*1.)endfunctionfunction bGo takes integer oSx,integer Ako,integer AKo returns nothingcall bgo(oSx,(NWv[(AKo)])-(NWv[(Ako)]))endfunctionfunction bho takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])call bGo(oSx,Ako,AKo)return trueendfunctionfunction bHo takes integer oSx,integer oux returns nothingset NIv[(oSx)]=((NIv[(oSx)])+oux)endfunctionfunction bjo takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])call bHo(oSx,Rlo((NAv[(AKo)]))-Rlo((NAv[(Ako)])))return trueendfunctionfunction bJo takes nothing returns nothingcall UnitAddAbility(vJ[((eJ))],('ARev'))
call Dcx(Xdx("FolderUnit_FolderRevival_StructAble_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderRevival_StructAble.Event_TypeChange).AddToStatics()",OP,bI,function bjo))set XP=(E3x())endfunctionfunction bko takes integer oSx,real oux returns nothingset NBv[oSx]=oux
call Rqo((oSx))endfunctionfunction bKo takes integer oSx,real oux returns nothingcall bko(oSx,(NBv[(oSx)])+oux)endfunctionfunction blo takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])set NNv[oSx]=(NNv[(oSx)])+(Nbv[(AKo)])-(Nbv[(Ako)])call bKo(oSx,(Ncv[(AKo)])-(Ncv[(Ako)]))return trueendfunctionfunction bLo takes nothing returns nothingendfunctionfunction bmo takes nothing returns nothingcall Dcx(Xdx("FolderUnit_StructSightRange_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructSightRange.Event_TypeChange).AddToStatics()",OP,bI,function blo))call bLo()endfunctionfunction bMo takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])call BMx(oSx,(NGv[(AKo)])-(NGv[(Ako)]))return trueendfunctionfunction bpo takes nothing returns booleanlocal integer rFx=(bv)call BUx(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction bPo takes integer oSx,real oux returns nothingset ZF[oSx]=ouxcall BLx((oSx))endfunctionfunction bqo takes integer oSx,real oux returns nothingcall bPo(oSx,(ZF[(oSx)])+oux)endfunctionfunction bQo takes nothing returns booleanlocal integer rFx=(bv)call bqo(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction bso takes nothing returns nothingcall Dcx(Xdx("FolderUnit_FolderSpellPower_StructBase_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderSpellPower_StructBase.Event_TypeChange).AddToStatics()",OP,bI,function bMo))set cCv=Ayo(X4v,function bpo)set Ehv=Ayo(X6v,function bQo)endfunctionfunction bSo takes integer oSx,real oux returns nothingset NHv[oSx]=oux
call Ruo((oSx))endfunctionfunction bto takes integer oSx,real oux returns nothingcall bSo(oSx,(NHv[(oSx)])+oux)endfunctionfunction bTo takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])call bto(oSx,(Njv[(AKo)])-(Njv[(Ako)]))return trueendfunctionfunction buo takes integer oSx,real oux returns nothingset NJv[oSx]=oux
call Ruo((oSx))endfunctionfunction bUo takes integer oSx,real oux returns nothingcall buo(oSx,(NJv[(oSx)])+oux)endfunctionfunction bwo takes nothing returns booleanlocal integer rFx=(bv)call bUo(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction bWo takes integer oSx,real oux returns nothingset Nkv[oSx]=oux
call Ruo((oSx))endfunctionfunction byo takes integer oSx,real oux returns nothingcall bWo(oSx,(Nkv[(oSx)])+oux)endfunctionfunction bYo takes nothing returns booleanlocal integer rFx=(bv)call byo(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction bzo takes nothing returns nothingcall Dcx(Xdx("FolderUnit_FolderSpellVamp_StructBase_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderSpellVamp_StructBase.Event_TypeChange).AddToStatics()",OP,bI,function bTo))set cdv=Ayo(Oxv,function bwo)set cDv=Ayo(Orv,function bYo)endfunctionfunction bZo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oDxlocal integer oMx=CIx(rLx,cFv)call RPx(rLx,cfv)loop
set oDx=CAx(rLx,cFv,oMx)
call rnx(rLx,cFv,oDx)call rVx(rLx,ak+oDx)
call rVx(rLx,nk+oDx)
call rVx(rLx,Vk+oDx)
call rVx(rLx,Ek+oDx)
call hjx(oDx,cgv)set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction b_o takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])call fJx(oSx,(Nyv[(AKo)])-(Nyv[(Ako)]),(NYv[(AKo)])-(NYv[(Ako)]),(Nzv[(AKo)])-(Nzv[(Ako)]),(NZv[(AKo)])-(NZv[(Ako)]))return trueendfunctionfunction b0o takes nothing returns booleanlocal integer rFx=(bv)local integer IQx=(Fc[(rFx)])local real izx=nCv[(IQx)]local real iZx=ndv[(IQx)]local real i_x=nDv[(IQx)]local real i0x=nfv[(IQx)]if(Dc[(rFx)])thencall fJx(((Vv[(rFx)])),izx,iZx,i_x,i0x)else
call fJx((((Vv[(rFx)]))),-((izx)*1.),-((iZx)*1.),-((i_x)*1.),-((i0x)*1.))endifreturn trueendfunctionfunction b1o takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oMx=CIx(rLx,Gk)local integer oSxloop
set oSx=CAx(rLx,Gk,oMx)call fqx(oSx,Fk[oSx],rLx)set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction b2o takes nothing returns booleanlocal integer rFx=(bv)local integer IQx=(Fc[(rFx)])local real izx=chv[(IQx)]local real iZx=cHv[(IQx)]local real i_x=cjv[(IQx)]local real i0x=cJv[(IQx)]local real iMx=ckv[(IQx)]if(Dc[(rFx)])thencall fsx(((Vv[(rFx)])),izx,iZx,i_x,i0x,iMx)else
call fsx((((Vv[(rFx)]))),-((izx)*1.),-((iZx)*1.),-((i_x)*1.),-((i0x)*1.),((iMx)*1.))
endifreturn trueendfunctionfunction b3o takes nothing returns nothingset hk=Xdx("FolderUnit_FolderVertexColor_StructTimed_Init: set FolderUnit_FolderVertexColor_StructTimed.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderVertexColor_StructTimed.Event_Destroy)",EP,bI,function b1o)set cGv=Ayo(Rk,function b2o)
set kk=iXx()
endfunctionfunction b4o takes nothing returns nothingset cfv=Xdx("FolderUnit_StructVertexColor_Init: set FolderUnit_StructVertexColor.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructVertexColor.Event_Destroy)",EP,bI,function bZo)call Dcx(Xdx("FolderUnit_StructVertexColor_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructVertexColor.Event_TypeChange).AddToStatics()",OP,bI,function b_o))set ncv=Ayo(nov,function b0o)call b3o()endfunctionfunction b5o takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=osx(rLx,xqv)call Uax(oSx,rLx)return trueendfunctionfunction b6o takes nothing returns nothingset xuv=Xdx("FolderUnit_FolderAnimation_StructLoop_Init: set FolderUnit_FolderAnimation_StructLoop.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAnimation_StructLoop.Event_Death)",VP,bI,function b5o)
set xyv=iXx()endfunctionfunction b7o takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=(Vv[(rFx)])local integer oMx=(CIx(((oSx)),vB))local integer Iaxloop
set Iax=(CAx(((oSx)),vB,(oMx)))if(Pc[(Iax)])thencall AZx(oSx,Iax)endifset oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction b8o takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=(Vv[(rFx)])local integer oMx=(CIx(((oSx)),vB))local integer Iaxloop
set Iax=(CAx(((oSx)),vB,(oMx)))call AZx(oSx,Iax)set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction b9o takes nothing returns nothingset Mc=(E3x())set bd=(E3x())set jc=(E3x())endfunctionfunction Bvo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oMx=CIx(rLx,td)local integer oSxloop
set oSx=CAx(rLx,td,oMx)call Nrx(oSx)set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction Beo takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer rLx=(Vv[(rFx)])local integer Iax=(Hc[(rFx)])local integer oSx=(IGx(E[((X))],(Cd),(((rLx))),((Iax)),((rYx)),(w)))
if(oSx!=w)thencall Nrx(oSx)endifreturn trueendfunctionfunction Bxo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oMx=CIx(rLx,Qd)local integer oSxloop
set oSx=CAx(rLx,Qd,oMx)call Nvx(oSx,Sd[oSx],rLx)set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction Boo takes nothing returns nothingset Td=Xdx("FolderUnit_FolderBuffs_StructTimed_Init: set FolderUnit_FolderBuffs_StructTimed.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderBuffs_StructTimed.Event_Death)",VP,bI,function Bvo)set ud=Xdx("FolderUnit_FolderBuffs_StructTimed_Init: set FolderUnit_FolderBuffs_StructTimed.LOSE_EVENT = Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderBuffs_StructTimed.Event_Lose)",jc,bI,function Beo)set sd=Xdx("FolderUnit_FolderBuffs_FolderTimed_StructCountdown_Init: set FolderUnit_FolderBuffs_FolderTimed_StructCountdown.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderBuffs_FolderTimed_StructCountdown.Event_Death)",VP,bI,function Bxo)endfunctionfunction Bro takes nothing returns nothingset eB=Xdx("FolderUnit_StructBuffs_Init: set FolderUnit_StructBuffs.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructBuffs.Event_Death)",VP,bI,function b7o)set xB=Xdx("FolderUnit_StructBuffs_Init: set FolderUnit_StructBuffs.DESTROY_EVENT = Event.Create(UNIT.DESTROY_EVENT_TYPE, EventPriority.HEADER_TOP, function FolderUnit_StructBuffs.Event_Destroy)",EP,GI,function b8o)call b9o()call Boo()endfunctionfunction Bio takes integer oSx,real oux returns nothingset A4v[(oSx)]=(((A4v[(oSx)])+oux)*1.)endfunctionfunction Bao takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])call Bio(oSx,(A5v[(AKo)])-(A5v[(Ako)]))return trueendfunctionfunction Bno takes integer oSx,boolean iTx returns nothingcall UnitSuspendDecay(C[(oSx)],iTx)endfunctionfunction BVo takes nothing returns nothinglocal integer BEo=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))call Bno(adx(clv[BEo]),true)
call iKx(BEo)endfunctionfunction BXo takes nothing returns booleanlocal integer BEo=iXx()set clv[BEo]=C[Q2x()]call iDx(BEo,.0,false,function BVo)return trueendfunctionfunction BOo takes nothing returns booleanif not(I8x((A6v),Ob,(jhx())))thenreturn false
endifreturn truereturn trueendfunctionfunction BRo takes nothing returns nothingset cKv=XJx(function BXo)set A6v=Jbx("FolderUnit_FolderDecay_StructEvents_Init: set FolderUnit_FolderDecay_StructEvents.REG_GROUP = UnitList.Create()")call Q5x(cKv,Ge,EVENT_PLAYER_UNIT_DECAY,function BOo)endfunctionfunction BIo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=osx(rLx,civ)call Nmo(oSx,cov[oSx],rLx)return trueendfunctionfunction BAo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=osx(rLx,civ)call Nmo(oSx,cov[oSx],rLx)return trueendfunctionfunction BNo takes nothing returns nothingset cav=Xdx("FolderUnit_FolderDecay_StructTimed_Init: set FolderUnit_FolderDecay_StructTimed.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDecay_StructTimed.Event_Destroy)",EP,bI,function BIo)
set cnv=Xdx("FolderUnit_FolderDecay_StructTimed_Init: set FolderUnit_FolderDecay_StructTimed.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDecay_StructTimed.Event_Revive)",XP,bI,function BAo)endfunctionfunction Bbo takes nothing returns nothingcall Dcx(Xdx("FolderUnit_FolderDecay_StructDuration_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDecay_StructDuration.Event_TypeChange).AddToStatics()",OP,bI,function Bao))call BRo()call BNo()endfunctionfunction BBo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=rLxcall RPx(rLx,BRv)call dKx(oSx)return trueendfunctionfunction Bco takes integer oqx returns integerreturn(LoadInteger(o[((V[(E[((X))])]))],(((oqx))),(((Aj)))))
endfunctionfunction BCo takes integer oSx returns integerset nj[oSx]=true
set cMv[oSx]=falsecall rEx(Vj)
return oSxendfunctionfunction Bdo takes nothing returns integerlocal integer oSxif(cLv==8190)thencall o_x("OrderInstance_Allocation_allocCustom","call DebugEx(OrderInstance.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",aj+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(ij[(w)]==w)thenset cmv=cmv+1set oSx=cmvelse
set oSx=ij[(w)]set ij[(w)]=ij[ij[(w)]]endifset ij[oSx]=Zset rj[oSx]=1call BCo(oSx)return oSxendfunctionfunction BDo takes integer oSx returns nothingset Oh[(oSx)]=(w)set hj[(oSx)]=(w)set Hj[(oSx)]=(w)set fj[(oSx)]=((.0)*1.)set Fj[(oSx)]=((.0)*1.)endfunctionfunction Bfo takes integer oSx returns nothingset xj[oSx]=0set oj[oSx]=falseendfunctionfunction BFo takes nothing returns integerlocal integer oSx=Bdo()call BDo(oSx)call Bfo(oSx)return oSxendfunctionfunction Bgo takes nothing returns booleanlocal integer oSx=Q2x()local integer Rox=(Bco(GetIssuedOrderId()))local integer I6x=BFo()set Oh[(I6x)]=(Rox)set cpv[(I6x)]=(0)if nh[oSx]thenif(Xh[oSx]!=w)thencall dkx(Xh[oSx])endifset Xh[oSx]=I6xreturn trueendifif(O6v[((oSx))])then
return trueendifcall d4x(oSx,I6x)return trueendfunctionfunction BGo takes nothing returns nothingset Cj=(E3x())set Mb=XJx(function Bgo)
endfunctionfunction Bho takes nothing returns booleanlocal real dVx=(GetOrderPointX())local real dEx=(GetOrderPointY())local integer oSx=Q2x()local integer Rox=(Bco(GetIssuedOrderId()))local integer I6x=BFo()set Oh[(I6x)]=(Rox)set fj[(I6x)]=((dVx)*1.)
set Fj[(I6x)]=((dEx)*1.)
set cpv[(I6x)]=(2)if Vh[oSx]thenif(Dj[oSx]!=w)thencall dkx(Dj[oSx])endifset Dj[oSx]=I6xreturn trueendifcall Dox(oSx,I6x)return trueendfunctionfunction BHo takes nothing returns nothingset gj=(E3x())set bh=XJx(function Bho)
endfunctionfunction Bjo takes item oqx returns integerreturn(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((oqx))))),((((hh))))))endfunctionfunction BJo takes nothing returns integerlocal unit oqx=GetOrderTargetUnit()local integer o7xif(GetUnitAbilityLevel(oqx,'aLoc')>0)thenset oqx=null
return Z
endifset o7x=adx(oqx)
set oqx=null
return o7xendfunctionfunction Bko takes nothing returns booleanlocal integer dax=(Bjo(GetOrderTargetItem()))local integer dnx=BJo()local integer oSx=Q2x()local integer Rox=(Bco(GetIssuedOrderId()))local integer I6x=BFo()set Oh[(I6x)]=(Rox)set hj[(I6x)]=(dax)set Hj[(I6x)]=(dnx)set cpv[(I6x)]=(4)if Eh[oSx]thenif(Gj[oSx]!=w)thencall dkx(Gj[oSx])endifset Gj[oSx]=I6xreturn trueendifcall Dnx(oSx,I6x)return trueendfunctionfunction BKo takes nothing returns nothingset jj=(E3x())set BIv=XJx(function Bko)set Jj=(E3x())endfunctionfunction Blo takes nothing returns nothingcall BGo()call BHo()call BKo()endfunctionfunction BLo takes integer oSx returns booleanif(((cQv[((oSx))])>0)==false)thenreturn false
endifset cQv[csv[cSv]]=cQv[oSx]set csv[cQv[oSx]-1]=csv[cSv]
set cQv[oSx]=0set cSv=cSv-1return(cSv==F)endfunctionfunction Bmo takes integer oSx returns booleanif(((ctv[((oSx))])>0)==false)thenreturn false
endifset ctv[cTv[cuv]]=ctv[oSx]set cTv[ctv[oSx]-1]=cTv[cuv]
set ctv[oSx]=0set cuv=cuv-1return(cuv==F)endfunctionfunction BMo takes integer oSx,integer XYx returns nothingif rnx((oSx),cqv,XYx)thencall BLo(oSx)call RPx((oSx),cPv)if Bmo(oSx)thencall ikx(cUv)endifendifcall RPx((oSx),XYx)endfunctionfunction Bpo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oMx=CIx(rLx,cqv)loop
call BMo((rLx),CAx(rLx,cqv,oMx))
set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction BPo takes integer oSx returns booleanif(((cYv[((oSx))])>0)==false)thenreturn false
endifset cYv[czv[cZv]]=cYv[oSx]set czv[cYv[oSx]-1]=czv[cZv]
set cYv[oSx]=0set cZv=cZv-1return(cZv==F)endfunctionfunction Bqo takes integer oSx returns nothinglocal integer rLx=oSxlocal integer rFx=rRx((A[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset Vv[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,cwv,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(rLx,cwv,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction BQo takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=(Vv[(rFx)])if not((cQv[((oSx))])>0)then
return trueendifcall Bmo(oSx)if((cYv[((oSx))])>0)then
call BPo(oSx)call Bqo(oSx)endifreturn trueendfunctionfunction Bso takes integer oSx returns booleanif((ctv[((oSx))])>0)then
return false
endifset cuv=cuv+1set cTv[cuv]=oSx
set ctv[oSx]=cuv+1return(cuv==0)endfunctionfunction BSo takes integer oSx returns booleanif((cYv[((oSx))])>0)then
return false
endifset cZv=cZv+1set czv[cZv]=oSx
set cYv[oSx]=cZv+1return(cZv==0)endfunctionfunction Bto takes integer oSx returns nothinglocal integer rLx=oSxlocal integer rFx=rRx((A[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset Vv[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,cyv,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(rLx,cyv,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction BTo takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=(Vv[(rFx)])if not((cQv[((oSx))])>0)then
return trueendifcall Bso(oSx)call BSo(oSx)call Bto(oSx)return trueendfunctionfunction Buo takes nothing returns nothingset cPv=Xdx("FolderUnit_FolderOrder_FolderEvents_StructIdle_Init: set FolderUnit_FolderOrder_FolderEvents_StructIdle.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderOrder_FolderEvents_StructIdle.Event_Destroy)",EP,bI,function Bpo)
set cwv=(E3x())set cWv=(E3x())set cyv=(E3x())set cUv=iXx()call Dcx(Xdx("FolderUnit_FolderOrder_FolderEvents_StructIdle_Init: call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderOrder_FolderEvents_StructIdle.Event_Death).AddToStatics()",VP,bI,function BQo))
call Dcx(Xdx("FolderUnit_FolderOrder_FolderEvents_StructIdle_Init: call Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderOrder_FolderEvents_StructIdle.Event_Revive).AddToStatics()",XP,bI,function BTo))endfunctionfunction BUo takes integer oSx returns nothingcall IRo(vj,oSx)
call RPx((oSx),BAv)if not(I8x((Ej),Ob,(oSx)))thenreturnendifcall IRo(Ej,oSx)
if(dmx((Ej),Ob))then
call ikx(Xj)
endifendfunctionfunction Bwo takes nothing returns booleanlocal integer rFx=(bv)call BUo(((Vv[(rFx)])))return trueendfunctionfunction BWo takes nothing returns nothingset BAv=Xdx("FolderUnit_FolderOrder_FolderEvents_StructLose_Init: set FolderUnit_FolderOrder_FolderEvents_StructLose.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderOrder_FolderEvents_StructLose.Event_Destroy)",EP,bI,function Bwo)
set Bj=Jbx("FolderUnit_FolderOrder_FolderEvents_StructLose_Init: set FolderUnit_FolderOrder_FolderEvents_StructLose.ENUM_GROUP = UnitList.Create()")
set vj=Jbx("FolderUnit_FolderOrder_FolderEvents_StructLose_Init: set FolderUnit_FolderOrder_FolderEvents_StructLose.REG_GROUP = UnitList.Create()")set Ej=Jbx("FolderUnit_FolderOrder_FolderEvents_StructLose_Init: set FolderUnit_FolderOrder_FolderEvents_StructLose.UPDATE_GROUP = UnitList.Create()")set Xj=iXx()
endfunctionfunction Byo takes nothing returns nothingcall Blo()call Buo()call BWo()endfunctionfunction BYo takes nothing returns nothingset BRv=Xdx("FolderUnit_StructOrder_Init: set FolderUnit_StructOrder.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructOrder.Event_Destroy)",EP,bI,function BBo)
call Byo()endfunctionfunction Bzo takes nothing returns nothingendfunctionfunction BZo takes integer oSx returns nothingset c3v[oSx]=falsecall rHx(Rov)endfunctionfunction B_o takes integer oSx returns nothingif(c1v[oSx]>0)thenreturnendifif(c2v[oSx]!=Z)thencall o_x("FolderUnit_FolderPosition_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderPosition_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Rrv+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset c2v[oSx]=c2v[(w)]set c2v[(w)]=oSx
call BZo(oSx)endfunctionfunction B0o takes integer oSx returns nothingset c1v[oSx]=c1v[oSx]-1call B_o(oSx)endfunctionfunction B1o takes integer oSx returns booleanlocal integer oLx=(c5v[(oSx)])set c5v[c6v[c7v]]=oLxset c6v[oLx-1]=c6v[c7v]set c5v[oSx]=0set c7v=c7v-1return(c7v==F)endfunctionfunction B2o takes integer Iix returns booleanreturn( not((NPv[((Tf[(Iix)]))])<=.0))endfunctionfunction B3o takes integer oSx returns integerset Crv[oSx]=trueset Civ[oSx]=falsecall rEx(Rev)return oSxendfunctionfunction B4o takes nothing returns integerlocal integer oSxif(Cvv==8190)thencall o_x("FolderUnit_FolderPosition_FolderTimed_StructAccelerated_Allocation_allocCustom","call DebugEx(FolderUnit_FolderPosition_FolderTimed_StructAccelerated.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Rxv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Cev[(w)]==w)thenset Cxv=Cxv+1set oSx=Cxvelse
set oSx=Cev[(w)]
set Cev[(w)]=Cev[Cev[(w)]]endifset Cev[oSx]=Zset Cov[oSx]=1call B3o(oSx)return oSxendfunctionfunction B5o takes integer oSx returns booleanset CBv=CBv+1set Ccv[CBv]=oSx
set CCv[oSx]=CBv+1return(CBv==0)endfunctionfunction B6o takes integer oSx,real oux returns nothingcall fwx(oSx,(GetUnitX(C[((oSx))]))+oux)
endfunctionfunction B7o takes integer oSx,real oux returns nothingcall fWx(oSx,(GetUnitY(C[((oSx))]))+oux)
endfunctionfunction B8o takes integer oSx,real z returns nothingcall fyx(oSx,(GetUnitX(C[(((oSx)))])),(GetUnitY(C[(((oSx)))])),z)endfunctionfunction B9o takes integer oSx,real oux returns nothingcall B8o(oSx,fYx(oSx)+oux)endfunctionfunction cvo takes nothing returns nothinglocal integer oMx=CBvlocal integer oSxlocal integer rLxlocal real N5xlocal real N6xlocal real cNxloop
set oSx=Ccv[oMx]
set rLx=Cnv[oSx]
set N5x=CVv[oSx]+CEv[oSx]set N6x=CXv[oSx]+COv[oSx]set cNx=CRv[oSx]+CIv[oSx]set CVv[oSx]=N5x
set CXv[oSx]=N6x
set CRv[oSx]=cNx
call B6o(rLx,N5x)call B7o(rLx,N6x)call B9o(rLx,cNx)set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction ceo takes integer oSx returns nothingset Crv[oSx]=falsecall rHx(Rev)endfunctionfunction cxo takes integer oSx returns nothingif(Cov[oSx]>0)thenreturnendifif(Cev[oSx]!=Z)thencall o_x("FolderUnit_FolderPosition_FolderTimed_StructAccelerated_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderPosition_FolderTimed_StructAccelerated.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Rxv+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Cev[oSx]=Cev[(w)]set Cev[(w)]=oSx
call ceo(oSx)endfunctionfunction coo takes integer oSx returns nothingset Cov[oSx]=Cov[oSx]-1call cxo(oSx)endfunctionfunction cro takes integer oSx returns booleanlocal integer oLx=(CCv[(oSx)])set CCv[Ccv[CBv]]=oLxset Ccv[oLx-1]=Ccv[CBv]set CCv[oSx]=0set CBv=CBv-1return(CBv==F)endfunctionfunction cio takes integer oSx returns nothingset Od=oSxcall TriggerEvaluate(CDv)endfunctionfunction cao takes integer oSx,integer iCx,integer rLx returns nothingcall coo((oSx))call iKx(iCx)if rnx(rLx,CAv,oSx)thencall RPx(rLx,CNv)call RPx(rLx,Cbv)endifif cro(oSx)thencall ikx(Cdv)endifcall cio(rLx)endfunctionfunction cno takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])call cao(oSx,iCx,Cnv[oSx])endfunctionfunction cVo takes integer oSx,real N5x,real N6x,real cNx,real cEo,real cXo,real cOo,real iMx returns nothinglocal integer rLx=oSxlocal integer fexlocal integer iCxif not B2o(oSx)thenreturnendifset fex=(R2I(((iAx((1),((R2I(((iMx*1./ c9v+.5)*1.))))))*1.)))set oSx=B4o()set iCx=iXx()set Cav[oSx]=iCx
set Cnv[oSx]=rLx
set CVv[oSx]=N5x*1./ fex
set CEv[oSx]=cEo*1./ fex*c9v
set CXv[oSx]=N6x*1./ fex
set COv[oSx]=cXo*1./ fex*c9v
set CRv[oSx]=cNx*1./ fex
set CIv[oSx]=cOo*1./ fex*c9v
set ge[(iCx)]=(oSx)if rUx(rLx,CAv,oSx)thencall Avx(rLx,CNv)call Avx(rLx,Cbv)endifif B5o(oSx)thencall iDx(Cdv,c9v,true,function cvo)endifcall iDx(iCx,iMx,false,function cno)
endfunctionfunction cRo takes integer oSx returns integerset Xu[oSx]=true
set Cgv[oSx]=falseset iT[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set RT[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(Zt)
return oSxendfunctionfunction cIo takes nothing returns integerlocal integer oSxif(Cfv==8190)thencall o_x("Lightning_Allocation_allocCustom","call DebugEx(Lightning.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",vT+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(Eu[(w)]==w)thenset CFv=CFv+1set oSx=CFvelse
set oSx=Eu[(w)]set Eu[(w)]=Eu[Eu[(w)]]endifset Eu[oSx]=Zset Vu[oSx]=1call cRo(oSx)return oSxendfunctionfunction cAo takes integer oSx returns nothingset aT[(oSx)]=(CHv+oSx)endfunctionfunction cNo takes integer oSx returns nothingset UT[(oSx)]=((GetLightningColorR(YT[(oSx)]))*1.)endfunctionfunction cbo takes integer oSx returns nothingset wT[(oSx)]=((GetLightningColorG(YT[(oSx)]))*1.)endfunctionfunction cBo takes integer oSx returns nothingset WT[(oSx)]=((GetLightningColorB(YT[(oSx)]))*1.)endfunctionfunction cco takes integer oSx returns nothingset yT[(oSx)]=((GetLightningColorA(YT[(oSx)]))*1.)endfunctionfunction cCo takes integer oSx returns nothingcall cNo(oSx)call cbo(oSx)call cBo(oSx)call cco(oSx)call Kpx(oSx,(UT[(oSx)]),(wT[(oSx)]),(WT[(oSx)]),(yT[(oSx)]))endfunctionfunction cdo takes integer rNx returns integerlocal integer oSx=cIo()local lightning oqx=AddLightningEx((tE[(rNx)]),false,.0,.0,.0,.0,.0,.0)set CGv[oSx]=trueset uT[oSx]=falseset YT[oSx]=oqxcall cAo(oSx)call cCo(oSx)return oSxendfunctionfunction cDo takes integer oSx returns nothingif uT[oSx]thencall Kmx(oSx)endifset uT[oSx]=true
endfunctionfunction cfo takes integer oSx returns integerset wu[oSx]=true
set Ckv[oSx]=falsecall rEx(Ut)
return oSxendfunctionfunction cFo takes nothing returns integerlocal integer oSxif(Cjv==8190)thencall o_x("FolderLightning_StructFromSpotToUnit_Allocation_allocCustom","call DebugEx(FolderLightning_StructFromSpotToUnit.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",wt+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Uu[(w)]==w)thenset CJv=CJv+1set oSx=CJvelse
set oSx=Uu[(w)]set Uu[(w)]=Uu[Uu[(w)]]endifset Uu[oSx]=Zset uu[oSx]=1call cfo(oSx)return oSxendfunctionfunction cgo takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((iT[(oSx)]))])]))],((((aT[((oSx))])))),(((otx))),(((oux))))endfunctionfunction cGo takes integer oSx,real x,real y,real z,real x2,real y2,real z2 returns nothingcall MoveLightningEx(YT[oSx],CGv[oSx],x,y,z,x2,y2,z2)endfunctionfunction cho takes integer oSx returns booleanset vU=vU+1set Zu[vU]=oSxset zu[oSx]=vU+1
return(vU==0)endfunctionfunction cHo takes nothing returns nothinglocal integer oMx=vU
local integer oSxlocal integer Iixlocal real dVxlocal real dExlocal real MQxloop
set oSx=Zu[oMx]set Iix=xU[oSx]if(Iix==w)thenset dVx=CMv[oSx]
set dEx=Cpv[oSx]
set MQx=CPv[oSx]
else
set dVx=Dsx(Iix)
set dEx=Dtx(Iix)
set MQx=OMx(Iix,dVx,dEx)+K2x(Iix,true)endifcall cGo(oU[oSx],CKv[oSx],Clv[oSx],CLv[oSx],dVx,dEx,MQx)
set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction cjo takes integer oSx,real jMx,real jpx,real cJo,integer Iix returns nothinglocal integer rLx=oSxlocal real dVx=Dsx(Iix)local real dEx=Dtx(Iix)call cDo(rLx)set oSx=cFo()set oU[oSx]=rLxset CKv[oSx]=jMx
set Clv[oSx]=jpx
set CLv[oSx]=cJo
set xU[oSx]=Iixcall cgo(rLx,Tu,oSx)
call KSx(rLx,Su)
if rUx(Iix,yu,oSx)thencall Avx(Iix,Yu)
call A_o(Iix)endifcall cGo(rLx,jMx,jpx,cJo,dVx,dEx,OMx(Iix,dVx,dEx)+K2x(Iix,true))
if cho(oSx)thencall iDx(eU,Cmv,true,function cHo)endifendfunctionfunction cko takes integer oSx returns integerset FT[oSx]=true
set Csv[oSx]=falsecall rEx(Yt)
return oSxendfunctionfunction cKo takes nothing returns integerlocal integer oSxif(Cqv==8190)thencall o_x("FolderLightning_StructDestroyTimed_Allocation_allocCustom","call DebugEx(FolderLightning_StructDestroyTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",zt+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(fT[(w)]==w)thenset CQv=CQv+1set oSx=CQvelse
set oSx=fT[(w)]set fT[(w)]=fT[fT[(w)]]endifset fT[oSx]=Zset DT[oSx]=1call cko(oSx)return oSxendfunctionfunction clo takes nothing returns nothinglocal integer iCx=iGx()local integer oSx=(ge[(iCx)])local integer rLx=CSv[oSx]call Kdx(oSx,iCx,rLx)call K0x(rLx)endfunctionfunction cLo takes integer oSx,real iMx returns nothinglocal integer rLx=oSxlocal integer iCxset oSx=KNx(rLx,dT)if(oSx!=w)thencall Kdx(oSx,gT[oSx],rLx)endifset oSx=cKo()set iCx=iXx()set gT[oSx]=iCxset CSv[oSx]=rLx
set ge[(iCx)]=(oSx)call cgo(rLx,dT,oSx)
call KSx(rLx,cT)
call iDx(iCx,iMx,false,function clo)
endfunctionfunction cmo takes integer oSx returns nothinglocal real iMxlocal integer cMolocal real jMx=(GetUnitX(C[((oSx))]))local real jpx=(GetUnitY(C[((oSx))]))local item cpo=CreateItem('iUPN',jMx,jpx)local real dVx=GetWidgetX(cpo)local real dEx=GetWidgetY(cpo)local real d=jKx(dVx-jMx,dEx-jpx)call RemoveItem(cpo)
set cpo=null
if(d<1.)then
returnendifset iMx=d*1./ 150.call cVo(oSx,dVx-jMx,dEx-jpx,.0,.0,.0,.0,iMx)set cMo=cdo(REv)
call cjo(cMo,dVx,dEx,X_x(dVx,dEx),oSx)call cLo(cMo,iMx)endfunctionfunction cPo takes integer oSx,integer iCx,integer rLx returns nothingcall B0o((oSx))call iKx(iCx)if rnx(rLx,c0v,oSx)thencall RPx(rLx,c_v)call RPx(rLx,c4v)endifif B1o(oSx)thencall ikx(c8v)endifcall cmo(rLx)endfunctionfunction cqo takes integer rLx returns nothinglocal integer oMx=CIx(rLx,c0v)local integer oSxloop
set oSx=CAx(rLx,c0v,oMx)
call cPo(oSx,Ctv[oSx],rLx)set oMx=oMx-1exitwhen(oMx<q)endloopendfunctionfunction cQo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])call cqo(rLx)return trueendfunctionfunction cso takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])call cqo(rLx)return trueendfunctionfunction cSo takes integer rLx returns nothinglocal integer oMx=CIx(rLx,CAv)local integer oSxloop
set oSx=CAx(rLx,CAv,oMx)
call cao(oSx,Cav[oSx],rLx)set oMx=oMx-1exitwhen(oMx<q)endloopendfunctionfunction cto takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])call cSo(rLx)return trueendfunctionfunction cTo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])call cSo(rLx)return trueendfunctionfunction cuo takes nothing returns nothingset CNv=Xdx("FolderUnit_FolderPosition_FolderTimed_StructAccelerated_Init: set FolderUnit_FolderPosition_FolderTimed_StructAccelerated.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderPosition_FolderTimed_StructAccelerated.Event_Death)",VP,bI,function cto)set Cbv=Xdx("FolderUnit_FolderPosition_FolderTimed_StructAccelerated_Init: set FolderUnit_FolderPosition_FolderTimed_StructAccelerated.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderPosition_FolderTimed_StructAccelerated.Event_Destroy)",EP,bI,function cTo)set Cdv=iXx()endfunctionfunction cUo takes nothing returns nothingset c_v=Xdx("FolderUnit_FolderPosition_StructTimed_Init: set FolderUnit_FolderPosition_StructTimed.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderPosition_StructTimed.Event_Death)",VP,bI,function cQo)
set c4v=Xdx("FolderUnit_FolderPosition_StructTimed_Init: set FolderUnit_FolderPosition_StructTimed.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderPosition_StructTimed.Event_Destroy)",EP,bI,function cso)set c8v=iXx()call cuo()endfunctionfunction cwo takes nothing returns nothingcall Bzo()call cUo()endfunctionfunction cWo takes integer oSx,integer otx returns nothingcall SaveInteger(o[(((V[(E[((CB[(oSx)]))])])))],(((((iB[((oSx))]))))),((((otx)))),(0))endfunctionfunction cyo takes integer oSx returns nothingset CZv[oSx]=falsecall rHx(RIv)endfunctionfunction cYo takes integer oSx returns nothingif(CYv[oSx]>0)thenreturnendifif(Czv[oSx]!=Z)thencall o_x("FolderUnit_FolderSelection_StructCircle_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderSelection_StructCircle.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",RAv+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Czv[oSx]=Czv[(w)]set Czv[(w)]=oSx
call cyo(oSx)endfunctionfunction czo takes integer oSx returns nothingset CYv[oSx]=CYv[oSx]-1call cYo(oSx)endfunctionfunction cZo takes integer oSx returns nothingcall cWo(CUv[oSx],Cwv)call hjx(CWv[oSx],Cuv+Cyv[oSx])call czo((oSx))endfunctionfunction c_o takes integer oSx,integer oDx returns nothinglocal integer rLx=oSxlocal integer c0oset oSx=hhx(oDx,Cuv+oSx)
set c0o=CUv[oSx]
call cZo(oSx)call Ryx(c0o)endfunctionfunction c1o takes integer oSx,integer oDx returns nothinglocal integer rLx=oSxlocal integer rFx=rRx(0)
local integer Ekolocal integer oMxlocal integer rbxlocal integer rMxset Vv[(rFx)]=(oSx)set ZA[(rFx)]=(oDx)set Eko=rRx((A[(rLx)]))set Vv[(Eko)]=(oSx)set ZA[(Eko)]=(oDx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((C0v))-1)*Iv+(((rbx))-1)))))))))
loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((C0v))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset rMx=rAx(rLx,C0v,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(rLx,C0v,rbx,rMx),Eko)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call rkx(((Eko)))endfunctionfunction c2o takes integer oSx,integer oDx returns nothingcall c_o(oSx,oDx)call hGx(oDx,Cb,oSx)
if rnx((oSx),Cb,oDx)then
call RPx((oSx),CTv)call RPx((oSx),C_v)endifcall c1o(oSx,oDx)endfunctionfunction c3o takes integer rLx returns nothinglocal integer oMx=CIx(rLx,Cb)loop
call c2o((rLx),CAx(rLx,Cb,oMx))set oMx=oMx-1exitwhen(oMx<q)endloopendfunctionfunction c4o takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])call c3o(rLx)return trueendfunctionfunction c5o takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])call c3o(rLx)return trueendfunctionfunction c6o takes nothing returns booleancall c2o((Q2x()),oQx())return trueendfunctionfunction c7o takes integer oSx,integer oDx returns nothinglocal integer rLx=oSxlocal integer rFx=rRx(0)
local integer Ekolocal integer oMxlocal integer rbxlocal integer rMxset Vv[(rFx)]=(oSx)set ZA[(rFx)]=(oDx)set Eko=rRx((A[(rLx)]))set Vv[(Eko)]=(oSx)set ZA[(Eko)]=(oDx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((C3v))-1)*Iv+(((rbx))-1)))))))))
loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((C3v))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset rMx=rAx(rLx,C3v,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(rLx,C3v,rbx,rMx),Eko)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call rkx(((Eko)))endfunctionfunction c8o takes integer oSx returns integerif(oSx==w)thencall o_x("User_GetNativeIndex","call DebugEx(User.NAME + \"GetNativeIndex: no valid user \" + Integer.ToString(this))",TD+"GetNativeIndex: no valid user "+(I2S((oSx))))
return-1
endifif(vx[oSx]==null)thencall o_x("User_GetNativeIndex","call DebugEx(User.NAME + \"GetNativeIndex: no valid self \" + Integer.ToString(this))",TD+"GetNativeIndex: no valid self "+(I2S((oSx))))
return-1
endifreturn GetPlayerId(vx[oSx])endfunctionfunction c9o takes integer oSx returns integerset CZv[oSx]=trueset C7v[oSx]=falsecall rEx(RIv)return oSxendfunctionfunction Cvo takes nothing returns integerlocal integer oSxif(C5v==8190)thencall o_x("FolderUnit_FolderSelection_StructCircle_Allocation_allocCustom","call DebugEx(FolderUnit_FolderSelection_StructCircle.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",RAv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Czv[(w)]==w)thenset C6v=C6v+1set oSx=C6velse
set oSx=Czv[(w)]
set Czv[(w)]=Czv[Czv[(w)]]endifset Czv[oSx]=Zset CYv[oSx]=1call c9o(oSx)return oSxendfunctionfunction Ceo takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((CB[(oSx)]))])]))],((((iB[((oSx))])))),(((otx))),(((oux))))endfunctionfunction Cxo takes integer oSx,integer oDx returns nothinglocal integer rLx=oSxlocal string Coo
local integer c0oif iOx(oDx)thenset Coo=RRv[c8o(oDx)+1]else
set Coo=""endifset oSx=Cvo()set c0o=(ACx((rLx),(Coo),(C8v),(ri)))set CUv[oSx]=c0o
set Cyv[oSx]=rLx
set CWv[oSx]=oDx
call Ceo(c0o,Cwv,oSx)call hlx(oDx,Cuv+rLx,oSx)endfunctionfunction Cro takes integer oSx,integer oDx returns nothinglocal integer rLx=oSxlocal integer rFx=rRx(0)
local integer Ekolocal integer oMxlocal integer rbxlocal integer rMxset Vv[(rFx)]=(oSx)set ZA[(rFx)]=(oDx)set Eko=rRx((A[(rLx)]))set Vv[(Eko)]=(oSx)set ZA[(Eko)]=(oDx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((C2v))-1)*Iv+(((rbx))-1)))))))))
loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((C2v))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset rMx=rAx(rLx,C2v,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(rLx,C2v,rbx,rMx),Eko)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call rkx(((Eko)))endfunctionfunction Cio takes integer oSx,integer oDx returns nothinglocal integer rLx=oSxif not hFx(oDx,Cb,rLx)thencall hqx(oDx,Cb,rLx)
if rUx(rLx,Cb,oDx)thencall Avx(rLx,CTv)call Avx(rLx,C_v)endifcall c7o(oSx,oDx)call Cxo(oSx,oDx)endifcall Cro(oSx,oDx)endfunctionfunction Cao takes nothing returns booleancall Cio((Q2x()),oQx())return trueendfunctionfunction Cno takes nothing returns nothingendfunctionfunction CVo takes nothing returns nothingset CTv=Xdx("FolderUnit_StructSelection_Init: set FolderUnit_StructSelection.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructSelection.Event_Death)",VP,bI,function c4o)set C_v=Xdx("FolderUnit_StructSelection_Init: set FolderUnit_StructSelection.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructSelection.Event_Destroy)",EP,bI,function c5o)
set C0v=(E3x())set C1v=XJx(function c6o)set C2v=(E3x())set C3v=(E3x())set C4v=XJx(function Cao)call Q5x(C1v,Ge,EVENT_PLAYER_UNIT_DESELECTED,null)call Q5x(C4v,Ge,EVENT_PLAYER_UNIT_SELECTED,null)
call Cno()endfunctionfunction CEo takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])call Bix(oSx,(bDv[(AKo)])-(bDv[(Ako)]))return trueendfunctionfunction CXo takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=(Vv[(rFx)])set OF[oSx]=falsecall RPx((oSx),RF)call b0x(oSx,(EF[(oSx)]),XF[oSx])return trueendfunctionfunction COo takes integer oSx,real oux returns nothingset dF[oSx]=ouxcall Box((oSx))endfunctionfunction CRo takes integer oSx,real oux returns nothingcall COo(oSx,(dF[(oSx)])+oux)endfunctionfunction CIo takes nothing returns booleanlocal integer rFx=(bv)call CRo(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction CAo takes nothing returns nothingcall Dcx(Xdx("FolderUnit_FolderAgility_StructBase_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAgility_StructBase.Event_TypeChange).AddToStatics()",OP,bI,function CEo))set RF=Xdx("FolderUnit_FolderAgility_FolderBonus_StructDisplayed_Init: set FolderUnit_FolderAgility_FolderBonus_StructDisplayed.SELECTION_EVENT = Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAgility_FolderBonus_StructDisplayed.Event_Selection)",C3v,bI,function CXo)set C9v=Ayo(RSv,function CIo)endfunctionfunction CNo takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])call B_x(oSx,(bfv[(AKo)])-(bfv[(Ako)]))return trueendfunctionfunction Cbo takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=(Vv[(rFx)])set ig[oSx]=falsecall RPx((oSx),ag)call Bqx(oSx,(og[(oSx)]),rg[oSx])return trueendfunctionfunction CBo takes integer oSx,real oux returns nothingset Ig[oSx]=ouxcall Bzx((oSx))endfunctionfunction Cco takes integer oSx,real oux returns nothingcall CBo(oSx,(Ig[(oSx)])+oux)endfunctionfunction CCo takes nothing returns booleanlocal integer rFx=(bv)call Cco(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction Cdo takes nothing returns nothingcall Dcx(Xdx("FolderUnit_FolderIntelligence_StructBase_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderIntelligence_StructBase.Event_TypeChange).AddToStatics()",OP,bI,function CNo))set ag=Xdx("FolderUnit_FolderIntelligence_FolderBonus_StructDisplayed_Init: set FolderUnit_FolderIntelligence_FolderBonus_StructDisplayed.SELECTION_EVENT = Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderIntelligence_FolderBonus_StructDisplayed.Event_Selection)",C3v,bI,function Cbo)set dvv=Ayo(RZv,function CCo)endfunctionfunction CDo takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])call c7x(oSx,(bFv[(AKo)])-(bFv[(Ako)]))return trueendfunctionfunction Cfo takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=(Vv[(rFx)])set tG[oSx]=falsecall RPx((oSx),TG)call cwx(oSx,(sG[(oSx)]),SG[oSx])return trueendfunctionfunction CFo takes integer oSx,real oux returns nothingset zG[oSx]=ouxcall c5x((oSx))endfunctionfunction Cgo takes integer oSx,real oux returns nothingcall CFo(oSx,(zG[(oSx)])+oux)endfunctionfunction CGo takes nothing returns booleanlocal integer rFx=(bv)call Cgo(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction Cho takes nothing returns nothingcall Dcx(Xdx("FolderUnit_FolderStrength_StructBase_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderStrength_StructBase.Event_TypeChange).AddToStatics()",OP,bI,function CDo))set TG=Xdx("FolderUnit_FolderStrength_FolderBonus_StructDisplayed_Init: set FolderUnit_FolderStrength_FolderBonus_StructDisplayed.SELECTION_EVENT = Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderStrength_FolderBonus_StructDisplayed.Event_Selection)",C3v,bI,function Cfo)set dev=Ayo(R8v,function CGo)endfunctionfunction CHo takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])local integer oMxlocal integer rlxif I9x((oSx),Wd)then
return trueendifcall Abo(oSx)set oMx=OOo(AKo)
loop
exitwhen(oMx<0)set rlx=OIo(AKo,oMx)
call OAo(oSx,rlx,ONo(AKo,rlx))set oMx=oMx-1endloopreturn trueendfunctionfunction Cjo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oMx=CIx(rLx,PH)local integer oSxloop
set oSx=CAx(rLx,PH,oMx)call C0x(oSx,mH[oSx],rLx,pH[oSx])set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction CJo takes nothing returns nothingset qH=Xdx("FolderUnit_FolderAbilities_StructCooldown_Init: set FolderUnit_FolderAbilities_StructCooldown.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAbilities_StructCooldown.Event_Destroy)",EP,bI,function Cjo)
set QH=(E3x())set sH=(E3x())endfunctionfunction Cko takes nothing returns integerlocal unit oqx=GetSpellTargetUnit()local integer o7xif(GetUnitAbilityLevel(oqx,'aLoc')>0)thenset oqx=null
return Z
endifset o7x=adx(oqx)
set oqx=null
return o7xendfunctionfunction CKo takes integer oqx returns integerreturn(LoadInteger(o[((V[(E[((X))])]))],(((oqx))),(((mv)))))
endfunctionfunction Clo takes integer Cqx,integer rYx,integer dnx,real dVx,real dEx,integer rlx returns nothing
local integer dXx=rRx((A[(Cqx)]))local integer rmxlocal integer oMxlocal integer rbxlocal integer rMxset Mv[(dXx)]=(rYx)set nv[(dXx)]=(rlx)set yH[(dXx)]=((dVx)*1.)
set YH[(dXx)]=((dEx)*1.)
set zH[(dXx)]=(dnx)set Vv[(dXx)]=(Cqx)set rmx=rRx((Ev[(rlx)]))
set Mv[(rmx)]=(rYx)set nv[(rmx)]=(rlx)set yH[(rmx)]=((dVx)*1.)
set YH[(rmx)]=((dEx)*1.)
set zH[(rmx)]=(dnx)set Vv[(rmx)]=(Cqx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rGx(rlx,dxv,rbx)
loop
exitwhen(rMx<q)call rfx(rhx(rlx,dxv,rbx,rMx),dXx)set rMx=rMx-1endloopset rMx=rAx(Cqx,dxv,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(Cqx,dxv,rbx,rMx),rmx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((dXx)))call rkx(((rmx)))endfunctionfunction CLo takes nothing returns booleanlocal integer Cqx=Q2x()local integer dnx=Cko()local real dVx=(GetSpellTargetX())local real dEx=(GetSpellTargetY())local integer rlx=(CKo(GetSpellAbilityId()))
local integer rYx=rWx(Cqx,rlx)call Clo(Cqx,rYx,dnx,dVx,dEx,rlx)return trueendfunctionfunction Cmo takes integer oSx,code oux returns nothingif(oux==null)thenreturnendifset dA[oSx]=CreateTrigger()call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((dA[oSx]))))),((((FA)))),((((oSx)))))
call TriggerAddCondition(dA[oSx],Condition(oux))
endfunctionfunction CMo takes nothing returns booleanif not(I8x((Iyv),Ob,(Q2x())))thenreturn false
endifif((CKo(GetSpellAbilityId()))==w)thenreturn false
endifreturn truereturn trueendfunctionfunction Cpo takes nothing returns nothingset dxv=(E3x())set dov=XJx(function CLo)set Iyv=Jbx("FolderUnit_FolderAbilities_FolderEvents_StructBegin_Init: set FolderUnit_FolderAbilities_FolderEvents_StructBegin.REG_GROUP = UnitList.Create()")call Cmo(dov,function CMo)call Q5x(dov,Ge,EVENT_PLAYER_UNIT_SPELL_CAST,null)endfunctionfunction CPo takes nothing returns nothingset onv=(E3x())set oVv=(E3x())endfunctionfunction Cqo takes integer rLx returns booleanreturn(I8x((Izv),Ob,(rLx)))endfunctionfunction CQo takes integer oSx returns nothingset bgv[oSx]=GetHeroSkillPoints(C[(oSx)])-1endfunctionfunction Cso takes nothing returns booleanlocal integer rLx=Q2x()if not Cqo(rLx)thenreturn trueendifcall CQo(rLx)call rzx((rLx),(CKo(GetLearnedSkill())))
return trueendfunctionfunction CSo takes nothing returns nothingset Pv=(E3x())set pv=(E3x())set drv=XJx(function Cso)set Izv=Jbx("FolderUnit_FolderAbilities_FolderEvents_StructLearn_Init: set FolderUnit_FolderAbilities_FolderEvents_StructLearn.REG_GROUP = UnitList.Create()")call Q5x(drv,Ge,EVENT_PLAYER_HERO_SKILL,null)endfunctionfunction Cto takes nothing returns booleanlocal integer Cqx=Q2x()local integer oSx=Cqxlocal integer Ctx=Uh[oSx]local integer AKolocal integer CTolocal integer Cuoif(Ctx==w)thenreturn trueendifif dav[oSx]thenreturn trueendifset AKo=(oxv[((AH[(Ctx)]))])
set CTo=dnv[AKo]
if(CTo!=0)thencall rtx(Cqx,CTo)set Cuo=BFo()set Oh[(Cuo)]=(b3)set cpv[(Cuo)]=(AKo)
set Hj[(Cuo)]=((Wh[(Ctx)]))set fj[(Cuo)]=(((yh[(Ctx)]))*1.)
set Fj[(Cuo)]=(((Yh[(Ctx)]))*1.)
call dkx(Cuo)endifcall dbx(Ctx,w)return trueendfunctionfunction CUo takes integer oSx returns integerreturn(Oh[(ej[oSx])])endfunctionfunction Cwo takes integer oSx,integer CWo returns integerreturn osx((oSx),Dh+CWo)
endfunctionfunction Cyo takes integer Ctx returns nothinglocal integer Cqx=(EH[(Ctx)])local integer rYx=(IH[(Ctx)])local integer dax=(wh[(Ctx)])local integer dnx=(Wh[(Ctx)])local real dVx=(yh[(Ctx)])local real dEx=(Yh[(Ctx)])local integer rlx=(AH[(Ctx)])local integer dXx=rRx((A[(Cqx)]))local integer rmxlocal integer oMxlocal integer rbxlocal integer rMxset wH[(dXx)]=(dax)set Mv[(dXx)]=(rYx)set nv[(dXx)]=(rlx)set WH[(dXx)]=(Ctx)set yH[(dXx)]=((dVx)*1.)
set YH[(dXx)]=((dEx)*1.)
set zH[(dXx)]=(dnx)set Vv[(dXx)]=(Cqx)set rmx=rRx((Ev[(rlx)]))
set wH[(rmx)]=(dax)set Mv[(rmx)]=(rYx)set nv[(rmx)]=(rlx)set WH[(rmx)]=(Ctx)set yH[(rmx)]=((dVx)*1.)
set YH[(rmx)]=((dEx)*1.)
set zH[(rmx)]=(dnx)set Vv[(rmx)]=(Cqx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(Cqx,dVv,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(Cqx,dVv,rbx,rMx),dXx)set rMx=rMx-1endloopset rMx=rGx(rlx,dVv,rbx)
loop
exitwhen(rMx<q)call rfx(rhx(rlx,dVv,rbx,rMx),rmx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((dXx)))call rkx(((rmx)))endfunctionfunction CYo takes nothing returns booleanlocal integer Cqx=Q2x()local integer rlx=(CKo(GetSpellAbilityId()))
local integer Czo=CUo(Cqx)local integer oSx=Cqxlocal integer Ctx=CPx(Cqx,rlx)local integer rYxlocal real dVxlocal real dExlocal integer daxlocal integer dnxif Cdx(Czo)thenset rYx=(CLx(((Cwo(Cqx,((Czo)-Ch)))),Zh+(rlx)))set dav[oSx]=trueelse
set rYx=rWx(Cqx,rlx)
set dav[oSx]=falseendifset Uh[oSx]=Ctxset dVx=(GetSpellTargetX())set dEx=(GetSpellTargetY())if((oxv[((AH[(Ctx)]))])==0)thenset dax=wset dnx=welse
set dax=(Bjo(GetSpellTargetItem()))set dnx=Cko()endifset VH[(Ctx)]=((Ufx(Cqx,dVx-Dsx(Cqx),dEx-Dtx(Cqx)))*1.)set IH[(Ctx)]=(rYx)set wh[(Ctx)]=(dax)set Wh[(Ctx)]=(dnx)set yh[(Ctx)]=((dVx)*1.)
set Yh[(Ctx)]=((dEx)*1.)
call Cyo(Ctx)return trueendfunctionfunction CZo takes integer oSx,integer C_o returns nothingcall UnitRemoveAbility(C[(((oSx)))],(C_o))endfunctionfunction C0o takes nothing returns booleanlocal integer Cqx=Q2x()if(Cqx==w)thenreturn false
endifif(Qux(Cqx,'BPar')>0)thencall CZo(Cqx,'BPar')
endifif not(I8x((IYv),Ob,(Cqx)))thenreturn false
endifif((CKo(GetSpellAbilityId()))==w)thenreturn false
endifreturn truereturn trueendfunctionfunction C1o takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),DH)
return trueendfunctionfunction C2o takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer Rox=(Ah[(rFx)])local integer C3oif(Rox==P3)thencall AZx(Cqx,DH)
elseif(Rox==N4)thenset C3o=(ze[(Cqx)])if((O1x(Cqx,C3o)==q)and(O7x(Cqx,C3o,q)==Cqx))thencall AZx(Cqx,DH)
endifendifreturn trueendfunctionfunction C4o takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])if((Ah[(rFx)])==d4)thencall AZx(Cqx,DH)
endifreturn trueendfunctionfunction C5o takes integer Iix returns nothinglocal integer oMx=CIx(Iix,xMv)local integer Cqxloop
set Cqx=CAx(Iix,xMv,oMx)
call AZx(Cqx,DH)
set oMx=oMx-1exitwhen(oMx<q)endloopendfunctionfunction C6o takes nothing returns booleanlocal integer rFx=(bv)call C5o((Vv[(rFx)]))return trueendfunctionfunction C7o takes nothing returns booleanlocal integer rFx=(bv)call C5o((Vv[(rFx)]))return trueendfunctionfunction C8o takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rlx=(nv[(rFx)])local integer oSx=Cqxif((AH[(xjv[oSx])])==rlx)thencall AZx(Cqx,DH)
endifreturn trueendfunctionfunction C9o takes nothing returns nothingset x9v=iXx()set xJv=Xdx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Init: set FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_Death)",VP,bI,function C1o)
set xkv=Xdx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Init: set FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.ORDER_EVENT = Event.Create(UNIT.Order.Events.Gain.Immediate.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_Order)",Cj,bI,function C2o)set xKv=Xdx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Init: set FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.ORDER_POINT_EVENT = Event.Create(UNIT.Order.Events.Gain.Point.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_Order)",gj,bI,function C2o)set xlv=Xdx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Init: set FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.ORDER_TARGET_EVENT = Event.Create(UNIT.Order.Events.Gain.Target.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_Order)",jj,bI,function C2o)set xLv=Xdx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Init: set FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.STUN_EVENT = Event.Create(UNIT.Order.Events.Gain.Target.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_Stun)",jj,bI,function C4o)set xpv=Xdx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Init: set FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.TARGET_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_TargetDeath)",VP,bI,function C6o)set xPv=Xdx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Init: set FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.TARGET_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_TargetDestroy)",EP,bI,function C7o)set xmv=Xdx("FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Init: set FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.UNLEARN_EVENT = Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling.Event_Unlearn)",Av,bI,function C8o)
endfunctionfunction dvo takes nothing returns nothingset ih=(E3x())set div=XJx(function Cto)set dVv=(E3x())set dEv=XJx(function CYo)set IYv=Jbx("FolderUnit_FolderAbilities_FolderEvents_StructEffect_Init: set FolderUnit_FolderAbilities_FolderEvents_StructEffect.REG_GROUP = UnitList.Create()")
call Cmo(div,function C0o)call Q5x(div,Ge,EVENT_PLAYER_UNIT_SPELL_ENDCAST,null)call Cmo(dEv,function C0o)call Q5x(dEv,Ge,EVENT_PLAYER_UNIT_SPELL_EFFECT,null)
set dnv[0]='AUCI'set dnv[2]='AUCP'set dnv[3]='AUCQ'set dnv[4]='AUCU'call C9o()endfunctionfunction deo takes nothing returns nothingcall Cpo()call CPo()call CSo()set Av=(E3x())call dvo()endfunctionfunction dxo takes nothing returns nothingcall Dcx(Xdx("FolderUnit_StructAbilities_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructAbilities.Event_TypeChange).AddToStatics()",OP,bI,function CHo))set Qb=(E3x())call CJo()call deo()endfunctionfunction doo takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])call IUo(oSx,(I8v[(AKo)])-(I8v[(Ako)]))return trueendfunctionfunction dro takes integer oSx,real oux returns nothingset I9v[oSx]=oux
call Omo((oSx))endfunctionfunction dio takes integer oSx,real oux returns nothingcall dro(oSx,(I9v[(oSx)])+oux)endfunctionfunction dao takes nothing returns booleanlocal integer rFx=(bv)call dio(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction dno takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=(Vv[(rFx)])set Axv[oSx]=falsecall RPx((oSx),AVv)call Oko(oSx,(Avv[(oSx)]),Aev[oSx])return trueendfunctionfunction dVo takes nothing returns nothingset dXv=Ayo(riv,function dao)set AVv=Xdx("FolderUnit_FolderArmor_FolderBonus_StructDisplayed_Init: set FolderUnit_FolderArmor_FolderBonus_StructDisplayed.SELECTION_EVENT = Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderArmor_FolderBonus_StructDisplayed.Event_Selection)",C3v,bI,function dno)endfunctionfunction dEo takes integer oSx,real oux returns nothingset Arv[oSx]=oux
call Omo((oSx))endfunctionfunction dXo takes integer oSx,real oux returns nothingcall dEo(oSx,(Arv[(oSx)])+oux)endfunctionfunction dOo takes nothing returns booleanlocal integer rFx=(bv)call dXo(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction dRo takes integer oSx,real oux returns nothingset E0v[(oSx)]=(((E0v[(oSx)])+oux)*1.)endfunctionfunction dIo takes nothing returns booleanlocal integer rFx=(bv)call dRo(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction dAo takes integer oSx,real oux returns nothingset Eyv[(oSx)]=(((Eyv[(oSx)])+oux)*1.)endfunctionfunction dNo takes nothing returns booleanlocal integer rFx=(bv)call dAo(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction dbo takes nothing returns booleanlocal integer rFx=(bv)local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])set Aav[(oSx)]=((Anv[(AKo)]))return trueendfunctionfunction dBo takes nothing returns nothingcall Dcx(Xdx("FolderUnit_FolderArmor_StructBase_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderArmor_StructBase.Event_TypeChange).AddToStatics()",OP,bI,function doo))call dVo()set dOv=Ayo(rIv,function dOo)set nav=Ayo(rNv,function dIo)set dRv=Ayo(rBv,function dNo)call Dcx(Xdx("FolderUnit_FolderArmor_StructTypeA_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderArmor_StructTypeA.Event_TypeChange).AddToStatics()",OP,bI,function dbo))endfunctionfunction dco takes nothing returns nothingendfunctionfunction dCo takes integer oSx,integer AKo returns nothingset Bg[oSx]=(AUv[(AKo)])
set Cg[oSx]=falseendfunctionfunction ddo takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])call dCo(oSx,AKo)call cax(oSx,(Auv[(AKo)])-(Auv[(Ako)]))return trueendfunctionfunction dDo takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=(Vv[(rFx)])if B3x(oSx,(cg[(oSx)]),Bg[oSx])thenset Cg[oSx]=falsecall RPx((oSx),dg)endifreturn trueendfunctionfunction dfo takes nothing returns nothingcall Dcx(Xdx("FolderUnit_FolderDamage_StructBase_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDamage_StructBase.Event_TypeChange).AddToStatics()",OP,bI,function ddo))set dg=Xdx("FolderUnit_FolderDamage_FolderBase_StructDisplayed_Init: set FolderUnit_FolderDamage_FolderBase_StructDisplayed.SELECTION_EVENT = Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDamage_FolderBase_StructDisplayed.Event_Selection)",C3v,bI,function dDo)
endfunctionfunction dFo takes nothing returns booleanlocal integer rFx=(bv)call cYx(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction dgo takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=(Vv[(rFx)])set pg[oSx]=falsecall RPx((oSx),Pg)call B7x(oSx,(Mg[(oSx)]),mg[oSx])return trueendfunctionfunction dGo takes nothing returns nothingset dIv=Ayo(adv,function dFo)set Pg=Xdx("FolderUnit_FolderDamage_FolderBonus_StructDisplayed_Init: set FolderUnit_FolderDamage_FolderBonus_StructDisplayed.SELECTION_EVENT = Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDamage_FolderBonus_StructDisplayed.Event_Selection)",C3v,bI,function dgo)endfunctionfunction dho takes nothing returns booleanlocal integer rFx=(bv)local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])set Ayv[(oSx)]=((AYv[(AKo)]))return trueendfunctionfunction dHo takes nothing returns integerlocal unit oqx=GetEventDamageSource()local integer o7xif(GetUnitAbilityLevel(oqx,'aLoc')>0)thenset oqx=null
return Z
endifset o7x=adx(oqx)
set oqx=null
return o7xendfunctionfunction djo takes integer oSx,integer Iix returns realreturn blx(((oF[((Iix))])-(Isv[((oSx))]))*1./ 'd',.05,.5)endfunctionfunction dJo takes integer oSx,integer Iix returns booleanif not(NVv[((Iix))]>0)thenreturn false
endifif(Ezv[(Iix)])thenreturn false
endifif(rk[((oSx))])thenreturn false
endifif((GetRandomReal(((.0)*1.),((1.)*1.)))>djo((oSx),Iix))thenreturn false
endifcall Oqx((oSx),iSx("patzer","dfffdfdf"),.02,140.,.0,1.5,(0))
call Ryx((ACx((Iix),("Abilities\\Spells\\Orc\\MirrorImage\\MirrorImageDeathCaster.mdl"),("chest"),(Bi))))return trueendfunctionfunction dko takes integer oSx,integer Iix,real nZx returns nothinglocal integer rLx=oSxlocal integer rFx=rRx(0)
local integer Rnxlocal integer oMxlocal integer rbxlocal integer rMxset Vv[(rFx)]=(rLx)set zH[(rFx)]=(Iix)set Rnx=rRx((A[(rLx)]))set Vv[(Rnx)]=(rLx)set zH[(Rnx)]=(Iix)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Bfv))-1)*Iv+(((rbx))-1)))))))))
loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Bfv))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset rMx=rAx(rLx,Bfv,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(rLx,Bfv,rbx,rMx),Rnx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call rkx(((Rnx)))endfunctionfunction dKo takes integer oSx,integer Iix,real nZx returns real
set nZx=nZx*2.call dko(oSx,Iix,nZx)return nZxendfunctionfunction dlo takes integer oSx,integer Iix returns nothinglocal integer rLx=oSxlocal real o5xif(IsUnitAlly(C[(Iix)],vx[(rLx)]))thenreturnendifset o5x=(Iuv[(oSx)])
if(o5x<=.0)thenreturnendifcall Oqx(rLx,iSx("+"+(I2S(((R2I(((o5x)*1.)))))),"ffc80000"),.02,80.,.0,3.,(0))call Ryx((ACx((rLx),(dBv),(dcv),(Bi))))call cjx(rLx,o5x)endfunctionfunction dLo takes integer oSx,integer Iix returns nothinglocal integer rLx=oSxlocal real o5xif(IsUnitAlly(C[(Iix)],vx[(rLx)]))thenreturnendifset o5x=(IUv[(oSx)])
if(o5x<=.0)thenreturnendifcall Oqx(rLx,iSx("+"+(I2S(((R2I(((o5x)*1.)))))),"ffc80000"),.02,80.,.0,3.,(0))call Ryx((ACx((rLx),(dCv),(ddv),(Bi))))call BNx(rLx,o5x)endfunctionfunction dmo takes integer oSx,integer otx returns booleanreturn(LoadBoolean(o[((V[(E[((Jw[(oSx)]))])]))],((((kw[((oSx))])))),(((otx)))))endfunctionfunction dMo takes integer oSx,integer dpo returns booleanreturn dmo((oSx),dDv+dpo)endfunctionfunction dPo takes integer oSx,integer Iix,real nZx,integer rNx returns nothingset nZx=nZx*(1.-(Aov[(Iix)]))set nZx=nZx*nco((EYv[(Iix)]))set nZx=nZx*(JO[(rNx)*7+((Aav[(Iix)]))])
call NAo((oSx),Iix,nZx,false)endfunctionfunction dqo takes integer oSx,real dQo,integer dso,real x,real y,integer dSo returns nothinglocal integer dto=(CIx((((oSx))),APv))local boolean dTolocal integer d8xlocal integer oMxlocal integer O7olocal integer Iixlocal real duoif(dto<q)thenreturnendifset dTo=(dMo((Tf[((((oSx))))]),(0)))
set d8x=(ze[((oSx))])call dQx(dfv,dSo)set oMx=qloop
set O7o=(CAx((((oSx))),APv,(oMx)))set dFv=dToset hf=d8xcall NVo(dgv,x,y,(AMv[(O7o)]),dGv)set Iix=NEo(dgv)
if(Iix!=w)thenset duo=dQo*(Apv[(O7o)])
loop
call dQx(dfv,Iix)call dPo(oSx,Iix,duo,dso)set Iix=NEo(dgv)
exitwhen(Iix==w)
endloopendifset oMx=oMx+1exitwhen(oMx>dto)endloopcall dWx((dfv),Ob)endfunctionfunction dUo takes integer oSx,integer Iix,boolean nho,real nZx returns nothinglocal real armorAmount=(EYv[(Iix)])local boolean nKo=falselocal integer dso=(A1v[((oSx))])
local real dwolocal integer oldTextTag
local integer rLx=oSxlocal real dVx=Dsx(Iix)local real dEx=Dtx(Iix)local integer oMx=(Ayv[(rLx)])local integer dWo=(AZv[(rLx)])if dJo(rLx,Iix)thenreturnendifif ndo(Iix)thenreturnendifloop
exitwhen(oMx<1)set nZx=nZx+(GetRandomInt((1),(dWo)))set oMx=oMx-1endloopset nZx=nZx*(1.-(Aov[(Iix)]))set nZx=nZx*nco((EYv[(Iix)]))set nZx=nZx*(JO[((A1v[(rLx)]))*7+((Aav[(Iix)]))])set nKo=nCo(rLx,Iix)
set nZx=nDo(oSx,nZx,Iix,false)set dwo=NAo(rLx,Iix,nZx,false)if nKo thenset dwo=dKo(rLx,Iix,dwo)
if(dwo>.0)thencall nHo(Iix,iSx((I2S(((R2I(((((dwo)*1.))*1.))))))+"!",(xb[((ze[(rLx)]))])),nJo(dwo,(rG[(Iix)])*1./ 2.,.024,.028),160.,.0,1.,dbv+Iix,dwo*1./ 2)endifelse
if(dwo>.0)thencall nHo(Iix,iSx((I2S(((R2I(((((dwo)*1.))*1.)))))),(xb[((ze[(rLx)]))])),nJo(dwo,(rG[(Iix)])*1./ 2.,.016,.022),160.,.0,1.,dbv+Iix,dwo*1./ 2)endifendifcall dlo(rLx,Iix)call dLo(rLx,Iix)call dqo(oSx,nZx,dso,dVx,dEx,Iix)endfunctionfunction dyo takes nothing returns booleanlocal integer rLx=dHo()local boolean nfo=dNvlocal integer Iix=Q2x()if((rLx==Z)or((GetEventDamage())==.0)or((Adv[((Tf[(((rLx)))]))])==ADv))thenset ZH=trueendifset dNv=falseif ZH thenset ZH=false
else
if nfo thencall nDo((rLx),.0,Iix,true)else
call dUo((rLx),Iix,true,(Lg[(rLx)]))
endifendifreturn trueendfunctionfunction dYo takes nothing returns booleanlocal integer Iix=jhx()if(I8x((dfv),Ob,(Iix)))thenreturn false
endifif(not dFv and(IsUnitAlly(C[(Iix)],vx[(hf)])))thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifreturn truereturn trueendfunctionfunction dzo takes nothing returns nothingset dAv=(E3x())set E4v=(E3x())set Azv=XJx(function dyo)set dGv=Xpx(function dYo)set dgv=O5x()set dfv=Jbx("FolderUnit_FolderDamage_StructEvents_Init: set FolderUnit_FolderDamage_StructEvents.SPLASH_GROUP2 = UnitList.Create()")
set dhv=(E3x())set E3v=(E3x())endfunctionfunction dZo takes integer oSx returns nothingcall cyx(oSx,(Jg[(oSx)]))endfunctionfunction d_o takes integer oSx,real oux returns nothingset kg[oSx]=ouxcall dZo((oSx))endfunctionfunction d0o takes integer oSx,real oux returns nothingcall d_o(oSx,(kg[(oSx)])+oux)endfunctionfunction d1o takes nothing returns booleanlocal integer rFx=(bv)call d0o(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction d2o takes nothing returns booleanlocal integer rFx=(bv)local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])set AZv[(oSx)]=((A_v[(AKo)]))return trueendfunctionfunction d3o takes nothing returns booleanlocal integer rFx=(bv)local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])set A1v[(oSx)]=((A2v[(AKo)]))return trueendfunctionfunction d4o takes nothing returns nothingcall dfo()call dGo()call Dcx(Xdx("FolderUnit_FolderDamage_StructDices_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDamage_StructDices.Event_TypeChange).AddToStatics()",OP,bI,function dho))call dzo()set dHv=Ayo(akv,function d1o)call Dcx(Xdx("FolderUnit_FolderDamage_StructSides_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDamage_StructSides.Event_TypeChange).AddToStatics()",OP,bI,function d2o))call Dcx(Xdx("FolderUnit_FolderDamage_StructTypeA_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderDamage_StructTypeA.Event_TypeChange).AddToStatics()",OP,bI,function d3o))endfunctionfunction d5o takes nothing returns nothingendfunctionfunction d6o takes nothing returns nothingendfunctionfunction d7o takes integer oSx,boolean o5x returns nothingif o5x thencall Ulx(((oSx)),x5v)else
call Dux((((oSx))),(x5v),(1),w)endifendfunctionfunction d8o takes nothing returns booleanlocal integer rFx=(bv)call d7o(((Vv[(rFx)])),not(rc[(rFx)]))return trueendfunctionfunction d9o takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])local boolean Dvo=((NPv[(AKo)])>.0)if(((NPv[(Ako)])>.0)==Dvo)thenif not Dvo thencall R1o(oSx)endifreturn trueendifif Dvo thencall Ulx(((oSx)),x5v)else
call R1o(oSx)endifreturn trueendfunctionfunction Deo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oMx=CIx(rLx,bUv)local integer oSxloop
set oSx=CAx(rLx,bUv,oMx)
call ikx(btv[oSx])set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction Dxo takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer rLx=bTv[oSx]local real Doo=Dsx(rLx)local real Dro=Dtx(rLx)local integer rFx=rRx((A[(rLx)]))set biv[(rFx)]=((GZx(Doo-dKv[oSx],Dro-dlv[oSx]))*1.)
set Vv[(rFx)]=(rLx)set dKv[oSx]=Doo
set dlv[oSx]=Dro
call rfx(buv[oSx],rFx)call rkx(((rFx)))endfunctionfunction Dio takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oMx=CIx(rLx,bUv)local integer oSxloop
set oSx=CAx(rLx,bUv,oMx)
set dKv[oSx]=Dsx(rLx)set dlv[oSx]=Dtx(rLx)call iDx(btv[oSx],bSv[oSx],true,function Dxo)set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction Dao takes nothing returns nothingset bwv=Xdx("FolderUnit_FolderMovement_FolderEvents_StructInterval_Init: set FolderUnit_FolderMovement_FolderEvents_StructInterval.MOVE_ENDING_EVENT = Event.Create(UNIT.Movement.Events.ENDING_EVENT_TYPE, EventPriority.EVENTS, function FolderUnit_FolderMovement_FolderEvents_StructInterval.Event_Move_Ending)",bav,jI,function Deo)set bWv=Xdx("FolderUnit_FolderMovement_FolderEvents_StructInterval_Init: set FolderUnit_FolderMovement_FolderEvents_StructInterval.MOVE_START_EVENT = Event.Create(UNIT.Movement.Events.START_EVENT_TYPE, EventPriority.EVENTS, function FolderUnit_FolderMovement_FolderEvents_StructInterval.Event_Move_Start)",bnv,jI,function Dio)endfunctionfunction Dno takes nothing returns nothingset dJv=XIx()set bav=(E3x())set bxv=Jbx("FolderUnit_FolderMovement_StructEvents_Init: set FolderUnit_FolderMovement_StructEvents.ENUM_GROUP = UnitList.Create()")set N7v=Jbx("FolderUnit_FolderMovement_StructEvents_Init: set FolderUnit_FolderMovement_StructEvents.EVENT_GROUP = UnitList.Create()")set bov=Jbx("FolderUnit_FolderMovement_StructEvents_Init: set FolderUnit_FolderMovement_StructEvents.MOVING_GROUP = UnitList.Create()")set bnv=(E3x())set N8v=iXx()call XBx(dJv,function Ibo)set dkv=(E3x())call Dao()set dLv=(E3x())endfunctionfunction DVo takes boolean b returns integer
if b thenreturn 1
endifreturn 0
endfunctionfunction DEo takes integer oSx returns nothingcall rtx((oSx),'AUUD')call UnitRemoveAbility(C[(((oSx)))],('AUUD'))endfunctionfunction DXo takes integer oSx,real oux returns nothinglocal integer DOoset Nsv[oSx]=oux
set oux=(oux+(NQv[((oSx))]))*((NSv[((oSx))])-1.)
if(byx(oux)<.1)thenset oux=.0endifif(oux>.0)thenset DOo=3else
set DOo=1+DVo(oux<.0)endifcall R8o((oSx))call rZx((oSx),'AmSp',DOo)call DEo((oSx))endfunctionfunction DRo takes integer oSx,real oux returns nothingcall DXo(oSx,(Nsv[(oSx)])+oux)endfunctionfunction DIo takes nothing returns booleanlocal integer rFx=(bv)call DRo(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction DAo takes nothing returns nothingcall Q0x(Ge,'AmSx',false)set dmv=Ayo(VYv,function DIo)endfunctionfunction DNo takes integer oSx returns nothingcall DXo(oSx,(Nsv[(oSx)]))endfunctionfunction Dbo takes integer oSx,real oux returns nothingset NSv[oSx]=oux
call DNo((oSx))endfunctionfunction DBo takes integer oSx,real oux returns nothingcall Dbo(oSx,(NSv[(oSx)])+oux)endfunctionfunction Dco takes nothing returns booleanlocal integer rFx=(bv)call DBo(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction DCo takes nothing returns nothingcall DAo()set iw=Ayo(VZv,function Dco)
endfunctionfunction Ddo takes nothing returns nothingset djv=Ayo(V1v,function d8o)call Dcx(Xdx("FolderUnit_StructMovement_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructMovement.Event_TypeChange).AddToStatics()",OP,bI,function d9o))call Dno()call DCo()endfunctionfunction DDo takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])call DYx(oSx,(Uj[(AKo)])-(Uj[(Ako)]))return trueendfunctionfunction Dfo takes nothing returns booleanlocal integer rFx=(bv)call DPx(((Vv[(rFx)])))return trueendfunctionfunction DFo takes nothing returns booleanlocal integer rFx=(bv)call Dwx(((Vv[(rFx)])))return trueendfunctionfunction Dgo takes integer oSx,real oux returns nothingset uj[oSx]=ouxcall Dwx((oSx))endfunctionfunction DGo takes integer oSx,real oux returns nothingcall Dgo(oSx,(uj[(oSx)])+oux)endfunctionfunction Dho takes nothing returns booleanlocal integer rFx=(bv)call DGo(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction DHo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oMx=CIx(rLx,gJ)local integer oSxloop
set oSx=CAx(rLx,gJ,oMx)call D7x(oSx,DJ[oSx],rLx)set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction Djo takes nothing returns booleanlocal integer rFx=(bv)local integer IQx=(Fc[(rFx)])local real fvx=dPv[(IQx)]local real DJo=dqv[(IQx)]if not(Dc[(rFx)])thenset fvx=-fvx
endifcall D9x(((Vv[(rFx)])),fvx,DJo)return trueendfunctionfunction Dko takes nothing returns nothingset GJ=Xdx("FolderUnit_FolderScale_StructTimed_Init: set FolderUnit_FolderScale_StructTimed.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderScale_StructTimed.Event_Destroy)",EP,bI,function DHo)set JJ=iXx()
set dpv=Ayo(AJ,function Djo)
endfunctionfunction DKo takes nothing returns nothingcall Dcx(Xdx("FolderUnit_StructScale_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructScale.Event_TypeChange).AddToStatics()",OP,bI,function DDo))set a1v=Xdx("FolderUnit_StructScale_Init: set FolderUnit_StructScale.MODDED_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructScale.Event_Modded_Death)",VP,bI,function Dfo)set a2v=Xdx("FolderUnit_StructScale_Init: set FolderUnit_StructScale.MODDED_REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructScale.Event_Modded_Revive)",XP,bI,function DFo)set dMv=Ayo(aZv,function Dho)call Dko()endfunctionfunction Dlo takes integer oSx returns nothingset bQv[oSx]=falsecall rHx(Vsv)endfunctionfunction DLo takes integer oSx returns nothingif(bqv[oSx]>0)thenreturnendifif(bpv[oSx]!=Z)thencall o_x("FolderUnit_FolderMovement_FolderEvents_StructInterval_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderMovement_FolderEvents_StructInterval.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",VSv+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset bpv[oSx]=bpv[(w)]set bpv[(w)]=oSx
call Dlo(oSx)endfunctionfunction Dmo takes integer oSx returns nothingset bqv[oSx]=bqv[oSx]-1call DLo(oSx)endfunctionfunction DMo takes integer oSx,integer otx returns nothingcall SaveInteger(o[(((V[(E[((xA[(oSx)]))])])))],(((((aA[((oSx))]))))),((((otx)))),(0))endfunctionfunction Dpo takes integer oSx,integer otx,integer oux returns booleanlocal integer aCx=osx(oSx,otx)set oux=(aCx-oux)call rwx(oSx,otx,oux)if(aCx==0)thenreturn false
endifreturn(oux==0)endfunctionfunction DPo takes integer oSx,integer XYx returns nothinglocal integer rLx=oSxif not Dpo(rLx,N5v+XYx,1)thenreturnendifcall RPx(rLx,XYx)if not Dpo(rLx,N6v,1)thenreturnendifcall IRo(N7v,rLx)if(dmx((N7v),Ob))thencall ikx(N8v)endifendfunctionfunction Dqo takes integer oSx,integer XYx returns nothinglocal integer rLx=oSxlocal integer p3xset oSx=Fqx(XYx,bmv+rLx)
if(oSx==w)thencall o_x("FolderUnit_FolderMovement_FolderEvents_StructInterval_Remove","call DebugEx(\"not listed \" + whichEvent.GetName() + \";\" + parent.GetName() + \";\" + I2S(parent))","not listed "+(jA[(XYx)])+";"+(GetUnitName(C[(rLx)]))+";"+I2S(rLx))returnendifset p3x=btv[oSx]
call Dmo((oSx))call iKx(p3x)call DMo(XYx,bmv+rLx)if rnx(rLx,bUv,oSx)thencall DPo(rLx,bwv)call DPo(rLx,bWv)endifendfunctionfunction DQo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])call RPx(rLx,bLv)call Dqo(rLx,byv)return trueendfunctionfunction Dso takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=(Vv[(rFx)])local real oux=iAx(.0,(Nuv[(oSx)])-dQv)call Ino(oSx,oux)return trueendfunctionfunction DSo takes nothing returns nothingendfunctionfunction Dto takes nothing returns nothingset bLv=Xdx("FolderUnit_StructStamina_Init: set FolderUnit_StructStamina.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructStamina.Event_Destroy)",EP,bI,function DQo)set byv=Xdx("FolderUnit_StructStamina_Init: set FolderUnit_StructStamina.MOVE_EVENT = Event.Create(NULL, NULL, function FolderUnit_StructStamina.Event_Move)",w,w,function Dso)call DSo()endfunctionfunction DTo takes nothing returns nothingendfunctionfunction Duo takes integer oSx,boolean o5x returns nothingif o5x thencall Ulx(((oSx)),x4v)else
call Dux((((oSx))),(x4v),(1),w)endifendfunctionfunction DUo takes nothing returns booleanlocal integer rFx=(bv)call Duo(((Vv[(rFx)])),not(rc[(rFx)]))return trueendfunctionfunction Dwo takes nothing returns integerlocal unit oqx=GetEventTargetUnit()local integer o7xif(GetUnitAbilityLevel(oqx,'aLoc')>0)thenset oqx=null
return Z
endifset o7x=adx(oqx)
set oqx=null
return o7xendfunctionfunction DWo takes integer oSx,integer Iix returns nothinglocal integer rLx=oSxlocal integer OTo=(Tf[(rLx)])local integer rFx=rRx((A[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset zH[(rFx)]=(Iix)set Vv[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,Ew,rbx)loop
exitwhen(rMx<q)call rfx(rgx(rLx,Ew,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction Dyo takes integer oSx,integer Okx,integer rLx returns nothinglocal integer Iix=dSv[oSx]call iKx(Okx)set Acv[oSx]=falsecall Khx(Iix)endfunctionfunction DYo takes integer oSx,integer Iix returns nothinglocal integer rLx=oSxlocal integer rFx=rRx((A[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset zH[(rFx)]=(Iix)set Vv[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx((oSx),dTv,rbx)loop
exitwhen(rMx<q)call rfx(rgx(rLx,dTv,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction Dzo takes nothing returns nothinglocal integer Okx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(Okx)])call Dyo(oSx,Okx,oSx)call DYo(oSx,dSv[oSx])endfunctionfunction DZo takes integer oSx,integer Iix returns nothinglocal integer Okx=iXx()if Acv[oSx]thencall Dyo(oSx,dtv[oSx],oSx)endifset dtv[oSx]=Okx
set Acv[oSx]=trueset dSv[oSx]=Iix
set ge[(Okx)]=(oSx)call A_o(Iix)call iDx(Okx,.01,false,function Dzo)
endfunctionfunction D_o takes nothing returns booleanlocal integer rLx=Q2x()local integer Iix=Dwo()if((IsUnitEnemy(C[(Iix)],vx[((ze[(rLx)]))]))and(CUo(Iix)==w))thencall Lox(rLx,bw,Iix)
endifcall DWo((rLx),Iix)call DZo((rLx),Iix)return trueendfunctionfunction D0o takes integer oSx,integer Iix returns nothinglocal integer rLx=oSxlocal integer OTo=(Tf[(rLx)])local integer rFx=rRx((A[(rLx)]))local integer GPxlocal integer oMxlocal integer rbxlocal integer rMxset zH[(rFx)]=(Iix)set Vv[(rFx)]=(oSx)set GPx=rRx((kw[(OTo)]))
set zH[(GPx)]=(Iix)set Vv[(GPx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,duv,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(rLx,duv,rbx,rMx),rFx)set rMx=rMx-1endloopset rMx=AEo(OTo,duv,rbx)
loop
exitwhen(rMx<q)call rfx(AXo(OTo,duv,rbx,rMx),GPx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call rkx(((GPx)))endfunctionfunction D1o takes nothing returns booleanlocal integer rLx=Q2x()local integer Iix=Dwo()call D0o((rLx),Iix)return trueendfunctionfunction D2o takes integer rLx returns booleanreturn(I8x((ABv),Ob,(rLx)))endfunctionfunction D3o takes integer oSx,integer D4o returns nothinglocal integer rLx=oSxlocal integer D5o=rRx((A[(D4o)]))local integer rFxlocal integer oMxlocal integer rbxlocal integer rMxset zH[(D5o)]=(oSx)set Vv[(D5o)]=(D4o)set rFx=rRx((A[(rLx)]))set zH[(rFx)]=(D4o)set Vv[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(D4o,dwv,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(D4o,dwv,rbx,rMx),D5o)set rMx=rMx-1endloopset rMx=rAx(rLx,dUv,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(rLx,dUv,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((D5o)))call rkx(((rFx)))endfunctionfunction D6o takes nothing returns integerlocal unit oqx=(GetAttacker())local integer o7xif(GetUnitAbilityLevel(oqx,'aLoc')>0)thenset oqx=null
return Z
endifset o7x=adx(oqx)
set oqx=null
return o7xendfunctionfunction D7o takes nothing returns booleanlocal integer rLx=Q2x()if not D2o(rLx)thenreturn trueendifcall D3o((rLx),D6o())return trueendfunctionfunction D8o takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=rLxcall RPx(rLx,ACv)if Acv[oSx]thencall Dyo(oSx,dtv[oSx],rLx)endifreturn trueendfunctionfunction D9o takes nothing returns nothingset ACv=Xdx("FolderUnit_FolderAttack_FolderEvents_StructAcquire2_Init: set FolderUnit_FolderAttack_FolderEvents_StructAcquire2.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAttack_FolderEvents_StructAcquire2.Event_Destroy)",EP,bI,function D8o)set dTv=(E3x())endfunctionfunction fvo takes unit oqx returns integerreturn(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((oqx))))),((((Ly))))))endfunctionfunction feo takes integer oSx returns nothingset d0v[oSx]=falsecall rHx(rgv)endfunctionfunction fxo takes integer oSx returns nothingif(dZv[oSx]>0)thenreturnendifif(d_v[oSx]!=Z)thencall o_x("FolderUnit_FolderAttack_FolderEvents_StructGround_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderAttack_FolderEvents_StructGround.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",rGv+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset d_v[oSx]=d_v[(w)]set d_v[(w)]=oSx
call feo(oSx)endfunctionfunction foo takes integer oSx returns nothingset dZv[oSx]=dZv[oSx]-1call fxo(oSx)endfunctionfunction fro takes integer oSx,integer HAx,integer rLx returns nothingcall foo((oSx))call L8x(HAx,dYv)call HRx(HAx,d1v)call rnx(rLx,d2v,oSx)call Khx(rLx)endfunctionfunction fio takes integer oSx,integer dpo returns booleanreturn dMo((Tf[((oSx))]),dpo)endfunctionfunction fao takes integer oSx returns integerreturn CIx((oSx),APv)endfunctionfunction fno takes integer oSx,integer oLx returns integerreturn CAx((oSx),APv,oLx)endfunctionfunction fVo takes integer oSx returns nothingcall Dux(((oSx)),(iiv),(1),w)endfunctionfunction fEo takes integer oSx returns nothingcall Ulx((oSx),iiv)endfunctionfunction fXo takes integer oSx,integer Iix,real nZx,integer rNx returns nothingset nZx=nZx*(1.-(Aov[(Iix)]))set nZx=nZx*nco((EYv[(Iix)]))set nZx=nZx*(JO[(rNx)*7+((Aav[(Iix)]))])
call fVo(Iix)call NAo((oSx),Iix,nZx,false)call fEo(Iix)endfunctionfunction fOo takes integer oSx,real x,real y returns nothing
local boolean dTo=fio((oSx),0)local real dQo=(Lg[((oSx))])+(Jg[((oSx))])local integer fRo=(AZv[((oSx))])
local integer dso=(A1v[((oSx))])
local integer oMx=(Ayv[((oSx))])
local integer dto=fao((oSx))
local integer d8x=(ze[((oSx))])local real duolocal integer O7olocal integer Iixlocal real array fIo
loop
exitwhen(oMx<1)set dQo=dQo+(GetRandomInt((1),(fRo)))set oMx=oMx-1endloopset dQo=dQo*(kg[((oSx))])*(ug[((oSx))])set oMx=qloop
exitwhen(oMx>dto)set O7o=fno((oSx),oMx)set dFv=dToset hf=d8xcall NVo(d4v,x,y,(AMv[(O7o)]),d5v)loop
set Iix=NEo(d4v)
exitwhen(Iix==w)
if not(I8x((d6v),Ob,(Iix)))thenset fIo[Iix]=.0call dQx(d6v,Iix)endifset fIo[Iix]=fIo[Iix]+(Apv[(O7o)])endloopset oMx=oMx+1endlooploop
set Iix=(dpx((d6v),Ob))exitwhen(Iix==w)
call fXo(oSx,Iix,dQo*fIo[Iix],dso)endloopendfunctionfunction fAo takes integer oSx,real x,real y returns nothing
local integer rLx=oSxlocal integer rFx=rRx((A[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset yH[(rFx)]=((x)*1.)set YH[(rFx)]=((y)*1.)set Vv[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,d3v,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(rLx,d3v,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call fOo(oSx,x,y)endfunctionfunction fNo takes nothing returns booleanlocal integer HAx=(fvo(GetTriggerUnit()))local integer rLx=dHo()local integer oSx=Mxx(HAx,dYv)local real x
local real y
if(rLx!=dzv[oSx])thenreturn trueendifset x=(iJ[(HAx)])set y=(EJ[(HAx)])call fro(oSx,HAx,rLx)call fAo((rLx),x,y)return trueendfunctionfunction fbo takes integer oSx returns integerset d0v[oSx]=trueset d9v[oSx]=falsecall rEx(rgv)return oSxendfunctionfunction fBo takes nothing returns integerlocal integer oSxif(d7v==8190)thencall o_x("FolderUnit_FolderAttack_FolderEvents_StructGround_Allocation_allocCustom","call DebugEx(FolderUnit_FolderAttack_FolderEvents_StructGround.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",rGv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(d_v[(w)]==w)thenset d8v=d8v+1set oSx=d8velse
set oSx=d_v[(w)]
set d_v[(w)]=d_v[d_v[(w)]]endifset d_v[oSx]=Zset dZv[oSx]=1call fbo(oSx)return oSxendfunctionfunction fco takes integer oSx returns integerset Drv[oSx]=trueset Div[oSx]=falsecall rEx(vW)
return oSxendfunctionfunction fCo takes nothing returns integerlocal integer oSxif(Dvv==8190)thencall o_x("FolderDummyUnit_StructDestroyTimed_Allocation_allocCustom","call DebugEx(FolderDummyUnit_StructDestroyTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",eW+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Dev[(w)]==w)thenset Dxv=Dxv+1set oSx=Dxvelse
set oSx=Dev[(w)]
set Dev[(w)]=Dev[Dev[(w)]]endifset Dev[oSx]=Zset Dov[oSx]=1call fco(oSx)return oSxendfunctionfunction fdo takes integer oSx returns nothingset Drv[oSx]=falsecall rHx(vW)
endfunctionfunction fDo takes integer oSx returns nothingif(Dov[oSx]>0)thenreturnendifif(Dev[oSx]!=Z)thencall o_x("FolderDummyUnit_StructDestroyTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderDummyUnit_StructDestroyTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",eW+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Dev[oSx]=Dev[(w)]set Dev[(w)]=oSx
call fdo(oSx)endfunctionfunction ffo takes integer oSx returns nothingset Dov[oSx]=Dov[oSx]-1call fDo(oSx)endfunctionfunction fFo takes nothing returns nothinglocal integer iCx=iGx()local integer oSx=(ge[(iCx)])local integer rLx=Dav[oSx]call ffo((oSx))call iKx(iCx)call Mfx(rLx)endfunctionfunction fgo takes integer oSx,real iMx returns nothinglocal integer rLx=oSxlocal integer iCxset oSx=fCo()set iCx=iXx()set Dav[oSx]=rLx
set ge[(iCx)]=(oSx)call iDx(iCx,iMx,false,function fFo)
endfunctionfunction fGo takes integer oSx returns realreturn(Dnv[((Tf[((oSx))]))])
endfunctionfunction fho takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(zH[(rFx)])local integer rLx=(Vv[(rFx)])local real dVx=Dsx(Iix)local real dEx=Dtx(Iix)local integer oSx=fBo()local integer HAx=mDx('qGrA',dVx,dEx,.0,.0)set dzv[oSx]=rLx
call TriggerRegisterUnitEvent(DA[((dyv))],vJ[(HAx)],(EVENT_UNIT_DAMAGED))call Mrx(HAx,dYv,oSx)call Mix(HAx,d1v)call rUx(rLx,d2v,oSx)call A_o(rLx)call fgo(HAx,jKx(dVx-Dsx(rLx),dEx-Dtx(rLx))*1./ fGo(rLx)+2.)
return trueendfunctionfunction fHo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])call RPx(rLx,Afv)call RPx(rLx,AFv)return trueendfunctionfunction fjo takes nothing returns booleanlocal integer rFx=(bv)local integer HAx=(Wp[(rFx)])local integer oSx=Mxx(HAx,dYv)call fro(oSx,HAx,dzv[oSx])return trueendfunctionfunction fJo takes nothing returns booleanlocal integer Iix=jhx()if(not dFv and(IsUnitAlly(C[(Iix)],vx[(hf)])))thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifreturn truereturn trueendfunctionfunction fko takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local boolean fKo=((Adv[(AKo)])==ADv)if(((Adv[(Ako)])==ADv)==fKo)then
return trueendifif fKo thencall Avx(rLx,Afv)call Avx(rLx,AFv)else
call RPx(rLx,Afv)call RPx(rLx,AFv)endifreturn trueendfunctionfunction flo takes nothing returns nothingset dyv=XJx(function fNo)set Afv=Xdx("FolderUnit_FolderAttack_FolderEvents_StructGround_Init: set FolderUnit_FolderAttack_FolderEvents_StructGround.ATTACK_EVENT = Event.Create(UNIT.Attack.Events.DUMMY_EVENT_TYPE, EventPriority.EVENTS, function FolderUnit_FolderAttack_FolderEvents_StructGround.Event_Attack)",duv,jI,function fho)
set AFv=Xdx("FolderUnit_FolderAttack_FolderEvents_StructGround_Init: set FolderUnit_FolderAttack_FolderEvents_StructGround.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.EVENTS, function FolderUnit_FolderAttack_FolderEvents_StructGround.Event_Destroy)",EP,jI,function fHo)set d3v=(E3x())set d1v=Xdx("FolderUnit_FolderAttack_FolderEvents_StructGround_Init: set FolderUnit_FolderAttack_FolderEvents_StructGround.DUMMY_UNIT_DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.EVENTS, function FolderUnit_FolderAttack_FolderEvents_StructGround.Event_DummyUnitDestroy)",aP,jI,function fjo)set d4v=O5x()set d6v=Jbx("FolderUnit_FolderAttack_FolderEvents_StructGround_Init: set FolderUnit_FolderAttack_FolderEvents_StructGround.ENUM_GROUP2 = UnitList.Create()")
set d5v=Xpx(function fJo)call Dcx(Xdx("FolderUnit_FolderAttack_FolderEvents_StructGround_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAttack_FolderEvents_StructGround.Event_TypeChange).AddToStatics()",OP,bI,function fko))endfunctionfunction fLo takes nothing returns nothingset Ew=(E3x())set ANv=XJx(function D_o)set duv=(E3x())set Abv=XJx(function D1o)set dUv=(E3x())set ABv=Jbx("FolderUnit_FolderAttack_StructEvents_Init: set FolderUnit_FolderAttack_StructEvents.OFFENDED_REG_GROUP = UnitList.Create()")set dwv=(E3x())set dWv=XJx(function D7o)call Q5x(dWv,Ge,EVENT_PLAYER_UNIT_ATTACKED,null)
call D9o()call flo()endfunctionfunction fmo takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])call bKx(oSx,(Ahv[(AKo)])-(Ahv[(Ako)]))return trueendfunctionfunction fMo takes integer oSx,unit oqx,real nZx,real bzx returns nothinglocal integer bZxlocal integer b_xset nZx=nZx*'d'set bzx=bzx*'d'if(nZx*bzx<=.0)thenif(bzx<.0)thenset b_x=DVvloop
call UnitRemoveAbility(oqx,evv[b_x])
set b_x=b_x-1exitwhen(b_x<0)endloopelse
set b_x=DEvloop
call UnitRemoveAbility(oqx,v9v[b_x])
set b_x=b_x-1exitwhen(b_x<0)endloopendifif(nZx<.0)thenset nZx=-nZx
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(DVv)))*1.)))
loop
exitwhen(nZx<1.)
set bZx=eev[b_x]
if(bZx<=nZx)then
set nZx=nZx-bZxcall UnitAddAbility(oqx,evv[b_x])endifset b_x=b_x-1endloopelse
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(DEv)))*1.)))
loop
exitwhen(nZx<1.)
set bZx=eev[b_x]
if(bZx<=nZx)then
set nZx=nZx-bZxcall UnitAddAbility(oqx,v9v[b_x])endifset b_x=b_x-1endloopendifelse
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(DVv)))*1.)))
if(nZx<.0)thenset nZx=-nZx
loop
exitwhen(b_x<0)set bZx=eev[b_x]
if(bZx<=nZx)then
set nZx=nZx-bZxcall UnitAddAbility(oqx,evv[b_x])else
call UnitRemoveAbility(oqx,evv[b_x])
endifset b_x=b_x-1endloopelse
set b_x=(R2I(((iUx((bWx((R2I(((iAx(byx(bzx),byx(nZx)))*1.))))),(DEv)))*1.)))
loop
exitwhen(b_x<0)set bZx=eev[b_x]
if(bZx<=nZx)then
set nZx=nZx-bZxelse
call UnitRemoveAbility(oqx,v9v[b_x])
endifset b_x=b_x-1endloopendifendifendfunctionfunction fpo takes integer oSx,real oux returns nothinglocal real aCx=(CF[(oSx)])set CF[oSx]=ouxcall fMo(DXv,C[(oSx)],oux,aCx)endfunctionfunction fPo takes integer oSx returns nothingcall fpo((oSx),(((wf[((oSx))]))*1.))
endfunctionfunction fqo takes integer oSx,real oux returns nothingset wf[oSx]=ouxcall fPo(oSx)call bJx((oSx))endfunctionfunction fQo takes integer oSx,real oux returns nothingcall fqo(oSx,(wf[(oSx)])+oux)endfunctionfunction fso takes nothing returns booleanlocal integer rFx=(bv)call fQo(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction fSo takes nothing returns nothingendfunctionfunction fto takes nothing returns nothingset nnv=Ayo(rQv,function fso)call fSo()endfunctionfunction fTo takes nothing returns nothingcall Dcx(Xdx("FolderUnit_FolderAttack_FolderSpeed_StructBaseA_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAttack_FolderSpeed_StructBaseA.Event_TypeChange).AddToStatics()",OP,bI,function fmo))call fto()endfunctionfunction fuo takes integer oSx returns nothingset ALv[oSx]=falsecall rHx(elv)endfunctionfunction fUo takes integer oSx returns nothingif(Alv[oSx]>0)thenreturnendifif(Akv[oSx]!=Z)thencall o_x("UnitAttackSplash_Allocation_deallocCustom_confirm","call DebugEx(UnitAttackSplash.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",eLv+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset Akv[oSx]=Akv[(w)]set Akv[(w)]=oSx
call fuo(oSx)endfunctionfunction fwo takes integer oSx returns nothingset Alv[oSx]=Alv[oSx]-1call fUo(oSx)endfunctionfunction fWo takes nothing returns booleanlocal integer rFx=(bv)local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])local integer oMx=CIx((oSx),Ajv)
local integer O7oloop
exitwhen(oMx<q)set O7o=CAx((oSx),Ajv,oMx)call fwo(((O7o)))set oMx=oMx-1endloopcall Nwo((oSx),Ajv)set oMx=O0o(AKo)
loop
exitwhen(oMx<q)call rUx((oSx),Ajv,O6o(oSx,O9o(AKo,oMx),Rvo(AKo,oMx)))set oMx=oMx-1endloopreturn trueendfunctionfunction fyo takes nothing returns nothingset dsv=Ayo(rwv,function DUo)call fLo()call fTo()call Dcx(Xdx("FolderUnit_FolderAttack_StructSplash_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderAttack_StructSplash.Event_TypeChange).AddToStatics()",OP,bI,function fWo))endfunctionfunction fYo takes nothing returns booleanlocal integer rFx=(bv)call DTx(eJ,V3,(Vv[(rFx)]))return trueendfunctionfunction fzo takes nothing returns nothingset Ebv=Xdx("FolderUnit_StructBanish_Init: set FolderUnit_StructBanish.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructBanish.Event_Revive)",XP,bI,function fYo)call UnitAddAbility(vJ[((eJ))],('aBan'))
endfunctionfunction fZo takes nothing returns booleanlocal integer rFx=(bv)return trueendfunctionfunction f_o takes integer oSx returns booleanlocal integer oLx=(b7v[(oSx)])set b7v[b6v[b5v]]=oLxset b6v[oLx-1]=b6v[b5v]set b7v[oSx]=0set b5v=b5v-1return(b5v==F)endfunctionfunction f0o takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=rLxif f_o(oSx)thencall ikx(b8v)endifcall RPx(rLx,b2v)call RPx(rLx,b3v)call RPx(rLx,b4v)call iKx(oov[oSx])call DestroyLightning(orv[oSx])call DestroyLightning(oiv[oSx])call DestroyLightning(bYv[oSx])call DestroyLightning(bzv[oSx])call DestroyLightning(bZv[oSx])call DestroyLightning(b_v[oSx])call DestroyLightning(b0v[oSx])call DestroyLightning(b1v[oSx])return trueendfunctionfunction f1o takes nothing returns booleanlocal integer rFx=(bv)return trueendfunctionfunction f2o takes nothing returns nothingset b2v=Xdx("FolderUnit_StructBars_Init: set FolderUnit_StructBars.CAST_EVENT = Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.HEADER_TOP, function FolderUnit_StructBars.Event_SpellEffect)",ih,GI,function fZo)
set b3v=Xdx("FolderUnit_StructBars_Init: set FolderUnit_StructBars.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructBars.Event_Destroy)",EP,bI,function f0o)set b4v=Xdx("FolderUnit_StructBars_Init: set FolderUnit_StructBars.END_CAST_EVENT = Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructBars.Event_EndCast)",onv,bI,function f1o)set b8v=iXx()endfunctionfunction f3o takes nothing returns nothingendfunctionfunction f4o takes nothing returns nothingendfunctionfunction f5o takes nothing returns nothingendfunctionfunction f6o takes integer oSx,boolean o5x returns nothingif o5x thencall Dux((((oSx))),(nYv),(1),w)else
call Ulx(((oSx)),nYv)endifendfunctionfunction f7o takes nothing returns booleanlocal integer rFx=(bv)call f6o(((Vv[(rFx)])),(rc[(rFx)]))return trueendfunctionfunction f8o takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer rLx=oSxif(nyv[(oSx)])thenreturnendifcall Nbx((((oSx))),(nLv),(1),w,((((2.)*1.))*1.))
call AZx(rLx,ntv)endfunctionfunction f9o takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=rLxcall iDx(nuv[oSx],(Awv[(rLx)])+.01,false,function f8o)return trueendfunctionfunction Fvo takes nothing returns nothingendfunctionfunction Feo takes nothing returns nothingset nUv=Xdx("FolderUnit_StructInvisibility_Init: set FolderUnit_StructInvisibility.ATTACK_EVENT = Event.Create(UNIT.Attack.Events.OFFENDED_REVERSED_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructInvisibility.Event_Attack)",dwv,bI,function f9o)
set nwv=Xdx("FolderUnit_StructInvisibility_Init: set FolderUnit_StructInvisibility.CAST_EVENT = Event.Create(UNIT.Abilities.Events.Begin.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructInvisibility.Event_Attack)",dxv,bI,function f9o)set nWv=(E3x())call Fvo()endfunctionfunction Fxo takes integer oSx,boolean o5x returns nothingif o5x thencall Dux((((oSx))),(aVv),(1),w)else
call Ulx(((oSx)),aVv)endifendfunctionfunction Foo takes nothing returns booleanlocal integer rFx=(bv)call Fxo(((Vv[(rFx)])),(rc[(rFx)]))return trueendfunctionfunction Fro takes integer rLx returns booleanreturn(I8x((BVv),Ob,(rLx)))endfunctionfunction Fio takes integer oSx returns nothingcall kcx(oSx,(qS[(oSx)]))endfunctionfunction Fao takes integer oSx,integer oux returns nothingcall kcx(oSx,(qS[(oSx)])-oux)endfunctionfunction Fno takes integer oSx,integer Cgx returns nothinglocal boolean FVo=(Cjx(((Cgx)),mh,(Mh)))
if(not FVo or not(osx(((((oSx)))),(Wb+(DNv)))>0))thencall dFx(oSx,Cgx)endifif FVo thencall Nbx(((oSx)),(DNv),(1),w,((.01)*1.))
call Fio(Cgx)elseif(Cjx(((Cgx)),mh,(bS)))then
call kBx(Cgx)else
if((qS[(Cgx)])>0)thencall Fao(Cgx,1)endifendifendfunctionfunction FEo takes integer oSx,integer Cgx returns nothingcall Fno(oSx,Cgx)endfunctionfunction FXo takes integer oSx returns integerlocal integer FOo=(UnitInventorySize(C[((oSx))]))-1local integer oMx=0loop
exitwhen(oMx>FOo)if((osx(((oSx)),Dh+(oMx)))==w)thenreturn oMxendifset oMx=oMx+1endloopreturn-1
endfunctionfunction FRo takes integer oSx,integer Cgx returns integerlocal integer FIoif(Cjx(((Cgx)),mh,(bS)))then
return-1
endifset FIo=FXo(oSx)
call rwx((oSx),Dh+FIo,Cgx)call rwx((oSx),Dbv+Cgx,0+1+FIo)set HS[(Cgx)]=(FIo)return FIoendfunctionfunction FAo takes integer oSx,integer Cgx returns integerlocal integer o7x=osx((oSx),Dbv+Cgx)
if(o7x==0)thenreturn-1
endifreturn(o7x-0-1)endfunctionfunction FNo takes integer oSx,integer Cgx returns booleanreturn(FAo(oSx,Cgx)!=-1)
endfunctionfunction Fbo takes integer oSx,integer Cgx,integer FIo returns nothinglocal integer rLx=oSxlocal integer dgx=(Fh[(Cgx)])local integer dGx=rRx((Ph[(dgx)]))local integer rFxlocal integer oMxlocal integer rbxlocal integer rMxset qh[(dGx)]=(Cgx)set DBv[(dGx)]=(FIo)
set Qh[(dGx)]=(dgx)set Vv[(dGx)]=(rLx)set rFx=rRx((A[(rLx)]))set qh[(rFx)]=(Cgx)set DBv[(rFx)]=(FIo)
set Qh[(rFx)]=(dgx)set Vv[(rFx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=CJx(dgx,DIv,rbx)
loop
exitwhen(rMx<q)call rfx(Ckx(dgx,DIv,rbx,rMx),dGx)if not FNo(rLx,Cgx)thenreturnendifset rMx=rMx-1endloopset rMx=rAx(rLx,DIv,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(rLx,DIv,rbx,rMx),rFx)if not FNo(rLx,Cgx)thenreturnendifset rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((dGx)))call rkx(((rFx)))endfunctionfunction FBo takes nothing returns booleanlocal integer rLx=Q2x()local integer Cgxlocal integer FIoif not Fro(rLx)thenreturn trueendifif DAv thenset DAv=falsereturn trueendifset Cgx=(Bjo(GetManipulatedItem()))if(Cgx==w)thenreturn trueendifif(Cjx(((Cgx)),mh,(bS)))then
call FEo(rLx,Cgx)return trueendifset FIo=FRo(rLx,Cgx)
call Fbo((rLx),Cgx,FIo)return trueendfunctionfunction Fco takes nothing returns nothingset DIv=(E3x())set Dg=XJx(function FBo)
set BVv=Jbx("FolderUnit_FolderItems_FolderEvents_StructGain_Init: set FolderUnit_FolderItems_FolderEvents_StructGain.REG_GROUP = UnitList.Create()")
call Q5x(Dg,Ge,EVENT_PLAYER_UNIT_PICKUP_ITEM,null)endfunctionfunction FCo takes integer rLx returns booleanreturn(I8x((BEv),Ob,(rLx)))endfunctionfunction Fdo takes integer oSx,integer Cgx returns integerlocal integer FIoif not(Cjx(((Cgx)),mh,(bS)))then
set FIo=FAo(oSx,Cgx)
call rVx((oSx),Dh+FIo)call rVx((oSx),Dbv+Cgx)set HS[(Cgx)]=(-1)return FIoendifreturn-1
endfunctionfunction FDo takes integer oSx,integer Cgx,integer FIo returns nothinglocal integer rLx=oSxlocal integer dgx=(Fh[(Cgx)])local integer dGx=rRx((Ph[(dgx)]))local integer rFxlocal integer oMxlocal integer rbxlocal integer rMxset qh[(dGx)]=(Cgx)set DBv[(dGx)]=(FIo)
set Qh[(dGx)]=(dgx)set Vv[(dGx)]=(rLx)set rFx=rRx((A[(rLx)]))set qh[(rFx)]=(Cgx)set DBv[(rFx)]=(FIo)
set Qh[(rFx)]=(dgx)set Vv[(rFx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=CJx(dgx,Dcv,rbx)
loop
exitwhen(rMx<q)call rfx(Ckx(dgx,Dcv,rbx,rMx),dGx)set rMx=rMx-1endloopset rMx=rAx(rLx,Dcv,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(rLx,Dcv,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((dGx)))call rkx(((rFx)))endfunctionfunction Ffo takes nothing returns booleanlocal integer rLx=Q2x()local integer Cgxlocal integer FIoif not FCo(rLx)thenreturn trueendifif DCv thenset DCv=falsereturn trueendifset Cgx=(Bjo(GetManipulatedItem()))if(Cgx==w)thenreturn trueendifset FIo=Fdo(rLx,Cgx)
call FDo((rLx),Cgx,FIo)return trueendfunctionfunction FFo takes nothing returns nothingset Dcv=(E3x())set fg=XJx(function Ffo)
set BEv=Jbx("FolderUnit_FolderItems_FolderEvents_StructLose_Init: set FolderUnit_FolderItems_FolderEvents_StructLose.REG_GROUP = UnitList.Create()")
call Q5x(fg,Ge,EVENT_PLAYER_UNIT_DROP_ITEM,null)
endfunctionfunction Fgo takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((Z2[(oSx)]))])]))],((((cj[((oSx))])))),(((otx)))))endfunctionfunction FGo takes integer oSx,integer Cgx,integer CWo returns nothingcall rVx((oSx),Dh+FAo(oSx,Cgx))call rVx((oSx),Dbv+Cgx)call rwx((oSx),Dh+CWo,Cgx)call rwx((oSx),Dbv+Cgx,0+1+CWo)set HS[(Cgx)]=(CWo)endfunctionfunction Fho takes integer Cgx,integer FIo,integer dax,integer FHo,integer OSx returns nothinglocal integer Eko=rRx((A[(OSx)]))local integer oMxlocal integer rbxlocal integer rMxset wH[(Eko)]=(dax)set DFv[(Eko)]=(FHo)
set qh[(Eko)]=(Cgx)set DBv[(Eko)]=(FIo)
set Vv[(Eko)]=(OSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(OSx,Ddv,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(OSx,Ddv,rbx,rMx),Eko)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((Eko)))endfunctionfunction Fjo takes nothing returns booleanlocal integer rFx=(bv)local integer FJo=(wH[(rFx)])local integer FHo=Fgo((Ah[(rFx)]),Dfv)local integer OSx=(Vv[(rFx)])local integer Fko=FAo(OSx,FJo)local integer dax=Cwo(OSx,FHo)call FGo(OSx,FJo,FHo)if(dax!=w)thencall FGo(OSx,dax,Fko)endifcall Fho(FJo,Fko,dax,FHo,OSx)return trueendfunctionfunction FKo takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((Z2[(oSx)]))])]))],((((cj[((oSx))])))),(((otx))),(((oux))))endfunctionfunction Flo takes integer oSx,integer XYx returns nothingif(dj[oSx]==w)thencall o_x("FolderOrder_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oSx)+";"+(jA[(XYx)]))set dj[oSx]=Xendifcall rux(dj[oSx],(cj[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction FLo takes integer Rox,integer CWo returns nothingcall FKo(Rox,Dfv,CWo)call Flo(Rox,DDv)endfunctionfunction Fmo takes nothing returns nothingset Ddv=(E3x())set DDv=Xdx("FolderUnit_FolderItems_FolderEvents_StructMoveInInventory_Init: set FolderUnit_FolderItems_FolderEvents_StructMoveInInventory.ORDER_EVENT = Event.Create(UNIT.Order.Events.Gain.Target.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderUnit_FolderItems_FolderEvents_StructMoveInInventory.Event_Order)",jj,lI,function Fjo)call FLo(Y3,0)call FLo(z3,1)call FLo(Z3,2)call FLo(v4,3)call FLo(e4,4)call FLo(o4,5)endfunctionfunction FMo takes integer rLx returns booleanreturn(I8x((BXv),Ob,(rLx)))endfunctionfunction Fpo takes nothing returns integerlocal unit oqx=GetBuyingUnit()local integer o7xif(GetUnitAbilityLevel(oqx,'aLoc')>0)thenset oqx=null
return Z
endifset o7x=adx(oqx)
set oqx=null
return o7xendfunctionfunction FPo takes integer oSx,integer Fqo,integer Cgx returns nothinglocal integer dgx=(Fh[(Cgx)])local integer dGx=rRx((Ph[(dgx)]))local integer oMxlocal integer rbxlocal integer rMxset qh[(dGx)]=(Cgx)set Qh[(dGx)]=(dgx)set zH[(dGx)]=(Fqo)set Vv[(dGx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=CJx(dgx,Dgv,rbx)
loop
exitwhen(rMx<q)call rfx(Ckx(dgx,Dgv,rbx,rMx),dGx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((dGx)))endfunctionfunction FQo takes nothing returns booleanlocal integer Fso=Q2x()local integer Fqolocal integer Cgxif not FMo(Fso)thenreturn trueendifset Fqo=Fpo()set Cgx=kGx(GetSoldItem())call Ryx((ACx((Fqo),("Abilities\\Spells\\Items\\TomeOfRetraining\\TomeOfRetrainingCaster.mdl"),("origin"),(Bi))))call FPo((Fso),Fqo,Cgx)return trueendfunctionfunction FSo takes nothing returns nothingset Dgv=(E3x())set DGv=XJx(function FQo)set BXv=Jbx("FolderUnit_FolderItems_FolderEvents_StructSell_Init: set FolderUnit_FolderItems_FolderEvents_StructSell.REG_GROUP = UnitList.Create()")
call Q5x(DGv,Ge,EVENT_PLAYER_UNIT_SELL_ITEM,null)endfunctionfunction Fto takes integer rLx returns booleanreturn(I8x((BOv),Ob,(rLx)))endfunctionfunction FTo takes nothing returns booleanlocal integer rLx=Q2x()local integer Cgxif not Fto(rLx)thenreturn trueendifset Cgx=(Bjo(GetManipulatedItem()))call Fno((rLx),Cgx)return trueendfunctionfunction Fuo takes nothing returns nothingset Sh=(E3x())set Dhv=XJx(function FTo)set BOv=Jbx("FolderUnit_FolderItems_FolderEvents_StructUse_Init: set FolderUnit_FolderItems_FolderEvents_StructUse.REG_GROUP = UnitList.Create()")set DNv=ltx(ozv)
call Q5x(Dhv,Ge,EVENT_PLAYER_UNIT_USE_ITEM,null)
endfunctionfunction FUo takes nothing returns nothingcall Fco()call FFo()call Fmo()call FSo()call Fuo()endfunctionfunction Fwo takes nothing returns booleanlocal integer rFx=(bv)call Dux(((((((Vv[(rFx)])))))),(yg),(1),w)return trueendfunctionfunction FWo takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=(Vv[(rFx)])call clx(oSx)return trueendfunctionfunction Fyo takes nothing returns booleanlocal integer rFx=(bv)call Ulx((((((Vv[(rFx)]))))),yg)
return trueendfunctionfunction FYo takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])call cpx(oSx,(NKv[(AKo)])-(NKv[(Ako)]))return trueendfunctionfunction Fzo takes nothing returns booleanlocal integer rFx=(bv)call cZx(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction FZo takes integer oSx,boolean o5x returns nothingif o5x thencall Dux((((oSx))),(yg),(1),w)else
call Ulx(((oSx)),yg)
endifendfunctionfunction F_o takes nothing returns booleanlocal integer rFx=(bv)call FZo(((Vv[(rFx)])),not(rc[(rFx)]))return trueendfunctionfunction F0o takes nothing returns booleanlocal integer rFx=(bv)call Dux((((((Vv[(rFx)]))))),(yg),(1),w)
return trueendfunctionfunction F1o takes nothing returns booleanlocal integer rFx=(bv)call Ulx(((((Vv[(rFx)])))),yg)return trueendfunctionfunction F2o takes nothing returns nothingset Djv=Ayo(VVv,function F_o)call Dcx(Xdx("FolderUnit_FolderLifeRegeneration_StructDisablement_Init: call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderLifeRegeneration_StructDisablement.Event_Death).AddToStatics()",VP,bI,function F0o))call Dcx(Xdx("FolderUnit_FolderLifeRegeneration_StructDisablement_Init: call Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderLifeRegeneration_StructDisablement.Event_Revive).AddToStatics()",XP,bI,function F1o))endfunctionfunction F3o takes integer oSx,real oux returns nothingset hG[oSx]=ouxcall cmx((oSx))endfunctionfunction F4o takes integer oSx,real oux returns nothingcall F3o(oSx,(hG[(oSx)])+oux)endfunctionfunction F5o takes nothing returns booleanlocal integer rFx=(bv)call F4o(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction F6o takes nothing returns nothingset vG=iXx()
call Dcx(Xdx("FolderUnit_StructLifeRegeneration_Init: call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructLifeRegeneration.Event_Death).AddToStatics()",VP,bI,function Fwo))call Dcx(Xdx("FolderUnit_StructLifeRegeneration_Init: call Event.Create(UNIT.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructLifeRegeneration.Event_Destroy).AddToStatics()",EP,bI,function FWo))call Dcx(Xdx("FolderUnit_StructLifeRegeneration_Init: call Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructLifeRegeneration.Event_Revive).AddToStatics()",XP,bI,function Fyo))call Dcx(Xdx("FolderUnit_FolderLifeRegeneration_StructBase_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderLifeRegeneration_StructBase.Event_TypeChange).AddToStatics()",OP,bI,function FYo))set DHv=Ayo(Vnv,function Fzo)call F2o()set Xdv=Ayo(VRv,function F5o)endfunctionfunction F7o takes integer oSx,boolean o5x returns nothingif o5x thencall Dux((((oSx))),(aWv),(1),w)else
call Ulx(((oSx)),aWv)endifendfunctionfunction F8o takes nothing returns booleanlocal integer rFx=(bv)call F7o(((Vv[(rFx)])),(rc[(rFx)]))return trueendfunctionfunction F9o takes nothing returns nothingendfunctionfunction gvo takes nothing returns nothingset DJv=Ayo(awv,function F8o)call F9o()endfunctionfunction geo takes nothing returns booleanlocal integer rFx=(bv)call Dux(((((((Vv[(rFx)])))))),(GF),(1),w)return trueendfunctionfunction gxo takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=(Vv[(rFx)])call BCx(oSx)return trueendfunctionfunction goo takes nothing returns booleanlocal integer rFx=(bv)call Ulx((((((Vv[(rFx)]))))),GF)
return trueendfunctionfunction gro takes nothing returns booleanlocal integer rFx=(bv)local integer Ako=(Bdv[(rFx)])local integer AKo=(Bbv[(rFx)])local integer oSx=(Vv[(rFx)])call BFx(oSx,(Nlv[(AKo)])-(Nlv[(Ako)]))return trueendfunctionfunction gio takes nothing returns booleanlocal integer rFx=(bv)call BSx(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction gao takes integer oSx,boolean o5x returns nothingif o5x thencall Dux((((oSx))),(GF),(1),w)else
call Ulx(((oSx)),GF)
endifendfunctionfunction gno takes nothing returns booleanlocal integer rFx=(bv)call gao(((Vv[(rFx)])),not(rc[(rFx)]))return trueendfunctionfunction gVo takes nothing returns booleanlocal integer rFx=(bv)call Dux((((((Vv[(rFx)]))))),(GF),(1),w)
return trueendfunctionfunction gEo takes nothing returns booleanlocal integer rFx=(bv)call Ulx(((((Vv[(rFx)])))),GF)return trueendfunctionfunction gXo takes nothing returns nothingset DKv=Ayo(VKv,function gno)call Dcx(Xdx("FolderUnit_FolderManaRegeneration_StructDisablement_Init: call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderManaRegeneration_StructDisablement.Event_Death).AddToStatics()",VP,bI,function gVo))call Dcx(Xdx("FolderUnit_FolderManaRegeneration_StructDisablement_Init: call Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderManaRegeneration_StructDisablement.Event_Revive).AddToStatics()",XP,bI,function gEo))endfunctionfunction gOo takes integer oSx,real oux returns nothingset MF[oSx]=ouxcall BDx((oSx))endfunctionfunction gRo takes integer oSx,real oux returns nothingcall gOo(oSx,(MF[(oSx)])+oux)endfunctionfunction gIo takes nothing returns booleanlocal integer rFx=(bv)call gRo(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction gAo takes nothing returns nothingset JF=iXx()
call Dcx(Xdx("FolderUnit_StructManaRegeneration_Init: call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructManaRegeneration.Event_Death).AddToStatics()",VP,bI,function geo))call Dcx(Xdx("FolderUnit_StructManaRegeneration_Init: call Event.Create(UNIT.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructManaRegeneration.Event_Destroy).AddToStatics()",EP,bI,function gxo))call Dcx(Xdx("FolderUnit_StructManaRegeneration_Init: call Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructManaRegeneration.Event_Revive).AddToStatics()",XP,bI,function goo))call Dcx(Xdx("FolderUnit_FolderManaRegeneration_StructBase_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderManaRegeneration_StructBase.Event_TypeChange).AddToStatics()",OP,bI,function gro))set Dkv=Ayo(Vkv,function gio)call gXo()set EGv=Ayo(VMv,function gIo)endfunctionfunction gNo takes integer oSx returns nothingcall SetUnitPathing(C[(oSx)],(XBv[(oSx)]))endfunctionfunction gbo takes nothing returns booleanlocal integer rFx=(bv)call gNo(((Vv[(rFx)])))return trueendfunctionfunction gBo takes nothing returns nothingendfunctionfunction gco takes nothing returns booleanlocal integer rFx=(bv)call DTx(eJ,b4,(Vv[(rFx)]))return trueendfunctionfunction gCo takes nothing returns nothingset Xpv=Xdx("FolderUnit_StructSilence_Init: set FolderUnit_StructSilence.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructSilence.Event_Revive)",XP,bI,function gco)call UnitAddAbility(vJ[((eJ))],('aSil'))
endfunctionfunction gdo takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),XQv)return trueendfunctionfunction gDo takes nothing returns nothingset XSv=Xdx("FolderUnit_StructSleep_Init: set FolderUnit_StructSleep.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructSleep.Event_Damage)",E3v,bI,function gdo)
set Xtv=(E3x())call UnitAddAbility(vJ[((eJ))],('ACsl'))
endfunctionfunction gfo takes integer oSx returns booleanif(((bXv[((oSx))])>0)==false)thenreturn false
endifset bXv[bRv[bOv]]=bXv[oSx]set bRv[bXv[oSx]-1]=bRv[bOv]
set bXv[oSx]=0set bOv=bOv-1return(bOv==F)endfunctionfunction gFo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])if gfo(rLx)thencall ikx(bIv)endifcall RPx(rLx,N4v)call DPo(rLx,bVv)call DPo(rLx,bEv)return trueendfunctionfunction ggo takes nothing returns booleanlocal integer rFx=(bv)call Ico((Vv[(rFx)]))return trueendfunctionfunction gGo takes nothing returns booleanlocal integer rFx=(bv)call gfo((Vv[(rFx)]))return trueendfunctionfunction gho takes integer oSx,real oux returns nothingset bcv[oSx]=oux
call Igo((oSx))endfunctionfunction gHo takes integer oSx,real oux returns nothingcall gho(oSx,(bcv[(oSx)])+oux)endfunctionfunction gjo takes nothing returns booleanlocal integer rFx=(bv)call gHo(((Vv[(rFx)])),(Vc[(rFx)]))return trueendfunctionfunction gJo takes nothing returns nothingset N4v=Xdx("FolderUnit_StructStaminaRegeneration_Init: set FolderUnit_StructStaminaRegeneration.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructStaminaRegeneration.Event_Destroy)",EP,bI,function gFo)set bVv=Xdx("FolderUnit_StructStaminaRegeneration_Init: set FolderUnit_StructStaminaRegeneration.MOVE_ENDING_EVENT = Event.Create(UNIT.Movement.Events.ENDING_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructStaminaRegeneration.Event_MoveEnding)",bav,bI,function ggo)set bEv=Xdx("FolderUnit_StructStaminaRegeneration_Init: set FolderUnit_StructStaminaRegeneration.MOVE_START_EVENT = Event.Create(UNIT.Movement.Events.START_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructStaminaRegeneration.Event_MoveStart)",bnv,bI,function gGo)set bIv=iXx()set Dlv=Ayo(OSv,function gjo)endfunctionfunction gko takes integer oSx,boolean o5x returns nothingif o5x thencall Dux((((oSx))),(nlv),(1),w)else
call Ulx(((oSx)),nlv)endifendfunctionfunction gKo takes nothing returns booleanlocal integer rFx=(bv)call gko(((Vv[(rFx)])),(rc[(rFx)]))return trueendfunctionfunction glo takes integer oSx returns integerset Dsv[oSx]=trueset DSv[oSx]=falsecall rEx(XTv)return oSxendfunctionfunction gLo takes nothing returns integerlocal integer oSxif(Dpv==8190)thencall o_x("FolderUnit_FolderStun_StructCancel_Allocation_allocCustom","call DebugEx(FolderUnit_FolderStun_StructCancel.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Xuv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(DPv[(w)]==w)thenset Dqv=Dqv+1set oSx=Dqvelse
set oSx=DPv[(w)]
set DPv[(w)]=DPv[DPv[(w)]]endifset DPv[oSx]=Zset DQv[oSx]=1call glo(oSx)return oSxendfunctionfunction gmo takes integer oSx returns nothingset Dsv[oSx]=falsecall rHx(XTv)endfunctionfunction gMo takes integer oSx returns nothingif(DQv[oSx]>0)thenreturnendifif(DPv[oSx]!=Z)thencall o_x("FolderUnit_FolderStun_StructCancel_Allocation_deallocCustom_confirm","call DebugEx(FolderUnit_FolderStun_StructCancel.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Xuv+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset DPv[oSx]=DPv[(w)]set DPv[(w)]=oSx
call gmo(oSx)endfunctionfunction gpo takes integer oSx returns nothingset DQv[oSx]=DQv[oSx]-1call gMo(oSx)endfunctionfunction gPo takes integer oSx,integer Okx,integer rLx returns nothingcall gpo((oSx))call iKx(Okx)call rVx(rLx,DMv)call RPx(rLx,Dmv)call UnitRemoveAbility(C[((((rLx))))],(('bStu')))endfunctionfunction gqo takes nothing returns nothinglocal integer Okx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(Okx)])call gPo(oSx,Okx,DTv[oSx])endfunctionfunction gQo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(Vv[(rFx)])local integer oSx=osx(rLx,DMv)local integer Okxif not(ph[(rLx)])thenif(osx(rLx,DMv)==w)thenset oSx=gLo()set Okx=iXx()set Dtv[oSx]=Okx
set DTv[oSx]=rLx
set ge[(Okx)]=(oSx)call rwx(rLx,DMv,oSx)call Avx(rLx,Dmv)call iDx(Okx,.0,false,function gqo)endifendifreturn trueendfunctionfunction gso takes nothing returns nothingset Dmv=Xdx("FolderUnit_FolderStun_StructCancel_Init: set DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderStun_StructCancel.Event_Order)",VP,bI,function gQo)
call Flo(d4,Xdx("FolderUnit_FolderStun_StructCancel_Init: call Order.STUNNED.Event.Add(Event.Create(UNIT.Order.Events.Gain.Target.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderStun_StructCancel.Event_Order))",jj,bI,function gQo))endfunctionfunction gSo takes nothing returns nothingcall UnitAddAbility(vJ[((eJ))],('AStn'))
set DLv=Ayo(XUv,function gKo)call gso()endfunctionfunction gto takes nothing returns nothingset O8v=(E3x())set O7v=(E3x())endfunctionfunction gTo takes nothing returns booleanlocal integer rFx=(bv)call DTx(eJ,C3,(Vv[(rFx)]))return trueendfunctionfunction guo takes nothing returns nothingset EMv=Xdx("FolderUnit_StructWhirl_Init: set FolderUnit_StructWhirl.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructWhirl.Event_Revive)",XP,bI,function gTo)call UnitAddAbility(vJ[((eJ))],('aWhC'))
call UnitAddAbility(vJ[((eJ))],('aWhI'))
endfunctionfunction gUo takes nothing returns booleanreturn trueendfunctionfunction gwo takes nothing returns nothingcall akx(function gUo)endfunctionfunction gWo takes nothing returns nothingendfunctionfunction gyo takes nothing returns nothingcall dxo()call dBo()call dco()call d4o()call d5o()call d6o()call Ddo()call DKo()call Dto()call DTo()call fyo()call fzo()call f2o()call f3o()call f4o()call f5o()set DOv=Ayo(nzv,function f7o)call Feo()set DRv=Ayo(aEv,function Foo)call FUo()call F6o()call gvo()call gAo()call Dcx(Xdx("FolderUnit_StructPathing_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructPathing.Event_TypeChange).AddToStatics()",OP,bI,function gbo))call gBo()call gCo()call gDo()call gJo()call gSo()call gto()call guo()call gwo()call gWo()endfunctionfunction gYo takes nothing returns booleancall Xwo()call X_o()call X0o()set IJv=(E3x())set jf=XJx(function AAo)
set Iiv=XJx(function ANo)set EP=(E3x())set Ib=XJx(function AHo)
set Bcv=Xpx(function Ajo)set BCv=(E3x())call Amo()call Dcx(Xdx("FolderUnit_StructAttachments_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructAttachments.Event_TypeChange).AddToStatics()",OP,bI,function AMo))call Dcx(Xdx("FolderUnit_StructBlood_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructBlood.Event_TypeChange).AddToStatics()",OP,bI,function Apo))call Dcx(Xdx("FolderUnit_StructBloodExplosion_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructBloodExplosion.Event_TypeChange).AddToStatics()",OP,bI,function APo))call ATo()call Dcx(Xdx("FolderUnit_StructCollisionSize_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructCollisionSize.Event_TypeChange).AddToStatics()",OP,bI,function AUo))call Azo()call Nuo()call NUo()call N1o()set cVv=Ayo(iTv,function N2o)set cEv=Ayo(iPv,function N5o)set cXv=Xdx("FolderUnit_FolderEvent_StructCounted_Init: set FolderUnit_FolderEvent_StructCounted.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_FolderEvent_StructCounted.Event_Destroy)",EP,bI,function N9o)set Egv=Ayo(n1v,function bxo)call Dcx(Xdx("FolderUnit_StructImpact_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructImpact.Event_TypeChange).AddToStatics()",OP,bI,function bio))call bXo()set GG=(E3x())set cNv=Ayo(axv,function bRo)call bIo()set mF=(E3x())set cbv=Ayo(arv,function bNo)call bCo()call bFo()call Dcx(Xdx("FolderUnit_StructOutpact_Init: call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function FolderUnit_StructOutpact.Event_TypeChange).AddToStatics()",OP,bI,function bho))set rx=(E3x())call bJo()call bmo()call bso()call bzo()call b4o()call b6o()call Bro()call Bbo()call BYo()call cwo()call CVo()call CAo()call Cdo()call Cho()call akx(function gyo)return trueendfunctionfunction gzo takes nothing returns booleancall XPo(function gYo,"Unit_Init")return trueendfunctionfunction gZo takes nothing returns booleanset BKv=VXx(BGv)
return trueendfunctionfunction g_o takes nothing returns booleanset nbv=VXx(nXv)
return trueendfunctionfunction g0o takes nothing returns booleanset Duv=VXx(DUv)
return trueendfunctionfunction g1o takes nothing returns booleanset Dwv=VXx(DWv)
return trueendfunctionfunction g2o takes nothing returns booleanset Dyv=VXx(DYv)
return trueendfunctionfunction g3o takes nothing returns booleanset Dzv=VXx(DZv)
return trueendfunctionfunction g4o takes nothing returns booleanset D_v=VXx(D0v)
return trueendfunctionfunction g5o takes nothing returns booleanset D1v=VXx(D2v)
return trueendfunctionfunction g6o takes nothing returns booleanset D3v=VXx(D4v)
return trueendfunctionfunction g7o takes nothing returns booleanset D5v=VXx(D6v)
return trueendfunctionfunction g8o takes nothing returns booleanset D7v=VXx(D8v)
return trueendfunctionfunction g9o takes nothing returns booleanset D9v=VXx(fvv)
return trueendfunctionfunction Gvo takes nothing returns booleanset fev=VXx(fxv)
return trueendfunctionfunction Geo takes nothing returns booleanset fov=VXx(frv)
return trueendfunctionfunction Gxo takes nothing returns booleanset fiv=VXx(fav)
return trueendfunctionfunction Goo takes nothing returns booleanset ow=VXx(YU)return trueendfunctionfunction Gro takes nothing returns booleanset yB=VXx(wB)return trueendfunctionfunction Gio takes nothing returns booleanset fnv=VXx(fVv)
return trueendfunctionfunction Gao takes nothing returns booleanset fEv=VXx(fXv)
return trueendfunctionfunction Gno takes nothing returns booleanset fOv=VXx(fRv)
return trueendfunctionfunction GVo takes nothing returns booleanset fIv=VXx(fAv)
return trueendfunctionfunction GEo takes nothing returns booleanset fNv=VXx(fbv)
return trueendfunctionfunction GXo takes nothing returns booleanset fBv=VXx(fcv)
return trueendfunctionfunction GOo takes nothing returns booleanset fCv=VXx(fdv)
return trueendfunctionfunction GRo takes nothing returns booleanset fDv=VXx(ffv)
return trueendfunctionfunction GIo takes nothing returns booleanset fFv=VXx(fgv)
return trueendfunctionfunction GAo takes nothing returns booleanset fGv=VXx(fhv)
return trueendfunctionfunction GNo takes nothing returns booleanset fHv=VXx(fjv)
return trueendfunctionfunction Gbo takes nothing returns booleanset fJv=VXx(fkv)
return trueendfunctionfunction GBo takes nothing returns booleanset fKv=VXx(flv)
return trueendfunctionfunction Gco takes nothing returns booleanset fLv=VXx(fmv)
return trueendfunctionfunction GCo takes nothing returns booleanset fMv=VXx(fpv)
return trueendfunctionfunction Gdo takes nothing returns booleanset fPv=VXx(fqv)
return trueendfunctionfunction GDo takes nothing returns booleanset fQv=VXx(fsv)
return trueendfunctionfunction Gfo takes nothing returns booleanset fSv=VXx(ftv)
return trueendfunctionfunction GFo takes nothing returns booleanset fTv=VXx(fuv)
return trueendfunctionfunction Ggo takes nothing returns booleanset fUv=VXx(fwv)
return trueendfunctionfunction GGo takes nothing returns booleanset fWv=VXx(fyv)
return trueendfunctionfunction Gho takes nothing returns booleanset fYv=VXx(fzv)
return trueendfunctionfunction GHo takes nothing returns booleanset fZv=VXx(f_v)
return trueendfunctionfunction Gjo takes nothing returns booleanset f0v=VXx(f1v)
return trueendfunctionfunction GJo takes nothing returns booleanset f2v=VXx(f3v)
return trueendfunctionfunction Gko takes nothing returns booleanset f4v=VXx(f5v)
return trueendfunctionfunction GKo takes nothing returns booleanset f6v=VXx(f7v)
return trueendfunctionfunction Glo takes nothing returns booleanset f8v=VXx(f9v)
return trueendfunctionfunction GLo takes nothing returns booleanset Fvv=VXx(Fev)
return trueendfunctionfunction Gmo takes nothing returns booleanset Fxv=VXx(Fov)
return trueendfunctionfunction GMo takes nothing returns booleanset Frv=VXx(Fiv)
return trueendfunctionfunction Gpo takes nothing returns booleanset Fav=VXx(Fnv)
return trueendfunctionfunction GPo takes nothing returns booleanset FVv=VXx(FEv)
return trueendfunctionfunction Gqo takes nothing returns booleanset FXv=VXx(FOv)
return trueendfunctionfunction GQo takes nothing returns booleanset FRv=VXx(FIv)
return trueendfunctionfunction Gso takes nothing returns booleanset FAv=VXx(FNv)
return trueendfunctionfunction GSo takes nothing returns booleanset Fbv=VXx(FBv)
return trueendfunctionfunction Gto takes nothing returns booleanset Fcv=VXx(FCv)
return trueendfunctionfunction GTo takes nothing returns booleanset Fdv=VXx(FDv)
return trueendfunctionfunction Guo takes nothing returns booleanset Ffv=VXx(FFv)
return trueendfunctionfunction GUo takes nothing returns booleanset Fgv=VXx(FGv)
return trueendfunctionfunction Gwo takes nothing returns booleanset Fhv=VXx(FHv)
return trueendfunctionfunction GWo takes nothing returns booleanset Fjv=VXx(FJv)
return trueendfunctionfunction Gyo takes nothing returns booleanset Fkv=VXx(FKv)
return trueendfunctionfunction GYo takes nothing returns booleanset Flv=VXx(FLv)
return trueendfunctionfunction Gzo takes nothing returns booleanset Fmv=VXx(FMv)
return trueendfunctionfunction GZo takes nothing returns booleanset Fpv=VXx(FPv)
return trueendfunctionfunction G_o takes nothing returns booleanset Fqv=VXx(FQv)
return trueendfunctionfunction G0o takes nothing returns booleanset Fsv=VXx(FSv)
return trueendfunctionfunction G1o takes nothing returns booleanset Ftv=VXx(FTv)
return trueendfunctionfunction G2o takes nothing returns booleanset Fuv=VXx(FUv)
return trueendfunctionfunction G3o takes nothing returns booleanset Fwv=VXx(FWv)
return trueendfunctionfunction G4o takes nothing returns booleanset Fyv=VXx(FYv)
return trueendfunctionfunction G5o takes nothing returns booleanset Fzv=VXx(FZv)
return trueendfunctionfunction G6o takes nothing returns booleanset F_v=VXx(F0v)
return trueendfunctionfunction G7o takes nothing returns booleanset F1v=VXx(F2v)
return trueendfunctionfunction G8o takes nothing returns booleanset F3v=VXx(F4v)
return trueendfunctionfunction G9o takes nothing returns booleanset F5v=VXx(F6v)
return trueendfunctionfunction hvo takes nothing returns booleanset F7v=VXx(F8v)
return trueendfunctionfunction heo takes nothing returns booleanset F9v=VXx(gvv)
return trueendfunctionfunction hxo takes nothing returns booleanset gev=VXx(gxv)
return trueendfunctionfunction hoo takes nothing returns booleanset gov=VXx(grv)
return trueendfunctionfunction hro takes nothing returns booleanset giv=VXx(gav)
return trueendfunctionfunction hio takes nothing returns booleanset gnv=VXx(gVv)
return trueendfunctionfunction hao takes nothing returns booleanset gEv=VXx(gXv)
return trueendfunctionfunction hno takes nothing returns booleanset gOv=VXx(gRv)
return trueendfunctionfunction hVo takes nothing returns booleanset gIv=VXx(gAv)
return trueendfunctionfunction hEo takes code c,string rSx returns nothing
call VNx(sa,c,rSx)endfunctionfunction hXo takes integer oSx returns integerset gDv[oSx]=trueset gfv[oSx]=falseset Jw[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set BBv[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(gFv)return oSxendfunctionfunction hOo takes nothing returns integerlocal integer oSxif(gbv==8190)thencall o_x("UnitType_Allocation_allocCustom","call DebugEx(UnitType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",gBv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(gcv[(w)]==w)thenset gCv=gCv+1set oSx=gCvelse
set oSx=gcv[(w)]
set gcv[(w)]=gcv[gcv[(w)]]endifset gcv[oSx]=Zset gdv[oSx]=1call hXo(oSx)return oSxendfunctionfunction hRo takes integer oSx returns nothingset kw[(oSx)]=(gGv+oSx)endfunctionfunction hIo takes integer oSx returns nothingendfunctionfunction hAo takes integer oSx returns nothingcall hIo(oSx)set IZv[(oSx)]=F
endfunctionfunction hNo takes integer oSx returns nothingset I8v[(oSx)]=((.0)*1.)
set Anv[((oSx))]=(0)
endfunctionfunction hbo takes integer oSx returns nothingset Adv[oSx]=wset Dnv[(((oSx)))]=((.0)*1.)
set AGv[((oSx))]=((.0)*1.)set Ahv[((oSx))]=((.0)*1.)endfunctionfunction hBo takes integer oSx returns nothingset Auv[(oSx)]=((.0)*1.)
set AWv[((oSx))]=((.0)*1.)set AYv[((oSx))]=(0)
set A_v[((oSx))]=(0)
set A2v[((oSx))]=(-1)endfunctionfunction hco takes integer oSx returns nothingset ghv[(oSx)]=(true)set A5v[((oSx))]=((10.)*1.)endfunctionfunction hCo takes integer oSx returns nothingset Niv[((oSx))]=(0)
set Nnv[((oSx))]=(0)
endfunctionfunction hdo takes integer oSx returns nothingset bDv[(oSx)]=((.0)*1.)
set bjv[((oSx))]=((.0)*1.)endfunctionfunction hDo takes integer oSx returns nothingset bfv[(oSx)]=((.0)*1.)
set bkv[((oSx))]=((.0)*1.)endfunctionfunction hfo takes integer oSx returns nothingset bFv[(oSx)]=((.0)*1.)
set bKv[((oSx))]=((.0)*1.)endfunctionfunction hFo takes integer oSx returns nothingcall hdo(oSx)set bJv[((oSx))]=((.0)*1.)call hDo(oSx)set tf[((oSx))]=(0)call hfo(oSx)endfunctionfunction hgo takes integer oSx returns nothinglocal unit HAx=aGx(vx[Jy],Ikv[(oSx)],.0,.0,.0)call KillUnit(HAx)call MDx(HAx)set HAx=null
endfunctionfunction hGo takes integer oSx returns nothingset Nyv[((oSx))]=((255.)*1.)
set NYv[((oSx))]=((255.)*1.)
set Nzv[((oSx))]=((255.)*1.)
set NZv[((oSx))]=((255.)*1.)
endfunctionfunction hho takes integer oSx returns booleanset gHv=gHv+1set gjv[gHv]=oSx
set gJv[oSx]=gHv+1return(gHv==0)endfunctionfunction hHo takes integer oqx returns integerlocal integer oSx=hOo()set ggv[oSx]=nullset Ikv[oSx]=oqx
call hRo(oSx)call hAo(oSx)call hNo(oSx)call hbo(oSx)set AQv[((oSx))]=(null)set nKv[((oSx))]=(null)set ATv[((oSx))]=((.0)*1.)call hBo(oSx)call hco(oSx)call hCo(oSx)call hFo(oSx)set NOv[(((oSx)))]=((60.)*1.)set Nmv[((oSx))]=((.0)*1.)set NKv[((oSx))]=((.0)*1.)set Npv[((oSx))]=((.0)*1.)set Nlv[((oSx))]=((.0)*1.)call hgo(oSx)set NWv[(((oSx)))]=((60.)*1.)set NAv[((oSx))]=(true)set Uj[((oSx))]=((1.)*1.)set NPv[((oSx))]=((.0)*1.)set NGv[((oSx))]=((.0)*1.)set Njv[((oSx))]=((.0)*1.)call hGo(oSx)set nKv[(oSx)]=("Objects\\Spawnmodels\\Human\\HumanSmallDeathExplode\\HumanSmallDeathExplode.mdl")call hho(oSx)call Xlx(lv[(E[((X))])],((((GetObjectName(Ikv[(oSx)]))))),(((I2S(((ff)))))),(((oSx))))return oSxendfunctionfunction hjo takes integer oqx returns integerlocal integer oSx=hHo(oqx)set Ikv[oSx]=oqx
call SaveInteger(o[((V[(E[((X))])]))],(((oqx))),(((ff))),(((oSx))))return oSxendfunctionfunction hJo takes integer oSx,integer otx,integer oux returns booleanreturn rux(Jw[(oSx)],(kw[((oSx))]),otx,oux)endfunctionfunction hko takes integer oSx,real izx,real iZx,real i_x,real i0x returns nothingset Nyv[(oSx)]=((izx)*1.)set NYv[(oSx)]=((iZx)*1.)set Nzv[(oSx)]=((i_x)*1.)set NZv[(oSx)]=((i0x)*1.)endfunctionfunction hKo takes nothing returns booleanset gNv=hjo('uKoM')call hJo(((gNv)),ASv,(Idv))set Uj[(gNv)]=((.85)*1.)
call hko(gNv,$FF,$FF,$A5,$FF)set NOv[(gNv)]=((83.044982698962)*1.)set NWv[(gNv)]=((83.044982698962)*1.)set NPv[(gNv)]=((270)*1.)set I8v[(gNv)]=((1)*1.)set Anv[(gNv)]=(2)set Nmv[(gNv)]=(($AF)*1.)set NLv[(gNv)]=(($AF)*1.)set NKv[(gNv)]=((.2)*1.)
set Ncv[(gNv)]=(($578)*1.)set Nbv[(gNv)]=(($578)*1.)set NGv[(gNv)]=(($A)*1.)
set Adv[(gNv)]=(gkv)
set AGv[(gNv)]=(('x')*1.)set Ahv[((gNv))]=((1.*1./((1.35)*1.))*1.)set AWv[(gNv)]=((.38)*1.)set Auv[(gNv)]=((4)*1.)set AUv[(gNv)]=((4)*1.)set AYv[(gNv)]=(1)set A_v[(gNv)]=(3)set A2v[(gNv)]=(0)set ATv[(gNv)]=((42.906574394464)*1.)set Nnv[(gNv)]=(20)set Niv[(gNv)]=($A)return trueendfunctionfunction hlo takes nothing returns booleanset gKv=hjo('uMoo')call hJo(((gKv)),ASv,(Idv))set Uj[(gKv)]=((1.25)*1.)set NOv[(gKv)]=((41.666666666667)*1.)set NWv[(gKv)]=((41.666666666667)*1.)set AQv[(gKv)]=("Objects\\Spawnmodels\\NightElf\\NightElfBlood\\NightElfBloodDruidoftheClaw.mdx")set NPv[(gKv)]=(($87)*1.)set I8v[(gKv)]=((3)*1.)set Anv[(gKv)]=(2)set Nmv[(gKv)]=(($8C)*1.)set NLv[(gKv)]=(($8C)*1.)set NKv[(gKv)]=((.8)*1.)
set Ncv[(gKv)]=(($578)*1.)set Nbv[(gKv)]=(($578)*1.)set NGv[(gKv)]=((27.5)*1.)set Adv[(gKv)]=(gkv)
set AGv[(gKv)]=((153.6)*1.)set Ahv[((gKv))]=((1.*1./((1.7)*1.))*1.)
set AWv[(gKv)]=((.3)*1.)
set Auv[(gKv)]=(($D)*1.)
set AUv[(gKv)]=(($D)*1.)
set AYv[(gKv)]=(2)set A_v[(gKv)]=(4)set A2v[(gKv)]=(0)set ATv[(gKv)]=((33.333333333333)*1.)set Nnv[(gKv)]=(9)set Niv[(gKv)]=(60)return trueendfunctionfunction hLo takes nothing returns booleanset glv=hjo('uPeC')call hJo(((glv)),ASv,(Idv))set Uj[(glv)]=((3)*1.)call hko(glv,$FF,$BF,0,$FF)set NOv[(glv)]=((60)*1.)
set NWv[(glv)]=((60)*1.)
set NPv[(glv)]=(($C8)*1.)set I8v[(glv)]=((0)*1.)set Anv[(glv)]=(3)set Nmv[(glv)]=(('i')*1.)set NLv[(glv)]=(('i')*1.)set NKv[(glv)]=((.6)*1.)
set Ncv[(glv)]=((350)*1.)set Nbv[(glv)]=((350)*1.)set NGv[(glv)]=(($F)*1.)
set Adv[(glv)]=(gkv)
set AGv[(glv)]=(('x')*1.)set Ahv[((glv))]=((1.*1./((1.5)*1.))*1.)
set AWv[(glv)]=((1)*1.)set Auv[(glv)]=((5)*1.)set AUv[(glv)]=((5)*1.)set AYv[(glv)]=(1)set A_v[(glv)]=($A)set A2v[(glv)]=(0)set ATv[(glv)]=((16)*1.)
return trueendfunctionfunction hmo takes integer oSx,integer otx,integer oux returns booleanreturn((LoadInteger(o[((D[((Jw[(oSx)]))]))],((((kw[((oSx))])))),(oTx(((otx)),(((oux)))))))!=0)endfunctionfunction hMo takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((Jw[(oSx)]))])]))],((((kw[((oSx))])))),(((otx))),(((oux))))endfunctionfunction hpo takes integer oSx,integer rlx,integer rYx returns nothingif hmo((oSx),Iwv,rlx)thencall o_x("FolderUnitType_FolderAbilities_StructArrayBuild_Add","call DebugEx(\"unitType \"+UnitType(this).GetName()+\" already has spell \"+whichSpell.GetName())","unitType "+(GetObjectName(Ikv[((oSx))]))+" already has spell "+(TH[(rlx)]))returnendifcall hJo((oSx),Iwv,rlx)call hMo((oSx),IWv+rlx,rYx)endfunctionfunction hPo takes nothing returns booleanset gLv=hjo('uGnM')call hJo(((gLv)),ASv,(Idv))set Uj[(gLv)]=((1.25)*1.)set NOv[(gLv)]=((26.666666666667)*1.)set NWv[(gLv)]=((26.666666666667)*1.)set NPv[(gLv)]=(($87)*1.)set I8v[(gLv)]=((0)*1.)set Anv[(gLv)]=(0)set Nmv[(gLv)]=((85)*1.)
set NLv[(gLv)]=((85)*1.)
set NKv[(gLv)]=((.3)*1.)
set Npv[(gLv)]=((90)*1.)
set NMv[(gLv)]=((90)*1.)
set Nlv[(gLv)]=((.2)*1.)
set Ncv[(gLv)]=(($578)*1.)set Nbv[(gLv)]=(($578)*1.)set NGv[(gLv)]=((40)*1.)
set Adv[(gLv)]=(gmv)
set AGv[(gLv)]=((600)*1.)set Ahv[((gLv))]=((1.*1./((1.6)*1.))*1.)
set AWv[(gLv)]=((.3)*1.)
set Dnv[(gLv)]=(($4B0)*1.)set Auv[(gLv)]=((7)*1.)set AUv[(gLv)]=((7)*1.)set AYv[(gLv)]=(1)set A_v[(gLv)]=(5)set A2v[(gLv)]=(3)set ATv[(gLv)]=((14.222222222222)*1.)set Nnv[(gLv)]=(7)set Niv[(gLv)]=(35)call hpo((gLv),(gMv),1)return trueendfunctionfunction hqo takes integer oSx,integer rlx returns nothinglocal integer hQo=IZv[oSx]+1
set IZv[oSx]=hQo
call hMo((oSx),I4v+hQo,rlx)endfunctionfunction hso takes nothing returns booleanset gpv=hjo('UKer')call hpo((gpv),('AInv'),1)call hJo(((gpv)),ASv,(Wd))call hJo(((gpv)),ASv,(Idv))set Uj[(gpv)]=((1.3)*1.)
set NOv[(gpv)]=((80)*1.)
set NWv[(gpv)]=((80)*1.)
set NPv[(gpv)]=((320)*1.)set I8v[(gpv)]=((3)*1.)set Anv[(gpv)]=(4)set Nmv[(gpv)]=(('d')*1.)set NLv[(gpv)]=(('d')*1.)set NKv[(gpv)]=((0)*1.)set Npv[(gpv)]=(('d')*1.)set NMv[(gpv)]=(('d')*1.)set Nlv[(gpv)]=((0)*1.)set Ncv[(gpv)]=(($708)*1.)set Nbv[(gpv)]=(($708)*1.)set Adv[(gpv)]=(gkv)
set AGv[(gpv)]=(('x')*1.)set Ahv[((gpv))]=((1.*1./((1.3)*1.))*1.)
set AWv[(gpv)]=((.3)*1.)
set Auv[(gpv)]=(($A)*1.)
set AUv[(gpv)]=(($A)*1.)
set AYv[(gpv)]=(4)set A_v[(gpv)]=(4)set A2v[(gpv)]=(0)set ATv[(gpv)]=((32)*1.)
call hqo(gpv,gPv)call hqo(gpv,gqv)call hqo(gpv,gQv)call hqo(gpv,gsv)set bDv[(gpv)]=(($C)*1.)
set bjv[(gpv)]=((3.75)*1.)set bJv[(gpv)]=((1)*1.)set bfv[(gpv)]=(($A)*1.)
set bkv[(gpv)]=((3.5)*1.)set bFv[(gpv)]=((9.5)*1.)set bKv[(gpv)]=((4)*1.)return trueendfunctionfunction hSo takes nothing returns booleanset gSv=hjo('uBTw')call hJo(((gSv)),ASv,(Igv))set Uj[(gSv)]=((1.55)*1.)call hko(gSv,$C8,$C8,$C8,$FF)set I8v[(gSv)]=((0)*1.)set Anv[(gSv)]=(3)set Nmv[(gSv)]=((150000.)*1.)set NLv[(gSv)]=((150000.)*1.)set NKv[(gSv)]=((0)*1.)set Ncv[(gSv)]=(($578)*1.)set Nbv[(gSv)]=(($578)*1.)set Auv[(gSv)]=((0)*1.)set AUv[(gSv)]=((0)*1.)set AYv[(gSv)]=(0)set A_v[(gSv)]=(0)call hpo((gSv),(gtv),1)return trueendfunctionfunction hto takes nothing returns booleanset gTv=hjo('uITP')call hJo(((gTv)),ASv,(Idv))set Uj[(gTv)]=((1.75)*1.)call hko(gTv,$AA,$82,$FF,$FF)set NOv[(gTv)]=((38.4)*1.)set NWv[(gTv)]=((38.4)*1.)set NPv[(gTv)]=(($91)*1.)set I8v[(gTv)]=((0)*1.)set Anv[(gTv)]=(1)set Nmv[(gTv)]=(('s')*1.)set NLv[(gTv)]=(('s')*1.)set NKv[(gTv)]=((.4)*1.)
set Npv[(gTv)]=((80)*1.)
set NMv[(gTv)]=((80)*1.)
set Nlv[(gTv)]=((.4)*1.)
set Ncv[(gTv)]=(($578)*1.)set Nbv[(gTv)]=(($578)*1.)set NGv[(gTv)]=((35)*1.)
set Adv[(gTv)]=(guv)
set AGv[(gTv)]=((720)*1.)set Ahv[((gTv))]=((1.*1./((1.8)*1.))*1.)
set AWv[(gTv)]=((.3)*1.)
set Dnv[(gTv)]=((900)*1.)set Auv[(gTv)]=((8)*1.)set AUv[(gTv)]=((8)*1.)set AYv[(gTv)]=(1)set A_v[(gTv)]=(8)set A2v[(gTv)]=(3)set ATv[(gTv)]=((25.6)*1.)set Nnv[(gTv)]=(9)set Niv[(gTv)]=(25)call hpo((gTv),(gUv),1)call hpo((gTv),(gwv),1)return trueendfunctionfunction hTo takes nothing returns booleanset gWv=hjo('uDT2')call hJo(((gWv)),ASv,(Igv))set Uj[(gWv)]=((2.25)*1.)call hko(gWv,$90,0,$90,$FF)set NOv[(gWv)]=(('x')*1.)set NWv[(gWv)]=(($B4)*1.)set I8v[(gWv)]=((0)*1.)set Anv[(gWv)]=(3)set Nmv[(gWv)]=((150000.)*1.)set NLv[(gWv)]=((150000.)*1.)set NKv[(gWv)]=((0)*1.)set Ncv[(gWv)]=(($578)*1.)set Nbv[(gWv)]=(($578)*1.)set Adv[(gWv)]=(guv)
set AGv[(gWv)]=(($4B0)*1.)set Ahv[((gWv))]=((1.*1./((1.6)*1.))*1.)
set AWv[(gWv)]=((.5)*1.)
set Dnv[(gWv)]=(($3E8)*1.)set Auv[(gWv)]=((32)*1.)
set AUv[(gWv)]=((32)*1.)
set AYv[(gWv)]=(3)set A_v[(gWv)]=(5)set A2v[(gWv)]=(4)call hpo((gWv),(gtv),1)call hpo((gWv),(gyv),(2))return trueendfunctionfunction huo takes nothing returns booleanset gYv=hjo('UThr')call hpo((gYv),('AInv'),1)call hJo(((gYv)),ASv,(Wd))call hJo(((gYv)),ASv,(Idv))set Uj[(gYv)]=((1.35)*1.)set NOv[(gYv)]=((60)*1.)
set NWv[(gYv)]=((60)*1.)
set NPv[(gYv)]=((330)*1.)set I8v[(gYv)]=((.5)*1.)
set Anv[(gYv)]=(4)set Nmv[(gYv)]=(('d')*1.)set NLv[(gYv)]=(('d')*1.)set NKv[(gYv)]=((0)*1.)set Npv[(gYv)]=(('d')*1.)set NMv[(gYv)]=(('d')*1.)set Nlv[(gYv)]=((0)*1.)set Ncv[(gYv)]=(($708)*1.)set Nbv[(gYv)]=(($708)*1.)set Adv[(gYv)]=(guv)
set AGv[(gYv)]=((720)*1.)set Ahv[((gYv))]=((1.*1./((1.7)*1.))*1.)
set AWv[(gYv)]=((.3)*1.)
set Dnv[(gYv)]=(($4B0)*1.)set Auv[(gYv)]=((7)*1.)set AUv[(gYv)]=((7)*1.)set AYv[(gYv)]=(1)set A_v[(gYv)]=($A)set A2v[(gYv)]=(3)set ATv[(gYv)]=((32)*1.)
call hqo(gYv,gzv)call hqo(gYv,gZv)call hqo(gYv,g_v)call hqo(gYv,g0v)set bDv[(gYv)]=((9)*1.)set bjv[(gYv)]=((3.5)*1.)set bJv[(gYv)]=((.5)*1.)
set bfv[(gYv)]=((14.5)*1.)set bkv[(gYv)]=((4)*1.)set bFv[(gYv)]=((7.5)*1.)set bKv[(gYv)]=((3)*1.)return trueendfunctionfunction hUo takes nothing returns booleanset g1v=hjo('uIcT')call hJo(((g1v)),ASv,(Idv))set Uj[(g1v)]=((1.25)*1.)call hko(g1v,$BE,$FF,$FF,$FF)set NOv[(g1v)]=((60)*1.)
set NWv[(g1v)]=((60)*1.)
set NPv[(g1v)]=(($91)*1.)set I8v[(g1v)]=((1)*1.)set Anv[(g1v)]=(1)set Nmv[(g1v)]=((70)*1.)
set NLv[(g1v)]=((70)*1.)
set NKv[(g1v)]=((.15)*1.)set Ncv[(g1v)]=(($578)*1.)set Nbv[(g1v)]=(($578)*1.)set NGv[(g1v)]=((20)*1.)
set Adv[(g1v)]=(gkv)
set AGv[(g1v)]=(('x')*1.)set Ahv[((g1v))]=((1.*1./((1.6)*1.))*1.)
set AWv[(g1v)]=((.3)*1.)
set Auv[(g1v)]=((8)*1.)set AUv[(g1v)]=((8)*1.)set AYv[(g1v)]=(2)set A_v[(g1v)]=(2)set A2v[(g1v)]=(0)set ATv[(g1v)]=((32)*1.)
set Nnv[(g1v)]=(6)set Niv[(g1v)]=(30)return trueendfunctionfunction hwo takes integer oSx,integer o9x,integer otx,real oux returns booleanlocal integer rvx=(0+(LoadInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx))))))+1call SaveInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx))),(((rvx)-0)))
call SaveReal(o[((V[(E[(oSx)])]))],((o9x)),((otx+rvx)),((((oux)*1.))*1.))return(rvx==q)endfunctionfunction hWo takes integer oSx,integer otx,real oux returns booleanreturn hwo(Jw[(oSx)],(kw[((oSx))]),otx,oux)endfunctionfunction hyo takes integer oSx,real O4o,real O5o returns nothing
call hWo((oSx),AHv,O4o)call hWo((oSx),Aqv,O5o)endfunctionfunction hYo takes nothing returns booleanset g2v=hjo('uFTw')call hJo(((g2v)),ASv,(Igv))set Uj[(g2v)]=((1.4)*1.)
set NOv[(g2v)]=(('x')*1.)set NWv[(g2v)]=(($91)*1.)set I8v[(g2v)]=((0)*1.)set Anv[(g2v)]=(3)set Nmv[(g2v)]=((150000.)*1.)set NLv[(g2v)]=((150000.)*1.)set NKv[(g2v)]=((0)*1.)set Ncv[(g2v)]=(($578)*1.)set Nbv[(g2v)]=(($578)*1.)set Adv[(g2v)]=(guv)
set AGv[(g2v)]=(($4B0)*1.)set Ahv[((g2v))]=((1.*1./((2.5)*1.))*1.)
set AWv[(g2v)]=((.5)*1.)
set Dnv[(g2v)]=((700)*1.)call hyo(g2v,80,1)call hyo(g2v,$96,.4)
call hyo(g2v,$DC,.2)
set Auv[(g2v)]=((19)*1.)
set AUv[(g2v)]=((19)*1.)
set AYv[(g2v)]=(2)set A_v[(g2v)]=(3)set A2v[(g2v)]=(3)call hpo((g2v),(gtv),1)call hpo((g2v),(g3v),1)return trueendfunctionfunction hzo takes nothing returns booleanset g4v=hjo('UMan')call hpo((g4v),('AInv'),1)call hJo(((g4v)),ASv,(Wd))call hJo(((g4v)),ASv,(Idv))set Uj[(g4v)]=((1.25)*1.)set NOv[(g4v)]=((83.044982698962)*1.)set NWv[(g4v)]=((91.349480968858)*1.)set NPv[(g4v)]=((305)*1.)set I8v[(g4v)]=((0)*1.)set Anv[(g4v)]=(4)set Nmv[(g4v)]=(('d')*1.)set NLv[(g4v)]=(('d')*1.)set NKv[(g4v)]=((0)*1.)set Npv[(g4v)]=(('d')*1.)set NMv[(g4v)]=(('d')*1.)set Nlv[(g4v)]=((0)*1.)set Ncv[(g4v)]=(($708)*1.)set Nbv[(g4v)]=(($708)*1.)set Adv[(g4v)]=(guv)
set AGv[(g4v)]=((720)*1.)set Ahv[((g4v))]=((1.*1./((1.7)*1.))*1.)
set AWv[(g4v)]=((.55)*1.)set Dnv[(g4v)]=((900)*1.)set Auv[(g4v)]=(($E)*1.)
set AUv[(g4v)]=(($E)*1.)
set AYv[(g4v)]=(1)set A_v[(g4v)]=($E)set A2v[(g4v)]=(3)set ATv[(g4v)]=((37.647058823529)*1.)call hqo(g4v,g5v)call hqo(g4v,g6v)call hqo(g4v,g7v)call hqo(g4v,g8v)set bDv[(g4v)]=((7.5)*1.)set bjv[(g4v)]=((3)*1.)set bJv[(g4v)]=((.4)*1.)
set bfv[(g4v)]=((17.5)*1.)set bkv[(g4v)]=((4.5)*1.)set bFv[(g4v)]=((5)*1.)set bKv[(g4v)]=((2.5)*1.)return trueendfunctionfunction hZo takes nothing returns booleanset g9v=hjo('uFuM')call hJo(((g9v)),ASv,(Idv))set Uj[(g9v)]=((1.75)*1.)call hko(g9v,$FF,'x',$96,$FF)set NOv[(g9v)]=((35.502958579882)*1.)set NWv[(g9v)]=((35.502958579882)*1.)set NPv[(g9v)]=(($BE)*1.)set I8v[(g9v)]=((4)*1.)set Anv[(g9v)]=(2)set Nmv[(g9v)]=((600)*1.)set NLv[(g9v)]=((600)*1.)set NKv[(g9v)]=((1)*1.)set Npv[(g9v)]=(('d')*1.)set NMv[(g9v)]=(('d')*1.)set Nlv[(g9v)]=((.4)*1.)
set Ncv[(g9v)]=(($578)*1.)set Nbv[(g9v)]=(($578)*1.)set NGv[(g9v)]=((40)*1.)
set Adv[(g9v)]=(gkv)
set AGv[(g9v)]=(($A8)*1.)set Ahv[((g9v))]=((1.*1./((2)*1.))*1.)set AWv[(g9v)]=((.3)*1.)
set Auv[(g9v)]=((24)*1.)
set AUv[(g9v)]=((24)*1.)
set AYv[(g9v)]=(3)set A_v[(g9v)]=(4)set A2v[(g9v)]=(4)set ATv[(g9v)]=((28.402366863905)*1.)set Nnv[(g9v)]=($96)
set Niv[(g9v)]=(80)call hpo((g9v),(Gvv),1)return trueendfunctionfunction h_o takes nothing returns booleanset Gev=hjo('uTrP')call hJo(((Gev)),ASv,(Idv))set Uj[(Gev)]=((1)*1.)call hko(Gev,$FF,$8C,$FF,$FF)set NOv[(Gev)]=((123.45679012346)*1.)set NWv[(Gev)]=((74.074074074074)*1.)set NPv[(Gev)]=((280)*1.)set I8v[(Gev)]=((0)*1.)set Anv[(Gev)]=(2)set Nmv[(Gev)]=((400)*1.)set NLv[(Gev)]=((400)*1.)set NKv[(Gev)]=((.3)*1.)
set Ncv[(Gev)]=(($578)*1.)set Nbv[(Gev)]=(($578)*1.)set NGv[(Gev)]=((30)*1.)
set Adv[(Gev)]=(gkv)
set AGv[(Gev)]=(('x')*1.)set Ahv[((Gev))]=((1.*1./((1.35)*1.))*1.)set AWv[(Gev)]=((.467)*1.)set Auv[(Gev)]=(($F)*1.)
set AUv[(Gev)]=(($F)*1.)
set AYv[(Gev)]=(1)set A_v[(Gev)]=(2)set A2v[(Gev)]=(0)set ATv[(Gev)]=((39.506172839506)*1.)set Nnv[(Gev)]=(21)set Niv[(Gev)]=(55)return trueendfunctionfunction h0o takes nothing returns booleanset Gxv=hjo('uFT2')call hJo(((Gxv)),ASv,(Igv))set Uj[(Gxv)]=((1.6)*1.)
call hko(Gxv,92,92,$FF,$FF)set NOv[(Gxv)]=(('x')*1.)set NWv[(Gxv)]=(($91)*1.)set I8v[(Gxv)]=((0)*1.)set Anv[(Gxv)]=(3)set Nmv[(Gxv)]=((150000.)*1.)set NLv[(Gxv)]=((150000.)*1.)set NKv[(Gxv)]=((0)*1.)set Ncv[(Gxv)]=(($578)*1.)set Nbv[(Gxv)]=(($578)*1.)set Adv[(Gxv)]=(guv)
set AGv[(Gxv)]=(($4B0)*1.)set Ahv[((Gxv))]=((1.*1./((2.5)*1.))*1.)
set AWv[(Gxv)]=((.5)*1.)
set Dnv[(Gxv)]=((700)*1.)call hyo(Gxv,80,1)call hyo(Gxv,$96,.4)
call hyo(Gxv,$DC,.2)
set Auv[(Gxv)]=((27)*1.)
set AUv[(Gxv)]=((27)*1.)
set AYv[(Gxv)]=(4)set A_v[(Gxv)]=(3)set A2v[(Gxv)]=(3)call hpo((Gxv),(gtv),1)call hpo((Gxv),(g3v),(2))return trueendfunctionfunction h1o takes nothing returns booleanset Gov=hjo('uWoM')call hJo(((Gov)),ASv,(Idv))set Uj[(Gov)]=((1.45)*1.)call hko(Gov,$96,'x',$FF,$FF)set NOv[(Gov)]=((28.537455410226)*1.)set NWv[(Gov)]=((28.537455410226)*1.)set NPv[(Gov)]=((320)*1.)set I8v[(Gov)]=((2)*1.)set Anv[(Gov)]=(2)set Nmv[(Gov)]=((350)*1.)set NLv[(Gov)]=((350)*1.)set NKv[(Gov)]=((.4)*1.)
set Ncv[(Gov)]=(($578)*1.)set Nbv[(Gov)]=(($578)*1.)set NGv[(Gov)]=((20)*1.)
set Adv[(Gov)]=(gkv)
set AGv[(Gov)]=(('l')*1.)set Ahv[((Gov))]=((1.*1./((1.4)*1.))*1.)
set AWv[(Gov)]=((.33)*1.)set Auv[(Gov)]=((18)*1.)
set AUv[(Gov)]=((18)*1.)
set AYv[(Gov)]=(3)set A_v[(Gov)]=(4)set A2v[(Gov)]=(0)set ATv[(Gov)]=((22.829964328181)*1.)set Nnv[(Gov)]=(50)set Niv[(Gov)]=(60)return trueendfunctionfunction h2o takes nothing returns booleanset Grv=hjo('UDra')call hpo((Grv),('AInv'),1)call hJo(((Grv)),ASv,(Wd))call hJo(((Grv)),ASv,(Idv))set Uj[(Grv)]=((1.3)*1.)
set NOv[(Grv)]=(('d')*1.)set NWv[(Grv)]=((60)*1.)
set NPv[(Grv)]=((330)*1.)set I8v[(Grv)]=((1)*1.)set Anv[(Grv)]=(4)set Nmv[(Grv)]=(('d')*1.)set NLv[(Grv)]=(('d')*1.)set NKv[(Grv)]=((0)*1.)set Npv[(Grv)]=(('d')*1.)set NMv[(Grv)]=(('d')*1.)set Nlv[(Grv)]=((0)*1.)set Ncv[(Grv)]=(($708)*1.)set Nbv[(Grv)]=(($708)*1.)set Adv[(Grv)]=(gkv)
set AGv[(Grv)]=(('x')*1.)set Ahv[((Grv))]=((1.*1./((1.6)*1.))*1.)
set AWv[(Grv)]=((.55)*1.)set Auv[(Grv)]=(($E)*1.)
set AUv[(Grv)]=(($E)*1.)
set AYv[(Grv)]=(2)set A_v[(Grv)]=(7)set A2v[(Grv)]=(0)set ATv[(Grv)]=((32)*1.)
call hqo(Grv,Giv)call hqo(Grv,Gav)call hqo(Grv,Gnv)call hqo(Grv,GVv)set bDv[(Grv)]=((9)*1.)set bjv[(Grv)]=((3.7)*1.)set bJv[(Grv)]=((.65)*1.)set bfv[(Grv)]=((9)*1.)set bkv[(Grv)]=((3.7)*1.)set bFv[(Grv)]=(($B)*1.)
set bKv[(Grv)]=((4)*1.)return trueendfunctionfunction h3o takes nothing returns booleanset GEv=hjo('uRai')call hJo(((GEv)),ASv,(Idv))set Uj[(GEv)]=((1)*1.)set NOv[(GEv)]=((60)*1.)
set NWv[(GEv)]=((60)*1.)
set NPv[(GEv)]=(($96)*1.)set I8v[(GEv)]=((0)*1.)set Anv[(GEv)]=(1)set Nmv[(GEv)]=(($C8)*1.)set NLv[(GEv)]=(($C8)*1.)set NKv[(GEv)]=((.1)*1.)
set Ncv[(GEv)]=(($578)*1.)set Nbv[(GEv)]=(($578)*1.)set NGv[(GEv)]=((30)*1.)
set Adv[(GEv)]=(gkv)
set AGv[(GEv)]=(($A2)*1.)set Ahv[((GEv))]=((1.*1./((1.85)*1.))*1.)set AWv[(GEv)]=((.5)*1.)
set Auv[(GEv)]=(($A)*1.)
set AUv[(GEv)]=(($A)*1.)
set AYv[(GEv)]=(1)set A_v[(GEv)]=(5)set A2v[(GEv)]=(2)set ATv[(GEv)]=((32)*1.)
set Nnv[(GEv)]=(35)set Niv[(GEv)]=(40)return trueendfunctionfunction h4o takes nothing returns booleanset GXv=hjo('uVia')call hJo(((GXv)),ASv,(Idv))set Uj[(GXv)]=((1.15)*1.)call hko(GXv,$FF,$FF,$FF,$FF)set NOv[(GXv)]=((60)*1.)
set NWv[(GXv)]=((60)*1.)
set NPv[(GXv)]=((270)*1.)set I8v[(GXv)]=((0)*1.)set Anv[(GXv)]=(5)set Nmv[(GXv)]=(($C8)*1.)set NLv[(GXv)]=(($C8)*1.)set NKv[(GXv)]=((.2)*1.)
set Npv[(GXv)]=(($96)*1.)set NMv[(GXv)]=(($96)*1.)set Nlv[(GXv)]=((.2)*1.)
set Ncv[(GXv)]=(($578)*1.)set Nbv[(GXv)]=(($578)*1.)set NGv[(GXv)]=(($F)*1.)
set Adv[(GXv)]=(guv)
set AGv[(GXv)]=((720)*1.)set Ahv[((GXv))]=((1.*1./((2)*1.))*1.)set AWv[(GXv)]=((.3)*1.)
set Dnv[(GXv)]=(($4B0)*1.)set Auv[(GXv)]=((1)*1.)set AUv[(GXv)]=((1)*1.)set AYv[(GXv)]=(1)set A_v[(GXv)]=(2)set A2v[(GXv)]=(3)set ATv[(GXv)]=((16)*1.)
set Nnv[(GXv)]=(20)set Niv[(GXv)]=($A)return trueendfunctionfunction h5o takes nothing returns booleanset GOv=hjo('uAss')call hJo(((GOv)),ASv,(Idv))set Uj[(GOv)]=((1.1)*1.)
set NOv[(GOv)]=((38.4)*1.)set NWv[(GOv)]=((38.4)*1.)set NPv[(GOv)]=(($87)*1.)set I8v[(GOv)]=((1)*1.)set Anv[(GOv)]=(5)set Nmv[(GOv)]=(($F0)*1.)set NLv[(GOv)]=(($F0)*1.)set NKv[(GOv)]=((.2)*1.)
set Npv[(GOv)]=(($C8)*1.)set NMv[(GOv)]=(($C8)*1.)set Nlv[(GOv)]=((.6)*1.)
set Ncv[(GOv)]=(($708)*1.)set Nbv[(GOv)]=(($708)*1.)set NGv[(GOv)]=((60)*1.)
set Adv[(GOv)]=(gkv)
set AGv[(GOv)]=(('x')*1.)set Ahv[((GOv))]=((1.*1./((1.4)*1.))*1.)
set AWv[(GOv)]=((.35)*1.)set Auv[(GOv)]=(($A)*1.)
set AUv[(GOv)]=(($A)*1.)
set AYv[(GOv)]=(2)set A_v[(GOv)]=(6)set A2v[(GOv)]=(0)set ATv[(GOv)]=((20.48)*1.)set Nnv[(GOv)]=(30)set Niv[(GOv)]=('d')
call hpo((GOv),(GRv),1)return trueendfunctionfunction h6o takes nothing returns booleanset GIv=hjo('uTus')call hJo(((GIv)),ASv,(Idv))set Uj[(GIv)]=((.75)*1.)
call hko(GIv,$FF,$FF,$FF,$FF)set NOv[(GIv)]=((106.66666666667)*1.)set NWv[(GIv)]=((126.22222222222)*1.)set NPv[(GIv)]=((270)*1.)set I8v[(GIv)]=((0)*1.)set Anv[(GIv)]=(1)set Nmv[(GIv)]=(('n')*1.)set NLv[(GIv)]=(('n')*1.)set NKv[(GIv)]=((.25)*1.)set Ncv[(GIv)]=(($578)*1.)set Nbv[(GIv)]=(($578)*1.)set NGv[(GIv)]=(($D)*1.)
set Adv[(GIv)]=(gmv)
set AGv[(GIv)]=((600)*1.)set Ahv[((GIv))]=((1.*1./((1.8)*1.))*1.)
set AWv[(GIv)]=((.3)*1.)
set Dnv[(GIv)]=(($4B0)*1.)set Auv[(GIv)]=((7)*1.)set AUv[(GIv)]=((7)*1.)set AYv[(GIv)]=(3)set A_v[(GIv)]=(2)set A2v[(GIv)]=(1)set ATv[(GIv)]=((55.111111111111)*1.)set Nnv[(GIv)]=($F)set Niv[(GIv)]=($F)return trueendfunctionfunction h7o takes integer oSx,integer otx,boolean oux returns nothingcall SaveBoolean(o[((V[(E[((Jw[(oSx)]))])]))],((((kw[((oSx))])))),(((otx))),(((oux))))endfunctionfunction h8o takes integer oSx,integer otx returns booleanlocal boolean aCx=dmo(oSx,otx)call h7o(oSx,otx,not false)return(aCx==false)endfunctionfunction h9o takes nothing returns booleanset GAv=hjo('uCat')call hJo(((GAv)),ASv,(Idv))set Uj[(GAv)]=((1)*1.)set NOv[(GAv)]=((60)*1.)
set NWv[(GAv)]=((60)*1.)
set NPv[(GAv)]=(('n')*1.)set I8v[(GAv)]=((2)*1.)set Anv[(GAv)]=(2)set Nmv[(GAv)]=((300)*1.)set NLv[(GAv)]=((300)*1.)set NKv[(GAv)]=((0)*1.)set Ncv[(GAv)]=(($578)*1.)set Nbv[(GAv)]=(($578)*1.)set NGv[(GAv)]=((50)*1.)
set Adv[(GAv)]=(ADv)
set AGv[(GAv)]=(($564)*1.)set Ahv[((GAv))]=((1.*1./((4.5)*1.))*1.)
set AWv[(GAv)]=((.1)*1.)
set Dnv[(GAv)]=((900)*1.)call hyo(GAv,40,1)call hyo(GAv,75,.4)call hyo(GAv,'n',.2)
call h8o(((GAv)),dDv+(0))set Auv[(GAv)]=((20)*1.)
set AUv[(GAv)]=((20)*1.)
set AYv[(GAv)]=(1)set A_v[(GAv)]=($F)set A2v[(GAv)]=(2)set ATv[(GAv)]=((48)*1.)
set Nnv[(GAv)]=(25)set Niv[(GAv)]=(50)return trueendfunctionfunction Hvo takes nothing returns booleanset GNv=hjo('UTrL')call hpo((GNv),('AInv'),1)call hJo(((GNv)),ASv,(Wd))call hJo(((GNv)),ASv,(Idv))set Uj[(GNv)]=((1.25)*1.)set NOv[(GNv)]=((38.4)*1.)set NWv[(GNv)]=((38.4)*1.)set NPv[(GNv)]=(($B4)*1.)set I8v[(GNv)]=((7)*1.)set Anv[(GNv)]=(4)set Nmv[(GNv)]=(($9C4)*1.)set NLv[(GNv)]=(($9C4)*1.)set NKv[(GNv)]=((1)*1.)set Npv[(GNv)]=(($C8)*1.)set NMv[(GNv)]=(($C8)*1.)set Nlv[(GNv)]=((.5)*1.)
set Ncv[(GNv)]=(($708)*1.)set Nbv[(GNv)]=(($708)*1.)set NGv[(GNv)]=(('x')*1.)set Adv[(GNv)]=(gkv)
set AGv[(GNv)]=(('x')*1.)set Ahv[((GNv))]=((1.*1./((2.2)*1.))*1.)
set AWv[(GNv)]=((.433)*1.)set Auv[(GNv)]=((30)*1.)
set AUv[(GNv)]=((30)*1.)
set AYv[(GNv)]=(2)set A_v[(GNv)]=(6)set A2v[(GNv)]=(5)set ATv[(GNv)]=((20.48)*1.)set Nnv[(GNv)]=('d')
set Niv[(GNv)]=($C8)
call hpo((GNv),(Gbv),1)call hpo((GNv),(GBv),1)return trueendfunctionfunction Heo takes nothing returns booleanset Gcv=hjo('uDem')call hJo(((Gcv)),ASv,(Idv))set Uj[(Gcv)]=((1)*1.)set NOv[(Gcv)]=((26.666666666667)*1.)set NWv[(Gcv)]=((26.666666666667)*1.)set NPv[(Gcv)]=(($87)*1.)set I8v[(Gcv)]=(($A)*1.)
set Anv[(Gcv)]=(3)set Nmv[(Gcv)]=((300)*1.)set NLv[(Gcv)]=((300)*1.)set NKv[(Gcv)]=((0)*1.)set Ncv[(Gcv)]=(($578)*1.)set Nbv[(Gcv)]=(($578)*1.)set NGv[(Gcv)]=((75)*1.)
set Adv[(Gcv)]=(ADv)
set AGv[(Gcv)]=(($6CC)*1.)set Ahv[((Gcv))]=((1.*1./((4.5)*1.))*1.)
set AWv[(Gcv)]=((.1)*1.)
set Dnv[(Gcv)]=((900)*1.)call hyo(Gcv,80,1)call hyo(Gcv,$96,.4)
call hyo(Gcv,$DC,.2)
call h8o(((Gcv)),dDv+(0))set Auv[(Gcv)]=((70)*1.)
set AUv[(Gcv)]=((70)*1.)
set AYv[(Gcv)]=(1)set A_v[(Gcv)]=(30)set A2v[(Gcv)]=(2)set ATv[(Gcv)]=((32)*1.)
set Nnv[(Gcv)]=(50)set Niv[(Gcv)]=($96)
call hpo((Gcv),(gtv),1)return trueendfunctionfunction Hxo takes nothing returns booleanset GCv=hjo('USmo')call hpo((GCv),('AInv'),1)call hJo(((GCv)),ASv,(Wd))call hJo(((GCv)),ASv,(Idv))set Uj[(GCv)]=((1.3)*1.)
set NOv[(GCv)]=(('d')*1.)set NWv[(GCv)]=((76)*1.)
set NPv[(GCv)]=((360)*1.)set I8v[(GCv)]=((3)*1.)set Anv[(GCv)]=(4)set Nmv[(GCv)]=(('d')*1.)set NLv[(GCv)]=(('d')*1.)set NKv[(GCv)]=((0)*1.)set Npv[(GCv)]=(('d')*1.)set NMv[(GCv)]=(('d')*1.)set Nlv[(GCv)]=((0)*1.)set Ncv[(GCv)]=(($708)*1.)set Nbv[(GCv)]=(($708)*1.)set Adv[(GCv)]=(gkv)
set AGv[(GCv)]=(('x')*1.)set Ahv[((GCv))]=((1.*1./((1.4)*1.))*1.)
set AWv[(GCv)]=((.56)*1.)set Auv[(GCv)]=(($D)*1.)
set AUv[(GCv)]=(($D)*1.)
set AYv[(GCv)]=(4)set A_v[(GCv)]=(4)set A2v[(GCv)]=(0)set ATv[(GCv)]=((32)*1.)
call hqo(GCv,Gdv)call hqo(GCv,GDv)call hqo(GCv,Gfv)call hqo(GCv,GFv)set bDv[(GCv)]=((13.5)*1.)set bjv[(GCv)]=((4.65)*1.)set bJv[(GCv)]=((1)*1.)set bfv[(GCv)]=((7.5)*1.)set bkv[(GCv)]=((3.5)*1.)set bFv[(GCv)]=(($A)*1.)
set bKv[(GCv)]=((3.85)*1.)return trueendfunctionfunction Hoo takes nothing returns booleanset Ggv=hjo('uKoR')call hJo(((Ggv)),ASv,(Idv))set Uj[(Ggv)]=((1.25)*1.)call hko(Ggv,$FF,$96,$B4,$FF)set NOv[(Ggv)]=((38.4)*1.)set NWv[(Ggv)]=((38.4)*1.)set NPv[(Ggv)]=((270)*1.)set I8v[(Ggv)]=((1)*1.)set Anv[(Ggv)]=(2)set Nmv[(Ggv)]=(($8C)*1.)set NLv[(Ggv)]=(($8C)*1.)set NKv[(Ggv)]=((.2)*1.)
set Ncv[(Ggv)]=(($578)*1.)set Nbv[(Ggv)]=(($578)*1.)set NGv[(Ggv)]=(($C)*1.)
set Adv[(Ggv)]=(gkv)
set AGv[(Ggv)]=(('x')*1.)set Ahv[((Ggv))]=((1.*1./((1.4)*1.))*1.)
set AWv[(Ggv)]=((.38)*1.)set Auv[(Ggv)]=((7)*1.)set AUv[(Ggv)]=((7)*1.)set AYv[(Ggv)]=(1)set A_v[(Ggv)]=(3)set A2v[(Ggv)]=(0)set ATv[(Ggv)]=((19.84)*1.)set Nnv[(Ggv)]=(20)set Niv[(Ggv)]=($F)return trueendfunctionfunction Hro takes nothing returns booleanset GGv=hjo('uTow')call hJo(((GGv)),ASv,(Igv))set Uj[(GGv)]=((2.25)*1.)set NOv[(GGv)]=((60)*1.)
set NWv[(GGv)]=((60)*1.)
set I8v[(GGv)]=((0)*1.)set Anv[(GGv)]=(3)set Nmv[(GGv)]=((150000.)*1.)set NLv[(GGv)]=((150000.)*1.)set NKv[(GGv)]=((0)*1.)set Ncv[(GGv)]=(($578)*1.)set Nbv[(GGv)]=(($578)*1.)set Adv[(GGv)]=(ADv)
set AGv[(GGv)]=(($960)*1.)set Ahv[((GGv))]=((1.*1./((2.5)*1.))*1.)
set AWv[(GGv)]=((.3)*1.)
set Dnv[(GGv)]=((900)*1.)call hyo(GGv,80,1)call hyo(GGv,$96,.4)
call hyo(GGv,$DC,.2)
set Auv[(GGv)]=(($A)*1.)
set AUv[(GGv)]=(($A)*1.)
set AYv[(GGv)]=(5)set A_v[(GGv)]=(3)set A2v[(GGv)]=(2)call hpo((GGv),(gtv),1)return trueendfunctionfunction Hio takes nothing returns booleanset Ghv=hjo('uPan')call hJo(((Ghv)),ASv,(Idv))set Uj[(Ghv)]=((1)*1.)call hko(Ghv,$FF,$FF,$FF,$FF)set NOv[(Ghv)]=(('d')*1.)set NWv[(Ghv)]=((60)*1.)
set NPv[(Ghv)]=((300)*1.)set I8v[(Ghv)]=((2)*1.)set Anv[(Ghv)]=(2)set Nmv[(Ghv)]=(($C8)*1.)set NLv[(Ghv)]=(($C8)*1.)set NKv[(Ghv)]=((.4)*1.)
set Ncv[(Ghv)]=(($578)*1.)set Nbv[(Ghv)]=(($578)*1.)set NGv[(Ghv)]=(($E)*1.)
set Adv[(Ghv)]=(gkv)
set AGv[(Ghv)]=(('x')*1.)set Ahv[((Ghv))]=((1.*1./((1.6)*1.))*1.)
set AWv[(Ghv)]=((.3)*1.)
set Auv[(Ghv)]=(($C)*1.)
set AUv[(Ghv)]=(($C)*1.)
set AYv[(Ghv)]=(2)set A_v[(Ghv)]=(3)set A2v[(Ghv)]=(0)set ATv[(Ghv)]=((48)*1.)
set Nnv[(Ghv)]=(25)set Niv[(Ghv)]=(30)return trueendfunctionfunction Hao takes nothing returns booleanset GHv=hjo('UJot')call hpo((GHv),('AInv'),1)call hJo(((GHv)),ASv,(Wd))call hJo(((GHv)),ASv,(Idv))set Uj[(GHv)]=((1.3)*1.)
set NOv[(GHv)]=((60)*1.)
set NWv[(GHv)]=((66)*1.)
set NPv[(GHv)]=((280)*1.)set I8v[(GHv)]=((0)*1.)set Anv[(GHv)]=(4)set Nmv[(GHv)]=(('d')*1.)set NLv[(GHv)]=(('d')*1.)set NKv[(GHv)]=((0)*1.)set Npv[(GHv)]=(('d')*1.)set NMv[(GHv)]=(('d')*1.)set Nlv[(GHv)]=((0)*1.)set Ncv[(GHv)]=(($708)*1.)set Nbv[(GHv)]=(($708)*1.)set Adv[(GHv)]=(guv)
set AGv[(GHv)]=((720)*1.)set Ahv[((GHv))]=((1.*1./((2)*1.))*1.)set AWv[(GHv)]=((.55)*1.)set Dnv[(GHv)]=((900)*1.)set Auv[(GHv)]=(($D)*1.)
set AUv[(GHv)]=(($D)*1.)
set AYv[(GHv)]=(2)set A_v[(GHv)]=(4)set A2v[(GHv)]=(3)set ATv[(GHv)]=((32)*1.)
call hqo(GHv,Gjv)call hqo(GHv,GJv)call hqo(GHv,Gkv)call hqo(GHv,GKv)set bDv[(GHv)]=((6)*1.)set bjv[(GHv)]=((2.5)*1.)set bJv[(GHv)]=((.8)*1.)
set bfv[(GHv)]=((16)*1.)
set bkv[(GHv)]=((4.5)*1.)set bFv[(GHv)]=((9)*1.)set bKv[(GHv)]=((3.5)*1.)return trueendfunctionfunction Hno takes nothing returns booleanset Glv=hjo('uTar')call hJo(((Glv)),ASv,(Idv))set Uj[(Glv)]=((1.35)*1.)call hko(Glv,$FF,$FF,$FF,$BE)set NOv[(Glv)]=((60)*1.)
set NWv[(Glv)]=((60)*1.)
set NPv[(Glv)]=(($87)*1.)set I8v[(Glv)]=((0)*1.)set Anv[(Glv)]=(1)set Nmv[(Glv)]=((825)*1.)set NLv[(Glv)]=((825)*1.)set NKv[(Glv)]=((.55)*1.)set Ncv[(Glv)]=(($578)*1.)set Nbv[(Glv)]=(($578)*1.)set NGv[(Glv)]=((85)*1.)
set Adv[(Glv)]=(guv)
set AGv[(Glv)]=((720)*1.)set Ahv[((Glv))]=((1.*1./((1.75)*1.))*1.)set AWv[(Glv)]=((.43)*1.)set Dnv[(Glv)]=(($4B0)*1.)set Auv[(Glv)]=(($A)*1.)
set AUv[(Glv)]=(($A)*1.)
set AYv[(Glv)]=(2)set A_v[(Glv)]=(3)set A2v[(Glv)]=(4)set ATv[(Glv)]=((31)*1.)
set Nnv[(Glv)]=(60)set Niv[(Glv)]=('x')
call hpo((Glv),(GLv),1)call hpo((Glv),(Gmv),1)return trueendfunctionfunction HVo takes nothing returns booleanset GMv=hjo('uPen')call hJo(((GMv)),ASv,(Idv))set Uj[(GMv)]=((1.5)*1.)
set NOv[(GMv)]=((60)*1.)
set NWv[(GMv)]=((60)*1.)
set I8v[(GMv)]=((0)*1.)set Anv[(GMv)]=(5)set Nmv[(GMv)]=(('d')*1.)set NLv[(GMv)]=(('d')*1.)set NKv[(GMv)]=((0)*1.)set Ncv[(GMv)]=((350)*1.)set Nbv[(GMv)]=((350)*1.)set Auv[(GMv)]=((0)*1.)set AUv[(GMv)]=((0)*1.)set AYv[(GMv)]=(0)set A_v[(GMv)]=(0)set ATv[(GMv)]=((8)*1.)return trueendfunctionfunction HEo takes nothing returns booleanset Gpv=hjo('uLTw')call hJo(((Gpv)),ASv,(Igv))set Uj[(Gpv)]=((1.5)*1.)
call hko(Gpv,$C8,$C8,$C0,$FF)set NOv[(Gpv)]=(('x')*1.)set NWv[(Gpv)]=(($FF)*1.)set I8v[(Gpv)]=((0)*1.)set Anv[(Gpv)]=(3)set Nmv[(Gpv)]=((150000.)*1.)set NLv[(Gpv)]=((150000.)*1.)set NKv[(Gpv)]=((0)*1.)set Ncv[(Gpv)]=(($578)*1.)set Nbv[(Gpv)]=(($578)*1.)set Adv[(Gpv)]=(guv)
set AGv[(Gpv)]=(($4B0)*1.)set Ahv[((Gpv))]=((1.*1./((6)*1.))*1.)set AWv[(Gpv)]=((.5)*1.)
set Dnv[(Gpv)]=(($5DC)*1.)set Auv[(Gpv)]=((1)*1.)set AUv[(Gpv)]=((1)*1.)set AYv[(Gpv)]=(1)set A_v[(Gpv)]=(1)set A2v[(Gpv)]=(3)call hpo((Gpv),(gtv),1)call hpo((Gpv),(GPv),1)return trueendfunctionfunction HXo takes nothing returns booleanset Gqv=hjo('uNag')call hJo(((Gqv)),ASv,(Idv))set Uj[(Gqv)]=((1)*1.)call hko(Gqv,$FF,$FF,$FF,$BE)set NOv[(Gqv)]=((60)*1.)
set NWv[(Gqv)]=((60)*1.)
set NPv[(Gqv)]=(($96)*1.)set I8v[(Gqv)]=((0)*1.)set Anv[(Gqv)]=(0)set Nmv[(Gqv)]=((825)*1.)set NLv[(Gqv)]=((825)*1.)set NKv[(Gqv)]=((.55)*1.)set Npv[(Gqv)]=((400)*1.)set NMv[(Gqv)]=((400)*1.)set Nlv[(Gqv)]=((.5)*1.)
set Ncv[(Gqv)]=(($578)*1.)set Nbv[(Gqv)]=(($578)*1.)set NGv[(Gqv)]=((70)*1.)
set Adv[(Gqv)]=(gkv)
set AGv[(Gqv)]=(('x')*1.)set Ahv[((Gqv))]=((1.*1./((2.28)*1.))*1.)set AWv[(Gqv)]=((.5)*1.)
set Auv[(Gqv)]=(($A)*1.)
set AUv[(Gqv)]=(($A)*1.)
set AYv[(Gqv)]=(2)set A_v[(Gqv)]=(3)set A2v[(Gqv)]=(3)set ATv[(Gqv)]=((32)*1.)
set Nnv[(Gqv)]=(50)set Niv[(Gqv)]=('d')
call hpo((Gqv),(GQv),1)call hpo((Gqv),(Gsv),1)return trueendfunctionfunction HOo takes nothing returns booleanset GSv=hjo('uBal')call hJo(((GSv)),ASv,(Idv))set Uj[(GSv)]=((1.75)*1.)set NOv[(GSv)]=((29.387755102041)*1.)set NWv[(GSv)]=((19.591836734694)*1.)set NPv[(GSv)]=(($87)*1.)set I8v[(GSv)]=(($C)*1.)
set Anv[(GSv)]=(4)set Nmv[(GSv)]=(($514)*1.)set NLv[(GSv)]=(($514)*1.)set NKv[(GSv)]=((1)*1.)set Ncv[(GSv)]=(($708)*1.)set Nbv[(GSv)]=(($708)*1.)set NGv[(GSv)]=((70)*1.)
set Adv[(GSv)]=(gkv)
set AGv[(GSv)]=(($CC)*1.)set Ahv[((GSv))]=((1.*1./((2.2)*1.))*1.)
set AWv[(GSv)]=((.33)*1.)set Auv[(GSv)]=((40)*1.)
set AUv[(GSv)]=((40)*1.)
set AYv[(GSv)]=(2)set A_v[(GSv)]=(6)set A2v[(GSv)]=(0)set ATv[(GSv)]=((27.428571428571)*1.)set Nnv[(GSv)]=('x')
set Niv[(GSv)]=($FA)
call hpo((GSv),(Gtv),1)call hpo((GSv),(GTv),1)return trueendfunctionfunction HRo takes nothing returns booleanset Guv=hjo('uFou')call hJo(((Guv)),ASv,(Igv))set Uj[(Guv)]=((1.5)*1.)
set NOv[(Guv)]=(('x')*1.)set NWv[(Guv)]=((60)*1.)
set I8v[(Guv)]=((0)*1.)set Anv[(Guv)]=(3)set Nmv[(Guv)]=((150000.)*1.)set NLv[(Guv)]=((150000.)*1.)set NKv[(Guv)]=((0)*1.)set Ncv[(Guv)]=((900)*1.)set Nbv[(Guv)]=((900)*1.)set Auv[(Guv)]=((0)*1.)set AUv[(Guv)]=((0)*1.)set AYv[(Guv)]=(0)set A_v[(Guv)]=(0)call hpo((Guv),(gtv),1)call hpo((Guv),(GUv),1)return trueendfunctionfunction HIo takes nothing returns booleanset Gwv=hjo('UAru')call hpo((Gwv),('AInv'),1)call hJo(((Gwv)),ASv,(Wd))call hJo(((Gwv)),ASv,(Idv))set Uj[(Gwv)]=((1.3)*1.)
set NOv[(Gwv)]=((60)*1.)
set NWv[(Gwv)]=(('d')*1.)set NPv[(Gwv)]=((320)*1.)set I8v[(Gwv)]=((2)*1.)set Anv[(Gwv)]=(4)set Nmv[(Gwv)]=(('d')*1.)set NLv[(Gwv)]=(('d')*1.)set NKv[(Gwv)]=((0)*1.)set Npv[(Gwv)]=(('d')*1.)set NMv[(Gwv)]=(('d')*1.)set Nlv[(Gwv)]=((0)*1.)set Ncv[(Gwv)]=(($708)*1.)set Nbv[(Gwv)]=(($708)*1.)set Adv[(Gwv)]=(gmv)
set AGv[(Gwv)]=((720)*1.)set Ahv[((Gwv))]=((1.*1./((1.55)*1.))*1.)set AWv[(Gwv)]=((.3)*1.)
set Dnv[(Gwv)]=((900)*1.)set Auv[(Gwv)]=(($C)*1.)
set AUv[(Gwv)]=(($C)*1.)
set AYv[(Gwv)]=(3)set A_v[(Gwv)]=(3)set A2v[(Gwv)]=(1)set ATv[(Gwv)]=((32)*1.)
call hqo(Gwv,GWv)call hqo(Gwv,Gyv)call hqo(Gwv,GYv)call hqo(Gwv,Gzv)set bDv[(Gwv)]=(($C)*1.)
set bjv[(Gwv)]=((3.75)*1.)set bJv[(Gwv)]=((.75)*1.)set bfv[(Gwv)]=(($B)*1.)
set bkv[(Gwv)]=((4)*1.)set bFv[(Gwv)]=((8.5)*1.)set bKv[(Gwv)]=((3.5)*1.)return trueendfunctionfunction HAo takes nothing returns booleanset GZv=hjo('UFuO')call hpo((GZv),('AInv'),1)call hJo(((GZv)),ASv,(Wd))call hJo(((GZv)),ASv,(Idv))set Uj[(GZv)]=((3.6)*1.)
set NOv[(GZv)]=((60)*1.)
set NWv[(GZv)]=((60)*1.)
set NPv[(GZv)]=(($B4)*1.)set I8v[(GZv)]=((4)*1.)set Anv[(GZv)]=(4)set Nmv[(GZv)]=((6500)*1.)set NLv[(GZv)]=((6500)*1.)set NKv[(GZv)]=((3)*1.)set Npv[(GZv)]=(($5DC)*1.)set NMv[(GZv)]=(($5DC)*1.)set Nlv[(GZv)]=((5)*1.)set Ncv[(GZv)]=(($708)*1.)set Nbv[(GZv)]=(($708)*1.)set NGv[(GZv)]=(('d')*1.)set Adv[(GZv)]=(gkv)
set AGv[(GZv)]=(('x')*1.)set Ahv[((GZv))]=((1.*1./((3)*1.))*1.)set AWv[(GZv)]=((.35)*1.)set Auv[(GZv)]=((44)*1.)
set AUv[(GZv)]=((44)*1.)
set AYv[(GZv)]=(1)set A_v[(GZv)]=(20)set A2v[(GZv)]=(5)set ATv[(GZv)]=((32)*1.)
set Nnv[(GZv)]=(50)set Niv[(GZv)]=(50)call hpo((GZv),(G_v),1)call hpo((GZv),(G0v),1)call hpo((GZv),(G1v),1)return trueendfunctionfunction HNo takes nothing returns booleanset G2v=hjo('uDTw')call hJo(((G2v)),ASv,(Igv))set Uj[(G2v)]=((2)*1.)set NOv[(G2v)]=(('x')*1.)set NWv[(G2v)]=(($B4)*1.)set I8v[(G2v)]=((0)*1.)set Anv[(G2v)]=(3)set Nmv[(G2v)]=((150000.)*1.)set NLv[(G2v)]=((150000.)*1.)set NKv[(G2v)]=((0)*1.)set Ncv[(G2v)]=(($578)*1.)set Nbv[(G2v)]=(($578)*1.)set Adv[(G2v)]=(guv)
set AGv[(G2v)]=(($4B0)*1.)set Ahv[((G2v))]=((1.*1./((1.75)*1.))*1.)set AWv[(G2v)]=((.5)*1.)
set Dnv[(G2v)]=(($3E8)*1.)set Auv[(G2v)]=((23)*1.)
set AUv[(G2v)]=((23)*1.)
set AYv[(G2v)]=(3)set A_v[(G2v)]=(3)set A2v[(G2v)]=(4)call hpo((G2v),(gtv),1)call hpo((G2v),(gyv),1)return trueendfunctionfunction Hbo takes nothing returns booleanset G3v=hjo('uAxe')call hJo(((G3v)),ASv,(Idv))set Uj[(G3v)]=((1.2)*1.)
set NOv[(G3v)]=((41.666666666667)*1.)set NWv[(G3v)]=((41.666666666667)*1.)set NPv[(G3v)]=(('}')*1.)set I8v[(G3v)]=((2)*1.)set Anv[(G3v)]=(2)set Nmv[(G3v)]=((400)*1.)set NLv[(G3v)]=((400)*1.)set NKv[(G3v)]=((.4)*1.)
set Ncv[(G3v)]=(($578)*1.)set Nbv[(G3v)]=(($578)*1.)set NGv[(G3v)]=((40)*1.)
set Adv[(G3v)]=(gkv)
set AGv[(G3v)]=(('x')*1.)set Ahv[((G3v))]=((1.*1./((1.6)*1.))*1.)
set AWv[(G3v)]=((.35)*1.)set Auv[(G3v)]=((16)*1.)
set AUv[(G3v)]=((16)*1.)
set AYv[(G3v)]=(3)set A_v[(G3v)]=(3)set A2v[(G3v)]=(0)set ATv[(G3v)]=((22.222222222222)*1.)set Nnv[(G3v)]=(20)set Niv[(G3v)]=(90)return trueendfunctionfunction HBo takes nothing returns booleanset G4v=hjo('USto')call hpo((G4v),('AInv'),1)call hJo(((G4v)),ASv,(Wd))call hJo(((G4v)),ASv,(Idv))set Uj[(G4v)]=((1.3)*1.)
set NOv[(G4v)]=((60)*1.)
set NWv[(G4v)]=((60)*1.)
set NPv[(G4v)]=((290)*1.)set I8v[(G4v)]=((1.5)*1.)set Anv[(G4v)]=(4)set Nmv[(G4v)]=(('d')*1.)set NLv[(G4v)]=(('d')*1.)set NKv[(G4v)]=((0)*1.)set Npv[(G4v)]=(('d')*1.)set NMv[(G4v)]=(('d')*1.)set Nlv[(G4v)]=((0)*1.)set Ncv[(G4v)]=(($708)*1.)set Nbv[(G4v)]=(($708)*1.)set Adv[(G4v)]=(gkv)
set AGv[(G4v)]=(('x')*1.)set Ahv[((G4v))]=((1.*1./((1.7)*1.))*1.)
set AWv[(G4v)]=((.35)*1.)set Auv[(G4v)]=(($C)*1.)
set AUv[(G4v)]=(($C)*1.)
set AYv[(G4v)]=(1)set A_v[(G4v)]=($A)set A2v[(G4v)]=(0)set ATv[(G4v)]=((32)*1.)
call hqo(G4v,G5v)call hqo(G4v,G6v)call hqo(G4v,G7v)call hqo(G4v,G8v)set bDv[(G4v)]=(($A)*1.)
set bjv[(G4v)]=((3.75)*1.)set bJv[(G4v)]=((.7)*1.)
set bfv[(G4v)]=(($A)*1.)
set bkv[(G4v)]=((3.75)*1.)set bFv[(G4v)]=((10.5)*1.)set bKv[(G4v)]=((3.75)*1.)return trueendfunctionfunction Hco takes nothing returns booleanset G9v=hjo('uBDS')call hJo(((G9v)),ASv,(Iav))set Uj[(G9v)]=((.7)*1.)call hko(G9v,$96,$96,$FF,$FF)set NOv[(G9v)]=((0)*1.)set NWv[(G9v)]=((-20.408163265306)*1.)set NPv[(G9v)]=((300)*1.)set I8v[(G9v)]=((0)*1.)set Anv[(G9v)]=(2)set Nmv[(G9v)]=((300)*1.)set NLv[(G9v)]=((300)*1.)set NKv[(G9v)]=((.2)*1.)
set Ncv[(G9v)]=(($578)*1.)set Nbv[(G9v)]=(($578)*1.)set NGv[(G9v)]=((25)*1.)
set Adv[(G9v)]=(guv)
set AGv[(G9v)]=((720)*1.)set Ahv[((G9v))]=((1.*1./((1.8)*1.))*1.)
set AWv[(G9v)]=((.94)*1.)set Dnv[(G9v)]=((800)*1.)set Auv[(G9v)]=(($C)*1.)
set AUv[(G9v)]=(($C)*1.)
set AYv[(G9v)]=(1)set A_v[(G9v)]=(2)set A2v[(G9v)]=(1)set ATv[(G9v)]=((97.959183673469)*1.)set Nnv[(G9v)]=($E)set Niv[(G9v)]=(35)return trueendfunctionfunction HCo takes nothing returns booleanset hvv=hjo('uKoB')call hJo(((hvv)),ASv,(Idv))set Uj[(hvv)]=((1.4)*1.)
call hko(hvv,$FF,$FF,$FF,$FF)set NOv[(hvv)]=((30.612244897959)*1.)set NWv[(hvv)]=((30.612244897959)*1.)set NPv[(hvv)]=((270)*1.)set I8v[(hvv)]=((0)*1.)set Anv[(hvv)]=(5)set Nmv[(hvv)]=((90)*1.)
set NLv[(hvv)]=((90)*1.)
set NKv[(hvv)]=((.2)*1.)
set Npv[(hvv)]=((50)*1.)
set NMv[(hvv)]=((50)*1.)
set Nlv[(hvv)]=((.4)*1.)
set Ncv[(hvv)]=(($578)*1.)set Nbv[(hvv)]=(($578)*1.)set NGv[(hvv)]=((25)*1.)
set Adv[(hvv)]=(guv)
set AGv[(hvv)]=((720)*1.)set Ahv[((hvv))]=((1.*1./((1.8)*1.))*1.)
set AWv[(hvv)]=((.38)*1.)set Dnv[(hvv)]=((900)*1.)set Auv[(hvv)]=((4)*1.)set AUv[(hvv)]=((4)*1.)set AYv[(hvv)]=(2)set A_v[(hvv)]=(2)set A2v[(hvv)]=(3)set ATv[(hvv)]=((15.816326530612)*1.)set Nnv[(hvv)]=($F)set Niv[(hvv)]=($A)return trueendfunctionfunction Hdo takes nothing returns booleanset hev=hjo('uPeB')call hJo(((hev)),ASv,(Idv))set Uj[(hev)]=((1.725)*1.)set NOv[(hev)]=((60)*1.)
set NWv[(hev)]=((60)*1.)
set NPv[(hev)]=((340)*1.)set I8v[(hev)]=((0)*1.)set Anv[(hev)]=(2)set Nmv[(hev)]=((55)*1.)
set NLv[(hev)]=((55)*1.)
set NKv[(hev)]=((.2)*1.)
set Ncv[(hev)]=((350)*1.)set Nbv[(hev)]=((350)*1.)set NGv[(hev)]=(($A)*1.)
set Adv[(hev)]=(gkv)
set AGv[(hev)]=(('x')*1.)set Ahv[((hev))]=((1.*1./((1.5)*1.))*1.)
set AWv[(hev)]=((1)*1.)set Auv[(hev)]=((5)*1.)set AUv[(hev)]=((5)*1.)set AYv[(hev)]=(1)set A_v[(hev)]=(1)set A2v[(hev)]=(4)set ATv[(hev)]=((16)*1.)
return trueendfunctionfunction HDo takes nothing returns booleanset hxv=hjo('uRes')call hJo(((hxv)),ASv,(Igv))set Uj[(hxv)]=((1.1)*1.)
call hko(hxv,$96,$C8,$FF,$FF)set NOv[(hxv)]=(('x')*1.)set NWv[(hxv)]=((60)*1.)
set I8v[(hxv)]=((0)*1.)set Anv[(hxv)]=(3)set Nmv[(hxv)]=((150000.)*1.)set NLv[(hxv)]=((150000.)*1.)set NKv[(hxv)]=((0)*1.)set Npv[(hxv)]=(($C8)*1.)set NMv[(hxv)]=(($C8)*1.)set Nlv[(hxv)]=((.4)*1.)
set Ncv[(hxv)]=((300)*1.)set Nbv[(hxv)]=((300)*1.)set Auv[(hxv)]=((0)*1.)set AUv[(hxv)]=((0)*1.)set AYv[(hxv)]=(0)set A_v[(hxv)]=(0)call hpo((hxv),(gtv),1)call hpo((hxv),(hov),1)return trueendfunctionfunction Hfo takes nothing returns booleanset hrv=hjo('uLT2')call hJo(((hrv)),ASv,(Igv))set Uj[(hrv)]=((1.6)*1.)
call hko(hrv,$C8,$C8,$C0,$FF)set NOv[(hrv)]=(('x')*1.)set NWv[(hrv)]=(($FF)*1.)set I8v[(hrv)]=((0)*1.)set Anv[(hrv)]=(3)set Nmv[(hrv)]=((150000.)*1.)set NLv[(hrv)]=((150000.)*1.)set NKv[(hrv)]=((0)*1.)set Ncv[(hrv)]=(($578)*1.)set Nbv[(hrv)]=(($578)*1.)set Adv[(hrv)]=(guv)
set AGv[(hrv)]=(($4B0)*1.)set Ahv[((hrv))]=((1.*1./((5)*1.))*1.)set AWv[(hrv)]=((.5)*1.)
set Dnv[(hrv)]=(($5DC)*1.)set Auv[(hrv)]=((1)*1.)set AUv[(hrv)]=((1)*1.)set AYv[(hrv)]=(1)set A_v[(hrv)]=(1)set A2v[(hrv)]=(3)call hpo((hrv),(gtv),1)call hpo((hrv),(GPv),(2))return trueendfunctionfunction HFo takes nothing returns booleanset hiv=hjo('uDee')call hJo(((hiv)),ASv,(Idv))set Uj[(hiv)]=((1.7)*1.)
set NOv[(hiv)]=((15.555555555556)*1.)set NWv[(hiv)]=((15.555555555556)*1.)set NPv[(hiv)]=(($96)*1.)set I8v[(hiv)]=((0)*1.)set Anv[(hiv)]=(1)set Nmv[(hiv)]=((60)*1.)
set NLv[(hiv)]=((60)*1.)
set NKv[(hiv)]=((.1)*1.)
set Npv[(hiv)]=((25)*1.)
set NMv[(hiv)]=((25)*1.)
set Nlv[(hiv)]=((.3)*1.)
set Ncv[(hiv)]=(($578)*1.)set Nbv[(hiv)]=(($578)*1.)set NGv[(hiv)]=(($A)*1.)
set Adv[(hiv)]=(gkv)
set AGv[(hiv)]=(('l')*1.)set Ahv[((hiv))]=((1.*1./((1.4)*1.))*1.)
set AWv[(hiv)]=((.5)*1.)
set Auv[(hiv)]=((5)*1.)set AUv[(hiv)]=((5)*1.)set AYv[(hiv)]=(1)set A_v[(hiv)]=(2)set A2v[(hiv)]=(0)set ATv[(hiv)]=((10.666666666667)*1.)set Nnv[(hiv)]=(5)set Niv[(hiv)]=(20)return trueendfunctionfunction Hgo takes nothing returns booleanset hav=hjo('uSnF')call hJo(((hav)),ASv,(Iav))set Uj[(hav)]=((.9)*1.)set NOv[(hav)]=((60)*1.)
set NWv[(hav)]=((60)*1.)
set NPv[(hav)]=(($87)*1.)set I8v[(hav)]=((0)*1.)set Anv[(hav)]=(0)set Nmv[(hav)]=(('n')*1.)set NLv[(hav)]=(('n')*1.)set NKv[(hav)]=((.3)*1.)
set Npv[(hav)]=((30)*1.)
set NMv[(hav)]=((30)*1.)
set Nlv[(hav)]=((.1)*1.)
set Ncv[(hav)]=(($640)*1.)set Nbv[(hav)]=(($640)*1.)set NGv[(hav)]=((20)*1.)
set Adv[(hav)]=(gmv)
set AGv[(hav)]=((600)*1.)set Ahv[((hav))]=((1.*1./((1.5)*1.))*1.)
set AWv[(hav)]=((.5)*1.)
set Dnv[(hav)]=(($5DC)*1.)set Auv[(hav)]=((7)*1.)set AUv[(hav)]=((7)*1.)set AYv[(hav)]=(1)set A_v[(hav)]=(4)set A2v[(hav)]=(3)set ATv[(hav)]=((8)*1.)set Nnv[(hav)]=(25)set Niv[(hav)]=(50)call hpo((hav),(hnv),1)return trueendfunctionfunction HGo takes nothing returns booleanset hVv=hjo('uTrG')call hJo(((hVv)),ASv,(Idv))set Uj[(hVv)]=((1)*1.)call hko(hVv,$AA,$FF,60,$FF)
set NOv[(hVv)]=((38.4)*1.)set NWv[(hVv)]=((38.4)*1.)set NPv[(hVv)]=((280)*1.)set I8v[(hVv)]=((0)*1.)set Anv[(hVv)]=(2)set Nmv[(hVv)]=((600)*1.)set NLv[(hVv)]=((600)*1.)set NKv[(hVv)]=((.3)*1.)
set Ncv[(hVv)]=(($578)*1.)set Nbv[(hVv)]=(($578)*1.)set NGv[(hVv)]=((20)*1.)
set Adv[(hVv)]=(gkv)
set AGv[(hVv)]=(('x')*1.)set Ahv[((hVv))]=((1.*1./((1.35)*1.))*1.)set AWv[(hVv)]=((.467)*1.)set Auv[(hVv)]=((22)*1.)
set AUv[(hVv)]=((22)*1.)
set AYv[(hVv)]=(1)set A_v[(hVv)]=(4)set A2v[(hVv)]=(4)set ATv[(hVv)]=((20.48)*1.)set Nnv[(hVv)]=(20)set Niv[(hVv)]=(70)return trueendfunctionfunction Hho takes nothing returns booleanset hEv=hjo('uWol')call hJo(((hEv)),ASv,(Idv))set Uj[(hEv)]=((1)*1.)set NOv[(hEv)]=((60)*1.)
set NWv[(hEv)]=((60)*1.)
set NPv[(hEv)]=(('}')*1.)set I8v[(hEv)]=((2)*1.)set Anv[(hEv)]=(2)set Nmv[(hEv)]=(('x')*1.)set NLv[(hEv)]=(('x')*1.)set NKv[(hEv)]=((.4)*1.)
set Npv[(hEv)]=(('d')*1.)set NMv[(hEv)]=(('d')*1.)set Nlv[(hEv)]=((1)*1.)set Ncv[(hEv)]=(($578)*1.)set Nbv[(hEv)]=(($578)*1.)set NGv[(hEv)]=((22.5)*1.)set Adv[(hEv)]=(gkv)
set AGv[(hEv)]=(($84)*1.)set Ahv[((hEv))]=((1.*1./((1.35)*1.))*1.)set AWv[(hEv)]=((.33)*1.)set Auv[(hEv)]=((8)*1.)set AUv[(hEv)]=((8)*1.)set AYv[(hEv)]=(2)set A_v[(hEv)]=(3)set A2v[(hEv)]=(0)set ATv[(hEv)]=((32)*1.)
set Nnv[(hEv)]=(8)set Niv[(hEv)]=(40)call hpo((hEv),(hXv),1)return trueendfunctionfunction HHo takes nothing returns booleanset hOv=hjo('uDru')call hJo(((hOv)),ASv,(Idv))set Uj[(hOv)]=((1)*1.)set NOv[(hOv)]=((26.666666666667)*1.)set NWv[(hOv)]=((26.666666666667)*1.)set NPv[(hOv)]=(('n')*1.)set I8v[(hOv)]=((1)*1.)set Anv[(hOv)]=(3)set Nmv[(hOv)]=((300)*1.)set NLv[(hOv)]=((300)*1.)set NKv[(hOv)]=((2)*1.)set Ncv[(hOv)]=(($578)*1.)set Nbv[(hOv)]=(($578)*1.)set NGv[(hOv)]=((50)*1.)
set Adv[(hOv)]=(gmv)
set AGv[(hOv)]=((600)*1.)set Ahv[((hOv))]=((1.*1./((1.44)*1.))*1.)set AWv[(hOv)]=((.85)*1.)set Dnv[(hOv)]=(($4B0)*1.)set Auv[(hOv)]=((4)*1.)set AUv[(hOv)]=((4)*1.)set AYv[(hOv)]=(1)set A_v[(hOv)]=(3)set A2v[(hOv)]=(1)set ATv[(hOv)]=((21.333333333333)*1.)set Nnv[(hOv)]=(35)set Niv[(hOv)]=(80)call hpo((hOv),(hRv),1)return trueendfunctionfunction Hjo takes nothing returns booleanset hIv=hjo('ULea')call hpo((hIv),('AInv'),1)call hJo(((hIv)),ASv,(Wd))call hJo(((hIv)),ASv,(Idv))set Uj[(hIv)]=((1.25)*1.)set NOv[(hIv)]=((60)*1.)
set NWv[(hIv)]=((60)*1.)
set NPv[(hIv)]=(($96)*1.)set I8v[(hIv)]=((5)*1.)set Anv[(hIv)]=(4)set Nmv[(hIv)]=(($FA0)*1.)set NLv[(hIv)]=(($FA0)*1.)set NKv[(hIv)]=((1)*1.)set Npv[(hIv)]=(($C8)*1.)set NMv[(hIv)]=(($C8)*1.)set Nlv[(hIv)]=((.5)*1.)
set Ncv[(hIv)]=(($578)*1.)set Nbv[(hIv)]=(($578)*1.)set NGv[(hIv)]=((90)*1.)
set Adv[(hIv)]=(gkv)
set AGv[(hIv)]=(('x')*1.)set Ahv[((hIv))]=((1.*1./((1.5)*1.))*1.)
set AWv[(hIv)]=((.5)*1.)
set Auv[(hIv)]=((20)*1.)
set AUv[(hIv)]=((20)*1.)
set AYv[(hIv)]=(2)set A_v[(hIv)]=(8)set A2v[(hIv)]=(5)set ATv[(hIv)]=((32)*1.)
set Nnv[(hIv)]=('d')
set Niv[(hIv)]=($C8)
call hpo((hIv),(hAv),1)return trueendfunctionfunction HJo takes nothing returns booleanset hNv=hjo('URoc')call hpo((hNv),('AInv'),1)call hJo(((hNv)),ASv,(Wd))call hJo(((hNv)),ASv,(Idv))set Uj[(hNv)]=((1.4)*1.)
set NOv[(hNv)]=((60)*1.)
set NWv[(hNv)]=((60)*1.)
set NPv[(hNv)]=((280)*1.)set I8v[(hNv)]=((3)*1.)set Anv[(hNv)]=(4)set Nmv[(hNv)]=(('d')*1.)set NLv[(hNv)]=(('d')*1.)set NKv[(hNv)]=((0)*1.)set Npv[(hNv)]=(('d')*1.)set NMv[(hNv)]=(('d')*1.)set Nlv[(hNv)]=((0)*1.)set Ncv[(hNv)]=(($708)*1.)set Nbv[(hNv)]=(($708)*1.)set Adv[(hNv)]=(gkv)
set AGv[(hNv)]=(('x')*1.)set Ahv[((hNv))]=((1.*1./((1.55)*1.))*1.)set AWv[(hNv)]=((.35)*1.)set Auv[(hNv)]=(($C)*1.)
set AUv[(hNv)]=(($C)*1.)
set AYv[(hNv)]=(2)set A_v[(hNv)]=($C)set A2v[(hNv)]=(0)set ATv[(hNv)]=((32)*1.)
call hqo(hNv,hbv)call hqo(hNv,hBv)call hqo(hNv,hcv)call hqo(hNv,hCv)set bDv[(hNv)]=((7.5)*1.)set bjv[(hNv)]=((3.5)*1.)set bJv[(hNv)]=((.85)*1.)set bfv[(hNv)]=((6)*1.)set bkv[(hNv)]=((3.25)*1.)set bFv[(hNv)]=((16)*1.)
set bKv[(hNv)]=((5)*1.)return trueendfunctionfunction Hko takes nothing returns booleanset hdv=hjo('uSat')call hJo(((hdv)),ASv,(Idv))set Uj[(hdv)]=((1.4)*1.)
set NOv[(hdv)]=((45.368620037807)*1.)set NWv[(hdv)]=((45.368620037807)*1.)set NPv[(hdv)]=(($E6)*1.)set I8v[(hdv)]=((1)*1.)set Anv[(hdv)]=(2)set Nmv[(hdv)]=((80)*1.)
set NLv[(hdv)]=((80)*1.)
set NKv[(hdv)]=((.4)*1.)
set Npv[(hdv)]=(('x')*1.)set NMv[(hdv)]=(('x')*1.)set Nlv[(hdv)]=((.7)*1.)
set Ncv[(hdv)]=(($578)*1.)set Nbv[(hdv)]=(($578)*1.)set NGv[(hdv)]=((35)*1.)
set Adv[(hdv)]=(gkv)
set AGv[(hdv)]=(('x')*1.)set Ahv[((hdv))]=((1.*1./((1.35)*1.))*1.)set AWv[(hdv)]=((.3)*1.)
set Auv[(hdv)]=(($E)*1.)
set AUv[(hdv)]=(($E)*1.)
set AYv[(hdv)]=(1)set A_v[(hdv)]=(4)set A2v[(hdv)]=(0)set ATv[(hdv)]=((24.196597353497)*1.)set Nnv[(hdv)]=($F)set Niv[(hdv)]=(35)return trueendfunctionfunction HKo takes nothing returns booleanset hDv=hjo('uSpe')call hJo(((hDv)),ASv,(Idv))set Uj[(hDv)]=((1.35)*1.)set NOv[(hDv)]=((60)*1.)
set NWv[(hDv)]=(('q')*1.)set NPv[(hDv)]=(('}')*1.)set I8v[(hDv)]=((0)*1.)set Anv[(hDv)]=(1)set Nmv[(hDv)]=(($E1)*1.)set NLv[(hDv)]=(($E1)*1.)set NKv[(hDv)]=((.15)*1.)set Npv[(hDv)]=((75)*1.)
set NMv[(hDv)]=((75)*1.)
set Nlv[(hDv)]=((.2)*1.)
set Ncv[(hDv)]=(($578)*1.)set Nbv[(hDv)]=(($578)*1.)set NGv[(hDv)]=((35)*1.)
set Adv[(hDv)]=(gmv)
set AGv[(hDv)]=(($A2)*1.)set Ahv[((hDv))]=((1.*1./((2.31)*1.))*1.)set AWv[(hDv)]=((.31)*1.)set Dnv[(hDv)]=(($4B0)*1.)set Auv[(hDv)]=(($E)*1.)
set AUv[(hDv)]=(($E)*1.)
set AYv[(hDv)]=(1)set A_v[(hDv)]=(5)set A2v[(hDv)]=(1)set ATv[(hDv)]=((32)*1.)
set Nnv[(hDv)]=(20)set Niv[(hDv)]=(25)call hpo((hDv),(hfv),1)return trueendfunctionfunction Hlo takes nothing returns booleanset hFv=hjo('uFlP')call hJo(((hFv)),ASv,(Iav))set Uj[(hFv)]=((1.3)*1.)
call hko(hFv,$FF,0,$FF,$FF)set NOv[(hFv)]=((60)*1.)
set NWv[(hFv)]=((60)*1.)
set NPv[(hFv)]=((340)*1.)set I8v[(hFv)]=((0)*1.)set Anv[(hFv)]=(0)set Nmv[(hFv)]=((40)*1.)
set NLv[(hFv)]=((40)*1.)
set NKv[(hFv)]=((.2)*1.)
set Ncv[(hFv)]=((350)*1.)set Nbv[(hFv)]=((350)*1.)set NGv[(hFv)]=(($A)*1.)
set Adv[(hFv)]=(gmv)
set AGv[(hFv)]=(('x')*1.)set Ahv[((hFv))]=((1.*1./((1.5)*1.))*1.)
set AWv[(hFv)]=((1)*1.)set Dnv[(hFv)]=((600)*1.)set Auv[(hFv)]=((5)*1.)set AUv[(hFv)]=((5)*1.)set AYv[(hFv)]=(1)set A_v[(hFv)]=(1)set A2v[(hFv)]=(2)set ATv[(hFv)]=((20.8)*1.)return trueendfunctionfunction HLo takes nothing returns booleanset hgv=hjo('uPeL')call hJo(((hgv)),ASv,(Idv))set Uj[(hgv)]=((1.5)*1.)
set NOv[(hgv)]=((60)*1.)
set NWv[(hgv)]=((60)*1.)
set I8v[(hgv)]=((0)*1.)set Anv[(hgv)]=(5)set Nmv[(hgv)]=(('d')*1.)set NLv[(hgv)]=(('d')*1.)set NKv[(hgv)]=((0)*1.)set Ncv[(hgv)]=((350)*1.)set Nbv[(hgv)]=((350)*1.)set Auv[(hgv)]=((0)*1.)set AUv[(hgv)]=((0)*1.)set AYv[(hgv)]=(0)set A_v[(hgv)]=(0)set ATv[(hgv)]=((8)*1.)return trueendfunctionfunction Hmo takes nothing returns booleanset hGv=hjo('uPeo')call hJo(((hGv)),ASv,(Idv))set Uj[(hGv)]=((.85)*1.)
set NOv[(hGv)]=((45)*1.)
set NWv[(hGv)]=((60)*1.)
set NPv[(hGv)]=(($AA)*1.)set I8v[(hGv)]=((0)*1.)set Anv[(hGv)]=(1)set Nmv[(hGv)]=(('x')*1.)set NLv[(hGv)]=(('x')*1.)set NKv[(hGv)]=((.1)*1.)
set Ncv[(hGv)]=((800)*1.)set Nbv[(hGv)]=((800)*1.)set NGv[(hGv)]=((35)*1.)
set Adv[(hGv)]=(gkv)
set AGv[(hGv)]=(('l')*1.)set Ahv[((hGv))]=((1.*1./((3)*1.))*1.)set AWv[(hGv)]=((.5)*1.)
set Auv[(hGv)]=((5)*1.)set AUv[(hGv)]=((5)*1.)set AYv[(hGv)]=(1)set A_v[(hGv)]=(2)set A2v[(hGv)]=(0)set ATv[(hGv)]=((16)*1.)
set Nnv[(hGv)]=($F)set Niv[(hGv)]=(20)return trueendfunctionfunction HMo takes nothing returns booleanset hhv=hjo('uSwo')call hJo(((hhv)),ASv,(Idv))set Uj[(hhv)]=((1.25)*1.)call hko(hhv,$FF,$FF,$FF,$FF)set NOv[(hhv)]=((41.666666666667)*1.)set NWv[(hhv)]=((41.666666666667)*1.)set NPv[(hhv)]=((270)*1.)set I8v[(hhv)]=((3)*1.)set Anv[(hhv)]=(2)set Nmv[(hhv)]=((400)*1.)set NLv[(hhv)]=((400)*1.)set NKv[(hhv)]=((.2)*1.)
set Ncv[(hhv)]=(($578)*1.)set Nbv[(hhv)]=(($578)*1.)set NGv[(hhv)]=((40)*1.)
set Adv[(hhv)]=(gkv)
set AGv[(hhv)]=(('x')*1.)set Ahv[((hhv))]=((1.*1./((1)*1.))*1.)set AWv[(hhv)]=((.5)*1.)
set Auv[(hhv)]=((2)*1.)set AUv[(hhv)]=((2)*1.)set AYv[(hhv)]=(1)set A_v[(hhv)]=(3)set A2v[(hhv)]=(0)set ATv[(hhv)]=((21.527777777778)*1.)set Nnv[(hhv)]=(20)set Niv[(hhv)]=($A)return trueendfunctionfunction Hpo takes integer oSx,integer otx,string oux returns booleanreturn lTx(Jw[(oSx)],(kw[((oSx))]),otx,oux)endfunctionfunction HPo takes integer oSx,integer otx,integer oux returns booleanreturn lUx(Jw[(oSx)],(kw[((oSx))]),otx,oux)endfunctionfunction Hqo takes integer oSx,string lyx,string Abx,integer rYx returns nothing
call Hpo((oSx),AIv,Abx)call HPo((oSx),AAv,rYx)call Hpo((oSx),ARv,lyx)endfunctionfunction HQo takes nothing returns booleanset hHv=hjo('uVic')set Uj[(hHv)]=((1.2)*1.)
set NOv[(hHv)]=((41.666666666667)*1.)set NWv[(hHv)]=((41.666666666667)*1.)call Hqo(hHv,"UnitType_page\\UnitType_struct\\Hammer.mdx","hand right",ri)set I8v[(hHv)]=((0)*1.)set Anv[(hHv)]=(2)set Nmv[(hHv)]=(($C8)*1.)set NLv[(hHv)]=(($C8)*1.)set NKv[(hHv)]=((0)*1.)set Ncv[(hHv)]=((500)*1.)set Nbv[(hHv)]=((500)*1.)set NGv[(hHv)]=((300)*1.)set Auv[(hHv)]=((0)*1.)set AUv[(hHv)]=((0)*1.)set AYv[(hHv)]=(0)set A_v[(hHv)]=(0)return trueendfunctionfunction Hso takes nothing returns booleancall hEo(function hKo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_KoboldBrown_wc3unit.j")call hEo(function hlo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\obj_Moonkin_wc3unit.j")call hEo(function hLo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Bonus\\obj_PenguinChamp_wc3unit.j")call hEo(function hPo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\obj_GnollMage_wc3unit.j")call hEo(function hso,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Heroes\\obj_Kera_wc3unit.j")
call hEo(function hSo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_BaseTower_wc3unit.j")
call hEo(function hto,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\obj_TrollPriest_wc3unit.j")call hEo(function hTo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_DarkTower2_wc3unit.j")call hEo(function huo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Heroes\\obj_Tajran_wc3unit.j")call hEo(function hUo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\obj_Troll_wc3unit.j")call hEo(function hYo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_FrostTower_wc3unit.j")call hEo(function hzo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Heroes\\Lizzy\\obj_Lizzy_wc3unit.j")
call hEo(function hZo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_FurbolgMother_wc3unit.j")call hEo(function h_o,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_TreantPurple_wc3unit.j")call hEo(function h0o,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_FrostTower2_wc3unit.j")call hEo(function h1o,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_WolfMother_wc3unit.j")
call hEo(function h2o,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Heroes\\obj_Drakul_wc3unit.j")call hEo(function h3o,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\obj_Raider_wc3unit.j")
call hEo(function h4o,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\DefenderSpawns\\obj_Vicar_wc3unit.j")
call hEo(function h5o,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\Assassin\\obj_Assassin_wc3unit.j")
call hEo(function h6o,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_Tuskar_wc3unit.j")
call hEo(function h9o,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\obj_Catapult_wc3unit.j")call hEo(function Hvo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\obj_TrueLeader_wc3unit.j")
call hEo(function Heo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\obj_Demolisher_wc3unit.j")
call hEo(function Hxo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Heroes\\obj_Smokealot_wc3unit.j")call hEo(function Hoo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_KoboldRed_wc3unit.j")call hEo(function Hro,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\Tower\\obj_Tower_wc3unit.j")call hEo(function Hio,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_Pandarene_wc3unit.j")call hEo(function Hao,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Heroes\\obj_Jota_wc3unit.j")
call hEo(function Hno,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\Tarog\\obj_Tarog_wc3unit.j")call hEo(function HVo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_PropPenguin_wc3unit.j")call hEo(function HEo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_LightningTower_wc3unit.j")call hEo(function HXo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\obj_Nagarosh_wc3unit.j")call hEo(function HOo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\Balduir\\obj_Balduir_wc3unit.j")call hEo(function HRo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\Fountain\\obj_Fountain_wc3unit.j")call hEo(function HIo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Heroes\\obj_Aruruw_wc3unit.j")call hEo(function HAo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\obj_FurbolgOracle_wc3unit.j")call hEo(function HNo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_DarkTower_wc3unit.j")
call hEo(function Hbo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\obj_AxeFighter_wc3unit.j")
call hEo(function HBo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Heroes\\obj_Stormy_wc3unit.j")call hEo(function Hco,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_BlueDragonSpawn_wc3unit.j")call hEo(function HCo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_KoboldBlue_wc3unit.j")
call hEo(function Hdo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Bonus\\obj_Penguin_wc3unit.j")call hEo(function HDo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_Reservoir_wc3unit.j")
call hEo(function Hfo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_LightningTower2_wc3unit.j")call hEo(function HFo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Deer\\obj_Deer_wc3unit.j")
call hEo(function Hgo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\obj_SnowFalcon_wc3unit.j")
call hEo(function HGo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\Creeps\\obj_TreantGreen_wc3unit.j")call hEo(function Hho,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\obj_Wolf_wc3unit.j")call hEo(function HHo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\obj_Drummer_wc3unit.j")call hEo(function Hjo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\obj_Leader_wc3unit.j")
call hEo(function HJo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Heroes\\obj_Rocketeye_wc3unit.j")call hEo(function Hko,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act1\\obj_Satyr_wc3unit.j")call hEo(function HKo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\SpearScout\\obj_SpearScout_wc3unit.j")
call hEo(function Hlo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Bonus\\FlyingPenguin\\obj_FlyingPenguin_wc3unit.j")call hEo(function HLo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\obj_PenguinLying_wc3unit.j")call hEo(function Hmo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Spawns\\Act2\\obj_Peon_wc3unit.j")call hEo(function HMo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\DefenderSpawns\\obj_Swordsman_wc3unit.j")
call hEo(function HQo,"D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\UnitType.page\\UnitType.struct\\UnitTypes.pack\\Other\\Victor\\obj_Victor_wc3unit.j")return trueendfunctionfunction HSo takes nothing returns booleanset gFv=VXx(gBv)
return trueendfunctionfunction Hto takes nothing returns booleanset lD=VXx(hD)return trueendfunctionfunction HTo takes nothing returns booleanset hjv=VXx(hJv)
return trueendfunctionfunction Huo takes nothing returns booleanset hkv=VXx(hKv)
return trueendfunctionfunction HUo takes nothing returns booleanset hlv=VXx(hLv)
return trueendfunctionfunction Hwo takes nothing returns booleanset hmv=VXx(hMv)
return trueendfunctionfunction HWo takes nothing returns booleanset hpv=VXx(hPv)
return trueendfunctionfunction Hyo takes nothing returns booleanset hqv=VXx(hQv)
return trueendfunctionfunction HYo takes nothing returns booleanset hsv=VXx(hSv)
return trueendfunctionfunction Hzo takes nothing returns booleanset htv=VXx(hTv)
return trueendfunctionfunction HZo takes nothing returns booleanset huv=VXx(hUv)
return trueendfunctionfunction H_o takes nothing returns booleanset hwv=VXx(hWv)
return trueendfunctionfunction H0o takes nothing returns booleanset hyv=VXx(hYv)
return trueendfunctionfunction H1o takes nothing returns booleanset hzv=VXx(hZv)
return trueendfunctionfunction H2o takes nothing returns booleanset h_v=VXx(h0v)
return trueendfunctionfunction H3o takes nothing returns booleanset J0=VXx(F0)return trueendfunctionfunction H4o takes nothing returns booleanset f1=VXx(b1)return trueendfunctionfunction H5o takes nothing returns booleanset s1=VXx(m1)return trueendfunctionfunction H6o takes nothing returns booleanset V2=VXx(v2)return trueendfunctionfunction H7o takes nothing returns booleanset h1v=VXx(h2v)
return trueendfunctionfunction H8o takes nothing returns booleanset h3v=VXx(h4v)
return trueendfunctionfunction H9o takes nothing returns booleanset h5v=VXx(h6v)
return trueendfunctionfunction jvo takes nothing returns booleanset h7v=VXx(h8v)
return trueendfunctionfunction jeo takes nothing returns booleanreturn trueendfunctionfunction jxo takes nothing returns booleanset h9v=VXx(TD)return trueendfunctionfunction joo takes code c,string rSx returns nothing
set ea=ea+1set xa[ea]=CreateTrigger()set oa[ea]=(GetHandleId(Condition((c))))
set ra[ea]=rSxcall TriggerAddCondition(xa[ea],Condition(c))endfunctionfunction jro takes integer oSx returns integerset Hnv[oSx]=trueset HVv[oSx]=falsecall rEx(hjv)return oSxendfunctionfunction jio takes nothing returns integerlocal integer oSxif(Hov==8190)thencall o_x("PlayerController_Allocation_allocCustom","call DebugEx(PlayerController.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",hJv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Hrv[(w)]==w)thenset Hiv=Hiv+1set oSx=Hivelse
set oSx=Hrv[(w)]
set Hrv[(w)]=Hrv[Hrv[(w)]]endifset Hrv[oSx]=Zset Hav[oSx]=1call jro(oSx)return oSxendfunctionfunction jao takes mapcontrol oqx returns integerlocal integer oSx=jio()set HEv[oSx]=oqx
call SaveInteger(o[((V[(E[((X))])]))],(((HXv+GetHandleId(oqx)))),(((HOv))),(((oSx))))return oSxendfunctionfunction jno takes integer oSx,mapcontrol oqx returns nothingcall SaveInteger(o[((V[(E[((X))])]))],(((HXv+GetHandleId(oqx)))),(((HOv))),(((oSx))))endfunctionfunction jVo takes nothing returns nothingset Hxv=jao(MAP_CONTROL_COMPUTER)set HRv=jao(MAP_CONTROL_USER)call jno(Hxv,MAP_CONTROL_CREEP)call jno(Hxv,MAP_CONTROL_NONE)endfunctionfunction jEo takes integer oSx returns integerset Hcv[oSx]=trueset HCv[oSx]=falsecall rEx(hkv)return oSxendfunctionfunction jXo takes nothing returns integerlocal integer oSxif(HAv==8190)thencall o_x("PlayerSlotState_Allocation_allocCustom","call DebugEx(PlayerSlotState.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",hKv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(HNv[(w)]==w)thenset Hbv=Hbv+1set oSx=Hbvelse
set oSx=HNv[(w)]
set HNv[(w)]=HNv[HNv[(w)]]endifset HNv[oSx]=Zset HBv[oSx]=1call jEo(oSx)return oSxendfunctionfunction jOo takes playerslotstate oqx returns integerlocal integer oSx=jXo()set Hdv[oSx]=oqx
call SaveInteger(o[((V[(E[((X))])]))],(((HDv+GetHandleId(oqx)))),(((Hfv))),(((oSx))))return oSxendfunctionfunction jRo takes nothing returns nothingset HIv=jOo(PLAYER_SLOT_STATE_EMPTY)
set HFv=jOo(PLAYER_SLOT_STATE_LEFT)set Hgv=jOo(PLAYER_SLOT_STATE_PLAYING)endfunctionfunction jIo takes integer oSx returns integerset Hkv[oSx]=trueset HKv[oSx]=falsecall rEx(hlv)return oSxendfunctionfunction jAo takes nothing returns integerlocal integer oSxif(Hhv==8190)thencall o_x("Team_Allocation_allocCustom","call DebugEx(Team.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",hLv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(HHv[(w)]==w)thenset Hjv=Hjv+1set oSx=Hjvelse
set oSx=HHv[(w)]
set HHv[(w)]=HHv[HHv[(w)]]endifset HHv[oSx]=Zset HJv[oSx]=1call jIo(oSx)return oSxendfunctionfunction jNo takes nothing returns nothingset HGv=jAo()set Byv=jAo()set Hlv=jAo()endfunctionfunction jbo takes nothing returns nothingendfunctionfunction jBo takes integer oSx returns integerset HPv[oSx]=trueset Hqv[oSx]=falseset Bb[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set B0[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(h9v)return oSxendfunctionfunction jco takes nothing returns integerlocal integer oSxif(HLv==8190)thencall o_x("User_Allocation_allocCustom","call DebugEx(User.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",TD+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Hmv[(w)]==w)thenset HMv=HMv+1set oSx=HMvelse
set oSx=Hmv[(w)]
set Hmv[(w)]=Hmv[Hmv[(w)]]endifset Hmv[oSx]=Zset Hpv[oSx]=1call jBo(oSx)return oSxendfunctionfunction jCo takes integer oSx,playercolor oux returns nothingset ox[oSx]=ouxcall SetPlayerColor(vx[oSx],oux)
endfunctionfunction jdo takes integer oSx,string oux returns nothingset ob[oSx]=ouxcall SetPlayerName(vx[oSx],oux)endfunctionfunction jDo takes integer oSx returns booleanset Jh=Jh+1set kh[Jh]=oSxset HQv[oSx]=Jh+1return(Jh==0)endfunctionfunction jfo takes integer oSx,integer oux returns nothingset Hsv[oSx]=oux
if(oux==HRv)then
set HSv=HSv+1set Htv[HSv]=oSx
endifendfunctionfunction jFo takes mapcontrol oqx returns integerif((LoadInteger(o[((V[(E[((X))])]))],(((HXv+GetHandleId(oqx)))),(((HOv)))))==0)thencall o_x("PlayerController_GetFromSelf","call DebugEx(\"PlayerController: GetFromSelf: \"+I2S(GetHandleId(self)))","PlayerController: GetFromSelf: "+I2S(GetHandleId(oqx)))endifreturn(LoadInteger(o[((V[(E[((X))])]))],(((HXv+GetHandleId(oqx)))),(((HOv)))))endfunctionfunction jgo takes integer oSx returns nothingcall jfo(oSx,jFo(GetPlayerController(vx[(oSx)])))endfunctionfunction jGo takes integer oSx returns nothingset cb[(oSx)]=(HTv+oSx)endfunctionfunction jho takes integer oSx,integer aCx,integer oux returns nothinglocal integer oLxlocal integer jHoif(aCx==Hgv)then
set oLx=hhx((oSx),HUv)set jHo=jl[Hl]set jl[oLx]=jHoset Hl=Hl-1call hlx(jHo,HUv,oLx)elseif(oux==Hgv)then
set Hl=Hl+1set jl[Hl]=oSxcall hlx((oSx),HUv,Hl)endifendfunctionfunction jjo takes integer oSx,integer oux returns nothinglocal integer aCx=Huv[oSx]set Huv[oSx]=oux
if(aCx!=oux)then
call jho(oSx,aCx,oux)endifendfunctionfunction jJo takes integer oSx returns nothingset Huv[oSx]=HIv
call jjo(oSx,(LoadInteger(o[((V[(E[((X))])]))],(((HDv+GetHandleId((GetPlayerSlotState(vx[(oSx)])))))),(((Hfv))))))endfunctionfunction jko takes string jKo,integer Nzx,string jlo returns integer
local integer oSx=jco()local player oqx=Player(Nzx)
set vx[oSx]=oqxcall SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oqx))))),((((R)))),((((oSx)))))call jCo(oSx,GetPlayerColor(oqx))set xb[(oSx)]=(jlo)call jdo(oSx,GetPlayerName(oqx))
set oqx=null
call jDo(oSx)call jgo(oSx)set kv[((oSx))]=(w)call jGo(oSx)call jJo(oSx)set BWv[(oSx)]=w
if((GetPlayerController(vx[oSx])!=MAP_CONTROL_USER)or(GetPlayerSlotState(vx[oSx])!=PLAYER_SLOT_STATE_PLAYING))thencall jdo(oSx,jKo)endifreturn oSxendfunctionfunction jLo takes integer oDx,integer jHo,alliancetype rNx,boolean iTx,boolean jmo returns nothingcall SetPlayerAlliance(vx[oDx],vx[jHo],rNx,iTx)if jmo thencall SetPlayerAlliance(vx[jHo],vx[oDx],rNx,iTx)endifendfunctionfunction jMo takes integer oSx,integer oDx returns nothinglocal integer oMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Hwv+oSx))),(((HWv))))))local integer jHoloop
exitwhen(oMx<q)set jHo=(LoadInteger(o[((V[(E[((X))])]))],(((Hwv+oSx))),(((HWv)+(oMx)))))call jLo(oDx,jHo,ALLIANCE_PASSIVE,true,true)
call jLo(oDx,jHo,ALLIANCE_SHARED_SPELLS,true,true)call jLo(oDx,jHo,ALLIANCE_SHARED_VISION,true,true)set oMx=oMx-1endloopcall rux(X,Hwv+oSx,HWv,oDx)endfunctionfunction jpo takes integer oSx,integer oux returns nothingset BWv[oSx]=oux
call jMo(oux,oSx)endfunctionfunction jPo takes integer oDx,integer jqo returns nothinglocal integer oMxif(oDx==Ge)thenset oMx=Jhloop
call jPo(kh[oMx],jqo)set oMx=oMx-1exitwhen(oMx<0)endloopelse
call FogModifierStart(CreateFogModifierRect(vx[oDx],FOG_OF_WAR_VISIBLE,bm[jqo],true,true))endifendfunctionfunction jQo takes integer oSx,integer oDx,string r4x,boolean jso returns nothinglocal integer oMxif(oDx==Ge)thenset oMx=Jhloop
call jQo(oSx,kh[oMx],r4x,jso)set oMx=oMx-1exitwhen(oMx<0)endloopendifcall TriggerRegisterPlayerChatEvent(DA[(oSx)],vx[oDx],r4x,jso)endfunctionfunction jSo takes integer oSx,string oqx,integer rNx,integer rbx returns integerreturn(YA+(rPx(lv[(E[((X))])],(((oqx))),(((I2S((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))))))))))endfunctionfunction jto takes integer oSx,string oqx,integer rNx,integer rbx,integer oLx returns integerreturn(rPx(lv[(E[((X))])],(((oqx))),(((I2S((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))))))+I2S(YA+((oLx))+2))))
endfunctionfunction jTo takes integer oSx,string r4x returns nothinglocal integer rFx=rRx(0)
local string juo
local integer oMxlocal integer rbxlocal integer rMxset ZA[(rFx)]=(oSx)set juo=r4xloop
exitwhen(juo==null)set lA[(rFx)]=(r4x)set LA[(rFx)]=(juo)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=jSo(zA,juo,KA,rbx)loop
exitwhen(rMx<0)call rfx(jto(zA,juo,KA,rbx,rMx),rFx)
set rMx=rMx-1endloopset oMx=oMx-1endloopset juo=(r5x((juo),0,((StringLength((juo)))-2)))
endloopcall rkx(((rFx)))endfunctionfunction jUo takes nothing returns booleanlocal string r4x=(GetEventPlayerChatString())local integer oSx=(oPx(GetTriggerPlayer()))call jTo(oSx,r4x)return trueendfunctionfunction jwo takes integer oSx,integer oDx,playerevent jWo returns nothinglocal integer oMxif(oDx==Ge)thenset oMx=Jhloop
call jwo(oSx,kh[oMx],jWo)set oMx=oMx-1exitwhen(oMx<0)endloopendifcall TriggerRegisterPlayerEvent(DA[(oSx)],vx[oDx],jWo)endfunctionfunction jyo takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((B0[oSx]))])]))],((((cb[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))endfunctionfunction jYo takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((B0[oSx]))])]))],((((cb[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))endfunctionfunction jzo takes integer oSx returns nothinglocal integer rFx=rRx(0)
local integer jZo=rRx((cb[(oSx)]))local integer oMxlocal integer rbxlocal integer rMxset ZA[(rFx)]=(oSx)set ZA[(jZo)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Hvv))-1)*Iv+(((rbx))-1)))))))))
loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Hvv))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset rMx=jyo(oSx,Hvv,rbx)
loop
exitwhen(rMx<q)call rfx(jYo(oSx,Hvv,rbx,rMx),jZo)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call rkx(((jZo)))endfunctionfunction j_o takes nothing returns booleanlocal integer oSx=(oPx(GetTriggerPlayer()))call ipx(Ge,iSx((ob[(oSx)]),(xb[(oSx)]))+"'s footprints were blown away",10.)call jzo(oSx)return trueendfunctionfunction j0o takes nothing returns nothingset Hvv=(E3x())call jwo(XJx(function j_o),Ge,EVENT_PLAYER_LEAVE)endfunctionfunction j1o takes integer njo,integer o5x returns nothinglocal integer rFx=rRx(0)
local integer oMxlocal integer rbxlocal integer rMxset ZA[(rFx)]=(o5x)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((H_v))-1)*Iv+(((rbx))-1)))))))))
loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((H_v))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction j2o takes integer o5x returns nothinglocal integer njo=H2vif(o5x==njo)then
returnendifif(njo!=w)thencall pjx(njo,H0v)endifset H2v=o5xcall p_x(o5x,H0v)set H3v=o5xcall aKx("new host is "+OQx(o5x))call j1o(njo,o5x)endfunctionfunction j3o takes nothing returns nothingcall StoreInteger(H1v,"","",fhx())call TriggerSyncStart()call SyncStoredInteger(H1v,"","")call TriggerSyncReady()call j2o(GetStoredInteger(H1v,"",""))endfunctionfunction j4o takes nothing returns booleanlocal integer rFx=(bv)call akx(function j3o)return trueendfunctionfunction j5o takes nothing returns nothingset H_v=(E3x())set H0v=Xdx("FolderUser_StructHostAppointment_Init: set FolderUser_StructHostAppointment.LEAVE_EVENT = Event.Create(User.LEAVE_EVENT_TYPE, EventPriority.HEADER, function FolderUser_StructHostAppointment.Event_Leave)",Hvv,bI,function j4o)set H1v=InitGameCache(hZv)call j2o(Htv[0])
call akx(function j3o)endfunctionfunction j6o takes nothing returns nothinglocal integer iset gl=NJx()
set i=Jh
loop
exitwhen(i<0)call ForceAddPlayer(LD[(gl)],vx[(kh[i])])set i=i-1endloopendfunctionfunction j7o takes integer oSx returns nothinglocal integer rFx=rRx(0)
local integer oMxlocal integer rbxlocal integer rMxset ZA[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((FZ))-1)*Iv+(((rbx))-1)))))))))loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((FZ))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction j8o takes nothing returns booleanlocal integer oSx=(oPx(GetTriggerPlayer()))call j7o(oSx)return trueendfunctionfunction j9o takes integer oSx returns nothingset H0[oSx]=falsecall rHx(J0)
endfunctionfunction Jvo takes integer oSx returns nothingif(h0[oSx]>0)thenreturnendifif(g0[oSx]!=Z)thencall o_x("FolderUser_FolderKeyEvent_StructDownArrow_Allocation_deallocCustom_confirm","call DebugEx(FolderUser_FolderKeyEvent_StructDownArrow.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",F0+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset g0[oSx]=g0[(w)]set g0[(w)]=oSxcall j9o(oSx)endfunctionfunction Jeo takes integer oSx returns nothingset h0[oSx]=h0[oSx]-1call Jvo(oSx)endfunctionfunction Jxo takes integer oSx,integer otx,integer oux returns booleanreturn rrx(xA[(oSx)],(aA[((oSx))]),otx,oux)endfunctionfunction Joo takes integer oSx,integer XYx returns nothingcall Jxo((oSx),(oA[(XYx)]),XYx)endfunctionfunction Jro takes nothing returns booleanlocal integer rFx=(bv)local integer XYx=(jZ[(rFx)])local integer oSx=Fqx(XYx,P0)local integer p3x=K0[oSx]local integer oDx=m0[oSx]call Jeo((oSx))call iKx(p3x)call DMo(XYx,P0)
call Joo(XYx,p0)
call hGx(oDx,M0,oSx)
call pjx(oDx,XYx)return trueendfunctionfunction Jio takes integer rLx returns nothinglocal integer rFx=rRx((cb[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset K1[(rFx)]=((1.)*1.)set ZA[(rFx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=jyo(rLx,D0,rbx)loop
exitwhen(rMx<q)call rfx(jYo(rLx,D0,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction Jao takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer rFx=rRx(0)
set K1[(rFx)]=((l0[oSx])*1.)
set ZA[(rFx)]=(m0[oSx])call rfx(L0[oSx],rFx)call rkx(((rFx)))endfunctionfunction Jno takes nothing returns booleanlocal integer rLx=(oPx(GetTriggerPlayer()))local integer oMxlocal integer oSxset Rf[rLx]=true
call Jio(rLx)set oMx=O0x(rLx,M0)loop
exitwhen(oMx<q)set oSx=O6x(rLx,M0,oMx)call iDx(K0[oSx],k0[oSx],true,function Jao)set oMx=oMx-1endloopreturn trueendfunctionfunction JVo takes integer rLx returns nothinglocal integer rFx=rRx((cb[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset ZA[(rFx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=jyo(rLx,H5v,rbx)
loop
exitwhen(rMx<q)call rfx(jYo(rLx,H5v,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction JEo takes nothing returns booleanlocal integer rLx=(oPx(GetTriggerPlayer()))local integer oMxlocal integer oSxset Rf[rLx]=falsecall JVo(rLx)set oMx=O0x(rLx,M0)loop
exitwhen(oMx<q)set oSx=O6x(rLx,M0,oMx)call ikx(K0[oSx])set oMx=oMx-1endloopreturn trueendfunctionfunction JXo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(ZA[(rFx)])set Rf[rLx]=falsereturn trueendfunctionfunction JOo takes nothing returns nothingset p0=Xdx("FolderUser_FolderKeyEvent_StructDownArrow_Init: set FolderUser_FolderKeyEvent_StructDownArrow.DESTROY_EVENT = Event.Create(Event.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUser_FolderKeyEvent_StructDownArrow.Event_Destroy)",nI,bI,function Jro)set D0=(E3x())set H5v=(E3x())call jwo(XJx(function Jno),Ge,EVENT_PLAYER_ARROW_DOWN_DOWN)call jwo(XJx(function JEo),Ge,EVENT_PLAYER_ARROW_DOWN_UP)call gdx(gl,function JXo,w)endfunctionfunction JRo takes integer oSx returns nothingset d1[oSx]=falsecall rHx(f1)
endfunctionfunction JIo takes integer oSx returns nothingif(C1[oSx]>0)thenreturnendifif(B1[oSx]!=Z)thencall o_x("FolderUser_FolderKeyEvent_StructLeftArrow_Allocation_deallocCustom_confirm","call DebugEx(FolderUser_FolderKeyEvent_StructLeftArrow.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",b1+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset B1[oSx]=B1[(w)]set B1[(w)]=oSxcall JRo(oSx)endfunctionfunction JAo takes integer oSx returns nothingset C1[oSx]=C1[oSx]-1call JIo(oSx)endfunctionfunction JNo takes nothing returns booleanlocal integer rFx=(bv)local integer XYx=(jZ[(rFx)])local integer oSx=Fqx(XYx,k1)local integer p3x=g1[oSx]local integer oDx=H1[oSx]call JAo((oSx))call iKx(p3x)call DMo(XYx,k1)
call Joo(XYx,J1)
call hGx(oDx,j1,oSx)
call pjx(oDx,XYx)return trueendfunctionfunction Jbo takes integer rLx returns nothinglocal integer rFx=rRx((cb[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset K1[(rFx)]=((1.)*1.)set ZA[(rFx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=jyo(rLx,A1,rbx)loop
exitwhen(rMx<q)call rfx(jYo(rLx,A1,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction JBo takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer rFx=rRx(0)
set K1[(rFx)]=((G1[oSx])*1.)
set ZA[(rFx)]=(H1[oSx])call rfx(h1[oSx],rFx)call rkx(((rFx)))endfunctionfunction Jco takes nothing returns booleanlocal integer rLx=(oPx(GetTriggerPlayer()))local integer oMxlocal integer oSxset Xf[rLx]=true
call Jbo(rLx)set oMx=O0x(rLx,j1)loop
exitwhen(oMx<q)set oSx=O6x(rLx,j1,oMx)call iDx(g1[oSx],F1[oSx],true,function JBo)set oMx=oMx-1endloopreturn trueendfunctionfunction JCo takes integer rLx returns nothinglocal integer rFx=rRx((cb[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset ZA[(rFx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=jyo(rLx,H6v,rbx)
loop
exitwhen(rMx<q)call rfx(jYo(rLx,H6v,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction Jdo takes nothing returns booleanlocal integer rLx=(oPx(GetTriggerPlayer()))local integer oMxlocal integer oSxset Xf[rLx]=falsecall JCo(rLx)set oMx=O0x(rLx,j1)loop
exitwhen(oMx<q)set oSx=O6x(rLx,j1,oMx)call ikx(g1[oSx])set oMx=oMx-1endloopreturn trueendfunctionfunction JDo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(ZA[(rFx)])set Xf[rLx]=falsereturn trueendfunctionfunction Jfo takes nothing returns nothingset J1=Xdx("FolderUser_FolderKeyEvent_StructLeftArrow_Init: set FolderUser_FolderKeyEvent_StructLeftArrow.DESTROY_EVENT = Event.Create(Event.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUser_FolderKeyEvent_StructLeftArrow.Event_Destroy)",nI,bI,function JNo)set A1=(E3x())set H6v=(E3x())call jwo(XJx(function Jco),Ge,EVENT_PLAYER_ARROW_LEFT_DOWN)call jwo(XJx(function Jdo),Ge,EVENT_PLAYER_ARROW_LEFT_UP)call gdx(gl,function JDo,w)endfunctionfunction JFo takes integer oSx returns nothingset q1[oSx]=falsecall rHx(s1)
endfunctionfunction Jgo takes integer oSx returns nothingif(P1[oSx]>0)thenreturnendifif(M1[oSx]!=Z)thencall o_x("FolderUser_FolderKeyEvent_StructRightArrow_Allocation_deallocCustom_confirm","call DebugEx(FolderUser_FolderKeyEvent_StructRightArrow.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",m1+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset M1[oSx]=M1[(w)]set M1[(w)]=oSxcall JFo(oSx)endfunctionfunction JGo takes integer oSx returns nothingset P1[oSx]=P1[oSx]-1call Jgo(oSx)endfunctionfunction Jho takes nothing returns booleanlocal integer rFx=(bv)local integer XYx=(jZ[(rFx)])local integer oSx=Fqx(XYx,Y1)local integer p3x=t1[oSx]local integer oDx=U1[oSx]call JGo((oSx))call iKx(p3x)call DMo(XYx,Y1)
call Joo(XYx,W1)
call hGx(oDx,w1,oSx)
call pjx(oDx,XYx)return trueendfunctionfunction JHo takes integer rLx returns nothinglocal integer rFx=rRx((cb[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset K1[(rFx)]=((1.)*1.)set ZA[(rFx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=jyo(rLx,l1,rbx)loop
exitwhen(rMx<q)call rfx(jYo(rLx,l1,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction Jjo takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer rFx=rRx(0)
set K1[(rFx)]=((T1[oSx])*1.)
set ZA[(rFx)]=(U1[oSx])call rfx(u1[oSx],rFx)call rkx(((rFx)))endfunctionfunction JJo takes nothing returns booleanlocal integer rLx=(oPx(GetTriggerPlayer()))local integer oMxlocal integer oSxset Of[rLx]=true
call JHo(rLx)set oMx=O0x(rLx,w1)loop
exitwhen(oMx<q)set oSx=O6x(rLx,w1,oMx)call iDx(t1[oSx],S1[oSx],true,function Jjo)set oMx=oMx-1endloopreturn trueendfunctionfunction Jko takes integer rLx returns nothinglocal integer rFx=rRx((cb[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset ZA[(rFx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=jyo(rLx,H7v,rbx)
loop
exitwhen(rMx<q)call rfx(jYo(rLx,H7v,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction JKo takes nothing returns booleanlocal integer rLx=(oPx(GetTriggerPlayer()))local integer oMxlocal integer oSxset Of[rLx]=falsecall Jko(rLx)set oMx=O0x(rLx,w1)loop
exitwhen(oMx<q)set oSx=O6x(rLx,w1,oMx)call ikx(t1[oSx])set oMx=oMx-1endloopreturn trueendfunctionfunction Jlo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(ZA[(rFx)])set Of[rLx]=falsereturn trueendfunctionfunction JLo takes nothing returns nothingset W1=Xdx("FolderUser_FolderKeyEvent_StructRightArrow_Init: set FolderUser_FolderKeyEvent_StructRightArrow.DESTROY_EVENT = Event.Create(Event.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUser_FolderKeyEvent_StructRightArrow.Event_Destroy)",nI,bI,function Jho)
set l1=(E3x())set H7v=(E3x())call jwo(XJx(function JJo),Ge,EVENT_PLAYER_ARROW_RIGHT_DOWN)
call jwo(XJx(function JKo),Ge,EVENT_PLAYER_ARROW_RIGHT_UP)call gdx(gl,function Jlo,w)endfunctionfunction Jmo takes integer oSx returns nothingset i2[oSx]=falsecall rHx(V2)
endfunctionfunction JMo takes integer oSx returns nothingif(r2[oSx]>0)thenreturnendifif(e2[oSx]!=Z)thencall o_x("FolderUser_FolderKeyEvent_StructUpArrow_Allocation_deallocCustom_confirm","call DebugEx(FolderUser_FolderKeyEvent_StructUpArrow.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",v2+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset e2[oSx]=e2[(w)]set e2[(w)]=oSxcall Jmo(oSx)endfunctionfunction Jpo takes integer oSx returns nothingset r2[oSx]=r2[oSx]-1call JMo(oSx)endfunctionfunction JPo takes nothing returns booleanlocal integer rFx=(bv)local integer XYx=(jZ[(rFx)])local integer oSx=Fqx(XYx,b2)local integer p3x=X2[oSx]local integer oDx=I2[oSx]call Jpo((oSx))call iKx(p3x)call DMo(XYx,b2)
call Joo(XYx,N2)
call hGx(oDx,A2,oSx)
call pjx(oDx,XYx)return trueendfunctionfunction Jqo takes integer rLx returns nothinglocal integer rFx=rRx((cb[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset K1[(rFx)]=((1.)*1.)set ZA[(rFx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=jyo(rLx,z1,rbx)loop
exitwhen(rMx<q)call rfx(jYo(rLx,z1,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction JQo takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer rFx=rRx(0)
set K1[(rFx)]=((O2[oSx])*1.)
set ZA[(rFx)]=(I2[oSx])call rfx(R2[oSx],rFx)call rkx(((rFx)))endfunctionfunction Jso takes nothing returns booleanlocal integer rLx=(oPx(GetTriggerPlayer()))local integer oMxlocal integer oSxset If[rLx]=true
call Jqo(rLx)set oMx=O0x(rLx,A2)loop
exitwhen(oMx<q)set oSx=O6x(rLx,A2,oMx)call iDx(X2[oSx],E2[oSx],true,function JQo)set oMx=oMx-1endloopreturn trueendfunctionfunction JSo takes integer rLx returns nothinglocal integer rFx=rRx((cb[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset ZA[(rFx)]=(rLx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=jyo(rLx,H8v,rbx)
loop
exitwhen(rMx<q)call rfx(jYo(rLx,H8v,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction Jto takes nothing returns booleanlocal integer rLx=(oPx(GetTriggerPlayer()))local integer oMxlocal integer oSxset If[rLx]=falsecall JSo(rLx)set oMx=O0x(rLx,A2)loop
exitwhen(oMx<q)set oSx=O6x(rLx,A2,oMx)call ikx(X2[oSx])set oMx=oMx-1endloopreturn trueendfunctionfunction JTo takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(ZA[(rFx)])set If[rLx]=falsereturn trueendfunctionfunction Juo takes nothing returns nothingset N2=Xdx("FolderUser_FolderKeyEvent_StructUpArrow_Init: set FolderUser_FolderKeyEvent_StructUpArrow.DESTROY_EVENT = Event.Create(Event.DESTROY_EVENT_TYPE, EventPriority.HEADER, function FolderUser_FolderKeyEvent_StructUpArrow.Event_Destroy)",nI,bI,function JPo)set z1=(E3x())set H8v=(E3x())call jwo(XJx(function Jso),Ge,EVENT_PLAYER_ARROW_UP_DOWN)call jwo(XJx(function Jto),Ge,EVENT_PLAYER_ARROW_UP_UP)call gdx(gl,function JTo,w)endfunctionfunction JUo takes nothing returns nothingset FZ=(E3x())set H4v=XJx(function j8o)call jwo(H4v,Ge,EVENT_PLAYER_END_CINEMATIC)call JOo()call Jfo()call JLo()call Juo()endfunctionfunction Jwo takes nothing returns booleanlocal integer oSxlocal integer oMxset KA=(E3x())set Hvv=(E3x())set Hev=O5x()call jVo()call jRo()call jNo()call jbo()set oSx=jko("HumanRed",0,"ffff0000")
call jpo((oSx),(Byv))set oSx=jko("HumanBlue",1,"ff0000ff")call jpo((oSx),(Byv))set oSx=jko("HumanTeal",2,"ff18e7bd")call jpo((oSx),(Byv))set oSx=jko("HumanPurple",3,"ff520084")call jpo((oSx),(Byv))set oSx=jko("HumanYellow",4,"ffffff00")call jpo((oSx),(Byv))set oSx=jko("HumanOrange",5,"ffff8a08")call jpo((oSx),(Byv))set oSx=jko("HumanGreen",6,"ff18be00")call jpo((oSx),(Byv))set oSx=jko("Castle",7,"ffe759ad")set BYv=oSxcall jpo((oSx),(Byv))call StartCampaignAI(vx[oSx],Hyv)set oSx=jko("Dummy",8,"ff949694")set Jy=oSxcall jpo((oSx),(Hlv))set oSx=jko("Creeps",9,"ff7bbef7")set HYv=oSxcall jCo(oSx,PLAYER_COLOR_AQUA)call jpo((oSx),(HGv))set oSx=jko("Spawns",$A,"ff086142")set Hzv=oSxcall jCo(oSx,PLAYER_COLOR_BROWN)
call jpo((oSx),(HGv))set oSx=jko("Castle (controlable)",$B,"ffe759ad")set Bzv=oSxcall jCo(oSx,PLAYER_COLOR_PINK)call jpo((oSx),(Byv))set oSx=jko("Neutral aggressive",$C,"ff000000")set ex=oSxcall jpo((oSx),(HGv))call jLo(oSx,oSx,ALLIANCE_PASSIVE,false,false)set oSx=jko("Neutral passive",$F,"ff000000")
set HZv=oSxset Ge=w
set oMx=Jhloop
exitwhen(oMx<0)call jLo(Jy,kh[oMx],ALLIANCE_PASSIVE,true,true)if((BWv[(kh[oMx])])==Byv)thencall jLo(Bzv,kh[oMx],ALLIANCE_SHARED_ADVANCED_CONTROL,true,true)
call jLo(Bzv,kh[oMx],ALLIANCE_SHARED_CONTROL,true,true)endifset oMx=oMx-1endloopcall jPo(Jy,Bm)call jPo(Hzv,Bm)
call jLo(HYv,BYv,ALLIANCE_PASSIVE,true,true)
call jLo(HYv,Bzv,ALLIANCE_PASSIVE,true,true)
call jQo(XJx(function jUo),Ge,"",false)call j0o()call j5o()call j6o()call JUo()return trueendfunctionfunction JWo takes nothing returns booleancall joo(function Jwo,"User_Init")return trueendfunctionfunction Jyo takes nothing returns booleanset H9v=VXx(jvv)
return trueendfunctionfunction JYo takes integer oSx returns integerset jav[oSx]=trueset jnv[oSx]=falsecall rEx(H9v)return oSxendfunctionfunction Jzo takes nothing returns integerlocal integer oSxif(jxv==8190)thencall o_x("WeatherType_Allocation_allocCustom","call DebugEx(WeatherType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",jvv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(jov[(w)]==w)thenset jrv=jrv+1set oSx=jrvelse
set oSx=jov[(w)]
set jov[(w)]=jov[jov[(w)]]endifset jov[oSx]=Zset jiv[oSx]=1call JYo(oSx)return oSxendfunctionfunction JZo takes integer oqx returns integerlocal integer oSx=Jzo()set jVv[(oSx)]=(oqx)
return oSxendfunctionfunction J_o takes nothing returns booleanset jev=JZo('WMoo')return trueendfunctionfunction J0o takes nothing returns booleancall VNx(Ha,(function J_o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Header\\WeatherEffect.page\\WeatherEffect.struct\\obj_moonType_wc3weather.j"))
return trueendfunctionfunction J1o takes nothing returns booleanset jEv=VXx(jXv)
return trueendfunctionfunction J2o takes nothing returns nothingendfunctionfunction J3o takes integer oSx returns integerset jbv[oSx]=trueset jBv[oSx]=falsecall rEx(jEv)return oSxendfunctionfunction J4o takes nothing returns integerlocal integer oSxif(jRv==8190)thencall o_x("WeatherEffect_Allocation_allocCustom","call DebugEx(WeatherEffect.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",jXv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(jIv[(w)]==w)thenset jAv=jAv+1set oSx=jAvelse
set oSx=jIv[(w)]
set jIv[(w)]=jIv[jIv[(w)]]endifset jIv[oSx]=Zset jNv[oSx]=1call J3o(oSx)return oSxendfunctionfunction J5o takes integer jqo,integer rNx returns integerlocal integer oSx=J4o()set jcv[oSx]=AddWeatherEffect(bm[jqo],(jVv[(rNx)]))return oSxendfunctionfunction J6o takes nothing returns booleanlocal integer rFx=(bv)if iOx((ZA[(rFx)]))thencall EnableWeatherEffect(jcv[(jOv)],true)endifreturn trueendfunctionfunction J7o takes nothing returns booleanlocal integer rFx=(bv)set jOv=J5o(Bm,jev)call Dcx(Xdx("WeatherEffect_Event_Start: call Event.Create(AfterIntro.FOR_PLAYER_EVENT_TYPE, EventPriority.HEADER, function WeatherEffect.Event_AfterIntro).AddToStatics()",jCv,bI,function J6o))return trueendfunctionfunction J8o takes nothing returns booleancall J2o()call Dcx(Xdx("WeatherEffect_Init: call Event.Create(EventType.START, EventPriority.HEADER, function WeatherEffect.Event_Start).AddToStatics()",EE,bI,function J7o))return trueendfunctionfunction J9o takes nothing returns booleancall GDx(function J8o,"WeatherEffect_Init")return trueendfunctionfunction kvo takes nothing returns booleanset jdv=VXx(jDv)
return trueendfunctionfunction keo takes nothing returns booleanset jfv=VXx(jFv)
return trueendfunctionfunction kxo takes nothing returns booleanset jgv=VXx(jGv)
return trueendfunctionfunction koo takes nothing returns booleanset jhv=VXx(jHv)
return trueendfunctionfunction kro takes nothing returns booleanset jjv=VXx(jJv)
return trueendfunctionfunction kio takes nothing returns booleanset jkv=VXx(jKv)
return trueendfunctionfunction kao takes nothing returns booleanset jlv=VXx(jLv)
return trueendfunctionfunction kno takes nothing returns booleanset jmv=VXx(jMv)
return trueendfunctionfunction kVo takes code c,string rSx returns nothing
set GV=GV+1set hV[GV]=CreateTrigger()set HV[GV]=(GetHandleId(Condition((c))))
set jV[GV]=rSxcall TriggerAddCondition(hV[GV],Condition(c))endfunctionfunction kEo takes integer oSx,string o9x,string otx,integer oux returns boolean
local integer rvx=(YA+(rPx(lv[(E[((oSx))])],((o9x)),((otx)))))local integer oMx=rvxloop
exitwhen((rPx(lv[(E[((oSx))])],((o9x)),((otx)+I2S(YA+(oMx)+2))))==oux)set oMx=oMx-1endloopcall Xlx(lv[(E[(oSx)])],(o9x),(otx+I2S(YA+oMx+2)),((rPx(lv[(E[((oSx))])],((o9x)),((otx)+I2S(YA+(rvx)+2))))))
set rvx=rvx-1call Xlx(lv[(E[(oSx)])],(o9x),(otx),(rvx-YA))return(rvx==YA)endfunctionfunction kXo takes integer oSx,string oqx,integer XYx returns nothingcall kEo(X,(oqx),(I2S((((oA[(XYx)]))))),(XYx))endfunctionfunction kOo takes nothing returns nothingif not jsv thenreturnendifset jsv=falsecall ilx(jSv)call kXo(zA,"-rdy",jtv)call DCx(jTv)endfunctionfunction kRo takes integer oSx returns nothingif(oSx==w)thenreturnendifset jQv=wcall kOo()if(qe!=w)thencall aRx(qe)
endifendfunctionfunction kIo takes integer oSx returns nothingif jsv thencall kOo()endifset jsv=true
set jSv=iBx(OQx(H3v)+" type \"-rdy\" in order to start "+(juv[((oSx))]),Ge)set jUv=oSxcall Xyx(zA,"-rdy",jtv)call Dcx(jTv)endfunctionfunction kAo takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((jwv[(oSx)]))])]))],((((se[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction kNo takes nothing returns booleanlocal integer rFx=(bv)if(jQv!=w)thencall kRo(jQv)endifcall kIo((kAo((((jWv[(rFx)]))),jyv,(q))))return trueendfunctionfunction kbo takes integer oSx returns nothinglocal integer rFx=rRx(0)
local integer oMxlocal integer rbxlocal integer rMxset jWv[(rFx)]=(oSx)
set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((jPv))-1)*Iv+(((rbx))-1)))))))))
loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((jPv))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction kBo takes integer oSx returns nothingset jpv=wcall kbo(oSx)if jYv thenreturnendifendfunctionfunction kco takes integer oSx,integer kCo,integer rYx returns nothinglocal integer oMxif(oSx==Ge)thenset oMx=Jhloop
call kco(kh[oMx],kCo,rYx)set oMx=oMx-1exitwhen(oMx<0)endloopelse
call SetPlayerTechResearched(vx[oSx],kCo,rYx)endifendfunctionfunction kdo takes integer oSx returns nothinglocal integer rFx=rRx(0)
local integer oMxlocal integer rbxlocal integer rMxset jWv[(rFx)]=(oSx)
set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((jqv))-1)*Iv+(((rbx))-1)))))))))
loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((jqv))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction kDo takes integer oSx returns nothinglocal integer rYxif(jpv!=w)thencall kBo(jpv)endifset jpv=oSxset rYx=0if(oSx==jzv)then
set rYx=1elseif(oSx==jZv)then
set rYx=2elseif(oSx==j_v)then
set rYx=3elseif(oSx==j0v)then
set rYx=4elseif(oSx==j1v)then
set rYx=5elseif(oSx==j2v)then
set rYx=6endifcall ipx(Ge,"New Chapter begins: "+iSx((j3v[(oSx)]),"ffffcc00"),15.)
if(rYx>0)thencall kco(Ge,'R000',rYx)endifcall kdo(oSx)endfunctionfunction kfo takes nothing returns booleanlocal integer rFx=(bv)call Dcx(Xdx("Act_Event_Start: call Event.Create(Act.START_EVENT_TYPE, EventPriority.MISC, function LevelSet.Event_ActStart).AddToStatics()",jqv,lI,function kNo))call kDo(j4v)return trueendfunctionfunction kFo takes integer oSx returns integerset j9v[oSx]=trueset Jvv[oSx]=falseset Jev[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set Jxv[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(jmv)return oSxendfunctionfunction kgo takes nothing returns integerlocal integer oSxif(j5v==8190)thencall o_x("Act_Allocation_allocCustom","call DebugEx(Act.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",jMv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(j6v[(w)]==w)thenset j7v=j7v+1set oSx=j7velse
set oSx=j6v[(w)]
set j6v[(w)]=j6v[j6v[(w)]]endifset j6v[oSx]=Zset j8v[oSx]=1call kFo(oSx)return oSxendfunctionfunction kGo takes integer oSx returns booleanset Jov=Jov+1set Jrv[Jov]=oSx
set Jiv[oSx]=Jov+1return(Jov==0)endfunctionfunction kho takes integer oSx returns nothingset Jnv[(oSx)]=(JVv+oSx)
endfunctionfunction kHo takes string rSx returns integerlocal integer oSx=kgo()set j3v[(oSx)]=(rSx)
call kGo(oSx)if(Jov>F)thenset Jav[(Jrv[Jov-1])]=(oSx)endifcall kho(oSx)return oSxendfunctionfunction kjo takes integer oSx,integer otx,integer oux returns booleanreturn rux(jwv[(oSx)],(se[((oSx))]),otx,oux)
endfunctionfunction kJo takes nothing returns nothinglocal integer oSxset oSx=kHo("Penguin Prelude")set j4v=oSxset JEv[(oSx)]=(true)set JXv[(oSx)]=("X")
call kjo(((oSx)),jyv,(JOv))set oSx=kHo("Delightful disturbances")set jzv=oSxcall kjo(((oSx)),jyv,(JRv))call kjo(((oSx)),jyv,(JIv))call kjo(((oSx)),jyv,(JAv))call kjo(((oSx)),jyv,(JNv))set oSx=kHo("Dash into the fire")set jZv=oSxcall kjo(((oSx)),jyv,(Jbv))call kjo(((oSx)),jyv,(JBv))call kjo(((oSx)),jyv,(Jcv))call kjo(((oSx)),jyv,(JCv))set oSx=kHo("Return of the elves")set j_v=oSxset oSx=kHo("Desire beyond death")set j0v=oSxset oSx=kHo("The mourning mountain")
set j1v=oSxset oSx=kHo("The dragon's flight, Frozen in time")set j2v=oSxendfunctionfunction kko takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((jwv[(oSx)]))])]))],((((se[((oSx))])))),(((otx))))))
endfunctionfunction kKo takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((Jdv[(oSx)]))])]))],((((JDv[((oSx))])))),(((otx))))))endfunctionfunction klo takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((Jdv[(oSx)]))])]))],((((JDv[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction kLo takes nothing returns nothinglocal integer oMx=0local integer kmolocal integer kMolocal integer rMxlocal integer kpolocal integer kPolocal integer oSxloop
exitwhen(oMx>Jov)set kmo=wset kMo=Jrv[oMx]
set rMx=(kko(((kMo)),jyv))loop
exitwhen(rMx<q)set kpo=(kAo(((kMo)),jyv,(rMx)))
set kPo=(kKo(((kpo)),Jfv))loop
exitwhen(kPo<q)set oSx=(klo(((kpo)),Jfv,(kPo)))
set JFv[(oSx)]=(kpo)
set ue[(oSx)]=(kmo)set kmo=oSxset kPo=kPo-1endloopset rMx=rMx-1endloopset oMx=oMx+1endloopendfunctionfunction kqo takes nothing returns booleanset jpv=wset jPv=(E3x())set jqv=(E3x())call Dcx(Xdx("Act_Init: call Event.Create(EventType.START, EventPriority.HEADER, function Act.Event_Start).AddToStatics()",EE,bI,function kfo))set Aov[(lw)]=((1.)*1.)call kJo()call kLo()return trueendfunctionfunction kQo takes nothing returns booleancall kVo(function kqo,"Act_Init")return trueendfunctionfunction kso takes nothing returns booleanset Jgv=VXx(JGv)
return trueendfunctionfunction kSo takes code c,string rSx returns nothing
set JV=JV+1set kV[JV]=CreateTrigger()set KV[JV]=(GetHandleId(Condition((c))))
set lV[JV]=rSxcall TriggerAddCondition(kV[JV],Condition(c))endfunctionfunction kto takes integer oSx,integer jqo,integer Q7x returns nothingif(Q7x==w)thenset Q7x=GKendifset Q7x=Nao(SQ,Q7x)call GroupEnumUnitsInRect(kb[((oSx))],bm[(jqo)],Bv[(Q7x)])endfunctionfunction kTo takes integer rNx,code XCx returns nothinglocal integer Rex=O5x()set Hf=rNxcall kto(Rex,Bm,Bcv)
call ForGroup(kb[(Rex)],(XCx))call O9x(Rex)endfunctionfunction kuo takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=ROx()call Oqx(Iix,iSx("+"+(I2S(('d'))),"ff0000ff"),.032,60.,1.,2.5,(0))call BKx(Iix,'d')return trueendfunctionfunction kUo takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=ROx()call cax(Iix,$F)
return trueendfunctionfunction kwo takes nothing returns booleanlocal integer rFx=(bv)local integer kMo=(jWv[(rFx)])if(JEv[(kMo)])thenreturn trueendifcall kTo(hxv,function kuo)call kTo(GGv,function kUo)return trueendfunctionfunction kWo takes nothing returns booleancall Dcx(Xdx("ActUpgrades_Init: call Event.Create(Act.ENDING_EVENT_TYPE, EventPriority.MISC, function ActUpgrades.Event_ActEnding).AddToStatics()",jPv,lI,function kwo))
return trueendfunctionfunction kyo takes nothing returns booleancall kSo(function kWo,"ActUpgrades_Init")return trueendfunctionfunction kYo takes nothing returns booleanset Jhv=VXx(JHv)
return trueendfunctionfunction kzo takes code c,string rSx returns nothing
set IV=IV+1set AV[IV]=CreateTrigger()set NV[IV]=(GetHandleId(Condition((c))))
set bV[IV]=rSxcall TriggerAddCondition(AV[IV],Condition(c))endfunctionfunction kZo takes nothing returns booleanlocal integer oMx=Hl
set Jjv=(E3x())set jCv=(E3x())set JJv=NJx()loop
exitwhen(oMx<0)call ForceAddPlayer(LD[(JJv)],vx[(jl[oMx])])
set oMx=oMx-1endloopreturn trueendfunctionfunction k_o takes nothing returns booleancall kzo(function kZo,"AfterIntro_Init")
return trueendfunctionfunction k0o takes nothing returns booleanset Jkv=VXx(JKv)
return trueendfunctionfunction k1o takes code c,string rSx returns nothing
set BV=BV+1set cV[BV]=CreateTrigger()set CV[BV]=(GetHandleId(Condition((c))))
set dV[BV]=rSxcall TriggerAddCondition(cV[BV],Condition(c))endfunctionfunction k2o takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((jwv[(oSx)]))])]))],((((se[((oSx))])))),(((otx)))))
endfunctionfunction k3o takes integer k4o returns integerreturn k2o(k4o,Jpv)endfunctionfunction k5o takes integer oSx,real fvx returns nothingcall SetUnitScale(vJ[oSx],fvx,fvx,fvx)endfunctionfunction k6o takes integer oSx returns booleanset Cy=Cy+1set cy[Cy]=oSxset By[oSx]=Cy+1
return(Cy==0)endfunctionfunction k7o takes integer oSx,real oux returns nothingcall mNx(oSx,(py[(oSx)])+oux)endfunctionfunction k8o takes nothing returns nothinglocal integer oMx=Cy
local integer oSxloop
set oSx=cy[oMx]call k7o((oSx),JQv[oSx])
set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction k9o takes integer oSx,real Nlx returns nothingset JQv[oSx]=Nlx*Jsv
call Mix((oSx),by)if k6o(oSx)thencall iDx(Dy,Jsv,true,function k8o)endifendfunctionfunction Kvo takes integer Keo,real x,real y,boolean Kxo returns nothing
local playercolor Koo=(ox[(Hzv)])local real izx=(Nyv[(Keo)])local real iZx=(Nyv[(Keo)])local real i_x=(Nyv[(Keo)])local integer HAxif Kxo thenset HAx=JPvelse
set HAx=Jqvendifif(HAx!=w)thencall Mfx(HAx)endifset HAx=mDx(Ikv[Keo],x,y,X_x(x,y)+280.,kf)call k5o(HAx,1.5)call UnitAddAbility(vJ[(HAx)],'aLoc')call SetUnitColor(vJ[((HAx))],(Koo))
call k9o(HAx,Cf*1./ 3.)call mdx(HAx,izx,iZx,i_x,180.)if Kxo thenset JPv=HAxelse
set Jqv=HAxendifendfunctionfunction Kro takes nothing returns booleanlocal integer rFx=(bv)local integer k4o=(Qe[(rFx)])local integer Kio=k3o(k4o)if(Kio!=w)thencall Kvo((JSv[(Kio)]),Jlv,JLv,false)
endifset k4o=(ue[(k4o)])if(k4o!=w)thenset Kio=k3o(k4o)
if(Kio!=w)thencall Kvo((JSv[(Kio)]),Jmv,JMv,true)endifendifreturn trueendfunctionfunction Kao takes nothing returns booleanlocal integer rFx=(bv)call Dcx(Xdx("BrazierOracle_Event_Start: call Event.Create(Level.START_EVENT_TYPE, EventPriority.MISC2, function BrazierOracle.Event_LevelStart).AddToStatics()",We,LI,function Kro))return trueendfunctionfunction Kno takes nothing returns booleanlocal integer rFx=(bv)if(Jqv!=w)thencall Mfx(Jqv)endifif(JPv!=w)thencall Mfx(JPv)endifcall SetDoodadAnimationRect(bm[Bm],'D01K',"death",false)
call SetDoodadAnimationRect(bm[Bm],'D01M',"death",false)
return trueendfunctionfunction KVo takes nothing returns booleanlocal integer KEo=q2x(Yx)local integer KXo=q2x(zx)set Jlv=(tm[(KEo)])set JLv=(Tm[(KEo)])set Jmv=(tm[(KXo)])set JMv=(Tm[(KXo)])call Dcx(Xdx("BrazierOracle_Init: call Event.Create(EventType.START, EventPriority.MISC, function BrazierOracle.Event_Start).AddToStatics()",EE,lI,function Kao))call Dcx(Xdx("BrazierOracle_Init: call Event.Create(Meteorite.GAME_OVER_EVENT_TYPE, EventPriority.MISC, function BrazierOracle.Event_GameOver).AddToStatics()",Jtv,lI,function Kno))
return trueendfunctionfunction KOo takes nothing returns booleancall k1o(function KVo,"BrazierOracle_Init")return trueendfunctionfunction KRo takes nothing returns booleanset JTv=VXx(Juv)
return trueendfunctionfunction KIo takes nothing returns nothinglocal integer KAo=(kv[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetLocalPlayer())))))),((((R)))))))])if(KAo==w)thenreturnendifcall SetCameraQuickPosition((GetUnitX(C[((KAo))])),(GetUnitY(C[((KAo))])))endfunctionfunction KNo takes nothing returns booleanlocal integer rFx=(bv)call DCx(JUv)call iDx(iXx(),.035,true,function KIo)return trueendfunctionfunction Kbo takes nothing returns booleanset JUv=Xdx("CameraQuickPosition_Init: set CameraQuickPosition.PICK_EVENT = Event.Create(HeroSelection.DUMMY_EVENT_TYPE, EventPriority.MISC, function CameraQuickPosition.Event_HeroPick)",Jwv,lI,function KNo)call Dcx(JUv)return trueendfunctionfunction KBo takes nothing returns booleancall k1o(function Kbo,"CameraQuickPosition_Init")return trueendfunctionfunction Kco takes nothing returns booleanset JWv=Wwx('BMOP',"Mark of the Paw",'bMOP')
set uU[(JWv)]=(true)
set anv[(JWv)]=("ReplaceableTextures\\CommandButtons\\BTNBattleRoar.blp")call lWx(JWv,"Abilities\\Spells\\NightElf\\BattleRoar\\RoarTarget.mdl","overhead",ri)set WU=l_x()
call l2x(WU,nnv,1)call l3x(((JWv)),ZB+(1),(WU))return trueendfunctionfunction KCo takes nothing returns booleancall VNx(ma,(function Kco),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\CreepBuffs\\MarkOfThePaw.page\\MarkOfThePaw.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction Kdo takes nothing returns booleanset Jyv=VXx(JYv)
return trueendfunctionfunction KDo takes code c,string rSx returns nothing
set EV=EV+1set XV[EV]=CreateTrigger()set OV[EV]=(GetHandleId(Condition((c))))
set RV[EV]=rSxcall TriggerAddCondition(XV[EV],Condition(c))endfunctionfunction Kfo takes nothing returns booleanreturn trueendfunctionfunction KFo takes nothing returns booleancall KDo(function Kfo,"MarkOfThePaw_Init")return trueendfunctionfunction Kgo takes nothing returns booleanset Jzv=VXx(JZv)
return trueendfunctionfunction KGo takes nothing returns booleanset J_v=VXx(J0v)
return trueendfunctionfunction Kho takes nothing returns booleanset J1v=VXx(J2v)
return trueendfunctionfunction KHo takes nothing returns booleanset J3v=VXx(J4v)
return trueendfunctionfunction Kjo takes nothing returns booleanset J5v=VXx(J6v)
return trueendfunctionfunction KJo takes nothing returns booleanset J7v=VXx(J8v)
return trueendfunctionfunction Kko takes nothing returns booleanset J9v=VXx(kvv)
return trueendfunctionfunction KKo takes nothing returns booleanset kev=VXx(kxv)
return trueendfunctionfunction Klo takes nothing returns booleanset kov=VXx(krv)
return trueendfunctionfunction KLo takes nothing returns nothingendfunctionfunction Kmo takes integer oSx returns booleanif(((mq[((oSx))])>0)==false)then
return false
endifset mq[pq[Mq]]=mq[oSx]set pq[mq[oSx]-1]=pq[Mq]
set mq[oSx]=0set Mq=Mq-1return(Mq==F)endfunctionfunction KMo takes integer oSx,boolean oux returns nothinglocal boolean aCx=Jq[oSx]if(oux==aCx)then
returnendifset Jq[oSx]=ouxif oux thencall Kmo(oSx)else
call jix(oSx)endifendfunctionfunction Kpo takes integer oSx returns nothingset kOv[oSx]=falsecall rHx(tq)
endfunctionfunction KPo takes integer oSx returns nothingif(kEv[oSx]>0)thenreturnendifif(kXv[oSx]!=Z)thencall o_x("Ping_Allocation_deallocCustom_confirm","call DebugEx(Ping.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Tq+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset kXv[oSx]=kXv[(w)]set kXv[(w)]=oSx
call Kpo(oSx)endfunctionfunction Kqo takes integer oSx returns nothingset kEv[oSx]=kEv[oSx]-1call KPo(oSx)endfunctionfunction KQo takes integer oSx returns booleanlocal integer oLx=(kRv[(oSx)])set kRv[kIv[kAv]]=oLxset kIv[oLx-1]=kIv[kAv]set kRv[oSx]=0set kAv=kAv-1return(kAv==F)endfunctionfunction Kso takes integer oSx returns nothinglocal integer KSo=kVv[oSx]if(KSo!=w)thencall KMo(KSo,false)endifcall Kqo((oSx))if KQo(oSx)thencall ikx(Cq)
endifendfunctionfunction Kto takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])local integer oSx=osx(OSx,kav)local integer KTo=knv[oSx]call IRo(KTo,OSx)call rVx(OSx,kav)call RPx(OSx,kiv)if(dmx((KTo),Ob))thencall Kso(kNv[oSx])endifreturn trueendfunctionfunction Kuo takes integer oSx returns integerset kDv[oSx]=trueset kfv[oSx]=falsecall rEx(J1v)return oSxendfunctionfunction KUo takes nothing returns integerlocal integer oSxif(kBv==8190)thencall o_x("CreepLocation_Allocation_allocCustom","call DebugEx(CreepLocation.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",J2v+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(kcv[(w)]==w)thenset kCv=kCv+1set oSx=kCvelse
set oSx=kcv[(w)]
set kcv[(w)]=kcv[kcv[(w)]]endifset kcv[oSx]=Zset kdv[oSx]=1call Kuo(oSx)return oSxendfunctionfunction Kwo takes integer jqo returns integerlocal integer oSx=KUo()set knv[oSx]=Jbx("CreepLocation_Create: set this.currentUnitsGroup = UnitList.Create()")
set kFv[oSx]=jqo
return oSxendfunctionfunction KWo takes nothing returns nothingset kiv=Xdx("CreepLocation_Init: set CreepLocation.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function CreepLocation.Event_Death)",VP,lI,function Kto)set kbv=Kwo(q2x(co))
set kgv=Kwo(q2x(wx))
set kGv=Kwo(q2x(Bo))
set khv=Kwo(q2x(do))
set kHv=Kwo(q2x(Do))
set kjv=Kwo(q2x(Co))
endfunctionfunction Kyo takes nothing returns nothingendfunctionfunction KYo takes integer oSx returns integerset kOv[oSx]=trueset kmv[oSx]=falsecall rEx(tq)
return oSxendfunctionfunction Kzo takes nothing returns integerlocal integer oSxif(klv==8190)thencall o_x("Ping_Allocation_allocCustom","call DebugEx(Ping.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Tq+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(kXv[(w)]==w)thenset kLv=kLv+1set oSx=kLvelse
set oSx=kXv[(w)]
set kXv[(w)]=kXv[kXv[(w)]]endifset kXv[oSx]=Zset kEv[oSx]=1call KYo(oSx)return oSxendfunctionfunction KZo takes real x,real y,integer KSo returns integer
local integer oSx=Kzo()set kMv[oSx]=(Kq[(KSo)])
set kpv[oSx]=(lq[(KSo)])
set kPv[oSx]=(Lq[(KSo)])
set kVv[oSx]=KSo
set kqv[oSx]=xset kQv[oSx]=ycall KMo(KSo,true)return oSxendfunctionfunction K_o takes integer oSx returns nothinglocal integer KTo=knv[oSx]local integer OSxloop
set OSx=(OUx((KTo),Ob))exitwhen(OSx==w)
call Crx((OSx),w)endloopendfunctionfunction K0o takes real x,real y,integer izx,integer iZx,integer i_x,real iMx returns nothingcall PingMinimapEx(x,y,iMx,izx,iZx,i_x,false)endfunctionfunction K1o takes integer oSx returns nothingset kSv[oSx]=truecall K0o(kqv[oSx],kQv[oSx],kMv[oSx],kpv[oSx],kPv[oSx],5.)endfunctionfunction K2o takes integer oSx returns booleanset kAv=kAv+1set kIv[kAv]=oSx
set kRv[oSx]=kAv+1return(kAv==0)endfunctionfunction K3o takes nothing returns nothinglocal integer oMx=kAvlocal integer oSxloop
set oSx=kIv[oMx]
if kSv[oSx]thencall K0o(kqv[oSx],kQv[oSx],kMv[oSx],kpv[oSx],kPv[oSx],5.)endifset oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction K4o takes integer oSx returns nothingif K2o(oSx)thencall iDx(Cq,5.,true,function K3o)endifendfunctionfunction K5o takes integer oSx,integer K6o returns nothingset kNv[oSx]=K6o
call K1o(K6o)call K4o(K6o)endfunctionfunction K7o takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((ktv[(oSx)]))])]))],((((kTv[((oSx))])))),(((otx))))))endfunctionfunction K8o takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((ktv[(oSx)]))])]))],((((kTv[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction K9o takes integer oSx,integer OSx returns nothingcall rwx(OSx,kav,oSx)call Avx(OSx,kiv)call dQx(knv[oSx],OSx)endfunctionfunction lvo takes integer oSx,real addX,real addY returns integerlocal integer o7x=bOx(kUv[oSx],HYv,kwv[oSx],kWv[oSx],kyv[oSx])local integer leo=kYv[oSx]if(leo!=w)thencall Rgo(o7x,leo)endifreturn o7xendfunctionfunction lxo takes integer oSx returns nothinglocal integer loo=(kKv[(oSx)])local integer lro=(pq[(GetRandomInt(((0)),((Mq))))])
local real lio=(tm[(kFv[(loo)])])local real lao=(Tm[(kFv[(loo)])])local integer K6o=KZo(lio,lao,lro)local integer oMxlocal integer lnocall K_o(loo)if(lro==w)thencall ipx(Ge,iSx((ksv[(oSx)]),"ffffcc00")+" has/have spawned.",10.)else
call ipx(Ge,iSx((ksv[(oSx)]),"ffffcc00")+" has/have spawned at the "+(kq[(lro)])+" spot.",10.)endifcall K5o(loo,K6o)set oMx=K7o(oSx,kuv)
loop
set lno=K8o(oSx,kuv,oMx)
call K9o(loo,lvo(lno,lio,lao))set oMx=oMx-1exitwhen(oMx<q)endloopendfunctionfunction lVo takes nothing returns booleanlocal integer rFx=(bv)local integer k4o=(Qe[(rFx)])local integer oMx=kko(k4o,kkv)loop
call lxo((kAo(k4o,kkv,oMx)))
set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction lEo takes nothing returns booleanlocal integer rFx=(bv)local integer k4o=(ue[((Qe[(rFx)]))])local integer rvxlocal integer oMxlocal string lXo
if(k4o==w)thenreturn trueendifset rvx=kko(k4o,kkv)
if(rvx<q)thenreturn trueendifset oMx=rvxset lXo=""loop
if(oMx!=rvx)then
if(oMx==q)thenset lXo=lXo+" and "else
set lXo=lXo+", "
endifendifset lXo=lXo+iSx((ksv[((kAo(k4o,kkv,oMx)))]),"ffffcc00")set oMx=oMx-1exitwhen(oMx<q)endloopcall ipx(Ge,iSx("Notification:","ffffcc00")+" Next level features the creeps "+lXo+".",10.)return trueendfunctionfunction lOo takes integer oSx returns integerset k1v[oSx]=trueset k2v[oSx]=falseset ktv[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set k3v[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(kov)return oSxendfunctionfunction lRo takes nothing returns integerlocal integer oSxif(kzv==8190)thencall o_x("CreepSet_Allocation_allocCustom","call DebugEx(CreepSet.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",krv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(kZv[(w)]==w)thenset k_v=k_v+1set oSx=k_velse
set oSx=kZv[(w)]
set kZv[(w)]=kZv[kZv[(w)]]endifset kZv[oSx]=Zset k0v[oSx]=1call lOo(oSx)return oSxendfunctionfunction lIo takes integer oSx returns nothingset kTv[(oSx)]=(k4v+oSx)
endfunctionfunction lAo takes string rSx,integer loo returns integerlocal integer oSx=lRo()set kKv[(oSx)]=(loo)
set ksv[(oSx)]=(rSx)
call lIo(oSx)return oSxendfunctionfunction lNo takes integer oSx,integer otx,integer oux returns booleanreturn rux(ktv[(oSx)],(kTv[((oSx))]),otx,oux)endfunctionfunction lbo takes integer oSx returns integerset Kvv[oSx]=trueset Kev[oSx]=falsecall rEx(J_v)return oSxendfunctionfunction lBo takes nothing returns integerlocal integer oSxif(k6v==8190)thencall o_x("Creep_Allocation_allocCustom","call DebugEx(Creep.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",J0v+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(k7v[(w)]==w)thenset k8v=k8v+1set oSx=k8velse
set oSx=k7v[(w)]
set k7v[(w)]=k7v[k7v[(w)]]endifset k7v[oSx]=Zset k9v[oSx]=1call lbo(oSx)return oSxendfunctionfunction lco takes integer lCo,unit ldo returns integerlocal real bex=Nh*GetUnitFacing(ldo)
local real x=GetUnitX(ldo)local real y=GetUnitY(ldo)local integer oSxcall MDx(ldo)set oSx=lBo()set kyv[oSx]=bex
set kYv[oSx]=wset kUv[oSx]=lCo
set kwv[oSx]=xset kWv[oSx]=yreturn oSxendfunctionfunction lDo takes integer oSx,integer XYx returns nothingif(Te[oSx]==w)thencall o_x("FolderLevel_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oSx)+";"+(jA[(XYx)]))set Te[oSx]=Xendifcall rux(Te[oSx],(se[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction lfo takes integer oSx,integer k4o returns nothingif kjo(k4o,kkv,oSx)thencall lDo(k4o,kJv)endifendfunctionfunction lFo takes nothing returns booleanlocal integer oSxcall KLo()call KWo()call Kyo()set kJv=Xdx("CreepSet_Init: set CreepSet.LEVEL_START_EVENT = Event.Create(Level.START_EVENT_TYPE, EventPriority.MISC, function CreepSet.Event_LevelStart)",We,lI,function lVo)call Dcx(Xdx("CreepSet_Init: call Event.Create(Level.START_EVENT_TYPE, EventPriority.MISC, function CreepSet.Event_Warning_LevelStart).AddToStatics()",We,lI,function lEo))set oSx=lAo("Blue Dragon Spawns",kbv)set k5v=oSxcall lNo((oSx),kuv,(lco(G9v,Xr)))call lNo((oSx),kuv,(lco(G9v,gr)))call lNo((oSx),kuv,(lco(GIv,Ar)))call lNo((oSx),kuv,(lco(GIv,Cr)))call lfo(oSx,Kxv)set oSx=lAo("Furbolg Mother",kgv)set Kov=oSxcall lNo((oSx),kuv,(lco(g9v,Br)))call lNo((oSx),kuv,(lco(gNv,fr)))call lNo((oSx),kuv,(lco(gNv,Fr)))call lfo(oSx,Krv)set oSx=lAo("Kobolds",kjv)set Kiv=oSxcall lNo((oSx),kuv,(lco(hvv,Nr)))call lNo((oSx),kuv,(lco(hvv,Hr)))call lNo((oSx),kuv,(lco(Ggv,dr)))call lNo((oSx),kuv,(lco(Ggv,Dr)))call lfo(oSx,Krv)set oSx=lAo("Pandarenes",kGv)set Kav=oSxcall lNo((oSx),kuv,(lco(Ghv,Er)))call lNo((oSx),kuv,(lco(Ghv,Rr)))call lfo(oSx,Krv)set oSx=lAo("Treants",kHv)set Kiv=oSxcall lNo((oSx),kuv,(lco(hVv,Jr)))call lNo((oSx),kuv,(lco(hVv,kr)))call lNo((oSx),kuv,(lco(Gev,jr)))call lfo(oSx,Krv)set oSx=lAo("Wolves",khv)set Knv=oSxcall lNo((oSx),kuv,(lco(hEv,Ir)))call lNo((oSx),kuv,(lco(hEv,hr)))call lNo((oSx),kuv,(lco(Gov,Gr)))call lfo(oSx,Krv)return trueendfunctionfunction lgo takes nothing returns booleancall kSo(function lFo,"CreepSet_Init")return trueendfunctionfunction lGo takes nothing returns booleanset KVv=VXx(KEv)
return trueendfunctionfunction lho takes nothing returns booleanset KXv=VXx(KOv)
return trueendfunctionfunction lHo takes nothing returns booleanset KRv=VXx(KIv)
return trueendfunctionfunction ljo takes nothing returns booleanset KAv=VXx(KNv)
return trueendfunctionfunction lJo takes nothing returns booleanset Kbv=VXx(KBv)
return trueendfunctionfunction lko takes nothing returns booleanset Kcv=VXx(KCv)
return trueendfunctionfunction lKo takes nothing returns booleanset Kdv=VXx(KDv)
return trueendfunctionfunction llo takes nothing returns booleanset Kfv=VXx(KFv)
return trueendfunctionfunction lLo takes nothing returns booleanset Kgv=VXx(KGv)
return trueendfunctionfunction lmo takes nothing returns booleanset Khv=VXx(KHv)
return trueendfunctionfunction lMo takes nothing returns booleanset Kjv=VXx(KJv)
return trueendfunctionfunction lpo takes nothing returns booleanset Kkv=VXx(KKv)
return trueendfunctionfunction lPo takes nothing returns booleanset Klv=VXx(KLv)
return trueendfunctionfunction lqo takes nothing returns booleanset Kmv=VXx(KMv)
return trueendfunctionfunction lQo takes nothing returns booleanset Kpv=VXx(KPv)
return trueendfunctionfunction lso takes nothing returns booleanset Kqv=VXx(KQv)
return trueendfunctionfunction lSo takes nothing returns booleanset Ksv=VXx(KSv)
return trueendfunctionfunction lto takes nothing returns booleanset Ktv=VXx(KTv)
return trueendfunctionfunction lTo takes nothing returns booleanset Kuv=VXx(KUv)
return trueendfunctionfunction luo takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((KYv[(oSx)]))])]))],((((Kzv[((oSx))])))),(((otx))))))endfunctionfunction lUo takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((KYv[(oSx)]))])]))],((((Kzv[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction lwo takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((K2v[(oSx)]))])]))],((((K3v[((oSx))])))),(((otx))))))endfunctionfunction lWo takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((K2v[(oSx)]))])]))],((((K3v[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction lyo takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((K7v[oSx]))])]))],((((K6v[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))endfunctionfunction lYo takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((K7v[oSx]))])]))],((((K6v[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))endfunctionfunction lzo takes integer rNx,integer OSx returns nothinglocal integer rFx=rRx(0)
local integer GPxlocal integer oMxlocal integer rbxlocal integer rMxset K5v[(rFx)]=(rNx)
set Vv[(rFx)]=(OSx)set GPx=rRx((K6v[(rNx)]))set K5v[(GPx)]=(rNx)
set Vv[(GPx)]=(OSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((KWv))-1)*Iv+(((rbx))-1)))))))))
loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((KWv))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset rMx=lyo(rNx,KWv,rbx)
loop
exitwhen(rMx<q)call rfx(lYo(rNx,KWv,rbx,rMx),GPx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call rkx(((GPx)))endfunctionfunction lZo takes integer rNx,integer l_o,real x,real y,real bex returns integerlocal integer l0o=bOx(l_o,BYv,x,y,bex)call GroupAddUnit(kb[(Kwv)],C[(l0o)])call lzo(rNx,l0o)return l0oendfunctionfunction l1o takes integer oSx returns realreturn(GetRandomReal((((wm[(oSx)]))*1.),(((um[(oSx)]))*1.)))
endfunctionfunction l2o takes integer oSx returns realreturn(GetRandomReal((((Wm[(oSx)]))*1.),(((Um[(oSx)]))*1.)))
endfunctionfunction l3o takes integer oSx returns nothinglocal integer o0x=K_v[oSx]local integer Iix=K0v[oSx]local real jMx=(tm[(K1v[(o0x)])])local real jpx=(Tm[(K1v[(o0x)])])local integer rvx=lwo(oSx,K4v)local integer Rex=O5x()local integer oMx=qlocal integer rNxloop
exitwhen(oMx>rvx)set rNx=lWo(oSx,K4v,oMx)
call GroupAddUnit(kb[(Rex)],C[(lZo(rNx,(K8v[(rNx)]),jMx,jpx,kf))])set oMx=oMx+1endloopcall GroupPointOrderById(kb[((Rex))],pb[(bw)],(((l1o(K1v[(Iix)])))*1.),(((l2o(K1v[(Iix)])))*1.))
call O9x(Rex)endfunctionfunction l4o takes integer oSx returns nothinglocal integer rLx=oSxlocal integer rvx=luo(rLx,KZv)local integer oMx=qlocal integer l5oloop
exitwhen(oMx>rvx)set l5o=lUo(rLx,KZv,oMx)
call l3o(l5o)set oMx=oMx+1endloopendfunctionfunction l6o takes nothing returns booleanlocal integer rFx=(bv)local integer l7o=(k2o(((Qe[(rFx)])),Kyv))call l4o((l7o))return trueendfunctionfunction l8o takes nothing returns booleanlocal integer rFx=(bv)call Dcx(Xdx("DefenderSpawn_Event_Start: call Event.Create(Level.START_EVENT_TYPE, EventPriority.MISC, function DefenderSpawn.Event_LevelStart).AddToStatics()",We,lI,function l6o))
return trueendfunctionfunction l9o takes integer oSx returns integerset lrv[oSx]=trueset liv[oSx]=falsecall rEx(KVv)return oSxendfunctionfunction Lvo takes nothing returns integerlocal integer oSxif(lvv==8190)thencall o_x("DefenderSpawnLocation_Allocation_allocCustom","call DebugEx(DefenderSpawnLocation.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",KEv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(lev[(w)]==w)thenset lxv=lxv+1set oSx=lxvelse
set oSx=lev[(w)]
set lev[(w)]=lev[lev[(w)]]endifset lev[oSx]=Zset lov[oSx]=1call l9o(oSx)return oSxendfunctionfunction Leo takes integer oSx returns booleanset lav=lav+1set lnv[lav]=oSx
set lVv[oSx]=lav+1return(lav==0)endfunctionfunction Lxo takes integer o0x returns integerlocal integer oSx=Lvo()set K1v[oSx]=o0x
call Leo(oSx)return oSxendfunctionfunction Loo takes nothing returns nothingset K9v=Lxo(q2x(go))
set lEv=Lxo(q2x(Ho))
set lXv=Lxo(q2x(Go))
set lOv=Lxo(q2x(ho))
endfunctionfunction Lro takes integer oSx returns integerset lbv[oSx]=trueset lBv[oSx]=falseset lcv[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set K7v[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(Kdv)return oSxendfunctionfunction Lio takes nothing returns integerlocal integer oSxif(lRv==8190)thencall o_x("DefenderSpawnType_Allocation_allocCustom","call DebugEx(DefenderSpawnType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",KDv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(lIv[(w)]==w)thenset lAv=lAv+1set oSx=lAvelse
set oSx=lIv[(w)]
set lIv[(w)]=lIv[lIv[(w)]]endifset lIv[oSx]=Zset lNv[oSx]=1call Lro(oSx)return oSxendfunctionfunction Lao takes integer oSx returns booleanset lCv=lCv+1set ldv[lCv]=oSx
set lDv[oSx]=lCv+1return(lCv==0)endfunctionfunction Lno takes integer oSx returns nothingset K6v[(oSx)]=(lfv+oSx)
endfunctionfunction LVo takes integer lCo returns integerlocal integer oSx=Lio()set K8v[(oSx)]=(lCo)
call Lao(oSx)call Lno(oSx)return oSxendfunctionfunction LEo takes nothing returns nothinglocal integer oSxset oSx=LVo(GXv)
set oSx=LVo(GXv)
set oSx=LVo(GXv)
set lFv=oSxset oSx=LVo(hhv)
set oSx=LVo(hhv)
set oSx=LVo(hhv)
set lgv=oSxendfunctionfunction LXo takes integer oSx returns integerset lKv[oSx]=trueset llv[oSx]=falseset KYv[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])call rEx(Ktv)return oSxendfunctionfunction LOo takes nothing returns integerlocal integer oSxif(lHv==8190)thencall o_x("DefenderSpawnWave_Allocation_allocCustom","call DebugEx(DefenderSpawnWave.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",KTv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(ljv[(w)]==w)thenset lJv=lJv+1set oSx=lJvelse
set oSx=ljv[(w)]
set ljv[(w)]=ljv[ljv[(w)]]endifset ljv[oSx]=Zset lkv[oSx]=1call LXo(oSx)return oSxendfunctionfunction LRo takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((jwv[(oSx)]))])]))],((((se[((oSx))])))),(((otx))),(((oux))))endfunctionfunction LIo takes integer oSx,integer oux returns nothingset lLv[oSx]=oux
call LRo(oux,Kyv,oSx)endfunctionfunction LAo takes integer oSx returns nothingset Kzv[(oSx)]=(lMv+oSx)
endfunctionfunction LNo takes integer k4o returns integerlocal integer oSx=LOo()call LIo(oSx,k4o)set lmv[(oSx)]=((20.)*1.)call LAo(oSx)return oSxendfunctionfunction Lbo takes integer oSx returns integerset lsv[oSx]=trueset lSv[oSx]=falseset K2v[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])call rEx(Kkv)return oSxendfunctionfunction LBo takes nothing returns integerlocal integer oSxif(lpv==8190)thencall o_x("DefenderSpawnGroup_Allocation_allocCustom","call DebugEx(DefenderSpawnGroup.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",KKv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(lPv[(w)]==w)thenset lqv=lqv+1set oSx=lqvelse
set oSx=lPv[(w)]
set lPv[(w)]=lPv[lPv[(w)]]endifset lPv[oSx]=Zset lQv[oSx]=1call Lbo(oSx)return oSxendfunctionfunction Lco takes integer oSx returns nothingset K3v[(oSx)]=(ltv+oSx)
endfunctionfunction LCo takes integer o0x,integer Iix returns integerlocal integer oSx=LBo()set K_v[(oSx)]=(o0x)
set K0v[(oSx)]=(Iix)
call Lco(oSx)return oSxendfunctionfunction Ldo takes integer oSx,integer otx,integer oux returns booleanreturn lUx(K2v[(oSx)],(K3v[((oSx))]),otx,oux)endfunctionfunction LDo takes integer oSx,integer otx,integer oux returns booleanreturn rux(KYv[(oSx)],(Kzv[((oSx))]),otx,oux)endfunctionfunction Lfo takes nothing returns nothinglocal integer oMx=lGvlocal integer thisTypeIndexlocal integer LFolocal integer oSxlocal integer l5oloop
exitwhen(oMx<0)set LFo=ye[oMx]if not(lhv[(LFo)])thenset oSx=LNo(LFo)
set l5o=LCo(K9v,lXv)
call Ldo((l5o),K4v,(lgv))call Ldo((l5o),K4v,(lgv))call Ldo((l5o),K4v,(lFv))call LDo(((oSx)),KZv,(l5o))set l5o=LCo(K9v,lOv)
call Ldo((l5o),K4v,(lgv))call Ldo((l5o),K4v,(lgv))call Ldo((l5o),K4v,(lFv))call LDo(((oSx)),KZv,(l5o))set l5o=LCo(K9v,lEv)
call Ldo((l5o),K4v,(lgv))call Ldo((l5o),K4v,(lgv))call Ldo((l5o),K4v,(lFv))call LDo(((oSx)),KZv,(l5o))endifset oMx=oMx-1endloopendfunctionfunction Lgo takes nothing returns booleanset Kwv=O5x()set KWv=(E3x())call Dcx(Xdx("DefenderSpawn_Init: call Event.Create(EventType.START, EventPriority.MISC, function DefenderSpawn.Event_Start).AddToStatics()",EE,lI,function l8o))call Loo()call LEo()call Lfo()return trueendfunctionfunction LGo takes nothing returns booleancall kSo(function Lgo,"DefenderSpawn_Init")return trueendfunctionfunction Lho takes nothing returns booleanset lTv=VXx(luv)
return trueendfunctionfunction LHo takes nothing returns booleanreturn trueendfunctionfunction Ljo takes nothing returns booleanset lUv=VXx(lwv)
return trueendfunctionfunction LJo takes nothing returns booleanlocal integer Iix=jhx()if((kv[((ze[(Iix)]))])!=Iix)then
return false
endifif I9x(Iix,Qc)thenreturn false
endifif((BWv[((ze[(Iix)]))])!=Byv)thenreturn false
endifreturn truereturn trueendfunctionfunction Lko takes integer oSx,integer id,real oux returns integerlocal integer njo=(LoadInteger(o[((V[(E[((X))])]))],(((EN))),((((id))))))if(njo==w)thenset njo=ccx(null,.02,(GetUnitX(C[((oSx))])),(GetUnitY(C[((oSx))])),fYx(oSx)+Opx(oSx,true),id)set dN[(njo)]=((oux)*1.)
else
set dN[(njo)]=(((dN[(njo)])+oux)*1.)
endifreturn njoendfunctionfunction LKo takes integer Iix,real o5x returns nothinglocal integer Lloif I9x(Iix,Qc)thenreturnendifif I9x(Iix,Ifv)thenreturnendifif I9x(Iix,Igv)thenreturnendifif I9x(Iix,Ijv)thenreturnendifif(o5x<=0)thenreturnendifcall Ryx((ACx((Iix),(lYv),(lzv),(ri))))set Llo=Lko(Iix,lZv+Iix,o5x)
call X9x(Llo,iSx("+"+(I2S(((R2I((((dN[(Llo)]))*1.)))))),"ffd45e19"),.02)
call cjx(Iix,o5x)call BNx(Iix,o5x)call IDo(Iix,o5x)endfunctionfunction LLo takes integer oSx,integer OSx returns booleanreturn IsUnitInGroup(C[OSx],kb[oSx])
endfunctionfunction Lmo takes integer oSx,real oux returns nothingcall bfx(oSx,(pf[(oSx)])+oux)endfunctionfunction LMo takes integer Iix,real nZx returns nothinglocal integer Llo=Lko(Iix,l_v+Iix,nZx)call X9x(Llo,iSx("+"+(I2S(((R2I((((dN[(Llo)]))*1.)))))),"ff8b008b"),.02)
call Lmo(Iix,nZx)endfunctionfunction Lpo takes nothing returns booleanlocal integer rFx=(bv)local integer cfx=(fG[(rFx)])local integer NBolocal integer OSxlocal real nZxlocal integer LPolocal real Lqolocal real LQolocal integer Iixif(cfx==w)thenreturn trueendifset NBo=(ze[(cfx)])set OSx=(Vv[(rFx)])if(IsUnitAlly(C[(OSx)],vx[(NBo)]))thenreturn trueendifif((BWv[(NBo)])!=Byv)thenreturn trueendifset nZx=(Niv[((Tf[(OSx)]))])
call LKo(cfx,nZx)set cfx=(kv[(NBo)])call NVo(lWv,(GetUnitX(C[((OSx))])),(GetUnitY(C[((OSx))])),1000.,lyv)set LPo=(NIo((lWv)))
if(cfx==w)thenset Lqo=.0else
set Lqo=.4-.05*LPoendifif(LPo<=0)thenset LQo=.0else
set LQo=(1.-Lqo)*1./ LPo
endifif(cfx!=w)thenif LLo(lWv,cfx)thencall LMo(cfx,(LQo+Lqo)*nZx)call GroupRemoveUnit(kb[(lWv)],C[(cfx)])
else
call LMo(cfx,Lqo*nZx)endifendifset Iix=NEo(lWv)
if(Iix!=w)thenloop
call LMo(Iix,LQo*nZx)set Iix=NEo(lWv)
exitwhen(Iix==w)
endloopendifreturn trueendfunctionfunction Lso takes integer cfx,integer OSx returns integerreturn(R2I((((Nav[(OSx)]))*1.)))
endfunctionfunction LSo takes integer oSx,playerstate Cfx,integer oux returns nothingcall Chx(oSx,Cfx,(GetPlayerState(vx[((oSx))],(Cfx)))+oux)endfunctionfunction Lto takes integer oSx,string icx,real Ovx,integer id,boolean LTo,boolean OPx returns integerlocal real x=(GetUnitX(C[((oSx))]))local real y=(GetUnitY(C[((oSx))]))local real z=OMx(oSx,x,y)if LTo thenset z=z+Opx(oSx,OPx)
endifif OPx thenset Ovx=Ovx*(eb[(oSx)])endifreturn ccx(icx,Ovx,x,y,z,id)
endfunctionfunction Luo takes nothing returns booleanlocal integer rFx=(bv)local integer cfx=(fG[(rFx)])local integer OSx=(Vv[(rFx)])local integer NBolocal integer LUoif(cfx==w)thenreturn trueendifif((BWv[((ze[(OSx)]))])!=HGv)thenreturn trueendifset NBo=(ze[(cfx)])if((BWv[(NBo)])!=Byv)thenreturn trueendifif(NBo==BYv)then
return trueendifset LUo=(R2I(((Lso(cfx,OSx)*l0v)*1.)))if(LUo<=0)thenreturn trueendifcall LSo(NBo,PLAYER_STATE_RESOURCE_GOLD,LUo)
if(LUo>(Nnv[((Tf[(OSx)]))]))then
call Lto(OSx,iSx("+"+(I2S((LUo))),"ffffcc00"),1.15*rb,(0),false,false)else
call Lto(OSx,iSx("+"+(I2S((LUo))),"ffffcc00"),1.*rb,(0),false,false)
endifreturn trueendfunctionfunction Lwo takes nothing returns booleanset lWv=O5x()set lyv=Xpx(function LJo)call Dcx(Xdx("Drop_Init: call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function Drop.Exp_Event_Death).AddToStatics()",VP,lI,function Lpo))call Dcx(Xdx("Drop_Init: call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function Drop.Supply_Event_Death).AddToStatics()",VP,lI,function Luo))return trueendfunctionfunction LWo takes nothing returns booleancall kzo(function Lwo,"Drop_Init")return trueendfunctionfunction Lyo takes integer oSx returns integerset l6v[oSx]=trueset l7v[oSx]=falseset cH[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set Hv[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(E6)
return oSxendfunctionfunction LYo takes nothing returns integerlocal integer oSxif(l2v==8190)thencall o_x("Spell_Allocation_allocCustom","call DebugEx(Spell.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",X6+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(l3v[(w)]==w)thenset l4v=l4v+1set oSx=l4velse
set oSx=l3v[(w)]
set l3v[(w)]=l3v[l3v[(w)]]endifset l3v[oSx]=Zset l5v[oSx]=1call Lyo(oSx)return oSxendfunctionfunction Lzo takes integer oSx returns nothingset Ev[(oSx)]=(Lvv+oSx)endfunctionfunction LZo takes integer oSx returns booleanset mJ=mJ+1set MJ[mJ]=oSxset Lev[oSx]=mJ+1return(mJ==0)endfunctionfunction L_o takes string rSx returns integerlocal integer oSx=LYo()set m6[oSx]=0set l8v[(oSx)]=(false)set TH[(oSx)]=(rSx)call Lzo(oSx)call XLx((TH[(oSx)]),mv,oSx)
call LZo(oSx)return oSxendfunctionfunction L0o takes integer oqx returns integerlocal integer oSx=L_o(GetObjectName(oqx))set B[oSx]=oqxcall SaveInteger(o[((V[(E[((X))])]))],(((oqx))),(((mv))),(((oSx))))return oSxendfunctionfunction L1o takes integer oSx,integer otx,real oux returns nothingcall SaveReal(o[((V[(E[((cH[(oSx)]))])]))],((((Ev[((oSx))])))),(((otx))),((((((oux)*1.))*1.))*1.))endfunctionfunction L2o takes nothing returns booleancall L1x('AVia',false)set l1v=L0o('AVia')set K6[(l1v)]=(h6)set m6[(l1v)]=(1)set TH[(l1v)]=("Eternal Vial")set Rh[(l1v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Aj))))))set oxv[(l1v)]=(0)set x3v[(l1v)]=("spell")
call L1o((l1v),GH+(1),((60)*1.))
call L1o((l1v),Lov+(1),((750)*1.))return trueendfunctionfunction L3o takes integer oSx returns integerset LEv[oSx]=trueset LXv[oSx]=falseset lS[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set sh[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(At)
return oSxendfunctionfunction L4o takes nothing returns integerlocal integer oSxif(Liv==8190)thencall o_x("ItemType_Allocation_allocCustom","call DebugEx(ItemType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Nt+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Lav[(w)]==w)thenset Lnv=Lnv+1set oSx=Lnvelse
set oSx=Lav[(w)]
set Lav[(w)]=Lav[Lav[(w)]]endifset Lav[oSx]=Zset LVv[oSx]=1call L3o(oSx)return oSxendfunctionfunction L5o takes integer oSx returns nothingset Ph[(oSx)]=(LRv+oSx)endfunctionfunction L6o takes integer oqx returns integerlocal integer oSx=L4o()set Hh[oSx]=oqxcall SaveInteger(o[((V[(E[((X))])]))],(((oqx))),(((KS))),(((oSx))))call L5o(oSx)set sS[((oSx))]=(0)set fh[((oSx))]=(0)return oSxendfunctionfunction L7o takes integer oSx,integer otx,integer oux returns booleanreturn rux(lS[(oSx)],(Ph[((oSx))]),otx,oux)endfunctionfunction L8o takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((lS[(oSx)]))])]))],((((Ph[((oSx))])))),(((otx))),(((oux))))endfunctionfunction L9o takes integer oSx,integer rlx,integer rYx returns nothingcall L7o((oSx),mS,rlx)call L8o((oSx),PS+rlx,rYx)endfunctionfunction mvo takes nothing returns booleanset Lrv=L6o('IVia')set LIv[(Lrv)]=("ReplaceableTextures\\CommandButtons\\BTNVialFull.blp")set fh[(Lrv)]=(50)call L9o((Lrv),(l1v),1)return trueendfunctionfunction meo takes nothing returns booleancall VNx(Pa,(function L2o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\EternalVial.page\\EternalVial.struct\\obj_thisSpell_wc3spell.j"))call VNx(Qa,(function mvo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\EternalVial.page\\EternalVial.struct\\obj_thisItem_wc3item.j"))return trueendfunctionfunction mxo takes nothing returns booleanset LAv=VXx(LNv)
return trueendfunctionfunction moo takes code c,string rSx returns nothing
set Dn=Dn+1set fn[Dn]=CreateTrigger()set Fn[Dn]=(GetHandleId(Condition((c))))
set gn[Dn]=rSxcall TriggerAddCondition(fn[Dn],Condition(c))endfunctionfunction mro takes integer oSx,integer XYx returns nothingif(Hv[oSx]==w)thencall o_x("FolderSpell_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oSx)+";"+(jA[(XYx)]))set Hv[oSx]=Xendifcall rux(Hv[oSx],(Ev[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction mio takes integer oSx,integer Iix,real nZx returns nothinglocal integer nFo=rRx((A[(Iix)]))local integer oMxlocal integer rbxlocal integer rMxset LCv[(nFo)]=((nZx)*1.)set Vv[(nFo)]=(Iix)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(Iix,BCv,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(Iix,BCv,rbx,rMx),nFo)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((nFo)))endfunctionfunction mao takes integer oSx,integer Iix,real nZx returns nothinglocal integer Lloif(nZx<1.)thenreturnendifset nZx=nZx*nBo(-(zF[(oSx)]))*(ITv[(Iix)])*(GetRandomReal(((.9)*1.),((1.1)*1.)))
set Llo=Lko(Iix,Lcv+Iix,nZx)
call X9x(Llo,iSx("+"+(I2S(((R2I((((dN[(Llo)]))*1.)))))),"ff00c800"),.02)
call cjx(Iix,nZx)call mio(oSx,Iix,nZx)endfunctionfunction mno takes integer oSx,integer Iix,real nZx returns nothinglocal integer Lloif(nZx<1.)thenreturnendifset Llo=Lko(Iix,LDv+Iix,nZx)
call X9x(Llo,iSx("+"+(I2S(((R2I((((dN[(Llo)]))*1.)))))),"ffaa55ff"),.02)
call BNx(Iix,nZx)endfunctionfunction mVo takes integer oSx,integer Iix,real nZx returns nothinglocal integer Lloif(nZx<1.)thenreturnendifset Llo=Lko(Iix,LFv+Iix,nZx)
call X9x(Llo,iSx("+"+(I2S(((R2I((((dN[(Llo)]))*1.)))))),"ffffff00"),.02)
call IDo(Iix,nZx)endfunctionfunction mEo takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])call Ryx((ACx((Cqx),(Lbv),(LBv),(ri))))call mao(Cqx,Cqx,Ldv*(rG[(Cqx)]))call mno(Cqx,Cqx,Lfv*(LF[(Cqx)]))call mVo(Cqx,Cqx,Lgv*(NTv[(Cqx)]))return trueendfunctionfunction mXo takes nothing returns booleancall mro(l1v,Xdx("EternalVial_Init: call EternalVial.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function EternalVial.Event_SpellEffect))",ih,KI,function mEo))return trueendfunctionfunction mOo takes nothing returns booleancall moo(function mXo,"EternalVial_Init")return trueendfunctionfunction mRo takes nothing returns booleanreturn trueendfunctionfunction mIo takes nothing returns booleanset LGv=VXx(Lhv)
return trueendfunctionfunction mAo takes integer oSx,integer XYx returns nothingif(Am[oSx]==w)thencall o_x("FolderDestructable_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oSx)+";"+(jA[(XYx)]))set Am[oSx]=Xendifcall rux(Am[oSx],(Rm[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction mNo takes nothing returns booleanlocal integer rFx=(bv)call mAo((Im[(rFx)]),Ljv)return trueendfunctionfunction mbo takes integer oSx returns integerset LLv[oSx]=trueset Lmv[oSx]=falsecall rEx(LGv)return oSxendfunctionfunction mBo takes nothing returns integerlocal integer oSxif(LJv==8190)thencall o_x("Explosive_Allocation_allocCustom","call DebugEx(Explosive.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Lhv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Lkv[(w)]==w)thenset LKv=LKv+1set oSx=LKvelse
set oSx=Lkv[(w)]
set Lkv[(w)]=Lkv[Lkv[(w)]]endifset Lkv[oSx]=Zset Llv[oSx]=1call mbo(oSx)return oSxendfunctionfunction mco takes integer oSx returns nothingset LLv[oSx]=falsecall rHx(LGv)endfunctionfunction mCo takes integer oSx returns nothingif(Llv[oSx]>0)thenreturnendifif(Lkv[oSx]!=Z)thencall o_x("Explosive_Allocation_deallocCustom_confirm","call DebugEx(Explosive.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Lhv+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Lkv[oSx]=Lkv[(w)]set Lkv[(w)]=oSx
call mco(oSx)endfunctionfunction mdo takes integer oSx returns nothingset Llv[oSx]=Llv[oSx]-1call mCo(oSx)endfunctionfunction mDo takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((LSv[oSx]))])])],((((Ltv[((oSx))])))))
endfunctionfunction mfo takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((LTv[oSx]))])])],((((Ltv[((oSx))])))))
endfunctionfunction mFo takes integer oSx returns nothingset Lsv[oSx]=falsecall mDo((oSx))call mfo(((oSx)))call rHx(Hp)
endfunctionfunction mgo takes integer oSx returns nothingif(Lqv[oSx]>0)thenreturnendifif(LQv[oSx]!=Z)thencall o_x("SpotEffect_Allocation_deallocCustom_confirm","call DebugEx(SpotEffect.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",jp+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset LQv[oSx]=LQv[(w)]set LQv[(w)]=oSx
call mFo(oSx)endfunctionfunction mGo takes integer oSx returns nothingset Lqv[oSx]=Lqv[oSx]-1call mgo(oSx)endfunctionfunction mho takes integer oSx returns nothinglocal effect oqx=LPv[oSx]call mGo((oSx))if(oqx!=null)thencall DestroyEffect(oqx)set oqx=null
endifendfunctionfunction mHo takes integer oSx returns integerset Lsv[oSx]=trueset Lwv[oSx]=falseset LSv[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set LTv[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(Hp)
return oSxendfunctionfunction mjo takes nothing returns integerlocal integer oSxif(Luv==8190)thencall o_x("SpotEffect_Allocation_allocCustom","call DebugEx(SpotEffect.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",jp+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(LQv[(w)]==w)thenset LUv=LUv+1set oSx=LUvelse
set oSx=LQv[(w)]
set LQv[(w)]=LQv[LQv[(w)]]endifset LQv[oSx]=Zset Lqv[oSx]=1call mHo(oSx)return oSxendfunctionfunction mJo takes integer oSx returns nothingset LPv[oSx]=AddSpecialEffect(itx(ci>=LWv[oSx],Lyv[oSx]),LYv[oSx],Lzv[oSx])endfunctionfunction mko takes real x,real y,string ANx,integer rYx returns integerlocal integer oSx=mjo()set LWv[oSx]=rYx
set Lyv[oSx]=ANx
set LYv[oSx]=xset Lzv[oSx]=ycall mJo(oSx)return oSxendfunctionfunction mKo takes integer oSx,real x,real y returns integer
local integer XLo=NEo((oSx))
local real mlolocal integer NRolocal boolean mLolocal real mmoif(XLo==w)thenreturn w
endifset mLo=falseloop
set mmo=GZx(Dsx(XLo)-x,Dtx(XLo)-y)call GroupAddUnit(kb[(yQ)],C[(XLo)])
if not mLo thenset mlo=mmoset NRo=XLoset mLo=true
elseif(mmo<mlo)thenset mlo=mmoset NRo=XLoendifset XLo=NEo((oSx))exitwhen(XLo==w)
endloopcall NXo((oSx),yQ)return NRoendfunctionfunction mMo takes real x,real y,real O4o,code XCx returns nothingcall SetRect(bm[(lm)],((x-O4o)*1.),((y-O4o)*1.),((x+O4o)*1.),((y+O4o)*1.))set Ff=x
set gf=y
set Gf=O4o*O4ocall EnumDestructablesInRect(bm[lm],Bv[Zm],XCx)endfunctionfunction mpo takes integer oSx,real oux returns nothingcall SetDestructableLife(Gm[((oSx))],(((GetDestructableLife(Gm[((oSx))]))-oux)*1.))endfunctionfunction mPo takes nothing returns booleanlocal integer rFx=(bv)call mpo((GGx(GetEnumDestructable())),200.)return trueendfunctionfunction mqo takes nothing returns nothinglocal integer Okx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(Okx)])local integer Iixlocal real mQolocal real Nbocall mdo((oSx))call iKx(Okx)call mho((mko(((LMv[oSx])*1.),((Lpv[oSx])*1.),(LZv),(ri))))call NVo(L_v,LMv[oSx],Lpv[oSx],300.,L0v)
set Iix=(mKo((L_v),((LMv[oSx])*1.),((Lpv[oSx])*1.)))
if(Iix!=w)thenset mQo=900.
loop
exitwhen(mQo==0)
set Nbo=iUx(200.,(oG[(Iix)]))call GroupRemoveUnit(kb[(L_v)],C[(Iix)])
set mQo=mQo-Nbocall ngo(Iix,Nbo)set Iix=(mKo((L_v),((LMv[oSx])*1.),((Lpv[oSx])*1.)))
exitwhen(Iix==w)
endloopendifcall mMo(LMv[oSx],Lpv[oSx],300.,function mPo)endfunctionfunction mso takes nothing returns booleanlocal integer rFx=(bv)local integer mSo=(Im[(rFx)])local integer oSx=mBo()local integer Okx=iXx()local real x=(hm[(mSo)])
local real y=(Hm[(mSo)])
set LMv[oSx]=xset Lpv[oSx]=yset ge[(Okx)]=(oSx)call G7x(mSo,Ljv)call iDx(Okx,.35,false,function mqo)
return trueendfunctionfunction mto takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif ndo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction mTo takes integer oSx,integer XYx returns nothingif(fL[oSx]==w)thencall o_x("FolderDestructableType_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oSx)+";"+(jA[(XYx)]))set fL[oSx]=Xendifcall rux(fL[oSx],(HL[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction muo takes nothing returns booleanset LHv=Xdx("Explosive_Init: set Explosive.CREATE_EVENT = Event.Create(Destructable.CREATE_EVENT_TYPE, EventPriority.MISC, function Explosive.Event_Create)",Vm,lI,function mNo)
set Ljv=Xdx("Explosive_Init: set Explosive.DEATH_EVENT = Event.Create(Destructable.DEATH_EVENT_TYPE, EventPriority.MISC, function Explosive.Event_Death)",Em,lI,function mso)set L_v=O5x()set L0v=Xpx(function mto)call mTo(JL,LHv)
call mTo(IL,LHv)
return trueendfunctionfunction mUo takes nothing returns booleancall kzo(function muo,"Explosive_Init")return trueendfunctionfunction mwo takes nothing returns booleanset L1v=hjo('uGaC')call hJo(((L1v)),ASv,(Igv))set Uj[(L1v)]=((1.5)*1.)
set NOv[(L1v)]=(('x')*1.)set NWv[(L1v)]=((60)*1.)
set I8v[(L1v)]=((0)*1.)set Anv[(L1v)]=(3)set Nmv[(L1v)]=((150000.)*1.)set NLv[(L1v)]=((150000.)*1.)set NKv[(L1v)]=((0)*1.)set Ncv[(L1v)]=((500)*1.)set Nbv[(L1v)]=((500)*1.)set Auv[(L1v)]=((0)*1.)set AUv[(L1v)]=((0)*1.)set AYv[(L1v)]=(0)set A_v[(L1v)]=(0)call hpo((L1v),(gtv),1)return trueendfunctionfunction mWo takes nothing returns booleancall VNx(sa,(function mwo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\obj_shop_wc3unit.j"))return trueendfunctionfunction myo takes nothing returns booleanset L2v=VXx(L3v)
return trueendfunctionfunction mYo takes nothing returns booleanset L4v=L6o('IBoS')set LIv[(L4v)]=("ReplaceableTextures\\CommandButtons\\BTNGolemStormBolt.blp")call L9o((L4v),(L5v),1)return trueendfunctionfunction mzo takes nothing returns booleancall L1x('ABoS',false)set L5v=L0o('ABoS')set K6[(L5v)]=(h6)set m6[(L5v)]=(1)set TH[(L5v)]=("Boomerang Stone")set Rh[(L5v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0278)))),(((Aj))))))set oxv[(L5v)]=(4)set x3v[(L5v)]=("spell")
call L1o((L5v),GH+(1),(($A)*1.))
call L1o((L5v),tH+(1),((50)*1.))
call L1o((L5v),Lov+(1),((650)*1.))return trueendfunctionfunction mZo takes nothing returns booleancall VNx(Qa,(function mYo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act1.pack\\BoomerangStone.page\\BoomerangStone.struct\\obj_thisItem_wc3item.j"))
call VNx(Pa,(function mzo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act1.pack\\BoomerangStone.page\\BoomerangStone.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction m_o takes nothing returns booleanset L6v=VXx(L7v)
return trueendfunctionfunction m0o takes code c,string rSx returns nothing
set en=en+1set xn[en]=CreateTrigger()set on[en]=(GetHandleId(Condition((c))))
set rn[en]=rSxcall TriggerAddCondition(xn[en],Condition(c))endfunctionfunction m1o takes integer oSx returns integerset mxv[oSx]=trueset mov[oSx]=falseset mrv[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set xz[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(wY)
return oSxendfunctionfunction m2o takes nothing returns integerlocal integer oSxif(L8v==8190)thencall o_x("Missile_Allocation_allocCustom","call DebugEx(Missile.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",WY+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(L9v[(w)]==w)thenset mvv=mvv+1set oSx=mvvelse
set oSx=L9v[(w)]
set L9v[(w)]=L9v[L9v[(w)]]endifset L9v[oSx]=Zset mev[oSx]=1call m1o(oSx)return oSxendfunctionfunction m3o takes integer oSx,real x,real y,real z returns nothingset mnv[oSx]=xset mVv[oSx]=x*mEvset mXv[oSx]=yset mOv[oSx]=y*mEvset mRv[oSx]=zset mIv[oSx]=z*mEvendfunctionfunction m4o takes integer oSx,real oux returns nothingset mav[oSx]=oux
call m3o(oSx,oux,.0,.0)endfunctionfunction m5o takes integer oSx returns nothingset mAv[oSx]=.0set mNv[oSx]=.0set mbv[oSx]=.0set mBv[oSx]=.0set mcv[(oSx)]=((.0)*1.)
endfunctionfunction m6o takes integer oSx returns nothingset mdv[oSx]=falseset bz[oSx]=wendfunctionfunction m7o takes integer oSx returns nothingset oz[(oSx)]=(mfv+oSx)endfunctionfunction m8o takes integer oSx returns nothingset mFv[oSx]=wset mgv[oSx]=wendfunctionfunction m9o takes integer oSx returns nothingset mGv[oSx]=wset mhv[oSx]=wset mHv[((oSx))]=((.0)*1.)set mjv[((oSx))]=((.0)*1.)set mJv[((oSx))]=((.0)*1.)endfunctionfunction Mvo takes integer oSx,real x,real y,real z returns nothinglocal real d=gHx(x,y,z)local real bLxif mKv[oSx]thenif(d>0)thenif(d<mkv[oSx])thenset bLx=mkv[oSx]
set x=x*1./ d*bLxset y=y*1./ d*bLxset z=z*1./ d*bLxendifelse
set bLx=mkv[oSx]
if(bLx==0)thenset x=.0
set y=.0
set z=.0
else
returnendifendifendifset mLv[oSx]=dset mmv[oSx]=xset mMv[oSx]=x*mEvset mpv[oSx]=yset mPv[oSx]=y*mEvset mqv[oSx]=zset mQv[oSx]=z*mEvendfunctionfunction Meo takes integer oSx,real oux returns nothingif(oux<mkv[oSx])then
set oux=mkv[oSx]
endifset mLv[oSx]=oux
call Mvo(oSx,oux,.0,.0)endfunctionfunction Mxo takes integer oSx returns nothingset mkv[oSx]=.0set mKv[oSx]=falseset mlv[oSx]=.0call Meo(oSx,.0)
endfunctionfunction Moo takes nothing returns integerlocal integer oSx=m2o()set miv[oSx]=falsecall m4o((oSx),.0)call m5o(oSx)set Ez[(oSx)]=wset mCv[((oSx))]=((.0)*1.)call m6o(oSx)call m7o(oSx)call m8o(oSx)call m9o(oSx)call Mxo(oSx)return oSxendfunctionfunction Mro takes integer oSx returns integerset muv[oSx]=trueset mUv[oSx]=falsecall rEx(L6v)return oSxendfunctionfunction Mio takes nothing returns integerlocal integer oSxif(msv==8190)thencall o_x("BoomerangStone_Allocation_allocCustom","call DebugEx(BoomerangStone.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",L7v+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(mSv[(w)]==w)thenset mtv=mtv+1set oSx=mtvelse
set oSx=mSv[(w)]
set mSv[(w)]=mSv[mSv[(w)]]endifset mSv[oSx]=Zset mTv[oSx]=1call Mro(oSx)return oSxendfunctionfunction Mao takes integer oSx returns realreturn(Atan2((((mYv[(oSx)]))*1.),(((mzv[(oSx)]))*1.)))endfunctionfunction Mno takes integer oSx,integer id,real fvx returns integerlocal real MVolocal integer ouxif mdv[oSx]thenset MVo=myv[oSx]
else
set MVo=Mao((oSx))endifset oux=mDx(id,(mHv[((oSx))]),(mjv[((oSx))]),(mJv[((oSx))]),MVo)
call Max(oSx,oux)call mCx(oux,fvx)return ouxendfunctionfunction MEo takes integer Iix returns booleanreturn( not(I9x(Iix,Qc)))and( not(I9x(Iix,Igv)))and( not(ndo(Iix)))and( not(IsUnitAlly(C[(Iix)],vx[(hf)])))endfunctionfunction MXo takes integer oSx returns nothingset muv[oSx]=falsecall rHx(L6v)endfunctionfunction MOo takes integer oSx returns nothingif(mTv[oSx]>0)thenreturnendifif(mSv[oSx]!=Z)thencall o_x("BoomerangStone_Allocation_deallocCustom_confirm","call DebugEx(BoomerangStone.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",L7v+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset mSv[oSx]=mSv[(w)]set mSv[(w)]=oSx
call MXo(oSx)endfunctionfunction MRo takes integer oSx returns nothingset mTv[oSx]=mTv[oSx]-1call MOo(oSx)endfunctionfunction MIo takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((xz[oSx]))])]))],((((oz[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))endfunctionfunction MAo takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((xz[oSx]))])]))],((((oz[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))endfunctionfunction MNo takes integer oSx returns nothinglocal integer rFx=rRx((oz[(oSx)]))local integer oMxlocal integer rbxlocal integer rMxset ez[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=MIo(oSx,YY,rbx)loop
exitwhen(rMx<q)call rfx(MAo(oSx,YY,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction Mbo takes integer oSx returns nothingif miv[oSx]thenset miv[oSx]=falsecall MNo(oSx)endifendfunctionfunction MBo takes integer oSx returns nothinglocal integer rFx=rRx((oz[(oSx)]))local integer oMxlocal integer rbxlocal integer rMxset ez[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=MIo(oSx,yY,rbx)loop
exitwhen(rMx<q)call rfx(MAo(oSx,yY,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction Mco takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((mrv[oSx]))])])],((((oz[((oSx))])))))endfunctionfunction MCo takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((xz[oSx]))])])],((((oz[((oSx))])))))endfunctionfunction Mdo takes integer oSx returns nothingset mxv[oSx]=falsecall Mco((oSx))call MCo(((oSx)))call rHx(wY)
endfunctionfunction MDo takes integer oSx returns nothingif(mev[oSx]>0)thenreturnendifif(L9v[oSx]!=Z)thencall o_x("Missile_Allocation_deallocCustom_confirm","call DebugEx(Missile.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",WY+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset L9v[oSx]=L9v[(w)]set L9v[(w)]=oSx
call Mdo(oSx)endfunctionfunction Mfo takes integer oSx returns nothingset mev[oSx]=mev[oSx]-1call MDo(oSx)endfunctionfunction MFo takes integer oSx returns nothingcall Mbo(oSx)call MBo(oSx)call Mfo((oSx))endfunctionfunction Mgo takes integer Cqx returns booleanreturn( not(I9x(Cqx,Qc)))endfunctionfunction MGo takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=mwv[oSx]call MRo((oSx))call MFo(Mho)if Mgo(Cqx)thenendifreturn trueendfunctionfunction MHo takes integer oSx,real dVx,real dEx,real MQx returns nothingif miv[oSx]thencall Mbo(oSx)endifset miv[oSx]=trueset m1v[(oSx)]=((dVx)*1.)set m2v[(oSx)]=((dEx)*1.)set m3v[(oSx)]=((MQx)*1.)endfunctionfunction Mjo takes integer oSx returns realreturn jKx((mHv[(oSx)])-(m1v[(oSx)]),(mjv[(oSx)])-(m2v[(oSx)]))endfunctionfunction MJo takes integer oSx returns nothinglocal real NKx=Mjo((oSx))local real Nlx=(mmv[((oSx))])local real iMx=Nkx(NKx,Nlx,(mnv[((oSx))]))local real NLxif(iMx==.0)thenset mAv[oSx]=.0set mNv[oSx]=.0set mbv[oSx]=.0set mBv[oSx]=.0set m5v[oSx]=(mHv[((oSx))])set m6v[oSx]=(mjv[((oSx))])returnendifset mNv[oSx]=NKx
set NKx=NKx*(Tan((((((mcv[(oSx)]))*1.))*1.)))set Nlx=NKx*1./ iMxset NLx=-2*Nlx*1./ iMxset mAv[oSx]=NLx
set mbv[oSx]=iMx
set mBv[oSx]=Nlx
set m5v[oSx]=(mHv[((oSx))])set m6v[oSx]=(mjv[((oSx))])endfunctionfunction Mko takes integer oSx returns booleanif((qz[((oSx))])>0)thenreturn false
endifset sz=sz+1set Qz[sz]=oSxset qz[oSx]=sz+1
return(sz==0)endfunctionfunction MKo takes nothing returns nothinglocal integer oMx=sz
loop
exitwhen(oMx<0)set m7v[oMx]=Qz[oMx]
set oMx=oMx-1endloopset m8v=szendfunctionfunction Mlo takes nothing returns integerlocal integer o7xif(m8v<0)thenreturn w
endifset o7x=m7v[0]set m7v[0]=m7v[m8v]set m8v=m8v-1return o7xendfunctionfunction MLo takes integer oSx,real x,real y,real z returns nothingcall DQx(oSx,x)call DSx(oSx,y)call mBx(oSx,x,y,z)endfunctionfunction Mmo takes integer oSx returns reallocal real NKx=jKx((m1v[((oSx))])-m5v[oSx],(m2v[((oSx))])-m6v[oSx])local real iMxlocal real MMolocal real Mpoif(NKx==.0)thenreturn .0endifset iMx=mbv[oSx]
if(iMx==.0)thenreturn .0endifset MMo=blx(jKx((mHv[((oSx))])-m5v[oSx],(mjv[((oSx))])-m6v[oSx])*1./ NKx,0,1)set Mpo=(1-MMo)*iMxreturn((mAv[oSx]*1./ 2)*Mpo*Mpo+mBv[oSx]*Mpo)endfunctionfunction MPo takes integer oSx,real x,real y,real z returns nothingset Od=oSxset Mxv=xset Mov=yset Mrv=zcall TriggerEvaluate(Miv)endfunctionfunction Mqo takes integer oSx,boolean OPx returns realif OPx thenreturn(NEv[oSx]*(eb[((oSx))]))endifreturn NEv[oSx]endfunctionfunction MQo takes integer oSx,boolean OPx returns realif OPx thenreturn(NXv[oSx]*(eb[((oSx))]))endifreturn NXv[oSx]endfunctionfunction Mso takes integer oSx,integer Iix,real C9x,real dvx,real MSo returns nothingcall MPo(oSx,Dsx(Iix)+Mqo(Iix,true)+C9x,Dtx(Iix)+MQo(Iix,true)+dvx,fYx(Iix)+K2x(Iix,true)+MSo)endfunctionfunction Mto takes integer oSx,integer Iix returns nothingcall Mso(oSx,Iix,.0,.0,.0)endfunctionfunction MTo takes integer oSx,integer Iix returns nothinglocal integer Muo=mgv[oSx]local integer rFx=rRx((oz[((oSx))]))
set mgv[oSx]=wcall Mto((oSx),Iix)set mgv[oSx]=Muo
set ez[(rFx)]=(oSx)set Vv[(rFx)]=(Iix)set bv=(rFx)
call rDx(mFv[oSx])call rkx(((rFx)))endfunctionfunction MUo takes integer oSx,real x,real y,real z returns nothinglocal integer HAx=(bz[((oSx))])local integer Mwo=(mgv[((oSx))])
local integer MWolocal integer rFxset mHv[(oSx)]=((x)*1.)set mjv[(oSx)]=((y)*1.)set mJv[(oSx)]=((z)*1.)if(HAx!=w)thencall MLo(HAx,x,y,z+Mmo((oSx)))endifif(Mwo!=w)thenset rFx=rRx(0)set ez[(rFx)]=(oSx)set bv=(rFx)
call NVo(zz,x,y,(mCv[((oSx))]),Mwo)call rkx(((rFx)))set MWo=(adx(FirstOfGroup(kb[(zz)])))if(MWo!=w)thencall MTo((oSx),MWo)endifendifif(mhv[oSx]!=w)thenset rFx=rRx(0)set ez[(rFx)]=(oSx)set bv=(rFx)
call NVo(zz,x,y,(mCv[((oSx))]),mhv[oSx])
set MWo=NEo(zz)if(MWo!=w)thenloop
set bv=(rFx)
set Vv[(rFx)]=(MWo)call rDx(mGv[oSx])set MWo=NEo(zz)exitwhen(MWo==w)
endloopendifcall rkx(((rFx)))endifendfunctionfunction Myo takes integer oSx,real x,real y,real z returns nothinglocal integer Muo=mgv[oSx]local integer rFx=rRx((oz[((oSx))]))
set mgv[oSx]=wcall MUo((oSx),x,y,z)set mgv[oSx]=Muo
set ez[(rFx)]=(oSx)set Vv[(rFx)]=(w)set bv=(rFx)
call rDx(mFv[oSx])call rkx(((rFx)))endfunctionfunction MYo takes integer oSx,integer Mzo returns nothinglocal integer rFx=rRx((oz[((oSx))]))
local integer oMxlocal integer rbxlocal integer rMxset ez[(rFx)]=(oSx)set lz[(rFx)]=(Mzo)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=MIo((oSx),ZY,rbx)loop
exitwhen(rMx<q)call rfx(MAo((oSx),ZY,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction MZo takes integer oSx returns nothinglocal integer o5x=(bz[(oSx)])if(o5x!=w)thenif mdv[oSx]thenelse
call mNx(o5x,Mao((oSx)))
endifendifendfunctionfunction M_o takes integer oSx,real dX,real dY,real dZ returns nothinglocal real d=gHx(dX,dY,dZ)set mzv[(oSx)]=((dX*1./ d)*1.)set mYv[(oSx)]=((dY*1./ d)*1.)set Mav[(oSx)]=((dZ*1./ d)*1.)call MZo((oSx))endfunctionfunction M0o takes integer oSx,real x,real y,real z returns nothingcall Mvo(oSx,(mmv[(oSx)])+x,(mpv[(oSx)])+y,(mqv[(oSx)])+z)endfunctionfunction M1o takes integer oSx,real x,real y,real z returns nothingcall MUo(oSx,(mHv[(oSx)])+x,(mjv[(oSx)])+y,(mJv[(oSx)])+z)endfunctionfunction M2o takes nothing returns nothinglocal integer oSxlocal integer M3olocal real M4olocal real M5olocal real OLxlocal real x
local real y
local real z
local integer Iixlocal real dVxlocal real dExlocal real MQxlocal real dXlocal real dYlocal real dZlocal real d
call MKo()loop
set oSx=Mlo()exitwhen(oSx==w)
set M3o=Kz[oSx]set M4o=(mMv[((oSx))])set M5o=(mPv[((oSx))])set OLx=(mQv[((oSx))])set x=(mHv[((oSx))])
set y=(mjv[((oSx))])
set z=(mJv[((oSx))])
set Iix=tz[oSx]if(M3o!=w)thenset dVx=(m9v[(M3o)])
set dEx=(Mvv[(M3o)])
set MQx=(Mev[(M3o)])
elseif(Iix==w)thenset dVx=Tz[oSx]set dEx=Uz[oSx]set MQx=Wz[oSx]else
set dVx=Dsx(Iix)+uz[oSx]
set dEx=Dtx(Iix)+wz[oSx]
set MQx=OMx(Iix,dVx,dEx)+K2x(Iix,true)+yz[oSx]endifset dX=dVx-x
set dY=dEx-y
set dZ=MQx-z
set d=gHx(dX,dY,dZ)if(d<M4o+(mCv[((oSx))]))then
if(M3o==w)thencall MMx(oSx,Iix)if(Iix==w)thencall Myo((oSx),dVx,dEx,MQx)else
call MTo((oSx),Iix)endifelse
set Kz[oSx]=(pKx(Ez[((oSx))],(M3o)))
call MYo(((oSx)),(M3o))endifelse
set dX=dX*1./ dset dY=dY*1./ dset dZ=dZ*1./ dcall M_o((oSx),dX,dY,dZ)
call M0o((oSx),(mVv[((oSx))]),(mOv[((oSx))]),(mIv[((oSx))]))
call M1o((oSx),M4o*dX,M4o*dY,M4o*dZ)
endifendloopendfunctionfunction M6o takes integer oSx,integer Iix,real C9x,real dvx,real MSo,code M7o returns nothingcall MHo((oSx),Dsx(Iix)+C9x,Dtx(Iix)+dvx,fYx(Iix)+K2x(Iix,true)+MSo)
set m4v[oSx]=m4v[oSx]set Kz[oSx]=(rz[(Ez[((oSx))])])set uz[oSx]=C9xset wz[oSx]=dvxset yz[oSx]=MSoset tz[oSx]=Iixset Yz[oSx]=Xkx(M7o)
if rUx(Iix,Mz,oSx)thencall Avx(Iix,pz)
call Avx(Iix,Pz)
call A_o(Iix)endifcall Mox((oSx),kz)call Mox((oSx),Lz)call MJo((oSx))if Mko(oSx)thencall iDx(Sz,mEv,true,function M2o)endifendfunctionfunction M8o takes nothing returns booleanlocal integer rFx=(bv)call MFo((ez[(rFx)]))return trueendfunctionfunction M9o takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=mwv[oSx]local integer Iix=mWv[oSx]set hf=(ze[(Cqx)])if MEo(Iix)thencall Nbx((Iix),(Xwv),(1),w,((m_v)*1.))call nlo((Cqx),(Iix),((m0v)*1.),(false),(false))
endifset mFv[(Mho)]=Xkx((function MGo))call Meo(Mho,1100.)call M6o((Mho),(Cqx),.0,.0,.0,(function M8o))call Khx(Cqx)return trueendfunctionfunction pvo takes integer oSx,boolean OPx returns realif OPx thenreturn(NUv[oSx]*(eb[((oSx))]))endifreturn NUv[oSx]endfunctionfunction peo takes integer oSx,boolean OPx returns realif OPx thenreturn(Nwv[oSx]*(eb[((oSx))]))endifreturn Nwv[oSx]endfunctionfunction pxo takes integer oSx,integer o0x returns nothinglocal real bex=UGx(o0x)local real pqx=pvo(o0x,true)
local real oyx=peo(o0x,true)
local real x=Dsx(o0x)+oyx*(Cos(((((bex)*1.))*1.)))+pqx*(Cos(((((bex-Bev)*1.))*1.)))local real y=Dtx(o0x)+oyx*(Sin(((((bex)*1.))*1.)))+pqx*(Sin(((((bex-Bev)*1.))*1.)))local real z=fYx(o0x)+Opx(o0x,true)call MUo(oSx,x,y,z)endfunctionfunction poo takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer Mho=Moo()local integer Iix=(zH[(rFx)])local integer oSx=Mio()set mwv[oSx]=Cqx
set mWv[oSx]=Iix
call A_o(Cqx)set mCv[(Mho)]=((10.)*1.)call Mno(Mho,'qBoS',2.)set mFv[(Mho)]=Xkx((function M9o))set mZv[(Mho)]=(oSx)
call Meo(Mho,1250.)call pxo(Mho,Cqx)call M6o((Mho),(Iix),.0,.0,.0,(function M8o))return trueendfunctionfunction pro takes nothing returns booleancall mro(L5v,Xdx("BoomerangStone_Init: call BoomerangStone.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BoomerangStone.Event_SpellEffect))",ih,MI,function poo))return trueendfunctionfunction pio takes nothing returns booleancall m0o(function pro,"BoomerangStone_Init")
return trueendfunctionfunction pao takes nothing returns booleanset Mnv=L6o('IMal')set LIv[(Mnv)]=("ReplaceableTextures\\CommandButtons\\BTNHammer.blp")return trueendfunctionfunction pno takes nothing returns booleancall VNx(Qa,(function pao),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act1.pack\\Mallet.page\\Mallet.struct\\obj_thisItem_wc3item.j"))
return trueendfunctionfunction pVo takes nothing returns booleanset MVv=VXx(MEv)
return trueendfunctionfunction pEo takes integer oSx,integer XYx returns nothingif(sh[oSx]==w)thencall o_x("FolderItemType_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oSx)+";"+(jA[(XYx)]))set sh[oSx]=Xendifcall rux(sh[oSx],(Ph[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction pXo takes integer oSx,real oux returns nothingcall cyx(oSx,(Jg[(oSx)])-oux)endfunctionfunction pOo takes integer oSx,real oux returns nothingset ZG[oSx]=ouxcall c5x((oSx))endfunctionfunction pRo takes integer oSx,real oux returns nothingcall pOo(oSx,(ZG[(oSx)])-oux)endfunctionfunction pIo takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call pXo(OSx,12.)call pRo(OSx,4.)
return trueendfunctionfunction pAo takes integer oSx,real oux returns nothingcall pOo(oSx,(ZG[(oSx)])+oux)endfunctionfunction pNo takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call cYx(OSx,12.)call pAo(OSx,4.)
return trueendfunctionfunction pbo takes nothing returns booleancall pEo(Mnv,Xdx("Mallet_Init: call Mallet.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function Mallet.Event_Drop))",Dcv,KI,function pIo))call pEo(Mnv,Xdx("Mallet_Init: call Mallet.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function Mallet.Event_PickUp))",DIv,KI,function pNo))return trueendfunctionfunction pBo takes nothing returns booleancall m0o(function pbo,"Mallet_Init")
return trueendfunctionfunction pco takes nothing returns booleancall L1x('APeF',false)set MXv=L0o('APeF')set K6[(MXv)]=(h6)set m6[(MXv)]=(1)set TH[(MXv)]=("Penguin Feather")set Rh[(MXv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0278)))),(((Aj))))))set oxv[(MXv)]=(4)set x3v[(MXv)]=("spell")
call L1o((MXv),GH+(1),(($C)*1.))
call L1o((MXv),tH+(1),((60)*1.))
call L1o((MXv),Lov+(1),((725)*1.))set MOv[(MXv)]=("ReplaceableTextures\\CommandButtons\\BTNEtherealFormOn.blp")return trueendfunctionfunction pCo takes nothing returns booleanset MRv=L6o('IPeF')set LIv[(MRv)]=("ReplaceableTextures\\CommandButtons\\BTNPenguin.blp")call L9o((MRv),(MXv),1)return trueendfunctionfunction pdo takes nothing returns booleancall VNx(Pa,(function pco),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act1.pack\\PenguinFeather.page\\PenguinFeather.struct\\obj_thisSpell_wc3spell.j"))call VNx(Qa,(function pCo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act1.pack\\PenguinFeather.page\\PenguinFeather.struct\\obj_thisItem_wc3item.j"))
return trueendfunctionfunction pDo takes nothing returns booleanset MIv=VXx(MAv)
return trueendfunctionfunction pfo takes integer oSx,real oux returns nothingcall bqx(oSx,(xF[(oSx)])-oux)endfunctionfunction pFo takes integer oSx,real oux returns nothingset Ag[oSx]=ouxcall Bzx((oSx))endfunctionfunction pgo takes integer oSx,real oux returns nothingcall pFo(oSx,(Ag[(oSx)])-oux)endfunctionfunction pGo takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call pfo(OSx,MNv)call pgo(OSx,Mbv)return trueendfunctionfunction pho takes integer oSx,real oux returns nothingcall pFo(oSx,(Ag[(oSx)])+oux)endfunctionfunction pHo takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call bQx(OSx,MNv)call pho(OSx,Mbv)return trueendfunctionfunction pjo takes integer oSx returns integerset MDv[oSx]=trueset Mfv[oSx]=falsecall rEx(Sp)
return oSxendfunctionfunction pJo takes nothing returns integerlocal integer oSxif(MBv==8190)thencall o_x("FolderUnitEffect_StructDestroyTimed_Allocation_allocCustom","call DebugEx(FolderUnitEffect_StructDestroyTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",tp+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(Mcv[(w)]==w)thenset MCv=MCv+1set oSx=MCvelse
set oSx=Mcv[(w)]
set Mcv[(w)]=Mcv[Mcv[(w)]]endifset Mcv[oSx]=Zset Mdv[oSx]=1call pjo(oSx)return oSxendfunctionfunction pko takes integer oSx returns nothingset MDv[oSx]=falsecall rHx(Sp)
endfunctionfunction pKo takes integer oSx returns nothingif(Mdv[oSx]>0)thenreturnendifif(Mcv[oSx]!=Z)thencall o_x("FolderUnitEffect_StructDestroyTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderUnitEffect_StructDestroyTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",tp+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Mcv[oSx]=Mcv[(w)]set Mcv[(w)]=oSx
call pko(oSx)endfunctionfunction plo takes integer oSx returns nothingset Mdv[oSx]=Mdv[oSx]-1call pKo(oSx)endfunctionfunction pLo takes nothing returns nothinglocal integer iCx=iGx()local integer oSx=(ge[(iCx)])local integer rLx=MFv[oSx]call plo((oSx))call iKx(iCx)call Ryx(rLx)endfunctionfunction pmo takes integer oSx,real iMx returns nothinglocal integer rLx=oSxlocal integer iCxset oSx=pJo()set iCx=iXx()set MFv[oSx]=rLx
set ge[(iCx)]=(oSx)call iDx(iCx,iMx,false,function pLo)
endfunctionfunction pMo takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer Iix=(zH[(rFx)])call pmo((ACx((Iix),(Mgv),(MGv),(Bi))),2.)call mao(Cqx,Iix,Mhv)return trueendfunctionfunction ppo takes nothing returns booleancall pEo(MRv,Xdx("PenguinFeather_Init: call PenguinFeather.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function PenguinFeather.Event_Drop))",Dcv,KI,function pGo))call pEo(MRv,Xdx("PenguinFeather_Init: call PenguinFeather.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function PenguinFeather.Event_PickUp))",DIv,KI,function pHo))call mro(MXv,Xdx("PenguinFeather_Init: call PenguinFeather.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function PenguinFeather.Event_SpellEffect))",ih,MI,function pMo))return trueendfunctionfunction pPo takes nothing returns booleancall m0o(function ppo,"PenguinFeather_Init")
return trueendfunctionfunction pqo takes nothing returns booleanset MHv=L6o('IRaF')set LIv[(MHv)]=("ReplaceableTextures\\CommandButtons\\BTNAdvancedStrengthOfTheWild.blp")
return trueendfunctionfunction pQo takes nothing returns booleancall VNx(Qa,(function pqo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act1.pack\\RabbitsFoot.page\\RabbitsFoot.struct\\obj_thisItem_wc3item.j"))return trueendfunctionfunction pso takes nothing returns booleanset Mjv=VXx(MJv)
return trueendfunctionfunction pSo takes integer oSx,real oux returns nothingcall bMx(oSx,(Zf[(oSx)])-oux)endfunctionfunction pto takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call o_x("RabbitsFoot_Event_Drop","call DebugEx(\"drop\")","drop")call pSo(OSx,.2)
call pfo(OSx,.25)return trueendfunctionfunction pTo takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call o_x("RabbitsFoot_Event_PickUp","call DebugEx(\"pickup\")","pickup")
call bpx(OSx,.2)
call bQx(OSx,.25)return trueendfunctionfunction puo takes nothing returns booleancall pEo(MHv,Xdx("RabbitsFoot_Init: call RabbitsFoot.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function RabbitsFoot.Event_Drop))",Dcv,KI,function pto))
call pEo(MHv,Xdx("RabbitsFoot_Init: call RabbitsFoot.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function RabbitsFoot.Event_PickUp))",DIv,KI,function pTo))return trueendfunctionfunction pUo takes nothing returns booleancall m0o(function puo,"RabbitsFoot_Init")return trueendfunctionfunction pwo takes nothing returns booleanset Mkv=L6o('IRaS')set LIv[(Mkv)]=("ReplaceableTextures\\CommandButtons\\BTNNatureTouchGrow.blp")return trueendfunctionfunction pWo takes nothing returns booleancall VNx(Qa,(function pwo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act1.pack\\RamblersStick.page\\RamblersStick.struct\\obj_thisItem_wc3item.j"))return trueendfunctionfunction pyo takes nothing returns booleanset MKv=VXx(Mlv)
return trueendfunctionfunction pYo takes integer oSx,real oux returns nothingcall dro(oSx,(I9v[(oSx)])-oux)endfunctionfunction pzo takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call pYo(OSx,1.)
call pXo(OSx,5.)
call pgo(OSx,4.)
return trueendfunctionfunction pZo takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call dio(OSx,1.)
call cYx(OSx,5.)
call pho(OSx,4.)
return trueendfunctionfunction p_o takes nothing returns booleancall pEo(Mkv,Xdx("RamblersStick_Init: call RamblersStick.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function RamblersStick.Event_Drop))",Dcv,KI,function pzo))call pEo(Mkv,Xdx("RamblersStick_Init: call RamblersStick.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function RamblersStick.Event_PickUp))",DIv,KI,function pZo))
return trueendfunctionfunction p0o takes nothing returns booleancall m0o(function p_o,"RamblersStick_Init")return trueendfunctionfunction p1o takes nothing returns booleanset MLv=L6o('IGrA')set LIv[(MLv)]=("ReplaceableTextures\\CommandButtons\\BTNOrcMeleeUpOne.blp")
return trueendfunctionfunction p2o takes nothing returns booleancall VNx(Qa,(function p1o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act2.pack\\GruntAxe.page\\GruntAxe.struct\\obj_thisItem_wc3item.j"))
return trueendfunctionfunction p3o takes nothing returns booleanset Mmv=VXx(MMv)
return trueendfunctionfunction p4o takes code c,string rSx returns nothing
set in=in+1set an[in]=CreateTrigger()set nn[in]=(GetHandleId(Condition((c))))
set Vn[in]=rSxcall TriggerAddCondition(an[in],Condition(c))endfunctionfunction p5o takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call pSo(OSx,50.)call pXo(OSx,8.)
return trueendfunctionfunction p6o takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call bpx(OSx,50.)call cYx(OSx,8.)
return trueendfunctionfunction p7o takes nothing returns booleancall pEo(MLv,Xdx("GruntAxe_Init: call GruntAxe.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function GruntAxe.Event_Drop))",Dcv,KI,function p5o))call pEo(MLv,Xdx("GruntAxe_Init: call GruntAxe.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function GruntAxe.Event_PickUp))",DIv,KI,function p6o))return trueendfunctionfunction p8o takes nothing returns booleancall p4o(function p7o,"GruntAxe_Init")return trueendfunctionfunction p9o takes nothing returns booleanset Mpv=L6o('IRoH')set LIv[(Mpv)]=("ReplaceableTextures\\CommandButtons\\BTNHoodOfCunning.blp")
return trueendfunctionfunction Pvo takes nothing returns booleancall VNx(Qa,(function p9o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act2.pack\\RobynsHood.page\\RobynsHood.struct\\obj_thisItem_wc3item.j"))
return trueendfunctionfunction Peo takes nothing returns booleanset MPv=VXx(Mqv)
return trueendfunctionfunction Pxo takes integer oSx,real oux returns nothingset DF[oSx]=ouxcall Box((oSx))endfunctionfunction Poo takes integer oSx,real oux returns nothingcall Pxo(oSx,(DF[(oSx)])-oux)endfunctionfunction Pro takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call Poo(OSx,2.)
call pYo(OSx,4.)
return trueendfunctionfunction Pio takes integer oSx,real oux returns nothingcall Pxo(oSx,(DF[(oSx)])+oux)endfunctionfunction Pao takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call Pio(OSx,2.)
call dio(OSx,4.)
return trueendfunctionfunction Pno takes nothing returns booleancall pEo(Mpv,Xdx("RobynsHood_Init: call RobynsHood.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function RobynsHood.Event_Drop))",Dcv,KI,function Pro))call pEo(Mpv,Xdx("RobynsHood_Init: call RobynsHood.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function RobynsHood.Event_PickUp))",DIv,KI,function Pao))return trueendfunctionfunction PVo takes nothing returns booleancall p4o(function Pno,"RobynsHood_Init")
return trueendfunctionfunction PEo takes nothing returns booleanset MQv=L6o('IElD')set LIv[(MQv)]=("ReplaceableTextures\\CommandButtons\\BTNWandOfManaSteal.blp")return trueendfunctionfunction PXo takes nothing returns booleancall VNx(Qa,(function PEo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act3.pack\\ElfinDagger.page\\ElfinDagger.struct\\obj_thisItem_wc3item.j"))return trueendfunctionfunction POo takes nothing returns booleanset Msv=VXx(MSv)
return trueendfunctionfunction PRo takes code c,string rSx returns nothing
set En=En+1set Xn[En]=CreateTrigger()set On[En]=(GetHandleId(Condition((c))))
set Rn[En]=rSxcall TriggerAddCondition(Xn[En],Condition(c))endfunctionfunction PIo takes integer oSx,real oux returns nothingset A0v[(oSx)]=(((A0v[(oSx)])-oux)*1.)endfunctionfunction PAo takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call PIo(OSx,.25)call pgo(OSx,10.)return trueendfunctionfunction PNo takes integer oSx,real oux returns nothingset A0v[(oSx)]=(((A0v[(oSx)])+oux)*1.)endfunctionfunction Pbo takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call PNo(OSx,.25)call pho(OSx,10.)return trueendfunctionfunction PBo takes nothing returns booleancall pEo(MQv,Xdx("ElfinDagger_Init: call ElfinDagger.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function ElfinDagger.Event_Drop))",Dcv,KI,function PAo))
call pEo(MQv,Xdx("ElfinDagger_Init: call ElfinDagger.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function ElfinDagger.Event_PickUp))",DIv,KI,function Pbo))return trueendfunctionfunction Pco takes nothing returns booleancall PRo(function PBo,"ElfinDagger_Init")return trueendfunctionfunction PCo takes nothing returns booleanset Mtv=Wwx('BSoD',"Bleeding",'bSoD')return trueendfunctionfunction Pdo takes nothing returns booleancall VNx(ma,(function PCo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act3.pack\\SpearOfTheDefender.page\\SpearOfTheDefender.struct\\Buff\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction PDo takes nothing returns booleanset MTv=VXx(Muv)
return trueendfunctionfunction Pfo takes nothing returns booleanset MUv=L6o('ISoD')set LIv[(MUv)]=("ReplaceableTextures\\CommandButtons\\BTNThoriumRanged.blp")
return trueendfunctionfunction PFo takes nothing returns booleancall VNx(Qa,(function Pfo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\Act3.pack\\SpearOfTheDefender.page\\SpearOfTheDefender.struct\\obj_thisItem_wc3item.j"))
return trueendfunctionfunction Pgo takes nothing returns booleanset Mwv=VXx(MWv)
return trueendfunctionfunction PGo takes integer Cqx,integer Iix returns nothingset MYv=Cqxcall Nbx((Iix),(Mtv),(1),w,((10.)*1.))endfunctionfunction Pho takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(E2v[(rFx)])local integer Iix=(Vv[(rFx)])call PGo(Cqx,Iix)return trueendfunctionfunction PHo takes integer oSx,real oux returns nothingcall dEo(oSx,(Arv[(oSx)])-oux)endfunctionfunction Pjo takes integer oSx,real oux returns nothingcall fqo(oSx,(wf[(oSx)])-oux)endfunctionfunction PJo takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])local integer nZx=(osx(OSx,Mzv)-1)call PHo(OSx,.2)
call Pjo(OSx,MZv)call pXo(OSx,50.)call rwx(OSx,Mzv,nZx)if(nZx==0)thencall Avx(OSx,Myv)endifreturn trueendfunctionfunction Pko takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])local integer nZx=(osx(OSx,Mzv)+1)call dXo(OSx,.2)
call fQo(OSx,MZv)call cYx(OSx,50.)call rwx(OSx,Mzv,nZx)if(nZx==0+1)then
call Avx(OSx,Myv)endifreturn trueendfunctionfunction PKo takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxcall pmo((ACx((Iix),((EUv[(Iix)])),("chest"),(ri))),2.)call nGo((M_v[oSx]),(Iix),((M3v)*1.),(false))endfunctionfunction Plo takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=MYvlocal integer p3x=iXx()local integer Iix=(Vv[(rFx)])local integer oSx=Iixset M_v[oSx]=Cqx
set M0v[oSx]=p3x
set ge[(p3x)]=(oSx)call iDx(p3x,M2v,true,function PKo)return trueendfunctionfunction PLo takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=M0v[oSx]call iKx(p3x)return trueendfunctionfunction Pmo takes nothing returns nothingcall Lxx(Mtv,Xdx("FolderSpearOfTheDefender_StructBuff_Init: call FolderSpearOfTheDefender_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSpearOfTheDefender_StructBuff.Event_BuffGain))",bd,MI,function Plo))call Lxx(Mtv,Xdx("FolderSpearOfTheDefender_StructBuff_Init: call FolderSpearOfTheDefender_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSpearOfTheDefender_StructBuff.Event_BuffLose))",jc,MI,function PLo))endfunctionfunction PMo takes nothing returns booleanset Myv=Xdx("SpearOfTheDefender_Init: set SpearOfTheDefender.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.ITEMS, function SpearOfTheDefender.Event_Damage)",E4v,KI,function Pho)call pEo(MUv,Xdx("SpearOfTheDefender_Init: call SpearOfTheDefender.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function SpearOfTheDefender.Event_Drop))",Dcv,KI,function PJo))call pEo(MUv,Xdx("SpearOfTheDefender_Init: call SpearOfTheDefender.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function SpearOfTheDefender.Event_PickUp))",DIv,KI,function Pko))call Pmo()return trueendfunctionfunction Ppo takes nothing returns booleancall PRo(function PMo,"SpearOfTheDefender_Init")
return trueendfunctionfunction PPo takes nothing returns booleanset M4v=L6o('IMeS')set LIv[(M4v)]=("ReplaceableTextures\\CommandButtons\\BTNGlyph.blp")
return trueendfunctionfunction Pqo takes nothing returns booleancall VNx(Qa,(function PPo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GarbageCollector.page\\GarbageCollector.struct\\MeteoriteShard.page\\MeteoriteShard.struct\\obj_thisItem_wc3item.j"))return trueendfunctionfunction PQo takes nothing returns booleanset M5v=VXx(M6v)
return trueendfunctionfunction Pso takes code c,string rSx returns nothing
set Ya=Ya+1set za[Ya]=CreateTrigger()set Za[Ya]=(GetHandleId(Condition((c))))
set vn[Ya]=rSxcall TriggerAddCondition(za[Ya],Condition(c))endfunctionfunction PSo takes integer oSx,real oux returns nothingcall c_x(oSx,(PG[(oSx)])-oux)endfunctionfunction Pto takes integer oSx,real oux returns nothingcall Btx(oSx,(wF[(oSx)])-oux)endfunctionfunction PTo takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call PSo(OSx,100.)call Pto(OSx,30.)return trueendfunctionfunction Puo takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call c0x(OSx,100.)call BTx(OSx,30.)return trueendfunctionfunction PUo takes nothing returns booleancall pEo(M4v,Xdx("MeteoriteShard_Init: call MeteoriteShard.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function MeteoriteShard.Event_Drop))",Dcv,KI,function PTo))call pEo(M4v,Xdx("MeteoriteShard_Init: call MeteoriteShard.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function MeteoriteShard.Event_PickUp))",DIv,KI,function Puo))return trueendfunctionfunction Pwo takes nothing returns booleancall Pso(function PUo,"MeteoriteShard_Init")
return trueendfunctionfunction PWo takes nothing returns booleanset M7v=L6o('ICoi')call L7o(((M7v)),tS,(bS))return trueendfunctionfunction Pyo takes nothing returns booleanset M8v=u4x()set IC[(M8v)]=("Abilities\\Spells\\Items\\ResourceItems\\ReceiveGold.wav")set BC[(M8v)]=(l5)set CC[(M8v)]=((1)*1.)set DC[(M8v)]=((1)*1.)set FC[(M8v)]=($A)set GC[(M8v)]=((1)*1.)set lC[(M8v)]=(true)
set mC[(M8v)]=(true)
set pC[(M8v)]=((600)*1.)
set qC[(M8v)]=(($186A0)*1.)set sC[(M8v)]=(($7D0)*1.)return trueendfunctionfunction PYo takes nothing returns booleancall VNx(Qa,(function PWo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GoldCoin.page\\GoldCoin.struct\\obj_thisItem_wc3item.j"))call VNx(La,(function Pyo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\GoldCoin.page\\GoldCoin.struct\\obj_dummySound_wc3sound.j"))
return trueendfunctionfunction Pzo takes nothing returns booleanset M9v=VXx(pvv)
return trueendfunctionfunction PZo takes nothing returns booleanlocal integer rFx=(bv)local integer P_o=(qh[(rFx)])local integer oSx=P_ocall J7x(P_o,pev)return trueendfunctionfunction P0o takes integer oSx returns integerset pnv[oSx]=trueset pVv[oSx]=falsecall rEx(mw)
return oSxendfunctionfunction P1o takes nothing returns integerlocal integer oSxif(pov==8190)thencall o_x("CustomDrop_Allocation_allocCustom","call DebugEx(CustomDrop.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Mw+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(prv[(w)]==w)thenset piv=piv+1set oSx=pivelse
set oSx=prv[(w)]
set prv[(w)]=prv[prv[(w)]]endifset prv[oSx]=Zset pav[oSx]=1call P0o(oSx)return oSxendfunctionfunction P2o takes integer XYx,string P3o,string P4o,integer P5o returns integer
local integer oSx=P1o()set Nxv[oSx]=P4o
set Nov[oSx]=P5o
set Nev[oSx]=P3o
set Nvv[oSx]=XYx
return oSxendfunctionfunction P6o takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])local integer P_o=(kGx(CreateItem(Hh[(M7v)],(((GetUnitX(C[((OSx))])))*1.),(((GetUnitY(C[((OSx))])))*1.))))local integer oSx=P_oset pEv[oSx]=Lnx((Tf[(OSx)]),pXv)call kex(P_o,pev)return trueendfunctionfunction P7o takes integer oSx returns realreturn X_x((GetItemX(gh[((oSx))])),(GetItemY(gh[((oSx))])))endfunctionfunction P8o takes integer oSx,real x,real y,real z returns nothingcall SetSoundPosition(FB[(oSx)],((x)*1.),((y)*1.),((z)*1.))call Akx(oSx)endfunctionfunction P9o takes nothing returns booleanlocal integer rFx=(bv)local integer P_o=(qh[(rFx)])local integer OSx=(Vv[(rFx)])local real x=(GetItemX(gh[((P_o))]))
local real y=(GetItemY(gh[((P_o))]))
local real z=P7o(P_o)local integer oSx=P_olocal integer qvo=AJx(M8v)local integer oMxcall P8o(qvo,x,y,z)call ccx(iSx("+"+(I2S((pEv[oSx]))),"ffffcc00"),1.15*rb,(GetItemX(gh[((P_o))])),(GetItemY(gh[((P_o))])),P7o(P_o),(0))
call R4x(qvo,true)set oMx=Jhloop
exitwhen(oMx<0)call LSo(kh[oMx],PLAYER_STATE_RESOURCE_GOLD,pEv[oSx])set oMx=oMx-1endloopreturn trueendfunctionfunction qeo takes nothing returns booleanset pev=Xdx("GoldCoin_Init: set GoldCoin.COIN_DESTROY_EVENT = Event.Create(Item.DESTROY_EVENT_TYPE, EventPriority.MISC, function GoldCoin.Event_Coin_Destroy)",CS,lI,function PZo)set pxv=P2o(Xdx("GoldCoin_Init: set GoldCoin.THIS_DROP = CustomDrop.Create(Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function GoldCoin.Event_Spawn_Death), null, null, EffectLevel.NORMAL)",VP,KI,function P6o),null,null,Bi)call pEo(M7v,Xdx("GoldCoin_Init: call GoldCoin.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Use.DUMMY_EVENT_TYPE, EventPriority.MISC, function GoldCoin.Event_ItemUse))",Sh,lI,function P9o))return trueendfunctionfunction qxo takes nothing returns booleancall kzo(function qeo,"GoldCoin_Init")return trueendfunctionfunction qoo takes nothing returns booleanset pOv=hjo('uRos')set Uj[(pOv)]=((1.5)*1.)
set NOv[(pOv)]=((60)*1.)
set NWv[(pOv)]=((85)*1.)
set I8v[(pOv)]=((0)*1.)set Anv[(pOv)]=(5)set Nmv[(pOv)]=(('d')*1.)set NLv[(pOv)]=(('d')*1.)set NKv[(pOv)]=((0)*1.)set Ncv[(pOv)]=((500)*1.)set Nbv[(pOv)]=((500)*1.)set NGv[(pOv)]=((500)*1.)set Auv[(pOv)]=((0)*1.)set AUv[(pOv)]=((0)*1.)set AYv[(pOv)]=(0)set A_v[(pOv)]=(0)call hpo((pOv),(gtv),1)return trueendfunctionfunction qro takes nothing returns booleancall L1x('AHRv',false)set pRv=L0o('AHRv')set K6[(pRv)]=(H6)set m6[(pRv)]=(1)set TH[(pRv)]=("Revive Hero")set Rh[(pRv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D007E)))),(((Aj))))))set oxv[(pRv)]=(0)set x3v[(pRv)]=("spell,channel")
call L1o((pRv),dH+(1),((2)*1.))call L1o((pRv),tH+(1),(('d')*1.))call L1o((pRv),Lov+(1),((750)*1.))set MOv[(pRv)]=("ReplaceableTextures\\CommandButtons\\BTNResurrection.blp")return trueendfunctionfunction qio takes nothing returns booleancall VNx(sa,(function qoo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\HeroRevival.page\\HeroRevival.struct\\obj_RosaType_wc3unit.j"))call VNx(Pa,(function qro),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\HeroRevival.page\\HeroRevival.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction qao takes nothing returns booleanset pIv=VXx(pAv)
return trueendfunctionfunction qno takes integer oSx returns integerset pdv[oSx]=trueset pDv[oSx]=falsecall rEx(Eq)
return oSxendfunctionfunction qVo takes nothing returns integerlocal integer oSxif(pbv==8190)thencall o_x("CineFilter_Allocation_allocCustom","call DebugEx(CineFilter.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Xq+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(pBv[(w)]==w)thenset pcv=pcv+1set oSx=pcvelse
set oSx=pBv[(w)]
set pBv[(w)]=pBv[pBv[(w)]]endifset pBv[oSx]=Zset pCv[oSx]=1call qno(oSx)return oSxendfunctionfunction qEo takes integer oSx,integer izx,integer iZx,integer i_x,integer i0x returns nothingset pFv[(oSx)]=(izx)
set pgv[(oSx)]=(iZx)
set pGv[(oSx)]=(i_x)
set phv[(oSx)]=(i0x)
endfunctionfunction qXo takes integer oSx,integer izx,integer iZx,integer i_x,integer i0x returns nothingset pHv[(oSx)]=(izx)
set pjv[(oSx)]=(iZx)
set pJv[(oSx)]=(i_x)
set pkv[(oSx)]=(i0x)
endfunctionfunction qOo takes integer oSx,real qRo,real qIo,real qAo,real qNo returns nothingset pLv[(oSx)]=((qAo)*1.)set pmv[(oSx)]=((qRo)*1.)set pMv[(oSx)]=((qNo)*1.)set ppv[(oSx)]=((qIo)*1.)endfunctionfunction qbo takes integer oSx,real qRo,real qIo,real qAo,real qNo returns nothingset pPv[(oSx)]=((qAo)*1.)set pqv[(oSx)]=((qRo)*1.)set pQv[(oSx)]=((qNo)*1.)set psv[(oSx)]=((qIo)*1.)endfunctionfunction qBo takes nothing returns integerlocal integer oSx=qVo()set pfv[(oSx)]=(BLEND_MODE_BLEND)call qEo(oSx,$FF,$FF,$FF,$FF)call qXo(oSx,0,0,0,0)set pKv[(oSx)]=(TEXMAP_FLAG_NONE)set plv[(oSx)]=(null)call qOo(oSx,.0,.0,1.,1.)call qbo(oSx,.0,.0,1.,1.)return oSxendfunctionfunction qco takes integer oSx returns integerset pyv[oSx]=trueset pYv[oSx]=falsecall rEx(pIv)return oSxendfunctionfunction qCo takes nothing returns integerlocal integer oSxif(puv==8190)thencall o_x("HeroRevival_Allocation_allocCustom","call DebugEx(HeroRevival.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",pAv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(pUv[(w)]==w)thenset pwv=pwv+1set oSx=pwvelse
set oSx=pUv[(w)]
set pUv[(w)]=pUv[pUv[(w)]]endifset pUv[oSx]=Zset pWv[oSx]=1call qco(oSx)return oSxendfunctionfunction qdo takes integer OSx returns nothinglocal integer oMx=CIx(OSx,I2v)local integer rlxloop
exitwhen(oMx<q)set rlx=CAx(OSx,I2v,oMx)
call Oco(rlx,OSx)set oMx=oMx-1endloopendfunctionfunction qDo takes integer oDx,real x,real y,real iMx returns nothingif iOx(oDx)thencall PanCameraToTimed(x,y,iMx)endifendfunctionfunction qfo takes integer oSx,real iMx,integer oDx returns nothingif not iOx(oDx)thenreturnendifcall SetCineFilterBlendMode((pfv[(oSx)]))call SetCineFilterEndColor(pFv[oSx],pgv[oSx],pGv[oSx],phv[oSx])call SetCineFilterEndUV(pmv[oSx],ppv[oSx],pLv[oSx],pMv[oSx])
call SetCineFilterStartColor(pHv[oSx],pjv[oSx],pJv[oSx],pkv[oSx])call SetCineFilterStartUV(pqv[oSx],psv[oSx],pPv[oSx],pQv[oSx])call SetCineFilterTexMapFlags((pKv[(oSx)]))call SetCineFilterTexture((plv[(oSx)]))call SetCineFilterDuration(iMx)call DisplayCineFilter(true)
endfunctionfunction qFo takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])call SetUnitFacing(C[((p2v[oSx]))],(((GetUnitFacing(C[((pzv[oSx]))])*Nh))*1.)*ky)endfunctionfunction qgo takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])local integer qGolocal integer qholocal integer qHolocal boolean qjolocal integer oSxlocal integer qJolocal real x
local real y
local integer qkoif(NRv[(OSx)])thenreturn trueendifset pTv=pTv+1set qGo=(ze[(OSx)])set qho=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetLocalPlayer())))))),((((R))))))set qHo=pSv[0]set qjo=(IsUnitSelected(C[(OSx)],vx[(qho)]))
set oSx=qCo()set qJo=iXx()set x=l1o(qHo)set y=l2o(qHo)set qko=bOx((Tf[(OSx)]),qGo,x,y,(Atan2(((LEx(hw)-y)*1.),((LVx(hw)-x)*1.))))set pzv[oSx]=qko
set pZv[oSx]=(ACx((qko),(p_v),(p0v),(ri)))set p1v[oSx]=qJo
set p2v[oSx]=OSx
call rwx(qko,p3v,oSx)set ge[(qJo)]=(oSx)call Abo(qko)call qdo(qko)call Dux((((qko))),(x4v),(1),w)call Rao(qko,IFv)call pmo((ACx((qko),(p4v),(p5v),(Bi))),5.)call Dux((((qko))),(nYv),(1),w)call Dux((((qko))),(nQv),(1),w)call Dux((((qko))),(aVv),(1),w)call cLx(qko,.0)
call BAx(qko,.0)
call Bdx(qko,p6v)call csx(qko,100.)call Bjx(qko,p7v)call Dux((((qko))),(XAv),(1),w)call EPo(qko,qho,qjo)call Nbx((((qko))),(nlv),(1),w,((((2.)*1.))*1.))
if((qho==(ze[(OSx)]))and qjo)thencall qDo(qho,x,y,3.)
endifcall rwx(OSx,p3v,oSx)call Avx(OSx,p8v)call SetUnitOwner(C[OSx],vx[HZv],false)call r0x(((qko)),((pRv)),(1))call chx(qko,100.)call qfo(pNv,3.,qGo)
call iDx(qJo,p9v,true,function qFo)if(pTv==1)thencall UNx(Pvv,"spell")endifreturn trueendfunctionfunction qKo takes integer oSx,integer qko,integer OSx returns nothinglocal integer ghostEffect=pZv[oSx]local integer qJo=p1v[oSx]call rVx(qko,p3v)call iKx(qJo)call rVx(OSx,p3v)call RPx(OSx,p8v)call Owx(qko)set pTv=pTv-1if(pTv==0)thencall Unx(Pvv)endifendfunctionfunction qlo takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])local integer oSx=osx(OSx,p3v)call qKo(oSx,pzv[oSx],OSx)return trueendfunctionfunction qLo takes nothing returns booleanlocal integer rFx=(bv)call Avx((Vv[(rFx)]),ptv)return trueendfunctionfunction qmo takes integer oSx,integer oDx returns nothingif not iOx(oDx)thenreturnendifcall DisplayCineFilter(false)endfunctionfunction qMo takes integer oSx returns nothinglocal integer rLx=oSxlocal integer rFx=rRx(0)
local integer Ekolocal integer oMxlocal integer rbxlocal integer rMxset Vv[(rFx)]=(oSx)set Eko=rRx((A[(rLx)]))set Vv[(Eko)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((XP))-1)*Iv+(((rbx))-1)))))))))loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((XP))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset rMx=rAx(rLx,XP,rbx)loop
exitwhen(rMx<q)call rfx(rgx(rLx,XP,rbx,rMx),Eko)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call rkx(((Eko)))endfunctionfunction qpo takes integer oSx,real x,real y returns nothing
call Aqo((oSx),Qc)set NRv[((oSx))]=(false)
call ReviveHero(C[(oSx)],x,y,false)call qMo(((oSx)))endfunctionfunction qPo takes nothing returns booleanlocal integer rFx=(bv)local integer qko=(Vv[(rFx)])local integer qho=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetLocalPlayer())))))),((((R))))))local boolean qjo=(IsUnitSelected(C[(qko)],vx[(qho)]))local real bex=(GetUnitFacing(C[((qko))])*Nh)local integer qGo=(ze[(qko)])local real x=(GetUnitX(C[((qko))]))local real y=(GetUnitY(C[((qko))]))local integer oSx=osx(qko,p3v)local integer OSx=p2v[oSx]call qKo(oSx,qko,OSx)call qmo(pNv,qGo)call qpo(OSx,x,y)call pmo((ACx((OSx),(Pev),(Pxv),(Bi))),5.)call SetUnitFacing(C[((OSx))],((bex)*1.)*ky)
call Nbx((OSx),(aWv),(1),w,((Pov)*1.))call SetUnitOwner(C[OSx],vx[qGo],false)call EPo(OSx,qho,qjo)call chx(OSx,Prv*(rG[(OSx)]))call BAx(OSx,Piv*(LF[(OSx)]))return trueendfunctionfunction qqo takes nothing returns booleanlocal integer rFx=(bv)set ptv=Xdx("HeroRevival_Event_Start: set HeroRevival.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function HeroRevival.Event_Death)",VP,lI,function qgo)set p8v=Xdx("HeroRevival_Event_Start: set HeroRevival.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function HeroRevival.Event_Revive)",XP,lI,function qlo)call Dcx(Xdx("HeroRevival_Event_Start: call Event.Create(HeroSelection.DUMMY_EVENT_TYPE, EventPriority.MISC, function HeroRevival.Event_HeroPick).AddToStatics()",Jwv,lI,function qLo))call mro(pRv,Xdx("HeroRevival_Event_Start: call HeroRevival.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.SUCCESS_EVENT_TYPE, EventPriority.MISC, function HeroRevival.Event_SpellEffect))",oVv,lI,function qPo))return trueendfunctionfunction qQo takes nothing returns booleanlocal real x
local real y
set pNv=qBo()set pSv[0]=q2x(Rx)set pSv[1]=q2x(Ix)call qEo(pNv,$94,58,$91,(R2I(((.7*$FF)*1.))))set plv[(pNv)]=("ReplaceableTextures\\CameraMasks\\DreamFilter_Mask.blp")call Dcx(Xdx("HeroRevival_Init: call Event.Create(EventType.START, EventPriority.MISC, function HeroRevival.Event_Start).AddToStatics()",EE,lI,function qqo))set Pav=q2x(Ux)set x=(tm[(Pav)])set y=(Tm[(Pav)])set Pvv=bOx(pOv,BYv,x,y,(Atan2((((Tm[(pSv[0])])-y)*1.),(((tm[(pSv[0])])-x)*1.))))return trueendfunctionfunction qso takes nothing returns booleancall k1o(function qQo,"HeroRevival_Init")return trueendfunctionfunction qSo takes nothing returns booleanreturn trueendfunctionfunction qto takes nothing returns booleanset Pnv=VXx(PVv)
return trueendfunctionfunction qTo takes integer oDx,integer OSx returns booleanreturn(LLo(POv,OSx))and( not((kv[(oDx)])!=w))endfunctionfunction quo takes integer oDx returns nothingif iOx(oDx)thencall ClearTextMessages()
endifendfunctionfunction qUo takes nothing returns booleanlocal integer rFx=(bv)local integer oDx=(oPx(GetTriggerPlayer()))local integer OSx=Q2x()if qTo(oDx,OSx)thenset PRv[oDx]=wcall quo(oDx)endifreturn trueendfunctionfunction qwo takes integer oSx returns integerset Pgv[oSx]=trueset PGv[oSx]=falsecall rEx(Gp)
return oSxendfunctionfunction qWo takes nothing returns integerlocal integer oSxif(Pdv==8190)thencall o_x("FolderSpotEffect_StructDestroyTimed_Allocation_allocCustom","call DebugEx(FolderSpotEffect_StructDestroyTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",hp+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(PDv[(w)]==w)thenset Pfv=Pfv+1set oSx=Pfvelse
set oSx=PDv[(w)]
set PDv[(w)]=PDv[PDv[(w)]]endifset PDv[oSx]=Zset PFv[oSx]=1call qwo(oSx)return oSxendfunctionfunction qyo takes integer oSx returns nothingset Pgv[oSx]=falsecall rHx(Gp)
endfunctionfunction qYo takes integer oSx returns nothingif(PFv[oSx]>0)thenreturnendifif(PDv[oSx]!=Z)thencall o_x("FolderSpotEffect_StructDestroyTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderSpotEffect_StructDestroyTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",hp+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset PDv[oSx]=PDv[(w)]set PDv[(w)]=oSx
call qyo(oSx)endfunctionfunction qzo takes integer oSx returns nothingset PFv[oSx]=PFv[oSx]-1call qYo(oSx)endfunctionfunction qZo takes nothing returns nothinglocal integer iCx=iGx()local integer oSx=(ge[(iCx)])local integer rLx=Phv[oSx]call qzo((oSx))call iKx(iCx)call mho(rLx)endfunctionfunction q_o takes integer oSx,real iMx returns nothinglocal integer rLx=oSxlocal integer iCxset oSx=qWo()set iCx=iXx()set Phv[oSx]=rLx
set ge[(iCx)]=(oSx)call iDx(iCx,iMx,false,function qZo)
endfunctionfunction q0o takes integer OSx returns nothinglocal integer oSx=osx(OSx,PAv)call Avx(OSx,PXv)call Avx(OSx,PIv)call GroupAddUnit(kb[(POv)],C[(OSx)])call acx(OSx,BYv)call PauseUnit(C[OSx],true)call SetUnitFacing(C[((OSx))],((PBv[oSx])*1.)*ky)call fzx(OSx,Pcv[oSx],PCv[oSx])call q_o((mko(((Pcv[oSx])*1.),((PCv[oSx])*1.),(PHv),(ri))),2.)endfunctionfunction q1o takes integer oSx,integer oDx returns nothingif iOx(oDx)thencall Akx(oSx)endifendfunctionfunction q2o takes integer oSx,integer otx,integer q3o,integer q4o returns integerreturn(LoadInteger(o[((V[(E[(((I[(oSx)])))])]))],(((((A[((oSx))]))))),((((otx))+((GetRandomInt(((q3o)),((q4o)))))))))endfunctionfunction q5o takes integer oSx,integer otx returns integerreturn q2o(oSx,otx,q,CIx(oSx,otx))endfunctionfunction q6o takes nothing returns booleanlocal integer rFx=(bv)local integer oDx=(oPx(GetTriggerPlayer()))local integer OSx=Q2x()local integer oSxif not qTo(oDx,OSx)thenreturn trueendifset oSx=osx(OSx,PAv)
if(PNv[oDx]!=w)thencall ilx(PNv[oDx])set PNv[oDx]=wendifif(PRv[oDx]==OSx)thenif(Pbv[oDx]!=w)thencall q0o(Pbv[oDx])endifset Pbv[oDx]=OSx
call RPx(OSx,PXv)call RPx(OSx,PIv)call GroupRemoveUnit(kb[(POv)],C[(OSx)])
call Ryx((ACx((OSx),(Pjv),(PJv),(ri))))call PauseUnit(C[OSx],false)
call acx(OSx,oDx)else
set PNv[oDx]=iBx(Pkv[oSx],oDx)set PRv[oDx]=OSx
call q1o((q5o(PKv[oSx],Plv)),oDx)call SetUnitAnimation(C[((OSx))],("attack"))
call QueueUnitAnimation(C[((OSx))],("stand"))endifreturn trueendfunctionfunction q7o takes integer oSx returns integerset Psv[oSx]=trueset PSv[oSx]=falsecall rEx(Pnv)return oSxendfunctionfunction q8o takes nothing returns integerlocal integer oSxif(Ppv==8190)thencall o_x("HeroSelection_Allocation_allocCustom","call DebugEx(HeroSelection.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",PVv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(PPv[(w)]==w)thenset Pqv=Pqv+1set oSx=Pqvelse
set oSx=PPv[(w)]
set PPv[(w)]=PPv[PPv[(w)]]endifset PPv[oSx]=Zset PQv[oSx]=1call q7o(oSx)return oSxendfunctionfunction q9o takes integer lCo,string Qvo,rect Qeo returns integerlocal integer oSx=q8o()local integer Qxo=X7x((0))local integer jqo=q2x(Qeo)local real x=(tm[(jqo)])
local real y=(Tm[(jqo)])
local real bex=(Atan2(((Pmv-y)*1.),((PLv-x)*1.)))local integer OSx=bOx(lCo,BYv,x,y,bex)set PBv[oSx]=bex
set Ptv[oSx]=iSx((GetHeroProperName(C[(OSx)])),"ffaaaa00")set PTv[oSx]=Qxo
set PKv[oSx]=OSx
set Pcv[oSx]=xset PCv[oSx]=ycall rwx(OSx,PAv,oSx)call Avx(OSx,PXv)call Avx(OSx,PIv)call GroupAddUnit(kb[(POv)],C[(OSx)])call X1x(Qxo,x-50.,y,200.)call PauseUnit(C[OSx],true)call Dux((((OSx))),(aVv),(1),w)call Dux((((OSx))),(Xkv),(1),w)call ITo(OSx,0)return oSxendfunctionfunction Qoo takes integer oSx,string lyx returns nothinglocal integer A0x=QEx(lyx,false,false,false,0,0,H5)call rUx(PKv[oSx],Plv,A0x)endfunctionfunction Qro takes nothing returns booleanlocal integer rFx=(bv)set PLv=(tm[(PEv)])set Pmv=(Tm[(PEv)])set PMv=q9o(Gwv,"Fast, strong, graceful and a superior handling with the bow adorn the reputation of this young defender. In contrast, she cannot keep pace in melee and owns a minor mana pool. If it should become tight, she will call animal spirits for support.",Ax)set Puv=q9o(Grv,"The Count is a close combat user, even if he does not come with the most of hitpoints. In return, he is able to suck life from his enemies and is granted another chance with 'Rigor Mortis'.",bx)set PUv=q9o(GHv,"An elven acquaintance of Count Drakul. There is not much known about this character either but he seems to be into general magics.",Fo)
set Pwv=q9o(gpv,"Covered in metal, Kera is the Sarafin family's bodyguard and mentor of Aruruw. Underneath her cloak, she holds a whole armory of devastating weapons which she knows well to effectively make use of in combat.",fo)set PWv=q9o(g4v,"This little cheeky fairy has a fragile body, which does not permit her open battles. Since here wings were pulled out, she is not able to fly anymore. Still, she has got a lavish magical potential and is a master of theurgic curses, which could become well handy.",Bx)set Pyv=q9o(hNv,"He is the meter-tall bulwark and has got a heavy punch. Forming a team with his Polar Bear chum, together, boosting the fighting spirit is their aim. Unfortunately, the dwarf is short on legs and hardly experienced in magics.",cx)set PYv=q9o(GCv,"The title 'The Stormpike', this hero maintains, is not for a joke. Using his horse he can reach high speeds and his swordsmanship skills are considerable. Other than that, only average attributes.",Cx)set Pzv=q9o(G4v,"This lively bear originates from the northern polar regions. About five years ago, he moved here alone because the climate up there never appealed to him. Also, there, he comes badly by beer. He is perhaps the most average in the group except his blood alcohol level. Yet, he can produce mana potions for the rest and alcoholize the enemies.",Dx)set PZv=q9o(gYv,"The greenskin is an apprentice of Shamanism. This allows him to heal the other group members and to summon the energies of nature. Maybe, thereby, he can gain the others' trust by doing so. He is seated on the back of a black timber wolf.",fx)
call Qoo(PMv,"Units\\NightElf\\HeroMoonPriestess\\HeroMoonPriestessPissed3.wav")
call Qoo(PMv,"Units\\NightElf\\HeroMoonPriestess\\HeroMoonPriestessPissed5.wav")
call Qoo(PMv,"Units\\NightElf\\HeroMoonPriestess\\HeroMoonPriestessWhat2.wav")call Qoo(Puv,"Units\\Undead\\HeroDreadLord\\HeroDreadlordWhat1.wav")
call Qoo(PUv,"Units\\Human\\Kael\\KaelYes4.wav")
call Qoo(Pwv,"Units\\NightElf\\HeroWarden\\HeroWardenPissed7.wav")call Qoo(Pwv,"Units\\NightElf\\HeroWarden\\HeroWardenReady1.wav")call Qoo(Pwv,"Units\\NightElf\\HeroWarden\\HeroWardenWarcry1.wav")call Qoo(Pwv,"Units\\NightElf\\HeroWarden\\HeroWardenWhat1.wav")
call Qoo(PWv,"Units\\Human\\Jaina\\JainaPissed1.wav")call Qoo(PWv,"Units\\Human\\Jaina\\JainaPissed3.wav")call Qoo(PWv,"Units\\Human\\Jaina\\JainaWhat1.wav")call Qoo(PWv,"Units\\Human\\Jaina\\JainaWhat3.wav")call Qoo(Pyv,"Units\\Human\\HeroMountainKing\\HeroMountainKingPissed3.wav")call Qoo(Pyv,"Units\\Human\\HeroMountainKing\\HeroMountainKingPissed5.wav")call Qoo(Pyv,"Units\\Human\\HeroMountainKing\\HeroMountainKingPissed6.wav")call Qoo(Pyv,"Units\\Human\\HeroMountainKing\\HeroMountainKingWhat1.wav")call Qoo(Pyv,"Units\\Human\\HeroMountainKing\\HeroMountainKingWhat2.wav")call Qoo(PYv,"Units\\Undead\\HeroDeathKnight\\DeathKnightPissed3.wav")call Qoo(PYv,"Units\\Undead\\HeroDeathKnight\\DeathKnightReady1.wav")call Qoo(PYv,"Units\\Undead\\HeroDeathKnight\\DeathKnightWhat1.wav")
call Qoo(Pzv,"Units\\Creeps\\PandarenBrewmaster\\PandarenBrewmasterPissed8.wav")
call Qoo(PZv,"Units\\Orc\\Thrall\\ThrallWhat2.wav")call Qoo(PZv,"Units\\Orc\\Thrall\\ThrallYes2.wav")call Qoo(PZv,"Units\\Orc\\Thrall\\ThrallYes3.wav")set P_v=PKv[PMv]
set P0v=PKv[Puv]
set P1v=PKv[Pwv]
set P2v=PKv[PWv]
set P3v=PKv[Pyv]
set P4v=PKv[PYv]
set P5v=PKv[Pzv]
set P6v=PKv[PZv]
return trueendfunctionfunction Qio takes integer oDx,integer OSx returns nothinglocal integer rFx=rRx(0)
local integer oMxlocal integer rbxlocal integer rMxset Vv[(rFx)]=(OSx)set ZA[(rFx)]=(oDx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Jwv))-1)*Iv+(((rbx))-1)))))))))
loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Jwv))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction Qao takes integer oSx,integer rNx,boolean test returns nothingcall UnitAddItem(C[((oSx))],gh[((kGx(CreateItem(Hh[(rNx)],((Dsx((oSx)))*1.),((Dtx((oSx)))*1.)))))])endfunctionfunction Qno takes integer oSx,integer oux returns nothinglocal integer aCx=(bGv[(oSx)])if(oux!=aCx)then
call SetHeroLevel(C[(oSx)],oux,true)
endifendfunctionfunction QVo takes nothing returns booleanlocal integer OSx=Q2x()local integer QEo=(ze[(OSx)])if(OSx!=Pbv[QEo])thenreturn trueendifcall rVx(OSx,PAv)call Ulx(((OSx)),aVv)set kv[(QEo)]=(OSx)call Qio(QEo,OSx)call Qao(OSx,Lrv,true)call SetUnitPosition(C[((OSx))],((P7v)*1.),((P8v)*1.))call Ulx(((OSx)),Xkv)call Iwo(OSx,1)call LSo(QEo,PLAYER_STATE_RESOURCE_GOLD,300)
call qDo(QEo,(GetUnitX(C[((OSx))])),(GetUnitY(C[((OSx))])),2.)call Qao(OSx,P9v,true)if(pe==qvv)thencall Qno(OSx,3)call LSo(QEo,PLAYER_STATE_RESOURCE_LUMBER,$FA)endifreturn trueendfunctionfunction QXo takes integer oSx returns integerset qav[oSx]=trueset qnv[oSx]=falseset qVv[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set qEv[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(X5)
return oSxendfunctionfunction QOo takes nothing returns integerlocal integer oSxif(qxv==8190)thencall o_x("Region_Allocation_allocCustom","call DebugEx(Region.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",O5+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(qov[(w)]==w)thenset qrv=qrv+1set oSx=qrvelse
set oSx=qov[(w)]
set qov[(w)]=qov[qov[(w)]]endifset qov[oSx]=Zset qiv[oSx]=1call QXo(oSx)return oSxendfunctionfunction QRo takes integer oSx returns nothingset qRv[(oSx)]=(qAv+oSx)
endfunctionfunction QIo takes nothing returns integerlocal integer oSx=QOo()set qev[oSx]=CreateRegion()call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((qev[oSx]))))),((((qOv)))),((((oSx)))))call QRo(oSx)return oSxendfunctionfunction QAo takes integer jqo returns integerlocal integer oSx=QIo()call RegionAddRect(qev[(oSx)],bm[(jqo)])
return oSxendfunctionfunction QNo takes nothing returns booleanlocal integer Qbo=q2x(vo)local integer oMxlocal integer M6xset PEv=q2x(Nx)set PXv=Xdx("HeroSelection_Init: set HeroSelection.DESELECTION_EVENT = Event.Create(UNIT.Selection.ENDING_EVENT_TYPE, EventPriority.MISC, function HeroSelection.Event_Deselect)",C0v,lI,function qUo)set Jwv=(E3x())set POv=O5x()set PIv=Xdx("HeroSelection_Init: set HeroSelection.SELECTION_EVENT = Event.Create(UNIT.Selection.REPEAT_EVENT_TYPE, EventPriority.MISC, function HeroSelection.Event_Select)",C2v,lI,function q6o)call Dcx(Xdx("HeroSelection_Init: call Event.Create(EventType.START, EventPriority.MISC, function HeroSelection.Event_Start).AddToStatics()",EE,lI,function Qro))set oMx=Jhloop
exitwhen(oMx<0)set M6x=kh[oMx]set PNv[M6x]=wset PRv[M6x]=wset Pbv[M6x]=wset oMx=oMx-1endloopset P7v=(tm[(Qbo)])set P8v=(Tm[(Qbo)])call TriggerRegisterEnterRegion(DA[((XJx(function QVo)))],qev[(QAo(q2x(Zx)))],Condition((null)))
call qDo(Ge,(tm[(PEv)]),(Tm[(PEv)]),.0)return trueendfunctionfunction QBo takes nothing returns booleancall kzo(function QNo,"HeroSelection_Init")return trueendfunctionfunction Qco takes nothing returns booleanset qNv=VXx(qbv)
return trueendfunctionfunction QCo takes integer oSx returns integerset qDv[oSx]=trueset qfv[oSx]=falsecall rEx(qNv)return oSxendfunctionfunction Qdo takes nothing returns integerlocal integer oSxif(qBv==8190)thencall o_x("Hint_Allocation_allocCustom","call DebugEx(Hint.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",qbv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(qcv[(w)]==w)thenset qCv=qCv+1set oSx=qCvelse
set oSx=qcv[(w)]
set qcv[(w)]=qcv[qcv[(w)]]endifset qcv[oSx]=Zset qdv[oSx]=1call QCo(oSx)return oSxendfunctionfunction QDo takes integer oSx returns booleanset qgv=qgv+1set qGv[qgv]=oSx
set qhv[oSx]=qgv+1return(qgv==0)endfunctionfunction Qfo takes string icx returns integerlocal integer oSx=Qdo()set qFv[oSx]=icx
call QDo(oSx)return oSxendfunctionfunction QFo takes nothing returns nothinglocal integer oSxif r1 thenset oSx=(qGv[(GetRandomInt(((0)),((qgv))))])
call ipx(Ge,iSx("Hint "+(I2S(((qhv[(oSx)]-1)+1-0)))+" of "+(I2S((qgv+1-0)))+": ","ffffcc00")+qFv[oSx],10.)endifendfunctionfunction Qgo takes nothing returns booleanlocal integer rFx=(bv)call iDx(iXx(),60.,true,function QFo)return trueendfunctionfunction QGo takes nothing returns booleancall Qfo("You receive a notification message each time when there are creep camps in the next level. These creeps spawn outside of the castle and drop some unique effect besides gold/xp like permanent stats bonuses or temporary buffs.")
call Qfo("Regard one of the modern travelling services that are next to the side entrances of the castle to spend a visit at the tavern.")call Qfo("Explore the vast castle library that holds ancient wisdom of nature-bound magic.")
call Qfo("Wintercastle lies in the crystal mountains, behind the shadowy forest that never met the light of spring.")call Qfo("1-2 heroes should be enough to take care of normal creep camps. The taverns serve 'Tropical Rainbow' for free, but only one vial at a time. You may use it to fast return to the castle or to approach the other camp. It also boosts the attack speed so can be compoundable with finishing off the creeps.")
call Dcx(Xdx("Hint_Init: call Event.Create(AfterIntro.DUMMY_EVENT_TYPE, EventPriority.MISC, function Hint.Event_AfterIntro).AddToStatics()",Jjv,lI,function Qgo))return trueendfunctionfunction Qho takes nothing returns booleancall k1o(function QGo,"Hint_Init")return trueendfunctionfunction QHo takes nothing returns booleanset qHv=ltx(qjv+" (dummyBuff)")set Pc[(qHv)]=(true)
return trueendfunctionfunction Qjo takes nothing returns booleancall VNx(ma,(function QHo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\HorseRide.page\\HorseRide.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction QJo takes nothing returns booleanset qJv=VXx(qjv)
return trueendfunctionfunction Qko takes nothing returns booleanset qkv=L6o('IHoR')call L7o(((qkv)),tS,(bS))set LIv[(qkv)]=("ReplaceableTextures\\CommandButtons\\BTNRiderlessHorse.blp")return trueendfunctionfunction QKo takes nothing returns booleanset qKv=hjo('uRiS')call hJo(((qKv)),ASv,(Igv))set Uj[(qKv)]=((1.3)*1.)
set NOv[(qKv)]=(('x')*1.)set NWv[(qKv)]=((60)*1.)
set I8v[(qKv)]=((0)*1.)set Anv[(qKv)]=(0)set Nmv[(qKv)]=((150000.)*1.)set NLv[(qKv)]=((150000.)*1.)set NKv[(qKv)]=((0)*1.)set Ncv[(qKv)]=((500)*1.)set Nbv[(qKv)]=((500)*1.)set Auv[(qKv)]=((0)*1.)set AUv[(qKv)]=((0)*1.)set AYv[(qKv)]=(0)set A_v[(qKv)]=(0)call hpo((qKv),(gtv),1)return trueendfunctionfunction Qlo takes nothing returns booleancall VNx(Qa,(function Qko),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\HorseRide.page\\HorseRide.struct\\obj_shopItem_wc3item.j"))call VNx(sa,(function QKo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\HorseRide.page\\HorseRide.struct\\obj_shop_wc3unit.j"))return trueendfunctionfunction QLo takes nothing returns booleanset qlv=VXx(qLv)
return trueendfunctionfunction Qmo takes integer Iix returns integerlocal integer oSx=Iixreturn qtv[oSx]endfunctionfunction QMo takes nothing returns nothingcall GroupAddUnit(qMv,vJ[Qmo(ROx())])endfunctionfunction Qpo takes integer oSx returns realreturn(X_x((GetUnitX(vJ[(((oSx)))])),(GetUnitY(vJ[(((oSx)))])))+(GetUnitFlyHeight(vJ[((oSx))])))
endfunctionfunction QPo takes integer oSx,real izx,real iZx,real i_x,real i0x returns nothingcall mdx(oSx,(Qy[(oSx)])+izx,(sy[(oSx)])+iZx,(Sy[(oSx)])+i_x,(ty[(oSx)])+i0x)endfunctionfunction Qqo takes integer oSx returns integerset qYv[oSx]=trueset qzv[oSx]=falsecall rEx(pW)
return oSxendfunctionfunction QQo takes nothing returns integerlocal integer oSxif(qUv==8190)thencall o_x("FolderDummyUnit_FolderVertexColor_StructTimed_Allocation_allocCustom","call DebugEx(FolderDummyUnit_FolderVertexColor_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",PW+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(qwv[(w)]==w)thenset qWv=qWv+1set oSx=qWvelse
set oSx=qwv[(w)]
set qwv[(w)]=qwv[qwv[(w)]]endifset qwv[oSx]=Zset qyv[oSx]=1call Qqo(oSx)return oSxendfunctionfunction Qso takes integer oSx,integer otx,integer oux returns booleanreturn rux(yp[(oSx)],(Yp[((oSx))]),otx,oux)endfunctionfunction QSo takes integer oSx returns booleanset q6v=q6v+1set q7v[q6v]=oSx
set q8v[oSx]=q6v+1return(q6v==0)endfunctionfunction Qto takes nothing returns nothinglocal integer oMx=q6vlocal integer oSxloop
set oSx=q7v[oMx]
call QPo(q3v[oSx],qZv[oSx],q_v[oSx],q0v[oSx],q1v[oSx])set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction QTo takes integer oSx returns nothingset qYv[oSx]=falsecall rHx(pW)
endfunctionfunction Quo takes integer oSx returns nothingif(qyv[oSx]>0)thenreturnendifif(qwv[oSx]!=Z)thencall o_x("FolderDummyUnit_FolderVertexColor_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderDummyUnit_FolderVertexColor_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",PW+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset qwv[oSx]=qwv[(w)]set qwv[(w)]=oSx
call QTo(oSx)endfunctionfunction QUo takes integer oSx returns nothingset qyv[oSx]=qyv[oSx]-1call Quo(oSx)endfunctionfunction Qwo takes integer oSx returns booleanlocal integer oLx=(q8v[(oSx)])set q8v[q7v[q6v]]=oLxset q7v[oLx-1]=q7v[q6v]set q8v[oSx]=0set q6v=q6v-1return(q6v==F)endfunctionfunction QWo takes integer oSx,integer iCx,integer rLx returns nothingcall QUo((oSx))call iKx(iCx)call HOx(rLx,q5v,oSx)if Qwo(oSx)thencall ikx(fy)
endifendfunctionfunction Qyo takes nothing returns nothinglocal integer iCx=iGx()local integer oSx=(ge[(iCx)])call QWo(oSx,iCx,q3v[oSx])endfunctionfunction QYo takes integer oSx,real izx,real iZx,real i_x,real i0x,real iMx returns nothinglocal integer rLx=oSxlocal integer fexlocal integer iCxif(iMx==.0)thencall QPo((oSx),izx,iZx,i_x,i0x)returnendifset fex=(R2I(((iMx*1./ quv)*1.)))set oSx=QQo()set iCx=iXx()set qZv[oSx]=izx*1./ fex
set q_v[oSx]=iZx*1./ fex
set q0v[oSx]=i_x*1./ fex
set q1v[oSx]=i0x*1./ fex
set q2v[oSx]=iCx
set q3v[oSx]=rLx
set ge[(iCx)]=(oSx)call Qso(rLx,q5v,oSx)if QSo(oSx)thencall iDx(fy,quv,true,function Qto)endifcall iDx(iCx,iMx,false,function Qyo)
endfunctionfunction Qzo takes integer Iix returns nothinglocal integer oSx=Iixlocal integer QZo=qtv[oSx]local real bex=(GetUnitFacing(vJ[((QZo))])*Nh)local real x=(GetUnitX(vJ[((QZo))]))
local real y=(GetUnitY(vJ[((QZo))]))
local real z=Qpo(QZo)local integer HAx=mDx('qHoR',x+qTv*(Cos(((((bex)*1.))*1.))),y+qTv*(Sin(((((bex)*1.))*1.))),z,bex)call IssuePointOrderById(vJ[((HAx))],pb[(Bh)],((x)*1.),((y)*1.))
call mdx(HAx,255.,255.,255.,191.)call QYo((HAx),-((255.)*1.),-((255.)*1.),-((255.)*1.),-((191.)*1.),((q9v)*1.))call fgo(HAx,q9v)endfunctionfunction Q_o takes nothing returns nothingcall Qzo(ROx())endfunctionfunction Q0o takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])call ForGroup(kb[(qQv[oSx])],(function Q_o))
endfunctionfunction Q1o takes integer oSx,real x,real y returns nothing
call DQx(oSx,x)call DSx(oSx,y)call mBx(oSx,x,y,(Au[(oSx)]))endfunctionfunction Q2o takes integer oSx,real x,real y returns boolean
return not((x<(wm[(oSx)]))or(y<(Wm[(oSx)]))or(x>(um[(oSx)]))or(y>(Um[(oSx)])))endfunctionfunction Q3o takes integer Iix returns nothinglocal integer oSx=Iixlocal integer QZo=qtv[oSx]local integer Q4o=qsv[Qvv[oSx]]local real x=(GetUnitX(vJ[((QZo))]))
local real y=(GetUnitY(vJ[((QZo))]))
local real Q5ocall Q1o(O4v[(Iix)],((x)*1.),((y)*1.))if Q2o(Q4o,x,y)thenset Q5o=(py[(QZo)])-3.141592654call AZx(Iix,qHv)call SetUnitPosition(C[((Iix))],((x+Qev*(Cos(((((Q5o)*1.))*1.))))*1.),((y+Qev*(Sin(((((Q5o)*1.))*1.))))*1.))
elseif((Bco(GetUnitCurrentOrder(vJ[((QZo))])))==w)thencall IssuePointOrderById(vJ[((QZo))],pb[(Bh)],(((tm[(Q4o)]))*1.),(((Tm[(Q4o)]))*1.))
endifendfunctionfunction Q6o takes nothing returns nothingcall Q3o(ROx())endfunctionfunction Q7o takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])call ForGroup(kb[(qQv[oSx])],(function Q6o))
endfunctionfunction Q8o takes nothing returns nothinglocal integer Q9o=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(Q9o)])local integer svo=qQv[oSx]local integer Q4o=qsv[oSx]call GroupClear(qMv)
call ForGroup(kb[(svo)],(function QMo))call GroupPointOrderById(qMv,pb[Bh],(tm[(Q4o)]),(Tm[(Q4o)]))
call iDx(qqv[oSx],.625,true,function Q0o)call iDx(Q9o,1.,true,function Q7o)endfunctionfunction seo takes integer oSx,integer Iax,integer rYx returns booleancall AZx(oSx,Iax)return(Dux((oSx),(Iax),(rYx),w))
endfunctionfunction sxo takes integer oSx,integer Iix returns nothingset Qxv=oSxcall seo(Iix,qHv,1)endfunctionfunction soo takes nothing returns nothingcall sxo(Qxv,ROx())endfunctionfunction sro takes integer svo,integer Q4o returns nothinglocal integer oSx=svolocal integer sio=iXx()local integer Q9o=iXx()set qqv[oSx]=sio
set qQv[oSx]=svo
set qsv[oSx]=Q4o
set qSv[oSx]=Q9o
set ge[(sio)]=(oSx)set ge[(Q9o)]=(oSx)call iDx(Q9o,2.,true,function Q8o)set Qxv=oSxcall ForGroup(kb[(svo)],(function soo))endfunctionfunction sao takes nothing returns booleanlocal integer rFx=(bv)local integer QZo=(Vv[(rFx)])local integer Iix=(zH[(rFx)])local boolean Kxo=(QZo==(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((Vr)))))),((((ix)))))))local integer svo=O5x()call GroupAddUnit(kb[(svo)],C[(Iix)])if Kxo thencall sro(svo,qPv)else
call sro(svo,qpv)endifreturn trueendfunctionfunction sno takes integer oSx returns integerset oP[oSx]=true
set Qav[oSx]=falsecall rEx(Op)
return oSxendfunctionfunction sVo takes nothing returns integerlocal integer oSxif(Qrv==8190)thencall o_x("DummyUnitEffect_Allocation_allocCustom","call DebugEx(DummyUnitEffect.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Rp+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(xP[(w)]==w)thenset Qiv=Qiv+1set oSx=Qivelse
set oSx=xP[(w)]set xP[(w)]=xP[xP[(w)]]endifset xP[oSx]=Zset eP[oSx]=1call sno(oSx)return oSxendfunctionfunction sEo takes integer HAx,string ANx,string Abx,integer rYx returns integer
local integer oSx=sVo()set Zp[oSx]=HAxset vP[oSx]=AddSpecialEffectTarget(itx(ci>=rYx,ANx),vJ[HAx],Abx)
if Qso(HAx,zp,oSx)thencall Mix(HAx,Up)
call Mix(HAx,iP)
endifreturn oSxendfunctionfunction sXo takes integer oDx,integer OSx returns nothingif iOx(oDx)thencall SetCameraTargetController(vJ[OSx],.0,.0,false)endifendfunctionfunction sOo takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer sRo=(ze[(Iix)])local integer oSx=Iixlocal integer QZo=mDx('qHoR',(GetUnitX(C[((Iix))])),(GetUnitY(C[((Iix))])),fYx(Iix),(GetRandomReal(((.0)*1.),((Cf)*1.))))set qtv[oSx]=QZo
set Qov[oSx]=sEo(QZo,Qnv,QVv,ri)
set Qvv[oSx]=Qxv
call sXo(sRo,QZo)call HIx(sEo(QZo,QEv,QXv,ri))call mbx(QZo,sRo)call SetUnitMoveSpeed(vJ[(QZo)],((522.)*1.))
call Dux((((Iix))),(O1v),(1),w)return trueendfunctionfunction sIo takes integer oDx,real iMx returns nothingif iOx(oDx)thencall ResetToGameCamera(iMx)endifendfunctionfunction sAo takes integer oSx returns nothinglocal integer sio=qqv[oSx]local integer svo=qQv[oSx]local integer Q9o=qSv[oSx]call iKx(sio)call O9x(svo)call iKx(Q9o)endfunctionfunction sNo takes integer oSx,integer Iix returns nothingcall GroupRemoveUnit(kb[(qQv[oSx])],C[(Iix)])if((adx(FirstOfGroup(kb[((qQv[oSx]))])))==w)then
call sAo(oSx)endifendfunctionfunction sbo takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer QZo=qtv[oSx]local integer sBo=Qov[oSx]call sIo(((ze[(Iix)])),.0)call IssueImmediateOrderById(vJ[((QZo))],pb[(ch)])call QYo((QZo),-((.0)*1.),-((.0)*1.),-((.0)*1.),-((255.)*1.),((QOv)*1.))
call HIx(sBo)call Ryx((ACx((Iix),(QRv),(QIv),(ri))))call Ulx(((Iix)),O1v)call fgo(QZo,QOv)call sNo(Qvv[oSx],Iix)return trueendfunctionfunction sco takes nothing returns nothingcall Lxx(qHv,Xdx("FolderHorseRide_StructTarget_Init: call FolderHorseRide_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderHorseRide_StructTarget.Event_BuffGain))",bd,MI,function sOo))
call Lxx(qHv,Xdx("FolderHorseRide_StructTarget_Init: call FolderHorseRide_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderHorseRide_StructTarget.Event_BuffLose))",jc,MI,function sbo))
endfunctionfunction sCo takes nothing returns booleanset qmv=q2x(eo)set qMv=CreateGroup()set qpv=q2x(yx)set qPv=q2x(Wx)call pEo(qkv,Xdx("HorseRide_Init: call HorseRide.SHOP_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Sell.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function HorseRide.Event_Sell))",Dgv,KI,function sao))call sco()return trueendfunctionfunction sdo takes nothing returns booleancall kzo(function sCo,"HorseRide_Init")return trueendfunctionfunction sDo takes nothing returns booleanset QAv=VXx(QNv)
return trueendfunctionfunction sfo takes nothing returns booleanset Qbv=VXx(QBv)
return trueendfunctionfunction sFo takes integer oDx returns integerlocal integer oSx=oDxreturn QCv[oSx]endfunctionfunction sgo takes integer oSx,integer pNx,integer pAx,string oux returns nothingcall pBx(oSx,pNx,pAx)call pVx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((op[(oSx)]))))),((((sZ+(pNx)*50+(pAx))))))),oux)
endfunctionfunction sGo takes integer Cgx,integer FIo,integer OSx returns nothinglocal integer sho=(qS[(Cgx)])local integer pNx=sFo((ze[(OSx)]))if(sho>0)thencall pCx(Qdv,pNx,QDv+FIo*2,(I2S((sho))))
endifcall sgo(Qdv,pNx,QDv+FIo*2+1,(LIv[((Fh[(Cgx)]))]))endfunctionfunction sHo takes nothing returns booleanlocal integer rFx=(bv)local integer Cgx=(qh[(rFx)])local integer OSx=(Vv[(rFx)])call sGo(Cgx,FAo(OSx,Cgx),OSx)return trueendfunctionfunction sjo takes integer oSx,integer XYx returns booleanreturn((LoadInteger(o[((D[((hS[oSx]))]))],((((lh[((oSx))])))),(oTx((((oA[(XYx)]))),(((XYx)))))))!=0)
endfunctionfunction sJo takes integer Cgx,integer FIo,integer OSx returns nothinglocal integer pNx=sFo((ze[(OSx)]))call sgo(Qdv,pNx,QDv+FIo*2+1,null)call pCx(Qdv,pNx,QDv+FIo*2,null)
endfunctionfunction sko takes nothing returns booleanlocal integer rFx=(bv)local integer Cgx=(qh[(rFx)])if not sjo(Cgx,Qcv)thenreturn trueendifcall sJo(Cgx,(DBv[(rFx)]),(Vv[(rFx)]))call J7x(Cgx,Qcv)return trueendfunctionfunction sKo takes nothing returns booleanlocal integer rFx=(bv)local integer dax=(wH[(rFx)])local integer FHo=(DFv[(rFx)])local integer Cgx=(qh[(rFx)])local integer FIo=(DBv[(rFx)])local integer OSx=(Vv[(rFx)])call sGo(Cgx,FHo,OSx)if(dax==w)thencall sJo(Cgx,FIo,OSx)else
call sGo(dax,FIo,OSx)endifreturn trueendfunctionfunction slo takes nothing returns booleanlocal integer rFx=(bv)local integer Cgx=(qh[(rFx)])call kex(Cgx,Qcv)call sGo(Cgx,(DBv[(rFx)]),(Vv[(rFx)]))return trueendfunctionfunction sLo takes nothing returns stringlocal integer smo=jpvlocal string o7x="Chapter: "
if(smo==w)thenreturn o7xendifreturn o7x+iSx((j3v[(smo)]),"ff00ff00")endfunctionfunction sMo takes nothing returns booleanlocal integer rFx=(bv)call pCx(Qdv,QGv,Qhv,sLo())return trueendfunctionfunction spo takes integer oSx,integer el returns booleanif plx(oSx,el)thenreturn false
endifcall m3x(X,el,iz+oSx,w)if((rz[((oSx))])==w)then
set rz[oSx]=elset az[oSx]=elreturn trueendifcall m3x(X,el,Vz+oSx,(az[(oSx)]))call m3x(X,(az[(oSx)]),iz+oSx,el)set az[oSx]=elreturn false
endfunctionfunction sPo takes integer oSx,integer oDx returns nothinglocal integer rLx=oSxset oSx=oDxif spo(BZ[oSx],rLx)thencall qex((rLx),oDx)else
call pTx(rLx)endifendfunctionfunction sqo takes nothing returns booleanlocal integer rFx=(bv)call sPo((Qdv),((ZA[(rFx)])))return trueendfunctionfunction sQo takes integer oDx returns nothinglocal integer ssoif((Huv[(oDx)])!=HIv)thenset sso=(kv[(oDx)])if(sso==w)thencall pCx(Qdv,sFo(oDx),1,"inactive")elseif I9x(sso,Qc)thencall pCx(Qdv,sFo(oDx),1,"dead "+(I2S(((R2I((((((lF[(pzv[(osx(sso,p3v))])]))*1.))*1.)))))))else
call pCx(Qdv,sFo(oDx),1,"active")endifendifendfunctionfunction sSo takes nothing returns booleanlocal integer rFx=(bv)local integer oDx=(ZA[(rFx)])local integer OSx=(Vv[(rFx)])call Avx(OSx,Qfv)call Avx(OSx,QFv)call Avx(OSx,Qgv)call sQo(oDx)return trueendfunctionfunction sto takes integer oSx returns integerreturn kKo((oSx),Jfv)endfunctionfunction sTo takes integer oSx,integer oLx returns integerreturn klo((oSx),Jfv,oLx)endfunctionfunction suo takes nothing returns stringlocal integer sUo=qe
local string o7x="Level: "local integer smolocal integer rvxlocal integer oMxlocal integer kpolocal string swo
local integer rMxlocal integer k4olocal string IMx
if(sUo==w)thenreturn o7xendifif(lhv[(sUo)])thenreturn o7x+(Ue[(sUo)])endifset smo=jpvif(smo==w)thenreturn o7xendifset rvx=0set oMx=qloop
exitwhen(oMx>(kko(((smo)),jyv)))
if(oMx>q)thenset o7x=o7x+" | "endifset kpo=(kAo(((smo)),jyv,(oMx)))
set swo=""set rMx=qloop
exitwhen(rMx>sto(kpo))set k4o=sTo(kpo,rMx)
if(Qjv[(k3o(k4o))])thenset IMx="Boss"else
set IMx=(I2S((rvx+1)))endifif(k4o==sUo)then
set IMx=iSx(IMx,"ff00ff00")endifif(swo=="")thenset swo=swo+IMxelse
set swo=swo+" - "+IMxendifset rvx=rvx+1set rMx=rMx+1endloopset o7x=o7x+swoset oMx=oMx+1endloopreturn o7xendfunctionfunction sWo takes nothing returns booleanlocal integer rFx=(bv)local integer k4o=(Qe[(rFx)])local integer oMxlocal integer Kiolocal boolean array syolocal integer rMxcall pCx(Qdv,QHv,Qhv,suo())set oMx=0loop
if((QJv[(k4o)]-1)<=lGv)thenset Kio=k3o(k4o)
if(Kio==w)thenreturn trueendifset syo[0]=(Qkv[(Kio)])set syo[1]=(QKv[(Kio)])set syo[2]=(Qlv[(Kio)])set syo[4]=(QLv[(Kio)])set syo[5]=(Qmv[(Kio)])set syo[6]=(QMv[(Kio)])set syo[7]=(Qpv[(Kio)])set syo[8]=(Qjv[(Kio)])if(Qjv[(Kio)])thencall sgo(Qdv,QPv+oMx,Qhv,"ReplaceableTextures\\CommandButtons\\BTNSelectHeroOff.blp")elseif((Qjv[(Kio)])and(oMx==1))thencall sgo(Qdv,QPv+oMx,Qhv,"ReplaceableTextures\\CommandButtons\\BTNSelectHeroOff.blp")else
call sgo(Qdv,QPv+oMx,Qhv,(Qqv[(k4o)]))endifset rMx=0loop
exitwhen(rMx>8)if syo[rMx]thencall sgo(Qdv,QPv+oMx,QQv+rMx,"ReplaceableTextures\\WorldEditUI\\Editor-Ally-HighPriority.blp")else
call sgo(Qdv,QPv+oMx,QQv+rMx,"ReplaceableTextures\\WorldEditUI\\Editor-Ally-NoPriority.blp")
endifif(rMx==2)thenset rMx=rMx+2else
set rMx=rMx+1endifendloopendifset oMx=oMx+1set k4o=(ue[(k4o)])exitwhen(oMx>1)endloopreturn trueendfunctionfunction sYo takes integer oSx returns integerset Quv[oSx]=trueset QUv[oSx]=falsecall rEx(NZ)
return oSxendfunctionfunction szo takes nothing returns integerlocal integer oSxif(Qsv==8190)thencall o_x("Multiboard_Allocation_allocCustom","call DebugEx(Multiboard.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",bZ+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(QSv[(w)]==w)thenset Qtv=Qtv+1set oSx=Qtvelse
set oSx=QSv[(w)]
set QSv[(w)]=QSv[QSv[(w)]]endifset QSv[oSx]=Zset QTv[oSx]=1call sYo(oSx)return oSxendfunctionfunction sZo takes integer oSx returns integerset QZv[oSx]=trueset Q_v[oSx]=falsecall rEx(Zz)
return oSxendfunctionfunction s_o takes nothing returns integerlocal integer oSxif(QWv==8190)thencall o_x("MultiboardItem_Allocation_allocCustom","call DebugEx(MultiboardItem.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",vZ+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Qyv[(w)]==w)thenset QYv=QYv+1set oSx=QYvelse
set oSx=Qyv[(w)]
set Qyv[(w)]=Qyv[Qyv[(w)]]endifset Qyv[oSx]=Zset Qzv[oSx]=1call sZo(oSx)return oSxendfunctionfunction s0o takes integer s1o,integer pNx,integer pAx returns integerlocal integer oSx=s_o()set Q0v[oSx]=pAx
set Q1v[oSx]=pNx
set PZ[oSx]=MultiboardGetItem(op[s1o],pNx,pAx)call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((PZ[oSx]))))),((((Q3v)))),((((oSx)))))return oSxendfunctionfunction s2o takes integer oSx,integer pNx,integer pAx,multiboard oqx returns nothinglocal integer s3o=s0o(oSx,pNx,pAx)call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oqx))))),((((sZ+pNx*50+pAx)))),((((s3o)))))endfunctionfunction s4o takes nothing returns booleanlocal integer oSx=Qwvlocal multiboard oqx=op[oSx]
local integer pAx=0local integer pNxloop
set pNx=0loop
call s2o(oSx,pNx,pAx,oqx)set pNx=pNx+1exitwhen(pNx==32)endloopset pAx=pAx+1exitwhen(pAx==50)endloopset oqx=null
return trueendfunctionfunction s5o takes nothing returns integerlocal integer oSx=szo()set mZ[oSx]=-1set MZ[oSx]=-1set op[oSx]=CreateMultiboard()set Qwv=oSxcall akx(function s4o)return oSxendfunctionfunction s6o takes integer oSx returns integerlocal integer rvx=(MZ[(oSx)])+1call pbx(oSx,rvx)return rvxendfunctionfunction s7o takes integer oSx,string icx returns nothingset d0[oSx]=icxcall pTx(oSx)endfunctionfunction s8o takes nothing returns stringlocal real s9o=(oG[(lw)])*100.*1./(rG[(lw)])
local string o7x="Meteorite is at: "
if(s9o<.25)thenset o7x=o7x+"ffff0000"endifreturn(o7x+(I2S(((R2I(((s9o)*1.))))))+"%")endfunctionfunction Svo takes integer oSx returns integerlocal integer rvx=(mZ[(oSx)])+1call pOx(oSx,rvx)return rvxendfunctionfunction Seo takes integer oSx,integer pNx,integer Sxo,integer Soo,real oux returns nothingif(Sxo>Soo)thencall Seo(oSx,pNx,Soo,Sxo,oux)else
loop
exitwhen(Sxo>Soo)call PYx((oSx),pNx,Sxo,oux)set Sxo=Sxo+1endloopendifendfunctionfunction Sro takes integer oDx,integer pNx returns nothinglocal integer oSx=oDxset QCv[oSx]=pNx
endfunctionfunction Sio takes nothing returns booleanlocal integer rFx=(bv)local integer Saolocal integer oMxlocal integer M6xlocal integer Snolocal integer SVolocal integer rMxlocal string SEo
set Qcv=Xdx("Infoboard_Event_Start: set Infoboard.CHARGES_CHANGE_EVENT = Event.Create(ITEM.ChargesAmount.DUMMY_EVENT_TYPE, EventPriority.MISC, function Infoboard.Event_ChargesChange)",QS,lI,function sHo)set Qfv=Xdx("Infoboard_Event_Start: set Infoboard.DROP_EVENT = Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.MISC, function Infoboard.Event_Drop)",Dcv,lI,function sko)set QFv=Xdx("Infoboard_Event_Start: set Infoboard.MOVE_EVENT = Event.Create(UNIT.Items.Events.MoveInInventory.DUMMY_EVENT_TYPE, EventPriority.MISC, function Infoboard.Event_Move)",Ddv,lI,function sKo)
set Qgv=Xdx("Infoboard_Event_Start: set Infoboard.PICK_UP_EVENT = Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.MISC, function Infoboard.Event_PickUp)",DIv,lI,function slo)call Dcx(Xdx("Infoboard_Event_Start: call Event.Create(Act.START_EVENT_TYPE, EventPriority.MISC, function Infoboard.Event_ActStart).AddToStatics()",jqv,lI,function sMo))call Dcx(Xdx("Infoboard_Event_Start: call Event.Create(AfterIntro.FOR_PLAYER_EVENT_TYPE, EventPriority.MISC, function Infoboard.Event_AfterIntro).AddToStatics()",jCv,lI,function sqo))call Dcx(Xdx("Infoboard_Event_Start: call Event.Create(HeroSelection.DUMMY_EVENT_TYPE, EventPriority.MISC, function Infoboard.Event_HeroPick).AddToStatics()",Jwv,lI,function sSo))call Dcx(Xdx("Infoboard_Event_Start: call Event.Create(Level.START_EVENT_TYPE, EventPriority.MISC2, function Infoboard.Event_LevelStart).AddToStatics()",We,LI,function sWo))set Qdv=s5o()set Sao=(s6o(Qdv))if(lw!=w)thencall s7o((Qdv),(s8o()))endifset Qhv=Svo(Qdv)
set QQv=Svo(Qdv)
set QDv=Svo(Qdv)
call pCx(Qdv,Sao,Qhv,iSx("Players","ffffcc00"))call PYx(Qdv,Sao,Qhv,.06)call pCx(Qdv,Sao,QQv,iSx("Status","ffffcc00"))call PYx(Qdv,Sao,QQv,.04)call pCx(Qdv,Sao,QDv,iSx("Items in Inventory","ffffcc00"))call PYx(Qdv,Sao,QDv,.1)
set Sao=(s6o(Qdv))call pCx(Qdv,Sao,Qhv,"=================================================")call PYx(Qdv,Sao,Qhv,.2)
call Seo(Qdv,Sao,Qhv+1,(mZ[(Qdv)]),.0)set Sao=(s6o(Qdv))set oMx=0loop
exitwhen(oMx>HSv)set M6x=Htv[oMx]
set Sno=(Huv[(M6x)])
if(Sno!=HIv)then
set SVo=(kv[(M6x)])set Sao=(s6o(Qdv))call PYx(Qdv,Sao,Qhv,.06)call PYx(Qdv,Sao,QQv,.04)set rMx=6-1loop
call PYx(Qdv,Sao,QDv+rMx*2,.007)
call PYx(Qdv,Sao,QDv+rMx*2+1,.012)set rMx=rMx-1exitwhen(rMx<0)endloopcall Sro(M6x,Sao)call sQo(M6x)if(Sno==Hgv)then
set SEo=(xb[(M6x)])else
set SEo="ff7F7F7F"endifcall pCx(Qdv,Sao,Qhv,iSx((ob[(M6x)]),SEo))else
call Sro(M6x,-1)
endifset oMx=oMx+1endloopset Sao=(s6o(Qdv))call PYx(Qdv,Sao,Qhv,.2)
call Seo(Qdv,Sao,Qhv+1,(mZ[(Qdv)]),.0)set Sao=(s6o(Qdv))call PYx(Qdv,Sao,Qhv,.1)
call sgo(Qdv,Sao,Qhv+1,"ReplaceableTextures\\CommandButtons\\BTNOrcMeleeUpOne.blp")call sgo(Qdv,Sao,Qhv+2,"ReplaceableTextures\\CommandButtons\\BTNImprovedBows.blp")call sgo(Qdv,Sao,Qhv+3,"ReplaceableTextures\\CommandButtons\\BTNStaffOfNegation.blp")call sgo(Qdv,Sao,Qhv+5,"ReplaceableTextures\\CommandButtons\\BTNInvisibility.blp")call sgo(Qdv,Sao,Qhv+6,"ReplaceableTextures\\CommandButtons\\BTNBootsOfSpeed.blp")call sgo(Qdv,Sao,Qhv+7,"ReplaceableTextures\\CommandButtons\\BTNGenericSpellImmunity.blp")call sgo(Qdv,Sao,Qhv+8,"ReplaceableTextures\\CommandButtons\\BTNSelfDestruct.blp")call sgo(Qdv,Sao,Qhv+9,"ReplaceableTextures\\CommandButtons\\BTNReincarnation.blp")call Seo(Qdv,Sao,Qhv+1,Qhv+9,.01)call Seo(Qdv,Sao,Qhv+9+1,(mZ[(Qdv)]),.0)
set QPv=(s6o(Qdv))call pCx(Qdv,QPv,Qhv,"This round")call PYx(Qdv,QPv,Qhv,.1)
call Seo(Qdv,QPv,Qhv+1,Qhv+1+8,.01)call Seo(Qdv,QPv,Qhv+1+8+1,(mZ[(Qdv)]),.0)set Sao=(s6o(Qdv))call pCx(Qdv,Sao,Qhv,"Next round")call PYx(Qdv,Sao,Qhv,.1)
call Seo(Qdv,Sao,Qhv+1,Qhv+1+8,.01)call Seo(Qdv,Sao,Qhv+1+8+1,(mZ[(Qdv)]),.0)set Sao=(s6o(Qdv))set QGv=(s6o(Qdv))call pCx(Qdv,QGv,Qhv,sLo())call PYx(Qdv,QGv,Qhv,.2)
set QHv=(s6o(Qdv))call pCx(Qdv,QHv,Qhv,suo())call PYx(Qdv,QHv,Qhv,.2)
return trueendfunctionfunction SXo takes nothing returns booleancall Dcx(Xdx("Infoboard_Init: call Event.Create(EventType.START, EventPriority.MISC, function Infoboard.Event_Start).AddToStatics()",EE,lI,function Sio))return trueendfunctionfunction SOo takes nothing returns booleancall kzo(function SXo,"Infoboard_Init")return trueendfunctionfunction SRo takes nothing returns booleanset Q4v=VXx(Q5v)
return trueendfunctionfunction SIo takes integer oSx returns integerset svv[oSx]=trueset sev[oSx]=falsecall rEx(Q4v)return oSxendfunctionfunction SAo takes nothing returns integerlocal integer oSxif(Q6v==8190)thencall o_x("Infocard_Allocation_allocCustom","call DebugEx(Infocard.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Q5v+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Q7v[(w)]==w)thenset Q8v=Q8v+1set oSx=Q8velse
set oSx=Q7v[(w)]
set Q7v[(w)]=Q7v[Q7v[(w)]]endifset Q7v[oSx]=Zset Q9v[oSx]=1call SIo(oSx)return oSxendfunctionfunction SNo takes boolean Sbo,string SBo,string Qvo,string Sco returns integerlocal integer oSx=SAo()local quest oqx=CreateQuest()set sxv[oSx]=oqx
call QuestSetDescription(oqx,Qvo)call QuestSetIconPath(oqx,Sco)call QuestSetRequired(oqx,Sbo)call QuestSetTitle(oqx,SBo)return oSxendfunctionfunction SCo takes nothing returns stringset sov=""set sov=sov+(iSx("Development:","ffffcc00"))+"
"
set sov=sov+((i1x(("WaterKnight"),"ff00bfff","ffffffff")))+"
"set sov=sov+("")+"
"
set sov=sov+(iSx("Imports:","ffffcc00"))+"
"
set sov=sov+("Balduir: "+(i1x(("supertoinkz"),"ff00bfff","ffffffff")))+"
"set sov=sov+("Bleeding: "+(i1x(("cotd333"),"ff00bfff","ffffffff")))+"
"set sov=sov+("Console: "+(i1x(("Kwaliti"),"ff00bfff","ffffffff")))+"
"set sov=sov+("Cityscape Set: "+(i1x(("xXm0RpH3usXx"),"ff00bfff","ffffffff")))+"
"set sov=sov+("EnchantedArrowBlueEffect: "+(i1x(("nGy"),"ff00bfff","ffffffff")))+"
"set sov=sov+("EnchantedArrowFlash: "+(i1x(("epsilon"),"ff00bfff","ffffffff")))+"
"set sov=sov+("EnchantedArrowSkeleton: "+(i1x(("Wrathion"),"ff00bfff","ffffffff")))+"
"set sov=sov+("GhostSword: "+(i1x(("jatter2"),"ff00bfff","ffffffff")))+"
"set sov=sov+("Immortality: "+(i1x(("Daelin"),"ff00bfff","ffffffff")))+"
"set sov=sov+("KhakiRecoveryVortex: "+(i1x(("Power"),"ff00bfff","ffffffff")))+"
"
set sov=sov+("Loadscreen Background: "+(i1x(("www.dreamscene.org"),"ff00bfff","ffffffff")))+"
"set sov=sov+("OrcAssassin: "+(i1x(("Linaze"),"ff00bfff","ffffffff")))+"
"set sov=sov+("Preview: "+(i1x(("www.albabackgrounds.com"),"ff00bfff","ffffffff")))+"
"set sov=sov+("SakeBombBarrel: "+(i1x(("Dojo"),"ff00bfff","ffffffff")))+"
"set sov=sov+("SakeBombMissile: "+(i1x(("RetroSexual"),"ff00bfff","ffffffff")))+"
"set sov=sov+("SnowPine: "+(i1x(("Gottfrei"),"ff00bfff","ffffffff")))+"
"
set sov=sov+("SpearScout: "+(i1x(("Dojo"),"ff00bfff","ffffffff")))+"
"set sov=sov+("TaintedLeafHeal: "+(i1x(("WILL_THE_ALMIGHTY"),"ff00bfff","ffffffff")))+"
"
set sov=sov+("Tarog: "+(i1x(("Dojo"),"ff00bfff","ffffffff")))+"
"set sov=sov+("ThunderstrikeBolt: "+(i1x(("Tranquil"),"ff00bfff","ffffffff")))+"
"set sov=sov+("ThunderstrikeCharge: "+(i1x(("marcus158"),"ff00bfff","ffffffff")))+"
"
set sov=sov+("ThunderstrikeNova: "+(i1x(("dhguardianes"),"ff00bfff","ffffffff")))+"
"set sov=sov+("Tower: "+(i1x(("unknownczar"),"ff00bfff","ffffffff")))+"
"
set sov=sov+("VictorHammer: "+(i1x(("Thrikodius"),"ff00bfff","ffffffff")))+"
"set sov=sov+("VioletEarringMissile: "+(i1x(("EdwardSwolenToe"),"ff00bfff","ffffffff")))+"
"set sov=sov+("VioletEarringWeaponAttach: "+(i1x(("marcus158"),"ff00bfff","ffffffff")))+"
"set sov=sov+("Wall: "+(i1x(("Rondo"),"ff00bfff","ffffffff")))+"
"set sov=sov+("WallEnd: "+(i1x(("Rondo"),"ff00bfff","ffffffff")))+"
"
set sov=sov+("")+"
"
set sov=sov+("Everything may be modified in order to fit the map. Rather than exporting stuff you are interested in, refer to the credits.txt enclosed in the map archive.")+"
"
return sovendfunctionfunction Sdo takes nothing returns booleancall SNo(false,"Commands","!"+" + any string: character speech"+"
","ReplaceableTextures\\CommandButtons\\BTNCommand.blp")call SNo(false,"Credits",SCo(),"ReplaceableTextures\\CommandButtons\\BTNStormEarth&Fire.blp")call SNo(true,"Introduction",srv+"
"+siv+"
"+sav,"ReplaceableTextures\\CommandButtons\\BTNPenguin.blp")call SNo(true,"Objective","Defend the meteorite at all costs!","ReplaceableTextures\\CommandButtons\\BTNArcaneObservatory.blp")call SNo(false,"Mechanics: Dying","When you die, your hero is transformed into a ghost and teleported to the graveyard. There, you will regenerate mana to a maximum of 100 that you can then use to execute your ascension. You can freely move your spirit around but mana is only refreshed while staying at the graveyard. However, it might be useful to leave the area after being filled up to gain a better spot for reviving. The meteorite also has a spell to replenish mana that even works on ghosts.","ReplaceableTextures\\CommandButtons\\BTNSacrifice.blp")
call SNo(false,"Mechanics: Meteorite","Failing at protecting the meteorite above the center of the castle will result in your team's defeat."+"
"+"The highest player spot does have control of the meteorite and can thereby make use of it to cast some valuable spells.","ReplaceableTextures\\CommandButtons\\BTNUndeadShrine.blp")call SNo(false,"Mechanics: Snowmen","There is one snowman figurine in front of each of the castle's entries. By giving them a lovely stroke they will not turn abominable but rather grant you sight trough their coal eyes that even detect invisible entities. The snowman will revert to neutral aggressive after "+(I2S(((R2I(((((30.)*1.))*1.))))))+" seconds.","")
call SNo(false,"Mechanics: Special spawns' attributes","The infoboard in the upper right corner of your screen shows, among other things, whether the current or next round's attacker spawns are of special behavior/have special abilities. These are, from left to right:"+"
"+"Melee: wave contains melee attackers"+"
"+"Ranged: wave contains ranged attackers"+"
"+"Magician: wave contains casters with magical abilities (this does not include physical abilities)"+"
"+"
"+"Runner: wave contains spawns that avoid aggressions and instead of this directly storm to the meteorite, they get easily dazed when being attacked from behind"+"
"+"Invis: wave contains invisible units"+"
"+"Magic immune: wave contains enemies that are immune to magical abilities"+"
"+"Kamikaze: wave contains suicidal spawns that detonate themselves to get rid of you!"+"
"+"Boss: boss wave, every sixth (last) wave of an chapter","ReplaceableTextures\\CommandButtons\\BTNDarkSummoning.blp")
call SNo(false,"Mechanics: Spell purchase","Your hero can only learn four characteristic spells plus the innate ability but further magical item scrolls can be purchased from the "+(GetObjectName(Ikv[(snv)]))+". In contrast to other charged items, one scroll's ability is displayed in the unit's command card (can be switched by pressing the item buttons) and these skills can be leveled up like other hero abilities.","ReplaceableTextures\\CommandButtons\\BTNBansheeAdept.blp")call FlashQuestDialogButton()return trueendfunctionfunction SDo takes nothing returns booleancall kzo(function Sdo,"Infocard_Init")return trueendfunctionfunction Sfo takes nothing returns booleanset sVv=VXx(sEv)
return trueendfunctionfunction SFo takes nothing returns nothingset hf=oPx(GetEnumPlayer())endfunctionfunction Sgo takes integer oSx returns integerset hf=w
call ForForce(LD[oSx],function SFo)return hfendfunctionfunction SGo takes integer oDx returns nothinglocal integer rFx=rRx(0)
local integer oMxlocal integer rbxlocal integer rMxset ZA[(rFx)]=(oDx)call ForceRemovePlayer(LD[(JJv)],vx[(oDx)])set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((jCv))-1)*Iv+(((rbx))-1)))))))))
loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((jCv))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction Sho takes nothing returns nothinglocal integer rFx=rRx(0)
local integer SHolocal integer oMxlocal integer rbxlocal integer rMxloop
set SHo=Sgo(JJv)
exitwhen(SHo==w)
call SGo(SHo)endloopset oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Jjv))-1)*Iv+(((rbx))-1)))))))))
loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Jjv))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction Sjo takes nothing returns nothingcall Sho()endfunctionfunction SJo takes integer oSx,integer oDx,boolean iTx returns nothingif iTx thencall hQx(oSx,oDx)else
call hLx(oSx,oDx)endifendfunctionfunction Sko takes nothing returns booleanlocal integer rFx=(bv)local integer oMx=0loop
set sRv=kh[oMx]exitwhen((Huv[(sRv)])==Hgv)set oMx=oMx+1endloopcall SJo(sIv,sRv,true)return trueendfunctionfunction SKo takes nothing returns booleanif((Tf[(jhx())])!=Hf)thenreturn false
endifreturn truereturn trueendfunctionfunction Slo takes integer oSx returns integerset sCv[oSx]=trueset sdv[oSx]=falseset YM[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set ap[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(tM)
return oSxendfunctionfunction SLo takes nothing returns integerlocal integer oSxif(sNv==8190)thencall o_x("Dialog_Allocation_allocCustom","call DebugEx(Dialog.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",TM+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(sbv[(w)]==w)thenset sBv=sBv+1set oSx=sBvelse
set oSx=sbv[(w)]
set sbv[(w)]=sbv[sbv[(w)]]endifset sbv[oSx]=Zset scv[oSx]=1call Slo(oSx)return oSxendfunctionfunction Smo takes integer oSx returns nothingset zM[(oSx)]=(sDv+oSx)endfunctionfunction SMo takes integer oSx,integer Spo returns nothingcall TriggerRegisterDialogEvent(DA[(oSx)],ep[Spo])endfunctionfunction SPo takes nothing returns integerlocal dialog oqx=DialogCreate()local integer oSx=SLo()set ep[oSx]=oqxcall SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oqx))))),((((WM)))),((((oSx)))))
set oqx=null
call Smo(oSx)call SMo(UM,oSx)
return oSxendfunctionfunction Sqo takes integer oSx returns integerset shv[oSx]=trueset sHv[oSx]=falsecall rEx(lTv)return oSxendfunctionfunction SQo takes nothing returns integerlocal integer oSxif(sfv==8190)thencall o_x("Difficulty_Allocation_allocCustom","call DebugEx(Difficulty.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",luv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(sFv[(w)]==w)thenset sgv=sgv+1set oSx=sgvelse
set oSx=sFv[(w)]
set sFv[(w)]=sFv[sFv[(w)]]endifset sFv[oSx]=Zset sGv[oSx]=1call Sqo(oSx)return oSxendfunctionfunction Sso takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((sKv[(oSx)]))])]))],((((slv[((oSx))])))),(((otx))),(((oux))))
endfunctionfunction SSo takes integer oSx returns integerset sPv[oSx]=trueset sqv[oSx]=falseset sKv[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set sQv[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(fM)
return oSxendfunctionfunction Sto takes nothing returns integerlocal integer oSxif(sLv==8190)thencall o_x("DialogButton_Allocation_allocCustom","call DebugEx(DialogButton.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",FM+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(smv[(w)]==w)thenset sMv=sMv+1set oSx=sMvelse
set oSx=smv[(w)]
set smv[(w)]=smv[smv[(w)]]endifset smv[oSx]=Zset spv[oSx]=1call SSo(oSx)return oSxendfunctionfunction STo takes integer oSx returns nothingset slv[(oSx)]=(ssv+oSx)
endfunctionfunction Suo takes string icx,integer SUo returns integerlocal integer oSx=Sto()call STo(oSx)set sSv[(oSx)]=(SUo)
set stv[(oSx)]=(icx)
return oSxendfunctionfunction Swo takes integer oSx,integer otx,integer oux returns booleanreturn rux(sKv[(oSx)],(slv[((oSx))]),otx,oux)endfunctionfunction SWo takes integer oSx,integer hPx returns nothinglocal button Syo=DialogAddButton(ep[(oSx)],stv[hPx],sSv[hPx])call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((Syo))))),((((wM)))),((((hPx)))))
call SaveButtonHandle(fO[(X)],(suv+oSx),(sUv+hPx),(Syo))
set Syo=null
endfunctionfunction SYo takes integer oSx,integer o5x returns nothingcall hKx((oSx),sTv,o5x)call Swo(o5x,sTv,oSx)call SWo(oSx,o5x)endfunctionfunction Szo takes integer oSx,string icx,integer SUo returns integerlocal integer o7x=Suo(icx,SUo)call SYo(oSx,o7x)return o7xendfunctionfunction SZo takes integer oSx returns booleanset sWv=sWv+1set syv[sWv]=oSx
set sYv[oSx]=sWv+1return(sWv==0)endfunctionfunction S_o takes string S0o,code S1o,code S2o returns integerlocal integer oSx=SQo()set sjv[oSx]=S0o
set sJv[oSx]=XJx(S1o)set skv[oSx]=XJx(S2o)call Sso(Szo(sIv,S0o,0),swv,oSx)
call SZo(oSx)return oSxendfunctionfunction S3o takes nothing returns booleanreturn trueendfunctionfunction S4o takes integer oSx returns integerset s3v[oSx]=trueset s4v[oSx]=falsecall rEx(nq)
return oSxendfunctionfunction S5o takes nothing returns integerlocal integer oSxif(s_v==8190)thencall o_x("Announcement_Allocation_allocCustom","call DebugEx(Announcement.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Vq+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(s0v[(w)]==w)thenset s1v=s1v+1set oSx=s1velse
set oSx=s0v[(w)]
set s0v[(w)]=s0v[s0v[(w)]]endifset s0v[oSx]=Zset s2v[oSx]=1call S4o(oSx)return oSxendfunctionfunction S6o takes integer oux returns integerlocal integer oSx=S5o()set s5v[oSx]=oux
return oSxendfunctionfunction S7o takes nothing returns booleanreturn trueendfunctionfunction S8o takes nothing returns booleanlocal integer rFx=(bv)local integer lCo=(Bbv[(rFx)])local integer OSx=(Vv[(rFx)])local integer oSx=Lnx(lCo,s9v)call OCo(Svv[oSx],OSx)call r0x(((OSx)),((Svv[oSx])),(1))return trueendfunctionfunction S9o takes integer oSx returns integerset SVv[oSx]=trueset SEv[oSx]=falsecall rEx(SXv)return oSxendfunctionfunction tvo takes nothing returns integerlocal integer oSxif(Sov==8190)thencall o_x("Artifact_Allocation_allocCustom","call DebugEx(Artifact.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Srv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Siv[(w)]==w)thenset Sav=Sav+1set oSx=Savelse
set oSx=Siv[(w)]
set Siv[(w)]=Siv[Siv[(w)]]endifset Siv[oSx]=Zset Snv[oSx]=1call S9o(oSx)return oSxendfunctionfunction teo takes integer oSx,integer XYx returns nothingif(BBv[oSx]==w)thencall o_x("FolderUnitType_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oSx)+";"+(jA[(XYx)]))set BBv[oSx]=Xendifcall rux(BBv[oSx],(kw[((oSx))]),(oA[(XYx)]),XYx)
endfunctionfunction txo takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=ROx()local integer oSx=Lnx((Tf[(OSx)]),s9v)call OCo(Svv[oSx],OSx)call r0x(((OSx)),((Svv[oSx])),(1))return trueendfunctionfunction too takes integer lCo,integer rlx returns integerlocal integer oSx=tvo()set Svv[oSx]=rlx
call hMo(lCo,s9v,oSx)call teo(lCo,s8v)call kTo(lCo,function txo)return oSxendfunctionfunction tro takes nothing returns nothingset s8v=Xdx("Artifact_Start: set Artifact.CREATE_EVENT = Event.Create(Unit.CREATE_EVENT_TYPE, EventPriority.MISC, function Artifact.Event_Create)",IJv,lI,function S8o)set Sev=O5x()set Sxv=true
call too(Gwv,SOv)call too(Grv,SRv)call too(GHv,SIv)call too(gpv,SAv)call too(g4v,SNv)call too(hNv,Sbv)call too(GCv,SBv)call too(G4v,Scv)call too(gYv,SCv)call ipx(Ge,iSx("Artifacts are enabled.","ff00ff00"),30.)endfunctionfunction tio takes integer lCo,integer rlx returns nothinglocal integer Iixcall hpo((lCo),(rlx),1)set Hf=lCocall GroupEnumUnitsInRect(kb[((sXv))],bm[Bm],Bv[(sAv)])loop
set Iix=NEo(sXv)
exitwhen(Iix==w)
call r0x(((Iix)),((rlx)),(1))endloopendfunctionfunction tao takes nothing returns booleancall tro()call tio(GZv,Sdv)call tio(gKv,SDv)call tio(GOv,Sfv)call tio(G3v,SFv)call tio(GSv,Sgv)call tio(Glv,SGv)return trueendfunctionfunction tno takes nothing returns booleanreturn trueendfunctionfunction tVo takes integer oSx,real oux returns nothingset Nlv[(oSx)]=(((Nlv[(oSx)])+oux)*1.)endfunctionfunction tEo takes nothing returns booleancall tio(GZv,SHv)call tio(gLv,Sdv)call tio(hdv,Sjv)call tVo(Gqv,2.)
call tVo(Glv,2.)
call tio(GOv,SJv)call tio(GSv,Skv)call tio(GAv,SKv)call tio(GEv,GRv)call tio(hDv,Slv)return trueendfunctionfunction tXo takes integer oSx,integer XYx returns nothingif(ap[oSx]==w)thencall o_x("FolderDialog_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oSx)+";"+(jA[(XYx)]))
set ap[oSx]=Xendifcall rux(ap[oSx],(zM[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction tOo takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((sKv[(oSx)]))])]))],((((slv[((oSx))])))),(((otx)))))endfunctionfunction tRo takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((YM[oSx]))])])],((((zM[((oSx))])))))endfunctionfunction tIo takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((ap[oSx]))])])],((((zM[((oSx))])))))endfunctionfunction tAo takes integer oSx returns nothingset sCv[oSx]=falsecall tRo((oSx))call tIo(((oSx)))call rHx(tM)
endfunctionfunction tNo takes integer oSx returns nothingif(scv[oSx]>0)thenreturnendifif(sbv[oSx]!=Z)thencall o_x("Dialog_Allocation_deallocCustom_confirm","call DebugEx(Dialog.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",TM+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset sbv[oSx]=sbv[(w)]set sbv[(w)]=oSx
call tAo(oSx)endfunctionfunction tbo takes integer oSx returns nothingset scv[oSx]=scv[oSx]-1call tNo(oSx)endfunctionfunction tBo takes integer oSx returns nothinglocal dialog oqx=ep[oSx]
call tbo((oSx))call DialogDestroy(oqx)set oqx=null
endfunctionfunction tco takes integer oSx returns nothingif(bq==oSx)thenreturnendifset bq=oSxcall Chx(Ge,PLAYER_STATE_RESOURCE_FOOD_USED,s5v[oSx]+1)endfunctionfunction tCo takes nothing returns booleancall tco(sZv[pe])return trueendfunctionfunction tdo takes nothing returns nothingcall iKx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))call tCo()endfunctionfunction tDo takes nothing returns nothingif(jpv!=w)thencall kBo(jpv)endifset Aov[(lw)]=((.0)*1.)call tco(S6o(1))
call iDx(iXx(),5.,false,function tdo)call kDo(jzv)endfunctionfunction tfo takes nothing returns booleanlocal integer rFx=(bv)local integer tFo=(rp[(rFx)])local integer tgo=(ip[(rFx)])local integer oSx=tOo(tgo,swv)local integer oLxlocal integer oMxlocal string tGo
call tBo(tFo)call pjx(sRv,sOv)set pe=oSxcall ipx(Ge,sjv[oSx],30.)call Chx(Ge,PLAYER_STATE_RESOURCE_GOLD,(s7v[(oSx)]))
set oLx=(sYv[(oSx)]-1)set oMx=0loop
exitwhen(oMx>=oLx)if(skv[syv[oMx]]!=w)then
call rDx(skv[syv[oMx]])endifset oMx=oMx+1endloopset tGo="Enemies have "+iSx((I2S(((R2I((((s6v[(oSx)])*'d')*1.)))))),"ffffcc00")+"% damage and "+iSx((I2S(((R2I((((Me[(oSx)])*'d')*1.)))))),"ffffcc00")+"% hitpoints."call ipx(Ge,tGo,30.)
if(sJv[oSx]!=w)thencall rDx(sJv[oSx])endifif(skv[oSx]!=w)thencall rDx(skv[oSx])endifif not Sxv thencall ipx(Ge,iSx("Artifacts are disabled.","ffff0000"),30.)endifcall tDo()return trueendfunctionfunction tho takes nothing returns nothinglocal integer oSxlocal integer oMxcall iKx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))set sXv=O5x()set sOv=Xdx("Difficulty_Start: set Difficulty.LEAVE_EVENT = Event.Create(User.LEAVE_EVENT_TYPE, EventPriority.MISC, function Difficulty.Event_Leave)",Hvv,lI,function Sko)set sAv=Xpx(function SKo)set sIv=SPo()set oSx=S_o("Castle visitor (easy)",function S3o,null)set szv=oSxset sZv[oSx]=S6o(2)set s6v[(oSx)]=((1.)*1.)
set s7v[(oSx)]=(500)
set Me[(oSx)]=((1.)*1.)set oSx=S_o("Vassal (medium)",function S7o,function tao)
set Shv=oSxset sZv[oSx]=S6o(3)set s6v[(oSx)]=((1.25)*1.)set s7v[(oSx)]=(400)
set Me[(oSx)]=((1.25)*1.)set oSx=S_o("Knight (hard)",function tno,function tEo)set SLv=oSxset sZv[oSx]=S6o(4)set s6v[(oSx)]=((1.5)*1.)set s7v[(oSx)]=(300)
set Me[(oSx)]=((1.5)*1.)
set oSx=S_o("Penguin (Test mode)",null,null)
set qvv=oSxset sZv[oSx]=S6o(5)set s6v[(oSx)]=((.75)*1.)set s7v[(oSx)]=($5DC)set Me[(oSx)]=((.75)*1.)
set oMx=0loop
set sRv=kh[oMx]exitwhen((Huv[(sRv)])==Hgv)set oMx=oMx+1endloopcall DialogSetMessage(ep[(sIv)],("Declare yourself!"))call p_x(sRv,sOv)call tXo(sIv,Xdx("Difficulty_Start: call Difficulty.THIS_DIALOG.Event.Add(Event.Create(Dialog.CLICK_EVENT_TYPE, EventPriority.MISC, function Difficulty.Event_DialogClick))",uM,lI,function tfo))call SJo(sIv,sRv,true)endfunctionfunction tHo takes integer oSx returns integerset Ssv[oSx]=trueset SSv[oSx]=falsecall rEx(Cl)
return oSxendfunctionfunction tjo takes nothing returns integerlocal integer oSxif(Spv==8190)thencall o_x("Camera_Allocation_allocCustom","call DebugEx(Camera.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",dl+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(SPv[(w)]==w)thenset Sqv=Sqv+1set oSx=Sqvelse
set oSx=SPv[(w)]
set SPv[(w)]=SPv[SPv[(w)]]endifset SPv[oSx]=Zset SQv[oSx]=1call tHo(oSx)return oSxendfunctionfunction tJo takes camerasetup oqx returns integerlocal integer oSx=tjo()set Stv[oSx]=oqx
return oSxendfunctionfunction tko takes integer oDx,boolean iTx,real iMx returns nothingif iOx(oDx)thencall ShowInterface(iTx,iMx)endifendfunctionfunction tKo takes integer oDx,boolean iTx returns nothingif iOx(oDx)thencall EnableUserControl(iTx)endifendfunctionfunction tlo takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((cA[oSx]))])])],((((gA[((oSx))])))))endfunctionfunction tLo takes integer oSx returns nothingset bA[oSx]=falsecall tlo((oSx))call rHx(CA)
endfunctionfunction tmo takes integer oSx returns nothingif(NA[oSx]>0)thenreturnendifif(IA[oSx]!=Z)thencall o_x("Trigger_Allocation_deallocCustom_confirm","call DebugEx(Trigger.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Dv+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset IA[oSx]=IA[(w)]set IA[(w)]=oSxcall tLo(oSx)endfunctionfunction tMo takes integer oSx returns nothingset NA[oSx]=NA[oSx]-1call tmo(oSx)endfunctionfunction tpo takes integer oSx returns nothinglocal trigger oqx=DA[oSx]call tMo((oSx))call DisableTrigger(oqx)
set oqx=null
endfunctionfunction tPo takes nothing returns nothinglocal real x=(tm[(PEv)])
local real y=(Tm[(PEv)])
call EndCinematicScene()
call tko(Ge,true,1.)
call tKo(Ge,true)call tpo(S0v)call R4x(S1v,false)call R4x(S2v,false)call Mfx(S3v)call Mfx(S4v)call Mfx(S5v)call Mfx(S6v)call Mfx(S7v)if(S8v!=w)thencall Mfx(S8v)endifif(S9v!=w)thencall Mfx(S9v)endifcall sIo(Ge,.0)call qDo(Ge,x,y,.0)call Sho()call iDx(tvv,1.,false,function tho)endfunctionfunction tqo takes nothing returns booleanlocal integer oMx=0local integer oDx=(oPx(GetTriggerPlayer()))local integer tQo=(HQv[(oDx)]-1)
call SGo((oDx))loop
exitwhen((Huv[(kh[oMx])])==Hgv)set oMx=oMx+1endloopif(tQo==oMx)then
call tPo()endifreturn trueendfunctionfunction tso takes integer mfx,integer jqo,real tSo returns integerlocal real tto=(tm[(jqo)])local real tTo=(Tm[(jqo)])local integer l0o=mDx(mfx,tto,tTo,.0,tSo)call SetUnitColor(vJ[((l0o))],(PLAYER_COLOR_BROWN))return l0oendfunctionfunction tuo takes integer mfx,integer jqo,integer OSx returns integerlocal real tto=(tm[(jqo)])local real tTo=(Tm[(jqo)])local real tSo=(Atan2((((EJ[(OSx)])-tTo)*1.),(((iJ[(OSx)])-tto)*1.)))local integer l0o=mDx(mfx,tto,tTo,.0,tSo)call SetUnitColor(vJ[((l0o))],(PLAYER_COLOR_BROWN))return l0oendfunctionfunction tUo takes integer OSx,string icx,real iMx,code two returns nothingcall AddIndicator(vJ[(OSx)],($7F),($7F),($7F),(63))call SetCinematicScene(((Ky[(OSx)])),(PLAYER_COLOR_BROWN),((GetHeroProperName(vJ[(OSx)]))),(icx),((iMx)*1.),((iMx*.8)*1.))call iDx(tvv,iMx,false,two)endfunctionfunction tWo takes integer tyo,real iMx,code two returns nothing
call CameraSetupApplyForceDuration(Stv[(tyo)],(true),((iMx)*1.))
call iDx(tvv,iMx,false,two)endfunctionfunction tYo takes integer oSx,integer tzo returns nothingcall mNx(oSx,(Atan2((((EJ[(tzo)])-(EJ[((oSx))]))*1.),(((iJ[(tzo)])-(iJ[((oSx))]))*1.))))
endfunctionfunction tZo takes integer OSx,integer jqo returns nothingcall DQx(OSx,(tm[(jqo)]))call DSx(OSx,(Tm[(jqo)]))endfunctionfunction t_o takes integer oSx,integer Iix returns nothingcall mNx(oSx,(Atan2((((Hm[(Iix)])-(EJ[((oSx))]))*1.),(((hm[(Iix)])-(iJ[((oSx))]))*1.))))
endfunctionfunction t0o takes integer OSx,integer jqo returns nothingcall IssuePointOrderById(vJ[((OSx))],pb[(Bh)],(((tm[(jqo)]))*1.),(((Tm[(jqo)]))*1.))
endfunctionfunction t1o takes integer izx,integer iZx,integer i_x,integer i0x,real iMx,code two returns nothing
local integer t2o=qBo()call qEo(t2o,izx,iZx,i_x,$FF)call qXo(t2o,$FF,$FF,$FF,0)set plv[(t2o)]=("ReplaceableTextures\\CameraMasks\\White_mask.blp")call qfo(t2o,iMx,Ge)
call iDx(tvv,iMx,false,two)endfunctionfunction t3o takes nothing returns nothingcall iDx(tvv,((3.)*1.),false,(function tPo))
endfunctionfunction t4o takes nothing returns nothingcall CameraSetupApplyForceDuration(Stv[((S_v))],(true),((((5.)*1.))*1.))
call t1o(0,0,0,0,4.,function t3o)endfunctionfunction t5o takes nothing returns nothingcall tUo(S3v,"Wintercastle should be a place for all that are in need of help. In these difficult times, we have to stick together, and as I am looking here, there seem to be already all kind of peoples. So break up your disputes and let's take it on at last...",12.,function t4o)
endfunctionfunction t6o takes nothing returns nothingcall tUo(S4v,"I have to agree with lady Aruruw in this matter.",3.,function t5o)
endfunctionfunction t7o takes nothing returns nothingcall tUo(S6v,"We shouldn't trust him, Milord. He could be a spy just as well. And even if he speaks the truth, he will still just cause trouble for us with his presence. I am aware of the Orcs' nature and their determination to wipe out every traitor.",10.,function t6o)endfunctionfunction t8o takes nothing returns nothingcall tUo(S9v,"Furthermore, my clan yearns to kill me. Hence, I would like to ask for refuge. As a reward, I promise you to help in every matter, until my legs won't carry me any longer.",9.,function t7o)endfunctionfunction t9o takes nothing returns nothingcall tYo((S9v),(S3v))call tUo(S9v,"Yes, I belong to the Orcish race, but was I expelled of my own tribe, when I hesistated to executed one of our enemies and escaped. You see, I was one of their shamans, not a fighter and never approved the violent methods of my fellows. Alone, I won't be able to last for long in this world of ice out there.",13.5,function t8o)endfunctionfunction Tvo takes nothing returns nothingcall tYo((S9v),(S5v))call tUo(S9v,"Listen to my words, please!",3.,function t9o)endfunctionfunction Teo takes nothing returns nothingcall tUo(S4v,"We should really start deploying some guard posts.",4.,function Tvo)endfunctionfunction Txo takes nothing returns nothingcall tYo((S5v),(S9v))call tUo(S5v,"Hey, you are one of these vandals!",3.,function Teo)endfunctionfunction Too takes nothing returns nothingcall tUo(S9v,"Excuse me for my rude intrusion...",3.5,function Txo)endfunctionfunction Tro takes nothing returns nothingset S9v=tso('O000',tXv,.0)call t0o(S9v,tOv)call iDx(tvv,((2.)*1.),false,(function Too))
endfunctionfunction Tio takes nothing returns nothingcall tUo(S3v,"With that said, we are complete. I myself will participate as well. The caravans, which will traverse the forest under the protection of our efforts, are already standing by.",8.,function Tro)endfunctionfunction Tao takes nothing returns nothingcall tZo(S7v,tiv)call tZo(S8v,tEv)call tYo((S5v),(S3v))call tYo((S4v),(S3v))call tYo((S6v),(S3v))call tYo((S7v),(S3v))call mNx(S3v,3.141592654)call CameraSetupApplyForceDuration(Stv[((SZv))],(true),((((.0)*1.))*1.))
call iDx(tvv,((1.)*1.),false,(function Tio))
endfunctionfunction Tno takes nothing returns nothingcall tUo(S5v,"Another gal. The group is already to my liking.",3.,function Tao)endfunctionfunction TVo takes nothing returns nothingcall tUo(S4v,"This is LIZZY, a fairy from the Mid East. She was the sole survivor, I rescued, when her homeland was destroyed by the elves. Back then, she decided to accompany me. I am confident she will complement us well with her magical abilities.",13.,function Tno)endfunctionfunction TEo takes nothing returns nothingcall tYo((S7v),(S8v))call tUo(S7v,"And you are? *hic*",2.5,function TVo)endfunctionfunction TXo takes nothing returns nothingcall tUo(S8v,"*hihi* What a primitive blubberbutt!",3.,function TEo)
endfunctionfunction TOo takes nothing returns nothingcall MGx(S8v)set S8v=tso('H007',tnv,Jf)call t0o(S8v,tVv)call tWo(Szv,2.,function TXo)endfunctionfunction TRo takes nothing returns nothingcall SetUnitAnimationByIndex(vJ[((S7v))],(6))call QueueUnitAnimation(vJ[((S7v))],("stand"))call tUo(S7v,"What the?! Where are these wretches that mess up my beer?! I thwack them until they decide to become meat eaters!",5.5,function TOo)endfunctionfunction TIo takes nothing returns nothingcall iDx(tvv,((1.)*1.),false,(function TRo))
endfunctionfunction TAo takes nothing returns nothingcall tUo(S4v,"When the animals are to steal all of the corn from the silos, there won't be any alcohol for you too soon!",5.,function TIo)endfunctionfunction TNo takes nothing returns nothingcall tUo(S7v,"Eh?",1.,function TAo)endfunctionfunction Tbo takes nothing returns nothingcall tUo(S4v,"We are in perilous situation right now, we should keep a clear mind.",3.5,function TNo)endfunctionfunction TBo takes nothing returns nothingcall tYo((S7v),(S3v))call tUo(S7v,"What?",1.,function Tbo)endfunctionfunction Tco takes nothing returns nothingcall tUo(S3v,"Stormy, now, it isn't the right time to bemuse yourself with this dazing mixture!",4.,function TBo)endfunctionfunction TCo takes nothing returns nothingcall iDx(tvv,((1)*1.),false,(function Tco))endfunctionfunction Tdo takes nothing returns nothingcall tYo((S3v),(S7v))call tYo((S5v),(S7v))call tYo((S4v),(S7v))call tYo((S6v),(S7v))call tWo(SZv,2.5,function TCo)endfunctionfunction TDo takes nothing returns nothingcall tUo(S7v,"*hic*",1.5,function Tdo)endfunctionfunction Tfo takes nothing returns nothingcall tUo(S6v,"...he stood right next to me just a moment ago.",3.,function TDo)endfunctionfunction TFo takes nothing returns nothingcall tUo(S6v,"...",.75,function Tfo)
endfunctionfunction Tgo takes nothing returns nothingcall tUo(S6v,"..",.75,function TFo)endfunctionfunction TGo takes nothing returns nothingcall tUo(S6v,".",.75,function Tgo)endfunctionfunction Tho takes nothing returns nothingcall CameraSetupApplyForceDuration(Stv[((Syv))],(true),((((.0)*1.))*1.))
call iDx(tvv,((1.)*1.),false,(function TGo))
endfunctionfunction THo takes nothing returns nothingcall tUo(S3v,"Where did he disappear to again?!",2.,function Tho)endfunctionfunction Tjo takes nothing returns nothingcall tZo(S7v,tav)call t_o((S7v),(Smv))set S8v=tso('h009',tiv,Jf)call tUo(S3v,"Then, there's Stor...",3.,function THo)endfunctionfunction TJo takes nothing returns nothingcall tWo(SMv,.5,function Tjo)endfunctionfunction Tko takes nothing returns nothingcall tYo((S5v),(S3v))call iDx(tvv,((.5)*1.),false,(function TJo))
endfunctionfunction TKo takes nothing returns nothingcall tUo(S5v,"Woo, I am impressed, young lad'.",3.,function Tko)
endfunctionfunction Tlo takes nothing returns nothingcall CameraSetupApplyForceDuration(Stv[((SWv))],(true),((((2.)*1.))*1.))
call tUo(S6v,"While approaching your castle I noticed a lot of incensed animals, on the south pass in particular. The "+iSx("Great Winter","ffffcc00")+" hit them pretty well, too, and turned them into raging creatures.",9.5,function TKo)endfunctionfunction TLo takes nothing returns nothingcall tYo((S6v),(S3v))call iDx(tvv,((1.)*1.),false,(function Tlo))
endfunctionfunction Tmo takes nothing returns nothingcall tUo(S3v,"I received information about lady Aruruw, about her excellent skills as a huntress. This might be to our advantage on this task.",9.,function TLo)
endfunctionfunction TMo takes nothing returns nothingcall tUo(S6v,"Do you aim to challenge me?",4.,function Tmo)endfunctionfunction Tpo takes nothing returns nothingcall tWo(SUv,1.,function TMo)endfunctionfunction TPo takes nothing returns nothingcall iDx(tvv,((1.)*1.),false,(function Tpo))
endfunctionfunction Tqo takes nothing returns nothingcall tYo((S6v),(S5v))call tWo(Swv,1.,function TPo)endfunctionfunction TQo takes nothing returns nothingcall tYo((S5v),(S6v))call tUo(S5v,"This shorty can fight?",2.5,function Tqo)endfunctionfunction Tso takes nothing returns nothingcall tUo(S3v,"Lady Aruruw",3.,function TQo)endfunctionfunction TSo takes nothing returns nothingcall SetUnitAnimation(vJ[((S4v))],("stand ready"))call tUo(S4v,"At your service *kindles a cigarette*",3.,function Tso)endfunctionfunction Tto takes nothing returns nothingcall CameraSetupApplyForceDuration(Stv[((Suv))],(true),((((.5)*1.))*1.))
call tUo(S3v,"Sir Smokealot",2.,function TSo)endfunctionfunction TTo takes nothing returns nothingcall tUo(S5v,"Aye",1.5,function Tto)
endfunctionfunction Tuo takes nothing returns nothingcall tWo(STv,.5,function TTo)endfunctionfunction TUo takes nothing returns nothingcall tUo(S3v,"Rocketeye",1.,function Tuo)endfunctionfunction Two takes nothing returns nothingcall SetUnitAnimation(vJ[((S3v))],("spell slam"))call QueueUnitAnimation(vJ[((S3v))],("stand"))call tUo(S3v,"Meanwhile, wild animals of the bordering woods have begun to exploit our storages and to attack the residents. This is the reason I called for the four of you.",7.,function TUo)endfunctionfunction TWo takes nothing returns booleanlocal integer rFx=(bv)local real x=(tm[(PEv)])
local real y=(Tm[(PEv)])
call qDo(Ge,x,y,.0)call iDx(iXx(),.0,false,function Sjo)call iDx(iXx(),1.,false,function tho)return trueset Smv=Gqx(uo)set SMv=tJo(ko)set STv=tJo(Ko)set Suv=tJo(lo)set SUv=tJo(Lo)set Swv=tJo(mo)set SWv=tJo(Mo)set Syv=tJo(po)set SYv=tJo(Po)set Szv=tJo(qo)set SZv=tJo(Qo)set S_v=tJo(so)set S0v=XJx(function tqo)set tvv=iXx()set tev=q2x(gx)set txv=q2x(Kx)set tov=q2x(kx)set trv=q2x(Fx)set tiv=q2x(lx)set tav=q2x(Lx)set tnv=q2x(Hx)set tVv=q2x(jx)set tEv=q2x(Jx)set tXv=q2x(mx)set tOv=q2x(Mx)set tRv=q2x(Gx)set tIv=q2x(hx)set S3v=tso(Ikv[Grv],tev,tAv)set S5v=tuo(Ikv[hNv],tov,S3v)set S4v=tuo(Ikv[GCv],txv,S3v)set S6v=tuo(Ikv[Gwv],trv,S3v)set S7v=tuo(Ikv[G4v],tiv,S3v)set S8v=wset S9v=wset tNv=tso('h008',tRv,Jf)set tbv=tso('h008',tIv,Jf)set S1v=QEx(tBv,true,false,false,0,0,j5)
set S2v=QEx(tBv,true,false,false,0,0,j5)
call tko(Ge,false,1)
call tKo(Ge,false)call CameraSetupApplyForceDuration(Stv[((tJo(ko)))],(true),((((0)*1.))*1.))call Akx(S1v)call Akx(S2v)call SetUnitAnimation(vJ[((S3v))],("spell slam"))call jwo(S0v,Ge,EVENT_PLAYER_END_CINEMATIC)call tUo(S3v,"It's about one month now that you searched for shelter in my domicile Wintercastle. Our supply reserves are at a scant stock, so we have to send out caravans in order to retrieve left-behind goods from the surrounding villages.",$B,function Two)call QueueUnitAnimation(vJ[((S3v))],("stand"))call jPo(Ge,q2x(Tx))
return trueendfunctionfunction Tyo takes nothing returns booleancall Dcx(Xdx("Intro_Init: call Event.Create(EventType.START, EventPriority.MISC, function Intro.Event_Start).AddToStatics()",EE,lI,function TWo))return trueendfunctionfunction TYo takes nothing returns booleancall kzo(function Tyo,"Intro_Init")return trueendfunctionfunction Tzo takes nothing returns booleanset tcv=VXx(tCv)
return trueendfunctionfunction TZo takes nothing returns booleanset tdv=VXx(tDv)
return trueendfunctionfunction T_o takes nothing returns booleanset tfv=VXx(tFv)
return trueendfunctionfunction T0o takes nothing returns booleanset tgv=VXx(tGv)
return trueendfunctionfunction T1o takes nothing returns booleanset thv=VXx(tHv)
return trueendfunctionfunction T2o takes nothing returns booleanset tjv=VXx(tJv)
return trueendfunctionfunction T3o takes nothing returns booleanset tkv=VXx(tKv)
return trueendfunctionfunction T4o takes nothing returns booleanset tlv=VXx(tLv)
return trueendfunctionfunction T5o takes nothing returns booleanset tmv=VXx(tMv)
return trueendfunctionfunction T6o takes nothing returns booleanset tpv=VXx(tPv)
return trueendfunctionfunction T7o takes nothing returns booleanset tqv=VXx(tQv)
return trueendfunctionfunction T8o takes nothing returns booleanset tsv=VXx(tSv)
return trueendfunctionfunction T9o takes nothing returns booleanset ttv=VXx(tTv)
return trueendfunctionfunction uvo takes nothing returns booleanset tuv=VXx(tUv)
return trueendfunctionfunction ueo takes code c,string rSx returns nothing
set DV=DV+1set fV[DV]=CreateTrigger()set FV[DV]=(GetHandleId(Condition((c))))
set gV[DV]=rSxcall TriggerAddCondition(fV[DV],Condition(c))endfunctionfunction uxo takes integer oSx returns integerset tzv[oSx]=trueset tZv[oSx]=falseset jwv[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set Te[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(tuv)return oSxendfunctionfunction uoo takes nothing returns integerlocal integer oSxif(twv==8190)thencall o_x("Level_Allocation_allocCustom","call DebugEx(Level.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",tUv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(tWv[(w)]==w)thenset tyv=tyv+1set oSx=tyvelse
set oSx=tWv[(w)]
set tWv[(w)]=tWv[tWv[(w)]]endifset tWv[oSx]=Zset tYv[oSx]=1call uxo(oSx)return oSxendfunctionfunction uro takes integer oSx returns booleanset lGv=lGv+1set ye[lGv]=oSxset QJv[oSx]=lGv+1return(lGv==0)endfunctionfunction uio takes integer oSx returns nothingset se[(oSx)]=(t_v+oSx)endfunctionfunction uao takes string rSx returns integerlocal integer oSx=uoo()set Qqv[(oSx)]=(Qqv[oSx])set JFv[(oSx)]=(w)set Ue[(oSx)]=(rSx)set ue[(oSx)]=(w)call uro(oSx)call uio(oSx)return oSxendfunctionfunction uno takes nothing returns nothinglocal integer oSx=uao("Deers")set t0v=oSxset Qqv[(oSx)]=("ReplaceableTextures\\CommandButtons\\BTNStag.blp")endfunctionfunction uVo takes nothing returns nothinglocal integer oSx=uao("Trolls")set Kxv=oSxset Qqv[(oSx)]=("ReplaceableTextures\\CommandButtons\\BTNIceTroll.blp")endfunctionfunction uEo takes nothing returns nothinglocal integer oSx=uao("Gnolls")set Krv=oSxset Qqv[(oSx)]=("ReplaceableTextures\\CommandButtons\\BTNGnollWarden.blp")endfunctionfunction uXo takes nothing returns nothinglocal integer oSx=uao("Wolves")set t1v=oSxset Qqv[(oSx)]=("ReplaceableTextures\\CommandButtons\\BTNTimberWolf.blp")endfunctionfunction uOo takes nothing returns nothinglocal integer oSx=uao("Moonkins")set t2v=oSxset Qqv[(oSx)]=("ReplaceableTextures\\CommandButtons\\BTNOwlBear.blp")endfunctionfunction uRo takes nothing returns nothinglocal integer oSx=uao("SnowFalcons")
set t3v=oSxset Qqv[(oSx)]=("ReplaceableTextures\\CommandButtons\\BTNWarEagle.blp")endfunctionfunction uIo takes nothing returns nothinglocal integer oSx=uao("Kobolds")
set t4v=oSxset Qqv[(oSx)]=("ReplaceableTextures\\CommandButtons\\BTNKobold.blp")endfunctionfunction uAo takes nothing returns nothinglocal integer oSx=uao("Treants")
set t5v=oSxset Qqv[(oSx)]=("ReplaceableTextures\\CommandButtons\\BTNCorruptedEnt.blp")endfunctionfunction uNo takes nothing returns nothinglocal integer oSx=uao("Furbolg Oracle")set t6v=oSxset Qqv[(oSx)]=("ReplaceableTextures\\CommandButtons\\BTNFurbolgTracker.blp")endfunctionfunction ubo takes nothing returns nothinglocal integer oSx=uao("Scouts")set t7v=oSxset Qqv[(oSx)]=("ReplaceableTextures\\CommandButtons\\BTNWyvernRider.blp")endfunctionfunction uBo takes nothing returns nothinglocal integer oSx=uao("Axe Fighters")set t8v=oSxset Qqv[(oSx)]=("ReplaceableTextures\\CommandButtons\\BTNGrunt.blp")
endfunctionfunction uco takes nothing returns nothinglocal integer oSx=uao("Raiders")
set t9v=oSxset Qqv[(oSx)]=("ReplaceableTextures\\CommandButtons\\BTNRaider.blp")endfunctionfunction uCo takes nothing returns nothinglocal integer oSx=uao("Catapults")set Tvv=oSxset Qqv[(oSx)]=("ReplaceableTextures\\CommandButtons\\BTNCatapult.blp")endfunctionfunction udo takes nothing returns nothinglocal integer oSx=uao("Assassins")set Tev=oSxset Qqv[(oSx)]=("ReplaceableTextures\\CommandButtons\\BTNHellScream.blp")endfunctionfunction uDo takes nothing returns nothinglocal integer oSx=uao("Leader")set Txv=oSxset Qqv[(oSx)]=("ReplaceableTextures\\CommandButtons\\BTNChaosWarlord.blp")endfunctionfunction ufo takes nothing returns nothinglocal integer oSx=uao("Penguins")set Trv=oSxset lhv[(oSx)]=(true)set Tiv[(oSx)]=("1")
endfunctionfunction uFo takes nothing returns nothingcall uno()call uVo()call uEo()call uXo()call uOo()call uRo()call uIo()call uAo()call uNo()call ubo()call uBo()call uco()call uCo()call udo()call uDo()set Tov=lGvcall ufo()set Tav=lGvendfunctionfunction ugo takes string icx returns integerif not cq thencall BJDebugMsg("Debug (uninit): "+icx)endifreturn ipx(Ge,"Debug: "+icx,15.)
endfunctionfunction uGo takes nothing returns nothinglocal integer oSx=jpvif(oSx==w)thenreturnendifcall kBo(oSx)set oSx=(Jav[(oSx)])
if(oSx==w)thencall ugo("Victory")else
call kDo(oSx)endifendfunctionfunction uho takes nothing returns nothinglocal integer oSx=jQvif(oSx==w)thenreturnendifcall kRo(oSx)set oSx=(Tnv[(oSx)])
if(oSx==w)thencall uGo()else
call kIo(oSx)endifendfunctionfunction uHo takes nothing returns booleanlocal integer rFx=(bv)local integer k4o=(Qe[(rFx)])local integer oSx=jQvif(k4o==(klo(((oSx)),Jfv,((kKo(((oSx)),Jfv))))))then
call uho()else
call aAx((ue[(k4o)]))endifreturn trueendfunctionfunction ujo takes nothing returns booleanlocal integer rFx=(bv)call kOo()return trueendfunctionfunction uJo takes integer oSx returns integerset TRv[oSx]=trueset TIv[oSx]=falseset Jdv[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])call rEx(tkv)return oSxendfunctionfunction uko takes nothing returns integerlocal integer oSxif(TVv==8190)thencall o_x("LevelSet_Allocation_allocCustom","call DebugEx(LevelSet.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",tKv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(TEv[(w)]==w)thenset TXv=TXv+1set oSx=TXvelse
set oSx=TEv[(w)]
set TEv[(w)]=TEv[TEv[(w)]]endifset TEv[oSx]=Zset TOv[oSx]=1call uJo(oSx)return oSxendfunctionfunction uKo takes integer oSx returns nothingset JDv[(oSx)]=(TAv+oSx)
endfunctionfunction ulo takes string rSx,integer Rmx returns integerlocal integer oSx=uko()call uKo(oSx)set juv[(oSx)]=(rSx)
set Tnv[(oSx)]=(w)set Tnv[(Rmx)]=(oSx)
return oSxendfunctionfunction uLo takes integer oSx,integer otx,integer oux returns booleanreturn rux(Jdv[(oSx)],(JDv[((oSx))]),otx,oux)endfunctionfunction umo takes integer oSx,integer o9x,integer otx returns nothinglocal integer rvx=(0+(LoadInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx))))))local integer oMx=rvxlocal integer array uMolocal integer oLxloop
exitwhen(oMx<q)set uMo[((oMx)-q+0)]=(LoadInteger(o[((V[(E[((oSx))])]))],(((o9x))),(((otx)+(oMx)))))
set oMx=oMx-1endloopcall dwx(oSx,o9x,otx)set oMx=((rvx)-q+0)loop
exitwhen(oMx<0)set oLx=(GetRandomInt((0),(oMx)))call rux(oSx,o9x,otx,uMo[oLx])set uMo[oLx]=uMo[oMx]set oMx=oMx-1endloopendfunctionfunction upo takes integer oSx,integer otx returns nothingcall umo(Jdv[(oSx)],(JDv[((oSx))]),otx)endfunctionfunction uPo takes nothing returns nothingcall uLo(((JRv)),Jfv,(t0v))call uLo(((JRv)),Jfv,(Kxv))call uLo(((JRv)),Jfv,(Krv))call upo(((JRv)),Jfv)call uLo(((JIv)),Jfv,(t1v))call uLo(((JIv)),Jfv,(t2v))call uLo(((JIv)),Jfv,(t3v))call upo(((JIv)),Jfv)call uLo(((JAv)),Jfv,(t4v))call uLo(((JAv)),Jfv,(t5v))call upo(((JAv)),Jfv)call uLo(((JNv)),Jfv,(t6v))call uLo(((Jbv)),Jfv,(t7v))call uLo(((Jbv)),Jfv,(t8v))call uLo(((Jbv)),Jfv,(t9v))call upo(((JRv)),Jfv)call uLo(((JBv)),Jfv,(Tvv))call uLo(((JBv)),Jfv,(Tev))call upo(((JIv)),Jfv)call uLo(((JCv)),Jfv,(Txv))call uLo(((JOv)),Jfv,(Trv))endfunctionfunction uqo takes nothing returns nothingset JRv=ulo("Act 1 - Part 1",w)set JIv=ulo("Act 1 - Part 2",JRv)set JAv=ulo("Act 1 - Part 3",JIv)set JNv=ulo("Act 1 - Boss",JAv)set Jbv=ulo("Act 2 - Part 1",w)set JBv=ulo("Act 2 - Part 2",Jbv)set Jcv=ulo("Act 2 - Part 3",JBv)set JCv=ulo("Act 2 - Boss",Jcv)set JOv=ulo("Bonus",w)call uPo()endfunctionfunction uQo takes integer oSx returns nothingif(jQv!=w)thencall kRo(jQv)endifset jQv=oSxcall aAx((klo(((oSx)),Jfv,(q))))
endfunctionfunction uso takes nothing returns booleanlocal integer rFx=(bv)if((ZA[(rFx)])!=H3v)then
return trueendifcall kOo()call uQo(jUv)return trueendfunctionfunction uSo takes nothing returns booleanlocal integer rFx=(bv)call ilx(jSv)set jSv=iBx(OQx(H3v)+" type \"-rdy\" in order to start "+(juv[(jUv)]),Ge)return trueendfunctionfunction uto takes nothing returns nothingset jtv=Xdx("FolderLevelSet_StructQuery_Init: set FolderLevelSet_StructQuery.CHAT_EVENT = Event.Create(User.CHAT_EVENT_TYPE, EventPriority.MISC, function FolderLevelSet_StructQuery.Event_Chat)",KA,lI,function uso)set jTv=Xdx("FolderLevelSet_StructQuery_Init: set FolderLevelSet_StructQuery.HOST_CHANGE_EVENT = Event.Create(USER.HostAppointment.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderLevelSet_StructQuery.Event_HostChange)",H_v,lI,function uSo)
endfunctionfunction uTo takes nothing returns nothingcall Dcx(Xdx("LevelSet_Init: call Event.Create(Level.ENDING_EVENT_TYPE, EventPriority.MISC, function LevelSet.Event_LevelEnding).AddToStatics()",te,lI,function uHo))call Dcx(Xdx("LevelSet_Init: call Event.Create(Meteorite.GAME_OVER_EVENT_TYPE, EventPriority.MISC, function LevelSet.Event_GameOver).AddToStatics()",Jtv,lI,function ujo))call uqo()call uto()endfunctionfunction uuo takes nothing returns booleanset te=(E3x())set We=(E3x())call uFo()call uTo()return trueendfunctionfunction uUo takes nothing returns booleancall ueo(function uuo,"Level_Init")return trueendfunctionfunction uwo takes nothing returns booleanset snv=hjo('uLib')call hJo(((snv)),ASv,(Igv))set Uj[(snv)]=((1.25)*1.)set NOv[(snv)]=(('x')*1.)set NWv[(snv)]=((60)*1.)
set I8v[(snv)]=((0)*1.)set Anv[(snv)]=(3)set Nmv[(snv)]=((150000.)*1.)set NLv[(snv)]=((150000.)*1.)set NKv[(snv)]=((0)*1.)set Ncv[(snv)]=((500)*1.)set Nbv[(snv)]=((500)*1.)set Auv[(snv)]=((0)*1.)set AUv[(snv)]=((0)*1.)set AYv[(snv)]=(0)set A_v[(snv)]=(0)call hpo((snv),(gtv),1)return trueendfunctionfunction uWo takes nothing returns booleancall VNx(sa,(function uwo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Library.page\\Library.struct\\obj_shop_wc3unit.j"))return trueendfunctionfunction uyo takes nothing returns booleanset TNv=VXx(Tbv)
return trueendfunctionfunction uYo takes nothing returns booleanlocal integer rFx=(bv)call abx((Vv[(rFx)]),PLAYER_COLOR_LIGHT_BLUE)return trueendfunctionfunction uzo takes nothing returns booleancall teo(snv,Xdx("Library_Init: call Library.SHOP.Event.Add(Event.Create(Unit.CREATE_EVENT_TYPE, EventPriority.UNIT_TYPES, function Library.Event_Create))",IJv,pI,function uYo))return trueendfunctionfunction uZo takes nothing returns booleancall kzo(function uzo,"Library_Init")return trueendfunctionfunction u_o takes nothing returns booleanset TBv=L6o('ILum')call L7o(((TBv)),tS,(bS))return trueendfunctionfunction u0o takes nothing returns booleanset Tcv=u4x()set IC[(Tcv)]=("Abilities\\Spells\\Items\\ResourceItems\\BundeOfLumber.wav")
set BC[(Tcv)]=(l5)set CC[(Tcv)]=((1)*1.)set DC[(Tcv)]=((1)*1.)set FC[(Tcv)]=($A)set GC[(Tcv)]=((1)*1.)set lC[(Tcv)]=(true)
set mC[(Tcv)]=(true)
set pC[(Tcv)]=((600)*1.)
set qC[(Tcv)]=(($186A0)*1.)set sC[(Tcv)]=(($7D0)*1.)return trueendfunctionfunction u1o takes nothing returns booleancall VNx(Qa,(function u_o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Lumber.page\\Lumber.struct\\obj_thisItemType_wc3item.j"))call VNx(La,(function u0o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Lumber.page\\Lumber.struct\\obj_dummySound_wc3sound.j"))
return trueendfunctionfunction u2o takes nothing returns booleanset TCv=VXx(Tdv)
return trueendfunctionfunction u3o takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer P_o=(kGx(CreateItem(Hh[(TBv)],((Tgv[oSx])*1.),((TGv[oSx])*1.))))call mho(Thv[oSx])call kxx(P_o,Tfv,oSx)call kex(P_o,TDv)endfunctionfunction u4o takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])set Thv[oSx]=mko(Tgv[oSx],TGv[oSx],"Abilities\\Spells\\Human\\slow\\slowtarget.mdl",ri)endfunctionfunction u5o takes integer oSx returns nothingcall iDx(TFv[oSx],30.,false,function u3o)call iDx(THv[oSx],30.-5.,false,function u4o)
endfunctionfunction u6o takes nothing returns booleanlocal integer rFx=(bv)local integer P_o=(qh[(rFx)])local integer oSx=CLx(P_o,Tfv)call J8x(P_o,Tfv)call J7x(P_o,TDv)call u5o(oSx)return trueendfunctionfunction u7o takes integer oSx returns integerset Tlv[oSx]=trueset TLv[oSx]=falsecall rEx(TCv)return oSxendfunctionfunction u8o takes nothing returns integerlocal integer oSxif(Tjv==8190)thencall o_x("Lumber_Allocation_allocCustom","call DebugEx(Lumber.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Tdv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(TJv[(w)]==w)thenset Tkv=Tkv+1set oSx=Tkvelse
set oSx=TJv[(w)]
set TJv[(w)]=TJv[TJv[(w)]]endifset TJv[oSx]=Zset TKv[oSx]=1call u7o(oSx)return oSxendfunctionfunction u9o takes integer o0x,integer Iix returns integerlocal real x=(tm[(Iix)])
local real y=(Tm[(Iix)])
local integer oSx=u8o()local integer Okx=iXx()local integer HAx=mDx('qLum',(hm[(o0x)]),(Hm[(o0x)]),(jm[(o0x)]),Jf)
local integer sio=iXx()set TFv[oSx]=Okx
set THv[oSx]=sio
set Tmv[oSx]=HAx
set TMv[oSx]=mDx('qLuP',x,y,X_x(x,y),Jf)
set Tpv[oSx]=(mko(((x)*1.),((y)*1.),("buildings\\other\\CircleOfPower\\CircleOfPower.mdl"),(ri)))set Tgv[oSx]=xset TGv[oSx]=yset ge[(Okx)]=(oSx)set ge[(sio)]=(oSx)call SetUnitAnimationByIndex(vJ[((HAx))],(3))call mCx(HAx,2.)
call u5o(oSx)return oSxendfunctionfunction Uvo takes nothing returns booleanlocal integer rFx=(bv)call u9o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((ar)))))),((((Nm)))))),q2x(xo))
call u9o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((rr)))))),((((Nm)))))),q2x(oo))
call u9o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((ir)))))),((((Nm)))))),q2x(ro))
call u9o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((xr)))))),((((Nm)))))),q2x(io))
call u9o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((Uo)))))),((((Nm)))))),q2x(ao))
call u9o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((Wo)))))),((((Nm)))))),q2x(no))
call u9o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((yo)))))),((((Nm)))))),q2x(Vo))
call u9o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((wo)))))),((((Nm)))))),q2x(Eo))
call u9o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((Yo)))))),((((Nm)))))),q2x(Xo))
call u9o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((zo)))))),((((Nm)))))),q2x(Oo))
call u9o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((er)))))),((((Nm)))))),q2x(Ro))
call u9o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((Zo)))))),((((Nm)))))),q2x(Io))
call u9o((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((vr)))))),((((Nm)))))),q2x(Ao))
return trueendfunctionfunction Ueo takes nothing returns booleanlocal integer rFx=(bv)local integer qvo=AJx(Tcv)local integer P_o=(qh[(rFx)])local integer OSx=(Vv[(rFx)])local real x=(GetItemX(gh[((P_o))]))
local real y=(GetItemY(gh[((P_o))]))
local real z=P7o(P_o)local integer oSx=P_olocal integer oMxcall P8o(qvo,x,y,z)call ccx(iSx("+"+(I2S((TPv))),"ff00c850"),1.15*rb,x,y,z,(0))
call R4x(qvo,true)set oMx=Jhloop
exitwhen(oMx<0)call LSo(kh[oMx],PLAYER_STATE_RESOURCE_LUMBER,TPv)set oMx=oMx-1endloopreturn trueendfunctionfunction Uxo takes nothing returns booleanset TDv=Xdx("Lumber_Init: set Lumber.DESTROY_EVENT = Event.Create(Item.DESTROY_EVENT_TYPE, EventPriority.MISC, function Lumber.Event_Destroy)",CS,lI,function u6o)call Dcx(Xdx("Lumber_Init: call Event.Create(EventType.START, EventPriority.MISC, function Lumber.Event_Start).AddToStatics()",EE,lI,function Uvo))call pEo(TBv,Xdx("Lumber_Init: call Lumber.THIS_ITEM_TYPE.Event.Add(Event.Create(UNIT.Items.Events.Use.DUMMY_EVENT_TYPE, EventPriority.MISC, function Lumber.Event_ItemUse))",Sh,lI,function Ueo))return trueendfunctionfunction Uoo takes nothing returns booleancall kzo(function Uxo,"Lumber_Init")
return trueendfunctionfunction Uro takes nothing returns booleanset Tqv=VXx(TQv)
return trueendfunctionfunction Uio takes nothing returns booleanset Tsv=VXx(TSv)
return trueendfunctionfunction Uao takes nothing returns nothingset Tuv=Tuv+1call pCx(Ttv,TUv,Twv,(I2S((Cv))))call pCx(Ttv,TWv,Twv,(I2S(((R2I(((((Cv*1./(Tuv*1./(1*1./ .5)))*1.))*1.)))))))call pCx(Ttv,Tyv,Twv,(I2S((fE))))call pCx(Ttv,TYv,Twv,(I2S((nr))))endfunctionfunction Uno takes nothing returns booleanlocal integer rFx=(bv)call sPo((Ttv),((ZA[(rFx)])))call iDx(TTv,.5,true,function Uao)return trueendfunctionfunction UVo takes nothing returns nothinglocal integer UEo=(s6o(Ttv))
local integer oMxlocal integer oLxset UEo=(s6o(Ttv))call pCx(Ttv,UEo,Tzv,i1x("Log:","ffffffff","ff00bfff"))call PYx(Ttv,UEo,Tzv,.2)
set oMx=0loop
exitwhen(oMx>8-1)set oLx=0+oMxset TZv[oLx]=""set UEo=(s6o(Ttv))call PYx(Ttv,UEo,Tzv,.000001)call PYx(Ttv,UEo,Twv,.199999)set T_v[oLx]=UEo
set oMx=oMx+1endloopset T0v=true
endfunctionfunction UXo takes nothing returns nothingset T1v=CreateQuest()call QuestSetIconPath(T1v,"ReplaceableTextures\\CommandButtons\\BTNPeon.blp")call QuestSetTitle(T1v,"DebugLog")endfunctionfunction UOo takes nothing returns booleanset Ttv=s5o()set TTv=iXx()call Dcx(Xdx("Nullboard_Init: call Event.Create(AfterIntro.FOR_PLAYER_EVENT_TYPE, EventPriority.MISC, function Nullboard.Event_AfterIntro).AddToStatics()",jCv,lI,function Uno))
call s7o((Ttv),("Nullboard"))set Tzv=Svo(Ttv)
set Twv=Svo(Ttv)
set TUv=(s6o(Ttv))set TWv=(s6o(Ttv))set Tyv=(s6o(Ttv))set TYv=(s6o(Ttv))call pCx(Ttv,TUv,Tzv,i1x("Called triggers:","ffffffff","ff00bfff"))call pCx(Ttv,TWv,Tzv,i1x("Per second:","ffffffff","ff00bfff"))call pCx(Ttv,Tyv,Tzv,i1x("Objs count:","ffffffff","ff00bfff"))call pCx(Ttv,TYv,Tzv,i1x("Native objs count:","ffffffff","ff00bfff"))call Pzx(Ttv,Tzv,.1)
call Pzx(Ttv,Twv,.1)
call UVo()call UXo()set Tuv=0return trueendfunctionfunction URo takes nothing returns booleancall k1o(function UOo,"Nullboard_Init")return trueendfunctionfunction UIo takes nothing returns booleanset T2v=VXx(T3v)
return trueendfunctionfunction UAo takes nothing returns booleanset T4v=VXx(T5v)
return trueendfunctionfunction UNo takes nothing returns booleanset T6v=VXx(T7v)
return trueendfunctionfunction Ubo takes nothing returns booleanset T8v=VXx(T9v)
return trueendfunctionfunction UBo takes nothing returns booleanset uvv=VXx(uev)
return trueendfunctionfunction Uco takes nothing returns booleanset uxv=VXx(uov)
return trueendfunctionfunction UCo takes nothing returns booleanset urv=VXx(uiv)
return trueendfunctionfunction Udo takes string UDo,string oux returns integer
local integer o7x=(s6o(tZ))set UDo=iSx(UDo,"ffffcc00")set q0=q0+1call pCx(tZ,o7x,TZ,UDo)call pCx(tZ,o7x,UZ,oux)set LZ[q0]=o7xset T0[o7x]=q0set uZ[q0]=UDoset wZ[q0]=ouxreturn o7xendfunctionfunction Ufo takes integer oSx returns nothingset W0[oSx]=0+$A
call p9x(oSx)endfunctionfunction UFo takes integer bIx returns integerlocal integer oSx=bIxset HZ[oSx]=falseset hZ[oSx]=bIxcall sPo((tZ),(bIx))
call p7x((oSx))call Ufo(oSx)call Pex((oSx))call Prx((oSx))call PVx((oSx),false)call PRx((oSx),false)return oSxendfunctionfunction Ugo takes nothing returns booleanlocal integer rFx=(bv)call UFo((ZA[(rFx)]))return trueendfunctionfunction UGo takes nothing returns nothingset t0=0+3set S0[0+0]=.0set S0[0+1]=.5set S0[0+2]=1.set S0[0+3]=1.5set S0[0+4]=2.set S0[0+5]=2.5set S0[0+6]=3.set S0[0+7]=3.5set S0[0+8]=4.endfunctionfunction Uho takes nothing returns nothingset w0[0]=$546set w0[0+1]=$5AA
set w0[0+2]=$60E
set w0[0+3]=$672
set w0[0+4]=$6D6
set w0[0+5]=$73A
set w0[0+6]=$79E
set w0[0+7]=$802
set w0[0+8]=$866
set w0[0+9]=$8CA
set w0[0+$A]=$92Eset w0[0+$B]=$992endfunctionfunction UHo takes nothing returns nothingendfunctionfunction Ujo takes nothing returns nothingset e1=0
set v1[0]="off"set v1[0+1]="on"
endfunctionfunction UJo takes integer oSx returns integerset uIv[oSx]=trueset uAv[oSx]=falsecall rEx(R5)
return oSxendfunctionfunction Uko takes nothing returns integerlocal integer oSxif(uEv==8190)thencall o_x("Music_Allocation_allocCustom","call DebugEx(Music.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",I5+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(uXv[(w)]==w)thenset uOv=uOv+1set oSx=uOvelse
set oSx=uXv[(w)]
set uXv[(w)]=uXv[uXv[(w)]]endifset uXv[oSx]=Zset uRv[oSx]=1call UJo(oSx)return oSxendfunctionfunction UKo takes string oqx,integer rbx returns integerlocal integer oSx=Uko()set yZ[oSx]=Fset n1[oSx]=rbxset ZZ[oSx]=oqxreturn oSxendfunctionfunction Ulo takes nothing returns nothingset I1=QEx("Units\\Human\\Footman\\FootmanPissed4.wav",false,false,false,$A,$A,w)call Ahx(I1,8)endfunctionfunction ULo takes nothing returns booleanlocal integer rFx=(bv)set tZ=s5o()
set TZ=Svo(tZ)set UZ=Svo(tZ)set uav=(s6o(tZ))set z0=Udo("SFX Level","")set unv=(s6o(tZ))set V1=Udo("Sound volume","")set WZ=Udo("Music volume","")set uVv=(s6o(tZ))set U0=Udo("Camera zoom","")
set s0=Udo("Camera smoothing factor","")
set Z0=Udo("Hint","")call Pzx(tZ,TZ,.1)call Pzx(tZ,UZ,.1)call s7o((tZ),("Options"))call pCx(tZ,unv,TZ,iSx("Audio","ffffcc00"))call PYx(tZ,unv,TZ,.2)call PYx(tZ,unv,UZ,.0)call pCx(tZ,uav,TZ,iSx("Graphics","ffffcc00"))call PYx(tZ,uav,TZ,.2)call PYx(tZ,uav,UZ,.0)call pCx(tZ,uVv,TZ,iSx("Misc","ffffcc00"))call PYx(tZ,uVv,TZ,.2)call PYx(tZ,uVv,UZ,.0)call Dcx(Xdx("OptionsBoard_Event_Start: call Event.Create(AfterIntro.FOR_PLAYER_EVENT_TYPE, EventPriority.MISC, function OptionsBoard.Event_AfterIntro).AddToStatics()",jCv,lI,function Ugo))call UGo()call Uho()call UHo()call Ujo()set v0=UKo("Sound\\Music\\mp3Music\\Credits.mp3",999)call Ulo()return trueendfunctionfunction Umo takes nothing returns booleancall Dcx(Xdx("OptionsBoard_Init: call Event.Create(EventType.START, EventPriority.MISC, function OptionsBoard.Event_Start).AddToStatics()",EE,lI,function ULo))return trueendfunctionfunction UMo takes nothing returns booleancall k1o(function Umo,"OptionsBoard_Init")return trueendfunctionfunction Upo takes nothing returns booleanset uNv=hjo('uPha')call hJo(((uNv)),ASv,(Igv))set Uj[(uNv)]=((2)*1.)set NOv[(uNv)]=(('x')*1.)set NWv[(uNv)]=((60)*1.)
set I8v[(uNv)]=((0)*1.)set Anv[(uNv)]=(3)set Nmv[(uNv)]=((150000.)*1.)set NLv[(uNv)]=((150000.)*1.)set NKv[(uNv)]=((0)*1.)set Ncv[(uNv)]=((500)*1.)set Nbv[(uNv)]=((500)*1.)set Auv[(uNv)]=((0)*1.)set AUv[(uNv)]=((0)*1.)set AYv[(uNv)]=(0)set A_v[(uNv)]=(0)call hpo((uNv),(gtv),1)return trueendfunctionfunction UPo takes nothing returns booleancall VNx(sa,(function Upo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\obj_shop_wc3unit.j"))return trueendfunctionfunction Uqo takes nothing returns booleanset ubv=VXx(uBv)
return trueendfunctionfunction UQo takes nothing returns booleancall L1x('AEmP',false)set ucv=L0o('AEmP')set K6[(ucv)]=(h6)set m6[(ucv)]=(1)set TH[(ucv)]=("Emergency Provisions")set Rh[(ucv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Aj))))))set oxv[(ucv)]=(0)set x3v[(ucv)]=("spell")
call L1o((ucv),GH+(1),((20)*1.))
call L1o((ucv),Lov+(1),((750)*1.))return trueendfunctionfunction Uso takes nothing returns booleanset uCv=L6o('IEmP')set sS[(uCv)]=(1)set LIv[(uCv)]=("ReplaceableTextures\\CommandButtons\\BTNDust.blp")call L9o((uCv),(ucv),1)return trueendfunctionfunction USo takes nothing returns booleancall VNx(Pa,(function UQo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\EmergencyProvisions.page\\EmergencyProvisions.struct\\obj_thisSpell_wc3spell.j"))
call VNx(Qa,(function Uso),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\EmergencyProvisions.page\\EmergencyProvisions.struct\\obj_thisItem_wc3item.j"))return trueendfunctionfunction Uto takes nothing returns booleanset udv=VXx(uDv)
return trueendfunctionfunction UTo takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])call pmo((ACx((Cqx),(ufv),(uFv),(Bi))),2.)call mao(Cqx,Cqx,ugv)return trueendfunctionfunction Uuo takes nothing returns booleancall mro(ucv,Xdx("EmergencyProvisions_Init: call EmergencyProvisions.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function EmergencyProvisions.Event_SpellEffect))",ih,KI,function UTo))return trueendfunctionfunction UUo takes nothing returns booleancall m0o(function Uuo,"EmergencyProvisions_Init")return trueendfunctionfunction Uwo takes nothing returns booleanset uGv=hjo('uEoF')call hJo(((uGv)),ASv,(Idv))set Uj[(uGv)]=((1.25)*1.)set NOv[(uGv)]=((60)*1.)
set NWv[(uGv)]=(($E1)*1.)set I8v[(uGv)]=((0)*1.)set Anv[(uGv)]=(2)set Nmv[(uGv)]=((65)*1.)
set NLv[(uGv)]=((65)*1.)
set NKv[(uGv)]=((0)*1.)set Ncv[(uGv)]=(($4B0)*1.)set Nbv[(uGv)]=(($4B0)*1.)set NGv[(uGv)]=((60)*1.)
set Adv[(uGv)]=(guv)
set AGv[(uGv)]=((360)*1.)set Ahv[((uGv))]=((1.*1./((.5)*1.))*1.)set AWv[(uGv)]=((.1)*1.)
set Dnv[(uGv)]=((600)*1.)set Auv[(uGv)]=((2)*1.)set AUv[(uGv)]=((2)*1.)set AYv[(uGv)]=(1)set A_v[(uGv)]=(3)set A2v[(uGv)]=(3)set ATv[(uGv)]=((16)*1.)
call hpo((uGv),(uhv),1)call hpo((uGv),(uHv),1)return trueendfunctionfunction UWo takes nothing returns booleancall L1x('AEoF',false)set ujv=L0o('AEoF')set K6[(ujv)]=(h6)set m6[(ujv)]=(1)set TH[(ujv)]=("Eye of the Flame")set Rh[(ujv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0089)))),(((Aj))))))set oxv[(ujv)]=(2)set x3v[(ujv)]=("spell")
call L1o((ujv),GH+(1),(($F)*1.))
call L1o((ujv),Lov+(1),((550)*1.))set MOv[(ujv)]=("ReplaceableTextures\\CommandButtons\\")
return trueendfunctionfunction Uyo takes nothing returns booleanset uJv=L6o('IEoF')set sS[(uJv)]=(1)set LIv[(uJv)]=("ReplaceableTextures\\CommandButtons\\BTNSentryWard.blp")call L9o((uJv),(ujv),1)return trueendfunctionfunction UYo takes nothing returns booleancall VNx(sa,(function Uwo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\EyeOfTheFlame.page\\EyeOfTheFlame.struct\\obj_summonUnitType_wc3unit.j"))
call VNx(Pa,(function UWo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\EyeOfTheFlame.page\\EyeOfTheFlame.struct\\obj_thisSpell_wc3spell.j"))
call VNx(Qa,(function Uyo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\EyeOfTheFlame.page\\EyeOfTheFlame.struct\\obj_thisItem_wc3item.j"))return trueendfunctionfunction Uzo takes nothing returns booleanset ukv=VXx(uKv)
return trueendfunctionfunction UZo takes integer oSx,real iMx returns nothingset Ff=iMxcall Dux(((oSx)),(Ozv),(1),w)endfunctionfunction U_o takes integer oSx,real iMx returns nothingif(iMx>=.0)thenset Asv[(oSx)]=("Abilities\\Spells\\Orc\\FeralSpirit\\feralspirittarget.mdl")call Rao(oSx,IGv)set A4v[(oSx)]=((.0)*1.)
call UZo((oSx),((iMx)*1.))endifendfunctionfunction U0o takes integer rNx,integer oDx,real x,real y,real bex,real iMx returns integerlocal integer oSx=bOx(rNx,oDx,x,y,bex)call Nvo(Noo(x,y,"Abilities\\Spells\\Orc\\FeralSpirit\\feralspirittarget.mdl",ri,(eb[(oSx)])))call SetUnitAnimation(C[((oSx))],("birth"))call QueueUnitAnimation(C[((oSx))],("stand"))call U_o(oSx,iMx)return oSxendfunctionfunction U1o takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local integer C3o=(ze[(Cqx)])local integer oMx=ulvloop
call U0o(uGv,C3o,dVx,dEx,kf,uLv)
set oMx=oMx-1exitwhen(oMx<1)endloopreturn trueendfunctionfunction U2o takes nothing returns booleancall mro(ujv,Xdx("EyeOfTheFlame_Init: call EyeOfTheFlame.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EyeOfTheFlame.Event_SpellEffect))",ih,MI,function U1o))
return trueendfunctionfunction U3o takes nothing returns booleancall m0o(function U2o,"EyeOfTheFlame_Init")return trueendfunctionfunction U4o takes nothing returns booleanset umv=ltx(uMv+" (dummyBuff)")return trueendfunctionfunction U5o takes nothing returns booleanset upv=ltx(uMv+" (ignitionBuff)")set Pc[(upv)]=(true)
set uU[(upv)]=(true)
return trueendfunctionfunction U6o takes nothing returns booleancall L1x('AToL',false)set uhv=L0o('AToL')set K6[(uhv)]=(H6)set m6[(uhv)]=(1)set TH[(uhv)]=("Torch Light")set x3v[(uhv)]=("spell")
call L1o((uhv),Lov+(1),((750)*1.))set MOv[(uhv)]=("ReplaceableTextures\\CommandButtons\\BTNVolcano.blp")return trueendfunctionfunction U7o takes nothing returns booleancall VNx(ma,(function U4o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\EyeOfTheFlame.page\\EyeOfTheFlame.struct\\TorchLight.page\\TorchLight.struct\\obj_dummyBuff_wc3buff.j"))call VNx(ma,(function U5o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\EyeOfTheFlame.page\\EyeOfTheFlame.struct\\TorchLight.page\\TorchLight.struct\\obj_ignitionBuff_wc3buff.j"))call VNx(Pa,(function U6o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\EyeOfTheFlame.page\\EyeOfTheFlame.struct\\TorchLight.page\\TorchLight.struct\\obj_thisSpell_wc3spell.j"))
return trueendfunctionfunction U8o takes nothing returns booleanset uPv=VXx(uMv)
return trueendfunctionfunction U9o takes integer Iix returns booleanreturn( not(I9x(Iix,Ifv)))and( not(I9x(Iix,Igv)))endfunctionfunction wvo takes integer Cqx,integer rYx,integer Iix returns nothinglocal real iMxif I9x(Iix,Wd)thenset iMx=uQvelse
set iMx=usvendifcall Nbx(Iix,upv,rYx,Cqx,iMx)endfunctionfunction weo takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])if not U9o(Iix)thenreturn trueendifcall wvo((E2v[(rFx)]),(Mv[(rFx)]),Iix)return trueendfunctionfunction wxo takes nothing returns booleanlocal integer Iix=jhx()if not U9o(Iix)thenreturn false
endifif(Xiv[(Iix)])thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif not(IsUnitEnemy(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction woo takes integer oSx,real x,real y returns integer
return mKo(oSx,x,y)endfunctionfunction wro takes real x,real y,real Jex,integer Q7x returns integercall NVo((bQ),x,y,Jex,Q7x)return woo(bQ,x,y)endfunctionfunction wio takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxlocal integer waoset hf=(ze[(Iix)])set wao=wro((GetUnitX(C[((Iix))])),(GetUnitY(C[((Iix))])),(Agv[(Iix)]),uSv)if(wao!=w)thencall Lox(Iix,bw,wao)
endifendfunctionfunction wno takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer Q9o=iXx()set utv[oSx]=Q9o
call Avx(Iix,uqv)set ge[(Q9o)]=(oSx)call iDx(Q9o,.5,true,function wio)return trueendfunctionfunction wVo takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer Q9o=utv[oSx]call RPx(Iix,uqv)call iKx(Q9o)return trueendfunctionfunction wEo takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(umv),((Mv[(rFx)])),w)return trueendfunctionfunction wXo takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),umv)return trueendfunctionfunction wOo takes nothing returns booleanset uqv=Xdx("TorchLight_Init: set TorchLight.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function TorchLight.Event_Damage)",E4v,MI,function weo)set uSv=Xpx(function wxo)call Lxx(umv,Xdx("TorchLight_Init: call TorchLight.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TorchLight.Event_BuffGain))",bd,MI,function wno))call Lxx(umv,Xdx("TorchLight_Init: call TorchLight.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TorchLight.Event_BuffLose))",jc,MI,function wVo))call mro(uhv,Xdx("TorchLight_Init: call TorchLight.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TorchLight.Event_Learn))",pv,MI,function wEo))
call mro(uhv,Xdx("TorchLight_Init: call TorchLight.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TorchLight.Event_Unlearn))",Av,MI,function wXo))
call W2x(Xev,upv)return trueendfunctionfunction wRo takes nothing returns booleancall moo(function wOo,"TorchLight_Init")
return trueendfunctionfunction wIo takes nothing returns booleanset uTv=L6o('IHeO')set sS[(uTv)]=(2)set LIv[(uTv)]=("ReplaceableTextures\\CommandButtons\\BTNHealingSalve.blp")call L9o((uTv),(uuv),1)return trueendfunctionfunction wAo takes nothing returns booleancall L1x('AHeO',false)set uuv=L0o('AHeO')set K6[(uuv)]=(h6)set m6[(uuv)]=(1)set TH[(uuv)]=("Herbal Ointment")set Rh[(uuv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Aj))))))set oxv[(uuv)]=(0)set x3v[(uuv)]=("spell")
call L1o((uuv),GH+(1),(($A)*1.))
call L1o((uuv),Lov+(1),((750)*1.))return trueendfunctionfunction wNo takes nothing returns booleanset uUv=Wwx('BHeO',"Herbal Ointment",'bHeO')
set aav[(uUv)]=(true)set anv[(uUv)]=("ReplaceableTextures\\CommandButtons\\BTNHealingSalve.blp")call lWx(uUv,"Abilities\\Spells\\Other\\ANrl\\ANrlTarget.mdl","origin",ri)call lWx(uUv,"Abilities\\Spells\\Other\\ANrm\\ANrmTarget.mdl","origin",Bi)return trueendfunctionfunction wbo takes nothing returns booleancall VNx(Qa,(function wIo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\HerbalOintment.page\\HerbalOintment.struct\\obj_thisItem_wc3item.j"))
call VNx(Pa,(function wAo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\HerbalOintment.page\\HerbalOintment.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function wNo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\HerbalOintment.page\\HerbalOintment.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction wBo takes nothing returns booleanset uwv=VXx(uWv)
return trueendfunctionfunction wco takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),uUv)return trueendfunctionfunction wCo takes integer oSx,boolean wdo,boolean wDo,boolean wfo returns integerlocal integer rvxlocal integer oMxlocal integer Iaxif wfo thencall Ryx((ACx(((oSx)),("Abilities\\Spells\\Human\\DispelMagic\\DispelMagicTarget.mdl"),("origin"),(ri))))endifset rvx=0set oMx=(CIx(((oSx)),vB))loop
set Iax=(CAx(((oSx)),vB,(oMx)))if(uU[(Iax)])thenif(aav[(Iax)])thenif wDo thenset rvx=rvx+1call AZx(oSx,Iax)endifelse
if wdo thenset rvx=rvx+1call AZx(oSx,Iax)endifendifendifset oMx=oMx-1exitwhen(oMx<q)endloopreturn rvxendfunctionfunction wFo takes nothing returns nothinglocal integer p3x=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(p3x)])local integer Iix=u0v[oSx]call mao(Iix,Iix,u1v)call mno(Iix,Iix,u2v)endfunctionfunction wgo takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=iXx()set u_v[oSx]=p3x
set u0v[oSx]=Iix
set ge[(p3x)]=(oSx)call Avx(Iix,uyv)call wCo(Iix,true,false,true)call iDx(p3x,uZv,true,function wFo)return trueendfunctionfunction wGo takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=u_v[oSx]call iKx(p3x)call RPx(Iix,uyv)return trueendfunctionfunction who takes nothing returns booleanlocal integer rFx=(bv)call Nbx(((Vv[(rFx)])),(uUv),((Mv[(rFx)])),w,((uzv)*1.))
return trueendfunctionfunction wHo takes nothing returns booleanset uyv=Xdx("HerbalOintment_Init: set HerbalOintment.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.ITEMS, function HerbalOintment.Event_Damage)",E3v,KI,function wco)set uYv=(R2I(((uzv*1./ uZv)*1.)))call Lxx(uUv,Xdx("HerbalOintment_Init: call HerbalOintment.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HerbalOintment.Event_BuffGain))",bd,MI,function wgo))call Lxx(uUv,Xdx("HerbalOintment_Init: call HerbalOintment.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HerbalOintment.Event_BuffLose))",jc,MI,function wGo))call mro(uuv,Xdx("HerbalOintment_Init: call HerbalOintment.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function HerbalOintment.Event_SpellEffect))",ih,KI,function who))set u1v=u3v*1./ uYvset u2v=u4v*1./ uYvreturn trueendfunctionfunction wjo takes nothing returns booleancall m0o(function wHo,"HerbalOintment_Init")
return trueendfunctionfunction wJo takes nothing returns booleanset u5v=Wwx('BScP',"Scroll of Protection",'bScP')set aav[(u5v)]=(true)set uU[(u5v)]=(true)
set anv[(u5v)]=("ReplaceableTextures\\CommandButtons\\BTNScroll.blp")call lWx(u5v,"Abilities\\Spells\\Items\\AIda\\AIdaTarget.mdl","overhead",Bi)
call lWx(u5v,"Abilities\\Spells\\Other\\ANrm\\ANrmTarget.mdl","origin",Bi)set WU=l_x()
call l2x(WU,dXv,4)call l3x(((u5v)),ZB+(1),(WU))return trueendfunctionfunction wko takes nothing returns booleancall VNx(ma,(function wJo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\ScrollOfProtection.page\\ScrollOfProtection.struct\\Target\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction wKo takes nothing returns booleanset u6v=VXx(u7v)
return trueendfunctionfunction wlo takes nothing returns booleancall L1x('AScP',false)set u8v=L0o('AScP')set K6[(u8v)]=(h6)set m6[(u8v)]=(1)set TH[(u8v)]=("Scroll of Protection")set Rh[(u8v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Aj))))))set oxv[(u8v)]=(0)set x3v[(u8v)]=("spell")
call L1o((u8v),Uvv+(1),((600)*1.))call L1o((u8v),GH+(1),((40)*1.))
call L1o((u8v),tH+(1),((0)*1.))call L1o((u8v),Lov+(1),((750)*1.))return trueendfunctionfunction wLo takes nothing returns booleanset Uev=L6o('IScP')set sS[(Uev)]=(1)set LIv[(Uev)]=("ReplaceableTextures\\CommandButtons\\BTNScroll.blp")call L9o((Uev),(u8v),1)return trueendfunctionfunction wmo takes nothing returns booleancall VNx(Pa,(function wlo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\ScrollOfProtection.page\\ScrollOfProtection.struct\\obj_thisSpell_wc3spell.j"))call VNx(Qa,(function wLo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Act1.pack\\ScrollOfProtection.page\\ScrollOfProtection.struct\\obj_thisItem_wc3item.j"))
return trueendfunctionfunction wMo takes nothing returns booleanset Uxv=VXx(Uov)
return trueendfunctionfunction wpo takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,IFv)thenreturn false
endifif not(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction wPo takes integer oSx,integer rYx,integer Iix returns nothingcall Nbx((Iix),(u5v),(rYx),w,((Unv)*1.))
endfunctionfunction wqo takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local integer Iixcall mho((mko(((wQo)*1.),((wso)*1.),(Uav),(Bi))))set hf=(ze[(Cqx)])call NVo(Urv,wQo,wso,(CQx((u8v),Uvv+(rYx))),Uiv)
set Iix=NEo(Urv)
if(Iix!=w)thenloop
set Iix=NEo(Urv)
exitwhen(Iix==w)
call wPo((w),rYx,Iix)endloopendifreturn trueendfunctionfunction wSo takes nothing returns nothingendfunctionfunction wto takes nothing returns booleanset Urv=O5x()set Uiv=Xpx(function wpo)call mro(u8v,Xdx("ScrollOfProtection_Init: call ScrollOfProtection.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ScrollOfProtection.Event_SpellEffect))",ih,MI,function wqo))call wSo()return trueendfunctionfunction wTo takes nothing returns booleancall m0o(function wto,"ScrollOfProtection_Init")
return trueendfunctionfunction wuo takes nothing returns booleanset UVv=Wwx('BFiW',"Fire Water",'bFiW')set aav[(UVv)]=(true)set anv[(UVv)]=("ReplaceableTextures\\CommandButtons\\BTNGreaterInvulneralbility.blp")call lWx(UVv,"Abilities\\Spells\\Other\\ImmolationRed\\ImmolationRedTarget.mdl","chest",ri)call lWx(UVv,"Abilities\\Spells\\Other\\ANrm\\ANrmTarget.mdl","origin",Bi)return trueendfunctionfunction wUo takes nothing returns booleancall VNx(ma,(function wuo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\FireWater.page\\FireWater.struct\\Buff\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction wwo takes nothing returns booleanset UEv=VXx(UXv)
return trueendfunctionfunction wWo takes nothing returns booleancall L1x('AFiW',false)set UOv=L0o('AFiW')set K6[(UOv)]=(h6)set m6[(UOv)]=(1)set TH[(UOv)]=("Fire Water")
set Rh[(UOv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Aj))))))set oxv[(UOv)]=(0)set x3v[(UOv)]=("spell")
call L1o((UOv),Uvv+(1),((70)*1.))call L1o((UOv),GH+(1),((40)*1.))
call L1o((UOv),Lov+(1),((750)*1.))return trueendfunctionfunction wyo takes nothing returns booleanset URv=L6o('IFiW')set sS[(URv)]=(1)set LIv[(URv)]=("ReplaceableTextures\\CommandButtons\\BTNGreaterInvulneralbility.blp")call L9o((URv),(UOv),1)return trueendfunctionfunction wYo takes nothing returns booleancall VNx(Pa,(function wWo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\FireWater.page\\FireWater.struct\\obj_thisSpell_wc3spell.j"))
call VNx(Qa,(function wyo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\FireWater.page\\FireWater.struct\\obj_thisItem_wc3item.j"))return trueendfunctionfunction wzo takes nothing returns booleanset UIv=VXx(UAv)
return trueendfunctionfunction wZo takes integer rYx,integer Iix returns nothingcall Nbx((Iix),(UVv),(rYx),w,((Ucv)*1.))
endfunctionfunction w_o takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])call Ryx((ACx((Cqx),(UNv),(Ubv),(Bi))))call mno(Cqx,Cqx,UBv)call wZo(rYx,Cqx)return trueendfunctionfunction w0o takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction w1o takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxlocal integer w2oset hf=(ze[(Iix)])call NVo(Ufv,(GetUnitX(C[((Iix))])),(GetUnitY(C[((Iix))])),Ugv[oSx],UFv)
set w2o=NEo(Ufv)
if(w2o!=w)thenloop
call nlo((Iix),(w2o),((UCv)*1.),(true),(false))set w2o=NEo(Ufv)
exitwhen(w2o==w)
endloopendifendfunctionfunction w3o takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=iXx()set Ugv[oSx]=(CQx((UOv),Uvv+(rYx)))set UGv[oSx]=p3x
set ge[(p3x)]=(oSx)call iDx(p3x,UDv,true,function w1o)return trueendfunctionfunction w4o takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=UGv[oSx]call iKx(p3x)return trueendfunctionfunction w5o takes nothing returns nothingset UCv=Udv*UDvset Ufv=O5x()set UFv=Xpx(function w0o)call Lxx(UVv,Xdx("FolderFireWater_StructBuff_Init: call FolderFireWater_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderFireWater_StructBuff.Event_BuffGain))",bd,MI,function w3o))call Lxx(UVv,Xdx("FolderFireWater_StructBuff_Init: call FolderFireWater_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderFireWater_StructBuff.Event_BuffLose))",jc,MI,function w4o))endfunctionfunction w6o takes nothing returns booleancall mro(UOv,Xdx("FireWater_Init: call FireWater.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function FireWater.Event_SpellEffect))",ih,KI,function w_o))call w5o()return trueendfunctionfunction w7o takes nothing returns booleancall Pso(function w6o,"FireWater_Init")return trueendfunctionfunction w8o takes nothing returns booleanset Uhv=L6o('ISDr')set sS[(Uhv)]=(1)set LIv[(Uhv)]=("ReplaceableTextures\\CommandButtons\\BTNMinorRejuvPotion.blp")call L9o((Uhv),(UHv),1)return trueendfunctionfunction w9o takes nothing returns booleanset Ujv=L6o('IThQ')set sS[(Ujv)]=(1)set LIv[(Ujv)]=("ReplaceableTextures\\CommandButtons\\BTNRejuvPotion.blp")call L9o(Ujv,UHv,3)return trueendfunctionfunction Wvo takes nothing returns booleancall L1x('AIcT',false)set UHv=L0o('AIcT')set K6[(UHv)]=(h6)set m6[(UHv)]=(3)set TH[(UHv)]=("Ice Tea")set Rh[(UHv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Aj))))))set oxv[(UHv)]=(0)set x3v[(UHv)]=("spell")
call L1o((UHv),GH+(1),((20)*1.))
call L1o((UHv),Lov+(1),((750)*1.))call L1o((UHv),GH+(2),((20)*1.))
call L1o((UHv),Lov+(2),((750)*1.))call L1o((UHv),GH+(3),((20)*1.))
call L1o((UHv),Lov+(3),((750)*1.))set UJv[1]=$C8set UJv[2]=350set UJv[3]=500return trueendfunctionfunction Weo takes nothing returns booleanset Ukv=L6o('IIcT')set sS[(Ukv)]=(1)set LIv[(Ukv)]=("ReplaceableTextures\\CommandButtons\\BTNLesserRejuvPotion.blp")
call L9o(Ukv,UHv,2)return trueendfunctionfunction Wxo takes nothing returns booleancall VNx(Qa,(function w8o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\IceTea.page\\IceTea.struct\\obj_SoftDrink_wc3item.j"))call VNx(Qa,(function w9o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\IceTea.page\\IceTea.struct\\obj_ThirstQuencher_wc3item.j"))call VNx(Pa,(function Wvo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\IceTea.page\\IceTea.struct\\obj_thisSpell_wc3spell.j"))call VNx(Qa,(function Weo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\IceTea.page\\IceTea.struct\\obj_IceTea_wc3item.j"))return trueendfunctionfunction Woo takes nothing returns booleanset UKv=VXx(Ulv)
return trueendfunctionfunction Wro takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])call Ryx((ACx((Cqx),(ULv),(Umv),(Bi))))call mno(Cqx,Cqx,UJv[rYx])return trueendfunctionfunction Wio takes nothing returns booleancall mro(UHv,Xdx("IceTea_Init: call IceTea.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function IceTea.Event_SpellEffect))",ih,KI,function Wro))return trueendfunctionfunction Wao takes nothing returns booleancall Pso(function Wio,"IceTea_Init")
return trueendfunctionfunction Wno takes nothing returns booleanset UMv=L6o('IMea')set sS[(UMv)]=(1)set LIv[(UMv)]=("ReplaceableTextures\\CommandButtons\\BTNMonsterLure.blp")call L9o((UMv),(Upv),1)return trueendfunctionfunction WVo takes nothing returns booleancall L1x('AMea',false)set Upv=L0o('AMea')set K6[(Upv)]=(h6)set m6[(Upv)]=(1)set TH[(Upv)]=("Meat")set Rh[(Upv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Aj))))))set oxv[(Upv)]=(0)set x3v[(Upv)]=("spell")
call L1o((Upv),GH+(1),((20)*1.))
call L1o((Upv),Lov+(1),((750)*1.))return trueendfunctionfunction WEo takes nothing returns booleancall VNx(Qa,(function Wno),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\Meat.page\\Meat.struct\\obj_thisItem_wc3item.j"))
call VNx(Pa,(function WVo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\Meat.page\\Meat.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction WXo takes nothing returns booleanset UPv=VXx(Uqv)
return trueendfunctionfunction WOo takes integer oSx returns nothingset Uuv[oSx]=falsecall rHx(UPv)endfunctionfunction WRo takes integer oSx returns nothingif(Utv[oSx]>0)thenreturnendifif(UTv[oSx]!=Z)thencall o_x("Meat_Allocation_deallocCustom_confirm","call DebugEx(Meat.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Uqv+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset UTv[oSx]=UTv[(w)]set UTv[(w)]=oSx
call WOo(oSx)endfunctionfunction WIo takes integer oSx returns nothingset Utv[oSx]=Utv[oSx]-1call WRo(oSx)endfunctionfunction WAo takes integer oSx,integer Cqx,integer iCx returns nothinglocal integer p3x=USv[oSx]call WIo((oSx))if rnx(Cqx,Usv,oSx)thencall RPx(Cqx,UQv)endifcall iKx(iCx)call iKx(p3x)endfunctionfunction WNo takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oMx=CIx(Cqx,Usv)local integer oSxloop
set oSx=CAx(Cqx,Usv,oMx)
call WAo(oSx,Cqx,UUv[oSx])set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction Wbo takes integer oSx returns integerset Uuv[oSx]=trueset UZv[oSx]=falsecall rEx(UPv)return oSxendfunctionfunction WBo takes nothing returns integerlocal integer oSxif(UYv==8190)thencall o_x("Meat_Allocation_allocCustom","call DebugEx(Meat.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Uqv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(UTv[(w)]==w)thenset Uzv=Uzv+1set oSx=Uzvelse
set oSx=UTv[(w)]
set UTv[(w)]=UTv[UTv[(w)]]endifset UTv[oSx]=Zset Utv[oSx]=1call Wbo(oSx)return oSxendfunctionfunction Wco takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=U_v[oSx]call pmo((ACx((Cqx),(U0v),(U1v),(Bi))),2.)call mao(Cqx,Cqx,U2v)endfunctionfunction WCo takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])call WAo(oSx,U_v[oSx],iCx)endfunctionfunction Wdo takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer iCx=iXx()local integer p3x=iXx()local integer oSx=WBo()set U_v[oSx]=Cqx
set UUv[oSx]=iCx
set USv[oSx]=p3x
if rUx(Cqx,Usv,oSx)thencall Avx(Cqx,UQv)endifset ge[(iCx)]=(oSx)set ge[(p3x)]=(oSx)call iDx(p3x,Uyv,true,function Wco)call iDx(iCx,UWv,false,function WCo)
return trueendfunctionfunction WDo takes nothing returns booleanset UQv=Xdx("Meat_Init: set Meat.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function Meat.Event_Death)",VP,KI,function WNo)
set Uwv=(R2I(((UWv*1./ Uyv)*1.)))call mro(Upv,Xdx("Meat_Init: call Meat.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function Meat.Event_SpellEffect))",ih,KI,function Wdo))
set U2v=U3v*1./ Uwvreturn trueendfunctionfunction Wfo takes nothing returns booleancall Pso(function WDo,"Meat_Init")return trueendfunctionfunction WFo takes nothing returns booleanset U4v=ltx(U5v+" (dummyBuff)")call lWx(U4v,"Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTo.mdl","origin",Bi)call lWx(U4v,"Abilities\\Spells\\Other\\ANrm\\ANrmTarget.mdl","origin",Bi)return trueendfunctionfunction Wgo takes nothing returns booleanset P9v=L6o('ITpS')set sS[(P9v)]=(1)set LIv[(P9v)]=("ReplaceableTextures\\CommandButtons\\BTNScrollUber.blp")call L9o((P9v),(U6v),1)return trueendfunctionfunction WGo takes nothing returns booleancall L1x('ATpS',false)set U6v=L0o('ATpS')set K6[(U6v)]=(h6)set m6[(U6v)]=(1)set TH[(U6v)]=("Teleport Scroll")set Rh[(U6v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0278)))),(((Aj))))))set oxv[(U6v)]=(3)set x3v[(U6v)]=("spell")
call L1o((U6v),dH+(1),((4)*1.))call L1o((U6v),GH+(1),((30)*1.))
call L1o((U6v),tH+(1),((0)*1.))call L1o((U6v),Lov+(1),((99999)*1.))
return trueendfunctionfunction Who takes nothing returns booleancall VNx(ma,(function WFo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\TeleportScroll.page\\TeleportScroll.struct\\obj_dummyBuff_wc3buff.j"))call VNx(Qa,(function Wgo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\TeleportScroll.page\\TeleportScroll.struct\\obj_thisItem_wc3item.j"))
call VNx(Pa,(function WGo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Pharmacy.page\\Pharmacy.struct\\Misc.pack\\TeleportScroll.page\\TeleportScroll.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction WHo takes nothing returns booleanset U7v=VXx(U5v)
return trueendfunctionfunction Wjo takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oMx=CIx(Iix,wxv)local integer oSxlocal integer Cqxloop
set oSx=CAx(Iix,wxv,oMx)
set Cqx=oSxcall AZx(Cqx,U4v)set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction WJo takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Igv)thenreturn false
endifif not(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction Wko takes integer oSx,real x,real y returns integer
local integer XLo=NEo((oSx))
local real mlolocal integer NRolocal boolean mLolocal real mmoif(XLo==w)thenreturn w
endifset mLo=falseloop
set mmo=iAx(.0,jKx(Dsx(XLo)-x,Dtx(XLo)-y)-dox(XLo,true))
call GroupAddUnit(kb[(yQ)],C[(XLo)])
if not mLo thenset mlo=mmoset NRo=XLoset mLo=true
elseif(mmo<mlo)thenset mlo=mmoset NRo=XLoendifset XLo=NEo((oSx))exitwhen(XLo==w)
endloopcall NXo((oSx),yQ)return NRoendfunctionfunction WKo takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer dax=wrvlocal real Wlo=wivlocal real WLo=wavlocal integer oSx=Cqxlocal integer dnxlocal real Wmolocal real WMolocal real Wpolocal real WPolocal real dXlocal real dYlocal real bexif(dax==w)thenset hf=(ze[(Cqx)])call GroupEnumUnitsInRect(kb[((U8v))],bm[Bm],Bv[(wov)])set dnx=(Wko((U8v),((Wlo)*1.),((WLo)*1.)))if(dnx==w)thenreturn trueendifset Wpo=(GetUnitX(C[((dnx))]))set WPo=(GetUnitY(C[((dnx))]))set dX=Wlo-Wposet dY=WLo-WPoif(GZx(dX,dY)>U9v)thenset bex=(Atan2(((dY)*1.),((dX)*1.)))
set Wmo=wvv*(Cos(((((bex)*1.))*1.)))
set WMo=wvv*(Sin(((((bex)*1.))*1.)))
else
set Wmo=Wlo-Wposet WMo=WLo-WPoendifelse
if(lw==w)thenreturn trueendifif I9x(lw,Qc)thenreturn trueendifset Wmo=.0set WMo=.0set dnx=lwendifset wnv[oSx]=dnx
set wVv[oSx]=(ACx((dnx),(wEv),(wXv),(Bi)))set wOv[oSx]=Wmo
set wRv[oSx]=WMo
if rUx(dnx,wxv,oSx)thencall Avx(dnx,wev)endifcall r0x(((Cqx)),((gtv)),(1))return trueendfunctionfunction Wqo takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oSx=Cqxlocal integer Iix=wnv[oSx]local integer WQo=wVv[oSx]if rnx(Iix,wxv,oSx)thencall RPx(Iix,wev)endifcall Ryx(WQo)call rpx(Cqx,gtv)return trueendfunctionfunction Wso takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local boolean ELo=(oav[(rFx)])local integer oSx=Cqxlocal integer Iix=wnv[oSx]local real Wmo=wOv[oSx]local real WMo=wRv[oSx]call AZx(Cqx,U4v)if ELo thencall pmo((ACx((Cqx),(wIv),(wAv),(Bi))),2.)call SetUnitPosition(C[((Cqx))],(((GetUnitX(C[((Iix))]))+Wmo)*1.),(((GetUnitY(C[((Iix))]))+WMo)*1.))
endifreturn trueendfunctionfunction WSo takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])set wrv=(wH[(rFx)])set wiv=(yH[(rFx)])set wav=(YH[(rFx)])call seo(Cqx,U4v,(Mv[(rFx)]))return trueendfunctionfunction Wto takes nothing returns booleanset U8v=O5x()set U9v=wvv*wvvset wev=Xdx("TeleportScroll_Init: set TeleportScroll.TARGET_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function TeleportScroll.Event_TargetDeath)",VP,KI,function Wjo)set wov=Xpx(function WJo)call Lxx(U4v,Xdx("TeleportScroll_Init: call TeleportScroll.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TeleportScroll.Event_BuffGain))",bd,MI,function WKo))call Lxx(U4v,Xdx("TeleportScroll_Init: call TeleportScroll.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TeleportScroll.Event_BuffLose))",jc,MI,function Wqo))call mro(U6v,Xdx("TeleportScroll_Init: call TeleportScroll.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TeleportScroll.Event_EndCast))",onv,MI,function Wso))
call mro(U6v,Xdx("TeleportScroll_Init: call TeleportScroll.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TeleportScroll.Event_SpellEffect))",ih,MI,function WSo))return trueendfunctionfunction WTo takes nothing returns booleancall Pso(function Wto,"TeleportScroll_Init")
return trueendfunctionfunction Wuo takes nothing returns booleanset wNv=L6o('IRun')call L7o(((wNv)),tS,(bS))return trueendfunctionfunction WUo takes nothing returns booleancall VNx(Qa,(function Wuo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Rune.page\\Rune.struct\\obj_thisItem_wc3item.j"))return trueendfunctionfunction Wwo takes nothing returns booleanset wbv=VXx(wBv)
return trueendfunctionfunction WWo takes code c,string rSx returns nothing
set LV=LV+1set mV[LV]=CreateTrigger()set MV[LV]=(GetHandleId(Condition((c))))
set pV[LV]=rSxcall TriggerAddCondition(mV[LV],Condition(c))endfunctionfunction Wyo takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif not(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction WYo takes integer oSx returns integerset wHv[oSx]=trueset wjv[oSx]=falsecall rEx(wbv)return oSxendfunctionfunction Wzo takes nothing returns integerlocal integer oSxif(wFv==8190)thencall o_x("Rune_Allocation_allocCustom","call DebugEx(Rune.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",wBv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(wgv[(w)]==w)thenset wGv=wGv+1set oSx=wGvelse
set oSx=wgv[(w)]
set wgv[(w)]=wgv[wgv[(w)]]endifset wgv[oSx]=Zset whv[oSx]=1call WYo(oSx)return oSxendfunctionfunction WZo takes integer oSx returns nothingset wHv[oSx]=falsecall rHx(wbv)endfunctionfunction W_o takes integer oSx returns nothingif(whv[oSx]>0)thenreturnendifif(wgv[oSx]!=Z)thencall o_x("Rune_Allocation_deallocCustom_confirm","call DebugEx(Rune.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",wBv+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset wgv[oSx]=wgv[(w)]set wgv[(w)]=oSx
call WZo(oSx)endfunctionfunction W0o takes integer oSx returns nothingset whv[oSx]=whv[oSx]-1call W_o(oSx)endfunctionfunction W1o takes integer oSx,integer iCx,integer W2o returns nothingcall W0o((oSx))call iKx(iCx)call J8x(W2o,wKv)call J7x(W2o,wlv)endfunctionfunction W3o takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local integer W2o=wkv[oSx]call W1o(oSx,iCx,W2o)call SetWidgetLife(gh[(W2o)],.0)
endfunctionfunction W4o takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])local integer oSxlocal integer iCxlocal integer W2oif((fG[(rFx)])==w)thenreturn trueendifif(wDv<wfv)thenset wDv=wDv+1return trueendifset wDv=0set oSx=Wzo()set iCx=iXx()set W2o=(kGx(CreateItem(Hh[(wNv)],(((GetUnitX(C[((OSx))])))*1.),(((GetUnitY(C[((OSx))])))*1.))))
set wJv[oSx]=iCx
set wkv[oSx]=W2o
set ge[(iCx)]=(oSx)call kxx(W2o,wKv,oSx)call kex(W2o,wlv)call iDx(iCx,wLv,false,function W3o)
return trueendfunctionfunction W5o takes nothing returns booleanlocal integer rFx=(bv)local integer W2o=(qh[(rFx)])local integer oSx=CLx(W2o,wKv)call W1o(oSx,wJv[oSx],W2o)return trueendfunctionfunction W6o takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call Rgo(OSx,wdv)return trueendfunctionfunction W7o takes nothing returns booleanlocal integer rFx=(bv)local integer Iixlocal integer Cgx=(qh[(rFx)])local integer OSx=(Vv[(rFx)])local real W8o=(GetItemX(gh[((Cgx))]))local real W9o=(GetItemY(gh[((Cgx))]))call mho((mko(((W8o)*1.),((W9o)*1.),(wmv),(Bi))))set hf=(ze[(OSx)])call NVo(wcv,W8o,W9o,wMv,wCv)set Iix=NEo(wcv)
if(Iix!=w)thenloop
call mao(Iix,Iix,(rG[(Iix)])*wpv)call BNx(Iix,(LF[(Iix)])*wPv)set Iix=NEo(wcv)
exitwhen(Iix==w)
endloopendifreturn trueendfunctionfunction yvo takes nothing returns booleanset wcv=O5x()set wCv=Xpx(function Wyo)set wdv=P2o(Xdx("Rune_Init: set Rune.THIS_DROP = CustomDrop.Create(Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function Rune.Event_Spawn_Death), null, null, EffectLevel.NORMAL)",VP,KI,function W4o),null,null,Bi)set wlv=Xdx("Rune_Init: set Rune.RUNE_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function Rune.Event_Rune_Death)",VP,lI,function W5o)call Dcx(Xdx("Rune_Init: call Event.Create(Spawn.DUMMY_EVENT_TYPE, EventPriority.MISC, function Rune.Event_Spawn).AddToStatics()",Rw,lI,function W6o))call pEo(wNv,Xdx("Rune_Init: call Rune.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Use.DUMMY_EVENT_TYPE, EventPriority.MISC, function Rune.Event_ItemUse))",Sh,lI,function W7o))return trueendfunctionfunction yeo takes nothing returns booleancall WWo(function yvo,"Rune_Init")return trueendfunctionfunction yxo takes nothing returns booleanset wqv=hjo('uSnM')call hJo(((wqv)),ASv,(Igv))call hJo(((wqv)),ASv,(Idv))set Uj[(wqv)]=((2)*1.)set NOv[(wqv)]=((20)*1.)
set NWv[(wqv)]=((60)*1.)
set I8v[(wqv)]=((0)*1.)set Anv[(wqv)]=(1)set Nmv[(wqv)]=(($C8)*1.)set NLv[(wqv)]=(($C8)*1.)set NKv[(wqv)]=((0)*1.)set Ncv[(wqv)]=(($5DC)*1.)set Nbv[(wqv)]=(($5DC)*1.)set NGv[(wqv)]=((25)*1.)
set Auv[(wqv)]=((0)*1.)set AUv[(wqv)]=((0)*1.)set AYv[(wqv)]=(0)set A_v[(wqv)]=(0)set Nnv[(wqv)]=(30)return trueendfunctionfunction yoo takes nothing returns booleanset wQv=L6o('ISno')call L7o(((wQv)),tS,(bS))return trueendfunctionfunction yro takes nothing returns booleanset wsv=Wwx('BPos',"Possession",'bPos')set aav[(wsv)]=(true)set anv[(wsv)]=("ReplaceableTextures\\CommandButtons\\BTNMagicalSentry.blp")
return trueendfunctionfunction yio takes nothing returns booleancall VNx(sa,(function yxo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Snowmen.page\\Snowmen.struct\\obj_thisUnitType_wc3unit.j"))call VNx(Qa,(function yoo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Snowmen.page\\Snowmen.struct\\obj_thisItemType_wc3item.j"))call VNx(ma,(function yro),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Snowmen.page\\Snowmen.struct\\obj_possessionBuff_wc3buff.j"))return trueendfunctionfunction yao takes nothing returns booleanset wSv=VXx(wtv)
return trueendfunctionfunction yno takes nothing returns booleanlocal integer rFx=(bv)local integer yVo=(Vv[(rFx)])local real x=(GetUnitX(C[((yVo))]))local real y=(GetUnitY(C[((yVo))]))call Owx(yVo)call kGx(CreateItem(Hh[(wQv)],((x)*1.),((y)*1.)))set wuv=wuv-1if(wuv==0)thenset l0v=l0v-((.25)*1.)call ipx(Ge,iSx("Notification:","ffffcc00")+" "+iSx("You lost control of the last Flower. The spawns' supply loot is reset to the default value.","ffff0000"),10.)endifreturn trueendfunctionfunction yEo takes nothing returns booleanlocal integer rFx=(bv)call SetItemInvulnerable(gh[((qh[(rFx)]))],(true))return trueendfunctionfunction yXo takes nothing returns booleanlocal integer rFx=(bv)local integer yOo=(qh[(rFx)])local real x=(GetItemX(gh[((yOo))]))
local real y=(GetItemY(gh[((yOo))]))
local integer yVo=bOx(wqv,BYv,x,y,kf)call Avx(yVo,wTv)call r0x(((yVo)),((gtv)),(1))call r0x((yVo),(uHv),(2))call SetUnitAnimation(C[((yVo))],("birth"))call QueueUnitAnimation(C[((yVo))],("stand"))call Nbx((yVo),(wsv),(1),w,((30.+.01)*1.))call pmo((ACx((yVo),(wUv),(wwv),(Bi))),2.)call UZo((yVo),((30.)*1.))set wuv=wuv+1if(wuv==1)thenset l0v=l0v+((.25)*1.)call ipx(Ge,iSx("Notification:","ffffcc00")+" "+iSx("You got control of a Flower, all enemy units drop "+(I2S(((R2I(((((.25*100.)*1.))*1.))))))+"%"+" more supply.","ff00ff00"),10.)
endifreturn trueendfunctionfunction yRo takes nothing returns booleanset wTv=Xdx("Snowmen_Init: set Snowmen.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function Snowmen.Event_Death)",VP,lI,function yno)
call pEo(wQv,Xdx("Snowmen_Init: call Snowmen.THIS_ITEM_TYPE.Event.Add(Event.Create(Item.CREATE_EVENT_TYPE, EventPriority.MISC, function Snowmen.Event_Create))",BS,lI,function yEo))
call pEo(wQv,Xdx("Snowmen_Init: call Snowmen.THIS_ITEM_TYPE.Event.Add(Event.Create(UNIT.Items.Events.Use.DUMMY_EVENT_TYPE, EventPriority.MISC, function Snowmen.Event_Use))",Sh,lI,function yXo))return trueendfunctionfunction yIo takes nothing returns booleancall kzo(function yRo,"Snowmen_Init")return trueendfunctionfunction yAo takes nothing returns booleanset wWv=VXx(wyv)
return trueendfunctionfunction yNo takes nothing returns booleanset wYv=VXx(wzv)
return trueendfunctionfunction ybo takes nothing returns booleanset wZv=VXx(w_v)
return trueendfunctionfunction yBo takes nothing returns booleanset w0v=VXx(w1v)
return trueendfunctionfunction yco takes nothing returns booleanset w2v=VXx(w3v)
return trueendfunctionfunction yCo takes nothing returns booleanset w4v=VXx(w5v)
return trueendfunctionfunction ydo takes nothing returns booleanset w6v=VXx(w7v)
return trueendfunctionfunction yDo takes nothing returns booleanset w8v=VXx(w9v)
return trueendfunctionfunction yfo takes nothing returns booleanset Wvv=VXx(Wev)
return trueendfunctionfunction yFo takes nothing returns booleanset Wxv=VXx(Wov)
return trueendfunctionfunction ygo takes nothing returns booleanset Wrv=VXx(Wiv)
return trueendfunctionfunction yGo takes nothing returns booleanset Wav=VXx(Wnv)
return trueendfunctionfunction yho takes nothing returns booleanset WVv=VXx(WEv)
return trueendfunctionfunction yHo takes nothing returns booleanset WXv=VXx(WOv)
return trueendfunctionfunction yjo takes nothing returns booleanset WRv=VXx(WIv)
return trueendfunctionfunction yJo takes nothing returns booleanset WAv=ltx(WNv+" (dummyBuff)")return trueendfunctionfunction yko takes nothing returns booleancall VNx(ma,(function yJo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Spawn.page\\Spawn.struct\\Shadow\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction yKo takes nothing returns booleanset Wbv=VXx(WNv)
return trueendfunctionfunction ylo takes nothing returns booleanset WBv=VXx(Wcv)
return trueendfunctionfunction yLo takes nothing returns nothingcall OWx()endfunctionfunction ymo takes nothing returns nothingif(WDv[((k2o((qe),Jpv)))])thenif(not(dmx((Eb),Ob))or not((Wfv)==F))thenreturnendifendifcall aRx(qe)
endfunctionfunction yMo takes nothing returns booleanlocal integer rFx=(bv)local integer Oyx=(Vv[(rFx)])call RPx(Oyx,Wdv)call IRo(Eb,Oyx)
if(WDv[((k2o((qe),Jpv)))])thencall ymo()endifreturn trueendfunctionfunction ypo takes nothing returns nothinglocal integer oMx=Hl
local integer OSxloop
exitwhen(oMx<0)set OSx=(kv[(jl[oMx])])if(OSx!=w)thenif I9x(OSx,Qc)thencall qpo(OSx,(GetUnitX(C[((OSx))])),(GetUnitY(C[((OSx))])))endifcall Ryx((ACx((OSx),("Abilities\\Spells\\Items\\AIre\\AIreTarget.mdl"),("origin"),(ri))))call chx(OSx,(rG[(OSx)]))call BAx(OSx,(LF[(OSx)]))endifset oMx=oMx-1endloopendfunctionfunction yPo takes nothing returns booleanlocal integer rFx=(bv)local integer kMo=(jWv[(rFx)])if((JEv[(kMo)])and not(JEv[((Jav[(kMo)]))]))then
call OWx()call ypo()endifreturn trueendfunctionfunction yqo takes integer oSx returns booleanif(((Wgv[((oSx))])>0)==false)thenreturn false
endifset Wgv[WGv[Wfv]]=Wgv[oSx]set WGv[Wgv[oSx]-1]=WGv[Wfv]
set Wgv[oSx]=0set Wfv=Wfv-1return(Wfv==F)endfunctionfunction yQo takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((Whv[(oSx)]))])]))],((((WHv[((oSx))])))),(((otx))))))endfunctionfunction yso takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((Whv[(oSx)]))])]))],((((WHv[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction ySo takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((Whv[(oSx)]))])]))],((((WHv[((oSx))])))),(((otx)))))endfunctionfunction yto takes integer oSx returns nothinglocal integer oMxlocal integer NOoif(oSx==w)thenreturnendifif not((Wgv[((oSx))])>0)then
returnendifcall yqo(oSx)set oMx=(yQo(((oSx)),Wjv))loop
exitwhen(oMx<q)set NOo=(yso(((oSx)),Wjv,(oMx)))
call ikx((ySo(((oSx)),WJv+(NOo))))call ikx(Wkv[oSx])set oMx=oMx-1endloopendfunctionfunction yTo takes nothing returns booleanlocal integer rFx=(bv)call yto((k2o(((Qe[(rFx)])),Jpv)))return trueendfunctionfunction yuo takes integer oSx returns realreturn iAx((Wmv[(oSx)]),(WMv[(oSx)]))endfunctionfunction yUo takes nothing returns nothingcall ymo()endfunctionfunction ywo takes integer oSx returns booleanif((Wgv[((oSx))])>0)then
return false
endifset Wfv=Wfv+1set WGv[Wfv]=oSx
set Wgv[oSx]=Wfv+1return(Wfv==0)endfunctionfunction yWo takes integer oSx,integer otx returns realreturn(LoadReal(o[((V[(E[((Whv[(oSx)]))])]))],((((WHv[((oSx))])))),(((otx)))))endfunctionfunction yyo takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((WQv[(oSx)]))])]))],((((Wsv[((oSx))])))),(((otx))))))endfunctionfunction yYo takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((WQv[(oSx)]))])]))],((((Wsv[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction yzo takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((WQv[(oSx)]))])]))],((((Wsv[((oSx))])))),(((otx)))))endfunctionfunction yZo takes integer oSx returns integerset W0v[oSx]=trueset W1v[oSx]=falsecall rEx(WRv)return oSxendfunctionfunction y_o takes nothing returns integerlocal integer oSxif(WYv==8190)thencall o_x("FolderSpawn_StructQueue_Allocation_allocCustom","call DebugEx(FolderSpawn_StructQueue.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",WIv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Wzv[(w)]==w)thenset WZv=WZv+1set oSx=WZvelse
set oSx=Wzv[(w)]
set Wzv[(w)]=Wzv[Wzv[(w)]]endifset Wzv[oSx]=Zset W_v[oSx]=1call yZo(oSx)return oSxendfunctionfunction y0o takes integer oSx returns booleanreturn(W7v==oSx)or((W8v[oSx]!=w)or(W9v[oSx]!=w))
endfunctionfunction y1o takes integer oSx returns booleanif y0o(oSx)thenreturn false
endifset W9v[oSx]=wif(W7v==w)thenset yvv=oSxset W7v=oSxreturn trueendifset W8v[oSx]=yvv
set W9v[yvv]=oSx
set yvv=oSxreturn false
endfunctionfunction y2o takes nothing returns integerlocal integer oSx=W7vif(oSx==w)thenreturn w
endifset W7v=W9v[oSx]
set W9v[oSx]=wif(W7v==w)thenset yvv=welse
set W8v[W7v]=wendifreturn oSxendfunctionfunction y3o takes integer oSx returns nothingset W0v[oSx]=falsecall rHx(WRv)endfunctionfunction y4o takes integer oSx returns nothingif(W_v[oSx]>0)thenreturnendifif(Wzv[oSx]!=Z)thencall o_x("FolderSpawn_StructQueue_Allocation_deallocCustom_confirm","call DebugEx(FolderSpawn_StructQueue.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",WIv+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Wzv[oSx]=Wzv[(w)]set Wzv[(w)]=oSx
call y3o(oSx)endfunctionfunction y5o takes integer oSx returns nothingset W_v[oSx]=W_v[oSx]-1call y4o(oSx)endfunctionfunction y6o takes integer Iix returns nothinglocal integer oSx=(yxv[(GetRandomInt(((0)),((yov))))])call Rgo(Iix,yrv[oSx])endfunctionfunction y7o takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((ynv[oSx]))])]))],((((yav[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))endfunctionfunction y8o takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((ynv[oSx]))])]))],((((yav[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))endfunctionfunction y9o takes integer rNx,integer OSx returns nothinglocal integer rFx=rRx(0)
local integer GPxlocal integer oMxlocal integer rbxlocal integer rMxset yiv[(rFx)]=(rNx)
set Vv[(rFx)]=(OSx)set GPx=rRx((yav[(rNx)]))set yiv[(GPx)]=(rNx)
set Vv[(GPx)]=(OSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Rw))-1)*Iv+(((rbx))-1)))))))))loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Rw))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset rMx=y7o(rNx,Rw,rbx)loop
exitwhen(rMx<q)call rfx(y8o(rNx,Rw,rbx,rMx),GPx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))call rkx(((GPx)))endfunctionfunction Yvo takes integer rNx,integer l_o,real x,real y,real bex returns nothinglocal real i0x=(NZv[(l_o)])local real Nlx=(NPv[(l_o)])local integer l0oset NPv[(l_o)]=((Nlx*.5)*1.)
set NZv[(l_o)]=((.0)*1.)
set l0o=bOx(l_o,Hzv,x,y,bex)
call dQx(Eb,l0o)
call Avx(l0o,Wdv)call fsx(l0o,.0,.0,.0,i0x,3.)set NPv[(l_o)]=((Nlx)*1.)set NZv[(l_o)]=((i0x)*1.)if((GetRandomInt((1),(17)))==17)then
call y6o(l0o)endifcall y9o(rNx,l0o)call cvx(l0o,(s6v[(pe)])*(Lg[(l0o)]))call csx(l0o,iAx(.405,(Me[(pe)])*(rG[(l0o)])))call chx(l0o,(rG[(l0o)]))endfunctionfunction Yeo takes nothing returns nothinglocal integer oSx=y2o()local integer rNx=W2v[oSx]local integer l_o=W3v[oSx]local real x=W4v[oSx]local real y=W5v[oSx]local real bex=W6v[oSx]call y5o((oSx))if(W7v==w)thencall ikx(yev)endifcall Yvo(rNx,l_o,x,y,bex)endfunctionfunction Yxo takes integer rNx,integer l_o,real x,real y,real bex returns nothinglocal integer oSx=y_o()set W2v[oSx]=rNx
set W3v[oSx]=l_o
set W4v[oSx]=xset W5v[oSx]=yset W6v[oSx]=bex
if y1o(oSx)thencall iDx(yev,.75,true,function Yeo)endifendfunctionfunction Yoo takes integer rNx,integer l_o,real x,real y,real bex returns nothingcall Yxo(rNx,l_o,x,y,bex)endfunctionfunction Yro takes nothing returns nothinglocal integer NOo=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer oMx=(yyo((NOo),WSv))local integer Yiolocal real bexlocal real GWxlocal real Gyxlocal real GUxlocal real Gwxlocal integer rMxlocal integer rNxlocal integer nZxloop
exitwhen(oMx<q)set Yio=(yYo((NOo),WSv,(oMx)))set bex=Wtv[Yio]
set GWx=WTv[Yio]
set Gyx=Wuv[Yio]
set GUx=WUv[Yio]
set Gwx=Wwv[Yio]
set rMx=(yyo((NOo),WWv))
loop
exitwhen(rMx<q)set rNx=(yYo((NOo),WWv,(rMx)))set nZx=(yzo((NOo),Wyv+(rNx)))loop
exitwhen(nZx<1)call Yoo(rNx,(yVv[(rNx)]),(GetRandomReal(((GUx)*1.),((GWx)*1.))),(GetRandomReal(((Gwx)*1.),((Gyx)*1.))),bex)
set nZx=nZx-1endloopset rMx=rMx-1endloopset oMx=oMx-1endloopendfunctionfunction Yao takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])call yto(oSx)endfunctionfunction Yno takes integer oSx returns nothinglocal integer oMxlocal integer NOocall ywo(oSx)set oMx=(yQo(((oSx)),Wjv))loop
exitwhen(oMx<q)set NOo=(yso(((oSx)),Wjv,(oMx)))
call iDx((ySo(((oSx)),WJv+(NOo))),(yWo(((oSx)),Wqv+(NOo))),false,function Yro)call iDx(Wkv[oSx],yuo(oSx),false,function Yao)set oMx=oMx-1endloopendfunctionfunction YVo takes nothing returns booleanlocal integer rFx=(bv)local integer k4o=(Qe[(rFx)])local integer l7o=(k2o((k4o),Jpv))local integer YEolocal integer YXoif(l7o==w)thenreturn trueendifset YEo=(ue[(k4o)])set YXo=(k2o((YEo),Jpv))
set WKv=0if(YEo==w)thencall TimerDialogDisplay(Wlv[(WLv)],false)call iDx(WFv,yuo(l7o)+(Wpv[(l7o)]),false,function yUo)else
if(WDv[(l7o)])thencall TimerDialogDisplay(Wlv[(WLv)],false)else
call TimerDialogSetTitle(Wlv[(WLv)],("Level "+(Ue[(YEo)])+" begins in: "))call iDx(WFv,yuo(l7o)+(Wpv[(l7o)])+(WPv[(YXo)]),false,function yUo)endifendifcall Yno(l7o)return trueendfunctionfunction YOo takes nothing returns booleanlocal integer rFx=(bv)call Dcx(Xdx("Spawn_Event_Start: call Event.Create(Level.ENDING_EVENT_TYPE, EventPriority.MISC, function Spawn.Event_LevelEnding).AddToStatics()",te,lI,function yTo))call Dcx(Xdx("Spawn_Event_Start: call Event.Create(Level.START_EVENT_TYPE, EventPriority.MISC, function Spawn.Event_LevelStart).AddToStatics()",We,lI,function YVo))
return trueendfunctionfunction YRo takes nothing returns nothinglocal integer oMx=Wfvloop
exitwhen(oMx<0)set yEv[oMx]=WGv[oMx]set oMx=oMx-1endloopset yXv=Wfvendfunctionfunction YIo takes nothing returns integerlocal integer o7xif(yXv<0)thenreturn w
endifset o7x=yEv[0]set yEv[0]=yEv[yXv]set yXv=yXv-1return o7xendfunctionfunction YAo takes nothing returns nothinglocal integer oSxcall YRo()loop
set oSx=YIo()exitwhen(oSx==w)
call yto(oSx)endloopendfunctionfunction YNo takes nothing returns booleanlocal integer rFx=(bv)call ikx(WFv)call YAo()return trueendfunctionfunction Ybo takes integer oSx returns integerset yNv[oSx]=trueset ybv[oSx]=falsecall rEx(vCv)return oSxendfunctionfunction YBo takes nothing returns integerlocal integer oSxif(yOv==8190)thencall o_x("TimerDialog_Allocation_allocCustom","call DebugEx(TimerDialog.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",vdv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(yRv[(w)]==w)thenset yIv=yIv+1set oSx=yIvelse
set oSx=yRv[(w)]
set yRv[(w)]=yRv[yRv[(w)]]endifset yRv[oSx]=Zset yAv[oSx]=1call Ybo(oSx)return oSxendfunctionfunction Yco takes integer o0x returns integerlocal integer oSx=YBo()set Wlv[oSx]=CreateTimerDialog(Oe[o0x])return oSxendfunctionfunction YCo takes integer oSx,real oux returns nothingcall BAx(oSx,(lF[(oSx)])-oux)endfunctionfunction Ydo takes integer oSx,integer Iix,real nZx returns nothinglocal integer Lloif(nZx<1.)thenreturnendifset Llo=Lko(Iix,ycv+Iix,nZx)
call X9x(Llo,iSx("-"+(I2S(((R2I((((((dN[(Llo)]))*1.))*1.)))))),"ffffff00"),.02)call YCo(Iix,nZx)endfunctionfunction YDo takes nothing returns booleanlocal integer rFx=(bv)local real Nbo=(E1v[(rFx)])local integer Yfo=(E2v[(rFx)])local integer Iix=(zH[(rFx)])local real YFo=iUx((lF[(Iix)]),Nbo)call o_x("FolderSpawn_StructShadow_Event_Damage","call DebugEx(\"burn mana\")","burn mana")call Ydo(Yfo,Iix,YFo)set E1v[(rFx)]=((Nbo-YFo)*1.)return trueendfunctionfunction Ygo takes integer oSx returns nothinglocal integer Yfo=oSxcall mho(mko((GetUnitX(C[((Yfo))])),(GetUnitY(C[((Yfo))])),"Objects\\Spawnmodels\\Undead\\UndeadDissipate\\UndeadDissipate.mdx",ri))
call Owx(Yfo)endfunctionfunction YGo takes nothing returns booleanlocal integer rFx=(bv)local integer Oyx=(Vv[(rFx)])local integer oSx=osx(Oyx,ydv)call Ygo(oSx)return trueendfunctionfunction Yho takes nothing returns booleanlocal integer rFx=(bv)local integer Oyx=(Vv[(rFx)])local integer oSx=osx(Oyx,ydv)call Ygo(oSx)return trueendfunctionfunction YHo takes nothing returns booleanlocal integer rFx=(bv)local integer Yfo=(Vv[(rFx)])local integer oSx=Yfocall CBx(Yfo,bw,(GetUnitX(C[((yFv[oSx]))])),(GetUnitY(C[((yFv[oSx]))])))
return trueendfunctionfunction Yjo takes integer oSx returns booleanreturn(yhv==oSx)or((yHv[oSx]!=w)or(yjv[oSx]!=w))
endfunctionfunction YJo takes integer oSx returns booleanif Yjo(oSx)thenreturn false
endifset yjv[oSx]=wif(yhv==w)thenset yJv=oSxset yhv=oSxreturn trueendifset yHv[oSx]=yJv
set yjv[yJv]=oSx
set yJv=oSxreturn false
endfunctionfunction Yko takes nothing returns integerlocal integer oSx=yhvif(oSx==w)thenreturn w
endifset yhv=yjv[oSx]
set yjv[oSx]=wif(yhv==w)thenset yJv=welse
set yHv[yhv]=wendifreturn oSxendfunctionfunction YKo takes integer oSx returns booleanlocal boolean Ylolocal integer YLolocal boolean o7xif not(NIv[(oSx)]>0)then
return false
endifif not(IsUnitType(C[(((oSx)))],(UNIT_TYPE_DEAD)))thenreturn false
endifset Ylo=(IsUnitType(C[(((oSx)))],(UNIT_TYPE_STRUCTURE)))
set YLo=(ze[((oSx))])call mbx(eJ,YLo)
call DQx(eJ,Dsx((oSx)))call DSx(eJ,Dtx((oSx)))call UnitAddType(C[(((oSx)))],(UNIT_TYPE_TAUREN))call UnitShareVision(C[(oSx)],vx[YLo],true)set o7x=(IssueImmediateOrderById(vJ[((eJ))],pb[(r3)]))call mbx(eJ,Jy)call UnitRemoveType(C[(((oSx)))],(UNIT_TYPE_TAUREN))
if o7x thenif Ylo thencall ShowUnit(C[(oSx)],false)endifset NRv[(oSx)]=(false)call Aqo((oSx),Qc)if Ylo thencall ShowUnit(C[(oSx)],true)
endifcall chx((oSx),(rG[((oSx))]))call qMo((oSx))return trueendifreturn false
endfunctionfunction Ymo takes nothing returns nothinglocal integer Yfo=Yko()local integer oSx=Yfoif(yhv==w)thencall ikx(ygv)endifcall ShowUnit(C[Yfo],true)call YKo(Yfo)call SetUnitPosition(C[((Yfo))],(((GetUnitX(C[((lw))])))*1.),(((GetUnitY(C[((lw))])))*1.))call CBx(Yfo,bw,(GetUnitX(C[((yFv[oSx]))])),(GetUnitY(C[((yFv[oSx]))])))
call UZo(Yfo,60.)endfunctionfunction YMo takes nothing returns booleanlocal integer rFx=(bv)local integer Yfo=(Vv[(rFx)])local integer oSx=Yfocall mho(mko((GetUnitX(C[((Yfo))])),(GetUnitY(C[((Yfo))])),"Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl",ri))
call SetUnitPosition(C[((Yfo))],(((GetUnitX(C[((lw))])))*1.),(((GetUnitY(C[((lw))])))*1.))call ShowUnit(C[Yfo],false)if YJo(Yfo)thencall iDx(ygv,1.25,true,function Ymo)
endifreturn trueendfunctionfunction Ypo takes integer oSx returns booleanif((cQv[((oSx))])>0)then
return false
endifset cSv=cSv+1set csv[cSv]=oSx
set cQv[oSx]=cSv+1return(cSv==0)endfunctionfunction YPo takes nothing returns nothinglocal integer oMx=cuvloop
exitwhen(oMx<0)set yKv[oMx]=cTv[oMx]set oMx=oMx-1endloopset ylv=cuvendfunctionfunction Yqo takes nothing returns integerlocal integer o7xif(ylv<0)thenreturn w
endifset o7x=yKv[0]set yKv[0]=yKv[ylv]set ylv=ylv-1return o7xendfunctionfunction YQo takes integer oSx returns nothinglocal integer rLx=oSxlocal integer rFx=rRx((A[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset Vv[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=rAx(rLx,cWv,rbx)
loop
exitwhen(rMx<q)call rfx(rgx(rLx,cWv,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction Yso takes nothing returns nothinglocal integer oSxcall YPo()loop
set oSx=Yqo()exitwhen(oSx==w)
if((cYv[((oSx))])>0)then
if(dPx((oSx))==w)thencall YQo(oSx)else
call BPo(oSx)call Bqo(oSx)endifelse
if(dPx((oSx))==w)thencall BSo(oSx)call Bto(oSx)endifendifendloopendfunctionfunction YSo takes integer oSx,integer XYx returns nothingif rUx((oSx),cqv,XYx)thencall Avx((oSx),cPv)call Ypo(oSx)if not I9x((oSx),Qc)then
if Bso(oSx)thencall iDx(cUv,.75,true,function Yso)endifendifendifcall Avx((oSx),XYx)endfunctionfunction Yto takes nothing returns booleanlocal integer rFx=(bv)local integer Yfo=(Vv[(rFx)])local integer Oyx=ykvlocal integer oSx=Yfoset yFv[oSx]=Oyx
call Avx(Yfo,yBv)call Avx(Yfo,yGv)call YSo(Yfo,yfv)call rwx(Oyx,ydv,oSx)call Avx(Oyx,yCv)call Avx(Oyx,yDv)return trueendfunctionfunction YTo takes integer oSx returns booleanlocal integer RLxlocal integer Rmxif(Yjo(oSx)==false)thenreturn false
endifif(yhv==oSx)then
call Yko()return(yhv==w)endifset RLx=yjv[oSx]
set Rmx=yHv[oSx]
if(Rmx!=w)thenset yHv[oSx]=wset yjv[Rmx]=RLx
endifif(RLx==w)thenset yJv=Rmxelse
set yjv[oSx]=wset yHv[RLx]=Rmx
endifreturn(yhv==w)endfunctionfunction Yuo takes nothing returns booleanlocal integer rFx=(bv)local integer Yfo=(Vv[(rFx)])local integer oSx=Yfolocal integer Oyx=yFv[oSx]call RPx(Yfo,yBv)call RPx(Yfo,yGv)call BMo(Yfo,yfv)call rVx(Oyx,ydv)call RPx(Oyx,yCv)call RPx(Oyx,yDv)if YTo(Yfo)thencall ikx(ygv)endifreturn trueendfunctionfunction YUo takes nothing returns nothingset yBv=Xdx("FolderSpawn_StructShadow_Init: set FolderSpawn_StructShadow.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EDIT_EVENT_TYPE, EventPriority.MISC, function FolderSpawn_StructShadow.Event_Damage)",dAv,lI,function YDo)set yCv=Xdx("FolderSpawn_StructShadow_Init: set FolderSpawn_StructShadow.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderSpawn_StructShadow.Event_Death)",VP,lI,function YGo)set yDv=Xdx("FolderSpawn_StructShadow_Init: set FolderSpawn_StructShadow.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.MISC, function FolderSpawn_StructShadow.Event_Destroy)",EP,lI,function Yho)
set yfv=Xdx("FolderSpawn_StructShadow_Init: set FolderSpawn_StructShadow.IDLE_EVENT = Event.Create(UNIT.Order.Events.Idle.START_EVENT_TYPE, EventPriority.MISC, function FolderSpawn_StructShadow.Event_Idle)",cyv,lI,function YHo)set ygv=iXx()set yGv=Xdx("FolderSpawn_StructShadow_Init: set FolderSpawn_StructShadow.SHADOW_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderSpawn_StructShadow.Event_ShadowDeath)",VP,lI,function YMo)
call Lxx(WAv,Xdx("FolderSpawn_StructShadow_Init: call FolderSpawn_StructShadow.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderSpawn_StructShadow.Event_BuffGain))",bd,lI,function Yto))call Lxx(WAv,Xdx("FolderSpawn_StructShadow_Init: call FolderSpawn_StructShadow.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderSpawn_StructShadow.Event_BuffLose))",jc,lI,function Yuo))endfunctionfunction Ywo takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((sm[(oSx)]))])]))],((((ym[((oSx))])))),(((otx)))))endfunctionfunction YWo takes integer o0x returns integerreturn Ywo(o0x,ymv)endfunctionfunction Yyo takes integer oSx returns integerset yQv[oSx]=trueset ysv[oSx]=falsecall rEx(wWv)return oSxendfunctionfunction YYo takes nothing returns integerlocal integer oSxif(yMv==8190)thencall o_x("SpawnLocation_Allocation_allocCustom","call DebugEx(SpawnLocation.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",wyv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(ypv[(w)]==w)thenset yPv=yPv+1set oSx=yPvelse
set oSx=ypv[(w)]
set ypv[(w)]=ypv[ypv[(w)]]endifset ypv[oSx]=Zset yqv[oSx]=1call Yyo(oSx)return oSxendfunctionfunction Yzo takes integer oSx returns booleanset ytv=ytv+1set yTv[ytv]=oSx
set yuv[oSx]=ytv+1return(ytv==0)endfunctionfunction YZo takes integer o0x returns integerlocal integer Y_o=YWo(o0x)local real x=(tm[(o0x)])
local real y=(Tm[(o0x)])
local integer Y0o=(Hw[(Y_o)])local integer oSx=YYo()set Wtv[oSx]=(Atan2(((LEx(Y0o)-y)*1.),((LVx(Y0o)-x)*1.)))set WTv[oSx]=(um[(o0x)])
set Wuv[oSx]=(Um[(o0x)])
set WUv[oSx]=(wm[(o0x)])
set Wwv[oSx]=(Wm[(o0x)])
set ySv=ySv+1call Yzo(oSx)return oSxendfunctionfunction Y1o takes nothing returns nothingset yLv=YZo(q2x(px))
set yUv=YZo(q2x(Qx))
set ywv=YZo(q2x(sx))
endfunctionfunction Y2o takes nothing returns booleanlocal integer rFx=(bv)local integer rNx=(yiv[(rFx)])local integer OSx=(Vv[(rFx)])call r0x((OSx),(GTv),(2))return trueendfunctionfunction Y3o takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((yYv[(oSx)]))])]))],((((yav[((oSx))])))),(((otx))))))endfunctionfunction Y4o takes integer oSx returns integerreturn Y3o((oSx),yzv)endfunctionfunction Y5o takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((yYv[(oSx)]))])]))],((((yav[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction Y6o takes integer oSx,integer oLx returns integerreturn Y5o((oSx),yzv,oLx)endfunctionfunction Y7o takes nothing returns booleanlocal integer rFx=(bv)local integer rNx=(yiv[(rFx)])local integer OSx=(Vv[(rFx)])local integer oSx=rNxlocal integer oMx=Y4o(oSx)loop
exitwhen(oMx<q)call UnitAddItem(C[((OSx))],gh[(Y6o(oSx,oMx))])set oMx=oMx-1endloopcall ACx((((OSx))),(("Abilities\\Spells\\Orc\\CommandAura\\CommandAura.mdl")),(("origin")),((Bi)))return trueendfunctionfunction Y8o takes integer oSx returns integerset y3v[oSx]=trueset y4v[oSx]=falseset yYv[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set ynv[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(y5v)return oSxendfunctionfunction Y9o takes nothing returns integerlocal integer oSxif(yZv==8190)thencall o_x("SpawnType_Allocation_allocCustom","call DebugEx(SpawnType.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",y_v+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(y0v[(w)]==w)thenset y1v=y1v+1set oSx=y1velse
set oSx=y0v[(w)]
set y0v[(w)]=y0v[y0v[(w)]]endifset y0v[oSx]=Zset y2v[oSx]=1call Y8o(oSx)return oSxendfunctionfunction zvo takes integer oSx,integer oux returns nothingset yVv[oSx]=oux
call hMo(oux,Kw,oSx)
endfunctionfunction zeo takes integer oSx returns booleanset y6v=y6v+1set y7v[y6v]=oSx
set y8v[oSx]=y6v+1return(y6v==0)endfunctionfunction zxo takes integer oSx returns nothingset yav[(oSx)]=(y9v+oSx)
endfunctionfunction zoo takes integer lCo returns integerlocal integer oSx=Y9o()call zvo(oSx,lCo)call zeo(oSx)call zxo(oSx)return oSxendfunctionfunction zro takes integer oSx,integer XYx returns nothingif(ynv[oSx]==w)thencall o_x("FolderSpawnType_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oSx)+";"+(jA[(XYx)]))set ynv[oSx]=Xendifcall rux(ynv[oSx],(yav[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction zio takes integer oSx returns nothingset Yiv[oSx]=truecall zro((oSx),yWv)endfunctionfunction zao takes integer rNx,integer nZx returns nothingcall hMo(rNx,pXv,nZx)call hJo(((rNx)),A7v,(pxv))endfunctionfunction zno takes integer oSx,real oux returns nothingset NPv[(oSx)]=(((NPv[(oSx)])+oux)*1.)endfunctionfunction zVo takes nothing returns nothinglocal integer oMx=y6vlocal integer oSxlocal integer lColoop
exitwhen(oMx<0)set oSx=y7v[oMx]
set lCo=(yVv[(oSx)])
call zno(lCo,(NPv[(lCo)])*.75)if(YEv[(oSx)])thencall hpo((lCo),(GTv),1)endifif(YFv[(oSx)])thencall hpo((lCo),(YMv),1)endifset oMx=oMx-1endloopendfunctionfunction zEo takes nothing returns nothinglocal integer oSxset yWv=Xdx("FolderSpawnType_StructChampion_Init: set FolderSpawnType_StructChampion.SPAWN_EVENT = Event.Create(Spawn.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderSpawnType_StructChampion.Event_Spawn)",Rw,lI,function Y2o)set yyv=Xdx("FolderSpawnType_StructItems_Init: set FolderSpawnType_StructItems.SPAWN_EVENT = Event.Create(Spawn.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderSpawnType_StructItems.Event_Spawn)",Rw,lI,function Y7o)
set oSx=zoo(hFv)
set Yvv=oSxset Yev[(oSx)]=(true)set oSx=zoo(hev)
set Yxv=oSxset Yov[(oSx)]=(true)set oSx=zoo(glv)
set Yrv=oSxcall zio(oSx)set Yov[(oSx)]=(true)set oSx=zoo(hiv)
set Yav=oSxset Yov[(oSx)]=(true)set oSx=zoo(g9v)
set Ynv=oSxcall zao(yVv[(oSx)],('d'))set Yov[(oSx)]=(true)call zio(oSx)set oSx=zoo(GZv)
set YVv=oSxcall zao(yVv[(oSx)],(350))set YEv[(oSx)]=(true)set Yov[(oSx)]=(true)set YXv[(oSx)]=(true)set oSx=zoo(gKv)
set YOv=oSxset Yov[(oSx)]=(true)set oSx=zoo(gKv)
set YRv=oSxcall zio(oSx)set oSx=zoo(gLv)
set YIv=oSxset YXv[(oSx)]=(true)set Yev[(oSx)]=(true)set oSx=zoo(Ggv)
set YAv=oSxset Yov[(oSx)]=(true)set oSx=zoo(hdv)
set YNv=oSxcall zio(oSx)set Yov[(oSx)]=(true)set oSx=zoo(hav)
set Ybv=oSxset Yev[(oSx)]=(true)set oSx=zoo(hVv)
set YBv=oSxset YXv[(oSx)]=(true)set Yov[(oSx)]=(true)set oSx=zoo(Gev)
set Ycv=oSxset Yov[(oSx)]=(true)set oSx=zoo(g1v)
set YCv=oSxset Yev[(oSx)]=(true)set oSx=zoo(gTv)
set Ydv=oSxset YXv[(oSx)]=(true)set Yev[(oSx)]=(true)set oSx=zoo(hEv)
set YDv=oSxset Yov[(oSx)]=(true)set jw[(oSx)]=(true)
set oSx=zoo(GOv)
set Yfv=oSxset YFv[(oSx)]=(true)set Yov[(oSx)]=(true)set oSx=zoo(G3v)
set Ygv=oSxset Yov[(oSx)]=(true)set oSx=zoo(GSv)
set YGv=oSxcall zao(yVv[(oSx)],($C8))set oSx=zoo(GAv)
set Yhv=oSxset YHv[(oSx)]=(true)set Yev[(oSx)]=(true)set oSx=zoo(Gcv)
set Yjv=oSxset YEv[(oSx)]=(true)set Yev[(oSx)]=(true)set oSx=zoo(hOv)
set YJv=oSxcall zao(yVv[(oSx)],(55))call zio(oSx)set Yev[(oSx)]=(true)set oSx=zoo(hIv)
set Ykv=oSxset YEv[(oSx)]=(true)set Yov[(oSx)]=(true)set oSx=zoo(hGv)
set YKv=oSxset Yov[(oSx)]=(true)set oSx=zoo(GEv)
set Ylv=oSxset Yov[(oSx)]=(true)set jw[(oSx)]=(true)
set oSx=zoo(hDv)
set YLv=oSxset Yev[(oSx)]=(true)set oSx=zoo(hDv)
set Ymv=oSxset Yev[(oSx)]=(true)call zVo()endfunctionfunction zXo takes integer oSx returns integerset Ysv[oSx]=trueset YSv[oSx]=falseset Whv[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])call rEx(WXv)return oSxendfunctionfunction zOo takes nothing returns integerlocal integer oSxif(Ypv==8190)thencall o_x("SpawnWave_Allocation_allocCustom","call DebugEx(SpawnWave.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",WOv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(YPv[(w)]==w)thenset Yqv=Yqv+1set oSx=Yqvelse
set oSx=YPv[(w)]
set YPv[(w)]=YPv[YPv[(w)]]endifset YPv[oSx]=Zset YQv[oSx]=1call zXo(oSx)return oSxendfunctionfunction zRo takes integer oSx returns nothingset WHv[(oSx)]=(Ytv+oSx)
endfunctionfunction zIo takes integer oSx,integer oux returns nothingset YTv[oSx]=oux
call LRo(oux,Jpv,oSx)endfunctionfunction zAo takes integer k4o returns integerlocal integer oSx=zOo()local integer iCx=iXx()set Wkv[oSx]=iCx
set ge[(iCx)]=(oSx)call zRo(oSx)set Wmv[(oSx)]=((30.)*1.)call zIo(oSx,k4o)set Wpv[(oSx)]=((.0)*1.)
set WPv[(oSx)]=((.0)*1.)
set WDv[(oSx)]=(k4o==(klo((((JFv[(k4o)]))),Jfv,((kKo((((JFv[(k4o)]))),Jfv))))))return oSxendfunctionfunction zNo takes integer oSx returns integerset Yyv[oSx]=trueset YYv[oSx]=falseset WQv[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])call rEx(w4v)return oSxendfunctionfunction zbo takes nothing returns integerlocal integer oSxif(Yuv==8190)thencall o_x("SpawnGroup_Allocation_allocCustom","call DebugEx(SpawnGroup.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",w5v+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(YUv[(w)]==w)thenset Ywv=Ywv+1set oSx=Ywvelse
set oSx=YUv[(w)]
set YUv[(w)]=YUv[YUv[(w)]]endifset YUv[oSx]=Zset YWv[oSx]=1call zNo(oSx)return oSxendfunctionfunction zBo takes integer oSx returns nothingset Wsv[(oSx)]=(Yzv+oSx)
endfunctionfunction zco takes integer oSx,integer otx,integer oux returns booleanreturn rux(WQv[(oSx)],(Wsv[((oSx))]),otx,oux)endfunctionfunction zCo takes nothing returns integerlocal integer oSx=zbo()call zBo(oSx)call zco((oSx),WSv,(yUv))call zco((oSx),WSv,(ywv))call zco((oSx),WSv,(yLv))return oSxendfunctionfunction zdo takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((WQv[(oSx)]))])]))],((((Wsv[((oSx))])))),(((otx))),(((oux))))
endfunctionfunction zDo takes integer oSx,integer rNx,integer nZx returns nothingcall zdo(oSx,Wyv+rNx,nZx)call zco(oSx,WWv,rNx)endfunctionfunction zfo takes integer oSx,integer otx,integer oux returns booleanreturn rux(Whv[(oSx)],(WHv[((oSx))]),otx,oux)endfunctionfunction zFo takes integer oSx,integer otx,real oux returns nothingcall SaveReal(o[((V[(E[((Whv[(oSx)]))])]))],((((WHv[((oSx))])))),(((otx))),((((((oux)*1.))*1.))*1.))
endfunctionfunction zgo takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((Whv[(oSx)]))])]))],((((WHv[((oSx))])))),(((otx))),(((oux))))
endfunctionfunction zGo takes integer oSx,integer NOo,real Ojx returns nothinglocal integer rLx=oSxlocal integer oMx=(yyo((NOo),WWv))local integer rNxlocal integer Okxloop
exitwhen(oMx<q)set rNx=(yYo((NOo),WWv,(oMx)))if(Yov[(rNx)])thenset Qkv[(rLx)]=(true)endifif(Yev[(rNx)])thenset QKv[(rLx)]=(true)endifif(YXv[(rNx)])thenset Qlv[(rLx)]=(true)endifif(jw[(rNx)])thenset Qmv[(rLx)]=(true)endifif(YFv[(rNx)])thenset QLv[(rLx)]=(true)endifif(YHv[(rNx)])thenset QMv[(rLx)]=(true)endifif(YZv[(rNx)])thenset Qpv[(rLx)]=(true)endifif(YEv[(rNx)])thenset Qjv[(rLx)]=(true)endifset oMx=oMx-1endloopset Okx=iXx()set ge[(Okx)]=(NOo)set WMv[(rLx)]=((Ojx)*1.)call zfo(rLx,Wjv,NOo)call zFo(rLx,Wqv+NOo,Ojx)call zgo(rLx,WJv+NOo,Okx)endfunctionfunction zho takes nothing returns nothinglocal integer oSx=zAo(t0v)local real Ojx=.0local integer zHo=7local integer NOoset JSv[(oSx)]=(hiv)
loop
exitwhen(zHo<1)set Ojx=Ojx+10.set NOo=zCo()call zDo(NOo,Yav,2)call zDo(NOo,YIv,1)call zGo(oSx,NOo,Ojx)set zHo=zHo-1endloopendfunctionfunction zjo takes nothing returns nothinglocal integer oSx=zAo(Kxv)local real Ojx=.0local integer zHo=7local integer NOoset JSv[(oSx)]=(g1v)
loop
exitwhen(zHo<1)set Ojx=Ojx+10.set NOo=zCo()call zDo(NOo,YCv,2)call zDo(NOo,Ydv,1)call zGo(oSx,NOo,Ojx)set zHo=zHo-1endloopendfunctionfunction zJo takes nothing returns nothinglocal integer oSx=zAo(Krv)local real Ojx=.0local integer zHo=7local integer NOoset JSv[(oSx)]=(gLv)
set NOo=zCo()call zDo(NOo,Ynv,1)call zGo(oSx,NOo,Ojx+40.)loop
exitwhen(zHo<1)set Ojx=Ojx+10.set NOo=zCo()call zDo(NOo,YIv,2)call zGo(oSx,NOo,Ojx)set NOo=zCo()call zDo(NOo,Ydv,1)call zGo(oSx,NOo,Ojx+5.)
set zHo=zHo-1endloopendfunctionfunction zko takes nothing returns nothinglocal integer oSx=zAo(t1v)local real Ojx=.0local integer zHo=7local integer NOoset JSv[(oSx)]=(hEv)
set NOo=zCo()call zDo(NOo,Ynv,1)call zGo(oSx,NOo,Ojx+30.)loop
exitwhen(zHo<1)set Ojx=Ojx+10.set NOo=zCo()call zDo(NOo,YDv,2)call zDo(NOo,Ydv,1)call zGo(oSx,NOo,Ojx)set zHo=zHo-1endloopendfunctionfunction zKo takes nothing returns nothinglocal integer oSx=zAo(t2v)local real Ojx=.0local integer zHo=7local integer NOoset JSv[(oSx)]=(gKv)
loop
exitwhen(zHo<1)set Ojx=Ojx+10.set NOo=zCo()call zDo(NOo,YOv,2)call zGo(oSx,NOo,Ojx)set zHo=zHo-1endloopendfunctionfunction zlo takes nothing returns nothinglocal integer oSx=zAo(t3v)local real Ojx=.0local integer zHo=7local integer NOoset JSv[(oSx)]=(hav)
loop
exitwhen(zHo<1)set Ojx=Ojx+12.set NOo=zCo()call zDo(NOo,Ybv,2)call zDo(NOo,Ycv,2)call zGo(oSx,NOo,Ojx)set zHo=zHo-1endloopendfunctionfunction zLo takes nothing returns nothinglocal integer oSx=zAo(t1v)local real Ojx=.0local integer zHo=7local integer NOoset JSv[(oSx)]=(Ggv)
set NOo=zCo()call zDo(NOo,Ynv,1)call zGo(oSx,NOo,Ojx+30.)loop
exitwhen(zHo<1)set Ojx=Ojx+10.set NOo=zCo()call zDo(NOo,YAv,4)call zGo(oSx,NOo,Ojx)set zHo=zHo-1endloopset Ojx=.0set zHo=2loop
exitwhen(zHo<1)set Ojx=Ojx+25.set NOo=zCo()call zDo(NOo,YNv,2)call zGo(oSx,NOo,Ojx)set zHo=zHo-1endloopendfunctionfunction zmo takes nothing returns nothinglocal integer oSx=zAo(t5v)local real Ojx=.0local integer zHo=7local integer NOoset JSv[(oSx)]=(hVv)
loop
exitwhen(zHo<1)set Ojx=Ojx+10.set NOo=zCo()call zDo(NOo,Ycv,2)call zDo(NOo,YBv,1)call zGo(oSx,NOo,Ojx)set zHo=zHo-1endloopendfunctionfunction zMo takes nothing returns nothinglocal integer oSx=zAo(t6v)local integer NOo=zCo()call zDo(NOo,YVv,1)call zGo(oSx,NOo,.0)
endfunctionfunction zpo takes nothing returns nothinglocal integer oSx=zAo(Trv)local real Ojx=10.local integer zHo=7local integer NOoloop
exitwhen(zHo<1)set Ojx=Ojx+10.set NOo=zCo()call zDo(NOo,Yxv,2)call zDo(NOo,Yvv,1)call zGo(oSx,NOo,Ojx)set zHo=zHo-1endloopset NOo=zCo()call zDo(NOo,Yrv,1)call zGo(oSx,NOo,30.)set WMv[(oSx)]=((300.)*1.)endfunctionfunction zPo takes nothing returns nothingcall zho()call zjo()call zJo()call zko()call zKo()call zlo()call zLo()call zmo()call zMo()call zpo()endfunctionfunction zqo takes nothing returns booleanset Eb=Jbx("Spawn_Init: set Spawn.ALL_GROUP = UnitList.Create()")set WCv=Xdx("Spawn_Init: set Spawn.CLEAR_CHAT_EVENT = Event.Create(User.CHAT_EVENT_TYPE, EventPriority.MISC, function Spawn.Event_ClearChat)",KA,lI,function yLo)set Wdv=Xdx("Spawn_Init: set Spawn.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.MISC, function Spawn.Event_Destroy)",EP,lI,function yMo)set Rw=(E3x())set WFv=iXx()call Dcx(Xdx("Spawn_Init: call Event.Create(Act.ENDING_EVENT_TYPE, EventPriority.MISC, function Spawn.Event_ActEnding).AddToStatics()",jPv,lI,function yPo))
call Dcx(Xdx("Spawn_Init: call Event.Create(EventType.START, EventPriority.MISC, function Spawn.Event_Start).AddToStatics()",EE,lI,function YOo))call Dcx(Xdx("Spawn_Init: call Event.Create(Meteorite.GAME_OVER_EVENT_TYPE, EventPriority.MISC, function Spawn.Event_GameOver).AddToStatics()",Jtv,lI,function YNo))
set WLv=Yco(WFv)
call Xyx(zA,"-clear wave",WCv)set yev=iXx()call YUo()call Y1o()call zEo()call zPo()return trueendfunctionfunction zQo takes nothing returns booleancall kSo(function zqo,"Spawn_Init")return trueendfunctionfunction zso takes nothing returns booleanset Y_v=VXx(Y0v)
return trueendfunctionfunction zSo takes nothing returns booleanset Y1v=VXx(Y2v)
return trueendfunctionfunction zto takes nothing returns booleanset Y3v=VXx(Y4v)
return trueendfunctionfunction zTo takes nothing returns booleanset Y5v=VXx(Y6v)
return trueendfunctionfunction zuo takes nothing returns booleanset Y7v=VXx(Y8v)
return trueendfunctionfunction zUo takes nothing returns booleanset Y9v=VXx(zvv)
return trueendfunctionfunction zwo takes nothing returns booleanset zev=VXx(zxv)
return trueendfunctionfunction zWo takes nothing returns booleanset y5v=VXx(y_v)
return trueendfunctionfunction zyo takes nothing returns booleanset zov=VXx(zrv)
return trueendfunctionfunction zYo takes integer a,integer b returns integerif(a-a/ b*b>0)thenreturn(a/ b+1)endifreturn(a/ b)
endfunctionfunction zzo takes string UDo,string oux returns integer
local integer o7x=(s6o(X0))set UDo=iSx(UDo,"ffffcc00")set B2=B2+1call pCx(X0,o7x,O0,UDo)call pCx(X0,o7x,I0,oux)set E0[B2]=o7xset D2[o7x]=B2set R0[B2]=UDoset A0[B2]=ouxreturn o7xendfunctionfunction zZo takes integer bIx returns integerlocal integer oSx=bIxset o0[oSx]=falseset f2[oSx]=-1set x0[oSx]=bIxset c2[oSx]=Fset N0[oSx]=Fcall sPo((X0),(bIx))
call P_x(oSx,40)
return oSxendfunctionfunction z_o takes nothing returns booleanlocal integer rFx=(bv)call zZo((ZA[(rFx)]))return trueendfunctionfunction z0o takes nothing returns nothinglocal integer oSx=((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetLocalPlayer())))))),((((R)))))))if not o0[oSx]thenreturnendifcall P_x(oSx,f2[oSx])endfunctionfunction z1o takes nothing returns booleanlocal integer rFx=(bv)set X0=s5o()
set O0=Svo(X0)set I0=Svo(X0)set F2=zYo(gE,30)-1set C2=zzo("Page","")set g2=(MZ[(X0)])+2call Pzx(X0,O0,.2)call Pzx(X0,I0,.05)call s7o((X0),("StructInfo"))call Dcx(Xdx("StructInfo_Event_Start: call Event.Create(AfterIntro.FOR_PLAYER_EVENT_TYPE, EventPriority.MISC, function StructInfo.Event_AfterIntro).AddToStatics()",jCv,lI,function z_o))set ziv=iXx()call iDx(ziv,1.,true,function z0o)return trueendfunctionfunction z2o takes nothing returns booleancall Dcx(Xdx("StructInfo_Init: call Event.Create(EventType.START, EventPriority.MISC, function StructInfo.Event_Start).AddToStatics()",EE,lI,function z1o))return trueendfunctionfunction z3o takes nothing returns booleancall k1o(function z2o,"StructInfo_Init")
return trueendfunctionfunction z4o takes nothing returns booleanset zav=hjo('uTav')call hJo(((zav)),ASv,(Igv))set Uj[(zav)]=((2)*1.)set NOv[(zav)]=(('x')*1.)set NWv[(zav)]=((60)*1.)
set I8v[(zav)]=((0)*1.)set Anv[(zav)]=(3)set Nmv[(zav)]=((150000.)*1.)set NLv[(zav)]=((150000.)*1.)set NKv[(zav)]=((0)*1.)set Ncv[(zav)]=((500)*1.)set Nbv[(zav)]=((500)*1.)set Auv[(zav)]=((0)*1.)set AUv[(zav)]=((0)*1.)set AYv[(zav)]=(0)set A_v[(zav)]=(0)call hpo((zav),(gtv),1)return trueendfunctionfunction z5o takes nothing returns booleancall VNx(sa,(function z4o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Tavern.page\\Tavern.struct\\obj_shop_wc3unit.j"))return trueendfunctionfunction z6o takes nothing returns booleanset znv=VXx(zVv)
return trueendfunctionfunction z7o takes nothing returns booleanset zEv=Wwx('BTrR',"Tropical Rainbow",'bTrR')set aav[(zEv)]=(true)set uU[(zEv)]=(true)
set anv[(zEv)]=("ReplaceableTextures\\CommandButtons\\BTNSnazzyPotion.blp")call lWx(zEv,"Abilities\\Spells\\Orc\\EtherealForm\\SpiritWalkerChange.mdl","head",ri)set WU=l_x()
call l2x(WU,dHv,.2)call l2x(WU,Xdv,.5)call l2x(WU,EGv,.5)call l2x(WU,iw,.2)call l2x(WU,Ehv,.2)call l0x(((WU)),fc,(rzo(db,0,-$80,-64,0)))call l3x(((zEv)),ZB+(1),(WU))return trueendfunctionfunction z8o takes nothing returns booleanset zXv=L6o('ITrR')call L7o(((zXv)),tS,(bS))set sS[(zXv)]=(1)set LIv[(zXv)]=("ReplaceableTextures\\CommandButtons\\BTNSnazzyPotion.blp")call L9o((zXv),(zOv),1)return trueendfunctionfunction z9o takes nothing returns booleancall L1x('ATrR',false)set zOv=L0o('ATrR')set K6[(zOv)]=(h6)set m6[(zOv)]=(1)set TH[(zOv)]=("Tropical Rainbow")set Rh[(zOv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Aj))))))set oxv[(zOv)]=(0)set x3v[(zOv)]=("spell")
call L1o((zOv),GH+(1),((60)*1.))
call L1o((zOv),Lov+(1),((750)*1.))return trueendfunctionfunction Zvo takes nothing returns booleancall VNx(ma,(function z7o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Tavern.page\\Tavern.struct\\TropicalRainbow.page\\TropicalRainbow.struct\\obj_dummyBuff_wc3buff.j"))
call VNx(Qa,(function z8o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Tavern.page\\Tavern.struct\\TropicalRainbow.page\\TropicalRainbow.struct\\obj_thisItem_wc3item.j"))call VNx(Pa,(function z9o),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Tavern.page\\Tavern.struct\\TropicalRainbow.page\\TropicalRainbow.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Zeo takes nothing returns booleanset zRv=VXx(zIv)
return trueendfunctionfunction Zxo takes nothing returns booleanlocal integer rFx=(bv)call Nbx(((Vv[(rFx)])),(zEv),((Mv[(rFx)])),w,((zAv)*1.))
return trueendfunctionfunction Zoo takes nothing returns booleancall mro(zOv,Xdx("TropicalRainbow_Init: call TropicalRainbow.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TropicalRainbow.Event_SpellEffect))",ih,MI,function Zxo))return trueendfunctionfunction Zro takes nothing returns booleancall Pso(function Zoo,"TropicalRainbow_Init")return trueendfunctionfunction Zio takes nothing returns booleanset zNv=L6o('IToA')call L7o(((zNv)),tS,(bS))return trueendfunctionfunction Zao takes nothing returns booleancall VNx(Qa,(function Zio),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Tomes.page\\Tomes.struct\\Agi\\obj_thisItem_wc3item.j"))
return trueendfunctionfunction Zno takes nothing returns booleanset zbv=VXx(zBv)
return trueendfunctionfunction ZVo takes nothing returns booleanset zcv=L6o('IToI')call L7o(((zcv)),tS,(bS))return trueendfunctionfunction ZEo takes nothing returns booleancall VNx(Qa,(function ZVo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Tomes.page\\Tomes.struct\\Int\\obj_thisItem_wc3item.j"))
return trueendfunctionfunction ZXo takes nothing returns booleanset zCv=VXx(zdv)
return trueendfunctionfunction ZOo takes nothing returns booleanset zDv=L6o('IToS')call L7o(((zDv)),tS,(bS))return trueendfunctionfunction ZRo takes nothing returns booleancall VNx(Qa,(function ZOo),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Tomes.page\\Tomes.struct\\Str\\obj_thisItem_wc3item.j"))
return trueendfunctionfunction ZIo takes nothing returns booleanset zfv=VXx(zFv)
return trueendfunctionfunction ZAo takes nothing returns booleanset zgv=VXx(zGv)
return trueendfunctionfunction ZNo takes nothing returns booleanlocal integer rFx=(bv)local integer Zbo=(Nv)local integer OSx=(Vv[(rFx)])local integer oSx=Fqx(Zbo,zhv)local integer Cgx=oSxcall kGx(CreateItem(Hh[(Cgx)],(((GetUnitX(C[((OSx))])))*1.),(((GetUnitY(C[((OSx))])))*1.)))return trueendfunctionfunction ZBo takes integer oSx returns booleanif((zHv[((oSx))])>0)then
return false
endifset yov=yov+1set yxv[yov]=oSx
set zHv[oSx]=yov+1return(yov==0)endfunctionfunction Zco takes integer Cgx,code XCx returns nothinglocal integer oSx=Cgxlocal integer Zbo=Xdx("Tomes_Create: local Event dropEvent = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function Tomes.Event_Drop)",VP,lI,function ZNo)set yrv[oSx]=P2o(Zbo,null,null,w)call pZx(Zbo,zhv,oSx)call pEo(Cgx,Xdx("Tomes_Create: call whichItem.Event.Add(Event.Create(UNIT.Items.Events.Use.DUMMY_EVENT_TYPE, EventPriority.MISC, action))",Sh,lI,XCx))call ZBo(oSx)endfunctionfunction ZCo takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call Ryx((ACx((OSx),(zjv),(zJv),(ri))))call Bix(OSx,1)return trueendfunctionfunction Zdo takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call Ryx((ACx((OSx),(zkv),(zKv),(ri))))call B_x(OSx,1)return trueendfunctionfunction ZDo takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])call Ryx((ACx((OSx),(zlv),(zLv),(ri))))call c7x(OSx,1)return trueendfunctionfunction Zfo takes nothing returns booleancall Zco(zNv,function ZCo)call Zco(zcv,function Zdo)call Zco(zDv,function ZDo)return trueendfunctionfunction ZFo takes nothing returns booleancall kzo(function Zfo,"Tomes_Init")return trueendfunctionfunction Zgo takes nothing returns booleanset zmv=VXx(zMv)
return trueendfunctionfunction ZGo takes nothing returns booleanlocal integer rFx=(bv)local integer Zho=X7x((0))local integer rNxlocal integer OSxlocal integer oSxif(Zho==w)thenreturn trueendifset rNx=(Bbv[(rFx)])
set OSx=(Vv[(rFx)])call X1x(Zho,(GetUnitX(C[((OSx))]))+pvo(OSx,true),(GetUnitY(C[((OSx))]))+peo(OSx,true),fYx(OSx)+Opx(OSx,true))call X3x(Zho)call X9x(Zho,i1x((GetObjectName(Ikv[(rNx)])),"ff77ffff","ff00bfff"),rb*1.15)
set oSx=OSxset zPv[oSx]=Zho
call Avx(OSx,zqv)return trueendfunctionfunction ZHo takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])local integer oSx=OSxlocal integer Zho=zPv[oSx]call RPx(OSx,zqv)call Odx(Zho)return trueendfunctionfunction Zjo takes nothing returns booleanset zpv=Xdx("UnitNameTag_Init: set UnitNameTag.CREATE_EVENT = Event.Create(Unit.CREATE_EVENT_TYPE, EventPriority.MISC, function UnitNameTag.Event_Create)",IJv,lI,function ZGo)set zqv=Xdx("UnitNameTag_Init: set UnitNameTag.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.MISC, function UnitNameTag.Event_Destroy)",EP,lI,function ZHo)call teo((L1v),zpv)call teo((snv),zpv)call teo((uNv),zpv)call teo((qKv),zpv)call teo((zav),zpv)return trueendfunctionfunction ZJo takes nothing returns booleancall kzo(function Zjo,"UnitNameTag_Init")return trueendfunctionfunction Zko takes nothing returns booleanset zQv=VXx(zsv)
return trueendfunctionfunction ZKo takes nothing returns booleanlocal integer rFx=(bv)if iOx((ZA[(rFx)]))thenset ztv=(zH[(rFx)])endifreturn trueendfunctionfunction Zlo takes nothing returns booleanlocal integer rFx=(bv)call sPo((zTv),((ZA[(rFx)])))return trueendfunctionfunction ZLo takes integer oSx,integer XYx returns nothingif Dpo((oSx),cRv+XYx,1)thencall N7o(oSx,XYx,false)endifendfunctionfunction Zmo takes integer oSx,integer XYx returns nothingif Aex((oSx),cRv+XYx,1)thenif rUx((oSx),cOv,XYx)thencall Avx((oSx),cXv)endifcall Avx((oSx),XYx)endifendfunctionfunction ZMo takes real a,real b,real c returns real
if(b==0)then
return c
endifreturn(a*1./ b)endfunctionfunction Zpo takes integer oDx,integer OSx returns nothinglocal integer tQo=(HQv[(oDx)]-1)
if(zuv[oDx]!=w)thencall ZLo(OSx,zSv)endifif iOx(oDx)thenset ztv=wendifset zuv[tQo]=OSx
if(OSx==w)thenreturnendifcall Zmo(OSx,zSv)set zUv=ZMo((oG[(OSx)]),(rG[(OSx)]),.0)set zwv=ZMo((lF[(OSx)]),(LF[(OSx)]),.0)set zWv=ZMo((Nuv[(OSx)]),(NTv[(OSx)]),.0)endfunctionfunction ZPo takes nothing returns booleanlocal integer rFx=(bv)local integer oDx=(ZA[(rFx)])local integer OSx=(Vv[(rFx)])if(O1x(OSx,oDx)==0)thenset OSx=(kv[(oDx)])if(OSx!=w)thenif I9x(OSx,Qc)thenset OSx=(pzv[(osx((OSx),p3v))])endifcall Zpo(oDx,OSx)endifelse
call Zpo(oDx,O7x(OSx,oDx,q))
endifreturn trueendfunctionfunction Zqo takes real ZQo,real Zso,integer pSx returns stringlocal string Koo
local string o7x
if(Zso<0)thenset Koo="ffff0000"elseif(Zso>0)thenset Koo="ff00ff00"else
set Koo=null
endifif(pSx==0)thenset o7x=(I2S(((R2I(((((ZQo)*1.))*1.))))))else
set o7x=psx(ZQo,pSx)
endifreturn iSx(o7x,Koo)endfunctionfunction ZSo takes integer OSx returns nothingcall pCx(zTv,zyv,zYv,"Armor: ")call pCx(zTv,zyv,zzv,Zqo((I5v[(OSx)]),(I6v[(OSx)]),1))endfunctionfunction Zto takes integer OSx returns nothingcall pCx(zTv,zZv,zYv,"Attack speed: ")call pCx(zTv,zZv,zzv,Zqo((Uf[(OSx)]),(wf[(OSx)]),3))
endfunctionfunction ZTo takes integer OSx,integer lCo returns nothinglocal real Zso=(lg[(OSx)])call pCx(zTv,z_v,zYv,"Damage: ")
call pCx(zTv,z_v,zzv,Zqo((Kg[(OSx)])+(AYv[(lCo)]),Zso,0)+" - "+Zqo((Kg[(OSx)])+(AYv[(lCo)])*(A_v[(lCo)]),Zso,0))
endfunctionfunction Zuo takes boolean iTx,string oqx,string ZUo returns stringif iTx thenreturn oqxendifreturn ZUoendfunctionfunction Zwo takes integer OSx returns nothinglocal real ZWo=(rG[(OSx)])local real ouxlocal real I7olocal integer Zyoif(ZWo<1.)thenset ZWo=1.endifset oux=(oG[(OSx)])set I7o=oux*1./ ZWoset I7o=zUv+(I7o-zUv)*z0vset zUv=I7oset Zyo=(R2I(((I7o*30)*1.)))
call pCx(zTv,z1v,zYv,iSx(ppx("l",Zyo),Zuo(I7o>.5,iYx(2.-2.*I7o,1.,.0,1.),iYx(1.,I7o*2.,.0,1.)))+iSx(ppx("l",30-Zyo),"ff000000"))
call pCx(zTv,z1v,zzv,(I2S(((R2I(((((oux)*1.))*1.))))))+"/"+(I2S(((R2I(((((ZWo)*1.))*1.)))))))endfunctionfunction ZYo takes integer OSx returns nothingcall pCx(zTv,z2v,zYv,"Life reg.: ")call pCx(zTv,z2v,zzv,Zqo((Wg[(OSx)]),(HG[(OSx)]),2))
endfunctionfunction Zzo takes integer OSx returns nothinglocal real ZWo=(LF[(OSx)])local real ouxlocal real I7olocal integer Zyoif(ZWo<1.)thenset ZWo=1.endifset oux=(lF[(OSx)])set I7o=oux*1./ ZWoset I7o=zwv+(I7o-zwv)*z0vset zwv=I7oset Zyo=(R2I(((I7o*40)*1.)))
call pCx(zTv,z3v,zYv,iSx(ppx("l",Zyo),iYx(iAx(I7o,.5),.0,iAx(I7o,.5),1.))+iSx(ppx("l",30-Zyo),"ff000000"))call pCx(zTv,z3v,zzv,(I2S(((R2I(((((oux)*1.))*1.))))))+"/"+(I2S(((R2I(((((ZWo)*1.))*1.)))))))endfunctionfunction ZZo takes integer OSx returns nothingcall pCx(zTv,z4v,zYv,"Mana reg.: ")call pCx(zTv,z4v,zzv,Zqo((gF[(OSx)]),(pF[(OSx)]),2))
endfunctionfunction Z_o takes integer OSx returns nothinglocal real oux=(Nqv[(OSx)])local real Z0o=R5o(OSx,oux)local string Z1o=Zqo(oux,(Ntv[(OSx)]),0)
if(Z0o!=oux)then
set Z1o=Z1o+" ("+iSx((I2S(((R2I(((((Z0o)*1.))*1.)))))),"ffffcc00")+")"endifcall pCx(zTv,z5v,zYv,"Move speed: ")
call pCx(zTv,z5v,zzv,Z1o)endfunctionfunction Z2o takes integer OSx returns nothingcall pCx(zTv,z7v,zYv,"Spell power: ")call pCx(zTv,z7v,zzv,Zqo((zF[(OSx)]),(YF[(OSx)]),0))
endfunctionfunction Z3o takes integer OSx returns nothinglocal real ZWo=(NTv[(OSx)])local real ouxlocal real I7olocal integer Zyoif(ZWo<1.)thenset ZWo=1.endifset oux=(Nuv[(OSx)])
set I7o=oux*1./ ZWoset I7o=zWv+(I7o-zWv)*z0vset zWv=I7oset Zyo=(R2I(((I7o*40)*1.)))
call pCx(zTv,z8v,zYv,iSx(ppx("l",Zyo),iYx(iAx(.7,I7o),iAx(.7,I7o),.0,1.))+iSx(ppx("l",30-Zyo),"ff000000"))call pCx(zTv,z8v,zzv,(I2S(((R2I(((((oux)*1.))*1.))))))+"/"+(I2S(((R2I(((((ZWo)*1.))*1.)))))))endfunctionfunction Z4o takes integer OSx returns nothingcall pCx(zTv,z9v,zYv,"Stamina reg.: ")call pCx(zTv,z9v,zzv,Zqo((bdv[(OSx)]),(bcv[(OSx)]),2))endfunctionfunction Z5o takes integer oSx returns integerlocal integer oMx=(CIx(((oSx)),vB))local integer o7x=0loop
exitwhen(oMx<q)if not(Ud[((CAx(((oSx)),vB,(oMx))))])thenset o7x=o7x+1endifset oMx=oMx-1endloopreturn o7xendfunctionfunction Z6o takes integer oSx,integer oLx returns integerlocal integer rvx=(CIx(((oSx)),vB))local integer Z7olocal integer mLo=0local integer oMx=qloop
exitwhen(oMx>rvx)set Z7o=(CAx(((oSx)),vB,(oMx)))if not(Ud[(Z7o)])thenset mLo=mLo+1if(mLo==oLx)then
return Z7oendifendifset oMx=oMx+1endloopreturn w
endfunctionfunction Z8o takes integer OSx returns nothinglocal integer rvx=Z5o(OSx)local integer oMx=Zvvlocal integer Iaxloop
exitwhen(oMx<=rvx)call sgo(zTv,Zev,zzv+oMx,null)call PYx(zTv,Zev,zzv,.0)
set oMx=oMx-1endloopset Zvv=rvxcall pCx(zTv,Zev,zYv,"Status: ")
loop
exitwhen(oMx<q)set Iax=Z6o(OSx,oMx)
call sgo(zTv,Zev,zzv+oMx,(anv[(Iax)]))call PYx(zTv,Zev,zzv,.01)set oMx=oMx-1endloopendfunctionfunction Z9o takes nothing returns nothinglocal integer oDx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetLocalPlayer())))))),((((R))))))local integer OSx=zuv[(HQv[(oDx)]-1)]local integer lCo=(Tf[(OSx)])call ZSo(OSx)call Zto(OSx)call ZTo(OSx,lCo)call Zwo(OSx)call ZYo(OSx)call Zzo(OSx)call ZZo(OSx)call Z_o(OSx)call pCx(zTv,z6v,zYv,iSx((GetUnitName(C[(OSx)])),Zuo((IsUnitAlly(C[(OSx)],vx[(oDx)]))and((ze[(OSx)])!=BYv),"ff00ff00",Zuo((IsUnitEnemy(C[(OSx)],vx[(oDx)])),"ffff0000","ffffcc00"))))call Z2o(OSx)call Z3o(OSx)call Z4o(OSx)call Z8o(OSx)endfunctionfunction vvr takes nothing returns booleanlocal integer rFx=(bv)local integer oDx=(ZA[(rFx)])local integer OSx=(Vv[(rFx)])call Zpo(oDx,OSx)if iOx(oDx)thencall Z9o()endifreturn trueendfunctionfunction ver takes nothing returns nothingcall Z9o()endfunctionfunction vxr takes nothing returns booleanlocal integer rFx=(bv)set zSv=Xdx("UnitStatus_Event_Start: set UnitStatus.ACQUIRE_EVENT = Event.Create(UNIT.Attack.Events.ACQUIRE_EVENT_TYPE, EventPriority.MISC, function UnitStatus.Event_TargetInRange)",Ew,lI,function ZKo)set zTv=s5o()call Dcx(Xdx("UnitStatus_Event_Start: call Event.Create(HeroSelection.DUMMY_EVENT_TYPE, EventPriority.MISC, function UnitStatus.Event_HeroPick).AddToStatics()",Jwv,lI,function Zlo))call Dcx(Xdx("UnitStatus_Event_Start: call Event.Create(UNIT.Selection.ENDING_EVENT_TYPE, EventPriority.MISC, function UnitStatus.Event_Deselect).AddToStatics()",C0v,lI,function ZPo))call Dcx(Xdx("UnitStatus_Event_Start: call Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.MISC, function UnitStatus.Event_Select).AddToStatics()",C3v,lI,function vvr))
set zYv=Svo(zTv)
set zzv=Svo(zTv)
set z6v=(s6o(zTv))call s6o(zTv)set z1v=(s6o(zTv))set z2v=(s6o(zTv))set z3v=(s6o(zTv))set z4v=(s6o(zTv))set z8v=(s6o(zTv))set z9v=(s6o(zTv))call s6o(zTv)set z_v=(s6o(zTv))set z7v=(s6o(zTv))set zyv=(s6o(zTv))set zZv=(s6o(zTv))set z5v=(s6o(zTv))call s6o(zTv)set Zev=(s6o(zTv))call Pzx(zTv,zYv,.1)
call Pzx(zTv,zzv,.1)
call s7o((zTv),("Unit Status"))call PYx(zTv,z1v,zYv,.12)call PYx(zTv,z1v,zzv,.08)call PYx(zTv,z3v,zYv,.12)call PYx(zTv,z3v,zzv,.08)call PYx(zTv,z6v,zYv,.2)
call PYx(zTv,z6v,zzv,.0)
call PYx(zTv,z8v,zYv,.12)call PYx(zTv,z8v,zzv,.08)call PYx(zTv,Zev,zzv,.01)call iDx(iXx(),.125,true,function ver)return trueendfunctionfunction vor takes nothing returns booleancall Dcx(Xdx("UnitStatus_Init: call Event.Create(EventType.START, EventPriority.MISC, function UnitStatus.Event_Start).AddToStatics()",EE,lI,function vxr))return trueendfunctionfunction vrr takes nothing returns booleancall k1o(function vor,"UnitStatus_Init")
return trueendfunctionfunction vir takes nothing returns booleanset Zxv=Wwx('BViR',"Victory Rush",'bViR')set uU[(Zxv)]=(true)
set anv[(Zxv)]=("ReplaceableTextures\\CommandButtons\\BTNBattleRoar.blp")call lWx(Zxv,"Abilities\\Spells\\NightElf\\BattleRoar\\RoarTarget.mdl","overhead",ri)set WU=l_x()
call l2x(WU,nnv,.3)call l2x(WU,iw,.2)call l3x(((Zxv)),ZB+(1),(WU))return trueendfunctionfunction var takes nothing returns booleancall VNx(ma,(function vir),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\VictoryRush.page\\VictoryRush.struct\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction vnr takes nothing returns booleanset Zov=VXx(Zrv)
return trueendfunctionfunction vVr takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=(Vv[(rFx)])local real x=(GetUnitX(C[((OSx))]))local real y=(GetUnitY(C[((OSx))]))local integer Iixcall mho((mko(((x)*1.),((y)*1.),(Zav),(ri))))call NVo(Znv,x,y,ZVv,ZEv)set Iix=NEo(Znv)
if(Iix!=w)thenloop
call Nbx((Iix),(Zxv),(1),w,((ZXv)*1.))set Iix=NEo(Znv)
exitwhen(Iix==w)
endloopendifset Me[(pe)]=(((Me[(pe)])+.01)*1.)call ipx(Ge,iSx("Notification:","ffffcc00")+" A defender died: Spawns have now "+(I2S(((R2I((((((Me[(pe)])*100.)*1.))*1.))))))+"%"+" life.",10.)
return trueendfunctionfunction vEr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif not(IsUnitAlly(C[(Iix)],vx[(Hzv)]))thenreturn false
endifreturn truereturn trueendfunctionfunction vXr takes nothing returns booleanset Ziv=Xdx("VictoryRush_Init: set VictoryRush.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function VictoryRush.Event_Death)",VP,lI,function vVr)
set Znv=O5x()set ZEv=Xpx(function vEr)return trueendfunctionfunction vOr takes nothing returns booleancall k1o(function vXr,"VictoryRush_Init")return trueendfunctionfunction vRr takes integer oSx,integer otx,integer oux returns booleanreturn((LoadInteger(o[((D[((ec[(oSx)]))]))],((((xc[((oSx))])))),(oTx(((otx)),(((oux)))))))!=0)endfunctionfunction vIr takes integer oSx,integer otx,boolean oux returns nothingcall SaveBoolean(o[((V[(E[((ec[(oSx)]))])]))],((((xc[((oSx))])))),(((otx))),(((oux))))endfunctionfunction vAr takes integer oSx,integer Ibx,boolean o5x returns nothingif vRr((oSx),oc,Ibx)then
call o_x("FolderUnitModSet_StructBoolMods_Add","call DebugEx(FolderUnitModSet_StructBoolMods.NAME + \": \"+I2S(this) + \" already has \" + state.GetName())",fvv+": "+I2S(oSx)+" already has "+(Blv[(Ibx)]))
returnendifcall l0x((oSx),oc,Ibx)call vIr((oSx),ac+Ibx,o5x)endfunctionfunction vNr takes nothing returns booleanset ZOv=ltx(ZRv+" (dummyBuff)")set Pc[(ZOv)]=(true)
call lWx(ZOv,"Abilities\\Spells\\Human\\ManaShield\\ManaShieldCaster.mdl","origin",ri)set WU=l_x()
call l2x(WU,Xdv,4)call l2x(WU,iw,.5)call vAr(WU,dsv,true)call l3x(((ZOv)),ZB+(1),(WU))return trueendfunctionfunction vbr takes nothing returns booleancall VNx(ma,(function vNr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Waypoint.page\\Waypoint.struct\\RegionCheck\\Retreat\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction vBr takes nothing returns booleanset ZIv=VXx(ZRv)
return trueendfunctionfunction vcr takes nothing returns booleanset ZAv=VXx(ZNv)
return trueendfunctionfunction vCr takes nothing returns booleancall L1x('Awan',false)return trueendfunctionfunction vdr takes nothing returns booleancall VNx(Pa,(function vCr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Misc\\Waypoint.page\\Waypoint.struct\\Spawns\\obj_wanderSpell_wc3spell.j"))return trueendfunctionfunction vDr takes nothing returns booleanset Zbv=VXx(ZBv)
return trueendfunctionfunction vfr takes nothing returns booleanset Zcv=VXx(ZCv)
return trueendfunctionfunction vFr takes integer oSx returns integerset Zgv[oSx]=trueset ZGv[oSx]=falsecall rEx(Zcv)return oSxendfunctionfunction vgr takes nothing returns integerlocal integer oSxif(Zdv==8190)thencall o_x("Waypoint_Allocation_allocCustom","call DebugEx(Waypoint.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",ZCv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(ZDv[(w)]==w)thenset Zfv=Zfv+1set oSx=Zfvelse
set oSx=ZDv[(w)]
set ZDv[(w)]=ZDv[ZDv[(w)]]endifset ZDv[oSx]=Zset ZFv[oSx]=1call vFr(oSx)return oSxendfunctionfunction vGr takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((sm[(oSx)]))])]))],((((ym[((oSx))])))),(((otx))),(((oux))))endfunctionfunction vhr takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((qVv[(oSx)]))])]))],((((qRv[((oSx))])))),(((otx))),(((oux))))
endfunctionfunction vHr takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((qVv[(oSx)]))])]))],((((qRv[((oSx))])))),(((otx)))))endfunctionfunction vjr takes integer oSx,integer OSx returns nothinglocal integer rLx=oSxif not((Zhv[((OSx))])>0)then
returnendifset oSx=OSxset gw[oSx]=rLxcall LXx(OSx)endfunctionfunction vJr takes nothing returns booleanlocal integer oSx=vHr((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetTriggeringRegion())))))),((((qOv)))))),ymv)call vjr(oSx,Q2x())return trueendfunctionfunction vkr takes integer o0x,integer RLx returns integerlocal integer oSx=vgr()local integer vKr=QAo(o0x)set Hw[(oSx)]=(RLx)set Lw[(oSx)]=(o0x)call vGr(o0x,ymv,oSx)call vhr(vKr,ymv,oSx)call TriggerRegisterEnterRegion(DA[((XJx(function vJr)))],qev[(vKr)],Condition((null)))return oSxendfunctionfunction vlr takes nothing returns booleanlocal integer OSx=Q2x()if((ze[(OSx)])!=Hzv)then
return trueendifcall Dux((OSx),(ZHv),(1),w)return trueendfunctionfunction vLr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxcall AZx(Iix,ZHv)call Nbx(((Iix)),(ZOv),(1),w,((ZJv)*1.))
call LXx(Iix)endfunctionfunction vmr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer iCx=iXx()set Zjv[oSx]=iCx
set ge[(iCx)]=(oSx)call iDx(iCx,3.,false,function vLr)return trueendfunctionfunction vMr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer iCx=Zjv[oSx]call iKx(iCx)return trueendfunctionfunction vpr takes nothing returns nothingendfunctionfunction vPr takes nothing returns nothinglocal integer vqr=QIo()call RegionAddRect(qev[(vqr)],bm[(q2x(No))])
call RegionAddRect(qev[(vqr)],bm[(q2x(bo))])
call RegionAddRect(qev[(vqr)],bm[(q2x(jo))])
call TriggerRegisterLeaveRegion(DA[((XJx(function vlr)))],qev[(vqr)],Condition((null)))set ZHv=ltx(ZNv)
call Lxx(ZHv,Xdx("FolderWaypoint_StructRegionCheck_Init: call FolderWaypoint_StructRegionCheck.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderWaypoint_StructRegionCheck.Event_BuffGain))",bd,lI,function vmr))call Lxx(ZHv,Xdx("FolderWaypoint_StructRegionCheck_Init: call FolderWaypoint_StructRegionCheck.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderWaypoint_StructRegionCheck.Event_BuffLose))",jc,lI,function vMr))set Pc[(ZHv)]=(true)
set yd[(ZHv)]=(true)
call lWx(ZHv,"Abilities\\Spells\\Other\\TalkToMe\\TalkToMe.mdl","overhead",ri)call vpr()endfunctionfunction vQr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])call RPx(Iix,Zkv)call RPx(Iix,ZKv)return trueendfunctionfunction vsr takes nothing returns booleanlocal integer rFx=(bv)call LXx((Vv[(rFx)]))return trueendfunctionfunction vSr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),ZLv)return trueendfunctionfunction vtr takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(ZLv),(1),w)return trueendfunctionfunction vTr takes nothing returns nothinglocal integer oMx=ZMvloop
exitwhen(oMx<0)set Zpv[oMx]=ZPv[oMx]set oMx=oMx-1endloopset Zqv=ZMvendfunctionfunction vur takes nothing returns integerlocal integer o7xif(Zqv<0)thenreturn w
endifset o7x=Zpv[0]set Zpv[0]=Zpv[Zqv]set Zqv=Zqv-1return o7xendfunctionfunction vUr takes nothing returns booleanlocal integer rFx=(bv)local integer oSxlocal integer Iixset Gw=truecall vTr()loop
set oSx=vur()exitwhen(oSx==w)
set Iix=oSxcall AZx(Iix,ZLv)call rtx(Iix,'Awan')
if(I9x(Iix,Qc)==false)thencall SetUnitAnimation(C[((Iix))],("victory"))call QueueUnitAnimation(C[((Iix))],("spell"))endifendloopreturn trueendfunctionfunction vwr takes integer oSx returns booleanif((Zhv[((oSx))])>0)then
return false
endifset ZMv=ZMv+1set ZPv[ZMv]=oSx
set Zhv[oSx]=ZMv+1return(ZMv==0)endfunctionfunction vWr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixset gw[oSx]=wcall Avx(Iix,Zkv)call Avx(Iix,ZKv)if not Gw thencall YSo(Iix,Zlv)endifcall vwr(Iix)return trueendfunctionfunction vyr takes integer oSx returns booleanif(((Zhv[((oSx))])>0)==false)thenreturn false
endifset Zhv[ZPv[ZMv]]=Zhv[oSx]set ZPv[Zhv[oSx]-1]=ZPv[ZMv]
set Zhv[oSx]=0set ZMv=ZMv-1return(ZMv==F)endfunctionfunction vYr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])call BMo(Iix,Zlv)call vyr(Iix)return trueendfunctionfunction vzr takes nothing returns nothingset Zkv=Xdx("FolderWaypoint_StructSpawns_Init: set FolderWaypoint_StructSpawns.DESTROY_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderWaypoint_StructSpawns.Event_Destroy)",VP,lI,function vQr)
set Gw=false
set Zlv=Xdx("FolderWaypoint_StructSpawns_Init: set FolderWaypoint_StructSpawns.IDLE_EVENT = Event.Create(UNIT.Order.Events.Idle.INTERVAL_EVENT_TYPE, EventPriority.MISC, function FolderWaypoint_StructSpawns.Event_Idle)",cWv,lI,function vsr)set ZKv=Xdx("FolderWaypoint_StructSpawns_Init: set FolderWaypoint_StructSpawns.OWNER_CHANGE_EVENT = Event.Create(UNIT.Owner.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderWaypoint_StructSpawns.Event_OwnerChange)",rx,lI,function vSr)set Zmv=Xdx("FolderWaypoint_StructSpawns_Init: set FolderWaypoint_StructSpawns.SPAWN_EVENT = Event.Create(Spawn.DUMMY_EVENT_TYPE, EventPriority.MISC, function FolderWaypoint_StructSpawns.Event_Spawn)",Rw,lI,function vtr)
call Dcx(Xdx("FolderWaypoint_StructSpawns_Init: call Event.Create(Meteorite.GAME_OVER_EVENT_TYPE, EventPriority.MISC, function FolderWaypoint_StructSpawns.Event_GameOver).AddToStatics()",Jtv,lI,function vUr))
call Dcx(Zmv)set ZLv=ltx(ZBv)
call Lxx(ZLv,Xdx("FolderWaypoint_StructSpawns_Init: call FolderWaypoint_StructSpawns.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderWaypoint_StructSpawns.Event_BuffGain))",bd,MI,function vWr))call Lxx(ZLv,Xdx("FolderWaypoint_StructSpawns_Init: call FolderWaypoint_StructSpawns.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderWaypoint_StructSpawns.Event_BuffLose))",jc,MI,function vYr))endfunctionfunction vZr takes nothing returns booleanset hw=vkr(q2x(Px),w)call vkr(q2x(px),hw)
call vkr(q2x(Qx),hw)
call vkr(q2x(sx),hw)
call vPr()call vzr()return trueendfunctionfunction v_r takes nothing returns booleancall WWo(function vZr,"Waypoint_Init")return trueendfunctionfunction v0r takes nothing returns booleanset ZQv=VXx(Zsv)
return trueendfunctionfunction v1r takes integer oSx returns booleanset Zuv=Zuv+1set ZUv[Zuv]=oSx
set Zwv[oSx]=Zuv+1return(Zuv==0)endfunctionfunction v2r takes integer oSx returns nothingset ZZv[oSx]=falsecall rHx(nl)
endfunctionfunction v3r takes integer oSx returns nothingif(ZYv[oSx]>0)thenreturnendifif(Zzv[oSx]!=Z)thencall o_x("FolderCameraField_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderCameraField_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Vl+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Zzv[oSx]=Zzv[(w)]set Zzv[(w)]=oSx
call v2r(oSx)endfunctionfunction v4r takes integer oSx returns nothingset ZYv[oSx]=ZYv[oSx]-1call v3r(oSx)endfunctionfunction v5r takes integer oSx returns booleanlocal integer oLx=(Z_v[(oSx)])set Z_v[Z0v[Z1v]]=oLxset Z0v[oLx-1]=Z0v[Z1v]set Z_v[oSx]=0set Z1v=Z1v-1return(Z1v==F)endfunctionfunction v6r takes integer oSx,integer iCx,integer rLx,integer oDx returns nothingcall v4r((oSx))call iKx(iCx)if v5r(oSx)thencall ikx(ll)
endifcall hjx(oDx,Zyv+rLx)endfunctionfunction v7r takes integer oSx returns integerset ZZv[oSx]=trueset Z5v[oSx]=falsecall rEx(nl)
return oSxendfunctionfunction v8r takes nothing returns integerlocal integer oSxif(Z3v==8190)thencall o_x("FolderCameraField_StructTimed_Allocation_allocCustom","call DebugEx(FolderCameraField_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Vl+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(Zzv[(w)]==w)thenset Z4v=Z4v+1set oSx=Z4velse
set oSx=Zzv[(w)]
set Zzv[(w)]=Zzv[Zzv[(w)]]endifset Zzv[oSx]=Zset ZYv[oSx]=1call v7r(oSx)return oSxendfunctionfunction v9r takes integer oSx returns booleanset Z1v=Z1v+1set Z0v[Z1v]=oSx
set Z_v[oSx]=Z1v+1return(Z1v==0)endfunctionfunction evr takes integer oSx,integer oDx,real oux returns nothingif iOx(oDx)thenset vee[oSx]=oux
call SetCameraField(sl[oSx],oux,.0)endifendfunctionfunction eer takes nothing returns nothinglocal integer oMx=Z1vlocal integer oSxlocal integer rLxlocal real exrlocal real aCxloop
set oSx=Z0v[oMx]
set rLx=Z6v[oSx]
set exr=Z7v[oSx]
set aCx=(vee[(rLx)])
set Z7v[oSx]=exr-1call evr(rLx,vve[oSx],aCx+(Z9v[oSx]-aCx)*1./ exr)set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction eor takes nothing returns nothinglocal integer iCx=iGx()local integer oSx=(ge[(iCx)])local integer rLx=Z6v[oSx]local real oux=Z9v[oSx]local integer oDx=vve[oSx]call v6r(oSx,iCx,rLx,oDx)call evr(rLx,oDx,oux)endfunctionfunction err takes integer oSx,integer oDx,real oux,real iMx returns nothing
local integer rLx=oSxlocal integer iCxset oSx=hhx(oDx,Zyv+rLx)
if(oSx!=w)thencall v6r(oSx,Z2v[oSx],rLx,oDx)endifset oSx=v8r()set iCx=iXx()set Z2v[oSx]=iCx
set Z6v[oSx]=rLx
set Z7v[oSx]=iMx*1./ Z8v
set Z9v[oSx]=oux
set vve[oSx]=oDx
set ge[(iCx)]=(oSx)call hlx(oDx,Zyv+rLx,oSx)if v9r(oSx)thencall iDx(ll,Z8v,true,function eer)endifcall iDx(iCx,iMx,false,function eor)
endfunctionfunction eir takes nothing returns nothinglocal real ear=(GetCameraTargetPositionX())local real enr=(GetCameraTargetPositionY())local integer oMx=Zuvlocal integer oSxlocal integer SHolocal real eVrloop
set oSx=ZUv[oMx]
set SHo=oSxset eVr=Y0set Ztv[oSx]=ear
set ZTv[oSx]=enr
call err(ul,SHo,eVr,1.)set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction eEr takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=(ZA[(rFx)])set Ztv[oSx]=(GetCameraTargetPositionX())set ZTv[oSx]=(GetCameraTargetPositionY())if v1r(oSx)thencall iDx(ZSv,ZWv,true,function eir)endifreturn trueendfunctionfunction eXr takes nothing returns booleanset ZSv=iXx()call Dcx(Xdx("Zoom_Init: call Event.Create(AfterIntro.FOR_PLAYER_EVENT_TYPE, EventPriority.MISC, function Zoom.Event_AfterIntro).AddToStatics()",jCv,lI,function eEr))return trueendfunctionfunction eOr takes nothing returns booleancall k1o(function eXr,"Zoom_Init")return trueendfunctionfunction eRr takes nothing returns booleanset vxe=VXx(voe)
return trueendfunctionfunction eIr takes code c,string rSx returns nothing
set In=In+1set An[In]=CreateTrigger()set Nn[In]=(GetHandleId(Condition((c))))
set bn[In]=rSxcall TriggerAddCondition(An[In],Condition(c))endfunctionfunction eAr takes integer oSx,integer XYx returns nothingif not((LoadInteger(o[((D[((BBv[oSx]))]))],((((kw[((oSx))])))),(oTx((((oA[(XYx)]))),(((XYx)))))))!=0)thencall o_x("FolderUnitType_StructEvent_Remove","call DebugEx(\"subject \"+I2S(UnitType(this).Id.Get()) + \" has not \" + whichEvent.GetName())","subject "+I2S((kw[((oSx))]))+" has not "+(jA[(XYx)]))
returnendifcall rrx(BBv[oSx],(kw[((oSx))]),(oA[(XYx)]),XYx)
endfunctionfunction eNr takes integer ebr,string icx,real iMx returns nothingcall ipx(Ge,"ffffcc00"+(GetUnitName(C[(ebr)]))+": "+"|r"+icx,iMx)call PingMinimap(((((Dsx(ebr))*1.))*1.),((((Dtx(ebr))*1.))*1.),((((1.)*1.))*1.))
call AddIndicator(C[(ebr)],($FF),($FF),($FF),($FF))endfunctionfunction eBr takes nothing returns booleanlocal integer rFx=(bv)local integer ecr=(Vv[(rFx)])call eAr(vie,vre)call eNr(ecr,"Let's have some fun, everyone!",2.)call TriggerSleepAction(((2.)*1.))call eNr(ecr,"Loot the castle!",1.)return trueendfunctionfunction eCr takes nothing returns booleanset vre=Xdx("AxeFighter_Init: set AxeFighter.ACQUIRES_TARGET_EVENT = Event.Create(UNIT.Attack.Events.DUMMY_EVENT_TYPE, EventPriority.SPEECHES, function AxeFighter.Event_AcquiresTarget)",duv,mI,function eBr)set vie=G3vcall teo(vie,vre)return trueendfunctionfunction edr takes nothing returns booleancall eIr(function eCr,"AxeFighter_Init")
return trueendfunctionfunction eDr takes nothing returns booleanset vae=VXx(vne)
return trueendfunctionfunction efr takes nothing returns booleanlocal integer rFx=(bv)local integer ecr=(Vv[(rFx)])call eAr(vEe,vVe)call eNr(ecr,"Crawl before me, little worms!",2.)call TriggerSleepAction(((1.)*1.))call eNr(ecr,"I challenge you!",.75)
call TriggerSleepAction(((1.)*1.))call eNr(ecr,"Only the winner shall be the one to survive.",3.)return trueendfunctionfunction eFr takes nothing returns booleanset vVe=Xdx("Balduir_Init: set Balduir.ACQUIRES_TARGET_EVENT = Event.Create(UNIT.Attack.Events.DUMMY_EVENT_TYPE, EventPriority.SPEECHES, function Balduir.Event_AcquiresTarget)",duv,mI,function efr)set vEe=GSvcall teo(vEe,vVe)return trueendfunctionfunction egr takes nothing returns booleancall eIr(function eFr,"Balduir_Init")return trueendfunctionfunction eGr takes nothing returns booleanset vXe=VXx(vOe)
return trueendfunctionfunction ehr takes nothing returns booleanset vRe=VXx(vIe)
return trueendfunctionfunction eHr takes nothing returns booleanset vAe=VXx(vNe)
return trueendfunctionfunction ejr takes nothing returns booleanset vbe=VXx(vBe)
return trueendfunctionfunction eJr takes nothing returns booleanset vce=VXx(vCe)
return trueendfunctionfunction ekr takes nothing returns booleanset vde=VXx(vDe)
return trueendfunctionfunction eKr takes nothing returns booleanset vfe=VXx(vFe)
return trueendfunctionfunction elr takes nothing returns booleanset vge=VXx(vGe)
return trueendfunctionfunction eLr takes code c,string rSx returns nothing
set Bn=Bn+1set cn[Bn]=CreateTrigger()set Cn[Bn]=(GetHandleId(Condition((c))))
set dn[Bn]=rSxcall TriggerAddCondition(cn[Bn],Condition(c))endfunctionfunction emr takes integer oSx returns booleanreturn( not(O6v[(vke[oSx])]))endfunctionfunction eMr takes integer oSx returns booleanif((vKe[((oSx))])>0)then
return false
endifset vle=vle+1set vLe[vle]=oSx
set vKe[oSx]=vle+1return(vle==0)endfunctionfunction epr takes nothing returns nothinglocal integer oMx=vleloop
exitwhen(oMx<0)set vMe[oMx]=vLe[oMx]set oMx=oMx-1endloopset vpe=vleendfunctionfunction ePr takes nothing returns integerlocal integer o7xif(vpe<0)thenreturn w
endifset o7x=vMe[0]set vMe[0]=vMe[vpe]set vpe=vpe-1return o7xendfunctionfunction eqr takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((vte[oSx]))])]))],((((vse[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))endfunctionfunction eQr takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((vte[oSx]))])]))],((((vse[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))endfunctionfunction esr takes integer oSx,integer Iix returns nothinglocal integer rLx=oSxlocal integer rFx=rRx((vse[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset vSe[(rFx)]=(rLx)
set Vv[(rFx)]=(Iix)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=eqr(rLx,vTe,rbx)
loop
exitwhen(rMx<q)call rfx(eQr(rLx,vTe,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction eSr takes integer oSx,integer Iix returns nothinglocal integer rLx=oSxcall esr(oSx,Iix)endfunctionfunction etr takes integer oSx,integer o5x returns nothinglocal integer nyxloop
set nyx=NEo(o5x)
exitwhen(nyx==w)
call dQx(oSx,nyx)endloopendfunctionfunction eTr takes integer oSx,integer Iix returns nothinglocal integer rLx=oSxlocal integer rFx=rRx((vse[(rLx)]))local integer oMxlocal integer rbxlocal integer rMxset vSe[(rFx)]=(rLx)
set Vv[(rFx)]=(Iix)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=eqr(rLx,vue,rbx)
loop
exitwhen(rMx<q)call rfx(eQr(rLx,vue,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction eur takes integer oSx,integer Iix returns nothinglocal integer rLx=oSxcall eTr(oSx,Iix)endfunctionfunction eUr takes integer oSx returns nothinglocal integer Cqx=(vke[(oSx)])local integer svo=(vPe[(oSx)])local real x=(GetUnitX(C[((Cqx))]))local real y=(GetUnitY(C[((Cqx))]))local integer Iixset hf=(ze[(Cqx)])call NVo(vhe,x,y,(vqe[(oSx)]),(vQe[(oSx)]))call GroupRemoveUnit(kb[(vhe)],C[(Cqx)])
set Iix=(OUx((svo),Ob))if(Iix!=w)thenloop
if LLo(vhe,Iix)thencall IRo(svo,Iix)call GroupRemoveUnit(kb[(vhe)],C[(Iix)])
call GroupAddUnit(kb[(vHe)],C[(Iix)])else
call IRo(svo,Iix)call eSr(oSx,Iix)endifset Iix=(OUx((svo),Ob))exitwhen(Iix==w)
endloopcall etr(svo,vHe)endifset Iix=NEo(vhe)
if(Iix!=w)thenloop
call dQx(svo,Iix)call eur(oSx,Iix)set Iix=NEo(vhe)
exitwhen(Iix==w)
endloopendifendfunctionfunction ewr takes nothing returns nothinglocal integer oSxcall epr()loop
set oSx=ePr()exitwhen(oSx==w)
call eUr(oSx)endloopendfunctionfunction eWr takes integer oSx returns nothingif not emr(oSx)thenreturnendifif eMr(oSx)thencall iDx(vme,.75,true,function ewr)endifendfunctionfunction eyr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oMx=CIx(Cqx,vJe)local integer oSxloop
set oSx=CAx(Cqx,vJe,oMx)
call eWr(oSx)set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction eYr takes integer oSx returns booleanif(((vKe[((oSx))])>0)==false)thenreturn false
endifset vKe[vLe[vle]]=vKe[oSx]set vLe[vKe[oSx]-1]=vLe[vle]
set vKe[oSx]=0set vle=vle-1return(vle==F)endfunctionfunction ezr takes integer oSx returns nothinglocal integer svo=(vPe[(oSx)])local integer Iixloop
set Iix=(dpx((svo),Ob))exitwhen(Iix==w)
call eSr(oSx,Iix)endloopendfunctionfunction eZr takes integer oSx returns nothingif eYr(oSx)thencall ikx(vme)endifcall ezr(oSx)endfunctionfunction e_r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oMx=CIx(Cqx,vJe)local integer oSxloop
set oSx=CAx(Cqx,vJe,oMx)
call eZr(oSx)set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction e0r takes nothing returns nothingset vTe=(E3x())set vue=(E3x())endfunctionfunction e1r takes nothing returns booleanset vhe=O5x()set vHe=O5x()set vje=Xdx("Aura_Init: set Aura.TRANSPORT_ENDING_EVENT = Event.Create(UNIT.Transport.ENDING_EVENT_TYPE, EventPriority.SPELLS, function Aura.Event_TransportEnding)",O8v,MI,function eyr)set vUe=Xdx("Aura_Init: set Aura.TRANSPORT_START_EVENT = Event.Create(UNIT.Transport.START_EVENT_TYPE, EventPriority.SPELLS, function Aura.Event_TransportStart)",O7v,MI,function e_r)set vme=iXx()call e0r()return trueendfunctionfunction e2r takes nothing returns booleancall eLr(function e1r,"Aura_Init")return trueendfunctionfunction e3r takes nothing returns booleanset vwe=VXx(vWe)
return trueendfunctionfunction e4r takes code c,string rSx returns nothing
set SV=SV+1set tV[SV]=CreateTrigger()set TV[SV]=(GetHandleId(Condition((c))))
set uV[SV]=rSxcall TriggerAddCondition(tV[SV],Condition(c))endfunctionfunction e5r takes integer oSx returns integerset v_e[oSx]=trueset v0e[oSx]=falseset NK[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])call rEx(iq)
return oSxendfunctionfunction e6r takes nothing returns integerlocal integer oSxif(vye==8190)thencall o_x("EventCombination_Allocation_allocCustom","call DebugEx(EventCombination.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",aq+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(vYe[(w)]==w)thenset vze=vze+1set oSx=vzeelse
set oSx=vYe[(w)]
set vYe[(w)]=vYe[vYe[(w)]]endifset vYe[oSx]=Zset vZe[oSx]=1call e5r(oSx)return oSxendfunctionfunction e7r takes integer oSx returns nothingset bK[(oSx)]=(v2e+oSx)endfunctionfunction e8r takes code XCx returns integerlocal integer oSx=e6r()set v1e[oSx]=wcall e7r(oSx)set v3e[(oSx)]=Xkx((XCx))set v1e[(oSx)]=(w)return oSxendfunctionfunction e9r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=Flx((av[(rFx)]))if((Hsv[((ze[(Cqx)]))])!=Hxv)thenreturn false
endifreturn truereturn trueendfunctionfunction xvr takes integer oSx,integer oLx returns realreturn CQx(oSx,GH+oLx)endfunctionfunction xer takes integer XYx,integer rIx returns booleanif(A0o(XYx,rIx)==false)thencall DBx((XYx),(rIx),false==(false))
call DBx(((Fqx((XYx),v4e))),(rIx),false==(true))
return trueendifreturn false
endfunctionfunction xxr takes integer oSx,integer rIx returns integerreturn(LoadInteger(o[((V[(E[((X))])]))],(((rIx))),(((v5e+oSx)))))endfunctionfunction xor takes integer oSx,integer rIx,integer oux returns nothingcall SaveInteger(o[((V[(E[((X))])]))],(((rIx))),(((v5e+oSx))),(((oux))))
endfunctionfunction xrr takes integer oSx,integer rIx returns booleanlocal integer oux=xxr(oSx,rIx)+1
call xor(oSx,rIx,oux)return(oux==1)endfunctionfunction xir takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((NK[(oSx)]))])]))],((((bK[((oSx))])))),(((otx))))))endfunctionfunction xar takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((NK[(oSx)]))])]))],((((bK[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction xnr takes integer oSx,integer otx,integer oux returns booleanreturn rrx(v8e[(oSx)],(v9e[((oSx))]),otx,oux)endfunctionfunction xVr takes integer oSx,integer p3x,integer oux returns booleanreturn xnr(p3x,eve,oux)endfunctionfunction xEr takes integer oSx,integer rIx returns nothinglocal integer oMx=(xir(((oSx)),v7e))
local integer p3xloop
exitwhen(oMx<q)set p3x=(xar(((oSx)),v7e,(oMx)))
if xVr((w),p3x,rIx)thencall PauseTimer(eee[(p3x)])endifset oMx=oMx-1endloopendfunctionfunction xXr takes nothing returns booleanlocal integer rFx=(bv)local integer rIx=(av[(rFx)])local integer XYx=(Nv)local integer rLx=(Fqx((XYx),CK))if xer(XYx,rIx)thenif xrr(rLx,rIx)thencall xEr(rLx,rIx)endifendifreturn trueendfunctionfunction xOr takes integer oSx,integer rIx returns booleanlocal integer oux=xxr(oSx,rIx)-1
call xor(oSx,rIx,oux)return(oux==0)endfunctionfunction xRr takes integer oSx,integer otx,integer oux returns booleanreturn rux(v8e[(oSx)],(v9e[((oSx))]),otx,oux)endfunctionfunction xIr takes integer oSx,integer p3x,integer oux returns booleanreturn xRr(p3x,eve,oux)endfunctionfunction xAr takes integer oSx returns nothingcall TimerStart(eee[oSx],exe[oSx],eoe[oSx],null)
endfunctionfunction xNr takes integer oSx returns nothingcall xAr(oSx)endfunctionfunction xbr takes integer oSx,integer rIx returns nothinglocal integer oMx=(xir(((oSx)),v7e))
local integer p3xloop
exitwhen(oMx<q)set p3x=(xar(((oSx)),v7e,(oMx)))
if xIr((w),p3x,rIx)thencall xNr(p3x)endifset oMx=oMx-1endloopendfunctionfunction xBr takes integer oSx,integer fromWhichEvent returns nothingset AK=(oSx)
if rBx(v1e[oSx])then
call rDx(v3e[oSx])endifendfunctionfunction xcr takes nothing returns booleanlocal integer rFx=(bv)local integer rIx=(av[(rFx)])local integer XYx=(Nv)local integer rLx=(Fqx((XYx),CK))if xer(XYx,rIx)thenif xOr(rLx,rIx)thencall xbr(rLx,rIx)if((xir(((rLx)),v7e))>0)then
call xBr(rLx,XYx)endifendifendifreturn trueendfunctionfunction xCr takes integer oSx returns integerset eVe[oSx]=trueset eEe[oSx]=falsecall rEx(LP)
return oSxendfunctionfunction xdr takes nothing returns integerlocal integer oSxif(ere==8190)thencall o_x("EventPair_Allocation_allocCustom","call DebugEx(EventPair.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",mP+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(eie[(w)]==w)thenset eae=eae+1set oSx=eaeelse
set oSx=eie[(w)]
set eie[(w)]=eie[eie[(w)]]endifset eie[oSx]=Zset ene[oSx]=1call xCr(oSx)return oSxendfunctionfunction xDr takes integer oSx,integer oux returns nothinglocal integer xfr=(eOe[(oSx)])set eXe[oSx]=oux
if(xfr!=w)thencall pZx(xfr,v4e,oux)call pZx(oux,v4e,xfr)endifendfunctionfunction xFr takes integer oSx,integer oux returns nothinglocal integer xgr=(eXe[(oSx)])set eOe[oSx]=oux
if(xgr!=w)thencall pZx(xgr,v4e,oux)call pZx(oux,v4e,xgr)endifendfunctionfunction xGr takes integer xgr,integer xfr,integer xhr returns integerlocal integer oSx=xdr()set eXe[oSx]=wset eOe[oSx]=wcall xDr(oSx,xgr)call xFr(oSx,xfr)set eRe[(oSx)]=(xhr)
return oSxendfunctionfunction xHr takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((v8e[(oSx)]))])]))],((((v9e[((oSx))])))),(((otx))))))endfunctionfunction xjr takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((v8e[(oSx)]))])]))],((((v9e[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction xJr takes integer oSx,integer otx,integer oux returns booleanreturn rux(NK[(oSx)],(bK[((oSx))]),otx,oux)endfunctionfunction xkr takes integer oSx,integer oux returns nothingcall pZx((eXe[(oux)]),CK,oSx)call pZx((eOe[(oux)]),CK,oSx)endfunctionfunction xKr takes integer oSx,integer xlr returns nothinglocal integer xgr=(eXe[(xlr)])local integer xfr=(eOe[(xlr)])local integer xhr=(eRe[(xlr)])local integer oMx=(xir((((oSx))),v7e))local integer rIxlocal integer p3xlocal integer rMxlocal boolean xLrloop
exitwhen(oMx<q)set p3x=(xar((((oSx))),v7e,(oMx)))set rMx=(xHr((p3x),eve))
loop
exitwhen(rMx<q)set rIx=(xjr((p3x),eve,(rMx)))set av[((bv))]=(rIx)
set AK=(oSx)
if not rBx(xhr)thencall xVr(eIe,p3x,rIx)endifset rMx=rMx-1endloopcall PauseTimer(eee[(p3x)])set oMx=oMx-1endloopcall xJr((oSx),eNe,xlr)set oMx=(xir((((oSx))),ebe))
loop
exitwhen(oMx<q)set rIx=(xar((((oSx))),ebe,(oMx)))set av[((bv))]=(rIx)
set AK=(oSx)
set xLr=rBx(xhr)
call DBx((xgr),(rIx),false==(xLr))call DBx((xfr),(rIx),false==(not xLr))set oMx=oMx-1endloopcall xkr((oSx),xlr)endfunctionfunction xmr takes integer oSx,integer xMr,integer xpr,integer xPr,integer xqr,integer xhr returns integerlocal integer xgr=Xdx("FolderEventCombination_StructPairs_Create: local Event negativeEvent = Event.Create(negativeType, EventPriority.COMBINATION, function FolderEventCombination_StructPairs.Event_Negative)",xPr,hI,function xXr)local integer xfr=Xdx("FolderEventCombination_StructPairs_Create: local Event positiveEvent = Event.Create(positiveType, EventPriority.COMBINATION, function FolderEventCombination_StructPairs.Event_Positive)",xMr,hI,function xcr)local integer o7x=xGr(xgr,xfr,xhr)set cv[(xgr)]=(xqr)set cv[(xfr)]=(xpr)call xKr(oSx,o7x)return o7xendfunctionfunction xQr takes integer oSx,integer oux,limitop BXx returns nothingset EA[oSx]=true
set XA[oSx]=ouxset OA[oSx]=BXxendfunctionfunction xsr takes limitop oqx returns limitopif(oqx==LESS_THAN)thenreturn GREATER_THAN_OR_EQUAL
endifif(oqx==LESS_THAN_OR_EQUAL)thenreturn GREATER_THANendifif(oqx==EQUAL)thenreturn NOT_EQUAL
endifif(oqx==NOT_EQUAL)thenreturn EQUAL
endifif(oqx==GREATER_THAN)thenreturn LESS_THAN_OR_EQUALendifif(oqx==GREATER_THAN_OR_EQUAL)thenreturn LESS_THAN
endifreturn nullendfunctionfunction xSr takes integer oSx,integer rNx,integer oux,limitop BXx,integer xhr returns integerlocal integer xgr=Xdx("FolderEventCombination_StructPairs_CreateLimit: local Event negativeEvent = Event.Create(whichType, EventPriority.COMBINATION, function FolderEventCombination_StructPairs.Event_Negative)",rNx,hI,function xXr)local integer xfr=Xdx("FolderEventCombination_StructPairs_CreateLimit: local Event positiveEvent = Event.Create(whichType, EventPriority.COMBINATION, function FolderEventCombination_StructPairs.Event_Positive)",rNx,hI,function xcr)local integer o7x=xGr(xgr,xfr,xhr)call xQr(xgr,oux,xsr(BXx))call xQr(xfr,oux,BXx)call xKr(oSx,o7x)return o7xendfunctionfunction xtr takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((NK[(oSx)]))])]))],((((bK[((oSx))])))),(((otx))),(((oux))))endfunctionfunction xTr takes integer oSx returns integerreturn xir((oSx),eNe)endfunctionfunction xur takes integer oSx,integer oLx returns integerreturn xar((oSx),eNe,oLx)endfunctionfunction xUr takes integer XYx,integer rIx,boolean iTx returns nothingcall DBx(XYx,rIx,false==iTx)
endfunctionfunction xwr takes integer oSx,integer rIx returns nothinglocal integer rvx=0local integer oMx=xTr((oSx))
local boolean xLrlocal integer xlrloop
exitwhen(oMx<q)set xlr=xur((oSx),oMx)set av[((bv))]=(rIx)
set AK=(oSx)
set xLr=rBx((eRe[(xlr)]))call xUr((eXe[(xlr)]),rIx,xLr)call xUr((eOe[(xlr)]),rIx,not xLr)if not xLr thenset rvx=rvx+1endifset oMx=oMx-1endloopcall xJr((oSx),ebe,rIx)if(rvx==0)thencall xbr((oSx),rIx)endifcall xor((oSx),rIx,rvx)endfunctionfunction xWr takes integer oSx,integer FPx returns nothinglocal integer oMx=(xir(((FPx)),eCe))
local integer xyrloop
exitwhen(oMx<q)call Avx((oSx),(xar(((FPx)),eCe,(oMx))))
set oMx=oMx-1endloopset oMx=(xir(((FPx)),eNe))loop
exitwhen(oMx<q)set xyr=(xar(((FPx)),eNe,(oMx)))
call Avx((oSx),(eXe[(xyr)]))
call Avx((oSx),(eOe[(xyr)]))
set oMx=oMx-1endloopcall xwr(FPx,(A[((oSx))]))endfunctionfunction xYr takes nothing returns booleanlocal integer rFx=(bv)local integer FPx=FLx((nv[(rFx)]),ece)call xWr((Vv[(rFx)]),FPx)return trueendfunctionfunction xzr takes integer oSx,integer otx returns nothingcall SaveBoolean(o[(((V[(E[((xA[(oSx)]))])])))],(((((aA[((oSx))]))))),((((otx)))),(false))endfunctionfunction xZr takes integer oSx,integer otx,integer oux returns booleanreturn rrx(NK[(oSx)],(bK[((oSx))]),otx,oux)endfunctionfunction x_r takes integer oSx,integer rIx returns nothingcall SaveInteger(o[(((V[(E[((X))])])))],((((rIx)))),((((v5e+oSx)))),(0))
endfunctionfunction x0r takes integer oSx,integer rIx returns nothinglocal integer oMx=xTr((oSx))
local integer xlrloop
exitwhen(oMx<q)set xlr=xur((oSx),oMx)call xzr((eXe[(xlr)]),rIx)call xzr((eOe[(xlr)]),rIx)set oMx=oMx-1endloopcall xZr((oSx),ebe,rIx)if(xxr((oSx),rIx)==0)thencall xEr((oSx),rIx)endifcall x_r((oSx),rIx)endfunctionfunction x1r takes integer oSx,integer FPx returns nothinglocal integer oMx=(xir(((FPx)),eCe))
local integer xyrloop
exitwhen(oMx<q)call RPx((oSx),(xar(((FPx)),eCe,(oMx))))
set oMx=oMx-1endloopset oMx=(xir(((FPx)),eNe))loop
exitwhen(oMx<q)set xyr=(xar(((FPx)),eNe,(oMx)))
call RPx((oSx),(eXe[(xyr)]))
call RPx((oSx),(eOe[(xyr)]))
set oMx=oMx-1endloopcall x0r(FPx,(A[((oSx))]))endfunctionfunction x2r takes nothing returns booleanlocal integer rFx=(bv)local integer FPx=FLx((nv[(rFx)]),ece)call x1r((Vv[(rFx)]),FPx)return trueendfunctionfunction x3r takes integer rlx,code XCx returns integerlocal integer FPx=e8r(XCx)set v1e[(FPx)]=(Xpx(function e9r))if(xvr(rlx,1)>.0)thencall xmr(FPx,QH,LU,sH,mU,kU)
endifif(Ftx(rlx,1)>.0)thencall xSr(FPx,mF,(R2I(((Ftx(rlx,1))*1.))),GREATER_THAN_OR_EQUAL,MU)endifcall xtr(FPx,lU,rlx)
call Cwx(rlx,ece,FPx)call mro(rlx,Xdx("AICastSpell_CreateBasics: call whichSpell.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.AI, function AICastSpell.Event_Learn))",pv,HI,function xYr))call mro(rlx,Xdx("AICastSpell_CreateBasics: call whichSpell.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.AI, function AICastSpell.Event_Unlearn))",Av,HI,function x2r))return FPxendfunctionfunction x4r takes nothing returns booleanlocal integer rFx=(bv)call Rxx(((LoadInteger(o[((V[(E[((X))])]))],(((RK+(((av[(rFx)])))))),(((IK)))))),(Rh[((ede))]))return trueendfunctionfunction x5r takes nothing returns booleanlocal integer rFx=(bv)local integer XYx=(Nv)local integer rLx=(Fqx((XYx),CK))if(xxr(rLx,(av[(rFx)]))==0)thencall xBr(rLx,XYx)endifreturn trueendfunctionfunction x6r takes integer oSx,integer rNx,integer rbx,integer x7r returns integerlocal integer o7x=Xdx("FolderEventCombination_StructEvents_Create: local Event result = Event.Create(whichType, priority, function FolderEventCombination_StructEvents.Event_Passive)",rNx,rbx,function x5r)
call pZx(o7x,CK,oSx)
call xJr((oSx),eCe,o7x)set cv[(o7x)]=(x7r)return o7xendfunctionfunction x8r takes nothing returns booleanlocal integer FPx=x3r(ede,function x4r)call x6r(FPx,dTv,HI,w)return trueendfunctionfunction x9r takes nothing returns booleancall e4r(function x8r,"AIBoost_Init")return trueendfunctionfunction ovr takes nothing returns booleanset eDe=Wwx('BBoo',"Boost",'bBoo')set aav[(eDe)]=(true)set uU[(eDe)]=(true)
set anv[(eDe)]=("ReplaceableTextures\\CommandButtons\\BTNEtherealFormOn.blp")call lWx(eDe,"Boost_page\\Boost_struct\\Buff.mdx","foot",ri)
set WU=l_x()
call l2x(WU,dmv,$96)
call l2x(WU,BFv,'d')
call l3x(((eDe)),ZB+(1),(WU))return trueendfunctionfunction oer takes nothing returns booleancall L1x('ABoo',false)set ede=L0o('ABoo')set K6[(ede)]=(H6)set m6[(ede)]=(1)set TH[(ede)]=("Boost")set Rh[(ede)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Aj))))))set oxv[(ede)]=(0)set x3v[(ede)]=("spell")
call L1o((ede),GH+(1),((20)*1.))
call L1o((ede),tH+(1),((18)*1.))
call L1o((ede),Lov+(1),((750)*1.))set MOv[(ede)]=("ReplaceableTextures\\CommandButtons\\BTNEtherealFormOn.blp")return trueendfunctionfunction oxr takes nothing returns booleancall VNx(ma,(function ovr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Boost.page\\Boost.struct\\obj_dummyBuff_wc3buff.j"))
call VNx(Pa,(function oer),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Boost.page\\Boost.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction oor takes nothing returns booleanset efe=VXx(eFe)
return trueendfunctionfunction orr takes code c,string rSx returns nothing
set Gn=Gn+1set hn[Gn]=CreateTrigger()set Hn[Gn]=(GetHandleId(Condition((c))))
set jn[Gn]=rSxcall TriggerAddCondition(hn[Gn],Condition(c))endfunctionfunction oir takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(Mv[(rFx)])call Nbx(((Vv[(rFx)])),(eDe),(rYx),w,((ege)*1.))
return trueendfunctionfunction oar takes nothing returns booleancall mro(ede,Xdx("Boost_Init: call Boost.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Boost.Event_SpellEffect))",ih,MI,function oir))
return trueendfunctionfunction onr takes nothing returns booleancall orr(function oar,"Boost_Init")return trueendfunctionfunction oVr takes nothing returns booleanset eGe=VXx(ehe)
return trueendfunctionfunction oEr takes integer oSx returns integerreturn adx(FirstOfGroup(kb[oSx]))endfunctionfunction oXr takes integer oSx returns integerlocal integer XLo=oEr((oSx))
local integer oMxlocal integer oOrlocal integer o7xif(XLo==w)thenreturn w
endifset oMx=1set oOr=(GetRandomInt((1),(NIo((oSx)))))
loop
exitwhen(oMx==oOr)set oMx=oMx+1set XLo=NEo((oSx))call GroupAddUnit(kb[(YQ)],C[(XLo)])
endloopset o7x=oEr((oSx))call NXo((oSx),YQ)return o7xendfunctionfunction oRr takes integer oSx returns integerreturn oXr(oSx)endfunctionfunction oIr takes real x,real y,real Jex,integer Q7x returns integercall NVo((bQ),x,y,Jex,Q7x)return oRr(bQ)endfunctionfunction oAr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(LoadInteger(o[((V[(E[((X))])]))],(((RK+(((av[(rFx)])))))),(((IK)))))local integer Iixif I9x(Cqx,Qc)thenreturn trueendifset hf=(ze[(Cqx)])set Iix=oIr((GetUnitX(C[((Cqx))])),(GetUnitY(C[((Cqx))])),500.,eHe)if(Iix==w)thenreturn trueendifcall Lox((Cqx),(Rh[((gMv))]),(Iix))return trueendfunctionfunction oNr takes nothing returns booleanlocal integer Iix=jhx()if(osx((((Iix))),(Wb+(eje)))>0)thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif not(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction obr takes integer oSx returns integerset eLe[oSx]=trueset eme[oSx]=falseset v8e[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])call rEx(vJv)return oSxendfunctionfunction oBr takes nothing returns integerlocal integer oSxif(eJe==8190)thencall o_x("TriggerTimer_Allocation_allocCustom","call DebugEx(TriggerTimer.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",vkv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(eke[(w)]==w)thenset eKe=eKe+1set oSx=eKeelse
set oSx=eke[(w)]
set eke[(w)]=eke[eke[(w)]]endifset eke[oSx]=Zset ele[oSx]=1call obr(oSx)return oSxendfunctionfunction ocr takes integer oSx returns nothingset v9e[(oSx)]=(eqe+oSx)
endfunctionfunction oCr takes nothing returns integerlocal integer oSx=oBr()local timer oqx=CreateTimer()set eee[oSx]=oqx
call SaveInteger(o[((V[(E[(((X)))])]))],(((GetHandleId((oqx))))),((((epe)))),((((oSx)))))set oqx=null
call ocr(oSx)return oSxendfunctionfunction odr takes integer oSx,integer rcx returns nothingcall TriggerRegisterTimerExpireEvent(DA[rcx],eee[oSx])endfunctionfunction oDr takes nothing returns integerreturn(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId(((GetExpiredTimer()))))),((((epe))))))endfunctionfunction ofr takes nothing returns booleanlocal integer p3x=oDr()local integer oMx=(xHr((p3x),eve))local integer oSx=(eQe[(p3x)])loop
set av[((bv))]=((xjr((p3x),eve,(oMx))))call xBr((oSx),w)set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction oFr takes integer oSx,real p1x returns nothinglocal integer p3x=oCr()local integer oMx=(xHr((p3x),eve))local integer rIxcall odr(p3x,XJx(function ofr))set eQe[(p3x)]=(oSx)
set eoe[(p3x)]=(true)set exe[(p3x)]=((p1x)*1.)loop
exitwhen(oMx<q)set rIx=(xjr((p3x),eve,(oMx)))if(xxr((oSx),rIx)>0)then
if xIr((w),p3x,rIx)thencall xAr(p3x)endifendifset oMx=oMx-1endloopcall xJr((oSx),v7e,p3x)endfunctionfunction ogr takes nothing returns booleanlocal integer FPx=x3r(gMv,function oAr)set eHe=Xpx(function oNr)call oFr(FPx,1.)
return trueendfunctionfunction oGr takes nothing returns booleancall e4r(function ogr,"AIBurningSpirit_Init")return trueendfunctionfunction ohr takes nothing returns booleanset eje=Wwx('BBuS',"Burning Spirit",'bBuS')set aav[(eje)]=(true)set uU[(eje)]=(true)
set anv[(eje)]=("ReplaceableTextures\\CommandButtons\\BTNIncinerate.blp")call lWx(eje,"Abilities\\Spells\\Orc\\Bloodlust\\BloodlustSpecial.mdl","hand left",ri)call lWx(eje,"Abilities\\Spells\\Orc\\Bloodlust\\BloodlustSpecial.mdl","hand right",Bi)set WU=l_x()
call l2x(WU,nnv,.6)call l2x(WU,BFv,25)call l2x(WU,iw,.6)call l3x(((eje)),ZB+(1),(WU))return trueendfunctionfunction oHr takes nothing returns booleancall L1x('ABuT',false)set gMv=L0o('ABuT')set K6[(gMv)]=(H6)set m6[(gMv)]=(1)set TH[(gMv)]=("Burning Spirit")
set Rh[(gMv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0085)))),(((Aj))))))set oxv[(gMv)]=(4)set x3v[(gMv)]=("spell")
call L1o((gMv),GH+(1),(($A)*1.))
call L1o((gMv),tH+(1),((50)*1.))
call L1o((gMv),Lov+(1),((750)*1.))set MOv[(gMv)]=("ReplaceableTextures\\CommandButtons\\BTNIncinerate.blp")return trueendfunctionfunction ojr takes nothing returns booleancall VNx(ma,(function ohr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\BurningSpirit.page\\BurningSpirit.struct\\obj_dummyBuff_wc3buff.j"))
call VNx(Pa,(function oHr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\BurningSpirit.page\\BurningSpirit.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction oJr takes nothing returns booleanset ese=VXx(eSe)
return trueendfunctionfunction okr takes nothing returns booleanset ete=VXx(eTe)
return trueendfunctionfunction oKr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(LoadInteger(o[((V[(E[((X))])]))],(((RK+(((av[(rFx)])))))),(((IK)))))local integer Iixif I9x(Cqx,Qc)thenreturn trueendifset hf=(ze[(Cqx)])set Iix=oIr((GetUnitX(C[((Cqx))])),(GetUnitY(C[((Cqx))])),500.,eue)if(Iix==w)thenreturn trueendifcall Lox((Cqx),(Rh[((Sjv))]),(Iix))return trueendfunctionfunction olr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction oLr takes nothing returns booleanlocal integer FPx=x3r(Sjv,function oKr)set eue=Xpx(function olr)call x6r(FPx,dTv,HI,w)return trueendfunctionfunction omr takes nothing returns booleancall e4r(function oLr,"AIChaosBall_Init")return trueendfunctionfunction oMr takes nothing returns booleancall L1x('AKao',false)set Sjv=L0o('AKao')set K6[(Sjv)]=(H6)set m6[(Sjv)]=(1)set TH[(Sjv)]=("Chaos Ball")
set Rh[(Sjv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00FE)))),(((Aj))))))set oxv[(Sjv)]=(4)set x3v[(Sjv)]=("spell")
call L1o((Sjv),Uvv+(1),(('d')*1.))call L1o((Sjv),dH+(1),((.75)*1.))call L1o((Sjv),GH+(1),((20)*1.))
call L1o((Sjv),tH+(1),(('d')*1.))call L1o((Sjv),Lov+(1),((700)*1.))set MOv[(Sjv)]=("ReplaceableTextures\\CommandButtons\\BTNOrbOfDeath.blp")return trueendfunctionfunction opr takes nothing returns booleanset eUe=ltx(ewe+" (poisonBuff)")
set Pc[(eUe)]=(true)
set uU[(eUe)]=(true)
return trueendfunctionfunction oPr takes nothing returns booleancall VNx(Pa,(function oMr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\ChaosBall.page\\ChaosBall.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function opr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\ChaosBall.page\\ChaosBall.struct\\obj_poisonBuff_wc3buff.j"))return trueendfunctionfunction oqr takes nothing returns booleanset eWe=VXx(ewe)
return trueendfunctionfunction oQr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction osr takes integer oSx returns integerset eze[oSx]=trueset eZe[oSx]=falsecall rEx(eWe)return oSxendfunctionfunction oSr takes integer oSx,real oux returns nothingcall mCx(oSx,(qy[(oSx)])+oux)endfunctionfunction otr takes integer oSx returns integerset e9e[oSx]=trueset xve[oSx]=falsecall rEx(gW)
return oSxendfunctionfunction oTr takes nothing returns integerlocal integer oSxif(e5e==8190)thencall o_x("FolderDummyUnit_FolderScale_StructTimed_Allocation_allocCustom","call DebugEx(FolderDummyUnit_FolderScale_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",GW+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(e6e[(w)]==w)thenset e7e=e7e+1set oSx=e7eelse
set oSx=e6e[(w)]
set e6e[(w)]=e6e[e6e[(w)]]endifset e6e[oSx]=Zset e8e[oSx]=1call otr(oSx)return oSxendfunctionfunction our takes integer oSx returns booleanset xae=xae+1set xne[xae]=oSx
set xVe[oSx]=xae+1return(xae==0)endfunctionfunction oUr takes nothing returns nothinglocal integer oMx=xaelocal integer oSxloop
set oSx=xne[oMx]
call oSr(xoe[oSx],xee[oSx])set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction owr takes integer oSx returns nothingset e9e[oSx]=falsecall rHx(gW)
endfunctionfunction oWr takes integer oSx returns nothingif(e8e[oSx]>0)thenreturnendifif(e6e[oSx]!=Z)thencall o_x("FolderDummyUnit_FolderScale_StructTimed_Allocation_deallocCustom_confirm","call DebugEx(FolderDummyUnit_FolderScale_StructTimed.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",GW+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset e6e[oSx]=e6e[(w)]set e6e[(w)]=oSx
call owr(oSx)endfunctionfunction oyr takes integer oSx returns nothingset e8e[oSx]=e8e[oSx]-1call oWr(oSx)endfunctionfunction oYr takes integer oSx returns booleanlocal integer oLx=(xVe[(oSx)])set xVe[xne[xae]]=oLxset xne[oLx-1]=xne[xae]set xVe[oSx]=0set xae=xae-1return(xae==F)endfunctionfunction ozr takes integer oSx,integer iCx,integer rLx returns nothingcall oyr((oSx))call iKx(iCx)call HOx(rLx,xie,oSx)if oYr(oSx)thencall ikx(Ny)
endifendfunctionfunction oZr takes nothing returns nothinglocal integer iCx=iGx()local integer oSx=(ge[(iCx)])call ozr(oSx,iCx,xoe[oSx])endfunctionfunction o_r takes integer oSx,real fvx,real iMx returns nothing
local integer rLx=oSxlocal integer fexlocal integer iCxif(iMx==.0)thencall oSr((oSx),fvx)returnendifset fex=(R2I(((iMx*1./ e4e)*1.)))set oSx=oTr()set iCx=iXx()set xee[oSx]=fvx*1./ fex
set xxe[oSx]=iCx
set xoe[oSx]=rLx
set ge[(iCx)]=(oSx)call Qso(rLx,xie,oSx)if our(oSx)thencall iDx(Ny,e4e,true,function oUr)endifcall iDx(iCx,iMx,false,function oZr)
endfunctionfunction o0r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real iMx=(CQx((Sjv),dH+(rYx)))
local integer Mho=Moo()local integer oSx=osr(Mho)local integer HAxset e_e[oSx]=Mho
set e0e[oSx]=rYx
set e1e[oSx]=(zH[(rFx)])
call rwx(Cqx,e2e,oSx)set HAx=Mno(Mho,'qCha',1.)call Meo(Mho,e3e*1./ iMx)call pxo(Mho,Cqx)call M6o(Mho,Cqx,.0,.0,e3e,null)
call o_r(HAx,1.,iMx)
return trueendfunctionfunction o1r takes integer oSx returns nothingset eze[oSx]=falsecall rHx(eWe)endfunctionfunction o2r takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local real x=(mHv[(Mho)])local real y=(mjv[(Mho)])local integer Cqx=xXe[oSx]local integer rYx=e0e[oSx]local integer Iixlocal real Nbolocal real o3rlocal real o4rlocal real iMxcall o1r(oSx)call MFo(Mho)call mho((mko(((x)*1.),((y)*1.),(xOe),(Bi))))set hf=(ze[(Cqx)])call NVo(eye,x,y,(CQx((Sjv),Uvv+(rYx))),eYe)
set Iix=NEo(eye)
if(Iix!=w)thenset Nbo=xReset o3r=xIeset o4r=xAeloop
if I9x(Iix,Wd)thenset iMx=o3relse
set iMx=o4rendifcall Nbx((Iix),(eUe),(rYx),w,((iMx)*1.))
call nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))set Iix=NEo(eye)
exitwhen(Iix==w)
endloopendifreturn trueendfunctionfunction o5r takes integer oSx returns booleanif((hz[((oSx))])>0)thenreturn false
endifset jz=jz+1set Hz[jz]=oSxset hz[oSx]=jz+1
return(jz==0)endfunctionfunction o6r takes nothing returns nothinglocal integer oMx=jz
loop
exitwhen(oMx<0)set xce[oMx]=Hz[oMx]
set oMx=oMx-1endloopset xCe=jzendfunctionfunction o7r takes nothing returns integerlocal integer o7xif(xCe<0)thenreturn w
endifset o7x=xce[0]set xce[0]=xce[xCe]set xCe=xCe-1return o7xendfunctionfunction o8r takes nothing returns nothinglocal integer oSxlocal real M4olocal real M5olocal real OLxlocal real dVxlocal real dExlocal real MQxlocal real dXlocal real dYlocal real dZlocal real d
call o6r()loop
set oSx=o7r()exitwhen(oSx==w)
set M4o=(mMv[((oSx))])set M5o=(mPv[((oSx))])set OLx=(mQv[((oSx))])set dVx=xNe[oSx]
set dEx=xbe[oSx]
set MQx=xBe[oSx]
set dX=dVx-(mHv[((oSx))])set dY=dEx-(mjv[((oSx))])set dZ=MQx-(mJv[((oSx))])set d=gHx(dX,dY,dZ)if(d<M4o+(mCv[((oSx))]))then
call MJx(oSx)call Myo((oSx),dVx,dEx,MQx)else
set dX=dX*1./ dset dY=dY*1./ dset dZ=dZ*1./ dcall M0o((oSx),(mVv[((oSx))]),(mOv[((oSx))]),(mIv[((oSx))]))
call M1o((oSx),M4o*dX,M4o*dY,M4o*dZ)
endifendloopendfunctionfunction o9r takes integer oSx,real dVx,real dEx,real MQx returns nothingcall MHo((oSx),dVx,dEx,MQx)set xNe[oSx]=dVx
set xbe[oSx]=dEx
set xBe[oSx]=MQx
call Mox((oSx),Gz)call M_o((oSx),dVx-(mHv[((oSx))]),dEx-(mjv[((oSx))]),MQx-(mJv[((oSx))]))
call MJo((oSx))if o5r(oSx)thencall iDx(Jz,mEv,true,function o8r)endifendfunctionfunction rvr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local boolean ELo=(oav[(rFx)])local integer oSx=osx(Cqx,e2e)local integer Mho=e_e[oSx]local integer rYx=e0e[oSx]local real dVxlocal real dExcall rVx(Cqx,e2e)if ELo thenset e1e[oSx]=e1e[oSx]set dVx=(GetUnitX(C[((e1e[oSx]))]))set dEx=(GetUnitY(C[((e1e[oSx]))]))if(GZx(dVx-(GetUnitX(C[((Cqx))])),dEx-(GetUnitY(C[((Cqx))])))<xEe[rYx])thenset xXe[oSx]=Cqx
call m4o(Mho,600.)set mcv[((Mho))]=((Bev*((.1)*1.))*1.)set mFv[(Mho)]=Xkx((function o2r))set mZv[(Mho)]=(oSx)
call Meo(Mho,700.)call Mso((Mho),(Cqx),.0,.0,.0)call o9r(Mho,dVx,dEx,X_x(dVx,dEx))return trueendifendifcall o1r(oSx)call MFo(Mho)call BNx(Cqx,(CQx((Sjv),tH+(rYx))))return trueendfunctionfunction rer takes real a returns realreturn(a*a)endfunctionfunction rxr takes nothing returns booleanlocal integer oMxset eye=O5x()set eYe=Xpx(function oQr)call mro(Sjv,Xdx("ChaosBall_Init: call ChaosBall.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ChaosBall.Event_SpellEffect))",ih,MI,function o0r))
call mro(Sjv,Xdx("ChaosBall_Init: call ChaosBall.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ChaosBall.Event_EndCast))",onv,MI,function rvr))call W2x(XDv,eUe)set oMx=(m6[(Sjv)])loop
set xEe[oMx]=rer((CQx((Sjv),Lov+(oMx)))+xde)
set oMx=oMx-1exitwhen(oMx<1)endloopreturn trueendfunctionfunction ror takes nothing returns booleancall orr(function rxr,"ChaosBall_Init")return trueendfunctionfunction rrr takes nothing returns booleanset xDe=Wwx('BEnC',"Energy Charge",'bEnC')set aav[(xDe)]=(true)set Pc[(xDe)]=(true)
set anv[(xDe)]=("ReplaceableTextures\\CommandButtons\\BTNSeaGiantPulverize.blp")
call lWx(xDe,"Abilities\\Weapons\\GreenDragonMissile\\GreenDragonMissile.mdl","hand right",ri)set WU=l_x()
call l2x(WU,dIv,25)call l3x(((xDe)),ZB+(1),(WU))return trueendfunctionfunction rir takes nothing returns booleancall VNx(ma,(function rrr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\EnergyCharge.page\\EnergyCharge.struct\\Target\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction rar takes nothing returns booleanset xfe=VXx(xFe)
return trueendfunctionfunction rnr takes nothing returns booleancall L1x('AEnC',false)set SDv=L0o('AEnC')set K6[(SDv)]=(H6)set m6[(SDv)]=(1)set TH[(SDv)]=("Energy Charge")set x3v[(SDv)]=("spell")
call L1o((SDv),Lov+(1),((750)*1.))set MOv[(SDv)]=("ReplaceableTextures\\PassiveButtons\\PASBTNSeaGiantPulverize.blp")return trueendfunctionfunction rVr takes nothing returns booleanset xge=ltx(xGe+" (dummyBuff)")return trueendfunctionfunction rEr takes nothing returns booleancall VNx(Pa,(function rnr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\EnergyCharge.page\\EnergyCharge.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function rVr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\EnergyCharge.page\\EnergyCharge.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction rXr takes nothing returns booleanset xhe=VXx(xGe)
return trueendfunctionfunction rOr takes integer Iix returns booleanreturn( not(I9x(Iix,Ifv)))and( not(I9x(Iix,Igv)))endfunctionfunction rRr takes integer rYx,integer Iix returns nothingcall Dux((Iix),(xDe),(rYx),w)endfunctionfunction rIr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(E2v[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSxlocal integer rArif not rOr(Iix)thenreturn trueendifset oSx=Cqxset rAr=xje[oSx]+1if(rAr==xJe)then
set xje[oSx]=0call Ryx(xke[oSx])call Ryx(xKe[oSx])call rRr((Mv[(rFx)]),Cqx)else
set xje[oSx]=rAr
if(rAr==1)thenset xke[oSx]=(ACx((Cqx),(xle),(xLe),(ri)))elseif(rAr==2)thenset xKe[oSx]=(ACx((Cqx),(xme),(xMe),(ri)))endifendifreturn trueendfunctionfunction rNr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixset xje[oSx]=0call Avx(Iix,xHe)return trueendfunctionfunction rbr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall RPx(Iix,xHe)if(xje[oSx]==2)thencall Ryx(xke[oSx])call Ryx(xKe[oSx])elseif(xje[oSx]==1)thencall Ryx(xke[oSx])endifreturn trueendfunctionfunction rBr takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(xge),((Mv[(rFx)])),w)return trueendfunctionfunction rcr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),xge)return trueendfunctionfunction rCr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(E2v[(rFx)])call mao(Iix,Iix,xPe)call AZx(Iix,xDe)return trueendfunctionfunction rdr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])call AZx(Iix,xge)call Avx(Iix,xpe)return trueendfunctionfunction rDr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer rYx=(hc[(rFx)])call RPx(Iix,xpe)set rYx=(osx(((Iix)),N+(SDv)))if(rYx>0)thencall Dux((Iix),(xge),(rYx),w)endifreturn trueendfunctionfunction rfr takes nothing returns nothingset xpe=Xdx("FolderEnergyCharge_StructTarget_Init: set FolderEnergyCharge_StructTarget.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function FolderEnergyCharge_StructTarget.Event_Damage)",E4v,MI,function rCr)call Lxx(xDe,Xdx("FolderEnergyCharge_StructTarget_Init: call FolderEnergyCharge_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderEnergyCharge_StructTarget.Event_BuffGain))",bd,MI,function rdr))call Lxx(xDe,Xdx("FolderEnergyCharge_StructTarget_Init: call FolderEnergyCharge_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderEnergyCharge_StructTarget.Event_BuffLose))",jc,MI,function rDr))endfunctionfunction rFr takes nothing returns booleanset xHe=Xdx("EnergyCharge_Init: set EnergyCharge.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function EnergyCharge.Event_Damage)",E4v,MI,function rIr)
call Lxx(xge,Xdx("EnergyCharge_Init: call EnergyCharge.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnergyCharge.Event_BuffGain))",bd,MI,function rNr))
call Lxx(xge,Xdx("EnergyCharge_Init: call EnergyCharge.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnergyCharge.Event_BuffLose))",jc,MI,function rbr))
call mro(SDv,Xdx("EnergyCharge_Init: call EnergyCharge.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnergyCharge.Event_Learn))",pv,MI,function rBr))call mro(SDv,Xdx("EnergyCharge_Init: call EnergyCharge.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnergyCharge.Event_Unlearn))",Av,MI,function rcr))call rfr()return trueendfunctionfunction rgr takes nothing returns booleancall orr(function rFr,"EnergyCharge_Init")return trueendfunctionfunction rGr takes nothing returns booleanset xqe=VXx(xQe)
return trueendfunctionfunction rhr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(LoadInteger(o[((V[(E[((X))])]))],(((RK+(((av[(rFx)])))))),(((IK)))))local integer Iixif I9x(Cqx,Qc)thenreturn trueendifset hf=(ze[(Cqx)])set Iix=oIr((GetUnitX(C[((Cqx))])),(GetUnitY(C[((Cqx))])),500.,xSe)if(Iix==w)thenreturn trueendifcall CBx((Cqx),(Rh[((xse))]),(((GetUnitX(C[((Iix))])))*1.),(((GetUnitY(C[((Iix))])))*1.))return trueendfunctionfunction rHr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction rjr takes nothing returns booleanlocal integer FPx=x3r(xse,function rhr)set xSe=Xpx(function rHr)call x6r(FPx,dTv,HI,w)return trueendfunctionfunction rJr takes nothing returns booleancall e4r(function rjr,"AIFlamelet_Init")
return trueendfunctionfunction rkr takes nothing returns booleanset xte=ltx(xTe+" (ignitionBuff)")set Pc[(xte)]=(true)
set uU[(xte)]=(true)
return trueendfunctionfunction rKr takes nothing returns booleancall L1x('AFba',false)set xse=L0o('AFba')set K6[(xse)]=(H6)set m6[(xse)]=(1)set TH[(xse)]=("Flamelet")set Rh[(xse)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Aj))))))set oxv[(xse)]=(2)set x3v[(xse)]=("spell")
call L1o((xse),Uvv+(1),((80)*1.))call L1o((xse),dH+(1),((2)*1.))call L1o((xse),GH+(1),(($C)*1.))
call L1o((xse),tH+(1),((50)*1.))
call L1o((xse),Lov+(1),((900)*1.))set MOv[(xse)]=("ReplaceableTextures\\CommandButtons\\BTNFireBolt.blp")return trueendfunctionfunction rlr takes nothing returns booleancall VNx(ma,(function rkr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Flamelet.page\\Flamelet.struct\\obj_ignitionBuff_wc3buff.j"))call VNx(Pa,(function rKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Flamelet.page\\Flamelet.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction rLr takes nothing returns booleanset xue=VXx(xTe)
return trueendfunctionfunction rmr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=jhx()local integer Mholocal integer oSxlocal integer Ctxif I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifset Mho=(ez[(rFx)])set oSx=(mZv[(Mho)])
set Ctx=xwe[oSx]
if(IsUnitAlly(C[(Iix)],vx[((ze[((EH[(Ctx)]))]))]))thenreturn false
endifreturn truereturn trueendfunctionfunction rMr takes integer oSx,real x,real y,real z returns nothingcall M_o(oSx,x-(mHv[((oSx))]),y-(mjv[((oSx))]),z-(mJv[((oSx))]))
endfunctionfunction rpr takes integer Ctx returns nothinglocal integer oSx=Ctxlocal integer Cqx=(EH[(Ctx)])local integer rYx=(IH[(Ctx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real rPr=(CQx((xse),Lov+(rYx)))local real dVx=(yh[(Ctx)])local real dEx=(Yh[(Ctx)])local real bex=(Atan2(((dEx-wso)*1.),((dVx-wQo)*1.)))local integer Mho=Moo()local integer HAxset xYe[oSx]=Mho
set xwe[oSx]=Ctx
call pxo(Mho,Cqx)call rMr(Mho,wQo+rPr*(Cos(((((bex)*1.))*1.))),wso+rPr*(Sin(((((bex)*1.))*1.))),X_x(dVx,dEx)+60.)
set HAx=Mno(Mho,'qFba',1.5)call o_r(HAx,1,(CQx(((AH[(Ctx)])),dH+(rYx))))call sEo((HAx),(xze),(xZe),(Bi))
endfunctionfunction rqr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer Ctx=(WH[(rFx)])call Ryx((ACx((Cqx),(xWe),(xye),(Bi))))call rpr(Ctx)return trueendfunctionfunction rQr takes integer oSx returns integerset x3e[oSx]=trueset x4e[oSx]=falsecall rEx(xue)return oSxendfunctionfunction rsr takes nothing returns integerlocal integer oSxif(x_e==8190)thencall o_x("Flamelet_Allocation_allocCustom","call DebugEx(Flamelet.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",xTe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(x0e[(w)]==w)thenset x1e=x1e+1set oSx=x1eelse
set oSx=x0e[(w)]
set x0e[(w)]=x0e[x0e[(w)]]endifset x0e[oSx]=Zset x2e[oSx]=1call rQr(oSx)return oSxendfunctionfunction rSr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])call MFo(Mho)return trueendfunctionfunction rtr takes integer oSx,code igx,integer Muo returns nothingset mGv[oSx]=Xkx(igx)set mhv[oSx]=Muo
endfunctionfunction rTr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=(mZv[(Mho)])local real Nbo=x5e[oSx]local integer rYx=x7e[oSx]local integer Ctx=xwe[oSx]local integer Cqx=(EH[(Ctx)])local real iMxcall MFo(Mho)call Usx(Ctx)if I9x(Iix,Wd)thenset iMx=oxeelse
set iMx=ooeendifcall Nbx(Iix,xte,rYx,Cqx,iMx)call nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))return trueendfunctionfunction rur takes integer Ctx returns nothinglocal integer Cqx=(EH[(Ctx)])local integer rYx=(IH[(Ctx)])local real dVx=(yh[(Ctx)])local real dEx=(Yh[(Ctx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real rPr=(CQx((xse),Lov+(rYx)))local real bex=(Atan2(((dEx-wso)*1.),((dVx-wQo)*1.)))local integer oSx=rsr()local integer Mho=xYe[oSx]set x5e[oSx]=x6e
set x7e[oSx]=rYx
set x8e[oSx]=rPr
set x9e[oSx]=wQo
set ove[oSx]=wso
set xwe[oSx]=Ctx
call Ucx(Ctx)set mCv[(Mho)]=(((CQx((xse),Uvv+(rYx))))*1.)
set mZv[(Mho)]=(oSx)
set mFv[(Mho)]=Xkx((function rSr))call Meo(Mho,oee)call o9r(Mho,wQo+rPr*(Cos(((((bex)*1.))*1.))),wso+rPr*(Sin(((((bex)*1.))*1.))),X_x(dVx,dEx)+60.)
call rtr(Mho,function rTr,xUe)endfunctionfunction rUr takes nothing returns booleanlocal integer rFx=(bv)local boolean ELo=(oav[(rFx)])local integer Ctx=(WH[(rFx)])local integer oSx=Ctxif not ELo thencall MFo(xYe[oSx])return trueendifcall rur(Ctx)return trueendfunctionfunction rwr takes nothing returns booleanset xUe=Xpx(function rmr)call mro(xse,Xdx("Flamelet_Init: call Flamelet.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Flamelet.Event_SpellEffect))",ih,MI,function rqr))call mro(xse,Xdx("Flamelet_Init: call Flamelet.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Flamelet.Event_EndCast))",onv,MI,function rUr))call W2x(Xev,xte)return trueendfunctionfunction rWr takes nothing returns booleancall orr(function rwr,"Flamelet_Init")return trueendfunctionfunction ryr takes nothing returns booleancall L1x('AFuA',false)set G_v=L0o('AFuA')set K6[(G_v)]=(H6)set m6[(G_v)]=(1)set TH[(G_v)]=("Fuzzy Attack")set Rh[(G_v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D007F)))),(((Aj))))))set oxv[(G_v)]=(4)set x3v[(G_v)]=("spell")
call L1o((G_v),dH+(1),((4.25)*1.))call L1o((G_v),GH+(1),(($F)*1.))
call L1o((G_v),tH+(1),(($96)*1.))call L1o((G_v),Lov+(1),((700)*1.))set MOv[(G_v)]=("ReplaceableTextures\\CommandButtons\\BTNFurbolg.blp")return trueendfunctionfunction rYr takes nothing returns booleancall VNx(Pa,(function ryr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\FuzzyAttack.page\\FuzzyAttack.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction rzr takes nothing returns booleanset ore=VXx(oie)
return trueendfunctionfunction rZr takes integer oSx returns nothingset oNe[oSx]=falsecall rHx(ore)endfunctionfunction r_r takes integer oSx returns nothingif(oIe[oSx]>0)thenreturnendifif(oAe[oSx]!=Z)thencall o_x("FuzzyAttack_Allocation_deallocCustom_confirm","call DebugEx(FuzzyAttack.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",oie+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset oAe[oSx]=oAe[(w)]set oAe[(w)]=oSx
call rZr(oSx)endfunctionfunction r0r takes integer oSx returns nothingset oIe[oSx]=oIe[oSx]-1call r_r(oSx)endfunctionfunction r1r takes integer oSx,integer Cqx returns nothinglocal integer Okx=oOe[oSx]local integer Ctx=oRe[oSx]call r0r((oSx))call rnx(Cqx,oEe,oSx)call iKx(Okx)call dNx(Ctx)endfunctionfunction r2r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oMx=CIx(Cqx,oEe)local integer oSxloop
set oSx=CAx(Cqx,oEe,oMx)
if(oXe[oSx]==0)thencall r1r(oSx,Cqx)else
call ikx(oOe[oSx])endifset oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction r3r takes integer oSx returns integerset oNe[oSx]=trueset oce[oSx]=falsecall rEx(ore)return oSxendfunctionfunction r4r takes nothing returns integerlocal integer oSxif(obe==8190)thencall o_x("FuzzyAttack_Allocation_allocCustom","call DebugEx(FuzzyAttack.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",oie+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(oAe[(w)]==w)thenset oBe=oBe+1set oSx=oBeelse
set oSx=oAe[(w)]
set oAe[(w)]=oAe[oAe[(w)]]endifset oAe[oSx]=Zset oIe[oSx]=1call r3r(oSx)return oSxendfunctionfunction r5r takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=oCe[oSx]local integer r6r=oXe[oSx]-1
local integer Iix=ode[oSx]call MFo(Mho)call nlo((Cqx),(ode[oSx]),((oDe)*1.),(true),(false))
if(r6r==0)thencall r1r(oSx,Cqx)else
set oXe[oSx]=r6r
endifreturn trueendfunctionfunction r7r takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Mho=Moo()set oXe[oSx]=oXe[oSx]+1set mcv[((Mho))]=((Bev*((.06)*1.))*1.)set mCv[(Mho)]=((32.)*1.)call Mno(Mho,'qFuA',1.)set mFv[(Mho)]=Xkx((function r5r))set mZv[(Mho)]=(oSx)
call Meo(Mho,700.)call pxo(Mho,oCe[oSx])call M6o((Mho),(ode[oSx]),.0,.0,.0,(null))endfunctionfunction r8r takes nothing returns nothingcall iDx((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))),oae,true,function r7r)endfunctionfunction r9r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer Iix=(zH[(rFx)])local integer oSx=r4r()local integer Okx=iXx()set oCe[oSx]=Cqx
set oOe[oSx]=Okx
set oXe[oSx]=0set ode[oSx]=Iix
set oRe[oSx]=CPx(Cqx,G_v)call rUx(Cqx,oEe,oSx)set ge[(Okx)]=(oSx)call iDx(Okx,one,false,function r8r)
return trueendfunctionfunction ivr takes nothing returns booleanset oae=((CQx((G_v),dH+(1)))-one)*1./ oVe-.01call mro(G_v,Xdx("FuzzyAttack_Init: call FuzzyAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FuzzyAttack.Event_EndCast))",onv,MI,function r2r))call mro(G_v,Xdx("FuzzyAttack_Init: call FuzzyAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FuzzyAttack.Event_SpellEffect))",ih,MI,function r9r))return trueendfunctionfunction ier takes nothing returns booleancall orr(function ivr,"FuzzyAttack_Init")return trueendfunctionfunction ixr takes nothing returns booleanset ofe=Wwx('BGrN',"Entangled",'bGrN')set uU[(ofe)]=(true)
set anv[(ofe)]=("ReplaceableTextures\\CommandButtons\\BTNEntanglingRoots.blp")call lWx(ofe,"Abilities\\Spells\\NightElf\\EntanglingRoots\\EntanglingRootsTarget.mdl","origin",ri)set WU=l_x()
call vAr(WU,dsv,true)call vAr(WU,djv,true)call l3x(((ofe)),ZB+(1),(WU))return trueendfunctionfunction ior takes nothing returns booleancall VNx(ma,(function ixr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\GreenNova.page\\GreenNova.struct\\Buff\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction irr takes nothing returns booleanset oFe=VXx(oge)
return trueendfunctionfunction iir takes nothing returns booleancall L1x('AGrN',false)set G0v=L0o('AGrN')set K6[(G0v)]=(H6)set m6[(G0v)]=(1)set TH[(G0v)]=("Green Nova")
set Rh[(G0v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00CB)))),(((Aj))))))set oxv[(G0v)]=(0)set x3v[(G0v)]=("spell")
call L1o((G0v),GH+(1),((20)*1.))
call L1o((G0v),tH+(1),((400)*1.))call L1o((G0v),Lov+(1),((750)*1.))set MOv[(G0v)]=("ReplaceableTextures\\CommandButtons\\BTNEntanglingRoots.blp")return trueendfunctionfunction iar takes nothing returns booleancall VNx(Pa,(function iir),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\GreenNova.page\\GreenNova.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction inr takes nothing returns booleanset oGe=VXx(ohe)
return trueendfunctionfunction iVr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifif Jvx(Iix,gf,Gf,Ff)then
return false
endifreturn truereturn trueendfunctionfunction iEr takes integer oSx returns integerset oqe[oSx]=trueset oQe[oSx]=falsecall rEx(oGe)return oSxendfunctionfunction iXr takes nothing returns integerlocal integer oSxif(ome==8190)thencall o_x("GreenNova_Allocation_allocCustom","call DebugEx(GreenNova.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",ohe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(oMe[(w)]==w)thenset ope=ope+1set oSx=opeelse
set oSx=oMe[(w)]
set oMe[(w)]=oMe[oMe[(w)]]endifset oMe[oSx]=Zset oPe[oSx]=1call iEr(oSx)return oSxendfunctionfunction iOr takes integer rYx,integer Iix returns nothinglocal real iMxif I9x(Iix,Wd)thenset iMx=ozeelse
set iMx=oZeendifcall Nbx((Iix),(ofe),(rYx),w,((iMx)*1.))
endfunctionfunction iRr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local real bex=ose[oSx]local integer rYx=oTe[oSx]local real Jex=oue[oSx]+oUe[oSx]
local real x=owe[oSx]local real y=oWe[oSx]local real iIr=oye*1./ Jexlocal integer oMx=(R2I(((2*3.141592654*Jex*1./ oye)*1.)))local integer Iixset oue[oSx]=Jex
loop
call mho((mko(((x+Jex*(Cos(((((bex)*1.))*1.))))*1.),((y+Jex*(Sin(((((bex)*1.))*1.))))*1.),(oYe),((Ni[(GetRandomInt((bi[(ri)]),(bi[(Bi)])))])))))
set oMx=oMx-1exitwhen(oMx<1)set bex=bex+iIrendloopset Ff=Jex-oUe[oSx]set gf=x
set Gf=y
set hf=(ze[(oSe[oSx])])call NVo(oke,x,y,Jex,oLe)loop
set Iix=NEo(oke)
exitwhen(Iix==w)
call iOr(rYx,Iix)endloopendfunctionfunction iAr takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local integer p3x=ote[oSx]call iKx(iCx)call iKx(p3x)endfunctionfunction iNr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oSx=iXr()local integer iCx=iXx()local integer p3x=iXx()set ose[oSx]=(GetUnitFacing(C[((Cqx))])*Nh)set oSe[oSx]=Cqx
set ote[oSx]=p3x
set oTe[oSx]=(Mv[(rFx)])
set oue[oSx]=.0set oUe[oSx]=oKe
set owe[oSx]=(GetUnitX(C[((Cqx))]))set oWe[oSx]=(GetUnitY(C[((Cqx))]))set ge[(iCx)]=(oSx)set ge[(p3x)]=(oSx)call iDx(p3x,oje,true,function iRr)call iDx(iCx,oHe,false,function iAr)
return trueendfunctionfunction ibr takes nothing returns nothingendfunctionfunction iBr takes nothing returns booleanset oHe=oje*oJeset oke=O5x()set oKe=ole*1./ oJeset oLe=Xpx(function iVr)call mro(G0v,Xdx("GreenNova_Init: call GreenNova.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function GreenNova.Event_SpellEffect))",ih,MI,function iNr))
call ibr()return trueendfunctionfunction icr takes nothing returns booleancall orr(function iBr,"GreenNova_Init")return trueendfunctionfunction iCr takes nothing returns booleanset o_e=VXx(o0e)
return trueendfunctionfunction idr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(LoadInteger(o[((V[(E[((X))])]))],(((RK+(((av[(rFx)])))))),(((IK)))))local integer Iixif I9x(Cqx,Qc)thenreturn trueendifset hf=(ze[(Cqx)])set Iix=oIr((GetUnitX(C[((Cqx))])),(GetUnitY(C[((Cqx))])),500.,o1e)if(Iix!=w)thencall Lox((Cqx),(Rh[((gUv))]),(Iix))endifreturn trueendfunctionfunction iDr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif not(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif((oG[(Iix)])>=(R2I((((rG[(Iix)]))*1.)))-o2e)thenreturn false
endifreturn trueendfunctionfunction ifr takes nothing returns booleanlocal integer FPx=x3r(gUv,function idr)set o1e=Xpx(function iDr)call oFr(FPx,1.)
return trueendfunctionfunction iFr takes nothing returns booleancall e4r(function ifr,"AIHeal_Init")
return trueendfunctionfunction igr takes nothing returns booleancall L1x('AHel',false)set gUv=L0o('AHel')set K6[(gUv)]=(H6)set m6[(gUv)]=(1)set TH[(gUv)]=("Heal")set Rh[(gUv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D005F)))),(((Aj))))))set oxv[(gUv)]=(4)set x3v[(gUv)]=("spell")
call L1o((gUv),GH+(1),((5)*1.))call L1o((gUv),tH+(1),((40)*1.))
call L1o((gUv),Lov+(1),((900)*1.))set MOv[(gUv)]=("ReplaceableTextures\\CommandButtons\\BTNHeal.blp")return trueendfunctionfunction iGr takes nothing returns booleancall VNx(Pa,(function igr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Heal.page\\Heal.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction ihr takes nothing returns booleanset o3e=VXx(o4e)
return trueendfunctionfunction iHr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer Iix=(zH[(rFx)])call pmo((ACx((Iix),(o5e),(o6e),(ri))),2.)call mao(Cqx,Iix,o2e)return trueendfunctionfunction ijr takes nothing returns booleancall mro(gUv,Xdx("Heal_Init: call Heal.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Heal.Event_SpellEffect))",ih,MI,function iHr))return trueendfunctionfunction iJr takes nothing returns booleancall orr(function ijr,"Heal_Init")return trueendfunctionfunction ikr takes nothing returns booleanset o7e=VXx(o8e)
return trueendfunctionfunction iKr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(LoadInteger(o[((V[(E[((X))])]))],(((RK+(((av[(rFx)])))))),(((IK)))))if I9x(Cqx,Qc)thenreturn trueendifset hf=(ze[(Cqx)])call NVo(o9e,(GetUnitX(C[((Cqx))])),(GetUnitY(C[((Cqx))])),(CQx((gwv),Uvv+((osx(((Cqx)),N+(gwv)))))),rve)if((NIo((o9e)))>3)thencall Rxx((Cqx),(Rh[((gwv))]))endifreturn trueendfunctionfunction ilr takes nothing returns booleanlocal integer FPx=x3r(gwv,function iKr)call oFr(FPx,1.)
return trueendfunctionfunction iLr takes nothing returns booleancall e4r(function ilr,"AIHealExplosion_Init")return trueendfunctionfunction imr takes nothing returns booleancall L1x('AHEx',false)set gwv=L0o('AHEx')set K6[(gwv)]=(H6)set m6[(gwv)]=(1)set TH[(gwv)]=("Heal Explosion")
set Rh[(gwv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0085)))),(((Aj))))))set oxv[(gwv)]=(0)set x3v[(gwv)]=("spell")
call L1o((gwv),Uvv+(1),((300)*1.))call L1o((gwv),dH+(1),((2.5)*1.))call L1o((gwv),GH+(1),(($F)*1.))
call L1o((gwv),tH+(1),((25)*1.))
call L1o((gwv),Lov+(1),((750)*1.))set MOv[(gwv)]=("ReplaceableTextures\\CommandButtons\\BTNHealExplosion.blp")
return trueendfunctionfunction iMr takes nothing returns booleancall VNx(Pa,(function imr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\HealExplosion.page\\HealExplosion.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction ipr takes nothing returns booleanset ree=VXx(rxe)
return trueendfunctionfunction iPr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,IFv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction iqr takes nothing returns booleanlocal integer Iix=jhx()if(Iix==Rb)thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,IFv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif not(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction iQr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer oSx=Cqxset rre[oSx]=(ACx((Cqx),(rie),(rae),(ri)))set rne[oSx]=rYx
return trueendfunctionfunction isr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local boolean ELo=(oav[(rFx)])local integer oSx=Cqxlocal integer iSr=rre[oSx]local integer rYx=rne[oSx]local integer Iixcall Ryx(iSr)if not ELo thenreturn trueendifcall Ryx((ACx((Cqx),(rVe),(rEe),(ri))))set hf=(ze[(Cqx)])call NVo(o9e,(GetUnitX(C[((Cqx))])),(GetUnitY(C[((Cqx))])),(CQx((gwv),Uvv+(rYx))),roe)set Iix=NEo(o9e)
if(Iix!=w)thenloop
call Ryx((ACx((Iix),(rXe),(rOe),(ri))))call nlo((Cqx),(Iix),((rRe)*1.),(false),(false))
set Iix=NEo(o9e)
exitwhen(Iix==w)
endloopendifcall mao(Cqx,Cqx,rIe)set hf=(ze[(Cqx)])set Rb=Cqxcall NVo(o9e,(GetUnitX(C[((Cqx))])),(GetUnitY(C[((Cqx))])),(CQx((gwv),Uvv+(rYx))),rve)call GroupRemoveUnit(kb[(o9e)],C[(Cqx)])
set Iix=NEo(o9e)
if(Iix!=w)thenloop
call Ryx((ACx((Iix),(rAe),(rNe),(ri))))call mao(Cqx,Iix,rIe)set Iix=NEo(o9e)
exitwhen(Iix==w)
endloopendifreturn trueendfunctionfunction itr takes nothing returns booleanset o9e=O5x()set roe=Xpx(function iPr)set rve=Xpx(function iqr)call mro(gwv,Xdx("HealExplosion_Init: call HealExplosion.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HealExplosion.Event_SpellEffect))",ih,MI,function iQr))
call mro(gwv,Xdx("HealExplosion_Init: call HealExplosion.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HealExplosion.Event_EndCast))",onv,MI,function isr))return trueendfunctionfunction iTr takes nothing returns booleancall orr(function itr,"HealExplosion_Init")return trueendfunctionfunction iur takes nothing returns booleancall L1x('AIcA',false)set hnv=L0o('AIcA')set K6[(hnv)]=(H6)set m6[(hnv)]=(1)set TH[(hnv)]=("Ice Arrows")
set x3v[(hnv)]=("spell")
call L1o((hnv),tH+(1),((20)*1.))
call L1o((hnv),Lov+(1),((750)*1.))set MOv[(hnv)]=("ReplaceableTextures\\CommandButtons\\BTNColdArrowsOn.blp")return trueendfunctionfunction iUr takes nothing returns booleanset rbe=ltx(rBe+" (coldnessBuff)")set Pc[(rbe)]=(true)
set uU[(rbe)]=(true)
return trueendfunctionfunction iwr takes nothing returns booleanset rce=ltx(rBe+" (dummyBuff)")return trueendfunctionfunction iWr takes nothing returns booleancall VNx(Pa,(function iur),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\IceArrows.page\\IceArrows.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function iUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\IceArrows.page\\IceArrows.struct\\obj_coldnessBuff_wc3buff.j"))call VNx(ma,(function iwr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\IceArrows.page\\IceArrows.struct\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction iyr takes nothing returns booleanset rCe=VXx(rBe)
return trueendfunctionfunction iYr takes integer Iix returns booleanreturn( not(I9x(Iix,Ifv)))and( not(I9x(Iix,Igv)))and( not(nbo(Iix)))
endfunctionfunction izr takes integer rYx,integer Iix returns nothinglocal real iMxif I9x(Iix,Wd)thenset iMx=rFeelse
set iMx=rgeendifcall Nbx((Iix),(rbe),(rYx),w,((iMx)*1.))
endfunctionfunction iZr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(E2v[(rFx)])local integer Iix=(Vv[(rFx)])local integer rYx=(osx(((Cqx)),N+(hnv)))
local real i_r=(lF[(Cqx)])-(CQx((hnv),tH+(rYx)))
if(i_r<.0)thenreturn trueendifcall BAx(Cqx,i_r)if not iYr(Iix)thenreturn trueendifcall Ryx((ACx((Iix),(rDe),(rfe),(ri))))call izr(rYx,Iix)call nlo((Cqx),(Iix),((rGe)*1.),(true),(false))return trueendfunctionfunction i0r takes nothing returns booleanlocal integer rFx=(bv)call Avx((Vv[(rFx)]),rde)return trueendfunctionfunction i1r takes nothing returns booleanlocal integer rFx=(bv)call RPx((Vv[(rFx)]),rde)return trueendfunctionfunction i2r takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(rce),((Mv[(rFx)])),w)return trueendfunctionfunction i3r takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),rce)return trueendfunctionfunction i4r takes nothing returns booleanset rde=Xdx("IceArrows_Init: set IceArrows.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function IceArrows.Event_Damage)",E4v,MI,function iZr)call Lxx(rce,Xdx("IceArrows_Init: call IceArrows.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function IceArrows.Event_BuffGain))",bd,MI,function i0r))call Lxx(rce,Xdx("IceArrows_Init: call IceArrows.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function IceArrows.Event_BuffLose))",jc,MI,function i1r))call mro(hnv,Xdx("IceArrows_Init: call IceArrows.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function IceArrows.Event_Learn))",pv,MI,function i2r))call mro(hnv,Xdx("IceArrows_Init: call IceArrows.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function IceArrows.Event_Unlearn))",Av,MI,function i3r))call W2x(nVv,rbe)return trueendfunctionfunction i5r takes nothing returns booleancall orr(function i4r,"IceArrows_Init")return trueendfunctionfunction i6r takes nothing returns booleancall L1x('ALiS',false)set G1v=L0o('ALiS')set K6[(G1v)]=(H6)set m6[(G1v)]=(1)set TH[(G1v)]=("Lightning Shield")set Rh[(G1v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D008E)))),(((Aj))))))set oxv[(G1v)]=(4)set x3v[(G1v)]=("spell")
call L1o((G1v),Uvv+(1),(($82)*1.))call L1o((G1v),GH+(1),((25)*1.))
call L1o((G1v),tH+(1),(('x')*1.))call L1o((G1v),Lov+(1),((900)*1.))set MOv[(G1v)]=("ReplaceableTextures\\CommandButtons\\BTNLightningShield.blp")return trueendfunctionfunction i7r takes nothing returns booleanset rhe=Wwx('BLiS',"Lightning Shield",'bLiS')set uU[(rhe)]=(true)
set anv[(rhe)]=("ReplaceableTextures\\CommandButtons\\BTNLightningShield.blp")call lWx(rhe,"Abilities\\Spells\\Orc\\LightningShield\\LightningShieldTarget.mdl","origin",ri)return trueendfunctionfunction i8r takes nothing returns booleancall VNx(Pa,(function i6r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\LightningShield.page\\LightningShield.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function i7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\LightningShield.page\\LightningShield.struct\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction i9r takes nothing returns booleanset rHe=VXx(rje)
return trueendfunctionfunction avr takes nothing returns booleanlocal integer Iix=jhx()if(Iix==Rb)thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifreturn truereturn trueendfunctionfunction aer takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=rpe[oSx]local integer axrset Rb=Iixcall NVo(rle,(GetUnitX(C[((Iix))])),(GetUnitY(C[((Iix))])),rme[oSx]*Opx(Iix,true)*1./ 60.,rLe)set axr=NEo(rle)
if(axr!=w)thenloop
call nlo((Iix),(axr),((rJe)*1.),(true),(false))set axr=NEo(rle)
exitwhen(axr==w)
endloopendifendfunctionfunction aor takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=iXx()set rme[oSx]=(CQx((G1v),Uvv+(rYx)))set rMe[oSx]=p3x
set rpe[oSx]=Iix
set ge[(p3x)]=(oSx)call iDx(p3x,rKe,true,function aer)return trueendfunctionfunction arr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=rMe[oSx]call iKx(p3x)return trueendfunctionfunction air takes nothing returns booleanlocal integer rFx=(bv)call Nbx(((zH[(rFx)])),(rhe),((Mv[(rFx)])),w,((rPe)*1.))
return trueendfunctionfunction aar takes nothing returns booleanset rJe=rke*rKeset rle=O5x()set rLe=Xpx(function avr)call Lxx(rhe,Xdx("LightningShield_Init: call LightningShield.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LightningShield.Event_BuffGain))",bd,MI,function aor))call Lxx(rhe,Xdx("LightningShield_Init: call LightningShield.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LightningShield.Event_BuffLose))",jc,MI,function arr))call mro(G1v,Xdx("LightningShield_Init: call LightningShield.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LightningShield.Event_SpellEffect))",ih,MI,function air))return trueendfunctionfunction anr takes nothing returns booleancall orr(function aar,"LightningShield_Init")return trueendfunctionfunction aVr takes nothing returns booleanset rqe=ltx(rQe+" (dummyBuff)")return trueendfunctionfunction aEr takes nothing returns booleancall VNx(ma,(function aVr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\LunarRestoration.page\\LunarRestoration.struct\\Revival\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction aXr takes nothing returns booleanset rse=VXx(rQe)
return trueendfunctionfunction aOr takes nothing returns booleanset rSe=ltx(rte+" (dummyBuff)")return trueendfunctionfunction aRr takes nothing returns booleanset rTe=Wwx('BLuR',"Lunar Restoration",'bLuR')set aav[(rTe)]=(true)set anv[(rTe)]=("ReplaceableTextures\\PassiveButtons\\PASBTNElunesBlessing.blp")
call lWx(rTe,"Abilities\\Spells\\Items\\ScrollOfRegeneration\\Scroll_Regen_Target.mdl","chest",Bi)return trueendfunctionfunction aIr takes nothing returns booleancall L1x('ALuR',false)set hXv=L0o('ALuR')set K6[(hXv)]=(H6)set m6[(hXv)]=(1)set TH[(hXv)]=("Lunar Restoration")set x3v[(hXv)]=("spell")
call L1o((hXv),tH+(1),(('d')*1.))call L1o((hXv),Lov+(1),((750)*1.))set MOv[(hXv)]=("ReplaceableTextures\\PassiveButtons\\PASBTNElunesBlessing.blp")
return trueendfunctionfunction aAr takes nothing returns booleancall VNx(ma,(function aOr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\LunarRestoration.page\\LunarRestoration.struct\\obj_dummyBuff_wc3buff.j"))call VNx(ma,(function aRr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\LunarRestoration.page\\LunarRestoration.struct\\obj_effectBuff_wc3buff.j"))call VNx(Pa,(function aIr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\LunarRestoration.page\\LunarRestoration.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction aNr takes nothing returns booleanset rue=VXx(rte)
return trueendfunctionfunction abr takes integer rYx,integer Iix returns nothingcall Dux((Iix),(rqe),(rYx),w)endfunctionfunction aBr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer rYxif(NRv[(Iix)])thenreturn trueendifset rYx=(osx(((Iix)),N+(hXv)))call abr(rYx,Iix)return trueendfunctionfunction acr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer aCr=rwe[rYx]local integer adr=rWe[rYx]set rye[oSx]=rYx
set rYe[oSx]=aCr
set rze[oSx]=adr
if((lF[(Iix)])<(CQx((hXv),tH+(rYx))))thenset rZe[oSx]=falsecall Avx(Iix,aCr)else
set rZe[oSx]=truecall Avx(Iix,adr)call Dux((Iix),(rTe),(rYx),w)endifreturn trueendfunctionfunction aDr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixif rZe[oSx]thencall RPx(Iix,rze[oSx])call AZx(Iix,rTe)else
call RPx(Iix,rYe[oSx])endifreturn trueendfunctionfunction afr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall Avx(Iix,rUe)return trueendfunctionfunction aFr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall RPx(Iix,rUe)return trueendfunctionfunction agr takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(rSe),((Mv[(rFx)])),w)return trueendfunctionfunction aGr takes string rSx,integer rNx,integer rbx,integer oux,limitop BXx,code igx returns integerlocal integer oSx=Xdx(rSx,rNx,rbx,igx)call xQr(oSx,oux,BXx)return oSxendfunctionfunction ahr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixset rZe[oSx]=truecall Avx(Iix,rze[oSx])call RPx(Iix,rYe[oSx])call Dux((Iix),(rTe),(rye[oSx]),w)return trueendfunctionfunction aHr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixset rZe[oSx]=falsecall Avx(Iix,rYe[oSx])call RPx(Iix,rze[oSx])call AZx(Iix,rTe)return trueendfunctionfunction ajr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),rqe)return trueendfunctionfunction aJr takes integer oSx returns nothingif I9x(oSx,Wd)thencall qpo(oSx,(GetUnitX(C[((oSx))])),(GetUnitY(C[((oSx))])))else
call YKo(oSx)endifendfunctionfunction akr takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local integer rYx=r1e[oSx]local integer Iix=oSxcall AZx(Iix,rqe)call aJr(Iix)call chx(Iix,(rG[(Iix)])*r7e)call BAx(Iix,(LF[(Iix)])*r8e-(CQx((hXv),tH+(rYx))))endfunctionfunction aKr takes nothing returns booleanlocal integer rFx=(bv)local integer iCx=iXx()local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local real dVx=(GetUnitX(C[((Iix))]))local real dEx=(GetUnitY(C[((Iix))]))local integer oSx=Iixset r0e[oSx]=iCx
set r1e[oSx]=rYx
set r2e[oSx]=(mko(((dVx)*1.),((dEx)*1.),(r3e),(ri)))
set r4e[oSx]=dVx
set r5e[oSx]=dEx
set ge[(iCx)]=(oSx)call Avx(Iix,r_e)set NRv[(Iix)]=(true)call iDx(iCx,r6e,false,function akr)
return trueendfunctionfunction alr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer aLr=r2e[oSx]call iKx(r0e[oSx])call mho(aLr)call RPx(Iix,r_e)return trueendfunctionfunction amr takes nothing returns nothingset r_e=Xdx("FolderLunarRestoration_StructRevival_Init: set FolderLunarRestoration_StructRevival.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderLunarRestoration_StructRevival.Event_Revive)",XP,MI,function ajr)call Lxx(rqe,Xdx("FolderLunarRestoration_StructRevival_Init: call FolderLunarRestoration_StructRevival.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderLunarRestoration_StructRevival.Event_BuffGain))",bd,MI,function aKr))
call Lxx(rqe,Xdx("FolderLunarRestoration_StructRevival_Init: call FolderLunarRestoration_StructRevival.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderLunarRestoration_StructRevival.Event_BuffLose))",jc,MI,function alr))
endfunctionfunction aMr takes nothing returns booleanlocal integer oMxset rUe=Xdx("LunarRestoration_Init: set LunarRestoration.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LunarRestoration.Event_Death)",VP,MI,function aBr)call Lxx(rSe,Xdx("LunarRestoration_Init: call LunarRestoration.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LunarRestoration.Event_BuffGain))",bd,MI,function acr))
call Lxx(rSe,Xdx("LunarRestoration_Init: call LunarRestoration.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LunarRestoration.Event_BuffLose))",jc,MI,function aDr))
call Lxx(rTe,Xdx("LunarRestoration_Init: call LunarRestoration.EFFECT_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LunarRestoration.Event_EffectBuffGain))",bd,MI,function afr))call Lxx(rTe,Xdx("LunarRestoration_Init: call LunarRestoration.EFFECT_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LunarRestoration.Event_EffectBuffLose))",jc,MI,function aFr))call mro(hXv,Xdx("LunarRestoration_Init: call LunarRestoration.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LunarRestoration.Event_Learn))",pv,MI,function agr))set oMx=(m6[(hXv)])loop
exitwhen(oMx<1)set rwe[oMx]=aGr("LunarRestoration_Init: set LunarRestoration.MANA_GAIN_EVENT[iteration] = Event.CreateLimit(UNIT.Mana.DUMMY_EVENT_TYPE, EventPriority.SPELLS, Real.ToInt(LunarRestoration.THIS_SPELL.GetManaCost(iteration)), GREATER_THAN_OR_EQUAL, function LunarRestoration.Event_ManaGain)",mF,MI,(R2I((((CQx((hXv),tH+(oMx))))*1.))),GREATER_THAN_OR_EQUAL,function ahr)set rWe[oMx]=aGr("LunarRestoration_Init: set LunarRestoration.MANA_LOSE_EVENT[iteration] = Event.CreateLimit(UNIT.Mana.DUMMY_EVENT_TYPE, EventPriority.SPELLS, Real.ToInt(LunarRestoration.THIS_SPELL.GetManaCost(iteration)), LESS_THAN, function LunarRestoration.Event_ManaLose)",mF,MI,(R2I((((CQx((hXv),tH+(oMx))))*1.))),LESS_THAN,function aHr)set oMx=oMx-1endloopcall amr()return trueendfunctionfunction apr takes nothing returns booleancall orr(function aMr,"LunarRestoration_Init")return trueendfunctionfunction aPr takes nothing returns booleanset r9e=VXx(ive)
return trueendfunctionfunction aqr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(LoadInteger(o[((V[(E[((X))])]))],(((RK+(((av[(rFx)])))))),(((IK)))))local integer Iixif I9x(Cqx,Qc)thenreturn trueendifset hf=(ze[(Cqx)])set Iix=oIr((GetUnitX(C[((Cqx))])),(GetUnitY(C[((Cqx))])),500.,iee)if(Iix==w)thenreturn trueendifcall Lox((Cqx),(Rh[((Sdv))]),(Iix))return trueendfunctionfunction aQr takes integer oSx,boolean wdo,boolean wDo returns integerlocal boolean asrlocal integer oMx=(CIx(((oSx)),vB))local integer o7x=0local integer Iaxloop
exitwhen(oMx<q)set Iax=(CAx(((oSx)),vB,(oMx)))if not(Ud[(Iax)])thenset asr=(aav[(Iax)])
if((wdo and not asr)or(wDo and asr))then
set o7x=o7x+1endifendifset oMx=oMx-1endloopreturn o7xendfunctionfunction aSr takes nothing returns booleanlocal integer Iix=jhx()if(((oG[(Iix)])>(rG[(Iix)]))and(aQr(Iix,false,true)==0))then
return false
endifif(osx((((Iix))),(Wb+(ixe)))>0)thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction atr takes nothing returns booleanlocal integer FPx=x3r(Sdv,function aqr)set iee=Xpx(function aSr)call x6r(FPx,dTv,HI,w)return trueendfunctionfunction aTr takes nothing returns booleancall e4r(function atr,"AIPurge_Init")return trueendfunctionfunction aur takes nothing returns booleancall L1x('APur',false)set Sdv=L0o('APur')set K6[(Sdv)]=(H6)set m6[(Sdv)]=(1)set TH[(Sdv)]=("Purge")set Rh[(Sdv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D008F)))),(((Aj))))))set oxv[(Sdv)]=(4)set x3v[(Sdv)]=("spell")
call L1o((Sdv),GH+(1),((8)*1.))call L1o((Sdv),tH+(1),((90)*1.))
call L1o((Sdv),Lov+(1),((900)*1.))set MOv[(Sdv)]=("ReplaceableTextures\\CommandButtons\\BTNPurge.blp")
return trueendfunctionfunction aUr takes nothing returns booleanset ixe=Wwx('BPur',"Purge",'bPur')set uU[(ixe)]=(true)
set anv[(ixe)]=("ReplaceableTextures\\CommandButtons\\BTNPurge.blp")
call lWx(ixe,"Abilities\\Spells\\Orc\\Purge\\PurgeBuffTarget.mdl","origin",ri)return trueendfunctionfunction awr takes nothing returns booleancall VNx(Pa,(function aur),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Purge.page\\Purge.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function aUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Purge.page\\Purge.struct\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction aWr takes nothing returns booleanset ioe=VXx(ire)
return trueendfunctionfunction ayr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer aYr=iEe[oSx]local integer azr=ine[oSx]-1
local integer Iix=oSxset ine[oSx]=azr
call ISx(Iix,aYr)call l1x(((aYr)),Ec+(iie),((iOe*(azr*1./ iVe))*1.))call I3x(Iix,aYr)endfunctionfunction aZr takes nothing returns booleanlocal integer rFx=(bv)local real iMx=iaelocal integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer aYr=l_x()local integer a_r=iXx()set ine[oSx]=iVe
set iEe[oSx]=aYr
set iXe[oSx]=a_r
set ge[(a_r)]=(oSx)call l2x(aYr,iie,iOe)call I3x(Iix,aYr)call iDx(a_r,iMx*1./ iVe,true,function ayr)return trueendfunctionfunction a0r takes integer oSx,integer otx returns nothingcall SaveBoolean(o[(((V[(E[((ec[(oSx)]))])])))],(((((xc[((oSx))]))))),((((otx)))),(false))endfunctionfunction a1r takes integer oSx,integer otx returns nothingcall dwx((ec[(oSx)]),((xc[((oSx))])),(otx))endfunctionfunction a2r takes integer oSx returns nothinglocal integer oMx=(IEx(((oSx)),oc))local integer Ibxloop
exitwhen(oMx<q)set Ibx=(IXx(((oSx)),oc,(oMx)))call a0r((oSx),ac+Ibx)set oMx=oMx-1endloopcall a1r((oSx),oc)endfunctionfunction a3r takes integer oSx,integer otx returns nothingcall SaveReal(o[(((V[(E[((ec[(oSx)]))])])))],(((((xc[((oSx))]))))),((((otx)))),((.0)*1.))endfunctionfunction a4r takes integer oSx returns nothinglocal integer oMx=(IEx(((oSx)),nc))local integer Ibxloop
exitwhen(oMx<q)set Ibx=(IXx(((oSx)),nc,(oMx)))call a3r((oSx),Ec+Ibx)set oMx=oMx-1endloopcall a1r((oSx),nc)endfunctionfunction a5r takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer RGx returns nothingcall SaveBoolean(o[(((EO[oSx])))],((Rcx(RCx,Rdx,RDx))),((RFx(RCx,Rgx,RGx))),(false))
endfunctionfunction a6r takes integer oSx,integer Ibx returns nothinglocal integer otx=RMx(X,Oc,oSx,Ibx,w)loop
exitwhen(otx==w)
call a5r(E[((X))],(Ac),(oSx),(Ibx),(otx),(w))set otx=RMx(X,Oc,oSx,Ibx,w)endloopendfunctionfunction a7r takes integer oSx,integer Ibx returns nothinglocal integer otx=RMx(X,Nc,oSx,Ibx,w)loop
exitwhen(otx==w)
call A6x(E[((X))],(bc),(oSx),(Ibx),(otx),(w))set otx=RMx(X,Nc,oSx,Ibx,w)endloopendfunctionfunction a8r takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer RGx returns nothingcall SaveReal(o[(((EO[oSx])))],((Rcx(RCx,Rdx,RDx))),((RFx(RCx,Rgx,RGx))),((.0)*1.))endfunctionfunction a9r takes integer oSx,integer Ibx returns nothinglocal integer otx=RMx(X,Bc,oSx,Ibx,w)loop
exitwhen(otx==w)
call a8r(E[((X))],(cc),(oSx),(Ibx),(otx),(w))set otx=RMx(X,Bc,oSx,Ibx,w)endloopendfunctionfunction nvr takes integer oSx,integer RCx,integer Rdx,integer RDx,integer Rgx,integer RGx returns nothingcall SaveStr(o[(((EO[oSx])))],((Rcx(RCx,Rdx,RDx))),((RFx(RCx,Rgx,RGx))),(null))endfunctionfunction ner takes integer oSx,integer Ibx returns nothinglocal integer otx=RMx(X,Cc,oSx,Ibx,w)loop
exitwhen(otx==w)
call nvr(E[((X))],(dc),(oSx),(Ibx),(otx),(w))set otx=RMx(X,Cc,oSx,Ibx,w)endloopendfunctionfunction nxr takes integer oSx returns nothinglocal integer oMx=IEx((oSx),Xc)local integer Ibxloop
exitwhen(oMx<q)set Ibx=IXx((oSx),Xc,oMx)call a6r(oSx,Ibx)call a7r(oSx,Ibx)call a9r(oSx,Ibx)call ner(oSx,Ibx)set oMx=oMx-1endloopcall a1r((oSx),Xc)endfunctionfunction nor takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((ec[oSx]))])])],((((xc[((oSx))])))))endfunctionfunction nrr takes integer oSx returns nothingset ew[oSx]=falsecall nor((oSx))call rHx(ow)
endfunctionfunction nir takes integer oSx returns nothingif(vw[oSx]>0)thenreturnendifif(zU[oSx]!=Z)thencall o_x("UnitModSet_Allocation_deallocCustom_confirm","call DebugEx(UnitModSet.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",YU+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset zU[oSx]=zU[(w)]set zU[(w)]=oSxcall nrr(oSx)endfunctionfunction nar takes integer oSx returns nothingset vw[oSx]=vw[oSx]-1call nir(oSx)endfunctionfunction nnr takes integer oSx returns nothingcall a2r(oSx)call a4r(oSx)call nxr(oSx)call a1r(((oSx)),fc)
call nar((oSx))endfunctionfunction nVr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer aYr=iEe[oSx]local integer a_r=iXe[oSx]call iKx(a_r)call ISx(Iix,aYr)call nnr(aYr)return trueendfunctionfunction nEr takes integer rYx,integer Iix,real iMx returns nothingif nbo(Iix)thenreturnendifcall wCo(Iix,false,true,true)set iae=iMxcall Nbx((Iix),(ixe),(rYx),w,((iMx)*1.))
endfunctionfunction nXr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local real iMxif I9x(Iix,Wd)thenset iMx=iReelse
set iMx=iIeendifcall nEr(rYx,Iix,iMx)return trueendfunctionfunction nOr takes nothing returns booleanset iie=iwcall Lxx(ixe,Xdx("Purge_Init: call Purge.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Purge.Event_BuffGain))",bd,MI,function aZr))call Lxx(ixe,Xdx("Purge_Init: call Purge.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Purge.Event_BuffLose))",jc,MI,function nVr))call mro(Sdv,Xdx("Purge_Init: call Purge.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Purge.Event_SpellEffect))",ih,MI,function nXr))
return trueendfunctionfunction nRr takes nothing returns booleancall orr(function nOr,"Purge_Init")return trueendfunctionfunction nIr takes nothing returns booleanset iAe=Wwx('BSoP',"Poisoned",'bSoP')set uU[(iAe)]=(true)
set anv[(iAe)]=("ReplaceableTextures\\CommandButtons\\BTNPoisonSting.blp")call lWx(iAe,"Abilities\\Weapons\\PoisonSting\\PoisonStingTarget.mdl","origin",ri)return trueendfunctionfunction nAr takes nothing returns booleancall VNx(ma,(function nIr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\SoakingPoison.page\\SoakingPoison.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction nNr takes nothing returns booleanset iNe=VXx(ibe)
return trueendfunctionfunction nbr takes nothing returns booleanset iBe=ltx(ice+" (dummyBuff)")set WU=l_x()
call l2x(WU,cVv,-20)
call l2x(WU,dmv,-50)
call l3x(((iBe)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,cVv,-40)
call l2x(WU,dmv,-50)
call l3x(((iBe)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,cVv,-60)
call l2x(WU,dmv,-50)
call l3x(((iBe)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,cVv,-80)
call l2x(WU,dmv,-50)
call l3x(((iBe)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,cVv,-'d')call l2x(WU,dmv,-50)
call l3x(((iBe)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,cVv,-'x')call l2x(WU,dmv,-50)
call l3x(((iBe)),ZB+(6),(WU))set iCe[1]=-20set iCe[2]=-40set iCe[3]=-60set iCe[4]=-80set iCe[5]=-'d'set iCe[6]=-'x'set ide[1]=-50set ide[2]=-50set ide[3]=-50set ide[4]=-50set ide[5]=-50set ide[6]=-50return trueendfunctionfunction nBr takes nothing returns booleancall L1x('ASoP',false)set iDe=L0o('ASoP')set K6[(iDe)]=(H6)set m6[(iDe)]=(1)set TH[(iDe)]=("Soaking Poison")
set x3v[(iDe)]=("spell")
call L1o((iDe),Lov+(1),((750)*1.))set MOv[(iDe)]=("ReplaceableTextures\\PassiveButtons\\PASBTNPoisonSting.blp")return trueendfunctionfunction ncr takes nothing returns booleancall VNx(ma,(function nbr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\SoakingPoison.page\\SoakingPoison.struct\\obj_dummyBuff_wc3buff.j"))
call VNx(Pa,(function nBr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\SoakingPoison.page\\SoakingPoison.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction nCr takes nothing returns booleanset ife=VXx(ice)
return trueendfunctionfunction ndr takes integer Iix returns booleanreturn( not(I9x(Iix,Ifv)))and( not(I9x(Iix,Igv)))endfunctionfunction nDr takes integer Cqx,integer rYx,integer Iix returns nothinglocal real iMxif I9x(Iix,Wd)thenset iMx=igeelse
set iMx=iGeendifset ihe=Cqxcall Nbx((Iix),(iAe),(rYx),w,((iMx)*1.))
endfunctionfunction nfr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])if not ndr(Iix)thenreturn trueendifcall nDr((E2v[(rFx)]),(osx((((E2v[(rFx)]))),N+(iDe))),Iix)return trueendfunctionfunction nFr takes nothing returns booleanlocal integer rFx=(bv)call Avx((Vv[(rFx)]),iFe)return trueendfunctionfunction ngr takes nothing returns booleanlocal integer rFx=(bv)call RPx((Vv[(rFx)]),iFe)return trueendfunctionfunction nGr takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(iBe),((Mv[(rFx)])),w)return trueendfunctionfunction nhr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),iBe)return trueendfunctionfunction nHr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxcall nlo((ike[oSx]),(Iix),((iUx(iKe[oSx],(oG[(Iix)])-dG))*1.),(false),(false))endfunctionfunction njr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=ihelocal integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=iXx()set ike[oSx]=Cqx
set iKe[oSx]=iHe
set ile[oSx]=p3x
set ge[(p3x)]=(oSx)call iDx(p3x,iJe,true,function nHr)return trueendfunctionfunction nJr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=ile[oSx]call iKx(p3x)return trueendfunctionfunction nkr takes nothing returns nothingset iHe=ije*iJecall Lxx(iAe,Xdx("FolderSoakingPoison_StructTarget_Init: call FolderSoakingPoison_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSoakingPoison_StructTarget.Event_BuffGain))",bd,MI,function njr))
call Lxx(iAe,Xdx("FolderSoakingPoison_StructTarget_Init: call FolderSoakingPoison_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSoakingPoison_StructTarget.Event_BuffLose))",jc,MI,function nJr))
call W2x(XDv,iAe)endfunctionfunction nKr takes nothing returns booleanset iFe=Xdx("SoakingPoison_Init: set SoakingPoison.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function SoakingPoison.Event_Damage)",E4v,MI,function nfr)call Lxx(iBe,Xdx("SoakingPoison_Init: call SoakingPoison.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoakingPoison.Event_BuffGain))",bd,MI,function nFr))call Lxx(iBe,Xdx("SoakingPoison_Init: call SoakingPoison.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoakingPoison.Event_BuffLose))",jc,MI,function ngr))call mro(iDe,Xdx("SoakingPoison_Init: call SoakingPoison.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoakingPoison.Event_Learn))",pv,MI,function nGr))call mro(iDe,Xdx("SoakingPoison_Init: call SoakingPoison.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoakingPoison.Event_Unlearn))",Av,MI,function nhr))call nkr()return trueendfunctionfunction nlr takes nothing returns booleancall orr(function nKr,"SoakingPoison_Init")return trueendfunctionfunction nLr takes nothing returns booleancall L1x('AStm',false)set SHv=L0o('AStm')set K6[(SHv)]=(H6)set m6[(SHv)]=(1)set TH[(SHv)]=("Stampede")set Rh[(SHv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0271)))),(((Aj))))))set oxv[(SHv)]=(2)set x3v[(SHv)]=("spell")
call L1o((SHv),GH+(1),((8)*1.))call L1o((SHv),tH+(1),((0)*1.))call L1o((SHv),Lov+(1),(($3E8)*1.))set MOv[(SHv)]=("ReplaceableTextures\\CommandButtons\\BTNSmash.blp")
return trueendfunctionfunction nmr takes nothing returns booleanset iLe=ltx(ime+" (dummyBuff)")return trueendfunctionfunction nMr takes nothing returns booleancall VNx(Pa,(function nLr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Stampede.page\\Stampede.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function nmr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Stampede.page\\Stampede.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction npr takes nothing returns booleanset iMe=VXx(ime)
return trueendfunctionfunction nPr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction nqr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=oSxlocal real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local integer Iixlocal real dQoset hf=(ze[(Cqx)])call NVo(iTe,wQo,wso,dox(Cqx,true),iWe)set Iix=NEo(iTe)
if(Iix!=w)thenset dQo=ipe*iYe[oSx]
call Nvo(Noo(wQo,wso,i3e,Bi,i4e*(eb[(Cqx)])))loop
call Ryx((ACx((Iix),(i5e),(i6e),(Bi))))call nlo((Cqx),(Iix),((dQo)*1.),(false),(false))
set Iix=NEo(iTe)
exitwhen(Iix==w)
endloopendifendfunctionfunction nQr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxlocal real N5x=i_e[oSx]+i0e[oSx]
local real N6x=i1e[oSx]+i2e[oSx]
set iYe[oSx]=iYe[oSx]+ize[oSx]set i_e[oSx]=N5x
set i1e[oSx]=N6x
call B6o(Iix,N5x)call B7o(Iix,N6x)endfunctionfunction nsr takes nothing returns booleanlocal integer rFx=(bv)local integer nSr=(Lc[(rFx)])local integer Iix=(Vv[(rFx)])local real dVx=(yH[(nSr)])local real dEx=(YH[(nSr)])local real bex=Ufx(Iix,dVx-(GetUnitX(C[((Iix))])),dEx-(GetUnitY(C[((Iix))])))local integer oSx=Iixlocal integer p3x=iXx()local integer Q9o=iXx()local real I2o=(Cos(((((bex)*1.))*1.)))local real I3o=(Sin(((((bex)*1.))*1.)))set iye[oSx]=p3x
set iYe[oSx]=ise
set ize[oSx]=iSe*iUe
set iZe[oSx]=Q9o
set i_e[oSx]=iue*I2o
set i0e[oSx]=iwe*I2o
set i1e[oSx]=iue*I3o
set i2e[oSx]=iwe*I3o
set ge[(p3x)]=(oSx)set ge[(Q9o)]=(oSx)call iDx(p3x,iqe,true,function nqr)call iDx(Q9o,iUe,true,function nQr)return trueendfunctionfunction ntr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=iye[oSx]local integer Q9o=iZe[oSx]call iKx(p3x)call iKx(Q9o)return trueendfunctionfunction nTr takes nothing returns booleanlocal integer rFx=(bv)call Nbx((Vv[(rFx)]),iLe,(Mv[(rFx)]),rFx,iQe)return trueendfunctionfunction nur takes nothing returns booleanset ipe=iPe*iqeset iQe=-ise*1./ iSe+(SquareRoot(((ise*ise*1./ iSe*1./ iSe+2*ite*1./ iSe)*1.)))set iTe=O5x()set iue=ise*iUeset iwe=iSe*iUe*iUeset iWe=Xpx(function nPr)call Lxx(iLe,Xdx("Stampede_Init: call Stampede.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Stampede.Event_BuffGain))",bd,MI,function nsr))
call Lxx(iLe,Xdx("Stampede_Init: call Stampede.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Stampede.Event_BuffLose))",jc,MI,function ntr))
call mro(SHv,Xdx("Stampede_Init: call Stampede.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Stampede.Event_SpellEffect))",ih,MI,function nTr))return trueendfunctionfunction nUr takes nothing returns booleancall orr(function nur,"Stampede_Init")return trueendfunctionfunction nwr takes nothing returns booleanset i7e=VXx(i8e)
return trueendfunctionfunction nWr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(LoadInteger(o[((V[(E[((X))])]))],(((RK+(((av[(rFx)])))))),(((IK)))))if I9x(Cqx,Qc)thenreturn trueendifset hf=(ze[(Cqx)])call NVo(i9e,(GetUnitX(C[((Cqx))])),(GetUnitY(C[((Cqx))])),(CQx((Gvv),Uvv+((osx(((Cqx)),N+(Gvv)))))),ave)if((NIo((i9e)))<2)thenreturn trueendifcall Rxx((Cqx),(Rh[((Gvv))]))return trueendfunctionfunction nyr takes nothing returns booleanlocal integer FPx=x3r(Gvv,function nWr)call oFr(FPx,5.)
return trueendfunctionfunction nYr takes nothing returns booleancall e4r(function nyr,"AIStomp_Init")return trueendfunctionfunction nzr takes nothing returns booleancall L1x('AStp',false)set Gvv=L0o('AStp')set K6[(Gvv)]=(H6)set m6[(Gvv)]=(1)set TH[(Gvv)]=("Stomp")set Rh[(Gvv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00C4)))),(((Aj))))))set oxv[(Gvv)]=(0)set x3v[(Gvv)]=("spell")
call L1o((Gvv),Uvv+(1),((400)*1.))call L1o((Gvv),dH+(1),((.5)*1.))
call L1o((Gvv),GH+(1),(($A)*1.))
call L1o((Gvv),tH+(1),((40)*1.))
call L1o((Gvv),Lov+(1),((750)*1.))set MOv[(Gvv)]=("ReplaceableTextures\\CommandButtons\\BTNWarStomp.blp")return trueendfunctionfunction nZr takes nothing returns booleancall VNx(Pa,(function nzr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act1\\Stomp.page\\Stomp.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction n_r takes nothing returns booleanset aee=VXx(axe)
return trueendfunctionfunction n0r takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction n1r takes integer oSx returns nothinglocal real DJo=1.local real I4o=250.*32.*1./(16.+dox((oSx),true))
local real n2r=-8*I4o*1./ DJo*1./ DJolocal real Nlx=-n2r*1./ 2*DJocall cVo((oSx),.0,.0,Nlx,.0,.0,n2r,DJo)endfunctionfunction n3r takes nothing returns booleanlocal integer rFx=(bv)call n1r((Vv[(rFx)]))return trueendfunctionfunction n4r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local integer Iixcall mho((mko(((wQo)*1.),((wso)*1.),(aoe),(ri))))set hf=(ze[(Cqx)])call NVo(i9e,wQo,wso,(CQx((Gvv),Uvv+(rYx))),ave)
set Iix=NEo(i9e)
if(Iix!=w)thenloop
call Nbx((Iix),(Xwv),(rYx),w,((are)*1.))
call nlo((Cqx),(Iix),((aie)*1.),(false),(false))
set Iix=NEo(i9e)
exitwhen(Iix==w)
endloopendifreturn trueendfunctionfunction n5r takes nothing returns booleanset i9e=O5x()set ave=Xpx(function n0r)call mro(Gvv,Xdx("Stomp_Init: call Stomp.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Stomp.Event_SpellEffect))",ih,MI,function n3r))
call mro(Gvv,Xdx("Stomp_Init: call Stomp.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.SUCCESS_EVENT_TYPE, EventPriority.SPELLS, function Stomp.Event_EndCast))",oVv,MI,function n4r))return trueendfunctionfunction n6r takes nothing returns booleancall orr(function n5r,"Stomp_Init")return trueendfunctionfunction n7r takes nothing returns booleanlocal integer rFx=(bv)local integer IQx=(Fc[(rFx)])call fsx(((Vv[(rFx)])),chv[(IQx)],cHv[(IQx)],cjv[(IQx)],cJv[(IQx)],ckv[(IQx)])return trueendfunctionfunction n8r takes nothing returns booleanlocal integer rFx=(bv)local integer IQx=(Fc[(rFx)])call fsx((((Vv[(rFx)]))),-((chv[(IQx)])*1.),-((cHv[(IQx)])*1.),-((cjv[(IQx)])*1.),-((cJv[(IQx)])*1.),((ckv[(IQx)])*1.))return trueendfunctionfunction n9r takes integer oSx,real izx,real iZx,real i_x,real i0x,real iMx returns integerlocal integer IQx=rUo(cGv,function n7r,function n8r)
set chv[(IQx)]=izxset cHv[(IQx)]=iZxset cjv[(IQx)]=i_xset cJv[(IQx)]=i0xset ckv[(IQx)]=iMxreturn IQxendfunctionfunction Vvr takes nothing returns booleanset aae=ltx(ane+" (dummyBuff)")set WU=l_x()
call l0x(((WU)),fc,(n9r(db,0,0,0,0,2)))call l3x(((aae)),ZB+(1),(WU))return trueendfunctionfunction Ver takes nothing returns booleancall L1x('ABag',false)set Gtv=L0o('ABag')set K6[(Gtv)]=(H6)set m6[(Gtv)]=(1)set TH[(Gtv)]=("Barrage")set Rh[(Gtv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D007F)))),(((Aj))))))set oxv[(Gtv)]=(4)set x3v[(Gtv)]=("spell")
call L1o((Gtv),Uvv+(1),(($FA)*1.))call L1o((Gtv),dH+(1),((5)*1.))call L1o((Gtv),GH+(1),(($C)*1.))
call L1o((Gtv),tH+(1),((80)*1.))
call L1o((Gtv),Lov+(1),((700)*1.))set MOv[(Gtv)]=("ReplaceableTextures\\CommandButtons\\BTNFlakCannons.blp")return trueendfunctionfunction Vxr takes nothing returns booleancall VNx(ma,(function Vvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\Barrage.page\\Barrage.struct\\obj_dummyBuff_wc3buff.j"))
call VNx(Pa,(function Ver),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\Barrage.page\\Barrage.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Vor takes nothing returns booleanset aVe=VXx(ane)
return trueendfunctionfunction Vrr takes code c,string rSx returns nothing
set Jn=Jn+1set kn[Jn]=CreateTrigger()set Kn[Jn]=(GetHandleId(Condition((c))))
set ln[Jn]=rSxcall TriggerAddCondition(kn[Jn],Condition(c))endfunctionfunction Vir takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif((sYv[(pe)]<sYv[(SLv)]))thenif I9x(Iix,Igv)thenreturn false
endifendifreturn truereturn trueendfunctionfunction Var takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=oSxlocal real bex=(GetUnitFacing(C[((Cqx))])*Nh)local integer Iixcall SetUnitAnimation(C[((Cqx))],("attack"))
set hf=(ze[(Cqx)])call NVo(aRe,(GetUnitX(C[((Cqx))]))+abe*(Cos(((((bex)*1.))*1.))),(GetUnitY(C[((Cqx))]))+abe*(Sin(((((bex)*1.))*1.))),aAe[oSx],aIe)set Iix=NEo(aRe)
if(Iix!=w)thenloop
call nlo((Cqx),(Iix),((aEe)*1.),(false),(false))
set Iix=NEo(aRe)
exitwhen(Iix==w)
endloopendifendfunctionfunction Vnr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=iXx()set aAe[oSx]=(CQx((Gtv),Uvv+(rYx)))set aNe[oSx]=p3x
set ge[(p3x)]=(oSx)call iDx(p3x,aOe,true,function Var)return trueendfunctionfunction VVr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=aNe[oSx]call iKx(p3x)return trueendfunctionfunction VEr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),aae)return trueendfunctionfunction VXr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])call fzx(Cqx,(yH[(rFx)]),(YH[(rFx)]))call Dux((Cqx),(aae),((Mv[(rFx)])),w)return trueendfunctionfunction VOr takes nothing returns booleanset aEe=aXe*aOeset aRe=O5x()set aIe=Xpx(function Vir)call Lxx(aae,Xdx("Barrage_Init: call Barrage.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Barrage.Event_BuffGain))",bd,MI,function Vnr))call Lxx(aae,Xdx("Barrage_Init: call Barrage.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Barrage.Event_BuffLose))",jc,MI,function VVr))call mro(Gtv,Xdx("Barrage_Init: call Barrage.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Barrage.Event_EndCast))",onv,MI,function VEr))call mro(Gtv,Xdx("Barrage_Init: call Barrage.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Barrage.Event_SpellEffect))",ih,MI,function VXr))return trueendfunctionfunction VRr takes nothing returns booleancall Vrr(function VOr,"Barrage_Init")return trueendfunctionfunction VIr takes nothing returns booleanset aBe=VXx(ace)
return trueendfunctionfunction VAr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(LoadInteger(o[((V[(E[((X))])]))],(((RK+(((av[(rFx)])))))),(((IK)))))local integer Iixif I9x(Cqx,Qc)thenreturn trueendifset hf=(ze[(Cqx)])set Iix=oIr((GetUnitX(C[((Cqx))])),(GetUnitY(C[((Cqx))])),500.,aCe)if(Iix==w)thenreturn trueendifcall CBx((Cqx),(Rh[((Slv))]),(((GetUnitX(C[((Iix))])))*1.),(((GetUnitY(C[((Iix))])))*1.))return trueendfunctionfunction VNr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction Vbr takes nothing returns booleanlocal integer FPx=x3r(Slv,function VAr)set aCe=Xpx(function VNr)call x6r(FPx,dTv,HI,w)return trueendfunctionfunction VBr takes nothing returns booleancall e4r(function Vbr,"AIBouncyBomb_Init")return trueendfunctionfunction Vcr takes nothing returns booleancall L1x('ABoB',false)set Slv=L0o('ABoB')set K6[(Slv)]=(H6)set m6[(Slv)]=(1)set TH[(Slv)]=("Bouncy Bomb")set Rh[(Slv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0107)))),(((Aj))))))set oxv[(Slv)]=(2)set x3v[(Slv)]=("spell")
call L1o((Slv),Uvv+(1),(('d')*1.))call L1o((Slv),GH+(1),(($A)*1.))
call L1o((Slv),tH+(1),((25)*1.))
call L1o((Slv),Lov+(1),((600)*1.))set MOv[(Slv)]=("ReplaceableTextures\\CommandButtons\\BTNHealthStone.blp")return trueendfunctionfunction VCr takes nothing returns booleancall VNx(Pa,(function Vcr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\BouncyBomb.page\\BouncyBomb.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Vdr takes nothing returns booleanset ade=VXx(aDe)
return trueendfunctionfunction VDr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction Vfr takes integer oSx returns integerset aLe[oSx]=trueset ame[oSx]=falsecall rEx(ade)return oSxendfunctionfunction VFr takes nothing returns integerlocal integer oSxif(aJe==8190)thencall o_x("BouncyBomb_Allocation_allocCustom","call DebugEx(BouncyBomb.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",aDe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(ake[(w)]==w)thenset aKe=aKe+1set oSx=aKeelse
set oSx=ake[(w)]
set ake[(w)]=ake[ake[(w)]]endifset ake[oSx]=Zset ale[oSx]=1call Vfr(oSx)return oSxendfunctionfunction Vgr takes integer oSx,real x,real y,real z returns nothingcall MLo(oSx,(iJ[(oSx)])+x,(EJ[(oSx)])+y,(Au[(oSx)])+z)endfunctionfunction VGr takes integer oSx returns realreturn(Au[oSx]-X_x((iJ[((oSx))]),(EJ[((oSx))])))
endfunctionfunction Vhr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer HAx=aPe[oSx]local real cNx=aUe[oSx]+aHecall Vgr(HAx,aTe[oSx],aue[oSx],cNx)if(VGr(HAx)<awe)then
set aUe[oSx]=byx(cNx)else
set aUe[oSx]=cNx
endifendfunctionfunction VHr takes integer oSx returns nothingset aLe[oSx]=falsecall rHx(ade)endfunctionfunction Vjr takes integer oSx returns nothingif(ale[oSx]>0)thenreturnendifif(ake[oSx]!=Z)thencall o_x("BouncyBomb_Allocation_deallocCustom_confirm","call DebugEx(BouncyBomb.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",aDe+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset ake[oSx]=ake[(w)]set ake[(w)]=oSx
call VHr(oSx)endfunctionfunction VJr takes integer oSx returns nothingset ale[oSx]=ale[oSx]-1call Vjr(oSx)endfunctionfunction Vkr takes real x,real y,real z,string ANx,integer rYx returns integerlocal destructable g9x=CreateDestructableZ('cEfL',x,y,z,.0,1.,0)
local integer oSx=mko(x,y,ANx,rYx)call RemoveDestructable(g9x)
set g9x=null
return oSxendfunctionfunction VKr takes integer oSx,real x,real y,real z,real Jex,integer Q7x returns nothing
if(Q7x==w)thenset Q7x=GKendifset Q7x=Nao(MQ,Q7x)set qQ=Jexset pQ=x
set PQ=y
set sQ=z
call Nno((oSx),x,y,Jex+BZv,Q7x)endfunctionfunction Vlr takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local integer Cqx=ape[oSx]local integer HAx=aPe[oSx]local integer Q9o=aSe[oSx]local integer Ctx=ate[oSx]local integer rYx=(IH[(Ctx)])local real x=(iJ[(HAx)])
local real y=(EJ[(HAx)])
local real z=(Au[(HAx)])
local integer Iixlocal real VLrlocal real Nbocall VJr((oSx))call MGx(HAx)call iKx(iCx)call iKx(Q9o)call mho((Vkr(((x)*1.),((y)*1.),((z)*1.),(aWe),(ri))))set hf=(ze[(Cqx)])call VKr(afe,x,y,z,(CQx((Slv),Uvv+(rYx))),aFe)set Iix=NEo(afe)
if(Iix!=w)thenset VLr=ayeloop
set Nbo=iUx(aYe,VLr)
set VLr=VLr-Nbocall nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))set Iix=NEo(afe)
exitwhen(Iix==w)
endloopendifcall dNx(Ctx)endfunctionfunction Vmr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local integer oSx=VFr()local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real VMr=fYx(Cqx)+Opx(Cqx,true)local integer iCx=iXx()local integer Q9o=iXx()local integer Ctx=CPx(Cqx,Slv)local real dX=dVx-(GetUnitX(C[((Cqx))]))
local real dY=dEx-(GetUnitY(C[((Cqx))]))
local real bex=Ufx(Cqx,dX,dY)local real d=jKx(dX,dY)local integer HAx=mDx('qByB',wQo,wso,VMr,bex)local real Vpr=d*1./ age
local real VPr=Vpr*(Cos(((((bex)*1.))*1.)))local real Vqr=Vpr*(Sin(((((bex)*1.))*1.)))local real VQr=((X_x(dVx,dEx)-VMr)*1./ aMe-aje*1./ 2*aMe)*aheset ape[oSx]=Cqx
set aPe[oSx]=HAx
set aqe[oSx]=gHx(VPr,Vqr,VQr)set aQe[oSx]=dVx
set ase[oSx]=dEx
set aSe[oSx]=Q9o
set ate[oSx]=Ctx
set aTe[oSx]=VPr
set aue[oSx]=Vqr
set aUe[oSx]=VQr
set ge[(iCx)]=(oSx)set ge[(Q9o)]=(oSx)call iDx(Q9o,ahe,true,function Vhr)call iDx(iCx,aGe,false,function Vlr)
return trueendfunctionfunction Vsr takes nothing returns booleanset afe=O5x()set aFe=Xpx(function VDr)set age=(R2I(((aGe*1./ ahe)*1.)))set aHe=aje*ahe*ahecall mro(Slv,Xdx("BouncyBomb_Init: call BouncyBomb.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BouncyBomb.Event_SpellEffect))",ih,MI,function Vmr))return trueendfunctionfunction VSr takes nothing returns booleancall Vrr(function Vsr,"BouncyBomb_Init")
return trueendfunctionfunction Vtr takes nothing returns booleancall L1x('ABuO',false)set SKv=L0o('ABuO')set K6[(SKv)]=(H6)set m6[(SKv)]=(1)set TH[(SKv)]=("Burning Oil")set x3v[(SKv)]=("spell")
call L1o((SKv),Uvv+(1),(($8C)*1.))call L1o((SKv),Lov+(1),((750)*1.))set MOv[(SKv)]=("ReplaceableTextures\\PassiveButtons\\PASBTNFireRocks.blp")return trueendfunctionfunction VTr takes nothing returns booleancall L1x('ABuX',false)return trueendfunctionfunction Vur takes nothing returns booleanset aze=ltx(aZe+" (dummyBuff)")return trueendfunctionfunction VUr takes nothing returns booleancall VNx(Pa,(function Vtr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\BurningOil.page\\BurningOil.struct\\obj_thisSpell_wc3spell.j"))call VNx(Pa,(function VTr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\BurningOil.page\\BurningOil.struct\\obj_missileGraphicSpell_wc3spell.j"))call VNx(ma,(function Vur),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\BurningOil.page\\BurningOil.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction Vwr takes nothing returns booleanset a_e=VXx(aZe)
return trueendfunctionfunction VWr takes integer oSx returns integerset a9e[oSx]=trueset nve[oSx]=falsecall rEx(a_e)return oSxendfunctionfunction Vyr takes nothing returns integerlocal integer oSxif(a5e==8190)thencall o_x("BurningOil_Allocation_allocCustom","call DebugEx(BurningOil.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",aZe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(a6e[(w)]==w)thenset a7e=a7e+1set oSx=a7eelse
set oSx=a6e[(w)]
set a6e[(w)]=a6e[a6e[(w)]]endifset a6e[oSx]=Zset a8e[oSx]=1call VWr(oSx)return oSxendfunctionfunction VYr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=nee[oSx]local integer Iixset hf=(ze[(Cqx)])call NVo(a3e,nae[oSx],nne[oSx],(CQx((SKv),Uvv+(noe[oSx]))),nVe)set Iix=NEo(a3e)
if(Iix!=w)thenloop
call nlo((Cqx),(Iix),((a0e)*1.),(false),(false))
set Iix=NEo(a3e)
exitwhen(Iix==w)
endloopendifendfunctionfunction Vzr takes integer oSx returns nothingset a9e[oSx]=falsecall rHx(a_e)endfunctionfunction VZr takes integer oSx returns nothingif(a8e[oSx]>0)thenreturnendifif(a6e[oSx]!=Z)thencall o_x("BurningOil_Allocation_deallocCustom_confirm","call DebugEx(BurningOil.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",aZe+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset a6e[oSx]=a6e[(w)]set a6e[(w)]=oSx
call Vzr(oSx)endfunctionfunction V_r takes integer oSx returns nothingset a8e[oSx]=a8e[oSx]-1call VZr(oSx)endfunctionfunction V0r takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local integer p3x=nxe[oSx]local integer aLr=nre[oSx]call V_r((oSx))call iKx(iCx)call iKx(p3x)call mho(aLr)endfunctionfunction V1r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local integer rYx=(osx(((Cqx)),N+(SKv)))
local integer oSx=Vyr()local integer iCx=iXx()local integer p3x=iXx()set nee[oSx]=Cqx
set nxe[oSx]=p3x
set noe[oSx]=rYx
set nre[oSx]=(mko(((dVx)*1.),((dEx)*1.),(nie),(ri)))
set nae[oSx]=dVx
set nne[oSx]=dEx
set ge[(iCx)]=(oSx)set ge[(p3x)]=(oSx)call iDx(p3x,a2e,true,function VYr)call iDx(iCx,nEe,false,function V0r)
return trueendfunctionfunction V2r takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction V3r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])call Avx(Iix,a4e)call rtx(Iix,'ABuX')
return trueendfunctionfunction V4r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])call RPx(Iix,a4e)call UnitRemoveAbility(C[((Iix))],('ABuX'))return trueendfunctionfunction V5r takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(aze),((Mv[(rFx)])),w)return trueendfunctionfunction V6r takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),aze)return trueendfunctionfunction V7r takes nothing returns booleanset a0e=a1e*a2eset a3e=O5x()set a4e=Xdx("BurningOil_Init: set BurningOil.GROUND_ATTACK_EVENT = Event.Create(UNIT.Attack.Events.Ground.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BurningOil.Event_GroundAttack)",d3v,MI,function V1r)set nVe=Xpx(function V2r)call Lxx(aze,Xdx("BurningOil_Init: call BurningOil.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BurningOil.Event_BuffGain))",bd,MI,function V3r))call Lxx(aze,Xdx("BurningOil_Init: call BurningOil.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BurningOil.Event_BuffLose))",jc,MI,function V4r))call mro(SKv,Xdx("BurningOil_Init: call BurningOil.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BurningOil.Event_Learn))",pv,MI,function V5r))
call mro(SKv,Xdx("BurningOil_Init: call BurningOil.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BurningOil.Event_Unlearn))",Av,MI,function V6r))
return trueendfunctionfunction V8r takes nothing returns booleancall Vrr(function V7r,"BurningOil_Init")
return trueendfunctionfunction V9r takes nothing returns booleanset nXe=VCx("OChP")return trueendfunctionfunction Evr takes nothing returns booleancall L1x('AChL',false)set GQv=L0o('AChL')set K6[(GQv)]=(H6)set m6[(GQv)]=(1)set TH[(GQv)]=("Chain Lightning")set Rh[(GQv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0097)))),(((Aj))))))set oxv[(GQv)]=(4)set x3v[(GQv)]=("spell")
call L1o((GQv),Uvv+(1),((500)*1.))call L1o((GQv),GH+(1),(($F)*1.))
call L1o((GQv),tH+(1),((95)*1.))
call L1o((GQv),Lov+(1),((550)*1.))set MOv[(GQv)]=("ReplaceableTextures\\CommandButtons\\BTNChainLightning.blp")return trueendfunctionfunction Eer takes nothing returns booleanset nOe=VCx("OChS")return trueendfunctionfunction Exr takes nothing returns booleancall VNx(ha,(function V9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\ChainLightning.page\\ChainLightning.struct\\obj_boltPrimary_wc3bolt.j"))
call VNx(Pa,(function Evr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\ChainLightning.page\\ChainLightning.struct\\obj_thisSpell_wc3spell.j"))call VNx(ha,(function Eer),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\ChainLightning.page\\ChainLightning.struct\\obj_boltSecondary_wc3bolt.j"))return trueendfunctionfunction Eor takes nothing returns booleanset nRe=VXx(nIe)
return trueendfunctionfunction Err takes integer Iix returns booleanreturn( not(I9x(Iix,Qc)))and( not(I9x(Iix,Ifv)))and( not(IsUnitAlly(C[(Iix)],vx[(hf)])))and( not(nbo(Iix)))endfunctionfunction Eir takes nothing returns booleanlocal integer Iix=jhx()if LLo(nbe,Iix)thenreturn false
endifif not Err(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction Ear takes integer oSx returns integerset nDe[oSx]=trueset nfe[oSx]=falsecall rEx(nRe)return oSxendfunctionfunction Enr takes nothing returns integerlocal integer oSxif(nBe==8190)thencall o_x("ChainLightning_Allocation_allocCustom","call DebugEx(ChainLightning.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",nIe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(nce[(w)]==w)thenset nCe=nCe+1set oSx=nCeelse
set oSx=nce[(w)]
set nce[(w)]=nce[nce[(w)]]endifset nce[oSx]=Zset nde[oSx]=1call Ear(oSx)return oSxendfunctionfunction EVr takes integer oSx returns integerset EU[oSx]=true
set nqe[oSx]=falsecall rEx(Wt)
return oSxendfunctionfunction EEr takes nothing returns integerlocal integer oSxif(npe==8190)thencall o_x("FolderLightning_StructFromUnitToUnit_Allocation_allocCustom","call DebugEx(FolderLightning_StructFromUnitToUnit.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",yt+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(VU[(w)]==w)thenset nPe=nPe+1set oSx=nPeelse
set oSx=VU[(w)]set VU[(w)]=VU[VU[(w)]]endifset VU[oSx]=Zset nU[oSx]=1call EVr(oSx)return oSxendfunctionfunction EXr takes integer oSx returns booleanset NU=NU+1set AU[NU]=oSxset IU[oSx]=NU+1
return(NU==0)endfunctionfunction EOr takes nothing returns nothinglocal integer oMx=NU
local integer oSxlocal integer o0xlocal integer Iixlocal real jMxlocal real jpxlocal real cJolocal real dVxlocal real dExlocal real MQxloop
set oSx=AU[oMx]set o0x=BU[oSx]set Iix=cU[oSx]if(o0x==w)thenset jMx=dU[oSx]set jpx=DU[oSx]set cJo=fU[oSx]else
set jMx=Dsx(o0x)
set jpx=Dtx(o0x)
set cJo=OMx(o0x,jMx,jpx)+Opx(o0x,true)endifif(Iix==w)thenset dVx=FU[oSx]set dEx=gU[oSx]set MQx=GU[oSx]else
set dVx=Dsx(Iix)
set dEx=Dtx(Iix)
set MQx=OMx(Iix,dVx,dEx)+K2x(Iix,true)endifcall cGo(CU[oSx],jMx,jpx,cJo,dVx,dEx,MQx)set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction ERr takes integer oSx,integer o0x,integer Iix returns nothinglocal integer rLx=oSxlocal real jMx=Dsx(o0x)local real jpx=Dtx(o0x)local real dVx=Dsx(Iix)local real dEx=Dtx(Iix)call cDo(rLx)set oSx=EEr()set CU[oSx]=rLxset BU[oSx]=o0xset cU[oSx]=Iixcall cgo(rLx,aU,oSx)
call KSx(rLx,rU)
if rUx(o0x,OU,oSx)thencall Avx(o0x,RU)
call A_o(o0x)endifif rUx(Iix,OU,oSx)thencall Avx(Iix,RU)
call A_o(Iix)endifcall cGo(rLx,Dsx(o0x),Dtx(o0x),OMx(o0x,jMx,jpx)+Opx(o0x,true),dVx,dEx,OMx(Iix,dVx,dEx)+K2x(Iix,true))if EXr(oSx)thencall iDx(bU,nQe,true,function EOr)endifendfunctionfunction EIr takes integer oSx returns nothingset nDe[oSx]=falsecall rHx(nRe)endfunctionfunction EAr takes integer oSx returns nothingif(nde[oSx]>0)thenreturnendifif(nce[oSx]!=Z)thencall o_x("ChainLightning_Allocation_deallocCustom_confirm","call DebugEx(ChainLightning.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",nIe+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset nce[oSx]=nce[(w)]set nce[(w)]=oSx
call EIr(oSx)endfunctionfunction ENr takes integer oSx returns nothingset nde[oSx]=nde[oSx]-1call EAr(oSx)endfunctionfunction Ebr takes integer oSx,integer svo returns nothingcall ENr((oSx))call O9x(svo)endfunctionfunction EBr takes integer oSx,integer Ecr,integer ECr,integer Iix,integer svo returns nothingset Od=oSxset Rd=Ecrset Id=ECrset Ad=Iixset nte=svocall TriggerEvaluate(nTe)endfunctionfunction Edr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=nge[oSx]local integer EDr=nke[oSx]local integer Efr=nLe[oSx]local integer Iix=nMe[oSx]local integer svo=nle[oSx]local real Nbolocal real dVxlocal real dExlocal integer EFrif(Iix!=w)thencall Ryx((ACx((Iix),(nse),(nSe),(Bi))))set hf=(ze[(Cqx)])if(Err(Iix))then
set Nbo=nGe[oSx]
set nGe[oSx]=Nbo*(1.-nHe[oSx])call nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))endifendifif(Efr==EDr)then
call Ebr(oSx,svo)else
set dVx=(GetUnitX(C[((Iix))]))set dEx=(GetUnitY(C[((Iix))]))set nbe=svoset hf=(ze[(Cqx)])call NVo(nAe,dVx,dEx,nFe[oSx],nNe)set EFr=(mKo((nAe),((dVx)*1.),((dEx)*1.)))if(EFr==w)thencall Ebr(oSx,svo)else
set nLe[oSx]=Efr+1call EBr(oSx,nOe,Iix,EFr,svo)endifendifcall MFo(Mho)return trueendfunctionfunction Egr takes integer oSx,integer Ecr,integer ECr,integer Iix,integer svo returns nothinglocal integer Mho=Moo()local integer cMo=cdo(Ecr)set nme[oSx]=Mho
set nMe[oSx]=Iix
call ERr(cMo,ECr,Iix)call GroupAddUnit(kb[(svo)],C[(Iix)])call cLo(cMo,.75)set mCv[(Mho)]=((10.)*1.)set mFv[(Mho)]=Xkx((function Edr))set mZv[(Mho)]=(oSx)
call Meo(Mho,iAx(jKx((GetUnitX(C[((Iix))]))-(GetUnitX(C[((ECr))])),(GetUnitY(C[((Iix))]))-(GetUnitY(C[((ECr))])))*1./ .25,700.))
call pxo(Mho,ECr)call M6o((Mho),(Iix),.0,.0,.0,(null))endfunctionfunction EGr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local integer oSx=Enr()local integer svo=O5x()set nFe[oSx]=(CQx((GQv),Uvv+(rYx)))set nge[oSx]=Cqx
set nGe[oSx]=nhe
set nHe[oSx]=nje
set nJe[oSx]=rYx
set nke[oSx]=nKe
set nle[oSx]=svo
set nLe[oSx]=1call Egr(oSx,nXe,Cqx,Iix,svo)return trueendfunctionfunction Ehr takes nothing returns booleanset nAe=O5x()set nNe=Xpx(function Eir)call mro(GQv,Xdx("ChainLightning_Init: call ChainLightning.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ChainLightning.Event_SpellEffect))",ih,MI,function EGr))return trueendfunctionfunction EHr takes nothing returns booleancall Vrr(function Ehr,"ChainLightning_Init")
return trueendfunctionfunction Ejr takes nothing returns booleanset nue=VXx(nUe)
return trueendfunctionfunction EJr takes nothing returns booleanset nwe=VXx(nWe)
return trueendfunctionfunction Ekr takes nothing returns booleanset nye=VXx(nYe)
return trueendfunctionfunction EKr takes nothing returns booleanset nze=VXx(nZe)
return trueendfunctionfunction Elr takes nothing returns booleanreturn trueendfunctionfunction ELr takes nothing returns booleanset n_e=VXx(n0e)
return trueendfunctionfunction Emr takes nothing returns booleancall L1x('AClv',false)set Sgv=L0o('AClv')set K6[(Sgv)]=(H6)set m6[(Sgv)]=(1)set TH[(Sgv)]=("Cleaver")set Rh[(Sgv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0089)))),(((Aj))))))set oxv[(Sgv)]=(2)set x3v[(Sgv)]=("spell")
call L1o((Sgv),GH+(1),((7)*1.))call L1o((Sgv),tH+(1),((60)*1.))
call L1o((Sgv),Lov+(1),((750)*1.))set MOv[(Sgv)]=("ReplaceableTextures\\CommandButtons\\BTNShockWave.blp")
return trueendfunctionfunction EMr takes nothing returns booleancall VNx(Pa,(function Emr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\Cleaver.page\\Cleaver.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Epr takes nothing returns booleanset n1e=VXx(n2e)
return trueendfunctionfunction EPr takes integer oSx returns integerset n3e[oSx]=trueset n4e[oSx]=falseset n5e[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set n6e[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(n1e)return oSxendfunctionfunction Eqr takes integer oSx returns nothingset Vre[(oSx)]=(Vie+oSx)
endfunctionfunction EQr takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((n5e[(oSx)]))])]))],((((Vre[((oSx))])))),(((otx))))))endfunctionfunction Esr takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((n5e[(oSx)]))])]))],((((Vre[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction ESr takes integer oSx returns nothinglocal integer rLx=oSxlocal integer oMx=EQr(rLx,Vne)local integer Cqxlocal integer rYxlocal real VLrlocal integer svolocal integer C3olocal integer Iixlocal real Nboif(oMx<q)thenreturnendifset Cqx=n7e[rLx]
set rYx=n9e[rLx]
set VLr=Vve[rLx]
set svo=Vxe[rLx]
set C3o=(ze[(Cqx)])loop
set oSx=Esr(rLx,Vne,oMx)
set nbe=svoset hf=C3ocall NVo(VVe,VEe[oSx],VXe[oSx],VOe,VRe)set Iix=NEo(VVe)
if(Iix!=w)thenloop
call GroupAddUnit(kb[(svo)],C[(Iix)])if not nbo(Iix)thenset Nbo=iUx(VIe,VLr)
set VLr=VLr-Nbocall nlo((Cqx),(Iix),((Nbo)*1.),(false),(false))
endifset Iix=NEo(VVe)
exitwhen(Iix==w)
endloopendifset oMx=oMx-1exitwhen(oMx<q)endloopset Vve[rLx]=VLr
endfunctionfunction Etr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])call ESr(oSx)endfunctionfunction ETr takes integer oSx returns nothinglocal integer rLx=oSxlocal integer oMx=EQr(rLx,Vne)local real x
local real y
if(oMx<q)thenreturnendifloop
set oSx=Esr(rLx,Vne,oMx)
set x=VEe[oSx]+VNe[oSx]set y=VXe[oSx]+Vbe[oSx]set VEe[oSx]=xset VXe[oSx]=ycall Q1o(VBe[oSx],x,y)set oMx=oMx-1exitwhen(oMx<q)endloopendfunctionfunction Eur takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])call ETr(oSx)endfunctionfunction EUr takes integer oSx returns nothingset VDe[oSx]=falsecall rHx(n_e)endfunctionfunction Ewr takes integer oSx returns nothingif(VCe[oSx]>0)thenreturnendifif(Vde[oSx]!=Z)thencall o_x("FolderCleaver_StructWave_Allocation_deallocCustom_confirm","call DebugEx(FolderCleaver_StructWave.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",n0e+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset Vde[oSx]=Vde[(w)]set Vde[(w)]=oSx
call EUr(oSx)endfunctionfunction EWr takes integer oSx returns nothingset VCe[oSx]=VCe[oSx]-1call Ewr(oSx)endfunctionfunction Eyr takes integer oSx,integer otx,integer oux returns booleanreturn rrx(n5e[(oSx)],(Vre[((oSx))]),otx,oux)endfunctionfunction EYr takes integer oSx returns nothinglocal integer rLx=oSxlocal integer oMx=EQr(rLx,Vne)local integer HAxif(oMx<q)thenreturnendifloop
set oSx=Esr(rLx,Vne,oMx)
set HAx=VBe[oSx]
call EWr((oSx))call MGx(HAx)call Eyr(rLx,Vne,oSx)set oMx=oMx-1exitwhen(oMx<q)endloopendfunctionfunction Ezr takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((n5e[oSx]))])])],((((Vre[((oSx))])))))
endfunctionfunction EZr takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((n6e[oSx]))])])],((((Vre[((oSx))])))))
endfunctionfunction E_r takes integer oSx returns nothingset n3e[oSx]=falsecall Ezr((oSx))call EZr(((oSx)))call rHx(n1e)endfunctionfunction E0r takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local integer p3x=n8e[oSx]local integer svo=Vxe[oSx]local integer Q9o=Voe[oSx]call EYr(oSx)call E_r(oSx)call iKx(iCx)call iKx(p3x)call O9x(svo)call iKx(Q9o)endfunctionfunction E1r takes integer oSx returns integerset VDe[oSx]=trueset Vge[oSx]=falsecall rEx(n_e)return oSxendfunctionfunction E2r takes nothing returns integerlocal integer oSxif(Vfe==8190)thencall o_x("FolderCleaver_StructWave_Allocation_allocCustom","call DebugEx(FolderCleaver_StructWave.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",n0e+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Vde[(w)]==w)thenset VFe=VFe+1set oSx=VFeelse
set oSx=Vde[(w)]
set Vde[(w)]=Vde[Vde[(w)]]endifset Vde[oSx]=Zset VCe[oSx]=1call E1r(oSx)return oSxendfunctionfunction E3r takes integer oSx,integer otx,integer oux returns booleanreturn rux(n5e[(oSx)],(Vre[((oSx))]),otx,oux)endfunctionfunction E4r takes integer oSx,real x,real y,real bex returns nothinglocal integer rLx=oSxlocal real I2o=(Cos(((((bex)*1.))*1.)))local real I3o=(Sin(((((bex)*1.))*1.)))set oSx=E2r()set x=x+VGe*I2oset y=y+VGe*I3oset VBe[oSx]=mDx('qClv',x,y,X_x(x,y),bex)set Vhe[oSx]=rLx
set VEe[oSx]=xset VNe[oSx]=VHe*I2o
set VXe[oSx]=yset Vbe[oSx]=VHe*I3o
call E3r(rLx,Vne,oSx)endfunctionfunction E5r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local integer oSx=EPr(Cqx)local integer iCx=iXx()local integer p3x=iXx()local integer Q9o=iXx()local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real dX=dVx-wQolocal real dY=dEx-wsolocal real bex=Ufx(Cqx,dX,dY)set n7e[oSx]=Cqx
set n8e[oSx]=p3x
set n9e[oSx]=rYx
set Vve[oSx]=Vee
set Vxe[oSx]=O5x()set Voe[oSx]=Q9o
set ge[(iCx)]=(oSx)set ge[(p3x)]=(oSx)set ge[(Q9o)]=(oSx)call Eqr(oSx)call iDx(p3x,Vae,true,function Etr)call iDx(Q9o,VAe,true,function Eur)call iDx(iCx,Vce,false,function E0r)
call E4r(oSx,wQo,wso,bex)call E4r(oSx,wQo,wso,bex-Bev*1./ 3)call E4r(oSx,wQo,wso,bex+Bev*1./ 3)return trueendfunctionfunction E6r takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif LLo(nbe,Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction E7r takes nothing returns nothingset VVe=O5x()set VHe=Vje*VAeset VRe=Xpx(function E6r)endfunctionfunction E8r takes nothing returns booleancall mro(Sgv,Xdx("Cleaver_Init: call Cleaver.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Cleaver.Event_SpellEffect))",ih,MI,function E5r))call E7r()set Vce=VJe*1./ Vjereturn trueendfunctionfunction E9r takes nothing returns booleancall Vrr(function E8r,"Cleaver_Init")return trueendfunctionfunction Xvr takes nothing returns booleanset Vke=Wwx('BCoR',"Cold Resistance",'bCoR')
set anv[(Vke)]=("ReplaceableTextures\\CommandButtons\\BTNFreezingBreath.blp")call lWx(Vke,"Abilities\\Spells\\Undead\\FrostArmor\\FrostArmorTarget.mdl","origin",ri)set WU=l_x()
call l2x(WU,dRv,$F)call l3x(((Vke)),ZB+(1),(WU))return trueendfunctionfunction Xer takes nothing returns booleancall L1x('ACRe',false)set GRv=L0o('ACRe')set K6[(GRv)]=(H6)set m6[(GRv)]=(1)set TH[(GRv)]=("Cold Resistance")set x3v[(GRv)]=("spell")
call L1o((GRv),Lov+(1),((750)*1.))set MOv[(GRv)]=("ReplaceableTextures\\PassiveButtons\\PASBTNFreezingBreath.blp")
return trueendfunctionfunction Xxr takes nothing returns booleancall VNx(ma,(function Xvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\ColdResistance.page\\ColdResistance.struct\\obj_dummyBuff_wc3buff.j"))call VNx(Pa,(function Xer),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\ColdResistance.page\\ColdResistance.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Xor takes nothing returns booleanset VKe=VXx(Vle)
return trueendfunctionfunction Xrr takes nothing returns booleanlocal integer rFx=(bv)call seo((Vv[(rFx)]),Vke,(Mv[(rFx)]))return trueendfunctionfunction Xir takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),Vke)return trueendfunctionfunction Xar takes nothing returns booleancall mro(GRv,Xdx("ColdResistance_Init: call ColdResistance.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ColdResistance.Event_Learn))",pv,MI,function Xrr))
call mro(GRv,Xdx("ColdResistance_Init: call ColdResistance.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ColdResistance.Event_Unlearn))",Av,MI,function Xir))
return trueendfunctionfunction Xnr takes nothing returns booleancall Vrr(function Xar,"ColdResistance_Init")
return trueendfunctionfunction XVr takes nothing returns booleancall L1x('ADeA',false)set SFv=L0o('ADeA')set K6[(SFv)]=(H6)set m6[(SFv)]=(1)set TH[(SFv)]=("Death Axe")set x3v[(SFv)]=("spell")
call L1o((SFv),Uvv+(1),((80)*1.))call L1o((SFv),Lov+(1),((750)*1.))set MOv[(SFv)]=("ReplaceableTextures\\CommandButtons\\BTNSpiritWalkerMasterTraining.blp")return trueendfunctionfunction XEr takes nothing returns booleancall VNx(Pa,(function XVr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\DeathAxe.page\\DeathAxe.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction XXr takes nothing returns booleanset VLe=VXx(Vme)
return trueendfunctionfunction XOr takes integer oSx returns integerset Vse[oSx]=trueset VSe[oSx]=falsecall rEx(VLe)return oSxendfunctionfunction XRr takes nothing returns integerlocal integer oSxif(Vpe==8190)thencall o_x("DeathAxe_Allocation_allocCustom","call DebugEx(DeathAxe.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Vme+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(VPe[(w)]==w)thenset Vqe=Vqe+1set oSx=Vqeelse
set oSx=VPe[(w)]
set VPe[(w)]=VPe[VPe[(w)]]endifset VPe[oSx]=Zset VQe[oSx]=1call XOr(oSx)return oSxendfunctionfunction XIr takes integer oSx returns nothingset Vse[oSx]=falsecall rHx(VLe)endfunctionfunction XAr takes integer oSx returns nothingif(VQe[oSx]>0)thenreturnendifif(VPe[oSx]!=Z)thencall o_x("DeathAxe_Allocation_deallocCustom_confirm","call DebugEx(DeathAxe.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Vme+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset VPe[oSx]=VPe[(w)]set VPe[(w)]=oSx
call XIr(oSx)endfunctionfunction XNr takes integer oSx returns nothingset VQe[oSx]=VQe[oSx]-1call XAr(oSx)endfunctionfunction Xbr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqxlocal real Nboif(Iix==w)thencall XNr((oSx))call MFo(Mho)return trueendifset Cqx=Vte[oSx]
set Nbo=VTe[oSx]
call XNr((oSx))call MFo(Mho)if nbo(Iix)thenreturn trueendifcall nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))call Nbx((Iix),(rWv),(Vwe[oSx]),w,((VYe)*1.))return trueendfunctionfunction XBr takes nothing returns nothinglocal integer Okx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(Okx)])local integer Cqx=Vte[oSx]local integer rYx=Vwe[oSx]local real Xcr=(GetUnitX(C[((Cqx))]))local real XCr=(GetUnitY(C[((Cqx))]))local real rPr=(CQx((SFv),Lov+(rYx)))local integer Iixlocal real dVxlocal real dExlocal real bexlocal integer Mholocal integer HAxcall iKx(Okx)set hf=(ze[(Cqx)])set Iix=wro(Xcr,XCr,(CQx((SFv),Lov+(rYx))),Vye)if(Iix==w)thencall XNr((oSx))else
set dVx=(GetUnitX(C[((Iix))]))set dEx=(GetUnitY(C[((Iix))]))set bex=(Atan2(((dEx-XCr)*1.),((dVx-Xcr)*1.)))set Mho=Moo()set HAx=Mno(Mho,'qDeA',1.5)call m4o(Mho,500.)set mCv[(Mho)]=(((CQx((SFv),Uvv+(rYx))))*1.)
set mFv[(Mho)]=Xkx((function Xbr))set mZv[(Mho)]=(oSx)
call Meo(Mho,350.)call pxo(Mho,Cqx)call sEo((HAx),(Vze),(VZe),(ri))
set mgv[(Mho)]=(V_e)
call o9r(Mho,Xcr+rPr*(Cos(((((bex)*1.))*1.))),XCr+rPr*(Sin(((((bex)*1.))*1.))),X_x(dVx,dEx)+60.)
endifcall Khx(Cqx)endfunctionfunction Xdr takes integer Cqx,integer rYx returns nothinglocal integer oSx=XRr()local integer Okx=iXx()set Vte[oSx]=Cqx
set VTe[oSx]=Vue
set VUe[oSx]=Okx
set Vwe[oSx]=rYx
set ge[(Okx)]=(oSx)call A_o(Cqx)call iDx(Okx,VWe,false,function XBr)
endfunctionfunction XDr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])call Xdr(Cqx,rYx)return trueendfunctionfunction Xfr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,IFv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction XFr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])set hf=(ze[(Vte[oSx])])if not Xfr()then
return false
endifreturn truereturn trueendfunctionfunction Xgr takes nothing returns booleanlocal integer rFx=(bv)call Avx((Vv[(rFx)]),VMe)return trueendfunctionfunction XGr takes nothing returns booleanlocal integer rFx=(bv)call RPx((Vv[(rFx)]),VMe)return trueendfunctionfunction Xhr takes nothing returns booleanset VMe=Xdx("DeathAxe_Init: set DeathAxe.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DeathAxe.Event_Death)",VP,MI,function XDr)set V_e=Xpx(function XFr)set Vye=Xpx(function Xfr)call mro(SFv,Xdx("DeathAxe_Init: call DeathAxe.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DeathAxe.Event_Learn))",pv,MI,function Xgr))call mro(SFv,Xdx("DeathAxe_Init: call DeathAxe.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DeathAxe.Event_Unlearn))",Av,MI,function XGr))return trueendfunctionfunction XHr takes nothing returns booleancall Vrr(function Xhr,"DeathAxe_Init")return trueendfunctionfunction Xjr takes nothing returns booleanset V0e=Wwx('BDrR',"Drum Roll",'bDrR')set aav[(V0e)]=(true)set anv[(V0e)]=("ReplaceableTextures\\PassiveButtons\\PASBTNDrum.blp")call lWx(V0e,"Abilities\\Spells\\Other\\GeneralAuraTarget\\GeneralAuraTarget.mdl","origin",ri)set WU=l_x()
call l2x(WU,dHv,.2)call l3x(((V0e)),ZB+(1),(WU))return trueendfunctionfunction XJr takes nothing returns booleancall VNx(ma,(function Xjr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\DrumRoll.page\\DrumRoll.struct\\Target\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction Xkr takes nothing returns booleanset V1e=VXx(V2e)
return trueendfunctionfunction XKr takes nothing returns booleancall L1x('ADrR',false)set hRv=L0o('ADrR')set K6[(hRv)]=(H6)set m6[(hRv)]=(1)set TH[(hRv)]=("Drum Roll")set x3v[(hRv)]=("spell")
call L1o((hRv),Uvv+(1),((500)*1.))call L1o((hRv),Lov+(1),((750)*1.))set MOv[(hRv)]=("ReplaceableTextures\\PassiveButtons\\PASBTNCommand.blp")return trueendfunctionfunction Xlr takes nothing returns booleanset V3e=ltx(V4e+" (dummyBuff)")call lWx(V3e,"Abilities\\Spells\\Orc\\CommandAura\\CommandAura.mdl","origin",ri)
return trueendfunctionfunction XLr takes nothing returns booleancall VNx(Pa,(function XKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\DrumRoll.page\\DrumRoll.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function Xlr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\DrumRoll.page\\DrumRoll.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction Xmr takes nothing returns booleanset V5e=VXx(V4e)
return trueendfunctionfunction XMr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif not(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction Xpr takes integer oSx returns integerset Eee[oSx]=trueset Exe[oSx]=falseset Eoe[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set vte[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(vge)return oSxendfunctionfunction XPr takes nothing returns integerlocal integer oSxif(V7e==8190)thencall o_x("Aura_Allocation_allocCustom","call DebugEx(Aura.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",vGe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(V8e[(w)]==w)thenset V9e=V9e+1set oSx=V9eelse
set oSx=V8e[(w)]
set V8e[(w)]=V8e[V8e[(w)]]endifset V8e[oSx]=Zset Eve[oSx]=1call Xpr(oSx)return oSxendfunctionfunction Xqr takes integer oSx returns nothingset vse[(oSx)]=(Ere+oSx)
endfunctionfunction XQr takes integer Cqx returns integerlocal integer oSx=XPr()call Xqr(oSx)set vqe[(oSx)]=((.0)*1.)
set vke[(oSx)]=(Cqx)
set vQe[(oSx)]=(w)set vPe[(oSx)]=(Jbx("Aura_Create: call this.SetTargetGroup(UnitList.Create())"))
return oSxendfunctionfunction Xsr takes integer oSx,integer XYx returns nothingif(vte[oSx]==w)thencall o_x("FolderAura_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oSx)+";"+(jA[(XYx)]))set vte[oSx]=Xendifcall rux(vte[oSx],(vse[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction XSr takes integer oSx returns booleanif((EXe[((oSx))])>0)then
return false
endifset EOe=EOe+1set ERe[EOe]=oSx
set EXe[oSx]=EOe+1return(EOe==0)endfunctionfunction Xtr takes integer oSx returns nothingif rUx(vke[oSx],vJe,oSx)then
call Avx(vke[oSx],vje)call Avx(vke[oSx],vUe)endifcall XSr(oSx)call eWr(oSx)endfunctionfunction XTr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer Xur=XQr(Iix)set Eie[oSx]=Xur
set Eae[oSx]=rYx
set Ene[(Xur)]=(oSx)
set vqe[(Xur)]=(((CQx((hRv),Uvv+(rYx))))*1.)
set vQe[(Xur)]=(V6e)
call Xsr(Xur,EVe)call Xsr(Xur,EEe)call Xtr(Xur)return trueendfunctionfunction XUr takes integer oSx returns booleanif(((EXe[((oSx))])>0)==false)thenreturn false
endifset EXe[ERe[EOe]]=EXe[oSx]set ERe[EXe[oSx]-1]=ERe[EOe]
set EXe[oSx]=0set EOe=EOe-1return(EOe==F)endfunctionfunction Xwr takes integer oSx returns nothingif rnx(vke[oSx],vJe,oSx)then
call RPx(vke[oSx],vje)call RPx(vke[oSx],vUe)endifcall XUr(oSx)call eZr(oSx)endfunctionfunction XWr takes integer oSx returns booleanif((ns[(oSx)])>0)thenset Vs[oSx]=true
return false
endifreturn trueendfunctionfunction Xyr takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((nb[oSx]))])])],((((Vb[((oSx))])))))endfunctionfunction XYr takes integer oSx returns nothingset xs[oSx]=falsecall Xyr((oSx))call rHx(rs)
endfunctionfunction Xzr takes integer oSx returns nothingif(es[oSx]>0)thenreturnendifif(ZQ[oSx]!=Z)thencall o_x("UnitList_Allocation_deallocCustom_confirm","call DebugEx(UnitList.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Nj+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset ZQ[oSx]=ZQ[(w)]set ZQ[(w)]=oSxcall XYr(oSx)endfunctionfunction XZr takes integer oSx returns nothingset es[oSx]=es[oSx]-1call Xzr(oSx)endfunctionfunction X_r takes integer oSx returns nothingcall dWx((oSx),Ob)if not XWr(oSx)thenreturnendifcall XZr((oSx))endfunctionfunction X0r takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((vte[oSx]))])])],((((vse[((oSx))])))))
endfunctionfunction X1r takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((Eoe[oSx]))])])],((((vse[((oSx))])))))
endfunctionfunction X2r takes integer oSx returns nothingset Eee[oSx]=falsecall X1r((oSx))call X0r(((oSx)))call rHx(vge)endfunctionfunction X3r takes integer oSx returns nothingif(Eve[oSx]>0)thenreturnendifif(V8e[oSx]!=Z)thencall o_x("Aura_Allocation_deallocCustom_confirm","call DebugEx(Aura.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",vGe+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset V8e[oSx]=V8e[(w)]set V8e[(w)]=oSx
call X2r(oSx)endfunctionfunction X4r takes integer oSx returns nothingset Eve[oSx]=Eve[oSx]-1call X3r(oSx)endfunctionfunction X5r takes integer oSx returns nothinglocal integer Cqx=(vke[(oSx)])local integer svo=(vPe[(oSx)])call Xwr(oSx)call X_r(svo)call X0r(oSx)call X4r((oSx))endfunctionfunction X6r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer Xur=Eie[oSx]call X5r(Xur)return trueendfunctionfunction X7r takes nothing returns booleanlocal integer rFx=(bv)call seo((Vv[(rFx)]),V3e,(Mv[(rFx)]))return trueendfunctionfunction X8r takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),V3e)return trueendfunctionfunction X9r takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer rLx=(Ene[(Xur)])call Ulx(Iix,V0e)return trueendfunctionfunction Ovr takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer Cqx=(vke[(Xur)])local integer rLx=(Ene[(Xur)])local integer rYx=Eae[rLx]call Dux((Iix),(V0e),(rYx),w)return trueendfunctionfunction Oer takes nothing returns nothingset EVe=Xdx("FolderDrumRoll_StructTarget_Init: set FolderDrumRoll_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderDrumRoll_StructTarget.Event_Ending)",vTe,MI,function X9r)
set EEe=Xdx("FolderDrumRoll_StructTarget_Init: set FolderDrumRoll_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderDrumRoll_StructTarget.Event_Start)",vue,MI,function Ovr)endfunctionfunction Oxr takes nothing returns booleanset V6e=Xpx(function XMr)call Lxx(V3e,Xdx("DrumRoll_Init: call DrumRoll.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DrumRoll.Event_BuffGain))",bd,MI,function XTr))
call Lxx(V3e,Xdx("DrumRoll_Init: call DrumRoll.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DrumRoll.Event_BuffLose))",jc,MI,function X6r))
call mro(hRv,Xdx("DrumRoll_Init: call DrumRoll.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DrumRoll.Event_Learn))",pv,MI,function X7r))call mro(hRv,Xdx("DrumRoll_Init: call DrumRoll.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DrumRoll.Event_Unlearn))",Av,MI,function X8r))call Oer()return trueendfunctionfunction Oor takes nothing returns booleancall Vrr(function Oxr,"DrumRoll_Init")return trueendfunctionfunction Orr takes nothing returns booleanset EIe=Wwx('BEnS',"Poisoned",'bEnS')set uU[(EIe)]=(true)
set anv[(EIe)]=("ReplaceableTextures\\CommandButtons\\BTNEnvenomedSpear.blp")call lWx(EIe,"Abilities\\Weapons\\PoisonSting\\PoisonStingTarget.mdl","origin",ri)return trueendfunctionfunction Oir takes nothing returns booleancall VNx(ma,(function Orr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\EnvenomedSpears.page\\EnvenomedSpears.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction Oar takes nothing returns booleanset EAe=VXx(ENe)
return trueendfunctionfunction Onr takes nothing returns booleanset Ebe=ltx(EBe+" (dummyBuff)")return trueendfunctionfunction OVr takes nothing returns booleancall L1x('AEnS',false)set hfv=L0o('AEnS')set K6[(hfv)]=(H6)set m6[(hfv)]=(1)set TH[(hfv)]=("Envenomed Spears")set x3v[(hfv)]=("spell")
call L1o((hfv),Lov+(1),((750)*1.))set MOv[(hfv)]=("ReplaceableTextures\\PassiveButtons\\PASBTNEnvenomedSpear.blp")
return trueendfunctionfunction OEr takes nothing returns booleancall VNx(ma,(function Onr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\EnvenomedSpears.page\\EnvenomedSpears.struct\\obj_dummyBuff_wc3buff.j"))
call VNx(Pa,(function OVr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\EnvenomedSpears.page\\EnvenomedSpears.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction OXr takes nothing returns booleanset Ece=VXx(EBe)
return trueendfunctionfunction OOr takes integer Iix returns booleanreturn( not(I9x(Iix,Ifv)))and( not(I9x(Iix,Igv)))endfunctionfunction ORr takes integer Cqx,integer rYx,integer Iix returns nothinglocal real iMxif I9x(Iix,Wd)thenset iMx=Edeelse
set iMx=EDeendifcall Nbx(Iix,EIe,rYx,Cqx,iMx)endfunctionfunction OIr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])if not OOr(Iix)thenreturn trueendifcall ORr((E2v[(rFx)]),(osx((((E2v[(rFx)]))),N+(hfv))),Iix)return trueendfunctionfunction OAr takes nothing returns booleanlocal integer rFx=(bv)call Avx((Vv[(rFx)]),ECe)return trueendfunctionfunction ONr takes nothing returns booleanlocal integer rFx=(bv)call RPx((Vv[(rFx)]),ECe)return trueendfunctionfunction Obr takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(Ebe),((Mv[(rFx)])),w)return trueendfunctionfunction OBr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),Ebe)return trueendfunctionfunction Ocr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxcall nlo((EGe[oSx]),(Iix),((iUx(Ehe[oSx],(oG[(Iix)])-dG))*1.),(false),(false))endfunctionfunction OCr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Lc[(rFx)])local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=iXx()set EGe[oSx]=Cqx
set Ehe[oSx]=Efe
set EHe[oSx]=p3x
set ge[(p3x)]=(oSx)call iDx(p3x,Ege,true,function Ocr)return trueendfunctionfunction Odr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=EHe[oSx]call iKx(p3x)return trueendfunctionfunction ODr takes nothing returns nothingset Efe=EFe*Egecall Lxx(EIe,Xdx("FolderEnvenomedSpears_StructTarget_Init: call FolderEnvenomedSpears_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderEnvenomedSpears_StructTarget.Event_BuffGain))",bd,MI,function OCr))call Lxx(EIe,Xdx("FolderEnvenomedSpears_StructTarget_Init: call FolderEnvenomedSpears_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderEnvenomedSpears_StructTarget.Event_BuffLose))",jc,MI,function Odr))call W2x(XDv,EIe)endfunctionfunction Ofr takes nothing returns booleanset ECe=Xdx("EnvenomedSpears_Init: set EnvenomedSpears.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function EnvenomedSpears.Event_Damage)",E4v,MI,function OIr)call Lxx(Ebe,Xdx("EnvenomedSpears_Init: call EnvenomedSpears.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnvenomedSpears.Event_BuffGain))",bd,MI,function OAr))call Lxx(Ebe,Xdx("EnvenomedSpears_Init: call EnvenomedSpears.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnvenomedSpears.Event_BuffLose))",jc,MI,function ONr))call mro(hfv,Xdx("EnvenomedSpears_Init: call EnvenomedSpears.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnvenomedSpears.Event_Learn))",pv,MI,function Obr))call mro(hfv,Xdx("EnvenomedSpears_Init: call EnvenomedSpears.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnvenomedSpears.Event_Unlearn))",Av,MI,function OBr))call ODr()return trueendfunctionfunction OFr takes nothing returns booleancall Vrr(function Ofr,"EnvenomedSpears_Init")return trueendfunctionfunction Ogr takes nothing returns booleanset Eje=VXx(EJe)
return trueendfunctionfunction OGr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(LoadInteger(o[((V[(E[((X))])]))],(((RK+(((av[(rFx)])))))),(((IK)))))local integer Iixif I9x(Cqx,Qc)thenreturn trueendifset hf=(ze[(Cqx)])set Iix=oIr((GetUnitX(C[((Cqx))])),(GetUnitY(C[((Cqx))])),500.,Eke)if(Iix!=w)thencall Lox((Cqx),(Rh[((Sfv))]),(Iix))endifreturn trueendfunctionfunction Ohr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction OHr takes nothing returns booleanlocal integer FPx=x3r(Sfv,function OGr)set Eke=Xpx(function Ohr)call x6r(FPx,dTv,HI,w)return trueendfunctionfunction Ojr takes nothing returns booleancall e4r(function OHr,"AIKnockout_Init")
return trueendfunctionfunction OJr takes nothing returns booleanset EKe=Wwx('BKnO',"Knockout",'bKnO')set aav[(EKe)]=(true)set anv[(EKe)]=("ReplaceableTextures\\CommandButtons\\BTNEntanglingRoots.blp")return trueendfunctionfunction Okr takes nothing returns booleancall VNx(ma,(function OJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\Knockout.page\\Knockout.struct\\Target\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction OKr takes nothing returns booleanset Ele=VXx(ELe)
return trueendfunctionfunction Olr takes nothing returns booleancall L1x('AKno',false)set Sfv=L0o('AKno')set K6[(Sfv)]=(H6)set m6[(Sfv)]=(1)set TH[(Sfv)]=("Knockout")set Rh[(Sfv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D007F)))),(((Aj))))))set oxv[(Sfv)]=(4)set x3v[(Sfv)]=("spell")
call L1o((Sfv),GH+(1),(($C)*1.))
call L1o((Sfv),tH+(1),((80)*1.))
call L1o((Sfv),Lov+(1),((700)*1.))set MOv[(Sfv)]=("ReplaceableTextures\\CommandButtons\\BTNSeaGiantPulverize.blp")
return trueendfunctionfunction OLr takes nothing returns booleancall VNx(Pa,(function Olr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\Knockout.page\\Knockout.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Omr takes nothing returns booleanset Eme=VXx(EMe)
return trueendfunctionfunction OMr takes integer oSx returns integerset Epe[oSx]=trueset EPe[oSx]=falsecall rEx(Eme)return oSxendfunctionfunction Opr takes integer oSx,integer Iix returns nothinglocal real dVx=Dsx(Iix)local real dEx=Dtx(Iix)local real OPr=Dsx((oSx))local real Oqr=Dtx((oSx))if((dVx!=OPr)or(dEx!=Oqr))thencall SetUnitFacing(C[((oSx))],(((Atan2(((dEx-Oqr)*1.),((dVx-OPr)*1.))))*1.)*ky)endifendfunctionfunction OQr takes integer oSx returns nothingset Epe[oSx]=falsecall rHx(Eme)endfunctionfunction Osr takes integer Cqx,integer Iix returns booleanreturn( not(Iix==w))and( not(IsUnitAlly(C[(Iix)],vx[((ze[(Cqx)]))])))and( not(nbo(Iix)))
endfunctionfunction OSr takes integer oSx,real N5x,real N6x,real cNx,real cEo,real cXo,real cOo,real iMx returns nothinglocal integer rLx=oSxlocal integer iCxset oSx=B4o()set iCx=iXx()set Cav[oSx]=iCx
set Cnv[oSx]=rLx
set CVv[oSx]=N5x
set CEv[oSx]=cEo
set CXv[oSx]=N6x
set COv[oSx]=cXo
set CRv[oSx]=cNx
set CIv[oSx]=cOo
set ge[(iCx)]=(oSx)if rUx(rLx,CAv,oSx)thencall Avx(rLx,CNv)call Avx(rLx,Cbv)endifif B5o(oSx)thencall iDx(Cdv,c9v,true,function cvo)endifcall iDx(iCx,iMx,false,function cno)
endfunctionfunction Otr takes integer oSx,real N5x,real N6x,real cNx,real cEo,real cXo,real cOo,real iMx returns nothingif B2o(oSx)thencall OSr(oSx,N5x,N6x,cNx,cEo,cXo,cOo,iMx)endifendfunctionfunction OTr takes integer oSx,real Nlx,real NLx,real bex,real iMx returns nothinglocal real I2o=(Cos(((((bex)*1.))*1.)))local real I3o=(Sin(((((bex)*1.))*1.)))set NLx=NLx*c9v*c9vset Nlx=Nlx*c9vcall Otr(oSx,Nlx*I2o,Nlx*I3o,.0,NLx*I2o,NLx*I3o,.0,iMx)endfunctionfunction Our takes integer oSx,real Nlx,real NLx,real bex,real iMx returns nothingcall Nbx(((((oSx)))),(x5v),(1),w,((((iMx)*1.))*1.))call OTr(oSx,Nlx,NLx,bex,iMx)endfunctionfunction OUr takes integer Cqx,integer rYx,integer Iix returns nothingif not(osx((((Iix))),(Wb+(EKe)))>0)thencall Nbx((Iix),(EKe),(rYx),w,((ESe)*1.))
endifcall Our(Iix,900.,-900.,(Atan2((((GetUnitY(C[((Iix))]))-(GetUnitY(C[((Cqx))])))*1.),(((GetUnitX(C[((Iix))]))-(GetUnitX(C[((Cqx))])))*1.))),.14)call nlo((Cqx),(Iix),((Ete)*1.),(true),(false))endfunctionfunction Owr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=Eqe[oSx]local integer rYx=EQe[oSx]local integer Iix=Ese[oSx]call OQr(oSx)call MFo(Mho)if(Iix==w)thenreturn trueendifif Osr(Cqx,Iix)thencall OUr(Cqx,rYx,Iix)endifreturn trueendfunctionfunction OWr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local integer Mho=Moo()local integer oSx=OMr(Mho)set Eqe[oSx]=Cqx
set EQe[oSx]=rYx
set Ese[oSx]=Iix
call SetUnitPosition(C[((Cqx))],(((GetUnitX(C[((Iix))])))*1.),(((GetUnitY(C[((Iix))])))*1.))
call Opr(Cqx,Iix)set mCv[(Mho)]=((10.)*1.)call Mno(Mho,'qKnO',2.)set mFv[(Mho)]=Xkx((function Owr))set mZv[(Mho)]=(oSx)
call Meo(Mho,700.)call pxo(Mho,Cqx)call M6o((Mho),(Iix),.0,.0,.0,(null))return trueendfunctionfunction Oyr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall Nbx((Iix),(Xwv),(rYx),w,((ETe)*1.))
return trueendfunctionfunction OYr takes nothing returns booleancall mro(Sfv,Xdx("Knockout_Init: call Knockout.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Knockout.Event_SpellEffect))",ih,MI,function OWr))call Lxx(EKe,Xdx("FolderKnockout_StructTarget_Init: call FolderKnockout_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderKnockout_StructTarget.Event_BuffGain))",bd,MI,function Oyr))return trueendfunctionfunction Ozr takes nothing returns booleancall Vrr(function OYr,"Knockout_Init")return trueendfunctionfunction OZr takes nothing returns booleanset Eue=VXx(EUe)
return trueendfunctionfunction O_r takes nothing returns booleanlocal integer rFx=(bv)call Rxx(((LoadInteger(o[((V[(E[((X))])]))],(((RK+(((av[(rFx)])))))),(((IK)))))),(Rh[((SJv))]))return trueendfunctionfunction O0r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(LoadInteger(o[((V[(E[((X))])]))],(((RK+(((av[(rFx)])))))),(((IK)))))if((oG[(Cqx)])>=(R2I((((Nmv[(GOv)])-Ewe)*1.))))thenreturn false
endifreturn truereturn trueendfunctionfunction O1r takes nothing returns booleanlocal integer FPx=x3r(SJv,function O_r)call xSr(FPx,GG,(R2I((((Nmv[(GOv)])-Ewe)*1.))),LESS_THAN,Xpx(function O0r))return trueendfunctionfunction O2r takes nothing returns booleancall e4r(function O1r,"AIMedipack_Init")
return trueendfunctionfunction O3r takes nothing returns booleancall L1x('AMeP',false)set SJv=L0o('AMeP')set K6[(SJv)]=(H6)set m6[(SJv)]=(1)set TH[(SJv)]=("Medipack")set Rh[(SJv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Aj))))))set oxv[(SJv)]=(0)set x3v[(SJv)]=("spell")
call L1o((SJv),GH+(1),(($F)*1.))
call L1o((SJv),tH+(1),((25)*1.))
call L1o((SJv),Lov+(1),((750)*1.))set MOv[(SJv)]=("ReplaceableTextures\\CommandButtons\\BTNManual.blp")return trueendfunctionfunction O4r takes nothing returns booleancall VNx(Pa,(function O3r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\Medipack.page\\Medipack.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction O5r takes nothing returns booleanset EWe=VXx(Eye)
return trueendfunctionfunction O6r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])call Ryx((ACx((Cqx),(EYe),(Eze),(ri))))call wCo(Cqx,true,false,true)call mao(Cqx,Cqx,Ewe)return trueendfunctionfunction O7r takes nothing returns booleancall mro(SJv,Xdx("Medipack_Init: call Medipack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Medipack.Event_SpellEffect))",ih,MI,function O6r))return trueendfunctionfunction O8r takes nothing returns booleancall Vrr(function O7r,"Medipack_Init")return trueendfunctionfunction O9r takes nothing returns booleanset EZe=ltx(E_e+" (silenceBuff)")set Pc[(EZe)]=(true)
set uU[(EZe)]=(true)
return trueendfunctionfunction Rvr takes nothing returns booleancall L1x('AMuS',false)set Skv=L0o('AMuS')set K6[(Skv)]=(H6)set m6[(Skv)]=(1)set TH[(Skv)]=("Muting Shout")set Rh[(Skv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00C4)))),(((Aj))))))set oxv[(Skv)]=(0)set x3v[(Skv)]=("spell")
call L1o((Skv),Uvv+(1),((550)*1.))call L1o((Skv),GH+(1),(($F)*1.))
call L1o((Skv),tH+(1),((30)*1.))
call L1o((Skv),Lov+(1),((750)*1.))set MOv[(Skv)]=("ReplaceableTextures\\CommandButtons\\BTNBattleRoar.blp")return trueendfunctionfunction Rer takes nothing returns booleancall VNx(ma,(function O9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\MutingShout.page\\MutingShout.struct\\obj_silenceBuff_wc3buff.j"))call VNx(Pa,(function Rvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\MutingShout.page\\MutingShout.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Rxr takes nothing returns booleanset E0e=VXx(E_e)
return trueendfunctionfunction Ror takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction Rrr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local integer Iixlocal integer Efrcall mho((mko(((wQo)*1.),((wso)*1.),(E3e),(ri))))set hf=(ze[(Cqx)])call NVo(E1e,wQo,wso,(CQx((Skv),Uvv+(rYx))),E2e)
set Iix=NEo(E1e)
set Efr=0if(Iix!=w)thenloop
set Efr=Efr+1call Nbx((Iix),(EZe),(rYx),w,((E4e)*1.))
set Iix=NEo(E1e)
exitwhen(Iix==w)
endloopendifcall mao(Cqx,Cqx,E5e*(rG[(Cqx)])*Efr)return trueendfunctionfunction Rir takes nothing returns booleanset E1e=O5x()set E2e=Xpx(function Ror)call mro(Skv,Xdx("MutingShout_Init: call MutingShout.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MutingShout.Event_SpellEffect))",ih,MI,function Rrr))call W2x(Xlv,EZe)return trueendfunctionfunction Rar takes nothing returns booleancall Vrr(function Rir,"MutingShout_Init")return trueendfunctionfunction Rnr takes nothing returns booleancall L1x('AReP',false)set Gbv=L0o('AReP')set K6[(Gbv)]=(H6)set m6[(Gbv)]=(1)set TH[(Gbv)]=("Realplex")set Rh[(Gbv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D009B)))),(((Aj))))))set oxv[(Gbv)]=(0)set x3v[(Gbv)]=("spell")
call L1o((Gbv),GH+(1),(($A)*1.))
call L1o((Gbv),tH+(1),((50)*1.))
call L1o((Gbv),Lov+(1),((750)*1.))set MOv[(Gbv)]=("ReplaceableTextures\\CommandButtons\\BTNInvisibility.blp")return trueendfunctionfunction RVr takes nothing returns booleancall VNx(Pa,(function Rnr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\Realplex.page\\Realplex.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction REr takes nothing returns booleanset E6e=VXx(E7e)
return trueendfunctionfunction RXr takes integer oSx returns nothingset Xoe[oSx]=falsecall rHx(E6e)endfunctionfunction ROr takes integer oSx returns nothingif(Xee[oSx]>0)thenreturnendifif(Xxe[oSx]!=Z)thencall o_x("Realplex_Allocation_deallocCustom_confirm","call DebugEx(Realplex.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",E7e+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset Xxe[oSx]=Xxe[(w)]set Xxe[(w)]=oSx
call RXr(oSx)endfunctionfunction RRr takes integer oSx returns nothingset Xee[oSx]=Xee[oSx]-1call ROr(oSx)endfunctionfunction RIr takes integer oSx returns nothingset Bmv=true
call Crx((oSx),w)endfunctionfunction RAr takes integer oSx,integer Cqx,integer RNr returns nothinglocal integer iCx=Xve[oSx]local integer Rbrcall RRr((oSx))call iKx(iCx)call rVx(Cqx,E9e)call RPx(Cqx,E8e)loop
set Rbr=(OUx((RNr),Ob))exitwhen(Rbr==w)
call RIr(Rbr)endloopcall X_r(RNr)endfunctionfunction RBr takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=osx((Vv[(rFx)]),E9e)call RAr(oSx,Xre[oSx],Xie[oSx])return trueendfunctionfunction Rcr takes integer oSx,integer Rbr,integer RNr returns nothingcall rVx(Rbr,E9e)call RPx(Rbr,Xne)call IRo(RNr,Rbr)endfunctionfunction RCr takes nothing returns booleanlocal integer rFx=(bv)local integer Rbr=(Vv[(rFx)])local integer oSx=osx(Rbr,E9e)local integer RNr=Xie[oSx]call Rcr(oSx,Rbr,RNr)return trueendfunctionfunction Rdr takes integer oSx returns integerset Xoe[oSx]=trueset XIe[oSx]=falsecall rEx(E6e)return oSxendfunctionfunction RDr takes nothing returns integerlocal integer oSxif(XOe==8190)thencall o_x("Realplex_Allocation_allocCustom","call DebugEx(Realplex.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",E7e+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Xxe[(w)]==w)thenset XRe=XRe+1set oSx=XReelse
set oSx=Xxe[(w)]
set Xxe[(w)]=Xxe[Xxe[(w)]]endifset Xxe[oSx]=Zset Xee[oSx]=1call Rdr(oSx)return oSxendfunctionfunction Rfr takes integer oSx returns integerset c3v[oSx]=trueset XBe[oSx]=falsecall rEx(Rov)return oSxendfunctionfunction RFr takes nothing returns integerlocal integer oSxif(XNe==8190)thencall o_x("FolderUnit_FolderPosition_StructTimed_Allocation_allocCustom","call DebugEx(FolderUnit_FolderPosition_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Rrv+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(c2v[(w)]==w)thenset Xbe=Xbe+1set oSx=Xbeelse
set oSx=c2v[(w)]
set c2v[(w)]=c2v[c2v[(w)]]endifset c2v[oSx]=Zset c1v[oSx]=1call Rfr(oSx)return oSxendfunctionfunction Rgr takes integer oSx returns booleanset c7v=c7v+1set c6v[c7v]=oSx
set c5v[oSx]=c7v+1return(c7v==0)endfunctionfunction RGr takes nothing returns nothinglocal integer oMx=c7vlocal integer oSxlocal integer rLxloop
set oSx=c6v[oMx]
set rLx=Xce[oSx]
call B6o(rLx,XCe[oSx])call B7o(rLx,Xde[oSx])call B9o(rLx,XDe[oSx])set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction Rhr takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])call cPo(oSx,iCx,Xce[oSx])endfunctionfunction RHr takes integer oSx,real N5x,real N6x,real cNx,real iMx returns nothinglocal integer rLx=oSxlocal integer fex=(R2I(((iMx*1./ XAe)*1.)))local integer iCxset oSx=RFr()set iCx=iXx()set Ctv[oSx]=iCx
set Xce[oSx]=rLx
set XCe[oSx]=N5x*1./ fex
set Xde[oSx]=N6x*1./ fex
set XDe[oSx]=cNx*1./ fex
set ge[(iCx)]=(oSx)if rUx(rLx,c0v,oSx)thencall Avx(rLx,c_v)call Avx(rLx,c4v)endifif Rgr(oSx)thencall iDx(c8v,XAe,true,function RGr)endifcall iDx(iCx,iMx,false,function Rhr)
endfunctionfunction Rjr takes integer oSx,real N5x,real N6x,real cNx,real iMx returns nothingif not B2o(oSx)thenreturnendifcall RHr(oSx,N5x,N6x,cNx,iMx)endfunctionfunction RJr takes integer oSx,real x,real y,real z,real iMx returns nothing
call Rjr(oSx,x-Dsx((oSx)),y-Dtx((oSx)),z-fYx((oSx)),iMx)
endfunctionfunction Rkr takes integer oSx returns realreturn GetUnitFlyHeight(C[(oSx)])endfunctionfunction RKr takes integer oSx,real x,real y,real iMx returns nothingcall RJr(oSx,x,y,X_x(x,y)+Rkr((oSx)),iMx)endfunctionfunction Rlr takes integer oSx,real oux returns nothingset Aiv[oSx]=oux
call Omo((oSx))endfunctionfunction RLr takes integer oSx,real oux returns nothingcall Rlr(oSx,(Aiv[(oSx)])+oux)endfunctionfunction Rmr takes integer oSx returns nothinglocal integer oMx=(CIx((((oSx))),Q))
loop
exitwhen(oMx<q)call rpx((oSx),(CAx((((oSx))),Q,(oMx))))
set oMx=oMx-1endloopcall Rao(oSx,IDv)endfunctionfunction RMr takes integer oSx,real oux returns nothingset ug[oSx]=ouxcall cex((oSx))endfunctionfunction Rpr takes integer oSx,real oux returns nothingcall RMr(oSx,(ug[(oSx)])+oux)endfunctionfunction RPr takes integer oSx,integer otx returns booleanreturn(LoadBoolean(o[((V[(E[((Bb[(oSx)]))])]))],((((cb[((oSx))])))),(((otx)))))endfunctionfunction Rqr takes integer oSx,integer otx returns booleanreturn(RPr(oSx,otx)!=false)endfunctionfunction RQr takes integer oSx,integer otx,boolean oux returns nothingcall SaveBoolean(o[((V[(E[((Bb[(oSx)]))])]))],((((cb[((oSx))])))),(((otx))),(((oux))))endfunctionfunction Rsr takes integer oSx,integer otx returns booleanlocal boolean aCx=RPr(oSx,otx)call RQr(oSx,otx,not false)return(aCx==false)endfunctionfunction RSr takes integer oSx,integer otx,real oux returns nothingcall SaveReal(o[((V[(E[((I[(oSx)]))])]))],((((A[((oSx))])))),(((otx))),((((((oux)*1.))*1.))*1.))
endfunctionfunction Rtr takes integer oSx,real izx,real iZx,real i_x,real i0x,integer oDx returns nothingif not Rqr(oDx,cgv)thencall Rsr(oDx,cgv)if rUx((oSx),cFv,oDx)thencall Avx((oSx),cfv)endifendifcall RSr((oSx),ak+oDx,izx)call RSr((oSx),nk+oDx,iZx)call RSr((oSx),Vk+oDx,i_x)call RSr((oSx),Ek+oDx,i0x)call SetUnitVertexColor(C[(oSx)],(R2I((((vk[(oSx)])+izx)*1.))),(R2I((((ek[(oSx)])+iZx)*1.))),(R2I((((xk[(oSx)])+i_x)*1.))),(R2I((((ok[(oSx)])+i0x)*1.))))endfunctionfunction RTr takes integer oSx,real izx,real iZx,real i_x,real i0x,integer oDx returns nothingcall Rtr(oSx,(fHx(((oSx)),ak+(oDx)))+izx,(fHx(((oSx)),nk+(oDx)))+iZx,(fHx(((oSx)),Vk+(oDx)))+i_x,(fHx(((oSx)),Ek+(oDx)))+i0x,oDx)endfunctionfunction Rur takes integer rNx,integer oDx,real x,real y,real bex,real iMx,string RUr returns integerlocal integer oSxset BNv=falseset oSx=bOx(rNx,oDx,x,y,bex)
set BNv=true
call RLr(oSx,-.5)call Rmr(oSx)call Rpr(oSx,-1.)call RTr(oSx,-191.,-191.,.0,.0,oDx)call U_o(oSx,iMx)set Asv[(oSx)]=(RUr)
call AOo(oSx)return oSxendfunctionfunction Rwr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer RNr=Xie[oSx]local integer Rbrloop
set Rbr=(dpx((RNr),Ob))exitwhen(Rbr==w)
call GroupAddUnit(kb[(Xae)],C[(Rbr)])call Ulx(((Rbr)),XAv)endloopcall Ulx(((Xre[oSx])),XAv)loop
set Rbr=NEo(Xae)
exitwhen(Rbr==w)
call dQx(RNr,Rbr)call Ulx(((Rbr)),XAv)call PauseUnit(C[Rbr],false)
endloopendfunctionfunction RWr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real Ryr=(GetUnitFacing(C[((Cqx))])*Nh)local integer C3o=(ze[(Cqx)])local integer RYr=(Tf[(Cqx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local integer oSx=osx(Cqx,E9e)local real bex=Ryr-Bevlocal real N5x=XVe*(Cos(((((bex)*1.))*1.)))local real N6x=XVe*(Sin(((((bex)*1.))*1.)))local real x=wQo-XEe*1./ 2*N5xlocal real y=wso-XEe*1./ 2*N6xlocal integer iCxlocal integer RNrlocal integer oMxlocal integer oOrlocal integer Rbrcall mho((mko(((wQo)*1.),((wso)*1.),(XXe),(ri))))if(oSx!=w)thencall RAr(oSx,Cqx,Xie[oSx])endifset oSx=RDr()set iCx=iXx()set RNr=Jbx("Realplex_Event_SpellEffect: set illusionGroup = UnitList.Create()")
set Xre[oSx]=Cqx
set Xve[oSx]=iCx
set Xie[oSx]=RNr
call rwx(Cqx,E9e,oSx)call Avx(Cqx,E8e)set ge[(iCx)]=(oSx)call Dux((((Cqx))),(XAv),(1),w)set oMx=XEe+1set oOr=(GetRandomInt((1),(XEe)))loop
exitwhen(oMx<1)if(oMx==oOr)then
call RKr(Cqx,x,y,Xfe)else
set Rbr=Rur(RYr,C3o,wQo,wso,Ryr,XFe,Xge)
call Rpr(Rbr,.5)
call rwx(Rbr,E9e,oSx)call Avx(Rbr,Xne)call Dux((((Rbr))),(XAv),(1),w)call dQx(RNr,Rbr)call PauseUnit(C[Rbr],true)call fwx(Rbr,wQo)call fWx(Rbr,wso)call RKr(Rbr,x,y,Xfe)endifset oMx=oMx-1set x=x+N5xset y=y+N6xendloopcall iDx(iCx,Xfe,false,function Rwr)
return trueendfunctionfunction Rzr takes nothing returns booleanset E8e=Xdx("Realplex_Init: set Realplex.CASTER_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Realplex.Event_Caster_Death)",VP,MI,function RBr)set Xae=O5x()set Xne=Xdx("Realplex_Init: set Realplex.ILLUSION_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Realplex.Event_Illusion_Death)",VP,MI,function RCr)call mro(Gbv,Xdx("Realplex_Init: call Realplex.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Realplex.Event_SpellEffect))",ih,MI,function RWr))return trueendfunctionfunction RZr takes nothing returns booleancall Vrr(function Rzr,"Realplex_Init")return trueendfunctionfunction R_r takes nothing returns booleancall L1x('ASeW',false)set GLv=L0o('ASeW')set K6[(GLv)]=(H6)set m6[(GLv)]=(1)set TH[(GLv)]=("Serpent Ward")set Rh[(GLv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0218)))),(((Aj))))))set oxv[(GLv)]=(2)set x3v[(GLv)]=("spell")
call L1o((GLv),GH+(1),(($F)*1.))
call L1o((GLv),tH+(1),((55)*1.))
call L1o((GLv),Lov+(1),((550)*1.))set MOv[(GLv)]=("ReplaceableTextures\\CommandButtons\\BTNSerpentWard.blp")return trueendfunctionfunction R0r takes nothing returns booleanset XGe=hjo('uSeW')call hJo(((XGe)),ASv,(Idv))set Uj[(XGe)]=((1)*1.)set NOv[(XGe)]=((60)*1.)
set NWv[(XGe)]=(($E1)*1.)set I8v[(XGe)]=((0)*1.)set Anv[(XGe)]=(2)set Nmv[(XGe)]=(('d')*1.)set NLv[(XGe)]=(('d')*1.)set NKv[(XGe)]=((0)*1.)set Ncv[(XGe)]=(($4B0)*1.)set Nbv[(XGe)]=(($4B0)*1.)set NGv[(XGe)]=((35)*1.)
set Adv[(XGe)]=(guv)
set AGv[(XGe)]=((720)*1.)set Ahv[((XGe))]=((1.*1./((1.5)*1.))*1.)
set AWv[(XGe)]=((.3)*1.)
set Dnv[(XGe)]=((900)*1.)set Auv[(XGe)]=(($C)*1.)
set AUv[(XGe)]=(($C)*1.)
set AYv[(XGe)]=(1)set A_v[(XGe)]=(3)set A2v[(XGe)]=(1)set ATv[(XGe)]=((16)*1.)
return trueendfunctionfunction R1r takes nothing returns booleancall VNx(Pa,(function R_r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\SerpentWard.page\\SerpentWard.struct\\obj_thisSpell_wc3spell.j"))call VNx(sa,(function R0r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\SerpentWard.page\\SerpentWard.struct\\obj_summonUnitType_wc3unit.j"))return trueendfunctionfunction R2r takes nothing returns booleanset Xhe=VXx(XHe)
return trueendfunctionfunction R3r takes integer oSx returns integerset Xle[oSx]=trueset XLe[oSx]=falsecall rEx(Xhe)return oSxendfunctionfunction R4r takes nothing returns integerlocal integer oSxif(Xje==8190)thencall o_x("SerpentWard_Allocation_allocCustom","call DebugEx(SerpentWard.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",XHe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(XJe[(w)]==w)thenset Xke=Xke+1set oSx=Xkeelse
set oSx=XJe[(w)]
set XJe[(w)]=XJe[XJe[(w)]]endifset XJe[oSx]=Zset XKe[oSx]=1call R3r(oSx)return oSxendfunctionfunction R5r takes integer oSx returns nothingset Xle[oSx]=falsecall rHx(Xhe)endfunctionfunction R6r takes integer oSx returns nothingif(XKe[oSx]>0)thenreturnendifif(XJe[oSx]!=Z)thencall o_x("SerpentWard_Allocation_deallocCustom_confirm","call DebugEx(SerpentWard.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",XHe+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset XJe[oSx]=XJe[(w)]set XJe[(w)]=oSx
call R5r(oSx)endfunctionfunction R7r takes integer oSx returns nothingset XKe[oSx]=XKe[oSx]-1call R6r(oSx)endfunctionfunction R8r takes integer Cqx,real dVx,real dEx returns nothing
local integer C3o=(ze[(Cqx)])local integer oMx=XPeloop
call U0o(XGe,C3o,dVx,dEx,kf,Xqe)
set oMx=oMx-1exitwhen(oMx<1)endloopendfunctionfunction R9r takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=Xme[oSx]local real dVx=XMe[oSx]local real dEx=Xpe[oSx]call R7r((oSx))call MFo(Mho)call R8r(Cqx,dVx,dEx)return trueendfunctionfunction Ivr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local integer oSx=R4r()local integer Mho=Moo()set Xme[oSx]=Cqx
set XMe[oSx]=dVx
set Xpe[oSx]=dEx
set mcv[((Mho))]=((Bev*((.1)*1.))*1.)set mCv[(Mho)]=((10.)*1.)call Mno(Mho,'qSeW',2.)set mFv[(Mho)]=Xkx((function R9r))set mZv[(Mho)]=(oSx)
call Meo(Mho,900.)call pxo(Mho,Cqx)call o9r(Mho,dVx,dEx,X_x(dVx,dEx))return trueendfunctionfunction Ier takes nothing returns booleancall mro(GLv,Xdx("SerpentWard_Init: call SerpentWard.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SerpentWard.Event_SpellEffect))",ih,MI,function Ivr))return trueendfunctionfunction Ixr takes nothing returns booleancall Vrr(function Ier,"SerpentWard_Init")return trueendfunctionfunction Ior takes nothing returns booleanset XQe=hjo('uSpW')call hJo(((XQe)),ASv,(Idv))set Uj[(XQe)]=((1.25)*1.)set NOv[(XQe)]=((49.586776859504)*1.)set NWv[(XQe)]=((49.586776859504)*1.)set I8v[(XQe)]=((0)*1.)set Anv[(XQe)]=(2)set Nmv[(XQe)]=((300)*1.)set NLv[(XQe)]=((300)*1.)set NKv[(XQe)]=((0)*1.)set Ncv[(XQe)]=(($4B0)*1.)set Nbv[(XQe)]=(($4B0)*1.)set NGv[(XQe)]=((45)*1.)
set Adv[(XQe)]=(gkv)
set AGv[(XQe)]=(('l')*1.)set Ahv[((XQe))]=((1.*1./((1)*1.))*1.)set AWv[(XQe)]=((.33)*1.)set Auv[(XQe)]=(($F)*1.)
set AUv[(XQe)]=(($F)*1.)
set AYv[(XQe)]=(1)set A_v[(XQe)]=(2)set A2v[(XQe)]=(0)set ATv[(XQe)]=((26.446280991736)*1.)return trueendfunctionfunction Irr takes nothing returns booleancall L1x('ASpW',false)set Gsv=L0o('ASpW')set K6[(Gsv)]=(H6)set m6[(Gsv)]=(1)set TH[(Gsv)]=("Spirit Wolves")set Rh[(Gsv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D009E)))),(((Aj))))))set oxv[(Gsv)]=(0)set x3v[(Gsv)]=("spell")
call L1o((Gsv),GH+(1),((22)*1.))
call L1o((Gsv),tH+(1),(('}')*1.))call L1o((Gsv),Lov+(1),((750)*1.))set MOv[(Gsv)]=("ReplaceableTextures\\CommandButtons\\BTNSpiritWolf.blp")return trueendfunctionfunction Iir takes nothing returns booleancall VNx(sa,(function Ior),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\SpiritWolves.page\\SpiritWolves.struct\\obj_summonUnitType_wc3unit.j"))call VNx(Pa,(function Irr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\SpiritWolves.page\\SpiritWolves.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Iar takes nothing returns booleanset Xse=VXx(XSe)
return trueendfunctionfunction Inr takes integer oSx returns nothingset XYe[oSx]=falsecall rHx(Xse)endfunctionfunction IVr takes integer oSx returns nothingif(XWe[oSx]>0)thenreturnendifif(Xye[oSx]!=Z)thencall o_x("SpiritWolves_Allocation_deallocCustom_confirm","call DebugEx(SpiritWolves.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",XSe+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset Xye[oSx]=Xye[(w)]set Xye[(w)]=oSx
call Inr(oSx)endfunctionfunction IEr takes integer oSx returns nothingset XWe[oSx]=XWe[oSx]-1call IVr(oSx)endfunctionfunction IXr takes nothing returns booleanlocal integer rFx=(bv)local integer IOr=(Vv[(rFx)])local integer oSx=osx(IOr,XTe)local integer IRr=Xue[oSx]local integer Cqxlocal integer Ctxcall rVx(IOr,XTe)call RPx(IOr,Xte)call IRo(IRr,IOr)if(dmx((IRr),Ob))thenset Cqx=XUe[oSx]
set Ctx=Xwe[oSx]
call IEr((oSx))call rVx(Cqx,XTe)call X_r(IRr)call dNx(Ctx)endifreturn trueendfunctionfunction IIr takes integer oSx returns nothingset ns[oSx]=(ns[(oSx)])+1endfunctionfunction IAr takes integer oSx returns nothinglocal integer oux=(ns[(oSx)])-1set ns[oSx]=ouxif((oux==0)and Vs[oSx])thencall X_r((oSx))endifendfunctionfunction INr takes integer oSx returns nothinglocal integer IRr=Xue[oSx]local integer IOr=(OUx((IRr),Ob))call IIr(IRr)loop
call Crx((IOr),w)set IOr=(OUx((IRr),Ob))exitwhen(IOr==w)
endloopcall IAr(IRr)endfunctionfunction Ibr takes integer oSx returns integerset XYe[oSx]=trueset X0e[oSx]=falsecall rEx(Xse)return oSxendfunctionfunction IBr takes nothing returns integerlocal integer oSxif(XZe==8190)thencall o_x("SpiritWolves_Allocation_allocCustom","call DebugEx(SpiritWolves.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",XSe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Xye[(w)]==w)thenset X_e=X_e+1set oSx=X_eelse
set oSx=Xye[(w)]
set Xye[(w)]=Xye[Xye[(w)]]endifset Xye[oSx]=Zset XWe[oSx]=1call Ibr(oSx)return oSxendfunctionfunction Icr takes integer oSx,integer C3o,real wQo,real wso,real bex,integer IRr returns integerlocal integer IOr=U0o(XQe,C3o,wQo,wso,bex,X2e)call rwx(IOr,XTe,oSx)call Avx(IOr,Xte)call dQx(IRr,IOr)return IOrendfunctionfunction ICr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oSx=osx(Cqx,XTe)local integer oMxlocal integer IRrlocal real bexlocal integer C3olocal real wQolocal real wsolocal integer IOrif(oSx!=w)thencall INr(oSx)endifset oMx=Xzeif(oMx>0)thenset oSx=IBr()set IRr=Jbx("SpiritWolves_Event_SpellEffect: set summonGroup = UnitList.Create()")set XUe[oSx]=Cqx
set Xue[oSx]=IRr
set Xwe[oSx]=CPx(Cqx,Gsv)call rwx(Cqx,XTe,oSx)set bex=(GetUnitFacing(C[((Cqx))])*Nh)set C3o=(ze[(Cqx)])set wQo=(GetUnitX(C[((Cqx))]))+X1e*(Cos(((((bex)*1.))*1.)))set wso=(GetUnitY(C[((Cqx))]))+X1e*(Sin(((((bex)*1.))*1.)))loop
set IOr=Icr(oSx,C3o,wQo,wso,bex,IRr)
set oMx=oMx-1exitwhen(oMx<1)endloopendifreturn trueendfunctionfunction Idr takes nothing returns booleanset Xte=Xdx("SpiritWolves_Init: set SpiritWolves.SUMMON_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SpiritWolves.Event_Summon_Death)",VP,MI,function IXr)call mro(Gsv,Xdx("SpiritWolves_Init: call SpiritWolves.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SpiritWolves.Event_SpellEffect))",ih,MI,function ICr))return trueendfunctionfunction IDr takes nothing returns booleancall Vrr(function Idr,"SpiritWolves_Init")return trueendfunctionfunction Ifr takes nothing returns booleancall L1x('AStb',false)set GBv=L0o('AStb')set K6[(GBv)]=(H6)set m6[(GBv)]=(1)set TH[(GBv)]=("Stormbolt")set Rh[(GBv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D007F)))),(((Aj))))))set oxv[(GBv)]=(4)set x3v[(GBv)]=("spell")
call L1o((GBv),GH+(1),(($F)*1.))
call L1o((GBv),tH+(1),((80)*1.))
call L1o((GBv),Lov+(1),((700)*1.))set MOv[(GBv)]=("ReplaceableTextures\\CommandButtons\\BTNStormBolt.blp")
return trueendfunctionfunction IFr takes nothing returns booleancall VNx(Pa,(function Ifr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\Stormbolt.page\\Stormbolt.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Igr takes nothing returns booleanset X3e=VXx(X4e)
return trueendfunctionfunction IGr takes integer oSx returns integerset X5e[oSx]=trueset X6e[oSx]=falsecall rEx(X3e)return oSxendfunctionfunction Ihr takes integer oSx returns nothingset X5e[oSx]=falsecall rHx(X3e)endfunctionfunction IHr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=X7e[oSx]call Ihr(oSx)call MFo(Mho)if(Iix==w)thenreturn trueendifif nbo(Iix)thenreturn trueendifcall Nbx((Iix),(Xwv),(X8e[oSx]),w,((X9e)*1.))call nlo((Cqx),(Iix),((Ove)*1.),(true),(false))return trueendfunctionfunction Ijr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local integer Mho=Moo()local integer oSx=IGr(Mho)set X7e[oSx]=Cqx
set X8e[oSx]=rYx
set mCv[(Mho)]=((10.)*1.)call Mno(Mho,'qStb',2.)set mFv[(Mho)]=Xkx((function IHr))set mZv[(Mho)]=(oSx)
call Meo(Mho,700.)call pxo(Mho,Cqx)call M6o((Mho),(Iix),.0,.0,.0,(null))return trueendfunctionfunction IJr takes nothing returns booleancall mro(GBv,Xdx("Stormbolt_Init: call Stormbolt.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Stormbolt.Event_SpellEffect))",ih,MI,function Ijr))
return trueendfunctionfunction Ikr takes nothing returns booleancall Vrr(function IJr,"Stormbolt_Init")return trueendfunctionfunction IKr takes nothing returns booleancall L1x('ASuM',false)set hAv=L0o('ASuM')set K6[(hAv)]=(H6)set m6[(hAv)]=(1)set TH[(hAv)]=("Summon Minions")
set Rh[(hAv)]=((LoadInteger(o[((V[(E[((X))])]))],((((OrderId("summonGrizzly"))))),(((Aj))))))set oxv[(hAv)]=(0)set x3v[(hAv)]=("spell")
call L1o((hAv),dH+(1),(($A)*1.))
call L1o((hAv),GH+(1),((30)*1.))
call L1o((hAv),tH+(1),((0)*1.))call L1o((hAv),Lov+(1),((750)*1.))set MOv[(hAv)]=("ReplaceableTextures\\CommandButtons\\BTNMassTeleport.blp")set Oee=hDvset Oxe=G3vreturn trueendfunctionfunction Ilr takes nothing returns booleanset Ooe=ltx(Ore+" (dummyBuff)")return trueendfunctionfunction ILr takes nothing returns booleancall VNx(Pa,(function IKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\SummonMinions.page\\SummonMinions.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function Ilr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Act2\\SummonMinions.page\\SummonMinions.struct\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction Imr takes nothing returns booleanset Oie=VXx(Ore)
return trueendfunctionfunction IMr takes integer oSx,integer otx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((OIe[(oSx)]))])]))],((((OAe[((oSx))])))),(((otx)+(oLx)))))endfunctionfunction Ipr takes integer oSx,integer otx returns realreturn(LoadReal(o[((V[(E[((OIe[(oSx)]))])]))],((((OAe[((oSx))])))),(((otx)))))endfunctionfunction IPr takes integer oSx returns integerlocal integer oMx=qlocal real oOr=(GetRandomReal(((.0)*1.),((ORe[oSx])*1.)))local real Iqr=.0local integer rNxloop
set rNx=IMr(oSx,ONe,oMx)
set Iqr=Iqr+Ipr(oSx,Obe+rNx)
exitwhen(oOr<=Iqr)set oMx=oMx+1endloopreturn rNxendfunctionfunction IQr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=oSxlocal real bex=(GetRandomReal(((.0)*1.),((Cf)*1.)))local integer C3o=(ze[(Cqx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real x=wQo-OXe*(Cos(((((bex)*1.))*1.)))local real y=wso-OXe*(Sin(((((bex)*1.))*1.)))local integer oMx=OOelocal integer lColocal integer l0oloop
exitwhen(oMx<1)set lCo=IPr(OBe)
set l0o=U0o(lCo,C3o,x,y,bex,Oce)
call fJx((l0o),-((.0)*1.),-((.0)*1.),-((.0)*1.),-(((NZv[(lCo)]))*1.))call fsx(l0o,.0,.0,.0,(NZv[(lCo)]),1.)set oMx=oMx-1endloopendfunctionfunction Isr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(hc[(rFx)])local integer oSx=Cqxlocal integer p3x=iXx()set OVe[oSx]=p3x
set OEe[oSx]=rYx
set ge[(p3x)]=(oSx)call iDx(p3x,Oae,true,function IQr)return trueendfunctionfunction ISr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oSx=Cqxlocal integer p3x=OVe[oSx]call iKx(p3x)return trueendfunctionfunction Itr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),Ooe)return trueendfunctionfunction ITr takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(Ooe),((Mv[(rFx)])),w)return trueendfunctionfunction Iur takes integer oSx returns integerset OFe[oSx]=trueset Oge[oSx]=falseset OIe[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])call rEx(e1v)return oSxendfunctionfunction IUr takes nothing returns integerlocal integer oSxif(OCe==8190)thencall o_x("UnitTypePool_Allocation_allocCustom","call DebugEx(UnitTypePool.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",e2v+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Ode[(w)]==w)thenset ODe=ODe+1set oSx=ODeelse
set oSx=Ode[(w)]
set Ode[(w)]=Ode[Ode[(w)]]endifset Ode[oSx]=Zset Ofe[oSx]=1call Iur(oSx)return oSxendfunctionfunction Iwr takes integer oSx returns nothingset OAe[(oSx)]=(OGe+oSx)
endfunctionfunction IWr takes nothing returns integerlocal integer oSx=IUr()set ORe[oSx]=.0call Iwr(oSx)return oSxendfunctionfunction Iyr takes integer oSx,integer otx,integer oux returns booleanreturn rux(OIe[(oSx)],(OAe[((oSx))]),otx,oux)endfunctionfunction IYr takes integer oSx,integer otx,real oux returns nothingcall SaveReal(o[((V[(E[((OIe[(oSx)]))])]))],((((OAe[((oSx))])))),(((otx))),((((((oux)*1.))*1.))*1.))
endfunctionfunction Izr takes integer oSx,integer rNx,real IZr returns nothingset ORe[oSx]=ORe[oSx]+IZrcall Iyr(oSx,ONe,rNx)call IYr(oSx,Obe+rNx,IZr)endfunctionfunction I_r takes nothing returns booleanset Oae=(CQx((hAv),dH+(1)))*1./ One-.01call Lxx(Ooe,Xdx("SummonMinions_Init: call SummonMinions.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SummonMinions.Event_BuffGain))",bd,MI,function Isr))call Lxx(Ooe,Xdx("SummonMinions_Init: call SummonMinions.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SummonMinions.Event_BuffLose))",jc,MI,function ISr))call mro(hAv,Xdx("SummonMinions_Init: call SummonMinions.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SummonMinions.Event_EndCast))",onv,MI,function Itr))call mro(hAv,Xdx("SummonMinions_Init: call SummonMinions.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SummonMinions.Event_SpellEffect))",ih,MI,function ITr))
set OBe=IWr()call Izr(OBe,G3v,Ohe)call Izr(OBe,hDv,OHe)return trueendfunctionfunction I0r takes nothing returns booleancall Vrr(function I_r,"SummonMinions_Init")return trueendfunctionfunction I1r takes nothing returns booleanset Oje=hjo('uArS')call hJo(((Oje)),ASv,(Igv))call hJo(((Oje)),ASv,(Idv))set Uj[(Oje)]=((1.5)*1.)
set NOv[(Oje)]=(('x')*1.)set NWv[(Oje)]=((60)*1.)
set I8v[(Oje)]=((0)*1.)set Anv[(Oje)]=(3)set Nmv[(Oje)]=((150000.)*1.)set NLv[(Oje)]=((150000.)*1.)set NKv[(Oje)]=((0)*1.)set Ncv[(Oje)]=((500)*1.)set Nbv[(Oje)]=((500)*1.)set Auv[(Oje)]=((0)*1.)set AUv[(Oje)]=((0)*1.)set AYv[(Oje)]=(0)set A_v[(Oje)]=(0)return trueendfunctionfunction I2r takes nothing returns booleancall VNx(sa,(function I1r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\Artifact.page\\Artifact.struct\\obj_thisUnitType_wc3unit.j"))return trueendfunctionfunction I3r takes nothing returns booleanset SXv=VXx(Srv)
return trueendfunctionfunction I4r takes nothing returns booleanset Sxv=falsereturn trueendfunctionfunction I5r takes nothing returns booleancall kSo(function I4r,"Artifact_Init")return trueendfunctionfunction I6r takes nothing returns booleanreturn trueendfunctionfunction I7r takes nothing returns booleanset OJe=VXx(Oke)
return trueendfunctionfunction I8r takes nothing returns booleanset OKe=ltx(Ole+" (eclipseBuff)")set Pc[(OKe)]=(true)
return trueendfunctionfunction I9r takes nothing returns booleancall L1x('ABaS',false)set SRv=L0o('ABaS')set K6[(SRv)]=(f6)set m6[(SRv)]=(6)set TH[(SRv)]=("Bat Swarm")set Rh[(SRv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Aj))))))set oxv[(SRv)]=(4)set x3v[(SRv)]=("spell")
call L1o((SRv),Uvv+(1),((400)*1.))call L1o((SRv),GH+(1),(($E)*1.))
call L1o((SRv),tH+(1),((75)*1.))
call L1o((SRv),Lov+(1),((800)*1.))call L1o((SRv),Uvv+(2),((400)*1.))call L1o((SRv),GH+(2),(($E)*1.))
call L1o((SRv),tH+(2),((85)*1.))
call L1o((SRv),Lov+(2),((800)*1.))call L1o((SRv),Uvv+(3),((400)*1.))call L1o((SRv),GH+(3),(($E)*1.))
call L1o((SRv),tH+(3),((95)*1.))
call L1o((SRv),Lov+(3),((800)*1.))call L1o((SRv),Uvv+(4),((400)*1.))call L1o((SRv),GH+(4),(($E)*1.))
call L1o((SRv),tH+(4),(('i')*1.))call L1o((SRv),Lov+(4),((800)*1.))call L1o((SRv),Uvv+(5),((400)*1.))call L1o((SRv),GH+(5),(($E)*1.))
call L1o((SRv),tH+(5),(('s')*1.))call L1o((SRv),Lov+(5),((800)*1.))call L1o((SRv),Uvv+(6),((400)*1.))call L1o((SRv),GH+(6),(($E)*1.))
call L1o((SRv),tH+(6),(('}')*1.))call L1o((SRv),Lov+(6),((800)*1.))set MOv[(SRv)]=("ReplaceableTextures\\CommandButtons\\BTNCarrionSwarm.blp")set OLe[1]=7
set OLe[2]=7
set OLe[3]=7
set OLe[4]=7
set OLe[5]=7
set OLe[6]=7
set Ome[1]=7
set Ome[2]=7
set Ome[3]=7
set Ome[4]=7
set Ome[5]=7
set Ome[6]=7
set OMe[1]=20set OMe[2]=25set OMe[3]=30set OMe[4]=35set OMe[5]=40set OMe[6]=45set Ope[1]=3
set Ope[2]=3
set Ope[3]=3
set Ope[4]=3
set Ope[5]=3
set Ope[6]=3
set OPe[1]=20set OPe[2]=30set OPe[3]=45set OPe[4]=65set OPe[5]=90set OPe[6]='x'return trueendfunctionfunction Avr takes nothing returns booleancall VNx(ma,(function I8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\BatSwarm.page\\BatSwarm.struct\\obj_eclipseBuff_wc3buff.j"))call VNx(Pa,(function I9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\BatSwarm.page\\BatSwarm.struct\\obj_thisSpell_wc3spell.j"))
return trueendfunctionfunction Aer takes nothing returns booleanset Oqe=VXx(Ole)
return trueendfunctionfunction Axr takes code c,string rSx returns nothing
set Pn=Pn+1set qn[Pn]=CreateTrigger()set Qn[Pn]=(GetHandleId(Condition((c))))
set sn[Pn]=rSxcall TriggerAddCondition(qn[Pn],Condition(c))endfunctionfunction Aor takes nothing returns booleanlocal integer Iix=jhx()if(I8x((Ose),Ob,(Iix)))thenreturn false
endifif(Iix==Rb)thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif I9x(Iix,Ijv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction Arr takes integer oSx returns integerset OUe[oSx]=trueset Owe[oSx]=falsecall rEx(Oqe)return oSxendfunctionfunction Air takes nothing returns integerlocal integer oSxif(OSe==8190)thencall o_x("BatSwarm_Allocation_allocCustom","call DebugEx(BatSwarm.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Ole+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Ote[(w)]==w)thenset OTe=OTe+1set oSx=OTeelse
set oSx=Ote[(w)]
set Ote[(w)]=Ote[Ote[(w)]]endifset Ote[oSx]=Zset Oue[oSx]=1call Arr(oSx)return oSxendfunctionfunction Aar takes integer oSx returns nothingset OUe[oSx]=falsecall rHx(Oqe)endfunctionfunction Anr takes integer oSx returns nothingif(Oue[oSx]>0)thenreturnendifif(Ote[oSx]!=Z)thencall o_x("BatSwarm_Allocation_deallocCustom_confirm","call DebugEx(BatSwarm.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Ole+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset Ote[oSx]=Ote[(w)]set Ote[(w)]=oSx
call Aar(oSx)endfunctionfunction AVr takes integer oSx returns nothingset Oue[oSx]=Oue[oSx]-1call Anr(oSx)endfunctionfunction AEr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=OWe[oSx]local real AXr=OYe[oSx]local integer Iix=Oze[oSx]call AVr((oSx))call MFo(Mho)call mao(Cqx,Iix,AXr)return trueendfunctionfunction AOr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer ARr=(Vv[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=OWe[oSx]local integer Iix=Oze[oSx]call MFo(Mho)if not I9x(ARr,Qc)thencall Ryx((ACx((ARr),(OZe),(O_e),(Bi))))call nlo((Cqx),(ARr),((Oye[oSx])*1.),(false),(false))endifif not(IsUnitAlly(C[(Iix)],vx[((ze[(Cqx)]))]))thencall AVr((oSx))return trueendifset Mho=Moo()set mcv[((Mho))]=((Bev*((.06)*1.))*1.)set mCv[(Mho)]=((8.)*1.)
call Mno(Mho,'qBST',1.5)
set mFv[(Mho)]=Xkx((function AEr))set mZv[(Mho)]=(oSx)
call Meo(Mho,500.)call pxo(Mho,ARr)call M6o((Mho),(Cqx),.0,.0,.0,(null))return trueendfunctionfunction AIr takes integer Ctx returns nothinglocal integer Cqx=(EH[(Ctx)])local integer rYx=(IH[(Ctx)])local integer Iix=(Wh[(Ctx)])local integer C3o=(ze[(Cqx)])local real O4olocal real dVxlocal real dExlocal integer AArlocal integer oMxlocal integer ARrlocal integer oSxlocal integer Mhoif(IsUnitAlly(C[(Iix)],vx[(C3o)]))thencall Nbx((Iix),(aSv),(rYx),w,((Ome[rYx])*1.))else
call Nbx((Iix),(OKe),(rYx),w,((OLe[rYx])*1.))endifset O4o=(CQx((SRv),Uvv+(rYx)))set dVx=(GetUnitX(C[((Iix))]))set dEx=(GetUnitY(C[((Iix))]))set AAr=Jbx("BatSwarm_Start: set enemyGroup = UnitList.Create()")set oMx=Ope[rYx]
loop
exitwhen(oMx<1)set hf=C3oset Ose=AArset Rb=Iixset ARr=wro(dVx,dEx,O4o,OQe)
exitwhen(ARr==w)
set oSx=Air()set Mho=Moo()set OWe[oSx]=Cqx
set Oye[oSx]=OPe[rYx]set OYe[oSx]=OMe[rYx]set Oze[oSx]=Iix
call dQx(AAr,ARr)set mcv[((Mho))]=((Bev*((.06)*1.))*1.)set mCv[(Mho)]=((8.)*1.)
call SetUnitColor(vJ[((Mno(Mho,'qBaS',.5)))],((ox[(C3o)])))set mFv[(Mho)]=Xkx((function AOr))set mZv[(Mho)]=(oSx)
call Meo(Mho,500.)call pxo(Mho,Iix)call M6o((Mho),(ARr),.0,.0,.0,(null))set oMx=oMx-1endloopcall X_r(AAr)endfunctionfunction ANr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer Ctx=(mZv[(Mho)])call MFo(Mho)call AIr(Ctx)call Usx(Ctx)return trueendfunctionfunction Abr takes integer Ctx returns nothinglocal integer Mho=Moo()call Ucx(Ctx)set mcv[((Mho))]=((Bev*((.4)*1.))*1.)set mCv[(Mho)]=((32.)*1.)call Mno(Mho,'qBSM',1.)set mFv[(Mho)]=Xkx((function ANr))set mZv[(Mho)]=(Ctx)
call Meo(Mho,900.)call pxo(Mho,(EH[(Ctx)]))call M6o((Mho),((Wh[(Ctx)])),.0,.0,.0,(null))endfunctionfunction ABr takes nothing returns booleanlocal integer rFx=(bv)local integer Ctx=(WH[(rFx)])if((Wh[(Ctx)])==(EH[(Ctx)]))then
call AIr(Ctx)else
call Abr(Ctx)endifreturn trueendfunctionfunction Acr takes nothing returns booleanset OQe=Xpx(function Aor)call mro(SRv,Xdx("BatSwarm_Init: call BatSwarm.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BatSwarm.Event_SpellEffect))",ih,MI,function ABr))call W2x(EDv,OKe)return trueendfunctionfunction ACr takes nothing returns booleancall Axr(function Acr,"BatSwarm_Init")return trueendfunctionfunction Adr takes nothing returns booleanset O0e=ltx(O1e+" (bleedingBuff)")return trueendfunctionfunction ADr takes nothing returns booleancall L1x('AHaE',false)set SOv=L0o('AHaE')set K6[(SOv)]=(f6)set m6[(SOv)]=(6)set TH[(SOv)]=("Hawk Eye")set Rh[(SOv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Aj))))))set oxv[(SOv)]=(0)set x3v[(SOv)]=("spell")
call L1o((SOv),Uvv+(1),((750)*1.))call L1o((SOv),GH+(1),(($A)*1.))
call L1o((SOv),tH+(1),((30)*1.))
call L1o((SOv),Lov+(1),((750)*1.))call L1o((SOv),Uvv+(2),((750)*1.))call L1o((SOv),GH+(2),(($A)*1.))
call L1o((SOv),tH+(2),((40)*1.))
call L1o((SOv),Lov+(2),((750)*1.))call L1o((SOv),Uvv+(3),((750)*1.))call L1o((SOv),GH+(3),(($A)*1.))
call L1o((SOv),tH+(3),((50)*1.))
call L1o((SOv),Lov+(3),((750)*1.))call L1o((SOv),Uvv+(4),((750)*1.))call L1o((SOv),GH+(4),(($A)*1.))
call L1o((SOv),tH+(4),((60)*1.))
call L1o((SOv),Lov+(4),((750)*1.))call L1o((SOv),Uvv+(5),((750)*1.))call L1o((SOv),GH+(5),(($A)*1.))
call L1o((SOv),tH+(5),((70)*1.))
call L1o((SOv),Lov+(5),((750)*1.))call L1o((SOv),Uvv+(6),((750)*1.))call L1o((SOv),GH+(6),(($A)*1.))
call L1o((SOv),tH+(6),((80)*1.))
call L1o((SOv),Lov+(6),((750)*1.))set MOv[(SOv)]=("ReplaceableTextures\\CommandButtons\\BTNScout.blp")
set O2e[1]=$Fset O2e[2]=20set O2e[3]=25set O2e[4]=30set O2e[5]=35set O2e[6]=40set O3e[1]=-.1set O3e[2]=-.1set O3e[3]=-.2set O3e[4]=-.2set O3e[5]=-.3set O3e[6]=-.3set O4e[1]=$Aset O4e[2]=$Aset O4e[3]=$Aset O4e[4]=$Aset O4e[5]=$Aset O4e[6]=$Aset O5e[1]=3
set O5e[2]=3
set O5e[3]=3
set O5e[4]=3
set O5e[5]=3
set O5e[6]=3
set O6e[1]=5
set O6e[2]=5
set O6e[3]=5
set O6e[4]=5
set O6e[5]=5
set O6e[6]=5
return trueendfunctionfunction Afr takes nothing returns booleanset O7e=ltx(O1e+" (dummyBuff)")set Pc[(O7e)]=(true)
call lWx(O7e,"HawkEye_page\\HawkEye_struct\\buff2.mdx","overhead",ri)set WU=l_x()
call l2x(WU,nav,-.1)
call l3x(((O7e)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,nav,-.1)
call l3x(((O7e)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,nav,-.2)
call l3x(((O7e)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,nav,-.2)
call l3x(((O7e)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,nav,-.3)
call l3x(((O7e)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,nav,-.3)
call l3x(((O7e)),ZB+(6),(WU))return trueendfunctionfunction AFr takes nothing returns booleancall VNx(ma,(function Adr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\HawkEye.page\\HawkEye.struct\\obj_bleedingBuff_wc3buff.j"))
call VNx(Pa,(function ADr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\HawkEye.page\\HawkEye.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function Afr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\HawkEye.page\\HawkEye.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction Agr takes nothing returns booleanset O8e=VXx(O1e)
return trueendfunctionfunction AGr takes nothing returns booleanlocal integer rFx=(bv)local integer Ahr=(E2v[(rFx)])local integer Iix=(Vv[(rFx)])local integer rYx=(osx(((Iix)),Yb+(O7e)))call Nbx(Iix,O0e,rYx,Ahr,O6e[rYx])return trueendfunctionfunction AHr takes integer oSx returns integerset Rie[oSx]=trueset Rae[oSx]=falsecall rEx(O8e)return oSxendfunctionfunction Ajr takes nothing returns integerlocal integer oSxif(Ree==8190)thencall o_x("HawkEye_Allocation_allocCustom","call DebugEx(HawkEye.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",O1e+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Rxe[(w)]==w)thenset Roe=Roe+1set oSx=Roeelse
set oSx=Rxe[(w)]
set Rxe[(w)]=Rxe[Rxe[(w)]]endifset Rxe[oSx]=Zset Rre[oSx]=1call AHr(oSx)return oSxendfunctionfunction AJr takes integer oSx returns nothingset Rie[oSx]=falsecall rHx(O8e)endfunctionfunction Akr takes integer oSx returns nothingif(Rre[oSx]>0)thenreturnendifif(Rxe[oSx]!=Z)thencall o_x("HawkEye_Allocation_deallocCustom_confirm","call DebugEx(HawkEye.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",O1e+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Rxe[oSx]=Rxe[(w)]set Rxe[(w)]=oSx
call AJr(oSx)endfunctionfunction AKr takes integer oSx returns nothingset Rre[oSx]=Rre[oSx]-1call Akr(oSx)endfunctionfunction Alr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=(mZv[(Mho)])local real ALr=Rne[oSx]call MFo(Mho)call AKr((oSx))if(Iix==w)thenreturn trueendifcall mno(Iix,Iix,ALr)return trueendfunctionfunction Amr takes integer o0x,integer Iix,real ALr returns nothinglocal integer oSx=Ajr()local integer Mho=Moo()set Rne[oSx]=ALr
set mcv[((Mho))]=((Bev*((.1)*1.))*1.)set mCv[(Mho)]=((32.)*1.)call Mno(Mho,'qHaE',1.25)set mFv[(Mho)]=Xkx((function Alr))set mZv[(Mho)]=(oSx)
call Meo(Mho,500.)call pxo(Mho,o0x)call M6o((Mho),(Iix),.0,.0,.0,(null))endfunctionfunction AMr takes nothing returns booleanlocal integer rFx=(bv)local integer cfx=(fG[(rFx)])local integer Iix=(Vv[(rFx)])local integer rYx=(osx(((Iix)),Yb+(O7e)))local integer Apr=(kv[((ze[(cfx)]))])if((Apr!=w)and not I9x(Apr,Qc))thenset cfx=Aprendifcall Amr(Iix,cfx,O2e[rYx])return trueendfunctionfunction APr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction Aqr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall Avx(Iix,O9e)call Avx(Iix,Rve)call Dux((((Iix))),(nLv),(1),w)return trueendfunctionfunction AQr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall RPx(Iix,O9e)call RPx(Iix,Rve)call Ulx(((Iix)),nLv)return trueendfunctionfunction Asr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local string ASr
local integer Iixlocal integer Efrif(ci==ri)thenset ASr=RXeelse
set ASr=ROeendifcall mho((mko(((wQo)*1.),((wso)*1.),(ASr),(ri))))set hf=(ze[(Cqx)])call NVo(RVe,wQo,wso,(CQx((SOv),Uvv+(rYx))),REe)
set Iix=(mKo((RVe),((wQo)*1.),((wso)*1.)))if(Iix!=w)thenset Efr=O5e[rYx]
loop
call GroupRemoveUnit(kb[(RVe)],C[(Iix)])
call Nbx((Iix),(O7e),(rYx),w,((O4e[rYx])*1.))set Efr=Efr-1exitwhen(Efr<1)set Iix=(mKo((RVe),((wQo)*1.),((wso)*1.)))exitwhen(Iix==w)
endloopendifreturn trueendfunctionfunction Atr takes nothing returns booleanset O9e=Xdx("HawkEye_Init: set HawkEye.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.SPELLS, function HawkEye.Event_Damage)",E3v,MI,function AGr)set Rve=Xdx("HawkEye_Init: set HawkEye.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HawkEye.Event_Death)",VP,MI,function AMr)set RVe=O5x()set REe=Xpx(function APr)call Lxx(O7e,Xdx("HawkEye_Init: call HawkEye.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HawkEye.Event_BuffGain))",bd,MI,function Aqr))call Lxx(O7e,Xdx("HawkEye_Init: call HawkEye.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HawkEye.Event_BuffLose))",jc,MI,function AQr))call mro(SOv,Xdx("HawkEye_Init: call HawkEye.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HawkEye.Event_SpellEffect))",ih,MI,function Asr))call W2x(Esv,O0e)return trueendfunctionfunction ATr takes nothing returns booleancall Axr(function Atr,"HawkEye_Init")return trueendfunctionfunction Aur takes nothing returns booleanset RRe=Wwx('BCrM',"Spell Potion",'bCrM')set aav[(RRe)]=(true)set uU[(RRe)]=(true)
set anv[(RRe)]=("ReplaceableTextures\\CommandButtons\\BTNMinorRejuvPotion.blp")call lWx(RRe,"Abilities\\Spells\\Human\\MagicSentry\\MagicSentryCaster.mdl","overhead",ri)set WU=l_x()
call l2x(WU,cCv,30)call l3x(((RRe)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,cCv,50)call l3x(((RRe)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,cCv,70)call l3x(((RRe)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,cCv,90)call l3x(((RRe)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,cCv,'n')
call l3x(((RRe)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,cCv,$82)
call l3x(((RRe)),ZB+(6),(WU))return trueendfunctionfunction AUr takes nothing returns booleanset RIe[1]=30set RIe[2]=50set RIe[3]=70set RIe[4]=90set RIe[5]='n'set RIe[6]=$82set RAe[1]=7.5set RAe[2]=7.5set RAe[3]=7.5set RAe[4]=7.5set RAe[5]=7.5set RAe[6]=7.5return trueendfunctionfunction Awr takes nothing returns booleancall VNx(ma,(function Aur),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\MagicBottle.page\\MagicBottle.struct\\Buff\\obj_dummyBuff_wc3buff.j"))call VNx(va,(function AUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\MagicBottle.page\\MagicBottle.struct\\Buff\\obj_this_wc3obj.j"))return trueendfunctionfunction AWr takes nothing returns booleanset RNe=VXx(Rbe)
return trueendfunctionfunction Ayr takes nothing returns booleancall L1x('AMaB',false)set Scv=L0o('AMaB')set K6[(Scv)]=(f6)set m6[(Scv)]=(6)set TH[(Scv)]=("Magic Bottle")set Rh[(Scv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Aj))))))set oxv[(Scv)]=(4)set x3v[(Scv)]=("spell")
call L1o((Scv),GH+(1),(($D)*1.))
call L1o((Scv),tH+(1),((55)*1.))
call L1o((Scv),Lov+(1),((700)*1.))call L1o((Scv),GH+(2),(($D)*1.))
call L1o((Scv),tH+(2),((75)*1.))
call L1o((Scv),Lov+(2),((700)*1.))call L1o((Scv),GH+(3),(($D)*1.))
call L1o((Scv),tH+(3),((95)*1.))
call L1o((Scv),Lov+(3),((700)*1.))call L1o((Scv),GH+(4),(($D)*1.))
call L1o((Scv),tH+(4),(('s')*1.))call L1o((Scv),Lov+(4),((700)*1.))call L1o((Scv),GH+(5),(($D)*1.))
call L1o((Scv),tH+(5),(('}')*1.))call L1o((Scv),Lov+(5),((700)*1.))call L1o((Scv),GH+(6),(($D)*1.))
call L1o((Scv),tH+(6),(($87)*1.))call L1o((Scv),Lov+(6),((700)*1.))set MOv[(Scv)]=("ReplaceableTextures\\CommandButtons\\BTNPotionOfOmniscience.blp")set RBe[1]=40set RBe[2]=60set RBe[3]=80set RBe[4]='d'set RBe[5]='x'set RBe[6]=$8Cset Rce[1]=1.5set Rce[2]=1.5set Rce[3]=1.5set Rce[4]=1.5set Rce[5]=1.5set Rce[6]=1.5return trueendfunctionfunction AYr takes nothing returns booleancall VNx(Pa,(function Ayr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\MagicBottle.page\\MagicBottle.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Azr takes nothing returns booleanset RCe=VXx(Rde)
return trueendfunctionfunction AZr takes integer oSx returns integerset RGe[oSx]=trueset Rhe[oSx]=falsecall rEx(RCe)return oSxendfunctionfunction A_r takes nothing returns integerlocal integer oSxif(RDe==8190)thencall o_x("MagicBottle_Allocation_allocCustom","call DebugEx(MagicBottle.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Rde+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Rfe[(w)]==w)thenset RFe=RFe+1set oSx=RFeelse
set oSx=Rfe[(w)]
set Rfe[(w)]=Rfe[Rfe[(w)]]endifset Rfe[oSx]=Zset Rge[oSx]=1call AZr(oSx)return oSxendfunctionfunction A0r takes integer oSx returns nothingset RGe[oSx]=falsecall rHx(RCe)endfunctionfunction A1r takes integer oSx returns nothingif(Rge[oSx]>0)thenreturnendifif(Rfe[oSx]!=Z)thencall o_x("MagicBottle_Allocation_deallocCustom_confirm","call DebugEx(MagicBottle.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Rde+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Rfe[oSx]=Rfe[(w)]set Rfe[(w)]=oSx
call A0r(oSx)endfunctionfunction A2r takes integer oSx returns nothingset Rge[oSx]=Rge[oSx]-1call A1r(oSx)endfunctionfunction A3r takes integer rYx,integer Iix returns nothingcall Nbx((Iix),(RRe),(rYx),w,((RAe[rYx])*1.))endfunctionfunction A4r takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=RHe[oSx]local integer rYx=Rje[oSx]local integer Iix=RJe[oSx]call A2r((oSx))call MFo(Mho)call Ryx((ACx((Iix),(Rke),(RKe),(Bi))))if(IsUnitAlly(C[(Iix)],vx[((ze[(Cqx)]))]))thencall mno(Cqx,Iix,RBe[rYx])call A3r(rYx,Iix)else
if(wCo(Iix,true,true,true)>0)thencall mno(Cqx,Cqx,RBe[rYx])endifcall Nbx((((Iix))),(Elv),(1),w,((((Rce[rYx])*1.))*1.))call A3r(rYx,Cqx)endifreturn trueendfunctionfunction A5r takes integer Cqx,integer rYx,integer Iix returns nothinglocal integer oSx=A_r()local integer Mho=Moo()set RHe[oSx]=Cqx
set Rje[oSx]=rYx
set RJe[oSx]=Iix
set mcv[((Mho))]=((Bev*((.06)*1.))*1.)set mCv[(Mho)]=((10.)*1.)call Mno(Mho,'qCMP',2.)set mFv[(Mho)]=Xkx((function A4r))set mZv[(Mho)]=(oSx)
call Meo(Mho,900.)call pxo(Mho,Cqx)call M6o((Mho),(Iix),.0,.0,.0,(null))endfunctionfunction A6r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])call A5r(Cqx,rYx,Iix)return trueendfunctionfunction A7r takes nothing returns nothingendfunctionfunction A8r takes nothing returns booleancall mro(Scv,Xdx("MagicBottle_Init: call MagicBottle.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MagicBottle.Event_SpellEffect))",ih,MI,function A6r))call A7r()return trueendfunctionfunction A9r takes nothing returns booleancall Axr(function A8r,"MagicBottle_Init")return trueendfunctionfunction Nvr takes nothing returns booleanset Rle[1]=$96set Rle[2]=$96set Rle[3]=$96set Rle[4]=$96set Rle[5]=$96set Rle[6]=$96set RLe[1]=60set RLe[2]=90set RLe[3]='x'set RLe[4]=$96set RLe[5]=$B4set RLe[6]=$D2return trueendfunctionfunction Ner takes nothing returns booleancall VNx(va,(function Nvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\RedwoodValkyrie.page\\RedwoodValkyrie.struct\\Air\\obj_this_wc3obj.j"))
return trueendfunctionfunction Nxr takes nothing returns booleanset Rme=VXx(RMe)
return trueendfunctionfunction Nor takes nothing returns booleanset Rpe=ltx(RPe+" (ignitionBuff)")set Pc[(Rpe)]=(true)
set uU[(Rpe)]=(true)
return trueendfunctionfunction Nrr takes nothing returns booleancall L1x('ARwV',false)set Rqe=L0o('ARwV')set K6[(Rqe)]=(f6)set m6[(Rqe)]=(6)set TH[(Rqe)]=("Redwood Valkyrie")set Rh[(Rqe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Aj))))))set oxv[(Rqe)]=(3)set x3v[(Rqe)]=("attack")call L1o((Rqe),Uvv+(1),((80)*1.))call L1o((Rqe),GH+(1),((4)*1.))call L1o((Rqe),tH+(1),((30)*1.))
call L1o((Rqe),Lov+(1),(($514)*1.))call L1o((Rqe),Uvv+(2),((80)*1.))call L1o((Rqe),GH+(2),((4)*1.))call L1o((Rqe),tH+(2),((40)*1.))
call L1o((Rqe),Lov+(2),(($514)*1.))call L1o((Rqe),Uvv+(3),((80)*1.))call L1o((Rqe),GH+(3),((4)*1.))call L1o((Rqe),tH+(3),((50)*1.))
call L1o((Rqe),Lov+(3),(($514)*1.))call L1o((Rqe),Uvv+(4),((80)*1.))call L1o((Rqe),GH+(4),((4)*1.))call L1o((Rqe),tH+(4),((60)*1.))
call L1o((Rqe),Lov+(4),(($514)*1.))call L1o((Rqe),Uvv+(5),((80)*1.))call L1o((Rqe),GH+(5),((4)*1.))call L1o((Rqe),tH+(5),((70)*1.))
call L1o((Rqe),Lov+(5),(($514)*1.))call L1o((Rqe),Uvv+(6),((80)*1.))call L1o((Rqe),GH+(6),((4)*1.))call L1o((Rqe),tH+(6),((80)*1.))
call L1o((Rqe),Lov+(6),(($514)*1.))set MOv[(Rqe)]=("ReplaceableTextures\\CommandButtons\\BTNFlamingArrows.blp")
set RQe[1]='s'set RQe[2]='s'set RQe[3]='s'set RQe[4]='s'set RQe[5]='s'set RQe[6]='s'set Rse[1]=1.75set Rse[2]=2
set Rse[3]=2.25set Rse[4]=2.5set Rse[5]=2.75set Rse[6]=3
set RSe[1]=20set RSe[2]=30set RSe[3]=40set RSe[4]=50set RSe[5]=60set RSe[6]=70set Rte[1]=5
set Rte[2]=$Fset Rte[3]=30set Rte[4]=50set Rte[5]=75set Rte[6]='i'return trueendfunctionfunction Nir takes nothing returns booleancall VNx(ma,(function Nor),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\RedwoodValkyrie.page\\RedwoodValkyrie.struct\\obj_ignitionBuff_wc3buff.j"))
call VNx(Pa,(function Nrr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\RedwoodValkyrie.page\\RedwoodValkyrie.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Nar takes nothing returns booleanset RTe=VXx(RPe)
return trueendfunctionfunction Nnr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer Iix=jhx()local integer oSxlocal integer Ctxif I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifset oSx=(mZv[(Mho)])
if(I8x((RUe[oSx]),Ob,(Iix)))then
return false
endifset Ctx=Rwe[oSx]
if(IsUnitAlly(C[(Iix)],vx[((ze[((EH[(Ctx)]))]))]))thenreturn false
endifreturn truereturn trueendfunctionfunction NVr takes integer oSx returns integerset RYe[oSx]=trueset Rze[oSx]=falsecall rEx(Rme)return oSxendfunctionfunction NEr takes integer oSx returns nothingset RYe[oSx]=falsecall rHx(Rme)endfunctionfunction NXr takes integer Cqx,real NOr,real NRr,real x,real y returns nothinglocal integer Iixcall mho((mko(((x)*1.),((y)*1.),("Abilities\\Spells\\Other\\Incinerate\\FireLordDeathExplode.mdl"),(Bi))))set hf=(ze[(Cqx)])call NVo(R1e,x,y,NOr,R2e)set Iix=NEo(R1e)
if(Iix!=w)thenloop
call nlo((Cqx),(Iix),((NRr)*1.),(true),(false))set Iix=NEo(R1e)
exitwhen(Iix==w)
endloopendifendfunctionfunction NIr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local real x=(mHv[(Mho)])local real y=(mjv[(Mho)])local integer Ctx=RZe[oSx]local integer Cqx=(EH[(Ctx)])local integer rYx=(IH[(Ctx)])call NEr(oSx)call MFo(Mho)call NXr(Cqx,Rle[rYx],RLe[rYx]+(OH[(Ctx)])*R3e,x,y)call Usx(Ctx)return trueendfunctionfunction NAr takes integer Ctx returns nothinglocal integer Cqx=(EH[(Ctx)])local integer rYx=(IH[(Ctx)])local integer Iix=(Wh[(Ctx)])local integer Mho=Moo()local integer oSx=NVr(Mho)set RZe[oSx]=Ctx
set mCv[(Mho)]=(((CQx((Rqe),Uvv+(rYx))))*1.)
call sEo((Mno(Mho,'qRwA',1.5)),(R_e),(R0e),(Bi))
set mFv[(Mho)]=Xkx((function NIr))set mZv[(Mho)]=(oSx)
call Meo(Mho,R4e)call pxo(Mho,Cqx)call M6o((Mho),(Iix),.0,.0,.0,(null))call Ucx(Ctx)endfunctionfunction NNr takes integer oSx returns integerset R9e[oSx]=trueset Ive[oSx]=falsecall rEx(RTe)return oSxendfunctionfunction Nbr takes nothing returns integerlocal integer oSxif(R5e==8190)thencall o_x("RedwoodValkyrie_Allocation_allocCustom","call DebugEx(RedwoodValkyrie.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",RPe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(R6e[(w)]==w)thenset R7e=R7e+1set oSx=R7eelse
set oSx=R6e[(w)]
set R6e[(w)]=R6e[R6e[(w)]]endifset R6e[oSx]=Zset R8e[oSx]=1call NNr(oSx)return oSxendfunctionfunction NBr takes integer oSx returns nothingset R9e[oSx]=falsecall rHx(RTe)endfunctionfunction Ncr takes integer oSx returns nothingif(R8e[oSx]>0)thenreturnendifif(R6e[oSx]!=Z)thencall o_x("RedwoodValkyrie_Allocation_deallocCustom_confirm","call DebugEx(RedwoodValkyrie.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",RPe+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset R6e[oSx]=R6e[(w)]set R6e[(w)]=oSx
call NBr(oSx)endfunctionfunction NCr takes integer oSx returns nothingset R8e[oSx]=R8e[oSx]-1call Ncr(oSx)endfunctionfunction Ndr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])call X_r(RUe[oSx])call NCr((oSx))call MFo(Mho)return trueendfunctionfunction NDr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=(mZv[(Mho)])local real Nbo=Iee[oSx]local integer Ctx=Rwe[oSx]local integer Cqx=(EH[(Ctx)])local real Nfrcall dQx(RUe[oSx],Iix)if I9x(Iix,Wd)thenset Nfr=Ineelse
set Nfr=IVeendifcall Nbx(Iix,Rpe,(IH[(Ctx)]),Cqx,Nfr)call dUo(Cqx,Iix,true,Nbo)return trueendfunctionfunction NFr takes integer Ctx returns nothinglocal integer Cqx=(EH[(Ctx)])local integer rYx=(IH[(Ctx)])local real dVx=(yh[(Ctx)])local real dEx=(Yh[(Ctx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real rPr=(CQx((Rqe),Lov+(rYx)))local integer oSx=Nbr()local integer Mho=Moo()local real bex=(Atan2(((dEx-wso)*1.),((dVx-wQo)*1.)))set Iee[oSx]=Rte[rYx]+(Lg[(Cqx)])*Rse[rYx]set Ixe[oSx]=rPr
set Ioe[oSx]=wQo
set Ire[oSx]=wso
set RUe[oSx]=Jbx("RedwoodValkyrie_Start: set this.targetGroup = UnitList.Create()")set Rwe[oSx]=Ctx
set mCv[(Mho)]=(((CQx((Rqe),Uvv+(rYx))))*1.)
call sEo((Mno(Mho,'qRwV',1.5)),(Iie),(Iae),(Bi))
set mZv[(Mho)]=(oSx)
set mFv[(Mho)]=Xkx((function Ndr))call Meo(Mho,R4e)call pxo(Mho,Cqx)call o9r(Mho,wQo+rPr*(Cos(((((bex)*1.))*1.))),wso+rPr*(Sin(((((bex)*1.))*1.))),X_x(dVx,dEx)+60.)
call rtr(Mho,function NDr,Rue)endfunctionfunction Ngr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer Iix=(zH[(rFx)])local integer Ctx=(WH[(rFx)])call Ryx((ACx((Cqx),(RWe),(Rye),(Bi))))if((Iix!=w)and not I9x(Iix,Idv))then
call NAr(Ctx)return trueendifcall NFr(Ctx)return trueendfunctionfunction NGr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Iav)thenreturn false
endifif ndo(Iix)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction Nhr takes nothing returns nothingset R1e=O5x()set R2e=Xpx(function NGr)endfunctionfunction NHr takes nothing returns booleanset Rue=Xpx(function Nnr)call mro(Rqe,Xdx("RedwoodValkyrie_Init: call RedwoodValkyrie.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RedwoodValkyrie.Event_SpellEffect))",ih,MI,function Ngr))call W2x(Xev,Rpe)call Nhr()return trueendfunctionfunction Njr takes nothing returns booleancall Axr(function NHr,"RedwoodValkyrie_Init")return trueendfunctionfunction NJr takes nothing returns booleanset IEe=ltx(IXe+" (frostBuff)")set Pc[(IEe)]=(true)
set uU[(IEe)]=(true)
return trueendfunctionfunction Nkr takes nothing returns booleancall L1x('ASaD',false)set SBv=L0o('ASaD')set K6[(SBv)]=(f6)set m6[(SBv)]=(6)set TH[(SBv)]=("Sapphireblue Dagger")set Rh[(SBv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Aj))))))set oxv[(SBv)]=(2)set x3v[(SBv)]=("spell")
call L1o((SBv),Uvv+(1),(($C8)*1.))call L1o((SBv),GH+(1),(($B)*1.))
call L1o((SBv),tH+(1),((30)*1.))
call L1o((SBv),Lov+(1),((99999)*1.))
call L1o((SBv),Uvv+(2),(($C8)*1.))call L1o((SBv),GH+(2),(($B)*1.))
call L1o((SBv),tH+(2),((30)*1.))
call L1o((SBv),Lov+(2),((99999)*1.))
call L1o((SBv),Uvv+(3),(($C8)*1.))call L1o((SBv),GH+(3),(($B)*1.))
call L1o((SBv),tH+(3),((30)*1.))
call L1o((SBv),Lov+(3),((99999)*1.))
call L1o((SBv),Uvv+(4),(($C8)*1.))call L1o((SBv),GH+(4),(($B)*1.))
call L1o((SBv),tH+(4),((30)*1.))
call L1o((SBv),Lov+(4),((99999)*1.))
call L1o((SBv),Uvv+(5),(($C8)*1.))call L1o((SBv),GH+(5),(($B)*1.))
call L1o((SBv),tH+(5),((30)*1.))
call L1o((SBv),Lov+(5),((99999)*1.))
call L1o((SBv),Uvv+(6),(($C8)*1.))call L1o((SBv),GH+(6),(($B)*1.))
call L1o((SBv),tH+(6),((30)*1.))
call L1o((SBv),Lov+(6),((99999)*1.))
set MOv[(SBv)]=("ReplaceableTextures\\CommandButtons\\BTNDaggerOfEscape.blp")set IOe[1]=8
set IOe[2]=8
set IOe[3]=8
set IOe[4]=8
set IOe[5]=8
set IOe[6]=8
set IRe[1]=4
set IRe[2]=4
set IRe[3]=4
set IRe[4]=4
set IRe[5]=4
set IRe[6]=4
set IIe[1]=8
set IIe[2]=$Dset IIe[3]=20set IIe[4]=29set IIe[5]=40set IIe[6]=53set IAe[1]=500set IAe[2]=500set IAe[3]=500set IAe[4]=500set IAe[5]=500set IAe[6]=500return trueendfunctionfunction NKr takes nothing returns booleanset INe=Wwx('BSaD',"Sapphireblue Dagger",'bSaD')
set aav[(INe)]=(true)set Pc[(INe)]=(true)
set uU[(INe)]=(true)
set anv[(INe)]=("ReplaceableTextures\\CommandButtons\\BTNThoriumMelee.blp")call lWx(INe,"SapphireblueDagger_page\\SapphireblueDagger_struct\\casterBuff.mdx","weapon",ri)call lWx(INe,"SapphireblueDagger_page\\SapphireblueDagger_struct\\casterBuff.mdx","weapon",Bi)call lWx(INe,"SapphireblueDagger_page\\SapphireblueDagger_struct\\casterBuff.mdx","weapon",Bi)call lWx(INe,"SapphireblueDagger_page\\SapphireblueDagger_struct\\casterBuff.mdx","weapon",Bi)call lWx(INe,"SapphireblueDagger_page\\SapphireblueDagger_struct\\casterBuff.mdx","weapon",Bi)return trueendfunctionfunction Nlr takes nothing returns booleancall VNx(ma,(function NJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\SapphireblueDagger.page\\SapphireblueDagger.struct\\obj_frostBuff_wc3buff.j"))call VNx(Pa,(function Nkr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\SapphireblueDagger.page\\SapphireblueDagger.struct\\obj_thisSpell_wc3spell.j"))
call VNx(ma,(function NKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\SapphireblueDagger.page\\SapphireblueDagger.struct\\obj_casterBuff_wc3buff.j"))
return trueendfunctionfunction NLr takes nothing returns booleanset Ibe=VXx(IXe)
return trueendfunctionfunction Nmr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer Iix=(zH[(rFx)])local integer rYx=(osx(((Cqx)),Yb+(INe)))call nlo((Cqx),(Iix),((IIe[rYx])*1.),(true),(false))
return trueendfunctionfunction NMr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif I9x(Iix,Wd)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction Npr takes nothing returns booleanlocal integer rFx=(bv)call Avx((Vv[(rFx)]),IBe)return trueendfunctionfunction NPr takes nothing returns booleanlocal integer rFx=(bv)call RPx((Vv[(rFx)]),IBe)return trueendfunctionfunction Nqr takes integer oSx,real jMx,real jpx,real oyx,real bex,real jPx,real jqx,integer Q7x returns nothing
local real Nro=iAx(oyx,iAx(jqx,jPx))+Ife
if(Q7x==w)thenset Q7x=GKendifset Q7x=Nao(hQ,Q7x)set kQ=bexset JQ=oyxset HQ=jMxset jQ=jpxset lQ=jqxset KQ=jPxcall SetRect(bm[(LQ)],((jMx-Nro)*1.),((jpx-Nro)*1.),((jMx+Nro)*1.),((jpx+Nro)*1.))call GroupEnumUnitsInRect(kb[(oSx)],bm[LQ],Bv[Q7x])endfunctionfunction NQr takes real jMx,real jpx,real dVx,real dEx,integer Cqx,integer rYx returns nothinglocal real dX=dVx-jMxlocal real dY=dEx-jpxlocal real pqx=dox(Cqx,true)
local integer Iixlocal real iMxset hf=(ze[(Cqx)])call Nqr(Ice,jMx,jpx,jKx(dX,dY),(Atan2(((dY)*1.),((dX)*1.))),pqx,pqx,ICe)set Iix=NEo(Ice)
if(Iix!=w)thenset iMx=IRe[rYx]
loop
call Nbx((Iix),(IEe),(rYx),w,((iMx)*1.))
set Iix=NEo(Ice)
exitwhen(Iix==w)
endloopendifendfunctionfunction Nsr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local real O4o=(CQx((SBv),Uvv+(rYx)))local integer C3o=(ze[(Cqx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real dX=dVx-wQolocal real dY=dEx-wsolocal real bexif(GZx(dX,dY)>Ide[rYx])thenset bex=Ufx(Cqx,dX,dY)set dVx=wQo+IAe[rYx]*(Cos(((((bex)*1.))*1.)))set dEx=wso+IAe[rYx]*(Sin(((((bex)*1.))*1.)))endifcall mho((mko(((wQo)*1.),((wso)*1.),(IDe),(Bi))))call NQr(wQo,wso,dVx,dEx,Cqx,rYx)call mho((mko(((dVx)*1.),((dEx)*1.),(IFe),(ri))))call SetUnitPosition(C[((Cqx))],((dVx)*1.),((dEx)*1.))call Nbx((Cqx),(INe),(rYx),w,((IOe[rYx])*1.))call fNx(Cqx,rYx)return trueendfunctionfunction NSr takes nothing returns booleanlocal integer oMxset IBe=Xdx("SapphireblueDagger_Init: set SapphireblueDagger.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function SapphireblueDagger.Event_Damage)",E4v,MI,function Nmr)set Ice=O5x()set ICe=Xpx(function NMr)call Lxx(INe,Xdx("SapphireblueDagger_Init: call SapphireblueDagger.CASTER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SapphireblueDagger.Event_BuffGain))",bd,MI,function Npr))call Lxx(INe,Xdx("SapphireblueDagger_Init: call SapphireblueDagger.CASTER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SapphireblueDagger.Event_BuffLose))",jc,MI,function NPr))call mro(SBv,Xdx("SapphireblueDagger_Init: call SapphireblueDagger.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SapphireblueDagger.Event_SpellEffect))",ih,MI,function Nsr))call W2x(nGv,IEe)set oMx=(m6[(SBv)])loop
set Ide[oMx]=rer(IAe[oMx])set oMx=oMx-1exitwhen(oMx<1)endloopreturn trueendfunctionfunction Ntr takes nothing returns booleancall Axr(function NSr,"SapphireblueDagger_Init")
return trueendfunctionfunction NTr takes nothing returns booleancall L1x('ASiB',false)set SAv=L0o('ASiB')set K6[(SAv)]=(f6)set m6[(SAv)]=(6)set TH[(SAv)]=("Silent Boots")set Rh[(SAv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0084)))),(((Aj))))))set oxv[(SAv)]=(0)set x3v[(SAv)]=("spell")
call L1o((SAv),GH+(1),(($A)*1.))
call L1o((SAv),tH+(1),((50)*1.))
call L1o((SAv),Lov+(1),((750)*1.))call L1o((SAv),GH+(2),((9)*1.))call L1o((SAv),tH+(2),((50)*1.))
call L1o((SAv),Lov+(2),((750)*1.))call L1o((SAv),GH+(3),((8)*1.))call L1o((SAv),tH+(3),((50)*1.))
call L1o((SAv),Lov+(3),((750)*1.))call L1o((SAv),GH+(4),((7)*1.))call L1o((SAv),tH+(4),((50)*1.))
call L1o((SAv),Lov+(4),((750)*1.))call L1o((SAv),GH+(5),((6)*1.))call L1o((SAv),tH+(5),((50)*1.))
call L1o((SAv),Lov+(5),((750)*1.))call L1o((SAv),GH+(6),((5)*1.))call L1o((SAv),tH+(6),((50)*1.))
call L1o((SAv),Lov+(6),((750)*1.))set MOv[(SAv)]=("ReplaceableTextures\\CommandButtons\\BTNSlippersOfAgility.blp")
set Ige[1]=$Aset Ige[2]=20set Ige[3]=30set Ige[4]=40set Ige[5]=50set Ige[6]=60set IGe[1]=1
set IGe[2]=1
set IGe[3]=1
set IGe[4]=1
set IGe[5]=1
set IGe[6]=1
set Ihe[1]=5
set Ihe[2]=6
set Ihe[3]=7
set Ihe[4]=8
set Ihe[5]=9
set Ihe[6]=$Aset IHe[1]=2
set IHe[2]=2
set IHe[3]=2
set IHe[4]=2
set IHe[5]=2
set IHe[6]=2
set Ije[1]=$82set Ije[2]=$AAset Ije[3]=$D2set Ije[4]=$FAset Ije[5]=290set Ije[6]=330return trueendfunctionfunction Nur takes nothing returns booleanset IJe=Wwx('BSiB',"Silent Boots",'bSiB')set aav[(IJe)]=(true)set Pc[(IJe)]=(true)
set uU[(IJe)]=(true)
set anv[(IJe)]=("ReplaceableTextures\\CommandButtons\\BTNSlippersOfAgility.blp")
call lWx(IJe,"Abilities\\Spells\\Orc\\SpiritLink\\SpiritLinkTarget.mdl","origin",ri)
set WU=l_x()
call vAr(WU,DOv,true)call l3x(((IJe)),ZB+(1),(WU))set WU=l_x()
call vAr(WU,DOv,true)call l3x(((IJe)),ZB+(2),(WU))set WU=l_x()
call vAr(WU,DOv,true)call l3x(((IJe)),ZB+(3),(WU))set WU=l_x()
call vAr(WU,DOv,true)call l3x(((IJe)),ZB+(4),(WU))set WU=l_x()
call vAr(WU,DOv,true)call l3x(((IJe)),ZB+(5),(WU))set WU=l_x()
call vAr(WU,DOv,true)call l3x(((IJe)),ZB+(6),(WU))return trueendfunctionfunction NUr takes nothing returns booleancall VNx(Pa,(function NTr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\SilentBoots.page\\SilentBoots.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function Nur),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\SilentBoots.page\\SilentBoots.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction Nwr takes nothing returns booleanset Ike=VXx(IKe)
return trueendfunctionfunction NWr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local real Nbo=(E1v[(rFx)])local integer Iix=(zH[(rFx)])local integer rYx=(osx(((Cqx)),Yb+(IJe)))local real Nyrcall o_x("SilentBoots_Event_Damage","call DebugEx(SilentBoots.NAME+ \" dmg\")",IKe+" dmg")if I9x(Iix,Wd)thenset Nyr=IGe[rYx]
else
set Nyr=IHe[rYx]
endifcall Nbx((((Iix))),(x4v),(1),w,((((Nyr)*1.))*1.))call Nbx((((Iix))),(Xkv),(1),w,((((Nyr)*1.))*1.))set E1v[(rFx)]=((Nbo+Ige[rYx])*1.)return trueendfunctionfunction NYr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),IJe)return trueendfunctionfunction Nzr takes string rSx,real Xfx returns realif(HaveStoredString(Kv[((uH))],(rSx),("var")))thenreturn(S2R(((dex(uH,(rSx),"var")))))
endifreturn Xfxendfunctionfunction NZr takes integer oSx,integer rNx,integer rbx returns integerreturn(0+(LoadInteger(o[((V[(E[((Z8[oSx]))])]))],((((U8[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1)))))))))endfunctionfunction N_r takes integer oSx,integer rNx,integer rbx,integer oLx returns integerreturn(LoadInteger(o[((V[(E[((Z8[oSx]))])]))],((((U8[((oSx))])))),((((1+8192*(((rNx)-1)*Iv+((rbx)-1))))+(oLx)))))endfunctionfunction N0r takes integer oSx returns nothinglocal integer rFx=rRx((U8[(oSx)]))local integer oMxlocal integer rbxlocal integer rMxset T8[(rFx)]=(oSx)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=NZr(oSx,S8,rbx)loop
exitwhen(rMx<q)call rfx(N_r(oSx,S8,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction N1r takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((u8[oSx]))])])],((((U8[((oSx))])))))endfunctionfunction N2r takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((Z8[oSx]))])])],((((U8[((oSx))])))))endfunctionfunction N3r takes integer oSx returns nothingset IUe[oSx]=falsecall N1r((oSx))call N2r(((oSx)))call rHx(Q8)
endfunctionfunction N4r takes integer oSx returns nothingif(ITe[oSx]>0)thenreturnendifif(Iue[oSx]!=Z)thencall o_x("Ubersplat_Allocation_deallocCustom_confirm","call DebugEx(Ubersplat.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",s8+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Iue[oSx]=Iue[(w)]set Iue[(w)]=oSx
call N3r(oSx)endfunctionfunction N5r takes integer oSx returns nothingset ITe[oSx]=ITe[oSx]-1call N4r(oSx)endfunctionfunction N6r takes integer oSx returns nothingcall N0r(oSx)if(ISe[(oSx)])thencall DestroyUbersplat(Ite[oSx])endifcall N5r((oSx))endfunctionfunction N7r takes nothing returns nothinglocal integer oSx=(ge[(iGx())])call iKx(Ise[(oSx)])
call N6r((oSx))endfunctionfunction N8r takes integer oSx returns nothingif(ISe[(oSx)])thencall DestroyUbersplat(Ite[oSx])endifset Ite[oSx]=CreateUbersplat((Ize[(oSx)]),(IZe[(oSx)]),V8[(I_e[(oSx)])],Dqx((R2I((((Iwe[(oSx)]))*1.))),0,$FF),Dqx((R2I((((IWe[(oSx)]))*1.))),0,$FF),Dqx((R2I((((Iye[(oSx)]))*1.))),0,$FF),Dqx((R2I((((IYe[(oSx)]))*1.))),0,$FF),(I0e[(oSx)]),(I1e[(oSx)]))set ISe[oSx]=(GetHandleId(Ite[oSx])!=-1)
call SetUbersplatRenderAlways(Ite[oSx],true)
endfunctionfunction N9r takes integer oSx,real izx,real iZx,real i_x,real i0x returns nothingset Iwe[(oSx)]=((izx)*1.)set IWe[(oSx)]=((iZx)*1.)set Iye[(oSx)]=((i_x)*1.)set IYe[(oSx)]=((i0x)*1.)call N8r((oSx))endfunctionfunction bvr takes integer oSx,real izx,real iZx,real i_x,real i0x returns nothingcall N9r(oSx,(Iwe[(oSx)])+izx,(IWe[(oSx)])+iZx,(Iye[(oSx)])+i_x,(IYe[(oSx)])+i0x)endfunctionfunction ber takes integer oSx returns integerset z8[oSx]=true
set I5e[oSx]=falsecall rEx(J8)
return oSxendfunctionfunction bxr takes nothing returns integerlocal integer oSxif(I3e==8190)thencall o_x("FolderUbersplat_FolderColor_StructTimed_Allocation_allocCustom","call DebugEx(FolderUbersplat_FolderColor_StructTimed.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",k8+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(Y8[(w)]==w)thenset I4e=I4e+1set oSx=I4eelse
set oSx=Y8[(w)]set Y8[(w)]=Y8[Y8[(w)]]endifset Y8[oSx]=Zset y8[oSx]=1call ber(oSx)return oSxendfunctionfunction bor takes integer oSx,integer otx,integer oux returns booleanreturn rux(u8[(oSx)],(U8[((oSx))]),otx,oux)endfunctionfunction brr takes integer oSx,integer XYx returns nothingif(Z8[oSx]==w)thencall o_x("FolderUbersplat_StructEvent_Add","call DebugEx(\"no table \"+I2S(this)+\";\"+whichEvent.GetName())","no table "+I2S(oSx)+";"+(jA[(XYx)]))set Z8[oSx]=Xendifcall rux(Z8[oSx],(U8[((oSx))]),(oA[(XYx)]),XYx)endfunctionfunction bir takes integer oSx returns booleanset vxv=vxv+1set vev[vxv]=oSx
set vvv[oSx]=vxv+1return(vxv==0)endfunctionfunction bar takes nothing returns nothinglocal integer oMx=vxvlocal integer oSxloop
set oSx=vev[oMx]
call bvr(Ave[oSx],I6e[oSx],I7e[oSx],I8e[oSx],I9e[oSx])set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction bnr takes nothing returns nothinglocal integer iCx=iGx()local integer oSx=(ge[(iCx)])call Scx(oSx,iCx,Ave[oSx])endfunctionfunction bVr takes integer oSx,real izx,real iZx,real i_x,real i0x,real iMx returns nothinglocal integer rLx=oSxlocal integer fexlocal integer iCxif(iMx==.0)thencall bvr(rLx,izx,iZx,i_x,i0x)returnendifset fex=(R2I(((iMx*1./ I2e)*1.)))set oSx=bxr()set iCx=iXx()set I6e[oSx]=izx*1./ fex
set I7e[oSx]=iZx*1./ fex
set I8e[oSx]=i_x*1./ fex
set I9e[oSx]=i0x*1./ fex
set vrv[oSx]=iCx
set Ave[oSx]=rLx
set ge[(iCx)]=(oSx)call bor(rLx,W8,oSx)
call brr(rLx,t8)
if bir(oSx)thencall iDx(vov,I2e,true,function bar)endifcall iDx(iCx,iMx,false,function bnr)
endfunctionfunction bEr takes integer oSx,real izx,real iZx,real i_x,real i0x,real iMx returns nothingcall bVr(oSx,-izx,-iZx,-i_x,-i0x,iMx)endfunctionfunction bXr takes integer oSx,real iMx returns nothinglocal integer iCx=iXx()set Ise[oSx]=iCx
set ge[(iCx)]=(oSx)call iDx(iCx,iMx,false,function N7r)
call bEr((oSx),.0,.0,.0,(IYe[((oSx))]),iMx)endfunctionfunction bOr takes integer oSx returns integerset IUe[oSx]=trueset Aoe[oSx]=falseset u8[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])set Z8[((oSx))]=(NI[(GetRandomInt((0),(AI)))])call rEx(Q8)
return oSxendfunctionfunction bRr takes nothing returns integerlocal integer oSxif(Aee==8190)thencall o_x("Ubersplat_Allocation_allocCustom","call DebugEx(Ubersplat.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",s8+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(Iue[(w)]==w)thenset Axe=Axe+1set oSx=Axeelse
set oSx=Iue[(w)]
set Iue[(w)]=Iue[Iue[(w)]]endifset Iue[oSx]=Zset ITe[oSx]=1call bOr(oSx)return oSxendfunctionfunction bIr takes integer oSx returns nothingset U8[(oSx)]=(Aie+oSx)endfunctionfunction bAr takes integer oSx,real izx,real iZx,real i_x,real i0x returns nothingset Iwe[(oSx)]=((izx)*1.)set IWe[(oSx)]=((iZx)*1.)set Iye[(oSx)]=((i_x)*1.)set IYe[(oSx)]=((i0x)*1.)endfunctionfunction bNr takes integer oSx,real x,real y returns nothing
set Ize[(oSx)]=((x)*1.)set IZe[(oSx)]=((y)*1.)endfunctionfunction bbr takes integer rNx,real x,real y,real izx,real iZx,real i_x,real i0x,boolean bBr,boolean bcr returns integer
local integer oSx=bRr()set Ite[oSx]=nullset ISe[oSx]=falsecall bIr(oSx)set I0e[(oSx)]=(bBr)
set I1e[(oSx)]=(bcr)
set I_e[(oSx)]=(rNx)
call bAr(oSx,izx,iZx,i_x,i0x)call bNr(oSx,x,y)call N8r(oSx)return oSxendfunctionfunction bCr takes integer oSx,integer Iax,integer rYx returns realset oSx=(IGx(E[((X))],(Cd),((oSx)),((Iax)),((rYx)),(w)))
if(oSx==w)thenreturn .0endifreturn(TimerGetRemaining(Oe[(jd[oSx])]))
endfunctionfunction bdr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxlocal real x=(GetUnitX(C[((Iix))]))local real y=(GetUnitY(C[((Iix))]))call bXr(bbr(Z7,x,y,$FF,$FF,$FF,bCr(Iix,IJe,Ime[oSx])*1./ Ihe[Ime[oSx]]*Nzr("snowAlphaFactor",1.5)*$FF,false,false),Nzr("snowDur",5.))endfunctionfunction bDr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer bfr=IMe[oSx]local integer rYx=Ime[oSx]local integer azr=Ipe[oSx]-1
local integer Iix=oSxset Ipe[oSx]=azr
call ISx(Iix,bfr)call l1x(((bfr)),Ec+(dmv),((Ije[rYx]*(azr*1./ IPe))*1.))
call I3x(Iix,bfr)endfunctionfunction bFr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer bfr=l_x()local integer bgr=iXx()local integer a_r=iXx()set Ime[oSx]=rYx
set IMe[oSx]=bfr
set Ipe[oSx]=IPe
set Iqe[oSx]=bgr
set IQe[oSx]=a_r
set ge[(bgr)]=(oSx)set ge[(a_r)]=(oSx)call Avx(Iix,Ile)call Avx(Iix,ILe)call l2x(bfr,dmv,Ije[rYx])call I3x(Iix,bfr)call iDx(bgr,Nzr("snow",.125),true,function bdr)
call iDx(a_r,Ihe[rYx]*1./ IPe,true,function bDr)
return trueendfunctionfunction bGr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer bfr=IMe[oSx]local integer bgr=Iqe[oSx]local integer a_r=IQe[oSx]call iKx(bgr)call iKx(a_r)call RPx(Iix,Ile)call RPx(Iix,ILe)call ISx(Iix,bfr)call nnr(bfr)return trueendfunctionfunction bhr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])call Ryx((ACx((Cqx),(Aae),(Ane),(ri))))call Nbx((((Cqx))),(ntv),(1),w,((((Ihe[rYx])*1.))*1.))call Nbx((Cqx),(IJe),(rYx),w,((Ihe[rYx])*1.))return trueendfunctionfunction bHr takes nothing returns booleanset Ile=Xdx("SilentBoots_Init: set SilentBoots.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function SilentBoots.Event_Damage)",E4v,MI,function NWr)set ILe=Xdx("SilentBoots_Init: set SilentBoots.INVISIBILITY_EVENT = Event.Create(UNIT.Invisibility.ENDING_EVENT_TYPE, EventPriority.SPELLS, function SilentBoots.Event_InvisibilityEnding)",nWv,MI,function NYr)
call Lxx(IJe,Xdx("SilentBoots_Init: call SilentBoots.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SilentBoots.Event_BuffGain))",bd,MI,function bFr))call Lxx(IJe,Xdx("SilentBoots_Init: call SilentBoots.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SilentBoots.Event_BuffLose))",jc,MI,function bGr))call mro(SAv,Xdx("SilentBoots_Init: call SilentBoots.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SilentBoots.Event_SpellEffect))",ih,MI,function bhr))call W2x(ntv,IJe)return trueendfunctionfunction bjr takes nothing returns booleancall Axr(function bHr,"SilentBoots_Init")return trueendfunctionfunction bJr takes nothing returns booleancall L1x('AStS',false)set Sbv=L0o('AStS')set K6[(Sbv)]=(f6)set m6[(Sbv)]=(6)set TH[(Sbv)]=("Stone Shield")set Rh[(Sbv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Aj))))))set oxv[(Sbv)]=(4)set x3v[(Sbv)]=("spell")
call L1o((Sbv),GH+(1),((8)*1.))call L1o((Sbv),tH+(1),((35)*1.))
call L1o((Sbv),Lov+(1),((700)*1.))call L1o((Sbv),GH+(2),((8)*1.))call L1o((Sbv),tH+(2),((45)*1.))
call L1o((Sbv),Lov+(2),((700)*1.))call L1o((Sbv),GH+(3),((8)*1.))call L1o((Sbv),tH+(3),((55)*1.))
call L1o((Sbv),Lov+(3),((700)*1.))call L1o((Sbv),GH+(4),((8)*1.))call L1o((Sbv),tH+(4),((65)*1.))
call L1o((Sbv),Lov+(4),((700)*1.))call L1o((Sbv),GH+(5),((8)*1.))call L1o((Sbv),tH+(5),((75)*1.))
call L1o((Sbv),Lov+(5),((700)*1.))call L1o((Sbv),GH+(6),((8)*1.))call L1o((Sbv),tH+(6),((85)*1.))
call L1o((Sbv),Lov+(6),((700)*1.))set MOv[(Sbv)]=("ReplaceableTextures\\CommandButtons\\BTNArcaniteArmor.blp")
set AVe[1]=$Aset AVe[2]=$Fset AVe[3]=20set AVe[4]=25set AVe[5]=30set AVe[6]=35set AEe[1]=$Aset AEe[2]=$Aset AEe[3]=$Aset AEe[4]=$Aset AEe[5]=$Aset AEe[6]=$Aset AXe[1]=.5set AXe[2]=.5set AXe[3]=.5set AXe[4]=.5set AXe[5]=.5set AXe[6]=.5set AOe[1]=2
set AOe[2]=4
set AOe[3]=6
set AOe[4]=8
set AOe[5]=$Aset AOe[6]=$Cset ARe[1]=800set ARe[2]=800set ARe[3]=800set ARe[4]=800set ARe[5]=800set ARe[6]=800return trueendfunctionfunction bkr takes nothing returns booleanset AIe=Wwx('BStS',"Stone Shield",'bStS')set aav[(AIe)]=(true)set anv[(AIe)]=("ReplaceableTextures\\CommandButtons\\BTNArcaniteArmor.blp")
call lWx(AIe,"Abilities\\Spells\\Items\\AIda\\AIdaTarget.mdl","overhead",ri)
return trueendfunctionfunction bKr takes nothing returns booleancall VNx(Pa,(function bJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\StoneShield.page\\StoneShield.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function bkr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\StoneShield.page\\StoneShield.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction blr takes nothing returns booleanset AAe=VXx(ANe)
return trueendfunctionfunction bLr takes nothing returns booleanlocal integer Iix=jhx()if(I8x((Ose),Ob,(Iix)))thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction bmr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer HAx=AGe[oSx]local integer Iix=oSxlocal real x=(iJ[(HAx)])
local real y=(EJ[(HAx)])
local real dVx=(GetUnitX(C[((Iix))]))local real dEx=(GetUnitY(C[((Iix))]))local real dX=x-dVxlocal real dY=y-dExlocal real bex=(Atan2(((dY)*1.),((dX)*1.)))+ACe[oSx]
local real bMr=dox(Iix,true)*6set dVx=dVx+bMr*(Cos(((((bex)*1.))*1.)))
set dEx=dEx+bMr*(Sin(((((bex)*1.))*1.)))
set dX=dVx-x
set dY=dEx-y
set bex=(Atan2(((dY)*1.),((dX)*1.)))
set bMr=jKx(dX,dY)if(bMr>Ahe[oSx])then
set bMr=Ahe[oSx]
endifset x=x+bMr*(Cos(((((bex)*1.))*1.)))
set y=y+bMr*(Sin(((((bex)*1.))*1.)))
call mNx(HAx,bex+Bev)call Q1o(HAx,x,y)endfunctionfunction bpr takes integer oSx returns nothinglocal integer Cqx=oSxlocal integer HAx=AGe[oSx]local real x=(iJ[(HAx)])
local real y=(EJ[(HAx)])
local real z=(Au[(HAx)])
local integer Iixlocal real Nbocall mho(Vkr(x,y,z,Ale,ri))set hf=(ze[(Cqx)])call VKr(Abe,x,y,z,ALe,ABe)set Iix=NEo(Abe)
if(Iix!=w)thenset Nbo=Afe[oSx]
loop
call Ryx((ACx((Iix),(Ame),(AMe),(Bi))))call nlo((Cqx),(Iix),((Nbo)*1.),(false),(false))
set Iix=NEo(Abe)
exitwhen(Iix==w)
endloopendifendfunctionfunction bPr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer bqr=ADe[oSx]local integer rYx=AHe[oSx]local integer azr=Aje[oSx]-1
local integer Iix=oSxset Aje[oSx]=azr
call ISx(Iix,bqr)call l1x(((bqr)),Ec+(dXv),((AVe[rYx]*(azr*1./ AJe))*1.))
call I3x(Iix,bqr)call bpr(oSx)endfunctionfunction bQr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Lc[(rFx)])local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local real x=(GetUnitX(C[((Cqx))]))local real y=(GetUnitY(C[((Cqx))]))local real z=fYx(Cqx)+K2x(Iix,true)local real dVx=(GetUnitX(C[((Iix))]))local real dEx=(GetUnitY(C[((Iix))]))local real dX=dVx-xlocal real dY=dEx-ylocal real bex=(Atan2(((dY)*1.),((dX)*1.)))local integer oSx=Iixlocal integer bqr=l_x()local integer HAx=mDx('qStS',x,y,z,bex)local integer Q9o=iXx()local integer a_r=iXx()set Ace[oSx]=bex
set ACe[oSx]=Cf*1./ .9*Adeset ADe[oSx]=bqr
set Afe[oSx]=AOe[rYx]+AXe[rYx]*(VF[(Cqx)])set AFe[oSx]=Age*Ade
set AGe[oSx]=HAx
set Ahe[oSx]=ARe[rYx]*Adeset AHe[oSx]=rYx
set Aje[oSx]=AJe
set Ake[oSx]=Q9o
set AKe[oSx]=a_r
set ge[(Q9o)]=(oSx)set ge[(a_r)]=(oSx)call mCx(HAx,1.5)call o_r(HAx,-1,AEe[rYx])call l2x(bqr,dXv,AVe[rYx])call I3x(Iix,bqr)call iDx(Q9o,Ade,true,function bmr)call iDx(a_r,AEe[rYx]*1./ AJe,true,function bPr)
return trueendfunctionfunction bsr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer bqr=ADe[oSx]local integer HAx=AGe[oSx]local integer Q9o=Ake[oSx]local integer a_r=AKe[oSx]call MGx(HAx)call iKx(Q9o)call iKx(a_r)call ISx(Iix,bqr)call nnr(bqr)return trueendfunctionfunction bSr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])call AZx(Iix,AIe)call Nbx(Iix,AIe,rYx,Cqx,AEe[rYx])return trueendfunctionfunction btr takes nothing returns booleanset Abe=O5x()set ABe=Xpx(function bLr)call Lxx(AIe,Xdx("StoneShield_Init: call StoneShield.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function StoneShield.Event_BuffGain))",bd,MI,function bQr))call Lxx(AIe,Xdx("StoneShield_Init: call StoneShield.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function StoneShield.Event_BuffLose))",jc,MI,function bsr))call mro(Sbv,Xdx("StoneShield_Init: call StoneShield.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function StoneShield.Event_SpellEffect))",ih,MI,function bSr))return trueendfunctionfunction bTr takes nothing returns booleancall Axr(function btr,"StoneShield_Init")return trueendfunctionfunction bur takes nothing returns booleanset Ape=ltx(APe+" (sleepBuff)")set Pc[(Ape)]=(true)
return trueendfunctionfunction bUr takes nothing returns booleancall L1x('ATaL',false)set SCv=L0o('ATaL')set K6[(SCv)]=(f6)set m6[(SCv)]=(6)set TH[(SCv)]=("Tainted Leaf")set Rh[(SCv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Aj))))))set oxv[(SCv)]=(4)set x3v[(SCv)]=("spell")
call L1o((SCv),Uvv+(1),(($C8)*1.))call L1o((SCv),GH+(1),((6)*1.))call L1o((SCv),tH+(1),((70)*1.))
call L1o((SCv),Lov+(1),((800)*1.))call L1o((SCv),Uvv+(2),(($C8)*1.))call L1o((SCv),GH+(2),((6)*1.))call L1o((SCv),tH+(2),((70)*1.))
call L1o((SCv),Lov+(2),((800)*1.))call L1o((SCv),Uvv+(3),(($C8)*1.))call L1o((SCv),GH+(3),((6)*1.))call L1o((SCv),tH+(3),((70)*1.))
call L1o((SCv),Lov+(3),((800)*1.))call L1o((SCv),Uvv+(4),(($C8)*1.))call L1o((SCv),GH+(4),((6)*1.))call L1o((SCv),tH+(4),((70)*1.))
call L1o((SCv),Lov+(4),((800)*1.))call L1o((SCv),Uvv+(5),(($C8)*1.))call L1o((SCv),GH+(5),((6)*1.))call L1o((SCv),tH+(5),((70)*1.))
call L1o((SCv),Lov+(5),((800)*1.))call L1o((SCv),Uvv+(6),(($C8)*1.))call L1o((SCv),GH+(6),((6)*1.))call L1o((SCv),tH+(6),((70)*1.))
call L1o((SCv),Lov+(6),((800)*1.))set MOv[(SCv)]=("ReplaceableTextures\\CommandButtons\\BTNRejuvenation.blp")set Aqe[1]='d'set Aqe[2]=$96set Aqe[3]=$C8set Aqe[4]=$FAset Aqe[5]=300set Aqe[6]=350set AQe[1]=8
set AQe[2]=8
set AQe[3]=8
set AQe[4]=8
set AQe[5]=8
set AQe[6]=8
set Ase[1]=3
set Ase[2]=3
set Ase[3]=3
set Ase[4]=3
set Ase[5]=3
set Ase[6]=3
set ASe[1]=3
set ASe[2]=4
set ASe[3]=5
set ASe[4]=6
set ASe[5]=7
set ASe[6]=8
set Ate[1]=.05set Ate[2]=.1set Ate[3]=.15set Ate[4]=.2set Ate[5]=.25set Ate[6]=.3set ATe[1]=80set ATe[2]='d'set ATe[3]='x'set ATe[4]=$8Cset ATe[5]=$A0set ATe[6]=$B4set Aue[1]=25set Aue[2]=40set Aue[3]=55set Aue[4]=70set Aue[5]=85set Aue[6]='d'return trueendfunctionfunction bwr takes nothing returns booleanset AUe=Wwx('BTaL',"Tainted Leaf",'bTaL')set aav[(AUe)]=(true)set uU[(AUe)]=(true)
set anv[(AUe)]=("ReplaceableTextures\\CommandButtons\\BTNRejuvenation.blp")set WU=l_x()
call vAr(WU,DJv,true)call l2x(WU,cBv,'d')
call l0x(((WU)),fc,(rzo(db,$FF,-$7F,$FF,0)))
call l3x(((AUe)),ZB+(1),(WU))set WU=l_x()
call vAr(WU,DJv,true)call l2x(WU,cBv,$96)
call l0x(((WU)),fc,(rzo(db,$FF,-$7F,$FF,0)))
call l3x(((AUe)),ZB+(2),(WU))set WU=l_x()
call vAr(WU,DJv,true)call l2x(WU,cBv,$C8)
call l0x(((WU)),fc,(rzo(db,$FF,-$7F,$FF,0)))
call l3x(((AUe)),ZB+(3),(WU))set WU=l_x()
call vAr(WU,DJv,true)call l2x(WU,cBv,$FA)
call l0x(((WU)),fc,(rzo(db,$FF,-$7F,$FF,0)))
call l3x(((AUe)),ZB+(4),(WU))set WU=l_x()
call vAr(WU,DJv,true)call l2x(WU,cBv,300)
call l0x(((WU)),fc,(rzo(db,$FF,-$7F,$FF,0)))
call l3x(((AUe)),ZB+(5),(WU))set WU=l_x()
call vAr(WU,DJv,true)call l2x(WU,cBv,350)
call l0x(((WU)),fc,(rzo(db,$FF,-$7F,$FF,0)))
call l3x(((AUe)),ZB+(6),(WU))return trueendfunctionfunction bWr takes nothing returns booleanset Awe=ltx(APe+" (castBuff)")return trueendfunctionfunction byr takes nothing returns booleancall VNx(ma,(function bur),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\TaintedLeaf.page\\TaintedLeaf.struct\\obj_sleepBuff_wc3buff.j"))call VNx(Pa,(function bUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\TaintedLeaf.page\\TaintedLeaf.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function bwr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\TaintedLeaf.page\\TaintedLeaf.struct\\obj_taintedBuff_wc3buff.j"))call VNx(ma,(function bWr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\TaintedLeaf.page\\TaintedLeaf.struct\\obj_castBuff_wc3buff.j"))
return trueendfunctionfunction bYr takes nothing returns booleanset AWe=VXx(APe)
return trueendfunctionfunction bzr takes nothing returns booleanlocal integer Iix=jhx()if(Iix==Rb)thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction bZr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=AYelocal integer Iix=Azelocal real dVx=AZelocal real dEx=A_elocal integer svo=O5x()local integer oSx=Cqxset A0e[oSx]=svo
set hf=(ze[(Cqx)])set Rb=Iixcall NVo(svo,dVx,dEx,(CQx((SCv),Uvv+(rYx))),Aye)
return trueendfunctionfunction b_r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oSx=Cqxlocal integer svo=A0e[oSx]call O9x(svo)return trueendfunctionfunction b0r takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxlocal integer Cqx=A1e[oSx]local integer rYx=A3e[oSx]call mao(Cqx,Iix,A5e[rYx])endfunctionfunction b1r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Lc[(rFx)])local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=iXx()set A1e[oSx]=Cqx
set A2e[oSx]=p3x
set A3e[oSx]=rYx
set ge[(p3x)]=(oSx)call iDx(p3x,A4e,true,function b0r)return trueendfunctionfunction b2r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=A2e[oSx]local integer rYx=A3e[oSx]call iKx(p3x)return trueendfunctionfunction b3r takes nothing returns booleanlocal integer rFx=(bv)set AYe=(Mv[(rFx)])set Aze=(zH[(rFx)])set AZe=(yH[(rFx)])set A_e=(YH[(rFx)])call Dux(((Vv[(rFx)])),(Awe),(1),w)return trueendfunctionfunction b4r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local real O4o=(CQx((SCv),Uvv+(rYx)))local real Nbo=Aue[rYx]local integer svo=A0e[(Cqx)]
local integer AKo=(Tf[(Iix)])local real dVx=(GetUnitX(C[((Iix))]))local real dEx=(GetUnitY(C[((Iix))]))call Nvo(Noo(dVx,dEx,A6e,Bi,O4o*1./ 160.))if(IsUnitAlly(C[(Iix)],vx[((ze[(Cqx)]))]))thencall Nbx((Iix),(AUe),(rYx),(Cqx),((AQe[rYx])*1.))call mao(Cqx,Iix,(Ate[rYx]*(rG[(Iix)]))*(1.-Rlo(Iix==Cqx)*(1.-A7e)))
else
if I9x(Iix,Wd)thencall Nbx((Iix),(Ape),(rYx),w,((Ase[rYx])*1.))else
call Nbx((Iix),(Ape),(rYx),w,((ASe[rYx])*1.))endifset Iix=NEo(svo)
if(Iix!=w)thenloop
call nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))set Iix=NEo(svo)
exitwhen(Iix==w)
endloopendifendifreturn trueendfunctionfunction b5r takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),Awe)return trueendfunctionfunction b6r takes nothing returns booleanlocal integer iset Aye=Xpx(function bzr)call Lxx(Awe,Xdx("TaintedLeaf_Init: call TaintedLeaf.CAST_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TaintedLeaf.Event_Cast_BuffGain))",bd,MI,function bZr))call Lxx(Awe,Xdx("TaintedLeaf_Init: call TaintedLeaf.CAST_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TaintedLeaf.Event_Cast_BuffLose))",jc,MI,function b_r))call Lxx(AUe,Xdx("TaintedLeaf_Init: call TaintedLeaf.TAINTED_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TaintedLeaf.Event_BuffGain))",bd,MI,function b1r))call Lxx(AUe,Xdx("TaintedLeaf_Init: call TaintedLeaf.TAINTED_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TaintedLeaf.Event_BuffLose))",jc,MI,function b2r))call mro(SCv,Xdx("TaintedLeaf_Init: call TaintedLeaf.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Begin.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TaintedLeaf.Event_Cast))",dxv,MI,function b3r))call mro(SCv,Xdx("TaintedLeaf_Init: call TaintedLeaf.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TaintedLeaf.Event_SpellEffect))",ih,MI,function b4r))call mro(SCv,Xdx("TaintedLeaf_Init: call TaintedLeaf.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TaintedLeaf.Event_EndCast))",onv,MI,function b5r))call W2x(XPv,Ape)set i=(m6[(SCv)])loop
exitwhen(i<1)set A5e[i]=ATe[i]*1./(R2I(((AQe[i]*1./ A4e)*1.)))set i=i-1endloopreturn trueendfunctionfunction b7r takes nothing returns booleancall Axr(function b6r,"TaintedLeaf_Init")return trueendfunctionfunction b8r takes nothing returns booleanset A8e[1]=2
set A8e[2]=2
set A8e[3]=2
set A8e[4]=2
set A8e[5]=2
set A9e[1]=.5set A9e[2]=.5set A9e[3]=.5set A9e[4]=.5set A9e[5]=.5set Nve[1]=6
set Nve[2]=6
set Nve[3]=6
set Nve[4]=6
set Nve[5]=6
set Nee[1]=2
set Nee[2]=2
set Nee[3]=3
set Nee[4]=3
set Nee[5]=4
return trueendfunctionfunction b9r takes nothing returns booleanset Nxe=ltx(Noe+" (activeBuff)")
call lWx(Nxe,"VioletEarring_page\\VioletEarring_struct\\Charge\\WeaponEffectGreen.mdx","weapon",ri)return trueendfunctionfunction Bvr takes nothing returns booleancall L1x('AVEX',false)return trueendfunctionfunction Ber takes nothing returns booleanset Nre=ltx(Noe+" (dummyBuff)")return trueendfunctionfunction Bxr takes nothing returns booleanset Nie=ltx(Noe+" (banishBuff)")
return trueendfunctionfunction Bor takes nothing returns booleanset Nae=ltx(Noe+" (cooldownBuff)")return trueendfunctionfunction Brr takes nothing returns booleancall VNx(va,(function b8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\VioletEarring.page\\VioletEarring.struct\\Charge\\obj_this_wc3obj.j"))call VNx(ma,(function b9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\VioletEarring.page\\VioletEarring.struct\\Charge\\obj_activeBuff_wc3buff.j"))call VNx(Pa,(function Bvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\VioletEarring.page\\VioletEarring.struct\\Charge\\obj_missileArtSpell_wc3spell.j"))
call VNx(ma,(function Ber),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\VioletEarring.page\\VioletEarring.struct\\Charge\\obj_dummyBuff_wc3buff.j"))call VNx(ma,(function Bxr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\VioletEarring.page\\VioletEarring.struct\\Charge\\obj_banishBuff_wc3buff.j"))call VNx(ma,(function Bor),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\VioletEarring.page\\VioletEarring.struct\\Charge\\obj_cooldownBuff_wc3buff.j"))
return trueendfunctionfunction Bir takes nothing returns booleanset Nne=VXx(Noe)
return trueendfunctionfunction Bar takes nothing returns booleanset NVe=ltx(NEe+" (dummyBuff)")call lWx(NVe,"VioletEarring_page\\VioletEarring_struct\\Port\\PortCircle.mdx","origin",ri)return trueendfunctionfunction Bnr takes nothing returns booleancall VNx(ma,(function Bar),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\VioletEarring.page\\VioletEarring.struct\\Port\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction BVr takes nothing returns booleanset NXe=VXx(NEe)
return trueendfunctionfunction BEr takes nothing returns booleancall L1x('AViE',false)set SNv=L0o('AViE')set K6[(SNv)]=(f6)set m6[(SNv)]=(6)set TH[(SNv)]=("Violet Earring")
set Rh[(SNv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Aj))))))set oxv[(SNv)]=(4)set x3v[(SNv)]=("spell")
call L1o((SNv),GH+(1),((40)*1.))
call L1o((SNv),tH+(1),((0)*1.))call L1o((SNv),Lov+(1),(($3E8)*1.))call L1o((SNv),GH+(2),((38)*1.))
call L1o((SNv),tH+(2),((0)*1.))call L1o((SNv),Lov+(2),(($3E8)*1.))call L1o((SNv),GH+(3),((36)*1.))
call L1o((SNv),tH+(3),((0)*1.))call L1o((SNv),Lov+(3),(($3E8)*1.))call L1o((SNv),GH+(4),((34)*1.))
call L1o((SNv),tH+(4),((0)*1.))call L1o((SNv),Lov+(4),(($3E8)*1.))call L1o((SNv),GH+(5),((32)*1.))
call L1o((SNv),tH+(5),((0)*1.))call L1o((SNv),Lov+(5),(($3E8)*1.))call L1o((SNv),GH+(6),((30)*1.))
call L1o((SNv),tH+(6),((0)*1.))call L1o((SNv),Lov+(6),(($3E8)*1.))set MOv[(SNv)]=("ReplaceableTextures\\CommandButtons\\BTNHeartOfAszune.blp")
set NOe[1]=$A0set NOe[2]=$FAset NOe[3]=340set NOe[4]=430set NOe[5]=520set NOe[6]=610return trueendfunctionfunction BXr takes nothing returns booleancall VNx(Pa,(function BEr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\VioletEarring.page\\VioletEarring.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction BOr takes nothing returns booleanset NRe=VXx(NIe)
return trueendfunctionfunction BRr takes integer oSx returns integerset Nde[oSx]=trueset NDe[oSx]=falsecall rEx(NXe)return oSxendfunctionfunction BIr takes nothing returns integerlocal integer oSxif(Nbe==8190)thencall o_x("FolderVioletEarring_StructPort_Allocation_allocCustom","call DebugEx(FolderVioletEarring_StructPort.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",NEe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(NBe[(w)]==w)thenset Nce=Nce+1set oSx=Nceelse
set oSx=NBe[(w)]
set NBe[(w)]=NBe[NBe[(w)]]endifset NBe[oSx]=Zset NCe[oSx]=1call BRr(oSx)return oSxendfunctionfunction BAr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=(mZv[(Mho)])local integer rLx=Nfe[oSx]local integer Cqx=(EH[(rLx)])local integer rYx=(IH[(rLx)])local real wQolocal real wsocall MFo(Mho)set wQo=(GetUnitX(C[((Cqx))]))set wso=(GetUnitY(C[((Cqx))]))call Ryx((ACx((Cqx),(Nge),(NGe),(ri))))call fzx(Cqx,(GetUnitX(C[((Iix))])),(GetUnitY(C[((Iix))])))call Ryx((ACx((Iix),(Nge),(NGe),(ri))))call fzx(Iix,wQo,wso)call Ulx(Cqx,NVe)call Ulx(Iix,NVe)return trueendfunctionfunction BNr takes integer rLx returns nothinglocal integer Cqx=(EH[(rLx)])local integer Iix=(Wh[(rLx)])local integer oSx=BIr()local integer Mho=Moo()set Nfe[oSx]=rLx
call Ucx(rLx)call Dux((Cqx),(NVe),(1),w)call Dux((Iix),(NVe),(1),w)call Mox(Mho,NFe)set mcv[((Mho))]=((Bev*((.0)*1.))*1.)set mCv[(Mho)]=((10.)*1.)set mFv[(Mho)]=Xkx((function BAr))set mZv[(Mho)]=(oSx)
call Meo(Mho,600.)call pxo(Mho,Cqx)call M6o((Mho),(Iix),.0,.0,.0,(function M8o))call Mno(Mho,'qViE',1.)endfunctionfunction Bbr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local integer Ctx=(WH[(rFx)])call Ryx((ACx((Cqx),(NAe),(NNe),(ri))))call DXx((Cqx),(g5v))call DXx((Cqx),(g6v))call BNx(Cqx,NOe[rYx])if(Cqx!=Iix)then
call BNr(Ctx)endifreturn trueendfunctionfunction BBr takes nothing returns booleanlocal integer rFx=(bv)local real nZx=(E1v[(rFx)])local integer Cqx=(E2v[(rFx)])local integer Iix=(Vv[(rFx)])local integer rYx=(osx(((Cqx)),Yb+(Nxe)))local real Bcrif((GetUnitAbilityLevel(C[((Iix))],('BVEX')))==0)thenreturn trueendifcall UnitRemoveAbility(C[((Iix))],('BVEX'))if I9x(Iix,Wd)thenset Bcr=A9e[rYx]
else
set Bcr=A8e[rYx]
endifcall Nbx((Iix),(Nie),(rYx),w,((Bcr)*1.))
call Nbx((Cqx),(Nae),(rYx),w,((Nve[rYx])*1.))set E1v[(rFx)]=((nZx*Nee[rYx])*1.)return trueendfunctionfunction BCr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])call Avx(Cqx,Nhe)call rtx(Cqx,'AVEX')
return trueendfunctionfunction Bdr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(hc[(rFx)])call RPx(Cqx,Nhe)call UnitRemoveAbility(C[((Cqx))],('AVEX'))return trueendfunctionfunction BDr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])call AZx(Cqx,Nxe)return trueendfunctionfunction Bfr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(hc[(rFx)])local integer oSx=Cqxif NHe[oSx]thencall Dux((Cqx),(Nxe),(rYx),w)endifreturn trueendfunctionfunction BFr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(hc[(rFx)])local integer oSx=Cqxset NHe[oSx]=truecall Dux((Cqx),(Nxe),(rYx),w)return trueendfunctionfunction Bgr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oSx=Cqxset NHe[oSx]=falsecall AZx(Cqx,Nxe)call AZx(Cqx,Nae)return trueendfunctionfunction BGr takes nothing returns booleanlocal integer rFx=(bv)call seo((Vv[(rFx)]),Nre,(Mv[(rFx)]))return trueendfunctionfunction Bhr takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(Nre),((Mv[(rFx)])),w)return trueendfunctionfunction BHr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),Nre)return trueendfunctionfunction Bjr takes nothing returns nothingset Nhe=Xdx("FolderVioletEarring_StructCharge_Init: set FolderVioletEarring_StructCharge.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_Damage)",E4v,MI,function BBr)
call Lxx(Nxe,Xdx("FolderVioletEarring_StructCharge_Init: call FolderVioletEarring_StructCharge.ACTIVE_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_ActiveBuffGain))",bd,MI,function BCr))call Lxx(Nxe,Xdx("FolderVioletEarring_StructCharge_Init: call FolderVioletEarring_StructCharge.ACTIVE_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_ActiveBuffLose))",jc,MI,function Bdr))call Lxx(Nae,Xdx("FolderVioletEarring_StructCharge_Init: call FolderVioletEarring_StructCharge.COOLDOWN_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_CooldownBuffGain))",bd,MI,function BDr))call Lxx(Nae,Xdx("FolderVioletEarring_StructCharge_Init: call FolderVioletEarring_StructCharge.COOLDOWN_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_CooldownBuffLose))",jc,MI,function Bfr))call Lxx(Nre,Xdx("FolderVioletEarring_StructCharge_Init: call FolderVioletEarring_StructCharge.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_BuffGain))",bd,MI,function BFr))
call Lxx(Nre,Xdx("FolderVioletEarring_StructCharge_Init: call FolderVioletEarring_StructCharge.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_BuffLose))",jc,MI,function Bgr))
call mro(SNv,Xdx("FolderVioletEarring_StructCharge_Init: call VioletEarring.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_ChangeLevel))",Pv,MI,function BGr))
call mro(SNv,Xdx("FolderVioletEarring_StructCharge_Init: call VioletEarring.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_Learn))",pv,MI,function Bhr))call mro(SNv,Xdx("FolderVioletEarring_StructCharge_Init: call VioletEarring.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructCharge.Event_Unlearn))",Av,MI,function BHr))call W2x(ERv,Nie)endfunctionfunction BJr takes integer oSx returns nothingset Nde[oSx]=falsecall rHx(NXe)endfunctionfunction Bkr takes integer oSx returns nothingif(NCe[oSx]>0)thenreturnendifif(NBe[oSx]!=Z)thencall o_x("FolderVioletEarring_StructPort_Allocation_deallocCustom_confirm","call DebugEx(FolderVioletEarring_StructPort.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",NEe+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset NBe[oSx]=NBe[(w)]set NBe[(w)]=oSx
call BJr(oSx)endfunctionfunction BKr takes integer oSx returns nothingset NCe[oSx]=NCe[oSx]-1call Bkr(oSx)endfunctionfunction Blr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer rLx=Nfe[oSx]call m1x(Mho,NFe)call Usx(rLx)call BKr((oSx))return trueendfunctionfunction BLr takes nothing returns booleancall mro(SNv,Xdx("VioletEarring_Init: call VioletEarring.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function VioletEarring.Event_SpellEffect))",ih,MI,function Bbr))
call Bjr()set NFe=Xdx("FolderVioletEarring_StructPort_Init: set FolderVioletEarring_StructPort.MISSILE_DESTROY_EVENT = Event.Create(Missile.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function FolderVioletEarring_StructPort.Event_Missile_Destroy)",yY,MI,function Blr)return trueendfunctionfunction Bmr takes nothing returns booleancall Axr(function BLr,"VioletEarring_Init")return trueendfunctionfunction BMr takes nothing returns booleanset Nje[1]=5
set Nje[2]=6
set Nje[3]=7
set Nje[4]=8
set Nje[5]=9
set Nje[6]=$Aset NJe[1]=30set NJe[2]=40set NJe[3]=50set NJe[4]=60set NJe[5]=70set NJe[6]=80set Nke[1]=2.5set Nke[2]=3
set Nke[3]=3.5set Nke[4]=4
set Nke[5]=4.5set Nke[6]=5
return trueendfunctionfunction Bpr takes nothing returns booleanset NKe=ltx(Nle+" (poisonBuff)")
set Pc[(NKe)]=(true)
set uU[(NKe)]=(true)
return trueendfunctionfunction BPr takes nothing returns booleancall VNx(va,(function BMr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\Vomit.page\\Vomit.struct\\Target\\obj_this_wc3obj.j"))call VNx(ma,(function Bpr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\Vomit.page\\Vomit.struct\\Target\\obj_poisonBuff_wc3buff.j"))return trueendfunctionfunction Bqr takes nothing returns booleanset NLe=VXx(Nle)
return trueendfunctionfunction BQr takes nothing returns booleancall L1x('AVom',false)set Nme=L0o('AVom')set K6[(Nme)]=(f6)set m6[(Nme)]=(6)set TH[(Nme)]=("Vomit")set Rh[(Nme)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Aj))))))set oxv[(Nme)]=(4)set x3v[(Nme)]=("spell")
call L1o((Nme),Uvv+(1),(('}')*1.))call L1o((Nme),GH+(1),((3)*1.))call L1o((Nme),tH+(1),((25)*1.))
call L1o((Nme),Lov+(1),((700)*1.))call L1o((Nme),Uvv+(2),(('}')*1.))call L1o((Nme),GH+(2),((3)*1.))call L1o((Nme),tH+(2),((30)*1.))
call L1o((Nme),Lov+(2),((700)*1.))call L1o((Nme),Uvv+(3),(('}')*1.))call L1o((Nme),GH+(3),((3)*1.))call L1o((Nme),tH+(3),((35)*1.))
call L1o((Nme),Lov+(3),((700)*1.))call L1o((Nme),Uvv+(4),(('}')*1.))call L1o((Nme),GH+(4),((3)*1.))call L1o((Nme),tH+(4),((40)*1.))
call L1o((Nme),Lov+(4),((700)*1.))call L1o((Nme),Uvv+(5),(('}')*1.))call L1o((Nme),GH+(5),((3)*1.))call L1o((Nme),tH+(5),((45)*1.))
call L1o((Nme),Lov+(5),((700)*1.))call L1o((Nme),Uvv+(6),(('}')*1.))call L1o((Nme),GH+(6),((3)*1.))call L1o((Nme),tH+(6),((50)*1.))
call L1o((Nme),Lov+(6),((700)*1.))set MOv[(Nme)]=("ReplaceableTextures\\CommandButtons\\BTNCorrosiveBreath.blp")set NMe[1]=$Aset NMe[2]=20set NMe[3]=30set NMe[4]=40set NMe[5]=50set NMe[6]=60return trueendfunctionfunction Bsr takes nothing returns booleancall VNx(Pa,(function BQr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\Vomit.page\\Vomit.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction BSr takes nothing returns booleanset Npe=VXx(NPe)
return trueendfunctionfunction Btr takes integer Iix returns booleanreturn( not(I9x(Iix,Qc)))and( not((I9x(Rb,Idv)!=I9x(Iix,Qc))and(I9x(Rb,Iav)!=I9x(Iix,Iav))))and( not(I9x(Iix,Igv)))and( not(IsUnitAlly(C[(Iix)],vx[(hf)])))endfunctionfunction BTr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer Iix=jhx()local integer oSx=(mZv[(Mho)])if(I8x((Nse[oSx]),Ob,(Iix)))then
return false
endifif not Btr(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction Bur takes nothing returns booleanreturn Btr(jhx())return trueendfunctionfunction BUr takes integer oSx returns integerset Nwe[oSx]=trueset NWe[oSx]=falsecall rEx(Npe)return oSxendfunctionfunction Bwr takes nothing returns integerlocal integer oSxif(Nte==8190)thencall o_x("Vomit_Allocation_allocCustom","call DebugEx(Vomit.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",NPe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(NTe[(w)]==w)thenset Nue=Nue+1set oSx=Nueelse
set oSx=NTe[(w)]
set NTe[(w)]=NTe[NTe[(w)]]endifset NTe[oSx]=Zset NUe[oSx]=1call BUr(oSx)return oSxendfunctionfunction BWr takes integer oSx returns nothingset Nwe[oSx]=falsecall rHx(Npe)endfunctionfunction Byr takes integer oSx returns nothingif(NUe[oSx]>0)thenreturnendifif(NTe[oSx]!=Z)thencall o_x("Vomit_Allocation_deallocCustom_confirm","call DebugEx(Vomit.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",NPe+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset NTe[oSx]=NTe[(w)]set NTe[(w)]=oSx
call BWr(oSx)endfunctionfunction BYr takes integer oSx returns nothingset NUe[oSx]=NUe[oSx]-1call Byr(oSx)endfunctionfunction Bzr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=Nye[oSx]local integer rYx=NYe[oSx]local integer Iix=NZe[oSx]local integer Ctx=N_e[oSx]local real Nbocall BYr((oSx))call MFo(Mho)set hf=(ze[(Cqx)])set Rb=Iixcall NVo(Nqe,(GetUnitX(C[((Iix))])),(GetUnitY(C[((Iix))])),(CQx((Nme),Uvv+(rYx)))*Nze[oSx],NSe)call GroupRemoveUnit(kb[(Nqe)],C[(Iix)])
set Iix=NEo(Nqe)
if(Iix!=w)thenset Nbo=NMe[rYx]
loop
call nlo((Cqx),(Iix),((Nbo)*1.),(false),(false))
set Iix=NEo(Nqe)
exitwhen(Iix==w)
endloopendifcall dNx(Ctx)return trueendfunctionfunction BZr takes integer oSx,integer rYx,integer Iix returns nothinglocal real iMxif I9x(Iix,Wd)thenset iMx=Nke[rYx]
else
set iMx=Nje[rYx]
endifcall Nbx(Iix,NKe,rYx,N2e[oSx],iMx)endfunctionfunction B_r takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=(mZv[(Mho)])call dQx(Nse[oSx],Iix)call BZr((w),NYe[oSx],Iix)return trueendfunctionfunction B0r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local real MQx=X_x(dVx,dEx)+60.local real fvx=(eb[(Cqx)])local integer oSx=Bwr()local integer Mho=Moo()local integer Ctx=CPx(Cqx,Nme)set Nye[oSx]=Cqx
set NYe[oSx]=(IH[(Ctx)])
set Nze[oSx]=fvx
set NZe[oSx]=NZe[oSx]set N_e[oSx]=Ctx
set N0e[oSx]=(GetUnitX(C[((Cqx))]))set N1e[oSx]=(GetUnitY(C[((Cqx))]))set mcv[((Mho))]=((Bev*((.06)*1.))*1.)set mCv[(Mho)]=(((CQx((Nme),Uvv+(NYe[oSx]))))*1.)call Mno(Mho,'qVom',fvx)
set mFv[(Mho)]=Xkx((function Bzr))set mZv[(Mho)]=(oSx)
call Meo(Mho,900.)call pxo(Mho,Cqx)call o9r(Mho,dVx,dEx,MQx)call rtr(Mho,function B_r,NQe)return trueendfunctionfunction B1r takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxcall nlo((N2e[oSx]),(Iix),((N4e[oSx])*1.),(false),(false))endfunctionfunction B2r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Lc[(rFx)])local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local real iMxlocal integer fexlocal integer oSxlocal integer p3xif I9x(Iix,Wd)thenset iMx=Nke[rYx]
else
set iMx=Nje[rYx]
endifset fex=(R2I(((iMx*1./ N3e)*1.)))set oSx=Iixset p3x=iXx()set N2e[oSx]=Cqx
set N4e[oSx]=NJe[rYx]*1./ fexset N5e[oSx]=p3x
set ge[(p3x)]=(oSx)call iDx(p3x,N3e,true,function B1r)return trueendfunctionfunction B3r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=N5e[oSx]call iKx(p3x)return trueendfunctionfunction B4r takes nothing returns nothingcall Lxx(NKe,Xdx("FolderVomit_StructTarget_Init: call FolderVomit_StructTarget.POISON_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVomit_StructTarget.BuffGain))",bd,MI,function B2r))call Lxx(NKe,Xdx("FolderVomit_StructTarget_Init: call FolderVomit_StructTarget.POISON_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderVomit_StructTarget.BuffLose))",jc,MI,function B3r))call W2x(XDv,NKe)endfunctionfunction B5r takes nothing returns booleanset Nqe=O5x()set NQe=Xpx(function BTr)set NSe=Xpx(function Bur)call mro(Nme,Xdx("Vomit_Init: call Vomit.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Vomit.Event_SpellEffect))",ih,MI,function B0r))
call B4r()return trueendfunctionfunction B6r takes nothing returns booleancall Axr(function B5r,"Vomit_Init")return trueendfunctionfunction B7r takes nothing returns booleanset N6e[1]=30set N6e[2]=40set N6e[3]=50set N6e[4]=60set N6e[5]=70set N6e[6]=80return trueendfunctionfunction B8r takes nothing returns booleanset N7e=Wwx('BWhS',"White Staff",'bWhS')
set aav[(N7e)]=(true)set anv[(N7e)]=("ReplaceableTextures\\CommandButtons\\BTNAdvancedStrengthOfTheMoon.blp")
call lWx(N7e,"Abilities\\Spells\\Items\\AIil\\AIilTarget.mdl","origin",ri)set WU=l_x()
call l2x(WU,cVv,30)call l3x(((N7e)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,cVv,40)call l3x(((N7e)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,cVv,50)call l3x(((N7e)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,cVv,60)call l3x(((N7e)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,cVv,70)call l3x(((N7e)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,cVv,80)call l3x(((N7e)),ZB+(6),(WU))return trueendfunctionfunction B9r takes nothing returns booleancall VNx(va,(function B7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\WhiteStaff.page\\WhiteStaff.struct\\Target\\obj_this_wc3obj.j"))call VNx(ma,(function B8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\WhiteStaff.page\\WhiteStaff.struct\\Target\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction cvr takes nothing returns booleanset N8e=VXx(N9e)
return trueendfunctionfunction cer takes nothing returns booleanset bve=u4x()set IC[(bve)]=("Abilities\\Spells\\Other\\Drain\\SiphonManaLoop.wav")set NC[(bve)]=(p5)set BC[(bve)]=(l5)set CC[(bve)]=((1)*1.)set DC[(bve)]=((1)*1.)set FC[(bve)]=($A)set GC[(bve)]=((1)*1.)set kC[(bve)]=(true)
set mC[(bve)]=(true)
set pC[(bve)]=((600)*1.)
set qC[(bve)]=(($186A0)*1.)set sC[(bve)]=(($7D0)*1.)return trueendfunctionfunction cxr takes nothing returns booleanset bee=VCx("OWhS")return trueendfunctionfunction cor takes nothing returns booleancall L1x('AWhS',false)set SIv=L0o('AWhS')set K6[(SIv)]=(f6)set m6[(SIv)]=(6)set TH[(SIv)]=("White Staff")set Rh[(SIv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Aj))))))set oxv[(SIv)]=(4)set x3v[(SIv)]=("spell")
call L1o((SIv),dH+(1),((5)*1.))call L1o((SIv),GH+(1),(($A)*1.))
call L1o((SIv),tH+(1),((5)*1.))call L1o((SIv),Lov+(1),((700)*1.))call L1o((SIv),dH+(2),((4.75)*1.))call L1o((SIv),GH+(2),(($A)*1.))
call L1o((SIv),tH+(2),((5)*1.))call L1o((SIv),Lov+(2),((700)*1.))call L1o((SIv),dH+(3),((4.5)*1.))call L1o((SIv),GH+(3),(($A)*1.))
call L1o((SIv),tH+(3),((5)*1.))call L1o((SIv),Lov+(3),((700)*1.))call L1o((SIv),dH+(4),((4.25)*1.))call L1o((SIv),GH+(4),(($A)*1.))
call L1o((SIv),tH+(4),((5)*1.))call L1o((SIv),Lov+(4),((700)*1.))call L1o((SIv),dH+(5),((4)*1.))call L1o((SIv),GH+(5),(($A)*1.))
call L1o((SIv),tH+(5),((5)*1.))call L1o((SIv),Lov+(5),((700)*1.))call L1o((SIv),dH+(6),((3.75)*1.))call L1o((SIv),GH+(6),(($A)*1.))
call L1o((SIv),tH+(6),((5)*1.))call L1o((SIv),Lov+(6),((700)*1.))set MOv[(SIv)]=("ReplaceableTextures\\CommandButtons\\BTNAdvancedStrengthOfTheMoon.blp")
set bxe[1]=8
set bxe[2]=$Cset bxe[3]=16set bxe[4]=20set bxe[5]=24set bxe[6]=28return trueendfunctionfunction crr takes nothing returns booleancall VNx(La,(function cer),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\WhiteStaff.page\\WhiteStaff.struct\\obj_dummySound_wc3sound.j"))call VNx(ha,(function cxr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\WhiteStaff.page\\WhiteStaff.struct\\obj_bolt_wc3bolt.j"))call VNx(Pa,(function cor),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Artifacts\\WhiteStaff.page\\WhiteStaff.struct\\obj_thisSpell_wc3spell.j"))
return trueendfunctionfunction cir takes nothing returns booleanset boe=VXx(bre)
return trueendfunctionfunction car takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=oSxcall mno(Cqx,Cqx,bEe[oSx])endfunctionfunction cnr takes integer Cqx,integer rYx,integer Iix returns nothinglocal integer oSx=Cqxlocal integer cMo=cdo(bee)local integer p3x=iXx()set bie[oSx]=trueset bae[oSx]=AJx(bve)set bne[oSx]=cMo
set bVe[oSx]=p3x
set bEe[oSx]=bXe[rYx]set bOe[oSx]=Iix
set ge[(p3x)]=(oSx)call AKx(bae[oSx],Cqx)call ERr(cMo,Cqx,Iix)if I9x(Iix,IGv)thenset bRe[oSx]=truecall Dux((((Iix))),(iiv),(1),w)call D9x(Iix,bIe*(Uj[((Tf[(Iix)]))]),(CQx((SIv),dH+(rYx))))else
set bRe[oSx]=falseendifcall iDx(p3x,bAe,true,function car)if(IsUnitAlly(C[(Iix)],vx[((ze[(Cqx)]))]))thenset bNe[oSx]=Asx(Iix,N7e,rYx,w)else
set bNe[oSx]=wendifendfunctionfunction cVr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])call cnr(Cqx,rYx,Iix)return trueendfunctionfunction cEr takes integer Cqx returns nothinglocal integer oSx=Cqxlocal integer cMo=bne[oSx]local integer p3x=bVe[oSx]local boolean cXr=bRe[oSx]local integer Iix=bOe[oSx]local integer cOr=bNe[oSx]call R4x(bae[oSx],true)call K0x(cMo)call iKx(p3x)if(cOr!=w)thencall AYx(cOr)endifif cXr thencall Crx((Iix),(Cqx))call Ulx(((Iix)),iiv)endifendfunctionfunction cRr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oSx=(Cqx)if not bie[oSx]thenreturn trueendifset bie[oSx]=falsecall cEr(Cqx)return trueendfunctionfunction cIr takes nothing returns nothingendfunctionfunction cAr takes nothing returns booleanlocal integer rYxcall mro(SIv,Xdx("WhiteStaff_Init: call WhiteStaff.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function WhiteStaff.Event_SpellEffect))",ih,MI,function cVr))call mro(SIv,Xdx("WhiteStaff_Init: call WhiteStaff.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function WhiteStaff.Event_EndCast))",onv,MI,function cRr))
set rYx=(m6[(SIv)])loop
exitwhen(rYx<1)set bXe[rYx]=bxe[rYx]*bAeset rYx=rYx-1endloopcall cIr()return trueendfunctionfunction cNr takes nothing returns booleancall Axr(function cAr,"WhiteStaff_Init")
return trueendfunctionfunction cbr takes nothing returns booleanset bbe=ltx(bBe+" (dummyBuff)")return trueendfunctionfunction cBr takes nothing returns booleancall VNx(ma,(function cbr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Barrier.page\\Barrier.struct\\Knockback\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction ccr takes nothing returns booleanset bce=VXx(bBe)
return trueendfunctionfunction cCr takes nothing returns booleanset bCe=Wwx('BBar',"Strong",'bBar')set aav[(bCe)]=(true)set anv[(bCe)]=("ReplaceableTextures\\CommandButtons\\BTNFrostMourne.blp")return trueendfunctionfunction cdr takes nothing returns booleanset bde[1]=hjo('uBar')call hJo(((bde[1])),ASv,(Igv))set Uj[(bde[1])]=((1)*1.)set NOv[(bde[1])]=((60)*1.)set NWv[(bde[1])]=((60)*1.)set NPv[(bde[1])]=((1)*1.)set I8v[(bde[1])]=((5)*1.)set Anv[(bde[1])]=(3)set Nmv[(bde[1])]=(('}')*1.)
set NLv[(bde[1])]=(('}')*1.)
set NKv[(bde[1])]=((0)*1.)set NGv[(bde[1])]=((60)*1.)set Auv[(bde[1])]=((0)*1.)set AUv[(bde[1])]=((0)*1.)set AYv[(bde[1])]=(0)set A_v[(bde[1])]=(0)set ATv[(bde[1])]=((40)*1.)return trueendfunctionfunction cDr takes integer rlx,integer cfr,integer cFr,integer cgr,integer cGr,integer chr returns nothinglocal integer Odo=(K6[(rlx)])local integer cHr=(cgr+(c6[(Odo)]))local integer cjr=(C6[(Odo)])local integer rYx=(cFr-1)call L1x(cGr,false)call L1x(chr,false)call Q0x(Ge,cHr,false)call Q0x(Ge,cGr,false)call Q0x(Ge,chr,false)set bfe[((rlx))]=(cGr)set I3v[((rlx))]=(chr)set l6[((rlx))]=(cfr)set k6[((rlx))]=(cgr)call mro(rlx,J6)
call mro(rlx,M6)
call mro(rlx,p6)
loop
exitwhen(rYx<0)set cHr=(cjr+cfr+rYx)call SaveInteger(o[((V[(E[((X))])]))],(((cHr))),(((Q6))),(((rlx))))call L1x(cHr,false)set rYx=rYx-1endloopendfunctionfunction cJr takes nothing returns booleancall L1x('ABar',false)set bDe=L0o('ABar')set K6[(bDe)]=(F6)set m6[(bDe)]=(6)set TH[(bDe)]=("Barrier")set Rh[(bDe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D02B2)))),(((Aj))))))set oxv[(bDe)]=(0)set x3v[(bDe)]=("spell")
call L1o((bDe),GH+(1),((8)*1.))call L1o((bDe),tH+(1),((20)*1.))
call L1o((bDe),Lov+(1),((750)*1.))call L1o((bDe),GH+(2),((8)*1.))call L1o((bDe),tH+(2),((30)*1.))
call L1o((bDe),Lov+(2),((750)*1.))call L1o((bDe),GH+(3),((8)*1.))call L1o((bDe),tH+(3),((40)*1.))
call L1o((bDe),Lov+(3),((750)*1.))call L1o((bDe),GH+(4),((8)*1.))call L1o((bDe),tH+(4),((50)*1.))
call L1o((bDe),Lov+(4),((750)*1.))call L1o((bDe),GH+(5),((8)*1.))call L1o((bDe),tH+(5),((60)*1.))
call L1o((bDe),Lov+(5),((750)*1.))call L1o((bDe),GH+(6),((8)*1.))call L1o((bDe),tH+(6),((70)*1.))
call L1o((bDe),Lov+(6),((750)*1.))set MOv[(bDe)]=("ReplaceableTextures\\CommandButtons\\BTNFrostMourne.blp")call cDr(bDe,'FBA0',6,'VBA0','LPBA','LRBA')set bFe[1]=3
set bFe[2]=3
set bFe[3]=4
set bFe[4]=4
set bFe[5]=5
set bFe[6]=5
set bge[1]=3
set bge[2]=3.5set bge[3]=4
set bge[4]=4.5set bge[5]=5
set bge[6]=5.5return trueendfunctionfunction ckr takes nothing returns booleanset bde[6]=hjo('uBa6')call hJo(((bde[6])),ASv,(Igv))set Uj[(bde[6])]=((1)*1.)set NOv[(bde[6])]=((60)*1.)set NWv[(bde[6])]=((60)*1.)set I8v[(bde[6])]=(($A)*1.)set Anv[(bde[6])]=(3)set Nmv[(bde[6])]=((500)*1.)
set NLv[(bde[6])]=((500)*1.)
set NKv[(bde[6])]=((0)*1.)set NGv[(bde[6])]=(('n')*1.)
set Auv[(bde[6])]=((0)*1.)set AUv[(bde[6])]=((0)*1.)set AYv[(bde[6])]=(0)set A_v[(bde[6])]=(0)set ATv[(bde[6])]=((40)*1.)return trueendfunctionfunction cKr takes nothing returns booleanset bde[2]=hjo('uBa2')call hJo(((bde[2])),ASv,(Igv))set Uj[(bde[2])]=((1)*1.)set NOv[(bde[2])]=((60)*1.)set NWv[(bde[2])]=((60)*1.)set I8v[(bde[2])]=((6)*1.)set Anv[(bde[2])]=(3)set Nmv[(bde[2])]=(($B4)*1.)
set NLv[(bde[2])]=(($B4)*1.)
set NKv[(bde[2])]=((0)*1.)set NGv[(bde[2])]=((70)*1.)set Auv[(bde[2])]=((0)*1.)set AUv[(bde[2])]=((0)*1.)set AYv[(bde[2])]=(0)set A_v[(bde[2])]=(0)set ATv[(bde[2])]=((40)*1.)return trueendfunctionfunction clr takes nothing returns booleanset bde[3]=hjo('uBa3')call hJo(((bde[3])),ASv,(Igv))set Uj[(bde[3])]=((1)*1.)set NOv[(bde[3])]=((60)*1.)set NWv[(bde[3])]=((60)*1.)set I8v[(bde[3])]=((7)*1.)set Anv[(bde[3])]=(3)set Nmv[(bde[3])]=(($F0)*1.)
set NLv[(bde[3])]=(($F0)*1.)
set NKv[(bde[3])]=((0)*1.)set NGv[(bde[3])]=((80)*1.)set Auv[(bde[3])]=((0)*1.)set AUv[(bde[3])]=((0)*1.)set AYv[(bde[3])]=(0)set A_v[(bde[3])]=(0)set ATv[(bde[3])]=((40)*1.)return trueendfunctionfunction cLr takes nothing returns booleanset bde[4]=hjo('uBa4')call hJo(((bde[4])),ASv,(Igv))set Uj[(bde[4])]=((1)*1.)set NOv[(bde[4])]=((60)*1.)set NWv[(bde[4])]=((60)*1.)set I8v[(bde[4])]=((8)*1.)set Anv[(bde[4])]=(3)set Nmv[(bde[4])]=((310)*1.)
set NLv[(bde[4])]=((310)*1.)
set NKv[(bde[4])]=((0)*1.)set NGv[(bde[4])]=((90)*1.)set Auv[(bde[4])]=((0)*1.)set AUv[(bde[4])]=((0)*1.)set AYv[(bde[4])]=(0)set A_v[(bde[4])]=(0)set ATv[(bde[4])]=((40)*1.)return trueendfunctionfunction cmr takes nothing returns booleanset bde[5]=hjo('uBa5')call hJo(((bde[5])),ASv,(Igv))set Uj[(bde[5])]=((1)*1.)set NOv[(bde[5])]=((60)*1.)set NWv[(bde[5])]=((60)*1.)set I8v[(bde[5])]=((9)*1.)set Anv[(bde[5])]=(3)set Nmv[(bde[5])]=((400)*1.)
set NLv[(bde[5])]=((400)*1.)
set NKv[(bde[5])]=((0)*1.)set NGv[(bde[5])]=(('d')*1.)
set Auv[(bde[5])]=((0)*1.)set AUv[(bde[5])]=((0)*1.)set AYv[(bde[5])]=(0)set A_v[(bde[5])]=(0)set ATv[(bde[5])]=((40)*1.)return trueendfunctionfunction cMr takes nothing returns booleancall VNx(ma,(function cCr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Barrier.page\\Barrier.struct\\obj_dummyBuff_wc3buff.j"))call VNx(sa,(function cdr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Barrier.page\\Barrier.struct\\obj_summonUnitType[1]_wc3unit.j"))call VNx(Pa,(function cJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Barrier.page\\Barrier.struct\\obj_thisSpell_wc3spell.j"))call VNx(sa,(function ckr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Barrier.page\\Barrier.struct\\obj_summonUnitType[6]_wc3unit.j"))call VNx(sa,(function cKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Barrier.page\\Barrier.struct\\obj_summonUnitType[2]_wc3unit.j"))call VNx(sa,(function clr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Barrier.page\\Barrier.struct\\obj_summonUnitType[3]_wc3unit.j"))call VNx(sa,(function cLr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Barrier.page\\Barrier.struct\\obj_summonUnitType[4]_wc3unit.j"))call VNx(sa,(function cmr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Barrier.page\\Barrier.struct\\obj_summonUnitType[5]_wc3unit.j"))return trueendfunctionfunction cpr takes nothing returns booleanset bGe=VXx(bhe)
return trueendfunctionfunction cPr takes code c,string rSx returns nothing
set Sn=Sn+1set tn[Sn]=CreateTrigger()set Tn[Sn]=(GetHandleId(Condition((c))))
set un[Sn]=rSxcall TriggerAddCondition(tn[Sn],Condition(c))endfunctionfunction cqr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real bex=(GetUnitFacing(C[((Cqx))])*Nh)local integer C3o=(ze[(Cqx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real cQr=(Cos(((((bex)*1.))*1.)))local real csr=(Sin(((((bex)*1.))*1.)))local real iMx=bge[rYx]local integer oMx=bFe[rYx]local integer cSr=bde[rYx]local real dVx=wQo+bHe*cQrlocal real dEx=wso+bHe*csrlocal real ctr=oMx*bjelocal integer cTrset bex=bex-ctr*1./ 2.loop
set cTr=bOx(cSr,C3o,dVx,dEx,kf)call Nbx((cTr),(bCe),(rYx),w,((iMx)*1.))
call pmo((ACx((cTr),(bJe),(bke),(Bi))),2.)call R1o(cTr)call Dux((((cTr))),(XAv),(1),w)call fwx(cTr,dVx)call fWx(cTr,dEx)call RHr(cTr,bKe*(Cos(((((bex)*1.))*1.))),bKe*(Sin(((((bex)*1.))*1.))),.0,ble)call UZo((cTr),((iMx)*1.))call Nbx(((cTr)),(bbe),(1),w,((ble)*1.))
set oMx=oMx-1exitwhen(oMx<1)set bex=bex+bjeendloopreturn trueendfunctionfunction cUr takes nothing returns booleanlocal integer Iix=jhx()if(I8x((Ose),Ob,(Iix)))thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifreturn truereturn trueendfunctionfunction cwr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxlocal integer svo=bMe[oSx]local real dVx=(GetUnitX(C[((Iix))]))local real dEx=(GetUnitY(C[((Iix))]))local integer w2oset Ose=svocall NVo(bLe,dVx,dEx,bPe,bme)set w2o=NEo(bLe)
if(w2o!=w)thenloop
call dQx(svo,w2o)call Our(w2o,1000.,-520.,(Atan2((((GetUnitY(C[((w2o))]))-dEx)*1.),(((GetUnitX(C[((w2o))]))-dVx)*1.))),.35)set w2o=NEo(bLe)
exitwhen(w2o==w)
endloopendifendfunctionfunction cWr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer Q9o=iXx()set bMe[oSx]=Jbx("FolderBarrier_StructKnockback_Event_BuffGain: set this.targetGroup = UnitList.Create()")set bpe[oSx]=Q9o
set ge[(Q9o)]=(oSx)call iDx(Q9o,.1,true,function cwr)return trueendfunctionfunction cyr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer svo=bMe[oSx]local integer Q9o=bpe[oSx]call O9x(svo)call iKx(Q9o)return trueendfunctionfunction cYr takes nothing returns nothingset bLe=O5x()set bme=Xpx(function cUr)call Lxx(bbe,Xdx("FolderBarrier_StructKnockback_Init: call FolderBarrier_StructKnockback.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderBarrier_StructKnockback.Event_BuffGain))",bd,MI,function cWr))call Lxx(bbe,Xdx("FolderBarrier_StructKnockback_Init: call FolderBarrier_StructKnockback.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderBarrier_StructKnockback.Event_BuffLose))",jc,MI,function cyr))endfunctionfunction czr takes nothing returns booleancall mro(bDe,Xdx("Barrier_Init: call Barrier.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Barrier.Event_SpellEffect))",ih,MI,function cqr))call cYr()return trueendfunctionfunction cZr takes nothing returns booleancall cPr(function czr,"Barrier_Init")return trueendfunctionfunction c_r takes nothing returns booleanset bqe[1]=20set bqe[2]=30set bqe[3]=40set bqe[4]=50set bqe[5]=60set bQe[1]=5
set bQe[2]=6
set bQe[3]=7
set bQe[4]=8
set bQe[5]=9
return trueendfunctionfunction c0r takes nothing returns booleancall VNx(va,(function c_r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Blizzard.page\\Blizzard.struct\\Wave\\obj_this_wc3obj.j"))return trueendfunctionfunction c1r takes nothing returns booleanset bse=VXx(bSe)
return trueendfunctionfunction c2r takes nothing returns booleanset bte=ltx(bTe+" (dummyBuff)")return trueendfunctionfunction c3r takes nothing returns booleancall L1x('ABlz',false)set bue=L0o('ABlz')set K6[(bue)]=(F6)set m6[(bue)]=(6)set TH[(bue)]=("Blizzard")set Rh[(bue)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0079)))),(((Aj))))))set oxv[(bue)]=(2)set x3v[(bue)]=("spell")
call L1o((bue),Uvv+(1),((275)*1.))call L1o((bue),dH+(1),((5)*1.))call L1o((bue),GH+(1),((0)*1.))call L1o((bue),tH+(1),((40)*1.))
call L1o((bue),Lov+(1),((600)*1.))call L1o((bue),Uvv+(2),((325)*1.))call L1o((bue),dH+(2),((5)*1.))call L1o((bue),GH+(2),((0)*1.))call L1o((bue),tH+(2),((55)*1.))
call L1o((bue),Lov+(2),((600)*1.))call L1o((bue),Uvv+(3),((375)*1.))call L1o((bue),dH+(3),((5)*1.))call L1o((bue),GH+(3),((0)*1.))call L1o((bue),tH+(3),((70)*1.))
call L1o((bue),Lov+(3),((600)*1.))call L1o((bue),Uvv+(4),((425)*1.))call L1o((bue),dH+(4),((5)*1.))call L1o((bue),GH+(4),((0)*1.))call L1o((bue),tH+(4),((85)*1.))
call L1o((bue),Lov+(4),((600)*1.))call L1o((bue),Uvv+(5),((475)*1.))call L1o((bue),dH+(5),((5)*1.))call L1o((bue),GH+(5),((0)*1.))call L1o((bue),tH+(5),(('d')*1.))call L1o((bue),Lov+(5),((600)*1.))call L1o((bue),Uvv+(6),((525)*1.))call L1o((bue),dH+(6),((5)*1.))call L1o((bue),GH+(6),((0)*1.))call L1o((bue),tH+(6),(('s')*1.))call L1o((bue),Lov+(6),((600)*1.))set MOv[(bue)]=("ReplaceableTextures\\CommandButtons\\BTNBlizzard.blp")call cDr(bue,'FBZ0',6,'VBZ0','LPBZ','LRBZ')return trueendfunctionfunction c4r takes nothing returns booleancall VNx(ma,(function c2r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Blizzard.page\\Blizzard.struct\\obj_dummyBuff_wc3buff.j"))call VNx(Pa,(function c3r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Blizzard.page\\Blizzard.struct\\obj_thisSpell_wc3spell.j"))
return trueendfunctionfunction c5r takes nothing returns booleanset bUe=VXx(bTe)
return trueendfunctionfunction c6r takes integer oSx returns integerset b4e[oSx]=trueset b5e[oSx]=falsecall rEx(bse)return oSxendfunctionfunction c7r takes nothing returns integerlocal integer oSxif(b0e==8190)thencall o_x("FolderBlizzard_StructWave_Allocation_allocCustom","call DebugEx(FolderBlizzard_StructWave.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",bSe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(b1e[(w)]==w)thenset b2e=b2e+1set oSx=b2eelse
set oSx=b1e[(w)]
set b1e[(w)]=b1e[b1e[(w)]]endifset b1e[oSx]=Zset b3e[oSx]=1call c6r(oSx)return oSxendfunctionfunction c8r takes integer oSx returns nothingset b4e[oSx]=falsecall rHx(bse)endfunctionfunction c9r takes integer oSx returns nothingif(b3e[oSx]>0)thenreturnendifif(b1e[oSx]!=Z)thencall o_x("FolderBlizzard_StructWave_Allocation_deallocCustom_confirm","call DebugEx(FolderBlizzard_StructWave.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",bSe+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset b1e[oSx]=b1e[(w)]set b1e[(w)]=oSx
call c8r(oSx)endfunctionfunction Cvr takes integer oSx returns nothingset b3e[oSx]=b3e[oSx]-1call c9r(oSx)endfunctionfunction Cer takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local real O4o=b6e[oSx]local integer Cqx=b7e[oSx]local real Nbo=b8e[oSx]local real dVx=b9e[oSx]local real dEx=Bve[oSx]local integer Ctx=CPx(Cqx,bue)local integer Iixcall Cvr((oSx))call iKx(iCx)call dNx(Ctx)call NVo(Boe,dVx,dEx,O4o,Bre)loop
set Iix=NEo(Boe)
exitwhen(Iix==w)
call nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))endloopendfunctionfunction Cxr takes integer Cqx,integer rYx,real dVx,real dEx returns nothing
local real O4o=(CQx((bue),Uvv+(rYx)))local integer oSx=c7r()local integer qvo=QEx("Abilities\\Spells\\Human\\Blizzard\\BlizzardTarget"+(I2S(((GetRandomInt((1),(3))))))+".wav",false,true,false,$A,$A,l5)local integer iCx=iXx()local integer oMxlocal real bexlocal real n2xset b6e[oSx]=O4o
set b7e[oSx]=Cqx
set b8e[oSx]=bqe[rYx]set b9e[oSx]=dVx
set Bve[oSx]=dEx
set ge[(iCx)]=(oSx)set O4o=O4o*.75set oMx=bQe[rYx]
loop
exitwhen(oMx<1)set bex=(GetRandomReal(((.0)*1.),((Cf)*1.)))
set n2x=(GetRandomReal(((.0)*1.),((O4o)*1.)))call mho((mko(((dVx+n2x*(Cos(((((bex)*1.))*1.))))*1.),((dEx+n2x*(Sin(((((bex)*1.))*1.))))*1.),(Bee),(ri))))set oMx=oMx-1endloopcall iDx(iCx,Bxe,false,function Cer)
call P8o(qvo,dVx,dEx,X_x(dVx,dEx))call R4x(qvo,true)endfunctionfunction Cor takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxcall Cxr(Iix,bYe[oSx],bze[oSx],bZe[oSx])
endfunctionfunction Crr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Ctx=bwelocal integer Iix=(EH[(Ctx)])local real dVx=(yh[(Ctx)])local real dEx=(Yh[(Ctx)])local integer oSx=Iixlocal integer Cir=QEx("Abilities\\Spells\\Human\\Blizzard\\BlizzardLoop1.wav",true,true,false,$A,$A,l5)local integer p3x=iXx()set bWe[oSx]=Cir
set bye[oSx]=p3x
set bYe[oSx]=rYx
set bze[oSx]=dVx
set bZe[oSx]=dEx
set ge[(p3x)]=(oSx)call iDx(p3x,b_e,true,function Cor)call P8o(Cir,dVx,dEx,X_x(dVx,dEx))call Cxr(Iix,rYx,dVx,dEx)return trueendfunctionfunction Car takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer Cir=bWe[oSx]local integer p3x=bye[oSx]call R4x(Cir,true)call iKx(p3x)return trueendfunctionfunction Cnr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),bte)return trueendfunctionfunction CVr takes nothing returns booleanlocal integer rFx=(bv)set bwe=(WH[(rFx)])call Dux(((Vv[(rFx)])),(bte),((Mv[(rFx)])),w)return trueendfunctionfunction CEr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction CXr takes nothing returns nothingset Boe=O5x()set Bre=Xpx(function CEr)endfunctionfunction COr takes nothing returns booleancall Lxx(bte,Xdx("Blizzard_Init: call Blizzard.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Blizzard.Event_BuffGain))",bd,MI,function Crr))
call Lxx(bte,Xdx("Blizzard_Init: call Blizzard.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Blizzard.Event_BuffLose))",jc,MI,function Car))
call mro(bue,Xdx("Blizzard_Init: call Blizzard.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Blizzard.Event_EndCast))",onv,MI,function Cnr))call mro(bue,Xdx("Blizzard_Init: call Blizzard.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Blizzard.Event_SpellEffect))",ih,MI,function CVr))call CXr()return trueendfunctionfunction CRr takes nothing returns booleancall cPr(function COr,"Blizzard_Init")return trueendfunctionfunction CIr takes nothing returns booleanset Bie[1]=8
set Bie[2]=9
set Bie[3]=$Aset Bie[4]=$Bset Bie[5]=$Cset Bie[6]=$Dreturn trueendfunctionfunction CAr takes nothing returns booleanset Bae=Wwx('BChB',"Cold and slowed",'bChB')
set Pc[(Bae)]=(true)
set uU[(Bae)]=(true)
set anv[(Bae)]=("ReplaceableTextures\\CommandButtons\\BTNBreathOfFrost.blp")
call lWx(Bae,"Abilities\\Spells\\Undead\\FrostArmor\\FrostArmorDamage.mdl","chest",Bi)set WU=l_x()
call l2x(WU,dmv,-25)
call l3x(((Bae)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,dmv,-35)
call l3x(((Bae)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,dmv,-45)
call l3x(((Bae)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,dmv,-55)
call l3x(((Bae)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,dmv,-65)
call l3x(((Bae)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,dmv,-75)
call l3x(((Bae)),ZB+(6),(WU))return trueendfunctionfunction CNr takes nothing returns booleancall VNx(va,(function CIr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\ChillyBreath.page\\ChillyBreath.struct\\Buff\\obj_this_wc3obj.j"))call VNx(ma,(function CAr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\ChillyBreath.page\\ChillyBreath.struct\\Buff\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction Cbr takes nothing returns booleanset Bne=VXx(BVe)
return trueendfunctionfunction CBr takes nothing returns booleancall L1x('AChB',false)set BEe=L0o('AChB')set K6[(BEe)]=(F6)set m6[(BEe)]=(6)set TH[(BEe)]=("Chilly Breath")set Rh[(BEe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0250)))),(((Aj))))))set oxv[(BEe)]=(2)set x3v[(BEe)]=("spell")
call L1o((BEe),dH+(1),((2)*1.))call L1o((BEe),GH+(1),(($E)*1.))
call L1o((BEe),tH+(1),((20)*1.))
call L1o((BEe),Lov+(1),((500)*1.))call L1o((BEe),dH+(2),((2)*1.))call L1o((BEe),GH+(2),(($E)*1.))
call L1o((BEe),tH+(2),((30)*1.))
call L1o((BEe),Lov+(2),((550)*1.))call L1o((BEe),dH+(3),((2)*1.))call L1o((BEe),GH+(3),(($E)*1.))
call L1o((BEe),tH+(3),((40)*1.))
call L1o((BEe),Lov+(3),((600)*1.))call L1o((BEe),dH+(4),((2)*1.))call L1o((BEe),GH+(4),(($E)*1.))
call L1o((BEe),tH+(4),((50)*1.))
call L1o((BEe),Lov+(4),((650)*1.))call L1o((BEe),dH+(5),((2)*1.))call L1o((BEe),GH+(5),(($E)*1.))
call L1o((BEe),tH+(5),((60)*1.))
call L1o((BEe),Lov+(5),((700)*1.))call L1o((BEe),dH+(6),((2)*1.))call L1o((BEe),GH+(6),(($E)*1.))
call L1o((BEe),tH+(6),((70)*1.))
call L1o((BEe),Lov+(6),((750)*1.))set MOv[(BEe)]=("ReplaceableTextures\\CommandButtons\\BTNBreathOfFrost.blp")
call cDr(BEe,'FCB0',6,'VCB0','LPCB','LRCB')set BXe[1]=800set BXe[2]=850set BXe[3]=900set BXe[4]=950set BXe[5]=$3E8set BXe[6]=$41Aset BOe[1]=35set BOe[2]=60set BOe[3]=85set BOe[4]='n'set BOe[5]=$87set BOe[6]=$A0return trueendfunctionfunction Ccr takes nothing returns booleanset BRe=u4x()set IC[(BRe)]=("Abilities\\Spells\\Other\\BreathOfFrost\\BreathOfFrost1.wav")set NC[(BRe)]=(M5)set BC[(BRe)]=(l5)set CC[(BRe)]=((1)*1.)set DC[(BRe)]=((1)*1.)set FC[(BRe)]=($A)set GC[(BRe)]=((1)*1.)set HC[(BRe)]=(($A)*1.)set JC[(BRe)]=(($A)*1.)set mC[(BRe)]=(true)
set pC[(BRe)]=((600)*1.)
set qC[(BRe)]=(($186A0)*1.)set sC[(BRe)]=(($7D0)*1.)return trueendfunctionfunction CCr takes nothing returns booleancall VNx(Pa,(function CBr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\ChillyBreath.page\\ChillyBreath.struct\\obj_thisSpell_wc3spell.j"))
call VNx(La,(function Ccr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\ChillyBreath.page\\ChillyBreath.struct\\obj_effectSound_wc3sound.j"))return trueendfunctionfunction Cdr takes nothing returns booleanset BIe=VXx(BAe)
return trueendfunctionfunction CDr takes nothing returns booleanlocal integer Iix=jhx()if LLo(nbe,Iix)thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction Cfr takes real jjx,real jJx returns realreturn byx(jjx-(R2I(((jjx*1./ jJx)*1.)))*jJx)endfunctionfunction CFr takes real Cgr,real p1x returns reallocal real d
local real d2if(p1x==0)thenreturn .0endifset d=Cfr(Cgr,p1x)set d2=byx(p1x)-dif(d2<d)then
return(Cgr+jwx(p1x)*d2)endifreturn(Cgr-jwx(p1x)*d)endfunctionfunction CGr takes integer oSx returns integerset Bqe[oSx]=trueset BQe[oSx]=falsecall rEx(u7)
return oSxendfunctionfunction Chr takes nothing returns integerlocal integer oSxif(Bme==8190)thencall o_x("Tile_Allocation_allocCustom","call DebugEx(Tile.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",U7+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(BMe[(w)]==w)thenset Bpe=Bpe+1set oSx=Bpeelse
set oSx=BMe[(w)]
set BMe[(w)]=BMe[BMe[(w)]]endifset BMe[oSx]=Zset BPe[oSx]=1call CGr(oSx)return oSxendfunctionfunction CHr takes real x,real y returns integer
local integer xI=(R2I(((CFr(x,$80))*1.)))/ $80local integer yI=(R2I(((CFr(y,$80))*1.)))/ $80local integer oSx=(LoadInteger(o[((w7))],(xI),(yI)))
if(oSx==w)thenset oSx=Chr()call SaveInteger(o[((w7))],(xI),(yI),(oSx))set Bse[oSx]=1set BSe[(oSx)]=(xI*$80)set Bte[(oSx)]=(yI*$80)set BTe[(oSx)]=w
else
set Bse[oSx]=Bse[oSx]+1endifreturn oSxendfunctionfunction Cjr takes integer oSx returns nothingset Bqe[oSx]=falsecall rHx(u7)
endfunctionfunction CJr takes integer oSx returns nothingif(BPe[oSx]>0)thenreturnendifif(BMe[oSx]!=Z)thencall o_x("Tile_Allocation_deallocCustom_confirm","call DebugEx(Tile.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",U7+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset BMe[oSx]=BMe[(w)]set BMe[(w)]=oSx
call Cjr(oSx)endfunctionfunction Ckr takes integer oSx returns nothingset BPe[oSx]=BPe[oSx]-1call CJr(oSx)endfunctionfunction CKr takes integer oSx returns nothingif(Bse[oSx]==1)thencall SaveInteger(o[(((w7)))],(((R2I((((BSe[(oSx)]))*1.)))/ $80)),(((R2I((((Bte[(oSx)]))*1.)))/ $80)),(0))call Ckr((oSx))returnendifset Bse[oSx]=Bse[oSx]-1endfunctionfunction Clr takes integer oSx,integer el returns booleanlocal integer RLxlocal integer Rmxif(plx(oSx,el)==false)thenreturn false
endifif((rz[(oSx)])==el)thencall m4x(oSx)return((rz[((oSx))])==w)
endifset RLx=m2x(X,el,iz+oSx)
set Rmx=m2x(X,el,Vz+oSx)
if(Rmx!=w)thencall m3x(X,el,Vz+oSx,w)call m3x(X,Rmx,iz+oSx,RLx)endifif(RLx==w)thenset az[oSx]=Rmxelse
call m3x(X,el,iz+oSx,w)call m3x(X,RLx,Vz+oSx,Rmx)endifreturn((rz[((oSx))])==w)
endfunctionfunction CLr takes integer oSx,integer o5x returns nothingcall SetTerrainType((BSe[((oSx))]),(Bte[((oSx))]),H7[o5x],-1,1,0)endfunctionfunction Cmr takes integer oSx,integer o5x returns nothingif(BTe[oSx]==w)thencall o_x("FolderTile_StructType_Remove","call DebugEx(FolderTile_StructType.NAME + \" tile \" + I2S(this) + \" has not \" + I2S(val))",T7+" tile "+I2S(oSx)+" has not "+I2S(o5x))returnendifcall Clr(BTe[oSx],o5x)if((rz[((BTe[oSx]))])==w)thencall m9x(BTe[oSx])set BTe[oSx]=wcall CLr(oSx,Bwe[oSx])else
set o5x=(az[(BTe[oSx])])
call CLr(oSx,(BWe[(o5x)]))endifendfunctionfunction CMr takes integer oSx returns nothingset Bze[oSx]=falsecall rHx(Y7)
endfunctionfunction Cpr takes integer oSx returns nothingif(Bye[oSx]>0)thenreturnendifif(BYe[oSx]!=Z)thencall o_x("TileTypeMod_Allocation_deallocCustom_confirm","call DebugEx(TileTypeMod.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",z7+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset BYe[oSx]=BYe[(w)]set BYe[(w)]=oSx
call CMr(oSx)endfunctionfunction CPr takes integer oSx returns nothingset Bye[oSx]=Bye[oSx]-1call Cpr(oSx)endfunctionfunction Cqr takes integer oSx returns nothinglocal integer CQr=(BUe[(oSx)])call Cmr(CQr,oSx)call CKr(CQr)call CPr((oSx))endfunctionfunction Csr takes nothing returns nothinglocal integer oSx=(ge[(iGx())])call iKx(Bue[(oSx)])
call Cqr((oSx))endfunctionfunction CSr takes integer oSx,real iMx returns nothinglocal integer iCx=iXx()set Bue[oSx]=iCx
set ge[(iCx)]=(oSx)call iDx(iCx,iMx,false,function Csr)
endfunctionfunction Ctr takes integer oSx returns integerset Bze[oSx]=trueset B0e[oSx]=falsecall rEx(Y7)
return oSxendfunctionfunction CTr takes nothing returns integerlocal integer oSxif(BZe==8190)thencall o_x("TileTypeMod_Allocation_allocCustom","call DebugEx(TileTypeMod.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",z7+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(BYe[(w)]==w)thenset B_e=B_e+1set oSx=B_eelse
set oSx=BYe[(w)]
set BYe[(w)]=BYe[BYe[(w)]]endifset BYe[oSx]=Zset Bye[oSx]=1call Ctr(oSx)return oSxendfunctionfunction Cur takes integer oSx returns integerreturn(LoadInteger(o[((V[(E[((X))])]))],((((GetTerrainType((BSe[((oSx))]),(Bte[((oSx))])))))),(((J7)))))
endfunctionfunction CUr takes integer oSx,integer o5x returns nothingif(BTe[oSx]==w)thenset Bwe[oSx]=Cur(oSx)set BTe[oSx]=M3x()endifcall spo(BTe[oSx],o5x)call CLr(oSx,(BWe[(o5x)]))endfunctionfunction Cwr takes real x,real y,integer o5x returns integer
local integer CQr=CHr(x,y)local integer oSx=CTr()set BUe[(oSx)]=(CQr)
set BWe[(oSx)]=(o5x)
call CUr(CQr,oSx)return oSxendfunctionfunction CWr takes integer oSx,real x,real y returns nothing
local integer o5x=CHr(x,y)if plx(BHe[oSx],o5x)then
call CKr(o5x)returnendifcall spo(BHe[oSx],o5x)call CSr(Cwr(x,y,c7),4.)
endfunctionfunction Cyr takes integer rYx,integer Iix returns nothingcall Nbx((Iix),(Bae),(rYx),w,((Bie[rYx])*1.))endfunctionfunction CYr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local real bex=BBe[oSx]local integer Cqx=Bce[oSx]local integer HAx=Bde[oSx]local real Czr=Bfe[oSx]local real rPr=BGe[oSx]local real CZr=BDe[oSx]local integer svo=Bhe[oSx]local real oyx=CZr+Czrlocal real x=(iJ[(HAx)])+BJe[oSx]local real y=(EJ[(HAx)])+Bke[oSx]local real jqx=Ble+(BLe-Ble)*(CZr*1./ rPr)local real jPx=Ble+(BLe-Ble)*(oyx*1./ rPr)local integer Iixlocal real Nbolocal integer rYxcall CWr(oSx,x,y)call CWr(oSx,(mHv[(B1e[oSx])]),(mjv[(B1e[oSx])]))call CWr(oSx,(mHv[(B2e[oSx])]),(mjv[(B2e[oSx])]))set BDe[oSx]=oyx
call Q1o(HAx,x,y)set hf=(ze[(Cqx)])set nbe=svocall Nqr(BNe,x,y,Czr,bex,jPx,jqx,Bbe)set Iix=NEo(BNe)
if(Iix!=w)thenset Nbo=BCe[oSx]*(1+oyx*1./ rPr*B3e)
set rYx=Bge[oSx]
loop
call GroupAddUnit(kb[(svo)],C[(Iix)])call Cyr(rYx,Iix)call nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))set Iix=NEo(BNe)
exitwhen(Iix==w)
endloopendifendfunctionfunction C_r takes nothing returns booleanlocal integer rFx=(bv)return trueendfunctionfunction C0r takes integer oSx,integer o0x,real oyx,real Nlx,real bex,real C1r returns nothinglocal real jMx=(GetUnitX(C[((o0x))]))local real jpx=(GetUnitY(C[((o0x))]))local integer Mho=Moo()local real dVxlocal real dExlocal integer HAxset B2e[oSx]=Mho
set bex=bex-Bev*1./ 3set dVx=jMx+oyx*(Cos(((((bex)*1.))*1.)))
set dEx=jpx+oyx*(Sin(((((bex)*1.))*1.)))
set mCv[(Mho)]=((10.)*1.)call Mno(Mho,'qChB',.4)set mFv[(Mho)]=Xkx((function C_r))call Meo(Mho,Nlx)call pxo(Mho,o0x)set HAx=(bz[(Mho)])call SetUnitTimeScale(vJ[(HAx)],((C1r)*1.))call o9r(Mho,dVx,dEx,X_x(dVx,dEx))set bex=bex+2*Bev*1./ 3set Mho=Moo()set dVx=jMx+oyx*(Cos(((((bex)*1.))*1.)))
set dEx=jpx+oyx*(Sin(((((bex)*1.))*1.)))
set B1e[oSx]=Mho
set mCv[(Mho)]=((10.)*1.)call SetUnitTimeScale(vJ[(Mno(Mho,'qChB',.4))],((C1r)*1.))set mFv[(Mho)]=Xkx((function C_r))call Meo(Mho,Nlx)call pxo(Mho,o0x)set HAx=(bz[(Mho)])call SetUnitTimeScale(vJ[(HAx)],((C1r)*1.))call o9r(Mho,dVx,dEx,X_x(dVx,dEx))endfunctionfunction C2r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real dX=dVx-wQolocal real dY=dEx-wsolocal real C1r=.35*1./(CQx((BEe),dH+(rYx)))local real bex=Ufx(Cqx,dX,dY)local integer oSx=Cqxlocal integer HAx=mDx('qChB',wQo,wso,OMx(Cqx,wQo,wso)+Opx(Cqx,true),bex)
local integer Cir=AJx(BRe)local integer Q9o=iXx()call o_x("ChillyBreath_Event_SpellEffect","call DebugEx(\"create \"+I2S(this)+\";\"+I2S(updateTimer))","create "+I2S(oSx)+";"+I2S(Q9o))set BBe[oSx]=bex
set Bce[oSx]=Cqx
set BCe[oSx]=BOe[rYx]set Bde[oSx]=HAx
set BDe[oSx]=.0set Bfe[oSx]=BFe[rYx]set Bge[oSx]=rYx
set BGe[oSx]=BXe[rYx]set Bhe[oSx]=O5x()set BHe[oSx]=M3x()set Bje[oSx]=Q9o
set BJe[oSx]=(Cos(((((bex)*1.))*1.)))*BFe[rYx]set Bke[oSx]=(Sin(((((bex)*1.))*1.)))*BFe[rYx]set ge[(Q9o)]=(oSx)call k5o(HAx,.75)call SetUnitTimeScale(vJ[(HAx)],((C1r)*1.))call P8o(Cir,wQo,wso,X_x(wQo,wso))call R4x(Cir,true)call iDx(Q9o,BKe,true,function CYr)call C0r(oSx,Cqx,BXe[rYx],B4e[rYx],bex,C1r)call n1r(Cqx)return trueendfunctionfunction C3r takes integer oSx returns nothinglocal integer HAx=Bde[oSx]local integer svo=Bhe[oSx]local integer Q9o=Bje[oSx]call o_x("ChillyBreath_Ending","call DebugEx(\"destroy \"+I2S(this)+\";\"+I2S(updateTimer))","destroy "+I2S(oSx)+";"+I2S(Q9o))call SetUnitTimeScale(vJ[(HAx)],((1.)*1.))call MGx(HAx)call O9x(svo)call m9x(BHe[oSx])call iKx(Q9o)call SetUnitTimeScale(vJ[((bz[(B1e[oSx])]))],((1.)*1.))call MFo(B1e[oSx])call SetUnitTimeScale(vJ[((bz[(B2e[oSx])]))],((1.)*1.))call MFo(B2e[oSx])endfunctionfunction C4r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local boolean ELo=(oav[(rFx)])local integer oSx=Cqxcall C3r(oSx)if ELo thencall DXx((Cqx),(Gav))endifreturn trueendfunctionfunction C5r takes nothing returns nothingcall W2x(nVv,Bae)call W2x(ECv,Bae)endfunctionfunction C6r takes nothing returns booleanlocal integer oMxset BNe=O5x()set Bbe=Xpx(function CDr)call mro(BEe,Xdx("ChillyBreath_Init: call ChillyBreath.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ChillyBreath.Event_SpellEffect))",ih,MI,function C2r))call mro(BEe,Xdx("ChillyBreath_Init: call ChillyBreath.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ChillyBreath.Event_EndCast))",onv,MI,function C4r))set oMx=(m6[(BEe)])loop
set B4e[oMx]=BXe[oMx]*1./(CQx((BEe),dH+(oMx)))set BFe[oMx]=B4e[oMx]*BKeset oMx=oMx-1exitwhen(oMx<1)endloopcall C5r()return trueendfunctionfunction C7r takes nothing returns booleancall cPr(function C6r,"ChillyBreath_Init")return trueendfunctionfunction C8r takes nothing returns booleanset B5e=VXx(B6e)
return trueendfunctionfunction C9r takes code c,string rSx returns nothing
set Yn=Yn+1set zn[Yn]=CreateTrigger()set Zn[Yn]=(GetHandleId(Condition((c))))
set vV[Yn]=rSxcall TriggerAddCondition(zn[Yn],Condition(c))endfunctionfunction dvr takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=Lnx((Bbv[(rFx)]),B8e)local integer OSx=(Vv[(rFx)])call OCo(B9e[oSx],OSx)call r0x(((OSx)),((B9e[oSx])),(1))return trueendfunctionfunction der takes integer oSx returns integerset cie[oSx]=trueset cae[oSx]=falsecall rEx(B5e)return oSxendfunctionfunction dxr takes nothing returns integerlocal integer oSxif(cee==8190)thencall o_x("ElementalSpellToHero_Allocation_allocCustom","call DebugEx(ElementalSpellToHero.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",B6e+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(cxe[(w)]==w)thenset coe=coe+1set oSx=coeelse
set oSx=cxe[(w)]
set cxe[(w)]=cxe[cxe[(w)]]endifset cxe[oSx]=Zset cre[oSx]=1call der(oSx)return oSxendfunctionfunction dor takes nothing returns booleanlocal integer rFx=(bv)local integer OSx=ROx()local integer oSx=Lnx((Tf[(OSx)]),B8e)call OCo(B9e[oSx],OSx)call r0x(((OSx)),((B9e[oSx])),(1))return trueendfunctionfunction drr takes integer lCo,integer rlx returns integerlocal integer oSx=dxr()set B9e[oSx]=rlx
call hMo(lCo,B8e,oSx)call teo(lCo,B7e)call kTo(lCo,function dor)return oSxendfunctionfunction dir takes nothing returns booleanset B7e=Xdx("ElementalSpellToHero_Init: set ElementalSpellToHero.CREATE_EVENT = Event.Create(Unit.CREATE_EVENT_TYPE, EventPriority.MISC, function ElementalSpellToHero.Event_Create)",IJv,lI,function dvr)set cve=O5x()call drr(Gwv,cne)call drr(Grv,BEe)call drr(GHv,cVe)call drr(gpv,cEe)call drr(g4v,SGv)call drr(hNv,cXe)call drr(GCv,cOe)call drr(G4v,Gmv)call drr(gYv,cRe)return trueendfunctionfunction dar takes nothing returns booleancall C9r(function dir,"ElementalSpellToHero_Init")return trueendfunctionfunction dnr takes nothing returns booleanset cIe=ltx(cAe+" (ignitionBuff)")return trueendfunctionfunction dVr takes nothing returns booleanset cNe[1]=4
set cNe[2]=4
set cNe[3]=5
set cNe[4]=5
set cNe[5]=6
set cNe[6]=6
set cbe[1]=$Aset cbe[2]=$Fset cbe[3]=20set cbe[4]=25set cbe[5]=30set cbe[6]=35return trueendfunctionfunction dEr takes nothing returns booleancall VNx(ma,(function dnr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Fireburst.page\\Fireburst.struct\\Shot\\obj_ignitionBuff_wc3buff.j"))call VNx(va,(function dVr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Fireburst.page\\Fireburst.struct\\Shot\\obj_this_wc3obj.j"))return trueendfunctionfunction dXr takes nothing returns booleanset cBe=VXx(cAe)
return trueendfunctionfunction dOr takes nothing returns booleancall L1x('AFiB',false)set SGv=L0o('AFiB')set K6[(SGv)]=(F6)set m6[(SGv)]=(6)set TH[(SGv)]=("Fireburst")set Rh[(SGv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0107)))),(((Aj))))))set oxv[(SGv)]=(4)set x3v[(SGv)]=("spell")
call L1o((SGv),Uvv+(1),(($96)*1.))call L1o((SGv),GH+(1),((6)*1.))call L1o((SGv),tH+(1),((45)*1.))
call L1o((SGv),Lov+(1),((700)*1.))call L1o((SGv),Uvv+(2),(($AF)*1.))call L1o((SGv),GH+(2),((6)*1.))call L1o((SGv),tH+(2),((65)*1.))
call L1o((SGv),Lov+(2),((700)*1.))call L1o((SGv),Uvv+(3),(($C8)*1.))call L1o((SGv),GH+(3),((6)*1.))call L1o((SGv),tH+(3),((90)*1.))
call L1o((SGv),Lov+(3),((700)*1.))call L1o((SGv),Uvv+(4),(($E1)*1.))call L1o((SGv),GH+(4),((6)*1.))call L1o((SGv),tH+(4),(('x')*1.))call L1o((SGv),Lov+(4),((700)*1.))call L1o((SGv),Uvv+(5),(($FA)*1.))call L1o((SGv),GH+(5),((6)*1.))call L1o((SGv),tH+(5),(($9B)*1.))call L1o((SGv),Lov+(5),((700)*1.))call L1o((SGv),Uvv+(6),((275)*1.))call L1o((SGv),GH+(6),((6)*1.))call L1o((SGv),tH+(6),(($C3)*1.))call L1o((SGv),Lov+(6),((700)*1.))set MOv[(SGv)]=("ReplaceableTextures\\CommandButtons\\BTNFireForTheCannon.blp")call cDr(SGv,'FFB0',6,'VFB0','LPFB','LRFB')set cce[1]=3
set cce[2]=3
set cce[3]=4
set cce[4]=4
set cce[5]=5
set cce[6]=5
return trueendfunctionfunction dRr takes nothing returns booleanset cCe=ltx(cde+" (dummyBuff)")set Pc[(cCe)]=(true)
return trueendfunctionfunction dIr takes nothing returns booleancall VNx(Pa,(function dOr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Fireburst.page\\Fireburst.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function dRr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Fireburst.page\\Fireburst.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction dAr takes nothing returns booleanset cDe=VXx(cde)
return trueendfunctionfunction dNr takes integer oSx returns integerset che[oSx]=trueset cHe[oSx]=falsecall rEx(cDe)return oSxendfunctionfunction dbr takes nothing returns integerlocal integer oSxif(cfe==8190)thencall o_x("Fireburst_Allocation_allocCustom","call DebugEx(Fireburst.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",cde+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(cFe[(w)]==w)thenset cge=cge+1set oSx=cgeelse
set oSx=cFe[(w)]
set cFe[(w)]=cFe[cFe[(w)]]endifset cFe[oSx]=Zset cGe[oSx]=1call dNr(oSx)return oSxendfunctionfunction dBr takes integer oSx returns integerset cye[oSx]=trueset cYe[oSx]=falsecall rEx(cBe)return oSxendfunctionfunction dcr takes nothing returns integerlocal integer oSxif(cue==8190)thencall o_x("FolderFireburst_StructShot_Allocation_allocCustom","call DebugEx(FolderFireburst_StructShot.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",cAe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(cUe[(w)]==w)thenset cwe=cwe+1set oSx=cweelse
set oSx=cUe[(w)]
set cUe[(w)]=cUe[cUe[(w)]]endifset cUe[oSx]=Zset cWe[oSx]=1call dBr(oSx)return oSxendfunctionfunction dCr takes integer oSx returns nothingset cLe[oSx]=cLe[oSx]+1endfunctionfunction ddr takes real x1,real y1,real x2,real y2,real n2x returns real
local real m=(y2-y1)*1./(x2-x1)local real n=y1-m*x1
return(m*n2x+n)endfunctionfunction dDr takes integer oSx returns nothingset che[oSx]=falsecall rHx(cDe)endfunctionfunction dfr takes integer oSx returns nothingif(cGe[oSx]>0)thenreturnendifif(cFe[oSx]!=Z)thencall o_x("Fireburst_Allocation_deallocCustom_confirm","call DebugEx(Fireburst.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",cde+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset cFe[oSx]=cFe[(w)]set cFe[(w)]=oSx
call dDr(oSx)endfunctionfunction dFr takes integer oSx returns nothingset cGe[oSx]=cGe[oSx]-1call dfr(oSx)endfunctionfunction dgr takes integer oSx returns nothingif not cJe[oSx]thenreturnendifif(cLe[oSx]>0)thenreturnendifcall dFr((oSx))endfunctionfunction dGr takes integer oSx returns nothingset cLe[oSx]=cLe[oSx]-1call dgr(oSx)endfunctionfunction dhr takes integer oSx returns nothingset cye[oSx]=falsecall rHx(cBe)endfunctionfunction dHr takes integer oSx returns nothingif(cWe[oSx]>0)thenreturnendifif(cUe[oSx]!=Z)thencall o_x("FolderFireburst_StructShot_Allocation_deallocCustom_confirm","call DebugEx(FolderFireburst_StructShot.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",cAe+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset cUe[oSx]=cUe[(w)]set cUe[(w)]=oSx
call dhr(oSx)endfunctionfunction djr takes integer oSx returns nothingset cWe[oSx]=cWe[oSx]-1call dHr(oSx)endfunctionfunction dJr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer rLx=cze[oSx]local integer Cqx=cje[rLx]local integer rYx=cle[rLx]local integer Iix=cMe[rLx]local real dVx=(mHv[(Mho)])local real dEx=(mjv[(Mho)])call MFo(Mho)call Nbx(Iix,cIe,rYx,Cqx,cNe[rYx])call nlo((Cqx),(Iix),((c4e[oSx])*1.),(true),(false))
call dGr(rLx)call djr((oSx))return trueendfunctionfunction dkr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=(mZv[(Mho)])local integer rLx=cze[oSx]local integer Cqx=cje[rLx]local integer rYx=cle[rLx]local real dVx=(mHv[(Mho)])local real dEx=(mjv[(Mho)])local real wQolocal real wsolocal real dKrlocal real Nbolocal real d
local real dlrcall MFo(Mho)call mho((mko(((dVx)*1.),((dEx)*1.),("Objects\\Spawnmodels\\Other\\NeutralBuildingExplosion\\NeutralBuildingExplosion.mdl"),(Bi))))if(Iix!=w)thencall Nbx(Iix,cIe,rYx,Cqx,cNe[rYx])endifset hf=(ze[(Cqx)])call NVo(cZe,dVx,dEx,(CQx((SGv),Uvv+(rYx))),c_e)
set Iix=NEo(cZe)
if(Iix!=w)thenset wQo=cPe[rLx]
set wso=cqe[rLx]
set dKr=dox(Cqx,true)set Nbo=cbe[rYx]
loop
set d=jKx((GetUnitX(C[((Iix))]))-wQo,(GetUnitY(C[((Iix))]))-wso)
set dlr=ddr(dKr,c0e,(CQx((SGv),Lov+(rYx))),c1e,d)set dlr=blx(dlr,c0e,c1e)
call GroupAddUnit(kb[(c2e)],C[(Iix)])call nlo((Cqx),(Iix),((Nbo*dlr)*1.),(true),(false))set Iix=NEo(cZe)
exitwhen(Iix==w)
endloopendifset hf=(ze[(Cqx)])call NVo(cZe,dVx,dEx,(CQx((SGv),Lov+(rYx))),c_e)
call GroupRemoveUnit(kb[(cZe)],C[(cMe[rLx])])loop
set Iix=NEo(c2e)
exitwhen(Iix==w)
call GroupRemoveUnit(kb[(cZe)],C[(Iix)])
endloopset Iix=(Wko((cZe),((dVx)*1.),((dEx)*1.)))if((Iix==w)or not(osx((((Cqx))),(Wb+(c3e)))>0))thencall dGr(rLx)call djr((oSx))return trueendifset c4e[oSx]=cbe[rYx]*c5e[(osx(((Cqx)),Yb+(c3e)))]set Mho=Moo()set mcv[((Mho))]=((Bev*((.06)*1.))*1.)set mCv[(Mho)]=((10.)*1.)set mFv[(Mho)]=Xkx((function dJr))set mZv[(Mho)]=(oSx)
call Meo(Mho,900.)call pxo(Mho,Cqx)call M6o((Mho),(Iix),.0,.0,.0,(null))call Mno(Mho,'qFiE',.75)
return trueendfunctionfunction dLr takes integer rLx returns nothinglocal integer Cqx=cje[rLx]local integer HAx=cke[rLx]local integer Iix=cMe[rLx]local integer Mho=Moo()local integer oSx=dcr()local real jMxlocal real jpxlocal real bexset cze[oSx]=rLx
call dCr(rLx)set jMx=(iJ[(HAx)])set jpx=(EJ[(HAx)])set bex=(Atan2((((GetUnitY(C[((Iix))]))-jpx)*1.),(((GetUnitX(C[((Iix))]))-jMx)*1.)))
call mNx(HAx,bex)set mcv[((Mho))]=((Bev*((.2)*1.))*1.)set mCv[(Mho)]=((10.)*1.)set mFv[(Mho)]=Xkx((function dkr))set mZv[(Mho)]=(oSx)
call Meo(Mho,1000.)call M6o((Mho),(Iix),.0,.0,.0,(null))call Mno(Mho,'qFiS',1.)call rtr(Mho,function dkr,c6e)call MUo(Mho,jMx+c7e*(Cos(((((bex)*1.))*1.))),jpx+c7e*(Sin(((((bex)*1.))*1.))),(Au[(HAx)]))endfunctionfunction dmr takes integer oSx returns nothinglocal integer HAx=cke[oSx]local integer p3x=cKe[oSx]local integer Ctx=cpe[oSx]call MGx(HAx)call iKx(p3x)if rnx(cje[oSx],cte,oSx)then
call AZx(cje[oSx],cCe)endifset cJe[oSx]=truecall dgr(oSx)endfunctionfunction dMr takes integer oSx returns nothingcall dLr(oSx)if(cme[oSx]==1)thencall dmr(oSx)else
set cme[oSx]=cme[oSx]-1endifendfunctionfunction dpr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])call dMr(oSx)endfunctionfunction dPr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])call iDx(cKe[oSx],cTe,true,function dpr)
call dMr(oSx)endfunctionfunction dqr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local integer Ctx=(WH[(rFx)])local real x=(GetUnitX(C[((Cqx))]))local real y=(GetUnitY(C[((Cqx))]))local real z=fYx(Cqx)+Opx(Cqx,true)*3local integer oSx=dbr()local integer HAx=mDx('qFiB',x,y,z,(VH[(Ctx)]))local integer p3x=iXx()set cje[oSx]=Cqx
set cJe[oSx]=falseset cke[oSx]=HAx
set cKe[oSx]=p3x
set cle[oSx]=rYx
set cLe[oSx]=0set cme[oSx]=cce[rYx]set cMe[oSx]=Iix
set cpe[oSx]=Ctx
set cPe[oSx]=xset cqe[oSx]=yset ge[(p3x)]=(oSx)call HIx((sEo((HAx),(cQe),(cse),(Bi))))call SetUnitAnimation(vJ[((HAx))],("spell"))
call SetUnitColor(vJ[((HAx))],((xx[(Cqx)])))
call mdx(HAx,0,0,0,0)call QYo(HAx,$FF,$FF,$FF,$FF,cSe)if rUx(Cqx,cte,oSx)thencall Dux((Cqx),(cCe),(rYx),w)endifcall iDx(p3x,cSe,false,function dPr)
return trueendfunctionfunction dQr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])return trueendfunctionfunction dsr takes integer Cqx returns nothinglocal integer oMx=CIx(Cqx,cte)local integer oSxloop
exitwhen(oMx<q)set oSx=CAx(Cqx,cte,oMx)
call dmr(oSx)endloopendfunctionfunction dSr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])call dsr(Cqx)return trueendfunctionfunction dtr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer Iix=jhx()local integer oSx=(mZv[(Mho)])local integer rLx=cze[oSx]if I9x(Iix,Qc)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[((ze[(cje[rLx])]))]))thenreturn false
endifreturn trueendfunctionfunction dTr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif nbo(Iix)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction dUr takes nothing returns nothingset c6e=Xpx(function dtr)set cZe=O5x()set c2e=O5x()set c_e=Xpx(function dTr)call W2x(Xev,cIe)endfunctionfunction dwr takes nothing returns booleancall mro(SGv,Xdx("Fireburst_Init: call Fireburst.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Fireburst.Event_SpellEffect))",ih,MI,function dqr))
call Lxx(cCe,Xdx("Fireburst_Init: call Fireburst.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Fireburst.Event_BuffGain))",bd,MI,function dQr))call Lxx(cCe,Xdx("Fireburst_Init: call Fireburst.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Fireburst.Event_BuffLose))",jc,MI,function dSr))call dUr()return trueendfunctionfunction dWr takes nothing returns booleancall cPr(function dwr,"Fireburst_Init")return trueendfunctionfunction dyr takes nothing returns booleancall L1x('AFlT',false)set c8e=L0o('AFlT')set K6[(c8e)]=(F6)set m6[(c8e)]=(6)set TH[(c8e)]=("Flame Tongue")set Rh[(c8e)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D02AC)))),(((Aj))))))set oxv[(c8e)]=(2)set x3v[(c8e)]=("spell")
call L1o((c8e),Uvv+(1),(($C8)*1.))call L1o((c8e),GH+(1),(($A)*1.))
call L1o((c8e),tH+(1),((30)*1.))
call L1o((c8e),Lov+(1),((700)*1.))call L1o((c8e),Uvv+(2),(($C8)*1.))call L1o((c8e),GH+(2),(($A)*1.))
call L1o((c8e),tH+(2),((45)*1.))
call L1o((c8e),Lov+(2),((700)*1.))call L1o((c8e),Uvv+(3),(($C8)*1.))call L1o((c8e),GH+(3),(($A)*1.))
call L1o((c8e),tH+(3),((55)*1.))
call L1o((c8e),Lov+(3),((700)*1.))call L1o((c8e),Uvv+(4),(($C8)*1.))call L1o((c8e),GH+(4),(($A)*1.))
call L1o((c8e),tH+(4),((70)*1.))
call L1o((c8e),Lov+(4),((700)*1.))call L1o((c8e),Uvv+(5),(($C8)*1.))call L1o((c8e),GH+(5),(($A)*1.))
call L1o((c8e),tH+(5),((90)*1.))
call L1o((c8e),Lov+(5),((700)*1.))call L1o((c8e),Uvv+(6),(($C8)*1.))call L1o((c8e),GH+(6),(($A)*1.))
call L1o((c8e),tH+(6),(('s')*1.))call L1o((c8e),Lov+(6),((700)*1.))set MOv[(c8e)]=("ReplaceableTextures\\CommandButtons\\BTNMarkOfFire.blp")set c9e[1]=500set c9e[2]=900set c9e[3]=$5DCset c9e[4]=$898set c9e[5]=$BB8set c9e[6]=$F3Cset Cve[1]=.5set Cve[2]=.6set Cve[3]=.7set Cve[4]=.8set Cve[5]=.9set Cve[6]=1
set Cee[1]=600set Cee[2]=600set Cee[3]=600set Cee[4]=600set Cee[5]=600set Cee[6]=600set Cxe[1]=500set Cxe[2]=500set Cxe[3]=500set Cxe[4]=500set Cxe[5]=500set Cxe[6]=500set Coe[1]=700set Coe[2]=700set Coe[3]=700set Coe[4]=700set Coe[5]=700set Coe[6]=700set Cre[1]=.5set Cre[2]=.5set Cre[3]=.5set Cre[4]=.5set Cre[5]=.5set Cre[6]=.5set Cie[1]=35set Cie[2]=50set Cie[3]=65set Cie[4]=80set Cie[5]=95set Cie[6]='n'return trueendfunctionfunction dYr takes nothing returns booleancall VNx(Pa,(function dyr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\FlameTongue.page\\FlameTongue.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction dzr takes nothing returns booleanset Cae=VXx(Cne)
return trueendfunctionfunction dZr takes nothing returns booleanlocal integer Iix=jhx()if(I8x((Ose),Ob,(Iix)))thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction d_r takes integer oSx returns integerset CAe[oSx]=trueset CNe[oSx]=falsecall rEx(Cae)return oSxendfunctionfunction d0r takes nothing returns integerlocal integer oSxif(CXe==8190)thencall o_x("FlameTongue_Allocation_allocCustom","call DebugEx(FlameTongue.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Cne+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(COe[(w)]==w)thenset CRe=CRe+1set oSx=CReelse
set oSx=COe[(w)]
set COe[(w)]=COe[COe[(w)]]endifset COe[oSx]=Zset CIe[oSx]=1call d_r(oSx)return oSxendfunctionfunction d1r takes integer oSx,real O4o,integer Cqx,integer C3o,real Nbo,integer d2r,real d3r,real d4r,integer svo,real x,real y,integer Ctx returns nothing
local integer Iixlocal real d5rlocal real VLrset x=x+d2r*d3rset y=y+d2r*d4rcall mho((mko(((x)*1.),((y)*1.),(CSe),(ri))))call mho((mko(((x)*1.),((y)*1.),(Cte),(Bi))))set Ose=svoset hf=C3ocall NVo(CVe,x,y,O4o,CEe)set Iix=NEo(CVe)
if(Iix!=w)thenset d5r=CDe[oSx]
set VLr=CLe[oSx]
loop
set Nbo=iUx(Nbo,VLr)
call dQx(svo,Iix)set VLr=VLr-Nboif(Xiv[(Iix)])thenset Nbo=Nbo*d5rendifcall nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))set Iix=NEo(CVe)
exitwhen(Iix==w)
endloopset CLe[oSx]=VLr
endifendfunctionfunction d6r takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local real bex=Cbe[oSx]local real O4o=CBe[oSx]local integer Cqx=Cce[oSx]local real Nbo=CCe[oSx]local real oyx=CJe[oSx]+Cke[oSx]
local integer svo=Cme[oSx]local real x=CMe[oSx]+Cpe[oSx]local real y=CPe[oSx]+Cqe[oSx]local integer Ctx=CQe[oSx]local integer C3o=(ze[(Cqx)])local real d7r=oyx*(Cfe[oSx]*oyx+Che[oSx])local real d3r=d7r*Cge[oSx]local real d4r=d7r*CGe[oSx]set CJe[oSx]=oyx
set CMe[oSx]=xset CPe[oSx]=ycall d1r(oSx,O4o,Cqx,C3o,Nbo,-1,d3r,d4r,svo,x,y,Ctx)
call d1r(oSx,O4o,Cqx,C3o,Nbo,1,d3r,d4r,svo,x,y,Ctx)endfunctionfunction d8r takes integer oSx returns nothingset CAe[oSx]=falsecall rHx(Cae)endfunctionfunction d9r takes integer oSx returns nothingif(CIe[oSx]>0)thenreturnendifif(COe[oSx]!=Z)thencall o_x("FlameTongue_Allocation_deallocCustom_confirm","call DebugEx(FlameTongue.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Cne+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset COe[oSx]=COe[(w)]set COe[(w)]=oSx
call d8r(oSx)endfunctionfunction Dvr takes integer oSx returns nothingset CIe[oSx]=CIe[oSx]-1call d9r(oSx)endfunctionfunction Der takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local integer p3x=Cje[oSx]local integer svo=Cme[oSx]local integer Ctx=CQe[oSx]call Dvr((oSx))call iKx(iCx)call iKx(p3x)call X_r(svo)call dNx(Ctx)endfunctionfunction Dxr takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])set Cke[oSx]=-Cke[oSx]set Cpe[oSx]=-Cpe[oSx]set Cqe[oSx]=-Cqe[oSx]call dWx((Cme[oSx]),Ob)call iDx(Cje[oSx],Cse,true,function d6r)
call iDx(iCx,CTe[Cle[oSx]],false,function Der)endfunctionfunction Dor takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])call ikx(Cje[oSx])call iDx(iCx,.15,false,function Dxr)
endfunctionfunction Drr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real dX=dVx-wQolocal real dY=dEx-wsolocal real bex=Ufx(Cqx,dX,dY)local real d=jKx(dX,dY)local real Dir=bex-Bevlocal integer oSx=d0r()local integer iCx=iXx()local integer p3x=iXx()local integer Ctx=CPx(Cqx,c8e)set Cbe[oSx]=bex
set CBe[oSx]=(CQx((c8e),Uvv+(rYx)))set Cce[oSx]=Cqx
set CCe[oSx]=Cie[rYx]+(Lg[(Cqx)])*Cdeset CDe[oSx]=(1.+Cve[rYx])set Cfe[oSx]=CFe[rYx]set Cge[oSx]=(Cos(((((Dir)*1.))*1.)))set CGe[oSx]=(Sin(((((Dir)*1.))*1.)))set Che[oSx]=CHe[rYx]set Cje[oSx]=p3x
set CJe[oSx]=.0set Cke[oSx]=CKe[rYx]set Cle[oSx]=rYx
set CLe[oSx]=c9e[rYx]set Cme[oSx]=Jbx("FlameTongue_Event_SpellEffect: set this.targetGroup = UnitList.Create()")set CMe[oSx]=dVx
set Cpe[oSx]=CKe[rYx]*(Cos(((((bex)*1.))*1.)))set CPe[oSx]=dEx
set Cqe[oSx]=CKe[rYx]*(Sin(((((bex)*1.))*1.)))set CQe[oSx]=Ctx
set ge[(iCx)]=(oSx)set ge[(p3x)]=(oSx)call iDx(p3x,Cse,true,function d6r)call iDx(iCx,CTe[rYx],false,function Dor)return trueendfunctionfunction Dar takes nothing returns booleanlocal integer oMxset CVe=O5x()set CEe=Xpx(function dZr)call mro(c8e,Xdx("FlameTongue_Init: call FlameTongue.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FlameTongue.Event_SpellEffect))",ih,MI,function Drr))set oMx=(m6[(c8e)])loop
set CTe[oMx]=(R2I((((Cee[oMx]*1./ Coe[oMx])*1./ Cse)*1.)))*Cseset Cue[oMx]=Cre[oMx]*Cee[oMx]set CKe[oMx]=Coe[oMx]*Cseset CFe[oMx]=Cxe[oMx]*1./ Cue[oMx]*1./(Cue[oMx]+Cee[oMx])set CHe[oMx]=-CFe[oMx]*Cee[oMx]set oMx=oMx-1exitwhen(oMx<1)endloopreturn trueendfunctionfunction Dnr takes nothing returns booleancall cPr(function Dar,"FlameTongue_Init")return trueendfunctionfunction DVr takes nothing returns booleanset CUe[1]=-90set CUe[2]=-90set CUe[3]=-90set CUe[4]=-90set CUe[5]=-90set CUe[6]=-90set Cwe[1]=5
set Cwe[2]=8
set Cwe[3]=$Bset Cwe[4]=$Eset Cwe[5]=17set Cwe[6]=20return trueendfunctionfunction DEr takes nothing returns booleanset CWe=Wwx('BFrS',"Frozen Star",'bFrS')
set Pc[(CWe)]=(true)
set anv[(CWe)]=("ReplaceableTextures\\CommandButtons\\BTNBreathOfFrost.blp")
set WU=l_x()
call l2x(WU,dmv,-90)
call l3x(((CWe)),ZB+(1),(WU))return trueendfunctionfunction DXr takes nothing returns booleancall VNx(va,(function DVr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\FrozenStar.page\\FrozenStar.struct\\Target\\obj_this_wc3obj.j"))call VNx(ma,(function DEr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\FrozenStar.page\\FrozenStar.struct\\Target\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction DOr takes nothing returns booleanset Cye=VXx(CYe)
return trueendfunctionfunction DRr takes nothing returns booleanset Cze[1]=30set Cze[2]=40set Cze[3]=60set Cze[4]=70set Cze[5]=80set Cze[6]=90return trueendfunctionfunction DIr takes nothing returns booleancall VNx(va,(function DRr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\FrozenStar.page\\FrozenStar.struct\\Explosion\\obj_this_wc3obj.j"))
return trueendfunctionfunction DAr takes nothing returns booleanset CZe=VXx(C_e)
return trueendfunctionfunction DNr takes nothing returns booleancall L1x('AFrS',false)set C0e=L0o('AFrS')set K6[(C0e)]=(F6)set m6[(C0e)]=(6)set TH[(C0e)]=("Frozen Star")set Rh[(C0e)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00FA)))),(((Aj))))))set oxv[(C0e)]=(2)set x3v[(C0e)]=("spell")
call L1o((C0e),Uvv+(1),((400)*1.))call L1o((C0e),GH+(1),((9)*1.))call L1o((C0e),tH+(1),((55)*1.))
call L1o((C0e),Lov+(1),((700)*1.))call L1o((C0e),Uvv+(2),((500)*1.))call L1o((C0e),GH+(2),((9)*1.))call L1o((C0e),tH+(2),((75)*1.))
call L1o((C0e),Lov+(2),((700)*1.))call L1o((C0e),Uvv+(3),((600)*1.))call L1o((C0e),GH+(3),((9)*1.))call L1o((C0e),tH+(3),((95)*1.))
call L1o((C0e),Lov+(3),((700)*1.))call L1o((C0e),Uvv+(4),((700)*1.))call L1o((C0e),GH+(4),((9)*1.))call L1o((C0e),tH+(4),(('s')*1.))call L1o((C0e),Lov+(4),((700)*1.))call L1o((C0e),Uvv+(5),((800)*1.))call L1o((C0e),GH+(5),((9)*1.))call L1o((C0e),tH+(5),(($87)*1.))call L1o((C0e),Lov+(5),((700)*1.))call L1o((C0e),Uvv+(6),((900)*1.))call L1o((C0e),GH+(6),((9)*1.))call L1o((C0e),tH+(6),(($9B)*1.))call L1o((C0e),Lov+(6),((700)*1.))set MOv[(C0e)]=("ReplaceableTextures\\CommandButtons\\BTNStaffOfNegation.blp")set C1e[1]=700set C1e[2]=700set C1e[3]=700set C1e[4]=700set C1e[5]=700set C1e[6]=700set C2e[1]=$C8set C2e[2]=$C8set C2e[3]=$C8set C2e[4]=$C8set C2e[5]=$C8set C2e[6]=$C8set C3e[1]=600set C3e[2]=600set C3e[3]=600set C3e[4]=600set C3e[5]=600set C3e[6]=600return trueendfunctionfunction Dbr takes nothing returns booleancall VNx(Pa,(function DNr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\FrozenStar.page\\FrozenStar.struct\\obj_thisSpell_wc3spell.j"))
return trueendfunctionfunction DBr takes nothing returns booleanset C4e=VXx(C5e)
return trueendfunctionfunction Dcr takes nothing returns booleanlocal integer Iix=jhx()if(I8x((Ose),Ob,(Iix)))thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction DCr takes real a,real b returns boolean
set a=jHx(a,Cf)set b=jHx(b,Cf)if(a<b)thenreturn false
endifreturn trueendfunctionfunction Ddr takes integer oSx returns integerset die[oSx]=trueset dae[oSx]=falsecall rEx(C4e)return oSxendfunctionfunction DDr takes nothing returns integerlocal integer oSxif(dee==8190)thencall o_x("FrozenStar_Allocation_allocCustom","call DebugEx(FrozenStar.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",C5e+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(dxe[(w)]==w)thenset doe=doe+1set oSx=doeelse
set oSx=dxe[(w)]
set dxe[(w)]=dxe[dxe[(w)]]endifset dxe[oSx]=Zset dre[oSx]=1call Ddr(oSx)return oSxendfunctionfunction Dfr takes integer rYx,integer Iix returns nothingcall Nbx((Iix),(CWe),(rYx),w,((Cwe[rYx])*1.))endfunctionfunction DFr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local real bex=dne[oSx]local integer HAx=dOe[oSx]local real oyx=dbe[oSx]+dBe[oSx]
local integer svo=dde[oSx]local real x=dfe[oSx]+dFe[oSx]local real y=dge[oSx]+dGe[oSx]local real d7r=oyx*(dRe[oSx]*oyx+dNe[oSx])local integer Iixlocal integer rYxset dbe[oSx]=oyx
set dfe[oSx]=xset dge[oSx]=yset x=x+d7r*dIe[oSx]
set y=y+d7r*dAe[oSx]
call mho((mko(((x)*1.),((y)*1.),(dje),(ri))))call DQx(HAx,x)call DSx(HAx,y)set hf=(ze[(dEe[oSx])])set Ose=svocall NVo(C6e,x,y,dVe[oSx],C7e)set Iix=NEo(C6e)
if(Iix!=w)thenset rYx=dCe[oSx]
loop
call dQx(svo,Iix)call Dfr(rYx,Iix)set Iix=NEo(C6e)
exitwhen(Iix==w)
endloopendifendfunctionfunction Dgr takes integer oSx returns nothingset die[oSx]=falsecall rHx(C4e)endfunctionfunction DGr takes integer oSx returns nothingif(dre[oSx]>0)thenreturnendifif(dxe[oSx]!=Z)thencall o_x("FrozenStar_Allocation_deallocCustom_confirm","call DebugEx(FrozenStar.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",C5e+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset dxe[oSx]=dxe[(w)]set dxe[(w)]=oSx
call Dgr(oSx)endfunctionfunction Dhr takes integer oSx returns nothingset dre[oSx]=dre[oSx]-1call DGr(oSx)endfunctionfunction DHr takes integer oSx,integer Cqx,real Nbo,integer rYx,real x,real y returns nothinglocal integer rLx=oSxlocal integer Iixcall mho((mko(((x)*1.),((y)*1.),(dke),(ri))))set hf=(ze[(Cqx)])call NVo(dKe,x,y,(CQx((C0e),Uvv+(rYx))),dle)
set Iix=NEo(dKe)
if(Iix!=w)thenloop
call Dfr(rYx,Iix)call Our(Iix,dLe,.0,(Atan2((((GetUnitY(C[((Iix))]))-y)*1.),(((GetUnitX(C[((Iix))]))-x)*1.)))+3.141592654,dme)call nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))set Iix=NEo(dKe)
exitwhen(Iix==w)
endloopendifendfunctionfunction Djr takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local integer Cqx=dEe[oSx]local real Nbo=dXe[oSx]local integer HAx=dOe[oSx]local integer rYx=dCe[oSx]local integer svo=dde[oSx]local integer Q9o=dDe[oSx]local real x=dfe[oSx]local real y=dge[oSx]local integer Ctx=dhe[oSx]call Dhr((oSx))call MGx(HAx)call iKx(iCx)call X_r(svo)call iKx(Q9o)call dNx(Ctx)call DHr((w),Cqx,Nbo,rYx,x,y)endfunctionfunction DJr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local real Dkr=(GetUnitFacing(C[((Cqx))])*Nh)local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real dX=dVx-wQolocal real dY=dEx-wsolocal real bex=Ufx(Cqx,dX,dY)local real DKr=C1e[rYx]*C8elocal real d=jKx(dX,dY)local real jQx=iUx(jkx(Dkr,bex)*C9e,dve)
local real Dir=bex-Bev+2*Bev*Rlo(DCr(Dkr,bex))local real oyx=DKr*(Cos(((((jQx)*1.))*1.)))local real Dlr=((Sin(((((jQx)*1.))*1.)))*DKr)*1./(oyx*(oyx-C1e[rYx]))local integer oSx=DDr()local integer iCx=iXx()local integer Q9o=iXx()local integer Ctx=CPx(Cqx,C0e)set dne[oSx]=bex
set dVe[oSx]=C2e[rYx]set dEe[oSx]=Cqx
set dXe[oSx]=Cze[rYx]set dOe[oSx]=mDx('qFrS',wQo,wso,OMx(Cqx,wQo,wso)+Opx(Cqx,true),bex)set dRe[oSx]=Dlr
set dIe[oSx]=Dir*(Cos(((((Dir)*1.))*1.)))set dAe[oSx]=Dir*(Sin(((((Dir)*1.))*1.)))set dNe[oSx]=-Dlr*C1e[rYx]set dbe[oSx]=.0set dBe[oSx]=dce[rYx]set dCe[oSx]=rYx
set dde[oSx]=Jbx("FrozenStar_Event_SpellEffect: set this.targetGroup = UnitList.Create()")set dDe[oSx]=Q9o
set dfe[oSx]=wQo
set dFe[oSx]=dce[rYx]*(Cos(((((bex)*1.))*1.)))set dge[oSx]=wso
set dGe[oSx]=dce[rYx]*(Sin(((((bex)*1.))*1.)))set dhe[oSx]=Ctx
set ge[(iCx)]=(oSx)set ge[(Q9o)]=(oSx)call iDx(Q9o,dHe,true,function DFr)call iDx(iCx,dJe[rYx],false,function Djr)return trueendfunctionfunction DLr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn trueendfunctionfunction Dmr takes nothing returns nothingset dKe=O5x()set dle=Xpx(function DLr)endfunctionfunction DMr takes nothing returns booleanlocal integer oMxset C6e=O5x()set C7e=Xpx(function Dcr)call mro(C0e,Xdx("FrozenStar_Init: call FrozenStar.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FrozenStar.Event_SpellEffect))",ih,MI,function DJr))set oMx=(m6[(C0e)])loop
set dJe[oMx]=C1e[oMx]*1./ C3e[oMx]set dce[oMx]=C3e[oMx]*dHeset oMx=oMx-1exitwhen(oMx<1)endloopcall Dmr()call W2x(nVv,CWe)return trueendfunctionfunction Dpr takes nothing returns booleancall cPr(function DMr,"FrozenStar_Init")
return trueendfunctionfunction DPr takes nothing returns booleanset dMe[5]=hjo('uGh5')call hJo(((dMe[5])),ASv,(Idv))set Uj[(dMe[5])]=((1)*1.)set NOv[(dMe[5])]=((60)*1.)set NWv[(dMe[5])]=((60)*1.)set NPv[(dMe[5])]=(($DC)*1.)
set I8v[(dMe[5])]=((1)*1.)set Anv[(dMe[5])]=(1)set Nmv[(dMe[5])]=((350)*1.)
set NLv[(dMe[5])]=((350)*1.)
set NKv[(dMe[5])]=((0)*1.)set Ncv[(dMe[5])]=(($578)*1.)set Nbv[(dMe[5])]=(($578)*1.)set NGv[(dMe[5])]=((80)*1.)set Adv[(dMe[5])]=(gkv)set AGv[(dMe[5])]=((153.6)*1.)set Ahv[((dMe[5]))]=((1.*1./((1.7)*1.))*1.)set AWv[(dMe[5])]=((.3)*1.)set Auv[(dMe[5])]=(($A)*1.)set AUv[(dMe[5])]=(($A)*1.)set AYv[(dMe[5])]=(2)set A_v[(dMe[5])]=(2)set A2v[(dMe[5])]=(0)set ATv[(dMe[5])]=((20)*1.)return trueendfunctionfunction Dqr takes nothing returns booleanset dMe[1]=hjo('uGho')call hJo(((dMe[1])),ASv,(Idv))set Uj[(dMe[1])]=((1)*1.)set NOv[(dMe[1])]=((60)*1.)set NWv[(dMe[1])]=((60)*1.)set NPv[(dMe[1])]=(($DC)*1.)
set I8v[(dMe[1])]=((1)*1.)set Anv[(dMe[1])]=(1)set Nmv[(dMe[1])]=(($C8)*1.)
set NLv[(dMe[1])]=(($C8)*1.)
set NKv[(dMe[1])]=((0)*1.)set Ncv[(dMe[1])]=(($578)*1.)set Nbv[(dMe[1])]=(($578)*1.)set NGv[(dMe[1])]=((40)*1.)set Adv[(dMe[1])]=(gmv)set AGv[(dMe[1])]=((480)*1.)
set Ahv[((dMe[1]))]=((1.*1./((1.7)*1.))*1.)set AWv[(dMe[1])]=((.3)*1.)set Dnv[(dMe[1])]=((600)*1.)
set Auv[(dMe[1])]=((7)*1.)set AUv[(dMe[1])]=((7)*1.)set AYv[(dMe[1])]=(2)set A_v[(dMe[1])]=(2)set A2v[(dMe[1])]=(3)set ATv[(dMe[1])]=((20)*1.)return trueendfunctionfunction DQr takes nothing returns booleanset dMe[3]=hjo('uGh3')call hJo(((dMe[3])),ASv,(Idv))set Uj[(dMe[3])]=((1)*1.)set NOv[(dMe[3])]=((60)*1.)set NWv[(dMe[3])]=((60)*1.)set NPv[(dMe[3])]=(($DC)*1.)
set I8v[(dMe[3])]=((1)*1.)set Anv[(dMe[3])]=(1)set Nmv[(dMe[3])]=((275)*1.)
set NLv[(dMe[3])]=((275)*1.)
set NKv[(dMe[3])]=((0)*1.)set Ncv[(dMe[3])]=(($578)*1.)set Nbv[(dMe[3])]=(($578)*1.)set NGv[(dMe[3])]=((60)*1.)set Adv[(dMe[3])]=(gkv)set AGv[(dMe[3])]=((153.6)*1.)set Ahv[((dMe[3]))]=((1.*1./((1.7)*1.))*1.)set AWv[(dMe[3])]=((.3)*1.)set Auv[(dMe[3])]=((5)*1.)set AUv[(dMe[3])]=((5)*1.)set AYv[(dMe[3])]=(2)set A_v[(dMe[3])]=(2)set A2v[(dMe[3])]=(0)set ATv[(dMe[3])]=((20)*1.)return trueendfunctionfunction Dsr takes nothing returns booleanset dMe[4]=hjo('uGh4')call hJo(((dMe[4])),ASv,(Idv))set Uj[(dMe[4])]=((1)*1.)set NOv[(dMe[4])]=((60)*1.)set NWv[(dMe[4])]=((60)*1.)set NPv[(dMe[4])]=(($DC)*1.)
set I8v[(dMe[4])]=((1)*1.)set Anv[(dMe[4])]=(1)set Nmv[(dMe[4])]=((350)*1.)
set NLv[(dMe[4])]=((350)*1.)
set NKv[(dMe[4])]=((0)*1.)set Ncv[(dMe[4])]=(($578)*1.)set Nbv[(dMe[4])]=(($578)*1.)set NGv[(dMe[4])]=((60)*1.)set Adv[(dMe[4])]=(gkv)set AGv[(dMe[4])]=((153.6)*1.)set Ahv[((dMe[4]))]=((1.*1./((1.7)*1.))*1.)set AWv[(dMe[4])]=((.3)*1.)set Auv[(dMe[4])]=(($A)*1.)set AUv[(dMe[4])]=(($A)*1.)set AYv[(dMe[4])]=(2)set A_v[(dMe[4])]=(2)set A2v[(dMe[4])]=(0)set ATv[(dMe[4])]=((20)*1.)return trueendfunctionfunction DSr takes nothing returns booleanset dpe=ltx(dPe+" (dummyBuff)")call lWx(dpe,"GhostSword_page\\GhostSword_struct\\Sword\\ScimitarAttachment.mdx","weapon",ri)return trueendfunctionfunction Dtr takes nothing returns booleanset dqe[1]=.5set dqe[2]=.75set dqe[3]=1
set dqe[4]=1.25set dqe[5]=1.5set dqe[6]=1.75set dQe[1]=5
set dQe[2]=7.5set dQe[3]=7.5set dQe[4]=$Aset dQe[5]=$Aset dQe[6]=12.5set dse[1]=.25set dse[2]=.25set dse[3]=.25set dse[4]=.25set dse[5]=.25set dse[6]=.25set dSe[1]=2
set dSe[2]=2
set dSe[3]=2
set dSe[4]=2
set dSe[5]=2
set dSe[6]=2
return trueendfunctionfunction DTr takes nothing returns booleanset dMe[6]=hjo('uGh6')call hJo(((dMe[6])),ASv,(Idv))set Uj[(dMe[6])]=((1)*1.)set NOv[(dMe[6])]=((60)*1.)set NWv[(dMe[6])]=((60)*1.)set NPv[(dMe[6])]=(($DC)*1.)
set I8v[(dMe[6])]=((1)*1.)set Anv[(dMe[6])]=(1)set Nmv[(dMe[6])]=((350)*1.)
set NLv[(dMe[6])]=((350)*1.)
set NKv[(dMe[6])]=((0)*1.)set Ncv[(dMe[6])]=(($578)*1.)set Nbv[(dMe[6])]=(($578)*1.)set NGv[(dMe[6])]=(('d')*1.)
set Adv[(dMe[6])]=(gkv)set AGv[(dMe[6])]=((153.6)*1.)set Ahv[((dMe[6]))]=((1.*1./((1.7)*1.))*1.)set AWv[(dMe[6])]=((.3)*1.)set Auv[(dMe[6])]=(($A)*1.)set AUv[(dMe[6])]=(($A)*1.)set AYv[(dMe[6])]=(2)set A_v[(dMe[6])]=(2)set A2v[(dMe[6])]=(0)set ATv[(dMe[6])]=((20)*1.)return trueendfunctionfunction Dur takes nothing returns booleanset dMe[2]=hjo('uGh2')call hJo(((dMe[2])),ASv,(Idv))set Uj[(dMe[2])]=((1)*1.)set NOv[(dMe[2])]=((60)*1.)set NWv[(dMe[2])]=((60)*1.)set NPv[(dMe[2])]=(($DC)*1.)
set I8v[(dMe[2])]=((1)*1.)set Anv[(dMe[2])]=(1)set Nmv[(dMe[2])]=((275)*1.)
set NLv[(dMe[2])]=((275)*1.)
set NKv[(dMe[2])]=((0)*1.)set Ncv[(dMe[2])]=(($578)*1.)set Nbv[(dMe[2])]=(($578)*1.)set NGv[(dMe[2])]=((40)*1.)set Adv[(dMe[2])]=(gkv)set AGv[(dMe[2])]=((153.6)*1.)set Ahv[((dMe[2]))]=((1.*1./((1.7)*1.))*1.)set AWv[(dMe[2])]=((.3)*1.)set Auv[(dMe[2])]=((5)*1.)set AUv[(dMe[2])]=((5)*1.)set AYv[(dMe[2])]=(2)set A_v[(dMe[2])]=(2)set A2v[(dMe[2])]=(0)set ATv[(dMe[2])]=((20)*1.)return trueendfunctionfunction DUr takes nothing returns booleancall VNx(sa,(function DPr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\obj_summonUnitType[5]_wc3unit.j"))call VNx(sa,(function Dqr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\obj_summonUnitType[1]_wc3unit.j"))call VNx(sa,(function DQr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\obj_summonUnitType[3]_wc3unit.j"))call VNx(sa,(function Dsr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\obj_summonUnitType[4]_wc3unit.j"))call VNx(ma,(function DSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\obj_dummyBuff_wc3buff.j"))call VNx(va,(function Dtr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\obj_this_wc3obj.j"))
call VNx(sa,(function DTr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\obj_summonUnitType[6]_wc3unit.j"))call VNx(sa,(function Dur),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\obj_summonUnitType[2]_wc3unit.j"))return trueendfunctionfunction Dwr takes nothing returns booleanset dte=VXx(dPe)
return trueendfunctionfunction DWr takes nothing returns booleancall L1x('AGhS',false)set cEe=L0o('AGhS')set K6[(cEe)]=(F6)set m6[(cEe)]=(6)set TH[(cEe)]=("Ghost Sword")set Rh[(cEe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0274)))),(((Aj))))))set oxv[(cEe)]=(4)set x3v[(cEe)]=("spell")
call L1o((cEe),GH+(1),(($C)*1.))
call L1o((cEe),tH+(1),((40)*1.))
call L1o((cEe),Lov+(1),((750)*1.))call L1o((cEe),GH+(2),(($C)*1.))
call L1o((cEe),tH+(2),((50)*1.))
call L1o((cEe),Lov+(2),((750)*1.))call L1o((cEe),GH+(3),(($C)*1.))
call L1o((cEe),tH+(3),((60)*1.))
call L1o((cEe),Lov+(3),((750)*1.))call L1o((cEe),GH+(4),(($C)*1.))
call L1o((cEe),tH+(4),((70)*1.))
call L1o((cEe),Lov+(4),((750)*1.))call L1o((cEe),GH+(5),(($C)*1.))
call L1o((cEe),tH+(5),((80)*1.))
call L1o((cEe),Lov+(5),((750)*1.))call L1o((cEe),GH+(6),(($C)*1.))
call L1o((cEe),tH+(6),((90)*1.))
call L1o((cEe),Lov+(6),((750)*1.))set MOv[(cEe)]=("ReplaceableTextures\\CommandButtons\\BTNThoriumMelee.blp")call cDr(cEe,'FGS0',6,'VGS0','LPGS','LRGS')set dTe[1]=2
set dTe[2]=2
set dTe[3]=3
set dTe[4]=3
set dTe[5]=4
set dTe[6]=4
set due[1]=25set due[2]=25set due[3]=25set due[4]=25set due[5]=25set due[6]=25return trueendfunctionfunction Dyr takes nothing returns booleanset dUe=ltx(dwe+" (dummyBuff)")set Pc[(dUe)]=(true)
return trueendfunctionfunction DYr takes nothing returns booleancall VNx(Pa,(function DWr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\obj_thisSpell_wc3spell.j"))
call VNx(ma,(function Dyr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction Dzr takes nothing returns booleanset dWe=VXx(dwe)
return trueendfunctionfunction DZr takes integer oSx returns booleanif((dYe[((oSx))])>0)then
return false
endifset dze=dze+1set dZe[dze]=oSx
set dYe[oSx]=dze+1return(dze==0)endfunctionfunction D_r takes nothing returns nothinglocal integer oMx=dzeloop
exitwhen(oMx<0)set d1e[oMx]=dZe[oMx]set oMx=oMx-1endloopset d2e=dzeendfunctionfunction D0r takes nothing returns integerlocal integer o7xif(d2e<0)thenreturn w
endifset o7x=d1e[0]set d1e[0]=d1e[d2e]set d2e=d2e-1return o7xendfunctionfunction D1r takes nothing returns nothinglocal integer oSxlocal real bexlocal real iIrlocal integer Iixlocal real dKrlocal integer oMxlocal integer D2rcall D_r()loop
set oSx=D0r()exitwhen(oSx==w)
set bex=d3e[oSx]
set iIr=d4e[oSx]
set Iix=oSxset dKr=dox(Iix,true)set d3e[oSx]=bex+d5e*d0e
set oMx=CIx(Iix,d6e)
loop
exitwhen(oMx<q)set D2r=CAx(Iix,d6e,oMx)
if((LoadInteger(o[((V[(E[((X))])]))],((((GetUnitCurrentOrder(C[((Iix))]))))),(((Aj)))))==w)thenendifcall fzx(D2r,(GetUnitX(C[((Iix))]))+(dKr*(1+d7e))*(Cos(((((bex)*1.))*1.))),(GetUnitY(C[((Iix))]))+(dKr*(1+d7e))*(Sin(((((bex)*1.))*1.))))set bex=bex+iIrset oMx=oMx-1endloopendloopendfunctionfunction D3r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer oMxlocal integer D2rif DZr(oSx)thencall iDx(d_e,d0e,true,function D1r)endifset oMx=CIx(Iix,d6e)
loop
exitwhen(oMx<q)set D2r=CAx(Iix,d6e,oMx)
call Ulx(((D2r)),O1v)set oMx=oMx-1endloopreturn trueendfunctionfunction D4r takes integer oSx returns booleanif(((dYe[((oSx))])>0)==false)thenreturn false
endifset dYe[dZe[dze]]=dYe[oSx]set dZe[dYe[oSx]-1]=dZe[dze]
set dYe[oSx]=0set dze=dze-1return(dze==F)endfunctionfunction D5r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer oMxlocal integer D2rif D4r(oSx)thencall ikx(d_e)endifset oMx=CIx(Iix,d6e)
loop
exitwhen(oMx<q)set D2r=CAx(Iix,d6e,oMx)
call Dux((((D2r))),(O1v),(1),w)set oMx=oMx-1endloopreturn trueendfunctionfunction D6r takes integer C3o,real x,real y,real bex,integer rYx returns integerlocal integer D2r=U0o(dMe[rYx],C3o,x,y,bex,due[rYx])
call Dux((D2r),(dpe),(rYx),w)call Dux((((D2r))),(nYv),(1),w)call Dux((((D2r))),(x5v),(1),w)call Dux((((D2r))),(XAv),(1),w)call r0x((D2r),(d9e),(rYx))call r0x(((D2r)),((gtv)),(1))return D2rendfunctionfunction D7r takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer Ctx=(Lc[(rFx)])local integer Cqx=(EH[(Ctx)])local real dKr=dox(Iix,true)
local integer oMx=dTe[rYx]local real dVx=(GetUnitX(C[((Iix))]))local real dEx=(GetUnitY(C[((Iix))]))local real bex=(GetUnitFacing(C[((Cqx))])*Nh)local real iIr=Cf*1./ oMxlocal integer C3o=(ze[(Cqx)])local integer oSx=Iixlocal integer D2rset d3e[oSx]=bex
set d4e[oSx]=iIr
call Avx(Iix,dye)call Avx(Iix,d8e)loop
exitwhen(oMx<1)set D2r=D6r(C3o,dVx+(dKr*(1+d7e))*(Cos(((((bex)*1.))*1.))),dEx+(dKr*(1+d7e))*(Sin(((((bex)*1.))*1.))),bex,rYx)call rUx(Iix,d6e,D2r)call A_o(D2r)call Dyx(D2r,dKr*1./ 36.)call SetUnitLookAt(C[D2r],"bone_chest",C[Iix],.0,.0,.0)set bex=bex+iIrset oMx=oMx-1endloopif DZr(oSx)thencall iDx(d_e,d0e,true,function D1r)endifreturn trueendfunctionfunction D8r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer oMx=CIx(Iix,d6e)local integer D2rloop
exitwhen(oMx<q)set D2r=CAx(Iix,d6e,oMx)
call Crx((D2r),w)call Khx(D2r)set oMx=oMx-1endloopcall Nwo(Iix,d6e)call RPx(Iix,dye)call RPx(Iix,d8e)if D4r(oSx)thencall ikx(d_e)endifreturn trueendfunctionfunction D9r takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local integer Ctx=(WH[(rFx)])call AZx(Iix,dUe)call Nbx(Iix,dUe,rYx,Ctx,due[rYx])return trueendfunctionfunction fvr takes nothing returns booleanlocal integer rFx=(bv)local integer D2r=(Vv[(rFx)])local integer Iix=(zH[(rFx)])local integer oSx=D2rlocal real iMxif I9x(Iix,Wd)thenset iMx=dse[Dee[oSx]]else
set iMx=dSe[Dee[oSx]]endifcall nEr(Dee[oSx],Iix,iMx)return trueendfunctionfunction fer takes nothing returns booleanlocal integer rFx=(bv)local integer D2r=(E2v[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=D2rlocal real fxr=iUx((lF[(Iix)]),Doe[oSx])
if(fxr>.0)thencall Ryx((ACx((Iix),(Dre),(Die),(ri))))call YCo(Iix,fxr)call nlo((D2r),(Iix),((fxr*Dae[oSx])*1.),(true),(false))
endifreturn trueendfunctionfunction for takes integer oSx returns booleanif((DRe[((oSx))])>0)then
return false
endifset DIe=DIe+1set DAe[DIe]=oSx
set DRe[oSx]=DIe+1return(DIe==0)endfunctionfunction frr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer fir=iXx()set DVe[oSx]=trueset DEe[oSx]=fir
set Dae[oSx]=dqe[rYx]set Dee[oSx]=rYx
set Doe[oSx]=dQe[rYx]set ge[(fir)]=(oSx)call Ryx((ACx((Iix),(DXe),(DOe),(ri))))call Avx(Iix,Dve)call Avx(Iix,Dxe)if for(oSx)thenendifreturn trueendfunctionfunction far takes integer oSx returns booleanif(((DRe[((oSx))])>0)==false)thenreturn false
endifset DRe[DAe[DIe]]=DRe[oSx]set DAe[DRe[oSx]-1]=DAe[DIe]
set DRe[oSx]=0set DIe=DIe-1return(DIe==F)endfunctionfunction fnr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer fir=DEe[oSx]call Ryx((ACx((Iix),(DNe),(Dbe),(ri))))call iKx(fir)call RPx(Iix,Dve)call RPx(Iix,Dxe)if DVe[oSx]thenif far(oSx)thencall ikx(Dne)endifendifreturn trueendfunctionfunction fVr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction fEr takes nothing returns nothingset Dve=Xdx("FolderGhostSword_StructSword_Init: set FolderGhostSword_StructSword.CRIT_EVENT = Event.Create(UNIT.CriticalChance.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderGhostSword_StructSword.Event_Crit)",Bfv,MI,function fvr)set Dxe=Xdx("FolderGhostSword_StructSword_Init: set FolderGhostSword_StructSword.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function FolderGhostSword_StructSword.Event_Damage)",E4v,MI,function fer)
set Dne=iXx()call Lxx(dpe,Xdx("FolderGhostSword_StructSword_Init: call FolderGhostSword_StructSword.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderGhostSword_StructSword.Event_BuffGain))",bd,MI,function frr))
call Lxx(dpe,Xdx("FolderGhostSword_StructSword_Init: call FolderGhostSword_StructSword.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderGhostSword_StructSword.Event_BuffLose))",jc,MI,function fnr))
set DBe=O5x()set Dce=Xpx(function fVr)endfunctionfunction fXr takes nothing returns booleanset dye=Xdx("GhostSword_Init: set GhostSword.TRANSPORT_ENDING_EVENT = Event.Create(UNIT.Transport.ENDING_EVENT_TYPE, EventPriority.SPELLS, function GhostSword.Event_TransportEnding)",O8v,MI,function D3r)set d8e=Xdx("GhostSword_Init: set GhostSword.TRANSPORT_START_EVENT = Event.Create(UNIT.Transport.START_EVENT_TYPE, EventPriority.SPELLS, function GhostSword.Event_TransportStart)",O7v,MI,function D5r)
set d_e=iXx()call Lxx(dUe,Xdx("GhostSword_Init: call GhostSword.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function GhostSword.Event_BuffGain))",bd,MI,function D7r))call Lxx(dUe,Xdx("GhostSword_Init: call GhostSword.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function GhostSword.Event_BuffLose))",jc,MI,function D8r))call mro(cEe,Xdx("GhostSword_Init: call GhostSword.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function GhostSword.Event_SpellEffect))",ih,MI,function D9r))call fEr()return trueendfunctionfunction fOr takes nothing returns booleancall cPr(function fXr,"GhostSword_Init")
return trueendfunctionfunction fRr takes nothing returns booleanset DCe[1]=20set DCe[2]=30set DCe[3]=40set DCe[4]=50set DCe[5]=60set DCe[6]=70set Dde[1]=.2set Dde[2]=.3set Dde[3]=.4set Dde[4]=.5set Dde[5]=.6set Dde[6]=.7return trueendfunctionfunction fIr takes nothing returns booleanset DDe=Wwx('BHnS',"Hack'n'Slay",'bHnS')
set anv[(DDe)]=("ReplaceableTextures\\CommandButtons\\BTNCriticalStrike.blp")set WU=l_x()
call l2x(WU,nnv,.2)call l2x(WU,BFv,20)call l3x(((DDe)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,nnv,.3)call l2x(WU,BFv,30)call l3x(((DDe)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,nnv,.4)call l2x(WU,BFv,40)call l3x(((DDe)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,nnv,.5)call l2x(WU,BFv,50)call l3x(((DDe)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,nnv,.6)call l2x(WU,BFv,60)call l3x(((DDe)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,nnv,.7)call l2x(WU,BFv,70)call l3x(((DDe)),ZB+(6),(WU))return trueendfunctionfunction fAr takes nothing returns booleancall VNx(va,(function fRr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\HackNSlay.page\\HackNSlay.struct\\Target\\obj_this_wc3obj.j"))call VNx(ma,(function fIr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\HackNSlay.page\\HackNSlay.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction fNr takes nothing returns booleanset Dfe=VXx(DFe)
return trueendfunctionfunction fbr takes nothing returns booleanset Dge=ltx(DGe+" (dummyBuff)")set aav[(Dge)]=(true)return trueendfunctionfunction fBr takes nothing returns booleancall L1x('AHnS',false)set d9e=L0o('AHnS')set K6[(d9e)]=(H6)set m6[(d9e)]=(6)set TH[(d9e)]=("Hack'n'Slay")set x3v[(d9e)]=("spell")
call L1o((d9e),Uvv+(1),((400)*1.))call L1o((d9e),Lov+(1),((750)*1.))call L1o((d9e),Uvv+(2),((400)*1.))call L1o((d9e),Lov+(2),((750)*1.))call L1o((d9e),Uvv+(3),((400)*1.))call L1o((d9e),Lov+(3),((750)*1.))call L1o((d9e),Uvv+(4),((400)*1.))call L1o((d9e),Lov+(4),((750)*1.))call L1o((d9e),Uvv+(5),((400)*1.))call L1o((d9e),Lov+(5),((750)*1.))call L1o((d9e),Uvv+(6),((400)*1.))call L1o((d9e),Lov+(6),((750)*1.))set MOv[(d9e)]=("ReplaceableTextures\\PassiveButtons\\PASBTNCriticalStrike.blp")
return trueendfunctionfunction fcr takes nothing returns booleancall VNx(ma,(function fbr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\HackNSlay.page\\HackNSlay.struct\\obj_dummyBuff_wc3buff.j"))
call VNx(Pa,(function fBr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\GhostSword.page\\GhostSword.struct\\Sword\\HackNSlay.page\\HackNSlay.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction fCr takes nothing returns booleanset Dhe=VXx(DGe)
return trueendfunctionfunction fdr takes code c,string rSx returns nothing
set Un=Un+1set wn[Un]=CreateTrigger()set Wn[Un]=(GetHandleId(Condition((c))))
set yn[Un]=rSxcall TriggerAddCondition(wn[Un],Condition(c))endfunctionfunction fDr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif((IsUnitAlly(C[(Iix)],vx[(hf)]))==false)thenreturn false
endifreturn truereturn trueendfunctionfunction ffr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(hc[(rFx)])local integer oSx=Cqxlocal integer Xur=XQr(Cqx)set Dje[oSx]=Xur
set DJe[oSx]=Cqx
set Dke[oSx]=rYx
set Ene[(Xur)]=(oSx)
set vqe[(Xur)]=(((CQx((d9e),Uvv+(rYx))))*1.)
set vQe[(Xur)]=(DHe)
call Xsr(Xur,DKe)call Xsr(Xur,Dle)call Xtr(Xur)return trueendfunctionfunction fFr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oSx=Cqxlocal integer Xur=Dje[oSx]call X5r(Xur)return trueendfunctionfunction fgr takes nothing returns booleanlocal integer rFx=(bv)call seo((Vv[(rFx)]),Dge,(Mv[(rFx)]))return trueendfunctionfunction fGr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),Dge)return trueendfunctionfunction fhr takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer rLx=(Ene[(Xur)])call Ulx(Iix,DDe)return trueendfunctionfunction fHr takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer Cqx=(vke[(Xur)])local integer rLx=(Ene[(Xur)])local integer rYx=Dke[rLx]call Dux((Iix),(DDe),(rYx),w)return trueendfunctionfunction fjr takes nothing returns nothingset DKe=Xdx("FolderHackNSlay_StructTarget_Init: set FolderHackNSlay_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderHackNSlay_StructTarget.Event_Ending)",vTe,MI,function fhr)set Dle=Xdx("FolderHackNSlay_StructTarget_Init: set FolderHackNSlay_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderHackNSlay_StructTarget.Event_Start)",vue,MI,function fHr)
endfunctionfunction fJr takes nothing returns booleanset DHe=Xpx(function fDr)call Lxx(Dge,Xdx("HackNSlay_Init: call HackNSlay.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HackNSlay.Event_BuffGain))",bd,MI,function ffr))call Lxx(Dge,Xdx("HackNSlay_Init: call HackNSlay.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HackNSlay.Event_BuffLose))",jc,MI,function fFr))call mro(d9e,Xdx("HackNSlay_Init: call HackNSlay.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function HackNSlay.Event_Learn))",Pv,MI,function fgr))
call mro(d9e,Xdx("HackNSlay_Init: call HackNSlay.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HackNSlay.Event_Learn))",pv,MI,function fgr))call mro(d9e,Xdx("HackNSlay_Init: call HackNSlay.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HackNSlay.Event_Unlearn))",Av,MI,function fGr))call fjr()return trueendfunctionfunction fkr takes nothing returns booleancall fdr(function fJr,"HackNSlay_Init")return trueendfunctionfunction fKr takes nothing returns booleancall L1x('AIcB',false)set DLe=L0o('AIcB')set K6[(DLe)]=(F6)set m6[(DLe)]=(6)set TH[(DLe)]=("Ice Block")set Rh[(DLe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0216)))),(((Aj))))))set oxv[(DLe)]=(0)set x3v[(DLe)]=("spell")
call L1o((DLe),GH+(1),(($F)*1.))
call L1o((DLe),tH+(1),((30)*1.))
call L1o((DLe),Lov+(1),((750)*1.))call L1o((DLe),GH+(2),(($F)*1.))
call L1o((DLe),tH+(2),((35)*1.))
call L1o((DLe),Lov+(2),((750)*1.))call L1o((DLe),GH+(3),(($F)*1.))
call L1o((DLe),tH+(3),((40)*1.))
call L1o((DLe),Lov+(3),((750)*1.))call L1o((DLe),GH+(4),(($F)*1.))
call L1o((DLe),tH+(4),((45)*1.))
call L1o((DLe),Lov+(4),((750)*1.))call L1o((DLe),GH+(5),(($F)*1.))
call L1o((DLe),tH+(5),((50)*1.))
call L1o((DLe),Lov+(5),((750)*1.))set MOv[(DLe)]=("ReplaceableTextures\\CommandButtons\\BTNIcyTreasureBox.blp")set Dme[1]=5
set Dme[2]=$Aset Dme[3]=$Fset Dme[4]=20set Dme[5]=25set DMe[1]=5
set DMe[2]=5.5set DMe[3]=6
set DMe[4]=6.5set DMe[5]=7
return trueendfunctionfunction flr takes nothing returns booleanset Dpe=Wwx('BIcB',"Ice Block",'bIcB')set aav[(Dpe)]=(true)set uU[(Dpe)]=(true)
set anv[(Dpe)]=("ReplaceableTextures\\CommandButtons\\BTNIcyTreasureBox.blp")call lWx(Dpe,"Abilities\\Spells\\Undead\\FreezingBreath\\FreezingBreathTargetArt.mdl","origin",ri)call lWx(Dpe,"Abilities\\Spells\\Items\\StaffOfSanctuary\\Staff_Sanctuary_Target.mdl","chest",Bi)set WU=l_x()
call l2x(WU,DHv,5)call vAr(WU,DRv,true)call vAr(WU,DJv,true)call vAr(WU,DLv,true)call l3x(((Dpe)),ZB+(1),(WU))return trueendfunctionfunction fLr takes nothing returns booleancall VNx(Pa,(function fKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\IceBlock.page\\IceBlock.struct\\obj_thisSpell_wc3spell.j"))
call VNx(ma,(function flr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\IceBlock.page\\IceBlock.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction fmr takes nothing returns booleanset DPe=VXx(Dqe)
return trueendfunctionfunction fMr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(Mv[(rFx)])call Nbx(((Vv[(rFx)])),(Dpe),(rYx),w,((DMe[rYx])*1.))return trueendfunctionfunction fpr takes nothing returns booleancall mro(DLe,Xdx("IceBlock_Init: call IceBlock.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function IceBlock.Event_SpellEffect))",ih,MI,function fMr))return trueendfunctionfunction fPr takes nothing returns booleancall cPr(function fpr,"IceBlock_Init")return trueendfunctionfunction fqr takes nothing returns booleanset DQe=ltx(Dse+" (frostBuff)")return trueendfunctionfunction fQr takes nothing returns booleanset DSe=ltx(Dse+" (coldnessBuff)")return trueendfunctionfunction fsr takes nothing returns booleancall L1x('AIcS',false)set cVe=L0o('AIcS')set K6[(cVe)]=(F6)set m6[(cVe)]=(6)set TH[(cVe)]=("Ice Shock")set Rh[(cVe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0108)))),(((Aj))))))set oxv[(cVe)]=(4)set x3v[(cVe)]=("spell")
call L1o((cVe),Uvv+(1),(($C8)*1.))call L1o((cVe),GH+(1),(($F)*1.))
call L1o((cVe),tH+(1),((70)*1.))
call L1o((cVe),Lov+(1),((600)*1.))call L1o((cVe),Uvv+(2),(($C8)*1.))call L1o((cVe),GH+(2),(($F)*1.))
call L1o((cVe),tH+(2),((70)*1.))
call L1o((cVe),Lov+(2),((600)*1.))call L1o((cVe),Uvv+(3),(($C8)*1.))call L1o((cVe),GH+(3),(($F)*1.))
call L1o((cVe),tH+(3),((70)*1.))
call L1o((cVe),Lov+(3),((600)*1.))call L1o((cVe),Uvv+(4),(($C8)*1.))call L1o((cVe),GH+(4),(($F)*1.))
call L1o((cVe),tH+(4),((70)*1.))
call L1o((cVe),Lov+(4),((600)*1.))call L1o((cVe),Uvv+(5),(($C8)*1.))call L1o((cVe),GH+(5),(($F)*1.))
call L1o((cVe),tH+(5),((70)*1.))
call L1o((cVe),Lov+(5),((600)*1.))call L1o((cVe),Uvv+(6),(($C8)*1.))call L1o((cVe),GH+(6),(($F)*1.))
call L1o((cVe),tH+(6),((70)*1.))
call L1o((cVe),Lov+(6),((600)*1.))set MOv[(cVe)]=("ReplaceableTextures\\CommandButtons\\BTNGlacier.blp")call cDr(cVe,'FIS0',6,'VIS0','LPIS','LRIS')set Dte[1]=1
set Dte[2]=1
set Dte[3]=1
set Dte[4]=1
set Dte[5]=1
set Dte[6]=1
set DTe[1]=4
set DTe[2]=4
set DTe[3]=4
set DTe[4]=4
set DTe[5]=4
set DTe[6]=4
set Due[1]=1
set Due[2]=1
set Due[3]=1
set Due[4]=1
set Due[5]=1
set Due[6]=1
set DUe[1]=25set DUe[2]=50set DUe[3]=75set DUe[4]='d'set DUe[5]='}'set DUe[6]=$96set Dwe[1]=$Aset Dwe[2]=25set Dwe[3]=40set Dwe[4]=55set Dwe[5]=70set Dwe[6]=85set DWe[1]=4
set DWe[2]=4
set DWe[3]=4
set DWe[4]=4
set DWe[5]=4
set DWe[6]=4
return trueendfunctionfunction fSr takes nothing returns booleancall VNx(ma,(function fqr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\IceShock.page\\IceShock.struct\\obj_frostBuff_wc3buff.j"))call VNx(ma,(function fQr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\IceShock.page\\IceShock.struct\\obj_coldnessBuff_wc3buff.j"))call VNx(Pa,(function fsr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\IceShock.page\\IceShock.struct\\obj_thisSpell_wc3spell.j"))
return trueendfunctionfunction ftr takes nothing returns booleanset Dye=VXx(Dse)
return trueendfunctionfunction fTr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction fur takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local integer C3olocal real iMxlocal real Nbocall mho((mko(((dVx)*1.),((dEx)*1.),(DZe),(ri))))set C3o=(ze[(Cqx)])set hf=C3ocall NVo(DYe,dVx,dEx,(CQx((cVe),Uvv+(rYx))),Dze)
call GroupRemoveUnit(kb[(DYe)],C[(Iix)])
if I9x(Iix,Wd)thenset iMx=Dte[rYx]
else
set iMx=DWe[rYx]
endifcall Nbx((Iix),(DQe),(rYx),w,((iMx)*1.))
call nlo((Cqx),(Iix),((DUe[rYx])*1.),(true),(false))
set Iix=NEo(DYe)
if(Iix!=w)thenset Nbo=Dwe[rYx]
loop
if I9x(Iix,Wd)thenset iMx=Due[rYx]
else
set iMx=DTe[rYx]
endifcall Nbx((Iix),(DSe),(rYx),w,((iMx)*1.))
call nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))set Iix=NEo(DYe)
exitwhen(Iix==w)
endloopendifreturn trueendfunctionfunction fUr takes nothing returns booleanset DYe=O5x()set Dze=Xpx(function fTr)call mro(cVe,Xdx("IceShock_Init: call IceShock.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function IceShock.Event_SpellEffect))",ih,MI,function fur))call W2x(nVv,DSe)call W2x(nGv,DQe)return trueendfunctionfunction fwr takes nothing returns booleancall fdr(function fUr,"IceShock_Init")return trueendfunctionfunction fWr takes nothing returns booleanset D_e[1]=$Aset D_e[2]=$Fset D_e[3]=20set D_e[4]=25set D_e[5]=30set D_e[6]=35return trueendfunctionfunction fyr takes nothing returns booleanset D0e=Wwx('BIFo',"Inner Force",'bIFo')
set aav[(D0e)]=(true)set Pc[(D0e)]=(true)
set anv[(D0e)]=("ReplaceableTextures\\CommandButtons\\BTNImmolationOn.blp")call lWx(D0e,"Abilities\\Spells\\NightElf\\Immolation\\ImmolationTarget.mdl","origin",ri)set WU=l_x()
call l2x(WU,BFv,$A)call l3x(((D0e)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,BFv,$F)call l3x(((D0e)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,BFv,20)call l3x(((D0e)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,BFv,25)call l3x(((D0e)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,BFv,30)call l3x(((D0e)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,BFv,35)call l3x(((D0e)),ZB+(6),(WU))return trueendfunctionfunction fYr takes nothing returns booleancall VNx(va,(function fWr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\InnerForce.page\\InnerForce.struct\\Crit\\obj_this_wc3obj.j"))call VNx(ma,(function fyr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\InnerForce.page\\InnerForce.struct\\Crit\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction fzr takes nothing returns booleanset D1e=VXx(D2e)
return trueendfunctionfunction fZr takes nothing returns booleancall L1x('AIFo',false)set cOe=L0o('AIFo')set K6[(cOe)]=(F6)set m6[(cOe)]=(6)set TH[(cOe)]=("Inner Force")set Rh[(cOe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0108)))),(((Aj))))))set oxv[(cOe)]=(0)set x3v[(cOe)]=("spell")
call L1o((cOe),Uvv+(1),(($E1)*1.))call L1o((cOe),GH+(1),(($D)*1.))
call L1o((cOe),tH+(1),((40)*1.))
call L1o((cOe),Lov+(1),((750)*1.))call L1o((cOe),Uvv+(2),(($E1)*1.))call L1o((cOe),GH+(2),(($D)*1.))
call L1o((cOe),tH+(2),((50)*1.))
call L1o((cOe),Lov+(2),((750)*1.))call L1o((cOe),Uvv+(3),(($E1)*1.))call L1o((cOe),GH+(3),(($D)*1.))
call L1o((cOe),tH+(3),((60)*1.))
call L1o((cOe),Lov+(3),((750)*1.))call L1o((cOe),Uvv+(4),(($E1)*1.))call L1o((cOe),GH+(4),(($D)*1.))
call L1o((cOe),tH+(4),((70)*1.))
call L1o((cOe),Lov+(4),((750)*1.))call L1o((cOe),Uvv+(5),(($E1)*1.))call L1o((cOe),GH+(5),(($D)*1.))
call L1o((cOe),tH+(5),((80)*1.))
call L1o((cOe),Lov+(5),((750)*1.))call L1o((cOe),Uvv+(6),(($E1)*1.))call L1o((cOe),GH+(6),(($D)*1.))
call L1o((cOe),tH+(6),((90)*1.))
call L1o((cOe),Lov+(6),((750)*1.))set MOv[(cOe)]=("ReplaceableTextures\\CommandButtons\\BTNImmolationOn.blp")call cDr(cOe,'FIF0',6,'VIF0','LPIF','LRIF')set D3e[1]=25set D3e[2]=34set D3e[3]=43set D3e[4]=52set D3e[5]=61set D3e[6]=70set D4e[1]=30set D4e[2]=50set D4e[3]=70set D4e[4]=90set D4e[5]='x'set D4e[6]=$96return trueendfunctionfunction f_r takes nothing returns booleancall VNx(Pa,(function fZr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\InnerForce.page\\InnerForce.struct\\obj_thisSpell_wc3spell.j"))
return trueendfunctionfunction f0r takes nothing returns booleanset D5e=VXx(D6e)
return trueendfunctionfunction f1r takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif((IsUnitAlly(C[(Iix)],vx[(hf)]))==false)thenreturn false
endifreturn truereturn trueendfunctionfunction f2r takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction f3r takes integer oSx returns integerset fre[oSx]=trueset fie[oSx]=falsecall rEx(D5e)return oSxendfunctionfunction f4r takes nothing returns integerlocal integer oSxif(fve==8190)thencall o_x("InnerForce_Allocation_allocCustom","call DebugEx(InnerForce.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",D6e+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(fee[(w)]==w)thenset fxe=fxe+1set oSx=fxeelse
set oSx=fee[(w)]
set fee[(w)]=fee[fee[(w)]]endifset fee[oSx]=Zset foe[oSx]=1call f3r(oSx)return oSxendfunctionfunction f5r takes integer oSx returns nothinglocal integer Cqx=fEe[oSx]local real O4o=dox(Cqx,true)+fVe[oSx]local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local integer Iixlocal real AXrlocal real Nbocall Ryx((ACx((Cqx),(fCe),(fde),(Bi))))set hf=(ze[(Cqx)])call NVo(D7e,wQo,wso,O4o,D8e)set Iix=NEo(D7e)
if(Iix!=w)thenset AXr=fOe[oSx]
loop
call mao(Cqx,Iix,AXr)set Iix=NEo(D7e)
exitwhen(Iix==w)
endloopendifset hf=(ze[(Cqx)])call NVo(D7e,wQo,wso,O4o,D9e)set Iix=NEo(D7e)
if(Iix!=w)thenset Nbo=fXe[oSx]
loop
call Our(Iix,fDe,ffe,(Atan2((((GetUnitY(C[((Iix))]))-wso)*1.),(((GetUnitX(C[((Iix))]))-wQo)*1.))),fFe)call nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))set Iix=NEo(D7e)
exitwhen(Iix==w)
endloopendifendfunctionfunction f6r takes nothing returns nothinglocal integer Okx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(Okx)])call f5r(oSx)endfunctionfunction f7r takes integer oSx returns nothinglocal integer Okxcall Ryx((ACx((fEe[oSx]),(fbe),(fBe),(ri))))
set Okx=iXx()set fne[oSx]=fne[oSx]+1set ge[(Okx)]=(oSx)call iDx(Okx,fce,false,function f6r)
endfunctionfunction f8r takes nothing returns nothingcall f7r(((ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])))endfunctionfunction f9r takes integer oSx returns nothingset fre[oSx]=falsecall rHx(D5e)endfunctionfunction Fvr takes integer oSx returns nothingif(foe[oSx]>0)thenreturnendifif(fee[oSx]!=Z)thencall o_x("InnerForce_Allocation_deallocCustom_confirm","call DebugEx(InnerForce.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",D6e+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset fee[oSx]=fee[(w)]set fee[(w)]=oSx
call f9r(oSx)endfunctionfunction Fer takes integer oSx returns nothingset foe[oSx]=foe[oSx]-1call Fvr(oSx)endfunctionfunction Fxr takes integer oSx returns nothingif not fae[oSx]thenreturnendifif(fne[oSx]>0)thenreturnendifcall Fer((oSx))endfunctionfunction For takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local integer p3x=fRe[oSx]local integer Ctx=fAe[oSx]call iKx(iCx)call iKx(p3x)call dNx(Ctx)set fae[oSx]=truecall Fxr(oSx)endfunctionfunction Frr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real O4o=(CQx((cOe),Uvv+(rYx)))local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local integer oSx=f4r()local integer iCx=iXx()local integer p3x=iXx()local integer Ctx=CPx(Cqx,cOe)set fae[oSx]=falseset fne[oSx]=0set fVe[oSx]=O4o
set fEe[oSx]=Cqx
set fXe[oSx]=D4e[rYx]set fOe[oSx]=D3e[rYx]set fRe[oSx]=p3x
set fIe[oSx]=rYx
set fAe[oSx]=Ctx
set ge[(iCx)]=(oSx)set ge[(p3x)]=(oSx)call iDx(p3x,fNe,true,function f8r)call iDx(iCx,(fge-1)*fNe,false,function For)
call f7r(oSx)return trueendfunctionfunction Fir takes nothing returns booleanlocal integer rFx=(bv)call seo((Vv[(rFx)]),D0e,(Mv[(rFx)]))return trueendfunctionfunction Far takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),D0e)return trueendfunctionfunction Fnr takes nothing returns nothingcall mro(cOe,Xdx("FolderInnerForce_StructCrit_Init: call InnerForce.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function FolderInnerForce_StructCrit.Event_Learn))",Pv,MI,function Fir))call mro(cOe,Xdx("FolderInnerForce_StructCrit_Init: call InnerForce.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInnerForce_StructCrit.Event_Learn))",pv,MI,function Fir))call mro(cOe,Xdx("FolderInnerForce_StructCrit_Init: call InnerForce.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInnerForce_StructCrit.Event_Unlearn))",Av,MI,function Far))endfunctionfunction FVr takes nothing returns booleanset D7e=O5x()set D8e=Xpx(function f1r)set D9e=Xpx(function f2r)call mro(cOe,Xdx("InnerForce_Init: call InnerForce.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function InnerForce.Event_SpellEffect))",ih,MI,function Frr))call Fnr()return trueendfunctionfunction FEr takes nothing returns booleancall cPr(function FVr,"InnerForce_Init")
return trueendfunctionfunction FXr takes nothing returns booleancall L1x('AMon',false)set cXe=L0o('AMon')set K6[(cXe)]=(F6)set m6[(cXe)]=(6)set TH[(cXe)]=("Monolith")set Rh[(cXe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0089)))),(((Aj))))))set oxv[(cXe)]=(2)set x3v[(cXe)]=("spell")
call L1o((cXe),Uvv+(1),((350)*1.))call L1o((cXe),GH+(1),((20)*1.))
call L1o((cXe),tH+(1),((40)*1.))
call L1o((cXe),Lov+(1),((99999)*1.))
call L1o((cXe),Uvv+(2),((350)*1.))call L1o((cXe),GH+(2),((20)*1.))
call L1o((cXe),tH+(2),((50)*1.))
call L1o((cXe),Lov+(2),((99999)*1.))
call L1o((cXe),Uvv+(3),((350)*1.))call L1o((cXe),GH+(3),((20)*1.))
call L1o((cXe),tH+(3),((60)*1.))
call L1o((cXe),Lov+(3),((99999)*1.))
call L1o((cXe),Uvv+(4),((350)*1.))call L1o((cXe),GH+(4),((20)*1.))
call L1o((cXe),tH+(4),((70)*1.))
call L1o((cXe),Lov+(4),((99999)*1.))
call L1o((cXe),Uvv+(5),((350)*1.))call L1o((cXe),GH+(5),((20)*1.))
call L1o((cXe),tH+(5),((80)*1.))
call L1o((cXe),Lov+(5),((99999)*1.))
call L1o((cXe),Uvv+(6),((350)*1.))call L1o((cXe),GH+(6),((20)*1.))
call L1o((cXe),tH+(6),((90)*1.))
call L1o((cXe),Lov+(6),((99999)*1.))
set MOv[(cXe)]=("ReplaceableTextures\\CommandButtons\\BTNResStone.blp")call cDr(cXe,'FMo0',6,'VMo0','LPMo','LRMo')set fGe[1]=$Fset fGe[2]=$Fset fGe[3]=$Fset fGe[4]=$Fset fGe[5]=$Fset fGe[6]=$Fset fhe[1]=650set fhe[2]=650set fhe[3]=650set fhe[4]=650set fhe[5]=650set fhe[6]=650set fHe[1]=$Fset fHe[2]=25set fHe[3]=35set fHe[4]=45set fHe[5]=55set fHe[6]=65return trueendfunctionfunction FOr takes nothing returns booleanset fje=hjo('uMon')call hJo(((fje)),ASv,(Igv))set Uj[(fje)]=((1)*1.)call hko(fje,$FF,$FF,$FF,$FF)set NOv[(fje)]=(('d')*1.)set NWv[(fje)]=(('d')*1.)set I8v[(fje)]=((0)*1.)set Anv[(fje)]=(3)set Nmv[(fje)]=(($C8)*1.)set NLv[(fje)]=(($C8)*1.)set NKv[(fje)]=((0)*1.)set Npv[(fje)]=((0)*1.)set NMv[(fje)]=((0)*1.)set Nlv[(fje)]=((0)*1.)set Ncv[(fje)]=((800)*1.)set Nbv[(fje)]=((800)*1.)set NGv[(fje)]=((0)*1.)set Auv[(fje)]=((0)*1.)set AUv[(fje)]=((0)*1.)set AYv[(fje)]=(0)set A_v[(fje)]=(0)set ATv[(fje)]=((64)*1.)
call hpo((fje),(fJe),1)return trueendfunctionfunction FRr takes nothing returns booleancall VNx(Pa,(function FXr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Monolith.page\\Monolith.struct\\obj_thisSpell_wc3spell.j"))
call VNx(sa,(function FOr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Monolith.page\\Monolith.struct\\obj_MonolithType_wc3unit.j"))return trueendfunctionfunction FIr takes nothing returns booleanset fke=VXx(fKe)
return trueendfunctionfunction FAr takes code c,string rSx returns nothing
set Ln=Ln+1set mn[Ln]=CreateTrigger()set Mn[Ln]=(GetHandleId(Condition((c))))
set pn[Ln]=rSxcall TriggerAddCondition(mn[Ln],Condition(c))endfunctionfunction FNr takes nothing returns booleanlocal integer Iix=jhx()if(Iix==Rb)thenreturn false
endifif(I8x((Ose),Ob,(Iix)))thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifreturn truereturn trueendfunctionfunction Fbr takes integer oSx returns integerset fqe[oSx]=trueset fQe[oSx]=falsecall rEx(fke)return oSxendfunctionfunction FBr takes nothing returns integerlocal integer oSxif(fme==8190)thencall o_x("Monolith_Allocation_allocCustom","call DebugEx(Monolith.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",fKe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(fMe[(w)]==w)thenset fpe=fpe+1set oSx=fpeelse
set oSx=fMe[(w)]
set fMe[(w)]=fMe[fMe[(w)]]endifset fMe[oSx]=Zset fPe[oSx]=1call Fbr(oSx)return oSxendfunctionfunction Fcr takes integer oSx returns nothingset fqe[oSx]=falsecall rHx(fke)endfunctionfunction FCr takes integer oSx returns nothingif(fPe[oSx]>0)thenreturnendifif(fMe[oSx]!=Z)thencall o_x("Monolith_Allocation_deallocCustom_confirm","call DebugEx(Monolith.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",fKe+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset fMe[oSx]=fMe[(w)]set fMe[(w)]=oSx
call Fcr(oSx)endfunctionfunction Fdr takes integer oSx returns nothingset fPe[oSx]=fPe[oSx]-1call FCr(oSx)endfunctionfunction FDr takes integer Ffr,integer Cqx,integer rYx returns nothingcall SetUnitAnimation(C[((Ffr))],("work"))call Dux(Ffr,fYe,rYx,Cqx)endfunctionfunction FFr takes integer Cqx,integer rYx,real x,real y returns nothing
local integer Ffr=U0o(fje,(ze[(Cqx)]),x,y,kf,fGe[rYx])call FDr(Ffr,Cqx,rYx)endfunctionfunction Fgr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=fse[oSx]local integer rYx=fTe[oSx]local integer Q9o=fWe[oSx]local real x=(mHv[(Mho)])local real y=(mjv[(Mho)])call Fdr((oSx))call MFo(Mho)call iKx(Q9o)call FFr(Cqx,rYx,x,y)return trueendfunctionfunction FGr takes integer oSx,real o5x returns nothingset myv[oSx]=o5x
set mdv[oSx]=truecall MZo(oSx)endfunctionfunction Fhr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=fse[oSx]local integer Mho=fte[oSx]local integer svo=fue[oSx]local integer C3o=(ze[(Cqx)])local real x=(mHv[(Mho)])local real y=(mjv[(Mho)])local integer Iixlocal real Nboset Rb=Cqxset hf=C3oset Ose=svocall VKr(fle,(mHv[(Mho)]),(mjv[(Mho)]),(mJv[(Mho)]),(mCv[(Mho)]),fLe)set Iix=NEo(fle)
if(Iix!=w)thenset Nbo=fSe[oSx]
loop
call dQx(svo,Iix)call Ryx((ACx((Iix),(fZe),(f_e),(Bi))))call Our(Iix,(mLv[(Mho)]),(mav[(Mho)]),(Atan2((((GetUnitY(C[((Iix))]))-y)*1.),(((GetUnitX(C[((Iix))]))-x)*1.))),1.)if not(IsUnitAlly(C[(Iix)],vx[(C3o)]))thencall nlo((Cqx),(Iix),((Nbo)*1.),(false),(false))
endifset Iix=NEo(fle)
exitwhen(Iix==w)
endloopendifendfunctionfunction FHr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real rPr=fhe[rYx]local real bex=Ufx(Cqx,dVx-wQo,dEx-wso)local integer oSxlocal integer Mholocal integer Q9olocal real Fjrlocal real Nlxlocal real n2rset dVx=wQo+rPr*(Cos(((((bex)*1.))*1.)))
set dEx=wso+rPr*(Sin(((((bex)*1.))*1.)))
set oSx=FBr()set Mho=Moo()set Q9o=iXx()set fse[oSx]=Cqx
set fSe[oSx]=fHe[rYx]set fte[oSx]=Mho
set fTe[oSx]=rYx
set fue[oSx]=Jbx("Monolith_Event_SpellEffect: set this.targetGroup = UnitList.Create()")
set fUe[oSx]=dVx
set fwe[oSx]=dEx
set fWe[oSx]=Q9o
set ge[(Q9o)]=(oSx)set Fjr=1.set Nlx=800.
set n2r=-Nlx*Nlx*1./(2*(rPr+Fjr))call m4o(Mho,n2r)set mCv[(Mho)]=((fye)*1.)set mFv[(Mho)]=Xkx((function Fgr))set mZv[(Mho)]=(oSx)
call Meo(Mho,Nlx)call pxo(Mho,Cqx)call o9r(Mho,dVx,dEx,X_x(dVx,dEx)+60.)call FGr(Mho,kf)
call Mno(Mho,'qMon',.75)
call iDx(Q9o,fze,true,function Fhr)return trueendfunctionfunction FJr takes nothing returns booleanset fle=O5x()set fLe=Xpx(function FNr)call mro(cXe,Xdx("Monolith_Init: call Monolith.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Monolith.Event_SpellEffect))",ih,MI,function FHr))return trueendfunctionfunction Fkr takes nothing returns booleancall FAr(function FJr,"Monolith_Init")return trueendfunctionfunction FKr takes nothing returns booleanset f0e=Wwx('BMoM',"Monolith - Mana Regen",'bMoM')set aav[(f0e)]=(true)set anv[(f0e)]=("ReplaceableTextures\\CommandButtons\\BTNResStone.blp")call lWx(f0e,"Abilities\\Spells\\Other\\GeneralAuraTarget\\GeneralAuraTarget.mdl","origin",ri)set WU=l_x()
call l2x(WU,Dkv,5)call l3x(((f0e)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,Dkv,6.5)
call l3x(((f0e)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,Dkv,8)call l3x(((f0e)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,Dkv,9.5)
call l3x(((f0e)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,Dkv,$B)call l3x(((f0e)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,Dkv,12.5)call l3x(((f0e)),ZB+(6),(WU))return trueendfunctionfunction Flr takes nothing returns booleanset f1e[1]=5
set f1e[2]=6.5set f1e[3]=8
set f1e[4]=9.5set f1e[5]=$Bset f1e[6]=12.5return trueendfunctionfunction FLr takes nothing returns booleancall VNx(ma,(function FKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Monolith.page\\Monolith.struct\\SacredAura.page\\SacredAura.struct\\Target\\obj_dummyBuff_wc3buff.j"))call VNx(va,(function Flr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Monolith.page\\Monolith.struct\\SacredAura.page\\SacredAura.struct\\Target\\obj_this_wc3obj.j"))return trueendfunctionfunction Fmr takes nothing returns booleanset f2e=VXx(f3e)
return trueendfunctionfunction FMr takes nothing returns booleancall L1x('ASaA',false)set f4e=L0o('ASaA')set K6[(f4e)]=(H6)set m6[(f4e)]=(1)set TH[(f4e)]=("Sacred Aura")set x3v[(f4e)]=("spell")
call L1o((f4e),Uvv+(1),((350)*1.))call L1o((f4e),Lov+(1),((750)*1.))set MOv[(f4e)]=("ReplaceableTextures\\PassiveButtons\\PASBTNBrilliance.blp")
return trueendfunctionfunction Fpr takes nothing returns booleanset fYe=Wwx('BMoA',"Monolith Aura",'bMoA')set aav[(fYe)]=(true)set anv[(fYe)]=("ReplaceableTextures\\CommandButtons\\BTNResStone.blp")call lWx(fYe,"Monolith_page\\Monolith_struct\\SacredAura_page\\SacredAura_struct\\Aura.mdx","origin",ri)
call lWx(fYe,"Monolith_page\\Monolith_struct\\SacredAura_page\\SacredAura_struct\\AuraHead.mdx","overhead",Bi)return trueendfunctionfunction FPr takes nothing returns booleancall VNx(Pa,(function FMr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Monolith.page\\Monolith.struct\\SacredAura.page\\SacredAura.struct\\obj_thisSpell_wc3spell.j"))
call VNx(ma,(function Fpr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Monolith.page\\Monolith.struct\\SacredAura.page\\SacredAura.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction Fqr takes nothing returns booleanset f5e=VXx(f6e)
return trueendfunctionfunction FQr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif not(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction Fsr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Lc[(rFx)])local integer Ffr=(Vv[(rFx)])local integer rYx=(hc[(rFx)])local integer oSx=Ffrlocal integer Xur=XQr(Ffr)set f8e[oSx]=Xur
set f9e[oSx]=Cqx
set Fve[oSx]=rYx
set Ene[(Xur)]=(oSx)
set vqe[(Xur)]=(((CQx((cXe),Uvv+(rYx))))*1.)
set vQe[(Xur)]=(f7e)
call Xsr(Xur,Fee)call Xsr(Xur,Fxe)call Xtr(Xur)return trueendfunctionfunction FSr takes nothing returns booleanlocal integer rFx=(bv)local integer Ffr=(Vv[(rFx)])local integer oSx=Ffrlocal integer Xur=f8e[oSx]call X5r(Xur)return trueendfunctionfunction Ftr takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer rLx=(Ene[(Xur)])call Ulx(Iix,f0e)return trueendfunctionfunction FTr takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer Cqx=(vke[(Xur)])local integer rLx=(Ene[(Xur)])local integer rYx=Fve[rLx]call Dux((Iix),(f0e),(rYx),w)return trueendfunctionfunction Fur takes nothing returns nothingset Fee=Xdx("FolderSacredAura_StructTarget_Init: set FolderSacredAura_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderSacredAura_StructTarget.Event_Ending)",vTe,MI,function Ftr)set Fxe=Xdx("FolderSacredAura_StructTarget_Init: set FolderSacredAura_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderSacredAura_StructTarget.Event_Start)",vue,MI,function FTr)endfunctionfunction FUr takes nothing returns booleanset f7e=Xpx(function FQr)call Lxx(fYe,Xdx("SacredAura_Init: call SacredAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SacredAura.Event_BuffGain))",bd,MI,function Fsr))call Lxx(fYe,Xdx("SacredAura_Init: call SacredAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SacredAura.Event_BuffLose))",jc,MI,function FSr))call Fur()return trueendfunctionfunction Fwr takes nothing returns booleancall FAr(function FUr,"SacredAura_Init")
return trueendfunctionfunction FWr takes nothing returns booleanset Foe=Wwx('BSev',"Severance",'bSev')set uU[(Foe)]=(true)
set anv[(Foe)]=("ReplaceableTextures\\CommandButtons\\BTNAcidBomb.blp")call lWx(Foe,"Abilities\\Spells\\Undead\\UnholyFrenzy\\UnholyFrenzyTarget.mdl","overhead",ri)set WU=l_x()
call l2x(WU,dXv,-3)call l2x(WU,dmv,-30)
call l3x(((Foe)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,dXv,-6)call l2x(WU,dmv,-40)
call l3x(((Foe)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,dXv,-9)call l2x(WU,dmv,-50)
call l3x(((Foe)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,dXv,-$C)
call l2x(WU,dmv,-60)
call l3x(((Foe)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,dXv,-$F)
call l2x(WU,dmv,-70)
call l3x(((Foe)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,dXv,-18)
call l2x(WU,dmv,-80)
call l3x(((Foe)),ZB+(6),(WU))return trueendfunctionfunction Fyr takes nothing returns booleanset Fre[1]=-3set Fre[2]=-6set Fre[3]=-9set Fre[4]=-$Cset Fre[5]=-$Fset Fre[6]=-18set Fie[1]=-30set Fie[2]=-40set Fie[3]=-50set Fie[4]=-60set Fie[5]=-70set Fie[6]=-80set Fae[1]=$Aset Fae[2]=$Aset Fae[3]=$Aset Fae[4]=$Aset Fae[5]=$Aset Fae[6]=$Areturn trueendfunctionfunction FYr takes nothing returns booleancall VNx(ma,(function FWr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Severance.page\\Severance.struct\\Buff\\obj_dummyBuff_wc3buff.j"))call VNx(va,(function Fyr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Severance.page\\Severance.struct\\Buff\\obj_this_wc3obj.j"))return trueendfunctionfunction Fzr takes nothing returns booleanset Fne=VXx(FVe)
return trueendfunctionfunction FZr takes nothing returns booleancall L1x('ASev',false)set Gmv=L0o('ASev')set K6[(Gmv)]=(F6)set m6[(Gmv)]=(6)set TH[(Gmv)]=("Severance")set Rh[(Gmv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D026C)))),(((Aj))))))set oxv[(Gmv)]=(4)set x3v[(Gmv)]=("spell")
call L1o((Gmv),Uvv+(1),((500)*1.))call L1o((Gmv),GH+(1),(($C)*1.))
call L1o((Gmv),tH+(1),((40)*1.))
call L1o((Gmv),Lov+(1),((800)*1.))call L1o((Gmv),Uvv+(2),((500)*1.))call L1o((Gmv),GH+(2),(($C)*1.))
call L1o((Gmv),tH+(2),((50)*1.))
call L1o((Gmv),Lov+(2),((800)*1.))call L1o((Gmv),Uvv+(3),((500)*1.))call L1o((Gmv),GH+(3),(($C)*1.))
call L1o((Gmv),tH+(3),((65)*1.))
call L1o((Gmv),Lov+(3),((800)*1.))call L1o((Gmv),Uvv+(4),((500)*1.))call L1o((Gmv),GH+(4),(($C)*1.))
call L1o((Gmv),tH+(4),((85)*1.))
call L1o((Gmv),Lov+(4),((800)*1.))call L1o((Gmv),Uvv+(5),((500)*1.))call L1o((Gmv),GH+(5),(($C)*1.))
call L1o((Gmv),tH+(5),(('n')*1.))call L1o((Gmv),Lov+(5),((800)*1.))call L1o((Gmv),Uvv+(6),((500)*1.))call L1o((Gmv),GH+(6),(($C)*1.))
call L1o((Gmv),tH+(6),(($8C)*1.))call L1o((Gmv),Lov+(6),((800)*1.))set MOv[(Gmv)]=("ReplaceableTextures\\CommandButtons\\BTNAcidBomb.blp")call cDr(Gmv,'FSV0',6,'VSV0','LPSV','LRSV')set FEe[1]=5
set FEe[2]=6
set FEe[3]=7
set FEe[4]=8
set FEe[5]=9
set FEe[6]=$Aset FXe[1]=20set FXe[2]=30set FXe[3]=40set FXe[4]=50set FXe[5]=60set FXe[6]=70return trueendfunctionfunction F_r takes nothing returns booleancall VNx(Pa,(function FZr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Severance.page\\Severance.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction F0r takes nothing returns booleanset FOe=VXx(FRe)
return trueendfunctionfunction F1r takes integer Iix returns booleanreturn( not(I9x(Iix,Qc)))and( not(I9x(Iix,Ifv)))and( not(IsUnitAlly(C[(Iix)],vx[(hf)])))and( not(nbo(Iix)))endfunctionfunction F2r takes nothing returns booleanlocal integer Iix=jhx()if(I8x((Ose),Ob,(Iix)))thenreturn false
endifif not F1r(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction F3r takes integer oSx returns integerset FCe[oSx]=trueset Fde[oSx]=falsecall rEx(FOe)return oSxendfunctionfunction F4r takes nothing returns integerlocal integer oSxif(FNe==8190)thencall o_x("Severance_Allocation_allocCustom","call DebugEx(Severance.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",FRe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Fbe[(w)]==w)thenset FBe=FBe+1set oSx=FBeelse
set oSx=Fbe[(w)]
set Fbe[(w)]=Fbe[Fbe[(w)]]endifset Fbe[oSx]=Zset Fce[oSx]=1call F3r(oSx)return oSxendfunctionfunction F5r takes integer rYx,integer Iix returns nothingcall Nbx((Iix),(Foe),(rYx),w,((Fae[rYx])*1.))endfunctionfunction F6r takes integer oSx returns nothingset FCe[oSx]=falsecall rHx(FOe)endfunctionfunction F7r takes integer oSx returns nothingif(Fce[oSx]>0)thenreturnendifif(Fbe[oSx]!=Z)thencall o_x("Severance_Allocation_deallocCustom_confirm","call DebugEx(Severance.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",FRe+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Fbe[oSx]=Fbe[(w)]set Fbe[(w)]=oSx
call F6r(oSx)endfunctionfunction F8r takes integer oSx returns nothingset Fce[oSx]=Fce[oSx]-1call F7r(oSx)endfunctionfunction F9r takes integer oSx returns nothingcall F8r((oSx))call X_r(Fhe[oSx])endfunctionfunction gvr takes integer oSx,real jMx,real jpx,real cJo,integer Iix returns nothingset Od=oSxset Mxv=jMxset Mov=jpxset Mrv=cJoset Rd=Iixcall TriggerEvaluate(Fke)endfunctionfunction ger takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=Ffe[oSx]local integer EDr=FGe[oSx]local integer Efr=FHe[oSx]local integer Iix=Fje[oSx]local integer svo=Fhe[oSx]local real dVx=(mHv[(Mho)])local real dEx=(mjv[(Mho)])local real MQx=(mJv[(Mho)])local real Nbocall MFo(Mho)if(Iix!=w)thenset hf=(ze[(Cqx)])if F1r(Iix)thenset Nbo=FFe[oSx]
call nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))set FFe[oSx]=Nbo*(1.-FJe)call F5r(Fge[oSx],Iix)endifendifif(Efr==EDr)then
call F9r(oSx)else
set Ose=svoset hf=(ze[(Cqx)])call NVo(FIe,dVx,dEx,FDe[oSx],FAe)if(Iix!=w)thencall GroupRemoveUnit(kb[(FIe)],C[(Iix)])
call IRo(svo,Iix)endifset Iix=(mKo((FIe),((dVx)*1.),((dEx)*1.)))if(Iix==w)thencall F9r(oSx)else
set FHe[oSx]=Efr+1call gvr(oSx,dVx,dEx,MQx,Iix)endifendifreturn trueendfunctionfunction gxr takes integer oSx,real jMx,real jpx,real cJo,integer Iix returns nothinglocal integer Mho=Moo()set Fje[oSx]=Iix
call dQx(Fhe[oSx],Iix)set mCv[(Mho)]=((10.)*1.)call Mno(Mho,'qSev',2.)set mFv[(Mho)]=Xkx((function ger))set mZv[(Mho)]=(oSx)
call Meo(Mho,900.)call MUo(Mho,jMx,jpx,cJo)call M6o((Mho),(Iix),.0,.0,.0,(null))endfunctionfunction gor takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local integer oSx=F4r()set FDe[oSx]=(CQx((Gmv),Uvv+(rYx)))set Ffe[oSx]=Cqx
set FFe[oSx]=FXe[rYx]set Fge[oSx]=rYx
set FGe[oSx]=FEe[rYx]set Fhe[oSx]=Jbx("Severance_Event_SpellEffect: set this.targetGroup = UnitList.Create()")set FHe[oSx]=1call gxr(oSx,wQo,wso,OMx(Cqx,wQo,wso)+Opx(Cqx,true),Iix)
return trueendfunctionfunction grr takes nothing returns booleanset FIe=O5x()set FAe=Xpx(function F2r)call mro(Gmv,Xdx("Severance_Init: call Severance.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Severance.Event_SpellEffect))",ih,MI,function gor))
call W2x(ECv,Foe)return trueendfunctionfunction gir takes nothing returns booleancall cPr(function grr,"Severance_Init")return trueendfunctionfunction gar takes nothing returns booleanset FKe[1]=700set FKe[2]=700set FKe[3]=700set FKe[4]=700set FKe[5]=700set FKe[6]=700set Fle[1]=7
set Fle[2]=$Dset Fle[3]=21set Fle[4]=31set Fle[5]=43set Fle[6]=57set FLe[1]=50set FLe[2]=50set FLe[3]=50set FLe[4]=50set FLe[5]=50set FLe[6]=50set Fme[1]=400set Fme[2]=500set Fme[3]=600set Fme[4]=700set Fme[5]=800set Fme[6]=900return trueendfunctionfunction gnr takes nothing returns booleancall VNx(va,(function gar),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\SnowySphere.page\\SnowySphere.struct\\Particle\\obj_this_wc3obj.j"))return trueendfunctionfunction gVr takes nothing returns booleanset FMe=VXx(Fpe)
return trueendfunctionfunction gEr takes nothing returns booleancall L1x('ASnS',false)set FPe=L0o('ASnS')set K6[(FPe)]=(F6)set m6[(FPe)]=(6)set TH[(FPe)]=("Snowy Sphere")set Rh[(FPe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D02B6)))),(((Aj))))))set oxv[(FPe)]=(2)set x3v[(FPe)]=("spell")
call L1o((FPe),Uvv+(1),((75)*1.))call L1o((FPe),GH+(1),(($F)*1.))
call L1o((FPe),Lov+(1),((500)*1.))call L1o((FPe),Uvv+(2),((75)*1.))call L1o((FPe),GH+(2),(($F)*1.))
call L1o((FPe),Lov+(2),((500)*1.))call L1o((FPe),Uvv+(3),((75)*1.))call L1o((FPe),GH+(3),(($F)*1.))
call L1o((FPe),Lov+(3),((500)*1.))call L1o((FPe),Uvv+(4),((75)*1.))call L1o((FPe),GH+(4),(($F)*1.))
call L1o((FPe),Lov+(4),((500)*1.))call L1o((FPe),Uvv+(5),((75)*1.))call L1o((FPe),GH+(5),(($F)*1.))
call L1o((FPe),Lov+(5),((500)*1.))call L1o((FPe),Uvv+(6),((75)*1.))call L1o((FPe),GH+(6),(($F)*1.))
call L1o((FPe),Lov+(6),((500)*1.))set MOv[(FPe)]=("ReplaceableTextures\\CommandButtons\\BTNTornado.blp")set Fqe[1]=$Eset Fqe[2]=$Eset Fqe[3]=$Eset Fqe[4]=$Eset Fqe[5]=$Eset Fqe[6]=$Eset FQe[1]=800set FQe[2]=800set FQe[3]=800set FQe[4]=800set FQe[5]=800set FQe[6]=800set Fse[1]=800set Fse[2]=800set Fse[3]=800set Fse[4]=800set Fse[5]=800set Fse[6]=800set FSe[1]=20set FSe[2]=30set FSe[3]=40set FSe[4]=50set FSe[5]=60set FSe[6]=70return trueendfunctionfunction gXr takes nothing returns booleancall VNx(Pa,(function gEr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\SnowySphere.page\\SnowySphere.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction gOr takes nothing returns booleanset Fte=VXx(FTe)
return trueendfunctionfunction gRr takes integer oSx returns integerset Fye[oSx]=trueset FYe[oSx]=falsecall rEx(Fte)return oSxendfunctionfunction gIr takes nothing returns integerlocal integer oSxif(Fue==8190)thencall o_x("SnowySphere_Allocation_allocCustom","call DebugEx(SnowySphere.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",FTe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(FUe[(w)]==w)thenset Fwe=Fwe+1set oSx=Fweelse
set oSx=FUe[(w)]
set FUe[(w)]=FUe[FUe[(w)]]endifset FUe[oSx]=Zset FWe[oSx]=1call gRr(oSx)return oSxendfunctionfunction gAr takes integer oSx returns integerset gVe[oSx]=trueset gEe[oSx]=falsecall rEx(FMe)return oSxendfunctionfunction gNr takes nothing returns integerlocal integer oSxif(gre==8190)thencall o_x("FolderSnowySphere_StructParticle_Allocation_allocCustom","call DebugEx(FolderSnowySphere_StructParticle.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Fpe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(gie[(w)]==w)thenset gae=gae+1set oSx=gaeelse
set oSx=gie[(w)]
set gie[(w)]=gie[gie[(w)]]endifset gie[oSx]=Zset gne[oSx]=1call gAr(oSx)return oSxendfunctionfunction gbr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=gOe[oSx]local integer HAx=gIe[oSx]local integer svo=gAe[oSx]local real x=(iJ[(HAx)])+gbe[oSx]local real y=(EJ[(HAx)])+gce[oSx]local integer Iixlocal real Nbocall MLo(HAx,x,y,(Au[(HAx)]))set Ose=svoset hf=(ze[(Cqx)])call NVo(gDe,x,y,gXe[oSx],gfe)set Iix=NEo(gDe)
if(Iix!=w)thenset Nbo=gRe[oSx]
loop
call dQx(svo,Iix)call nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))set Iix=NEo(gDe)
exitwhen(Iix==w)
endloopendifendfunctionfunction gBr takes integer oSx returns nothingset gVe[oSx]=falsecall rHx(FMe)endfunctionfunction gcr takes integer oSx returns nothingif(gne[oSx]>0)thenreturnendifif(gie[oSx]!=Z)thencall o_x("FolderSnowySphere_StructParticle_Allocation_deallocCustom_confirm","call DebugEx(FolderSnowySphere_StructParticle.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Fpe+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset gie[oSx]=gie[(w)]set gie[(w)]=oSx
call gBr(oSx)endfunctionfunction gCr takes integer oSx returns nothingset gne[oSx]=gne[oSx]-1call gcr(oSx)endfunctionfunction gdr takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local integer HAx=gIe[oSx]local integer svo=gAe[oSx]local integer Q9o=gNe[oSx]local integer Ctx=gCe[oSx]call gCr((oSx))call Mfx(HAx)call iKx(iCx)call X_r(svo)call iKx(Q9o)call Usx(Ctx)endfunctionfunction gDr takes real bex,integer Cqx,real Nbo,integer rYx,integer Ctx,real x,real y,real z returns nothinglocal integer oSx=gNr()local integer iCx=iXx()local integer HAx=mDx('qSnP',x,y,z,bex)local integer Q9o=iXx()set gXe[oSx]=FLe[rYx]set gOe[oSx]=Cqx
set gRe[oSx]=Nbo
set gIe[oSx]=HAx
set gAe[oSx]=Jbx("FolderSnowySphere_StructParticle_Start: set this.targetGroup = UnitList.Create()")
set gNe[oSx]=Q9o
set gbe[oSx]=gBe[rYx]*(Cos(((((bex)*1.))*1.)))set gce[oSx]=gBe[rYx]*(Sin(((((bex)*1.))*1.)))set gCe[oSx]=Ctx
set ge[(iCx)]=(oSx)set ge[(Q9o)]=(oSx)call Ucx(Ctx)call iDx(Q9o,gde,true,function gbr)call iDx(iCx,gFe[rYx],false,function gdr)endfunctionfunction gfr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local real bex=F2e[oSx]+F3e[oSx]
local integer HAx=F_e[oSx]set F2e[oSx]=bex
call gDr(bex,Fze[oSx],FZe[oSx],F1e[oSx],F9e[oSx],(iJ[(HAx)])+F5e[oSx],(EJ[(HAx)])+F7e[oSx],(Au[(HAx)]))endfunctionfunction gFr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer HAx=F_e[oSx]call MLo(HAx,(iJ[(HAx)])+gve[oSx],(EJ[(HAx)])+gxe[oSx],(Au[(HAx)]))endfunctionfunction ggr takes integer oSx returns nothingset Fye[oSx]=falsecall rHx(Fte)endfunctionfunction gGr takes integer oSx returns nothingif(FWe[oSx]>0)thenreturnendifif(FUe[oSx]!=Z)thencall o_x("SnowySphere_Allocation_deallocCustom_confirm","call DebugEx(SnowySphere.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",FTe+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset FUe[oSx]=FUe[(w)]set FUe[(w)]=oSx
call ggr(oSx)endfunctionfunction ghr takes integer oSx returns nothingset FWe[oSx]=FWe[oSx]-1call gGr(oSx)endfunctionfunction gHr takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local integer HAx=F_e[oSx]local integer p3x=F0e[oSx]local integer Q9o=F8e[oSx]local integer Ctx=F9e[oSx]call ghr((oSx))call MGx(HAx)call iKx(iCx)call iKx(p3x)call iKx(Q9o)call dNx(Ctx)endfunctionfunction gjr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real VMr=fYx(Cqx)+Opx(Cqx,true)local real bex=Ufx(Cqx,dVx-wQo,dEx-wso)local real I2o=(Cos(((((bex)*1.))*1.)))local real I3o=(Sin(((((bex)*1.))*1.)))local integer oSx=gIr()local integer HAx=mDx('qSnS',wQo,wso,VMr,bex)local integer iCx=iXx()local integer p3x=iXx()local integer Q9o=iXx()local integer Ctx=CPx(Cqx,FPe)set Fze[oSx]=Cqx
set FZe[oSx]=Fle[rYx]set F_e[oSx]=HAx
set F0e[oSx]=p3x
set F1e[oSx]=rYx
set F2e[oSx]=bex
set F3e[oSx]=F4e[rYx]set F5e[oSx]=F6e*I2o
set F7e[oSx]=F6e*I3o
set F8e[oSx]=Q9o
set F9e[oSx]=Ctx
set gve[oSx]=gee[rYx]*I2oset gxe[oSx]=gee[rYx]*I3oset ge[(iCx)]=(oSx)set ge[(p3x)]=(oSx)set ge[(Q9o)]=(oSx)call iDx(p3x,goe[rYx],true,function gfr)
call iDx(Q9o,gge,true,function gFr)call iDx(iCx,gGe[rYx],false,function gHr)return trueendfunctionfunction gJr takes nothing returns booleanlocal integer Iix=jhx()if(I8x((Ose),Ob,(Iix)))thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction gkr takes nothing returns nothinglocal integer oMxset gDe=O5x()set gfe=Xpx(function gJr)set oMx=(m6[(FPe)])loop
set gFe[oMx]=Fme[oMx]*1./ FKe[oMx]set gBe[oMx]=FKe[oMx]*gdeset oMx=oMx-1exitwhen(oMx<1)endloopendfunctionfunction gKr takes nothing returns booleanlocal integer oMxcall mro(FPe,Xdx("SnowySphere_Init: call SnowySphere.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SnowySphere.Event_SpellEffect))",ih,MI,function gjr))set oMx=(m6[(FPe)])loop
set gGe[oMx]=FQe[oMx]*1./ Fse[oMx]set gee[oMx]=Fse[oMx]*ggeset goe[oMx]=gGe[oMx]*1./ FSe[oMx]set F4e[oMx]=Fqe[oMx]*goe[oMx]*1./ gGe[oMx]set oMx=oMx-1exitwhen(oMx<1)endloopcall gkr()return trueendfunctionfunction glr takes nothing returns booleancall cPr(function gKr,"SnowySphere_Init")return trueendfunctionfunction gLr takes nothing returns booleancall L1x('AThS',false)set cRe=L0o('AThS')set K6[(cRe)]=(F6)set m6[(cRe)]=(6)set TH[(cRe)]=("Thunderstrike")set Rh[(cRe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0080)))),(((Aj))))))set oxv[(cRe)]=(2)set x3v[(cRe)]=("spell")
call L1o((cRe),Uvv+(1),((350)*1.))call L1o((cRe),GH+(1),((9)*1.))call L1o((cRe),tH+(1),((90)*1.))
call L1o((cRe),Lov+(1),(($3E8)*1.))call L1o((cRe),Uvv+(2),((400)*1.))call L1o((cRe),GH+(2),((9)*1.))call L1o((cRe),tH+(2),(('i')*1.))call L1o((cRe),Lov+(2),(($3E8)*1.))call L1o((cRe),Uvv+(3),((450)*1.))call L1o((cRe),GH+(3),((9)*1.))call L1o((cRe),tH+(3),(('x')*1.))call L1o((cRe),Lov+(3),(($3E8)*1.))call L1o((cRe),Uvv+(4),((500)*1.))call L1o((cRe),GH+(4),((9)*1.))call L1o((cRe),tH+(4),(($87)*1.))call L1o((cRe),Lov+(4),(($3E8)*1.))call L1o((cRe),Uvv+(5),((550)*1.))call L1o((cRe),GH+(5),((9)*1.))call L1o((cRe),tH+(5),(($96)*1.))call L1o((cRe),Lov+(5),(($3E8)*1.))call L1o((cRe),Uvv+(6),((600)*1.))call L1o((cRe),GH+(6),((9)*1.))call L1o((cRe),tH+(6),(($A5)*1.))call L1o((cRe),Lov+(6),(($3E8)*1.))set MOv[(cRe)]=("ReplaceableTextures\\CommandButtons\\BTNMonsoon.blp")call cDr(cRe,'FTh0',6,'VTh0','LPTh','LRTh')set ghe[1]=2
set ghe[2]=2.25set ghe[3]=2.5set ghe[4]=2.75set ghe[5]=3
set ghe[6]=3.25set gHe[1]=1.5set gHe[2]=1.75set gHe[3]=2
set gHe[4]=2.25set gHe[5]=2.5set gHe[6]=2.75set gje[1]=50set gje[2]=75set gje[3]='d'set gje[4]='}'set gje[5]=$96set gje[6]=$AFreturn trueendfunctionfunction gmr takes nothing returns booleancall VNx(Pa,(function gLr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\Thunderstrike.page\\Thunderstrike.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction gMr takes nothing returns booleanset gJe=VXx(gke)
return trueendfunctionfunction gpr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction gPr takes integer oSx returns integerset gPe[oSx]=trueset gqe[oSx]=falsecall rEx(gJe)return oSxendfunctionfunction gqr takes nothing returns integerlocal integer oSxif(gLe==8190)thencall o_x("Thunderstrike_Allocation_allocCustom","call DebugEx(Thunderstrike.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",gke+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(gme[(w)]==w)thenset gMe=gMe+1set oSx=gMeelse
set oSx=gme[(w)]
set gme[(w)]=gme[gme[(w)]]endifset gme[oSx]=Zset gpe[oSx]=1call gPr(oSx)return oSxendfunctionfunction gQr takes integer oSx,real I4o,real iMx returns nothing
if(iMx>0)thencall SetUnitFlyHeight(vJ[(oSx)],I4o,(I4o-(GetUnitFlyHeight(vJ[((oSx))])))*1./ iMx)else
call SetUnitFlyHeight(vJ[(oSx)],I4o,.0)endifendfunctionfunction gsr takes integer oSx returns nothingset gPe[oSx]=falsecall rHx(gJe)endfunctionfunction gSr takes integer oSx returns nothingif(gpe[oSx]>0)thenreturnendifif(gme[oSx]!=Z)thencall o_x("Thunderstrike_Allocation_deallocCustom_confirm","call DebugEx(Thunderstrike.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",gke+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset gme[oSx]=gme[(w)]set gme[(w)]=oSx
call gsr(oSx)endfunctionfunction gtr takes integer oSx returns nothingset gpe[oSx]=gpe[oSx]-1call gSr(oSx)endfunctionfunction gTr takes nothing returns nothinglocal integer Okx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(Okx)])local real dVx=gUe[oSx]local real dEx=gwe[oSx]local integer Ctx=gye[oSx]local integer rYx=(IH[(Ctx)])local integer gur=mDx('qTSN',dVx,dEx,X_x(dVx,dEx),.0)call gtr((oSx))call iKx(Okx)call Mfx(gue[oSx])call dNx(Ctx)call mCx(gur,(CQx((cRe),Uvv+(rYx)))*1./(100.))call fgo(gur,2.)
endfunctionfunction gUr takes nothing returns nothinglocal integer Okx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(Okx)])local real O4o=gQe[oSx]local integer Cqx=gse[oSx]local integer gwr=gSe[oSx]local real Nbo=gte[oSx]local real dVx=gUe[oSx]local real dEx=gwe[oSx]local integer Ctx=gye[oSx]local integer rYx=(IH[(Ctx)])local integer Iixlocal real gWrlocal real gyrlocal real gYrcall Mfx(gwr)call q_o((mko(((dVx)*1.),((dEx)*1.),(g_e),(ri))),.5)
set hf=(ze[(Cqx)])call NVo(gKe,dVx,dEx,O4o,gle)set Iix=NEo(gKe)
if(Iix!=w)thenset gWr=gHe[rYx]
set gyr=ghe[rYx]
loop
if I9x(Iix,Wd)thenset gYr=gWrelse
set gYr=gyrendifcall Nbx((Iix),(Xwv),(rYx),w,((gYr)*1.))
call nlo((Cqx),(Iix),((Nbo)*1.),(true),(true))set Iix=NEo(gKe)
exitwhen(Iix==w)
endloopendifcall iDx(Okx,.15,false,function gTr)
endfunctionfunction gzr takes integer Cqx,integer rYx,real dVx,real dEx,integer Ctx returns nothing
local real O4o=(CQx((cRe),Uvv+(rYx)))local real MQx=X_x(dVx,dEx)local integer oSx=gqr()local integer gwr=mDx('qThS',dVx,dEx,MQx,kf)
local integer Okx=iXx()local integer gZr=mDx('qTSA',dVx,dEx,MQx,kf)
set gQe[oSx]=O4o
set gse[oSx]=Cqx
set gSe[oSx]=gwr
set gte[oSx]=gje[rYx]set gTe[oSx]=Okx
set gue[oSx]=gZr
set gUe[oSx]=dVx
set gwe[oSx]=dEx
set gWe[oSx]=MQx
set gye[oSx]=Ctx
set ge[(Okx)]=(oSx)call k5o(gZr,O4o*1./(256.*1./ 5))call mdx(gZr,$FF,$FF,$FF,$7F)call gQr(gwr,gYe,gze-gZe)call o_r(gwr,O4o*1./ 128.-1.,gze)call iDx(Okx,gze,false,function gUr)
endfunctionfunction g_r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])call gzr(Cqx,(Mv[(rFx)]),(yH[(rFx)]),(YH[(rFx)]),CPx(Cqx,cRe))return trueendfunctionfunction g0r takes nothing returns booleanset gKe=O5x()set gle=Xpx(function gpr)call mro(cRe,Xdx("Thunderstrike_Init: call Thunderstrike.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Thunderstrike.Event_SpellEffect))",ih,MI,function g_r))
return trueendfunctionfunction g1r takes nothing returns booleancall cPr(function g0r,"Thunderstrike_Init")return trueendfunctionfunction g2r takes nothing returns booleanset g0e[6]=hjo('uTW6')call hJo(((g0e[6])),ASv,(Idv))set Uj[(g0e[6])]=((1.4)*1.)call hko(g0e[6],$C8,$C8,$C8,$FF)
set NOv[(g0e[6])]=((60)*1.)set NWv[(g0e[6])]=((60)*1.)set NPv[(g0e[6])]=((320)*1.)
set I8v[(g0e[6])]=((3)*1.)set Anv[(g0e[6])]=(2)set Nmv[(g0e[6])]=((620)*1.)
set NLv[(g0e[6])]=((620)*1.)
set NKv[(g0e[6])]=((0)*1.)set Npv[(g0e[6])]=((0)*1.)set NMv[(g0e[6])]=((0)*1.)set Nlv[(g0e[6])]=((0)*1.)set Ncv[(g0e[6])]=(($578)*1.)set Nbv[(g0e[6])]=(($578)*1.)set NGv[(g0e[6])]=(('n')*1.)
set Adv[(g0e[6])]=(gkv)set AGv[(g0e[6])]=(('l')*1.)
set Ahv[((g0e[6]))]=((1.*1./((1.35)*1.))*1.)
set AWv[(g0e[6])]=((.33)*1.)
set Auv[(g0e[6])]=((35)*1.)set AUv[(g0e[6])]=((35)*1.)set AYv[(g0e[6])]=(4)set A_v[(g0e[6])]=(5)set A2v[(g0e[6])]=(0)set ATv[(g0e[6])]=((33)*1.)return trueendfunctionfunction g3r takes nothing returns booleanset g0e[1]=hjo('uTW1')call hJo(((g0e[1])),ASv,(Idv))set Uj[(g0e[1])]=((.9)*1.)call hko(g0e[1],$C8,$C8,$C8,$FF)
set NOv[(g0e[1])]=((60)*1.)set NWv[(g0e[1])]=((60)*1.)set NPv[(g0e[1])]=((320)*1.)
set I8v[(g0e[1])]=((0)*1.)set Anv[(g0e[1])]=(2)set Nmv[(g0e[1])]=((90)*1.)set NLv[(g0e[1])]=((90)*1.)set NKv[(g0e[1])]=((0)*1.)set Npv[(g0e[1])]=((0)*1.)set NMv[(g0e[1])]=((0)*1.)set Nlv[(g0e[1])]=((0)*1.)set Ncv[(g0e[1])]=(($578)*1.)set Nbv[(g0e[1])]=(($578)*1.)set NGv[(g0e[1])]=((50)*1.)set Adv[(g0e[1])]=(gkv)set AGv[(g0e[1])]=(('l')*1.)
set Ahv[((g0e[1]))]=((1.*1./((1.35)*1.))*1.)
set AWv[(g0e[1])]=((.33)*1.)
set Auv[(g0e[1])]=((8)*1.)set AUv[(g0e[1])]=((8)*1.)set AYv[(g0e[1])]=(1)set A_v[(g0e[1])]=(5)set A2v[(g0e[1])]=(0)set ATv[(g0e[1])]=((33)*1.)return trueendfunctionfunction g4r takes nothing returns booleanset g0e[2]=hjo('uTW2')call hJo(((g0e[2])),ASv,(Idv))set Uj[(g0e[2])]=((1)*1.)call hko(g0e[2],$C8,$C8,$C8,$FF)
set NOv[(g0e[2])]=((60)*1.)set NWv[(g0e[2])]=((60)*1.)set NPv[(g0e[2])]=((320)*1.)
set I8v[(g0e[2])]=((1)*1.)set Anv[(g0e[2])]=(2)set Nmv[(g0e[2])]=(($87)*1.)
set NLv[(g0e[2])]=(($87)*1.)
set NKv[(g0e[2])]=((0)*1.)set Npv[(g0e[2])]=((0)*1.)set NMv[(g0e[2])]=((0)*1.)set Nlv[(g0e[2])]=((0)*1.)set Ncv[(g0e[2])]=(($578)*1.)set Nbv[(g0e[2])]=(($578)*1.)set NGv[(g0e[2])]=((80)*1.)set Adv[(g0e[2])]=(gkv)set AGv[(g0e[2])]=(('l')*1.)
set Ahv[((g0e[2]))]=((1.*1./((1.35)*1.))*1.)
set AWv[(g0e[2])]=((.33)*1.)
set Auv[(g0e[2])]=(($C)*1.)set AUv[(g0e[2])]=(($C)*1.)set AYv[(g0e[2])]=(2)set A_v[(g0e[2])]=(3)set A2v[(g0e[2])]=(0)set ATv[(g0e[2])]=((33)*1.)return trueendfunctionfunction g5r takes nothing returns booleancall L1x('ATwW',false)set cne=L0o('ATwW')set K6[(cne)]=(F6)set m6[(cne)]=(6)set TH[(cne)]=("Twin Wolves")set Rh[(cne)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D009E)))),(((Aj))))))set oxv[(cne)]=(0)set x3v[(cne)]=("spell")
call L1o((cne),GH+(1),(($F)*1.))
call L1o((cne),tH+(1),(('d')*1.))call L1o((cne),Lov+(1),((750)*1.))call L1o((cne),GH+(2),(($F)*1.))
call L1o((cne),tH+(2),(('d')*1.))call L1o((cne),Lov+(2),((750)*1.))call L1o((cne),GH+(3),(($F)*1.))
call L1o((cne),tH+(3),(('d')*1.))call L1o((cne),Lov+(3),((750)*1.))call L1o((cne),GH+(4),(($F)*1.))
call L1o((cne),tH+(4),(('d')*1.))call L1o((cne),Lov+(4),((750)*1.))call L1o((cne),GH+(5),(($F)*1.))
call L1o((cne),tH+(5),(('d')*1.))call L1o((cne),Lov+(5),((750)*1.))call L1o((cne),GH+(6),(($F)*1.))
call L1o((cne),tH+(6),(('d')*1.))call L1o((cne),Lov+(6),((750)*1.))set MOv[(cne)]=("ReplaceableTextures\\CommandButtons\\BTNWolf.blp")call cDr(cne,'FAW0',6,'VAW0','LPAW','LRAW')return trueendfunctionfunction g6r takes nothing returns booleanset g0e[3]=hjo('uTW3')call hJo(((g0e[3])),ASv,(Idv))set Uj[(g0e[3])]=((1.1)*1.)call hko(g0e[3],$C8,$C8,$C8,$FF)
set NOv[(g0e[3])]=((60)*1.)set NWv[(g0e[3])]=((60)*1.)set NPv[(g0e[3])]=((320)*1.)
set I8v[(g0e[3])]=((1)*1.)set Anv[(g0e[3])]=(2)set Nmv[(g0e[3])]=(($C8)*1.)
set NLv[(g0e[3])]=(($C8)*1.)
set NKv[(g0e[3])]=((0)*1.)set Npv[(g0e[3])]=((0)*1.)set NMv[(g0e[3])]=((0)*1.)set Nlv[(g0e[3])]=((0)*1.)set Ncv[(g0e[3])]=(($578)*1.)set Nbv[(g0e[3])]=(($578)*1.)set NGv[(g0e[3])]=(('n')*1.)
set Adv[(g0e[3])]=(gkv)set AGv[(g0e[3])]=(('l')*1.)
set Ahv[((g0e[3]))]=((1.*1./((1.35)*1.))*1.)
set AWv[(g0e[3])]=((.33)*1.)
set Auv[(g0e[3])]=((16)*1.)set AUv[(g0e[3])]=((16)*1.)set AYv[(g0e[3])]=(3)set A_v[(g0e[3])]=(3)set A2v[(g0e[3])]=(0)set ATv[(g0e[3])]=((33)*1.)return trueendfunctionfunction g7r takes nothing returns booleanset g0e[4]=hjo('uTW4')call hJo(((g0e[4])),ASv,(Idv))set Uj[(g0e[4])]=((1.2)*1.)call hko(g0e[4],$C8,$C8,$C8,$FF)
set NOv[(g0e[4])]=((60)*1.)set NWv[(g0e[4])]=((60)*1.)set NPv[(g0e[4])]=((320)*1.)
set I8v[(g0e[4])]=((2)*1.)set Anv[(g0e[4])]=(2)set Nmv[(g0e[4])]=((315)*1.)
set NLv[(g0e[4])]=((315)*1.)
set NKv[(g0e[4])]=((0)*1.)set Npv[(g0e[4])]=((0)*1.)set NMv[(g0e[4])]=((0)*1.)set Nlv[(g0e[4])]=((0)*1.)set Ncv[(g0e[4])]=(($578)*1.)set Nbv[(g0e[4])]=(($578)*1.)set NGv[(g0e[4])]=(('n')*1.)
set Adv[(g0e[4])]=(gkv)set AGv[(g0e[4])]=(('l')*1.)
set Ahv[((g0e[4]))]=((1.*1./((1.35)*1.))*1.)
set AWv[(g0e[4])]=((.33)*1.)
set Auv[(g0e[4])]=((22)*1.)set AUv[(g0e[4])]=((22)*1.)set AYv[(g0e[4])]=(3)set A_v[(g0e[4])]=(4)set A2v[(g0e[4])]=(0)set ATv[(g0e[4])]=((33)*1.)return trueendfunctionfunction g8r takes nothing returns booleanset g1e[1]=20set g1e[2]=20set g1e[3]=20set g1e[4]=20set g1e[5]=20set g1e[6]=20set g2e[1]=2
set g2e[2]=2
set g2e[3]=2
set g2e[4]=2
set g2e[5]=2
set g2e[6]=2
return trueendfunctionfunction g9r takes nothing returns booleanset g0e[5]=hjo('uTW5')call hJo(((g0e[5])),ASv,(Idv))set Uj[(g0e[5])]=((1.3)*1.)call hko(g0e[5],$C8,$C8,$C8,$FF)
set NOv[(g0e[5])]=((60)*1.)set NWv[(g0e[5])]=((60)*1.)set NPv[(g0e[5])]=((320)*1.)
set I8v[(g0e[5])]=((2)*1.)set Anv[(g0e[5])]=(2)set Nmv[(g0e[5])]=((450)*1.)
set NLv[(g0e[5])]=((450)*1.)
set NKv[(g0e[5])]=((0)*1.)set Npv[(g0e[5])]=((0)*1.)set NMv[(g0e[5])]=((0)*1.)set Nlv[(g0e[5])]=((0)*1.)set Ncv[(g0e[5])]=(($578)*1.)set Nbv[(g0e[5])]=(($578)*1.)set NGv[(g0e[5])]=(('n')*1.)
set Adv[(g0e[5])]=(gkv)set AGv[(g0e[5])]=(('l')*1.)
set Ahv[((g0e[5]))]=((1.*1./((1.35)*1.))*1.)
set AWv[(g0e[5])]=((.33)*1.)
set Auv[(g0e[5])]=((31)*1.)set AUv[(g0e[5])]=((31)*1.)set AYv[(g0e[5])]=(4)set A_v[(g0e[5])]=(4)set A2v[(g0e[5])]=(0)set ATv[(g0e[5])]=((33)*1.)return trueendfunctionfunction Gvr takes nothing returns booleancall VNx(sa,(function g2r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\obj_summonUnitType[6]_wc3unit.j"))call VNx(sa,(function g3r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\obj_summonUnitType[1]_wc3unit.j"))call VNx(sa,(function g4r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\obj_summonUnitType[2]_wc3unit.j"))call VNx(Pa,(function g5r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\obj_thisSpell_wc3spell.j"))
call VNx(sa,(function g6r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\obj_summonUnitType[3]_wc3unit.j"))call VNx(sa,(function g7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\obj_summonUnitType[4]_wc3unit.j"))call VNx(va,(function g8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\obj_this_wc3obj.j"))call VNx(sa,(function g9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\obj_summonUnitType[5]_wc3unit.j"))return trueendfunctionfunction Ger takes nothing returns booleanset g3e=VXx(g4e)
return trueendfunctionfunction Gxr takes integer rYx,integer Cqx,real x,real y,real bex returns integerlocal integer C3o=(ze[(Cqx)])local integer Gor=U0o(g0e[rYx],C3o,x,y,bex,g1e[rYx])
call r0x((Gor),(g8e),(rYx))call fJx((Gor),-((.0)*1.),-((.0)*1.),-((.0)*1.),-((255.)*1.))call fsx(Gor,.0,.0,.0,255.,g9e)return Gorendfunctionfunction Grr takes integer Gir,integer rYx,integer Gar returns nothingset Gee=Garcall r0x((Gir),(Gxe),(rYx))endfunctionfunction Gnr takes integer Iix,integer rYx returns nothingcall Nbx((Iix),(Goe),(rYx),w,((Gre[rYx])*1.))endfunctionfunction GVr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real GEr=(GetUnitFacing(C[((Cqx))])*Nh)local real GXr=dox(Cqx,true)+g5e
local real jMx=(GetUnitX(C[((Cqx))]))+GXr*(Cos(((((GEr)*1.))*1.)))local real jpx=(GetUnitY(C[((Cqx))]))+GXr*(Sin(((((GEr)*1.))*1.)))local integer GOr=g2e[rYx]local real GRr=GEr-g6e*1./ 2
local real GIr=g6e*1./(GOr-1)local integer array GArlocal real bexlocal real x
local real y
loop
exitwhen(GOr<1)set bex=GRr+(GOr-1)*GIrset x=jMx+g7e*(Cos(((((bex)*1.))*1.)))set y=jpx+g7e*(Sin(((((bex)*1.))*1.)))set GAr[GOr]=Gxr(rYx,Cqx,x,y,bex)call CBx(GAr[GOr],bw,x+Gve*(Cos(((((bex)*1.))*1.))),y+Gve*(Sin(((((bex)*1.))*1.))))set GOr=GOr-1endloopcall Grr(GAr[1],rYx,GAr[2])call Grr(GAr[2],rYx,GAr[1])call Gnr(Cqx,rYx)return trueendfunctionfunction GNr takes nothing returns booleancall mro(cne,Xdx("TwinWolves_Init: call TwinWolves.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TwinWolves.Event_SpellEffect))",ih,MI,function GVr))return trueendfunctionfunction Gbr takes nothing returns booleancall FAr(function GNr,"TwinWolves_Init")
return trueendfunctionfunction GBr takes nothing returns booleanset Gie=Wwx('BBrh',"Brotherhood",'bBrh')
set anv[(Gie)]=("ReplaceableTextures\\PassiveButtons\\PASBTNGnollCommandAura.blp")return trueendfunctionfunction Gcr takes nothing returns booleancall L1x('ABrh',false)set Gxe=L0o('ABrh')set K6[(Gxe)]=(H6)set m6[(Gxe)]=(1)set TH[(Gxe)]=("Brotherhood")set x3v[(Gxe)]=("spell")
call L1o((Gxe),Lov+(1),((750)*1.))set MOv[(Gxe)]=("ReplaceableTextures\\PassiveButtons\\PASBTNGnollCommandAura.blp")return trueendfunctionfunction GCr takes nothing returns booleancall VNx(ma,(function GBr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\Brotherhood.page\\Brotherhood.struct\\obj_dummyBuff_wc3buff.j"))call VNx(Pa,(function Gcr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\Brotherhood.page\\Brotherhood.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Gdr takes nothing returns booleanset Gae=VXx(Gne)
return trueendfunctionfunction GDr takes nothing returns booleanlocal integer rFx=(bv)local integer Ahr=(E2v[(rFx)])local real Gfr=(E1v[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer GFr=GEe[oSx]local real Ggrif((pc[(GFr)])or I9x(GFr,Qc))thenreturn trueendifset Ggr=Gfr*GXe*1./ 2if(Ggr<=.0)thenreturn trueendifcall nGo((Ahr),(GFr),((Ggr)*1.),(false))
set E1v[(rFx)]=((Gfr-Ggr)*1.)return trueendfunctionfunction GGr takes nothing returns booleanlocal integer rFx=(bv)local integer GFr=Geelocal integer Iix=(Vv[(rFx)])local integer oSx=Iixset GEe[oSx]=GFr
call Avx(Iix,GVe)call A_o(GFr)return trueendfunctionfunction Ghr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer GFr=GEe[oSx]call RPx(Iix,GVe)call Khx(GFr)return trueendfunctionfunction GHr takes nothing returns booleanlocal integer rFx=(bv)call seo((Vv[(rFx)]),Gie,(Mv[(rFx)]))return trueendfunctionfunction Gjr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),Gie)return trueendfunctionfunction GJr takes nothing returns booleanset GVe=Xdx("Brotherhood_Init: set Brotherhood.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.SPELLS, function Brotherhood.Event_Damage)",E3v,MI,function GDr)call Lxx(Gie,Xdx("Brotherhood_Init: call Brotherhood.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Brotherhood.Event_BuffGain))",bd,MI,function GGr))call Lxx(Gie,Xdx("Brotherhood_Init: call Brotherhood.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Brotherhood.Event_BuffLose))",jc,MI,function Ghr))call mro(Gxe,Xdx("Brotherhood_Init: call Brotherhood.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Brotherhood.Event_Learn))",pv,MI,function GHr))call mro(Gxe,Xdx("Brotherhood_Init: call Brotherhood.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Brotherhood.Event_Unlearn))",Av,MI,function Gjr))return trueendfunctionfunction Gkr takes nothing returns booleancall FAr(function GJr,"Brotherhood_Init")return trueendfunctionfunction GKr takes nothing returns booleancall L1x('ACar',false)set g8e=L0o('ACar')set K6[(g8e)]=(H6)set m6[(g8e)]=(1)set TH[(g8e)]=("Carnivore")set x3v[(g8e)]=("spell")
call L1o((g8e),Lov+(1),((750)*1.))set MOv[(g8e)]=("ReplaceableTextures\\PassiveButtons\\PASBTNVampiricAura.blp")return trueendfunctionfunction Glr takes nothing returns booleanset GOe=Wwx('BCar',"Carnivore",'bCar')set anv[(GOe)]=("ReplaceableTextures\\PassiveButtons\\PASBTNVampiricAura.blp")call lWx(GOe,"Abilities\\Spells\\NightElf\\BattleRoar\\RoarTarget.mdl","overhead",ri)set WU=l_x()
call l2x(WU,BFv,20)call l2x(WU,cNv,5)call l3x(((GOe)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,BFv,30)call l2x(WU,cNv,$A)call l3x(((GOe)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,BFv,40)call l2x(WU,cNv,$F)call l3x(((GOe)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,BFv,50)call l2x(WU,cNv,20)call l3x(((GOe)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,BFv,60)call l2x(WU,cNv,25)call l3x(((GOe)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,BFv,70)call l2x(WU,cNv,30)call l3x(((GOe)),ZB+(6),(WU))return trueendfunctionfunction GLr takes nothing returns booleanset GRe[1]=5
set GRe[2]=$Aset GRe[3]=$Fset GRe[4]=20set GRe[5]=25set GRe[6]=30set GIe[1]=20set GIe[2]=30set GIe[3]=40set GIe[4]=50set GIe[5]=60set GIe[6]=70return trueendfunctionfunction Gmr takes nothing returns booleancall VNx(Pa,(function GKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\Carnivore.page\\Carnivore.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function Glr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\Carnivore.page\\Carnivore.struct\\obj_dummyBuff_wc3buff.j"))call VNx(va,(function GLr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\Carnivore.page\\Carnivore.struct\\obj_this_wc3obj.j"))return trueendfunctionfunction GMr takes nothing returns booleanset GAe=VXx(GNe)
return trueendfunctionfunction Gpr takes nothing returns booleanlocal integer rFx=(bv)call seo((Vv[(rFx)]),GOe,(Mv[(rFx)]))return trueendfunctionfunction GPr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),GOe)return trueendfunctionfunction Gqr takes nothing returns booleancall mro(g8e,Xdx("Carnivore_Init: call Carnivore.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Carnivore.Event_Learn))",pv,MI,function Gpr))call mro(g8e,Xdx("Carnivore_Init: call Carnivore.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Carnivore.Event_Unlearn))",Av,MI,function GPr))return trueendfunctionfunction GQr takes nothing returns booleancall FAr(function Gqr,"Carnivore_Init")return trueendfunctionfunction Gsr takes nothing returns booleanset Goe=Wwx('BWoM',"Wolf's Mark",'bWoM')
set Pc[(Goe)]=(true)
set anv[(Goe)]=("ReplaceableTextures\\PassiveButtons\\PASBTNVampiricAura.blp")call lWx(Goe,"Abilities\\Spells\\NightElf\\BattleRoar\\RoarTarget.mdl","overhead",ri)set WU=l_x()
call l2x(WU,BFv,'d')
call l2x(WU,cEv,'d')
call l2x(WU,cNv,5)call l3x(((Goe)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,BFv,'}')
call l2x(WU,cEv,'}')
call l2x(WU,cNv,$A)call l3x(((Goe)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,BFv,$96)
call l2x(WU,cEv,$96)
call l2x(WU,cNv,$F)call l3x(((Goe)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,BFv,$AF)
call l2x(WU,cEv,$AF)
call l2x(WU,cNv,20)call l3x(((Goe)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,BFv,$C8)
call l2x(WU,cEv,$C8)
call l2x(WU,cNv,25)call l3x(((Goe)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,BFv,$E1)
call l2x(WU,cEv,$E1)
call l2x(WU,cNv,30)call l3x(((Goe)),ZB+(6),(WU))return trueendfunctionfunction GSr takes nothing returns booleanset Gbe[1]='d'set Gbe[2]='}'set Gbe[3]=$96set Gbe[4]=$AFset Gbe[5]=$C8set Gbe[6]=$E1set Gre[1]=5
set Gre[2]=5
set Gre[3]=5
set Gre[4]=5
set Gre[5]=5
set Gre[6]=5
set GBe[1]='d'set GBe[2]='}'set GBe[3]=$96set GBe[4]=$AFset GBe[5]=$C8set GBe[6]=$E1set Gce[1]=5
set Gce[2]=$Aset Gce[3]=$Fset Gce[4]=20set Gce[5]=25set Gce[6]=30return trueendfunctionfunction Gtr takes nothing returns booleancall VNx(ma,(function Gsr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\WolfsMark.page\\WolfsMark.struct\\obj_dummyBuff_wc3buff.j"))call VNx(va,(function GSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\TwinWolves.page\\TwinWolves.struct\\WolfsMark.page\\WolfsMark.struct\\obj_this_wc3obj.j"))return trueendfunctionfunction GTr takes nothing returns booleanset GCe=VXx(Gde)
return trueendfunctionfunction Gur takes nothing returns booleanreturn trueendfunctionfunction GUr takes nothing returns booleancall FAr(function Gur,"WolfsMark_Init")return trueendfunctionfunction Gwr takes nothing returns booleanreturn trueendfunctionfunction GWr takes nothing returns booleanset GDe=VXx(Gfe)
return trueendfunctionfunction Gyr takes nothing returns booleancall L1x('AViM',false)set GFe=L0o('AViM')set K6[(GFe)]=(F6)set m6[(GFe)]=(6)set TH[(GFe)]=("Vivid Meteor")set Rh[(GFe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D026F)))),(((Aj))))))set oxv[(GFe)]=(2)set x3v[(GFe)]=("spell")
call L1o((GFe),Uvv+(1),((300)*1.))call L1o((GFe),GH+(1),(($A)*1.))
call L1o((GFe),tH+(1),((80)*1.))
call L1o((GFe),Lov+(1),(($578)*1.))call L1o((GFe),Uvv+(2),((300)*1.))call L1o((GFe),GH+(2),(($A)*1.))
call L1o((GFe),tH+(2),(('d')*1.))call L1o((GFe),Lov+(2),(($578)*1.))call L1o((GFe),Uvv+(3),((300)*1.))call L1o((GFe),GH+(3),(($A)*1.))
call L1o((GFe),tH+(3),(('x')*1.))call L1o((GFe),Lov+(3),(($578)*1.))call L1o((GFe),Uvv+(4),((300)*1.))call L1o((GFe),GH+(4),(($A)*1.))
call L1o((GFe),tH+(4),(($8C)*1.))call L1o((GFe),Lov+(4),(($578)*1.))call L1o((GFe),Uvv+(5),((300)*1.))call L1o((GFe),GH+(5),(($A)*1.))
call L1o((GFe),tH+(5),(($A0)*1.))call L1o((GFe),Lov+(5),(($578)*1.))call L1o((GFe),Uvv+(6),((300)*1.))call L1o((GFe),GH+(6),(($A)*1.))
call L1o((GFe),tH+(6),(($B4)*1.))call L1o((GFe),Lov+(6),(($578)*1.))set MOv[(GFe)]=("ReplaceableTextures\\CommandButtons\\BTNFireRocks.blp")
call cDr(GFe,'FVM0',6,'VVM0','LPVM','LRVM')set Gge[1]='}'set Gge[2]=$C8set Gge[3]=275set Gge[4]=350set Gge[5]=425set Gge[6]=500set GGe[1]=3
set GGe[2]=4
set GGe[3]=5
set GGe[4]=6
set GGe[5]=7
set GGe[6]=8
set Ghe[1]=65set Ghe[2]='i'set Ghe[3]=$91set Ghe[4]=$B9set Ghe[5]=$E1set Ghe[6]=265set GHe[1]=2
set GHe[2]=2.5set GHe[3]=3
set GHe[4]=3.5set GHe[5]=4
set GHe[6]=4.5return trueendfunctionfunction GYr takes nothing returns booleanset Gje=ltx(GJe+" (poisonBuff)")
set Pc[(Gje)]=(true)
set uU[(Gje)]=(true)
return trueendfunctionfunction Gzr takes nothing returns booleancall VNx(Pa,(function Gyr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\VividMeteor.page\\VividMeteor.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function GYr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\VividMeteor.page\\VividMeteor.struct\\obj_poisonBuff_wc3buff.j"))return trueendfunctionfunction GZr takes nothing returns booleanset Gke=VXx(GJe)
return trueendfunctionfunction G_r takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif I9x(Iix,IFv)thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction G0r takes integer oSx returns integerset GPe[oSx]=trueset Gqe[oSx]=falsecall rEx(Gke)return oSxendfunctionfunction G1r takes nothing returns integerlocal integer oSxif(GLe==8190)thencall o_x("VividMeteor_Allocation_allocCustom","call DebugEx(VividMeteor.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",GJe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Gme[(w)]==w)thenset GMe=GMe+1set oSx=GMeelse
set oSx=Gme[(w)]
set Gme[(w)]=Gme[Gme[(w)]]endifset Gme[oSx]=Zset Gpe[oSx]=1call G0r(oSx)return oSxendfunctionfunction G2r takes integer oSx returns booleanset G6e=G6e+1set G7e[G6e]=oSx
set G8e[oSx]=G6e+1return(G6e==0)endfunctionfunction G3r takes nothing returns nothinglocal integer oMx=G6elocal integer oSxlocal real iIrlocal integer rMxlocal real n2xlocal real x
local real y
local real bexlocal integer HAxloop
set oSx=G7e[oMx]
set iIr=Gye[oSx]+hee
set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((G3e+oSx))),(((G4e))))))set n2x=Gze[oSx]+hxe
set x=G_e[oSx]set y=G0e[oSx]set Gye[oSx]=iIr
set Gze[oSx]=n2x
set bex=GWe[oSx]+iIr
set GWe[oSx]=bex
loop
set bex=bex+G2eset HAx=(LoadInteger(o[((V[(E[((X))])]))],(((G3e+oSx))),(((G4e)+(rMx)))))call mNx(HAx,bex+Bev)call Q1o(HAx,x+n2x*(Cos(((((bex)*1.))*1.))),y+n2x*(Sin(((((bex)*1.))*1.))))set rMx=rMx-1exitwhen(rMx<q)endloopset oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction G4r takes integer oSx,real x,real y returns nothing
local real bex=Gwelocal integer oMxlocal integer HAxset GWe[oSx]=Gwe
set Gye[oSx]=GYe
set Gze[oSx]=GZe
set G_e[oSx]=xset G0e[oSx]=yset oMx=G1eloop
exitwhen(oMx<1)set bex=bex+G2eset HAx=mDx('qViM',x+GZe*(Cos(((((bex)*1.))*1.))),y+GZe*(Sin(((((bex)*1.))*1.))),X_x(x,y),Gwe+Bev)call rux(X,G3e+oSx,G4e,HAx)call k5o(HAx,.75)call SetUnitTimeScale(vJ[(HAx)],((.75*1./ G5e)*1.))set oMx=oMx-1endloopif G2r(oSx)thencall iDx(G9e,hve,true,function G3r)endifendfunctionfunction G5r takes integer oSx returns nothingset GPe[oSx]=falsecall rHx(Gke)endfunctionfunction G6r takes integer oSx returns nothingif(Gpe[oSx]>0)thenreturnendifif(Gme[oSx]!=Z)thencall o_x("VividMeteor_Allocation_deallocCustom_confirm","call DebugEx(VividMeteor.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",GJe+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Gme[oSx]=Gme[(w)]set Gme[(w)]=oSx
call G5r(oSx)endfunctionfunction G7r takes integer oSx returns nothingset Gpe[oSx]=Gpe[oSx]-1call G6r(oSx)endfunctionfunction G8r takes integer oSx returns booleanlocal integer oLx=(G8e[(oSx)])set G8e[G7e[G6e]]=oLxset G7e[oLx-1]=G7e[G6e]set G8e[oSx]=0set G6e=G6e-1return(G6e==F)endfunctionfunction G9r takes integer oSx returns nothinglocal integer oMxlocal integer HAxif G8r(oSx)thencall ikx(G9e)endifset oMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((G3e+oSx))),(((G4e))))))loop
set HAx=(LoadInteger(o[((V[(E[((X))])]))],(((G3e+oSx))),(((G4e)+(oMx)))))call rrx(X,G3e+oSx,G4e,HAx)if(oMx!=q)thencall Mfx(HAx)endifset oMx=oMx-1exitwhen(oMx<q)endloopendfunctionfunction hvr takes nothing returns nothinglocal integer Okx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(Okx)])local integer Cqx=Gse[oSx]local real AXr=Gte[oSx]local integer rYx=GTe[oSx]local real dVx=Gue[oSx]local real dEx=GUe[oSx]local integer C3o=(ze[(Cqx)])local integer Iixlocal real Nbolocal real herlocal real hxrlocal real horcall G7r((oSx))call iKx(Okx)call NVo(GKe,dVx,dEx,GQe[oSx],Gle)set Iix=NEo(GKe)
if(Iix!=w)thenset Nbo=GSe[oSx]
set her=GGe[rYx]
set hxr=GHe[rYx]
loop
if(IsUnitAlly(C[(Iix)],vx[(C3o)]))thencall mao(Cqx,Iix,AXr)else
if I9x(Iix,Wd)thenset hor=hxrelse
set hor=herendifcall Nbx((Iix),(Gje),(rYx),w,((hor)*1.))
call nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))endifset Iix=NEo(GKe)
exitwhen(Iix==w)
endloopendifcall G9r(oSx)endfunctionfunction hrr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local integer oSx=G1r()local integer Okx=iXx()set GQe[oSx]=(CQx((GFe),Uvv+(rYx)))set Gse[oSx]=Cqx
set GSe[oSx]=Ghe[rYx]set Gte[oSx]=Gge[rYx]set GTe[oSx]=rYx
set Gue[oSx]=dVx
set GUe[oSx]=dEx
set ge[(Okx)]=(oSx)call G4r(oSx,dVx,dEx)call iDx(Okx,G5e,false,function hvr)
return trueendfunctionfunction hir takes nothing returns nothingset GYe=hoe*hveset hee=hre*hve*hveset G2e=Cf*1./ G1eset hxe=-GZe*1./ G5e*hve
set G9e=iXx()endfunctionfunction har takes nothing returns booleanset GKe=O5x()set Gle=Xpx(function G_r)call mro(GFe,Xdx("VividMeteor_Init: call VividMeteor.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function VividMeteor.Event_SpellEffect))",ih,MI,function hrr))call W2x(XDv,Gje)call hir()return trueendfunctionfunction hnr takes nothing returns booleancall cPr(function har,"VividMeteor_Init")return trueendfunctionfunction hVr takes nothing returns booleancall L1x('AWaM',false)set hie=L0o('AWaM')set K6[(hie)]=(F6)set m6[(hie)]=(6)set TH[(hie)]=("Warmth Magnetism")set Rh[(hie)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0105)))),(((Aj))))))set oxv[(hie)]=(4)set x3v[(hie)]=("spell")
call L1o((hie),GH+(1),((6)*1.))call L1o((hie),tH+(1),((50)*1.))
call L1o((hie),Lov+(1),((600)*1.))call L1o((hie),GH+(2),((6)*1.))call L1o((hie),tH+(2),((50)*1.))
call L1o((hie),Lov+(2),((600)*1.))call L1o((hie),GH+(3),((6)*1.))call L1o((hie),tH+(3),((60)*1.))
call L1o((hie),Lov+(3),((600)*1.))call L1o((hie),GH+(4),((6)*1.))call L1o((hie),tH+(4),((60)*1.))
call L1o((hie),Lov+(4),((600)*1.))call L1o((hie),GH+(5),((6)*1.))call L1o((hie),tH+(5),((70)*1.))
call L1o((hie),Lov+(5),((600)*1.))call L1o((hie),GH+(6),((6)*1.))call L1o((hie),tH+(6),((70)*1.))
call L1o((hie),Lov+(6),((600)*1.))set MOv[(hie)]=("ReplaceableTextures\\CommandButtons\\BTNGnollCommandAura.blp")call cDr(hie,'FWM0',6,'VWM0','LPWM','LRWM')set hae[1]=20set hae[2]=30set hae[3]=40set hae[4]=50set hae[5]=60set hae[6]=70return trueendfunctionfunction hEr takes nothing returns booleanset hne=VCx("OWaM")return trueendfunctionfunction hXr takes nothing returns booleanset hVe=ltx(hEe+" (dummyBuff)")set Pc[(hVe)]=(true)
set uU[(hVe)]=(true)
set WU=l_x()
call vAr(WU,djv,true)call l3x(((hVe)),ZB+(1),(WU))set WU=l_x()
call vAr(WU,djv,true)call l3x(((hVe)),ZB+(2),(WU))set WU=l_x()
call vAr(WU,djv,true)call l3x(((hVe)),ZB+(3),(WU))set WU=l_x()
call vAr(WU,djv,true)call l3x(((hVe)),ZB+(4),(WU))set WU=l_x()
call vAr(WU,djv,true)call l3x(((hVe)),ZB+(5),(WU))set WU=l_x()
call vAr(WU,djv,true)call l3x(((hVe)),ZB+(6),(WU))return trueendfunctionfunction hOr takes nothing returns booleancall VNx(Pa,(function hVr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\WarmthMagnetism.page\\WarmthMagnetism.struct\\obj_thisSpell_wc3spell.j"))call VNx(ha,(function hEr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\WarmthMagnetism.page\\WarmthMagnetism.struct\\obj_bolt_wc3bolt.j"))
call VNx(ma,(function hXr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Elemental\\WarmthMagnetism.page\\WarmthMagnetism.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction hRr takes nothing returns booleanset hXe=VXx(hEe)
return trueendfunctionfunction hIr takes integer oSx,integer Cqx returns nothingif rnx(Cqx,hRe,oSx)thencall RPx(Cqx,hOe)endifendfunctionfunction hAr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local integer oMx=CIx(Cqx,hRe)local integer oSxloop
set oSx=CAx(Cqx,hRe,oMx)
call hIr(oSx,Cqx)set hIe[oSx]=wset hAe[oSx]=wQo
set hNe[oSx]=wso
set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction hNr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxcall nlo((hIe[oSx]),(Iix),((hde[oSx])*1.),(true),(false))endfunctionfunction hbr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=hIe[oSx]local integer rYx=hFe[oSx]local integer Iix=oSxlocal real dVx=(GetUnitX(C[((Iix))]))local real dEx=(GetUnitY(C[((Iix))]))local real wQolocal real wsolocal real dXlocal real dYlocal real d
local real oyxlocal real bexlocal boolean hBrlocal real earlocal real enrif(Cqx==w)thenset wQo=hAe[oSx]
set wso=hNe[oSx]
else
set wQo=(GetUnitX(C[((Cqx))]))set wso=(GetUnitY(C[((Cqx))]))endifset dX=wQo-dVxset dY=wso-dExset d=jKx(dX,dY)
set oyx=hbeset bex=(Atan2(((dY)*1.),((dX)*1.)))
set hBr=(d<oyx+hje)set ear=dVx+oyx*(Cos(((((bex)*1.))*1.)))
set enr=dEx+oyx*(Sin(((((bex)*1.))*1.)))
call fwx(Iix,ear)call fWx(Iix,enr)if hBr thencall AZx(Iix,hVe)endifendfunctionfunction hcr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=hCelocal integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer cMo=cdo(hne)local integer p3x=iXx()local integer hCr=iXx()set hIe[oSx]=Cqx
set hde[oSx]=hae[rYx]set hDe[oSx]=cMo
set hfe[oSx]=p3x
set hFe[oSx]=rYx
set hge[oSx]=hCr
if rUx(Cqx,hRe,oSx)thencall Avx(Cqx,hOe)endifset ge[(p3x)]=(oSx)set ge[(hCr)]=(oSx)call ERr(cMo,Iix,Cqx)call Ryx((ACx((Iix),(hGe),(hhe),(Bi))))call iDx(p3x,hHe,true,function hNr)call iDx(hCr,hce,true,function hbr)return trueendfunctionfunction hdr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer Cqx=hIe[oSx]local integer cMo=hDe[oSx]local integer p3x=hfe[oSx]local integer hCr=hge[oSx]if(Cqx!=w)thencall hIr(oSx,Cqx)endifcall K0x(cMo)call iKx(p3x)call iKx(hCr)return trueendfunctionfunction hDr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])set hCe=Cqxcall seo((zH[(rFx)]),hVe,(Mv[(rFx)]))return trueendfunctionfunction hfr takes nothing returns booleanset hOe=Xdx("WarmthMagnetism_Init: set WarmthMagnetism.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function WarmthMagnetism.Event_Caster_Death)",VP,MI,function hAr)set hbe=hBe*hcecall Lxx(hVe,Xdx("WarmthMagnetism_Init: call WarmthMagnetism.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function WarmthMagnetism.Event_BuffGain))",bd,MI,function hcr))call Lxx(hVe,Xdx("WarmthMagnetism_Init: call WarmthMagnetism.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function WarmthMagnetism.Event_BuffLose))",jc,MI,function hdr))call mro(hie,Xdx("WarmthMagnetism_Init: call WarmthMagnetism.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function WarmthMagnetism.Event_SpellEffect))",ih,MI,function hDr))call W2x(Xlv,hVe)return trueendfunctionfunction hFr takes nothing returns booleancall cPr(function hfr,"WarmthMagnetism_Init")return trueendfunctionfunction hgr takes nothing returns booleanset hJe=ltx(hke+" (dummyBuff)")call lWx(hJe,"Abilities\\Spells\\Undead\\DeathandDecay\\DeathandDecayDamage.mdl","origin",Bi)return trueendfunctionfunction hGr takes nothing returns booleancall VNx(ma,(function hgr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Amaterasu.page\\Amaterasu.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction hhr takes nothing returns booleanset hKe=VXx(hke)
return trueendfunctionfunction hHr takes nothing returns booleanset hle=ltx(hLe+" (dummyBuff)")call lWx(hle,"Abilities\\Spells\\Orc\\LiquidFire\\Liquidfire.mdl","origin",ri)call lWx(hle,"Abilities\\Spells\\Other\\Doom\\DoomTarget.mdl","origin",Bi)call lWx(hle,"Abilities\\Spells\\Orc\\Voodoo\\VoodooAura.mdl","origin",Bi)return trueendfunctionfunction hjr takes nothing returns booleancall L1x('AAma',false)set hme=L0o('AAma')set K6[(hme)]=(G6)set m6[(hme)]=(3)set TH[(hme)]=("Amaterasu")set Rh[(hme)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00FD)))),(((Aj))))))set oxv[(hme)]=(0)set x3v[(hme)]=("spell,channel")
call L1o((hme),Uvv+(1),((450)*1.))call L1o((hme),dH+(1),(($F)*1.))
call L1o((hme),GH+(1),((90)*1.))
call L1o((hme),tH+(1),(($91)*1.))call L1o((hme),Lov+(1),((750)*1.))call L1o((hme),Uvv+(2),((450)*1.))call L1o((hme),dH+(2),(($F)*1.))
call L1o((hme),GH+(2),((90)*1.))
call L1o((hme),tH+(2),(($D2)*1.))call L1o((hme),Lov+(2),((750)*1.))call L1o((hme),Uvv+(3),((450)*1.))call L1o((hme),dH+(3),(($F)*1.))
call L1o((hme),GH+(3),((90)*1.))
call L1o((hme),tH+(3),((275)*1.))call L1o((hme),Lov+(3),((750)*1.))set MOv[(hme)]=("ReplaceableTextures\\CommandButtons\\BTNOrbofSlowness.blp")
call cDr(hme,'FAm0',3,'VAm0','LPAm','LRAm')set hMe[1]=300set hMe[2]=500set hMe[3]=800set hpe[1]=600set hpe[2]=900set hpe[3]=$4B0return trueendfunctionfunction hJr takes nothing returns booleancall VNx(ma,(function hHr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Amaterasu.page\\Amaterasu.struct\\obj_dummyBuff_wc3buff.j"))
call VNx(Pa,(function hjr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Amaterasu.page\\Amaterasu.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction hkr takes nothing returns booleanset hPe=VXx(hLe)
return trueendfunctionfunction hKr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif nbo(Iix)thenreturn false
endifif(osx((((Iix))),(Wb+(hJe)))>0)thenreturn false
endifreturn truereturn trueendfunctionfunction hlr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxlocal integer waolocal real Nbocall NVo(hqe,hue[oSx],hUe[oSx],hse[oSx],hQe)
set wao=NEo(hqe)
if(wao!=w)thenset Nbo=hSe[oSx]
loop
call Nbx(((wao)),(hJe),(1),w,((hWe)*1.))
if I9x(wao,Idv)thencall nlo((Iix),(wao),((Nbo)*1.),(false),(false))
else
call nlo((Iix),(wao),((Nbo*hye)*1.),(false),(false))
endifset wao=NEo(hqe)
exitwhen(wao==w)
endloopendifendfunctionfunction hLr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local real dVx=(GetUnitX(C[((Iix))]))local real dEx=(GetUnitY(C[((Iix))]))local integer oSx=Iixlocal integer p3x=iXx()set hse[oSx]=(CQx((hme),Uvv+(rYx)))set hSe[oSx]=hte[rYx]set hTe[oSx]=p3x
set hue[oSx]=dVx
set hUe[oSx]=dEx
set ge[(p3x)]=(oSx)call iDx(p3x,hwe,true,function hlr)return trueendfunctionfunction hmr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=hTe[oSx]call iKx(p3x)return trueendfunctionfunction hMr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),hle)return trueendfunctionfunction hpr takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(hle),((Mv[(rFx)])),w)return trueendfunctionfunction hPr takes nothing returns nothingendfunctionfunction hqr takes nothing returns booleanlocal integer oMxset hqe=O5x()set hQe=Xpx(function hKr)call Lxx(hle,Xdx("Amaterasu_Init: call Amaterasu.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Amaterasu.Event_BuffGain))",bd,MI,function hLr))call Lxx(hle,Xdx("Amaterasu_Init: call Amaterasu.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Amaterasu.Event_BuffLose))",jc,MI,function hmr))call mro(hme,Xdx("Amaterasu_Init: call Amaterasu.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Amaterasu.Event_EndCast))",onv,MI,function hMr))call mro(hme,Xdx("Amaterasu_Init: call Amaterasu.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Amaterasu.Event_SpellEffect))",ih,MI,function hpr))
set oMx=(m6[(hme)])loop
set hte[oMx]=hpe[oMx]*1./(R2I((((CQx((hme),dH+(oMx)))*1./ hWe)*1.)))
set oMx=oMx-1exitwhen(oMx<1)endloopcall hPr()return trueendfunctionfunction hQr takes nothing returns booleancall FAr(function hqr,"Amaterasu_Init")return trueendfunctionfunction hsr takes nothing returns booleanset hYe=VCx("OCrp")return trueendfunctionfunction hSr takes nothing returns booleanset hze=Wwx('BCrp',"Crippled",'bCrp')set uU[(hze)]=(true)
set anv[(hze)]=("ReplaceableTextures\\CommandButtons\\BTNDispelMagic.blp")call lWx(hze,"ArcaneAttractor_page\\ArcaneAttractor_struct\\Target\\Target.mdx","origin",ri)
set WU=l_x()
call l2x(WU,nnv,-.3)
call l2x(WU,dHv,-.3)
call l3x(((hze)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,nnv,-.35)call l2x(WU,dHv,-.3)
call l3x(((hze)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,nnv,-.4)
call l2x(WU,dHv,-.3)
call l3x(((hze)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,nnv,-.45)call l2x(WU,dHv,-.3)
call l3x(((hze)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,nnv,-.5)
call l2x(WU,dHv,-.3)
call l3x(((hze)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,nnv,-.55)call l2x(WU,dHv,-.3)
call l3x(((hze)),ZB+(6),(WU))return trueendfunctionfunction htr takes nothing returns booleanset hZe[1]=-.3set hZe[2]=-.3set hZe[3]=-.3set hZe[4]=-.3set hZe[5]=-.3set hZe[6]=-.3set h_e[1]=5
set h_e[2]=5
set h_e[3]=5
set h_e[4]=5
set h_e[5]=5
set h_e[6]=5
set h0e[1]=-.3set h0e[2]=-.35set h0e[3]=-.4set h0e[4]=-.45set h0e[5]=-.5set h0e[6]=-.55return trueendfunctionfunction hTr takes nothing returns booleancall VNx(ha,(function hsr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcaneAttractor.page\\ArcaneAttractor.struct\\Target\\obj_bolt_wc3bolt.j"))call VNx(ma,(function hSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcaneAttractor.page\\ArcaneAttractor.struct\\Target\\obj_dummyBuff_wc3buff.j"))
call VNx(va,(function htr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcaneAttractor.page\\ArcaneAttractor.struct\\Target\\obj_this_wc3obj.j"))return trueendfunctionfunction hur takes nothing returns booleanset h1e=VXx(h2e)
return trueendfunctionfunction hUr takes nothing returns booleancall L1x('ACrp',false)set g6v=L0o('ACrp')set K6[(g6v)]=(D6)set m6[(g6v)]=(6)set TH[(g6v)]=("Arcane Attractor")set Rh[(g6v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00DD)))),(((Aj))))))set oxv[(g6v)]=(2)set x3v[(g6v)]=("spell")
call L1o((g6v),Uvv+(1),((300)*1.))call L1o((g6v),GH+(1),((20)*1.))
call L1o((g6v),tH+(1),((85)*1.))
call L1o((g6v),Lov+(1),((650)*1.))call L1o((g6v),Uvv+(2),((300)*1.))call L1o((g6v),GH+(2),((19)*1.))
call L1o((g6v),tH+(2),(('n')*1.))call L1o((g6v),Lov+(2),((650)*1.))call L1o((g6v),Uvv+(3),((300)*1.))call L1o((g6v),GH+(3),((18)*1.))
call L1o((g6v),tH+(3),(($87)*1.))call L1o((g6v),Lov+(3),((650)*1.))call L1o((g6v),Uvv+(4),((300)*1.))call L1o((g6v),GH+(4),((17)*1.))
call L1o((g6v),tH+(4),(($A0)*1.))call L1o((g6v),Lov+(4),((650)*1.))call L1o((g6v),Uvv+(5),((300)*1.))call L1o((g6v),GH+(5),((16)*1.))
call L1o((g6v),tH+(5),(($B9)*1.))call L1o((g6v),Lov+(5),((650)*1.))call L1o((g6v),Uvv+(6),((300)*1.))call L1o((g6v),GH+(6),(($F)*1.))
call L1o((g6v),tH+(6),(($D2)*1.))call L1o((g6v),Lov+(6),((650)*1.))set MOv[(g6v)]=("ReplaceableTextures\\CommandButtons\\BTNDispelMagic.blp")call cDr(g6v,'FCp0',6,'VCp0','LPCp','LRCp')set h3e[1]=.06set h3e[2]=.07set h3e[3]=.08set h3e[4]=.09set h3e[5]=.1set h3e[6]=.11set h4e[1]=$Aset h4e[2]=$Aset h4e[3]=$Aset h4e[4]=$Aset h4e[5]=$Aset h4e[6]=$Aset h5e[1]=20set h5e[2]=30set h5e[3]=40set h5e[4]=50set h5e[5]=60set h5e[6]=70return trueendfunctionfunction hwr takes nothing returns booleanset h6e=hjo('uCrp')call hJo(((h6e)),ASv,(Iav))set Uj[(h6e)]=((1)*1.)set NOv[(h6e)]=(($B)*1.)
set NWv[(h6e)]=(($B)*1.)
set NPv[(h6e)]=(($96)*1.)set Anv[(h6e)]=(5)set Nmv[(h6e)]=((150000.)*1.)set NLv[(h6e)]=((150000.)*1.)set NKv[(h6e)]=((0)*1.)set Ncv[(h6e)]=((750)*1.)set Nbv[(h6e)]=((750)*1.)set NGv[(h6e)]=((50)*1.)
set Auv[(h6e)]=((0)*1.)set AUv[(h6e)]=((0)*1.)set AYv[(h6e)]=(0)set A_v[(h6e)]=(0)set ATv[(h6e)]=((8)*1.)call hpo((h6e),(gtv),1)return trueendfunctionfunction hWr takes nothing returns booleancall VNx(Pa,(function hUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcaneAttractor.page\\ArcaneAttractor.struct\\obj_thisSpell_wc3spell.j"))call VNx(sa,(function hwr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcaneAttractor.page\\ArcaneAttractor.struct\\obj_summonUnitType_wc3unit.j"))return trueendfunctionfunction hyr takes nothing returns booleanset h7e=VXx(h8e)
return trueendfunctionfunction hYr takes integer oSx returns nothinglocal integer iCx=Hee[oSx]local integer p3x=Hxe[oSx]local integer IOr=Hoe[oSx]call iKx(iCx)call iKx(p3x)call RPx(IOr,Hve)call Owx(IOr)endfunctionfunction hzr takes nothing returns booleanlocal integer rFx=(bv)local integer IOr=(Vv[(rFx)])local integer oSx=IOrcall hYr(oSx)return trueendfunctionfunction hZr takes nothing returns booleanlocal integer Iix=jhx()if(osx((((Iix))),(Wb+(hze)))>0)thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifif((GetRandomReal(((.0)*1.),((1.)*1.)))>Hie)then
return false
endifreturn truereturn trueendfunctionfunction h_r takes integer oSx,integer Cqx,integer rYx,integer Iix returns nothinglocal integer rLx=oSxlocal integer h0r=cdo(hYe)call ERr(h0r,Hoe[rLx],Iix)call cLo(h0r,1.)
set Rb=Cqxcall Nbx((Iix),(hze),(rYx),w,((h_e[rYx])*1.))endfunctionfunction h1r takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Ctx=Hae[oSx]local integer Cqx=(EH[(Ctx)])local integer rYx=(IH[(Ctx)])local integer IOr=Hoe[oSx]local real x=(GetUnitX(C[((IOr))]))local real y=(GetUnitY(C[((IOr))]))local integer Iixlocal real Nbolocal real h2rset hf=(ze[(Cqx)])call NVo(h9e,x,y,(CQx((g6v),Uvv+(rYx))),Hre)
set Iix=(mKo((h9e),((x)*1.),((y)*1.)))if(Iix!=w)thenset Nbo=h5e[rYx]
set h2r=h3e[rYx]
call h_r(oSx,Cqx,rYx,Iix)call n1r(Iix)call Our(Iix,450.,.0,(Atan2((((GetUnitY(C[((Iix))]))-y)*1.),(((GetUnitX(C[((Iix))]))-x)*1.)))+3.141592654,1.)if(osx((((Cqx))),(Wb+(c3e)))>0)thencall Nbx((((Iix))),((Xwv)),(1),w,((((HRe[(osx(((Cqx)),Yb+(c3e)))])*1.))*1.))
endifcall Ryx((ACx((Iix),(HIe),(HAe),(Bi))))call nlo((Cqx),(Iix),((Nbo+h2r*(oG[(Iix)]))*1.),(true),(false))endifendfunctionfunction h3r takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])call hYr(oSx)endfunctionfunction h4r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local integer Ctx=(WH[(rFx)])local integer IOr=U0o(h6e,(ze[(Cqx)]),dVx,dEx,(VH[(Ctx)]),h4e[rYx])local integer oSx=IOrlocal integer iCx=iXx()local integer p3x=iXx()set Hee[oSx]=iCx
set Hxe[oSx]=p3x
set Hoe[oSx]=IOr
set Hae[oSx]=Ctx
set ge[(iCx)]=(oSx)set ge[(p3x)]=(oSx)call Avx(IOr,Hve)call Ryx((ACx((IOr),(Hne),(HVe),(Bi))))call SetUnitAnimation(C[((IOr))],("channel"))call abx(IOr,(xx[(Cqx)]))call SetUnitFlyHeight(C[((IOr))],((HEe)*1.),.0)call fjx(IOr,0,0,0,0)call fsx(IOr,$FF,$FF,$FF,$FF,1.)
call mho((mko(((dVx)*1.),((dEx)*1.),(HXe),(ri))))call iDx(p3x,HOe,true,function h1r)call iDx(iCx,h4e[rYx],false,function h3r)return trueendfunctionfunction h5r takes nothing returns nothingendfunctionfunction h6r takes nothing returns booleanset h9e=O5x()set Hve=Xdx("ArcaneAttractor_Init: set ArcaneAttractor.SUMMON_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function ArcaneAttractor.Event_Summon_Destroy)",EP,MI,function hzr)set Hre=Xpx(function hZr)call mro(g6v,Xdx("ArcaneAttractor_Init: call ArcaneAttractor.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ArcaneAttractor.Event_SpellEffect))",ih,MI,function h4r))call h5r()return trueendfunctionfunction h7r takes nothing returns booleancall FAr(function h6r,"ArcaneAttractor_Init")return trueendfunctionfunction h8r takes nothing returns booleanset HNe[1]=0
set HNe[2]=0
set HNe[3]=0
set Hbe[1]=60set Hbe[2]=60set Hbe[3]=60set HBe[1]=3
set HBe[2]=4
set HBe[3]=5
set Hce[1]=1
set Hce[2]=2
set Hce[3]=3
set HCe[1]='d'set HCe[2]=$AFset HCe[3]=$FAreturn trueendfunctionfunction h9r takes nothing returns booleanset Hde[2]=hjo('uAW2')call hJo(((Hde[2])),ASv,(Idv))set Uj[(Hde[2])]=((1.375)*1.)call hko(Hde[2],$96,'x',$FF,$FF)
set NOv[(Hde[2])]=((60)*1.)set NWv[(Hde[2])]=((60)*1.)call Hqo(Hde[2],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","hand left",Bi)
call Hqo(Hde[2],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","hand right",Bi)call Hqo(Hde[2],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","foot left",Bi)
call Hqo(Hde[2],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","foot right",Bi)set NPv[(Hde[2])]=((320)*1.)
set I8v[(Hde[2])]=((2)*1.)set Anv[(Hde[2])]=(2)set Nmv[(Hde[2])]=((750)*1.)
set NLv[(Hde[2])]=((750)*1.)
set NKv[(Hde[2])]=((0)*1.)set Npv[(Hde[2])]=((300)*1.)
set NMv[(Hde[2])]=((300)*1.)
set Nlv[(Hde[2])]=((0)*1.)set Ncv[(Hde[2])]=(($578)*1.)set Nbv[(Hde[2])]=(($578)*1.)set NGv[(Hde[2])]=((80)*1.)set Adv[(Hde[2])]=(gkv)set AGv[(Hde[2])]=(('l')*1.)
set Ahv[((Hde[2]))]=((1.*1./((1.35)*1.))*1.)
set AWv[(Hde[2])]=((.33)*1.)
set Auv[(Hde[2])]=((48)*1.)set AUv[(Hde[2])]=((48)*1.)set AYv[(Hde[2])]=(2)set A_v[(Hde[2])]=($B)set A2v[(Hde[2])]=(0)set ATv[(Hde[2])]=((33)*1.)return trueendfunctionfunction Hvr takes nothing returns booleancall L1x('AArw',false)set HDe=L0o('AArw')set K6[(HDe)]=(g6)set m6[(HDe)]=(3)set TH[(HDe)]=("Arctic Wolf")set Rh[(HDe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D009E)))),(((Aj))))))set oxv[(HDe)]=(2)set x3v[(HDe)]=("spell")
call L1o((HDe),Uvv+(1),((300)*1.))call L1o((HDe),GH+(1),((60)*1.))
call L1o((HDe),tH+(1),(($96)*1.))call L1o((HDe),Lov+(1),((750)*1.))call L1o((HDe),Uvv+(2),((300)*1.))call L1o((HDe),GH+(2),((60)*1.))
call L1o((HDe),tH+(2),(($96)*1.))call L1o((HDe),Lov+(2),((750)*1.))call L1o((HDe),Uvv+(3),((300)*1.))call L1o((HDe),GH+(3),((60)*1.))
call L1o((HDe),tH+(3),(($96)*1.))call L1o((HDe),Lov+(3),((750)*1.))set MOv[(HDe)]=("ReplaceableTextures\\CommandButtons\\BTNWolf.blp")call cDr(HDe,'FAW0',3,'VAW0','LPAW','LRAW')return trueendfunctionfunction Her takes nothing returns booleanset Hde[1]=hjo('uArW')call hJo(((Hde[1])),ASv,(Idv))set Uj[(Hde[1])]=((1.25)*1.)
call hko(Hde[1],$96,'x',$FF,$C8)
set NOv[(Hde[1])]=((60)*1.)set NWv[(Hde[1])]=((60)*1.)call Hqo(Hde[1],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","hand left",Bi)
call Hqo(Hde[1],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","hand right",Bi)call Hqo(Hde[1],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","foot left",Bi)
call Hqo(Hde[1],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","foot right",Bi)set NPv[(Hde[1])]=((320)*1.)
set I8v[(Hde[1])]=((2)*1.)set Anv[(Hde[1])]=(2)set Nmv[(Hde[1])]=((750)*1.)
set NLv[(Hde[1])]=((750)*1.)
set NKv[(Hde[1])]=((0)*1.)set Npv[(Hde[1])]=((300)*1.)
set NMv[(Hde[1])]=((300)*1.)
set Nlv[(Hde[1])]=((0)*1.)set Ncv[(Hde[1])]=(($578)*1.)set Nbv[(Hde[1])]=(($578)*1.)set NGv[(Hde[1])]=((50)*1.)set Adv[(Hde[1])]=(gkv)set AGv[(Hde[1])]=(('l')*1.)
set Ahv[((Hde[1]))]=((1.*1./((1.35)*1.))*1.)
set AWv[(Hde[1])]=((.33)*1.)
set Auv[(Hde[1])]=((30)*1.)set AUv[(Hde[1])]=((30)*1.)set AYv[(Hde[1])]=(2)set A_v[(Hde[1])]=(9)set A2v[(Hde[1])]=(0)set ATv[(Hde[1])]=((33)*1.)return trueendfunctionfunction Hxr takes nothing returns booleanset Hde[3]=hjo('uAW3')call hJo(((Hde[3])),ASv,(Idv))set Uj[(Hde[3])]=((1.5)*1.)call hko(Hde[3],$96,'x',$FF,$FF)
set NOv[(Hde[3])]=((60)*1.)set NWv[(Hde[3])]=((60)*1.)call Hqo(Hde[3],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","hand left",Bi)
call Hqo(Hde[3],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","hand right",Bi)call Hqo(Hde[3],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","foot left",Bi)
call Hqo(Hde[3],"Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl","foot right",Bi)set NPv[(Hde[3])]=((320)*1.)
set I8v[(Hde[3])]=((2)*1.)set Anv[(Hde[3])]=(2)set Nmv[(Hde[3])]=((750)*1.)
set NLv[(Hde[3])]=((750)*1.)
set NKv[(Hde[3])]=((0)*1.)set Npv[(Hde[3])]=((300)*1.)
set NMv[(Hde[3])]=((300)*1.)
set Nlv[(Hde[3])]=((0)*1.)set Ncv[(Hde[3])]=(($578)*1.)set Nbv[(Hde[3])]=(($578)*1.)set NGv[(Hde[3])]=(('n')*1.)
set Adv[(Hde[3])]=(gkv)set AGv[(Hde[3])]=(('l')*1.)
set Ahv[((Hde[3]))]=((1.*1./((1.35)*1.))*1.)
set AWv[(Hde[3])]=((.33)*1.)
set Auv[(Hde[3])]=((70)*1.)set AUv[(Hde[3])]=((70)*1.)set AYv[(Hde[3])]=(2)set A_v[(Hde[3])]=(22)set A2v[(Hde[3])]=(0)set ATv[(Hde[3])]=((33)*1.)return trueendfunctionfunction Hor takes nothing returns booleancall VNx(va,(function h8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcticWolf.page\\ArcticWolf.struct\\obj_this_wc3obj.j"))
call VNx(sa,(function h9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcticWolf.page\\ArcticWolf.struct\\obj_summonUnitType[2]_wc3unit.j"))call VNx(Pa,(function Hvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcticWolf.page\\ArcticWolf.struct\\obj_thisSpell_wc3spell.j"))call VNx(sa,(function Her),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcticWolf.page\\ArcticWolf.struct\\obj_summonUnitType[1]_wc3unit.j"))call VNx(sa,(function Hxr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ArcticWolf.page\\ArcticWolf.struct\\obj_summonUnitType[3]_wc3unit.j"))return trueendfunctionfunction Hrr takes nothing returns booleanset Hfe=VXx(HFe)
return trueendfunctionfunction Hir takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction Har takes nothing returns booleanlocal integer Iix=jhx()if(I8x((Ose),Ob,(Iix)))thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction Hnr takes integer oSx returns integerset HMe[oSx]=trueset Hpe[oSx]=falsecall rEx(Hfe)return oSxendfunctionfunction HVr takes nothing returns integerlocal integer oSxif(HKe==8190)thencall o_x("ArcticWolf_Allocation_allocCustom","call DebugEx(ArcticWolf.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",HFe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Hle[(w)]==w)thenset HLe=HLe+1set oSx=HLeelse
set oSx=Hle[(w)]
set Hle[(w)]=Hle[Hle[(w)]]endifset Hle[oSx]=Zset Hme[oSx]=1call Hnr(oSx)return oSxendfunctionfunction HEr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local real O4o=HQe[oSx]local integer Cqx=Hse[oSx]local real Nbo=H0e[oSx]local integer HAx=HSe[oSx]local integer svo=H_e[oSx]local real x=(iJ[(HAx)])
local real y=(EJ[(HAx)])
local integer Iixlocal integer rYxlocal real gYrset hf=(ze[(Cqx)])set Ose=svocall NVo(Hge,x,y,O4o,HJe)set Iix=NEo(Hge)
if(Iix!=w)thenset rYx=Hye[oSx]
set gYr=HYe[oSx]
loop
call Nbx((Iix),(Xwv),(rYx),w,((gYr)*1.))
call dQx(svo,Iix)call nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))set Iix=NEo(Hge)
exitwhen(Iix==w)
endloopendifendfunctionfunction HXr takes integer oSx,real x,real y returns nothing
call Q1o(oSx,(iJ[(oSx)])+x,(EJ[(oSx)])+y)endfunctionfunction HOr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])call HXr(HSe[oSx],H3e[oSx],H4e[oSx])
endfunctionfunction HRr takes integer oSx returns nothingset HMe[oSx]=falsecall rHx(Hfe)endfunctionfunction HIr takes integer oSx returns nothingif(Hme[oSx]>0)thenreturnendifif(Hle[oSx]!=Z)thencall o_x("ArcticWolf_Allocation_deallocCustom_confirm","call DebugEx(ArcticWolf.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",HFe+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset Hle[oSx]=Hle[(w)]set Hle[(w)]=oSx
call HRr(oSx)endfunctionfunction HAr takes integer oSx returns nothingset Hme[oSx]=Hme[oSx]-1call HIr(oSx)endfunctionfunction HNr takes real x,real y,real O4o,integer Cqx,real Nbo returns nothinglocal integer Iixcall mko(x,y,H6e,ri)
set hf=(ze[(Cqx)])call NVo(Hge,x,y,O4o,HGe)set Iix=NEo(Hge)
if(Iix!=w)thenloop
call nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))set Iix=NEo(Hge)
exitwhen(Iix==w)
endloopendifendfunctionfunction Hbr takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local real bex=Hqe[oSx]local integer Cqx=Hse[oSx]local integer HAx=HSe[oSx]local integer HBr=Hte[oSx]local real Hcr=Hwe[oSx]local integer p3x=HWe[oSx]local integer GOr=Hze[oSx]local real HCr=HZe[oSx]local integer svo=H_e[oSx]local integer Hdr=H1e[oSx]local integer Q9o=H2e[oSx]local integer C3o=(ze[(Cqx)])local real x=(iJ[(HAx)])
local real y=(EJ[(HAx)])
local integer Gorcall HAr((oSx))call HIx(HBr)call iKx(iCx)call iKx(p3x)call X_r(svo)call iKx(Q9o)call fgo(HAx,H5e)call QYo((HAx),-((.0)*1.),-((.0)*1.),-((.0)*1.),-((127.)*1.),((H5e)*1.))
call HNr(x,y,HQe[oSx],Cqx,Hcr)loop
exitwhen(GOr<1)set Gor=U0o(Hdr,C3o,x,y,bex,HCr)
set GOr=GOr-1endloopendfunctionfunction HDr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real bex=Ufx(Cqx,dVx-wQo,dEx-wso)local real iMx=jKx(dVx-wQo,dEx-wso)*1./ HHelocal real Hfr=(Cos(((((bex)*1.))*1.)))local real HFr=(Sin(((((bex)*1.))*1.)))local real Xcr=wQo+Hke*Hfrlocal real XCr=wso+Hke*HFrlocal integer oSx=HVr()local integer HAx=mDx('qArW',Xcr,XCr,X_x(Xcr,XCr)+HPe,bex)local integer iCx=iXx()local integer p3x=iXx()local integer Q9o=iXx()set Hqe[oSx]=bex
set HQe[oSx]=(CQx((HDe),Uvv+(rYx)))set Hse[oSx]=Cqx
set HSe[oSx]=HAx
set Hte[oSx]=sEo(HAx,HTe,Hue,Bi)
set HUe[oSx]=iCx
set Hwe[oSx]=HCe[rYx]set HWe[oSx]=p3x
set Hye[oSx]=rYx
set HYe[oSx]=HBe[rYx]set Hze[oSx]=Hce[rYx]set HZe[oSx]=Hbe[rYx]set H_e[oSx]=Jbx("ArcticWolf_Event_SpellEffect: set this.targetGroup = UnitList.Create()")set H0e[oSx]=HNe[rYx]set H1e[oSx]=Hde[rYx]set H2e[oSx]=Q9o
set H3e[oSx]=Hhe*Hfr
set H4e[oSx]=Hhe*HFr
set ge[(iCx)]=(oSx)set ge[(p3x)]=(oSx)set ge[(Q9o)]=(oSx)call SetUnitAnimationByIndex(vJ[((HAx))],(2))call mCx(HAx,2.)
call mdx(HAx,255.,255.,255.,127.)call iDx(p3x,.25,true,function HEr)call iDx(Q9o,Hje,true,function HOr)call iDx(iCx,iMx,false,function Hbr)
return trueendfunctionfunction Hgr takes nothing returns booleanset Hge=O5x()set HGe=Xpx(function Hir)set Hhe=HHe*Hjeset HJe=Xpx(function Har)call mro(HDe,Xdx("ArcticWolf_Init: call ArcticWolf.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ArcticWolf.Event_SpellEffect))",ih,MI,function HDr))return trueendfunctionfunction HGr takes nothing returns booleancall FAr(function Hgr,"ArcticWolf_Init")
return trueendfunctionfunction Hhr takes nothing returns booleanset H7e=ltx(H8e+" (dummyBuff)")call lWx(H7e,"BoulderCrash_page\\BoulderCrash_struct\\Visuals\\Area2.mdx","origin",ri)return trueendfunctionfunction HHr takes nothing returns booleancall VNx(ma,(function Hhr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\BoulderCrash.page\\BoulderCrash.struct\\Visuals\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction Hjr takes nothing returns booleanset H9e=VXx(H8e)
return trueendfunctionfunction HJr takes nothing returns booleanset jve=ltx(jee+" (dummyBuff)")return trueendfunctionfunction Hkr takes nothing returns booleancall L1x('ABoC',false)set hCv=L0o('ABoC')set K6[(hCv)]=(G6)set m6[(hCv)]=(3)set TH[(hCv)]=("Boulder Crash")set Rh[(hCv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00FD)))),(((Aj))))))set oxv[(hCv)]=(0)set x3v[(hCv)]=("morph")
call L1o((hCv),Uvv+(1),((450)*1.))call L1o((hCv),dH+(1),(($F)*1.))
call L1o((hCv),GH+(1),((90)*1.))
call L1o((hCv),tH+(1),(($91)*1.))call L1o((hCv),Lov+(1),((750)*1.))call L1o((hCv),Uvv+(2),((600)*1.))call L1o((hCv),dH+(2),(($F)*1.))
call L1o((hCv),GH+(2),((90)*1.))
call L1o((hCv),tH+(2),(($D2)*1.))call L1o((hCv),Lov+(2),((750)*1.))call L1o((hCv),Uvv+(3),((850)*1.))call L1o((hCv),dH+(3),(($F)*1.))
call L1o((hCv),GH+(3),((90)*1.))
call L1o((hCv),tH+(3),((275)*1.))call L1o((hCv),Lov+(3),((750)*1.))set MOv[(hCv)]=("ReplaceableTextures\\CommandButtons\\BTNDizzy.blp")
call cDr(hCv,'FBC0',3,'VBC0','LPBC','LRBC')set jxe[1]=40set jxe[2]=60set jxe[3]=80set joe[1]=50set joe[2]=75set joe[3]='d'return trueendfunctionfunction HKr takes nothing returns booleancall VNx(ma,(function HJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\BoulderCrash.page\\BoulderCrash.struct\\obj_dummyBuff_wc3buff.j"))call VNx(Pa,(function Hkr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\BoulderCrash.page\\BoulderCrash.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Hlr takes nothing returns booleanset jre=VXx(jee)
return trueendfunctionfunction HLr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction Hmr takes integer oSx,real Nlx,real bex,real iMx returns nothingcall Rjr(oSx,Nlx*(Cos(((((bex)*1.))*1.))),Nlx*(Sin(((((bex)*1.))*1.))),.0,iMx)endfunctionfunction HMr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=oSxlocal integer rYx=jVe[oSx]local real O4o=(CQx((hCv),Uvv+(rYx)))local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real dKr=dox(Cqx,true)
local real Hpr=dKrlocal integer Iixlocal real Nbolocal real d
local real dlrlocal real HPrset hf=(ze[(Cqx)])call NVo(jie,wQo,wso,O4o,jae)set Iix=NEo(jie)
if(Iix!=w)thenset Nbo=jXe[rYx]
loop
set d=jKx((GetUnitX(C[((Iix))]))-wQo,(GetUnitY(C[((Iix))]))-wso)
set dlr=ddr(dKr,jOe,O4o,jRe,d)set HPr=Nkx(d-Hpr,joe[rYx],.0)call Hmr(Iix,joe[rYx],(Atan2(((wso-(GetUnitY(C[((Iix))])))*1.),((wQo-(GetUnitX(C[((Iix))])))*1.))),HPr)call nlo((Cqx),(Iix),((Nbo*dlr)*1.),(true),(false))set Iix=NEo(jie)
exitwhen(Iix==w)
endloopendifendfunctionfunction Hqr takes integer oSx,integer Cqx,integer rYx returns nothingcall Dux((Cqx),(H7e),(rYx),w)endfunctionfunction HQr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=iXx()set jne[oSx]=p3x
set jVe[oSx]=rYx
set ge[(p3x)]=(oSx)call iDx(p3x,jEe,true,function HMr)call Hqr((w),Iix,rYx)return trueendfunctionfunction Hsr takes integer oSx,integer Cqx returns nothingcall AZx(Cqx,H7e)endfunctionfunction HSr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=jne[oSx]call iKx(p3x)call Hsr((w),Iix)return trueendfunctionfunction Htr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),jve)return trueendfunctionfunction HTr takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(jve),((Mv[(rFx)])),w)return trueendfunctionfunction Hur takes integer oSx returns booleanset Ry=Ry+1set Oy[Ry]=oSxset Xy[oSx]=Ry+1
return(Ry==0)endfunctionfunction HUr takes nothing returns nothinglocal integer oMx=Ry
local integer oSxlocal real C9xlocal real dvxlocal real MSolocal integer Iixlocal real fvxloop
set oSx=Oy[oMx]set C9x=jbe[oSx]
set dvx=jBe[oSx]
set MSo=jce[oSx]
set Iix=Ay[oSx]if jCe[oSx]thenset C9x=C9x+pvo(Iix,false)set dvx=dvx+peo(Iix,false)set MSo=MSo+Opx(Iix,false)endifif jde[oSx]thenset fvx=(eb[(Iix)])set C9x=C9x*fvxset dvx=dvx*fvxset MSo=MSo*fvxendifcall MLo((oSx),Dsx(Iix)+C9x,Dtx(Iix)+dvx,fYx(Iix)+MSo)set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction Hwr takes integer oSx,integer Iix,boolean LTo,boolean OPx,real C9x,real dvx,real MSo returns nothingset jbe[oSx]=C9x
set jBe[oSx]=dvx
set jce[oSx]=MSo
set Ay[oSx]=Iixset jCe[oSx]=LTo
set jde[oSx]=OPx
call Mix((oSx),ny)if Hur(oSx)thencall iDx(Iy,jDe,true,function HUr)endifendfunctionfunction HWr takes nothing returns nothinglocal integer oSx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))call TimerStart(Oe[oSx],(GetRandomReal((((jge[(oSx)]))*1.),(((jFe[(oSx)]))*1.))),false,function HWr)
call rDx((jfe[(oSx)]))endfunctionfunction Hyr takes integer oSx,real HYr,real Hzr,code igx returns nothinglocal real ifx=(GetRandomReal(((HYr)*1.),((Hzr)*1.)))set jfe[(oSx)]=(Xkx(igx))set Je[(oSx)]=((GetHandleId(Condition((igx)))))set Be[(oSx)]=((LoadStr(j,(GetHandleId(Condition(((igx))))),0)))
set ce[(oSx)]=((ifx)*1.)
set jFe[(oSx)]=((Hzr)*1.)set jge[(oSx)]=((HYr)*1.)call TimerStart(Oe[oSx],ifx,false,function HWr)call idx(oSx)endfunctionfunction HZr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])call MFo(Mho)return trueendfunctionfunction H_r takes integer oSx,real o5x returns nothingset mkv[oSx]=o5x
set mKv[oSx]=trueset mlv[oSx]=o5x*o5x
endfunctionfunction H0r takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=oSxlocal integer rYx=jNe[oSx]local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real VMr=fYx(Cqx)local real NLx=S2R(dxx("acc","200."))local real bex=(GetRandomReal(((.0)*1.),((Cf)*1.)))local real bMr=(CQx((hCv),Uvv+(rYx)))*S2R(dxx("distFactor","0.75"))local real I4o=(GetRandomReal(((330.)*1.),((520.)*1.)))local real fvx=(GetRandomReal(((.5)*1.),((1.)*1.)))local real Nlx=S2R(dxx("speed","300."))local real iMx=Nkx(bMr,Nlx,NLx)local integer Mho=Moo()local integer HAxcall m4o(Mho,NLx)set mFv[(Mho)]=Xkx((function HZr))call Meo(Mho,Nlx)call H_r(Mho,100.)call MUo(Mho,wQo+bMr*(Cos(((((bex)*1.))*1.))),wso+bMr*(Sin(((((bex)*1.))*1.))),VMr+I4o)call o9r(Mho,wQo,wso,VMr)call FGr(Mho,kf)
if((GetRandomInt((0),(1)))==0)thenset HAx=Mno(Mho,'qBoC',fvx)else
set HAx=Mno(Mho,'qBCS',fvx)endifset mCv[(Mho)]=((64.)*1.)call mdx(HAx,255.,255.,255.,S2R(dxx("alpha","200.")))call QYo((HAx),-((0)*1.),-((0)*1.),-((0)*1.),-(((ty[(HAx)]))*1.),((iMx*S2R(dxx("durFactor","0.9")))*1.))
endfunctionfunction H1r takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer H2r=mDx('qBCA',(GetUnitX(C[((Iix))])),(GetUnitY(C[((Iix))])),fYx(Iix),(GetUnitFacing(C[((Iix))])*Nh))local integer p3x=iXx()set jIe[oSx]=H2r
set jAe[oSx]=p3x
set jNe[oSx]=rYx
set ge[(p3x)]=(oSx)call Hwr(H2r,Iix,false,false,.0,.0,.0)call Hyr(p3x,jGe,jhe,function H0r)return trueendfunctionfunction H3r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer H2r=jIe[oSx]local integer p3x=jAe[oSx]call MGx(H2r)call iKx(p3x)return trueendfunctionfunction H4r takes nothing returns nothingcall Lxx(H7e,Xdx("FolderBoulderCrash_StructVisuals_Init: call FolderBoulderCrash_StructVisuals.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderBoulderCrash_StructVisuals.Event_BuffGain))",bd,MI,function H1r))
call Lxx(H7e,Xdx("FolderBoulderCrash_StructVisuals_Init: call FolderBoulderCrash_StructVisuals.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderBoulderCrash_StructVisuals.Event_BuffLose))",jc,MI,function H3r))
endfunctionfunction H5r takes nothing returns booleanlocal integer rYxset jie=O5x()set jae=Xpx(function HLr)call Lxx(jve,Xdx("BoulderCrash_Init: call BoulderCrash.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BoulderCrash.Event_BuffGain))",bd,MI,function HQr))
call Lxx(jve,Xdx("BoulderCrash_Init: call BoulderCrash.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BoulderCrash.Event_BuffLose))",jc,MI,function HSr))
call mro(hCv,Xdx("BoulderCrash_Init: call BoulderCrash.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BoulderCrash.Event_EndCast))",onv,MI,function Htr))call mro(hCv,Xdx("BoulderCrash_Init: call BoulderCrash.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BoulderCrash.Event_SpellEffect))",ih,MI,function HTr))set rYx=(m6[(hCv)])loop
exitwhen(rYx<1)set jXe[rYx]=jxe[rYx]*jEeset rYx=rYx-1endloopcall H4r()return trueendfunctionfunction H6r takes nothing returns booleancall FAr(function H5r,"BoulderCrash_Init")return trueendfunctionfunction H7r takes nothing returns booleanset jHe=ltx(jje+" (eclipseBuff)")set Pc[(jHe)]=(true)
set uU[(jHe)]=(true)
return trueendfunctionfunction H8r takes nothing returns booleanset jJe=VCx("OCoT")return trueendfunctionfunction H9r takes nothing returns booleanset jke=VCx("OCon")return trueendfunctionfunction jvr takes nothing returns booleancall L1x('ACon',false)set jKe=L0o('ACon')set K6[(jKe)]=(O6)set m6[(jKe)]=(6)set TH[(jKe)]=("Conflagration")set Rh[(jKe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0264)))),(((Aj))))))set oxv[(jKe)]=(2)set x3v[(jKe)]=("spell")
call L1o((jKe),GH+(1),((9)*1.))call L1o((jKe),tH+(1),(('}')*1.))call L1o((jKe),Lov+(1),((500)*1.))call L1o((jKe),GH+(2),((9)*1.))call L1o((jKe),tH+(2),(($96)*1.))call L1o((jKe),Lov+(2),((550)*1.))call L1o((jKe),GH+(3),((9)*1.))call L1o((jKe),tH+(3),(($AF)*1.))call L1o((jKe),Lov+(3),((600)*1.))call L1o((jKe),GH+(4),((9)*1.))call L1o((jKe),tH+(4),(($C8)*1.))call L1o((jKe),Lov+(4),((650)*1.))call L1o((jKe),GH+(5),((9)*1.))call L1o((jKe),tH+(5),(($E1)*1.))call L1o((jKe),Lov+(5),((700)*1.))call L1o((jKe),GH+(6),((9)*1.))call L1o((jKe),tH+(6),(($FA)*1.))call L1o((jKe),Lov+(6),((750)*1.))set MOv[(jKe)]=("ReplaceableTextures\\CommandButtons\\BTNWallOfFire.blp")call cDr(jKe,'FCo0',6,'VCo0','LPCo','LRCo')set jle[1]=400set jle[2]=425set jle[3]=450set jle[4]=475set jle[5]=500set jle[6]=525set jLe[1]=25set jLe[2]=35set jLe[3]=45set jLe[4]=55set jLe[5]=65set jLe[6]=75set jme[1]=6
set jme[2]=7
set jme[3]=8
set jme[4]=9
set jme[5]=$Aset jme[6]=$Bset jMe[1]=650set jMe[2]=650set jMe[3]=650set jMe[4]=650set jMe[5]=650set jMe[6]=650set jpe[1]=3
set jpe[2]=3.5set jpe[3]=4
set jpe[4]=4.5set jpe[5]=5
set jpe[6]=5.5return trueendfunctionfunction jer takes nothing returns booleanset jPe=ltx(jje+" (ignitionBuff)")set Pc[(jPe)]=(true)
set uU[(jPe)]=(true)
return trueendfunctionfunction jxr takes nothing returns booleancall VNx(ma,(function H7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Conflagration.page\\Conflagration.struct\\obj_eclipseBuff_wc3buff.j"))call VNx(ha,(function H8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Conflagration.page\\Conflagration.struct\\obj_totalBolt_wc3bolt.j"))
call VNx(ha,(function H9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Conflagration.page\\Conflagration.struct\\obj_dummyBolt_wc3bolt.j"))
call VNx(Pa,(function jvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Conflagration.page\\Conflagration.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function jer),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Conflagration.page\\Conflagration.struct\\obj_ignitionBuff_wc3buff.j"))return trueendfunctionfunction jor takes nothing returns booleanset jqe=VXx(jje)
return trueendfunctionfunction jrr takes nothing returns booleanlocal integer Iix=jhx()if(I8x((Ose),Ob,(Iix)))thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenendifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction jir takes integer oSx returns integerset jUe[oSx]=trueset jwe[oSx]=falsecall rEx(jqe)return oSxendfunctionfunction jar takes nothing returns integerlocal integer oSxif(jSe==8190)thencall o_x("Conflagration_Allocation_allocCustom","call DebugEx(Conflagration.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",jje+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(jte[(w)]==w)thenset jTe=jTe+1set oSx=jTeelse
set oSx=jte[(w)]
set jte[(w)]=jte[jte[(w)]]endifset jte[oSx]=Zset jue[oSx]=1call jir(oSx)return oSxendfunctionfunction jnr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local real bex=jWe[oSx]local integer Cqx=jye[oSx]local integer HAx=jze[oSx]local real Czr=j_e[oSx]local real rPr=j2e[oSx]local real CZr=jZe[oSx]local integer svo=j3e[oSx]local real oyx=CZr+Czrlocal real x=(iJ[(HAx)])+j5e[oSx]local real y=(EJ[(HAx)])+j6e[oSx]local real jqx=Jie+(Jae-Jie)*(oyx*1./ rPr)local real jPx=Jie+(Jae-Jie)*(CZr*1./ rPr)local real jVr=x+jPx*(Cos(((((bex+Bev)*1.))*1.)))local real jEr=y+jPx*(Sin(((((bex+Bev)*1.))*1.)))local real jXr=x+jPx*(Cos(((((bex-Bev)*1.))*1.)))local real jOr=y+jPx*(Sin(((((bex-Bev)*1.))*1.)))local real jRr=x+Czr*(Cos(((((bex)*1.))*1.)))local real jIr=y+Czr*(Sin(((((bex)*1.))*1.)))local real jAr=jRr+jqx*(Cos(((((bex+Bev)*1.))*1.)))local real jNr=jIr+jqx*(Sin(((((bex+Bev)*1.))*1.)))local real jbr=jRr+jqx*(Cos(((((bex-Bev)*1.))*1.)))local real jBr=jIr+jqx*(Sin(((((bex-Bev)*1.))*1.)))local integer Iixlocal real Nbolocal integer rYxlocal real jcrcall cGo(j7e[oSx],jVr,jEr,X_x(jVr,jEr),jAr,jNr,X_x(jAr,jNr))
call cGo(j8e[oSx],jXr,jOr,X_x(jXr,jOr),jbr,jBr,X_x(jbr,jBr))
call cGo(j9e[oSx],jVr,jEr,X_x(jVr,jEr),jXr,jOr,X_x(jXr,jOr))
call cGo(Jve[oSx],jAr,jNr,X_x(jAr,jNr),jbr,jBr,X_x(jbr,jBr))
set jZe[oSx]=oyx
call Q1o(HAx,x,y)set hf=(ze[(Cqx)])set Ose=svocall Nqr(jQe,x,y,Czr,bex,jPx,jqx,jse)set Iix=NEo(jQe)
if(Iix!=w)thenset Nbo=jYe[oSx]
set rYx=j1e[oSx]
loop
call dQx(svo,Iix)if I9x(Iix,Wd)thenset jcr=jpe[rYx]
else
set jcr=jme[rYx]
endifcall Nbx((Iix),(jHe),(rYx),w,((jcr)*1.))
call Nbx(Iix,jPe,rYx,Cqx,jcr)call nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))set Iix=NEo(jQe)
exitwhen(Iix==w)
endloopendifendfunctionfunction jCr takes integer oSx returns nothingset jUe[oSx]=falsecall rHx(jqe)endfunctionfunction jdr takes integer oSx returns nothingif(jue[oSx]>0)thenreturnendifif(jte[oSx]!=Z)thencall o_x("Conflagration_Allocation_deallocCustom_confirm","call DebugEx(Conflagration.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",jje+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset jte[oSx]=jte[(w)]set jte[(w)]=oSx
call jCr(oSx)endfunctionfunction jDr takes integer oSx returns nothingset jue[oSx]=jue[oSx]-1call jdr(oSx)endfunctionfunction jfr takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local integer HAx=jze[oSx]local integer svo=j3e[oSx]local integer Q9o=j4e[oSx]call MGx(HAx)call iKx(iCx)call X_r(svo)call iKx(Q9o)call K0x(j7e[oSx])call K0x(j8e[oSx])call K0x(j9e[oSx])call K0x(Jve[oSx])call K0x(Jee[oSx])call K0x(Jxe[oSx])call K0x(Joe[oSx])call K0x(Jre[oSx])call jDr((oSx))endfunctionfunction jFr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real fvx=(eb[(Cqx)])local real dX=dVx-wQolocal real dY=dEx-wsolocal real bex=Ufx(Cqx,dX,dY)local real rPr=jle[rYx]*fvxlocal real n2x=(dox(Cqx,false)+.0)*fvxlocal real x=wQo+n2x*(Cos(((((bex)*1.))*1.)))local real y=wso+n2x*(Sin(((((bex)*1.))*1.)))local real d=jKx(dX,dY)local integer oSx=jar()local integer iCx=iXx()local integer Cir=QEx("/",true,false,false,$A,$A,l5)
local integer Q9o=iXx()local integer jgr=cdo(jJe)local integer jGr=cdo(jJe)local integer jhr=cdo(jJe)local integer jHr=cdo(jJe)local real jPxlocal real jqxlocal real jVrlocal real jErlocal real jXrlocal real jOrlocal real jRrlocal real jIrlocal real jArlocal real jNrlocal real jbrlocal real jBrlocal real iMxset jWe[oSx]=bex
set jye[oSx]=Cqx
set jYe[oSx]=jLe[rYx]set jze[oSx]=mDx('qCon',x,y,OMx(Cqx,x,y)+Opx(Cqx,true),bex)set jZe[oSx]=.0set j_e[oSx]=j0e[rYx]set j1e[oSx]=rYx
set j2e[oSx]=rPr
set j3e[oSx]=Jbx("Conflagration_Event_SpellEffect: set this.targetGroup = UnitList.Create()")set j4e[oSx]=Q9o
set j5e[oSx]=dX*1./ d*j0e[rYx]set j6e[oSx]=dY*1./ d*j0e[rYx]set ge[(iCx)]=(oSx)set ge[(Q9o)]=(oSx)set j7e[oSx]=cdo(jke)set j8e[oSx]=cdo(jke)set j9e[oSx]=cdo(jke)set Jve[oSx]=cdo(jke)set Jee[oSx]=jgr
set Jxe[oSx]=jGr
set Joe[oSx]=jhr
set Jre[oSx]=jHr
set jPx=Jieset jqx=Jaeset jVr=x+jPx*(Cos(((((bex+Bev)*1.))*1.)))set jEr=y+jPx*(Sin(((((bex+Bev)*1.))*1.)))set jXr=x+jPx*(Cos(((((bex-Bev)*1.))*1.)))set jOr=y+jPx*(Sin(((((bex-Bev)*1.))*1.)))set jRr=x+rPr*(Cos(((((bex)*1.))*1.)))set jIr=y+rPr*(Sin(((((bex)*1.))*1.)))set jAr=jRr+jqx*(Cos(((((bex+Bev)*1.))*1.)))
set jNr=jIr+jqx*(Sin(((((bex+Bev)*1.))*1.)))
set jbr=jRr+jqx*(Cos(((((bex-Bev)*1.))*1.)))
set jBr=jIr+jqx*(Sin(((((bex-Bev)*1.))*1.)))
call cGo(jgr,jVr,jEr,X_x(jVr,jEr),jAr,jNr,X_x(jAr,jNr))call cGo(jGr,jXr,jOr,X_x(jXr,jOr),jbr,jBr,X_x(jbr,jBr))call cGo(jhr,jVr,jEr,X_x(jVr,jEr),jXr,jOr,X_x(jXr,jOr))call cGo(jHr,jAr,jNr,X_x(jAr,jNr),jbr,jBr,X_x(jbr,jBr))set iMx=Nkx(rPr-j_e[oSx],jMe[rYx],.0)call SetUnitTimeScale(vJ[(jze[oSx])],((.5*1./ iMx)*1.))call mCx(jze[oSx],fvx)call P8o(Cir,x,y,X_x(x,y))call R4x(Cir,true)call iDx(Q9o,Jne,true,function jnr)call iDx(iCx,iMx,false,function jfr)
return trueendfunctionfunction jjr takes nothing returns booleanlocal integer oMxset jQe=O5x()set jse=Xpx(function jrr)call mro(jKe,Xdx("Conflagration_Init: call Conflagration.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Conflagration.Event_SpellEffect))",ih,MI,function jFr))
call W2x(EDv,jHe)call W2x(Xev,jPe)set oMx=(m6[(jKe)])loop
set JVe[oMx]=jle[oMx]*1./ jMe[oMx]set j0e[oMx]=jMe[oMx]*Jneset oMx=oMx-1exitwhen(oMx<1)endloopreturn trueendfunctionfunction jJr takes nothing returns booleancall FAr(function jjr,"Conflagration_Init")return trueendfunctionfunction jkr takes nothing returns booleancall L1x('ACyR',false)set JEe=L0o('ACyR')set K6[(JEe)]=(G6)set m6[(JEe)]=(3)set TH[(JEe)]=("Relocate")set Rh[(JEe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0085)))),(((Aj))))))set oxv[(JEe)]=(2)set x3v[(JEe)]=("spell")
call L1o((JEe),GH+(1),((0)*1.))call L1o((JEe),tH+(1),((0)*1.))call L1o((JEe),Lov+(1),((99999)*1.))
call L1o((JEe),GH+(2),((0)*1.))call L1o((JEe),tH+(2),((0)*1.))call L1o((JEe),Lov+(2),((99999)*1.))
set MOv[(JEe)]=("ReplaceableTextures\\CommandButtons\\BTNUndeadUnLoad.blp")call cDr(JEe,'FCR0',3,'VCR0','LPCR','LRCR')return trueendfunctionfunction jKr takes nothing returns booleancall VNx(Pa,(function jkr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Cyclone.page\\Cyclone.struct\\Relocate\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction jlr takes nothing returns booleanset JXe=VXx(JOe)
return trueendfunctionfunction jLr takes nothing returns booleancall L1x('ACyc',false)set g0v=L0o('ACyc')set K6[(g0v)]=(G6)set m6[(g0v)]=(3)set TH[(g0v)]=("Cyclone")set Rh[(g0v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D022D)))),(((Aj))))))set oxv[(g0v)]=(2)set x3v[(g0v)]=("spell")
call L1o((g0v),Uvv+(1),((500)*1.))call L1o((g0v),GH+(1),(('x')*1.))call L1o((g0v),tH+(1),(($96)*1.))call L1o((g0v),Lov+(1),(($3E8)*1.))call L1o((g0v),Uvv+(2),((500)*1.))call L1o((g0v),GH+(2),(('x')*1.))call L1o((g0v),tH+(2),(($C8)*1.))call L1o((g0v),Lov+(2),(($3E8)*1.))call L1o((g0v),Uvv+(3),((500)*1.))call L1o((g0v),GH+(3),(('x')*1.))call L1o((g0v),tH+(3),(($FA)*1.))call L1o((g0v),Lov+(3),(($3E8)*1.))set MOv[(g0v)]=("ReplaceableTextures\\CommandButtons\\BTNTornado.blp")call cDr(g0v,'FCy0',3,'VCy0','LPCy','LRCy')set JRe[1]=40set JRe[2]=40set JRe[3]=40set JIe[1]=$3E8set JIe[2]=$3E8set JIe[3]=$3E8set JAe[1]=3
set JAe[2]=3
set JAe[3]=3
set JNe[1]=50set JNe[2]=80set JNe[3]='x'return trueendfunctionfunction jmr takes nothing returns booleanset Jbe=hjo('uCyc')call hJo(((Jbe)),ASv,(Igv))set Uj[(Jbe)]=((1)*1.)call hko(Jbe,$FF,$FF,$FF,$FF)set NOv[(Jbe)]=(('d')*1.)set NWv[(Jbe)]=(('d')*1.)set NPv[(Jbe)]=((350)*1.)set I8v[(Jbe)]=((0)*1.)set Anv[(Jbe)]=(3)set Nmv[(Jbe)]=(($C8)*1.)set NLv[(Jbe)]=(($C8)*1.)set NKv[(Jbe)]=((0)*1.)set Npv[(Jbe)]=((0)*1.)set NMv[(Jbe)]=((0)*1.)set Nlv[(Jbe)]=((0)*1.)set Ncv[(Jbe)]=((800)*1.)set Nbv[(Jbe)]=((800)*1.)set NGv[(Jbe)]=((0)*1.)set Auv[(Jbe)]=((0)*1.)set AUv[(Jbe)]=((0)*1.)set AYv[(Jbe)]=(0)set A_v[(Jbe)]=(0)set ATv[(Jbe)]=((64)*1.)
call hpo((Jbe),(gtv),1)return trueendfunctionfunction jMr takes nothing returns booleancall VNx(Pa,(function jLr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Cyclone.page\\Cyclone.struct\\obj_thisSpell_wc3spell.j"))call VNx(sa,(function jmr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Cyclone.page\\Cyclone.struct\\obj_CycloneType_wc3unit.j"))return trueendfunctionfunction jpr takes nothing returns booleanset JBe=VXx(Jce)
return trueendfunctionfunction jPr takes nothing returns booleanlocal integer rFx=(bv)local integer jqr=(Vv[(rFx)])local integer Cqx=Jde[(jqr)]
call RPx(jqr,JCe)if rnx(Cqx,JDe,jqr)thenendifreturn trueendfunctionfunction jQr takes nothing returns booleanlocal integer Iix=jhx()if(I8x((Ose),Ob,(Iix)))thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction jsr takes integer oSx returns integerset JJe[oSx]=trueset Jke[oSx]=falsecall rEx(JBe)return oSxendfunctionfunction jSr takes nothing returns integerlocal integer oSxif(JGe==8190)thencall o_x("Cyclone_Allocation_allocCustom","call DebugEx(Cyclone.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Jce+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Jhe[(w)]==w)thenset JHe=JHe+1set oSx=JHeelse
set oSx=Jhe[(w)]
set Jhe[(w)]=Jhe[Jhe[(w)]]endifset Jhe[oSx]=Zset Jje[oSx]=1call jsr(oSx)return oSxendfunctionfunction jtr takes integer oSx returns nothingset JJe[oSx]=falsecall rHx(JBe)endfunctionfunction jTr takes integer oSx returns nothingif(Jje[oSx]>0)thenreturnendifif(Jhe[oSx]!=Z)thencall o_x("Cyclone_Allocation_deallocCustom_confirm","call DebugEx(Cyclone.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Jce+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Jhe[oSx]=Jhe[(w)]set Jhe[(w)]=oSx
call jtr(oSx)endfunctionfunction jur takes integer oSx returns nothingset Jje[oSx]=Jje[oSx]-1call jTr(oSx)endfunctionfunction jUr takes integer Cqx,integer jqr,integer rYx returns nothingset Jse=Cqxcall r0x((jqr),(JSe),(rYx))endfunctionfunction jwr takes integer Cqx,integer rYx,real x,real y returns nothing
local integer jqr=U0o(Jbe,(ze[(Cqx)]),x,y,kf,JRe[rYx])set Jde[(jqr)]=Cqxcall Avx(jqr,JCe)if rUx(Cqx,JDe,jqr)thenendifcall jUr(Cqx,jqr,rYx)endfunctionfunction jWr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=JKe[oSx]local integer rYx=Jme[oSx]local integer Q9o=Jqe[oSx]local real x=(mHv[(Mho)])local real y=(mjv[(Mho)])call jur((oSx))call MFo(Mho)call iKx(Q9o)call jwr(Cqx,rYx,x,y)return trueendfunctionfunction jyr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=JKe[oSx]local integer Mho=JLe[oSx]local integer rYx=Jme[oSx]local integer svo=JMe[oSx]local real x=(mHv[(Mho)])local real y=(mjv[(Mho)])local integer Iixlocal real Nbolocal real jYrset Ose=svoset hf=(ze[(Cqx)])call NVo(Jfe,(mHv[(Mho)]),(mjv[(Mho)]),(mCv[(Mho)]),JFe)
set Iix=NEo(Jfe)
if(Iix!=w)thenset Nbo=Jle[oSx]
set jYr=JAe[rYx]
loop
if not LLo(nbe,Iix)thencall dQx(svo,Iix)call nlo((Cqx),(Iix),((Nbo)*1.),(false),(false))
call Nbx((((Iix))),(Elv),(1),w,((((jYr)*1.))*1.))endifset Iix=NEo(Jfe)
exitwhen(Iix==w)
endloopendifendfunctionfunction jzr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real oyx=blx(jKx(dEx-wso,dVx-wQo),Jge,JIe[rYx])local real bex=Ufx(Cqx,dVx-wQo,dEx-wso)local integer oSxlocal integer Mholocal integer Q9oset dVx=wQo+oyx*(Cos(((((bex)*1.))*1.)))
set dEx=wso+oyx*(Sin(((((bex)*1.))*1.)))
set oSx=jSr()set Mho=Moo()set Q9o=iXx()set JKe[oSx]=Cqx
set Jle[oSx]=JNe[rYx]set JLe[oSx]=Mho
set Jme[oSx]=rYx
set JMe[oSx]=Jbx("Cyclone_Event_SpellEffect: set this.targetGroup = UnitList.Create()")set Jpe[oSx]=dVx
set JPe[oSx]=dEx
set Jqe[oSx]=Q9o
set ge[(Q9o)]=(oSx)call m4o(Mho,.0)
set mCv[(Mho)]=((JQe)*1.)set mFv[(Mho)]=Xkx((function jWr))set mZv[(Mho)]=(oSx)
call Meo(Mho,800)call pxo(Mho,Cqx)call o9r(Mho,dVx,dEx,X_x(dVx,dEx)+60.)call FGr(Mho,kf)
call Mno(Mho,'qCyc',.75)
call iDx(Q9o,Jte,true,function jyr)return trueendfunctionfunction jZr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local integer jqr=N6o(Cqx,JDe)call CBx(jqr,Bh,dVx,dEx)
return trueendfunctionfunction j_r takes nothing returns booleanset JCe=Xdx("Cyclone_Init: set Cyclone.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function Cyclone.Event_Destroy)",EP,MI,function jPr)set Jfe=O5x()set JFe=Xpx(function jQr)call mro(g0v,Xdx("Cyclone_Init: call Cyclone.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Cyclone.Event_SpellEffect))",ih,MI,function jzr))call mro(JEe,Xdx("FolderCyclone_StructRelocate_Init: call FolderCyclone_StructRelocate.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderCyclone_StructRelocate.Event_SpellEffect))",ih,MI,function jZr))return trueendfunctionfunction j0r takes nothing returns booleancall FAr(function j_r,"Cyclone_Init")return trueendfunctionfunction j1r takes nothing returns booleanset JTe=Wwx('BCyT',"Cyclone - Churned",'bCyT')set anv[(JTe)]=("ReplaceableTextures\\CommandButtons\\BTNCyclone.blp")return trueendfunctionfunction j2r takes nothing returns booleancall VNx(ma,(function j1r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Cyclone.page\\Cyclone.struct\\WindDance.page\\WindDance.struct\\Target\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction j3r takes nothing returns booleanset Jue=VXx(JUe)
return trueendfunctionfunction j4r takes nothing returns booleanset Jwe=Wwx('BCyA',"Cyclone Aura",'bCyA')set aav[(Jwe)]=(true)set anv[(Jwe)]=("ReplaceableTextures\\CommandButtons\\BTNTornado.blp")return trueendfunctionfunction j5r takes nothing returns booleanset JWe[1]=20set JWe[2]=30set JWe[3]=40return trueendfunctionfunction j6r takes nothing returns booleancall L1x('AWiD',false)set JSe=L0o('AWiD')set m6[(JSe)]=(3)set TH[(JSe)]=("Wind Dance")
set x3v[(JSe)]=("spell")
set MOv[(JSe)]=("ReplaceableTextures\\CommandButtons\\PASBTNWindDance.blp")return trueendfunctionfunction j7r takes nothing returns booleancall VNx(ma,(function j4r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Cyclone.page\\Cyclone.struct\\WindDance.page\\WindDance.struct\\obj_dummyBuff_wc3buff.j"))call VNx(va,(function j5r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Cyclone.page\\Cyclone.struct\\WindDance.page\\WindDance.struct\\obj_this_wc3obj.j"))
call VNx(Pa,(function j6r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Cyclone.page\\Cyclone.struct\\WindDance.page\\WindDance.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction j8r takes nothing returns booleanset Jye=VXx(JYe)
return trueendfunctionfunction j9r takes nothing returns booleancall L1x('ADeS',false)set GDv=L0o('ADeS')set K6[(GDv)]=(D6)set m6[(GDv)]=(6)set TH[(GDv)]=("Depriving Shock")set Rh[(GDv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0104)))),(((Aj))))))set oxv[(GDv)]=(4)set x3v[(GDv)]=("spell")
call L1o((GDv),Uvv+(1),(($96)*1.))call L1o((GDv),dH+(1),((2)*1.))call L1o((GDv),GH+(1),((4)*1.))call L1o((GDv),tH+(1),((30)*1.))
call L1o((GDv),Lov+(1),((575)*1.))call L1o((GDv),Uvv+(2),(($AF)*1.))call L1o((GDv),dH+(2),((2)*1.))call L1o((GDv),GH+(2),((4)*1.))call L1o((GDv),tH+(2),((45)*1.))
call L1o((GDv),Lov+(2),((575)*1.))call L1o((GDv),Uvv+(3),(($C8)*1.))call L1o((GDv),dH+(3),((2)*1.))call L1o((GDv),GH+(3),((4)*1.))call L1o((GDv),tH+(3),((60)*1.))
call L1o((GDv),Lov+(3),((575)*1.))call L1o((GDv),Uvv+(4),(($E1)*1.))call L1o((GDv),dH+(4),((2)*1.))call L1o((GDv),GH+(4),((4)*1.))call L1o((GDv),tH+(4),((75)*1.))
call L1o((GDv),Lov+(4),((575)*1.))call L1o((GDv),Uvv+(5),(($FA)*1.))call L1o((GDv),dH+(5),((2)*1.))call L1o((GDv),GH+(5),((4)*1.))call L1o((GDv),tH+(5),((90)*1.))
call L1o((GDv),Lov+(5),((575)*1.))call L1o((GDv),Uvv+(6),((275)*1.))call L1o((GDv),dH+(6),((2)*1.))call L1o((GDv),GH+(6),((4)*1.))call L1o((GDv),tH+(6),(('i')*1.))call L1o((GDv),Lov+(6),((575)*1.))set MOv[(GDv)]=("ReplaceableTextures\\CommandButtons\\BTNRavenForm.blp")
call cDr(GDv,'FDS0',6,'VDS0','LPDS','LRDS')return trueendfunctionfunction Jvr takes nothing returns booleanset Jze=Wwx('BDeS',"Revived",'bDeS')
set anv[(Jze)]=("ReplaceableTextures\\CommandButtons\\BTNAnimateDead.blp")return trueendfunctionfunction Jer takes nothing returns booleanset JZe=ltx(J_e+" (stunBuff)")return trueendfunctionfunction Jxr takes nothing returns booleanset J0e=VCx("ODeS")return trueendfunctionfunction Jor takes nothing returns booleanset J1e[1]=25set J1e[2]=25set J1e[3]=25set J1e[4]=25set J1e[5]=25set J1e[6]=25set J2e[1]=.5set J2e[2]=.5set J2e[3]=.5set J2e[4]=.5set J2e[5]=.5set J2e[6]=.5set J3e[1]=40set J3e[2]=60set J3e[3]=80set J3e[4]='d'set J3e[5]='x'set J3e[6]=$8Cset J4e[1]=65set J4e[2]='d'set J4e[3]=$8Cset J4e[4]=$B9set J4e[5]=$EBset J4e[6]=290set J5e[1]=.75set J5e[2]=.75set J5e[3]=.75set J5e[4]=.75set J5e[5]=.75set J5e[6]=.75return trueendfunctionfunction Jrr takes nothing returns booleancall VNx(Pa,(function j9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\DeprivingShock.page\\DeprivingShock.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function Jvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\DeprivingShock.page\\DeprivingShock.struct\\obj_summonBuff_wc3buff.j"))call VNx(ma,(function Jer),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\DeprivingShock.page\\DeprivingShock.struct\\obj_stunBuff_wc3buff.j"))call VNx(ha,(function Jxr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\DeprivingShock.page\\DeprivingShock.struct\\obj_bolt_wc3bolt.j"))call VNx(va,(function Jor),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\DeprivingShock.page\\DeprivingShock.struct\\obj_this_wc3obj.j"))
return trueendfunctionfunction Jir takes nothing returns booleanset J6e=VXx(J_e)
return trueendfunctionfunction Jar takes integer Iix,integer C3o,integer rYx returns nothingif not I9x(Iix,Qc)thenreturnendifcall Ryx((ACx((Iix),(kee),(kxe),(ri))))call aJr(Iix)call Dux((Iix),(Jze),(rYx),w)call acx(Iix,C3o)call U_o(Iix,J1e[rYx])set nJv[(Iix)]=(koe)
call fJx(Iix,-$80,-$80,-$80,0)endfunctionfunction Jnr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oMxlocal integer oSxlocal integer Cqxcall RPx(Iix,J7e)call RPx(Iix,J8e)set oMx=CIx(Iix,J9e)
loop
set oSx=CAx(Iix,J9e,oMx)
set Cqx=oSxset kve[oSx]=falsecall rnx(Iix,J9e,oSx)call Jar(Iix,(ze[(Cqx)]),kre[oSx])set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction JVr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oMxlocal integer oSxcall RPx(Iix,J7e)call RPx(Iix,J8e)set oMx=CIx(Iix,J9e)
loop
set oSx=CAx(Iix,J9e,oMx)
set kve[oSx]=falsecall rnx(Iix,J9e,oSx)set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction JEr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=oSxlocal integer Iix=kOe[oSx]local real YFo=iUx(kie[oSx],(lF[(Iix)]))
call Ydo(Cqx,Iix,YFo)call nlo((Cqx),(Iix),((kne[oSx]+YFo*kVe[oSx])*1.),(true),(false))call mno(Cqx,Cqx,YFo*kRe)endfunctionfunction JXr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local integer oSx=Cqxlocal integer JOr=iXx()local integer cMo=cdo(J0e)set kie[oSx]=J4e[rYx]*kaeset kne[oSx]=J3e[rYx]*kaeset kVe[oSx]=J5e[rYx]set kEe[oSx]=JOr
set kXe[oSx]=cMo
set kre[oSx]=rYx
set kOe[oSx]=Iix
set kve[oSx]=trueset ge[(JOr)]=(oSx)if rUx(Iix,J9e,oSx)thencall Avx(Iix,J7e)call Avx(Iix,J8e)endifcall ERr(cMo,Cqx,Iix)call A_o(Iix)call Dux((Iix),(JZe),(rYx),w)call iDx(JOr,kae,true,function JEr)return trueendfunctionfunction JRr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local boolean ELo=(oav[(rFx)])local integer oSx=Cqxlocal integer JOr=kEe[oSx]local integer cMo=kXe[oSx]local integer rYx=kre[oSx]local integer Iix=kOe[oSx]local boolean JIr=kve[oSx]call iKx(JOr)call K0x(cMo)if JIr thenif rnx(Iix,J9e,oSx)thencall RPx(Iix,J7e)call RPx(Iix,J8e)endifendifif ELo thencall fNx(Cqx,rYx)endifcall Ryx((ACx((Iix),(kIe),(kAe),(Bi))))call Nbx((Iix),(JZe),(rYx),w,((J2e[rYx])*1.))call Ulx(Iix,JZe)call Khx(Iix)return trueendfunctionfunction JAr takes nothing returns booleanset J7e=Xdx("DeprivingShock_Init: set DeprivingShock.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DeprivingShock.Event_Death)",VP,MI,function Jnr)set J8e=Xdx("DeprivingShock_Init: set DeprivingShock.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function DeprivingShock.Event_Destroy)",EP,MI,function JVr)
call mro(GDv,Xdx("DeprivingShock_Init: call DeprivingShock.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DeprivingShock.Event_SpellEffect))",ih,MI,function JXr))call mro(GDv,Xdx("DeprivingShock_Init: call DeprivingShock.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DeprivingShock.Event_EndCast))",onv,MI,function JRr))
call W2x(Xwv,JZe)return trueendfunctionfunction JNr takes nothing returns booleancall FAr(function JAr,"DeprivingShock_Init")
return trueendfunctionfunction Jbr takes nothing returns booleancall L1x('ABiB',false)set kNe=L0o('ABiB')set m6[(kNe)]=(3)set TH[(kNe)]=("Big Boom")set Rh[(kNe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D009B)))),(((Aj))))))set oxv[(kNe)]=(3)set x3v[(kNe)]=("spell")
call L1o((kNe),Uvv+(1),((300)*1.))call L1o((kNe),GH+(1),((0)*1.))call L1o((kNe),tH+(1),((0)*1.))call L1o((kNe),Lov+(1),((50)*1.))call L1o((kNe),Uvv+(2),((300)*1.))call L1o((kNe),GH+(2),((0)*1.))call L1o((kNe),tH+(2),((0)*1.))call L1o((kNe),Lov+(2),((50)*1.))call L1o((kNe),Uvv+(3),((300)*1.))call L1o((kNe),GH+(3),((0)*1.))call L1o((kNe),tH+(3),((0)*1.))call L1o((kNe),Lov+(3),((50)*1.))set MOv[(kNe)]=("ReplaceableTextures\\CommandButtons\\BTNSelfDestruct.blp")set kbe[1]=5
set kbe[2]=6
set kbe[3]=7
set kBe[1]=$Aset kBe[2]=$Cset kBe[3]=$Eset kce[1]='d'set kce[2]=$C8set kce[3]=300return trueendfunctionfunction JBr takes nothing returns booleanset kCe=ltx(kde+" (ignitionBuff)")set Pc[(kCe)]=(true)
return trueendfunctionfunction Jcr takes nothing returns booleancall VNx(Pa,(function Jbr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\BigBoom\\obj_thisSpell_wc3spell.j"))
call VNx(ma,(function JBr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\BigBoom\\obj_ignitionBuff_wc3buff.j"))return trueendfunctionfunction JCr takes nothing returns booleanset kDe=VXx(kde)
return trueendfunctionfunction Jdr takes nothing returns booleanset kfe=Wwx('BDGF',"Fire Buff",'bDGF')set aav[(kfe)]=(true)set Pc[(kfe)]=(true)
set anv[(kfe)]=("ReplaceableTextures\\CommandButtons\\BTNFire.blp")call lWx(kfe,"Abilities\\Spells\\Items\\AIfb\\AIfbTarget.mdl","weapon",ri)return trueendfunctionfunction JDr takes nothing returns booleanset kFe[1]=30set kFe[2]=30set kFe[3]=30set kge[1]='}'set kge[2]=$8Cset kge[3]=$A0set kGe[1]=.3set kGe[2]=.5set kGe[3]=.7return trueendfunctionfunction Jfr takes nothing returns booleancall VNx(ma,(function Jdr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\FireBuff\\obj_dummyBuff_wc3buff.j"))
call VNx(va,(function JDr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\FireBuff\\obj_this_wc3obj.j"))return trueendfunctionfunction JFr takes nothing returns booleanset khe=VXx(kHe)
return trueendfunctionfunction Jgr takes nothing returns booleanset kje[1]=3
set kje[2]=4
set kje[3]=5
return trueendfunctionfunction JGr takes nothing returns booleanset kJe=Wwx('BDGC',"Cold Buff",'bDGC')set aav[(kJe)]=(true)set anv[(kJe)]=("ReplaceableTextures\\CommandButtons\\BTNFrost.blp")
call lWx(kJe,"Abilities\\Spells\\Items\\AIob\\AIobTarget.mdl","weapon",ri)return trueendfunctionfunction Jhr takes nothing returns booleanset kke=ltx(kKe+" (coldnessBuff)")set Pc[(kke)]=(true)
return trueendfunctionfunction JHr takes nothing returns booleancall VNx(va,(function Jgr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\IceBuff\\obj_this_wc3obj.j"))call VNx(ma,(function JGr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\IceBuff\\obj_dummyBuff_wc3buff.j"))call VNx(ma,(function Jhr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\IceBuff\\obj_coldnessBuff_wc3buff.j"))return trueendfunctionfunction Jjr takes nothing returns booleanset kle=VXx(kKe)
return trueendfunctionfunction JJr takes nothing returns booleanset kLe=hjo('UDoG')call hpo((kLe),('AInv'),1)call hJo(((kLe)),ASv,(Wd))call hJo(((kLe)),ASv,(Idv))set Uj[(kLe)]=((1.3)*1.)
set NOv[(kLe)]=((80)*1.)
set NWv[(kLe)]=((80)*1.)
set NPv[(kLe)]=((320)*1.)set I8v[(kLe)]=((3)*1.)set Anv[(kLe)]=(4)set Nmv[(kLe)]=(('d')*1.)set NLv[(kLe)]=(('d')*1.)set NKv[(kLe)]=((0)*1.)set Npv[(kLe)]=(('d')*1.)set NMv[(kLe)]=(('d')*1.)set Nlv[(kLe)]=((0)*1.)set Ncv[(kLe)]=(($708)*1.)set Nbv[(kLe)]=(($708)*1.)set Adv[(kLe)]=(gkv)
set AGv[(kLe)]=(('x')*1.)set Ahv[((kLe))]=((1.*1./((1.3)*1.))*1.)
set AWv[(kLe)]=((.3)*1.)
set Auv[(kLe)]=(($A)*1.)
set AUv[(kLe)]=(($A)*1.)
set AYv[(kLe)]=(4)set A_v[(kLe)]=(4)set A2v[(kLe)]=(0)set ATv[(kLe)]=((32)*1.)
set bDv[(kLe)]=(($C)*1.)
set bjv[(kLe)]=((3.75)*1.)set bJv[(kLe)]=((1)*1.)set bfv[(kLe)]=(($A)*1.)
set bkv[(kLe)]=((3.5)*1.)set bFv[(kLe)]=((9.5)*1.)set bKv[(kLe)]=((4)*1.)return trueendfunctionfunction Jkr takes nothing returns booleancall L1x('ADoG',false)set gQv=L0o('ADoG')set K6[(gQv)]=(g6)set m6[(gQv)]=(3)set TH[(gQv)]=("Doppelganger")set Rh[(gQv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D009B)))),(((Aj))))))set oxv[(gQv)]=(2)set x3v[(gQv)]=("spell")
call L1o((gQv),GH+(1),((60)*1.))
call L1o((gQv),tH+(1),(($AF)*1.))call L1o((gQv),Lov+(1),((600)*1.))call L1o((gQv),GH+(2),((60)*1.))
call L1o((gQv),tH+(2),(($C8)*1.))call L1o((gQv),Lov+(2),((600)*1.))call L1o((gQv),GH+(3),((60)*1.))
call L1o((gQv),tH+(3),(($E1)*1.))call L1o((gQv),Lov+(3),((600)*1.))set MOv[(gQv)]=("ReplaceableTextures\\CommandButtons\\BTNAvengingWatcher.blp")call cDr(gQv,'FDG0',3,'VDG0','LPDG','LRDG')set kme[1]=.3set kme[2]=.5set kme[3]=.7set kMe[1]=45set kMe[2]=45set kMe[3]=45return trueendfunctionfunction JKr takes nothing returns booleanset kpe=ltx(kPe+" (dummyBuff)")return trueendfunctionfunction Jlr takes nothing returns booleanset kqe=Wwx('BDGI',"Doppelganger",'bDGI')set aav[(kqe)]=(true)set anv[(kqe)]=("ReplaceableTextures\\CommandButtons\\BTNDoom.blp")return trueendfunctionfunction JLr takes nothing returns booleancall VNx(sa,(function JJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\obj_thisUnitType_wc3unit.j"))call VNx(Pa,(function Jkr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function JKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\obj_dummyBuff_wc3buff.j"))call VNx(ma,(function Jlr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Doppelganger.page\\Doppelganger.struct\\obj_illusionBuff_wc3buff.j"))return trueendfunctionfunction Jmr takes nothing returns booleanset kQe=VXx(kPe)
return trueendfunctionfunction JMr takes nothing returns booleanlocal integer rFx=(bv)local integer Rbr=(Vv[(rFx)])local integer oSx=osx(Rbr,kSe)local integer Cqx=oSxlocal integer Okx=kte[oSx]set kTe[oSx]=wcall iKx(Okx)call rVx(Rbr,kSe)call RPx(Rbr,kse)call AZx(Cqx,kpe)return trueendfunctionfunction Jpr takes integer oSx,real x,real y,real z returns nothingcall fwx(oSx,x)call fWx(oSx,y)call fyx(oSx,x,y,z)endfunctionfunction JPr takes integer rYx,integer Iix returns nothingcall Nbx((Iix),(kfe),(rYx),w,((kFe[rYx])*1.))endfunctionfunction Jqr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local real x=(mHv[(Mho)])local real y=(mjv[(Mho)])local integer Cqx=oSxcall Mfx((bz[(Mho)]))call MFo(Mho)call Ulx(((Cqx)),O1v)call Jpr(Cqx,x,y,X_x(x,y))call JPr(kWe[oSx],Cqx)return trueendfunctionfunction JQr takes integer oSx,integer oux returns nothinglocal integer aCx=(bGv[(oSx)])if(oux!=aCx)then
call SetHeroLevel(C[(oSx)],oux,false)endifendfunctionfunction Jsr takes integer rYx,integer Iix returns nothingcall Dux((Iix),(kJe),(rYx),w)endfunctionfunction JSr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local real x=(mHv[(Mho)])local real y=(mjv[(Mho)])local integer Cqx=oSxlocal integer rYx=kWe[oSx]local integer Rbrcall Mfx((bz[(Mho)]))call MFo(Mho)set Rbr=Rur((Tf[(Cqx)]),(ze[(Cqx)]),x,y,(GetUnitFacing(C[((Cqx))])*Nh),kUe[oSx],k0e)
set kTe[oSx]=Rbr
call rwx(Rbr,kSe,oSx)call Avx(Rbr,kse)call Abo(Rbr)call qdo(Rbr)call r0x((Rbr),(kNe),(rYx))call Dux((Rbr),(kqe),(rYx),w)call RMr(Rbr,kwe[oSx])call JQr(Rbr,(bGv[(Cqx)]))call Jsr(rYx,Rbr)return trueendfunctionfunction Jtr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local real bex=kue[oSx]local integer Cqx=oSxlocal real Xcr=kye[oSx]local real XCr=kYe[oSx]local real dVx=kze[oSx]local real dEx=kZe[oSx]local real dX=dVx-Xcrlocal real dY=dEx-XCrlocal real d=iAx(k_e,jKx(dX,dY)-k_e)
local integer Mhoset bex=bex-Bevset dVx=Xcr+d*(Cos(((((bex)*1.))*1.)))set dEx=XCr+d*(Sin(((((bex)*1.))*1.)))set Mho=Moo()call m4o(Mho,500.)set mCv[(Mho)]=(((CQx((gQv),Uvv+(kWe[oSx]))))*1.)call Mno(Mho,'qDoG',1.)set mFv[(Mho)]=Xkx((function Jqr))set mZv[(Mho)]=(oSx)
call Meo(Mho,800.)call pxo(Mho,Cqx)call o9r(Mho,dVx,dEx,X_x(dVx,dEx)+60.)set bex=bex+3.141592654set Mho=Moo()set dVx=Xcr+d*(Cos(((((bex)*1.))*1.)))set dEx=XCr+d*(Sin(((((bex)*1.))*1.)))call m4o(Mho,500.)set mCv[(Mho)]=(((CQx((gQv),Uvv+(kWe[oSx]))))*1.)call Mno(Mho,'qDoG',1.)set mFv[(Mho)]=Xkx((function JSr))set mZv[(Mho)]=(oSx)
call Meo(Mho,800.)call pxo(Mho,Cqx)call o9r(Mho,dVx,dEx,X_x(dVx,dEx)+60.)endfunctionfunction JTr takes nothing returns booleanlocal integer rFx=(bv)local integer nSr=(Lc[(rFx)])local integer Cqx=(Vv[(rFx)])local integer rYx=(hc[(rFx)])local real dVx=(yH[(nSr)])local real dEx=(YH[(nSr)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local integer oSx=Cqxlocal integer Okx=iXx()set kue[oSx]=Ufx(Cqx,dVx-wQo,dEx-wso)set kte[oSx]=Okx
set kUe[oSx]=kMe[rYx]set kTe[oSx]=wset kwe[oSx]=kme[rYx]set kWe[oSx]=rYx
set kye[oSx]=wQo
set kYe[oSx]=wso
set kze[oSx]=dVx
set kZe[oSx]=dEx
set ge[(Okx)]=(oSx)call Dux((((Cqx))),(O1v),(1),w)call iDx(Okx,.5,false,function Jtr)return trueendfunctionfunction Jur takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oSx=Cqxlocal integer Rbr=kTe[oSx]if(Rbr!=w)thencall Crx((Rbr),w)endifreturn trueendfunctionfunction JUr takes integer oSx,integer Iax,integer rYx,integer I6x returns booleancall AZx(oSx,Iax)return Dux(oSx,Iax,rYx,I6x)endfunctionfunction Jwr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])call Nvo((Noo((((GetUnitX(C[((Cqx))])))*1.),(((GetUnitY(C[((Cqx))])))*1.),(k1e),(ri),(((eb[(Cqx)]))*1.))))call JUr(Cqx,kpe,(Mv[(rFx)]),rFx)return trueendfunctionfunction JWr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction Jyr takes integer Rbr returns integerreturn osx(Rbr,kSe)endfunctionfunction JYr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Jzr=Jyr(Cqx)local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local integer JZr=(Noo(((wQo)*1.),((wso)*1.),(k4e),(ri),(((eb[(Cqx)]))*1.)))
local integer Iixlocal real Nbolocal real J_rlocal real J0rlocal real Nfrcall o_r(BPv[(JZr)],((4.)*1.),((.25)*1.))call NGo(JZr,1.)
set JZr=(Noo(((wQo)*1.),((wso)*1.),(k5e),(ri),(((eb[(Cqx)]))*1.)))call o_r(BPv[(JZr)],((4.)*1.),((.25)*1.))call NGo(JZr,1.)
set hf=(ze[(Cqx)])call NVo(k2e,(GetUnitX(C[((Cqx))])),(GetUnitY(C[((Cqx))])),(CQx((kNe),Uvv+(rYx))),k3e)if(Jzr==w)thenset Jzr=Cqxendifset Iix=NEo(k2e)
if(Iix!=w)thenset Nbo=kce[rYx]
set J_r=kbe[rYx]
set J0r=kBe[rYx]
loop
if I9x(Iix,Wd)thenset Nfr=J_relse
set Nfr=J0rendifcall Nbx(Iix,kCe,rYx,Jzr,Nfr)call nlo((Jzr),(Iix),((Nbo)*1.),(false),(false))
set Iix=NEo(k2e)
exitwhen(Iix==w)
endloopendifcall Crx((Cqx),w)return trueendfunctionfunction J1r takes nothing returns nothingset k2e=O5x()set k3e=Xpx(function JWr)call mro(kNe,Xdx("FolderDoppelganger_StructBigBoom_Init: call FolderDoppelganger_StructBigBoom.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderDoppelganger_StructBigBoom.Event_SpellEffect))",ih,MI,function JYr))call W2x(Xev,kCe)endfunctionfunction J2r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(E2v[(rFx)])local integer w2o=(Vv[(rFx)])local integer oSx=Iixcall Ryx((ACx((w2o),("Abilities\\Weapons\\LordofFlameMissile\\LordofFlameMissile.mdl"),("chest"),(Bi))))
return trueendfunctionfunction J3r takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixset k7e[oSx]=O6o(Iix,kge[rYx],kGe[rYx])call Avx(Iix,k6e)return trueendfunctionfunction J4r takes integer oSx,integer O7o returns nothingcall rnx((oSx),APv,O7o)call fwo(((O7o)))endfunctionfunction J5r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall RPx(Iix,k6e)call J4r(Iix,k7e[oSx])return trueendfunctionfunction J6r takes nothing returns nothingset k6e=Xdx("FolderDoppelganger_StructFireBuff_Init: set FolderDoppelganger_StructFireBuff.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function FolderDoppelganger_StructFireBuff.Event_Damage)",E4v,MI,function J2r)call Lxx(kfe,Xdx("FolderDoppelganger_StructFireBuff_Init: call FolderDoppelganger_StructFireBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderDoppelganger_StructFireBuff.Event_BuffGain))",bd,MI,function J3r))call Lxx(kfe,Xdx("FolderDoppelganger_StructFireBuff_Init: call FolderDoppelganger_StructFireBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderDoppelganger_StructFireBuff.Event_BuffLose))",jc,MI,function J5r))endfunctionfunction J7r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(E2v[(rFx)])local integer w2o=(Vv[(rFx)])local integer oSx=Iixcall Nbx((w2o),(kke),(k9e[oSx]),w,((Kve[oSx])*1.))call Ryx((ACx((w2o),("Abilities\\Weapons\\LichMissile\\LichMissile.mdl"),("chest"),(Bi))))return trueendfunctionfunction J8r takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixset Kve[oSx]=kje[rYx]set k9e[oSx]=rYx
call Avx(Iix,k8e)return trueendfunctionfunction J9r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])call RPx(Iix,k8e)return trueendfunctionfunction kvr takes nothing returns nothingset k8e=Xdx("FolderDoppelganger_StructIceBuff_Init: set FolderDoppelganger_StructIceBuff.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function FolderDoppelganger_StructIceBuff.Event_Damage)",E4v,MI,function J7r)
call Lxx(kJe,Xdx("FolderDoppelganger_StructIceBuff_Init: call FolderDoppelganger_StructIceBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderDoppelganger_StructIceBuff.Event_BuffGain))",bd,MI,function J8r))
call Lxx(kJe,Xdx("FolderDoppelganger_StructIceBuff_Init: call FolderDoppelganger_StructIceBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderDoppelganger_StructIceBuff.Event_BuffLose))",jc,MI,function J9r))
call W2x(nVv,kke)endfunctionfunction ker takes nothing returns booleanset kse=Xdx("Doppelganger_Init: set Doppelganger.ILLUSION_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function Doppelganger.Event_IllusionDestroy)",EP,MI,function JMr)call Lxx(kpe,Xdx("Doppelganger_Init: call Doppelganger.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Doppelganger.Event_BuffGain))",bd,MI,function JTr))
call Lxx(kpe,Xdx("Doppelganger_Init: call Doppelganger.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Doppelganger.Event_BuffLose))",jc,MI,function Jur))
call mro(gQv,Xdx("Doppelganger_Init: call Doppelganger.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Doppelganger.Event_SpellEffect))",ih,MI,function Jwr))call J1r()call J6r()call kvr()return trueendfunctionfunction kxr takes nothing returns booleancall FAr(function ker,"Doppelganger_Init")return trueendfunctionfunction kor takes nothing returns booleancall L1x('AEbS',false)set GWv=L0o('AEbS')set K6[(GWv)]=(O6)set m6[(GWv)]=(6)set TH[(GWv)]=("Ebony Shot")
set Rh[(GWv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0089)))),(((Aj))))))set oxv[(GWv)]=(3)set x3v[(GWv)]=("attack")call L1o((GWv),Uvv+(1),((80)*1.))call L1o((GWv),GH+(1),(($E)*1.))
call L1o((GWv),tH+(1),((30)*1.))
call L1o((GWv),Lov+(1),(($3E8)*1.))call L1o((GWv),Uvv+(2),((80)*1.))call L1o((GWv),GH+(2),(($E)*1.))
call L1o((GWv),tH+(2),((40)*1.))
call L1o((GWv),Lov+(2),(($3E8)*1.))call L1o((GWv),Uvv+(3),((80)*1.))call L1o((GWv),GH+(3),(($E)*1.))
call L1o((GWv),tH+(3),((50)*1.))
call L1o((GWv),Lov+(3),(($3E8)*1.))call L1o((GWv),Uvv+(4),((80)*1.))call L1o((GWv),GH+(4),(($E)*1.))
call L1o((GWv),tH+(4),((60)*1.))
call L1o((GWv),Lov+(4),(($3E8)*1.))call L1o((GWv),Uvv+(5),((80)*1.))call L1o((GWv),GH+(5),(($E)*1.))
call L1o((GWv),tH+(5),((70)*1.))
call L1o((GWv),Lov+(5),(($3E8)*1.))call L1o((GWv),Uvv+(6),((80)*1.))call L1o((GWv),GH+(6),(($E)*1.))
call L1o((GWv),tH+(6),((80)*1.))
call L1o((GWv),Lov+(6),(($3E8)*1.))set MOv[(GWv)]=("ReplaceableTextures\\CommandButtons\\BTNImprovedBows.blp")call cDr(GWv,'FES0',6,'VES0','LPES','LRES')set Kee[1]=20set Kee[2]=20set Kee[3]=20set Kee[4]=20set Kee[5]=20set Kee[6]=20set Kxe[1]=3
set Kxe[2]=3
set Kxe[3]=5
set Kxe[4]=5
set Kxe[5]=7
set Kxe[6]=7
set Koe[1]=1.75set Koe[2]=1.75set Koe[3]=2
set Koe[4]=2
set Koe[5]=2.25set Koe[6]=2.25set Kre[1]=Bev*1*1./ 6set Kre[2]=Bev*1*1./ 6set Kre[3]=Bev*1*1./ 6set Kre[4]=Bev*1*1./ 6set Kre[5]=Bev*1*1./ 6set Kre[6]=Bev*1*1./ 6set Kie[1]=Bev*2*1./ 3set Kie[2]=Bev*2*1./ 3set Kie[3]=Bev*2*1./ 3set Kie[4]=Bev*2*1./ 3set Kie[5]=Bev*2*1./ 3set Kie[6]=Bev*2*1./ 3set Kae[1]=5
set Kae[2]=$Fset Kae[3]=30set Kae[4]=45set Kae[5]=65set Kae[6]=85return trueendfunctionfunction krr takes nothing returns booleanset Kne=ltx(KVe+" (ignitionBuff)")set Pc[(Kne)]=(true)
set uU[(Kne)]=(true)
return trueendfunctionfunction kir takes nothing returns booleancall VNx(Pa,(function kor),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\EbonyShot.page\\EbonyShot.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function krr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\EbonyShot.page\\EbonyShot.struct\\obj_ignitionBuff_wc3buff.j"))return trueendfunctionfunction kar takes nothing returns booleanset KEe=VXx(KVe)
return trueendfunctionfunction knr takes integer oSx returns nothingset KNe[oSx]=falsecall rHx(KEe)endfunctionfunction kVr takes integer oSx returns nothingif(KIe[oSx]>0)thenreturnendifif(KAe[oSx]!=Z)thencall o_x("EbonyShot_Allocation_deallocCustom_confirm","call DebugEx(EbonyShot.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",KVe+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset KAe[oSx]=KAe[(w)]set KAe[(w)]=oSx
call knr(oSx)endfunctionfunction kEr takes integer oSx returns nothingset KIe[oSx]=KIe[oSx]-1call kVr(oSx)endfunctionfunction kXr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSxlocal integer rvxcall m1x(Mho,KXe)set oSx=(mZv[(Mho)])
set rvx=KOe[oSx]-1if(rvx==0)thencall X_r(KRe[oSx])call kEr((oSx))else
set KOe[oSx]=rvx
endifreturn trueendfunctionfunction kOr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=jhx()local integer Mholocal integer oSxlocal integer Ctxif I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifset Mho=(ez[(rFx)])set oSx=(mZv[(Mho)])
set Ctx=KBe[oSx]
if(IsUnitAlly(C[(Iix)],vx[((ze[((EH[(Ctx)]))]))]))thenreturn false
endifif(I8x((KRe[oSx]),Ob,(Iix)))then
call nlo(((EH[(Ctx)])),(Iix),((Nzr("dmgGraze",Kee[(IH[(Ctx)])])*mEv)*1.),(true),(false))
return false
endifreturn truereturn trueendfunctionfunction kRr takes string rSx,integer Xfx returns integerif(HaveStoredString(Kv[((uH))],(rSx),("var")))thenreturn(S2I(((dex(uH,(rSx),"var")))))
endifreturn Xfxendfunctionfunction kIr takes integer oSx returns integerset KNe[oSx]=trueset Kfe[oSx]=falsecall rEx(KEe)return oSxendfunctionfunction kAr takes nothing returns integerlocal integer oSxif(Kde==8190)thencall o_x("EbonyShot_Allocation_allocCustom","call DebugEx(EbonyShot.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",KVe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(KAe[(w)]==w)thenset KDe=KDe+1set oSx=KDeelse
set oSx=KAe[(w)]
set KAe[(w)]=KAe[KAe[(w)]]endifset KAe[oSx]=Zset KIe[oSx]=1call kIr(oSx)return oSxendfunctionfunction kNr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])call MFo(Mho)return trueendfunctionfunction kbr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=(mZv[(Mho)])local real Nbo=KFe[oSx]local integer Ctx=KBe[oSx]local integer Cqx=(EH[(Ctx)])call dQx(KRe[oSx],Iix)call Ryx((ACx((Iix),(KHe),(Kje),(ri))))call nlo((Cqx),(Iix),((Nbo)*1.),(false),(true))return trueendfunctionfunction kBr takes integer oSx,integer Ctx,real bex,real kcr returns nothing
local integer Cqx=(EH[(Ctx)])local integer rYx=(IH[(Ctx)])local real dVx=(yh[(Ctx)])local real dEx=(Yh[(Ctx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local integer Mho=Moo()call Mox(Mho,KXe)set mCv[(Mho)]=(((CQx((GWv),Uvv+(rYx))))*1.)
call sEo((Mno(Mho,'qEbS',1.5)),(Kge),(KGe),(Bi))
set mZv[(Mho)]=(oSx)
set mFv[(Mho)]=Xkx((function kNr))call Meo(Mho,Khe)call pxo(Mho,Cqx)call o9r(Mho,wQo+kcr*(Cos(((((bex)*1.))*1.))),wso+kcr*(Sin(((((bex)*1.))*1.))),X_x(dVx,dEx)+Opx(Cqx,true))call rtr(Mho,function kbr,Kbe)endfunctionfunction kCr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local integer Ctx=(WH[(rFx)])local real wQolocal real wsolocal integer rYxlocal real d
local integer kdrlocal real kcrlocal real ctrlocal real bexlocal real iIrlocal integer oSxlocal integer oMxcall Ryx((ACx((Cqx),(Kce),(KCe),(Bi))))set wQo=(GetUnitX(C[((Cqx))]))set wso=(GetUnitY(C[((Cqx))]))set rYx=(IH[(Ctx)])set d=jKx(dVx-wQo,dEx-wso)set kdr=kRr("missiles",Kxe[rYx])
set kcr=Nzr("range",(CQx((GWv),Lov+(rYx))))set ctr=ddr(.0,Nzr("windowClose",Kie[rYx]),kcr,Nzr("windowFar",Kre[rYx]),d)set bex=(VH[(Ctx)])-ctr*1./ 2set iIr=ctr*1./(kdr-1)set oSx=kAr()set KOe[oSx]=kdr
set KFe[oSx]=Kae[rYx]+(Lg[(Cqx)])*Koe[rYx]set KRe[oSx]=Jbx("EbonyShot_Event_SpellEffect: set this.targetGroup = UnitList.Create()")set KBe[oSx]=Ctx
set oMx=kdrloop
exitwhen(oMx<1)call kBr(oSx,Ctx,bex,kcr)set bex=bex+iIrset oMx=oMx-1endloopreturn trueendfunctionfunction kDr takes nothing returns booleanset KXe=Xdx("EbonyShot_Init: set EbonyShot.MISSILE_DESTROY_EVENT = Event.Create(Missile.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function EbonyShot.Event_Missile_Destroy)",yY,MI,function kXr)
set Kbe=Xpx(function kOr)call mro(GWv,Xdx("EbonyShot_Init: call EbonyShot.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EbonyShot.Event_SpellEffect))",ih,MI,function kCr))
return trueendfunctionfunction kfr takes nothing returns booleancall FAr(function kDr,"EbonyShot_Init")return trueendfunctionfunction kFr takes nothing returns booleanset KJe=Wwx('BEmB',"Emphatic Bite",'bEmB')set aav[(KJe)]=(true)set anv[(KJe)]=("ReplaceableTextures\\CommandButtons\\BTNCannibalize.blp")call lWx(KJe,"Abilities\\Spells\\Orc\\Bloodlust\\BloodlustTarget.mdl","weapon",ri)set WU=l_x()
call l2x(WU,dHv,.1)call l3x(((KJe)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,dHv,.15)
call l3x(((KJe)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,dHv,.2)call l3x(((KJe)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,dHv,.25)
call l3x(((KJe)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,dHv,.3)call l3x(((KJe)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,dHv,.35)
call l3x(((KJe)),ZB+(6),(WU))return trueendfunctionfunction kgr takes nothing returns booleanset Kke[1]=.1set Kke[2]=.15set Kke[3]=.2set Kke[4]=.25set Kke[5]=.3set Kke[6]=.35set KKe[1]=8
set KKe[2]=8
set KKe[3]=8
set KKe[4]=8
set KKe[5]=8
set KKe[6]=8
return trueendfunctionfunction kGr takes nothing returns booleancall VNx(ma,(function kFr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\EmphaticBite.page\\EmphaticBite.struct\\Buff\\obj_dummyBuff_wc3buff.j"))
call VNx(va,(function kgr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\EmphaticBite.page\\EmphaticBite.struct\\Buff\\obj_this_wc3obj.j"))return trueendfunctionfunction khr takes nothing returns booleanset Kle=VXx(KLe)
return trueendfunctionfunction kHr takes nothing returns booleanset Kme=ltx(KMe+" (bleedingBuff)")set Pc[(Kme)]=(true)
return trueendfunctionfunction kjr takes nothing returns booleanset Kpe=ltx(KMe+" (dummyBuff)")set WU=l_x()
call vAr(WU,DLv,true)call l3x(((Kpe)),ZB+(1),(WU))return trueendfunctionfunction kJr takes nothing returns booleancall L1x('AEmC',false)set Giv=L0o('AEmC')set K6[(Giv)]=(O6)set m6[(Giv)]=(6)set TH[(Giv)]=("Emphatic Bite")set Rh[(Giv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00DC)))),(((Aj))))))set oxv[(Giv)]=(4)set x3v[(Giv)]=("spell")
call L1o((Giv),GH+(1),(($B)*1.))
call L1o((Giv),tH+(1),((75)*1.))
call L1o((Giv),Lov+(1),((700)*1.))call L1o((Giv),GH+(2),(($A)*1.))
call L1o((Giv),tH+(2),((85)*1.))
call L1o((Giv),Lov+(2),((700)*1.))call L1o((Giv),GH+(3),((9)*1.))call L1o((Giv),tH+(3),(('d')*1.))call L1o((Giv),Lov+(3),((700)*1.))call L1o((Giv),GH+(4),((8)*1.))call L1o((Giv),tH+(4),(('s')*1.))call L1o((Giv),Lov+(4),((700)*1.))call L1o((Giv),GH+(5),((7)*1.))call L1o((Giv),tH+(5),(($82)*1.))call L1o((Giv),Lov+(5),((700)*1.))call L1o((Giv),GH+(6),((7)*1.))call L1o((Giv),tH+(6),(($82)*1.))call L1o((Giv),Lov+(6),((700)*1.))set MOv[(Giv)]=("ReplaceableTextures\\CommandButtons\\BTNCannibalize.blp")call cDr(Giv,'FEB0',6,'VEB0','LPEB','LREB')set KPe[1]=3
set KPe[2]=3
set KPe[3]=3
set KPe[4]=3
set KPe[5]=3
set KPe[6]=3
set Kqe[1]=30set Kqe[2]=45set Kqe[3]=60set Kqe[4]=80set Kqe[5]='d'set Kqe[6]='}'set KQe[1]=45set KQe[2]=65set KQe[3]=90set KQe[4]='x'set KQe[5]=$9Bset KQe[6]=$C3set Kse[1]=45set Kse[2]=65set Kse[3]=90set Kse[4]='x'set Kse[5]=$9Bset Kse[6]=$C3return trueendfunctionfunction kkr takes nothing returns booleanset KSe=ltx(KMe+" (silenceBuff)")set Pc[(KSe)]=(true)
return trueendfunctionfunction kKr takes nothing returns booleancall VNx(ma,(function kHr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\EmphaticBite.page\\EmphaticBite.struct\\obj_bleedingBuff_wc3buff.j"))call VNx(ma,(function kjr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\EmphaticBite.page\\EmphaticBite.struct\\obj_dummyBuff_wc3buff.j"))call VNx(Pa,(function kJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\EmphaticBite.page\\EmphaticBite.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function kkr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\EmphaticBite.page\\EmphaticBite.struct\\obj_silenceBuff_wc3buff.j"))
return trueendfunctionfunction klr takes nothing returns booleanset Kte=VXx(KMe)
return trueendfunctionfunction kLr takes integer oSx,real kmr,real kMr,real kpr,real kPr,real kqr,real kQr,real iMx returns nothingif B2o(oSx)thencall OSr(oSx,kmr*c9v,kMr*c9v,kpr*c9v,kPr*c9v*c9v,kqr*c9v*c9v,kQr*c9v*c9v,iMx)endifendfunctionfunction ksr takes integer rYx,integer Iix returns nothingcall Nbx((Iix),(KJe),(rYx),w,((KKe[rYx])*1.))endfunctionfunction kSr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=oSxlocal integer rYx=KWe[oSx]local integer Iix=KZe[oSx]local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real dVxlocal real dExlocal real dXlocal real dYlocal real d
local real oyxlocal real bexlocal boolean ktrlocal real earlocal real enrif(Iix==w)thenset dVx=K0e[oSx]
set dEx=K1e[oSx]
else
set dVx=(GetUnitX(C[((Iix))]))set dEx=(GetUnitY(C[((Iix))]))endifset dX=dVx-wQoset dY=dEx-wsoset d=jKx(dX,dY)
set oyx=KTeset bex=(Atan2(((dY)*1.),((dX)*1.)))
set ktr=(d<oyx+K2e)set ear=wQo+oyx*(Cos(((((bex)*1.))*1.)))
set enr=wso+oyx*(Sin(((((bex)*1.))*1.)))
call fwx(Cqx,ear)call fWx(Cqx,enr)if ktr thencall AZx(Cqx,Kpe)if(Iix!=w)thencall Ryx((ACx((Iix),(K3e),(K4e),(Bi))))if(IsUnitAlly(C[(Iix)],vx[((ze[(Cqx)]))]))thencall ksr(rYx,Iix)call mao(Cqx,Iix,Kqe[rYx])else
call nlo((Cqx),(Iix),((Kse[rYx])*1.),(false),(true))
if not nbo(Iix)thencall Nbx((Iix),(Kpe),(rYx),w,((KPe[rYx])*1.))endifcall Nbx((Iix),(Kpe),(rYx),w,((KPe[rYx])*1.))endifcall mao(Cqx,Cqx,KQe[rYx])endifendifendfunctionfunction kTr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Cqx=(Vv[(rFx)])local integer Iix=Rb
local real jMx=(GetUnitX(C[((Cqx))]))local real jpx=(GetUnitY(C[((Cqx))]))local real dVx=(GetUnitX(C[((Iix))]))local real dEx=(GetUnitY(C[((Iix))]))local real bMr=jKx(dVx-jMx,dEx-jpx)local real kur=Nkx(bMr,Kue,.0)local real I4o=Kwe*bMrlocal integer oSx=Cqxlocal integer hCr=iXx()local integer Ctx=CPx(Cqx,Giv)local real OLxlocal real kUrset KWe[oSx]=rYx
set Kye[oSx]=hCr
set KYe[oSx]=jMx
set Kze[oSx]=jpx
set KZe[oSx]=Iix
set K_e[oSx]=Ctx
set ge[(hCr)]=(oSx)call SetUnitAnimation(C[((Cqx))],("attack"))
call QueueUnitAnimation(C[((Cqx))],("stand"))if(kur>0)thenset OLx=4*I4o*1./ kurset kUr=-8*I4o*1./ kur*1./ kurcall kLr(Cqx,.0,.0,OLx,.0,.0,kUr,kur)endifcall iDx(hCr,KUe,true,function kSr)return trueendfunctionfunction kwr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oSx=Cqxlocal integer hCr=Kye[oSx]local integer Iix=KZe[oSx]local integer Ctx=K_e[oSx]call iKx(hCr)call dNx(Ctx)return trueendfunctionfunction kWr takes nothing returns booleanlocal integer rFx=(bv)set Rb=(zH[(rFx)])call seo((Vv[(rFx)]),Kpe,(Mv[(rFx)]))return trueendfunctionfunction kyr takes nothing returns nothingendfunctionfunction kYr takes nothing returns booleanset KTe=Kue*KUecall Lxx(Kpe,Xdx("EmphaticBite_Init: call EmphaticBite.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EmphaticBite.Event_BuffGain))",bd,MI,function kTr))
call Lxx(Kpe,Xdx("EmphaticBite_Init: call EmphaticBite.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EmphaticBite.Event_BuffLose))",jc,MI,function kwr))
call mro(Giv,Xdx("EmphaticBite_Init: call EmphaticBite.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EmphaticBite.Event_SpellEffect))",ih,MI,function kWr))call W2x(Xlv,KSe)call W2x(Esv,Kme)call kyr()return trueendfunctionfunction kzr takes nothing returns booleancall FAr(function kYr,"EmphaticBite_Init")return trueendfunctionfunction kZr takes nothing returns booleancall L1x('AEnA',false)set GYv=L0o('AEnA')set K6[(GYv)]=(g6)set m6[(GYv)]=(3)set TH[(GYv)]=("Enchanted Arrow")set Rh[(GYv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0269)))),(((Aj))))))set oxv[(GYv)]=(2)set x3v[(GYv)]=("spell")
call L1o((GYv),Uvv+(1),(($C8)*1.))call L1o((GYv),dH+(1),((1)*1.))call L1o((GYv),GH+(1),((60)*1.))
call L1o((GYv),tH+(1),(($E1)*1.))call L1o((GYv),Lov+(1),((99999)*1.))
call L1o((GYv),Uvv+(2),(($C8)*1.))call L1o((GYv),dH+(2),((1)*1.))call L1o((GYv),GH+(2),((60)*1.))
call L1o((GYv),tH+(2),(($F0)*1.))call L1o((GYv),Lov+(2),((99999)*1.))
call L1o((GYv),Uvv+(3),(($C8)*1.))call L1o((GYv),dH+(3),((1)*1.))call L1o((GYv),GH+(3),((60)*1.))
call L1o((GYv),tH+(3),((260)*1.))call L1o((GYv),Lov+(3),((99999)*1.))
set MOv[(GYv)]=("ReplaceableTextures\\CommandButtons\\BTNImprovedStrengthOfTheMoon.blp")
call cDr(GYv,'FEA0',3,'VEA0','LPEA','LREA')set K5e[1]=99999
set K5e[2]=99999
set K5e[3]=99999
set K6e[1]=3
set K6e[2]=4
set K6e[3]=5
set K7e[1]=5
set K7e[2]=5
set K7e[3]=5
set K8e[1]=300set K8e[2]=400set K8e[3]=500return trueendfunctionfunction k_r takes nothing returns booleancall VNx(Pa,(function kZr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\EnchantedArrow.page\\EnchantedArrow.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction k0r takes nothing returns booleanset K9e=VXx(lve)
return trueendfunctionfunction k1r takes integer oSx returns nothingset lEe[oSx]=falsecall rHx(K9e)endfunctionfunction k2r takes integer oSx returns nothingif(lne[oSx]>0)thenreturnendifif(lVe[oSx]!=Z)thencall o_x("EnchantedArrow_Allocation_deallocCustom_confirm","call DebugEx(EnchantedArrow.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",lve+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset lVe[oSx]=lVe[(w)]set lVe[(w)]=oSx
call k1r(oSx)endfunctionfunction k3r takes integer oSx returns nothingset lne[oSx]=lne[oSx]-1call k2r(oSx)endfunctionfunction k4r takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=lre[oSx]local integer rYx=lie[oSx]local integer Q9o=lae[oSx]local real x=(mHv[(Mho)])local real y=(mjv[(Mho)])call iKx(Q9o)call m1x(Mho,loe)call k3r((oSx))return trueendfunctionfunction k5r takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction k6r takes integer oSx returns integerset lEe[oSx]=trueset lIe[oSx]=falsecall rEx(K9e)return oSxendfunctionfunction k7r takes nothing returns integerlocal integer oSxif(lOe==8190)thencall o_x("EnchantedArrow_Allocation_allocCustom","call DebugEx(EnchantedArrow.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",lve+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(lVe[(w)]==w)thenset lRe=lRe+1set oSx=lReelse
set oSx=lVe[(w)]
set lVe[(w)]=lVe[lVe[(w)]]endifset lVe[oSx]=Zset lne[oSx]=1call k6r(oSx)return oSxendfunctionfunction k8r takes integer oSx,integer Cqx,integer rYx,real x,real y returns nothing
local real O4o=(CQx((GYv),Uvv+(rYx)))local integer Iixlocal real Nbolocal real gYrcall Nvo((Noo(((x)*1.),((y)*1.),(lde),(ri),((O4o*1./ lDe)*1.))))
set hf=(ze[(Cqx)])call NVo(lxe,x,y,2*O4o,lXe)set Iix=NEo(lxe)
if(Iix!=w)thenset Nbo=lAe[oSx]
set gYr=lbe[oSx]
loop
call Nbx((((Iix))),((Xwv)),(1),w,((((gYr)*1.))*1.))call nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))set Iix=NEo(lxe)
exitwhen(Iix==w)
endloopendifendfunctionfunction k9r takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=lre[oSx]local integer rYx=lie[oSx]local real x=(mHv[(Mho)])local real y=(mjv[(Mho)])call MFo(Mho)call k8r(oSx,Cqx,rYx,x,y)return trueendfunctionfunction Kvr takes integer oSx,integer id,real fvx,real MVo returns integerlocal integer oux=mDx(id,(mHv[((oSx))]),(mjv[((oSx))]),(mJv[((oSx))]),MVo)call Max(oSx,oux)call mCx(oux,fvx)return ouxendfunctionfunction Ker takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real rPr=K5e[rYx]local real bex=Ufx(Cqx,dVx-wQo,dEx-wso)local integer oSxlocal integer Mholocal integer Q9oset dVx=wQo+rPr*(Cos(((((bex)*1.))*1.)))
set dEx=wso+rPr*(Sin(((((bex)*1.))*1.)))
set oSx=k7r()set Mho=Moo()set Q9o=iXx()set lre[oSx]=Cqx
set lAe[oSx]=K8e[rYx]+K6e[rYx]set lNe[oSx]=Mho
set lie[oSx]=rYx
set lbe[oSx]=K7e[rYx]set lBe[oSx]=Jbx("EnchantedArrow_Event_SpellEffect: set this.targetGroup = UnitList.Create()")set lce[oSx]=dVx
set lCe[oSx]=dEx
set lae[oSx]=Q9o
set ge[(Q9o)]=(oSx)call Mox(Mho,loe)call m4o(Mho,400.)set mCv[(Mho)]=(((CQx((GYv),Uvv+(rYx))))*1.)
set mFv[(Mho)]=Xkx((function k9r))set mZv[(Mho)]=(oSx)
call Meo(Mho,1100.)call pxo(Mho,Cqx)call sEo((Kvr(Mho,'qEnA',.0,(Atan2(((dEx-wso)*1.),((dVx-wQo)*1.))))),(lfe),(lFe),(Bi))call sEo(((bz[(Mho)])),(lge),(lGe),(Bi))
call o_r((bz[(Mho)]),5.,(CQx((GYv),dH+(rYx))))set lhe[(Cqx)]=oSxreturn trueendfunctionfunction Kxr takes integer oSx,integer Kor,integer Krr returns nothinglocal integer oMx=Ddx(oSx,Ob)local integer Kirloop
exitwhen(oMx<q)set Kir=DDx(oSx,Ob,oMx)if not LLo(Kor,Kir)thencall dQx(Krr,Kir)endifset oMx=oMx-1endloopendfunctionfunction Kar takes integer oSx returns realreturn mEvendfunctionfunction Knr takes integer oSx,real x,real y,real Jex,integer Q7x returns nothingif(Q7x==w)thenset Q7x=GKendifset Q7x=Nao(mQ,Q7x)call GroupEnumUnitsInRange(kb[((oSx))],((x)*1.),((y)*1.),((Jex)*1.),Bv[(Q7x)])endfunctionfunction KVr takes integer oSx returns nothingcall Dux(((oSx)),(XAv),(1),w)endfunctionfunction KEr takes nothing returns nothingcall KVr(ROx())endfunctionfunction KXr takes integer oSx returns nothingcall Ulx((oSx),XAv)endfunctionfunction KOr takes nothing returns nothingcall KXr(ROx())endfunctionfunction KRr takes real x,real y returns boolean
local item cpolocal real dVxlocal real dExlocal real d
call Knr(r7,x,y,$3E8,w)call ForGroup(kb[(r7)],(function KEr))set cpo=CreateItem('iUPN',x,y)call ForGroup(kb[(r7)],(function KOr))set dVx=GetWidgetX(cpo)set dEx=GetWidgetY(cpo)set d=GZx(dVx-x,dEx-y)call RemoveItem(cpo)
set cpo=null
return(d>1.)
endfunctionfunction KIr takes integer oSx returns nothingcall Myo(oSx,(mHv[((oSx))]),(mjv[((oSx))]),(mJv[((oSx))]))endfunctionfunction KAr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=lre[oSx]local integer Mho=lNe[oSx]local integer svo=lBe[oSx]local real dVx=lce[oSx]local real dEx=lCe[oSx]local real KNrlocal real Kbrlocal integer Iixlocal real bexlocal real Nlxlocal real KBrlocal real VPrlocal real Vqrlocal real earlocal real enrset Ose=svoset hf=(ze[(Cqx)])set KNr=(mHv[(Mho)])
set Kbr=(mjv[(Mho)])
call NVo(lxe,KNr,Kbr,(CQx((GYv),Uvv+(lie[oSx]))),lXe)call Kxr(svo,lxe,lee)loop
set Iix=(dpx((lee),Ob))exitwhen(Iix==w)
call IRo(svo,Iix)call Ulx(((Iix)),x5v)endloopset Iix=NEo(lxe)
if(Iix!=w)thenset bex=Mao(Mho)
set Nlx=(mLv[(Mho)])
set KBr=Kar(Mho)
set VPr=Nlx*lHe*(Cos(((((bex)*1.))*1.)))
set Vqr=Nlx*lHe*(Sin(((((bex)*1.))*1.)))
loop
if not(I8x((svo),Ob,(Iix)))thencall dQx(svo,Iix)call Dux((((Iix))),(x5v),(1),w)endifset ear=(GetUnitX(C[((Iix))]))+VPrset enr=(GetUnitY(C[((Iix))]))+Vqrif not KRr(ear,enr)thencall fzx(Iix,ear,enr)endifset Iix=NEo(lxe)
exitwhen(Iix==w)
endloopendifif KRr(KNr,Kbr)thencall KIr(Mho)endifendfunctionfunction Kcr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local boolean ELo=(oav[(rFx)])local integer oSx=lhe[(Cqx)]
local real dVxlocal real dExif not ELo thencall MFo(lNe[oSx])call DXx((Cqx),(GYv))call BNx(Cqx,(CQx((GYv),tH+(rYx))))return trueendifset dVx=lce[oSx]
set dEx=lCe[oSx]
call o9r(lNe[oSx],dVx,dEx,X_x(dVx,dEx)+60.)call iDx(lae[oSx],lHe,true,function KAr)
return trueendfunctionfunction KCr takes nothing returns booleanset lee=Jbx("EnchantedArrow_Init: set EnchantedArrow.DIFFERENCE_GROUP = UnitList.Create()")set lxe=O5x()set loe=Xdx("EnchantedArrow_Init: set EnchantedArrow.MISSILE_DESTROY_EVENT = Event.Create(Missile.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function EnchantedArrow.Event_Destroy)",yY,MI,function k4r)set lXe=Xpx(function k5r)call mro(GYv,Xdx("EnchantedArrow_Init: call EnchantedArrow.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnchantedArrow.Event_SpellEffect))",ih,MI,function Ker))call mro(GYv,Xdx("EnchantedArrow_Init: call EnchantedArrow.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function EnchantedArrow.Event_EndCast))",onv,MI,function Kcr))
return trueendfunctionfunction Kdr takes nothing returns booleancall FAr(function KCr,"EnchantedArrow_Init")
return trueendfunctionfunction KDr takes nothing returns booleancall L1x('AFSR',false)set lje=L0o('AFSR')set K6[(lje)]=(g6)set m6[(lje)]=(3)set TH[(lje)]=("Revert")
set Rh[(lje)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0104)))),(((Aj))))))set oxv[(lje)]=(0)set x3v[(lje)]=("spell")
call L1o((lje),GH+(1),((0)*1.))call L1o((lje),Lov+(1),((750)*1.))call L1o((lje),GH+(2),((0)*1.))call L1o((lje),Lov+(2),((750)*1.))call L1o((lje),GH+(3),((0)*1.))call L1o((lje),Lov+(3),((750)*1.))set MOv[(lje)]=("ReplaceableTextures\\CommandButtons\\BTNNeutralManaShieldOff.blp")call cDr(lje,'FFX0',3,'VFX0','LPFX','LRFX')return trueendfunctionfunction Kfr takes nothing returns booleanset lJe=ltx(lke+" (dummyBuff)")set Pc[(lJe)]=(true)
call lWx(lJe,"Abilities\\Spells\\NightElf\\Barkskin\\BarkSkinTarget.mdl","hand left",ri)
call lWx(lJe,"Abilities\\Spells\\NightElf\\Barkskin\\BarkSkinTarget.mdl","hand right",ri)return trueendfunctionfunction KFr takes nothing returns booleancall VNx(Pa,(function KDr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairyShape.page\\FairyShape.struct\\Revert\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function Kfr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairyShape.page\\FairyShape.struct\\Revert\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction Kgr takes nothing returns booleanset lKe=VXx(lke)
return trueendfunctionfunction KGr takes nothing returns booleancall L1x('AFSX',false)return trueendfunctionfunction Khr takes nothing returns booleanset lle=ltx(lLe+" (eclipseBuff)")return trueendfunctionfunction KHr takes nothing returns booleancall L1x('AFSC',false)return trueendfunctionfunction Kjr takes nothing returns booleanlocal integer rFx=(bv)local integer IQx=(Fc[(rFx)])call D9x(((Vv[(rFx)])),dPv[(IQx)],dqv[(IQx)])return trueendfunctionfunction KJr takes nothing returns booleanlocal integer rFx=(bv)local integer IQx=(Fc[(rFx)])call D9x((((Vv[(rFx)]))),-((dPv[(IQx)])*1.),((dqv[(IQx)])*1.))return trueendfunctionfunction Kkr takes integer oSx,real fvx,real DJo returns integer
local integer IQx=rUo(dpv,function Kjr,function KJr)
set dPv[(IQx)]=fvxset dqv[(IQx)]=DJoreturn IQxendfunctionfunction KKr takes nothing returns booleanset c3e=ltx(lLe+" (dummyBuff)")set Pc[(c3e)]=(true)
set WU=l_x()
call vAr(WU,DOv,true)call l0x(((WU)),fc,(Kkr(db,1,.5)))call l3x(((c3e)),ZB+(1),(WU))set WU=l_x()
call vAr(WU,DOv,true)call l0x(((WU)),fc,(Kkr(db,1,.5)))call l3x(((c3e)),ZB+(2),(WU))set WU=l_x()
call vAr(WU,DOv,true)call l0x(((WU)),fc,(Kkr(db,1,.5)))call l3x(((c3e)),ZB+(3),(WU))return trueendfunctionfunction Klr takes nothing returns booleanset lme=hjo('ULFS')call hpo((lme),('AInv'),1)call hJo(((lme)),ASv,(Wd))call hJo(((lme)),ASv,(Idv))set Uj[(lme)]=((1.25)*1.)set NOv[(lme)]=((83.044982698962)*1.)set NWv[(lme)]=((91.349480968858)*1.)set NPv[(lme)]=((305)*1.)set I8v[(lme)]=((0)*1.)set Anv[(lme)]=(4)set Nmv[(lme)]=(('d')*1.)set NLv[(lme)]=(('d')*1.)set NKv[(lme)]=((0)*1.)set Npv[(lme)]=(('d')*1.)set NMv[(lme)]=(('d')*1.)set Nlv[(lme)]=((0)*1.)set Ncv[(lme)]=(($708)*1.)set Nbv[(lme)]=(($708)*1.)set Adv[(lme)]=(guv)
set AGv[(lme)]=((720)*1.)set Ahv[((lme))]=((1.*1./((1.7)*1.))*1.)
set AWv[(lme)]=((.55)*1.)set Dnv[(lme)]=((900)*1.)set Auv[(lme)]=(($E)*1.)
set AUv[(lme)]=(($E)*1.)
set AYv[(lme)]=(1)set A_v[(lme)]=($E)set A2v[(lme)]=(3)set ATv[(lme)]=((37.647058823529)*1.)call hqo(lme,g5v)call hqo(lme,g6v)call hqo(lme,g7v)call hqo(lme,lMe)set bDv[(lme)]=((7.5)*1.)set bjv[(lme)]=((3)*1.)set bJv[(lme)]=((.4)*1.)
set bfv[(lme)]=((17.5)*1.)set bkv[(lme)]=((4.5)*1.)set bFv[(lme)]=((5)*1.)set bKv[(lme)]=((2.5)*1.)return trueendfunctionfunction KLr takes nothing returns booleanset lpe=VCx("OFaS")return trueendfunctionfunction Kmr takes nothing returns booleancall L1x('AFaS',false)set g7v=L0o('AFaS')set K6[(g7v)]=(g6)set m6[(g7v)]=(3)set TH[(g7v)]=("Fairy Shape")set Rh[(g7v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00D3)))),(((Aj))))))set oxv[(g7v)]=(0)set x3v[(g7v)]=("spell")
call L1o((g7v),Uvv+(1),((300)*1.))call L1o((g7v),GH+(1),(($F)*1.))
call L1o((g7v),tH+(1),((90)*1.))
call L1o((g7v),Lov+(1),((750)*1.))call L1o((g7v),Uvv+(2),((300)*1.))call L1o((g7v),GH+(2),(($F)*1.))
call L1o((g7v),tH+(2),(('i')*1.))call L1o((g7v),Lov+(2),((750)*1.))call L1o((g7v),Uvv+(3),((300)*1.))call L1o((g7v),GH+(3),(($F)*1.))
call L1o((g7v),tH+(3),(('x')*1.))call L1o((g7v),Lov+(3),((750)*1.))set MOv[(g7v)]=("ReplaceableTextures\\CommandButtons\\BTNManaBurn.blp")call cDr(g7v,'FFS0',3,'VFS0','LPFS','LRFS')set lPe[1]=50set lPe[2]=80set lPe[3]='n'set lqe[1]=5
set lqe[2]=5
set lqe[3]=5
set lQe[1]=6
set lQe[2]=6
set lQe[3]=6
set lse[1]=$Aset lse[2]=$Eset lse[3]=$Eset lSe[1]=4
set lSe[2]=4
set lSe[3]=4
set HRe[1]=4
set HRe[2]=5
set HRe[3]=6
set lte[1]=.5set lte[2]=.5set lte[3]=.5set c5e[1]=.5set c5e[2]=.7set c5e[3]=.9set lTe[1]=2
set lTe[2]=2
set lTe[3]=2
return trueendfunctionfunction KMr takes nothing returns booleancall VNx(Pa,(function KGr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairyShape.page\\FairyShape.struct\\obj_revertAbility_wc3spell.j"))call VNx(ma,(function Khr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairyShape.page\\FairyShape.struct\\obj_eclipseBuff_wc3buff.j"))
call VNx(Pa,(function KHr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairyShape.page\\FairyShape.struct\\obj_changerAbility_wc3spell.j"))
call VNx(ma,(function KKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairyShape.page\\FairyShape.struct\\obj_dummyBuff_wc3buff.j"))call VNx(sa,(function Klr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairyShape.page\\FairyShape.struct\\obj_thisUnitType_wc3unit.j"))call VNx(ha,(function KLr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairyShape.page\\FairyShape.struct\\obj_bolt_wc3bolt.j"))call VNx(Pa,(function Kmr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairyShape.page\\FairyShape.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Kpr takes nothing returns booleanset lue=VXx(lLe)
return trueendfunctionfunction KPr takes nothing returns booleanlocal integer Cqx=Rb
local integer Iix=jhx()local integer Kqrif I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif((lF[(Iix)])<=.0)thenreturn false
endifset Kqr=osx(Cqx,lWe+Iix)
if(Kqr<lye)thenset lye=Kqrendifreturn truereturn trueendfunctionfunction KQr takes integer oSx,integer AKo,integer Ksr returns nothingcall rtx((oSx),Ksr)call UnitRemoveAbility(C[(((oSx)))],(Ksr))call Alo(oSx,AKo)endfunctionfunction KSr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=ROx()if(osx(Rb,lWe+Iix)>lye)thencall GroupRemoveUnit(kb[(lUe)],C[(Iix)])
endifreturn trueendfunctionfunction Ktr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local real O4o=lYe[oSx]local integer Cqx=oSxlocal integer rYx=l_e[oSx]local real x=(GetUnitX(C[((Cqx))]))local real y=(GetUnitY(C[((Cqx))]))local integer Iixlocal real KTrlocal real AXrlocal integer svolocal integer cMolocal real Kurlocal real YFoset hf=(ze[(Cqx)])set Rb=Cqxset lye=l3ecall NVo(lUe,x,y,O4o,lwe)call ForGroup(kb[(lUe)],(function KSr))set Iix=(mKo((lUe),((x)*1.),((y)*1.)))if(Iix!=w)thenset KTr=lze[oSx]
set AXr=lZe[oSx]
set svo=l2e[oSx]
call Aex(Cqx,lWe+Iix,1)if not LLo(svo,Iix)thencall A_o(Iix)call GroupAddUnit(kb[(svo)],C[(Iix)])endifset cMo=cdo(lpe)
call ERr(cMo,Cqx,Iix)call cLo(cMo,.35)call Ryx((ACx((Iix),(l4e),(l5e),(ri))))if not nbo(Iix)thenif I9x(Iix,Wd)thenset Kur=lTe[rYx]
else
set Kur=lSe[rYx]
endifcall Nbx((Iix),(lle),(rYx),w,((Kur)*1.))
set YFo=iUx((lF[(Iix)]),KTr)
call Ydo(Cqx,Iix,YFo)call mao(Cqx,Cqx,YFo*1./ KTr*AXr)endifendifendfunctionfunction KUr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(hc[(rFx)])local integer oSx=Cqxlocal integer p3x=iXx()set lYe[oSx]=(CQx((g7v),Uvv+(rYx)))set lze[oSx]=lPe[rYx]set lZe[oSx]=lse[rYx]set l_e[oSx]=rYx
set l0e[oSx]=(Tf[(Cqx)])
set l1e[oSx]=p3x
set l2e[oSx]=O5x()set ge[(p3x)]=(oSx)call KQr(Cqx,lme,'AFSC')
call iDx(p3x,lte[rYx],true,function Ktr)
if(osx((((Cqx))),(Wb+(l6e)))>0)thencall AZx(Cqx,DH)
endifreturn trueendfunctionfunction Kwr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oSx=Cqxlocal integer p3x=l1e[oSx]local integer KWr=l0e[oSx]local integer svo=l2e[oSx]local integer Iixcall iKx(p3x)loop
set Iix=NEo(svo)
exitwhen(Iix==w)
call rVx(Cqx,lWe+Iix)call Khx(Iix)endloopcall KQr(Cqx,KWr,'AFSX')
return trueendfunctionfunction Kyr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(Mv[(rFx)])call Nbx(((Vv[(rFx)])),(c3e),(rYx),w,((lqe[rYx])*1.))return trueendfunctionfunction KYr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local real x=l7e
local real y=l8e
local integer oSx=Iixset l9e[oSx]=(mko(((x)*1.),((y)*1.),(Lve),(ri)))
set Lee[oSx]=xset Lxe[oSx]=yreturn trueendfunctionfunction Kzr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer KZr=l9e[oSx]call mho(KZr)return trueendfunctionfunction K_r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oSx=Cqxlocal real x=Lee[oSx]local real y=Lxe[oSx]call AZx(Cqx,lJe)call mho((mko((((GetUnitX(C[((Cqx))])))*1.),(((GetUnitY(C[((Cqx))])))*1.),(Loe),(ri))))call Jpr(Cqx,x,y,X_x(x,y))call mho((mko(((x)*1.),((y)*1.),(Lre),(ri))))call AZx(Cqx,c3e)return trueendfunctionfunction K0r takes nothing returns nothingcall Lxx(lJe,Xdx("FolderFairyShape_StructRevert_Init: call FolderFairyShape_StructRevert.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderFairyShape_StructRevert.Event_BuffGain))",bd,MI,function KYr))call Lxx(lJe,Xdx("FolderFairyShape_StructRevert_Init: call FolderFairyShape_StructRevert.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderFairyShape_StructRevert.Event_BuffLose))",jc,MI,function Kzr))call mro(lje,Xdx("FolderFairyShape_StructRevert_Init: call FolderFairyShape_StructRevert.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderFairyShape_StructRevert.Event_SpellEffect))",ih,MI,function K_r))
endfunctionfunction K1r takes nothing returns booleanset lUe=O5x()set lwe=Xpx(function KPr)call Lxx(c3e,Xdx("FairyShape_Init: call FairyShape.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FairyShape.Event_BuffGain))",bd,MI,function KUr))call Lxx(c3e,Xdx("FairyShape_Init: call FairyShape.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FairyShape.Event_BuffLose))",jc,MI,function Kwr))call mro(g7v,Xdx("FairyShape_Init: call FairyShape.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FairyShape.Event_SpellEffect))",ih,MI,function Kyr))call W2x(EDv,lle)call K0r()return trueendfunctionfunction K2r takes nothing returns booleancall FAr(function K1r,"FairyShape_Init")
return trueendfunctionfunction K3r takes nothing returns booleanset Lie[1]=1
set Lie[2]=2
set Lie[3]=3
set Lae[1]=$Fset Lae[2]=25set Lae[3]=35return trueendfunctionfunction K4r takes nothing returns booleanset Lne=ltx(LVe+" (coldnessBuff)")set Pc[(Lne)]=(true)
set uU[(Lne)]=(true)
return trueendfunctionfunction K5r takes nothing returns booleanset LEe=ltx(LVe+" (dummyBuff)")set Pc[(LEe)]=(true)
call lWx(LEe,"Abilities\\Spells\\NightElf\\Starfall\\StarfallTarget.mdl","origin",ri)return trueendfunctionfunction K6r takes nothing returns booleancall VNx(va,(function K3r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairysTears.page\\FairysTears.struct\\Target\\obj_this_wc3obj.j"))call VNx(ma,(function K4r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairysTears.page\\FairysTears.struct\\Target\\obj_coldnessBuff_wc3buff.j"))call VNx(ma,(function K5r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairysTears.page\\FairysTears.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction K7r takes nothing returns booleanset LXe=VXx(LVe)
return trueendfunctionfunction K8r takes nothing returns booleancall L1x('AFyT',false)set LOe=L0o('AFyT')set K6[(LOe)]=(g6)set m6[(LOe)]=(3)set TH[(LOe)]=("Fairy's Tears")set Rh[(LOe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00D7)))),(((Aj))))))set oxv[(LOe)]=(0)set x3v[(LOe)]=("spell,channel")
call L1o((LOe),Uvv+(1),((450)*1.))call L1o((LOe),dH+(1),((24)*1.))
call L1o((LOe),GH+(1),((80)*1.))
call L1o((LOe),tH+(1),(($FA)*1.))call L1o((LOe),Lov+(1),((750)*1.))call L1o((LOe),Uvv+(2),((525)*1.))call L1o((LOe),dH+(2),((27)*1.))
call L1o((LOe),GH+(2),((80)*1.))
call L1o((LOe),tH+(2),((350)*1.))call L1o((LOe),Lov+(2),((750)*1.))call L1o((LOe),Uvv+(3),((600)*1.))call L1o((LOe),dH+(3),((30)*1.))
call L1o((LOe),GH+(3),((80)*1.))
call L1o((LOe),tH+(3),((450)*1.))call L1o((LOe),Lov+(3),((750)*1.))set MOv[(LOe)]=("ReplaceableTextures\\CommandButtons\\BTNStarfall.blp")call cDr(LOe,'FFy0',3,'VFy0','LPFy','LRFy')return trueendfunctionfunction K9r takes nothing returns booleanset LRe=ltx(LIe+" (dummyBuff)")call lWx(LRe,"Abilities\\Spells\\NightElf\\Starfall\\StarfallCaster.mdl","origin",ri)return trueendfunctionfunction lvr takes nothing returns booleancall VNx(Pa,(function K8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairysTears.page\\FairysTears.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function K9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FairysTears.page\\FairysTears.struct\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction ler takes nothing returns booleanset LAe=VXx(LIe)
return trueendfunctionfunction lxr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif(osx((((Iix))),(Wb+(LEe)))>0)thenreturn false
endifreturn truereturn trueendfunctionfunction lor takes integer Cqx,real Nbo,integer rYx,integer Iix returns nothingset Ff=Nboset Rb=Cqxcall Nbx((Iix),(LEe),(rYx),w,((Lge)*1.))
endfunctionfunction lrr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxlocal integer waoset hf=(ze[(Iix)])call NVo(LNe,(GetUnitX(C[((Iix))])),(GetUnitY(C[((Iix))])),LBe[oSx],Lbe)
set wao=(oXr((LNe)))
if(wao!=w)thencall lor(Iix,Lce[oSx],Lfe[oSx],wao)endifendfunctionfunction lir takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local real dVx=(GetUnitX(C[((Iix))]))local real dEx=(GetUnitY(C[((Iix))]))local integer oSx=Iixlocal integer HAx=mDx('qStf',dVx,dEx,X_x(dVx,dEx),.0)local integer p3x=iXx()set LBe[oSx]=(CQx((LOe),Uvv+(rYx)))set Lce[oSx]=Lae[rYx]+(zF[(Iix)])*LCeset Lde[oSx]=HAx
set LDe[oSx]=p3x
set Lfe[oSx]=rYx
set ge[(p3x)]=(oSx)call Hwr(HAx,Iix,false,false,.0,.0,.0)call k5o(HAx,(CQx((LOe),Uvv+(rYx)))*4*1./(4*128.))call iDx(p3x,LFe,true,function lrr)return trueendfunctionfunction lar takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer HAx=Lde[oSx]local integer p3x=LDe[oSx]call MGx(HAx)call iKx(p3x)return trueendfunctionfunction lnr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),LRe)return trueendfunctionfunction lVr takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(LRe),((Mv[(rFx)])),w)return trueendfunctionfunction lEr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxcall Nbx((Iix),(Lne),(Lje[oSx]),w,((Lie[Lje[oSx]])*1.))call nlo((LGe[oSx]),(Iix),((Lhe[oSx])*1.),(true),(false))endfunctionfunction lXr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=Rb
local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer JOr=iXx()set LGe[oSx]=Cqx
set Lhe[oSx]=Ffset LHe[oSx]=JOr
set Lje[oSx]=rYx
set ge[(JOr)]=(oSx)call iDx(JOr,LJe,false,function lEr)
return trueendfunctionfunction lOr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer JOr=LHe[oSx]call iKx(JOr)return trueendfunctionfunction lRr takes nothing returns nothingcall Lxx(LEe,Xdx("FolderFairysTears_StructTarget_Init: call FolderFairysTears_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderFairysTears_StructTarget.Event_BuffGain))",bd,MI,function lXr))call Lxx(LEe,Xdx("FolderFairysTears_StructTarget_Init: call FolderFairysTears_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderFairysTears_StructTarget.Event_BuffLose))",jc,MI,function lOr))call W2x(nVv,Lne)endfunctionfunction lIr takes nothing returns booleanset LNe=O5x()set Lbe=Xpx(function lxr)call Lxx(LRe,Xdx("FairysTears_Init: call FairysTears.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FairysTears.Event_BuffGain))",bd,MI,function lir))call Lxx(LRe,Xdx("FairysTears_Init: call FairysTears.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FairysTears.Event_BuffLose))",jc,MI,function lar))call mro(LOe,Xdx("FairysTears_Init: call FairysTears.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FairysTears.Event_EndCast))",onv,MI,function lnr))call mro(LOe,Xdx("FairysTears_Init: call FairysTears.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FairysTears.Event_SpellEffect))",ih,MI,function lVr))call lRr()return trueendfunctionfunction lAr takes nothing returns booleancall FAr(function lIr,"FairysTears_Init")return trueendfunctionfunction lNr takes nothing returns booleanset Lke=hjo('uFLD')call hJo(((Lke)),ASv,(Igv))set Uj[(Lke)]=((1)*1.)call hko(Lke,$FF,$FF,$FF,$FF)set NOv[(Lke)]=(('d')*1.)set NWv[(Lke)]=(('d')*1.)set NPv[(Lke)]=((1)*1.)set I8v[(Lke)]=((0)*1.)set Anv[(Lke)]=(3)set Nmv[(Lke)]=((150000.)*1.)set NLv[(Lke)]=((150000.)*1.)set NKv[(Lke)]=((0)*1.)set Npv[(Lke)]=(($3E8)*1.)set NMv[(Lke)]=(($3E8)*1.)set Nlv[(Lke)]=((1)*1.)set Ncv[(Lke)]=(($4B0)*1.)set Nbv[(Lke)]=(($4B0)*1.)set NGv[(Lke)]=(($3E8)*1.)set Auv[(Lke)]=((0)*1.)set AUv[(Lke)]=((0)*1.)set AYv[(Lke)]=(0)set A_v[(Lke)]=(0)set ATv[(Lke)]=(($96)*1.)call hpo((Lke),(gtv),1)return trueendfunctionfunction lbr takes nothing returns booleancall L1x('AFLD',false)set GVv=L0o('AFLD')set K6[(GVv)]=(G6)set m6[(GVv)]=(3)set TH[(GVv)]=("Fountain of Life and Death")
set Rh[(GVv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D022D)))),(((Aj))))))set oxv[(GVv)]=(2)set x3v[(GVv)]=("spell")
call L1o((GVv),Uvv+(1),((500)*1.))call L1o((GVv),GH+(1),(('x')*1.))call L1o((GVv),tH+(1),((300)*1.))call L1o((GVv),Lov+(1),((750)*1.))call L1o((GVv),Uvv+(2),((600)*1.))call L1o((GVv),GH+(2),(('n')*1.))call L1o((GVv),tH+(2),((375)*1.))call L1o((GVv),Lov+(2),((750)*1.))call L1o((GVv),Uvv+(3),((700)*1.))call L1o((GVv),GH+(3),(('d')*1.))call L1o((GVv),tH+(3),((450)*1.))call L1o((GVv),Lov+(3),((750)*1.))set MOv[(GVv)]=("ReplaceableTextures\\CommandButtons\\BTNFountainOfLife.blp")call cDr(GVv,'FFL0',3,'VFL0','LPFL','LRFL')set LKe[1]=30set LKe[2]=45set LKe[3]=60return trueendfunctionfunction lBr takes nothing returns booleancall VNx(sa,(function lNr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FountainOfLifeAndDeath.page\\FountainOfLifeAndDeath.struct\\obj_FountainType_wc3unit.j"))call VNx(Pa,(function lbr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FountainOfLifeAndDeath.page\\FountainOfLifeAndDeath.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction lcr takes nothing returns booleanset Lle=VXx(LLe)
return trueendfunctionfunction lCr takes integer oSx returns integerset Lqe[oSx]=trueset LQe[oSx]=falsecall rEx(Lle)return oSxendfunctionfunction ldr takes nothing returns integerlocal integer oSxif(Lme==8190)thencall o_x("FountainOfLifeAndDeath_Allocation_allocCustom","call DebugEx(FountainOfLifeAndDeath.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",LLe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(LMe[(w)]==w)thenset Lpe=Lpe+1set oSx=Lpeelse
set oSx=LMe[(w)]
set LMe[(w)]=LMe[LMe[(w)]]endifset LMe[oSx]=Zset LPe[oSx]=1call lCr(oSx)return oSxendfunctionfunction lDr takes integer lfr,integer Cqx,integer rYx returns nothingcall Dux(lfr,Lte,rYx,Cqx)endfunctionfunction lFr takes integer Cqx,integer rYx returns nothingcall r0x((Cqx),(LTe),(rYx))call RXx(Cqx,LTe)endfunctionfunction lgr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local integer oSx=ldr()local real bex=Ufx(Cqx,dVx-(GetUnitX(C[((Cqx))])),dEx-(GetUnitY(C[((Cqx))])))local integer lfr=U0o(Lke,(ze[(Cqx)]),dVx,dEx,bex,LKe[rYx])set dVx=(GetUnitX(C[((lfr))]))set dEx=(GetUnitY(C[((lfr))]))call RJr(lfr,dVx,dEx,X_x(dVx,dEx)+Lse,LSe)call lDr(lfr,Cqx,rYx)call lFr(lfr,rYx)return trueendfunctionfunction lGr takes nothing returns booleancall mro(GVv,Xdx("FountainOfLifeAndDeath_Init: call FountainOfLifeAndDeath.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FountainOfLifeAndDeath.Event_SpellEffect))",ih,MI,function lgr))return trueendfunctionfunction lhr takes nothing returns booleancall FAr(function lGr,"FountainOfLifeAndDeath_Init")
return trueendfunctionfunction lHr takes nothing returns booleanset Lue=Wwx('BFLT',"Fountain of Life and Death - weakened",'bFLT')set anv[(Lue)]=("ReplaceableTextures\\CommandButtons\\BTNOrbOfDarkness.blp")
call lWx(Lue,"Abilities\\Spells\\Other\\Drain\\DrainTarget.mdl","origin",ri)
set WU=l_x()
call l2x(WU,nav,-.3)
call l3x(((Lue)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,nav,-.4)
call l3x(((Lue)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,nav,-.5)
call l3x(((Lue)),ZB+(3),(WU))return trueendfunctionfunction ljr takes nothing returns booleanset LUe[1]=-.3set LUe[2]=-.4set LUe[3]=-.5return trueendfunctionfunction lJr takes nothing returns booleancall VNx(ma,(function lHr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FountainOfLifeAndDeath.page\\FountainOfLifeAndDeath.struct\\DecayAura.page\\DecayAura.struct\\Target\\obj_dummyBuff_wc3buff.j"))
call VNx(va,(function ljr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FountainOfLifeAndDeath.page\\FountainOfLifeAndDeath.struct\\DecayAura.page\\DecayAura.struct\\Target\\obj_this_wc3obj.j"))return trueendfunctionfunction lkr takes nothing returns booleanset Lwe=VXx(LWe)
return trueendfunctionfunction lKr takes nothing returns booleancall L1x('ADkA',false)set Lye=L0o('ADkA')set m6[(Lye)]=(3)set TH[(Lye)]=("Decay Aura")
set x3v[(Lye)]=("spell")
set MOv[(Lye)]=("ReplaceableTextures\\PassiveButtons\\PASBTNShadeTrueSight.blp")
return trueendfunctionfunction llr takes nothing returns booleanset Lte=ltx(LYe+" (dummyBuff)")call lWx(Lte,"Abilities\\Spells\\Undead\\Darksummoning\\DarkSummonTarget.mdl","origin",Bi)return trueendfunctionfunction lLr takes nothing returns booleanset Lze[1]=30set Lze[2]=40set Lze[3]=50return trueendfunctionfunction lmr takes nothing returns booleancall VNx(Pa,(function lKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FountainOfLifeAndDeath.page\\FountainOfLifeAndDeath.struct\\DecayAura.page\\DecayAura.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function llr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FountainOfLifeAndDeath.page\\FountainOfLifeAndDeath.struct\\DecayAura.page\\DecayAura.struct\\obj_dummyBuff_wc3buff.j"))
call VNx(va,(function lLr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FountainOfLifeAndDeath.page\\FountainOfLifeAndDeath.struct\\DecayAura.page\\DecayAura.struct\\obj_this_wc3obj.j"))return trueendfunctionfunction lMr takes nothing returns booleanset LZe=VXx(LYe)
return trueendfunctionfunction lpr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction lPr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=(pj[(rFx)])call nlo((L1e[oSx]),(Iix),((L2e[oSx])*1.),(true),(false))return trueendfunctionfunction lqr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])call Dgx((vPe[(L0e[oSx])]),function lPr,oSx)
endfunctionfunction lQr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Lc[(rFx)])local integer lfr=(Vv[(rFx)])local integer rYx=(hc[(rFx)])local integer Xur=XQr(lfr)local integer p3x=iXx()local integer oSx=lfrset L0e[oSx]=Xur
set L1e[oSx]=Cqx
set L2e[oSx]=L3e[rYx]set L4e[oSx]=p3x
set L5e[oSx]=rYx
set Ene[(Xur)]=(oSx)
set ge[(p3x)]=(oSx)set vqe[(Xur)]=(((CQx((GVv),Uvv+(rYx))))*1.)
set vQe[(Xur)]=(L_e)
call Xsr(Xur,L6e)call Xsr(Xur,L7e)call Xtr(Xur)call iDx(p3x,L8e,true,function lqr)return trueendfunctionfunction lsr takes nothing returns booleanlocal integer rFx=(bv)local integer lfr=(Vv[(rFx)])local integer oSx=lfrlocal integer Xur=L0e[oSx]local integer p3x=L4e[oSx]call X5r(Xur)call iKx(p3x)return trueendfunctionfunction lSr takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer rLx=(Ene[(Xur)])call Ulx(Iix,Lue)return trueendfunctionfunction ltr takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer Cqx=(vke[(Xur)])local integer rLx=(Ene[(Xur)])local integer rYx=L5e[rLx]call Dux((Iix),(Lue),(rYx),w)return trueendfunctionfunction lTr takes nothing returns nothingset L6e=Xdx("FolderDecayAura_StructTarget_Init: set FolderDecayAura_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderDecayAura_StructTarget.Event_Ending)",vTe,MI,function lSr)set L7e=Xdx("FolderDecayAura_StructTarget_Init: set FolderDecayAura_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderDecayAura_StructTarget.Event_Start)",vue,MI,function ltr)
endfunctionfunction lur takes nothing returns booleanlocal integer oMxset L_e=Xpx(function lpr)call Lxx(Lte,Xdx("DecayAura_Init: call DecayAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DecayAura.Event_BuffGain))",bd,MI,function lQr))call Lxx(Lte,Xdx("DecayAura_Init: call DecayAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DecayAura.Event_BuffLose))",jc,MI,function lsr))set oMx=(m6[(Lye)])loop
exitwhen(oMx<1)set L3e[oMx]=Lze[oMx]*L8eset oMx=oMx-1endloopcall lTr()return trueendfunctionfunction lUr takes nothing returns booleancall FAr(function lur,"DecayAura_Init")return trueendfunctionfunction lwr takes nothing returns booleanset L9e=VXx(mve)
return trueendfunctionfunction lWr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=Flx((av[(rFx)]))return truereturn trueendfunctionfunction lyr takes nothing returns booleanlocal integer rFx=(bv)local integer FPx=FLx((nv[(rFx)]),mee)call xWr((Vv[(rFx)]),FPx)return trueendfunctionfunction lYr takes nothing returns booleanlocal integer rFx=(bv)local integer FPx=FLx((nv[(rFx)]),mee)call x1r((Vv[(rFx)]),FPx)return trueendfunctionfunction lzr takes integer rlx,code XCx returns integerlocal integer FPx=e8r(XCx)set v1e[(FPx)]=(Xpx(function lWr))if(xvr(rlx,1)>.0)thencall xmr(FPx,QH,cK,sH,dK,OK)
endifif(Ftx(rlx,1)>.0)thencall xSr(FPx,mF,(R2I(((Ftx(rlx,1))*1.))),GREATER_THAN_OR_EQUAL,DK)endifcall xtr(FPx,BK,rlx)
call Cwx(rlx,mee,FPx)call mro(rlx,Xdx("AIAutoCast_CreateBasics: call whichSpell.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.AI, function AIAutoCast.Event_Learn))",pv,HI,function lyr))call mro(rlx,Xdx("AIAutoCast_CreateBasics: call whichSpell.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.AI, function AIAutoCast.Event_Unlearn))",Av,HI,function lYr))call xmr(FPx,Qb,FK,Qb,fK,gK)
return FPxendfunctionfunction lZr takes nothing returns booleanlocal integer rFx=(bv)call Rxx(((LoadInteger(o[((V[(E[((X))])]))],(((RK+(((av[(rFx)])))))),(((IK)))))),(Rh[((LTe))]))return trueendfunctionfunction l_r takes nothing returns booleanlocal integer FPx=lzr(LTe,function lZr)call oFr(FPx,1.)
return trueendfunctionfunction l0r takes nothing returns booleancall e4r(function l_r,"AIPalingenesis_Init")
return trueendfunctionfunction l1r takes nothing returns booleanset mxe=Wwx('BFDL',"Revived",'bFDL')
set anv[(mxe)]=("ReplaceableTextures\\CommandButtons\\BTNAnimateDead.blp")return trueendfunctionfunction l2r takes nothing returns booleancall L1x('AFLX',false)set LTe=L0o('AFLX')set m6[(LTe)]=(3)set TH[(LTe)]=("Palingenesis")set Rh[(LTe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0251)))),(((Aj))))))set Pb[(LTe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0253)))),(((Aj))))))set sb[(LTe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0252)))),(((Aj))))))set x3v[(LTe)]=("spell")
call L1o((LTe),Uvv+(1),((500)*1.))call L1o((LTe),GH+(1),((6)*1.))call L1o((LTe),tH+(1),(('d')*1.))call L1o((LTe),Uvv+(2),((600)*1.))call L1o((LTe),GH+(2),((6)*1.))call L1o((LTe),tH+(2),(('d')*1.))call L1o((LTe),Uvv+(3),((700)*1.))call L1o((LTe),GH+(3),((6)*1.))call L1o((LTe),tH+(3),(('d')*1.))set MOv[(LTe)]=("ReplaceableTextures\\CommandButtons\\BTNOrbOfDarkness.blp")
set moe[1]=30set moe[2]=30set moe[3]=30return trueendfunctionfunction l3r takes nothing returns booleancall VNx(ma,(function l1r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FountainOfLifeAndDeath.page\\FountainOfLifeAndDeath.struct\\Palingenesis.page\\Palingenesis.struct\\obj_summonBuff_wc3buff.j"))call VNx(Pa,(function l2r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\FountainOfLifeAndDeath.page\\FountainOfLifeAndDeath.struct\\Palingenesis.page\\Palingenesis.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction l4r takes nothing returns booleanset mre=VXx(mie)
return trueendfunctionfunction l5r takes nothing returns booleanlocal integer Iix=jhx()if not I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifreturn truereturn trueendfunctionfunction l6r takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=mVe[oSx]local integer rYx=mEe[oSx]local integer C3o=(ze[(Cqx)])call MFo(Mho)if(Iix==w)thenreturn trueendifif not I9x(Iix,Qc)thenreturn trueendifcall Ryx((ACx((Iix),(mOe),(mRe),(ri))))call aJr(Iix)call Dux((Iix),(mxe),(rYx),w)call acx(Iix,C3o)call U_o(Iix,moe[rYx])set nJv[(Iix)]=(mIe)
call fJx(Iix,-$80,-$80,-$80,0)return trueendfunctionfunction l7r takes integer Cqx,integer rYx,integer Iix returns nothinglocal integer Mho=Moo()local integer oSx=Mhoset mVe[oSx]=Cqx
set mEe[oSx]=rYx
set mXe[oSx]=Iix
set mcv[((Mho))]=((Bev*((.06)*1.))*1.)set mCv[(Mho)]=((10.)*1.)call Mno(Mho,'qFDM',2.)set mFv[(Mho)]=Xkx((function l6r))set mZv[(Mho)]=(oSx)
call Meo(Mho,500.)call pxo(Mho,Cqx)call M6o((Mho),(Iix),.0,.0,.0,(function M8o))endfunctionfunction l8r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iixlocal real x=(GetUnitX(C[((Cqx))]))local real y=(GetUnitY(C[((Cqx))]))call NVo(mae,x,y,(CQx((LTe),Uvv+(rYx))),mne)
set Iix=Wko(mae,x,y)
if(Iix==w)thenreturn trueendifcall l7r(Cqx,rYx,Iix)return trueendfunctionfunction l9r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real x=(GetUnitX(C[((Cqx))]))local real y=(GetUnitY(C[((Cqx))]))call NVo(mae,x,y,(CQx((LTe),Uvv+(rYx))),mne)
return not((adx(FirstOfGroup(kb[((mae))])))==w)return trueendfunctionfunction Lvr takes nothing returns booleanset mae=O5x()set mne=Xpx(function l5r)call mro(LTe,Xdx("Palingenesis_Init: call Palingenesis.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Palingenesis.Event_SpellEffect))",ih,MI,function l8r))set Ih[(LTe)]=(Xpx(function l9r))return trueendfunctionfunction Ler takes nothing returns booleancall FAr(function Lvr,"Palingenesis_Init")return trueendfunctionfunction Lxr takes nothing returns booleanset mAe[1]=.5set mAe[2]=.5set mAe[3]=.5set mAe[4]=.5set mAe[5]=.5set mAe[6]=.5return trueendfunctionfunction Lor takes nothing returns booleanset mNe=ltx(mbe+" (dummyBuff)")return trueendfunctionfunction Lrr takes nothing returns booleancall VNx(va,(function Lxr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\GarmentsOfTheSalamander.page\\GarmentsOfTheSalamander.struct\\Regen\\obj_this_wc3obj.j"))call VNx(ma,(function Lor),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\GarmentsOfTheSalamander.page\\GarmentsOfTheSalamander.struct\\Regen\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction Lir takes nothing returns booleanset mBe=VXx(mbe)
return trueendfunctionfunction Lar takes nothing returns booleancall L1x('ASaR',false)set mce=L0o('ASaR')set K6[(mce)]=(D6)set m6[(mce)]=(6)set TH[(mce)]=("Revert to Human Form")set Rh[(mce)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0089)))),(((Aj))))))set oxv[(mce)]=(0)set x3v[(mce)]=("spell")
call L1o((mce),GH+(1),((3)*1.))call L1o((mce),Lov+(1),((750)*1.))call L1o((mce),GH+(2),((3)*1.))call L1o((mce),Lov+(2),((750)*1.))call L1o((mce),GH+(3),((3)*1.))call L1o((mce),Lov+(3),((750)*1.))call L1o((mce),GH+(4),((3)*1.))call L1o((mce),Lov+(4),((750)*1.))call L1o((mce),GH+(5),((3)*1.))call L1o((mce),Lov+(5),((750)*1.))call L1o((mce),GH+(6),((3)*1.))call L1o((mce),Lov+(6),((750)*1.))set MOv[(mce)]=("ReplaceableTextures\\CommandButtons\\BTNHeroBloodElfPrince.blp")call cDr(mce,'FSR0',6,'VSR0','LPSR','LRSR')return trueendfunctionfunction Lnr takes nothing returns booleancall L1x('ASaX',false)return trueendfunctionfunction LVr takes nothing returns booleanset mCe=hjo('USal')call hpo((mCe),('AInv'),1)call hJo(((mCe)),ASv,(Wd))call hJo(((mCe)),ASv,(Idv))set Uj[(mCe)]=((.95)*1.)
call hko(mCe,$FF,$96,$AA,$FF)set NOv[(mCe)]=((110.80332409972)*1.)set NWv[(mCe)]=((22.160664819945)*1.)set NPv[(mCe)]=((280)*1.)set I8v[(mCe)]=((1)*1.)set Anv[(mCe)]=(4)set Nmv[(mCe)]=(('d')*1.)set NLv[(mCe)]=(('d')*1.)set NKv[(mCe)]=((0)*1.)set Npv[(mCe)]=(('d')*1.)set NMv[(mCe)]=(('d')*1.)set Nlv[(mCe)]=((0)*1.)set Ncv[(mCe)]=(($578)*1.)set Nbv[(mCe)]=(($578)*1.)set Adv[(mCe)]=(gmv)
set AGv[(mCe)]=((360)*1.)set Ahv[((mCe))]=((1.*1./((1.8)*1.))*1.)
set AWv[(mCe)]=((.5)*1.)
set Dnv[(mCe)]=((500)*1.)set Auv[(mCe)]=((29)*1.)
set AUv[(mCe)]=((29)*1.)
set AYv[(mCe)]=(1)set A_v[(mCe)]=($A)set A2v[(mCe)]=(0)set ATv[(mCe)]=((53.185595567867)*1.)set Nnv[(mCe)]=(20)set Niv[(mCe)]=($A)set bDv[(mCe)]=((6)*1.)set bjv[(mCe)]=((2.5)*1.)set bJv[(mCe)]=((.8)*1.)
set bfv[(mCe)]=((16)*1.)
set bkv[(mCe)]=((4.5)*1.)set bFv[(mCe)]=((9)*1.)set bKv[(mCe)]=((3.5)*1.)call hpo((mCe),(Gjv),1)call hpo((mCe),(GJv),1)call hpo((mCe),(Gkv),1)call hpo((mCe),(lMe),1)return trueendfunctionfunction LEr takes nothing returns booleancall L1x('ASaC',false)return trueendfunctionfunction LXr takes nothing returns booleanset mde=ltx(mDe+" (dummyBuff)")call lWx(mde,"Units\\Aura.mdx","origin",ri)set WU=l_x()
call l2x(WU,DHv,3)call vAr(WU,DKv,true)call l0x(((WU)),fc,(Kkr(db,.2,.5)))call l3x(((mde)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,DHv,5)call vAr(WU,DKv,true)call l0x(((WU)),fc,(Kkr(db,.35,.5)))
call l3x(((mde)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,DHv,7)call vAr(WU,DKv,true)call l0x(((WU)),fc,(Kkr(db,.5,.5)))call l3x(((mde)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,DHv,9)call vAr(WU,DKv,true)call l0x(((WU)),fc,(Kkr(db,.65,.5)))
call l3x(((mde)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,DHv,$B)call vAr(WU,DKv,true)call l0x(((WU)),fc,(Kkr(db,.8,.5)))call l3x(((mde)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,DHv,$D)call vAr(WU,DKv,true)call l0x(((WU)),fc,(Kkr(db,.95,.5)))
call l3x(((mde)),ZB+(6),(WU))return trueendfunctionfunction LOr takes nothing returns booleancall L1x('ASam',false)set GJv=L0o('ASam')set K6[(GJv)]=(D6)set m6[(GJv)]=(6)set TH[(GJv)]=("Garments of the Salamander")
set Rh[(GJv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0089)))),(((Aj))))))set oxv[(GJv)]=(0)set x3v[(GJv)]=("spell")
call L1o((GJv),Uvv+(1),((500)*1.))call L1o((GJv),GH+(1),((5)*1.))call L1o((GJv),tH+(1),(($F)*1.))
call L1o((GJv),Lov+(1),((750)*1.))call L1o((GJv),Uvv+(2),((500)*1.))call L1o((GJv),GH+(2),((5)*1.))call L1o((GJv),tH+(2),(($F)*1.))
call L1o((GJv),Lov+(2),((750)*1.))call L1o((GJv),Uvv+(3),((500)*1.))call L1o((GJv),GH+(3),((5)*1.))call L1o((GJv),tH+(3),(($F)*1.))
call L1o((GJv),Lov+(3),((750)*1.))call L1o((GJv),Uvv+(4),((500)*1.))call L1o((GJv),GH+(4),((5)*1.))call L1o((GJv),tH+(4),(($F)*1.))
call L1o((GJv),Lov+(4),((750)*1.))call L1o((GJv),Uvv+(5),((500)*1.))call L1o((GJv),GH+(5),((5)*1.))call L1o((GJv),tH+(5),(($F)*1.))
call L1o((GJv),Lov+(5),((750)*1.))call L1o((GJv),Uvv+(6),((500)*1.))call L1o((GJv),GH+(6),((5)*1.))call L1o((GJv),tH+(6),(($F)*1.))
call L1o((GJv),Lov+(6),((750)*1.))set MOv[(GJv)]=("ReplaceableTextures\\CommandButtons\\BTNThunderLizardSalamander.blp")call cDr(GJv,'FGa0',6,'VGa0','LPGa','LRGa')set mfe[1]=3
set mfe[2]=5
set mfe[3]=7
set mfe[4]=9
set mfe[5]=$Bset mfe[6]=$Dreturn trueendfunctionfunction LRr takes nothing returns booleancall VNx(Pa,(function Lar),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\GarmentsOfTheSalamander.page\\GarmentsOfTheSalamander.struct\\obj_revertSpell_wc3spell.j"))call VNx(Pa,(function Lnr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\GarmentsOfTheSalamander.page\\GarmentsOfTheSalamander.struct\\obj_revertAbility_wc3spell.j"))call VNx(sa,(function LVr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\GarmentsOfTheSalamander.page\\GarmentsOfTheSalamander.struct\\obj_thisUnitType_wc3unit.j"))call VNx(Pa,(function LEr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\GarmentsOfTheSalamander.page\\GarmentsOfTheSalamander.struct\\obj_changerAbility_wc3spell.j"))call VNx(ma,(function LXr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\GarmentsOfTheSalamander.page\\GarmentsOfTheSalamander.struct\\obj_dummyBuff_wc3buff.j"))
call VNx(Pa,(function LOr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\GarmentsOfTheSalamander.page\\GarmentsOfTheSalamander.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction LIr takes nothing returns booleanset mFe=VXx(mDe)
return trueendfunctionfunction LAr takes integer Odo,integer LNr,integer OSx returns nothingif((osx((OSx),I0v+(Odo)))!=w)thencall OCo(LNr,OSx)endifendfunctionfunction Lbr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixset mge[oSx]=(Tf[(Iix)])
call KQr(Iix,mCe,'ASaC')
call Ryx((ACx((Iix),(mGe),(mhe),(ri))))call LAr(f6,Nme,Iix)
call LAr(O6,jKe,Iix)
call LAr(D6,mce,Iix)
call Dux(((Iix)),(mNe),((rYx)),w)return trueendfunctionfunction LBr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer KWr=mge[oSx]call KQr(Iix,KWr,'ASaX')
call Ryx((ACx((Iix),(mGe),(mhe),(ri))))call LAr(f6,SIv,Iix)
call LAr(O6,Gjv,Iix)
call LAr(D6,GJv,Iix)
call AZx((Iix),mNe)return trueendfunctionfunction Lcr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),mde)return trueendfunctionfunction LCr takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(mde),((Mv[(rFx)])),w)return trueendfunctionfunction Ldr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif not(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction LDr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer o0x=oSxlocal integer Lfr=mke[oSx]local integer rYx=(osx(((o0x)),N+(mce)))
local real x=(GetUnitX(C[((o0x))]))local real y=(GetUnitY(C[((o0x))]))local integer LFrset hf=(ze[(o0x)])call NVo(mHe,x,y,(CQx((GJv),Uvv+(rYx))),mje)
set LFr=(NIo((mHe)))
call ISx(o0x,Lfr)call l1x(((Lfr)),Ec+(DHv),((mAe[rYx]*LFr)*1.))call I3x(o0x,Lfr)if(rYx!=(osx(((o0x)),Yb+(mNe))))then
call AZx(o0x,mNe)call Dux((o0x),(mNe),(rYx),w)endifendfunctionfunction Lgr takes nothing returns booleanlocal integer rFx=(bv)local integer o0x=(Vv[(rFx)])local integer p3x=iXx()local integer Lfr=l_x()local integer oSx=o0xset mJe[oSx]=p3x
set mke[oSx]=Lfr
set ge[(p3x)]=(oSx)call l2x(Lfr,DHv,.0)
call I3x(o0x,Lfr)call iDx(p3x,mKe,true,function LDr)return trueendfunctionfunction LGr takes nothing returns booleanlocal integer rFx=(bv)local integer o0x=(Vv[(rFx)])local integer oSx=o0xlocal integer p3x=mJe[oSx]local integer Lfr=mke[oSx]call iKx(p3x)call ISx(o0x,Lfr)call nnr(Lfr)return trueendfunctionfunction Lhr takes nothing returns nothingset mHe=O5x()set mje=Xpx(function Ldr)call Lxx(mNe,Xdx("FolderGarmentsOfTheSalamander_StructRegen_Init: call FolderGarmentsOfTheSalamander_StructRegen.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderGarmentsOfTheSalamander_StructRegen.Event_BuffGain))",bd,MI,function Lgr))call Lxx(mNe,Xdx("FolderGarmentsOfTheSalamander_StructRegen_Init: call FolderGarmentsOfTheSalamander_StructRegen.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderGarmentsOfTheSalamander_StructRegen.Event_BuffLose))",jc,MI,function LGr))endfunctionfunction LHr takes nothing returns booleancall Lxx(mde,Xdx("GarmentsOfTheSalamander_Init: call GarmentsOfTheSalamander.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function GarmentsOfTheSalamander.Event_BuffGain))",bd,MI,function Lbr))call Lxx(mde,Xdx("GarmentsOfTheSalamander_Init: call GarmentsOfTheSalamander.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function GarmentsOfTheSalamander.Event_BuffLose))",jc,MI,function LBr))call mro(mce,Xdx("GarmentsOfTheSalamander_Init: call GarmentsOfTheSalamander.REVERT_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function GarmentsOfTheSalamander.Event_RevertSpellEffect))",ih,MI,function Lcr))call mro(GJv,Xdx("GarmentsOfTheSalamander_Init: call GarmentsOfTheSalamander.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function GarmentsOfTheSalamander.Event_SpellEffect))",ih,MI,function LCr))call Lhr()return trueendfunctionfunction Ljr takes nothing returns booleancall FAr(function LHr,"GarmentsOfTheSalamander_Init")return trueendfunctionfunction LJr takes nothing returns booleanset mle=VXx(mLe)
return trueendfunctionfunction Lkr takes nothing returns booleanset mme=VXx(mMe)
return trueendfunctionfunction LKr takes nothing returns booleanset mpe=VXx(mPe)
return trueendfunctionfunction Llr takes nothing returns booleanset mqe=VXx(mQe)
return trueendfunctionfunction LLr takes nothing returns booleanset mse=Wwx('BHNP',"Hand of Nature (Prison)",'bHNP')
set anv[(mse)]=("ReplaceableTextures\\CommandButtons\\BTNEntanglingRoots.blp")set WU=l_x()
call vAr(WU,djv,true)call l3x(((mse)),ZB+(1),(WU))set WU=l_x()
call vAr(WU,djv,true)call l3x(((mse)),ZB+(2),(WU))set WU=l_x()
call vAr(WU,djv,true)call l3x(((mse)),ZB+(3),(WU))set WU=l_x()
call vAr(WU,djv,true)call l3x(((mse)),ZB+(4),(WU))set WU=l_x()
call vAr(WU,djv,true)call l3x(((mse)),ZB+(5),(WU))set WU=l_x()
call vAr(WU,djv,true)call l3x(((mse)),ZB+(6),(WU))return trueendfunctionfunction Lmr takes nothing returns booleancall VNx(ma,(function LLr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\Prison\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction LMr takes nothing returns booleanset mSe=VXx(mte)
return trueendfunctionfunction Lpr takes nothing returns booleanset mTe[1]=-40set mTe[2]=-50set mTe[3]=-60set mTe[4]=-70set mTe[5]=-80set mTe[6]=-90set mue[1]=3
set mue[2]=3.5set mue[3]=4
set mue[4]=4.5set mue[5]=5
set mue[6]=5.5set mUe[1]=40set mUe[2]=40set mUe[3]=40set mUe[4]=40set mUe[5]=40set mUe[6]=40set mwe[1]=1
set mwe[2]=1
set mwe[3]=1
set mwe[4]=1
set mwe[5]=1
set mwe[6]=1
return trueendfunctionfunction LPr takes nothing returns booleanset mWe=Wwx('BHoN',"Hand of Nature",'bHoN')set uU[(mWe)]=(true)
set anv[(mWe)]=("ReplaceableTextures\\CommandButtons\\BTNEntanglingRoots.blp")call lWx(mWe,"Abilities\\Spells\\NightElf\\EntanglingRoots\\EntanglingRootsTarget.mdl","origin",ri)set WU=l_x()
call l2x(WU,cVv,-40)
call l3x(((mWe)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,cVv,-50)
call l3x(((mWe)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,cVv,-60)
call l3x(((mWe)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,cVv,-70)
call l3x(((mWe)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,cVv,-80)
call l3x(((mWe)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,cVv,-90)
call l3x(((mWe)),ZB+(6),(WU))return trueendfunctionfunction Lqr takes nothing returns booleancall VNx(va,(function Lpr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\Roots\\Buff\\obj_this_wc3obj.j"))call VNx(ma,(function LPr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\Roots\\Buff\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction LQr takes nothing returns booleanset mye=VXx(mYe)
return trueendfunctionfunction Lsr takes nothing returns booleanreturn trueendfunctionfunction LSr takes nothing returns booleanset mze=VXx(mZe)
return trueendfunctionfunction Ltr takes nothing returns booleanreturn trueendfunctionfunction LTr takes nothing returns booleanset m_e=VXx(m0e)
return trueendfunctionfunction Lur takes nothing returns booleancall L1x('AHoN',false)set m1e=L0o('AHoN')set K6[(m1e)]=(D6)set m6[(m1e)]=(6)set TH[(m1e)]=("Hand of Nature")
set Rh[(m1e)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00CB)))),(((Aj))))))set oxv[(m1e)]=(3)set x3v[(m1e)]=("spell")
call L1o((m1e),Uvv+(1),((350)*1.))call L1o((m1e),GH+(1),((8)*1.))call L1o((m1e),tH+(1),((65)*1.))
call L1o((m1e),Lov+(1),((650)*1.))call L1o((m1e),Uvv+(2),((350)*1.))call L1o((m1e),GH+(2),((8)*1.))call L1o((m1e),tH+(2),((75)*1.))
call L1o((m1e),Lov+(2),((650)*1.))call L1o((m1e),Uvv+(3),((350)*1.))call L1o((m1e),GH+(3),((8)*1.))call L1o((m1e),tH+(3),((85)*1.))
call L1o((m1e),Lov+(3),((650)*1.))call L1o((m1e),Uvv+(4),((350)*1.))call L1o((m1e),GH+(4),((8)*1.))call L1o((m1e),tH+(4),((95)*1.))
call L1o((m1e),Lov+(4),((650)*1.))call L1o((m1e),Uvv+(5),((350)*1.))call L1o((m1e),GH+(5),((8)*1.))call L1o((m1e),tH+(5),(('i')*1.))call L1o((m1e),Lov+(5),((650)*1.))call L1o((m1e),Uvv+(6),((350)*1.))call L1o((m1e),GH+(6),((8)*1.))call L1o((m1e),tH+(6),(('s')*1.))call L1o((m1e),Lov+(6),((650)*1.))set MOv[(m1e)]=("ReplaceableTextures\\CommandButtons\\BTNEntanglingRoots.blp")call cDr(m1e,'FHN0',6,'VHN0','LPHN','LRHN')set m2e[1]=40set m2e[2]=40set m2e[3]=40set m2e[4]=40set m2e[5]=40set m2e[6]=40set m3e[1]=3
set m3e[2]=3
set m3e[3]=3
set m3e[4]=3
set m3e[5]=3
set m3e[6]=3
set m4e[1]=2
set m4e[2]=2
set m4e[3]=2
set m4e[4]=2
set m4e[5]=2
set m4e[6]=2
return trueendfunctionfunction LUr takes nothing returns booleanset m5e[5]=hjo('uCL5')call hJo(((m5e[5])),ASv,(Idv))set Uj[(m5e[5])]=((.9)*1.)call hko(m5e[5],0,$FF,0,$FF)
set NOv[(m5e[5])]=(('d')*1.)
set NWv[(m5e[5])]=(($E1)*1.)
call Hqo(m5e[5],"Units\\CobraLily\\LightingOrb.mdx","head",Bi)set I8v[(m5e[5])]=((2)*1.)set Anv[(m5e[5])]=(2)set Nmv[(m5e[5])]=((450)*1.)
set NLv[(m5e[5])]=((450)*1.)
set NKv[(m5e[5])]=((0)*1.)set Ncv[(m5e[5])]=(($4B0)*1.)set Nbv[(m5e[5])]=(($4B0)*1.)set NGv[(m5e[5])]=(($F)*1.)set Adv[(m5e[5])]=(guv)set AGv[(m5e[5])]=((600)*1.)
set Ahv[((m5e[5]))]=((1.*1./((1.25)*1.))*1.)
set AWv[(m5e[5])]=((.4)*1.)set Dnv[(m5e[5])]=((600)*1.)
set Auv[(m5e[5])]=((32)*1.)set AUv[(m5e[5])]=((32)*1.)set AYv[(m5e[5])]=(3)set A_v[(m5e[5])]=(4)set A2v[(m5e[5])]=(1)set ATv[(m5e[5])]=((16)*1.)return trueendfunctionfunction Lwr takes nothing returns booleanset m5e[1]=hjo('uCoL')call hJo(((m5e[1])),ASv,(Idv))set Uj[(m5e[1])]=((.7)*1.)call hko(m5e[1],0,$FF,0,$FF)
set NOv[(m5e[1])]=(('d')*1.)
set NWv[(m5e[1])]=(($E1)*1.)
call Hqo(m5e[1],"HandOfNature_page\\HandOfNature_struct\\LightingOrb.mdx","head",Bi)
set I8v[(m5e[1])]=((0)*1.)set Anv[(m5e[1])]=(2)set Nmv[(m5e[1])]=(($96)*1.)
set NLv[(m5e[1])]=(($96)*1.)
set NKv[(m5e[1])]=((0)*1.)set Ncv[(m5e[1])]=(($4B0)*1.)set Nbv[(m5e[1])]=(($4B0)*1.)set NGv[(m5e[1])]=(($F)*1.)set Adv[(m5e[1])]=(guv)set AGv[(m5e[1])]=((600)*1.)
set Ahv[((m5e[1]))]=((1.*1./((1.25)*1.))*1.)
set AWv[(m5e[1])]=((.4)*1.)set Dnv[(m5e[1])]=((600)*1.)
set Auv[(m5e[1])]=(($C)*1.)set AUv[(m5e[1])]=(($C)*1.)set AYv[(m5e[1])]=(1)set A_v[(m5e[1])]=(3)set A2v[(m5e[1])]=(1)set ATv[(m5e[1])]=((40)*1.)return trueendfunctionfunction LWr takes nothing returns booleanset m6e=ltx(m7e+" (dummyBuff)")return trueendfunctionfunction Lyr takes nothing returns booleanset m5e[2]=hjo('uCL2')call hJo(((m5e[2])),ASv,(Idv))set Uj[(m5e[2])]=((.75)*1.)call hko(m5e[2],0,$FF,0,$FF)
set NOv[(m5e[2])]=(('d')*1.)
set NWv[(m5e[2])]=(($E1)*1.)
call Hqo(m5e[2],"Units\\CobraLily\\LightingOrb.mdx","head",Bi)set I8v[(m5e[2])]=((1)*1.)set Anv[(m5e[2])]=(2)set Nmv[(m5e[2])]=(($E1)*1.)
set NLv[(m5e[2])]=(($E1)*1.)
set NKv[(m5e[2])]=((0)*1.)set Ncv[(m5e[2])]=(($4B0)*1.)set Nbv[(m5e[2])]=(($4B0)*1.)set NGv[(m5e[2])]=(($F)*1.)set Adv[(m5e[2])]=(guv)set AGv[(m5e[2])]=((600)*1.)
set Ahv[((m5e[2]))]=((1.*1./((1.25)*1.))*1.)
set AWv[(m5e[2])]=((.4)*1.)set Dnv[(m5e[2])]=((600)*1.)
set Auv[(m5e[2])]=((16)*1.)set AUv[(m5e[2])]=((16)*1.)set AYv[(m5e[2])]=(2)set A_v[(m5e[2])]=(2)set A2v[(m5e[2])]=(1)set ATv[(m5e[2])]=((16)*1.)return trueendfunctionfunction LYr takes nothing returns booleanset m5e[3]=hjo('uCL3')call hJo(((m5e[3])),ASv,(Idv))set Uj[(m5e[3])]=((.8)*1.)call hko(m5e[3],0,$FF,0,$FF)
set NOv[(m5e[3])]=(('d')*1.)
set NWv[(m5e[3])]=(($E1)*1.)
call Hqo(m5e[3],"Units\\CobraLily\\LightingOrb.mdx","head",Bi)set I8v[(m5e[3])]=((1)*1.)set Anv[(m5e[3])]=(2)set Nmv[(m5e[3])]=((300)*1.)
set NLv[(m5e[3])]=((300)*1.)
set NKv[(m5e[3])]=((0)*1.)set Ncv[(m5e[3])]=(($4B0)*1.)set Nbv[(m5e[3])]=(($4B0)*1.)set NGv[(m5e[3])]=(($F)*1.)set Adv[(m5e[3])]=(guv)set AGv[(m5e[3])]=((600)*1.)
set Ahv[((m5e[3]))]=((1.*1./((1.25)*1.))*1.)
set AWv[(m5e[3])]=((.4)*1.)set Dnv[(m5e[3])]=((600)*1.)
set Auv[(m5e[3])]=((21)*1.)set AUv[(m5e[3])]=((21)*1.)set AYv[(m5e[3])]=(2)set A_v[(m5e[3])]=(3)set A2v[(m5e[3])]=(1)set ATv[(m5e[3])]=((16)*1.)return trueendfunctionfunction Lzr takes nothing returns booleanset m5e[6]=hjo('uCL6')call hJo(((m5e[6])),ASv,(Idv))set Uj[(m5e[6])]=((.95)*1.)call hko(m5e[6],0,$FF,0,$FF)
set NOv[(m5e[6])]=(('d')*1.)
set NWv[(m5e[6])]=(($E1)*1.)
call Hqo(m5e[6],"Units\\CobraLily\\LightingOrb.mdx","head",Bi)set I8v[(m5e[6])]=((2)*1.)set Anv[(m5e[6])]=(2)set Nmv[(m5e[6])]=((525)*1.)
set NLv[(m5e[6])]=((525)*1.)
set NKv[(m5e[6])]=((0)*1.)set Ncv[(m5e[6])]=(($4B0)*1.)set Nbv[(m5e[6])]=(($4B0)*1.)set NGv[(m5e[6])]=(($F)*1.)set Adv[(m5e[6])]=(guv)set AGv[(m5e[6])]=((600)*1.)
set Ahv[((m5e[6]))]=((1.*1./((1.25)*1.))*1.)
set AWv[(m5e[6])]=((.4)*1.)set Dnv[(m5e[6])]=((600)*1.)
set Auv[(m5e[6])]=((38)*1.)set AUv[(m5e[6])]=((38)*1.)set AYv[(m5e[6])]=(3)set A_v[(m5e[6])]=(5)set A2v[(m5e[6])]=(1)set ATv[(m5e[6])]=((16)*1.)return trueendfunctionfunction LZr takes nothing returns booleanset m5e[4]=hjo('uCL4')call hJo(((m5e[4])),ASv,(Idv))set Uj[(m5e[4])]=((.85)*1.)call hko(m5e[4],0,$FF,0,$FF)
set NOv[(m5e[4])]=(('d')*1.)
set NWv[(m5e[4])]=(($E1)*1.)
call Hqo(m5e[4],"Units\\CobraLily\\LightingOrb.mdx","head",Bi)set I8v[(m5e[4])]=((2)*1.)set Anv[(m5e[4])]=(2)set Nmv[(m5e[4])]=((375)*1.)
set NLv[(m5e[4])]=((375)*1.)
set NKv[(m5e[4])]=((0)*1.)set Ncv[(m5e[4])]=(($4B0)*1.)set Nbv[(m5e[4])]=(($4B0)*1.)set NGv[(m5e[4])]=(($F)*1.)set Adv[(m5e[4])]=(guv)set AGv[(m5e[4])]=((600)*1.)
set Ahv[((m5e[4]))]=((1.*1./((1.25)*1.))*1.)
set AWv[(m5e[4])]=((.4)*1.)set Dnv[(m5e[4])]=((600)*1.)
set Auv[(m5e[4])]=((26)*1.)set AUv[(m5e[4])]=((26)*1.)set AYv[(m5e[4])]=(3)set A_v[(m5e[4])]=(3)set A2v[(m5e[4])]=(1)set ATv[(m5e[4])]=((16)*1.)return trueendfunctionfunction L_r takes nothing returns booleancall VNx(Pa,(function Lur),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\obj_thisSpell_wc3spell.j"))call VNx(sa,(function LUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\obj_summonUnitType[5]_wc3unit.j"))call VNx(sa,(function Lwr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\obj_summonUnitType[1]_wc3unit.j"))call VNx(ma,(function LWr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\obj_dummyBuff_wc3buff.j"))call VNx(sa,(function Lyr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\obj_summonUnitType[2]_wc3unit.j"))call VNx(sa,(function LYr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\obj_summonUnitType[3]_wc3unit.j"))call VNx(sa,(function Lzr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\obj_summonUnitType[6]_wc3unit.j"))call VNx(sa,(function LZr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\obj_summonUnitType[4]_wc3unit.j"))return trueendfunctionfunction L0r takes nothing returns booleanset m8e=VXx(m7e)
return trueendfunctionfunction L1r takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction L2r takes integer oSx,integer Iix returns nothingcall Ulx(Iix,mse)endfunctionfunction L3r takes integer oSx,integer otx,integer oux returns booleanreturn rrx(Mre[(oSx)],(Mie[((oSx))]),otx,oux)endfunctionfunction L4r takes integer oSx returns nothinglocal integer iCx=Mne[oSx]local integer p3x=MVe[oSx]local integer L5r=MEe[oSx]local integer L6r=MXe[oSx]local integer IQxcall iKx(iCx)call iKx(p3x)call m9x(L5r)set IQx=(rz[(L6r)])loop
exitwhen(IQx==w)
call CSr(IQx,MOe[(IQx)])
set IQx=pKx(L6r,IQx)
endloopcall m9x(L6r)endfunctionfunction L7r takes integer oSx returns nothingcall FlushChildHashtable(o[(V[(E[((Mre[oSx]))])])],((((Mie[((oSx))])))))
endfunctionfunction L8r takes integer oSx returns nothingset MAe[oSx]=falsecall L7r((oSx))call rHx(m8e)endfunctionfunction L9r takes integer oSx returns nothingif(MRe[oSx]>0)thenreturnendifif(MIe[oSx]!=Z)thencall o_x("HandOfNature_Allocation_deallocCustom_confirm","call DebugEx(HandOfNature.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",m7e+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset MIe[oSx]=MIe[(w)]set MIe[(w)]=oSx
call L8r(oSx)endfunctionfunction mvr takes integer oSx returns nothingset MRe[oSx]=MRe[oSx]-1call L9r(oSx)endfunctionfunction mer takes nothing returns booleanlocal integer rFx=(bv)local integer IOr=(Vv[(rFx)])local integer oSx=osx(IOr,Mee)if Mxe[oSx]thenset Mxe[oSx]=falsecall L2r((w),Moe[oSx])endifif L3r(oSx,Mae,IOr)thencall L4r(oSx)call mvr((oSx))endifreturn trueendfunctionfunction mxr takes integer oSx returns integerset MAe[oSx]=trueset MBe[oSx]=falseset Mre[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])call rEx(m8e)return oSxendfunctionfunction mor takes nothing returns integerlocal integer oSxif(MNe==8190)thencall o_x("HandOfNature_Allocation_allocCustom","call DebugEx(HandOfNature.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",m7e+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(MIe[(w)]==w)thenset Mbe=Mbe+1set oSx=Mbeelse
set oSx=MIe[(w)]
set MIe[(w)]=MIe[MIe[(w)]]endifset MIe[oSx]=Zset MRe[oSx]=1call mxr(oSx)return oSxendfunctionfunction mrr takes integer oSx returns nothingset Mie[(oSx)]=(Mce+oSx)
endfunctionfunction mir takes integer oSx,integer Iix returns nothingcall Dux((Iix),(mse),(1),w)endfunctionfunction mar takes integer oSx,integer otx returns integerreturn(0+(LoadInteger(o[((V[(E[((Mre[(oSx)]))])]))],((((Mie[((oSx))])))),(((otx))))))endfunctionfunction mnr takes integer oSx,integer otx,integer oux returns booleanreturn rux(Mre[(oSx)],(Mie[((oSx))]),otx,oux)endfunctionfunction mVr takes integer oSx returns integerset Mhe[oSx]=trueset MHe[oSx]=falsecall rEx(mze)return oSxendfunctionfunction mEr takes nothing returns integerlocal integer oSxif(Mfe==8190)thencall o_x("FolderHandOfNature_StructRoots_Allocation_allocCustom","call DebugEx(FolderHandOfNature_StructRoots.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",mZe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(MFe[(w)]==w)thenset Mge=Mge+1set oSx=Mgeelse
set oSx=MFe[(w)]
set MFe[(w)]=MFe[MFe[(w)]]endifset MFe[oSx]=Zset MGe[oSx]=1call mVr(oSx)return oSxendfunctionfunction mXr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Mho=MJe[oSx]local integer effectAligment=-Mke[oSx]call mho((mko((((mHv[(Mho)])+Mke[oSx]*(GetRandomReal(((25.)*1.),((50.)*1.))))*1.),(((mjv[(Mho)])+Mke[oSx]*(GetRandomReal(((25.)*1.),((50.)*1.))))*1.),(MMe),(Bi))))set Mke[oSx]=Mke[oSx]endfunctionfunction mOr takes integer oSx returns nothingset Mhe[oSx]=falsecall rHx(mze)endfunctionfunction mRr takes integer oSx returns nothingif(MGe[oSx]>0)thenreturnendifif(MFe[oSx]!=Z)thencall o_x("FolderHandOfNature_StructRoots_Allocation_deallocCustom_confirm","call DebugEx(FolderHandOfNature_StructRoots.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",mZe+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset MFe[oSx]=MFe[(w)]set MFe[(w)]=oSx
call mOr(oSx)endfunctionfunction mIr takes integer oSx returns nothingset MGe[oSx]=MGe[oSx]-1call mRr(oSx)endfunctionfunction mAr takes integer Cqx,integer rYx,integer Iix returns nothinglocal real iMxif I9x(Iix,Wd)thenset iMx=mwe[rYx]
else
set iMx=mue[rYx]
endifset Rb=Cqxcall Nbx((Iix),(mWe),(rYx),w,((iMx)*1.))
endfunctionfunction mNr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=Mje[oSx]local integer p3x=MKe[oSx]local integer rYx=Mle[oSx]local integer Iix=MLe[oSx]call mIr((oSx))call MFo(Mho)call iKx(p3x)call mAr(Cqx,rYx,Iix)return trueendfunctionfunction mbr takes integer Cqx,integer rYx,integer Iix returns nothinglocal integer oSx=mEr()local integer Mho=Moo()local integer p3x=iXx()set Mje[oSx]=Cqx
set MJe[oSx]=Mho
set Mke[oSx]=-1set MKe[oSx]=p3x
set Mle[oSx]=rYx
set MLe[oSx]=Iix
set ge[(p3x)]=(oSx)call iDx(p3x,Mme,true,function mXr)set mCv[(Mho)]=((10.)*1.)set mFv[(Mho)]=Xkx((function mNr))set mZv[(Mho)]=(oSx)
call Meo(Mho,400.)call pxo(Mho,Cqx)call M6o((Mho),(Iix),.0,.0,.0,(null))endfunctionfunction mBr takes integer oSx,real x,real y returns nothing
local integer o5x=CHr(x,y)local integer IQxif plx(MEe[oSx],o5x)then
call CKr(o5x)returnendifcall spo(MEe[oSx],o5x)set IQx=Cwr(x,y,S7)set MOe[(IQx)]=(TimerGetRemaining(Oe[(Mne[oSx])]))*2+2call spo(MXe[oSx],IQx)endfunctionfunction mcr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local real jMx=Mse[oSx]local real jpx=MSe[oSx]local real oyx=Mqe[oSx]+MQe[oSx]
local real bexset Mqe[oSx]=oyx
set bex=(GetRandomReal(((.0)*1.),((Cf)*1.)))
loop
exitwhen(bex>Cf)
call mBr(oSx,jMx+oyx*(Cos(((((bex)*1.))*1.))),jpx+oyx*(Sin(((((bex)*1.))*1.))))set bex=bex+Bev*1./ 2endloopendfunctionfunction mCr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])call ikx(MVe[oSx])endfunctionfunction mdr takes integer oSx,integer Ctx returns nothinglocal integer rYx=(IH[(Ctx)])local real iMx=m2e[rYx]local integer fex=(R2I(((Mpe*1./ MPe)*1.)))local integer iCx=iXx()local integer p3x=iXx()set Mne[oSx]=iCx
set MVe[oSx]=p3x
set Mqe[oSx]=.0set MQe[oSx]=(CQx((m1e),Uvv+(rYx)))*1./ fexset Mse[oSx]=(yh[(Ctx)])
set MSe[oSx]=(Yh[(Ctx)])
set MEe[oSx]=M3x()set MXe[oSx]=M3x()set ge[(iCx)]=(oSx)set ge[(p3x)]=(oSx)call iDx(p3x,MPe,true,function mcr)call iDx(iCx,Mpe,false,function mCr)
endfunctionfunction mDr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local integer Ctx=(WH[(rFx)])local integer oSx=mor()local real n2xlocal real bexlocal integer mfrlocal integer mFrlocal real x
local real y
local integer IOrlocal integer EDrlocal integer Efrcall mrr(oSx)set MCe[oSx]=Cqx
if(Iix==w)thenset n2x=2*(ATv[(m5e[rYx])])*(Uj[(m5e[rYx])])
set Mxe[oSx]=falseelse
set n2x=dox(Iix,true)+S2R((dex(uH,("hon"),"var")))*(ATv[(m5e[rYx])])*(Uj[(m5e[rYx])])set Mxe[oSx]=trueset Moe[oSx]=Iix
call mir((w),Iix)endifcall mho((mko(((dVx)*1.),((dEx)*1.),(Mde),(Bi))))set bex=(Atan2(((dEx-(GetUnitY(C[((Cqx))])))*1.),((dVx-(GetUnitX(C[((Cqx))])))*1.)))
set mfr=m3e[rYx]
set mFr=1loop
exitwhen(mFr>mfr)set x=dVx+n2x*(Cos(((((bex)*1.))*1.)))set y=dEx+n2x*(Sin(((((bex)*1.))*1.)))set IOr=U0o(m5e[rYx],(ze[(Cqx)]),x,y,bex,m2e[rYx])call rwx(IOr,Mee,oSx)call o_x("HandOfNature_Event_SpellEffect","call DebugEx(I2S(this)+\";\"+I2S(this.Id.Get())+\" add \"+I2S(this.Data.Integer.Table.Count(SUMMONS_KEY_ARRAY)))",I2S(oSx)+";"+I2S((Mie[(oSx)]))+" add "+I2S(mar(oSx,Mae)))call mnr(oSx,Mae,IOr)call r0x((IOr),(MDe),(rYx))call Dux((IOr),(m6e),(1),w)call fzx(IOr,x,y)call Dyx(IOr,.0)
call D9x(IOr,(Uj[(m5e[rYx])]),1.)set hf=(ze[(IOr)])call NVo(m9e,dVx,dEx,(CQx((m1e),Uvv+(rYx))),Mve)
set EDr=m4e[rYx]
set Efr=1loop
exitwhen(Efr>EDr)set Iix=(mKo((m9e),((dVx)*1.),((dEx)*1.)))exitwhen(Iix==w)
call GroupRemoveUnit(kb[(m9e)],C[(Iix)])
if(Iix!=w)thencall mbr(IOr,rYx,Iix)endifset Efr=Efr+1endloopset bex=bex+Cf*1./ mfrset mFr=mFr+1endloopcall mdr(oSx,Ctx)return trueendfunctionfunction mgr takes nothing returns nothingendfunctionfunction mGr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])call nlo((Mue[oSx]),(MWe[oSx]),((MUe[oSx])*1.),(true),(false))endfunctionfunction mhr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=Rb
local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=iXx()set Mue[oSx]=Cqx
set MUe[oSx]=Mte[rYx]set Mwe[oSx]=p3x
set MWe[oSx]=Iix
set ge[(p3x)]=(oSx)call iDx(p3x,MTe,true,function mGr)return trueendfunctionfunction mHr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=Mwe[oSx]call iKx(p3x)return trueendfunctionfunction mjr takes nothing returns nothinglocal integer oMx=(m6[(m1e)])loop
set Mte[oMx]=mUe[oMx]*MTe*1./ mue[oMx]set oMx=oMx-1exitwhen(oMx<1)endloopcall Lxx(mWe,Xdx("FolderHandOfNature_FolderRoots_StructBuff_Init: call FolderHandOfNature_FolderRoots_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderHandOfNature_FolderRoots_StructBuff.Event_BuffGain))",bd,MI,function mhr))call Lxx(mWe,Xdx("FolderHandOfNature_FolderRoots_StructBuff_Init: call FolderHandOfNature_FolderRoots_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderHandOfNature_FolderRoots_StructBuff.Event_BuffLose))",jc,MI,function mHr))call W2x(nlv,mWe)endfunctionfunction mJr takes nothing returns booleanset m9e=O5x()set Mve=Xpx(function L1r)call Lxx(m6e,Xdx("HandOfNature_Init: call HandOfNature.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HandOfNature.Event_BuffLose))",jc,MI,function mer))
call mro(m1e,Xdx("HandOfNature_Init: call HandOfNature.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HandOfNature.Event_SpellEffect))",ih,MI,function mDr))call mgr()call mjr()return trueendfunctionfunction mkr takes nothing returns booleancall FAr(function mJr,"HandOfNature_Init")return trueendfunctionfunction mKr takes nothing returns booleanset Mye=Wwx('BSlP',"Poisoned",'bSlP')set uU[(Mye)]=(true)
set anv[(Mye)]=("ReplaceableTextures\\CommandButtons\\BTNPoisonSting.blp")call lWx(Mye,"Abilities\\Weapons\\PoisonSting\\PoisonStingTarget.mdl","origin",ri)return trueendfunctionfunction mlr takes nothing returns booleanset MYe[1]=-$Fset MYe[2]=-20set MYe[3]=-25set MYe[4]=-30set MYe[5]=-35set MYe[6]=-40set Mze[1]=-40set Mze[2]=-70set Mze[3]=-95set Mze[4]=-'s'set Mze[5]=-'x'set Mze[6]=-'}'return trueendfunctionfunction mLr takes nothing returns booleancall VNx(ma,(function mKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\SlowPoison.page\\SlowPoison.struct\\Target\\obj_dummyBuff_wc3buff.j"))call VNx(va,(function mlr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\SlowPoison.page\\SlowPoison.struct\\Target\\obj_this_wc3obj.j"))
return trueendfunctionfunction mmr takes nothing returns booleanset MZe=VXx(M_e)
return trueendfunctionfunction mMr takes nothing returns booleancall L1x('ASlP',false)set MDe=L0o('ASlP')set K6[(MDe)]=(H6)set m6[(MDe)]=(1)set TH[(MDe)]=("Slow Poison")set x3v[(MDe)]=("spell")
call L1o((MDe),Lov+(1),((750)*1.))set MOv[(MDe)]=("ReplaceableTextures\\PassiveButtons\\PASBTNPoisonSting.blp")return trueendfunctionfunction mpr takes nothing returns booleanset M0e=ltx(M1e+" (dummyBuff)")return trueendfunctionfunction mPr takes nothing returns booleancall VNx(Pa,(function mMr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\SlowPoison.page\\SlowPoison.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function mpr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HandOfNature.page\\HandOfNature.struct\\SlowPoison.page\\SlowPoison.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction mqr takes nothing returns booleanset M2e=VXx(M1e)
return trueendfunctionfunction mQr takes integer Iix returns booleanreturn( not(I9x(Iix,Ifv)))and( not(I9x(Iix,Igv)))endfunctionfunction msr takes integer Cqx,integer rYx,integer Iix returns nothinglocal real iMxif I9x(Iix,Wd)thenset iMx=M4eelse
set iMx=M5eendifset M6e=Cqxcall Nbx((Iix),(Mye),(rYx),w,((iMx)*1.))
endfunctionfunction mSr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])if not mQr(Iix)thenreturn trueendifcall msr((E2v[(rFx)]),(osx((((E2v[(rFx)]))),N+(MDe))),Iix)return trueendfunctionfunction mtr takes nothing returns booleanlocal integer rFx=(bv)call Avx((Vv[(rFx)]),M3e)return trueendfunctionfunction mTr takes nothing returns booleanlocal integer rFx=(bv)call RPx((Vv[(rFx)]),M3e)return trueendfunctionfunction mur takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(M0e),((Mv[(rFx)])),w)return trueendfunctionfunction mUr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),M0e)return trueendfunctionfunction mwr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxcall nlo((pve[oSx]),(Iix),((iUx(pee[oSx],(oG[(Iix)])-dG))*1.),(false),(false))endfunctionfunction mWr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=M6elocal integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=iXx()set pve[oSx]=Cqx
set pee[oSx]=M7e
set pxe[oSx]=p3x
set ge[(p3x)]=(oSx)call iDx(p3x,M9e,true,function mwr)return trueendfunctionfunction myr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=pxe[oSx]call iKx(p3x)return trueendfunctionfunction mYr takes nothing returns nothingset M7e=M8e*M9ecall Lxx(Mye,Xdx("FolderSlowPoison_StructTarget_Init: call FolderSlowPoison_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSlowPoison_StructTarget.Event_BuffGain))",bd,MI,function mWr))call Lxx(Mye,Xdx("FolderSlowPoison_StructTarget_Init: call FolderSlowPoison_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSlowPoison_StructTarget.Event_BuffLose))",jc,MI,function myr))call W2x(XDv,Mye)endfunctionfunction mzr takes nothing returns booleanset M3e=Xdx("SlowPoison_Init: set SlowPoison.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function SlowPoison.Event_Damage)",E4v,MI,function mSr)call Lxx(M0e,Xdx("SlowPoison_Init: call SlowPoison.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SlowPoison.Event_BuffGain))",bd,MI,function mtr))call Lxx(M0e,Xdx("SlowPoison_Init: call SlowPoison.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SlowPoison.Event_BuffLose))",jc,MI,function mTr))call mro(MDe,Xdx("SlowPoison_Init: call SlowPoison.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SlowPoison.Event_Learn))",pv,MI,function mur))
call mro(MDe,Xdx("SlowPoison_Init: call SlowPoison.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SlowPoison.Event_Unlearn))",Av,MI,function mUr))
call mYr()return trueendfunctionfunction mZr takes nothing returns booleancall FAr(function mzr,"SlowPoison_Init")
return trueendfunctionfunction m_r takes nothing returns booleanset poe=hjo('uTrM')call hJo(((poe)),ASv,(Ifv))call hJo(((poe)),ASv,(Idv))set Uj[(poe)]=((1.35)*1.)set NOv[(poe)]=((60)*1.)
set NWv[(poe)]=((60)*1.)
set I8v[(poe)]=((1)*1.)set Anv[(poe)]=(1)set Nmv[(poe)]=((5)*1.)set NLv[(poe)]=((5)*1.)set NKv[(poe)]=((0)*1.)set Auv[(poe)]=((0)*1.)set AUv[(poe)]=((0)*1.)set AYv[(poe)]=(0)set A_v[(poe)]=(0)set ATv[(poe)]=((16)*1.)
return trueendfunctionfunction m0r takes nothing returns booleanset pre=Wwx('BSMB',"Mine",'bSMB')set aav[(pre)]=(true)set Pc[(pre)]=(true)
set anv[(pre)]=("ReplaceableTextures\\CommandButtons\\BTNGoblinLandMine.blp")call lWx(pre,"HopNDrop_page\\HopNDrop_struct\\SetMines\\Mine\\PointingArrow.mdx","overhead",ri)return trueendfunctionfunction m1r takes nothing returns booleancall VNx(sa,(function m_r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HopNDrop.page\\HopNDrop.struct\\SetMines\\Mine\\obj_summonUnitType_wc3unit.j"))call VNx(ma,(function m0r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HopNDrop.page\\HopNDrop.struct\\SetMines\\Mine\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction m2r takes nothing returns booleanset pie=VXx(pae)
return trueendfunctionfunction m3r takes nothing returns booleanset pne[1]=$C8set pne[2]=$DCset pne[3]=$F0set pne[4]=260set pne[5]=280set pne[6]=300set pVe[1]=30set pVe[2]=45set pVe[3]=60set pVe[4]=80set pVe[5]='i'set pVe[6]=$87return trueendfunctionfunction m4r takes nothing returns booleanset pEe=ltx(pXe+" (dummyBuff)")set Pc[(pEe)]=(true)
call lWx(pEe,"units\\human\\phoenix\\phoenix.mdl","origin",Bi)return trueendfunctionfunction m5r takes nothing returns booleancall VNx(va,(function m3r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HopNDrop.page\\HopNDrop.struct\\SetMines\\obj_this_wc3obj.j"))call VNx(ma,(function m4r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HopNDrop.page\\HopNDrop.struct\\SetMines\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction m6r takes nothing returns booleanset pOe=VXx(pXe)
return trueendfunctionfunction m7r takes nothing returns booleanset pRe=ltx(pIe+" (dummyBuff)")call lWx(pRe,"Abilities\\Spells\\Undead\\OrbOfDeath\\OrbOfDeathMissile.mdl","origin",Bi)
call lWx(pRe,"units\\human\\phoenix\\phoenix.mdl","origin",Bi)return trueendfunctionfunction m8r takes nothing returns booleancall L1x('AHop',false)set Gyv=L0o('AHop')set K6[(Gyv)]=(D6)set m6[(Gyv)]=(6)set TH[(Gyv)]=("Hop'n'Drop")
set Rh[(Gyv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0092)))),(((Aj))))))set oxv[(Gyv)]=(2)set x3v[(Gyv)]=("spell")
call L1o((Gyv),GH+(1),((22)*1.))
call L1o((Gyv),tH+(1),(('x')*1.))call L1o((Gyv),Lov+(1),((900)*1.))call L1o((Gyv),GH+(2),((21)*1.))
call L1o((Gyv),tH+(2),(($8C)*1.))call L1o((Gyv),Lov+(2),((900)*1.))call L1o((Gyv),GH+(3),((20)*1.))
call L1o((Gyv),tH+(3),(($A0)*1.))call L1o((Gyv),Lov+(3),((900)*1.))call L1o((Gyv),GH+(4),((19)*1.))
call L1o((Gyv),tH+(4),(($B4)*1.))call L1o((Gyv),Lov+(4),((900)*1.))call L1o((Gyv),GH+(5),((18)*1.))
call L1o((Gyv),tH+(5),(($C8)*1.))call L1o((Gyv),Lov+(5),((900)*1.))call L1o((Gyv),GH+(6),((17)*1.))
call L1o((Gyv),tH+(6),(($DC)*1.))call L1o((Gyv),Lov+(6),((900)*1.))set MOv[(Gyv)]=("ReplaceableTextures\\CommandButtons\\BTNGoblinLandMine.blp")call cDr(Gyv,'FHD0',6,'VHD0','LPHD','LRHD')return trueendfunctionfunction m9r takes nothing returns booleancall VNx(ma,(function m7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HopNDrop.page\\HopNDrop.struct\\obj_dummyBuff_wc3buff.j"))call VNx(Pa,(function m8r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\HopNDrop.page\\HopNDrop.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Mvr takes nothing returns booleanset pAe=VXx(pIe)
return trueendfunctionfunction Mer takes integer oSx,real x,real y returns nothing
if(not IsTerrainPathable(((x)*1.),((y)*1.),PATHING_TYPE_WALKABILITY))thencall fwx(oSx,x)call fWx(oSx,y)endifendfunctionfunction Mxr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxlocal real cNx=pGe[oSx]+pHe[oSx]
local real x=(GetUnitX(C[((Iix))]))+pfe[oSx]
local real y=(GetUnitY(C[((Iix))]))+pge[oSx]
local real z=fYx(Iix)+cNxlocal real Mor=X_x(x,y)set pGe[oSx]=cNx
call Mer(Iix,x,y)if((cNx<.0)and(z<Mor+pke))thencall B8o(Iix,Mor)call AZx(Iix,pRe)else
call B8o(Iix,z)endifendfunctionfunction Mrr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local real dVx=pCelocal real dEx=pdelocal real bex=(Atan2(((dEx-(GetUnitY(C[((Iix))])))*1.),((dVx-(GetUnitX(C[((Iix))])))*1.)))local integer oSx=Iixlocal integer hCr=iXx()local real zD=X_x(dVx,dEx)-fYx(Iix)set pDe[oSx]=hCr
set pfe[oSx]=(Cos(((((bex)*1.))*1.)))*pFeset pge[oSx]=(Sin(((((bex)*1.))*1.)))*pFeset pGe[oSx]=phe-zD*1./ pBeset pHe[oSx]=pje+4*zD*1./ pJeset ge[(hCr)]=(oSx)call iDx(hCr,pce,true,function Mxr)return trueendfunctionfunction Mir takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer hCr=pDe[oSx]call iKx(hCr)call cmo(Iix)return trueendfunctionfunction Mar takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])set pCe=(yH[(rFx)])set pde=(YH[(rFx)])call Dux((Cqx),(pRe),(rYx),w)call Nbx(((Cqx)),(pEe),((rYx)),w,((pbe)*1.))
return trueendfunctionfunction Mnr takes real O4o,integer Cqx,real dQo,integer rYx,real x,real y,real z returns nothinglocal integer MVr=bOx(poe,(ze[(Cqx)]),x,y,(GetUnitFacing(C[((Cqx))])*Nh))local integer oSx=MVrset pSe[oSx]=O4o
set pte[oSx]=Cqx
set pTe[oSx]=dQo
call Avx(MVr,pue)call Dux((((MVr))),(nYv),(1),w)call Dux((((MVr))),(XAv),(1),w)call B8o(MVr,z)call Dyx(MVr,(64+O4o)*1./ $C0)call OSr(MVr,.0,.0,pUe*c9v,.0,.0,2*((X_x(x,y)-z)*1./ pwe*1./ pwe-pUe*1./ pwe)*c9v*c9v,pwe)call UZo((MVr),((pWe)*1.))endfunctionfunction MEr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxcall Mnr(pPe[oSx],Iix,pqe[oSx],pse[oSx],(GetUnitX(C[((Iix))])),(GetUnitY(C[((Iix))])),fYx(Iix))endfunctionfunction MXr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=iXx()set pPe[oSx]=pne[rYx]set pqe[oSx]=pVe[rYx]set pQe[oSx]=p3x
set pse[oSx]=rYx
set ge[(p3x)]=(oSx)call iDx(p3x,pMe,true,function MEr)return trueendfunctionfunction MOr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=pQe[oSx]call iKx(p3x)return trueendfunctionfunction MRr takes nothing returns booleanlocal integer rFx=(bv)local integer MVr=(Vv[(rFx)])local real MIr=(GetUnitX(C[((MVr))]))local real MAr=(GetUnitY(C[((MVr))]))local integer oSx=MVrlocal real O4o=pSe[oSx]local integer Cqx=pte[oSx]local real dQo=pTe[oSx]local integer C3o=(ze[(Cqx)])local integer Iixcall RPx(MVr,pue)call SetUnitAnimation(C[((MVr))],("spell"))call AZx(MVr,pre)set hf=C3ocall NVo(pye,MIr,MAr,O4o,pYe)set Iix=NEo(pye)
if(Iix!=w)thenloop
call Dux((((Iix))),(iiv),(1),w)call Nbx((((Iix))),(x5v),(1),w,((((pze)*1.))*1.))call nlo((Cqx),(Iix),((dQo)*1.),(false),(true))call Ulx(((Iix)),iiv)set Iix=NEo(pye)
exitwhen(Iix==w)
endloopendifreturn trueendfunctionfunction MNr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif I9x(Iix,Ijv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction Mbr takes nothing returns nothingset pue=Xdx("FolderHopNDrop_FolderSetMines_StructMine_Init: set FolderHopNDrop_FolderSetMines_StructMine.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderHopNDrop_FolderSetMines_StructMine.Event_Death)",VP,MI,function MRr)set pye=O5x()set pYe=Xpx(function MNr)endfunctionfunction MBr takes nothing returns nothingset pMe=pbe*1./(ppe+1)+.01call Lxx(pEe,Xdx("FolderHopNDrop_StructSetMines_Init: call FolderHopNDrop_StructSetMines.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderHopNDrop_StructSetMines.Event_BuffGain))",bd,MI,function MXr))call Lxx(pEe,Xdx("FolderHopNDrop_StructSetMines_Init: call FolderHopNDrop_StructSetMines.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderHopNDrop_StructSetMines.Event_BuffLose))",jc,MI,function MOr))call Mbr()endfunctionfunction Mcr takes nothing returns booleanset pNe=pbe*1./ 2.set pBe=(R2I(((pbe*1./ pce)*1.)))call Lxx(pRe,Xdx("HopNDrop_Init: call HopNDrop.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HopNDrop.Event_BuffGain))",bd,MI,function Mrr))
call Lxx(pRe,Xdx("HopNDrop_Init: call HopNDrop.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HopNDrop.Event_BuffLose))",jc,MI,function Mir))
call mro(Gyv,Xdx("HopNDrop_Init: call HopNDrop.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function HopNDrop.Event_SpellEffect))",ih,MI,function Mar))set pKe=pbe*pbe*1./ pNe*1./ pNe*pceset pFe=ple*1./ pBeset pJe=pBe*pBeset pLe=-2*pme*pce*pce*1./ pNe*1./ pNeset phe=2*pme*1./ pBeset pje=-4*pme*1./ pJecall MBr()return trueendfunctionfunction MCr takes nothing returns booleancall FAr(function Mcr,"HopNDrop_Init")return trueendfunctionfunction Mdr takes nothing returns booleanset pZe[1]=$Aset pZe[2]=$Fset pZe[3]=25set pZe[4]=35set pZe[5]=45set pZe[6]=55return trueendfunctionfunction MDr takes nothing returns booleancall VNx(va,(function Mdr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Cone\\obj_this_wc3obj.j"))
return trueendfunctionfunction Mfr takes nothing returns booleanset p_e=VXx(p0e)
return trueendfunctionfunction MFr takes nothing returns booleancall L1x('AInS',false)set p1e=L0o('AInS')set K6[(p1e)]=(H6)set m6[(p1e)]=(1)set TH[(p1e)]=("Funiculus Umbilicalis")set x3v[(p1e)]=("spell")
call L1o((p1e),Lov+(1),((750)*1.))set MOv[(p1e)]=("ReplaceableTextures\\CommandButtons\\BTNDoom.blp")return trueendfunctionfunction Mgr takes nothing returns booleanset p2e=ltx(p3e+" (dummyBuff)")return trueendfunctionfunction MGr takes nothing returns booleancall VNx(Pa,(function MFr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Summon\\FuniculusUmbilicalis\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function Mgr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Summon\\FuniculusUmbilicalis\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction Mhr takes nothing returns booleanset p4e=VXx(p3e)
return trueendfunctionfunction MHr takes nothing returns booleanset p5e[4]=hjo('uDe4')call hJo(((p5e[4])),ASv,(Idv))set Uj[(p5e[4])]=((.7)*1.)set NOv[(p5e[4])]=(('d')*1.)
set NWv[(p5e[4])]=((60)*1.)set NPv[(p5e[4])]=((270)*1.)
set I8v[(p5e[4])]=((0)*1.)set Anv[(p5e[4])]=(4)set Nmv[(p5e[4])]=(($FF)*1.)
set NLv[(p5e[4])]=(($FF)*1.)
set NKv[(p5e[4])]=((0)*1.)set Ncv[(p5e[4])]=(($708)*1.)set Nbv[(p5e[4])]=(($708)*1.)set NGv[(p5e[4])]=((45)*1.)set Adv[(p5e[4])]=(guv)set AGv[(p5e[4])]=((600)*1.)
set Ahv[((p5e[4]))]=((1.*1./((1.8)*1.))*1.)set AWv[(p5e[4])]=((.55)*1.)
set Dnv[(p5e[4])]=((600)*1.)
set Auv[(p5e[4])]=((28)*1.)set AUv[(p5e[4])]=((28)*1.)set AYv[(p5e[4])]=(2)set A_v[(p5e[4])]=(7)set A2v[(p5e[4])]=(4)set ATv[(p5e[4])]=((16)*1.)return trueendfunctionfunction Mjr takes nothing returns booleanset p5e[1]=hjo('uDes')call hJo(((p5e[1])),ASv,(Idv))set Uj[(p5e[1])]=((.6)*1.)set NOv[(p5e[1])]=(('d')*1.)
set NWv[(p5e[1])]=((60)*1.)set NPv[(p5e[1])]=((270)*1.)
set I8v[(p5e[1])]=((0)*1.)set Anv[(p5e[1])]=(4)set Nmv[(p5e[1])]=((75)*1.)set NLv[(p5e[1])]=((75)*1.)set NKv[(p5e[1])]=((0)*1.)set Ncv[(p5e[1])]=(($708)*1.)set Nbv[(p5e[1])]=(($708)*1.)set NGv[(p5e[1])]=(($F)*1.)set Adv[(p5e[1])]=(guv)set AGv[(p5e[1])]=((600)*1.)
set Ahv[((p5e[1]))]=((1.*1./((1.8)*1.))*1.)set AWv[(p5e[1])]=((.55)*1.)
set Dnv[(p5e[1])]=((600)*1.)
set Auv[(p5e[1])]=(($A)*1.)set AUv[(p5e[1])]=(($A)*1.)set AYv[(p5e[1])]=(2)set A_v[(p5e[1])]=(7)set A2v[(p5e[1])]=(4)set ATv[(p5e[1])]=((16)*1.)return trueendfunctionfunction MJr takes nothing returns booleanset p6e[1]=4
set p6e[2]=4
set p6e[3]=4
set p6e[4]=4
set p6e[5]=4
set p7e[1]=23set p7e[2]=23set p7e[3]=23set p7e[4]=23set p7e[5]=23return trueendfunctionfunction Mkr takes nothing returns booleanset p8e=ltx(p9e+" (dummyBuff)")return trueendfunctionfunction MKr takes nothing returns booleanset p5e[2]=hjo('uDe2')call hJo(((p5e[2])),ASv,(Idv))set Uj[(p5e[2])]=((.7)*1.)set NOv[(p5e[2])]=(('d')*1.)
set NWv[(p5e[2])]=((60)*1.)set NPv[(p5e[2])]=((270)*1.)
set I8v[(p5e[2])]=((0)*1.)set Anv[(p5e[2])]=(4)set Nmv[(p5e[2])]=(('}')*1.)
set NLv[(p5e[2])]=(('}')*1.)
set NKv[(p5e[2])]=((0)*1.)set Ncv[(p5e[2])]=(($708)*1.)set Nbv[(p5e[2])]=(($708)*1.)set NGv[(p5e[2])]=((25)*1.)set Adv[(p5e[2])]=(guv)set AGv[(p5e[2])]=((600)*1.)
set Ahv[((p5e[2]))]=((1.*1./((1.8)*1.))*1.)set AWv[(p5e[2])]=((.55)*1.)
set Dnv[(p5e[2])]=((600)*1.)
set Auv[(p5e[2])]=(($E)*1.)set AUv[(p5e[2])]=(($E)*1.)set AYv[(p5e[2])]=(2)set A_v[(p5e[2])]=(7)set A2v[(p5e[2])]=(4)set ATv[(p5e[2])]=((16)*1.)return trueendfunctionfunction Mlr takes nothing returns booleanset p5e[3]=hjo('uDe3')call hJo(((p5e[3])),ASv,(Idv))set Uj[(p5e[3])]=((.7)*1.)set NOv[(p5e[3])]=(('d')*1.)
set NWv[(p5e[3])]=((60)*1.)set NPv[(p5e[3])]=((270)*1.)
set I8v[(p5e[3])]=((0)*1.)set Anv[(p5e[3])]=(4)set Nmv[(p5e[3])]=(($B9)*1.)
set NLv[(p5e[3])]=(($B9)*1.)
set NKv[(p5e[3])]=((0)*1.)set Ncv[(p5e[3])]=(($708)*1.)set Nbv[(p5e[3])]=(($708)*1.)set NGv[(p5e[3])]=((35)*1.)set Adv[(p5e[3])]=(guv)set AGv[(p5e[3])]=((600)*1.)
set Ahv[((p5e[3]))]=((1.*1./((1.8)*1.))*1.)set AWv[(p5e[3])]=((.55)*1.)
set Dnv[(p5e[3])]=((600)*1.)
set Auv[(p5e[3])]=((20)*1.)set AUv[(p5e[3])]=((20)*1.)set AYv[(p5e[3])]=(2)set A_v[(p5e[3])]=(7)set A2v[(p5e[3])]=(4)set ATv[(p5e[3])]=((16)*1.)return trueendfunctionfunction MLr takes nothing returns booleanset p5e[5]=hjo('uDe5')call hJo(((p5e[5])),ASv,(Idv))set Uj[(p5e[5])]=((.7)*1.)set NOv[(p5e[5])]=(('d')*1.)
set NWv[(p5e[5])]=((60)*1.)set NPv[(p5e[5])]=((270)*1.)
set I8v[(p5e[5])]=((0)*1.)set Anv[(p5e[5])]=(4)set Nmv[(p5e[5])]=((335)*1.)
set NLv[(p5e[5])]=((335)*1.)
set NKv[(p5e[5])]=((0)*1.)set Ncv[(p5e[5])]=(($708)*1.)set Nbv[(p5e[5])]=(($708)*1.)set NGv[(p5e[5])]=((55)*1.)set Adv[(p5e[5])]=(guv)set AGv[(p5e[5])]=((600)*1.)
set Ahv[((p5e[5]))]=((1.*1./((1.8)*1.))*1.)set AWv[(p5e[5])]=((.55)*1.)
set Dnv[(p5e[5])]=((600)*1.)
set Auv[(p5e[5])]=((38)*1.)set AUv[(p5e[5])]=((38)*1.)set AYv[(p5e[5])]=(2)set A_v[(p5e[5])]=(7)set A2v[(p5e[5])]=(4)set ATv[(p5e[5])]=((16)*1.)return trueendfunctionfunction Mmr takes nothing returns booleancall VNx(sa,(function MHr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Summon\\obj_summonUnitType[4]_wc3unit.j"))
call VNx(sa,(function Mjr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Summon\\obj_summonUnitType[1]_wc3unit.j"))
call VNx(va,(function MJr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Summon\\obj_this_wc3obj.j"))call VNx(ma,(function Mkr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Summon\\obj_dummyBuff_wc3buff.j"))
call VNx(sa,(function MKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Summon\\obj_summonUnitType[2]_wc3unit.j"))
call VNx(sa,(function Mlr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Summon\\obj_summonUnitType[3]_wc3unit.j"))
call VNx(sa,(function MLr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Summon\\obj_summonUnitType[5]_wc3unit.j"))
return trueendfunctionfunction MMr takes nothing returns booleanset Pve=VXx(p9e)
return trueendfunctionfunction Mpr takes nothing returns booleanset Pee=Wwx('BInB',"Infection",'bInB')set Pc[(Pee)]=(true)
set uU[(Pee)]=(true)
set anv[(Pee)]=("ReplaceableTextures\\CommandButtons\\BTNDoom.blp")call lWx(Pee,"Abilities\\Spells\\Other\\AcidBomb\\BottleImpact.mdl","head",Bi)call lWx(Pee,"Abilities\\Spells\\Other\\Parasite\\ParasiteTarget.mdl","overhead",ri)
return trueendfunctionfunction MPr takes nothing returns booleanset Pxe[1]=-3set Pxe[2]=-5set Pxe[3]=-7set Pxe[4]=-9set Pxe[5]=-$Bset Pxe[6]=-$Dset Poe[1]=20set Poe[2]=35set Poe[3]=60set Poe[4]=95set Poe[5]=$8Cset Poe[6]=$C3set Pre[1]=5
set Pre[2]=5
set Pre[3]=5
set Pre[4]=5
set Pre[5]=5
set Pre[6]=5
return trueendfunctionfunction Mqr takes nothing returns booleancall VNx(ma,(function Mpr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Target\\obj_dummyBuff_wc3buff.j"))
call VNx(va,(function MPr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\Target\\obj_this_wc3obj.j"))return trueendfunctionfunction MQr takes nothing returns booleanset Pie=VXx(Pae)
return trueendfunctionfunction Msr takes nothing returns booleancall L1x('AIfc',false)set Gav=L0o('AIfc')set K6[(Gav)]=(D6)set m6[(Gav)]=(6)set TH[(Gav)]=("Infection")set Rh[(Gav)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00EE)))),(((Aj))))))set oxv[(Gav)]=(0)set x3v[(Gav)]=("spell")
call L1o((Gav),GH+(1),(($D)*1.))
call L1o((Gav),tH+(1),((50)*1.))
call L1o((Gav),Lov+(1),((750)*1.))call L1o((Gav),GH+(2),(($D)*1.))
call L1o((Gav),tH+(2),((62)*1.))
call L1o((Gav),Lov+(2),((750)*1.))call L1o((Gav),GH+(3),(($D)*1.))
call L1o((Gav),tH+(3),((74)*1.))
call L1o((Gav),Lov+(3),((750)*1.))call L1o((Gav),GH+(4),(($D)*1.))
call L1o((Gav),tH+(4),((86)*1.))
call L1o((Gav),Lov+(4),((750)*1.))call L1o((Gav),GH+(5),(($D)*1.))
call L1o((Gav),tH+(5),((98)*1.))
call L1o((Gav),Lov+(5),((750)*1.))call L1o((Gav),GH+(6),(($D)*1.))
call L1o((Gav),tH+(6),(('n')*1.))call L1o((Gav),Lov+(6),((750)*1.))set MOv[(Gav)]=("ReplaceableTextures\\CommandButtons\\BTNDoom.blp")call cDr(Gav,'FIn0',6,'VIn0','LPIn','LRIn')set Pne[1]=3
set Pne[2]=5
set Pne[3]=7
set Pne[4]=9
set Pne[5]=$Bset Pne[6]=$Dset PVe[1]=8
set PVe[2]=8
set PVe[3]=9
set PVe[4]=9
set PVe[5]=$Aset PVe[6]=$Aset PEe[1]=0
set PEe[2]=0
set PEe[3]=0
set PEe[4]=0
set PEe[5]=0
set PEe[6]=0
return trueendfunctionfunction MSr takes nothing returns booleanset PXe=Wwx('BInf',"Infection",'bInf')set aav[(PXe)]=(true)set anv[(PXe)]=("ReplaceableTextures\\CommandButtons\\BTNDoom.blp")call lWx(PXe,"Infection_page\\Infection_struct\\CasterEffect.mdx","head",ri)
set WU=l_x()
call l2x(WU,cbv,3)call l2x(WU,cCv,0)call l3x(((PXe)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,cbv,5)call l2x(WU,cCv,0)call l3x(((PXe)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,cbv,7)call l2x(WU,cCv,0)call l3x(((PXe)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,cbv,9)call l2x(WU,cCv,0)call l3x(((PXe)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,cbv,$B)call l2x(WU,cCv,0)call l3x(((PXe)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,cbv,$D)call l2x(WU,cCv,0)call l3x(((PXe)),ZB+(6),(WU))return trueendfunctionfunction Mtr takes nothing returns booleancall VNx(Pa,(function Msr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function MSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Infection.page\\Infection.struct\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction MTr takes nothing returns booleanset POe=VXx(PRe)
return trueendfunctionfunction Mur takes integer Cqx,integer rYx,integer Iix returns nothingset PNe=Cqxcall Nbx((Iix),(Pee),(rYx),w,((Pre[rYx])*1.))endfunctionfunction MUr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(E2v[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSxlocal integer rYxif(IsUnitAlly(C[(Iix)],vx[((ze[(Cqx)]))]))thenreturn trueendifset oSx=Cqxset rYx=PAe[oSx]
call Mur(Cqx,rYx,Iix)return trueendfunctionfunction Mwr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixset PAe[oSx]=rYx
call Avx(Iix,PIe)return trueendfunctionfunction MWr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall RPx(Iix,PIe)return trueendfunctionfunction Myr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(Mv[(rFx)])call Nbx(((Vv[(rFx)])),(PXe),(rYx),w,((PVe[rYx])*1.))return trueendfunctionfunction MYr takes nothing returns booleanlocal integer Iix=jhx()if(I8x((Ose),Ob,(Iix)))thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction Mzr takes nothing returns nothingset Pbe=PBe*1./ Pceset PCe=O5x()set Pde=Pce*PDeset Pfe=Xpx(function MYr)endfunctionfunction MZr takes integer Cqx,integer rYx,integer Iix returns nothinglocal integer oSx=Cqxlocal integer nZx=Pge[oSx]local integer IOrif(nZx<p6e[rYx])then
set nZx=nZx+1set IOr=U0o(p5e[rYx],(ze[(Cqx)]),(GetUnitX(C[((Iix))])),(GetUnitY(C[((Iix))])),(GetUnitFacing(C[((Iix))])*Nh),p7e[rYx])set Pge[oSx]=nZx
call rwx(IOr,PGe,oSx)call Avx(IOr,Phe)set PHe=Cqxcall r0x(((IOr)),((p1e)),(1))endifendfunctionfunction M_r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall MZr(Pje[oSx],PJe[oSx],Iix)return trueendfunctionfunction M0r takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxlocal integer Cqx=Pje[oSx]call nlo((Cqx),(Iix),((Pke[oSx])*1.),(true),(false))
endfunctionfunction M1r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=PNelocal integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=iXx()set Pje[oSx]=Cqx
set Pke[oSx]=PKe[rYx]set Ple[oSx]=p3x
set PJe[oSx]=rYx
call Avx(Iix,PFe)call iDx(p3x,PLe,true,function M0r)return trueendfunctionfunction M2r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=Ple[oSx]call iKx(p3x)call RPx(Iix,PFe)return trueendfunctionfunction M3r takes nothing returns nothinglocal integer oMxset PFe=Xdx("FolderInfection_StructTarget_Init: set FolderInfection_StructTarget.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_StructTarget.Event_Death)",VP,MI,function M_r)call Lxx(Pee,Xdx("FolderInfection_StructTarget_Init: call FolderInfection_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_StructTarget.Event_BuffGain))",bd,MI,function M1r))
call Lxx(Pee,Xdx("FolderInfection_StructTarget_Init: call FolderInfection_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_StructTarget.Event_BuffLose))",jc,MI,function M2r))
set oMx=(m6[(Gav)])loop
set PKe[oMx]=Poe[oMx]*1./(R2I(((Pre[oMx]*1./ PLe)*1.)))set oMx=oMx-1exitwhen(oMx<1)endloopendfunctionfunction M4r takes nothing returns booleanlocal integer rFx=(bv)local integer IOr=(Vv[(rFx)])local integer oSx=osx(IOr,PGe)local integer nZx=Pge[oSx]-1
set Pge[oSx]=nZx
call rVx(IOr,PGe)call RPx(IOr,Phe)return trueendfunctionfunction M5r takes nothing returns booleanlocal integer rFx=(bv)local integer M6r=(Vv[(rFx)])local real M7r=(LCv[(rFx)])*PMelocal integer oMx=CIx(M6r,Ppe)local integer oSxlocal integer Iixloop
set oSx=CAx(M6r,Ppe,oMx)
set Iix=oSxcall mao(M6r,Iix,M7r)set oMx=oMx-1exitwhen(oMx<q)endloopreturn trueendfunctionfunction M8r takes nothing returns booleanlocal integer rFx=(bv)local integer M6r=PHelocal integer Iix=(Vv[(rFx)])local integer oSx=Iixcall aKx("A")set PPe[oSx]=M6r
call aKx("B")if rUx(M6r,Ppe,oSx)thencall aKx("C")call Avx(M6r,Pme)endifcall aKx("D")return trueendfunctionfunction M9r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer M6r=PPe[oSx]if rnx(M6r,Ppe,oSx)thencall RPx(M6r,Pme)endifreturn trueendfunctionfunction pvr takes nothing returns booleanlocal integer rFx=(bv)call seo((Vv[(rFx)]),p2e,(Mv[(rFx)]))return trueendfunctionfunction per takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),p2e)return trueendfunctionfunction pxr takes nothing returns nothingset Pme=Xdx("FolderInfection_FolderSummon_StructFuniculusUmbilicalis_Init: set FolderInfection_FolderSummon_StructFuniculusUmbilicalis.HEAL_EVENT = Event.Create(Unit.HEALED_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_FolderSummon_StructFuniculusUmbilicalis.Event_Heal)",BCv,MI,function M5r)call Lxx(p2e,Xdx("FolderInfection_FolderSummon_StructFuniculusUmbilicalis_Init: call FolderInfection_FolderSummon_StructFuniculusUmbilicalis.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_FolderSummon_StructFuniculusUmbilicalis.Event_BuffGain))",bd,MI,function M8r))call Lxx(p2e,Xdx("FolderInfection_FolderSummon_StructFuniculusUmbilicalis_Init: call FolderInfection_FolderSummon_StructFuniculusUmbilicalis.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_FolderSummon_StructFuniculusUmbilicalis.Event_BuffLose))",jc,MI,function M9r))call mro(p1e,Xdx("FolderInfection_FolderSummon_StructFuniculusUmbilicalis_Init: call FolderInfection_FolderSummon_StructFuniculusUmbilicalis.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_FolderSummon_StructFuniculusUmbilicalis.Event_Learn))",Pv,MI,function pvr))call mro(p1e,Xdx("FolderInfection_FolderSummon_StructFuniculusUmbilicalis_Init: call FolderInfection_FolderSummon_StructFuniculusUmbilicalis.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_FolderSummon_StructFuniculusUmbilicalis.Event_Learn))",pv,MI,function pvr))call mro(p1e,Xdx("FolderInfection_FolderSummon_StructFuniculusUmbilicalis_Init: call FolderInfection_FolderSummon_StructFuniculusUmbilicalis.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_FolderSummon_StructFuniculusUmbilicalis.Event_Unlearn))",Av,MI,function per))endfunctionfunction por takes nothing returns nothingset Phe=Xdx("FolderInfection_StructSummon_Init: set FolderInfection_StructSummon.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderInfection_StructSummon.Event_Death)",VP,MI,function M4r)call pxr()endfunctionfunction prr takes nothing returns booleanset PIe=Xdx("Infection_Init: set Infection.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function Infection.Event_Damage)",E4v,MI,function MUr)call Lxx(PXe,Xdx("Infection_Init: call Infection.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Infection.Event_BuffGain))",bd,MI,function Mwr))call Lxx(PXe,Xdx("Infection_Init: call Infection.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Infection.Event_BuffLose))",jc,MI,function MWr))call mro(Gav,Xdx("Infection_Init: call Infection.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Infection.Event_SpellEffect))",ih,MI,function Myr))
call Mzr()call M3r()call por()return trueendfunctionfunction pir takes nothing returns booleancall FAr(function prr,"Infection_Init")return trueendfunctionfunction par takes nothing returns booleanset Pqe[1]=20set Pqe[2]=30set Pqe[3]=40set Pqe[4]=50set Pqe[5]=60set PQe[1]=20set PQe[2]=30set PQe[3]=40set PQe[4]=50set PQe[5]=60return trueendfunctionfunction pnr takes nothing returns booleanset Pse=ltx(PSe+" (dummyBuff)")return trueendfunctionfunction pVr takes nothing returns booleancall VNx(va,(function par),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\KhakiRecovery.page\\KhakiRecovery.struct\\Restoration\\obj_this_wc3obj.j"))call VNx(ma,(function pnr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\KhakiRecovery.page\\KhakiRecovery.struct\\Restoration\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction pEr takes nothing returns booleanset Pte=VXx(PSe)
return trueendfunctionfunction pXr takes nothing returns booleanset PTe=VCx("OKRS")return trueendfunctionfunction pOr takes nothing returns booleanset Pue=Wwx('BRec',"Khaki Recovery",'bRec')set aav[(Pue)]=(true)set Pc[(Pue)]=(true)
set uU[(Pue)]=(true)
set anv[(Pue)]=("ReplaceableTextures\\CommandButtons\\BTNMagicImmunity.blp")
call lWx(Pue,"Abilities\\Spells\\NightElf\\Barkskin\\BarkSkinTarget.mdl","chest",ri)
set WU=l_x()
call l2x(WU,dmv,50)call l3x(((Pue)),ZB+(1),(WU))return trueendfunctionfunction pRr takes nothing returns booleancall L1x('ARec',false)set gzv=L0o('ARec')set K6[(gzv)]=(O6)set m6[(gzv)]=(6)set TH[(gzv)]=("Khaki Recovery")
set Rh[(gzv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0215)))),(((Aj))))))set oxv[(gzv)]=(4)set x3v[(gzv)]=("spell")
call L1o((gzv),Uvv+(1),((500)*1.))call L1o((gzv),GH+(1),((6)*1.))call L1o((gzv),tH+(1),(('i')*1.))call L1o((gzv),Lov+(1),((650)*1.))call L1o((gzv),Uvv+(2),((500)*1.))call L1o((gzv),GH+(2),((6)*1.))call L1o((gzv),tH+(2),(('x')*1.))call L1o((gzv),Lov+(2),((650)*1.))call L1o((gzv),Uvv+(3),((500)*1.))call L1o((gzv),GH+(3),((6)*1.))call L1o((gzv),tH+(3),(($87)*1.))call L1o((gzv),Lov+(3),((650)*1.))call L1o((gzv),Uvv+(4),((500)*1.))call L1o((gzv),GH+(4),((6)*1.))call L1o((gzv),tH+(4),(($96)*1.))call L1o((gzv),Lov+(4),((650)*1.))call L1o((gzv),Uvv+(5),((500)*1.))call L1o((gzv),GH+(5),((6)*1.))call L1o((gzv),tH+(5),(($A5)*1.))call L1o((gzv),Lov+(5),((650)*1.))call L1o((gzv),Uvv+(6),((500)*1.))call L1o((gzv),GH+(6),((6)*1.))call L1o((gzv),tH+(6),(($B4)*1.))call L1o((gzv),Lov+(6),((650)*1.))set MOv[(gzv)]=("ReplaceableTextures\\CommandButtons\\BTNMagicImmunity.blp")
call cDr(gzv,'FRc0',6,'VRc0','LPRc','LRRc')set PUe[1]=3
set PUe[2]=3
set PUe[3]=4
set PUe[4]=4
set PUe[5]=5
set PUe[6]=5
set Pwe[1]=8
set Pwe[2]=8
set Pwe[3]=8
set Pwe[4]=8
set Pwe[5]=8
set Pwe[6]=8
set PWe[1]=50set PWe[2]=60set PWe[3]=70set PWe[4]=80set PWe[5]=90set PWe[6]='d'set Pye[1]='x'set Pye[2]=$B4set Pye[3]=$F0set Pye[4]=300set Pye[5]=360set Pye[6]=420set PYe[1]=30set PYe[2]=45set PYe[3]=60set PYe[4]=75set PYe[5]=90set PYe[6]='i'return trueendfunctionfunction pIr takes nothing returns booleanset Pze=VCx("OKhR")return trueendfunctionfunction pAr takes nothing returns booleancall VNx(ha,(function pXr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\KhakiRecovery.page\\KhakiRecovery.struct\\obj_boltSecondary_wc3bolt.j"))
call VNx(ma,(function pOr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\KhakiRecovery.page\\KhakiRecovery.struct\\obj_moveSpeedBuff_wc3buff.j"))
call VNx(Pa,(function pRr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\KhakiRecovery.page\\KhakiRecovery.struct\\obj_thisSpell_wc3spell.j"))call VNx(ha,(function pIr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\KhakiRecovery.page\\KhakiRecovery.struct\\obj_boltPrimary_wc3bolt.j"))return trueendfunctionfunction pNr takes nothing returns booleanset PZe=VXx(P_e)
return trueendfunctionfunction pbr takes nothing returns booleanlocal integer Iix=jhx()if LLo(nbe,Iix)thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,IFv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif not(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction pBr takes integer oSx returns integerset P6e[oSx]=trueset P7e[oSx]=falsecall rEx(PZe)return oSxendfunctionfunction pcr takes nothing returns integerlocal integer oSxif(P2e==8190)thencall o_x("KhakiRecovery_Allocation_allocCustom","call DebugEx(KhakiRecovery.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",P_e+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(P3e[(w)]==w)thenset P4e=P4e+1set oSx=P4eelse
set oSx=P3e[(w)]
set P3e[(w)]=P3e[P3e[(w)]]endifset P3e[oSx]=Zset P5e[oSx]=1call pBr(oSx)return oSxendfunctionfunction pCr takes integer oSx returns nothingset P6e[oSx]=falsecall rHx(PZe)endfunctionfunction pdr takes integer oSx returns nothingif(P5e[oSx]>0)thenreturnendifif(P3e[oSx]!=Z)thencall o_x("KhakiRecovery_Allocation_deallocCustom_confirm","call DebugEx(KhakiRecovery.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",P_e+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset P3e[oSx]=P3e[(w)]set P3e[(w)]=oSx
call pCr(oSx)endfunctionfunction pDr takes integer oSx returns nothingset P5e[oSx]=P5e[oSx]-1call pdr(oSx)endfunctionfunction pfr takes integer oSx,integer Okx returns nothingcall pDr((oSx))call iKx(Okx)call X_r(qre[oSx])endfunctionfunction pFr takes boolean pgr,integer pGr,integer phr returns integerif pgr thenreturn cdo(pGr)endifreturn cdo(phr)endfunctionfunction pHr takes integer oSx,integer Cqx,integer rYx,integer pjr,integer EFr,integer Efr returns nothinglocal integer cMo=pFr((Efr==0),Pze,PTe)local real AXr=qee[oSx]*(1.+qXe*(Efr-1))
set qxe[oSx]=EFr
call dQx(qre[oSx],EFr)call Ryx((ACx((EFr),(qOe),(qRe),(Bi))))call Nbx((EFr),(Pue),(rYx),w,((Pwe[rYx])*1.))call mao(Cqx,EFr,AXr)if(Efr!=0)thencall SetLightningColor(YT[(cMo)],(0)*1./ 255.,($FF)*1./ 255.,(0)*1./ 255.,($FF)*1./ 255.)endifcall ERr(cMo,pjr,EFr)call pmo((ACx((EFr),(qIe),(qAe),(ri))),2.)call cLo(cMo,.75)endfunctionfunction pJr takes nothing returns nothinglocal integer Okx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(Okx)])local integer svo=qre[oSx]local integer Efr=qie[oSx]+1
local integer Cqxlocal integer pjrlocal real pkrlocal real pKrlocal integer EFrif(Efr>qae[oSx])then
call pfr(oSx,Okx)else
set Cqx=P9e[oSx]
set pjr=qxe[oSx]
set pkr=(GetUnitX(C[((pjr))]))set pKr=(GetUnitY(C[((pjr))]))set Ose=svoset hf=(ze[(Cqx)])call NVo(P0e,pkr,pKr,P8e[oSx],P1e)set EFr=(mKo((P0e),((pkr)*1.),((pKr)*1.)))if(EFr==w)thencall pfr(oSx,Okx)else
set qie[oSx]=Efr
call pHr(oSx,Cqx,qoe[oSx],pjr,EFr,Efr-1)
endifendifendfunctionfunction plr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local integer oSx=pcr()local integer Okx=iXx()local integer svo=Jbx("KhakiRecovery_Event_SpellEffect: local UnitList targetGroup = UnitList.Create()")
set P8e[oSx]=(CQx((gzv),Uvv+(rYx)))set P9e[oSx]=Cqx
set qve[oSx]=Okx
set qee[oSx]=Pye[rYx]set qxe[oSx]=Iix
set qoe[oSx]=rYx
set qre[oSx]=svo
set qie[oSx]=1set qae[oSx]=PUe[rYx]set ge[(Okx)]=(oSx)call Ryx((ACx((Cqx),(qne),(qVe),(ri))))call iDx(Okx,qEe,true,function pJr)call pHr(oSx,Cqx,rYx,Cqx,Iix,0)call wCo(Iix,true,false,true)return trueendfunctionfunction pLr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(fG[(rFx)])local integer oSx=Cqxcall pmo((ACx((Cqx),(qbe),(qBe),(ri))),2.)call mao(Cqx,Cqx,qce[oSx])call mno(Cqx,Cqx,qCe[oSx])return trueendfunctionfunction pmr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixset qce[oSx]=Pqe[rYx]set qCe[oSx]=PQe[rYx]call Avx(Iix,qNe)return trueendfunctionfunction pMr takes nothing returns booleanlocal integer rFx=(bv)call RPx((Vv[(rFx)]),qNe)return trueendfunctionfunction ppr takes nothing returns booleanlocal integer rFx=(bv)call seo((Vv[(rFx)]),Pse,(Mv[(rFx)]))return trueendfunctionfunction pPr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),Pse)return trueendfunctionfunction pqr takes nothing returns nothingset qNe=Xdx("FolderKhakiRecovery_StructRestoration_Init: set FolderKhakiRecovery_StructRestoration.DEATH_EVENT = Event.Create(UNIT.Death.Events.KILLER_EVENT_TYPE, EventPriority.SPELLS, function FolderKhakiRecovery_StructRestoration.Event_Death)",BMv,MI,function pLr)call Lxx(Pse,Xdx("FolderKhakiRecovery_StructRestoration_Init: call FolderKhakiRecovery_StructRestoration.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderKhakiRecovery_StructRestoration.Event_BuffGain))",bd,MI,function pmr))call Lxx(Pse,Xdx("FolderKhakiRecovery_StructRestoration_Init: call FolderKhakiRecovery_StructRestoration.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderKhakiRecovery_StructRestoration.Event_BuffLose))",jc,MI,function pMr))call mro(gzv,Xdx("FolderKhakiRecovery_StructRestoration_Init: call KhakiRecovery.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function FolderKhakiRecovery_StructRestoration.Event_Learn))",Pv,MI,function ppr))
call mro(gzv,Xdx("FolderKhakiRecovery_StructRestoration_Init: call KhakiRecovery.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderKhakiRecovery_StructRestoration.Event_Learn))",pv,MI,function ppr))call mro(gzv,Xdx("FolderKhakiRecovery_StructRestoration_Init: call KhakiRecovery.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderKhakiRecovery_StructRestoration.Event_Unlearn))",Av,MI,function pPr))endfunctionfunction pQr takes nothing returns booleanset P0e=O5x()set P1e=Xpx(function pbr)call mro(gzv,Xdx("KhakiRecovery_Init: call KhakiRecovery.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function KhakiRecovery.Event_SpellEffect))",ih,MI,function plr))
call pqr()return trueendfunctionfunction psr takes nothing returns booleancall FAr(function pQr,"KhakiRecovery_Init")return trueendfunctionfunction pSr takes nothing returns booleanset qde[1]=60set qde[2]=60set qde[3]=60set qde[4]=60set qde[5]=60set qde[6]=60return trueendfunctionfunction ptr takes nothing returns booleanset qDe[2]=hjo('uMC2')call hJo(((qDe[2])),ASv,(Idv))set Uj[(qDe[2])]=((1.4)*1.)set NOv[(qDe[2])]=((123.45679012346)*1.)
set NWv[(qDe[2])]=((74.074074074074)*1.)
set nKv[(qDe[2])]=("Units\\Undead\\Abomination\\AbominationExplosion.mdx")set NPv[(qDe[2])]=((270)*1.)
set I8v[(qDe[2])]=(($A)*1.)set Anv[(qDe[2])]=(2)set Nmv[(qDe[2])]=(($5DC)*1.)set NLv[(qDe[2])]=(($5DC)*1.)set NKv[(qDe[2])]=((0)*1.)set Ncv[(qDe[2])]=(($578)*1.)set Nbv[(qDe[2])]=(($578)*1.)set NGv[(qDe[2])]=(($96)*1.)
set Adv[(qDe[2])]=(gkv)set AGv[(qDe[2])]=((300)*1.)
set Ahv[((qDe[2]))]=((1.*1./((2)*1.))*1.)set AWv[(qDe[2])]=((.5)*1.)set Auv[(qDe[2])]=((60)*1.)set AUv[(qDe[2])]=((60)*1.)set AYv[(qDe[2])]=(5)set A_v[(qDe[2])]=(8)set A2v[(qDe[2])]=(0)set ATv[(qDe[2])]=((59.259259259259)*1.)
return trueendfunctionfunction pTr takes nothing returns booleanset qDe[3]=hjo('uMC3')call hJo(((qDe[3])),ASv,(Idv))set Uj[(qDe[3])]=((1.65)*1.)
set NOv[(qDe[3])]=((123.45679012346)*1.)
set NWv[(qDe[3])]=((74.074074074074)*1.)
set nKv[(qDe[3])]=("Units\\Undead\\Abomination\\AbominationExplosion.mdx")set NPv[(qDe[3])]=((270)*1.)
set I8v[(qDe[3])]=(($A)*1.)set Anv[(qDe[3])]=(2)set Nmv[(qDe[3])]=(($7D0)*1.)set NLv[(qDe[3])]=(($7D0)*1.)set NKv[(qDe[3])]=((0)*1.)set Ncv[(qDe[3])]=(($578)*1.)set Nbv[(qDe[3])]=(($578)*1.)set NGv[(qDe[3])]=(($C8)*1.)
set Adv[(qDe[3])]=(gkv)set AGv[(qDe[3])]=((300)*1.)
set Ahv[((qDe[3]))]=((1.*1./((2)*1.))*1.)set AWv[(qDe[3])]=((.5)*1.)set Auv[(qDe[3])]=((80)*1.)set AUv[(qDe[3])]=((80)*1.)set AYv[(qDe[3])]=(5)set A_v[(qDe[3])]=($A)set A2v[(qDe[3])]=(0)set ATv[(qDe[3])]=((59.259259259259)*1.)
return trueendfunctionfunction pur takes nothing returns booleanset qDe[1]=hjo('uMC1')call hJo(((qDe[1])),ASv,(Idv))set Uj[(qDe[1])]=((1.25)*1.)
set NOv[(qDe[1])]=((123.45679012346)*1.)
set NWv[(qDe[1])]=((74.074074074074)*1.)
set nKv[(qDe[1])]=("Units\\Undead\\Abomination\\AbominationExplosion.mdx")set NPv[(qDe[1])]=((270)*1.)
set I8v[(qDe[1])]=(($A)*1.)set Anv[(qDe[1])]=(2)set Nmv[(qDe[1])]=(($3E8)*1.)set NLv[(qDe[1])]=(($3E8)*1.)set NKv[(qDe[1])]=((0)*1.)set Ncv[(qDe[1])]=(($578)*1.)set Nbv[(qDe[1])]=(($578)*1.)set NGv[(qDe[1])]=(('d')*1.)
set Adv[(qDe[1])]=(gkv)set AGv[(qDe[1])]=((300)*1.)
set Ahv[((qDe[1]))]=((1.*1./((2)*1.))*1.)set AWv[(qDe[1])]=((.5)*1.)set Auv[(qDe[1])]=((40)*1.)set AUv[(qDe[1])]=((40)*1.)set AYv[(qDe[1])]=(5)set A_v[(qDe[1])]=(6)set A2v[(qDe[1])]=(0)set ATv[(qDe[1])]=((59.259259259259)*1.)
return trueendfunctionfunction pUr takes nothing returns booleancall L1x('AMaC',false)set g8v=L0o('AMaC')set K6[(g8v)]=(G6)set m6[(g8v)]=(3)set TH[(g8v)]=("Mana Colossus")set Rh[(g8v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0272)))),(((Aj))))))set oxv[(g8v)]=(0)set x3v[(g8v)]=("spell")
call L1o((g8v),GH+(1),(('x')*1.))call L1o((g8v),tH+(1),(($FA)*1.))call L1o((g8v),Lov+(1),((750)*1.))call L1o((g8v),GH+(2),(('x')*1.))call L1o((g8v),tH+(2),((350)*1.))call L1o((g8v),Lov+(2),((750)*1.))call L1o((g8v),GH+(3),(('x')*1.))call L1o((g8v),tH+(3),((450)*1.))call L1o((g8v),Lov+(3),((750)*1.))set MOv[(g8v)]=("ReplaceableTextures\\CommandButtons\\BTNAbomination.blp")call cDr(g8v,'FMC0',3,'VMC0','LPMC','LRMC')return trueendfunctionfunction pwr takes nothing returns booleancall VNx(va,(function pSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaColossus.page\\ManaColossus.struct\\obj_this_wc3obj.j"))
call VNx(sa,(function ptr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaColossus.page\\ManaColossus.struct\\obj_thisUnitTypes[2]_wc3unit.j"))call VNx(sa,(function pTr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaColossus.page\\ManaColossus.struct\\obj_thisUnitTypes[3]_wc3unit.j"))call VNx(sa,(function pur),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaColossus.page\\ManaColossus.struct\\obj_thisUnitTypes[1]_wc3unit.j"))call VNx(Pa,(function pUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaColossus.page\\ManaColossus.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction pWr takes nothing returns booleanset qfe=VXx(qFe)
return trueendfunctionfunction pyr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer C3o=(ze[(Cqx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real bex=(GetUnitFacing(C[((Cqx))])*Nh)local integer IOr=U0o(qDe[rYx],C3o,wQo+qge*(Cos(((((bex)*1.))*1.))),wso+qge*(Sin(((((bex)*1.))*1.))),bex,qde[rYx])call r0x((IOr),(qGe),(rYx))return trueendfunctionfunction pYr takes nothing returns booleancall mro(g8v,Xdx("ManaColossus_Init: call ManaColossus.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ManaColossus.Event_SpellEffect))",ih,MI,function pyr))return trueendfunctionfunction pzr takes nothing returns booleancall FAr(function pYr,"ManaColossus_Init")return trueendfunctionfunction pZr takes nothing returns booleanset qhe=Wwx('BTVT',"Theurgic Vessel - Target",'bTVT')set aav[(qhe)]=(true)set anv[(qhe)]=("ReplaceableTextures\\CommandButtons\\BTNPotionOfVampirism.blp")
call lWx(qhe,"Abilities\\Spells\\Undead\\Possession\\PossessionTarget.mdl","origin",ri)set WU=l_x()
call l2x(WU,Ehv,.2)call l2x(WU,cdv,.2)call l3x(((qhe)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,Ehv,.3)call l2x(WU,cdv,.3)call l3x(((qhe)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,Ehv,.4)call l2x(WU,cdv,.4)call l3x(((qhe)),ZB+(3),(WU))return trueendfunctionfunction p_r takes nothing returns booleanset qHe[1]=.2set qHe[2]=.3set qHe[3]=.4set qje[1]=.2set qje[2]=.3set qje[3]=.4return trueendfunctionfunction p0r takes nothing returns booleancall VNx(ma,(function pZr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaColossus.page\\TheurgicVessel.struct\\Target\\obj_dummyBuff_wc3buff.j"))
call VNx(va,(function p_r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaColossus.page\\TheurgicVessel.struct\\Target\\obj_this_wc3obj.j"))return trueendfunctionfunction p1r takes nothing returns booleanset qJe=VXx(qke)
return trueendfunctionfunction p2r takes nothing returns booleanset qKe=Wwx('BThV',"Theurgic Vessel",'bThV')
set aav[(qKe)]=(true)set anv[(qKe)]=("ReplaceableTextures\\CommandButtons\\BTNPotionOfVampirism.blp")
call lWx(qKe,"Abilities\\Spells\\Items\\AIso\\BIsvTarget.mdx","chest",ri)return trueendfunctionfunction p3r takes nothing returns booleancall L1x('AThV',false)set qGe=L0o('AThV')set K6[(qGe)]=(H6)set m6[(qGe)]=(1)set TH[(qGe)]=("Theurgic Vessel")set x3v[(qGe)]=("spell")
call L1o((qGe),Uvv+(1),((600)*1.))call L1o((qGe),Lov+(1),((750)*1.))set MOv[(qGe)]=("ReplaceableTextures\\CommandButtons\\BTNPotionOfVampirism.blp")
return trueendfunctionfunction p4r takes nothing returns booleancall VNx(ma,(function p2r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaColossus.page\\TheurgicVessel.struct\\obj_dummyBuff_wc3buff.j"))
call VNx(Pa,(function p3r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaColossus.page\\TheurgicVessel.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction p5r takes nothing returns booleanset qle=VXx(qLe)
return trueendfunctionfunction p6r takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif not(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction p7r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(hc[(rFx)])local integer oSx=Cqxlocal integer Xur=XQr(Cqx)set qMe[oSx]=Cqx
set qpe[oSx]=rYx
set Ene[(Xur)]=(oSx)
set vqe[(Xur)]=(((CQx((qGe),Uvv+(rYx))))*1.)
set vQe[(Xur)]=(qme)
call Xsr(Xur,qPe)call Xsr(Xur,qqe)call Xtr(Xur)return trueendfunctionfunction p8r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oSx=Cqxlocal integer Xur=qQe[oSx]call X5r(Xur)return trueendfunctionfunction p9r takes nothing returns booleanlocal integer rFx=(bv)call seo((Vv[(rFx)]),qKe,(Mv[(rFx)]))return trueendfunctionfunction Pvr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),qKe)return trueendfunctionfunction Per takes nothing returns booleanset qme=Xpx(function p6r)call Lxx(qKe,Xdx("TheurgicVessel_Init: call TheurgicVessel.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TheurgicVessel.Event_BuffGain))",bd,MI,function p7r))call Lxx(qKe,Xdx("TheurgicVessel_Init: call TheurgicVessel.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TheurgicVessel.Event_BuffLose))",jc,MI,function p8r))call mro(qGe,Xdx("TheurgicVessel_Init: call TheurgicVessel.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function TheurgicVessel.Event_Learn))",Pv,MI,function p9r))call mro(qGe,Xdx("TheurgicVessel_Init: call TheurgicVessel.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TheurgicVessel.Event_Learn))",pv,MI,function p9r))
call mro(qGe,Xdx("TheurgicVessel_Init: call TheurgicVessel.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TheurgicVessel.Event_Unlearn))",Av,MI,function Pvr))
return trueendfunctionfunction Pxr takes nothing returns booleancall fdr(function Per,"TheurgicVessel_Init")
return trueendfunctionfunction Por takes nothing returns booleanset qse=ltx(qSe+" (dummyBuff)")set Pc[(qse)]=(true)
call lWx(qse,"Abilities\\Spells\\NightElf\\Barkskin\\BarkSkinTarget.mdl","hand left",ri)
call lWx(qse,"Abilities\\Spells\\NightElf\\Barkskin\\BarkSkinTarget.mdl","hand right",ri)return trueendfunctionfunction Prr takes nothing returns booleancall L1x('AMaR',false)set qte=L0o('AMaR')set K6[(qte)]=(O6)set m6[(qte)]=(6)set TH[(qte)]=("Revert")
set Rh[(qte)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0104)))),(((Aj))))))set oxv[(qte)]=(0)set x3v[(qte)]=("spell")
call L1o((qte),GH+(1),((0)*1.))call L1o((qte),Lov+(1),((750)*1.))call L1o((qte),GH+(2),((0)*1.))call L1o((qte),Lov+(2),((750)*1.))call L1o((qte),GH+(3),((0)*1.))call L1o((qte),Lov+(3),((750)*1.))call L1o((qte),GH+(4),((0)*1.))call L1o((qte),Lov+(4),((750)*1.))call L1o((qte),GH+(5),((0)*1.))call L1o((qte),Lov+(5),((750)*1.))call L1o((qte),GH+(6),((0)*1.))call L1o((qte),Lov+(6),((750)*1.))set MOv[(qte)]=("ReplaceableTextures\\CommandButtons\\BTNNeutralManaShieldOff.blp")call cDr(qte,'FMR0',6,'VMR0','LPMR','LRMR')return trueendfunctionfunction Pir takes nothing returns booleancall VNx(ma,(function Por),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaLaser.page\\ManaLaser.struct\\Revert\\obj_dummyBuff_wc3buff.j"))
call VNx(Pa,(function Prr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaLaser.page\\ManaLaser.struct\\Revert\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Par takes nothing returns booleanset qTe=VXx(qSe)
return trueendfunctionfunction Pnr takes nothing returns booleanset que=VCx("OMaL")return trueendfunctionfunction PVr takes nothing returns booleancall L1x('AMaL',false)set qUe=L0o('AMaL')set K6[(qUe)]=(O6)set m6[(qUe)]=(6)set TH[(qUe)]=("Mana Laser")
set Rh[(qUe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00D3)))),(((Aj))))))set oxv[(qUe)]=(2)set x3v[(qUe)]=("spell")
call L1o((qUe),Uvv+(1),(($C8)*1.))call L1o((qUe),GH+(1),(($F)*1.))
call L1o((qUe),tH+(1),((90)*1.))
call L1o((qUe),Lov+(1),((99999)*1.))
call L1o((qUe),Uvv+(2),(($C8)*1.))call L1o((qUe),GH+(2),(($F)*1.))
call L1o((qUe),tH+(2),(('i')*1.))call L1o((qUe),Lov+(2),((99999)*1.))
call L1o((qUe),Uvv+(3),(($C8)*1.))call L1o((qUe),GH+(3),(($F)*1.))
call L1o((qUe),tH+(3),(('x')*1.))call L1o((qUe),Lov+(3),((99999)*1.))
call L1o((qUe),Uvv+(4),(($C8)*1.))call L1o((qUe),GH+(4),(($F)*1.))
call L1o((qUe),tH+(4),(($87)*1.))call L1o((qUe),Lov+(4),((99999)*1.))
call L1o((qUe),Uvv+(5),(($C8)*1.))call L1o((qUe),GH+(5),(($F)*1.))
call L1o((qUe),tH+(5),(($96)*1.))call L1o((qUe),Lov+(5),((99999)*1.))
call L1o((qUe),Uvv+(6),(($C8)*1.))call L1o((qUe),GH+(6),(($F)*1.))
call L1o((qUe),tH+(6),(($A5)*1.))call L1o((qUe),Lov+(6),((99999)*1.))
set MOv[(qUe)]=("ReplaceableTextures\\CommandButtons\\BTNManaBurn.blp")call cDr(qUe,'FML0',6,'VML0','LPML','LRML')set qwe[1]=650set qwe[2]=650set qwe[3]=650set qwe[4]=650set qwe[5]=650set qwe[6]=650set qWe[1]=900set qWe[2]=900set qWe[3]=900set qWe[4]=900set qWe[5]=900set qWe[6]=900set qye[1]=3
set qye[2]=3
set qye[3]=4
set qye[4]=4
set qye[5]=5
set qye[6]=5
set qYe[1]=50set qYe[2]=80set qYe[3]='n'set qYe[4]=$8Cset qYe[5]=$B4set qYe[6]=$E6return trueendfunctionfunction PEr takes nothing returns booleancall VNx(ha,(function Pnr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaLaser.page\\ManaLaser.struct\\obj_bolt_wc3bolt.j"))call VNx(Pa,(function PVr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ManaLaser.page\\ManaLaser.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction PXr takes nothing returns booleanset qze=VXx(qZe)
return trueendfunctionfunction POr takes nothing returns booleanlocal integer Iix=jhx()if(I8x((Ose),Ob,(Iix)))thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction PRr takes integer oSx returns integerset q6e[oSx]=trueset q7e[oSx]=falsecall rEx(qze)return oSxendfunctionfunction PIr takes nothing returns integerlocal integer oSxif(q2e==8190)thencall o_x("ManaLaser_Allocation_allocCustom","call DebugEx(ManaLaser.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",qZe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(q3e[(w)]==w)thenset q4e=q4e+1set oSx=q4eelse
set oSx=q3e[(w)]
set q3e[(w)]=q3e[q3e[(w)]]endifset q3e[oSx]=Zset q5e[oSx]=1call PRr(oSx)return oSxendfunctionfunction PAr takes integer oSx returns integerset kT[oSx]=true
set QAe[oSx]=falsecall rEx(qt)
return oSxendfunctionfunction PNr takes nothing returns integerlocal integer oSxif(QRe==8190)thencall o_x("FolderLightning_StructFromDummyUnitToUnit_Allocation_allocCustom","call DebugEx(FolderLightning_StructFromDummyUnitToUnit.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Qt+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(JT[(w)]==w)thenset QIe=QIe+1set oSx=QIeelse
set oSx=JT[(w)]set JT[(w)]=JT[JT[(w)]]endifset JT[oSx]=Zset jT[oSx]=1call PAr(oSx)return oSxendfunctionfunction Pbr takes integer oSx returns booleanset QT=QT+1set qT[QT]=oSxset PT[oSx]=QT+1
return(QT==0)endfunctionfunction PBr takes nothing returns nothinglocal integer oMx=QT
local integer oSxlocal integer o0xlocal integer Iixlocal real jMxlocal real jpxlocal real cJolocal real dVxlocal real dExlocal real MQxloop
set oSx=qT[oMx]set o0x=ST[oSx]set Iix=tT[oSx]if(o0x==w)thenset jMx=Ou[oSx]set jpx=Ru[oSx]set cJo=Iu[oSx]else
set jMx=(iJ[(o0x)])set jpx=(EJ[(o0x)])set cJo=(Au[(o0x)])+Nu[oSx]endifif(Iix==w)thenset dVx=bu[oSx]set dEx=Bu[oSx]set MQx=cu[oSx]else
set dVx=Dsx(Iix)
set dEx=Dtx(Iix)
set MQx=OMx(Iix,dVx,dEx)+K2x(Iix,true)endifcall cGo(TT[oSx],jMx,jpx,cJo,dVx,dEx,MQx)set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction Pcr takes integer oSx,integer o0x,real PCr,integer Iix returns nothinglocal integer rLx=oSxlocal real dVx=Dsx(Iix)local real dEx=Dtx(Iix)call cDo(rLx)set oSx=PNr()set TT[oSx]=rLxset ST[oSx]=o0xset Nu[oSx]=PCrset tT[oSx]=Iixcall cgo(rLx,HT,oSx)
call KSx(rLx,GT)
if Qso(o0x,lT,oSx)thencall Mix(o0x,LT)
endifif rUx(Iix,lT,oSx)thencall Avx(Iix,mT)
call A_o(Iix)endifcall cGo(rLx,(iJ[(o0x)]),(EJ[(o0x)]),(Au[(o0x)])+PCr,dVx,dEx,OMx(Iix,dVx,dEx)+K2x(Iix,true))
if Pbr(oSx)thencall iDx(sT,QNe,true,function PBr)endifendfunctionfunction Pdr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local real O4o=q9e[oSx]local real KTr=Qve[oSx]local integer Cqx=Qee[oSx]local integer HAx=Qre[oSx]local integer svo=Qae[oSx]local real x=(iJ[(HAx)])+QVe[oSx]local real y=(EJ[(HAx)])+QXe[oSx]local integer Iixlocal integer PDrlocal integer Pfrlocal integer cMolocal real PFrlocal real YFocall MLo(HAx,x,y,X_x(x,y)+q8e)set hf=(ze[(Cqx)])set Ose=svocall NVo(q_e,x,y,O4o,q0e)set Iix=NEo(q_e)
if(Iix!=w)thenset PDr=Qxe[oSx]
set Pfr=Qoe[oSx]
loop
set cMo=cdo(que)
call dQx(svo,Iix)call Pcr(cMo,HAx,60.,Iix)call cLo(cMo,.35)call Ryx((ACx((Iix),(Qbe),(QBe),(ri))))if not nbo(Iix)thenset PFr=(lF[(Iix)])set YFo=iUx(PFr,KTr)
call Ydo(Cqx,Iix,YFo)if(PDr<Pfr)thenset PDr=PDr+1call Nbx((Iix),(ixe),(1),w,((iIe)*1.))call wCo(Iix,false,true,true)set Qxe[oSx]=PDr
endifendifset Iix=NEo(q_e)
exitwhen(Iix==w)
endloopendifendfunctionfunction Pgr takes integer oSx returns nothingset q6e[oSx]=falsecall rHx(qze)endfunctionfunction PGr takes integer oSx returns nothingif(q5e[oSx]>0)thenreturnendifif(q3e[oSx]!=Z)thencall o_x("ManaLaser_Allocation_deallocCustom_confirm","call DebugEx(ManaLaser.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",qZe+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset q3e[oSx]=q3e[(w)]set q3e[(w)]=oSx
call Pgr(oSx)endfunctionfunction Phr takes integer oSx returns nothingset q5e[oSx]=q5e[oSx]-1call PGr(oSx)endfunctionfunction PHr takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local integer Cqx=Qee[oSx]local integer HAx=Qre[oSx]local integer svo=Qae[oSx]local integer Q9o=Qne[oSx]local real x=(iJ[(HAx)])
local real y=(EJ[(HAx)])
local real z=(Au[(HAx)])
call Phr((oSx))call MGx(HAx)call iKx(iCx)call X_r(svo)call iKx(Q9o)call Ulx(((Cqx)),O1v)call Jpr(Cqx,x,y,X_x(x,y))endfunctionfunction Pjr takes integer Iix,real x,real y returns nothing
set QCe=xset Qde=ycall Nbx((Iix),(qse),(1),w,((QDe)*1.))endfunctionfunction PJr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local real bex=Ufx(Cqx,dVx-wQo,dEx-wso)local real Hfr=(Cos(((((bex)*1.))*1.)))local real HFr=(Sin(((((bex)*1.))*1.)))local real Xcr=wQo+q1e*Hfrlocal real XCr=wso+q1e*HFrlocal integer oSx=PIr()local integer HAx=mDx('qMaL',Xcr,XCr,X_x(Xcr,XCr)+q8e,bex)local integer iCx=iXx()local integer Q9o=iXx()set q9e[oSx]=(CQx((qUe),Uvv+(rYx)))set Qve[oSx]=qYe[rYx]set Qee[oSx]=Cqx
set Qxe[oSx]=0set Qoe[oSx]=qye[rYx]set Qre[oSx]=HAx
set Qie[oSx]=iCx
set Qae[oSx]=Jbx("ManaLaser_Event_SpellEffect: set this.targetGroup = UnitList.Create()")set Qne[oSx]=Q9o
set QVe[oSx]=QEe[rYx]*Hfrset QXe[oSx]=QEe[rYx]*HFrset ge[(iCx)]=(oSx)set ge[(Q9o)]=(oSx)call Dux((((Cqx))),(O1v),(1),w)call iDx(Q9o,QOe,true,function Pdr)call iDx(iCx,Qce[rYx],false,function PHr)call Pjr(Cqx,wQo,wso)return trueendfunctionfunction Pkr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local real x=QCe
local real y=Qde
local integer oSx=Iixset Qfe[oSx]=(mko(((x)*1.),((y)*1.),(QFe),(ri)))
set Qge[oSx]=xset QGe[oSx]=ycall OCo(qte,Iix)return trueendfunctionfunction PKr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer KZr=Qfe[oSx]call mho(KZr)call OCo(qUe,Iix)return trueendfunctionfunction Plr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oSx=Cqxlocal real x=Qge[oSx]local real y=QGe[oSx]call AZx(Cqx,qse)call mho((mko((((GetUnitX(C[((Cqx))])))*1.),(((GetUnitY(C[((Cqx))])))*1.),(Qhe),(ri))))call Jpr(Cqx,x,y,X_x(x,y))call mho((mko(((x)*1.),((y)*1.),(QHe),(ri))))return trueendfunctionfunction PLr takes nothing returns nothingcall Lxx(qse,Xdx("FolderManaLaser_StructRevert_Init: call FolderManaLaser_StructRevert.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderManaLaser_StructRevert.Event_BuffGain))",bd,MI,function Pkr))
call Lxx(qse,Xdx("FolderManaLaser_StructRevert_Init: call FolderManaLaser_StructRevert.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderManaLaser_StructRevert.Event_BuffLose))",jc,MI,function PKr))
call mro(qte,Xdx("FolderManaLaser_StructRevert_Init: call FolderManaLaser_StructRevert.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderManaLaser_StructRevert.Event_SpellEffect))",ih,MI,function Plr))endfunctionfunction Pmr takes nothing returns booleanlocal integer oMxset q_e=O5x()set q0e=Xpx(function POr)call mro(qUe,Xdx("ManaLaser_Init: call ManaLaser.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ManaLaser.Event_SpellEffect))",ih,MI,function PJr))
set oMx=(m6[(qUe)])loop
set Qce[oMx]=qwe[oMx]*1./ qWe[oMx]set QEe[oMx]=qWe[oMx]*QOeset oMx=oMx-1exitwhen(oMx<1)endloopcall PLr()return trueendfunctionfunction PMr takes nothing returns booleancall FAr(function Pmr,"ManaLaser_Init")return trueendfunctionfunction Ppr takes nothing returns booleancall L1x('AMaX',false)set Qje=L0o('AMaX')set K6[(Qje)]=(G6)set m6[(Qje)]=(3)set TH[(Qje)]=("Charm")set Rh[(Qje)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0206)))),(((Aj))))))set oxv[(Qje)]=(4)set x3v[(Qje)]=("spell")
call L1o((Qje),GH+(1),(($A)*1.))
call L1o((Qje),tH+(1),(($A)*1.))
call L1o((Qje),Lov+(1),((350)*1.))call L1o((Qje),GH+(2),(($A)*1.))
call L1o((Qje),tH+(2),(($A)*1.))
call L1o((Qje),Lov+(2),((350)*1.))call L1o((Qje),GH+(3),(($A)*1.))
call L1o((Qje),tH+(3),(($A)*1.))
call L1o((Qje),Lov+(3),((350)*1.))set MOv[(Qje)]=("ReplaceableTextures\\CommandButtons\\BTNCharm.blp")
call cDr(Qje,'FMX0',3,'VMX0','LPMX','LRMX')return trueendfunctionfunction PPr takes nothing returns booleancall VNx(Pa,(function Ppr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\MassMimesis.page\\MassMimesis.struct\\Charm\\obj_thisSpell_wc3spell.j"))
return trueendfunctionfunction Pqr takes nothing returns booleanset QJe=VXx(Qke)
return trueendfunctionfunction PQr takes nothing returns booleanreturn trueendfunctionfunction Psr takes nothing returns booleanset QKe=VXx(Qle)
return trueendfunctionfunction PSr takes nothing returns booleancall L1x('AMaM',false)set GKv=L0o('AMaM')set K6[(GKv)]=(G6)set m6[(GKv)]=(3)set TH[(GKv)]=("Mass Mimesis")set Rh[(GKv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0206)))),(((Aj))))))set oxv[(GKv)]=(2)set x3v[(GKv)]=("spell")
call L1o((GKv),GH+(1),(('x')*1.))call L1o((GKv),tH+(1),((400)*1.))call L1o((GKv),Lov+(1),((99999)*1.))
call L1o((GKv),GH+(2),(('x')*1.))call L1o((GKv),tH+(2),((500)*1.))call L1o((GKv),Lov+(2),((99999)*1.))
call L1o((GKv),GH+(3),(('x')*1.))call L1o((GKv),tH+(3),((600)*1.))call L1o((GKv),Lov+(3),((99999)*1.))
set MOv[(GKv)]=("ReplaceableTextures\\CommandButtons\\BTNAbsorbMagic.blp")call cDr(GKv,'FMM0',3,'VMM0','LPMM','LRMM')set QLe[1]=20set QLe[2]=20set QLe[3]=20set Qme[1]=60set Qme[2]=60set Qme[3]=60return trueendfunctionfunction Ptr takes nothing returns booleanset QMe=ltx(Qpe+" (dummyBuff)")return trueendfunctionfunction PTr takes nothing returns booleancall VNx(Pa,(function PSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\MassMimesis.page\\MassMimesis.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function Ptr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\MassMimesis.page\\MassMimesis.struct\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction Pur takes nothing returns booleanset QPe=VXx(Qpe)
return trueendfunctionfunction PUr takes integer Cqx,integer Iix returns booleanreturn( not(I9x(Iix,Wd)and not(IsUnitAlly(C[(Iix)],vx[((ze[(Cqx)]))]))))and( not(I9x(Iix,IDv)))and( not(I9x(Iix,Igv)))and( not(I9x(Iix,Ijv)))endfunctionfunction Pwr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer Iix=(zH[(rFx)])local integer rlx=(nv[(rFx)])local integer oSxlocal integer svolocal integer rYxlocal real PWrlocal real Pyrlocal real dVxlocal real dExlocal real dXlocal real dYlocal integer PYrif(Iix==w)thenreturn trueendifif not PUr(Cqx,Iix)thenreturn trueendifset oSx=Cqxset svo=QQe[oSx]
if(I8x((svo),Ob,(Iix)))thenreturn trueendifcall dQx(svo,Iix)set rYx=Qse[oSx]
set PWr=QSe[oSx]
set Pyr=Qte[oSx]
set dVx=(GetUnitX(C[((Iix))]))set dEx=(GetUnitY(C[((Iix))]))set dX=dVx-PWrset dY=dEx-Pyrset PYr=Rur((Tf[(Iix)]),(ze[(Cqx)]),QSe[oSx],Qte[oSx],(Atan2(((dY)*1.),((dX)*1.))),QLe[rYx],QTe)
call Ryx((ACx((PYr),(Que),(QUe),(ri))))call Dux((((PYr))),(nYv),(1),w)call Dux((((PYr))),(XAv),(1),w)call r0x(((PYr)),((gtv)),(1))call CBx(PYr,bw,dVx,dEx)
return trueendfunctionfunction Pzr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local real dVx=Qwelocal real dEx=QWelocal real O4o=(CQx((GKv),Uvv+(rYx)))local real MQx=X_x(dVx,dEx)local integer oSx=Iixlocal integer HAx=mDx('qMaM',dVx,dEx,MQx,.0)
local integer PZr=mDx('qMM2',dVx,dEx,MQx,.0)
set Qye[oSx]=(CQx((GKv),Uvv+(rYx)))set QYe[oSx]=HAx
set Qze[oSx]=PZr
set Qse[oSx]=rYx
set QQe[oSx]=Jbx("MassMimesis_Event_BuffGain: set this.targetGroup = UnitList.Create()")
set QSe[oSx]=dVx
set Qte[oSx]=dEx
call Avx(Iix,Qqe)call OCo(Qje,Iix)return trueendfunctionfunction P_r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer HAx=QYe[oSx]local integer PZr=Qze[oSx]local integer svo=QQe[oSx]call Mfx(HAx)call MGx(PZr)call X_r(svo)call RPx(Iix,Qqe)call OCo(GKv,Iix)return trueendfunctionfunction P0r takes integer oSx returns integerset Q2e[oSx]=trueset Q3e[oSx]=falsecall rEx(QKe)return oSxendfunctionfunction P1r takes nothing returns integerlocal integer oSxif(QZe==8190)thencall o_x("FolderMassMimesis_StructMissile_Allocation_allocCustom","call DebugEx(FolderMassMimesis_StructMissile.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Qle+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Q_e[(w)]==w)thenset Q0e=Q0e+1set oSx=Q0eelse
set oSx=Q_e[(w)]
set Q_e[(w)]=Q_e[Q_e[(w)]]endifset Q_e[oSx]=Zset Q1e[oSx]=1call P0r(oSx)return oSxendfunctionfunction P2r takes integer oSx returns nothingset Q2e[oSx]=falsecall rHx(QKe)endfunctionfunction P3r takes integer oSx returns nothingif(Q1e[oSx]>0)thenreturnendifif(Q_e[oSx]!=Z)thencall o_x("FolderMassMimesis_StructMissile_Allocation_deallocCustom_confirm","call DebugEx(FolderMassMimesis_StructMissile.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Qle+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Q_e[oSx]=Q_e[(w)]set Q_e[(w)]=oSx
call P2r(oSx)endfunctionfunction P4r takes integer oSx returns nothingset Q1e[oSx]=Q1e[oSx]-1call P3r(oSx)endfunctionfunction P5r takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=Q4e[oSx]local integer rYx=Q5e[oSx]local real dVx=Q6e[oSx]local real dEx=Q7e[oSx]call P4r((oSx))call MFo(Mho)set Qwe=dVxset QWe=dExcall Nbx((Cqx),(QMe),(rYx),w,((Qme[rYx])*1.))return trueendfunctionfunction P6r takes integer Cqx,integer rYx,real dVx,real dEx returns nothing
local integer oSx=P1r()local integer Mho=Moo()set Q4e[oSx]=Cqx
set Q5e[oSx]=rYx
set Q6e[oSx]=dVx
set Q7e[oSx]=dEx
call m4o(Mho,2000.)set mcv[((Mho))]=((Bev*((.2)*1.))*1.)set mCv[(Mho)]=((48.)*1.)call Mno(Mho,'qMMM',1.)set mFv[(Mho)]=Xkx((function P5r))set mZv[(Mho)]=(oSx)
call Meo(Mho,500.)call pxo(Mho,Cqx)call o9r(Mho,dVx,dEx,X_x(dVx,dEx))endfunctionfunction P7r takes nothing returns booleanlocal integer rFx=(bv)call P6r((Vv[(rFx)]),(Mv[(rFx)]),(yH[(rFx)]),(YH[(rFx)]))return trueendfunctionfunction P8r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(hc[(rFx)])local integer Iix=(zH[(rFx)])local integer rLx=Cqxif((Cqx!=Iix)and I9x(Iix,Wd))thenreturn trueendifcall Nvo((Noo((((GetUnitX(C[((Iix))])))*1.),(((GetUnitY(C[((Iix))])))*1.),(Q8e),(ri),(((eb[(Iix)]))*1.))))call SetUnitPosition(C[((Iix))],((QSe[rLx])*1.),((Qte[rLx])*1.))
call Nvo((Noo((((GetUnitX(C[((Iix))])))*1.),(((GetUnitY(C[((Iix))])))*1.),(Q9e),(ri),(((eb[(Iix)]))*1.))))return trueendfunctionfunction P9r takes nothing returns booleanlocal integer oMxset Qqe=Xdx("MassMimesis_Init: set MassMimesis.ANY_CAST_EVENT = Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MassMimesis.Event_AnyCast)",ih,MI,function Pwr)call Lxx(QMe,Xdx("MassMimesis_Init: call MassMimesis.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MassMimesis.Event_BuffGain))",bd,MI,function Pzr))call Lxx(QMe,Xdx("MassMimesis_Init: call MassMimesis.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MassMimesis.Event_BuffLose))",jc,MI,function P_r))call mro(GKv,Xdx("MassMimesis_Init: call MassMimesis.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MassMimesis.Event_SpellEffect))",ih,MI,function P7r))set oMx=(m6[(GKv)])loop
set oMx=oMx-1exitwhen(oMx<1)endloopcall mro(Qje,Xdx("FolderMassMimesis_StructCharm_Init: call FolderMassMimesis_StructCharm.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderMassMimesis_StructCharm.Event_SpellEffect))",ih,MI,function P8r))
return trueendfunctionfunction qvr takes nothing returns booleancall FAr(function P9r,"MassMimesis_Init")return trueendfunctionfunction qer takes nothing returns booleancall L1x('AAva',false)set hcv=L0o('AAva')set K6[(hcv)]=(g6)set m6[(hcv)]=(3)set TH[(hcv)]=("Mountain King")set Rh[(hcv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0076)))),(((Aj))))))set oxv[(hcv)]=(0)set x3v[(hcv)]=("spell")
call L1o((hcv),GH+(1),((70)*1.))
call L1o((hcv),tH+(1),(('}')*1.))call L1o((hcv),Lov+(1),((750)*1.))call L1o((hcv),GH+(2),((70)*1.))
call L1o((hcv),tH+(2),(('}')*1.))call L1o((hcv),Lov+(2),((750)*1.))call L1o((hcv),GH+(3),((70)*1.))
call L1o((hcv),tH+(3),(('}')*1.))call L1o((hcv),Lov+(3),((750)*1.))set MOv[(hcv)]=("ReplaceableTextures\\CommandButtons\\BTNAvatar.blp")call cDr(hcv,'FAv0',3,'VAv0','LPAv','LRAv')set sve[1]=.4set sve[2]=.6set sve[3]=.8set see[1]=5
set see[2]=$Aset see[3]=$Fset sxe[1]=30set sxe[2]=45set sxe[3]=60set soe[1]=.2set soe[2]=.3set soe[3]=.4set sre[1]=.2set sre[2]=.3set sre[3]=.4set sie[1]=.2set sie[2]=.3set sie[3]=.4return trueendfunctionfunction qxr takes nothing returns booleancall L1x('aAvC',false)return trueendfunctionfunction qor takes nothing returns booleanset sae=Wwx('BAva',"Avatar",'bAva')set aav[(sae)]=(true)set anv[(sae)]=("ReplaceableTextures\\CommandButtons\\BTNAvatar.blp")call lWx(sae,"Abilities\\Spells\\Orc\\SpiritLink\\SpiritLinkTarget.mdl","chest",Bi)set WU=l_x()
call l2x(WU,dev,.2)call l2x(WU,C9v,.2)call l2x(WU,dvv,.2)call l2x(WU,cNv,5)call l0x(((WU)),fc,(Kkr(db,.4,1)))call vAr(WU,DJv,true)call l3x(((sae)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,dev,.3)call l2x(WU,C9v,.3)call l2x(WU,dvv,.3)call l2x(WU,cNv,$A)call l0x(((WU)),fc,(Kkr(db,.6,1)))call vAr(WU,DJv,true)call l3x(((sae)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,dev,.4)call l2x(WU,C9v,.4)call l2x(WU,dvv,.4)call l2x(WU,cNv,$F)call l0x(((WU)),fc,(Kkr(db,.8,1)))call vAr(WU,DJv,true)call l3x(((sae)),ZB+(3),(WU))return trueendfunctionfunction qrr takes nothing returns booleanset sne=hjo('UAva')call hpo((sne),('AInv'),1)call hJo(((sne)),ASv,(Wd))call hJo(((sne)),ASv,(Idv))set Uj[(sne)]=((1.4)*1.)
set NOv[(sne)]=((60)*1.)
set NWv[(sne)]=((60)*1.)
set NPv[(sne)]=((280)*1.)set I8v[(sne)]=((3)*1.)set Anv[(sne)]=(4)set Nmv[(sne)]=(('d')*1.)set NLv[(sne)]=(('d')*1.)set NKv[(sne)]=((0)*1.)set Npv[(sne)]=(('d')*1.)set NMv[(sne)]=(('d')*1.)set Nlv[(sne)]=((0)*1.)set Ncv[(sne)]=(($708)*1.)set Nbv[(sne)]=(($708)*1.)set Adv[(sne)]=(gkv)
set AGv[(sne)]=(('x')*1.)set Ahv[((sne))]=((1.*1./((1.55)*1.))*1.)set AWv[(sne)]=((.35)*1.)set Auv[(sne)]=(($C)*1.)
set AUv[(sne)]=(($C)*1.)
set AYv[(sne)]=(2)set A_v[(sne)]=($C)set A2v[(sne)]=(0)set ATv[(sne)]=((32)*1.)
call hqo(sne,hbv)call hqo(sne,hBv)call hqo(sne,hcv)call hqo(sne,hCv)set bDv[(sne)]=((7.5)*1.)set bjv[(sne)]=((3.5)*1.)set bJv[(sne)]=((.85)*1.)set bfv[(sne)]=((6)*1.)set bkv[(sne)]=((3.25)*1.)set bFv[(sne)]=((16)*1.)
set bKv[(sne)]=((5)*1.)return trueendfunctionfunction qir takes nothing returns booleancall L1x('aAvX',false)return trueendfunctionfunction qar takes nothing returns booleancall VNx(Pa,(function qer),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\MountainKing.page\\MountainKing.struct\\obj_thisSpell_wc3spell.j"))call VNx(Pa,(function qxr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\MountainKing.page\\MountainKing.struct\\obj_changerAbility_wc3spell.j"))
call VNx(ma,(function qor),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\MountainKing.page\\MountainKing.struct\\obj_dummyBuff_wc3buff.j"))call VNx(sa,(function qrr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\MountainKing.page\\MountainKing.struct\\obj_thisUnitType_wc3unit.j"))call VNx(Pa,(function qir),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\MountainKing.page\\MountainKing.struct\\obj_revertAbility_wc3spell.j"))return trueendfunctionfunction qnr takes nothing returns booleanset sVe=VXx(sEe)
return trueendfunctionfunction qVr takes integer oSx,string URx returns nothingcall AddUnitAnimationProperties(C[(oSx)],URx,true)call Hgx((oSx))endfunctionfunction qEr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local real qXr=(zF[(Iix)])local integer oSx=Iixlocal integer qOr=l_x()set sXe[oSx]=qOr
call l2x(qOr,cNv,qXr*sOe)call qVr(Iix,"alternate")call I3x(Iix,qOr)call LAr(g6,sRe,Iix)
return trueendfunctionfunction qRr takes integer oSx,string URx returns nothingcall AddUnitAnimationProperties(C[(oSx)],URx,false)call Hgx((oSx))endfunctionfunction qIr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer qOr=sXe[oSx]call qRr(Iix,"alternate")call ISx(Iix,qOr)call nnr(qOr)call LAr(g6,hcv,Iix)
return trueendfunctionfunction qAr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(Mv[(rFx)])call Nbx(((Vv[(rFx)])),(sae),(rYx),w,((sxe[rYx])*1.))return trueendfunctionfunction qNr takes nothing returns booleancall Lxx(sae,Xdx("MountainKing_Init: call MountainKing.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MountainKing.Event_BuffGain))",bd,MI,function qEr))
call Lxx(sae,Xdx("MountainKing_Init: call MountainKing.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MountainKing.Event_BuffLose))",jc,MI,function qIr))
call mro(hcv,Xdx("MountainKing_Init: call MountainKing.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MountainKing.Event_SpellEffect))",ih,MI,function qAr))return trueendfunctionfunction qbr takes nothing returns booleancall FAr(function qNr,"MountainKing_Init")return trueendfunctionfunction qBr takes nothing returns booleancall L1x('AThu',false)set sRe=L0o('AThu')set K6[(sRe)]=(f6)set m6[(sRe)]=(6)set TH[(sRe)]=("Thunderbringer")
set Rh[(sRe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0259)))),(((Aj))))))set oxv[(sRe)]=(4)set x3v[(sRe)]=("spell")
call L1o((sRe),Uvv+(1),(('d')*1.))call L1o((sRe),GH+(1),((7)*1.))call L1o((sRe),Lov+(1),(($AF)*1.))call L1o((sRe),Uvv+(2),(($96)*1.))call L1o((sRe),GH+(2),((7)*1.))call L1o((sRe),Lov+(2),(($AF)*1.))call L1o((sRe),Uvv+(3),(($C8)*1.))call L1o((sRe),GH+(3),((7)*1.))call L1o((sRe),Lov+(3),(($AF)*1.))call L1o((sRe),Uvv+(4),(($E1)*1.))call L1o((sRe),GH+(4),((7)*1.))call L1o((sRe),Lov+(4),(($AF)*1.))call L1o((sRe),Uvv+(5),(($FA)*1.))call L1o((sRe),GH+(5),((7)*1.))call L1o((sRe),Lov+(5),(($AF)*1.))call L1o((sRe),Uvv+(6),((275)*1.))call L1o((sRe),GH+(6),((7)*1.))call L1o((sRe),Lov+(6),(($AF)*1.))set MOv[(sRe)]=("ReplaceableTextures\\CommandButtons\\BTNStormHammer.blp")set sIe[1]=30set sIe[2]=60set sIe[3]=90set sIe[4]='x'set sIe[5]=$96set sIe[6]=$B4set sAe[1]=2
set sAe[2]=2.25set sAe[3]=2.5set sAe[4]=2.75set sAe[5]=3
set sAe[6]=3.25return trueendfunctionfunction qcr takes nothing returns booleancall VNx(Pa,(function qBr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\MountainKing.page\\MountainKing.struct\\Thunderbringer.page\\Thunderbringer.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction qCr takes nothing returns booleanset sNe=VXx(sbe)
return trueendfunctionfunction qdr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn trueendfunctionfunction qDr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local real x=(GetUnitX(C[((Iix))]))local real y=(GetUnitY(C[((Iix))]))local real Nbolocal real gYrcall Ryx((ACx((Cqx),(sCe),(sde),(ri))))call mho((mko(((x)*1.),((y)*1.),(sDe),(Bi))))call mho((mko(((x)*1.),((y)*1.),(sfe),(Bi))))set hf=(ze[(Cqx)])call NVo(sBe,x,y,(CQx((sRe),Uvv+(rYx))),sce)
set Iix=NEo(sBe)
if(Iix!=w)thenset Nbo=(Lg[(Cqx)])+sIe[rYx]
set gYr=sAe[rYx]
loop
call Nbx((Iix),(Xwv),(rYx),w,((gYr)*1.))
call nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))set Iix=NEo(sBe)
exitwhen(Iix==w)
endloopendifreturn trueendfunctionfunction qfr takes nothing returns booleanset sBe=O5x()set sce=Xpx(function qdr)call mro(sRe,Xdx("Thunderbringer_Init: call Thunderbringer.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Thunderbringer.Event_SpellEffect))",ih,MI,function qDr))return trueendfunctionfunction qFr takes nothing returns booleancall Axr(function qfr,"Thunderbringer_Init")
return trueendfunctionfunction qgr takes nothing returns booleanset sFe=VCx("ONeW")return trueendfunctionfunction qGr takes nothing returns booleanset sge=ltx(sGe+" (silenceBuff)")set Pc[(sge)]=(true)
set uU[(sge)]=(true)
return trueendfunctionfunction qhr takes nothing returns booleancall L1x('ANeW',false)set Gkv=L0o('ANeW')set K6[(Gkv)]=(g6)set m6[(Gkv)]=(3)set TH[(Gkv)]=("Negation Wave")set Rh[(Gkv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0215)))),(((Aj))))))set oxv[(Gkv)]=(4)set x3v[(Gkv)]=("spell")
call L1o((Gkv),Uvv+(1),((500)*1.))call L1o((Gkv),GH+(1),((9)*1.))call L1o((Gkv),tH+(1),(('i')*1.))call L1o((Gkv),Lov+(1),((550)*1.))call L1o((Gkv),Uvv+(2),((500)*1.))call L1o((Gkv),GH+(2),((9)*1.))call L1o((Gkv),tH+(2),(('x')*1.))call L1o((Gkv),Lov+(2),((550)*1.))call L1o((Gkv),Uvv+(3),((500)*1.))call L1o((Gkv),GH+(3),((9)*1.))call L1o((Gkv),tH+(3),(($87)*1.))call L1o((Gkv),Lov+(3),((550)*1.))set MOv[(Gkv)]=("ReplaceableTextures\\CommandButtons\\BTNFeedback.blp")call cDr(Gkv,'FNW0',3,'VNW0','LPNW','LRNW')set she[1]=7
set she[2]=$Bset she[3]=$Fset sHe[1]=30set sHe[2]=40set sHe[3]=50set sje[1]=1
set sje[2]=1.1set sje[3]=1.2set sJe[1]=2
set sJe[2]=2.2set sJe[3]=2.4return trueendfunctionfunction qHr takes nothing returns booleancall VNx(ha,(function qgr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\NegationWave.page\\NegationWave.struct\\obj_bolt_wc3bolt.j"))call VNx(ma,(function qGr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\NegationWave.page\\NegationWave.struct\\obj_silenceBuff_wc3buff.j"))
call VNx(Pa,(function qhr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\NegationWave.page\\NegationWave.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction qjr takes nothing returns booleanset ske=VXx(sGe)
return trueendfunctionfunction qJr takes nothing returns booleanlocal integer Iix=jhx()if(I8x((Ose),Ob,(Iix)))thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,IFv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction qkr takes integer oSx returns integerset sQe[oSx]=trueset sse[oSx]=falsecall rEx(ske)return oSxendfunctionfunction qKr takes nothing returns integerlocal integer oSxif(sMe==8190)thencall o_x("NegationWave_Allocation_allocCustom","call DebugEx(NegationWave.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",sGe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(spe[(w)]==w)thenset sPe=sPe+1set oSx=sPeelse
set oSx=spe[(w)]
set spe[(w)]=spe[spe[(w)]]endifset spe[oSx]=Zset sqe[oSx]=1call qkr(oSx)return oSxendfunctionfunction qlr takes integer oSx returns nothingset sQe[oSx]=falsecall rHx(ske)endfunctionfunction qLr takes integer oSx returns nothingif(sqe[oSx]>0)thenreturnendifif(spe[oSx]!=Z)thencall o_x("NegationWave_Allocation_deallocCustom_confirm","call DebugEx(NegationWave.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",sGe+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset spe[oSx]=spe[(w)]set spe[(w)]=oSx
call qlr(oSx)endfunctionfunction qmr takes integer oSx returns nothingset sqe[oSx]=sqe[oSx]-1call qLr(oSx)endfunctionfunction qMr takes integer oSx returns nothingcall qmr((oSx))call iKx(sue[oSx])call X_r(sWe[oSx])endfunctionfunction qpr takes integer oSx,integer pjr,integer EFr,integer Efr returns nothinglocal integer cMo=cdo(sFe)local real qPrset sUe[oSx]=EFr
call ERr(cMo,pjr,EFr)call pmo((ACx((EFr),(sZe),(s_e),(ri))),2.)call dQx(sWe[oSx],EFr)call cLo(cMo,.75)if I9x(EFr,Wd)thenset qPr=sje[swe[oSx]]else
set qPr=sJe[swe[oSx]]endifcall Nbx((EFr),(sge),(swe[oSx]),w,((qPr)*1.))call nlo((ste[oSx]),(EFr),((sTe[oSx])*1.),(true),(false))endfunctionfunction qqr takes nothing returns nothinglocal integer Okx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(Okx)])local integer svo=sWe[oSx]local integer Efr=sye[oSx]+1
local integer Cqxlocal integer pjrlocal real pkrlocal real pKrlocal integer EFrif(Efr>sYe[oSx])then
call qMr(oSx)else
set Cqx=ste[oSx]
set pjr=sUe[oSx]
set pkr=(GetUnitX(C[((pjr))]))set pKr=(GetUnitY(C[((pjr))]))set Ose=svoset hf=(ze[(Cqx)])call NVo(sKe,pkr,pKr,sSe[oSx],sle)set EFr=(mKo((sKe),((pkr)*1.),((pKr)*1.)))if(EFr==w)thencall qMr(oSx)else
set sye[oSx]=Efr
call qpr(oSx,pjr,EFr,Efr-1)endifendifendfunctionfunction qQr takes integer oSx,integer Iax,integer rYx returns reallocal real o7xif not(osx((((oSx))),(Wb+(Iax)))>0)thenreturn .0endifset o7x=bCr(oSx,Iax,rYx)
if(o7x==.0)thenreturn s0eendifreturn o7xendfunctionfunction qsr takes integer oSx,integer Iax,integer rYx,integer I6x,real iMx returns integerif(iMx==s0e)then
return Asx(oSx,Iax,rYx,I6x)endifreturn(Nbx((oSx),(Iax),(rYx),(I6x),((iMx)*1.)))endfunctionfunction qSr takes integer oSx,integer Iix,boolean wdo,boolean wDo,integer rYx returns nothinglocal integer qtr=Iixlocal integer rvx=Flocal real array iMx
local integer oMx=(CIx(((qtr)),vB))local integer array uMolocal integer Z7oloop
exitwhen(oMx<q)set Z7o=(CAx(((qtr)),vB,(oMx)))if(not(Ud[(Z7o)])and(((aav[(Z7o)])and wDo)or(not(aav[(Z7o)])and wdo))and((osx(((Iix)),Yb+(Z7o)))<=rYx))thenset rvx=rvx+1set iMx[rvx]=qQr(Iix,Z7o,(osx(((Iix)),Yb+(Z7o))))set uMo[rvx]=Z7o
call AZx(Iix,Z7o)endifset oMx=oMx-1endlooploop
exitwhen(rvx<0)call qsr(oSx,uMo[rvx],rYx,w,iMx[rvx])set rvx=rvx-1endloopendfunctionfunction qTr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local integer oSxlocal integer Okxcall Ryx((ACx((Cqx),(sLe),(sme),(ri))))set oSx=qKr()set Okx=iXx()set sSe[oSx]=(CQx((Gkv),Uvv+(rYx)))set ste[oSx]=Cqx
set sTe[oSx]=sHe[rYx]set sue[oSx]=Okx
set sUe[oSx]=Iix
set swe[oSx]=rYx
set sWe[oSx]=Jbx("NegationWave_Event_SpellEffect: set this.targetGroup = UnitList.Create()")
set sye[oSx]=1set sYe[oSx]=she[rYx]set ge[(Okx)]=(oSx)call iDx(Okx,sze,true,function qqr)call qpr(oSx,Cqx,Iix,0)call qSr(Cqx,Iix,false,true,rYx)
return trueendfunctionfunction qur takes nothing returns booleanset sKe=O5x()set sle=Xpx(function qJr)call mro(Gkv,Xdx("NegationWave_Init: call NegationWave.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function NegationWave.Event_SpellEffect))",ih,MI,function qTr))call W2x(Xlv,sge)return trueendfunctionfunction qUr takes nothing returns booleancall FAr(function qur,"NegationWave_Init")return trueendfunctionfunction qwr takes nothing returns booleanset s1e[1]='aNG1'call L1x('aNG1',false)return trueendfunctionfunction qWr takes nothing returns booleanset s2e=ltx(s3e+" (dummyBuff)")return trueendfunctionfunction qyr takes nothing returns booleanset s4e[1]=30set s4e[2]=30set s4e[3]=30set s4e[4]=30set s4e[5]=30set s4e[6]=30return trueendfunctionfunction qYr takes nothing returns booleanset s5e=hjo('uNGS')call hJo(((s5e)),ASv,(Idv))set Uj[(s5e)]=((1.25)*1.)call hko(s5e,0,$FF,0,$FF)set NOv[(s5e)]=(($B)*1.)
set NWv[(s5e)]=(($B)*1.)
set Anv[(s5e)]=(5)set Nmv[(s5e)]=(('d')*1.)set NLv[(s5e)]=(('d')*1.)set NKv[(s5e)]=((0)*1.)set Ncv[(s5e)]=(($96)*1.)set Nbv[(s5e)]=(($96)*1.)set NGv[(s5e)]=((0)*1.)set Auv[(s5e)]=((0)*1.)set AUv[(s5e)]=((0)*1.)set AYv[(s5e)]=(0)set A_v[(s5e)]=(0)set ATv[(s5e)]=((8)*1.)call hpo((s5e),(gtv),1)return trueendfunctionfunction qzr takes nothing returns booleanset s6e[1]=hjo('uNG1')call hJo(((s6e[1])),ASv,(Idv))set Uj[(s6e[1])]=((1)*1.)set NOv[(s6e[1])]=((60)*1.)set NWv[(s6e[1])]=((60)*1.)set NPv[(s6e[1])]=(($DC)*1.)
set I8v[(s6e[1])]=((0)*1.)set Anv[(s6e[1])]=(0)set Nmv[(s6e[1])]=((40)*1.)set NLv[(s6e[1])]=((40)*1.)set NKv[(s6e[1])]=((0)*1.)set Ncv[(s6e[1])]=((600)*1.)
set Nbv[(s6e[1])]=((600)*1.)
set NGv[(s6e[1])]=(($F)*1.)set Adv[(s6e[1])]=(gkv)set AGv[(s6e[1])]=(('x')*1.)
set Ahv[((s6e[1]))]=((1.*1./((1.75)*1.))*1.)
set AWv[(s6e[1])]=((.467)*1.)set Auv[(s6e[1])]=((7)*1.)set AUv[(s6e[1])]=((7)*1.)set AYv[(s6e[1])]=(2)set A_v[(s6e[1])]=(2)set A2v[(s6e[1])]=(0)set ATv[(s6e[1])]=((32)*1.)return trueendfunctionfunction qZr takes nothing returns booleancall VNx(Pa,(function qwr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\NurturingGrounds.page\\NurturingGrounds.struct\\Egg\\obj_changerAbility[1]_wc3spell.j"))
call VNx(ma,(function qWr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\NurturingGrounds.page\\NurturingGrounds.struct\\Egg\\obj_dummyBuff_wc3buff.j"))call VNx(va,(function qyr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\NurturingGrounds.page\\NurturingGrounds.struct\\Egg\\obj_this_wc3obj.j"))call VNx(sa,(function qYr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\NurturingGrounds.page\\NurturingGrounds.struct\\Egg\\obj_egg_wc3unit.j"))call VNx(sa,(function qzr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\NurturingGrounds.page\\NurturingGrounds.struct\\Egg\\obj_treant[1]_wc3unit.j"))return trueendfunctionfunction q_r takes nothing returns booleanset s7e=VXx(s3e)
return trueendfunctionfunction q0r takes nothing returns booleancall L1x('ANuG',false)set gZv=L0o('ANuG')set K6[(gZv)]=(D6)set m6[(gZv)]=(6)set TH[(gZv)]=("Nurturing Grounds")set Rh[(gZv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00CB)))),(((Aj))))))set oxv[(gZv)]=(2)set x3v[(gZv)]=("spell")
call L1o((gZv),Uvv+(1),((350)*1.))call L1o((gZv),GH+(1),((17)*1.))
call L1o((gZv),tH+(1),((50)*1.))
call L1o((gZv),Lov+(1),((750)*1.))call L1o((gZv),Uvv+(2),((400)*1.))call L1o((gZv),GH+(2),((17)*1.))
call L1o((gZv),tH+(2),((62)*1.))
call L1o((gZv),Lov+(2),((750)*1.))call L1o((gZv),Uvv+(3),((450)*1.))call L1o((gZv),GH+(3),((17)*1.))
call L1o((gZv),tH+(3),((74)*1.))
call L1o((gZv),Lov+(3),((750)*1.))call L1o((gZv),Uvv+(4),((500)*1.))call L1o((gZv),GH+(4),((17)*1.))
call L1o((gZv),tH+(4),((86)*1.))
call L1o((gZv),Lov+(4),((750)*1.))call L1o((gZv),Uvv+(5),((550)*1.))call L1o((gZv),GH+(5),((17)*1.))
call L1o((gZv),tH+(5),((98)*1.))
call L1o((gZv),Lov+(5),((750)*1.))call L1o((gZv),Uvv+(6),((600)*1.))call L1o((gZv),GH+(6),((17)*1.))
call L1o((gZv),tH+(6),(('n')*1.))call L1o((gZv),Lov+(6),((750)*1.))set MOv[(gZv)]=("ReplaceableTextures\\CommandButtons\\BTNEntanglingRoots.blp")call cDr(gZv,'FNG0',6,'VNG0','LPNG','LRNG')set s8e[1]=$Cset s8e[2]=$Eset s8e[3]=16set s8e[4]=18set s8e[5]=20set s8e[6]=22set s9e[1]=1
set s9e[2]=1
set s9e[3]=1
set s9e[4]=1
set s9e[5]=1
set s9e[6]=1
set Sve[1]=3
set Sve[2]=3
set Sve[3]=4
set Sve[4]=4
set Sve[5]=5
set Sve[6]=5
return trueendfunctionfunction q1r takes nothing returns booleancall VNx(Pa,(function q0r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\NurturingGrounds.page\\NurturingGrounds.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction q2r takes nothing returns booleanset See=VXx(Sxe)
return trueendfunctionfunction q3r takes integer oSx returns integerset Sne[oSx]=trueset SVe[oSx]=falsecall rEx(See)return oSxendfunctionfunction q4r takes nothing returns integerlocal integer oSxif(Soe==8190)thencall o_x("NurturingGrounds_Allocation_allocCustom","call DebugEx(NurturingGrounds.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Sxe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Sre[(w)]==w)thenset Sie=Sie+1set oSx=Sieelse
set oSx=Sre[(w)]
set Sre[(w)]=Sre[Sre[(w)]]endifset Sre[oSx]=Zset Sae[oSx]=1call q3r(oSx)return oSxendfunctionfunction q5r takes integer oSx,real x,real y,real iMx returns nothinglocal integer o5x=CHr(x,y)if plx(SCe[oSx],o5x)then
call CKr(o5x)returnendifcall spo(SCe[oSx],o5x)call CSr(Cwr(x,y,S7),iMx)endfunctionfunction q6r takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local real q7r=SXe[oSx]+SRe[oSx]
local real dVxlocal real dExlocal real q8rlocal real jRrlocal real q9rlocal real jIrlocal real Qvrlocal real y
local real x
set SXe[oSx]=q7r
set dVx=SBe[oSx]
set dEx=Sce[oSx]
set q8r=dVx-q7rset jRr=dVx+q7rset q9r=dEx-q7rset jIr=dEx+q7rset Qvr=q7r*q7rset y=q9rcall o_x("NurturingGrounds_Spread","call DebugEx(\"spread \"+R2S(curLength))","spread "+R2S(q7r))loop
exitwhen(y>jIr)set x=q8rloop
exitwhen(x>jRr)if(GZx(x-dVx,y-dEx)<=Qvr)thencall q5r(oSx,x,y,s8e[SAe[oSx]]+2*(1-SXe[oSx]*1./(CQx((gZv),Uvv+(SAe[oSx]))))*s9e[SAe[oSx]])endifset x=x+SDeendloopset y=y+SDeendloopendfunctionfunction Qer takes nothing returns nothinglocal integer Qxr=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(Qxr)])call o_x("NurturingGrounds_EndSpread","call DebugEx(\"endSpread\")","endSpread")
call ikx(Qxr)call ikx(Sde[oSx])endfunctionfunction Qor takes integer oSx returns nothingset Sne[oSx]=falsecall rHx(See)endfunctionfunction Qrr takes integer oSx returns nothingif(Sae[oSx]>0)thenreturnendifif(Sre[oSx]!=Z)thencall o_x("NurturingGrounds_Allocation_deallocCustom_confirm","call DebugEx(NurturingGrounds.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Sxe+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset Sre[oSx]=Sre[(w)]set Sre[(w)]=oSx
call Qor(oSx)endfunctionfunction Qir takes integer oSx returns nothingset Sae[oSx]=Sae[oSx]-1call Qrr(oSx)endfunctionfunction Qar takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])call o_x("NurturingGrounds_EndingByTimer","call DebugEx(\"end\")","end")
call iKx(iCx)call iKx(SOe[oSx])call iKx(Sbe[oSx])call m9x(SCe[oSx])call iKx(Sde[oSx])call Qir((oSx))endfunctionfunction Qnr takes real x,real y,integer Cqx,integer rYx returns nothing
local integer IOr=bOx(s5e,(ze[(Cqx)]),x,y,kf)call Rao(IOr,IGv)call UZo((IOr),((s4e[rYx])*1.))call Dux((IOr),(s2e),(rYx),w)call SetUnitAnimation(C[((IOr))],("birth"))endfunctionfunction QVr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local real bex=(GetRandomReal(((.0)*1.),((Cf)*1.)))local real oyx=(GetRandomReal(((.0)*1.),((SXe[oSx])*1.)))local real x=SBe[oSx]+oyx*(Cos(((((bex)*1.))*1.)))local real y=Sce[oSx]+oyx*(Sin(((((bex)*1.))*1.)))call o_x("NurturingGrounds_SpawnEggByTimer","call DebugEx(\"create egg\")","create egg")
call Qnr(x,y,SEe[oSx],SAe[oSx])endfunctionfunction QEr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local real O4o=(CQx((gZv),Uvv+(rYx)))local real iMx=s8e[rYx]local real QXr=s9e[rYx]local integer oSx=q4r()local integer iCx=iXx()local integer QOr=iXx()local integer Qxr=iXx()local integer Q9o=iXx()set SEe[oSx]=Cqx
set SXe[oSx]=.0set SOe[oSx]=QOr
set SRe[oSx]=O4o*1./ QXr*SIe
set SAe[oSx]=rYx
set SNe[oSx]=QXr
set Sbe[oSx]=Qxr
set SBe[oSx]=dVx
set Sce[oSx]=dEx
set SCe[oSx]=M3x()set Sde[oSx]=Q9o
set ge[(iCx)]=(oSx)set ge[(QOr)]=(oSx)set ge[(Qxr)]=(oSx)set ge[(Q9o)]=(oSx)call iDx(Q9o,SIe,true,function q6r)call iDx(Qxr,QXr,false,function Qer)
call iDx(iCx,iMx+QXr,false,function Qar)
call iDx(QOr,(iMx+QXr)*1./(Sve[rYx]+1),true,function QVr)return trueendfunctionfunction QRr takes nothing returns booleanlocal integer rFx=(bv)local integer QIr=(Vv[(rFx)])local integer rYx=(osx(((QIr)),Yb+(s2e)))call AZx(QIr,s2e)call KQr(QIr,s6e[rYx],s1e[rYx])return trueendfunctionfunction QAr takes nothing returns booleanlocal integer rFx=(bv)local integer QIr=(Vv[(rFx)])call Avx(QIr,Sfe)return trueendfunctionfunction QNr takes nothing returns booleanlocal integer rFx=(bv)local integer QIr=(Vv[(rFx)])call RPx(QIr,Sfe)return trueendfunctionfunction Qbr takes nothing returns nothingset Sfe=Xdx("FolderNurturingGrounds_StructEgg_Init: set FolderNurturingGrounds_StructEgg.HEAL_EVENT = Event.Create(Unit.HEALED_EVENT_TYPE, EventPriority.SPELLS, function FolderNurturingGrounds_StructEgg.Event_Heal)",BCv,MI,function QRr)
call Lxx(s2e,Xdx("FolderNurturingGrounds_StructEgg_Init: call FolderNurturingGrounds_StructEgg.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderNurturingGrounds_StructEgg.Event_BuffGain))",bd,MI,function QAr))
call Lxx(s2e,Xdx("FolderNurturingGrounds_StructEgg_Init: call FolderNurturingGrounds_StructEgg.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderNurturingGrounds_StructEgg.Event_BuffLose))",jc,MI,function QNr))
endfunctionfunction QBr takes nothing returns booleanlocal integer oMxcall mro(gZv,Xdx("NurturingGrounds_Init: call NurturingGrounds.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function NurturingGrounds.Event_SpellEffect))",ih,MI,function QEr))set oMx=(m6[(gZv)])loop
set oMx=oMx-1exitwhen(oMx<1)endloopcall Qbr()return trueendfunctionfunction Qcr takes nothing returns booleancall cPr(function QBr,"NurturingGrounds_Init")return trueendfunctionfunction QCr takes nothing returns booleanset SFe[1]=275set SFe[2]=275set SFe[3]=275set Sge[1]=600set Sge[2]=725set Sge[3]=850set SGe[1]=1
set SGe[2]=1
set SGe[3]=1
set She[1]=3
set She[2]=4
set She[3]=5
set SHe[1]=1.5set SHe[2]=2
set SHe[3]=2.5set Sje[1]=50set Sje[2]=90set Sje[3]=$8Creturn trueendfunctionfunction Qdr takes nothing returns booleancall VNx(va,(function QCr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PandaPaw.page\\PandaPaw.struct\\Arrival\\Target\\obj_this_wc3obj.j"))return trueendfunctionfunction QDr takes nothing returns booleanset SJe=VXx(Ske)
return trueendfunctionfunction Qfr takes nothing returns booleanset SKe=s0x("CLTS")return trueendfunctionfunction QFr takes nothing returns booleanset Sle[1]=.5set Sle[2]=.5set Sle[3]=.5return trueendfunctionfunction Qgr takes nothing returns booleancall VNx(Ja,(function Qfr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PandaPaw.page\\PandaPaw.struct\\Arrival\\obj_dummyUbersplat_wc3ubersplat.j"))call VNx(va,(function QFr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PandaPaw.page\\PandaPaw.struct\\Arrival\\obj_this_wc3obj.j"))return trueendfunctionfunction QGr takes nothing returns booleanset SLe=VXx(Sme)
return trueendfunctionfunction Qhr takes nothing returns booleanset SMe=ltx(Spe+" (dummyBuff)")set WU=l_x()
call l2x(WU,cNv,5)call l3x(((SMe)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,cNv,$A)call l3x(((SMe)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,cNv,$F)call l3x(((SMe)),ZB+(3),(WU))return trueendfunctionfunction QHr takes nothing returns booleanset SPe[1]=5
set SPe[2]=$Aset SPe[3]=$Freturn trueendfunctionfunction Qjr takes nothing returns booleancall VNx(ma,(function Qhr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PandaPaw.page\\PandaPaw.struct\\Leech\\obj_dummyBuff_wc3buff.j"))call VNx(va,(function QHr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PandaPaw.page\\PandaPaw.struct\\Leech\\obj_this_wc3obj.j"))return trueendfunctionfunction QJr takes nothing returns booleanset Sqe=VXx(Spe)
return trueendfunctionfunction Qkr takes nothing returns booleanset SQe=ltx(Sse+" (dummyBuff)")set WU=l_x()
call vAr(WU,DRv,true)call vAr(WU,DLv,true)call l3x(((SQe)),ZB+(1),(WU))return trueendfunctionfunction QKr takes nothing returns booleancall L1x('APaP',false)set G7v=L0o('APaP')set K6[(G7v)]=(g6)set m6[(G7v)]=(3)set TH[(G7v)]=("Panda Paw")set Rh[(G7v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0269)))),(((Aj))))))set oxv[(G7v)]=(2)set x3v[(G7v)]=("attack")call L1o((G7v),Uvv+(1),((400)*1.))call L1o((G7v),GH+(1),(($F)*1.))
call L1o((G7v),tH+(1),(('}')*1.))call L1o((G7v),Lov+(1),((800)*1.))call L1o((G7v),Uvv+(2),((400)*1.))call L1o((G7v),GH+(2),(($E)*1.))
call L1o((G7v),tH+(2),(($96)*1.))call L1o((G7v),Lov+(2),((800)*1.))call L1o((G7v),Uvv+(3),((400)*1.))call L1o((G7v),GH+(3),(($D)*1.))
call L1o((G7v),tH+(3),(($AF)*1.))call L1o((G7v),Lov+(3),((800)*1.))set MOv[(G7v)]=("ReplaceableTextures\\CommandButtons\\BTNBearForm.blp")call cDr(G7v,'FPP0',3,'VPP0','LPPP','LRPP')set SSe[1]=500set SSe[2]=500set SSe[3]=500set Ste[1]=650set Ste[2]=650set Ste[3]=650return trueendfunctionfunction Qlr takes nothing returns booleancall VNx(ma,(function Qkr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PandaPaw.page\\PandaPaw.struct\\obj_dummyBuff_wc3buff.j"))call VNx(Pa,(function QKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PandaPaw.page\\PandaPaw.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction QLr takes nothing returns booleanset STe=VXx(Sse)
return trueendfunctionfunction Qmr takes integer oSx,real oux returns nothingcall X7o(oSx,(IPv[(oSx)])+oux)endfunctionfunction QMr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local real NLx=SYe[oSx]*1./ S6e*1./ S6elocal real bex=Sue[oSx]local integer Cqx=oSxlocal real p=SWe[oSx]*1./ S6e*1./ NLxlocal real dVx=S1e[oSx]local real dEx=S2e[oSx]local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real VMr=fYx(Cqx)local integer HAx=mDx(Ikv[(Tf[(Cqx)])],wQo+S7e*(Cos(((((bex)*1.))*1.))),wso+S7e*(Sin(((((bex)*1.))*1.))),VMr,bex)local real DJo=-p+(SquareRoot(((p*p+2*gHx(dVx-wQo,dEx-wso,X_x(dVx,dEx)-VMr)*1./ NLx)*1.)))if(DJo>.3)thencall SetUnitAnimation(C[((Cqx))],("attack"))
call QueueUnitAnimation(C[((Cqx))],("stand"))endifcall UnitAddAbility(vJ[((HAx))],('aLoc'))call fgo(HAx,S8e)call QYo((HAx),-((255.)*1.),-((255.)*1.),-((255.)*1.),-((255.)*1.),((S8e)*1.))endfunctionfunction Qpr takes integer oSx,real x,real y,real z returns nothingcall fwx(oSx,x)call fWx(oSx,y)call fyx(oSx,x,y,z)endfunctionfunction QPr takes real oux,real Qqr,real QQr returns reallocal real Qsr=jkx(oux,QQr)local real QSr=jkx(oux,Qqr)if(QSr+Qsr-.01>byx(QQr-Qqr))then
if(QSr<Qsr)thenreturn Qqrendifreturn QQrendifreturn ouxendfunctionfunction Qtr takes integer oSx returns integerset tEe[oSx]=trueset tXe[oSx]=falsecall rEx(SJe)return oSxendfunctionfunction QTr takes nothing returns integerlocal integer oSxif(tie==8190)thencall o_x("FolderPandaPaw_FolderArrival_StructTarget_Allocation_allocCustom","call DebugEx(FolderPandaPaw_FolderArrival_StructTarget.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Ske+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(tae[(w)]==w)thenset tne=tne+1set oSx=tneelse
set oSx=tae[(w)]
set tae[(w)]=tae[tae[(w)]]endifset tae[oSx]=Zset tVe[oSx]=1call Qtr(oSx)return oSxendfunctionfunction Qur takes integer oSx,real bex,integer rYx,integer Iix,real dVx,real dEx returns nothinglocal integer rLx=oSxset bex=QPr((Atan2((((GetUnitY(C[((Iix))]))-dEx)*1.),(((GetUnitX(C[((Iix))]))-dVx)*1.))),bex-tre,bex+tre)set oSx=QTr()set tOe[oSx]=Sje[rYx]+SGe[rYx]*(OH[(S3e[rLx])])set tRe[oSx]=rLx
set tIe[oSx]=tAe[rYx]*(Cos(((((bex)*1.))*1.)))set tNe[oSx]=tAe[rYx]*(Sin(((((bex)*1.))*1.)))set tbe[oSx]=tBe[rYx]set tce[oSx]=tCe[rYx]if rUx(Iix,tde,oSx)thencall Avx(Iix,tDe)endifcall rwx(Iix,tfe+rLx,oSx)endfunctionfunction QUr takes integer oSx returns booleanif((tFe[((oSx))])>0)then
return false
endifset tge=tge+1set tGe[tge]=oSx
set tFe[oSx]=tge+1return(tge==0)endfunctionfunction Qwr takes nothing returns nothinglocal integer oMx=tgeloop
exitwhen(oMx<0)set tje[oMx]=tGe[oMx]set oMx=oMx-1endloopset tJe=tgeendfunctionfunction QWr takes nothing returns integerlocal integer o7xif(tJe<0)thenreturn w
endifset o7x=tje[0]set tje[0]=tje[tJe]set tJe=tJe-1return o7xendfunctionfunction Qyr takes integer oSx,integer Cqx,integer Iix returns nothinglocal real cNxlocal integer rYxlocal real gYrset oSx=osx(Iix,tfe+oSx)
set cNx=tbe[oSx]+tce[oSx]set tbe[oSx]=cNx
call B6o(Iix,tIe[oSx])call B7o(Iix,tNe[oSx])call B9o(Iix,cNx)if((cNx<.0)and(fYx(Iix)<X_x((GetUnitX(C[((Iix))])),(GetUnitY(C[((Iix))])))+tke))then
set rYx=SZe[tRe[oSx]]call Ryx((ACx((Iix),(tKe),(tle),(Bi))))call cmo(Iix)if I9x(Iix,Wd)thenset gYr=SHe[rYx]
else
set gYr=She[rYx]
endifcall Nbx((((Iix))),((Xwv)),(1),w,((((gYr)*1.))*1.))call nlo((Cqx),(Iix),((tOe[oSx])*1.),(true),(true))endifendfunctionfunction QYr takes nothing returns booleanlocal integer rFx=(bv)local integer rLx=(pj[(rFx)])call Qyr((rLx),SUe[rLx],(Vv[(rFx)]))
return trueendfunctionfunction Qzr takes integer rLx returns nothingcall Dgx(S0e[rLx],function QYr,rLx)endfunctionfunction QZr takes nothing returns nothinglocal integer oSxlocal integer rLxlocal integer Cqxlocal integer svolocal integer Iixcall Qwr()loop
set oSx=QWr()exitwhen(oSx==w)
set rLx=oSxset Cqx=SUe[rLx]
set svo=S0e[rLx]
call Qzr(rLx)endloopendfunctionfunction Q_r takes integer oSx returns nothingset tEe[oSx]=falsecall rHx(SJe)endfunctionfunction Q0r takes integer oSx returns nothingif(tVe[oSx]>0)thenreturnendifif(tae[oSx]!=Z)thencall o_x("FolderPandaPaw_FolderArrival_StructTarget_Allocation_deallocCustom_confirm","call DebugEx(FolderPandaPaw_FolderArrival_StructTarget.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Ske+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset tae[oSx]=tae[(w)]set tae[(w)]=oSx
call Q_r(oSx)endfunctionfunction Q1r takes integer oSx returns nothingset tVe[oSx]=tVe[oSx]-1call Q0r(oSx)endfunctionfunction Q2r takes integer oSx,integer rLx,integer Iix,integer svo returns nothingcall Q1r((oSx))if rnx(Iix,tde,oSx)thencall RPx(Iix,tDe)endifcall rVx(Iix,tfe+rLx)call IRo(svo,Iix)endfunctionfunction Q3r takes integer oSx,integer Iix,integer svo returns nothinglocal integer rLx=oSxset oSx=osx(Iix,tfe+rLx)
call Q2r(oSx,rLx,Iix,svo)endfunctionfunction Q4r takes integer oSx,integer svo returns nothinglocal integer Iixloop
set Iix=(OUx((svo),Ob))exitwhen(Iix==w)
call Q3r(oSx,Iix,svo)endloopendfunctionfunction Q5r takes integer oSx returns booleanif(((tFe[((oSx))])>0)==false)thenreturn false
endifset tFe[tGe[tge]]=tFe[oSx]set tGe[tFe[oSx]-1]=tGe[tge]
set tFe[oSx]=0set tge=tge-1return(tge==F)endfunctionfunction Q6r takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local integer rLx=(oSx)local integer svo=S0e[rLx]local integer Ctx=S3e[rLx]call Q4r(oSx,svo)call iKx(iCx)call X_r(svo)if Q5r(oSx)thencall iKx(the)endifcall Usx(Ctx)endfunctionfunction Q7r takes integer oSx,real bex,integer Cqx,integer rYx,real dVx,real dEx,integer Ctx returns nothinglocal integer rLx=oSxlocal integer Iixlocal integer svolocal integer iCxcall bXr(bbr(SKe,dVx,dEx,$FF,$FF,$FF,$7F,false,false),5.)call mho((mko(((dVx)*1.),((dEx)*1.),(tve),(ri))))set dVx=dVx+tee*(Cos(((((bex)*1.))*1.)))
set dEx=dEx+tee*(Sin(((((bex)*1.))*1.)))
set Ff=dVxset gf=dExset Gf=bexset hf=(ze[(Cqx)])call NVo(txe,dVx,dEx,(CQx((G7v),Uvv+(rYx))),toe)
set Iix=NEo(txe)
set svo=S0e[rLx]
if(Iix==w)thencall X_r(svo)else
set iCx=iXx()set ge[(iCx)]=(oSx)loop
call dQx(svo,Iix)call Qur(oSx,bex,rYx,Iix,dVx,dEx)set Iix=NEo(txe)
exitwhen(Iix==w)
endloopif QUr(oSx)thencall iDx(the,tHe,true,function QZr)endifcall iDx(iCx,Sle[rYx],false,function Q6r)endifendfunctionfunction Q8r takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=oSxlocal real oyx=SWe[oSx]+SYe[oSx]
local real dVx=S1e[oSx]local real dEx=S2e[oSx]local real MQx=X_x(dVx,dEx)local real x=(GetUnitX(C[((Cqx))]))local real y=(GetUnitY(C[((Cqx))]))local real z=fYx(Cqx)local real dX=dVx-xlocal real dY=dEx-ylocal real dZ=MQx-zlocal real Q9r=(Atan2(((dY)*1.),((dX)*1.)))local real d=gHx(dX,dY,dZ)local boolean ktr=(d<oyx+S9e)local real svrlocal real Vprlocal integer Ctxif ktr thenset x=dVxset y=dExset z=MQxelse
set svr=(Atan2(((dZ)*1.),((jKx(dX,dY))*1.)))
set Vpr=oyx*(Cos(((((svr)*1.))*1.)))
set x=x+Vpr*(Cos(((((Q9r)*1.))*1.)))
set y=y+Vpr*(Sin(((((Q9r)*1.))*1.)))
set z=z+oyx*(Sin(((((svr)*1.))*1.)))
call SetUnitFacing(C[((Cqx))],((Q9r)*1.)*ky)
endifcall Qpr(Cqx,x,y,z)if ktr thenset Ctx=S3e[oSx]
call Ucx(Ctx)call AZx(Cqx,SQe)call Q7r(oSx,Q9r,Cqx,SZe[oSx],dVx,dEx,Ctx)else
set Sue[oSx]=Q9r
set SWe[oSx]=oyx
endifendfunctionfunction ser takes nothing returns booleanlocal integer rFx=(bv)local integer nSr=(Lc[(rFx)])local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer Ctx=CPx(Iix,G7v)local real dVx=(yH[(nSr)])local real dEx=(YH[(nSr)])local real bex=Ufx(Iix,dVx-(GetUnitX(C[((Iix))])),dEx-(GetUnitY(C[((Iix))])))local integer oSx=Iixlocal integer iCx=iXx()local integer sio=iXx()local integer hCr=iXx()set Sue[oSx]=bex
set SUe[oSx]=Iix
set Swe[oSx]=sio
set SWe[oSx]=Sye[rYx]set SYe[oSx]=Sze[rYx]set SZe[oSx]=rYx
set S_e[oSx]=hCr
set S0e[oSx]=Jbx("PandaPaw_Event_BuffGain: set this.targetGroup = UnitList.Create()")set S1e[oSx]=dVx
set S2e[oSx]=dEx
set S3e[oSx]=Ctx
set ge[(sio)]=(oSx)set ge[(hCr)]=(oSx)call Qmr(Iix,S4e)call iDx(sio,S5e,true,function QMr)call iDx(hCr,S6e,true,function Q8r)return trueendfunctionfunction sxr takes integer oSx,real oux returns nothingcall X7o(oSx,(IPv[(oSx)])-oux)endfunctionfunction sor takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer sio=Swe[oSx]local integer hCr=S_e[oSx]local integer Ctx=S3e[oSx]call iKx(sio)call iKx(hCr)call sxr(Iix,S4e)call dNx(Ctx)return trueendfunctionfunction srr takes nothing returns booleanlocal integer rFx=(bv)call JUr((Vv[(rFx)]),SQe,(Mv[(rFx)]),rFx)return trueendfunctionfunction sir takes nothing returns booleanlocal integer Iix=jhx()if(jkx((Atan2((((GetUnitY(C[((Iix))]))-gf)*1.),(((GetUnitX(C[((Iix))]))-Ff)*1.))),Gf)>Bev)thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction sar takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oMx=CIx(Iix,tde)local integer oSxlocal integer rLxloop
set oSx=CAx(Iix,tde,oMx)
set rLx=tRe[oSx]
call Q2r(oSx,rLx,Iix,S0e[rLx])set oMx=oMx-1exitwhen(oMx<q)endloopcall GroupRemoveUnit(kb[(txe)],C[(Iix)])
return trueendfunctionfunction snr takes nothing returns nothinglocal integer oMxset tDe=Xdx("FolderPandaPaw_FolderArrival_StructTarget_Init: set FolderPandaPaw_FolderArrival_StructTarget.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderPandaPaw_FolderArrival_StructTarget.Event_Death)",VP,MI,function sar)
set oMx=(m6[(G7v)])loop
set tAe[oMx]=Sge[oMx]*1./ Sle[oMx]*tHeset tCe[oMx]=-8.*SFe[oMx]*1./ Sle[oMx]*1./ Sle[oMx]*tHe*tHeset tBe[oMx]=-Sle[oMx]*tCe[oMx]*1./ 2*1./ tHeset oMx=oMx-1exitwhen(oMx<1)endloopendfunctionfunction sVr takes nothing returns nothingset txe=O5x()set toe=Xpx(function sir)set the=iXx()call snr()endfunctionfunction sEr takes nothing returns booleanlocal integer rFx=(bv)call seo((Vv[(rFx)]),SMe,(Mv[(rFx)]))return trueendfunctionfunction sXr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),SMe)return trueendfunctionfunction sOr takes nothing returns nothingcall mro(G7v,Xdx("FolderPandaPaw_StructLeech_Init: call PandaPaw.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function FolderPandaPaw_StructLeech.Event_Learn))",Pv,MI,function sEr))call mro(G7v,Xdx("FolderPandaPaw_StructLeech_Init: call PandaPaw.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderPandaPaw_StructLeech.Event_Learn))",pv,MI,function sEr))call mro(G7v,Xdx("FolderPandaPaw_StructLeech_Init: call PandaPaw.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderPandaPaw_StructLeech.Event_Unlearn))",Av,MI,function sXr))endfunctionfunction sRr takes nothing returns booleanlocal integer oMxcall Lxx(SQe,Xdx("PandaPaw_Init: call PandaPaw.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function PandaPaw.Event_BuffGain))",bd,MI,function ser))
call Lxx(SQe,Xdx("PandaPaw_Init: call PandaPaw.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function PandaPaw.Event_BuffLose))",jc,MI,function sor))
call mro(G7v,Xdx("PandaPaw_Init: call PandaPaw.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function PandaPaw.Event_SpellEffect))",ih,MI,function srr))set oMx=(m6[(G7v)])loop
set Sye[oMx]=Ste[oMx]*S6eset Sze[oMx]=SSe[oMx]*S6e*S6eset oMx=oMx-1exitwhen(oMx<1)endloopcall sVr()call sOr()return trueendfunctionfunction sIr takes nothing returns booleancall FAr(function sRr,"PandaPaw_Init")return trueendfunctionfunction sAr takes nothing returns booleanset tLe[1]=3
set tLe[2]=3
set tLe[3]=4
set tLe[4]=4
set tLe[5]=5
set tLe[6]=5
set tme[1]=20set tme[2]=30set tme[3]=40set tme[4]=50set tme[5]=60set tme[6]=70set tMe[1]=4
set tMe[2]=4
set tMe[3]=4
set tMe[4]=4
set tMe[5]=4
set tMe[6]=4
return trueendfunctionfunction sNr takes nothing returns booleancall VNx(va,(function sAr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PurgingRain.page\\PurgingRain.struct\\Wave\\obj_this_wc3obj.j"))
return trueendfunctionfunction sbr takes nothing returns booleanset tpe=VXx(tPe)
return trueendfunctionfunction sBr takes nothing returns booleancall L1x('APRa',false)set g5v=L0o('APRa')set K6[(g5v)]=(O6)set m6[(g5v)]=(6)set TH[(g5v)]=("Purging Rain")set Rh[(g5v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0079)))),(((Aj))))))set oxv[(g5v)]=(2)set x3v[(g5v)]=("spell")
call L1o((g5v),Uvv+(1),((300)*1.))call L1o((g5v),dH+(1),((5)*1.))call L1o((g5v),GH+(1),(($F)*1.))
call L1o((g5v),tH+(1),((80)*1.))
call L1o((g5v),Lov+(1),((600)*1.))call L1o((g5v),Uvv+(2),((325)*1.))call L1o((g5v),dH+(2),((5)*1.))call L1o((g5v),GH+(2),(($F)*1.))
call L1o((g5v),tH+(2),(('d')*1.))call L1o((g5v),Lov+(2),((600)*1.))call L1o((g5v),Uvv+(3),((350)*1.))call L1o((g5v),dH+(3),((5)*1.))call L1o((g5v),GH+(3),(($F)*1.))
call L1o((g5v),tH+(3),(('x')*1.))call L1o((g5v),Lov+(3),((600)*1.))call L1o((g5v),Uvv+(4),((375)*1.))call L1o((g5v),dH+(4),((5)*1.))call L1o((g5v),GH+(4),(($F)*1.))
call L1o((g5v),tH+(4),(($8C)*1.))call L1o((g5v),Lov+(4),((600)*1.))call L1o((g5v),Uvv+(5),((400)*1.))call L1o((g5v),dH+(5),((5)*1.))call L1o((g5v),GH+(5),(($F)*1.))
call L1o((g5v),tH+(5),(($A0)*1.))call L1o((g5v),Lov+(5),((600)*1.))call L1o((g5v),Uvv+(6),((425)*1.))call L1o((g5v),dH+(6),((5)*1.))call L1o((g5v),GH+(6),(($F)*1.))
call L1o((g5v),tH+(6),(($B4)*1.))call L1o((g5v),Lov+(6),((600)*1.))set MOv[(g5v)]=("ReplaceableTextures\\CommandButtons\\BTNStarfall.blp")call cDr(g5v,'FPR0',6,'VPR0','LPPR','LRPR')return trueendfunctionfunction scr takes nothing returns booleanset l6e=ltx(tqe+" (dummyBuff)")return trueendfunctionfunction sCr takes nothing returns booleancall VNx(Pa,(function sBr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PurgingRain.page\\PurgingRain.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function scr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\PurgingRain.page\\PurgingRain.struct\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction sdr takes nothing returns booleanset tQe=VXx(tqe)
return trueendfunctionfunction sDr takes integer oSx returns integerset tZe[oSx]=trueset t_e[oSx]=falsecall rEx(tpe)return oSxendfunctionfunction sfr takes nothing returns integerlocal integer oSxif(tWe==8190)thencall o_x("FolderPurgingRain_StructWave_Allocation_allocCustom","call DebugEx(FolderPurgingRain_StructWave.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",tPe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(tye[(w)]==w)thenset tYe=tYe+1set oSx=tYeelse
set oSx=tye[(w)]
set tye[(w)]=tye[tye[(w)]]endifset tye[oSx]=Zset tze[oSx]=1call sDr(oSx)return oSxendfunctionfunction sFr takes integer oSx returns nothingset tZe[oSx]=falsecall rHx(tpe)endfunctionfunction sgr takes integer oSx returns nothingif(tze[oSx]>0)thenreturnendifif(tye[oSx]!=Z)thencall o_x("FolderPurgingRain_StructWave_Allocation_deallocCustom_confirm","call DebugEx(FolderPurgingRain_StructWave.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",tPe+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset tye[oSx]=tye[(w)]set tye[(w)]=oSx
call sFr(oSx)endfunctionfunction sGr takes integer oSx returns nothingset tze[oSx]=tze[oSx]-1call sgr(oSx)endfunctionfunction shr takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local real O4o=t0e[oSx]local integer Cqx=t1e[oSx]local real Nbo=t2e[oSx]local real dVx=t3e[oSx]local real dEx=t4e[oSx]local integer Ctx=CPx(Cqx,g5v)local integer rYx=(IH[(Ctx)])local integer Iixcall sGr((oSx))call iKx(iCx)call dNx(Ctx)set hf=(ze[(Cqx)])call NVo(t7e,dVx,dEx,O4o,t8e)loop
set Iix=NEo(t7e)
exitwhen(Iix==w)
call nEr(rYx,Iix,tMe[rYx])call nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))endloopendfunctionfunction sHr takes integer Cqx,integer rYx,real dVx,real dEx returns nothing
local real O4o=(CQx((g5v),Uvv+(rYx)))local integer oSx=sfr()local integer iCx=iXx()local integer oMxlocal real bexlocal real n2xset t0e[oSx]=O4o
set t1e[oSx]=Cqx
set t2e[oSx]=tme[rYx]set t3e[oSx]=dVx
set t4e[oSx]=dEx
set ge[(iCx)]=(oSx)set O4o=O4o*.75set oMx=tLe[rYx]
loop
exitwhen(oMx<1)set bex=(GetRandomReal(((.0)*1.),((Cf)*1.)))
set n2x=(GetRandomReal(((.0)*1.),((O4o)*1.)))call mho((mko(((dVx+n2x*(Cos(((((bex)*1.))*1.))))*1.),((dEx+n2x*(Sin(((((bex)*1.))*1.))))*1.),(t5e),(ri))))set oMx=oMx-1endloopcall iDx(iCx,t6e,false,function shr)
endfunctionfunction sjr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxcall sHr(Iix,tTe[oSx],tue[oSx],tUe[oSx])
endfunctionfunction sJr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxcall AZx(Iix,l6e)endfunctionfunction skr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Ctx=tselocal integer Iix=(EH[(Ctx)])local real dVx=(yh[(Ctx)])local real dEx=(Yh[(Ctx)])local integer oSx=Iixlocal integer iCx=iXx()local integer p3x=iXx()set tSe[oSx]=iCx
set tte[oSx]=p3x
set tTe[oSx]=rYx
set tue[oSx]=dVx
set tUe[oSx]=dEx
set ge[(iCx)]=(oSx)set ge[(p3x)]=(oSx)call iDx(p3x,twe,true,function sjr)call iDx(iCx,(CQx((g5v),dH+(rYx))),false,function sJr)call sHr(Iix,rYx,dVx,dEx)return trueendfunctionfunction sKr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer iCx=tSe[oSx]local integer p3x=tte[oSx]call iKx(iCx)call iKx(p3x)return trueendfunctionfunction slr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])if(osx((((Cqx))),(Wb+(c3e)))>0)thenreturn trueendifcall AZx(Cqx,l6e)return trueendfunctionfunction sLr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Ctx=(WH[(rFx)])if(osx((((Cqx))),(Wb+(c3e)))>0)thencall AZx(Cqx,DH)
endifset tse=Ctxcall seo(Cqx,l6e,rYx)return trueendfunctionfunction smr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction sMr takes nothing returns nothingset t7e=O5x()set t8e=Xpx(function smr)endfunctionfunction spr takes nothing returns booleancall Lxx(l6e,Xdx("PurgingRain_Init: call PurgingRain.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function PurgingRain.Event_BuffGain))",bd,MI,function skr))call Lxx(l6e,Xdx("PurgingRain_Init: call PurgingRain.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function PurgingRain.Event_BuffLose))",jc,MI,function sKr))call mro(g5v,Xdx("PurgingRain_Init: call PurgingRain.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function PurgingRain.Event_EndCast))",onv,MI,function slr))call mro(g5v,Xdx("PurgingRain_Init: call PurgingRain.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function PurgingRain.Event_SpellEffect))",ih,MI,function sLr))call sMr()return trueendfunctionfunction sPr takes nothing returns booleancall FAr(function spr,"PurgingRain_Init")return trueendfunctionfunction sqr takes nothing returns booleanset t9e=VCx("ORBD")return trueendfunctionfunction sQr takes nothing returns booleancall VNx(ha,(function sqr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RazorBlade.page\\RazorBladeDrawBack.struct\\Blade\\obj_bolt_wc3bolt.j"))
return trueendfunctionfunction ssr takes nothing returns booleanset Tve=VXx(Tee)
return trueendfunctionfunction sSr takes nothing returns booleanset Txe[1]=60set Txe[2]=60set Txe[3]=60set Txe[4]=60set Txe[5]=60set Txe[6]=60set Toe[1]=.15set Toe[2]=.15set Toe[3]=.15set Toe[4]=.15set Toe[5]=.15set Toe[6]=.15set Tre[1]=3
set Tre[2]=4
set Tre[3]=5
set Tre[4]=6
set Tre[5]=7
set Tre[6]=8
set Tie[1]=20set Tie[2]=30set Tie[3]=40set Tie[4]=50set Tie[5]=60set Tie[6]=70return trueendfunctionfunction str takes nothing returns booleancall VNx(va,(function sSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RazorBlade.page\\RazorBladeDrawBack.struct\\obj_this_wc3obj.j"))
return trueendfunctionfunction sTr takes nothing returns booleanset Tae=VXx(Tne)
return trueendfunctionfunction sur takes integer oSx,integer otx returns integerreturn(LoadInteger(o[((V[(E[((TEe[(oSx)]))])]))],((((TXe[((oSx))])))),(((otx)))))endfunctionfunction sUr takes nothing returns booleanlocal integer rFx=(bv)local integer swr=(lz[(rFx)])local integer sWr=sur(swr,TOe)call K0x(sWr)return trueendfunctionfunction syr takes nothing returns booleanlocal integer Iix=jhx()if(I8x((Ose),Ob,(Iix)))thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction sYr takes nothing returns nothingset TVe=Xdx("FolderRazorBladeDrawBack_StructBlade_Init: set FolderRazorBladeDrawBack_StructBlade.CHECKPOINT_IMPACT_EVENT = Event.Create(MISSILE.Checkpoints.IMPACT_EVENT_TYPE, EventPriority.SPELLS, function FolderRazorBladeDrawBack_StructBlade.CheckpointImpact)",ZY,MI,function sUr)set TRe=O5x()set TIe=Xpx(function syr)set TAe=iXx()endfunctionfunction szr takes nothing returns booleancall sYr()return trueendfunctionfunction sZr takes nothing returns booleancall FAr(function szr,"RazorBladeDrawBack_Init")
return trueendfunctionfunction s_r takes nothing returns booleanset TNe=ltx(Tbe+" (dummyBuff)")set WU=l_x()
call l2x(WU,cdv,20)call l3x(((TNe)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,cdv,20)call l3x(((TNe)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,cdv,25)call l3x(((TNe)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,cdv,25)call l3x(((TNe)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,cdv,30)call l3x(((TNe)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,cdv,35)call l3x(((TNe)),ZB+(6),(WU))return trueendfunctionfunction s0r takes nothing returns booleanset TBe[1]=20set TBe[2]=20set TBe[3]=25set TBe[4]=25set TBe[5]=30set TBe[6]=35return trueendfunctionfunction s1r takes nothing returns booleancall VNx(ma,(function s_r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RazorBlade.page\\RazorBlade.struct\\Vamp\\obj_dummyBuff_wc3buff.j"))
call VNx(va,(function s0r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RazorBlade.page\\RazorBlade.struct\\Vamp\\obj_this_wc3obj.j"))return trueendfunctionfunction s2r takes nothing returns booleanset Tce=VXx(Tbe)
return trueendfunctionfunction s3r takes nothing returns booleancall L1x('ARaz',false)set gPv=L0o('ARaz')set K6[(gPv)]=(O6)set m6[(gPv)]=(6)set TH[(gPv)]=("Razor Blade")set Rh[(gPv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0089)))),(((Aj))))))set oxv[(gPv)]=(2)set x3v[(gPv)]=("spell")
call L1o((gPv),Uvv+(1),((90)*1.))call L1o((gPv),GH+(1),(($C)*1.))
call L1o((gPv),tH+(1),((70)*1.))
call L1o((gPv),Lov+(1),((99999)*1.))
call L1o((gPv),Uvv+(2),((90)*1.))call L1o((gPv),GH+(2),(($C)*1.))
call L1o((gPv),tH+(2),((85)*1.))
call L1o((gPv),Lov+(2),((99999)*1.))
call L1o((gPv),Uvv+(3),((90)*1.))call L1o((gPv),GH+(3),(($C)*1.))
call L1o((gPv),tH+(3),(('d')*1.))call L1o((gPv),Lov+(3),((99999)*1.))
call L1o((gPv),Uvv+(4),((90)*1.))call L1o((gPv),GH+(4),(($C)*1.))
call L1o((gPv),tH+(4),(('s')*1.))call L1o((gPv),Lov+(4),((99999)*1.))
call L1o((gPv),Uvv+(5),((90)*1.))call L1o((gPv),GH+(5),(($C)*1.))
call L1o((gPv),tH+(5),(($82)*1.))call L1o((gPv),Lov+(5),((99999)*1.))
call L1o((gPv),Uvv+(6),((90)*1.))call L1o((gPv),GH+(6),(($C)*1.))
call L1o((gPv),tH+(6),(($91)*1.))call L1o((gPv),Lov+(6),((99999)*1.))
set MOv[(gPv)]=("ReplaceableTextures\\CommandButtons\\BTNWhirlwind.blp")
call cDr(gPv,'FRB0',6,'VRB0','LPRB','LRRB')set TCe[1]=750set TCe[2]=750set TCe[3]=750set TCe[4]=750set TCe[5]=750set TCe[6]=750set Tde[1]=20set Tde[2]=35set Tde[3]=55set Tde[4]=80set Tde[5]='n'set Tde[6]=$91return trueendfunctionfunction s4r takes nothing returns booleanset TDe=VCx("ORaz")return trueendfunctionfunction s5r takes nothing returns booleancall VNx(Pa,(function s3r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RazorBlade.page\\RazorBlade.struct\\obj_thisSpell_wc3spell.j"))call VNx(ha,(function s4r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RazorBlade.page\\RazorBlade.struct\\obj_bolt_wc3bolt.j"))return trueendfunctionfunction s6r takes nothing returns booleanset Tfe=VXx(TFe)
return trueendfunctionfunction s7r takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction s8r takes integer oSx returns integerset Tke[oSx]=trueset TKe[oSx]=falsecall rEx(Tfe)return oSxendfunctionfunction s9r takes nothing returns integerlocal integer oSxif(The==8190)thencall o_x("RazorBlade_Allocation_allocCustom","call DebugEx(RazorBlade.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",TFe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(THe[(w)]==w)thenset Tje=Tje+1set oSx=Tjeelse
set oSx=THe[(w)]
set THe[(w)]=THe[THe[(w)]]endifset THe[oSx]=Zset TJe[oSx]=1call s8r(oSx)return oSxendfunctionfunction Svr takes integer oSx returns nothingset Tke[oSx]=falsecall rHx(Tfe)endfunctionfunction Ser takes integer oSx returns nothingif(TJe[oSx]>0)thenreturnendifif(THe[oSx]!=Z)thencall o_x("RazorBlade_Allocation_deallocCustom_confirm","call DebugEx(RazorBlade.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",TFe+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset THe[oSx]=THe[(w)]set THe[(w)]=oSx
call Svr(oSx)endfunctionfunction Sxr takes integer oSx returns nothingset TJe[oSx]=TJe[oSx]-1call Ser(oSx)endfunctionfunction Sor takes integer oSx returns integerset TUe[oSx]=trueset Twe[oSx]=falsecall rEx(Tae)return oSxendfunctionfunction Srr takes nothing returns integerlocal integer oSxif(TSe==8190)thencall o_x("RazorBladeDrawBack_Allocation_allocCustom","call DebugEx(RazorBladeDrawBack.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Tne+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Tte[(w)]==w)thenset TTe=TTe+1set oSx=TTeelse
set oSx=Tte[(w)]
set Tte[(w)]=Tte[Tte[(w)]]endifset Tte[oSx]=Zset Tue[oSx]=1call Sor(oSx)return oSxendfunctionfunction Sir takes integer oSx returns integerset uee[oSx]=trueset uxe[oSx]=falsecall rEx(Tve)return oSxendfunctionfunction Sar takes nothing returns integerlocal integer oSxif(T7e==8190)thencall o_x("FolderRazorBladeDrawBack_StructBlade_Allocation_allocCustom","call DebugEx(FolderRazorBladeDrawBack_StructBlade.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Tee+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(T8e[(w)]==w)thenset T9e=T9e+1set oSx=T9eelse
set oSx=T8e[(w)]
set T8e[(w)]=T8e[T8e[(w)]]endifset T8e[oSx]=Zset uve[oSx]=1call Sir(oSx)return oSxendfunctionfunction Snr takes integer oSx returns booleanif(((uEe[((oSx))])>0)==false)thenreturn false
endifset uEe[uXe[uOe]]=uEe[oSx]set uXe[uEe[oSx]-1]=uXe[uOe]
set uEe[oSx]=0set uOe=uOe-1return(uOe==F)endfunctionfunction SVr takes integer oSx returns nothingset TUe[oSx]=falsecall rHx(Tae)endfunctionfunction SEr takes integer oSx returns nothingif(Tue[oSx]>0)thenreturnendifif(Tte[oSx]!=Z)thencall o_x("RazorBladeDrawBack_Allocation_deallocCustom_confirm","call DebugEx(RazorBladeDrawBack.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Tne+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset Tte[oSx]=Tte[(w)]set Tte[(w)]=oSx
call SVr(oSx)endfunctionfunction SXr takes integer oSx returns nothingset Tue[oSx]=Tue[oSx]-1call SEr(oSx)endfunctionfunction SOr takes integer oSx returns nothingcall iKx(TZe[oSx])call MFo(T1e[oSx])call SXr((oSx))endfunctionfunction SRr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer SIr=uoe[oSx]local integer h0r=ure[oSx]local integer rLx=uae[oSx]if Snr(oSx)thencall ikx(TAe)endifcall m1x(Mho,TVe)call iKx(SIr)call K0x(h0r)call MFo(Mho)if(T6e[rLx]==1)thencall SOr(rLx)else
set T6e[rLx]=T6e[rLx]-1endifreturn trueendfunctionfunction SAr takes nothing returns nothinglocal integer Okx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer Mho=(ge[(Okx)])local integer oSxlocal integer rLxcall iKx(Okx)set oSx=(mZv[(Mho)])
set rLx=uae[oSx]
call m4o(Mho,500.)set mCv[(Mho)]=((TWe[rLx])*1.)set mFv[(Mho)]=Xkx((function SRr))call Meo(Mho,850.)call M6o((Mho),(TYe[rLx]),.0,.0,.0,(null))endfunctionfunction SNr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer Okx=iXx()set ge[(Okx)]=(Mho)call iDx(Okx,Nzr("delay",uVe),false,function SAr)return trueendfunctionfunction Sbr takes integer oSx returns booleanif((uEe[((oSx))])>0)then
return false
endifset uOe=uOe+1set uXe[uOe]=oSx
set uEe[oSx]=uOe+1return(uOe==0)endfunctionfunction SBr takes nothing returns nothinglocal integer oMx=uOeloop
exitwhen(oMx<0)set uIe[oMx]=uXe[oMx]set oMx=oMx-1endloopset uAe=uOeendfunctionfunction Scr takes nothing returns integerlocal integer o7xif(uAe<0)thenreturn w
endifset o7x=uIe[0]set uIe[0]=uIe[uAe]set uAe=uAe-1return o7xendfunctionfunction SCr takes nothing returns nothinglocal integer oSxlocal real O4olocal integer Cqxlocal real Nbolocal integer Mholocal integer svolocal integer Iixcall SBr()loop
set oSx=Scr()exitwhen(oSx==w)
set O4o=TWe[uae[oSx]]set Cqx=TYe[uae[oSx]]set Nbo=Tze[uae[oSx]]set Mho=uie[oSx]
set svo=une[oSx]
set Ose=svoset hf=(ze[(Cqx)])call VKr(TRe,(mHv[(Mho)]),(mjv[(Mho)]),(mJv[(Mho)]),O4o,TIe)
set Iix=NEo(TRe)
if(Iix!=w)thenloop
call Ryx((ACx((Iix),(uNe),(ube),(Bi))))call dQx(svo,Iix)call nlo((Cqx),(Iix),((Nbo)*1.),(false),(true))set Iix=NEo(TRe)
exitwhen(Iix==w)
endloopendifendloopendfunctionfunction Sdr takes integer oSx returns integerset uDe[oSx]=trueset ufe[oSx]=falseset TEe[((oSx))]=(Ve[(GetRandomInt((0),(Ee)))])call rEx(eY)
return oSxendfunctionfunction SDr takes nothing returns integerlocal integer oSxif(uBe==8190)thencall o_x("MissileCheckpoint_Allocation_allocCustom","call DebugEx(MissileCheckpoint.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",xY+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(uce[(w)]==w)thenset uCe=uCe+1set oSx=uCeelse
set oSx=uce[(w)]
set uce[(w)]=uce[uce[(w)]]endifset uce[oSx]=Zset ude[oSx]=1call Sdr(oSx)return oSxendfunctionfunction Sfr takes integer oSx returns nothingset TXe[(oSx)]=(uge+oSx)
endfunctionfunction SFr takes real x,real y,real z returns integerlocal integer oSx=SDr()call Sfr(oSx)set m9v[(oSx)]=((x)*1.)set Mvv[(oSx)]=((y)*1.)set Mev[(oSx)]=((z)*1.)return oSxendfunctionfunction Sgr takes integer oSx,integer Mzo returns nothinglocal integer rFx=rRx((oz[((oSx))]))
local integer oMxlocal integer rbxlocal integer rMxset ez[(rFx)]=(oSx)set lz[(rFx)]=(Mzo)set oMx=Xvloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=MIo((oSx),zY,rbx)loop
exitwhen(rMx<q)call rfx(MAo((oSx),zY,rbx,rMx),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction SGr takes integer oSx,integer Mzo returns booleanlocal boolean o7xif(Ez[oSx]==w)thenset Ez[oSx]=M3x()call Mox((oSx),vz)endifset o7x=spo(Ez[oSx],Mzo)
call Sgr(oSx,Mzo)return o7xendfunctionfunction Shr takes integer oSx,real x,real y,real z returns integerlocal integer o7x=SFr(x,y,z)
call SGr(oSx,o7x)return o7xendfunctionfunction SHr takes integer oSx,integer otx,integer oux returns nothingcall SaveInteger(o[((V[(E[((TEe[(oSx)]))])]))],((((TXe[((oSx))])))),(((otx))),(((oux))))
endfunctionfunction Sjr takes integer oSx returns integerset Gu[oSx]=true
set uHe[oSx]=falsecall rEx(St)
return oSxendfunctionfunction SJr takes nothing returns integerlocal integer oSxif(uGe==8190)thencall o_x("FolderLightning_StructFromSpotToDummyUnit_Allocation_allocCustom","call DebugEx(FolderLightning_StructFromSpotToDummyUnit.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",tt+" - alloc: unable to allocCustom, reached stack limit")
return w
endifif(gu[(w)]==w)thenset uhe=uhe+1set oSx=uheelse
set oSx=gu[(w)]set gu[(w)]=gu[gu[(w)]]endifset gu[oSx]=Zset Fu[oSx]=1call Sjr(oSx)return oSxendfunctionfunction Skr takes integer oSx returns booleanset Ku=Ku+1set ku[Ku]=oSxset Ju[oSx]=Ku+1
return(Ku==0)endfunctionfunction SKr takes nothing returns nothinglocal integer oMx=Ku
local integer oSxlocal integer Iixlocal real dVxlocal real dExlocal real MQxloop
set oSx=ku[oMx]set Iix=Lu[oSx]if(Iix==w)thenset dVx=ule[oSx]
set dEx=uLe[oSx]
set MQx=ume[oSx]
else
set dVx=(iJ[(Iix)])set dEx=(EJ[(Iix)])set MQx=(Au[(Iix)])endifcall cGo(mu[oSx],uje[oSx],uJe[oSx],uke[oSx],dVx,dEx,MQx)
set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction Slr takes integer oSx,real jMx,real jpx,real cJo,integer Iix returns nothinglocal integer rLx=oSxlocal real dVx=(iJ[(Iix)])local real dEx=(EJ[(Iix)])local real MQx=(Au[(Iix)])call cDo(rLx)set oSx=SJr()set mu[oSx]=rLxset uje[oSx]=jMx
set uJe[oSx]=jpx
set uke[oSx]=cJo
set Lu[oSx]=Iixcall cgo(rLx,fu,oSx)
call KSx(rLx,du)
if Qso(Iix,Hu,oSx)thencall Mix(Iix,ju)
endifcall cGo(rLx,jMx,jpx,cJo,dVx,dEx,MQx)if Skr(oSx)thencall iDx(lu,uKe,true,function SKr)endifendfunctionfunction SLr takes integer oSx returns integerset su[oSx]=true
set uPe[oSx]=falsecall rEx(Tt)
return oSxendfunctionfunction Smr takes nothing returns integerlocal integer oSxif(uMe==8190)thencall o_x("FolderLightning_StructFromSpotToSpot_Allocation_allocCustom","call DebugEx(FolderLightning_StructFromSpotToSpot.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",ut+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Qu[(w)]==w)thenset upe=upe+1set oSx=upeelse
set oSx=Qu[(w)]set Qu[(w)]=Qu[Qu[(w)]]endifset Qu[oSx]=Zset qu[oSx]=1call SLr(oSx)return oSxendfunctionfunction SMr takes integer oSx,real jMx,real jpx,real cJo,real dVx,real dEx,real MQx returns nothing
local integer rLx=oSxcall cDo(rLx)set oSx=Smr()set uqe[oSx]=rLx
set uQe[oSx]=jMx
set use[oSx]=jpx
set uSe[oSx]=cJo
set ute[oSx]=dVx
set uTe[oSx]=dEx
set uue[oSx]=MQx
call cgo(rLx,Pu,oSx)
call KSx(rLx,Mu)
call cGo(rLx,jMx,jpx,cJo,dVx,dEx,MQx)endfunctionfunction Spr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=TYe[uae[oSx]]local real x=(GetUnitX(C[((Cqx))]))local real y=(GetUnitY(C[((Cqx))]))local real z=fYx(Cqx)local integer SPr=Shr(uie[oSx],x,y,z)local integer Sqrlocal integer SQr=cdo(t9e)call SHr(SPr,TOe,SQr)if(SPr==(rz[(Ez[(uie[oSx])])]))thencall Slr(SQr,x,y,z,(bz[(uie[oSx])]))
else
set Sqr=(pkx(Ez[(uie[oSx])],(SPr)))call SMr(SQr,x,y,z,(m9v[(Sqr)]),(Mvv[(Sqr)]),(Mev[(Sqr)]))endifcall cjo(ure[oSx],x,y,z,Cqx)
endfunctionfunction Ssr takes integer oSx,real bex,real SSr returns nothing
local integer rLx=oSxlocal real jMx=T3e[rLx]local real jpx=T4e[rLx]local real cJo=T5e[rLx]local integer SIrlocal integer h0rlocal integer Mhoset oSx=Sar()set SIr=iXx()set h0r=cdo(t9e)
set Mho=Moo()set uoe[oSx]=SIr
set ure[oSx]=h0r
set uie[oSx]=Mho
set uae[oSx]=rLx
set une[oSx]=Jbx("FolderRazorBladeDrawBack_StructBlade_StartBlade: set this.targetGroup = UnitList.Create()")set ge[(SIr)]=(oSx)call Mox(Mho,TVe)call m4o(Mho,Nzr("acc",.0))set mCv[(Mho)]=((.0)*1.)
set mFv[(Mho)]=Xkx((function SNr))set mZv[(Mho)]=(oSx)
call Meo(Mho,Nzr("speed",600.))call MUo(Mho,jMx,jpx,cJo)call o9r(Mho,jMx+SSr*(Cos(((((bex)*1.))*1.))),jpx+SSr*(Sin(((((bex)*1.))*1.))),cJo)call Mno(Mho,'qRBD',1.)call Pcr(h0r,(bz[(Mho)]),.0,TYe[rLx])if Sbr(oSx)thencall iDx(TAe,uRe,true,function SCr)endifcall iDx(SIr,Nzr("smooth",.5),true,function Spr)
endfunctionfunction Str takes integer oSx returns nothingset Tye[oSx]=Tye[oSx]-1if(Tye[oSx]==0)thencall ikx(TZe[oSx])call Kpx(T0e[oSx],$FF,$FF,$FF,0)
endifcall oSr((bz[(T1e[oSx])]),T2e[oSx])call Ssr(oSx,Cf*1./ Tre[T_e[oSx]]*Tye[oSx],uUe)endfunctionfunction STr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])call Str(oSx)endfunctionfunction Sur takes integer SUr,integer Swr,integer Cqx,integer rYx,real jMx,real jpx,real cJo returns nothinglocal integer oSx=Srr()local integer p3x=iXx()set TWe[oSx]=Txe[rYx]set Tye[oSx]=Tre[rYx]set TYe[oSx]=Cqx
set Tze[oSx]=Tie[rYx]set TZe[oSx]=p3x
set T_e[oSx]=rYx
set T0e[oSx]=SUr
set T1e[oSx]=Swr
set T2e[oSx]=-(qy[((bz[(Swr)]))])*1./ Tre[rYx]set T3e[oSx]=jMx
set T4e[oSx]=jpx
set T5e[oSx]=cJo
set T6e[oSx]=Tre[rYx]call iDx(p3x,Nzr("interval",Toe[rYx]),true,function STr)
call Str(oSx)endfunctionfunction SWr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=Tle[oSx]local integer rYx=Tpe[oSx]local integer Q9o=Tse[oSx]local real x=(mHv[(Mho)])local real y=(mjv[(Mho)])local real z=(mJv[(Mho)])call iKx(Q9o)call Sxr((oSx))call Sur(TMe[oSx],Mho,Cqx,rYx,x,y,z)
return trueendfunctionfunction Syr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=Tle[oSx]local integer Mho=Tme[oSx]local integer svo=TPe[oSx]local real dVx=Tqe[oSx]local real dEx=TQe[oSx]local integer Iixlocal real Nboset Ose=svoset hf=(ze[(Cqx)])call VKr(Tge,(mHv[(Mho)]),(mjv[(Mho)]),(mJv[(Mho)]),(CQx((gPv),Uvv+(Tpe[oSx]))),TGe)
set Iix=NEo(Tge)
if(Iix!=w)thenset Nbo=TLe[oSx]
loop
if not(I8x((svo),Ob,(Iix)))thencall Ryx((ACx((Iix),(uWe),(uye),(Bi))))call Our(Iix,650.,-200.,(Atan2(((dEx-(GetUnitY(C[((Iix))])))*1.),((dVx-(GetUnitX(C[((Iix))])))*1.))),1.)
call dQx(svo,Iix)call nlo((Cqx),(Iix),((Nbo)*1.),(false),(true))endifset Iix=NEo(Tge)
exitwhen(Iix==w)
endloopendifendfunctionfunction SYr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real rPr=TCe[rYx]local real bex=Ufx(Cqx,dVx-wQo,dEx-wso)local integer oSxlocal integer h0rlocal integer Mholocal integer Q9oset dVx=wQo+rPr*(Cos(((((bex)*1.))*1.)))
set dEx=wso+rPr*(Sin(((((bex)*1.))*1.)))
set oSx=s9r()set h0r=wset Mho=Moo()set Q9o=iXx()set Tle[oSx]=Cqx
set TLe[oSx]=Tde[rYx]set Tme[oSx]=Mho
set TMe[oSx]=h0r
set Tpe[oSx]=rYx
set TPe[oSx]=Jbx("RazorBlade_Event_SpellEffect: set this.targetGroup = UnitList.Create()")set Tqe[oSx]=dVx
set TQe[oSx]=dEx
set Tse[oSx]=Q9o
set ge[(Q9o)]=(oSx)call m4o(Mho,-400.)set mCv[(Mho)]=(((CQx((gPv),Uvv+(rYx))))*1.)
set mFv[(Mho)]=Xkx((function SWr))set mZv[(Mho)]=(oSx)
call Meo(Mho,1100.)call pxo(Mho,Cqx)call o9r(Mho,dVx,dEx,X_x(dVx,dEx)+60.)call Mno(Mho,'qRaz',2.)call iDx(Q9o,uwe,true,function Syr)return trueendfunctionfunction Szr takes nothing returns booleanlocal integer rFx=(bv)call seo((Vv[(rFx)]),TNe,(Mv[(rFx)]))return trueendfunctionfunction SZr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),TNe)return trueendfunctionfunction S_r takes nothing returns nothingcall mro(gPv,Xdx("FolderRazorBlade_StructVamp_Init: call RazorBlade.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function FolderRazorBlade_StructVamp.Event_Learn))",Pv,MI,function Szr))call mro(gPv,Xdx("FolderRazorBlade_StructVamp_Init: call RazorBlade.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderRazorBlade_StructVamp.Event_Learn))",pv,MI,function Szr))call mro(gPv,Xdx("FolderRazorBlade_StructVamp_Init: call RazorBlade.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderRazorBlade_StructVamp.Event_Unlearn))",Av,MI,function SZr))endfunctionfunction S0r takes nothing returns booleanset Tge=O5x()set TGe=Xpx(function s7r)call mro(gPv,Xdx("RazorBlade_Init: call RazorBlade.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RazorBlade.Event_SpellEffect))",ih,MI,function SYr))call S_r()return trueendfunctionfunction S1r takes nothing returns booleancall FAr(function S0r,"RazorBlade_Init")
return trueendfunctionfunction S2r takes nothing returns booleanset uYe=ltx(uze+" (coldnessBuff)")set Pc[(uYe)]=(true)
return trueendfunctionfunction S3r takes nothing returns booleanset uZe[1]=2
set uZe[2]=2.5set uZe[3]=3
set u_e[1]=4
set u_e[2]=5
set u_e[3]=6
return trueendfunctionfunction S4r takes nothing returns booleancall VNx(ma,(function S2r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RelentlessShiver.page\\RelentlessShiver.struct\\Buff\\obj_coldnessBuff_wc3buff.j"))call VNx(va,(function S3r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RelentlessShiver.page\\RelentlessShiver.struct\\Buff\\obj_this_wc3obj.j"))return trueendfunctionfunction S5r takes nothing returns booleanset u0e=VXx(uze)
return trueendfunctionfunction S6r takes nothing returns booleanset u1e[1]=$Aset u1e[2]=20set u1e[3]=30return trueendfunctionfunction S7r takes nothing returns booleancall VNx(va,(function S6r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RelentlessShiver.page\\RelentlessShiver.struct\\Missile\\obj_this_wc3obj.j"))return trueendfunctionfunction S8r takes nothing returns booleanset u2e=VXx(u3e)
return trueendfunctionfunction S9r takes nothing returns booleancall L1x('AReS',false)set Gfv=L0o('AReS')set K6[(Gfv)]=(g6)set m6[(Gfv)]=(3)set TH[(Gfv)]=("Relentless Shiver")set Rh[(Gfv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00F9)))),(((Aj))))))set oxv[(Gfv)]=(0)set x3v[(Gfv)]=("spell")
call L1o((Gfv),Uvv+(1),((500)*1.))call L1o((Gfv),GH+(1),((80)*1.))
call L1o((Gfv),tH+(1),(($A)*1.))
call L1o((Gfv),Lov+(1),((750)*1.))call L1o((Gfv),Uvv+(2),((500)*1.))call L1o((Gfv),GH+(2),((80)*1.))
call L1o((Gfv),tH+(2),(($A)*1.))
call L1o((Gfv),Lov+(2),((750)*1.))call L1o((Gfv),Uvv+(3),((500)*1.))call L1o((Gfv),GH+(3),((80)*1.))
call L1o((Gfv),tH+(3),(($A)*1.))
call L1o((Gfv),Lov+(3),((750)*1.))set MOv[(Gfv)]=("ReplaceableTextures\\CommandButtons\\BTNAnimateDead.blp")call cDr(Gfv,'FRS0',3,'VRS0','LPRS','LRRS')set u4e[1]=20set u4e[2]=30set u4e[3]=40return trueendfunctionfunction tvr takes nothing returns booleancall L1x('ARSR',false)set u5e=L0o('ARSR')set K6[(u5e)]=(g6)set m6[(u5e)]=(3)set TH[(u5e)]=("Relentless Shiver (Revert)")
set Rh[(u5e)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00F9)))),(((Aj))))))set oxv[(u5e)]=(0)set x3v[(u5e)]=("spell")
call L1o((u5e),Lov+(1),((750)*1.))call L1o((u5e),Lov+(2),((750)*1.))call L1o((u5e),Lov+(3),((750)*1.))set MOv[(u5e)]=("ReplaceableTextures\\CommandButtons\\BTNCorpseExplode.blp")
call cDr(u5e,'FRR0',3,'VRR0','LPRR','LRRR')return trueendfunctionfunction ter takes nothing returns booleanset u6e=Wwx('BReS',"Relentless Shiver",'bReS')set aav[(u6e)]=(true)set Pc[(u6e)]=(true)
set anv[(u6e)]=("ReplaceableTextures\\CommandButtons\\BTNDoom.blp")call lWx(u6e,"RelentlessShiver_page\\RelentlessShiver_struct\\Aura.mdx","origin",ri)
set WU=l_x()
call l2x(WU,Dlv,5)call l2x(WU,nav,.1)call l3x(((u6e)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,Dlv,5)call l2x(WU,nav,.2)call l3x(((u6e)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,Dlv,5)call l2x(WU,nav,.3)call l3x(((u6e)),ZB+(3),(WU))return trueendfunctionfunction txr takes nothing returns booleanset u7e[1]=5
set u7e[2]=5
set u7e[3]=5
set u8e[1]=.1set u8e[2]=.2set u8e[3]=.3return trueendfunctionfunction tor takes nothing returns booleancall VNx(Pa,(function S9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RelentlessShiver.page\\RelentlessShiver.struct\\obj_thisSpell_wc3spell.j"))call VNx(Pa,(function tvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RelentlessShiver.page\\RelentlessShiver.struct\\obj_revertSpell_wc3spell.j"))call VNx(ma,(function ter),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RelentlessShiver.page\\RelentlessShiver.struct\\obj_dummyBuff_wc3buff.j"))call VNx(va,(function txr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RelentlessShiver.page\\RelentlessShiver.struct\\obj_this_wc3obj.j"))
return trueendfunctionfunction trr takes nothing returns booleanset u9e=VXx(Uve)
return trueendfunctionfunction tir takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Wd)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction tar takes integer oSx returns integerset UAe[oSx]=trueset UNe[oSx]=falsecall rEx(u2e)return oSxendfunctionfunction tnr takes nothing returns integerlocal integer oSxif(UXe==8190)thencall o_x("FolderRelentlessShiver_StructMissile_Allocation_allocCustom","call DebugEx(FolderRelentlessShiver_StructMissile.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",u3e+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(UOe[(w)]==w)thenset URe=URe+1set oSx=UReelse
set oSx=UOe[(w)]
set UOe[(w)]=UOe[UOe[(w)]]endifset UOe[oSx]=Zset UIe[oSx]=1call tar(oSx)return oSxendfunctionfunction tVr takes integer oSx returns nothingset UAe[oSx]=falsecall rHx(u2e)endfunctionfunction tEr takes integer oSx returns nothingif(UIe[oSx]>0)thenreturnendifif(UOe[oSx]!=Z)thencall o_x("FolderRelentlessShiver_StructMissile_Allocation_deallocCustom_confirm","call DebugEx(FolderRelentlessShiver_StructMissile.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",u3e+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset UOe[oSx]=UOe[(w)]set UOe[(w)]=oSx
call tVr(oSx)endfunctionfunction tXr takes integer oSx returns nothingset UIe[oSx]=UIe[oSx]-1call tEr(oSx)endfunctionfunction tOr takes integer Cqx,integer rYx,integer Iix returns nothinglocal real iMxif I9x(Iix,Wd)thenset iMx=uZe[rYx]
else
set iMx=u_e[rYx]
endifcall Nbx((Iix),(uYe),(rYx),w,((iMx)*1.))
endfunctionfunction tRr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=Ube[oSx]local integer rYx=UBe[oSx]call tXr((oSx))call MFo(Mho)call tOr(Cqx,rYx,Iix)call nlo((Cqx),(Iix),((u1e[rYx])*1.),(true),(false))
return trueendfunctionfunction tIr takes integer Cqx,integer rYx,integer Iix returns nothinglocal integer oSx=tnr()local integer Mho=Moo()set Ube[oSx]=Cqx
set UBe[oSx]=rYx
set mcv[((Mho))]=((Bev*((.06)*1.))*1.)set mCv[(Mho)]=((8.)*1.)
call Mno(Mho,'qReS',.75)
set mFv[(Mho)]=Xkx((function tRr))set mZv[(Mho)]=(oSx)
call Meo(Mho,500.)call pxo(Mho,Cqx)call M6o((Mho),(Iix),.0,.0,.0,(function M8o))endfunctionfunction tAr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=oSxlocal real O4o=Uoe[oSx]local integer rYx=Uie[oSx]local real tNr=Uae[oSx]local integer Iixcall YCo(Cqx,tNr)if((lF[(Cqx)])<UEe)thencall AZx(Cqx,u6e)endifset hf=(ze[(Cqx)])call NVo(Uee,(GetUnitX(C[((Cqx))])),(GetUnitY(C[((Cqx))])),O4o,Uxe)set Iix=NEo(Uee)
if(Iix!=w)thenloop
call tIr(Cqx,rYx,Iix)set Iix=NEo(Uee)
exitwhen(Iix==w)
endloopendifendfunctionfunction tbr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(hc[(rFx)])local integer oSx=Cqxlocal integer p3x=iXx()set Uoe[oSx]=(CQx((Gfv),Uvv+(rYx)))set Ure[oSx]=p3x
set Uie[oSx]=rYx
set Uae[oSx]=Une[rYx]set ge[(p3x)]=(oSx)call iDx(p3x,UVe,true,function tAr)call LAr((K6[(Gfv)]),u5e,Cqx)return trueendfunctionfunction tBr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oSx=Cqxlocal integer p3x=Ure[oSx]call iKx(p3x)call LAr((K6[(u5e)]),Gfv,Cqx)return trueendfunctionfunction tcr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),u6e)return trueendfunctionfunction tCr takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(u6e),((Mv[(rFx)])),w)return trueendfunctionfunction tdr takes nothing returns nothingendfunctionfunction tDr takes nothing returns booleanlocal integer oMxset Uee=O5x()set Uxe=Xpx(function tir)call Lxx(u6e,Xdx("RelentlessShiver_Init: call RelentlessShiver.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RelentlessShiver.Event_BuffGain))",bd,MI,function tbr))
call Lxx(u6e,Xdx("RelentlessShiver_Init: call RelentlessShiver.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RelentlessShiver.Event_BuffLose))",jc,MI,function tBr))
call mro(u5e,Xdx("RelentlessShiver_Init: call RelentlessShiver.REVERT_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RelentlessShiver.Event_RevertSpellEffect))",ih,MI,function tcr))call mro(Gfv,Xdx("RelentlessShiver_Init: call RelentlessShiver.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RelentlessShiver.Event_SpellEffect))",ih,MI,function tCr))set oMx=(m6[(Gfv)])loop
exitwhen(oMx<1)set Une[oMx]=u4e[oMx]*UVeset oMx=oMx-1endloopcall W2x(nVv,uYe)call tdr()return trueendfunctionfunction tfr takes nothing returns booleancall FAr(function tDr,"RelentlessShiver_Init")return trueendfunctionfunction tFr takes nothing returns booleanset Uce=ltx(UCe+" (dummyBuff)")return trueendfunctionfunction tgr takes nothing returns booleancall VNx(ma,(function tFr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RigorMortis.page\\RigorMortis.struct\\AfterBuff\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction tGr takes nothing returns booleanset Ude=VXx(UCe)
return trueendfunctionfunction thr takes nothing returns booleancall L1x('ARig',false)set Gnv=L0o('ARig')set K6[(Gnv)]=(g6)set m6[(Gnv)]=(3)set TH[(Gnv)]=("Rigor Mortis")set Rh[(Gnv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00C0)))),(((Aj))))))set oxv[(Gnv)]=(0)set x3v[(Gnv)]=("spell")
call L1o((Gnv),GH+(1),(($B4)*1.))call L1o((Gnv),tH+(1),(('d')*1.))call L1o((Gnv),Lov+(1),((750)*1.))call L1o((Gnv),GH+(2),(($A0)*1.))call L1o((Gnv),tH+(2),(($96)*1.))call L1o((Gnv),Lov+(2),((750)*1.))call L1o((Gnv),GH+(3),(($8C)*1.))call L1o((Gnv),tH+(3),(($C8)*1.))call L1o((Gnv),Lov+(3),((750)*1.))set MOv[(Gnv)]=("ReplaceableTextures\\CommandButtons\\BTNStatUp.blp")call cDr(Gnv,'FRe0',3,'VRe0','LPRe','LRRe')set UDe[1]=.3set UDe[2]=.5set UDe[3]=.7set Ufe[1]=.3set Ufe[2]=.5set Ufe[3]=.7return trueendfunctionfunction tHr takes nothing returns booleancall VNx(Pa,(function thr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\RigorMortis.page\\RigorMortis.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction tjr takes nothing returns booleanset UFe=VXx(Uge)
return trueendfunctionfunction tJr takes integer oSx,integer iCx,integer Iix returns nothinglocal integer aLr=Uhe[oSx]call ikx(iCx)call mho(aLr)call RPx(Iix,UGe)endfunctionfunction tkr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall tJr(oSx,UHe[oSx],Iix)return trueendfunctionfunction tKr takes integer oSx,integer rlx returns nothingendfunctionfunction tlr takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local integer rYx=UJe[oSx]local integer Iix=oSxlocal real tLr=UKe[oSx]local real PFr=Ule[oSx]local real dVx=ULe[oSx]local real dEx=Ume[oSx]call tJr(oSx,iCx,Iix)call Ryx((ACx((Iix),(Upe),(UPe),(ri))))call qpo(Iix,dVx,Ume[oSx])call chx(Iix,tLr)call BAx(Iix,PFr)call EPo(Iix,(ze[(Iix)]),true)call Nbx(((Iix)),(Uce),((rYx)),w,((Uqe)*1.))
endfunctionfunction tmr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real dVx=(GetUnitX(C[((Cqx))]))local real dEx=(GetUnitY(C[((Cqx))]))local integer oSxlocal integer iCxcall mho((mko(((dVx)*1.),((dEx)*1.),(Uje),(Bi))))set oSx=Cqxset iCx=iXx()set UHe[oSx]=iCx
set UJe[oSx]=rYx
set Uhe[oSx]=(mko(((dVx)*1.),((dEx)*1.),(Uke),(ri)))
set UKe[oSx]=(oG[(Cqx)])+(rG[(Cqx)])*Ufe[rYx]set Ule[oSx]=(lF[(Cqx)])+(LF[(Cqx)])*UDe[rYx]-(CQx((Gnv),tH+(rYx)))set ULe[oSx]=dVx
set Ume[oSx]=dEx
call Avx(Cqx,UGe)set ge[(iCx)]=(oSx)call tKr(Cqx,Gnv)set NRv[(Cqx)]=(true)call iDx(iCx,UMe,false,function tlr)
call Crx((Cqx),w)return trueendfunctionfunction tMr takes nothing returns nothingcall W2x(nYv,Uce)call W2x(nSv,Uce)call W2x(XAv,Uce)endfunctionfunction tpr takes nothing returns booleanset UGe=Xdx("RigorMortis_Init: set RigorMortis.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RigorMortis.Event_Revive)",XP,MI,function tkr)call mro(Gnv,Xdx("RigorMortis_Init: call RigorMortis.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RigorMortis.Event_SpellEffect))",ih,MI,function tmr))call tMr()return trueendfunctionfunction tPr takes nothing returns booleancall FAr(function tpr,"RigorMortis_Init")return trueendfunctionfunction tqr takes nothing returns booleanreturn trueendfunctionfunction tQr takes nothing returns booleanset UQe=VXx(Use)
return trueendfunctionfunction tsr takes nothing returns booleancall L1x('ASaB',false)set G6v=L0o('ASaB')set K6[(G6v)]=(D6)set m6[(G6v)]=(6)set TH[(G6v)]=("Sake Bomb")set Rh[(G6v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0080)))),(((Aj))))))set oxv[(G6v)]=(2)set x3v[(G6v)]=("spell")
call L1o((G6v),Uvv+(1),(($C8)*1.))call L1o((G6v),GH+(1),((4)*1.))call L1o((G6v),tH+(1),((35)*1.))
call L1o((G6v),Lov+(1),((700)*1.))call L1o((G6v),Uvv+(2),(($E1)*1.))call L1o((G6v),GH+(2),((4)*1.))call L1o((G6v),tH+(2),((40)*1.))
call L1o((G6v),Lov+(2),((700)*1.))call L1o((G6v),Uvv+(3),(($FA)*1.))call L1o((G6v),GH+(3),((4)*1.))call L1o((G6v),tH+(3),((50)*1.))
call L1o((G6v),Lov+(3),((700)*1.))call L1o((G6v),Uvv+(4),((275)*1.))call L1o((G6v),GH+(4),((4)*1.))call L1o((G6v),tH+(4),((65)*1.))
call L1o((G6v),Lov+(4),((700)*1.))call L1o((G6v),Uvv+(5),((300)*1.))call L1o((G6v),GH+(5),((4)*1.))call L1o((G6v),tH+(5),((85)*1.))
call L1o((G6v),Lov+(5),((700)*1.))call L1o((G6v),Uvv+(6),((325)*1.))call L1o((G6v),GH+(6),((4)*1.))call L1o((G6v),tH+(6),((95)*1.))
call L1o((G6v),Lov+(6),((700)*1.))set MOv[(G6v)]=("ReplaceableTextures\\CommandButtons\\BTNDrum.blp")call cDr(G6v,'FSB0',6,'VSB0','LPSB','LRSB')set USe[1]=7.5set USe[2]=8
set USe[3]=8.5set USe[4]=9
set USe[5]=9.5set USe[6]=$Aset Ute[1]=.03set Ute[2]=.03set Ute[3]=.04set Ute[4]=.04set Ute[5]=.05set Ute[6]=.05set UTe[1]=25set UTe[2]=45set UTe[3]=65set UTe[4]=85set UTe[5]='i'set UTe[6]='}'return trueendfunctionfunction tSr takes nothing returns booleanset Uue=Wwx('BSBP',"Poisoned",'bSBP')set Pc[(Uue)]=(true)
set uU[(Uue)]=(true)
set anv[(Uue)]=("ReplaceableTextures\\CommandButtons\\BTNDrum.blp")return trueendfunctionfunction ttr takes nothing returns booleancall VNx(Pa,(function tsr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SakeBomb.page\\SakeBomb.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function tSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SakeBomb.page\\SakeBomb.struct\\obj_poisonBuff_wc3buff.j"))return trueendfunctionfunction tTr takes nothing returns booleanset UUe=VXx(Uwe)
return trueendfunctionfunction tur takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction tUr takes integer oSx returns integerset U0e[oSx]=trueset U1e[oSx]=falsecall rEx(UQe)return oSxendfunctionfunction twr takes nothing returns integerlocal integer oSxif(UYe==8190)thencall o_x("FolderSakeBomb_StructMissile_Allocation_allocCustom","call DebugEx(FolderSakeBomb_StructMissile.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Use+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Uze[(w)]==w)thenset UZe=UZe+1set oSx=UZeelse
set oSx=Uze[(w)]
set Uze[(w)]=Uze[Uze[(w)]]endifset Uze[oSx]=Zset U_e[oSx]=1call tUr(oSx)return oSxendfunctionfunction tWr takes integer oSx returns nothingset U0e[oSx]=falsecall rHx(UQe)endfunctionfunction tyr takes integer oSx returns nothingif(U_e[oSx]>0)thenreturnendifif(Uze[oSx]!=Z)thencall o_x("FolderSakeBomb_StructMissile_Allocation_deallocCustom_confirm","call DebugEx(FolderSakeBomb_StructMissile.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Use+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset Uze[oSx]=Uze[(w)]set Uze[(w)]=oSx
call tWr(oSx)endfunctionfunction tYr takes integer oSx returns nothingset U_e[oSx]=U_e[oSx]-1call tyr(oSx)endfunctionfunction tzr takes integer oSx returns integerset wee[oSx]=trueset wxe[oSx]=falsecall rEx(UUe)return oSxendfunctionfunction tZr takes nothing returns integerlocal integer oSxif(U7e==8190)thencall o_x("SakeBomb_Allocation_allocCustom","call DebugEx(SakeBomb.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",Uwe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(U8e[(w)]==w)thenset U9e=U9e+1set oSx=U9eelse
set oSx=U8e[(w)]
set U8e[(w)]=U8e[U8e[(w)]]endifset U8e[oSx]=Zset wve[oSx]=1call tzr(oSx)return oSxendfunctionfunction t_r takes integer oSx returns nothingset wee[oSx]=falsecall rHx(UUe)endfunctionfunction t0r takes integer oSx returns nothingif(wve[oSx]>0)thenreturnendifif(U8e[oSx]!=Z)thencall o_x("SakeBomb_Allocation_deallocCustom_confirm","call DebugEx(SakeBomb.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",Uwe+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset U8e[oSx]=U8e[(w)]set U8e[(w)]=oSx
call t_r(oSx)endfunctionfunction t1r takes integer oSx returns nothingset wve[oSx]=wve[oSx]-1call t0r(oSx)endfunctionfunction t2r takes nothing returns nothinglocal integer p3x=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(p3x)])local integer zHo=wVe[oSx]-1
local integer t3rlocal real O4olocal integer Cqxlocal real Nbolocal integer HAxlocal real horlocal integer Ctxlocal real x
local real y
local integer rYxlocal integer Iixlocal real d
local real dlrif(zHo==0)thenset t3r=woe[oSx]
set O4o=wre[oSx]
set Cqx=wie[oSx]
set Nbo=wae[oSx]
set HAx=wne[oSx]
set hor=wXe[oSx]
set Ctx=wAe[oSx]
set x=wOe[oSx]set y=wRe[oSx]set rYx=(IH[(Ctx)])call t1r((oSx))call Mfx(t3r)call MGx(HAx)call iKx(p3x)call dNx(Ctx)call mho((mko(((x)*1.),((y)*1.),(wNe),(Bi))))set hf=(ze[(Cqx)])call NVo(UWe,x,y,O4o,Uye)set Iix=NEo(UWe)
if(Iix!=w)thenloop
set d=jKx((GetUnitX(C[((Iix))]))-x,(GetUnitY(C[((Iix))]))-y)
set dlr=ddr(.0,wbe,O4o,wBe,d)call Ydo(Cqx,Iix,(LF[(Iix)])*Ute[rYx])call nlo((Cqx),(Iix),((dlr*Nbo*(1.+Rlo((XFv[(Iix)]))*wce))*1.),(true),(true))call Nbx((Iix),(Uue),(rYx),w,((hor)*1.))
set Iix=NEo(UWe)
exitwhen(Iix==w)
endloopendifelse
set wVe[oSx]=zHo
call ccx(iSx((I2S((zHo))),iYx(1.-zHo*.05,.25,.0,.0)),.034-zHo*.003,wOe[oSx],wRe[oSx],wIe[oSx]+60.,(0))endifendfunctionfunction t4r takes integer Cqx,integer rYx,real dVx,real dEx,integer Ctx returns nothing
local real O4o=(CQx((G6v),Uvv+(rYx)))local real hor=USe[rYx]local real MQx=X_x(dVx,dEx)local integer oSx=tZr()local integer t3r=mDx('qSBA',dVx,dEx,MQx,kf)
local integer HAx=mDx('qSaB',dVx,dEx,MQx,kf)
local integer p3x=iXx()local integer Iixset woe[oSx]=t3r
set wre[oSx]=O4o
set wie[oSx]=Cqx
set wae[oSx]=UTe[rYx]set wne[oSx]=HAx
set wVe[oSx]=(R2I(((wEe)*1.)))set wXe[oSx]=hor
set wOe[oSx]=dVx
set wRe[oSx]=dEx
set wIe[oSx]=MQx
set wAe[oSx]=Ctx
set ge[(p3x)]=(oSx)call k5o(t3r,O4o*1./(256.*1./ 5))call mdx(t3r,$FF,$FF,$FF,$7F)call iDx(p3x,1.,true,function t2r)set hf=(ze[(Cqx)])call NVo(UWe,dVx,dEx,O4o,Uye)set Iix=NEo(UWe)
if(Iix!=w)thenloop
call Ryx((ACx((Iix),(wCe),(wde),(Bi))))call Nbx((Iix),(Uue),(rYx),w,((hor)*1.))
set Iix=NEo(UWe)
exitwhen(Iix==w)
endloopendifendfunctionfunction t5r takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=U2e[oSx]local integer rYx=U3e[oSx]local real dVx=U4e[oSx]local real dEx=U5e[oSx]local integer Ctx=U6e[oSx]call tYr((oSx))call MFo(Mho)call t4r(Cqx,rYx,dVx,dEx,Ctx)return trueendfunctionfunction t6r takes integer Cqx,integer rYx,real dVx,real dEx,integer Ctx returns nothing
local integer oSx=twr()local integer Mho=Moo()set U2e[oSx]=Cqx
set U3e[oSx]=rYx
set U4e[oSx]=dVx
set U5e[oSx]=dEx
set U6e[oSx]=Ctx
set mcv[((Mho))]=((Bev*((.5)*1.))*1.)set mCv[(Mho)]=((32.)*1.)call Mno(Mho,'qSBM',1.)set mFv[(Mho)]=Xkx((function t5r))set mZv[(Mho)]=(oSx)
call Meo(Mho,700.)call pxo(Mho,Cqx)call o9r(Mho,dVx,dEx,X_x(dVx,dEx))endfunctionfunction t7r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])call t6r(Cqx,(Mv[(rFx)]),(yH[(rFx)]),(YH[(rFx)]),CPx(Cqx,G6v))return trueendfunctionfunction t8r takes nothing returns booleanset UWe=O5x()set Uye=Xpx(function tur)call mro(G6v,Xdx("SakeBomb_Init: call SakeBomb.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SakeBomb.Event_SpellEffect))",ih,MI,function t7r))call W2x(XDv,Uue)return trueendfunctionfunction t9r takes nothing returns booleancall FAr(function t8r,"SakeBomb_Init")return trueendfunctionfunction Tvr takes nothing returns booleancall L1x('ASaE',false)set GFv=L0o('ASaE')set K6[(GFv)]=(G6)set m6[(GFv)]=(3)set TH[(GFv)]=("Sanguine Eyes")set Rh[(GFv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0215)))),(((Aj))))))set oxv[(GFv)]=(4)set x3v[(GFv)]=("spell")
call L1o((GFv),GH+(1),(($96)*1.))call L1o((GFv),tH+(1),(($8C)*1.))call L1o((GFv),Lov+(1),(($7D0)*1.))call L1o((GFv),GH+(2),(($96)*1.))call L1o((GFv),tH+(2),(($AA)*1.))call L1o((GFv),Lov+(2),(($7D0)*1.))call L1o((GFv),GH+(3),(($96)*1.))call L1o((GFv),tH+(3),(($C8)*1.))call L1o((GFv),Lov+(3),(($7D0)*1.))set MOv[(GFv)]=("ReplaceableTextures\\CommandButtons\\BTNOrbofSlowness.blp")
call cDr(GFv,'FSE0',3,'VSE0','LPSE','LRSE')set wDe[1]=.3set wDe[2]=.5set wDe[3]=.7set wfe[1]=20set wfe[2]=20set wfe[3]=20return trueendfunctionfunction Ter takes nothing returns booleanset wFe=Wwx('BSaE',"Sanguine Eyes",'bSaE')set aav[(wFe)]=(true)set uU[(wFe)]=(true)
set anv[(wFe)]=("ReplaceableTextures\\CommandButtons\\BTNOrbofSlowness.blp")
call lWx(wFe,"Abilities\\Spells\\Other\\Doom\\DoomTarget.mdl","origin",ri)return trueendfunctionfunction Txr takes nothing returns booleancall VNx(Pa,(function Tvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SanguineEyes.page\\SanguineEyes.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function Ter),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SanguineEyes.page\\SanguineEyes.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction Tor takes nothing returns booleanset wge=VXx(wGe)
return trueendfunctionfunction Trr takes nothing returns booleanlocal integer rFx=(bv)local real Nbo=(E1v[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall mao(wHe[oSx],wHe[oSx],Nbo*wje[oSx])
return trueendfunctionfunction Tir takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Lc[(rFx)])local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixset wHe[oSx]=Cqx
set wje[oSx]=wDe[rYx]call Avx(Iix,whe)return trueendfunctionfunction Tar takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall RPx(Iix,whe)call DXx((wHe[oSx]),(GFv))return trueendfunctionfunction Tnr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])call Nbx(Iix,wFe,rYx,Cqx,wfe[rYx])return trueendfunctionfunction TVr takes nothing returns booleanset whe=Xdx("SanguineEyes_Init: set SanguineEyes.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.SPELLS, function SanguineEyes.Event_Damage)",E3v,MI,function Trr)call Lxx(wFe,Xdx("SanguineEyes_Init: call SanguineEyes.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SanguineEyes.Event_BuffGain))",bd,MI,function Tir))
call Lxx(wFe,Xdx("SanguineEyes_Init: call SanguineEyes.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SanguineEyes.Event_BuffLose))",jc,MI,function Tar))
call mro(GFv,Xdx("SanguineEyes_Init: call SanguineEyes.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SanguineEyes.Event_SpellEffect))",ih,MI,function Tnr))call W2x(Eqv,wFe)call W2x(iiv,wFe)call W2x(x5v,wFe)return trueendfunctionfunction TEr takes nothing returns booleancall FAr(function TVr,"SanguineEyes_Init")return trueendfunctionfunction TXr takes nothing returns booleanset wJe=Wwx('BBub',"Protected by a bubble",'bBub')set aav[(wJe)]=(true)set Pc[(wJe)]=(true)
set anv[(wJe)]=("ReplaceableTextures\\CommandButtons\\BTNBigBadVoodooSpell.blp")
call lWx(wJe,"Abilities\\Spells\\Orc\\Voodoo\\VoodooAuraTarget.mdl","overhead",ri)set WU=l_x()
call vAr(WU,DRv,true)call l3x(((wJe)),ZB+(1),(WU))set WU=l_x()
call vAr(WU,DRv,true)call l3x(((wJe)),ZB+(2),(WU))set WU=l_x()
call vAr(WU,DRv,true)call l3x(((wJe)),ZB+(3),(WU))return trueendfunctionfunction TOr takes nothing returns booleancall VNx(ma,(function TXr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ShamanicBubble.page\\ShamanicBubble.struct\\Target\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction TRr takes nothing returns booleanset wke=VXx(wKe)
return trueendfunctionfunction TIr takes nothing returns booleanset wle=ltx(wLe+" (dummyBuff)")set Pc[(wle)]=(true)
call lWx(wle,"Abilities\\Spells\\Human\\Polymorph\\PolyMorphTarget.mdl","origin",ri)
return trueendfunctionfunction TAr takes nothing returns booleancall VNx(ma,(function TIr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ShamanicBubble.page\\ShamanicBubble.struct\\Transition\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction TNr takes nothing returns booleanset wme=VXx(wLe)
return trueendfunctionfunction Tbr takes nothing returns booleanset wMe=ltx(wpe+" (dummyBuff)")call lWx(wMe,"Abilities\\Spells\\Other\\Doom\\DoomTarget.mdl","origin",ri)call lWx(wMe,"Abilities\\Spells\\Undead\\Unsummon\\UnsummonTarget.mdl","origin",Bi)set WU=l_x()
call l2x(WU,Egv,.2)call l3x(((wMe)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,Egv,.3)call l3x(((wMe)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,Egv,.4)call l3x(((wMe)),ZB+(3),(WU))return trueendfunctionfunction TBr takes nothing returns booleancall L1x('ABub',false)set g_v=L0o('ABub')set K6[(g_v)]=(g6)set m6[(g_v)]=(3)set TH[(g_v)]=("ShamanicBubble")
set Rh[(g_v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0217)))),(((Aj))))))set oxv[(g_v)]=(2)set x3v[(g_v)]=("spell")
call L1o((g_v),Uvv+(1),((500)*1.))call L1o((g_v),dH+(1),(($A)*1.))
call L1o((g_v),GH+(1),((90)*1.))
call L1o((g_v),tH+(1),(($FA)*1.))call L1o((g_v),Lov+(1),((675)*1.))call L1o((g_v),Uvv+(2),((600)*1.))call L1o((g_v),dH+(2),(($D)*1.))
call L1o((g_v),GH+(2),((80)*1.))
call L1o((g_v),tH+(2),(($FA)*1.))call L1o((g_v),Lov+(2),((675)*1.))call L1o((g_v),Uvv+(3),((700)*1.))call L1o((g_v),dH+(3),((16)*1.))
call L1o((g_v),GH+(3),((70)*1.))
call L1o((g_v),tH+(3),(($FA)*1.))call L1o((g_v),Lov+(3),((675)*1.))set MOv[(g_v)]=("ReplaceableTextures\\CommandButtons\\BTNBigBadVoodooSpell.blp")
call cDr(g_v,'FBu0',3,'VBu0','LPBu','LRBu')set wPe[1]=.2set wPe[2]=.3set wPe[3]=.4return trueendfunctionfunction Tcr takes nothing returns booleancall VNx(ma,(function Tbr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ShamanicBubble.page\\ShamanicBubble.struct\\obj_dummyBuff_wc3buff.j"))call VNx(Pa,(function TBr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\ShamanicBubble.page\\ShamanicBubble.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction TCr takes nothing returns booleanset wqe=VXx(wpe)
return trueendfunctionfunction Tdr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif not(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction TDr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer Xur=XQr(Iix)set wse[oSx]=Xur
set wSe[oSx]=rYx
set Ene[(Xur)]=(oSx)
set vqe[(Xur)]=(((CQx((g_v),Uvv+(rYx))))*1.)
set vQe[(Xur)]=(wQe)
call Xsr(Xur,wte)call Xsr(Xur,wTe)call Xtr(Xur)return trueendfunctionfunction Tfr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer Xur=wse[oSx]call X5r(Xur)return trueendfunctionfunction TFr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])call AZx(Cqx,wle)call AZx(Cqx,wMe)return trueendfunctionfunction Tgr takes integer Ctx returns nothingset wue=Ctxcall Nbx(((EH[(Ctx)])),(wle),(1),w,((wUe)*1.))endfunctionfunction TGr takes nothing returns booleanlocal integer rFx=(bv)call Tgr((WH[(rFx)]))return trueendfunctionfunction Thr takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer rLx=(Ene[(Xur)])call Ulx(Iix,wJe)return trueendfunctionfunction THr takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer Cqx=(vke[(Xur)])local integer rLx=(Ene[(Xur)])local integer rYx=wSe[rLx]call Dux((Iix),(wJe),(rYx),w)return trueendfunctionfunction Tjr takes nothing returns nothingset wte=Xdx("FolderShamanicBubble_StructTarget_Init: set FolderShamanicBubble_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderShamanicBubble_StructTarget.Event_Ending)",vTe,MI,function Thr)set wTe=Xdx("FolderShamanicBubble_StructTarget_Init: set FolderShamanicBubble_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderShamanicBubble_StructTarget.Event_Start)",vue,MI,function THr)endfunctionfunction TJr takes integer Ctx returns nothinglocal integer Cqx=(EH[(Ctx)])local integer rYx=(IH[(Ctx)])local real dVx=(yh[(Ctx)])local real dEx=(Yh[(Ctx)])call Jpr(Cqx,dVx,dEx,X_x(dVx,dEx))call Dux((Cqx),(wMe),(rYx),w)endfunctionfunction Tkr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxcall AZx(Iix,wle)call TJr(wye[oSx])endfunctionfunction TKr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer Tlr=wuelocal real fvx=(eb[(Iix)])local integer oSx=Iixlocal integer Okx=iXx()set wwe[oSx]=Okx
set wWe[oSx]=fvx
set wye[oSx]=Tlr
set ge[(Okx)]=(oSx)call D9x((Iix),-((fvx)*1.),((wUe)*1.))call iDx(Okx,wUe,false,function Tkr)
return trueendfunctionfunction TLr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer Okx=wwe[oSx]local real fvx=wWe[oSx]call iKx(Okx)call D9x(Iix,fvx,wUe)return trueendfunctionfunction Tmr takes nothing returns nothingcall Lxx(wle,Xdx("FolderShamanicBubble_StructTransition_Init: call FolderShamanicBubble_StructTransition.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderShamanicBubble_StructTransition.Event_BuffGain))",bd,MI,function TKr))call Lxx(wle,Xdx("FolderShamanicBubble_StructTransition_Init: call FolderShamanicBubble_StructTransition.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderShamanicBubble_StructTransition.Event_BuffLose))",jc,MI,function TLr))endfunctionfunction TMr takes nothing returns booleanset wQe=Xpx(function Tdr)call Lxx(wMe,Xdx("ShamanicBubble_Init: call ShamanicBubble.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ShamanicBubble.Event_BuffGain))",bd,MI,function TDr))call Lxx(wMe,Xdx("ShamanicBubble_Init: call ShamanicBubble.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ShamanicBubble.Event_BuffLose))",jc,MI,function Tfr))call mro(g_v,Xdx("ShamanicBubble_Init: call ShamanicBubble.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ShamanicBubble.Event_EndCast))",onv,MI,function TFr))
call mro(g_v,Xdx("ShamanicBubble_Init: call ShamanicBubble.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ShamanicBubble.Event_SpellEffect))",ih,MI,function TGr))call Tjr()call Tmr()return trueendfunctionfunction Tpr takes nothing returns booleancall FAr(function TMr,"ShamanicBubble_Init")
return trueendfunctionfunction TPr takes nothing returns booleanset wYe=ltx(wze+" (coldnessBuff)")set Pc[(wYe)]=(true)
return trueendfunctionfunction Tqr takes nothing returns booleanset wZe=Wwx('BSDA',"Sleeping Draft",'bSDA')set aav[(wZe)]=(true)set anv[(wZe)]=("ReplaceableTextures\\CommandButtons\\BTNGreaterInvulneralbility.blp")call lWx(wZe,"Abilities\\Spells\\Items\\VampiricPotion\\VampPotionCaster.mdl","origin",ri)set WU=l_x()
call l2x(WU,nnv,.3)call l3x(((wZe)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,nnv,.4)call l3x(((wZe)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,nnv,.5)call l3x(((wZe)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,nnv,.6)call l3x(((wZe)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,nnv,.7)call l3x(((wZe)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,nnv,.8)call l3x(((wZe)),ZB+(6),(WU))return trueendfunctionfunction TQr takes nothing returns booleanset w_e[1]=3
set w_e[2]=3
set w_e[3]=3
set w_e[4]=3
set w_e[5]=3
set w_e[6]=3
set w0e[1]=6
set w0e[2]=6
set w0e[3]=6
set w0e[4]=6
set w0e[5]=6
set w0e[6]=6
return trueendfunctionfunction Tsr takes nothing returns booleancall VNx(ma,(function TPr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SleepingDraft.page\\SleepingDraft.struct\\Buff\\obj_coldnessBuff_wc3buff.j"))call VNx(ma,(function Tqr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SleepingDraft.page\\SleepingDraft.struct\\Buff\\obj_dummyBuff_wc3buff.j"))call VNx(va,(function TQr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SleepingDraft.page\\SleepingDraft.struct\\Buff\\obj_this_wc3obj.j"))
return trueendfunctionfunction TSr takes nothing returns booleanset w1e=VXx(wze)
return trueendfunctionfunction Ttr takes nothing returns booleanset w2e=Wwx('BSDB',"Sleep",'bSDB')set Pc[(w2e)]=(true)
set uU[(w2e)]=(true)
set anv[(w2e)]=("ReplaceableTextures\\CommandButtons\\BTNPotionOfClarity.blp")return trueendfunctionfunction TTr takes nothing returns booleancall L1x('ASlD',false)set G5v=L0o('ASlD')set K6[(G5v)]=(O6)set m6[(G5v)]=(6)set TH[(G5v)]=("Sleeping Draft")
set Rh[(G5v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0103)))),(((Aj))))))set oxv[(G5v)]=(4)set x3v[(G5v)]=("spell")
call L1o((G5v),Uvv+(1),((350)*1.))call L1o((G5v),GH+(1),((16)*1.))
call L1o((G5v),tH+(1),(('x')*1.))call L1o((G5v),Lov+(1),((700)*1.))call L1o((G5v),Uvv+(2),((350)*1.))call L1o((G5v),GH+(2),(($F)*1.))
call L1o((G5v),tH+(2),(('x')*1.))call L1o((G5v),Lov+(2),((700)*1.))call L1o((G5v),Uvv+(3),((350)*1.))call L1o((G5v),GH+(3),(($E)*1.))
call L1o((G5v),tH+(3),(('x')*1.))call L1o((G5v),Lov+(3),((700)*1.))call L1o((G5v),Uvv+(4),((350)*1.))call L1o((G5v),GH+(4),(($D)*1.))
call L1o((G5v),tH+(4),(('x')*1.))call L1o((G5v),Lov+(4),((700)*1.))call L1o((G5v),Uvv+(5),((350)*1.))call L1o((G5v),GH+(5),(($C)*1.))
call L1o((G5v),tH+(5),(('x')*1.))call L1o((G5v),Lov+(5),((700)*1.))call L1o((G5v),Uvv+(6),((350)*1.))call L1o((G5v),GH+(6),(($B)*1.))
call L1o((G5v),tH+(6),(('x')*1.))call L1o((G5v),Lov+(6),((700)*1.))set MOv[(G5v)]=("ReplaceableTextures\\CommandButtons\\BTNPotionOfClarity.blp")call cDr(G5v,'FSD0',6,'VSD0','LPSD','LRSD')set w3e[1]=3
set w3e[2]=4
set w3e[3]=5
set w3e[4]=6
set w3e[5]=7
set w3e[6]=8
set w4e[1]=6
set w4e[2]=8
set w4e[3]=$Aset w4e[4]=$Cset w4e[5]=$Eset w4e[6]=16set w5e[1]=25set w5e[2]=35set w5e[3]=45set w5e[4]=55set w5e[5]=60set w5e[6]=65set w6e[1]=2
set w6e[2]=3
set w6e[3]=4
set w6e[4]=5
set w6e[5]=6
set w6e[6]=7
return trueendfunctionfunction Tur takes nothing returns booleancall VNx(ma,(function Ttr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SleepingDraft.page\\SleepingDraft.struct\\obj_sleepBuff_wc3buff.j"))
call VNx(Pa,(function TTr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SleepingDraft.page\\SleepingDraft.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction TUr takes nothing returns booleanset w7e=VXx(w8e)
return trueendfunctionfunction Twr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction TWr takes integer oSx returns integerset Wie[oSx]=trueset Wae[oSx]=falsecall rEx(w7e)return oSxendfunctionfunction Tyr takes nothing returns integerlocal integer oSxif(Wee==8190)thencall o_x("SleepingDraft_Allocation_allocCustom","call DebugEx(SleepingDraft.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",w8e+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(Wxe[(w)]==w)thenset Woe=Woe+1set oSx=Woeelse
set oSx=Wxe[(w)]
set Wxe[(w)]=Wxe[Wxe[(w)]]endifset Wxe[oSx]=Zset Wre[oSx]=1call TWr(oSx)return oSxendfunctionfunction TYr takes integer oSx returns nothingset Wie[oSx]=falsecall rHx(w7e)endfunctionfunction Tzr takes integer oSx returns nothingif(Wre[oSx]>0)thenreturnendifif(Wxe[oSx]!=Z)thencall o_x("SleepingDraft_Allocation_deallocCustom_confirm","call DebugEx(SleepingDraft.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",w8e+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset Wxe[oSx]=Wxe[(w)]set Wxe[(w)]=oSx
call TYr(oSx)endfunctionfunction TZr takes integer oSx returns nothingset Wre[oSx]=Wre[oSx]-1call Tzr(oSx)endfunctionfunction T_r takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local real x=(mHv[(Mho)])local real y=(mjv[(Mho)])local integer Cqx=Wne[oSx]local integer rYx=WVe[oSx]local integer EDrlocal integer Iixlocal integer oMxcall TZr((oSx))call MFo(Mho)set hf=(ze[(Cqx)])call NVo(w9e,x,y,(CQx((G5v),Uvv+(rYx))),Wve)
set EDr=w3e[rYx]
if(EDr>0)thenset Iix=(mKo((w9e),((x)*1.),((y)*1.)))if(Iix!=w)thenset oMx=1loop
call GroupRemoveUnit(kb[(w9e)],C[(Iix)])
call Ryx((ACx((Iix),(WEe),(WXe),(ri))))if I9x(Iix,Wd)thencall Nbx((Iix),(w2e),(rYx),w,((w6e[rYx])*1.))else
call Nbx((Iix),(w2e),(rYx),w,((w4e[rYx])*1.))endifset oMx=oMx+1exitwhen(oMx>EDr)set Iix=(mKo((w9e),((x)*1.),((y)*1.)))exitwhen(Iix==w)
endloopendifendifreturn trueendfunctionfunction T0r takes integer rYx,integer Iix returns nothingcall Nbx((Iix),(wZe),(rYx),w,((w0e[rYx])*1.))endfunctionfunction T1r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local integer oSx=Tyr()local integer Mho=Moo()set Wne[oSx]=Cqx
set WVe[oSx]=rYx
set mcv[((Mho))]=((Bev*((.2)*1.))*1.)set mCv[(Mho)]=((10.)*1.)call Mno(Mho,'qSle',1.5)
set mFv[(Mho)]=Xkx((function T_r))set mZv[(Mho)]=(oSx)
call Meo(Mho,700.)call Mso((Mho),(Cqx),.0,.0,.0)call M6o((Mho),(Iix),.0,.0,.0,(null))call T0r(rYx,Cqx)call mVo(Cqx,Cqx,(NTv[(Cqx)])*WOe+w5e[rYx])return trueendfunctionfunction T2r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(E2v[(rFx)])local integer w2o=(zH[(rFx)])local integer oSx=Iixlocal integer rYx=WIe[oSx]call Nbx((w2o),(wYe),(rYx),w,((w_e[rYx])*1.))call Ryx((ACx((w2o),("Abilities\\Weapons\\LichMissile\\LichMissile.mdl"),("chest"),(Bi))))return trueendfunctionfunction T3r takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixset WIe[oSx]=rYx
call Avx(Iix,WRe)return trueendfunctionfunction T4r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall RPx(Iix,WRe)return trueendfunctionfunction T5r takes nothing returns nothingset WRe=Xdx("FolderSleepingDraft_StructBuff_Init: set FolderSleepingDraft_StructBuff.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function FolderSleepingDraft_StructBuff.Event_Damage)",E4v,MI,function T2r)call Lxx(wZe,Xdx("FolderSleepingDraft_StructBuff_Init: call FolderSleepingDraft_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSleepingDraft_StructBuff.Event_BuffGain))",bd,MI,function T3r))call Lxx(wZe,Xdx("FolderSleepingDraft_StructBuff_Init: call FolderSleepingDraft_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSleepingDraft_StructBuff.Event_BuffLose))",jc,MI,function T4r))call W2x(nVv,wYe)endfunctionfunction T6r takes nothing returns booleanset w9e=O5x()set Wve=Xpx(function Twr)call mro(G5v,Xdx("SleepingDraft_Init: call SleepingDraft.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SleepingDraft.Event_SpellEffect))",ih,MI,function T1r))
call W2x(XPv,w2e)call T5r()return trueendfunctionfunction T7r takes nothing returns booleancall FAr(function T6r,"SleepingDraft_Init")return trueendfunctionfunction T8r takes nothing returns booleanreturn trueendfunctionfunction T9r takes nothing returns booleanset WAe=VXx(WNe)
return trueendfunctionfunction uvr takes nothing returns booleancall L1x('ASoU',false)set G8v=L0o('ASoU')set K6[(G8v)]=(G6)set m6[(G8v)]=(3)set TH[(G8v)]=("Sober up")set Rh[(G8v)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00C4)))),(((Aj))))))set oxv[(G8v)]=(0)set x3v[(G8v)]=("spell")
call L1o((G8v),Uvv+(1),((750)*1.))call L1o((G8v),dH+(1),((.5)*1.))
call L1o((G8v),GH+(1),(('x')*1.))call L1o((G8v),tH+(1),(($96)*1.))call L1o((G8v),Lov+(1),((750)*1.))call L1o((G8v),Uvv+(2),((750)*1.))call L1o((G8v),dH+(2),((.5)*1.))
call L1o((G8v),GH+(2),(('d')*1.))call L1o((G8v),tH+(2),(($96)*1.))call L1o((G8v),Lov+(2),((750)*1.))call L1o((G8v),Uvv+(3),((750)*1.))call L1o((G8v),dH+(3),((.5)*1.))
call L1o((G8v),GH+(3),((80)*1.))
call L1o((G8v),tH+(3),(($96)*1.))call L1o((G8v),Lov+(3),((750)*1.))set MOv[(G8v)]=("ReplaceableTextures\\CommandButtons\\BTNStormEarth&Fire.blp")call cDr(G8v,'FSU0',3,'VSU0','LPSU','LRSU')set Wbe[1]=35set Wbe[2]=50set Wbe[3]=65set WBe[1]=3.5set WBe[2]=5
set WBe[3]=6.5set Wce[1]=5
set Wce[2]=7
set Wce[3]=9
set WCe[1]=$Fset WCe[2]=30set WCe[3]=35return trueendfunctionfunction uer takes nothing returns booleanset Wde=ltx(WDe+" (banishBuff)")
set Pc[(Wde)]=(true)
return trueendfunctionfunction uxr takes nothing returns booleancall VNx(Pa,(function uvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SoberUp.page\\SoberUp.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function uer),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SoberUp.page\\SoberUp.struct\\obj_banishBuff_wc3buff.j"))return trueendfunctionfunction uor takes nothing returns booleanset Wfe=VXx(WDe)
return trueendfunctionfunction urr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifreturn truereturn trueendfunctionfunction uir takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real O4o=(CQx((G8v),Uvv+(rYx)))local real x=(GetUnitX(C[((Cqx))]))local real y=(GetUnitY(C[((Cqx))]))local integer oSxcall Nvo(Noo(x,y,WGe,ri,O4o*1./ Whe))set oSx=Cqxset WHe[oSx]=rYx
set Wje[oSx]=xset WJe[oSx]=yreturn trueendfunctionfunction uar takes integer oSx returns integerset Wle[oSx]=trueset WLe[oSx]=falsecall rEx(WAe)return oSxendfunctionfunction unr takes integer oSx returns nothingset Wle[oSx]=falsecall rHx(WAe)endfunctionfunction uVr takes integer Cqx,integer rYx,integer nZx returns nothingcall Ryx((ACx((Cqx),(WPe),(Wqe),(ri))))call mao(Cqx,Cqx,WCe[rYx]*nZx)endfunctionfunction uEr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer nZx=Wme[oSx]local integer Cqx=WMe[oSx]local integer rYx=Wpe[oSx]call unr(oSx)call MFo(Mho)call uVr(Cqx,rYx,nZx)return trueendfunctionfunction uXr takes integer Cqx,integer rYx,integer o0x,integer nZx returns nothinglocal integer Mho=Moo()local integer oSx=uar(Mho)set Wme[oSx]=nZx
set WMe[oSx]=Cqx
set Wpe[oSx]=rYx
set mcv[((Mho))]=((Bev*((.4)*1.))*1.)set mCv[(Mho)]=((32.)*1.)set mFv[(Mho)]=Xkx((function uEr))set mZv[(Mho)]=(oSx)
call Meo(Mho,600.)call pxo(Mho,o0x)call M6o((Mho),(Cqx),.0,.0,.0,(null))call Mno(Mho,'qSUH',1+(nZx*.2))endfunctionfunction uOr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local boolean ELo=(oav[(rFx)])local integer oSx=Cqxlocal integer rYx=WHe[oSx]local real x=Wje[oSx]local real y=WJe[oSx]local real O4o=(CQx((G8v),Uvv+(rYx)))local integer Iixlocal integer C3olocal real uRrlocal integer nZxlocal real Bcrif not ELo thencall DXx((Cqx),(G8v))call BNx(Cqx,(CQx((G8v),tH+(rYx))))return trueendifcall Nvo(Noo(x,y,Wke,Bi,O4o*1./ WKe))call NVo(WFe,x,y,O4o,Wge)set Iix=NEo(WFe)
if(Iix!=w)thenset C3o=(ze[(Cqx)])set uRr=Wbe[rYx]
loop
if(IsUnitAlly(C[(Iix)],vx[(C3o)]))thenset nZx=wCo(Iix,true,false,true)
if(nZx>0)thencall uXr(Cqx,rYx,Iix,nZx)endifelse
call Ryx((ACx((Iix),(WQe),(Wse),(ri))))if I9x(Iix,Wd)thenset Bcr=WBe[rYx]
else
set Bcr=Wce[rYx]
endifcall Nbx((Iix),(Wde),(rYx),w,((Bcr)*1.))
set nZx=aQr(Iix,true,false)if(nZx>0)thencall nlo((Cqx),(Iix),((nZx*uRr)*1.),(true),(false))endifendifset Iix=NEo(WFe)
exitwhen(Iix==w)
endloopendifreturn trueendfunctionfunction uIr takes nothing returns booleanset WFe=O5x()set Wge=Xpx(function urr)call mro(G8v,Xdx("SoberUp_Init: call SoberUp.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoberUp.Event_SpellEffect))",ih,MI,function uir))call mro(G8v,Xdx("SoberUp_Init: call SoberUp.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoberUp.Event_EndCast))",onv,MI,function uOr))call W2x(ERv,Wde)return trueendfunctionfunction uAr takes nothing returns booleancall FAr(function uIr,"SoberUp_Init")return trueendfunctionfunction uNr takes nothing returns booleanset WSe[1]=5
set WSe[2]=7.5set WSe[3]=$Areturn trueendfunctionfunction ubr takes nothing returns booleanset Wte=Wwx('BStI',"Steel Impalement",'bStI')set uU[(Wte)]=(true)
set anv[(Wte)]=("ReplaceableTextures\\CommandButtons\\BTNImpale.blp")call lWx(Wte,"SteelImpalement_page\\SteelImpalement_struct\\Target\\spear.mdx","origin",ri)return trueendfunctionfunction uBr takes nothing returns booleancall VNx(va,(function uNr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SteelImpalement.page\\SteelImpalement.struct\\Target\\obj_this_wc3obj.j"))call VNx(ma,(function ubr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SteelImpalement.page\\SteelImpalement.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction ucr takes nothing returns booleanset WTe=VXx(Wue)
return trueendfunctionfunction uCr takes nothing returns booleancall L1x('AStI',false)set gsv=L0o('AStI')set K6[(gsv)]=(G6)set m6[(gsv)]=(3)set TH[(gsv)]=("Steel Impalement")set Rh[(gsv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00C4)))),(((Aj))))))set oxv[(gsv)]=(0)set x3v[(gsv)]=("slam")call L1o((gsv),Uvv+(1),(($BB8)*1.))call L1o((gsv),dH+(1),(($C)*1.))
call L1o((gsv),GH+(1),(('d')*1.))call L1o((gsv),tH+(1),(($B4)*1.))call L1o((gsv),Lov+(1),((750)*1.))call L1o((gsv),Uvv+(2),(($BB8)*1.))call L1o((gsv),dH+(2),(($C)*1.))
call L1o((gsv),GH+(2),(('d')*1.))call L1o((gsv),tH+(2),(($E1)*1.))call L1o((gsv),Lov+(2),((750)*1.))call L1o((gsv),Uvv+(3),(($BB8)*1.))call L1o((gsv),dH+(3),(($C)*1.))
call L1o((gsv),GH+(3),(('d')*1.))call L1o((gsv),tH+(3),((270)*1.))call L1o((gsv),Lov+(3),((750)*1.))set MOv[(gsv)]=("ReplaceableTextures\\CommandButtons\\BTNImpale.blp")call cDr(gsv,'FSI0',3,'VSI0','LPSI','LRSI')set WUe[1]=50set WUe[2]='d'set WUe[3]=$96set Wwe[1]=3
set Wwe[2]=3
set Wwe[3]=3
return trueendfunctionfunction udr takes nothing returns booleanset WWe=ltx(Wye+" (dummyBuff)")return trueendfunctionfunction uDr takes nothing returns booleancall VNx(Pa,(function uCr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SteelImpalement.page\\SteelImpalement.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function udr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SteelImpalement.page\\SteelImpalement.struct\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction ufr takes nothing returns booleanset WYe=VXx(Wye)
return trueendfunctionfunction uFr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(I8x((Ose),Ob,(Iix)))thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction ugr takes integer Iix,integer Cqx,integer rYx returns nothingcall Ryx((ACx((Iix),(W9e),(yve),(ri))))call n1r(Iix)call Nbx(Iix,Wte,rYx,Cqx,WSe[rYx])endfunctionfunction uGr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=oSxlocal real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real O4o=W0e[oSx]+W1e[oSx]
local integer rYx=(IH[(W6e[oSx])])local integer svo=W3e[oSx]local real uhrlocal real bexlocal integer uHrlocal real iIrlocal integer Iixset W0e[oSx]=O4o
set uhr=cf*O4oset bex=(GetRandomReal(((.0)*1.),((Cf)*1.)))
set uHr=(R2I(((uhr*1./ Nzr("sfxdist",W7e))*1.)))
set iIr=Cf*1./ uHrloop
exitwhen(uHr<1)set bex=bex+iIrcall mho((mko(((wQo+O4o*(Cos(((((bex)*1.))*1.))))*1.),((wso+O4o*(Sin(((((bex)*1.))*1.))))*1.),(W8e),(ri))))set uHr=uHr-1endloopset hf=(ze[(Cqx)])set Ose=svocall NVo(Wze,wQo,wso,O4o,WZe)set Iix=NEo(Wze)
if(Iix!=w)thenloop
call dQx(svo,Iix)call ugr(Iix,Cqx,rYx)call nlo((Cqx),(Iix),((W2e[oSx])*1.),(false),(false))set Iix=NEo(Wze)
exitwhen(Iix==w)
endloopendifendfunctionfunction ujr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])set W0e[oSx]=.0call dWx((W3e[oSx]),Ob)endfunctionfunction uJr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(hc[(rFx)])local integer Ctx=(Lc[(rFx)])local real ukr=Nzr("animspeed",.5)*1.2*1./(CQx((gsv),dH+(rYx)))-1local real KBr=1.5*1./ Wwe[rYx]local integer oSx=Cqxlocal integer Q9o=iXx()local integer uKr=iXx()set W_e[oSx]=ukr
set W0e[oSx]=.0set W1e[oSx]=(CQx((gsv),Uvv+(rYx)))*1./(CQx((gsv),dH+(rYx)))*Wwe[rYx]*KBrset W2e[oSx]=WUe[rYx]set W3e[oSx]=Jbx("SteelImpalement_Event_BuffGain: set this.targetGroup = UnitList.Create()")
set W4e[oSx]=Q9o
set W5e[oSx]=uKr
set W6e[oSx]=Ctx
set ge[(Q9o)]=(oSx)set ge[(uKr)]=(oSx)call Qmr(Cqx,ukr)call Dux((((Cqx))),(iOv),(1),w)call iDx(Q9o,KBr,true,function uGr)call iDx(uKr,(CQx((gsv),dH+(rYx)))*1./ Wwe[rYx],true,function ujr)return trueendfunctionfunction ulr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oSx=Cqxlocal real ukr=W_e[oSx]local integer Q9o=W4e[oSx]local integer uKr=W5e[oSx]call iKx(Q9o)call iKx(uKr)call sxr(Cqx,ukr)call Ulx(((Cqx)),iOv)return trueendfunctionfunction uLr takes nothing returns booleanlocal integer rFx=(bv)call Dux((Vv[(rFx)]),WWe,(Mv[(rFx)]),(WH[(rFx)]))return trueendfunctionfunction umr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),WWe)return trueendfunctionfunction uMr takes nothing returns nothingcall W2x(Esv,Wte)call W2x(x5v,Wte)endfunctionfunction upr takes nothing returns booleanset Wze=O5x()set WZe=Xpx(function uFr)call Lxx(WWe,Xdx("SteelImpalement_Init: call SteelImpalement.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SteelImpalement.Event_BuffGain))",bd,MI,function uJr))call Lxx(WWe,Xdx("SteelImpalement_Init: call SteelImpalement.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SteelImpalement.Event_BuffLose))",jc,MI,function ulr))call mro(gsv,Xdx("SteelImpalement_Init: call SteelImpalement.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SteelImpalement.Event_SpellEffect))",ih,MI,function uLr))call mro(gsv,Xdx("SteelImpalement_Init: call SteelImpalement.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SteelImpalement.Event_EndCast))",onv,MI,function umr))call uMr()return trueendfunctionfunction uPr takes nothing returns booleancall FAr(function upr,"SteelImpalement_Init")return trueendfunctionfunction uqr takes nothing returns booleanset yee=VXx(yxe)
return trueendfunctionfunction uQr takes nothing returns booleancall L1x('ATau',false)set yoe=L0o('ATau')set K6[(yoe)]=(H6)set m6[(yoe)]=(1)set TH[(yoe)]=("Taunt")set x3v[(yoe)]=("spell")
call L1o((yoe),Uvv+(1),((450)*1.))call L1o((yoe),Lov+(1),((750)*1.))return trueendfunctionfunction usr takes nothing returns booleanset yre[1]=hjo('uPoB')call hJo(((yre[1])),ASv,(Idv))set Uj[(yre[1])]=((.95)*1.)set NOv[(yre[1])]=((60)*1.)set NWv[(yre[1])]=((60)*1.)set NPv[(yre[1])]=((270)*1.)
set I8v[(yre[1])]=((2)*1.)set Anv[(yre[1])]=(2)set Nmv[(yre[1])]=((400)*1.)
set NLv[(yre[1])]=((400)*1.)
set NKv[(yre[1])]=((.3)*1.)set Npv[(yre[1])]=((80)*1.)set NMv[(yre[1])]=((80)*1.)set Nlv[(yre[1])]=((.1)*1.)set Ncv[(yre[1])]=(($578)*1.)set Nbv[(yre[1])]=(($578)*1.)set NGv[(yre[1])]=((45)*1.)set Adv[(yre[1])]=(gkv)set AGv[(yre[1])]=((153.6)*1.)set Ahv[((yre[1]))]=((1.*1./((1.35)*1.))*1.)
set AWv[(yre[1])]=((.63)*1.)
set Auv[(yre[1])]=(($E)*1.)set AUv[(yre[1])]=(($E)*1.)set AYv[(yre[1])]=(1)set A_v[(yre[1])]=(5)set A2v[(yre[1])]=(0)set ATv[(yre[1])]=((48)*1.)return trueendfunctionfunction uSr takes nothing returns booleanset yre[2]=hjo('uPB2')call hJo(((yre[2])),ASv,(Idv))set Uj[(yre[2])]=((1.15)*1.)
set NOv[(yre[2])]=((60)*1.)set NWv[(yre[2])]=((60)*1.)set NPv[(yre[2])]=((270)*1.)
set I8v[(yre[2])]=((3)*1.)set Anv[(yre[2])]=(2)set Nmv[(yre[2])]=((500)*1.)
set NLv[(yre[2])]=((500)*1.)
set NKv[(yre[2])]=((.4)*1.)set Npv[(yre[2])]=(('d')*1.)
set NMv[(yre[2])]=(('d')*1.)
set Nlv[(yre[2])]=((.15)*1.)
set Ncv[(yre[2])]=(($578)*1.)set Nbv[(yre[2])]=(($578)*1.)set NGv[(yre[2])]=((55)*1.)set Adv[(yre[2])]=(gkv)set AGv[(yre[2])]=((153.6)*1.)set Ahv[((yre[2]))]=((1.*1./((1.35)*1.))*1.)
set AWv[(yre[2])]=((.63)*1.)
set Auv[(yre[2])]=((18)*1.)set AUv[(yre[2])]=((18)*1.)set AYv[(yre[2])]=(1)set A_v[(yre[2])]=(6)set A2v[(yre[2])]=(0)set ATv[(yre[2])]=((48)*1.)return trueendfunctionfunction utr takes nothing returns booleancall L1x('ASGC',false)set yie=L0o('ASGC')set K6[(yie)]=(D6)set m6[(yie)]=(6)set TH[(yie)]=("Callback")set Rh[(yie)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0272)))),(((Aj))))))set oxv[(yie)]=(0)set x3v[(yie)]=("spell")
call L1o((yie),GH+(1),((0)*1.))call L1o((yie),tH+(1),((5)*1.))call L1o((yie),Lov+(1),((750)*1.))call L1o((yie),GH+(2),((0)*1.))call L1o((yie),tH+(2),((5)*1.))call L1o((yie),Lov+(2),((750)*1.))call L1o((yie),GH+(3),((0)*1.))call L1o((yie),tH+(3),((5)*1.))call L1o((yie),Lov+(3),((750)*1.))call L1o((yie),GH+(4),((0)*1.))call L1o((yie),tH+(4),((5)*1.))call L1o((yie),Lov+(4),((750)*1.))call L1o((yie),GH+(5),((0)*1.))call L1o((yie),tH+(5),((5)*1.))call L1o((yie),Lov+(5),((750)*1.))call L1o((yie),GH+(6),((0)*1.))call L1o((yie),tH+(6),((5)*1.))call L1o((yie),Lov+(6),((750)*1.))set MOv[(yie)]=("ReplaceableTextures\\CommandButtons\\BTNLifeDrain.blp")
call cDr(yie,'FSC0',6,'VSC0','LPSC','LRSC')set yae[1]=.3set yae[2]=.3set yae[3]=.3set yae[4]=.3set yae[5]=.3set yae[6]=.3set yne[1]=$Aset yne[2]=20set yne[3]=30set yne[4]=40set yne[5]=50set yne[6]=60return trueendfunctionfunction uTr takes nothing returns booleanset yre[3]=hjo('uPB3')call hJo(((yre[3])),ASv,(Idv))set Uj[(yre[3])]=((1.25)*1.)
set NOv[(yre[3])]=((60)*1.)set NWv[(yre[3])]=((60)*1.)set NPv[(yre[3])]=((270)*1.)
set I8v[(yre[3])]=((4)*1.)set Anv[(yre[3])]=(2)set Nmv[(yre[3])]=((620)*1.)
set NLv[(yre[3])]=((620)*1.)
set NKv[(yre[3])]=((.5)*1.)set Npv[(yre[3])]=(('x')*1.)
set NMv[(yre[3])]=(('x')*1.)
set Nlv[(yre[3])]=((.2)*1.)set Ncv[(yre[3])]=(($578)*1.)set Nbv[(yre[3])]=(($578)*1.)set NGv[(yre[3])]=((65)*1.)set Adv[(yre[3])]=(gkv)set AGv[(yre[3])]=((153.6)*1.)set Ahv[((yre[3]))]=((1.*1./((1.35)*1.))*1.)
set AWv[(yre[3])]=((.63)*1.)
set Auv[(yre[3])]=((24)*1.)set AUv[(yre[3])]=((24)*1.)set AYv[(yre[3])]=(2)set A_v[(yre[3])]=(4)set A2v[(yre[3])]=(0)set ATv[(yre[3])]=((48)*1.)return trueendfunctionfunction uur takes nothing returns booleanset yre[4]=hjo('uPB4')call hJo(((yre[4])),ASv,(Idv))set Uj[(yre[4])]=((1.35)*1.)
set NOv[(yre[4])]=((60)*1.)set NWv[(yre[4])]=((60)*1.)set NPv[(yre[4])]=((270)*1.)
set I8v[(yre[4])]=((5)*1.)set Anv[(yre[4])]=(2)set Nmv[(yre[4])]=((750)*1.)
set NLv[(yre[4])]=((750)*1.)
set NKv[(yre[4])]=((.5)*1.)set Npv[(yre[4])]=(($8C)*1.)
set NMv[(yre[4])]=(($8C)*1.)
set Nlv[(yre[4])]=((.25)*1.)
set Ncv[(yre[4])]=(($578)*1.)set Nbv[(yre[4])]=(($578)*1.)set NGv[(yre[4])]=((75)*1.)set Adv[(yre[4])]=(gkv)set AGv[(yre[4])]=((153.6)*1.)set Ahv[((yre[4]))]=((1.*1./((1.35)*1.))*1.)
set AWv[(yre[4])]=((.63)*1.)
set Auv[(yre[4])]=((26)*1.)set AUv[(yre[4])]=((26)*1.)set AYv[(yre[4])]=(3)set A_v[(yre[4])]=(4)set A2v[(yre[4])]=(0)set ATv[(yre[4])]=((48)*1.)return trueendfunctionfunction uUr takes nothing returns booleanset yre[5]=hjo('uPB5')call hJo(((yre[5])),ASv,(Idv))set Uj[(yre[5])]=((1.45)*1.)
set NOv[(yre[5])]=((60)*1.)set NWv[(yre[5])]=((60)*1.)set NPv[(yre[5])]=((270)*1.)
set I8v[(yre[5])]=((6)*1.)set Anv[(yre[5])]=(2)set Nmv[(yre[5])]=((900)*1.)
set NLv[(yre[5])]=((900)*1.)
set NKv[(yre[5])]=((.5)*1.)set Npv[(yre[5])]=(($A0)*1.)
set NMv[(yre[5])]=(($A0)*1.)
set Nlv[(yre[5])]=((.3)*1.)set Ncv[(yre[5])]=(($578)*1.)set Nbv[(yre[5])]=(($578)*1.)set NGv[(yre[5])]=((85)*1.)set Adv[(yre[5])]=(gkv)set AGv[(yre[5])]=((153.6)*1.)set Ahv[((yre[5]))]=((1.*1./((1.35)*1.))*1.)
set AWv[(yre[5])]=((.63)*1.)
set Auv[(yre[5])]=((27)*1.)set AUv[(yre[5])]=((27)*1.)set AYv[(yre[5])]=(4)set A_v[(yre[5])]=(4)set A2v[(yre[5])]=(0)set ATv[(yre[5])]=((48)*1.)return trueendfunctionfunction uwr takes nothing returns booleanset yVe[1]=3
set yVe[2]=3.5set yVe[3]=4
set yVe[4]=4.5set yVe[5]=5
set yVe[6]=5.5set yEe[1]=30set yEe[2]=30set yEe[3]=30set yEe[4]=30set yEe[5]=30set yEe[6]=30return trueendfunctionfunction uWr takes nothing returns booleancall VNx(Pa,(function uQr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\obj_tauntSpell_wc3spell.j"))call VNx(sa,(function usr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\obj_summonUnitType[1]_wc3unit.j"))
call VNx(sa,(function uSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\obj_summonUnitType[2]_wc3unit.j"))
call VNx(Pa,(function utr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\obj_callbackSpell_wc3spell.j"))call VNx(sa,(function uTr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\obj_summonUnitType[3]_wc3unit.j"))
call VNx(sa,(function uur),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\obj_summonUnitType[4]_wc3unit.j"))
call VNx(sa,(function uUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\obj_summonUnitType[5]_wc3unit.j"))
call VNx(va,(function uwr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\obj_this_wc3obj.j"))return trueendfunctionfunction uyr takes nothing returns booleanset yXe=VXx(yOe)
return trueendfunctionfunction uYr takes nothing returns booleancall L1x('ASuG',false)set hBv=L0o('ASuG')set K6[(hBv)]=(D6)set m6[(hBv)]=(6)set TH[(hBv)]=("Polar Pal")set Rh[(hBv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0272)))),(((Aj))))))set oxv[(hBv)]=(4)set x3v[(hBv)]=("spell")
call L1o((hBv),GH+(1),((25)*1.))
call L1o((hBv),tH+(1),((85)*1.))
call L1o((hBv),Lov+(1),((650)*1.))call L1o((hBv),GH+(2),((23)*1.))
call L1o((hBv),tH+(2),(('d')*1.))call L1o((hBv),Lov+(2),((650)*1.))call L1o((hBv),GH+(3),((21)*1.))
call L1o((hBv),tH+(3),(('s')*1.))call L1o((hBv),Lov+(3),((650)*1.))call L1o((hBv),GH+(4),((19)*1.))
call L1o((hBv),tH+(4),(($82)*1.))call L1o((hBv),Lov+(4),((650)*1.))call L1o((hBv),GH+(5),((17)*1.))
call L1o((hBv),tH+(5),(($91)*1.))call L1o((hBv),Lov+(5),((650)*1.))call L1o((hBv),GH+(6),(($F)*1.))
call L1o((hBv),tH+(6),(($A0)*1.))call L1o((hBv),Lov+(6),((650)*1.))set MOv[(hBv)]=("ReplaceableTextures\\CommandButtons\\BTNFrostBear.blp")
call cDr(hBv,'FSP0',6,'VSP0','LPSP','LRSP')return trueendfunctionfunction uzr takes nothing returns booleancall VNx(Pa,(function uYr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction uZr takes nothing returns booleanset yRe=VXx(yIe)
return trueendfunctionfunction u_r takes integer oSx returns integerset yce[oSx]=trueset yCe[oSx]=falsecall rEx(yRe)return oSxendfunctionfunction u0r takes nothing returns integerlocal integer oSxif(yAe==8190)thencall o_x("SummonPolarBear_Allocation_allocCustom","call DebugEx(SummonPolarBear.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",yIe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(yNe[(w)]==w)thenset ybe=ybe+1set oSx=ybeelse
set oSx=yNe[(w)]
set yNe[(w)]=yNe[yNe[(w)]]endifset yNe[oSx]=Zset yBe[oSx]=1call u_r(oSx)return oSxendfunctionfunction u1r takes integer oSx returns nothingset yce[oSx]=falsecall rHx(yRe)endfunctionfunction u2r takes integer oSx returns nothingif(yBe[oSx]>0)thenreturnendifif(yNe[oSx]!=Z)thencall o_x("SummonPolarBear_Allocation_deallocCustom_confirm","call DebugEx(SummonPolarBear.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",yIe+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset yNe[oSx]=yNe[(w)]set yNe[(w)]=oSx
call u1r(oSx)endfunctionfunction u3r takes integer oSx returns nothingset yBe[oSx]=yBe[oSx]-1call u2r(oSx)endfunctionfunction u4r takes integer oSx returns nothinglocal integer u5r=yge[oSx]local integer Cqx=yGe[oSx]local integer rYx=yhe[oSx]local real u6r=(oG[(u5r)])call RIr(u5r)call mao(Cqx,Cqx,yne[rYx]+u6r*yae[rYx])endfunctionfunction u7r takes integer oSx returns integerset yKe[oSx]=trueset yle[oSx]=falsecall rEx(yXe)return oSxendfunctionfunction u8r takes nothing returns integerlocal integer oSxif(yHe==8190)thencall o_x("FolderSummonPolarBear_StructSummon_Allocation_allocCustom","call DebugEx(FolderSummonPolarBear_StructSummon.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",yOe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(yje[(w)]==w)thenset yJe=yJe+1set oSx=yJeelse
set oSx=yje[(w)]
set yje[(w)]=yje[yje[(w)]]endifset yje[oSx]=Zset yke[oSx]=1call u7r(oSx)return oSxendfunctionfunction u9r takes integer Cqx,integer rYx,integer Iix,real x,real y returns nothing
local integer oSx=osx(Cqx,yFe)local integer u5rlocal integer C3oif(oSx!=w)thencall u4r(oSx)endifset C3o=(ze[(Cqx)])set u5r=U0o(yre[rYx],C3o,x,y,kf,yEe[rYx])set oSx=u8r()set yge[oSx]=u5r
set yGe[oSx]=Cqx
set yhe[oSx]=rYx
call rwx(u5r,yFe,oSx)call Avx(u5r,yLe)call rwx(Cqx,yFe,oSx)call Avx(Cqx,yme)call LAr(D6,yie,Cqx)
call Nbx((u5r),(aiv),(rYx),w,((yVe[rYx])*1.))call r0x(((u5r)),((yoe)),(1))call Q0x((C3o),B[(yoe)],(true))call Rxx(u5r,g4)
call Q0x((C3o),B[(yoe)],(false))
if(IsUnitAlly(C[(Iix)],vx[(C3o)]))thencall r0x((u5r),(yMe),(rYx))call Nbx((Iix),(aiv),(rYx),w,((yVe[rYx])*1.))else
call r0x((u5r),(yMe),(rYx+1))call Lox((u5r),(Rh[((yMe))]),(Iix))endifendfunctionfunction Uvr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=yde[oSx]local integer rYx=yDe[oSx]local integer Iix=yfe[oSx]local real dVx=(mHv[(Mho)])local real dEx=(mjv[(Mho)])call u3r((oSx))call MFo(Mho)call u9r(Cqx,rYx,Iix,dVx,dEx)return trueendfunctionfunction Uer takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real dVx=(GetUnitX(C[((Iix))]))local real dEx=(GetUnitY(C[((Iix))]))local integer oSx=u0r()local integer Mho=Moo()local integer Uxrset yde[oSx]=Cqx
set yDe[oSx]=rYx
set yfe[oSx]=Iix
set Uxr=yre[rYx]
set mcv[((Mho))]=((Bev*((.06)*1.))*1.)set mCv[(Mho)]=((2*(ATv[(Uxr)]))*1.)
call Mno(Mho,'qSuB',.25)
set mFv[(Mho)]=Xkx((function Uvr))set mZv[(Mho)]=(oSx)
call Meo(Mho,(NPv[(Uxr)])*4.)call pxo(Mho,Cqx)call o9r(Mho,dVx,dEx,X_x(dVx,dEx))return trueendfunctionfunction Uor takes integer oSx returns nothingset yKe[oSx]=falsecall rHx(yXe)endfunctionfunction Urr takes integer oSx returns nothingif(yke[oSx]>0)thenreturnendifif(yje[oSx]!=Z)thencall o_x("FolderSummonPolarBear_StructSummon_Allocation_deallocCustom_confirm","call DebugEx(FolderSummonPolarBear_StructSummon.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",yOe+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset yje[oSx]=yje[(w)]set yje[(w)]=oSx
call Uor(oSx)endfunctionfunction Uir takes integer oSx returns nothingset yke[oSx]=yke[oSx]-1call Urr(oSx)endfunctionfunction Uar takes nothing returns booleanlocal integer rFx=(bv)local integer u5r=(Vv[(rFx)])local integer oSx=osx(u5r,yFe)local integer Cqx=yGe[oSx]call Uir((oSx))call rVx(u5r,yFe)call RPx(u5r,yLe)call rVx(Cqx,yFe)call RPx(Cqx,yme)call LAr(D6,hBv,Cqx)
return trueendfunctionfunction Unr takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=osx((Vv[(rFx)]),yFe)call RIr(yge[oSx])return trueendfunctionfunction UVr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer oSx=osx(Cqx,yFe)call u4r(oSx)return trueendfunctionfunction UEr takes nothing returns nothingset yLe=Xdx("FolderSummonPolarBear_StructSummon_Init: set FolderSummonPolarBear_StructSummon.BEAR_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSummonPolarBear_StructSummon.Event_Bear_Death)",VP,MI,function Uar)set yme=Xdx("FolderSummonPolarBear_StructSummon_Init: set FolderSummonPolarBear_StructSummon.CASTER_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSummonPolarBear_StructSummon.Event_Caster_Death)",VP,MI,function Unr)call mro(yie,Xdx("FolderSummonPolarBear_StructSummon_Init: call FolderSummonPolarBear_StructSummon.CALLBACK_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSummonPolarBear_StructSummon.Event_SpellEffect))",ih,MI,function UVr))endfunctionfunction UXr takes nothing returns booleancall mro(hBv,Xdx("SummonPolarBear_Init: call SummonPolarBear.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SummonPolarBear.Event_SpellEffect))",ih,MI,function Uer))call UEr()return trueendfunctionfunction UOr takes nothing returns booleancall FAr(function UXr,"SummonPolarBear_Init")return trueendfunctionfunction URr takes nothing returns booleancall L1x('AArB',false)set yMe=L0o('AArB')set K6[(yMe)]=(H6)set m6[(yMe)]=(1)set TH[(yMe)]=("Arctic Blink")set Rh[(yMe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D007F)))),(((Aj))))))set oxv[(yMe)]=(4)set x3v[(yMe)]=("spell")
call L1o((yMe),GH+(1),((9)*1.))call L1o((yMe),tH+(1),((40)*1.))
call L1o((yMe),Lov+(1),((800)*1.))set MOv[(yMe)]=("ReplaceableTextures\\CommandButtons\\BTNBearBlink.blp")
set ype[1]=30return trueendfunctionfunction UIr takes nothing returns booleancall VNx(Pa,(function URr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\ArcticBlink.page\\ArcticBlink.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction UAr takes nothing returns booleanset yPe=VXx(yqe)
return trueendfunctionfunction UNr takes integer oSx returns integerset yTe[oSx]=trueset yue[oSx]=falsecall rEx(yPe)return oSxendfunctionfunction Ubr takes nothing returns integerlocal integer oSxif(yQe==8190)thencall o_x("ArcticBlink_Allocation_allocCustom","call DebugEx(ArcticBlink.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",yqe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(yse[(w)]==w)thenset ySe=ySe+1set oSx=ySeelse
set oSx=yse[(w)]
set yse[(w)]=yse[yse[(w)]]endifset yse[oSx]=Zset yte[oSx]=1call UNr(oSx)return oSxendfunctionfunction UBr takes integer oSx returns nothingset yTe[oSx]=falsecall rHx(yPe)endfunctionfunction Ucr takes integer oSx returns nothingif(yte[oSx]>0)thenreturnendifif(yse[oSx]!=Z)thencall o_x("ArcticBlink_Allocation_deallocCustom_confirm","call DebugEx(ArcticBlink.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",yqe+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset yse[oSx]=yse[(w)]set yse[(w)]=oSx
call UBr(oSx)endfunctionfunction UCr takes integer oSx returns nothingset yte[oSx]=yte[oSx]-1call Ucr(oSx)endfunctionfunction Udr takes integer Cqx,integer Iix returns booleanreturn( not(Iix==w))and( not(IsUnitAlly(C[(Iix)],vx[((ze[(Cqx)]))])))and( not(nbo(Iix)))
endfunctionfunction UDr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=yUe[oSx]local integer rYx=ywe[oSx]local integer Iix=yWe[oSx]call UCr((oSx))call MFo(Mho)if Udr(Cqx,Iix)thencall Nbx((Iix),(Xwv),(rYx),w,((yye)*1.))
call nlo((Cqx),(Iix),((ype[rYx])*1.),(true),(false))
endifreturn trueendfunctionfunction Ufr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local integer oSx=Ubr()local integer Mho=Moo()set yUe[oSx]=Cqx
set ywe[oSx]=rYx
set yWe[oSx]=Iix
call SetUnitPosition(C[((Cqx))],(((GetUnitX(C[((Iix))])))*1.),(((GetUnitY(C[((Iix))])))*1.))
call Opr(Cqx,Iix)set mCv[(Mho)]=((10.)*1.)call Mno(Mho,'qArB',2.)set mFv[(Mho)]=Xkx((function UDr))call pxo(Mho,Cqx)set mZv[(Mho)]=(oSx)
call Meo(Mho,700.)call M6o((Mho),(Iix),.0,.0,.0,(null))return trueendfunctionfunction UFr takes nothing returns booleancall mro(yMe,Xdx("ArcticBlink_Init: call ArcticBlink.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ArcticBlink.Event_SpellEffect))",ih,MI,function Ufr))return trueendfunctionfunction Ugr takes nothing returns booleancall moo(function UFr,"ArcticBlink_Init")return trueendfunctionfunction UGr takes nothing returns booleancall L1x('ADev',false)set yYe=L0o('ADev')set K6[(yYe)]=(H6)set m6[(yYe)]=(1)set TH[(yYe)]=("Devour")
set Rh[(yYe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0089)))),(((Aj))))))set oxv[(yYe)]=(4)set x3v[(yYe)]=("spell")
call L1o((yYe),GH+(1),(('x')*1.))call L1o((yYe),Lov+(1),(($96)*1.))set MOv[(yYe)]=("ReplaceableTextures\\CommandButtons\\BTNDevour.blp")return trueendfunctionfunction Uhr takes nothing returns booleancall VNx(Pa,(function UGr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\SummonPolarBear.page\\SummonPolarBear.struct\\Summon\\Devour.page\\Devour.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction UHr takes nothing returns booleanset yze=VXx(yZe)
return trueendfunctionfunction Ujr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])call Dux(((Iix)),O1v,1,(Cqx))return trueendfunctionfunction UJr takes nothing returns booleancall mro(yYe,Xdx("Devour_Init: call Devour.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Devour.Event_SpellEffect))",ih,MI,function Ujr))return trueendfunctionfunction Ukr takes nothing returns booleancall moo(function UJr,"Devour_Init")
return trueendfunctionfunction UKr takes nothing returns booleanset y_e=Wwx('BSuB',"Susanoo",'bSuB')
set aav[(y_e)]=(true)set anv[(y_e)]=("ReplaceableTextures\\CommandButtons\\BTNHowlOfTerror.blp")call lWx(y_e,"Susanoo_page\\Susanoo_struct\\Buff.mdx","overhead",ri)
set WU=l_x()
call l2x(WU,Ehv,.5)call l2x(WU,nnv,.35)
call l3x(((y_e)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,Ehv,1)call l2x(WU,nnv,.6)call l3x(((y_e)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,Ehv,.5)call l2x(WU,nnv,.35)
call l3x(((y_e)),ZB+(3),(WU))return trueendfunctionfunction Ulr takes nothing returns booleancall L1x('ASus',false)set y0e=L0o('ASus')set K6[(y0e)]=(G6)set m6[(y0e)]=(3)set TH[(y0e)]=("Susanoo")set Rh[(y0e)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D026D)))),(((Aj))))))set oxv[(y0e)]=(0)set x3v[(y0e)]=("spell")
call L1o((y0e),GH+(1),((60)*1.))
call L1o((y0e),tH+(1),(('n')*1.))call L1o((y0e),Lov+(1),((750)*1.))call L1o((y0e),GH+(2),((60)*1.))
call L1o((y0e),tH+(2),(($AA)*1.))call L1o((y0e),Lov+(2),((750)*1.))set MOv[(y0e)]=("ReplaceableTextures\\CommandButtons\\BTNHowlOfTerror.blp")call cDr(y0e,'FSa0',3,'VSa0','LPSa','LRSa')set y1e[1]=.35set y1e[2]=.45set y2e[1]=.5set y2e[2]=1
set y3e[1]=$Cset y3e[2]=$Cset y4e[1]=2
set y4e[2]=2
set y5e[1]=.35set y5e[2]=.6return trueendfunctionfunction ULr takes nothing returns booleancall VNx(ma,(function UKr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Susanoo.page\\Susanoo.struct\\obj_dummyBuff_wc3buff.j"))
call VNx(Pa,(function Ulr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Susanoo.page\\Susanoo.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Umr takes nothing returns booleanset y6e=VXx(y7e)
return trueendfunctionfunction UMr takes integer oSx,integer Iax returns integerreturn osx((oSx),Yb+Iax)
endfunctionfunction Upr takes integer oSx,integer Iax,real iMx returns nothinglocal integer rLx=oSxlocal integer iCxset oSx=(IGx(E[((X))],(Cd),(((rLx))),((Iax)),((UMr((oSx),Iax))),(w)))set iCx=jd[oSx]call Nxx((rLx),Iax)set iMx=iMx+(TimerGetRemaining(Oe[(iCx)]))call iDx(iCx,iMx,false,function Nax)
if not(Ud[(Iax)])thenif(I9x(rLx,Wd)or(yd[(Iax)]))then
call NAx((rLx),Iax,iMx)endifendifendfunctionfunction UPr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(fG[(rFx)])local integer oSx=Iixlocal real Uqr=y9e[oSx]set y9e[oSx]=Uqr*(1.+Yve)call Ryx((ACx((Iix),(Yee),(Yxe),(Bi))))call Upr(Iix,y_e,Uqr)return trueendfunctionfunction UQr takes integer oSx,real oux returns nothingset Aov[(oSx)]=(((Aov[(oSx)])+oux)*1.)endfunctionfunction Usr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local real USrlocal integer oSxcall mho((mko((((GetUnitX(C[((Iix))])))*1.),(((GetUnitY(C[((Iix))])))*1.),(Yoe),(ri))))set USr=y1e[rYx]
set oSx=Iixset Yre[oSx]=USr
set y9e[oSx]=y4e[rYx]call UQr(Iix,USr)call Avx(Iix,y8e)return trueendfunctionfunction Utr takes integer oSx,real oux returns nothingset Aov[(oSx)]=(((Aov[(oSx)])-oux)*1.)endfunctionfunction UTr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal real USr=Yre[oSx]call Utr(Iix,USr)call RPx(Iix,y8e)return trueendfunctionfunction Uur takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(Mv[(rFx)])call Nbx(((Vv[(rFx)])),(y_e),(rYx),w,((y3e[rYx])*1.))return trueendfunctionfunction UUr takes nothing returns booleanset y8e=Xdx("Susanoo_Init: set Susanoo.DEATH_EVENT = Event.Create(UNIT.Death.Events.KILLER_EVENT_TYPE, EventPriority.SPELLS, function Susanoo.Event_Death)",BMv,MI,function UPr)
call Lxx(y_e,Xdx("Susanoo_Init: call Susanoo.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Susanoo.Event_BuffGain))",bd,MI,function Usr))call Lxx(y_e,Xdx("Susanoo_Init: call Susanoo.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Susanoo.Event_BuffLose))",jc,MI,function UTr))call mro(y0e,Xdx("Susanoo_Init: call Susanoo.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Susanoo.Event_SpellEffect))",ih,MI,function Uur))return trueendfunctionfunction Uwr takes nothing returns booleancall FAr(function UUr,"Susanoo_Init")return trueendfunctionfunction UWr takes nothing returns booleanset tJ[1]=Wwx('BSW1',"Swiftness 1",'bSW1')set aav[(tJ[1])]=(true)set anv[(tJ[1])]=("ReplaceableTextures\\CommandButtons\\BTNBuff1.blp")call lWx(tJ[1],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)call lWx(tJ[1],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)call lWx(tJ[1],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)call lWx(tJ[1],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)return trueendfunctionfunction Uyr takes nothing returns booleanset Yie[1]=35set Yie[2]=60set Yie[3]=85set Yie[4]='n'set Yie[5]=$87set Yie[6]=$A0set Yae[1]=5
set Yae[2]=8
set Yae[3]=8
set Yae[4]=8
set Yae[5]=8
set Yae[6]=8
return trueendfunctionfunction UYr takes nothing returns booleanset sJ=ltx(Yne+" (timerBuff)")return trueendfunctionfunction Uzr takes nothing returns booleanset tJ[2]=Wwx('BSW2',"Swiftness 2",'bSW2')set aav[(tJ[2])]=(true)set anv[(tJ[2])]=("ReplaceableTextures\\CommandButtons\\BTNBuff2.blp")call lWx(tJ[2],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)call lWx(tJ[2],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)call lWx(tJ[2],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)call lWx(tJ[2],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)return trueendfunctionfunction UZr takes nothing returns booleanset tJ[3]=Wwx('BSW3',"Swiftness 3",'bSW3')set aav[(tJ[3])]=(true)set anv[(tJ[3])]=("ReplaceableTextures\\CommandButtons\\BTNBuff3.blp")call lWx(tJ[3],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)call lWx(tJ[3],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)call lWx(tJ[3],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)call lWx(tJ[3],"Abilities\\Spells\\Other\\Tornado\\Tornado_Target.mdl","overhead",ri)return trueendfunctionfunction U_r takes nothing returns booleancall VNx(ma,(function UWr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Swiftness.page\\Swiftness.struct\\obj_ChargeBuff[1]_wc3buff.j"))
call VNx(va,(function Uyr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Swiftness.page\\Swiftness.struct\\obj_this_wc3obj.j"))call VNx(ma,(function UYr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Swiftness.page\\Swiftness.struct\\obj_timerBuff_wc3buff.j"))
call VNx(ma,(function Uzr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Swiftness.page\\Swiftness.struct\\obj_ChargeBuff[2]_wc3buff.j"))
call VNx(ma,(function UZr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Swiftness.page\\Swiftness.struct\\obj_ChargeBuff[3]_wc3buff.j"))
return trueendfunctionfunction U0r takes nothing returns booleanset YVe=VXx(Yne)
return trueendfunctionfunction U1r takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxlocal integer rvx=SJ[oSx]call AZx(Iix,tJ[rvx])set SJ[oSx]=rvx-1if(rvx==1)thencall AZx(Iix,sJ)
endifendfunctionfunction U2r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=iXx()set YEe[oSx]=p3x
set ge[(p3x)]=(oSx)call iDx(p3x,Yae[1],true,function U1r)return trueendfunctionfunction U3r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer rvx=SJ[oSx]local integer p3x=YEe[oSx]call iKx(p3x)loop
exitwhen(rvx<1)call AZx(Iix,tJ[rvx])set rvx=rvx-1endloopreturn trueendfunctionfunction U4r takes nothing returns booleancall Lxx(sJ,Xdx("Swiftness_Init: call Swiftness.TIMER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Swiftness.Event_Timer_BuffGain))",bd,MI,function U2r))
call Lxx(sJ,Xdx("Swiftness_Init: call Swiftness.TIMER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Swiftness.Event_Timer_BuffLose))",jc,MI,function U3r))
return trueendfunctionfunction U5r takes nothing returns booleancall FAr(function U4r,"Swiftness_Init")return trueendfunctionfunction U6r takes nothing returns booleanset YXe[1]=.25set YXe[2]=.4set YXe[3]=.65set YXe[4]=.8set YXe[5]=.95set YXe[6]=1.1return trueendfunctionfunction U7r takes nothing returns booleanset YOe=Wwx('BCrA',"Tempest Strike",'bCrA')set aav[(YOe)]=(true)set uU[(YOe)]=(true)
set anv[(YOe)]=("ReplaceableTextures\\CommandButtons\\BTNCleavingAttack.blp")call lWx(YOe,"TempestStrike_page\\TempestStrike_struct\\CriticalAttacks\\Buff.mdx","weapon",ri)call lWx(YOe,"Abilities\\Weapons\\IllidanMissile\\IllidanMissile.mdl","weapon",ri)set WU=l_x()
call l2x(WU,nnv,.25)
call l3x(((YOe)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,nnv,.4)call l3x(((YOe)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,nnv,.65)
call l3x(((YOe)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,nnv,.8)call l3x(((YOe)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,nnv,.95)
call l3x(((YOe)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,nnv,1.1)
call l3x(((YOe)),ZB+(6),(WU))return trueendfunctionfunction U8r takes nothing returns booleancall VNx(va,(function U6r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\TempestStrike.page\\TempestStrike.struct\\CriticalAttacks\\obj_this_wc3obj.j"))call VNx(ma,(function U7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\TempestStrike.page\\TempestStrike.struct\\CriticalAttacks\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction U9r takes nothing returns booleanset YRe=VXx(YIe)
return trueendfunctionfunction wvr takes nothing returns booleanset YAe=ltx(YNe+" (dummyBuff)")call lWx(YAe,"Abilities\\Weapons\\PhoenixMissile\\Phoenix_Missile_mini.mdl","origin",Bi)
call lWx(YAe,"TempestStrike_page\\TempestStrike_struct\\Hurricanwave3.mdx","origin",ri)set WU=l_x()
call vAr(WU,DOv,true)call vAr(WU,DLv,true)call l3x(((YAe)),ZB+(1),(WU))set WU=l_x()
call vAr(WU,DOv,true)call vAr(WU,DLv,true)call l3x(((YAe)),ZB+(2),(WU))set WU=l_x()
call vAr(WU,DOv,true)call vAr(WU,DLv,true)call l3x(((YAe)),ZB+(3),(WU))set WU=l_x()
call vAr(WU,DOv,true)call vAr(WU,DLv,true)call l3x(((YAe)),ZB+(4),(WU))set WU=l_x()
call vAr(WU,DOv,true)call vAr(WU,DLv,true)call l3x(((YAe)),ZB+(5),(WU))set WU=l_x()
call vAr(WU,DOv,true)call vAr(WU,DLv,true)call l3x(((YAe)),ZB+(6),(WU))return trueendfunctionfunction wer takes nothing returns booleancall L1x('ATeS',false)set Gdv=L0o('ATeS')set K6[(Gdv)]=(O6)set m6[(Gdv)]=(6)set TH[(Gdv)]=("Tempest Strike")
set Rh[(Gdv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0089)))),(((Aj))))))set oxv[(Gdv)]=(2)set x3v[(Gdv)]=("spell")
call L1o((Gdv),Uvv+(1),((90)*1.))call L1o((Gdv),GH+(1),(($A)*1.))
call L1o((Gdv),tH+(1),((70)*1.))
call L1o((Gdv),Lov+(1),((99999)*1.))
call L1o((Gdv),Uvv+(2),((90)*1.))call L1o((Gdv),GH+(2),(($A)*1.))
call L1o((Gdv),tH+(2),((85)*1.))
call L1o((Gdv),Lov+(2),((99999)*1.))
call L1o((Gdv),Uvv+(3),((90)*1.))call L1o((Gdv),GH+(3),(($A)*1.))
call L1o((Gdv),tH+(3),(('d')*1.))call L1o((Gdv),Lov+(3),((99999)*1.))
call L1o((Gdv),Uvv+(4),((90)*1.))call L1o((Gdv),GH+(4),(($A)*1.))
call L1o((Gdv),tH+(4),(('s')*1.))call L1o((Gdv),Lov+(4),((99999)*1.))
call L1o((Gdv),Uvv+(5),((90)*1.))call L1o((Gdv),GH+(5),(($A)*1.))
call L1o((Gdv),tH+(5),(($82)*1.))call L1o((Gdv),Lov+(5),((99999)*1.))
call L1o((Gdv),Uvv+(6),((90)*1.))call L1o((Gdv),GH+(6),(($A)*1.))
call L1o((Gdv),tH+(6),(($91)*1.))call L1o((Gdv),Lov+(6),((99999)*1.))
set MOv[(Gdv)]=("ReplaceableTextures\\CommandButtons\\BTNCleavingAttack.blp")call cDr(Gdv,'FTe0',6,'VTe0','LPTe','LRTe')set Ybe[1]=30set Ybe[2]=60set Ybe[3]=90set Ybe[4]='x'set Ybe[5]=$96set Ybe[6]=$B4return trueendfunctionfunction wxr takes nothing returns booleancall VNx(ma,(function wvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\TempestStrike.page\\TempestStrike.struct\\obj_dummyBuff_wc3buff.j"))
call VNx(Pa,(function wer),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\TempestStrike.page\\TempestStrike.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction wor takes nothing returns booleanset YBe=VXx(YNe)
return trueendfunctionfunction wrr takes nothing returns booleanlocal integer Iix=jhx()if(I8x((Ose),Ob,(Iix)))thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction wir takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=oSxlocal integer svo=Yfe[oSx]local integer Iixlocal real Nbocall SetUnitAnimationByIndex(C[((Cqx))],(0))
set Ose=svoset hf=(ze[(Cqx)])call NVo(Yce,(GetUnitX(C[((Cqx))])),(GetUnitY(C[((Cqx))])),(CQx((Gdv),Uvv+(YDe[oSx]))),YCe)set Iix=NEo(Yce)
if(Iix!=w)thenset Nbo=Yde[oSx]
loop
call ACx((Iix),(YJe),(Yke),(Bi))
call dQx(svo,Iix)call nlo((Cqx),(Iix),((Nbo)*1.),(false),(true))set Iix=NEo(Yce)
exitwhen(Iix==w)
endloopendifendfunctionfunction war takes nothing returns booleanlocal integer rFx=(bv)local integer nSr=(Lc[(rFx)])local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer Q9o=iXx()local real dVxlocal real dExset Yde[oSx]=Ybe[rYx]set YDe[oSx]=rYx
set Yfe[oSx]=Jbx("TempestStrike_Event_BuffGain: set this.targetGroup = UnitList.Create()")set YFe[oSx]=Q9o
set ge[(Q9o)]=(oSx)set dVx=(yH[(nSr)])set dEx=(YH[(nSr)])call pmo((ACx((Iix),(Yge),(Yge),(Bi))),YGe)set YGe=Nzr("dur",YGe)set Yhe=Nzr("length",Yhe)set YHe=Nzr("speedEnd",YHe)call Our(Iix,2.*Yhe*1./ YGe-YHe,2.*1./ YGe*(YHe-Yhe*1./ YGe),(Atan2(((dEx-(GetUnitY(C[((Iix))])))*1.),((dVx-(GetUnitX(C[((Iix))])))*1.))),YGe)call iDx(Q9o,Yje,true,function wir)call DXx((Iix),(SBv))return trueendfunctionfunction wnr takes integer rYx,integer Iix returns nothingcall Nbx((Iix),(YOe),(rYx),w,((YKe)*1.))
endfunctionfunction wVr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer rYx=YDe[oSx]local integer svo=Yfe[oSx]local integer Q9o=YFe[oSx]local boolean wEr=((OUx((svo),Ob))!=w)call X_r(svo)call iKx(Q9o)call QueueUnitAnimation(C[((Iix))],("stand"))if wEr thencall wnr(rYx,Iix)endifreturn trueendfunctionfunction wXr takes nothing returns booleanlocal integer rFx=(bv)call Nbx((Vv[(rFx)]),YAe,(Mv[(rFx)]),rFx,YGe)return trueendfunctionfunction wOr takes nothing returns nothingendfunctionfunction wRr takes nothing returns booleanset Yce=O5x()set YCe=Xpx(function wrr)call Lxx(YAe,Xdx("TempestStrike_Init: call TempestStrike.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TempestStrike.Event_BuffGain))",bd,MI,function war))call Lxx(YAe,Xdx("TempestStrike_Init: call TempestStrike.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TempestStrike.Event_BuffLose))",jc,MI,function wVr))call mro(Gdv,Xdx("TempestStrike_Init: call TempestStrike.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function TempestStrike.Event_SpellEffect))",ih,MI,function wXr))
call wOr()return trueendfunctionfunction wIr takes nothing returns booleancall FAr(function wRr,"TempestStrike_Init")return trueendfunctionfunction wAr takes nothing returns booleanreturn trueendfunctionfunction wNr takes nothing returns booleanset Yle=VXx(YLe)
return trueendfunctionfunction wbr takes nothing returns booleancall L1x('ATsR',false)set Yme=L0o('ATsR')set K6[(Yme)]=(G6)set m6[(Yme)]=(3)set TH[(Yme)]=("Relocate")set Rh[(Yme)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0085)))),(((Aj))))))set oxv[(Yme)]=(2)set x3v[(Yme)]=("spell")
call L1o((Yme),GH+(1),((0)*1.))call L1o((Yme),tH+(1),((0)*1.))call L1o((Yme),Lov+(1),((99999)*1.))
call L1o((Yme),GH+(2),((0)*1.))call L1o((Yme),tH+(2),((0)*1.))call L1o((Yme),Lov+(2),((99999)*1.))
set MOv[(Yme)]=("ReplaceableTextures\\CommandButtons\\BTNUndeadUnLoad.blp")call cDr(Yme,'FTR0',3,'VTR0','LPTR','LRTR')return trueendfunctionfunction wBr takes nothing returns booleancall VNx(Pa,(function wbr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Tsukuyomi.page\\Tsukuyomi.struct\\Relocate\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction wcr takes nothing returns booleanset YMe=VXx(Ype)
return trueendfunctionfunction wCr takes nothing returns booleanset YPe=ltx(Yqe+" (dummyBuff)")set Pc[(YPe)]=(true)
return trueendfunctionfunction wdr takes nothing returns booleancall VNx(ma,(function wCr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Tsukuyomi.page\\Tsukuyomi.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction wDr takes nothing returns booleanset YQe=VXx(Yqe)
return trueendfunctionfunction wfr takes nothing returns booleanset Yse=ltx(YSe+" (dummyBuff)")return trueendfunctionfunction wFr takes nothing returns booleancall L1x('ATsu',false)set lMe=L0o('ATsu')set K6[(lMe)]=(G6)set m6[(lMe)]=(3)set TH[(lMe)]=("Tsukuyomi")set Rh[(lMe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0206)))),(((Aj))))))set oxv[(lMe)]=(2)set x3v[(lMe)]=("spell")
call L1o((lMe),Uvv+(1),((275)*1.))call L1o((lMe),GH+(1),((80)*1.))
call L1o((lMe),tH+(1),(($C8)*1.))call L1o((lMe),Lov+(1),((900)*1.))call L1o((lMe),Uvv+(2),((350)*1.))call L1o((lMe),GH+(2),((80)*1.))
call L1o((lMe),tH+(2),((300)*1.))call L1o((lMe),Lov+(2),((900)*1.))set MOv[(lMe)]=("ReplaceableTextures\\CommandButtons\\BTNBanish.blp")call cDr(lMe,'FTs0',3,'VTs0','LPTs','LRTs')set Yte[1]=$Fset Yte[2]=20set YTe[1]=.35set YTe[2]=.45set Yue[1]=$Aset Yue[2]=20return trueendfunctionfunction wgr takes nothing returns booleancall VNx(ma,(function wfr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Tsukuyomi.page\\Tsukuyomi.struct\\obj_dummyBuff_wc3buff.j"))
call VNx(Pa,(function wFr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Tsukuyomi.page\\Tsukuyomi.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction wGr takes nothing returns booleanset YUe=VXx(YSe)
return trueendfunctionfunction whr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction wHr takes integer oSx returns booleanset ry=ry+1set oy[ry]=oSxset xy[oSx]=ry+1
return(ry==0)endfunctionfunction wjr takes nothing returns nothinglocal integer oMx=ry
local integer oSxlocal real C9xlocal real dvxlocal real MSolocal integer Iixlocal real fvxloop
set oSx=oy[oMx]set C9x=Y9e[oSx]
set dvx=zve[oSx]
set MSo=zee[oSx]
set Iix=ay[oSx]if zxe[oSx]thenset fvx=(qy[(Iix)])set C9x=C9x*fvxset dvx=dvx*fvxset MSo=MSo*fvxendifcall MLo((oSx),(GetUnitX(vJ[((Iix))]))+C9x,(GetUnitY(vJ[((Iix))]))+dvx,(Au[(Iix)])+MSo)set oMx=oMx-1exitwhen(oMx<0)endloopendfunctionfunction wJr takes integer oSx,integer Iix,boolean OPx,real C9x,real dvx,real MSo returns nothingset Y9e[oSx]=C9x
set zve[oSx]=dvx
set zee[oSx]=MSo
set ay[oSx]=Iixset zxe[oSx]=OPx
call Mix((oSx),ZW)if wHr(oSx)thencall iDx(iy,zoe,true,function wjr)endifendfunctionfunction wkr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=oSxlocal integer wKr=YZe[oSx]local real x=(GetUnitX(vJ[((wKr))]))
local real y=(GetUnitY(vJ[((wKr))]))
local integer C3o=(ze[(Cqx)])local integer Iixlocal real wlrlocal real wLrlocal real wmrset hf=C3ocall NVo(Ywe,x,y,(vqe[(Yze[oSx])]),YWe)set Iix=NEo(Ywe)
if(Iix!=w)thenset wlr=Y3e[oSx]
set wLr=.0set wmr=Y4e[oSx]
loop
call Hmr(Iix,(Nqv[(Iix)])*wlr,(Atan2(((y-(GetUnitY(C[((Iix))])))*1.),((x-(GetUnitX(C[((Iix))])))*1.))),zie)if(IsUnitAlly(C[(Iix)],vx[(C3o)]))thencall YCo(Iix,wmr)else
set Y4e[oSx]=iUx((lF[(Iix)]),wmr)call Ydo(Cqx,Iix,Y4e[oSx])set wLr=wLr+Y4e[oSx]
endifset Iix=NEo(Ywe)
exitwhen(Iix==w)
endloopif(wLr>.0)thencall mno(Cqx,Cqx,wLr*zae)endifendifendfunctionfunction wMr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local real dVx=Yyelocal real dEx=YYelocal real MQx=X_x(dVx,dEx)local real O4o=(CQx((lMe),Uvv+(rYx)))local integer oSx=Iixlocal integer Xur=XQr(Iix)local integer HAx=mDx('qTsu',dVx,dEx,MQx-80.,.0)
local integer PZr=mDx('qTs2',dVx,dEx,MQx+150.,.0)local integer p3x=iXx()local integer wKr=mDx('qTsP',dVx,dEx,MQx,.0)
set Yze[oSx]=Xur
set YZe[oSx]=HAx
set Y_e[oSx]=PZr
set Y0e[oSx]=p3x
set Y1e[oSx]=rYx
set Y2e[oSx]=wKr
set Y3e[oSx]=YTe[rYx]set Y4e[oSx]=Yue[rYx]set Y5e[oSx]=dVx
set Y6e[oSx]=dEx
set Ene[(Xur)]=(oSx)
set ge[(p3x)]=(oSx)set vqe[(Xur)]=((O4o)*1.)set vQe[(Xur)]=(YWe)
call Xsr(Xur,Y7e)call Xsr(Xur,Y8e)call Xtr(Xur)call wJr(HAx,wKr,false,.0,.0,-80.)call mCx(HAx,.0)
call o_r(HAx,O4o*5*1./(3*128.),.25)call wJr(PZr,wKr,false,.0,.0,150.)call mCx(PZr,.0)
call o_r(PZr,O4o*8*1./(3*128.),.25)if((Tf[(Iix)])==GHv)then
call mdx(HAx,.0,200.,255.,200.)call mdx(PZr,.0,200.,200.,255.)elseif((Tf[(Iix)])==g4v)then
call mdx(HAx,255.,255.,255.,200.)elseif((Tf[(Iix)])==gYv)then
call mdx(HAx,63.,255.,.0,200.)call mdx(PZr,63.,255.,.0,255.)endifcall SetUnitMoveSpeed(vJ[(wKr)],((zre)*1.))call SetUnitPropWindow(vJ[(wKr)],((1.)*1.))call SetUnitTurnSpeed(vJ[(wKr)],((Cf)*1.))call iDx(p3x,zie,true,function wkr)call OCo(Yme,Iix)return trueendfunctionfunction wpr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer Xur=Yze[oSx]local integer HAx=YZe[oSx]local integer PZr=Y_e[oSx]local integer p3x=Y0e[oSx]call X5r(Xur)call Mfx(HAx)call MGx(PZr)call iKx(p3x)call OCo(lMe,Iix)return trueendfunctionfunction wPr takes integer oSx returns integerset zOe[oSx]=trueset zRe[oSx]=falsecall rEx(Yle)return oSxendfunctionfunction wqr takes nothing returns integerlocal integer oSxif(zne==8190)thencall o_x("FolderTsukuyomi_StructMissile_Allocation_allocCustom","call DebugEx(FolderTsukuyomi_StructMissile.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",YLe+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(zVe[(w)]==w)thenset zEe=zEe+1set oSx=zEeelse
set oSx=zVe[(w)]
set zVe[(w)]=zVe[zVe[(w)]]endifset zVe[oSx]=Zset zXe[oSx]=1call wPr(oSx)return oSxendfunctionfunction wQr takes integer oSx returns nothingset zOe[oSx]=falsecall rHx(Yle)endfunctionfunction wsr takes integer oSx returns nothingif(zXe[oSx]>0)thenreturnendifif(zVe[oSx]!=Z)thencall o_x("FolderTsukuyomi_StructMissile_Allocation_deallocCustom_confirm","call DebugEx(FolderTsukuyomi_StructMissile.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",YLe+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset zVe[oSx]=zVe[(w)]set zVe[(w)]=oSx
call wQr(oSx)endfunctionfunction wSr takes integer oSx returns nothingset zXe[oSx]=zXe[oSx]-1call wsr(oSx)endfunctionfunction wtr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=zIe[oSx]local integer rYx=zAe[oSx]local real dVx=zNe[oSx]local real dEx=zbe[oSx]call wSr((oSx))call MFo(Mho)set Yye=dVxset YYe=dExcall Nbx((Cqx),(Yse),(rYx),w,((Yte[rYx])*1.))return trueendfunctionfunction wTr takes integer Cqx,integer rYx,real dVx,real dEx returns nothing
local integer oSx=wqr()local integer Mho=Moo()set zIe[oSx]=Cqx
set zAe[oSx]=rYx
set zNe[oSx]=dVx
set zbe[oSx]=dEx
call m4o(Mho,2000.)set mcv[((Mho))]=((Bev*((.2)*1.))*1.)set mCv[(Mho)]=((48.)*1.)call Mno(Mho,'qTsM',1.)set mFv[(Mho)]=Xkx((function wtr))set mZv[(Mho)]=(oSx)
call Meo(Mho,500.)call pxo(Mho,Cqx)call o9r(Mho,dVx,dEx,X_x(dVx,dEx))endfunctionfunction wur takes nothing returns booleanlocal integer rFx=(bv)call wTr((Vv[(rFx)]),(Mv[(rFx)]),(yH[(rFx)]),(YH[(rFx)]))return trueendfunctionfunction wUr takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer rLx=(Ene[(Xur)])call Ulx(Iix,YPe)return trueendfunctionfunction wwr takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer Cqx=(vke[(Xur)])local integer rLx=(Ene[(Xur)])local integer rYx=Y1e[rLx]call Dux((Iix),(YPe),(rYx),w)return trueendfunctionfunction wWr takes nothing returns nothingset Y7e=Xdx("FolderTsukuyomi_StructTarget_Init: set FolderTsukuyomi_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderTsukuyomi_StructTarget.Event_Ending)",vTe,MI,function wUr)set Y8e=Xdx("FolderTsukuyomi_StructTarget_Init: set FolderTsukuyomi_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderTsukuyomi_StructTarget.Event_Start)",vue,MI,function wwr)
call W2x(EDv,YPe)endfunctionfunction wyr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local integer rLx=Cqxcall IssuePointOrderById(vJ[((Y2e[rLx]))],pb[(Bh)],((dVx)*1.),((dEx)*1.))return trueendfunctionfunction wYr takes nothing returns booleanlocal integer oMxset Ywe=O5x()set YWe=Xpx(function whr)call Lxx(Yse,Xdx("Tsukuyomi_Init: call Tsukuyomi.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Tsukuyomi.Event_BuffGain))",bd,MI,function wMr))call Lxx(Yse,Xdx("Tsukuyomi_Init: call Tsukuyomi.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Tsukuyomi.Event_BuffLose))",jc,MI,function wpr))call mro(lMe,Xdx("Tsukuyomi_Init: call Tsukuyomi.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Tsukuyomi.Event_SpellEffect))",ih,MI,function wur))
set oMx=(m6[(lMe)])loop
set Yue[oMx]=Yue[oMx]*zieset oMx=oMx-1exitwhen(oMx<1)endloopcall wWr()call mro(Yme,Xdx("FolderTsukuyomi_StructRelocate_Init: call FolderTsukuyomi_StructRelocate.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderTsukuyomi_StructRelocate.Event_SpellEffect))",ih,MI,function wyr))return trueendfunctionfunction wzr takes nothing returns booleancall FAr(function wYr,"Tsukuyomi_Init")return trueendfunctionfunction wZr takes nothing returns booleanreturn trueendfunctionfunction w_r takes nothing returns booleanset zBe=VXx(zce)
return trueendfunctionfunction w0r takes nothing returns booleanset zCe[1]=-3set zCe[2]=-5set zCe[3]=-7set zCe[4]=-9set zCe[5]=-$Bset zCe[6]=-$Dset zde[1]=2
set zde[2]=3
set zde[3]=4
set zde[4]=5
set zde[5]=6
set zde[6]=7
set zDe[1]=-.4set zDe[2]=-.4set zDe[3]=-.4set zDe[4]=-.4set zDe[5]=-.4set zDe[6]=-.4set zfe[1]=2
set zfe[2]=3
set zfe[3]=4
set zfe[4]=5
set zfe[5]=6
set zfe[6]=7
set zFe[1]=30set zFe[2]=60set zFe[3]=90set zFe[4]='x'set zFe[5]=$96set zFe[6]=$B4return trueendfunctionfunction w1r takes nothing returns booleanset zge=Wwx('BWSh',"Wan Shroud",'bWSh')set Pc[(zge)]=(true)
set anv[(zge)]=("ReplaceableTextures\\CommandButtons\\BTNCyclone.blp")set WU=l_x()
call l2x(WU,dXv,-3)call l2x(WU,cEv,30)call l2x(WU,iw,-.4)call l3x(((zge)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,dXv,-5)call l2x(WU,cEv,60)call l2x(WU,iw,-.4)call l3x(((zge)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,dXv,-7)call l2x(WU,cEv,90)call l2x(WU,iw,-.4)call l3x(((zge)),ZB+(3),(WU))set WU=l_x()
call l2x(WU,dXv,-9)call l2x(WU,cEv,'x')
call l2x(WU,iw,-.4)call l3x(((zge)),ZB+(4),(WU))set WU=l_x()
call l2x(WU,dXv,-$B)
call l2x(WU,cEv,$96)
call l2x(WU,iw,-.4)call l3x(((zge)),ZB+(5),(WU))set WU=l_x()
call l2x(WU,dXv,-$D)
call l2x(WU,cEv,$B4)
call l2x(WU,iw,-.4)call l3x(((zge)),ZB+(6),(WU))return trueendfunctionfunction w2r takes nothing returns booleancall VNx(va,(function w0r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WanShroud.page\\WanShroud.struct\\Target\\obj_this_wc3obj.j"))call VNx(ma,(function w1r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WanShroud.page\\WanShroud.struct\\Target\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction w3r takes nothing returns booleanset zGe=VXx(zhe)
return trueendfunctionfunction w4r takes nothing returns booleancall L1x('AWSh',false)set gqv=L0o('AWSh')set K6[(gqv)]=(D6)set m6[(gqv)]=(6)set TH[(gqv)]=("Wan Shroud")
set Rh[(gqv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0206)))),(((Aj))))))set oxv[(gqv)]=(2)set x3v[(gqv)]=("spell,channel")
call L1o((gqv),Uvv+(1),(($F0)*1.))call L1o((gqv),GH+(1),((17)*1.))
call L1o((gqv),tH+(1),(('x')*1.))call L1o((gqv),Lov+(1),((900)*1.))call L1o((gqv),Uvv+(2),((260)*1.))call L1o((gqv),GH+(2),((17)*1.))
call L1o((gqv),tH+(2),(($87)*1.))call L1o((gqv),Lov+(2),((900)*1.))call L1o((gqv),Uvv+(3),((280)*1.))call L1o((gqv),GH+(3),((17)*1.))
call L1o((gqv),tH+(3),(($96)*1.))call L1o((gqv),Lov+(3),((900)*1.))call L1o((gqv),Uvv+(4),((300)*1.))call L1o((gqv),GH+(4),((17)*1.))
call L1o((gqv),tH+(4),(($A5)*1.))call L1o((gqv),Lov+(4),((900)*1.))call L1o((gqv),Uvv+(5),((320)*1.))call L1o((gqv),GH+(5),((17)*1.))
call L1o((gqv),tH+(5),(($B4)*1.))call L1o((gqv),Lov+(5),((900)*1.))call L1o((gqv),Uvv+(6),((340)*1.))call L1o((gqv),GH+(6),((17)*1.))
call L1o((gqv),tH+(6),(($C3)*1.))call L1o((gqv),Lov+(6),((900)*1.))set MOv[(gqv)]=("ReplaceableTextures\\CommandButtons\\BTNCyclone.blp")call cDr(gqv,'FWS0',6,'VWS0','LPWS','LRWS')set zHe[1]=$Aset zHe[2]=$Aset zHe[3]=$Aset zHe[4]=$Aset zHe[5]=$Aset zHe[6]=$Aset zje[1]=3
set zje[2]=5
set zje[3]=7
set zje[4]=9
set zje[5]=$Bset zje[6]=$Dreturn trueendfunctionfunction w5r takes nothing returns booleancall VNx(Pa,(function w4r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WanShroud.page\\WanShroud.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction w6r takes nothing returns booleanset zJe=VXx(zke)
return trueendfunctionfunction w7r takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif not I9x(Iix,Idv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction w8r takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif ndo(Iix)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifif nbo(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction w9r takes integer oSx returns integerset zPe[oSx]=trueset zqe[oSx]=falsecall rEx(zBe)return oSxendfunctionfunction Wvr takes nothing returns integerlocal integer oSxif(zLe==8190)thencall o_x("FolderWanShroud_StructMissile_Allocation_allocCustom","call DebugEx(FolderWanShroud_StructMissile.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",zce+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(zme[(w)]==w)thenset zMe=zMe+1set oSx=zMeelse
set oSx=zme[(w)]
set zme[(w)]=zme[zme[(w)]]endifset zme[oSx]=Zset zpe[oSx]=1call w9r(oSx)return oSxendfunctionfunction Wer takes integer oSx returns nothingset zPe[oSx]=falsecall rHx(zBe)endfunctionfunction Wxr takes integer oSx returns nothingif(zpe[oSx]>0)thenreturnendifif(zme[oSx]!=Z)thencall o_x("FolderWanShroud_StructMissile_Allocation_deallocCustom_confirm","call DebugEx(FolderWanShroud_StructMissile.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",zce+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset zme[oSx]=zme[(w)]set zme[(w)]=oSx
call Wer(oSx)endfunctionfunction Wor takes integer oSx returns nothingset zpe[oSx]=zpe[oSx]-1call Wxr(oSx)endfunctionfunction Wrr takes integer oSx returns integerset zWe[oSx]=trueset zye[oSx]=falsecall rEx(zJe)return oSxendfunctionfunction Wir takes nothing returns integerlocal integer oSxif(zTe==8190)thencall o_x("WanShroud_Allocation_allocCustom","call DebugEx(WanShroud.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",zke+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(zue[(w)]==w)thenset zUe=zUe+1set oSx=zUeelse
set oSx=zue[(w)]
set zue[(w)]=zue[zue[(w)]]endifset zue[oSx]=Zset zwe[oSx]=1call Wrr(oSx)return oSxendfunctionfunction War takes nothing returns booleanlocal integer rFx=(bv)local integer oSx=(pj[(rFx)])local integer Iix=(Vv[(rFx)])call Ryx((ACx((Iix),(z8e),(z9e),(ri))))call nlo((zZe[oSx]),(Iix),((z_e[oSx])*1.),(true),(false))return trueendfunctionfunction Wnr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])call Dgx((vPe[(zze[oSx])]),function War,oSx)
endfunctionfunction WVr takes nothing returns nothinglocal integer iCx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer oSx=(ge[(iCx)])local integer Xur=zze[oSx]local integer t3r=zYe[oSx]local integer p3x=z1e[oSx]call MGx(t3r)call X5r(Xur)call iKx(iCx)call iKx(p3x)endfunctionfunction WEr takes integer Cqx,integer rYx,real dVx,real dEx returns nothing
local real O4o=(CQx((gqv),Uvv+(rYx)))local real MQx=X_x(dVx,dEx)local integer oSx=Wir()local integer t3r=mDx('qWSh',dVx,dEx,MQx,.0)
local integer Xur=XQr(Cqx)local integer iCx=iXx()local integer p3x=iXx()set zYe[oSx]=t3r
set zze[oSx]=Xur
set zZe[oSx]=Cqx
set z_e[oSx]=z0e[rYx]set z1e[oSx]=p3x
set z2e[oSx]=rYx
set z3e[oSx]=dVx
set z4e[oSx]=dEx
set Ene[(Xur)]=(oSx)
set ge[(iCx)]=(oSx)set ge[(p3x)]=(oSx)call mCx(t3r,O4o*1./ 180.)set vqe[(Xur)]=(((CQx((gqv),Uvv+(rYx))))*1.)
set vQe[(Xur)]=(zKe)
call Xsr(Xur,z5e)call Xsr(Xur,z6e)call Xtr(Xur)call iDx(p3x,z7e,true,function Wnr)call iDx(iCx,zHe[rYx],false,function WVr)endfunctionfunction WXr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=zQe[oSx]local integer rYx=zse[oSx]local real dVx=zSe[oSx]local real dEx=zte[oSx]call Wor((oSx))call MFo(Mho)call WEr(Cqx,rYx,dVx,dEx)return trueendfunctionfunction WOr takes integer Cqx,integer rYx,real dVx,real dEx returns nothing
local integer oSx=Wvr()local integer Mho=Moo()set zQe[oSx]=Cqx
set zse[oSx]=rYx
set zSe[oSx]=dVx
set zte[oSx]=dEx
call m4o(Mho,2000.)set mcv[((Mho))]=((Bev*((.2)*1.))*1.)set mCv[(Mho)]=((48.)*1.)call Mno(Mho,'qWSM',1.)set mFv[(Mho)]=Xkx((function WXr))set mZv[(Mho)]=(oSx)
call Meo(Mho,500.)call pxo(Mho,Cqx)call o9r(Mho,dVx,dEx,X_x(dVx,dEx))endfunctionfunction WRr takes nothing returns booleanlocal integer rFx=(bv)call WOr((Vv[(rFx)]),(Mv[(rFx)]),(yH[(rFx)]),(YH[(rFx)]))return trueendfunctionfunction WIr takes integer oSx,integer Iix,real o5x returns nothinglocal integer rLx=oSxif(IsUnitAlly(C[(Iix)],vx[(rLx)]))thenreturnendifif(o5x<=.0)thenreturnendifcall Oqx(rLx,iSx("+"+(I2S(((R2I(((o5x)*1.)))))),"ffc80000"),.02,80.,.0,3.,(0))call Ryx((ACx((rLx),(dBv),(dcv),(Bi))))call cjx(rLx,o5x)endfunctionfunction WAr takes integer oSx,integer Iix,real o5x returns nothinglocal integer rLx=oSxif(IsUnitAlly(C[(Iix)],vx[(rLx)]))thenreturnendifif(o5x<=.0)thenreturnendifcall Oqx(rLx,iSx("+"+(I2S(((R2I(((o5x)*1.)))))),"ffc80000"),.02,80.,.0,3.,(0))call Ryx((ACx((rLx),(dCv),(ddv),(Bi))))call BNx(rLx,o5x)endfunctionfunction WNr takes nothing returns booleanlocal integer rFx=(bv)local integer Ahr=(E2v[(rFx)])local integer Iix=(Vv[(rFx)])local integer Apr=(kv[((ze[(Ahr)]))])if((Apr!=w)and not I9x(Apr,Qc))thenset Ahr=Aprendifcall WIr(Ahr,Iix,zfe[(osx(((Iix)),Yb+(zge)))])call WAr(Ahr,Iix,zde[(osx(((Iix)),Yb+(zge)))])return trueendfunctionfunction Wbr takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer rLx=(Ene[(Xur)])call Ulx(Iix,zge)return trueendfunctionfunction WBr takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer Cqx=(vke[(Xur)])local integer rLx=(Ene[(Xur)])local integer rYx=z2e[rLx]call Dux((Iix),(zge),(rYx),w)return trueendfunctionfunction Wcr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])call Avx(Iix,Zve)return trueendfunctionfunction WCr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])call RPx(Iix,Zve)return trueendfunctionfunction Wdr takes nothing returns nothingset Zve=Xdx("FolderWanShroud_StructTarget_Init: set FolderWanShroud_StructTarget.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.SPELLS, function FolderWanShroud_StructTarget.Event_Damage)",E3v,MI,function WNr)set z5e=Xdx("FolderWanShroud_StructTarget_Init: set FolderWanShroud_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderWanShroud_StructTarget.Event_Ending)",vTe,MI,function Wbr)set z6e=Xdx("FolderWanShroud_StructTarget_Init: set FolderWanShroud_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderWanShroud_StructTarget.Event_Start)",vue,MI,function WBr)
call Lxx(zge,Xdx("FolderWanShroud_StructTarget_Init: call FolderWanShroud_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderWanShroud_StructTarget.Event_BuffGain))",bd,MI,function Wcr))
call Lxx(zge,Xdx("FolderWanShroud_StructTarget_Init: call FolderWanShroud_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderWanShroud_StructTarget.Event_BuffLose))",jc,MI,function WCr))
endfunctionfunction WDr takes nothing returns booleanlocal integer rYxset zKe=Xpx(function w7r)set zle=Xpx(function w8r)call mro(gqv,Xdx("WanShroud_Init: call WanShroud.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function WanShroud.Event_SpellEffect))",ih,MI,function WRr))
set rYx=(m6[(gqv)])loop
exitwhen(rYx<1)set z0e[rYx]=zje[rYx]*z7eset rYx=rYx-1endloopcall Wdr()return trueendfunctionfunction Wfr takes nothing returns booleancall FAr(function WDr,"WanShroud_Init")return trueendfunctionfunction WFr takes nothing returns booleanset Zee=Wwx('BWac',"Warcry",'bWac')set aav[(Zee)]=(true)set uU[(Zee)]=(true)
set anv[(Zee)]=("ReplaceableTextures\\CommandButtons\\BTNBattleRoar.blp")call lWx(Zee,"Abilities\\Spells\\NightElf\\BattleRoar\\RoarTarget.mdl","overhead",ri)return trueendfunctionfunction Wgr takes nothing returns booleanset Zxe[1]=20set Zxe[2]=20set Zxe[3]=20set Zxe[4]=20set Zxe[5]=20set Zxe[6]=20set Zoe[1]=.1set Zoe[2]=.1set Zoe[3]=.1set Zoe[4]=.1set Zoe[5]=.1set Zoe[6]=.1set Zre[1]=3
set Zre[2]=6
set Zre[3]=$Aset Zre[4]=$Fset Zre[5]=21set Zre[6]=28return trueendfunctionfunction WGr takes nothing returns booleancall VNx(ma,(function WFr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Warcry.page\\Warcry.struct\\Target\\obj_dummyBuff_wc3buff.j"))call VNx(va,(function Wgr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Warcry.page\\Warcry.struct\\Target\\obj_this_wc3obj.j"))
return trueendfunctionfunction Whr takes nothing returns booleanset Zie=VXx(Zae)
return trueendfunctionfunction WHr takes nothing returns booleancall L1x('AWac',false)set hbv=L0o('AWac')set K6[(hbv)]=(O6)set m6[(hbv)]=(6)set TH[(hbv)]=("Warcry")
set Rh[(hbv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00C4)))),(((Aj))))))set oxv[(hbv)]=(0)set x3v[(hbv)]=("spell")
call L1o((hbv),Uvv+(1),((450)*1.))call L1o((hbv),GH+(1),(($F)*1.))
call L1o((hbv),tH+(1),((80)*1.))
call L1o((hbv),Lov+(1),((750)*1.))call L1o((hbv),Uvv+(2),((450)*1.))call L1o((hbv),GH+(2),(($F)*1.))
call L1o((hbv),tH+(2),((92)*1.))
call L1o((hbv),Lov+(2),((750)*1.))call L1o((hbv),Uvv+(3),((450)*1.))call L1o((hbv),GH+(3),(($F)*1.))
call L1o((hbv),tH+(3),(('h')*1.))call L1o((hbv),Lov+(3),((750)*1.))call L1o((hbv),Uvv+(4),((450)*1.))call L1o((hbv),GH+(4),(($F)*1.))
call L1o((hbv),tH+(4),(('t')*1.))call L1o((hbv),Lov+(4),((750)*1.))call L1o((hbv),Uvv+(5),((450)*1.))call L1o((hbv),GH+(5),(($F)*1.))
call L1o((hbv),tH+(5),(($80)*1.))call L1o((hbv),Lov+(5),((750)*1.))call L1o((hbv),Uvv+(6),((450)*1.))call L1o((hbv),GH+(6),(($F)*1.))
call L1o((hbv),tH+(6),(($8C)*1.))call L1o((hbv),Lov+(6),((750)*1.))set MOv[(hbv)]=("ReplaceableTextures\\CommandButtons\\BTNBattleRoar.blp")call cDr(hbv,'FBR0',6,'VBR0','LPBR','LRBR')set Zne[1]=2
set Zne[2]=2
set Zne[3]=2
set Zne[4]=2
set Zne[5]=2
set Zne[6]=2
set ZVe[1]=.04set ZVe[2]=.05set ZVe[3]=.06set ZVe[4]=.07set ZVe[5]=.08set ZVe[6]=.09return trueendfunctionfunction Wjr takes nothing returns booleancall VNx(Pa,(function WHr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Warcry.page\\Warcry.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction WJr takes nothing returns booleanset ZEe=VXx(ZXe)
return trueendfunctionfunction Wkr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifreturn truereturn trueendfunctionfunction WKr takes integer Cqx,integer rYx,integer Iix returns nothingcall AZx(Iix,Zee)call Nbx(Iix,Zee,rYx,Cqx,Zxe[rYx])endfunctionfunction Wlr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real dKrlocal real O4olocal integer Iixlocal real WLrlocal integer C3olocal real h2rlocal real d
local real dlrcall mho((mko(((wQo)*1.),((wso)*1.),(ZIe),(ri))))set dKr=dox(Cqx,true)set O4o=(CQx((hbv),Uvv+(rYx)))+dKrcall NVo(ZOe,wQo,wso,O4o,ZRe)set Iix=NEo(ZOe)
if(Iix!=w)thenset WLr=Zne[rYx]
set C3o=(ze[(Cqx)])set h2r=ZVe[rYx]
loop
set d=jKx((GetUnitX(C[((Iix))]))-wQo,(GetUnitY(C[((Iix))]))-wso)
set dlr=ddr(dKr,ZAe,O4o,ZNe,d)if(IsUnitAlly(C[(Iix)],vx[(C3o)]))thencall WKr(Cqx,rYx,Iix)else
if not nbo(Iix)thencall Nbx((Iix),(rWv),(rYx),w,((WLr)*1.))
call nlo((Cqx),(Iix),(((oG[(Iix)])*h2r*dlr)*1.),(true),(false))endifendifset Iix=NEo(ZOe)
exitwhen(Iix==w)
endloopendifreturn trueendfunctionfunction Wmr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Lc[(rFx)])local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer WMr=l_x()set Zbe[oSx]=WMr
call l2x(WMr,dIv,Zre[rYx]+iAx(0,Zoe[rYx]*(QG[(Cqx)])))call I3x(Iix,WMr)return trueendfunctionfunction Wpr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer WMr=Zbe[oSx]call ISx(Iix,WMr)call nnr(WMr)return trueendfunctionfunction WPr takes nothing returns nothingcall Lxx(Zee,Xdx("FolderWarcry_StructTarget_Init: call FolderWarcry_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderWarcry_StructTarget.Event_BuffGain))",bd,MI,function Wmr))call Lxx(Zee,Xdx("FolderWarcry_StructTarget_Init: call FolderWarcry_StructTarget.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderWarcry_StructTarget.Event_BuffLose))",jc,MI,function Wpr))endfunctionfunction Wqr takes nothing returns booleanset ZOe=O5x()set ZRe=Xpx(function Wkr)call mro(hbv,Xdx("Warcry_Init: call Warcry.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Warcry.Event_SpellEffect))",ih,MI,function Wlr))call WPr()return trueendfunctionfunction WQr takes nothing returns booleancall FAr(function Wqr,"Warcry_Init")
return trueendfunctionfunction Wsr takes nothing returns booleanset ZBe[6]=hjo('uWB6')call hJo(((ZBe[6])),ASv,(Idv))set Uj[(ZBe[6])]=((1.4)*1.)set NOv[(ZBe[6])]=((148.14814814815)*1.)
set NWv[(ZBe[6])]=((74.074074074074)*1.)
set nKv[(ZBe[6])]=("Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdx")set NPv[(ZBe[6])]=(($E6)*1.)
set I8v[(ZBe[6])]=((4)*1.)set Anv[(ZBe[6])]=(2)set Nmv[(ZBe[6])]=((925)*1.)
set NLv[(ZBe[6])]=((925)*1.)
set NKv[(ZBe[6])]=((0)*1.)set Ncv[(ZBe[6])]=(($578)*1.)set Nbv[(ZBe[6])]=(($578)*1.)set NGv[(ZBe[6])]=((30)*1.)set Adv[(ZBe[6])]=(gmv)set AGv[(ZBe[6])]=((720)*1.)
set Ahv[((ZBe[6]))]=((1.*1./((1.6)*1.))*1.)set AWv[(ZBe[6])]=((.4)*1.)set Dnv[(ZBe[6])]=(($514)*1.)set Auv[(ZBe[6])]=((34)*1.)set AUv[(ZBe[6])]=((34)*1.)set AYv[(ZBe[6])]=(3)set A_v[(ZBe[6])]=(5)set A2v[(ZBe[6])]=(1)set ATv[(ZBe[6])]=((39.506172839506)*1.)
return trueendfunctionfunction WSr takes nothing returns booleanset ZBe[2]=hjo('uWB2')call hJo(((ZBe[2])),ASv,(Idv))set Uj[(ZBe[2])]=((1)*1.)set NOv[(ZBe[2])]=((148.14814814815)*1.)
set NWv[(ZBe[2])]=((74.074074074074)*1.)
set nKv[(ZBe[2])]=("Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdx")set NPv[(ZBe[2])]=(($E6)*1.)
set I8v[(ZBe[2])]=((1)*1.)set Anv[(ZBe[2])]=(2)set Nmv[(ZBe[2])]=((425)*1.)
set NLv[(ZBe[2])]=((425)*1.)
set NKv[(ZBe[2])]=((0)*1.)set Ncv[(ZBe[2])]=(($578)*1.)set Nbv[(ZBe[2])]=(($578)*1.)set NGv[(ZBe[2])]=((30)*1.)set Adv[(ZBe[2])]=(gmv)set AGv[(ZBe[2])]=((720)*1.)
set Ahv[((ZBe[2]))]=((1.*1./((1.6)*1.))*1.)set AWv[(ZBe[2])]=((.4)*1.)set Dnv[(ZBe[2])]=(($514)*1.)set Auv[(ZBe[2])]=((18)*1.)set AUv[(ZBe[2])]=((18)*1.)set AYv[(ZBe[2])]=(2)set A_v[(ZBe[2])]=(3)set A2v[(ZBe[2])]=(1)set ATv[(ZBe[2])]=((39.506172839506)*1.)
return trueendfunctionfunction Wtr takes nothing returns booleanset ZBe[3]=hjo('uWB3')call hJo(((ZBe[3])),ASv,(Idv))set Uj[(ZBe[3])]=((1.1)*1.)set NOv[(ZBe[3])]=((148.14814814815)*1.)
set NWv[(ZBe[3])]=((74.074074074074)*1.)
set nKv[(ZBe[3])]=("Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdx")set NPv[(ZBe[3])]=(($E6)*1.)
set I8v[(ZBe[3])]=((2)*1.)set Anv[(ZBe[3])]=(2)set Nmv[(ZBe[3])]=((550)*1.)
set NLv[(ZBe[3])]=((550)*1.)
set NKv[(ZBe[3])]=((0)*1.)set Ncv[(ZBe[3])]=(($578)*1.)set Nbv[(ZBe[3])]=(($578)*1.)set NGv[(ZBe[3])]=((30)*1.)set Adv[(ZBe[3])]=(gmv)set AGv[(ZBe[3])]=((720)*1.)
set Ahv[((ZBe[3]))]=((1.*1./((1.6)*1.))*1.)set AWv[(ZBe[3])]=((.4)*1.)set Dnv[(ZBe[3])]=(($514)*1.)set Auv[(ZBe[3])]=((22)*1.)set AUv[(ZBe[3])]=((22)*1.)set AYv[(ZBe[3])]=(3)set A_v[(ZBe[3])]=(3)set A2v[(ZBe[3])]=(1)set ATv[(ZBe[3])]=((39.506172839506)*1.)
return trueendfunctionfunction WTr takes nothing returns booleanset ZBe[4]=hjo('uWB4')call hJo(((ZBe[4])),ASv,(Idv))set Uj[(ZBe[4])]=((1.2)*1.)set NOv[(ZBe[4])]=((148.14814814815)*1.)
set NWv[(ZBe[4])]=((74.074074074074)*1.)
set nKv[(ZBe[4])]=("Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdx")set NPv[(ZBe[4])]=(($E6)*1.)
set I8v[(ZBe[4])]=((2)*1.)set Anv[(ZBe[4])]=(2)set Nmv[(ZBe[4])]=((675)*1.)
set NLv[(ZBe[4])]=((675)*1.)
set NKv[(ZBe[4])]=((0)*1.)set Ncv[(ZBe[4])]=(($578)*1.)set Nbv[(ZBe[4])]=(($578)*1.)set NGv[(ZBe[4])]=((30)*1.)set Adv[(ZBe[4])]=(gmv)set AGv[(ZBe[4])]=((720)*1.)
set Ahv[((ZBe[4]))]=((1.*1./((1.6)*1.))*1.)set AWv[(ZBe[4])]=((.4)*1.)set Dnv[(ZBe[4])]=(($514)*1.)set Auv[(ZBe[4])]=((26)*1.)set AUv[(ZBe[4])]=((26)*1.)set AYv[(ZBe[4])]=(3)set A_v[(ZBe[4])]=(3)set A2v[(ZBe[4])]=(1)set ATv[(ZBe[4])]=((39.506172839506)*1.)
return trueendfunctionfunction Wur takes nothing returns booleanset ZBe[1]=hjo('uWB1')call hJo(((ZBe[1])),ASv,(Idv))set Uj[(ZBe[1])]=((.9)*1.)set NOv[(ZBe[1])]=((148.14814814815)*1.)
set NWv[(ZBe[1])]=((74.074074074074)*1.)
set nKv[(ZBe[1])]=("Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdx")set NPv[(ZBe[1])]=(($E6)*1.)
set I8v[(ZBe[1])]=((1)*1.)set Anv[(ZBe[1])]=(2)set Nmv[(ZBe[1])]=((300)*1.)
set NLv[(ZBe[1])]=((300)*1.)
set NKv[(ZBe[1])]=((0)*1.)set Ncv[(ZBe[1])]=(($578)*1.)set Nbv[(ZBe[1])]=(($578)*1.)set NGv[(ZBe[1])]=((30)*1.)set Adv[(ZBe[1])]=(gmv)set AGv[(ZBe[1])]=((720)*1.)
set Ahv[((ZBe[1]))]=((1.*1./((1.6)*1.))*1.)set AWv[(ZBe[1])]=((.4)*1.)set Dnv[(ZBe[1])]=(($514)*1.)set Auv[(ZBe[1])]=(($E)*1.)set AUv[(ZBe[1])]=(($E)*1.)set AYv[(ZBe[1])]=(2)set A_v[(ZBe[1])]=(3)set A2v[(ZBe[1])]=(1)set ATv[(ZBe[1])]=((39.506172839506)*1.)
return trueendfunctionfunction WUr takes nothing returns booleanset Zce[1]=35set Zce[2]=35set Zce[3]=35set Zce[4]=35set Zce[5]=35set Zce[6]=35set ZCe[1]=2
set ZCe[2]=3
set ZCe[3]=4
set ZCe[4]=5
set ZCe[5]=6
set ZCe[6]=7
return trueendfunctionfunction Wwr takes nothing returns booleanset ZBe[5]=hjo('uWB5')call hJo(((ZBe[5])),ASv,(Idv))set Uj[(ZBe[5])]=((1.3)*1.)set NOv[(ZBe[5])]=((148.14814814815)*1.)
set NWv[(ZBe[5])]=((74.074074074074)*1.)
set nKv[(ZBe[5])]=("Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdx")set NPv[(ZBe[5])]=(($E6)*1.)
set I8v[(ZBe[5])]=((3)*1.)set Anv[(ZBe[5])]=(2)set Nmv[(ZBe[5])]=((800)*1.)
set NLv[(ZBe[5])]=((800)*1.)
set NKv[(ZBe[5])]=((0)*1.)set Ncv[(ZBe[5])]=(($578)*1.)set Nbv[(ZBe[5])]=(($578)*1.)set NGv[(ZBe[5])]=((30)*1.)set Adv[(ZBe[5])]=(gmv)set AGv[(ZBe[5])]=((720)*1.)
set Ahv[((ZBe[5]))]=((1.*1./((1.6)*1.))*1.)set AWv[(ZBe[5])]=((.4)*1.)set Dnv[(ZBe[5])]=(($514)*1.)set Auv[(ZBe[5])]=((30)*1.)set AUv[(ZBe[5])]=((30)*1.)set AYv[(ZBe[5])]=(3)set A_v[(ZBe[5])]=(4)set A2v[(ZBe[5])]=(1)set ATv[(ZBe[5])]=((39.506172839506)*1.)
return trueendfunctionfunction WWr takes nothing returns booleancall VNx(sa,(function Wsr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Summon\\obj_thisUnitTypes[6]_wc3unit.j"))call VNx(sa,(function WSr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Summon\\obj_thisUnitTypes[2]_wc3unit.j"))call VNx(sa,(function Wtr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Summon\\obj_thisUnitTypes[3]_wc3unit.j"))call VNx(sa,(function WTr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Summon\\obj_thisUnitTypes[4]_wc3unit.j"))call VNx(sa,(function Wur),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Summon\\obj_thisUnitTypes[1]_wc3unit.j"))call VNx(va,(function WUr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Summon\\obj_this_wc3obj.j"))call VNx(sa,(function Wwr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Summon\\obj_thisUnitTypes[5]_wc3unit.j"))return trueendfunctionfunction Wyr takes nothing returns booleanset Zde=VXx(ZDe)
return trueendfunctionfunction WYr takes nothing returns booleancall L1x('AWaB',false)set Gjv=L0o('AWaB')set K6[(Gjv)]=(O6)set m6[(Gjv)]=(6)set TH[(Gjv)]=("Water Bindings")
set Rh[(Gjv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0272)))),(((Aj))))))set oxv[(Gjv)]=(0)set x3v[(Gjv)]=("spell")
call L1o((Gjv),GH+(1),((20)*1.))
call L1o((Gjv),tH+(1),((70)*1.))
call L1o((Gjv),Lov+(1),((650)*1.))call L1o((Gjv),GH+(2),((19)*1.))
call L1o((Gjv),tH+(2),((85)*1.))
call L1o((Gjv),Lov+(2),((650)*1.))call L1o((Gjv),GH+(3),((18)*1.))
call L1o((Gjv),tH+(3),(('d')*1.))call L1o((Gjv),Lov+(3),((650)*1.))call L1o((Gjv),GH+(4),((17)*1.))
call L1o((Gjv),tH+(4),(('x')*1.))call L1o((Gjv),Lov+(4),((650)*1.))call L1o((Gjv),GH+(5),((16)*1.))
call L1o((Gjv),tH+(5),(($8C)*1.))call L1o((Gjv),Lov+(5),((650)*1.))call L1o((Gjv),GH+(6),(($F)*1.))
call L1o((Gjv),tH+(6),(($A0)*1.))call L1o((Gjv),Lov+(6),((650)*1.))set MOv[(Gjv)]=("ReplaceableTextures\\CommandButtons\\BTNSummonWaterElemental.blp")call cDr(Gjv,'FWB0',6,'VWB0','LPWB','LRWB')return trueendfunctionfunction Wzr takes nothing returns booleancall VNx(Pa,(function WYr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction WZr takes nothing returns booleanset Zfe=VXx(ZFe)
return trueendfunctionfunction W_r takes integer Cqx,integer rYx,integer Iix returns nothinglocal integer C3o=(ze[(Cqx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local real dVx=(GetUnitX(C[((Iix))]))local real dEx=(GetUnitY(C[((Iix))]))local real bex=Ufx(Cqx,dVx-wQo,dEx-wso)local integer IOr=U0o(ZBe[rYx],C3o,wQo+Zge*(Cos(((((bex)*1.))*1.))),wso+Zge*(Sin(((((bex)*1.))*1.))),bex,Zce[rYx])local real W0rcall Avx(IOr,ZGe)set W0r=ZCe[rYx]
set Zhe[(IOr)]=W0rset ZHe[(IOr)]=Cqxcall pho(Cqx,W0r)call r0x((IOr),(Zje),(rYx))returncall r0x((IOr),(ZJe),(rYx))call Q0x((C3o),B[(ZJe)],(true))call Lox((IOr),(Rh[((ZJe))]),(Iix))call Q0x((C3o),B[(ZJe)],(false))
endfunctionfunction W1r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])call W_r(Cqx,rYx,Iix)return trueendfunctionfunction W2r takes nothing returns booleanlocal integer rFx=(bv)local integer IOr=(Vv[(rFx)])local integer oSx=IOrcall RPx(IOr,ZGe)call pgo(ZHe[oSx],Zhe[oSx])return trueendfunctionfunction W3r takes nothing returns booleancall mro(Gjv,Xdx("WaterBindings_Init: call WaterBindings.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function WaterBindings.Event_SpellEffect))",ih,MI,function W1r))
set ZGe=Xdx("FolderWaterBindings_StructSummon_Init: set FolderWaterBindings_StructSummon.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function FolderWaterBindings_StructSummon.Event_Destroy)",EP,MI,function W2r)return trueendfunctionfunction W4r takes nothing returns booleancall FAr(function W3r,"WaterBindings_Init")return trueendfunctionfunction W5r takes nothing returns booleanset Zke=ltx(ZKe+" (dummyBuff)")set Pc[(Zke)]=(true)
set WU=l_x()
call vAr(WU,dsv,true)call vAr(WU,djv,true)call l3x(((Zke)),ZB+(1),(WU))set WU=l_x()
call vAr(WU,dsv,true)call vAr(WU,djv,true)call l3x(((Zke)),ZB+(2),(WU))set WU=l_x()
call vAr(WU,dsv,true)call vAr(WU,djv,true)call l3x(((Zke)),ZB+(3),(WU))set WU=l_x()
call vAr(WU,dsv,true)call vAr(WU,djv,true)call l3x(((Zke)),ZB+(4),(WU))set WU=l_x()
call vAr(WU,dsv,true)call vAr(WU,djv,true)call l3x(((Zke)),ZB+(5),(WU))set WU=l_x()
call vAr(WU,dsv,true)call vAr(WU,djv,true)call l3x(((Zke)),ZB+(6),(WU))return trueendfunctionfunction W6r takes nothing returns booleancall L1x('AWBS',false)set ZJe=L0o('AWBS')set K6[(ZJe)]=(H6)set m6[(ZJe)]=(1)set TH[(ZJe)]=("Water Bindings Lariat")set Rh[(ZJe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0272)))),(((Aj))))))set oxv[(ZJe)]=(4)set x3v[(ZJe)]=("attack")call L1o((ZJe),dH+(1),((5)*1.))call L1o((ZJe),GH+(1),((0)*1.))call L1o((ZJe),tH+(1),((0)*1.))call L1o((ZJe),Lov+(1),((99999)*1.))
set Zle[1]=.25set ZLe[1]=7
return trueendfunctionfunction W7r takes nothing returns booleanset Zme=VCx("OWBS")return trueendfunctionfunction W8r takes nothing returns booleancall VNx(ma,(function W5r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Lariat.page\\Lariat.struct\\obj_dummyBuff_wc3buff.j"))
call VNx(Pa,(function W6r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Lariat.page\\Lariat.struct\\obj_thisSpell_wc3spell.j"))call VNx(ha,(function W7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\Lariat.page\\Lariat.struct\\obj_bolt_wc3bolt.j"))return trueendfunctionfunction W9r takes nothing returns booleanset ZMe=VXx(ZKe)
return trueendfunctionfunction yvr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])return trueendfunctionfunction yer takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oMx=CIx(Iix,Zpe)local integer oSxlocal integer Cqxloop
exitwhen(oMx<q)set oSx=CAx(Iix,Zpe,oMx)
set Cqx=oSxcall CCx(Cqx)set oMx=oMx-1endloopreturn trueendfunctionfunction yxr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Cqx=oSxcall nlo((Cqx),(ZSe[oSx]),((ZPe[oSx])*1.),(true),(false))endfunctionfunction yor takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local integer oSx=Cqxlocal integer cMo=cdo(Zme)local integer p3x=iXx()set ZPe[oSx]=Zqe[rYx]set ZQe[oSx]=cMo
set Zse[oSx]=p3x
set ZSe[oSx]=Iix
set ge[(p3x)]=(oSx)if rUx(Iix,Zpe,oSx)thencall Dux((Iix),(Zke),(1),w)endifcall ERr(cMo,Cqx,Iix)call iDx(p3x,Zle[rYx],true,function yxr)
return trueendfunctionfunction yrr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local boolean ELo=(oav[(rFx)])local integer oSx=Cqxlocal integer cMo=ZQe[oSx]local integer p3x=Zse[oSx]local integer Iix=ZSe[oSx]call K0x(cMo)call iKx(p3x)if rnx(Iix,Zpe,oSx)thencall AZx(Iix,Zke)endifif ELo thencall Lox(Cqx,bw,Iix)
endifreturn trueendfunctionfunction yir takes nothing returns booleanlocal integer oMxcall Lxx(Zke,Xdx("Lariat_Init: call Lariat.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Lariat.Event_BuffGain))",bd,MI,function yvr))call Lxx(Zke,Xdx("Lariat_Init: call Lariat.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Lariat.Event_BuffLose))",jc,MI,function yer))call mro(ZJe,Xdx("Lariat_Init: call Lariat.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Lariat.Event_SpellEffect))",ih,MI,function yor))call mro(ZJe,Xdx("Lariat_Init: call Lariat.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Lariat.Event_EndCast))",onv,MI,function yrr))
set oMx=(m6[(ZJe)])loop
set Zqe[oMx]=ZLe[oMx]*Zle[oMx]set oMx=oMx-1exitwhen(oMx<1)endloopreturn trueendfunctionfunction yar takes nothing returns booleancall FAr(function yir,"Lariat_Init")
return trueendfunctionfunction ynr takes nothing returns booleanset Zte[1]=Wwx('BSA1',"Soaking wet",'bSA1')set anv[(Zte[1])]=("ReplaceableTextures\\PassiveButtons\\PASBTNPlagueCloud.blp")
call lWx(Zte[1],"Abilities\\Spells\\Items\\AIob\\AIobTarget.mdl","head",ri)set WU=l_x()
call l2x(WU,dmv,-35)
call l2x(WU,nnv,-.1)
call l3x(((Zte[1])),ZB+(1),(WU))
set WU=l_x()
call l2x(WU,dmv,-35)
call l2x(WU,nnv,-.1)
call l3x(((Zte[1])),ZB+(2),(WU))
set WU=l_x()
call l2x(WU,dmv,-35)
call l2x(WU,nnv,-.1)
call l3x(((Zte[1])),ZB+(3),(WU))
set WU=l_x()
call l2x(WU,dmv,-35)
call l2x(WU,nnv,-.1)
call l3x(((Zte[1])),ZB+(4),(WU))
set WU=l_x()
call l2x(WU,dmv,-35)
call l2x(WU,nnv,-.1)
call l3x(((Zte[1])),ZB+(5),(WU))
set WU=l_x()
call l2x(WU,dmv,-35)
call l2x(WU,nnv,-.1)
call l3x(((Zte[1])),ZB+(6),(WU))
return trueendfunctionfunction yVr takes nothing returns booleanset ZTe[1]=2
set ZTe[2]=2
set ZTe[3]=2
set ZTe[4]=2
set ZTe[5]=2
set ZTe[6]=2
set Zue[1]=6
set Zue[2]=6
set Zue[3]=6
set Zue[4]=6
set Zue[5]=6
set Zue[6]=6
set ZUe[1]=-35set ZUe[2]=-35set ZUe[3]=-35set ZUe[4]=-35set ZUe[5]=-35set ZUe[6]=-35set Zwe[1]=-.1set Zwe[2]=-.1set Zwe[3]=-.1set Zwe[4]=-.1set Zwe[5]=-.1set Zwe[6]=-.1return trueendfunctionfunction yEr takes nothing returns booleanset ZWe=ltx(Zye+" (timerBuff)")return trueendfunctionfunction yXr takes nothing returns booleanset Zte[2]=Wwx('BSA2',"Soaking wet",'bSA2')set anv[(Zte[2])]=("ReplaceableTextures\\PassiveButtons\\PASBTNPlagueCloud.blp")
call lWx(Zte[2],"Abilities\\Spells\\Items\\AIob\\AIobTarget.mdl","hand left",ri)
set WU=l_x()
call l2x(WU,dmv,-35)
call l2x(WU,nnv,-.1)
call l3x(((Zte[2])),ZB+(1),(WU))
set WU=l_x()
call l2x(WU,dmv,-35)
call l2x(WU,nnv,-.1)
call l3x(((Zte[2])),ZB+(2),(WU))
set WU=l_x()
call l2x(WU,dmv,-35)
call l2x(WU,nnv,-.1)
call l3x(((Zte[2])),ZB+(3),(WU))
set WU=l_x()
call l2x(WU,dmv,-35)
call l2x(WU,nnv,-.1)
call l3x(((Zte[2])),ZB+(4),(WU))
set WU=l_x()
call l2x(WU,dmv,-35)
call l2x(WU,nnv,-.1)
call l3x(((Zte[2])),ZB+(5),(WU))
set WU=l_x()
call l2x(WU,dmv,-35)
call l2x(WU,nnv,-.1)
call l3x(((Zte[2])),ZB+(6),(WU))
return trueendfunctionfunction yOr takes nothing returns booleanset Zte[3]=Wwx('BSA3',"Soaking wet",'bSA3')set anv[(Zte[3])]=("ReplaceableTextures\\PassiveButtons\\PASBTNPlagueCloud.blp")
call lWx(Zte[3],"Abilities\\Spells\\Items\\AIob\\AIobTarget.mdl","hand right",ri)set WU=l_x()
call l2x(WU,dmv,-35)
call l2x(WU,nnv,-.1)
call l3x(((Zte[3])),ZB+(1),(WU))
set WU=l_x()
call l2x(WU,dmv,-35)
call l2x(WU,nnv,-.1)
call l3x(((Zte[3])),ZB+(2),(WU))
set WU=l_x()
call l2x(WU,dmv,-35)
call l2x(WU,nnv,-.1)
call l3x(((Zte[3])),ZB+(3),(WU))
set WU=l_x()
call l2x(WU,dmv,-35)
call l2x(WU,nnv,-.1)
call l3x(((Zte[3])),ZB+(4),(WU))
set WU=l_x()
call l2x(WU,dmv,-35)
call l2x(WU,nnv,-.1)
call l3x(((Zte[3])),ZB+(5),(WU))
set WU=l_x()
call l2x(WU,dmv,-35)
call l2x(WU,nnv,-.1)
call l3x(((Zte[3])),ZB+(6),(WU))
return trueendfunctionfunction yRr takes nothing returns booleancall VNx(ma,(function ynr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\SoakingAttack.page\\SoakingAttack.struct\\Target\\obj_ChargeBuff[1]_wc3buff.j"))call VNx(va,(function yVr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\SoakingAttack.page\\SoakingAttack.struct\\Target\\obj_this_wc3obj.j"))
call VNx(ma,(function yEr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\SoakingAttack.page\\SoakingAttack.struct\\Target\\obj_timerBuff_wc3buff.j"))call VNx(ma,(function yXr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\SoakingAttack.page\\SoakingAttack.struct\\Target\\obj_ChargeBuff[2]_wc3buff.j"))call VNx(ma,(function yOr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\SoakingAttack.page\\SoakingAttack.struct\\Target\\obj_ChargeBuff[3]_wc3buff.j"))return trueendfunctionfunction yIr takes nothing returns booleanset ZYe=VXx(Zye)
return trueendfunctionfunction yAr takes nothing returns booleancall L1x('ASoA',false)set Zje=L0o('ASoA')set K6[(Zje)]=(H6)set m6[(Zje)]=(1)set TH[(Zje)]=("Soaking Attack")
set x3v[(Zje)]=("spell")
call L1o((Zje),Lov+(1),((750)*1.))set MOv[(Zje)]=("ReplaceableTextures\\PassiveButtons\\PASBTNPlagueCloud.blp")return trueendfunctionfunction yNr takes nothing returns booleanset Zze=ltx(ZZe+" (dummyBuff)")call lWx(Zze,"Abilities\\Spells\\Items\\AIob\\AIobTarget.mdl","hand left",ri)call lWx(Zze,"Abilities\\Spells\\Items\\AIob\\AIobTarget.mdl","hand right",ri)return trueendfunctionfunction ybr takes nothing returns booleancall VNx(Pa,(function yAr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\SoakingAttack.page\\SoakingAttack.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function yNr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\WaterBindings.page\\WaterBindings.struct\\SoakingAttack.page\\SoakingAttack.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction yBr takes nothing returns booleanset Z_e=VXx(ZZe)
return trueendfunctionfunction ycr takes integer Iix returns booleanreturn( not(I9x(Iix,Ifv)))and( not(I9x(Iix,Igv)))endfunctionfunction yCr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])local integer Iix=oSxlocal integer rvx=Z1e[oSx]call AZx(Iix,Zte[rvx])set Z1e[oSx]=rvx-1call o_x("FolderSoakingAttack_StructTarget_Interval","call DebugEx(\"reduce to \"+I2S(count-1))","reduce to "+I2S(rvx-1))if(rvx==1)thencall AZx(Iix,ZWe)endifendfunctionfunction ydr takes integer rYx,integer Iix returns nothinglocal integer oSx=Iixlocal integer p3x=Z2e[oSx]local real iMxif I9x(Iix,Wd)thenset iMx=ZTe[rYx]
else
set iMx=Zue[rYx]
endifcall iDx(p3x,iMx,true,function yCr)endfunctionfunction yDr takes integer Cqx,integer rYx,integer Iix returns nothinglocal integer rvxlocal integer oSx=Iixif((osx((((Iix))),(Wb+(ZWe)))>0)==false)then
set rvx=1else
set rvx=(R2I(((iUx((Z1e[oSx]+1),(3)))*1.)))endifset Z1e[oSx]=rvx
call o_x("FolderSoakingAttack_StructTarget_Start","call DebugEx(\"apply \"+I2S(count))","apply "+I2S(rvx))call Dux((Iix),(Zte[rvx]),(rYx),w)call Dux((Iix),(ZWe),(1),w)call ydr(rYx,Iix)endfunctionfunction yfr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])if not ycr(Iix)thenreturn trueendifcall yDr((E2v[(rFx)]),(osx((((E2v[(rFx)]))),N+(Zje))),Iix)return trueendfunctionfunction yFr takes nothing returns booleanlocal integer rFx=(bv)call Avx((Vv[(rFx)]),Z0e)return trueendfunctionfunction ygr takes nothing returns booleanlocal integer rFx=(bv)call RPx((Vv[(rFx)]),Z0e)return trueendfunctionfunction yGr takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(Zze),((Mv[(rFx)])),w)return trueendfunctionfunction yhr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),Zze)return trueendfunctionfunction yHr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer p3x=iXx()set Z2e[oSx]=p3x
set ge[(p3x)]=(oSx)return trueendfunctionfunction yjr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer rvx=Z1e[oSx]local integer p3x=Z2e[oSx]call iKx(p3x)loop
exitwhen(rvx<1)call AZx(Iix,Zte[rvx])set rvx=rvx-1endloopreturn trueendfunctionfunction yJr takes nothing returns nothingcall Lxx(ZWe,Xdx("FolderSoakingAttack_StructTarget_Init: call FolderSoakingAttack_StructTarget.TIMER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSoakingAttack_StructTarget.Event_Timer_BuffGain))",bd,MI,function yHr))call Lxx(ZWe,Xdx("FolderSoakingAttack_StructTarget_Init: call FolderSoakingAttack_StructTarget.TIMER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderSoakingAttack_StructTarget.Event_Timer_BuffLose))",jc,MI,function yjr))endfunctionfunction ykr takes nothing returns booleanset Z0e=Xdx("SoakingAttack_Init: set SoakingAttack.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function SoakingAttack.Event_Damage)",E4v,MI,function yfr)call Lxx(Zze,Xdx("SoakingAttack_Init: call SoakingAttack.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoakingAttack.Event_BuffGain))",bd,MI,function yFr))call Lxx(Zze,Xdx("SoakingAttack_Init: call SoakingAttack.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoakingAttack.Event_BuffLose))",jc,MI,function ygr))call mro(Zje,Xdx("SoakingAttack_Init: call SoakingAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoakingAttack.Event_Learn))",pv,MI,function yGr))call mro(Zje,Xdx("SoakingAttack_Init: call SoakingAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function SoakingAttack.Event_Unlearn))",Av,MI,function yhr))call yJr()return trueendfunctionfunction yKr takes nothing returns booleancall FAr(function ykr,"SoakingAttack_Init")return trueendfunctionfunction ylr takes nothing returns booleanset Z3e[1]=.2set Z3e[2]=.3set Z3e[3]=.4return trueendfunctionfunction yLr takes nothing returns booleanset Z4e=Wwx('BZoW',"Zodiac - winged",'bZoW')
set aav[(Z4e)]=(true)set anv[(Z4e)]=("ReplaceableTextures\\CommandButtons\\BTNRegenerate.blp")call lWx(Z4e,"Abilities\\Spells\\NightElf\\Tranquility\\TranquilityTarget.mdl","origin",ri)set WU=l_x()
call l2x(WU,iw,.2)call l3x(((Z4e)),ZB+(1),(WU))set WU=l_x()
call l2x(WU,iw,.3)call l3x(((Z4e)),ZB+(2),(WU))set WU=l_x()
call l2x(WU,iw,.4)call l3x(((Z4e)),ZB+(3),(WU))return trueendfunctionfunction ymr takes nothing returns booleancall VNx(va,(function ylr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Zodiac.page\\ZodiacAura.struct\\Target\\obj_this_wc3obj.j"))
call VNx(ma,(function yLr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Zodiac.page\\ZodiacAura.struct\\Target\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction yMr takes nothing returns booleanset Z5e=VXx(Z6e)
return trueendfunctionfunction ypr takes nothing returns booleanset Z7e[1]=.05set Z7e[2]=.1set Z7e[3]=.15set Z8e[1]=5
set Z8e[2]=$Aset Z8e[3]=$Freturn trueendfunctionfunction yPr takes nothing returns booleanset Z9e=ltx(vvx+" (dummyBuff)")return trueendfunctionfunction yqr takes nothing returns booleancall VNx(va,(function ypr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Zodiac.page\\ZodiacAura.struct\\obj_this_wc3obj.j"))
call VNx(ma,(function yPr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Zodiac.page\\ZodiacAura.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction yQr takes nothing returns booleanset vex=VXx(vvx)
return trueendfunctionfunction ysr takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif not(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction ySr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=(pj[(rFx)])call cjx(Iix,vix[oSx])return trueendfunctionfunction ytr takes nothing returns nothinglocal integer oSx=(ge[((LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re)))))))])call Dgx((vPe[(vox[oSx])]),function ySr,oSx)
endfunctionfunction yTr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Lc[(rFx)])local integer rYx=(hc[(rFx)])local integer o0x=(Vv[(rFx)])local integer oSx=o0xlocal integer Xur=XQr(Cqx)local integer p3x=iXx()set vox[oSx]=Xur
set vrx[oSx]=Cqx
set vix[oSx]=vax[rYx]+(xg[(Cqx)])*Z7e[rYx]*vnxset vVx[oSx]=p3x
set vEx[oSx]=rYx
set Ene[(Xur)]=(oSx)
set ge[(p3x)]=(oSx)set vqe[(Xur)]=(((CQx((Gzv),Uvv+(rYx))))*1.)
set vQe[(Xur)]=(vxx)
call Xsr(Xur,vXx)call Xsr(Xur,vOx)call Xtr(Xur)call iDx(p3x,vnx,true,function ytr)return trueendfunctionfunction yur takes nothing returns booleanlocal integer rFx=(bv)local integer o0x=(Vv[(rFx)])local integer oSx=o0xlocal integer Xur=vox[oSx]local integer p3x=vVx[oSx]call X5r(Xur)call iKx(p3x)return trueendfunctionfunction yUr takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer rLx=(Ene[(Xur)])call Ulx(Iix,Z4e)return trueendfunctionfunction ywr takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer Cqx=(vke[(Xur)])local integer rLx=(Ene[(Xur)])local integer rYx=vEx[rLx]call Dux((Iix),(Z4e),(rYx),w)return trueendfunctionfunction yWr takes nothing returns nothingset vXx=Xdx("FolderZodiacAura_StructTarget_Init: set FolderZodiacAura_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderZodiacAura_StructTarget.Event_Ending)",vTe,MI,function yUr)set vOx=Xdx("FolderZodiacAura_StructTarget_Init: set FolderZodiacAura_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderZodiacAura_StructTarget.Event_Start)",vue,MI,function ywr)endfunctionfunction yyr takes nothing returns booleanlocal integer oMxset vxx=Xpx(function ysr)call Lxx(Z9e,Xdx("ZodiacAura_Init: call ZodiacAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ZodiacAura.Event_BuffGain))",bd,MI,function yTr))call Lxx(Z9e,Xdx("ZodiacAura_Init: call ZodiacAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function ZodiacAura.Event_BuffLose))",jc,MI,function yur))set oMx=(m6[(Gzv)])loop
exitwhen(oMx<1)set vax[oMx]=Z8e[oMx]*vnxset oMx=oMx-1endloopcall yWr()return trueendfunctionfunction yYr takes nothing returns booleancall FAr(function yyr,"ZodiacAura_Init")
return trueendfunctionfunction yzr takes nothing returns booleanset vRx=Wwx('BZod',"Zodiac",'bZod')set aav[(vRx)]=(true)set Pc[(vRx)]=(true)
set anv[(vRx)]=("ReplaceableTextures\\CommandButtons\\BTNGenericSpellImmunity.blp")call lWx(vRx,"Zodiac_page\\Zodiac_struct\\casterEffect.mdx","origin",ri)
return trueendfunctionfunction yZr takes nothing returns booleancall L1x('AZod',false)set Gzv=L0o('AZod')set K6[(Gzv)]=(G6)set m6[(Gzv)]=(3)set TH[(Gzv)]=("Zodiac")
set Rh[(Gzv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0104)))),(((Aj))))))set oxv[(Gzv)]=(4)set x3v[(Gzv)]=("spell")
call L1o((Gzv),Uvv+(1),((750)*1.))call L1o((Gzv),GH+(1),(($96)*1.))call L1o((Gzv),Lov+(1),(($3E8)*1.))call L1o((Gzv),Uvv+(2),((750)*1.))call L1o((Gzv),GH+(2),(($87)*1.))call L1o((Gzv),Lov+(2),(($3E8)*1.))call L1o((Gzv),Uvv+(3),((750)*1.))call L1o((Gzv),GH+(3),(('x')*1.))call L1o((Gzv),Lov+(3),(($3E8)*1.))set MOv[(Gzv)]=("ReplaceableTextures\\CommandButtons\\BTNEnchantedCrows.blp")call cDr(Gzv,'FZo0',3,'VZo0','LPZo','LRZo')set vIx[1]=$Fset vIx[2]=20set vIx[3]=25return trueendfunctionfunction y_r takes nothing returns booleancall VNx(ma,(function yzr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Zodiac.page\\Zodiac.struct\\obj_dummyBuff_wc3buff.j"))call VNx(Pa,(function yZr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Hero\\Zodiac.page\\Zodiac.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction y0r takes nothing returns booleanset vAx=VXx(vNx)
return trueendfunctionfunction y1r takes integer oSx returns integerset vbx[oSx]=trueset vBx[oSx]=falsecall rEx(vAx)return oSxendfunctionfunction y2r takes integer o0x,integer Cqx,integer rYx returns nothingcall Dux(o0x,Z9e,rYx,Cqx)endfunctionfunction y3r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Lc[(rFx)])local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=y1r(Iix)call Dux((((Iix))),(iOv),(1),w)call y2r(Iix,Cqx,rYx)return trueendfunctionfunction y4r takes integer oSx returns nothingset vbx[oSx]=falsecall rHx(vAx)endfunctionfunction y5r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall y4r(oSx)call Ulx(((Iix)),iOv)call AZx(Iix,Z9e)return trueendfunctionfunction y6r takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])call Nbx(Iix,vRx,rYx,Cqx,vIx[rYx])return trueendfunctionfunction y7r takes nothing returns booleancall Lxx(vRx,Xdx("Zodiac_Init: call Zodiac.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Zodiac.Event_BuffGain))",bd,MI,function y3r))call Lxx(vRx,Xdx("Zodiac_Init: call Zodiac.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Zodiac.Event_BuffLose))",jc,MI,function y5r))call mro(Gzv,Xdx("Zodiac_Init: call Zodiac.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Zodiac.Event_SpellEffect))",ih,MI,function y6r))return trueendfunctionfunction y8r takes nothing returns booleancall FAr(function y7r,"Zodiac_Init")
return trueendfunctionfunction y9r takes nothing returns booleancall L1x('ABHW',false)set vcx=L0o('ABHW')set m6[(vcx)]=(1)set TH[(vcx)]=("Big Healing Wave")set Rh[(vcx)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0215)))),(((Aj))))))set oxv[(vcx)]=(4)set x3v[(vcx)]=("spell")
call L1o((vcx),Uvv+(1),((99999)*1.))
call L1o((vcx),GH+(1),(($F)*1.))
call L1o((vcx),tH+(1),(('d')*1.))call L1o((vcx),Lov+(1),((99999)*1.))
set MOv[(vcx)]=("ReplaceableTextures\\CommandButtons\\BTNHealingWave.blp")return trueendfunctionfunction Yvr takes nothing returns booleanset vCx=VCx("OHWP")return trueendfunctionfunction Yer takes nothing returns booleanset vdx=VCx("OHWS")return trueendfunctionfunction Yxr takes nothing returns booleancall VNx(Pa,(function y9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\BigHealingWave.page\\BigHealingWave.struct\\obj_thisSpell_wc3spell.j"))call VNx(ha,(function Yvr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\BigHealingWave.page\\BigHealingWave.struct\\obj_Bolt_wc3bolt.j"))call VNx(ha,(function Yer),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\BigHealingWave.page\\BigHealingWave.struct\\obj_BoltSec_wc3bolt.j"))
return trueendfunctionfunction Yor takes nothing returns booleanset vDx=VXx(vfx)
return trueendfunctionfunction Yrr takes nothing returns booleanlocal integer Iix=jhx()if(I8x((Ose),Ob,(Iix)))thenreturn false
endifif I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Ifv)thenreturn false
endifif I9x(Iix,IFv)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif((IsUnitAlly(C[(Iix)],vx[(hf)]))==false)thenreturn false
endifreturn truereturn trueendfunctionfunction Yir takes integer oSx returns integerset vJx[oSx]=trueset vkx[oSx]=falsecall rEx(vDx)return oSxendfunctionfunction Yar takes nothing returns integerlocal integer oSxif(vGx==8190)thencall o_x("BigHealingWave_Allocation_allocCustom","call DebugEx(BigHealingWave.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",vfx+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(vhx[(w)]==w)thenset vHx=vHx+1set oSx=vHxelse
set oSx=vhx[(w)]
set vhx[(w)]=vhx[vhx[(w)]]endifset vhx[oSx]=Zset vjx[oSx]=1call Yir(oSx)return oSxendfunctionfunction Ynr takes integer oSx returns nothingset vJx[oSx]=falsecall rHx(vDx)endfunctionfunction YVr takes integer oSx returns nothingif(vjx[oSx]>0)thenreturnendifif(vhx[oSx]!=Z)thencall o_x("BigHealingWave_Allocation_deallocCustom_confirm","call DebugEx(BigHealingWave.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",vfx+" - alloc: unable to deallocCustom instance "+I2S(oSx))
returnendifset vhx[oSx]=vhx[(w)]set vhx[(w)]=oSx
call Ynr(oSx)endfunctionfunction YEr takes integer oSx returns nothingset vjx[oSx]=vjx[oSx]-1call YVr(oSx)endfunctionfunction YXr takes integer oSx returns nothingcall YEr((oSx))call iKx(vLx[oSx])call X_r(vMx[oSx])endfunctionfunction YOr takes integer oSx,integer pjr,integer EFr returns nothinglocal integer cMo=pFr((pjr==EFr),vCx,vdx)set vmx[oSx]=EFr
call mao(vlx[oSx],EFr,vQx*(rG[(EFr)]))call ERr(cMo,pjr,EFr)call pmo((ACx((EFr),(vsx),(vSx),(ri))),.0)call dQx(vMx[oSx],EFr)call cLo(cMo,.75)endfunctionfunction YRr takes nothing returns nothinglocal integer Cqxlocal integer Okx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((GetExpiredTimer())))))),((((Re))))))local integer pjrlocal real pkrlocal real pKrlocal integer EFrlocal integer oSx=(ge[(Okx)])local integer svo=vMx[oSx]local integer Efr=vpx[oSx]+1
if(Efr>vqx)thencall YXr(oSx)else
set Cqx=vlx[oSx]
set pjr=vmx[oSx]
set pkr=(GetUnitX(C[((pjr))]))set pKr=(GetUnitY(C[((pjr))]))set Ose=svoset hf=(ze[(Cqx)])call NVo(vFx,pkr,pKr,vKx[oSx],vgx)set EFr=(mKo((vFx),((pkr)*1.),((pKr)*1.)))if(EFr==w)thencall YXr(oSx)else
set vpx[oSx]=Efr
call YOr(oSx,pjr,EFr)endifendifendfunctionfunction YIr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local integer oSx=Yar()local integer Okx=iXx()set vKx[oSx]=(CQx((vcx),Uvv+(rYx)))set vlx[oSx]=Cqx
set vLx[oSx]=Okx
set vmx[oSx]=Iix
set vMx[oSx]=Jbx("BigHealingWave_Event_SpellEffect: set this.targetGroup = UnitList.Create()")set vpx[oSx]=1set ge[(Okx)]=(oSx)call iDx(Okx,vPx,true,function YRr)call YOr(oSx,Cqx,Iix)return trueendfunctionfunction YAr takes nothing returns booleanset vFx=O5x()set vgx=Xpx(function Yrr)call mro(vcx,Xdx("BigHealingWave_Init: call BigHealingWave.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BigHealingWave.Event_SpellEffect))",ih,MI,function YIr))return trueendfunctionfunction YNr takes nothing returns booleancall moo(function YAr,"BigHealingWave_Init")
return trueendfunctionfunction Ybr takes nothing returns booleancall L1x('ABuM',false)set vtx=L0o('ABuM')set m6[(vtx)]=(1)set TH[(vtx)]=("Burning Spirit (Meteorite)")
set Rh[(vtx)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0085)))),(((Aj))))))set oxv[(vtx)]=(4)set x3v[(vtx)]=("spell")
call L1o((vtx),GH+(1),((60)*1.))
call L1o((vtx),tH+(1),((60)*1.))
call L1o((vtx),Lov+(1),((99999)*1.))
set MOv[(vtx)]=("ReplaceableTextures\\CommandButtons\\BTNIncinerate.blp")return trueendfunctionfunction YBr takes nothing returns booleanset vTx=Wwx('BBu2',"Burning Spirit",'bBu2')set aav[(vTx)]=(true)set uU[(vTx)]=(true)
set anv[(vTx)]=("ReplaceableTextures\\CommandButtons\\BTNIncinerate.blp")call lWx(vTx,"Abilities\\Spells\\Orc\\Bloodlust\\BloodlustSpecial.mdl","hand left",ri)call lWx(vTx,"Abilities\\Spells\\Orc\\Bloodlust\\BloodlustSpecial.mdl","hand right",Bi)set WU=l_x()
call l2x(WU,nnv,.25)
call l2x(WU,BFv,.25)
call l2x(WU,iw,.25)call l3x(((vTx)),ZB+(1),(WU))return trueendfunctionfunction Ycr takes nothing returns booleancall VNx(Pa,(function Ybr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\BurningSpiritMeteorite.page\\BurningSpiritMeteorite.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function YBr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\BurningSpiritMeteorite.page\\BurningSpiritMeteorite.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction YCr takes nothing returns booleanset vux=VXx(vUx)
return trueendfunctionfunction Ydr takes integer oSx returns integerset vwx[oSx]=trueset vWx[oSx]=falsecall rEx(vux)return oSxendfunctionfunction YDr takes integer oSx returns nothingset vwx[oSx]=falsecall rHx(vux)endfunctionfunction Yfr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=vyx[oSx]local integer rYx=vYx[oSx]local integer Iix=vzx[oSx]call YDr(oSx)call MFo(Mho)call Nbx((Iix),(vTx),(rYx),w,((vZx)*1.))
return trueendfunctionfunction YFr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local integer Iix=(zH[(rFx)])local integer Mho=Moo()local integer oSx=Ydr(Mho)set vyx[oSx]=Cqx
set vYx[oSx]=rYx
set vzx[oSx]=Iix
set mCv[(Mho)]=((10.)*1.)call Mno(Mho,'qBSp',2.)set mFv[(Mho)]=Xkx((function Yfr))set mZv[(Mho)]=(oSx)
call Meo(Mho,900.)call pxo(Mho,Cqx)call M6o((Mho),(Iix),.0,.0,.0,(null))return trueendfunctionfunction Ygr takes nothing returns booleancall mro(vtx,Xdx("BurningSpiritMeteorite_Init: call BurningSpiritMeteorite.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BurningSpiritMeteorite.Event_SpellEffect))",ih,MI,function YFr))return trueendfunctionfunction YGr takes nothing returns booleancall moo(function Ygr,"BurningSpiritMeteorite_Init")
return trueendfunctionfunction Yhr takes nothing returns booleancall L1x('ABuL',false)set v_x=L0o('ABuL')set K6[(v_x)]=(H6)set m6[(v_x)]=(1)set TH[(v_x)]=("Burn Lumber")set Rh[(v_x)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0296)))),(((Aj))))))set oxv[(v_x)]=(0)set x3v[(v_x)]=("spell")
call L1o((v_x),GH+(1),(($A)*1.))
call L1o((v_x),tH+(1),((0)*1.))call L1o((v_x),Lov+(1),((750)*1.))set MOv[(v_x)]=("ReplaceableTextures\\CommandButtons\\BTNOrcLumberUpgradeTwo.blp")return trueendfunctionfunction YHr takes nothing returns booleancall VNx(Pa,(function Yhr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\BurnLumber.page\\BurnLumber.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Yjr takes nothing returns booleanset v0x=VXx(v1x)
return trueendfunctionfunction YJr takes nothing returns booleanlocal integer rFx=(bv)call TriggerRegisterUnitEvent(DA[((v2x))],C[((Vv[(rFx)]))],(EVENT_UNIT_SPELL_EFFECT))return trueendfunctionfunction Ykr takes nothing returns booleanlocal integer Cqx=Q2x()call mao(Cqx,Cqx,v3x)call mno(Cqx,Cqx,v4x)return trueendfunctionfunction YKr takes nothing returns booleanif((CKo(GetSpellAbilityId()))!=v_x)thenreturn false
endifreturn truereturn trueendfunctionfunction Ylr takes nothing returns booleancall mro(v_x,Xdx("BurnLumber_Init: call BurnLumber.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function BurnLumber.Event_Learn))",pv,MI,function YJr))
set v2x=XJx(function Ykr)call Cmo(v2x,function YKr)return trueendfunctionfunction YLr takes nothing returns booleancall moo(function Ylr,"BurnLumber_Init")
return trueendfunctionfunction Ymr takes nothing returns booleancall L1x('ACoF',false)set v5x=L0o('ACoF')set m6[(v5x)]=(1)set TH[(v5x)]=("Core Fusion")set Rh[(v5x)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D00FD)))),(((Aj))))))set oxv[(v5x)]=(0)set x3v[(v5x)]=("spell")
call L1o((v5x),GH+(1),((60)*1.))
call L1o((v5x),tH+(1),(($96)*1.))set MOv[(v5x)]=("ReplaceableTextures\\CommandButtons\\BTNUsedSoulGem.blp")return trueendfunctionfunction YMr takes nothing returns booleancall VNx(Pa,(function Ymr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\CoreFusion.page\\CoreFusion.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Ypr takes nothing returns booleanset v6x=VXx(v7x)
return trueendfunctionfunction YPr takes integer oSx,real oux returns nothingcall ctx(oSx,(JG[(oSx)])-oux)endfunctionfunction Yqr takes integer oSx returns nothingset rG[oSx]=GetUnitState(C[(oSx)],UNIT_STATE_MAX_LIFE)call cSx(oSx)endfunctionfunction YQr takes nothing returns nothingset bq=w
call Chx(Ge,PLAYER_STATE_RESOURCE_FOOD_USED,0)endfunctionfunction Ysr takes integer oSx,real iMx returns nothingcall tco(oSx)call iDx(Bq,iMx,false,function YQr)endfunctionfunction YSr takes nothing returns nothinglocal real Ytr=evxlocal real YTr=(oG[(lw)])local real s9olocal boolean Yur=(YTr<Ytr)if Yur thencall RPx(lw,eex)
call YPr(lw,(Ytr-YTr)*.5)call Yqr(lw)
call Avx(lw,eex)
endifset s9o=YTr*1./(rG[(lw)])set evx=YTrif(Qdv!=w)thencall s7o((Qdv),(s8o()))call fjx(lw,255.,s9o*255.,s9o*255.,255.)
endifcall Dyx(lw,(Uj[(exx)])*((1.-.4)*s9o+.4))if Yur thencall Ysr(eox,5.)
call Akx(erx)endifendfunctionfunction YUr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])call mao(Cqx,Cqx,v8x*(rG[(Cqx)]))call Nvo(Noo((GetUnitX(C[((Cqx))])),(GetUnitY(C[((Cqx))])),v9x,ri,5.))call YSr()return trueendfunctionfunction Ywr takes nothing returns booleancall mro(v5x,Xdx("CoreFusion_Init: call CoreFusion.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function CoreFusion.Event_SpellEffect))",ih,MI,function YUr))return trueendfunctionfunction YWr takes nothing returns booleancall moo(function Ywr,"CoreFusion_Init")
return trueendfunctionfunction Yyr takes nothing returns booleanset eix=ltx(enx+" (dummyBuff)")return trueendfunctionfunction YYr takes nothing returns booleanset eVx=ltx(enx+" (eclipseBuff)")set Pc[(eVx)]=(true)
return trueendfunctionfunction Yzr takes nothing returns booleancall L1x('ADaA',false)set gyv=L0o('ADaA')set K6[(gyv)]=(H6)set m6[(gyv)]=(6)set TH[(gyv)]=("Dark Attack")set x3v[(gyv)]=("spell")
call L1o((gyv),Lov+(1),((750)*1.))call L1o((gyv),Lov+(2),((750)*1.))call L1o((gyv),Lov+(3),((750)*1.))call L1o((gyv),Lov+(4),((750)*1.))call L1o((gyv),Lov+(5),((750)*1.))call L1o((gyv),Lov+(6),((750)*1.))set MOv[(gyv)]=("ReplaceableTextures\\CommandButtons\\PASBTNDarkAttack.blp")
set eEx[1]=3
set eEx[2]=3
set eEx[3]=3
set eEx[4]=3
set eEx[5]=3
set eEx[6]=3
set eXx[1]=6
set eXx[2]=6
set eXx[3]=6
set eXx[4]=6
set eXx[5]=6
set eXx[6]=6
return trueendfunctionfunction YZr takes nothing returns booleancall VNx(ma,(function Yyr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\DarkAttack.page\\DarkAttack.struct\\obj_dummyBuff_wc3buff.j"))call VNx(ma,(function YYr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\DarkAttack.page\\DarkAttack.struct\\obj_eclipseBuff_wc3buff.j"))
call VNx(Pa,(function Yzr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\DarkAttack.page\\DarkAttack.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Y_r takes nothing returns booleanset eOx=VXx(enx)
return trueendfunctionfunction Y0r takes integer Iix returns booleanreturn( not(I9x(Iix,Ifv)))and( not(I9x(Iix,Igv)))and( not(nbo(Iix)))
endfunctionfunction Y1r takes integer rYx,integer Iix returns nothinglocal real iMxif I9x(Iix,Wd)thenset iMx=eEx[rYx]
else
set iMx=eXx[rYx]
endifcall Nbx((Iix),(eVx),(rYx),w,((iMx)*1.))
endfunctionfunction Y2r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])call Ryx((ACx((Iix),(eIx),(eAx),(Bi))))if not Y0r(Iix)thenreturn trueendifcall Y1r((osx((((E2v[(rFx)]))),N+(gyv))),Iix)return trueendfunctionfunction Y3r takes nothing returns booleanlocal integer rFx=(bv)call Avx((Vv[(rFx)]),eRx)return trueendfunctionfunction Y4r takes nothing returns booleanlocal integer rFx=(bv)call RPx((Vv[(rFx)]),eRx)return trueendfunctionfunction Y5r takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(eix),((Mv[(rFx)])),w)return trueendfunctionfunction Y6r takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),eix)return trueendfunctionfunction Y7r takes nothing returns booleanset eRx=Xdx("DarkAttack_Init: set DarkAttack.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function DarkAttack.Event_Damage)",E4v,MI,function Y2r)call Lxx(eix,Xdx("DarkAttack_Init: call DarkAttack.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DarkAttack.Event_BuffGain))",bd,MI,function Y3r))call Lxx(eix,Xdx("DarkAttack_Init: call DarkAttack.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DarkAttack.Event_BuffLose))",jc,MI,function Y4r))call mro(gyv,Xdx("DarkAttack_Init: call DarkAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DarkAttack.Event_Learn))",pv,MI,function Y5r))
call mro(gyv,Xdx("DarkAttack_Init: call DarkAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function DarkAttack.Event_Unlearn))",Av,MI,function Y6r))
call W2x(EDv,eVx)return trueendfunctionfunction Y8r takes nothing returns booleancall moo(function Y7r,"DarkAttack_Init")
return trueendfunctionfunction Y9r takes nothing returns booleanset eNx=Wwx('BFoA',"Healed",'bFoA')set aav[(eNx)]=(true)set anv[(eNx)]=("ReplaceableTextures\\CommandButtons\\BTNHeal.blp")call lWx(eNx,"Abilities\\Spells\\Other\\ANrm\\ANrmTarget.mdl","origin",Bi)return trueendfunctionfunction zvr takes nothing returns booleancall VNx(ma,(function Y9r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\FountainAura.page\\FountainAura.struct\\Target\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction zer takes nothing returns booleanset ebx=VXx(eBx)
return trueendfunctionfunction zxr takes nothing returns booleanset ecx=ltx(eCx+" (dummyBuff)")return trueendfunctionfunction zor takes nothing returns booleancall L1x('AFoA',false)set GUv=L0o('AFoA')set K6[(GUv)]=(H6)set m6[(GUv)]=(1)set TH[(GUv)]=("Fountain Aura")set x3v[(GUv)]=("spell")
call L1o((GUv),Uvv+(1),((575)*1.))call L1o((GUv),Lov+(1),((750)*1.))set MOv[(GUv)]=("ReplaceableTextures\\CommandButtons\\")
return trueendfunctionfunction zrr takes nothing returns booleancall VNx(ma,(function zxr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\FountainAura.page\\FountainAura.struct\\obj_dummyBuff_wc3buff.j"))call VNx(Pa,(function zor),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\FountainAura.page\\FountainAura.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction zir takes nothing returns booleanset edx=VXx(eCx)
return trueendfunctionfunction zar takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif((oG[(Iix)])>=(R2I((((rG[(Iix)]))*1.))))thenreturn false
endifreturn truereturn trueendfunctionfunction znr takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer Xur=XQr(Iix)set efx[oSx]=Xur
set eFx[oSx]=rYx
set Ene[(Xur)]=(oSx)
set vqe[(Xur)]=(((CQx((GUv),Uvv+(rYx))))*1.)
set vQe[(Xur)]=(eDx)
call Xsr(Xur,egx)call Xsr(Xur,eGx)call Xtr(Xur)return trueendfunctionfunction zVr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall X5r(efx[oSx])return trueendfunctionfunction zEr takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(ecx),((Mv[(rFx)])),w)return trueendfunctionfunction zXr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),ecx)return trueendfunctionfunction zOr takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer rLx=(Ene[(Xur)])call Ulx(Iix,eNx)return trueendfunctionfunction zRr takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer Cqx=(vke[(Xur)])local integer rLx=(Ene[(Xur)])local integer rYx=eFx[rLx]call Dux((Iix),(eNx),(rYx),w)return trueendfunctionfunction zIr takes nothing returns nothingset egx=Xdx("FolderFountainAura_StructTarget_Init: set FolderFountainAura_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderFountainAura_StructTarget.Event_Ending)",vTe,MI,function zOr)
set eGx=Xdx("FolderFountainAura_StructTarget_Init: set FolderFountainAura_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderFountainAura_StructTarget.Event_Start)",vue,MI,function zRr)endfunctionfunction zAr takes nothing returns booleanset eDx=Xpx(function zar)call Lxx(ecx,Xdx("FountainAura_Init: call FountainAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FountainAura.Event_BuffGain))",bd,MI,function znr))
call Lxx(ecx,Xdx("FountainAura_Init: call FountainAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FountainAura.Event_BuffLose))",jc,MI,function zVr))
call mro(GUv,Xdx("FountainAura_Init: call FountainAura.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FountainAura.Event_Learn))",pv,MI,function zEr))call mro(GUv,Xdx("FountainAura_Init: call FountainAura.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FountainAura.Event_Unlearn))",Av,MI,function zXr))call zIr()return trueendfunctionfunction zNr takes nothing returns booleancall moo(function zAr,"FountainAura_Init")return trueendfunctionfunction zbr takes nothing returns booleanset ehx=ltx(eHx+" (dummyBuff)")return trueendfunctionfunction zBr takes nothing returns booleancall L1x('AFoH',false)set hov=L0o('AFoH')set K6[(hov)]=(H6)set m6[(hov)]=(1)set TH[(hov)]=("Fountain Heal")set oxv[(hov)]=(4)set x3v[(hov)]=("spell")
call L1o((hov),Uvv+(1),((0)*1.))
call L1o((hov),Lov+(1),((0)*1.))
set MOv[(hov)]=("ReplaceableTextures\\CommandButtons\\")
return trueendfunctionfunction zcr takes nothing returns booleancall L1x('AFHD',false)set ejx=L0o('AFHD')set K6[(ejx)]=(H6)set m6[(ejx)]=(1)set TH[(ejx)]=("Fountain Heal")set oxv[(ejx)]=(4)set x3v[(ejx)]=("spell")
call L1o((ejx),Lov+(1),((384)*1.))return trueendfunctionfunction zCr takes nothing returns booleancall VNx(ma,(function zbr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\FountainHeal.page\\FountainHeal.struct\\obj_dummyBuff_wc3buff.j"))call VNx(Pa,(function zBr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\FountainHeal.page\\FountainHeal.struct\\obj_thisSpell_wc3spell.j"))call VNx(Pa,(function zcr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\FountainHeal.page\\FountainHeal.struct\\obj_dummySpell_wc3spell.j"))
return trueendfunctionfunction zdr takes nothing returns booleanset eJx=VXx(eHx)
return trueendfunctionfunction zDr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqxlocal integer Iixlocal integer sRoif((Ah[(rFx)])!=N4)thenreturn trueendifset Cqx=(Vv[(rFx)])set Iix=(zH[(rFx)])set sRo=(ze[(Iix)])call rtx(Iix,'AFHD')
call Q0x(sRo,'AFHD',true)call Lox(Iix,h3,Cqx)
call Q0x(sRo,'AFHD',false)return trueendfunctionfunction zfr takes nothing returns booleanlocal integer rFx=(bv)call Avx((Vv[(rFx)]),ekx)return trueendfunctionfunction zFr takes nothing returns booleanlocal integer rFx=(bv)call RPx((Vv[(rFx)]),ekx)return trueendfunctionfunction zgr takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(ehx),((Mv[(rFx)])),w)return trueendfunctionfunction zGr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),ehx)return trueendfunctionfunction zhr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(zH[(rFx)])local integer Iix=(Vv[(rFx)])local real zHr=((rG[(Iix)])-(oG[(Iix)]))*1./ eKx
local real zjr=((LF[(Iix)])-(lF[(Iix)]))*1./ elx
local real zJr=zHr+zjrlocal real zkr=iUx((lF[(Cqx)]),zJr)call CCx(Iix)if(zkr<10.)thencall Oqx(Cqx,iSx((GetUnitName(C[(Cqx)]))+" empty or target nearly full","ffff0000"),.024,120.,1.,2.,eLx+Cqx)
return trueendifcall Ryx((ACx((Cqx),(emx),(eMx),(ri))))if(zHr>.0)thencall Ryx((ACx((Iix),(epx),(ePx),(ri))))call mao(Cqx,Iix,zkr*zHr*1./ zJr*eKx)endifif(zjr>.0)thencall Ryx((ACx((Iix),(eqx),(eQx),(ri))))call mno(Cqx,Iix,zkr*zjr*1./ zJr*elx)endifcall YCo(Cqx,zkr)return trueendfunctionfunction zKr takes nothing returns booleanset ekx=Xdx("FountainHeal_Init: set FountainHeal.ORDER_EVENT = Event.Create(UNIT.Order.Events.Gain.Target.TARGET_EVENT_TYPE, EventPriority.SPELLS, function FountainHeal.Event_Order)",Jj,MI,function zDr)call Lxx(ehx,Xdx("FountainHeal_Init: call FountainHeal.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FountainHeal.Event_BuffGain))",bd,MI,function zfr))
call Lxx(ehx,Xdx("FountainHeal_Init: call FountainHeal.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FountainHeal.Event_BuffLose))",jc,MI,function zFr))
call mro(hov,Xdx("FountainHeal_Init: call FountainHeal.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FountainHeal.Event_Learn))",pv,MI,function zgr))call mro(hov,Xdx("FountainHeal_Init: call FountainHeal.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FountainHeal.Event_Unlearn))",Av,MI,function zGr))call mro(ejx,Xdx("FountainHeal_Init: call FountainHeal.DUMMY_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.PRE_EVENT_TYPE, EventPriority.SPELLS, function FountainHeal.Event_SpellEffect))",dVv,MI,function zhr))return trueendfunctionfunction zlr takes nothing returns booleancall moo(function zKr,"FountainHeal_Init")return trueendfunctionfunction zLr takes nothing returns booleanset esx=ltx(eSx+" (coldnessBuff)")set Pc[(esx)]=(true)
return trueendfunctionfunction zmr takes nothing returns booleanset etx=ltx(eSx+" (dummyBuff)")return trueendfunctionfunction zMr takes nothing returns booleancall L1x('AFrA',false)set g3v=L0o('AFrA')set K6[(g3v)]=(H6)set m6[(g3v)]=(6)set TH[(g3v)]=("Frost Attack")set x3v[(g3v)]=("spell")
call L1o((g3v),Uvv+(1),(($8C)*1.))call L1o((g3v),Lov+(1),((750)*1.))call L1o((g3v),Uvv+(2),(($8C)*1.))call L1o((g3v),Lov+(2),((750)*1.))call L1o((g3v),Uvv+(3),(($8C)*1.))call L1o((g3v),Lov+(3),((750)*1.))call L1o((g3v),Uvv+(4),(($8C)*1.))call L1o((g3v),Lov+(4),((750)*1.))call L1o((g3v),Uvv+(5),(($8C)*1.))call L1o((g3v),Lov+(5),((750)*1.))call L1o((g3v),Uvv+(6),(($8C)*1.))call L1o((g3v),Lov+(6),((750)*1.))set MOv[(g3v)]=("ReplaceableTextures\\PassiveButtons\\PASBTNFreezingBreath.blp")
set eTx[1]=2
set eTx[2]=2.5set eTx[3]=3
set eTx[4]=3.5set eTx[5]=4
set eTx[6]=4.5return trueendfunctionfunction zpr takes nothing returns booleancall VNx(ma,(function zLr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\FrostAttack.page\\FrostAttack.struct\\obj_coldnessBuff_wc3buff.j"))call VNx(ma,(function zmr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\FrostAttack.page\\FrostAttack.struct\\obj_dummyBuff_wc3buff.j"))
call VNx(Pa,(function zMr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\FrostAttack.page\\FrostAttack.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction zPr takes nothing returns booleanset eux=VXx(eSx)
return trueendfunctionfunction zqr takes integer oSx returns reallocal integer oMx=(CIx(((oSx)),APv))
local real o7x=.0loop
exitwhen(oMx<q)set o7x=iAx(o7x,(AMv[((CAx(((oSx)),APv,(oMx))))]))set oMx=oMx-1endloopreturn o7xendfunctionfunction zQr takes integer Iix returns booleanreturn( not(I9x(Iix,Qc)))and( not(I9x(Iix,Ifv)))and( not(I9x(Iix,Igv)))and( not(nbo(Iix)))endfunctionfunction zsr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(E2v[(rFx)])local integer Iix=(Vv[(rFx)])local real dVx=(GetUnitX(C[((Iix))]))local real dEx=(GetUnitY(C[((Iix))]))local integer rYx=(osx(((Cqx)),N+(g3v)))
local real iMx=eTx[rYx]set hf=(ze[(Cqx)])call NVo(eUx,dVx,dEx,zqr(Cqx),eWx)call GroupRemoveUnit(kb[(eUx)],C[(Iix)])
if zQr(Iix)thencall Nbx((Iix),(esx),(rYx),w,((iMx)*1.))
endifset Iix=NEo(eUx)
if(Iix!=w)thenloop
call Nbx((Iix),(esx),(rYx),w,((iMx)*1.))
set Iix=NEo(eUx)
exitwhen(Iix==w)
endloopendifreturn trueendfunctionfunction zSr takes nothing returns booleanlocal integer Iix=jhx()if zQr(Iix)thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction ztr takes nothing returns booleanlocal integer rFx=(bv)call Avx((Vv[(rFx)]),ewx)return trueendfunctionfunction zTr takes nothing returns booleanlocal integer rFx=(bv)call RPx((Vv[(rFx)]),ewx)return trueendfunctionfunction zur takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(etx),((Mv[(rFx)])),w)return trueendfunctionfunction zUr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),etx)return trueendfunctionfunction zwr takes nothing returns booleanset eUx=O5x()set ewx=Xdx("FrostAttack_Init: set FrostAttack.GROUND_ATTACK_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function FrostAttack.Event_GroundAttack)",E4v,MI,function zsr)set eWx=Xpx(function zSr)call Lxx(etx,Xdx("FrostAttack_Init: call FrostAttack.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FrostAttack.Event_BuffGain))",bd,MI,function ztr))call Lxx(etx,Xdx("FrostAttack_Init: call FrostAttack.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FrostAttack.Event_BuffLose))",jc,MI,function zTr))call mro(g3v,Xdx("FrostAttack_Init: call FrostAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FrostAttack.Event_Learn))",pv,MI,function zur))call mro(g3v,Xdx("FrostAttack_Init: call FrostAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FrostAttack.Event_Unlearn))",Av,MI,function zUr))call W2x(nVv,esx)return trueendfunctionfunction zWr takes nothing returns booleancall moo(function zwr,"FrostAttack_Init")return trueendfunctionfunction zyr takes nothing returns booleanset eyx=ltx(eYx+" (dummyBuff)")return trueendfunctionfunction zYr takes nothing returns booleanset YMv=(L_o((eYx+" (thisSpell)")))set m6[(YMv)]=(1)set TH[(YMv)]=("Invisibility")set Rh[(YMv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0278)))),(((Aj))))))set x3v[(YMv)]=("spell")
return trueendfunctionfunction zzr takes nothing returns booleancall VNx(ma,(function zyr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\Invisibility.page\\Invisibility.struct\\obj_dummyBuff_wc3buff.j"))call VNx(Pa,(function zYr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\Invisibility.page\\Invisibility.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction zZr takes nothing returns booleanset ezx=VXx(eYx)
return trueendfunctionfunction z_r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall Dux((((Iix))),(nQv),(1),w)return trueendfunctionfunction z0r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall Ulx(((Iix)),nQv)return trueendfunctionfunction z1r takes nothing returns booleanlocal integer rFx=(bv)call seo((Vv[(rFx)]),eyx,(Mv[(rFx)]))return trueendfunctionfunction z2r takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),eyx)return trueendfunctionfunction z3r takes nothing returns booleancall Lxx(eyx,Xdx("Invisibility_Init: call Invisibility.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Invisibility.Event_BuffGain))",bd,MI,function z_r))
call Lxx(eyx,Xdx("Invisibility_Init: call Invisibility.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Invisibility.Event_BuffLose))",jc,MI,function z0r))
call mro(YMv,Xdx("Invisibility_Init: call Invisibility.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Invisibility.Event_Learn))",pv,MI,function z1r))call mro(YMv,Xdx("Invisibility_Init: call Invisibility.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Invisibility.Event_Unlearn))",Av,MI,function z2r))return trueendfunctionfunction z4r takes nothing returns booleancall moo(function z3r,"Invisibility_Init")return trueendfunctionfunction z5r takes nothing returns booleanset gtv=(L_o((eZx+" (thisSpell)")))set m6[(gtv)]=(1)set TH[(gtv)]=("Invulnerability")set Rh[(gtv)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0278)))),(((Aj))))))set x3v[(gtv)]=("spell")
return trueendfunctionfunction z6r takes nothing returns booleanset e_x=ltx(eZx+" (dummyBuff)")set WU=l_x()
call l3x(((e_x)),ZB+(1),(WU))return trueendfunctionfunction z7r takes nothing returns booleancall VNx(Pa,(function z5r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\Invulnerability.page\\Invulnerability.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function z6r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\Invulnerability.page\\Invulnerability.struct\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction z8r takes nothing returns booleanset e0x=VXx(eZx)
return trueendfunctionfunction z9r takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])call SetUnitInvulnerable(C[Iix],true)return trueendfunctionfunction Zvr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])call SetUnitInvulnerable(C[Iix],false)return trueendfunctionfunction Zer takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(e_x),((Mv[(rFx)])),w)return trueendfunctionfunction Zxr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),e_x)return trueendfunctionfunction Zor takes nothing returns booleancall Lxx(e_x,Xdx("Invulnerability_Init: call Invulnerability.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Invulnerability.Event_BuffGain))",bd,MI,function z9r))call Lxx(e_x,Xdx("Invulnerability_Init: call Invulnerability.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Invulnerability.Event_BuffLose))",jc,MI,function Zvr))call mro(gtv,Xdx("Invulnerability_Init: call Invulnerability.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Invulnerability.Event_Learn))",pv,MI,function Zer))call mro(gtv,Xdx("Invulnerability_Init: call Invulnerability.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Invulnerability.Event_Unlearn))",Av,MI,function Zxr))return trueendfunctionfunction Zrr takes nothing returns booleancall moo(function Zor,"Invulnerability_Init")return trueendfunctionfunction Zir takes nothing returns booleanset e1x=Wwx('BLap',"Lapidated",'bLap')set uU[(e1x)]=(true)
set anv[(e1x)]=("ReplaceableTextures\\CommandButtons\\BTNGolemStormBolt.blp")call lWx(e1x,"Abilities\\Weapons\\RockBoltMissile\\RockBoltMissile.mdl","origin",ri)
call lWx(e1x,"Abilities\\Weapons\\RockBoltMissile\\RockBoltMissile.mdl","foot left",Bi)call lWx(e1x,"Abilities\\Weapons\\RockBoltMissile\\RockBoltMissile.mdl","foot right",Bi)
call lWx(e1x,"Abilities\\Weapons\\RockBoltMissile\\RockBoltMissile.mdl","hand left",Bi)call lWx(e1x,"Abilities\\Weapons\\RockBoltMissile\\RockBoltMissile.mdl","hand right",Bi)
return trueendfunctionfunction Zar takes nothing returns booleancall VNx(ma,(function Zir),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\Lapidation.page\\Lapidation.struct\\Buff\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction Znr takes nothing returns booleanset e2x=VXx(e3x)
return trueendfunctionfunction ZVr takes nothing returns booleancall L1x('ALap',false)set e4x=L0o('ALap')set m6[(e4x)]=(1)set TH[(e4x)]=("Lapidation")
set Rh[(e4x)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0103)))),(((Aj))))))set oxv[(e4x)]=(2)set x3v[(e4x)]=("spell")
call L1o((e4x),Uvv+(1),((700)*1.))call L1o((e4x),GH+(1),((60)*1.))
call L1o((e4x),tH+(1),((80)*1.))
call L1o((e4x),Lov+(1),((99999)*1.))
set MOv[(e4x)]=("ReplaceableTextures\\CommandButtons\\BTNGolemStormBolt.blp")return trueendfunctionfunction ZEr takes nothing returns booleancall VNx(Pa,(function ZVr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\Lapidation.page\\Lapidation.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction ZXr takes nothing returns booleanset e5x=VXx(e6x)
return trueendfunctionfunction ZOr takes integer Iix returns booleanreturn( not(I9x(Iix,Qc)))and(I9x(Iix,Idv))and( not(I9x(Iix,Ifv)))and( not(IsUnitAlly(C[(Iix)],vx[(hf)])))endfunctionfunction ZRr takes nothing returns booleanreturn(ZOr(jhx()))endfunctionfunction ZIr takes integer oSx returns integerset xvx[oSx]=trueset xex[oSx]=falsecall rEx(e5x)return oSxendfunctionfunction ZAr takes integer oSx returns nothingset xvx[oSx]=falsecall rHx(e5x)endfunctionfunction ZNr takes integer rYx,integer Iix returns nothingcall Nbx((Iix),(e1x),(rYx),w,((xnx)*1.))
endfunctionfunction Zbr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=xxx[oSx]local real Nbo=xox[oSx]local integer rYx=xix[oSx]local integer Iix=xax[oSx]call ZAr(oSx)call MFo(Mho)set hf=(ze[(Cqx)])if ZOr(Iix)thencall ZNr(rYx,Iix)call nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))endifreturn trueendfunctionfunction ZBr takes integer Cqx,integer rYx,integer Iix returns nothinglocal integer Mho=Moo()local integer oSx=ZIr(Mho)set xxx[oSx]=Cqx
set xox[oSx]=xrx
set xix[oSx]=rYx
set xax[oSx]=Iix
set mcv[((Mho))]=((Bev*((.06)*1.))*1.)set mCv[(Mho)]=((10.)*1.)call Mno(Mho,'qLap',2.)set mFv[(Mho)]=Xkx((function Zbr))set mZv[(Mho)]=(oSx)
call Meo(Mho,1400.)call pxo(Mho,Cqx)call M6o((Mho),(Iix),.0,.0,.0,(null))endfunctionfunction Zcr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(Vv[(rFx)])local integer rYx=(Mv[(rFx)])local real dVx=(yH[(rFx)])local real dEx=(YH[(rFx)])local integer Iixlocal integer oMxset hf=(ze[(Cqx)])call NVo(e7x,dVx,dEx,(CQx((e4x),Uvv+(rYx))),e8x)
set Iix=(oXr((e7x)))
if(Iix!=w)thenset oMx=e9xloop
exitwhen(oMx<1)call GroupRemoveUnit(kb[(e7x)],C[(Iix)])
call ZBr(Cqx,rYx,Iix)set Iix=(oXr((e7x)))
exitwhen(Iix==w)
set oMx=oMx-1endloopendifreturn trueendfunctionfunction ZCr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall sxr(Iix,1.)
return trueendfunctionfunction Zdr takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall Qmr(Iix,1.)
return trueendfunctionfunction ZDr takes nothing returns nothingcall Lxx(e1x,Xdx("FolderLapidation_StructBuff_Init: call FolderLapidation_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderLapidation_StructBuff.Event_BuffGain))",bd,MI,function ZCr))call Lxx(e1x,Xdx("FolderLapidation_StructBuff_Init: call FolderLapidation_StructBuff.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function FolderLapidation_StructBuff.Event_BuffLose))",jc,MI,function Zdr))call W2x(Xwv,e1x)endfunctionfunction Zfr takes nothing returns booleanset e7x=O5x()set e8x=Xpx(function ZRr)call mro(e4x,Xdx("Lapidation_Init: call Lapidation.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function Lapidation.Event_SpellEffect))",ih,MI,function Zcr))call ZDr()return trueendfunctionfunction ZFr takes nothing returns booleancall moo(function Zfr,"Lapidation_Init")
return trueendfunctionfunction Zgr takes nothing returns booleancall L1x('ALiA',false)set GPv=L0o('ALiA')set K6[(GPv)]=(H6)set m6[(GPv)]=(6)set TH[(GPv)]=("Lightning Attack")set x3v[(GPv)]=("spell")
call L1o((GPv),Uvv+(1),((500)*1.))call L1o((GPv),Lov+(1),((750)*1.))call L1o((GPv),Uvv+(2),((500)*1.))call L1o((GPv),Lov+(2),((750)*1.))call L1o((GPv),Uvv+(3),((500)*1.))call L1o((GPv),Lov+(3),((750)*1.))call L1o((GPv),Uvv+(4),((500)*1.))call L1o((GPv),Lov+(4),((750)*1.))call L1o((GPv),Uvv+(5),((500)*1.))call L1o((GPv),Lov+(5),((750)*1.))call L1o((GPv),Uvv+(6),((500)*1.))call L1o((GPv),Lov+(6),((750)*1.))set MOv[(GPv)]=("ReplaceableTextures\\CommandButtons\\PASBTNLightningAttack.blp")set xVx[1]=$Aset xVx[2]=$Aset xVx[3]=$Aset xVx[4]=$Aset xVx[5]=$Aset xVx[6]=$Aset xEx[1]=2
set xEx[2]=3
set xEx[3]=3
set xEx[4]=4
set xEx[5]=4
set xEx[6]=5
set xXx[1]=1.25set xXx[2]=1.25set xXx[3]=1.25set xXx[4]=1.25set xXx[5]=1.25set xXx[6]=1.25set xOx[1]=.2set xOx[2]=.2set xOx[3]=.2set xOx[4]=.2set xOx[5]=.2set xOx[6]=.2set xRx[1]=20set xRx[2]=35set xRx[3]=50set xRx[4]=65set xRx[5]=80set xRx[6]=95return trueendfunctionfunction ZGr takes nothing returns booleanset xIx=VCx("OLAP")return trueendfunctionfunction Zhr takes nothing returns booleanset xAx=VCx("OLAS")return trueendfunctionfunction ZHr takes nothing returns booleanset xNx=ltx(xbx+" (dummyBuff)")return trueendfunctionfunction Zjr takes nothing returns booleancall VNx(Pa,(function Zgr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\LightningAttack.page\\LightningAttack.struct\\obj_thisSpell_wc3spell.j"))call VNx(ha,(function ZGr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\LightningAttack.page\\LightningAttack.struct\\obj_boltPrimary_wc3bolt.j"))call VNx(ha,(function Zhr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\LightningAttack.page\\LightningAttack.struct\\obj_boltSecondary_wc3bolt.j"))
call VNx(ma,(function ZHr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\LightningAttack.page\\LightningAttack.struct\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction ZJr takes nothing returns booleanset xBx=VXx(xbx)
return trueendfunctionfunction Zkr takes integer oSx returns integerset xFx[oSx]=trueset xgx[oSx]=falsecall rEx(xBx)return oSxendfunctionfunction ZKr takes nothing returns integerlocal integer oSxif(xCx==8190)thencall o_x("LightningAttack_Allocation_allocCustom","call DebugEx(LightningAttack.NAME + \" - alloc: unable to allocCustom, reached stack limit\")",xbx+" - alloc: unable to allocCustom, reached stack limit")return w
endifif(xdx[(w)]==w)thenset xDx=xDx+1set oSx=xDxelse
set oSx=xdx[(w)]
set xdx[(w)]=xdx[xdx[(w)]]endifset xdx[oSx]=Zset xfx[oSx]=1call Zkr(oSx)return oSxendfunctionfunction Zlr takes integer Iix returns booleanreturn( not(I9x(Iix,Qc)))and( not(I9x(Iix,Ifv)))and( not(IsUnitAlly(C[(Iix)],vx[(hf)])))and( not(nbo(Iix)))endfunctionfunction ZLr takes integer oSx returns nothingset xFx[oSx]=falsecall rHx(xBx)endfunctionfunction Zmr takes integer oSx returns nothingif(xfx[oSx]>0)thenreturnendifif(xdx[oSx]!=Z)thencall o_x("LightningAttack_Allocation_deallocCustom_confirm","call DebugEx(LightningAttack.NAME + \" - alloc: unable to deallocCustom instance \" + I2S(this))",xbx+" - alloc: unable to deallocCustom instance "+I2S(oSx))returnendifset xdx[oSx]=xdx[(w)]set xdx[(w)]=oSx
call ZLr(oSx)endfunctionfunction ZMr takes integer oSx returns nothingset xfx[oSx]=xfx[oSx]-1call Zmr(oSx)endfunctionfunction Zpr takes integer oSx returns nothingcall ZMr((oSx))call X_r(xLx[oSx])endfunctionfunction ZPr takes integer oSx,integer Ecr,integer ECr,integer Iix,integer svo returns nothingset Od=oSxset Rd=Ecrset Id=ECrset Ad=Iixset nte=svocall TriggerEvaluate(xtx)endfunctionfunction Zqr takes nothing returns booleanlocal integer rFx=(bv)local integer Mho=(ez[(rFx)])local integer oSx=(mZv[(Mho)])local integer Cqx=xhx[oSx]local integer EDr=xkx[oSx]local integer Efr=xmx[oSx]local integer Iix=xpx[oSx]local integer svo=xLx[oSx]local integer ZQrlocal real Nbolocal real dVxlocal real dExlocal integer EFrif(Iix!=w)thenset ZQr=QEx(xPx,false,true,true,$A,$A,l5)call Ryx((ACx((Iix),(xqx),(xQx),(Bi))))call P8o(ZQr,(GetUnitX(C[((Iix))])),(GetUnitY(C[((Iix))])),fYx(Iix))
call R4x(ZQr,true)set hf=(ze[(Cqx)])if Zlr(Iix)thenset Nbo=xHx[oSx]
set xHx[oSx]=Nbo*(1.-xjx[oSx])if(Efr<=xlx[oSx])thencall Nbx((Iix),(Xwv),(xJx[oSx]),w,((xKx[oSx])*1.))endifcall nlo((Cqx),(Iix),((Nbo)*1.),(true),(false))endifendifif(Efr==EDr)then
call Zpr(oSx)else
set dVx=(GetUnitX(C[((Iix))]))set dEx=(GetUnitY(C[((Iix))]))set Ose=svoset hf=(ze[(Cqx)])call NVo(xsx,dVx,dEx,xGx[oSx],xSx)set EFr=(mKo((xsx),((dVx)*1.),((dEx)*1.)))if(EFr==w)thencall Zpr(oSx)else
set xmx[oSx]=Efr+1call ZPr(oSx,xAx,Iix,EFr,svo)endifendifcall MFo(Mho)return trueendfunctionfunction Zsr takes integer oSx,integer Ecr,integer ECr,integer Iix,integer svo returns nothinglocal integer Mho=Moo()local integer cMo=cdo(Ecr)set xMx[oSx]=Mho
set xpx[oSx]=Iix
call ERr(cMo,ECr,Iix)call GroupAddUnit(kb[(svo)],C[(Iix)])call cLo(cMo,.75)set mCv[(Mho)]=((10.)*1.)set mFv[(Mho)]=Xkx((function Zqr))set mZv[(Mho)]=(oSx)
call Meo(Mho,iAx(jKx((GetUnitX(C[((Iix))]))-(GetUnitX(C[((ECr))])),(GetUnitY(C[((Iix))]))-(GetUnitY(C[((ECr))])))*1./ .25,700.))
call pxo(Mho,ECr)call M6o((Mho),(Iix),.0,.0,.0,(null))endfunctionfunction ZSr takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=(E2v[(rFx)])local integer Iix=(Vv[(rFx)])local real wQo=(GetUnitX(C[((Cqx))]))local real wso=(GetUnitY(C[((Cqx))]))local integer rYx=(osx(((Cqx)),N+(GPv)))
local integer oSx=ZKr()local integer svo=O5x()set xGx[oSx]=(CQx((GPv),Uvv+(rYx)))set xhx[oSx]=Cqx
set xHx[oSx]=xRx[rYx]set xjx[oSx]=xOx[rYx]set xJx[oSx]=rYx
set xkx[oSx]=xVx[rYx]set xKx[oSx]=xXx[rYx]set xlx[oSx]=xEx[rYx]set xLx[oSx]=svo
set xmx[oSx]=1call Zsr(oSx,xIx,Cqx,Iix,svo)return trueendfunctionfunction Ztr takes nothing returns booleanlocal integer Iix=jhx()if(I8x((Ose),Ob,(Iix)))thenreturn false
endifif not Zlr(Iix)thenreturn false
endifreturn truereturn trueendfunctionfunction ZTr takes nothing returns booleanlocal integer rFx=(bv)call Avx((Vv[(rFx)]),xcx)return trueendfunctionfunction Zur takes nothing returns booleanlocal integer rFx=(bv)call RPx((Vv[(rFx)]),xcx)return trueendfunctionfunction ZUr takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(xNx),((Mv[(rFx)])),w)return trueendfunctionfunction Zwr takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),xNx)return trueendfunctionfunction ZWr takes nothing returns booleanset xcx=Xdx("LightningAttack_Init: set LightningAttack.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function LightningAttack.Event_Damage)",E4v,MI,function ZSr)set xsx=O5x()set xSx=Xpx(function Ztr)call Lxx(xNx,Xdx("LightningAttack_Init: call LightningAttack.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LightningAttack.Event_BuffGain))",bd,MI,function ZTr))call Lxx(xNx,Xdx("LightningAttack_Init: call LightningAttack.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LightningAttack.Event_BuffLose))",jc,MI,function Zur))call mro(GPv,Xdx("LightningAttack_Init: call LightningAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LightningAttack.Event_Learn))",pv,MI,function ZUr))call mro(GPv,Xdx("LightningAttack_Init: call LightningAttack.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function LightningAttack.Event_Unlearn))",Av,MI,function Zwr))return trueendfunctionfunction Zyr takes nothing returns booleancall moo(function ZWr,"LightningAttack_Init")return trueendfunctionfunction ZYr takes nothing returns booleanset fJe=(L_o((xTx+" (thisSpell)")))set m6[(fJe)]=(1)set TH[(fJe)]=("Magic Immunity")
set Rh[(fJe)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0278)))),(((Aj))))))set x3v[(fJe)]=("spell")
return trueendfunctionfunction Zzr takes nothing returns booleanset xux=ltx(xTx+" (dummyBuff)")set WU=l_x()
call vAr(WU,DJv,true)call l3x(((xux)),ZB+(1),(WU))return trueendfunctionfunction ZZr takes nothing returns booleancall VNx(Pa,(function ZYr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\MagicImmunity.page\\MagicImmunity.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function Zzr),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\MagicImmunity.page\\MagicImmunity.struct\\obj_dummyBuff_wc3buff.j"))
return trueendfunctionfunction Z_r takes nothing returns booleanset xUx=VXx(xTx)
return trueendfunctionfunction Z0r takes nothing returns booleanlocal integer rFx=(bv)call Dux(((Vv[(rFx)])),(xux),((Mv[(rFx)])),w)return trueendfunctionfunction Z1r takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),xux)return trueendfunctionfunction Z2r takes nothing returns booleancall mro(fJe,Xdx("MagicImmunity_Init: call MagicImmunity.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MagicImmunity.Event_Learn))",pv,MI,function Z0r))call mro(fJe,Xdx("MagicImmunity_Init: call MagicImmunity.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function MagicImmunity.Event_Unlearn))",Av,MI,function Z1r))return trueendfunctionfunction Z3r takes nothing returns booleancall moo(function Z2r,"MagicImmunity_Init")return trueendfunctionfunction Z4r takes nothing returns booleancall L1x('AMtP',false)set GTv=L0o('AMtP')set K6[(GTv)]=(H6)set m6[(GTv)]=(2)set TH[(GTv)]=("Meteorite Protection")set x3v[(GTv)]=("spell")
call L1o((GTv),Lov+(1),((750)*1.))return trueendfunctionfunction Z5r takes nothing returns booleancall VNx(Pa,(function Z4r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\MeteoriteProtection.page\\MeteoriteProtection.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Z6r takes nothing returns booleanset xwx=VXx(xWx)
return trueendfunctionfunction Z7r takes nothing returns booleancall L1x('AReM',false)set xyx=L0o('AReM')set m6[(xyx)]=(1)set TH[(xyx)]=("Refresh Mana")set Rh[(xyx)]=((LoadInteger(o[((V[(E[((X))])]))],(((($D0244)))),(((Aj))))))set oxv[(xyx)]=(0)set x3v[(xyx)]=("spell")
call L1o((xyx),GH+(1),((30)*1.))
call L1o((xyx),tH+(1),((90)*1.))
set MOv[(xyx)]=("ReplaceableTextures\\CommandButtons\\BTNManaRecharge.blp")return trueendfunctionfunction Z8r takes nothing returns booleancall VNx(Pa,(function Z7r),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\RefreshMana.page\\RefreshMana.struct\\obj_thisSpell_wc3spell.j"))return trueendfunctionfunction Z9r takes nothing returns booleanset xYx=VXx(xzx)
return trueendfunctionfunction vvi takes integer OSx returns integerreturn pzv[(osx(OSx,p3v))]endfunctionfunction vei takes integer oSx,code igx,boolean vxi returns nothinglocal integer oMx=Jh
local integer Iixloop
exitwhen(oMx<0)set Iix=(kv[((kh[oMx]))])if I9x(Iix,Qc)thenif vxi thencall GroupAddUnit(kb[(Hev)],C[(vvi(Iix))])endifelse
call GroupAddUnit(kb[(Hev)],C[(Iix)])endifset oMx=oMx-1endloopcall ForGroup(kb[(Hev)],(igx))endfunctionfunction voi takes nothing returns booleanlocal integer rFx=(bv)local integer Cqx=xZxlocal integer Iix=ROx()call Ryx((ACx((Iix),(x_x),(x0x),(ri))))call mno(Cqx,Iix,(LF[(Iix)])*x1x)return trueendfunctionfunction vri takes nothing returns booleanlocal integer rFx=(bv)set xZx=(Vv[(rFx)])call vei(fZ,function voi,true)return trueendfunctionfunction vii takes nothing returns booleancall mro(xyx,Xdx("RefreshMana_Init: call RefreshMana.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RefreshMana.Event_SpellEffect))",ih,MI,function vri))return trueendfunctionfunction vai takes nothing returns booleancall moo(function vii,"RefreshMana_Init")return trueendfunctionfunction vni takes nothing returns booleanset x2x=Wwx('BRVA',"Discovered",'bRVA')set anv[(x2x)]=("ReplaceableTextures\\CommandButtons\\BTNHeal.blp")return trueendfunctionfunction vVi takes nothing returns booleancall VNx(ma,(function vni),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\RevealAura.page\\RevealAura.struct\\Target\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction vEi takes nothing returns booleanset x3x=VXx(x4x)
return trueendfunctionfunction vXi takes nothing returns booleancall L1x('AReA',false)set uHv=L0o('AReA')set K6[(uHv)]=(H6)set m6[(uHv)]=(2)set TH[(uHv)]=("Reveal Aura")set x3v[(uHv)]=("spell")
call L1o((uHv),Uvv+(1),(($C8)*1.))call L1o((uHv),Lov+(1),((750)*1.))call L1o((uHv),Uvv+(2),(($5DC)*1.))call L1o((uHv),Lov+(2),((750)*1.))set MOv[(uHv)]=("ReplaceableTextures\\PassiveButtons\\PASBTNMagicalSentry.blp")return trueendfunctionfunction vOi takes nothing returns booleanset x5x=ltx(x6x+" (dummyBuff)")call lWx(x5x,"Abilities\\Spells\\Human\\MagicSentry\\MagicSentryCaster.mdl","overhead",ri)return trueendfunctionfunction vRi takes nothing returns booleancall VNx(Pa,(function vXi),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\RevealAura.page\\RevealAura.struct\\obj_thisSpell_wc3spell.j"))call VNx(ma,(function vOi),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Spells\\Misc\\RevealAura.page\\RevealAura.struct\\obj_dummyBuff_wc3buff.j"))return trueendfunctionfunction vIi takes nothing returns booleanset x7x=VXx(x6x)
return trueendfunctionfunction vAi takes nothing returns booleanlocal integer Iix=jhx()if I9x(Iix,Qc)thenreturn false
endifif I9x(Iix,Igv)thenreturn false
endifif not(rk[(Iix)])thenreturn false
endifif(IsUnitAlly(C[(Iix)],vx[(hf)]))thenreturn false
endifreturn truereturn trueendfunctionfunction vNi takes nothing returns booleanlocal integer rFx=(bv)local integer rYx=(hc[(rFx)])local integer Iix=(Vv[(rFx)])local integer oSx=Iixlocal integer Xur=XQr(Iix)set x9x[oSx]=Xur
set ovx[oSx]=rYx
set Ene[(Xur)]=(oSx)
set vqe[(Xur)]=(((CQx((uHv),Uvv+(rYx))))*1.)
set vQe[(Xur)]=(x8x)
call Xsr(Xur,oex)call Xsr(Xur,oxx)call Xtr(Xur)return trueendfunctionfunction vbi takes nothing returns booleanlocal integer rFx=(bv)local integer Iix=(Vv[(rFx)])local integer oSx=Iixcall X5r(x9x[oSx])return trueendfunctionfunction vBi takes nothing returns booleanlocal integer rFx=(bv)call seo((Vv[(rFx)]),x5x,(Mv[(rFx)]))return trueendfunctionfunction vci takes nothing returns booleanlocal integer rFx=(bv)call AZx((Vv[(rFx)]),x5x)return trueendfunctionfunction vCi takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer rLx=(Ene[(Xur)])call Ulx(Iix,x2x)return trueendfunctionfunction vdi takes nothing returns booleanlocal integer rFx=(bv)local integer Xur=(vSe[(rFx)])local integer Iix=(Vv[(rFx)])local integer Cqx=(vke[(Xur)])local integer rLx=(Ene[(Xur)])local integer rYx=ovx[rLx]call Dux((Iix),(x2x),(rYx),w)return trueendfunctionfunction vDi takes nothing returns nothingset oex=Xdx("FolderRevealAura_StructTarget_Init: set FolderRevealAura_StructTarget.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function FolderRevealAura_StructTarget.Event_Ending)",vTe,MI,function vCi)set oxx=Xdx("FolderRevealAura_StructTarget_Init: set FolderRevealAura_StructTarget.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function FolderRevealAura_StructTarget.Event_Start)",vue,MI,function vdi)endfunctionfunction vfi takes nothing returns booleanset x8x=Xpx(function vAi)call Lxx(x5x,Xdx("RevealAura_Init: call RevealAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RevealAura.Event_BuffGain))",bd,MI,function vNi))call Lxx(x5x,Xdx("RevealAura_Init: call RevealAura.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RevealAura.Event_BuffLose))",jc,MI,function vbi))call mro(uHv,Xdx("RevealAura_Init: call RevealAura.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RevealAura.Event_Learn))",pv,MI,function vBi))
call mro(uHv,Xdx("RevealAura_Init: call RevealAura.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function RevealAura.Event_Unlearn))",Av,MI,function vci))
call vDi()return trueendfunctionfunction vFi takes nothing returns booleancall moo(function vfi,"RevealAura_Init")
return trueendfunctionfunction vgi takes nothing returns booleanset exx=hjo('UMet')call hpo((exx),('AInv'),1)call hJo(((exx)),ASv,(Wd))call hJo(((exx)),ASv,(Igv))set Uj[(exx)]=((3)*1.)set NOv[(exx)]=((40)*1.)
set NWv[(exx)]=((60)*1.)
set I8v[(exx)]=((0)*1.)set Anv[(exx)]=(3)set Nmv[(exx)]=(($9C4)*1.)set NLv[(exx)]=(($9C4)*1.)set NKv[(exx)]=((0)*1.)set Npv[(exx)]=(($C8)*1.)set NMv[(exx)]=(($C8)*1.)set Nlv[(exx)]=((.2)*1.)
set Ncv[(exx)]=(($3E8)*1.)set Nbv[(exx)]=(($3E8)*1.)set Auv[(exx)]=((0)*1.)set AUv[(exx)]=((0)*1.)set AYv[(exx)]=(0)set A_v[(exx)]=(0)call hpo((exx),(vcx),1)call hpo((exx),(v_x),1)call hpo((exx),(vtx),1)call hpo((exx),(v5x),1)call hpo((exx),(e4x),1)call hpo((exx),(xyx),1)return trueendfunctionfunction vGi takes nothing returns booleancall VNx(sa,(function vgi),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\System\\Meteorite.page\\Meteorite.struct\\obj_thisUnitType_wc3unit.j"))return trueendfunctionfunction vhi takes nothing returns booleanset oox=VXx(orx)
return trueendfunctionfunction vHi takes nothing returns booleanlocal integer rFx=(bv)call Crx((lw),w)
return trueendfunctionfunction vji takes nothing returns booleanlocal integer rFx=(bv)call YSr()return trueendfunctionfunction vJi takes nothing returns booleanlocal integer rFx=(bv)call Ryx((ACx(((Vv[(rFx)])),("Abilities\\Spells\\Other\\Monsoon\\MonsoonBoltTarget.mdl"),("origin"),(Bi))))return trueendfunctionfunction vki takes nothing returns booleanlocal integer rFx=(bv)local integer Ahr=(E2v[(rFx)])local integer vKi=(osx(((Ahr)),N+(GTv)))
if(vKi==1)thenreturn trueendifcall Dux((((Ahr))),(iiv),(1),w)if(vKi==2)thencall ngo(Ahr,(rG[(Ahr)])*.15)else
call ngo(Ahr,(rG[(Ahr)])*.4)
endifcall Ulx(((Ahr)),iiv)return trueendfunctionfunction vli takes nothing returns nothinglocal integer rFx=rRx(0)
local integer oMx=Xv
local integer rbxlocal integer rMxloop
exitwhen(oMx<0)set rbx=Ov[oMx]set rMx=(0+(LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Jtv))-1)*Iv+(((rbx))-1)))))))))
loop
exitwhen(rMx<q)call rfx((LoadInteger(o[((V[(E[((X))])]))],(((Se))),((((1+8192*((((Jtv))-1)*Iv+(((rbx))-1))))+((rMx)))))),rFx)set rMx=rMx-1endloopset oMx=oMx-1endloopcall rkx(((rFx)))endfunctionfunction vLi takes nothing returns nothinglocal string array vmilocal string vMi
local integer vpilocal integer vPiset jYv=true
set vmi[0]="Leave this grim place"set vmi[1]="I can see the light"
set vmi[2]="It's too late"set vmi[3]="The world descends into eternal ice"
set vmi[4]="Eternal fail shall befall you"set vMi=vmi[(GetRandomInt((0),(4)))]
set vpi=SPo()call Szo(vpi,"I am okay with that",0)call DialogSetMessage(ep[(vpi)],("The castle has fallen!"))call Szo(vpi,vMi,0)call SJo(vpi,Ge,true)set vPi=qBo()call qEo(vPi,0,$80,$80,(R2I(((.3*$FF)*1.))))
set plv[(vPi)]=("ReplaceableTextures\\CameraMasks\\DreamFilter_Mask.blp")call qfo(vPi,10.,Ge)
call vli()endfunctionfunction vqi takes nothing returns booleanlocal integer rFx=(bv)call vLi()return trueendfunctionfunction vQi takes nothing returns booleanlocal integer rFx=(bv)call acx(lw,(ZA[(rFx)]))
return trueendfunctionfunction vsi takes nothing returns booleanlocal integer rFx=(bv)set lw=(Vv[(rFx)])set eex=Xdx("Meteorite_Event_Create: set Meteorite.LIFE_EVENT = Event.Create(UNIT.Life.DUMMY_EVENT_TYPE, EventPriority.MISC, function Meteorite.Event_Life)",GG,lI,function vji)
set eox=S6o($A)set erx=QEx("Sound\\Interface\\Warning.wav",false,false,false,$A,$A,H5)set gC[(erx)]=((.5)*1.)set evx=(oG[(lw)])call Avx(lw,Xdx("Meteorite_Event_Create: call Meteorite.THIS_UNIT.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.MISC, function Meteorite.Event_Cast))",ih,lI,function vJi))call Avx(lw,Xdx("Meteorite_Event_Create: call Meteorite.THIS_UNIT.Event.Add(Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.MISC, function Meteorite.Event_Damage))",E3v,lI,function vki))call Avx(lw,Xdx("Meteorite_Event_Create: call Meteorite.THIS_UNIT.Event.Add(Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function Meteorite.Event_Death))",VP,lI,function vqi))call Avx(lw,eex)
call Dcx(Xdx("Meteorite_Event_Create: call Event.Create(USER.HostAppointment.DUMMY_EVENT_TYPE, EventPriority.MISC, function Meteorite.Event_HostChange).AddToStatics()",H_v,lI,function vQi))if(Qdv!=w)thencall s7o((Qdv),(s8o()))endifcall Rao(lw,Ihv)
return trueendfunctionfunction vSi takes nothing returns booleanset jYv=falseset Jtv=(E3x())call Xyx(zA,"killM",Xdx("Meteorite_Init: call StringData.Event.Add(\"killM\", Event.Create(User.CHAT_EVENT_TYPE, EventPriority.MISC, function Meteorite.Event_Chat))",KA,lI,function vHi))call teo(exx,Xdx("Meteorite_Init: call Meteorite.THIS_UNIT_TYPE.Event.Add(Event.Create(Unit.CREATE_EVENT_TYPE, EventPriority.MISC, function Meteorite.Event_Create))",IJv,lI,function vsi))return trueendfunctionfunction vti takes nothing returns booleancall kzo(function vSi,"Meteorite_Init")return trueendfunctionfunction vTi takes nothing returns booleanset oix=VXx(oax)
return trueendfunctionfunction vui takes code c,string rSx returns nothing
set eV=eV+1set xV[eV]=CreateTrigger()set oV[eV]=(GetHandleId(Condition((c))))
set rV[eV]=rSxcall TriggerAddCondition(xV[eV],Condition(c))endfunctionfunction vUi takes nothing returns booleanlocal integer rFx=(bv)call qVr((Vv[(rFx)]),"swim")
return trueendfunctionfunction vwi takes nothing returns booleancall teo(hFv,Xdx("Pengu_Init: call UnitType.FLYING_PENGUIN.Event.Add(Event.Create(Unit.CREATE_EVENT_TYPE, EventPriority.UNIT_TYPES, function Pengu.Event_Create))",IJv,pI,function vUi))
return trueendfunctionfunction vWi takes nothing returns booleancall vui(function vwi,"Pengu_Init")return trueendfunctionfunction vyi takes nothing returns booleanset onx=hjo('uSeb')set Uj[(onx)]=((1)*1.)set NOv[(onx)]=((60)*1.)
set NWv[(onx)]=((60)*1.)
set I8v[(onx)]=((0)*1.)set Anv[(onx)]=(5)set Nmv[(onx)]=(('x')*1.)set NLv[(onx)]=(('x')*1.)set NKv[(onx)]=((0)*1.)set Ncv[(onx)]=((500)*1.)set Nbv[(onx)]=((500)*1.)set NGv[(onx)]=((400)*1.)set Auv[(onx)]=((0)*1.)set AUv[(onx)]=((0)*1.)set AYv[(onx)]=(0)set A_v[(onx)]=(0)call hpo((onx),(gtv),1)return trueendfunctionfunction vYi takes nothing returns booleancall VNx(sa,(function vyi),("D:\\Warcraft III\\Mapping\\DWC\\Scripts\\Units\\Sebastian.page\\Sebastian.struct\\obj_thisUnitType_wc3unit.j"))
return trueendfunctionfunction vzi takes nothing returns booleanset oVx=VXx(oEx)
return trueendfunctionfunction vZi takes nothing returns booleanlocal integer rFx=(bv)set oXx=(LoadInteger(o[((V[((E[((X))]))]))],((GetHandleId((((Kr)))))),((((ix))))))return trueendfunctionfunction v_i takes nothing returns booleancall Dcx(Xdx("Sebastian_Init: call Event.Create(EventType.START, EventPriority.MISC, function Sebastian.Event_Start).AddToStatics()",EE,lI,function vZi))return trueendfunctionfunction v0i takes nothing returns booleancall vui(function v_i,"Sebastian_Init")return trueendfunctionfunction v1i takes nothing returns booleanset ur=VXx("<s__Loading_Name>")return trueendfunctionfunction v2i takes nothing returns booleancall Vnx(function VOx,"s"+"__Queue_Allocation__allocInit_autoRun")call Vnx(function VRx,"s"+"__ObjThread_Allocation__allocInit_autoRun")call Vnx(function VIx,"s"+"__FolderMath_StructInteger_Allocation__allocInit_autoRun")call Vnx(function VAx,"s"+"__FolderMath_StructHex_Allocation__allocInit_autoRun")call Vnx(function VDx,"s"+"__FolderMath_StructShapes_objInits_autoRun")call Vnx(function Vfx,"s"+"__FolderMath_StructShapes_Allocation__allocInit_autoRun")
call Vnx(function Vjx,"s"+"__Math_initializer_Init_autoRun")
call Vnx(function VJx,"s"+"__FolderGameCache_StructBoolean_Allocation__allocInit_autoRun")call Vnx(function Vkx,"s"+"__FolderGameCache_StructInteger_Allocation__allocInit_autoRun")call Vnx(function VKx,"s"+"__FolderGameCache_StructReal_Allocation__allocInit_autoRun")call Vnx(function Vlx,"s"+"__FolderGameCache_StructString_Allocation__allocInit_autoRun")call Vnx(function VLx,"s"+"__GameCache_Allocation__allocInit_autoRun")call Vnx(function Vmx,"s"+"__FolderHashTable_StructBoolean_Allocation__allocInit_autoRun")call Vnx(function VMx,"s"+"__FolderHashTable_StructInteger_Allocation__allocInit_autoRun")call Vnx(function Vpx,"s"+"__FolderHashTable_StructReal_Allocation__allocInit_autoRun")call Vnx(function VPx,"s"+"__FolderHashTable_StructString_Allocation__allocInit_autoRun")call Vnx(function Vqx,"s"+"__HashTable_Allocation__allocInit_autoRun")call Vnx(function VQx,"s"+"__FolderDataTableHead_FolderIntegerKeys_StructD2_Allocation__allocInit_autoRun")call Vnx(function Vsx,"s"+"__FolderDataTableHead_StructIntegerKeys_Allocation__allocInit_autoRun")call Vnx(function VSx,"s"+"__FolderDataTableHead_StructStringKeys_Allocation__allocInit_autoRun")call Vnx(function Vtx,"s"+"__DataTableHead_Allocation__allocInit_autoRun")call Vnx(function VTx,"s"+"__FolderDataTable_FolderIntegerKeys_FolderD2_StructTable_Allocation__allocInit_autoRun")call Vnx(function Vux,"s"+"__FolderDataTable_FolderIntegerKeys_StructD2_Allocation__allocInit_autoRun")call Vnx(function VUx,"s"+"__FolderDataTable_FolderIntegerKeys_StructTable_Allocation__allocInit_autoRun")call Vnx(function Vwx,"s"+"__FolderDataTable_StructIntegerKeys_Allocation__allocInit_autoRun")call Vnx(function VWx,"s"+"__FolderDataTable_FolderStringKeys_StructTable_Allocation__allocInit_autoRun")call Vnx(function Vyx,"s"+"__FolderDataTable_StructStringKeys_Allocation__allocInit_autoRun")call Vnx(function VYx,"s"+"__FolderDataTable_StructNative_Allocation__allocInit_autoRun")call Vnx(function Vzx,"s"+"__DataTable_Allocation__allocInit_autoRun")call Vnx(function Enx,"s"+"__DataTable_initializer_Init_autoRun")call Vnx(function EVx,"s"+"__Animation_Allocation__allocInit_autoRun")call Vnx(function EEx,"s"+"__AttachPoint_Allocation__allocInit_autoRun")
call Vnx(function EXx,"s"+"__Attack_Allocation__allocInit_autoRun")call Vnx(function ERx,"s"+"__Attack_initializer_Init_autoRun")call Vnx(function EIx,"s"+"__FolderEventResponse_StructAct_Allocation__allocInit_autoRun")call Vnx(function EAx,"s"+"__FolderEventResponse_StructAura_Allocation__allocInit_autoRun")call Vnx(function ENx,"s"+"__FolderEventResponse_StructBool_Allocation__allocInit_autoRun")call Vnx(function Ebx,"s"+"__FolderEventResponse_StructBuff_Allocation__allocInit_autoRun")call Vnx(function EBx,"s"+"__FolderEventResponse_StructDefenderSpawnType_Allocation__allocInit_autoRun")
call Vnx(function Ecx,"s"+"__FolderEventResponse_StructDestructable_Allocation__allocInit_autoRun")call Vnx(function ECx,"s"+"__FolderEventResponse_StructDestructableType_Allocation__allocInit_autoRun")call Vnx(function Edx,"s"+"__FolderEventResponse_StructDialog_Allocation__allocInit_autoRun")call Vnx(function EDx,"s"+"__FolderEventResponse_StructDummyUnit_Allocation__allocInit_autoRun")
call Vnx(function Efx,"s"+"__FolderEventResponse_StructDynamic_Allocation__allocInit_autoRun")call Vnx(function EFx,"s"+"__FolderEventResponse_StructEvent_Allocation__allocInit_autoRun")
call Vnx(function Egx,"s"+"__FolderEventResponse_StructItem_Allocation__allocInit_autoRun")call Vnx(function EGx,"s"+"__FolderEventResponse_StructItemType_Allocation__allocInit_autoRun")call Vnx(function Ehx,"s"+"__FolderEventResponse_StructLevel_Allocation__allocInit_autoRun")
call Vnx(function EHx,"s"+"__FolderEventResponse_StructLightning_Allocation__allocInit_autoRun")
call Vnx(function Ejx,"s"+"__FolderEventResponse_StructMissile_Allocation__allocInit_autoRun")call Vnx(function EJx,"s"+"__FolderEventResponse_StructMissileCheckpoint_Allocation__allocInit_autoRun")
call Vnx(function Ekx,"s"+"__FolderEventResponse_StructOrder_Allocation__allocInit_autoRun")
call Vnx(function EKx,"s"+"__FolderEventResponse_StructReal_Allocation__allocInit_autoRun")call Vnx(function Elx,"s"+"__FolderEventResponse_StructSpawnType_Allocation__allocInit_autoRun")
call Vnx(function ELx,"s"+"__FolderEventResponse_StructSpell_Allocation__allocInit_autoRun")
call Vnx(function Emx,"s"+"__FolderEventResponse_StructSpellInstance_Allocation__allocInit_autoRun")
call Vnx(function EMx,"s"+"__FolderEventResponse_StructSpot_Allocation__allocInit_autoRun")call Vnx(function Epx,"s"+"__FolderEventResponse_StructString_Allocation__allocInit_autoRun")call Vnx(function EPx,"s"+"__FolderEventResponse_StructTile_Allocation__allocInit_autoRun")call Vnx(function Eqx,"s"+"__FolderEventResponse_StructUbersplat_Allocation__allocInit_autoRun")
call Vnx(function EQx,"s"+"__FolderEventResponse_StructUnit_Allocation__allocInit_autoRun")call Vnx(function Esx,"s"+"__FolderEventResponse_StructUnitEffect_Allocation__allocInit_autoRun")call Vnx(function ESx,"s"+"__FolderEventResponse_StructUnitMod_Allocation__allocInit_autoRun")call Vnx(function Etx,"s"+"__FolderEventResponse_StructUnitType_Allocation__allocInit_autoRun")call Vnx(function ETx,"s"+"__FolderEventResponse_StructUser_Allocation__allocInit_autoRun")call Vnx(function Eux,"s"+"__EventResponse_Allocation__allocInit_autoRun")call Vnx(function EUx,"s"+"__EventPriority_Allocation__allocInit_autoRun")call Vnx(function Ewx,"s"+"__EventType_Allocation__allocInit_autoRun")call Vnx(function EWx,"s"+"__FolderEvent_StructId_Allocation__allocInit_autoRun")call Vnx(function Eyx,"s"+"__FolderEvent_FolderData_StructBoolean_Allocation__allocInit_autoRun")call Vnx(function EYx,"s"+"__FolderEvent_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function Ezx,"s"+"__FolderEvent_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function EZx,"s"+"__FolderEvent_StructData_Allocation__allocInit_autoRun")call Vnx(function E_x,"s"+"__FolderEvent_StructLimit_Allocation__allocInit_autoRun")
call Vnx(function E0x,"s"+"__Event_Allocation__allocInit_autoRun")call Vnx(function Xvx,"s"+"__Event_initializer_Init_autoRun")call Vnx(function Xex,"s"+"__CharacterSpeech_Allocation__allocInit_autoRun")
call Vnx(function OTx,"s"+"__CharacterSpeech_initializer_Init_autoRun")call Vnx(function Oux,"s"+"__ClearSpawns_Allocation__allocInit_autoRun")
call Vnx(function OZx,"s"+"__ClearSpawns_initializer_Init_autoRun")call Vnx(function O_x,"s"+"__CommandAutoCast_Allocation__allocInit_autoRun")
call Vnx(function RNx,"s"+"__CommandAutoCast_initializer_Init_autoRun")call Vnx(function Rbx,"s"+"__CommandBuff_Allocation__allocInit_autoRun")
call Vnx(function NFx,"s"+"__CommandBuff_initializer_Init_autoRun")call Vnx(function Ngx,"s"+"__CommandCreateQuake_Allocation__allocInit_autoRun")call Vnx(function bVx,"s"+"__CommandCreateQuake_initializer_Init_autoRun")call Vnx(function bEx,"s"+"__CommandCreateUnit_Allocation__allocInit_autoRun")call Vnx(function bbx,"s"+"__CommandCreateUnit_initializer_Init_autoRun")call Vnx(function bBx,"s"+"__CommandDebug_Allocation__allocInit_autoRun")call Vnx(function bdx,"s"+"__CommandDebug_initializer_Init_autoRun")
call Vnx(function bDx,"s"+"__CommandExp_Allocation__allocInit_autoRun")call Vnx(function bhx,"s"+"__CommandExp_initializer_Init_autoRun")call Vnx(function bHx,"s"+"__CommandHeader_Allocation__allocInit_autoRun")call Vnx(function bjx,"s"+"__CommandHeroAttribute_Allocation__allocInit_autoRun")call Vnx(function Cxx,"s"+"__CommandHeroAttribute_initializer_Init_autoRun")
call Vnx(function Cox,"s"+"__CommandKillUnit_Allocation__allocInit_autoRun")
call Vnx(function CEx,"s"+"__CommandKillUnit_initializer_Init_autoRun")call Vnx(function CXx,"s"+"__CommandRefreshAbility_Allocation__allocInit_autoRun")call Vnx(function DJx,"s"+"__CommandRefreshAbility_initializer_Init_autoRun")call Vnx(function Dkx,"s"+"__CommandRemoveUnit_Allocation__allocInit_autoRun")call Vnx(function Dmx,"s"+"__CommandRemoveUnit_initializer_Init_autoRun")call Vnx(function DMx,"s"+"__CommandScaleUnit_Allocation__allocInit_autoRun")call Vnx(function fix,"s"+"__CommandScaleUnit_initializer_Init_autoRun")
call Vnx(function fax,"s"+"__CommandSpell_Allocation__allocInit_autoRun")call Vnx(function fIx,"s"+"__CommandSpell_initializer_Init_autoRun")
call Vnx(function fAx,"s"+"__CommandSwift_Allocation__allocInit_autoRun")call Vnx(function fCx,"s"+"__CommandSwift_initializer_Init_autoRun")
call Vnx(function fdx,"s"+"__CommandTest_Allocation__allocInit_autoRun")
call Vnx(function fFx,"s"+"__CommandTest_initializer_Init_autoRun")call Vnx(function fgx,"s"+"__CommandVertexColorUnit_Allocation__allocInit_autoRun")call Vnx(function fux,"s"+"__CommandVertexColorUnit_initializer_Init_autoRun")call Vnx(function fUx,"s"+"__MoveUnit_Allocation__allocInit_autoRun")call Vnx(function f1x,"s"+"__MoveUnit_initializer_Init_autoRun")
call Vnx(function f2x,"s"+"__PingSpawns_Allocation__allocInit_autoRun")call Vnx(function f9x,"s"+"__PingSpawns_initializer_Init_autoRun")call Vnx(function Fvx,"s"+"__RequestEvent_Allocation__allocInit_autoRun")call Vnx(function Fox,"s"+"__RequestEvent_initializer_Init_autoRun")
call Vnx(function Frx,"s"+"__RequestKeyMacro_Allocation__allocInit_autoRun")
call Vnx(function Fnx,"s"+"__RequestKeyMacro_initializer_Init_autoRun")call Vnx(function FVx,"s"+"__RequestTimers_Allocation__allocInit_autoRun")call Vnx(function FAx,"s"+"__RequestTimers_initializer_Init_autoRun")call Vnx(function FNx,"s"+"__SetDmgTest_Allocation__allocInit_autoRun")call Vnx(function FCx,"s"+"__SetDmgTest_initializer_Init_autoRun")call Vnx(function Fdx,"s"+"__SetVar_Allocation__allocInit_autoRun")call Vnx(function Fgx,"s"+"__SetVar_initializer_Init_autoRun")call Vnx(function FGx,"s"+"__FolderVoteHost_StructVotes_Allocation__allocInit_autoRun")call Vnx(function Fhx,"s"+"__VoteHost_Allocation__allocInit_autoRun")call Vnx(function FJx,"s"+"__VoteHost_initializer_Init_autoRun")
call Vnx(function Fkx,"s"+"__AIAutoCast_Allocation__allocInit_autoRun")call Vnx(function Fyx,"s"+"__AIAutoCast_initializer_Init_autoRun")call Vnx(function FYx,"s"+"__BoolExpr_Allocation__allocInit_autoRun")call Vnx(function F0x,"s"+"__BoolExpr_initializer_Init_autoRun")
call Vnx(function F1x,"s"+"__FolderBuff_StructId_Allocation__allocInit_autoRun")
call Vnx(function F2x,"s"+"__FolderBuff_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vnx(function F3x,"s"+"__FolderBuff_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vnx(function F4x,"s"+"__FolderBuff_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vnx(function F5x,"s"+"__FolderBuff_FolderData_FolderReal_StructTable_Allocation__allocInit_autoRun")call Vnx(function F6x,"s"+"__FolderBuff_FolderData_StructReal_Allocation__allocInit_autoRun")call Vnx(function F7x,"s"+"__FolderBuff_FolderData_FolderString_StructTable_Allocation__allocInit_autoRun")call Vnx(function F8x,"s"+"__FolderBuff_FolderData_StructString_Allocation__allocInit_autoRun")call Vnx(function F9x,"s"+"__FolderBuff_StructData_Allocation__allocInit_autoRun")call Vnx(function gvx,"s"+"__FolderBuff_StructEvent_Allocation__allocInit_autoRun")call Vnx(function gex,"s"+"__FolderBuff_StructTargetEffects_Allocation__allocInit_autoRun")call Vnx(function gxx,"s"+"__FolderBuff_StructLoopSounds_Allocation__allocInit_autoRun")
call Vnx(function gox,"s"+"__FolderBuff_StructVariants_Allocation__allocInit_autoRun")call Vnx(function grx,"s"+"__FolderBuff_StructUnitMods_Allocation__allocInit_autoRun")call Vnx(function gix,"s"+"__FolderBuff_StructUnitModSets_Allocation__allocInit_autoRun")call Vnx(function gax,"s"+"__Buff_Allocation__allocInit_autoRun")call Vnx(function gVx,"s"+"__Buff_initializer_Init_autoRun")
call Vnx(function gEx,"s"+"__FolderCameraField_StructTimed_Allocation__allocInit_autoRun")call Vnx(function gXx,"s"+"__CameraField_Allocation__allocInit_autoRun")
call Vnx(function gOx,"s"+"__FolderCamera_StructEye_Allocation__allocInit_autoRun")call Vnx(function gRx,"s"+"__FolderCamera_StructTarget_Allocation__allocInit_autoRun")call Vnx(function gIx,"s"+"__FolderCamera_StructPanTimedViaBounds_Allocation__allocInit_autoRun")call Vnx(function gAx,"s"+"__FolderCamera_StructShake_Allocation__allocInit_autoRun")call Vnx(function gNx,"s"+"__FolderCamera_StructSeismic_Allocation__allocInit_autoRun")call Vnx(function gbx,"s"+"__Camera_Allocation__allocInit_autoRun")call Vnx(function gyx,"s"+"__Camera_initializer_Init_autoRun")call Vnx(function gYx,"s"+"__FolderDestructableType_StructId_Allocation__allocInit_autoRun")
call Vnx(function gzx,"s"+"__FolderDestructableType_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vnx(function gZx,"s"+"__FolderDestructableType_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vnx(function g_x,"s"+"__FolderDestructableType_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vnx(function g0x,"s"+"__FolderDestructableType_FolderData_FolderReal_StructTable_Allocation__allocInit_autoRun")call Vnx(function g1x,"s"+"__FolderDestructableType_FolderData_StructReal_Allocation__allocInit_autoRun")call Vnx(function g2x,"s"+"__FolderDestructableType_StructData_Allocation__allocInit_autoRun")call Vnx(function g3x,"s"+"__FolderDestructableType_StructEvent_Allocation__allocInit_autoRun")call Vnx(function g4x,"s"+"__FolderDestructableType_StructPreload_Allocation__allocInit_autoRun")call Vnx(function Grx,"s"+"__DestructableType_objInits_autoRun")
call Vnx(function Gix,"s"+"__DestructableType_Allocation__allocInit_autoRun")call Vnx(function Gax,"s"+"__FolderDestructable_StructId_Allocation__allocInit_autoRun")
call Vnx(function Gnx,"s"+"__FolderDestructable_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vnx(function GVx,"s"+"__FolderDestructable_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vnx(function GEx,"s"+"__FolderDestructable_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vnx(function GXx,"s"+"__FolderDestructable_FolderData_FolderReal_StructTable_Allocation__allocInit_autoRun")call Vnx(function GOx,"s"+"__FolderDestructable_FolderData_StructReal_Allocation__allocInit_autoRun")call Vnx(function GRx,"s"+"__FolderDestructable_StructData_Allocation__allocInit_autoRun")call Vnx(function GIx,"s"+"__FolderDestructable_FolderEvent_StructNative_Allocation__allocInit_autoRun")
call Vnx(function GAx,"s"+"__FolderDestructable_StructEvent_Allocation__allocInit_autoRun")call Vnx(function GNx,"s"+"__FolderDestructable_StructType_Allocation__allocInit_autoRun")call Vnx(function Gbx,"s"+"__FolderDestructable_StructTimedLife_Allocation__allocInit_autoRun")call Vnx(function GBx,"s"+"__FolderDestructable_FolderEnum_StructInRange_Allocation__allocInit_autoRun")
call Vnx(function Gcx,"s"+"__FolderDestructable_StructEnum_Allocation__allocInit_autoRun")call Vnx(function GCx,"s"+"__FolderDestructable_StructLife_Allocation__allocInit_autoRun")call Vnx(function Gdx,"s"+"__Destructable_Allocation__allocInit_autoRun")call Vnx(function hxx,"s"+"__Destructable_initializer_Init_autoRun")
call Vnx(function hox,"s"+"__FolderDialogButton_StructId_Allocation__allocInit_autoRun")
call Vnx(function hrx,"s"+"__FolderDialogButton_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vnx(function hix,"s"+"__FolderDialogButton_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vnx(function hax,"s"+"__FolderDialogButton_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vnx(function hnx,"s"+"__FolderDialogButton_FolderData_StructReal_Allocation__allocInit_autoRun")call Vnx(function hVx,"s"+"__FolderDialogButton_StructData_Allocation__allocInit_autoRun")call Vnx(function hEx,"s"+"__FolderDialogButton_FolderEvent_StructNative_Allocation__allocInit_autoRun")
call Vnx(function hXx,"s"+"__FolderDialogButton_StructEvent_Allocation__allocInit_autoRun")call Vnx(function hOx,"s"+"__DialogButton_Allocation__allocInit_autoRun")call Vnx(function hRx,"s"+"__FolderDialog_StructId_Allocation__allocInit_autoRun")call Vnx(function hIx,"s"+"__FolderDialog_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function hAx,"s"+"__FolderDialog_FolderData_StructBoolean_Allocation__allocInit_autoRun")call Vnx(function hNx,"s"+"__FolderDialog_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function hbx,"s"+"__FolderDialog_FolderData_StructReal_Allocation__allocInit_autoRun")call Vnx(function hBx,"s"+"__FolderDialog_StructData_Allocation__allocInit_autoRun")
call Vnx(function hcx,"s"+"__FolderDialog_FolderEvent_StructNative_Allocation__allocInit_autoRun")call Vnx(function hCx,"s"+"__FolderDialog_StructEvent_Allocation__allocInit_autoRun")call Vnx(function hdx,"s"+"__FolderDialog_StructButtons_Allocation__allocInit_autoRun")call Vnx(function hDx,"s"+"__Dialog_Allocation__allocInit_autoRun")call Vnx(function hux,"s"+"__Dialog_initializer_Init_autoRun")call Vnx(function hUx,"s"+"__EffectLevel_Allocation__allocInit_autoRun")
call Vnx(function hwx,"s"+"__FolderSpotEffectWithSize_StructDestroyTimed_Allocation__allocInit_autoRun")
call Vnx(function hWx,"s"+"__SpotEffectWithSize_objInits_autoRun")call Vnx(function hyx,"s"+"__SpotEffectWithSize_Allocation__allocInit_autoRun")call Vnx(function hYx,"s"+"__DummyUnitEffect_Allocation__allocInit_autoRun")
call Vnx(function hzx,"s"+"__FolderSpotEffect_StructId_Allocation__allocInit_autoRun")call Vnx(function hZx,"s"+"__FolderSpotEffect_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function h_x,"s"+"__FolderSpotEffect_FolderData_StructBoolean_Allocation__allocInit_autoRun")call Vnx(function h0x,"s"+"__FolderSpotEffect_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function h1x,"s"+"__FolderSpotEffect_StructData_Allocation__allocInit_autoRun")
call Vnx(function h2x,"s"+"__FolderSpotEffect_StructEvent_Allocation__allocInit_autoRun")call Vnx(function h3x,"s"+"__FolderSpotEffect_StructDestroyTimed_Allocation__allocInit_autoRun")
call Vnx(function h4x,"s"+"__SpotEffect_objInits_autoRun")call Vnx(function h5x,"s"+"__SpotEffect_Allocation__allocInit_autoRun")call Vnx(function h6x,"s"+"__FolderUnitEffect_StructId_Allocation__allocInit_autoRun")call Vnx(function h7x,"s"+"__FolderUnitEffect_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function h8x,"s"+"__FolderUnitEffect_FolderData_StructBoolean_Allocation__allocInit_autoRun")call Vnx(function h9x,"s"+"__FolderUnitEffect_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function Hvx,"s"+"__FolderUnitEffect_StructData_Allocation__allocInit_autoRun")
call Vnx(function Hex,"s"+"__FolderUnitEffect_StructEvent_Allocation__allocInit_autoRun")call Vnx(function Hxx,"s"+"__FolderUnitEffect_StructDestroyTimed_Allocation__allocInit_autoRun")
call Vnx(function Hox,"s"+"__UnitEffect_Allocation__allocInit_autoRun")call Vnx(function Hrx,"s"+"__Effect_Allocation__allocInit_autoRun")call Vnx(function Hkx,"s"+"__Effect_initializer_Init_autoRun")call Vnx(function HKx,"s"+"__FolderEventMemoryHead_FolderIntegerKeys_StructD2_Allocation__allocInit_autoRun")call Vnx(function Hlx,"s"+"__FolderEventMemoryHead_StructIntegerKeys_Allocation__allocInit_autoRun")
call Vnx(function HLx,"s"+"__FolderEventMemory_FolderIntegerKeys_FolderD2_StructTable_Allocation__allocInit_autoRun")call Vnx(function Hmx,"s"+"__FolderEventMemory_FolderIntegerKeys_StructD2_Allocation__allocInit_autoRun")call Vnx(function HMx,"s"+"__FolderEventMemory_FolderIntegerKeys_StructTable_Allocation__allocInit_autoRun")
call Vnx(function Hpx,"s"+"__FolderEventMemory_StructIntegerKeys_Allocation__allocInit_autoRun")
call Vnx(function Htx,"s"+"__EventMemory_initializer_Init_autoRun")call Vnx(function HTx,"s"+"__EventPair_Allocation__allocInit_autoRun")call Vnx(function Hux,"s"+"__FolderEventCombination_StructId_Allocation__allocInit_autoRun")
call Vnx(function HUx,"s"+"__FolderEventCombination_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vnx(function Hwx,"s"+"__FolderEventCombination_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vnx(function HWx,"s"+"__FolderEventCombination_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vnx(function Hyx,"s"+"__FolderEventCombination_StructData_Allocation__allocInit_autoRun")call Vnx(function HYx,"s"+"__FolderEventCombination_StructRemainingEventsAmount_Allocation__allocInit_autoRun")call Vnx(function Hzx,"s"+"__FolderEventCombination_StructEvents_Allocation__allocInit_autoRun")
call Vnx(function HZx,"s"+"__FolderEventCombination_StructSubjects_Allocation__allocInit_autoRun")call Vnx(function H_x,"s"+"__FolderEventCombination_FolderPeriodic_StructSubjectsA_Allocation__allocInit_autoRun")call Vnx(function H0x,"s"+"__FolderEventCombination_StructPeriodic_Allocation__allocInit_autoRun")call Vnx(function H1x,"s"+"__FolderEventCombination_StructPairs_Allocation__allocInit_autoRun")call Vnx(function H2x,"s"+"__EventCombination_Allocation__allocInit_autoRun")call Vnx(function H4x,"s"+"__EventCombination_initializer_Init_autoRun")
call Vnx(function H5x,"s"+"__Announcement_Allocation__allocInit_autoRun")call Vnx(function H6x,"s"+"__GameMessage_Allocation__allocInit_autoRun")
call Vnx(function H7x,"s"+"__CineFilter_Allocation__allocInit_autoRun")call Vnx(function H8x,"s"+"__FolderGame_StructFloatState_Allocation__allocInit_autoRun")
call Vnx(function H9x,"s"+"__FolderGame_StructTimeOfDay_Allocation__allocInit_autoRun")call Vnx(function jEx,"s"+"__Game_initializer_Init_autoRun")
call Vnx(function jXx,"s"+"__PingColor_Allocation__allocInit_autoRun")call Vnx(function jOx,"s"+"__Ping_Allocation__allocInit_autoRun")call Vnx(function jRx,"s"+"__FolderGroup_StructRefs_Allocation__allocInit_autoRun")call Vnx(function jIx,"s"+"__FolderGroup_StructCountUnits_Allocation__allocInit_autoRun")call Vnx(function jAx,"s"+"__FolderGroup_StructNearestUnit_Allocation__allocInit_autoRun")call Vnx(function jNx,"s"+"__FolderGroup_StructOrder_Allocation__allocInit_autoRun")
call Vnx(function jbx,"s"+"__FolderGroup_StructRandomUnit_Allocation__allocInit_autoRun")call Vnx(function jBx,"s"+"__FolderGroup_FolderEnumUnits_FolderInLine_StructWithCollision_Allocation__allocInit_autoRun")call Vnx(function jcx,"s"+"__FolderGroup_FolderEnumUnits_StructInLine_Allocation__allocInit_autoRun")call Vnx(function jCx,"s"+"__FolderGroup_FolderEnumUnits_FolderInRange_StructWithCollision_Allocation__allocInit_autoRun")call Vnx(function jdx,"s"+"__FolderGroup_FolderEnumUnits_StructInRange_Allocation__allocInit_autoRun")call Vnx(function jDx,"s"+"__FolderGroup_FolderEnumUnits_FolderInRect_StructWithCollision_Allocation__allocInit_autoRun")call Vnx(function jfx,"s"+"__FolderGroup_FolderEnumUnits_StructInRect_Allocation__allocInit_autoRun")call Vnx(function jFx,"s"+"__FolderGroup_StructEnumUnits_Allocation__allocInit_autoRun")
call Vnx(function jgx,"s"+"__Group_Allocation__allocInit_autoRun")call Vnx(function JCx,"s"+"__Group_initializer_Init_autoRun")call Vnx(function Jdx,"s"+"__FolderUnitList_StructId_Allocation__allocInit_autoRun")
call Vnx(function JDx,"s"+"__FolderUnitList_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vnx(function Jfx,"s"+"__FolderUnitList_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vnx(function JFx,"s"+"__FolderUnitList_StructData_Allocation__allocInit_autoRun")call Vnx(function Jgx,"s"+"__FolderUnitList_StructRefs_Allocation__allocInit_autoRun")call Vnx(function JGx,"s"+"__UnitList_Allocation__allocInit_autoRun")call Vnx(function Jhx,"s"+"__FolderItemClass_StructId_Allocation__allocInit_autoRun")call Vnx(function JHx,"s"+"__FolderItemClass_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function Jjx,"s"+"__FolderItemClass_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function JJx,"s"+"__FolderItemClass_StructData_Allocation__allocInit_autoRun")call Vnx(function Jkx,"s"+"__ItemClass_Allocation__allocInit_autoRun")call Vnx(function JKx,"s"+"__FolderItem_StructId_Allocation__allocInit_autoRun")
call Vnx(function Jlx,"s"+"__FolderItem_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vnx(function JLx,"s"+"__FolderItem_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vnx(function Jmx,"s"+"__FolderItem_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vnx(function JMx,"s"+"__FolderItem_StructData_Allocation__allocInit_autoRun")call Vnx(function Jpx,"s"+"__FolderItem_FolderEvent_StructNative_Allocation__allocInit_autoRun")
call Vnx(function JPx,"s"+"__FolderItem_StructEvent_Allocation__allocInit_autoRun")call Vnx(function Jqx,"s"+"__FolderItem_StructClasses_Allocation__allocInit_autoRun")call Vnx(function JQx,"s"+"__FolderItem_StructType_Allocation__allocInit_autoRun")call Vnx(function Jsx,"s"+"__FolderItem_StructAbilities_Allocation__allocInit_autoRun")call Vnx(function JSx,"s"+"__FolderItem_StructChargesAmount_Allocation__allocInit_autoRun")call Vnx(function Jtx,"s"+"__FolderItem_StructPosition_Allocation__allocInit_autoRun")call Vnx(function JTx,"s"+"__Item_Allocation__allocInit_autoRun")call Vnx(function kLx,"s"+"__Item_initializer_Init_autoRun")
call Vnx(function kmx,"s"+"__FolderItemType_StructId_Allocation__allocInit_autoRun")
call Vnx(function kMx,"s"+"__FolderItemType_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vnx(function kpx,"s"+"__FolderItemType_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vnx(function kPx,"s"+"__FolderItemType_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vnx(function kqx,"s"+"__FolderItemType_StructData_Allocation__allocInit_autoRun")call Vnx(function kQx,"s"+"__FolderItemType_StructEvent_Allocation__allocInit_autoRun")call Vnx(function ksx,"s"+"__FolderItemType_StructAbilities_Allocation__allocInit_autoRun")call Vnx(function kSx,"s"+"__FolderItemType_StructChargesAmount_Allocation__allocInit_autoRun")call Vnx(function ktx,"s"+"__FolderItemType_StructClasses_Allocation__allocInit_autoRun")call Vnx(function kTx,"s"+"__FolderItemType_StructPreload_Allocation__allocInit_autoRun")call Vnx(function kux,"s"+"__FolderItemType_StructUsageGoldCost_Allocation__allocInit_autoRun")call Vnx(function kUx,"s"+"__ItemType_objInits_autoRun")
call Vnx(function kwx,"s"+"__ItemType_Allocation__allocInit_autoRun")call Vnx(function kWx,"s"+"__LightningType_Allocation__allocInit_autoRun")call Vnx(function kyx,"s"+"__FolderLightning_StructId_Allocation__allocInit_autoRun")call Vnx(function kYx,"s"+"__FolderLightning_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function kzx,"s"+"__FolderLightning_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function kZx,"s"+"__FolderLightning_StructData_Allocation__allocInit_autoRun")call Vnx(function k_x,"s"+"__FolderLightning_StructEvent_Allocation__allocInit_autoRun")
call Vnx(function k0x,"s"+"__FolderLightning_FolderColor_StructRed_Allocation__allocInit_autoRun")call Vnx(function k1x,"s"+"__FolderLightning_FolderColor_StructGreen_Allocation__allocInit_autoRun")
call Vnx(function k2x,"s"+"__FolderLightning_FolderColor_StructBlue_Allocation__allocInit_autoRun")call Vnx(function k3x,"s"+"__FolderLightning_FolderColor_StructAlpha_Allocation__allocInit_autoRun")
call Vnx(function k4x,"s"+"__FolderLightning_FolderColor_StructTimed_Allocation__allocInit_autoRun")
call Vnx(function k5x,"s"+"__FolderLightning_StructColor_Allocation__allocInit_autoRun")
call Vnx(function k6x,"s"+"__FolderLightning_StructFromDummyUnitToUnit_Allocation__allocInit_autoRun")call Vnx(function k7x,"s"+"__FolderLightning_StructFromSpotToDummyUnit_Allocation__allocInit_autoRun")call Vnx(function k8x,"s"+"__FolderLightning_StructFromSpotToSpot_Allocation__allocInit_autoRun")call Vnx(function k9x,"s"+"__FolderLightning_StructFromSpotToUnit_Allocation__allocInit_autoRun")call Vnx(function Kvx,"s"+"__FolderLightning_StructFromUnitToUnit_Allocation__allocInit_autoRun")call Vnx(function Kex,"s"+"__FolderLightning_StructDestroyTimed_Allocation__allocInit_autoRun")call Vnx(function Kxx,"s"+"__Lightning_Allocation__allocInit_autoRun")call Vnx(function lHx,"s"+"__Lightning_initializer_Init_autoRun")call Vnx(function ljx,"s"+"__LoadingEx_objInits_autoRun")call Vnx(function lJx,"s"+"__LoadingEx_Allocation__allocInit_autoRun")call Vnx(function lkx,"s"+"__AICastSpell_Allocation__allocInit_autoRun")
call Vnx(function lpx,"s"+"__AICastSpell_initializer_Init_autoRun")call Vnx(function l6x,"s"+"__AILetOff_objInits_autoRun")
call Vnx(function l7x,"s"+"__AILetOff_Allocation__allocInit_autoRun")call Vnx(function Lcx,"s"+"__AILetOff_initializer_Init_autoRun")
call Vnx(function LCx,"s"+"__CustomDrop_Allocation__allocInit_autoRun")call Vnx(function Ldx,"s"+"__FolderDummyUnit_StructId_Allocation__allocInit_autoRun")call Vnx(function LDx,"s"+"__FolderDummyUnit_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function Lfx,"s"+"__FolderDummyUnit_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function LFx,"s"+"__FolderDummyUnit_StructData_Allocation__allocInit_autoRun")call Vnx(function Lgx,"s"+"__FolderDummyUnit_FolderEvent_StructNative_Allocation__allocInit_autoRun")call Vnx(function LGx,"s"+"__FolderDummyUnit_StructEvent_Allocation__allocInit_autoRun")
call Vnx(function Lhx,"s"+"__FolderDummyUnit_StructAbilities_Allocation__allocInit_autoRun")
call Vnx(function LHx,"s"+"__FolderDummyUnit_StructAnimation_Allocation__allocInit_autoRun")
call Vnx(function Ljx,"s"+"__FolderDummyUnit_StructDestroyTimed_Allocation__allocInit_autoRun")call Vnx(function LJx,"s"+"__FolderDummyUnit_StructDestruction_Allocation__allocInit_autoRun")call Vnx(function Lkx,"s"+"__FolderDummyUnit_StructFacing_Allocation__allocInit_autoRun")call Vnx(function LKx,"s"+"__FolderDummyUnit_StructPlayerColor_Allocation__allocInit_autoRun")call Vnx(function Llx,"s"+"__FolderDummyUnit_StructOrder_Allocation__allocInit_autoRun")
call Vnx(function LLx,"s"+"__FolderDummyUnit_StructOwner_Allocation__allocInit_autoRun")
call Vnx(function Lmx,"s"+"__FolderDummyUnit_FolderPosition_StructX_Allocation__allocInit_autoRun")call Vnx(function LMx,"s"+"__FolderDummyUnit_FolderPosition_StructY_Allocation__allocInit_autoRun")call Vnx(function Lpx,"s"+"__FolderDummyUnit_FolderPosition_StructZ_Allocation__allocInit_autoRun")call Vnx(function LPx,"s"+"__FolderDummyUnit_StructPosition_Allocation__allocInit_autoRun")call Vnx(function Lqx,"s"+"__FolderDummyUnit_StructFollowDummyUnit_Allocation__allocInit_autoRun")call Vnx(function LQx,"s"+"__FolderDummyUnit_StructFollowUnit_Allocation__allocInit_autoRun")call Vnx(function Lsx,"s"+"__FolderDummyUnit_StructRotate_Allocation__allocInit_autoRun")call Vnx(function LSx,"s"+"__FolderDummyUnit_FolderScale_StructTimed_Allocation__allocInit_autoRun")
call Vnx(function Ltx,"s"+"__FolderDummyUnit_StructScale_Allocation__allocInit_autoRun")
call Vnx(function LTx,"s"+"__FolderDummyUnit_FolderVertexColor_StructRed_Allocation__allocInit_autoRun")
call Vnx(function Lux,"s"+"__FolderDummyUnit_FolderVertexColor_StructGreen_Allocation__allocInit_autoRun")call Vnx(function LUx,"s"+"__FolderDummyUnit_FolderVertexColor_StructBlue_Allocation__allocInit_autoRun")call Vnx(function Lwx,"s"+"__FolderDummyUnit_FolderVertexColor_StructAlpha_Allocation__allocInit_autoRun")call Vnx(function LWx,"s"+"__FolderDummyUnit_FolderVertexColor_StructTimed_Allocation__allocInit_autoRun")call Vnx(function Lyx,"s"+"__FolderDummyUnit_StructVertexColor_Allocation__allocInit_autoRun")call Vnx(function L4x,"s"+"__DummyUnit_objInits_autoRun")call Vnx(function L5x,"s"+"__DummyUnit_Allocation__allocInit_autoRun")call Vnx(function L6x,"s"+"__TargetFlag_Allocation__allocInit_autoRun")call Vnx(function L7x,"s"+"__Misc_Allocation__allocInit_autoRun")call Vnx(function mGx,"s"+"__Misc_initializer_Init_autoRun")
call Vnx(function mhx,"s"+"__FolderMissileCheckpoint_StructId_Allocation__allocInit_autoRun")call Vnx(function mHx,"s"+"__FolderMissileCheckpoint_FolderData_StructBoolean_Allocation__allocInit_autoRun")call Vnx(function mjx,"s"+"__FolderMissileCheckpoint_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function mJx,"s"+"__FolderMissileCheckpoint_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function mkx,"s"+"__FolderMissileCheckpoint_StructData_Allocation__allocInit_autoRun")call Vnx(function mKx,"s"+"__MissileCheckpoint_Allocation__allocInit_autoRun")call Vnx(function mlx,"s"+"__FolderMissile_StructId_Allocation__allocInit_autoRun")call Vnx(function mLx,"s"+"__FolderMissile_FolderData_StructBoolean_Allocation__allocInit_autoRun")call Vnx(function mmx,"s"+"__FolderMissile_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function mMx,"s"+"__FolderMissile_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function mpx,"s"+"__FolderMissile_StructData_Allocation__allocInit_autoRun")call Vnx(function mPx,"s"+"__FolderMissile_StructEvent_Allocation__allocInit_autoRun")call Vnx(function mqx,"s"+"__FolderMissile_StructArc_Allocation__allocInit_autoRun")
call Vnx(function mQx,"s"+"__FolderMissile_StructImpact_Allocation__allocInit_autoRun")call Vnx(function msx,"s"+"__FolderMissile_StructCollisionSize_Allocation__allocInit_autoRun")call Vnx(function mSx,"s"+"__FolderMissile_StructDummyUnit_Allocation__allocInit_autoRun")call Vnx(function mtx,"s"+"__FolderMissile_StructAngle_Allocation__allocInit_autoRun")call Vnx(function mTx,"s"+"__FolderMissile_FolderPosition_StructX_Allocation__allocInit_autoRun")call Vnx(function mux,"s"+"__FolderMissile_FolderPosition_StructY_Allocation__allocInit_autoRun")call Vnx(function mUx,"s"+"__FolderMissile_FolderPosition_StructZ_Allocation__allocInit_autoRun")call Vnx(function mwx,"s"+"__FolderMissile_StructPosition_Allocation__allocInit_autoRun")call Vnx(function mWx,"s"+"__FolderMissile_StructUpdateTime_Allocation__allocInit_autoRun")call Vnx(function myx,"s"+"__FolderMissile_StructAcceleration_Allocation__allocInit_autoRun")call Vnx(function mYx,"s"+"__FolderMissile_StructSpeed_Allocation__allocInit_autoRun")call Vnx(function mzx,"s"+"__FolderMissile_StructGoToSpot_Allocation__allocInit_autoRun")call Vnx(function mZx,"s"+"__FolderMissile_StructCheckpoints_Allocation__allocInit_autoRun")
call Vnx(function m_x,"s"+"__FolderMissile_StructGoToUnit_Allocation__allocInit_autoRun")call Vnx(function m0x,"s"+"__Missile_Allocation__allocInit_autoRun")
call Vnx(function Mux,"s"+"__Missile_initializer_Init_autoRun")call Vnx(function MUx,"s"+"__MultiboardItem_Allocation__allocInit_autoRun")call Vnx(function Mwx,"s"+"__FolderMultiboard_StructColumn_Allocation__allocInit_autoRun")call Vnx(function MWx,"s"+"__FolderMultiboard_StructColumnSpan_Allocation__allocInit_autoRun")call Vnx(function Myx,"s"+"__FolderMultiboard_StructRow_Allocation__allocInit_autoRun")call Vnx(function MYx,"s"+"__FolderMultiboard_StructTitle_Allocation__allocInit_autoRun")call Vnx(function Mzx,"s"+"__FolderMultiboard_FolderShown_FolderControl_StructPageSwitch_Allocation__allocInit_autoRun")
call Vnx(function MZx,"s"+"__FolderMultiboard_FolderShown_StructControl_Allocation__allocInit_autoRun")call Vnx(function M_x,"s"+"__FolderMultiboard_StructShown_Allocation__allocInit_autoRun")call Vnx(function M0x,"s"+"__Multiboard_Allocation__allocInit_autoRun")call Vnx(function qcx,"s"+"__Multiboard_initializer_Init_autoRun")call Vnx(function qCx,"s"+"__FolderOrder_StructId_Allocation__allocInit_autoRun")call Vnx(function qdx,"s"+"__FolderOrder_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function qDx,"s"+"__FolderOrder_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function qfx,"s"+"__FolderOrder_StructData_Allocation__allocInit_autoRun")call Vnx(function qFx,"s"+"__FolderOrder_FolderEvent_StructNative_Allocation__allocInit_autoRun")call Vnx(function qgx,"s"+"__FolderOrder_StructEvent_Allocation__allocInit_autoRun")
call Vnx(function qGx,"s"+"__Order_Allocation__allocInit_autoRun")call Vnx(function qKx,"s"+"__Order_initializer_Init_autoRun")call Vnx(function qlx,"s"+"__FolderOrderInstance_StructRefs_Allocation__allocInit_autoRun")call Vnx(function qLx,"s"+"__OrderInstance_Allocation__allocInit_autoRun")call Vnx(function qmx,"s"+"__FolderReal_StructEvent_Allocation__allocInit_autoRun")call Vnx(function qMx,"s"+"__FolderString_StructColor_Allocation__allocInit_autoRun")call Vnx(function qtx,"s"+"__Primitive_initializer_Init_autoRun")call Vnx(function qTx,"s"+"__FolderRectangle_StructId_Allocation__allocInit_autoRun")call Vnx(function qux,"s"+"__FolderRectangle_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function qUx,"s"+"__FolderRectangle_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function qwx,"s"+"__FolderRectangle_StructData_Allocation__allocInit_autoRun")call Vnx(function qWx,"s"+"__Rectangle_Allocation__allocInit_autoRun")call Vnx(function qyx,"s"+"__FolderRegion_StructId_Allocation__allocInit_autoRun")call Vnx(function qYx,"s"+"__FolderRegion_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function qzx,"s"+"__FolderRegion_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function qZx,"s"+"__FolderRegion_StructData_Allocation__allocInit_autoRun")
call Vnx(function q_x,"s"+"__FolderRegion_FolderEvent_StructNative_Allocation__allocInit_autoRun")call Vnx(function q0x,"s"+"__FolderRegion_StructEvent_Allocation__allocInit_autoRun")call Vnx(function q1x,"s"+"__Region_Allocation__allocInit_autoRun")call Vnx(function q4x,"s"+"__Region_initializer_Init_autoRun")call Vnx(function q5x,"s"+"__Music_Allocation__allocInit_autoRun")call Vnx(function q6x,"s"+"__SoundChannel_Allocation__allocInit_autoRun")call Vnx(function q7x,"s"+"__SoundEax_Allocation__allocInit_autoRun")call Vnx(function q8x,"s"+"__SoundType_Allocation__allocInit_autoRun")call Vnx(function q9x,"s"+"__Sound_Allocation__allocInit_autoRun")call Vnx(function QBx,"s"+"__Sound_initializer_Init_autoRun")call Vnx(function Qcx,"s"+"__UnitSound_Allocation__allocInit_autoRun")call Vnx(function Qgx,"s"+"__HeroSpell_objInits_autoRun")call Vnx(function QGx,"s"+"__HeroSpell_Allocation__allocInit_autoRun")call Vnx(function Qhx,"s"+"__SpellClass_Allocation__allocInit_autoRun")call Vnx(function QHx,"s"+"__FolderSpell_StructId_Allocation__allocInit_autoRun")call Vnx(function Qjx,"s"+"__FolderSpell_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function QJx,"s"+"__FolderSpell_FolderData_StructBoolean_Allocation__allocInit_autoRun")call Vnx(function Qkx,"s"+"__FolderSpell_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function QKx,"s"+"__FolderSpell_FolderData_StructReal_Allocation__allocInit_autoRun")call Vnx(function Qlx,"s"+"__FolderSpell_StructData_Allocation__allocInit_autoRun")call Vnx(function QLx,"s"+"__FolderSpell_FolderEvent_StructNative_Allocation__allocInit_autoRun")call Vnx(function Qmx,"s"+"__FolderSpell_StructEvent_Allocation__allocInit_autoRun")
call Vnx(function QMx,"s"+"__Spell_objInits_autoRun")call Vnx(function Qpx,"s"+"__Spell_Allocation__allocInit_autoRun")call Vnx(function svx,"s"+"__Spell_initializer_Init_autoRun")call Vnx(function sex,"s"+"__FolderSpellInstance_StructRefs_Allocation__allocInit_autoRun")call Vnx(function sxx,"s"+"__SpellInstance_Allocation__allocInit_autoRun")call Vnx(function sox,"s"+"__FolderSpot_FolderEvent_StructNative_Allocation__allocInit_autoRun")
call Vnx(function srx,"s"+"__FolderSpot_StructEvent_Allocation__allocInit_autoRun")call Vnx(function six,"s"+"__FolderSpot_StructDeformNova_Allocation__allocInit_autoRun")
call Vnx(function sax,"s"+"__Spot_Allocation__allocInit_autoRun")call Vnx(function sOx,"s"+"__Spot_initializer_Init_autoRun")
call Vnx(function sRx,"s"+"__FolderStringData_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function sIx,"s"+"__FolderStringData_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function sAx,"s"+"__FolderStringData_StructData_Allocation__allocInit_autoRun")
call Vnx(function sNx,"s"+"__FolderStringData_FolderEvent_StructNative_Allocation__allocInit_autoRun")call Vnx(function sbx,"s"+"__FolderStringData_StructEvent_Allocation__allocInit_autoRun")call Vnx(function sBx,"s"+"__StringData_Allocation__allocInit_autoRun")call Vnx(function sCx,"s"+"__StringData_initializer_Init_autoRun")call Vnx(function sqx,"s"+"__TileType_objInits_autoRun")
call Vnx(function sQx,"s"+"__TileType_Allocation__allocInit_autoRun")call Vnx(function sSx,"s"+"__TileType_initializer_Init_autoRun")
call Vnx(function stx,"s"+"__FolderTile_StructType_Allocation__allocInit_autoRun")call Vnx(function sTx,"s"+"__Tile_Allocation__allocInit_autoRun")call Vnx(function sUx,"s"+"__Tile_initializer_Init_autoRun")
call Vnx(function swx,"s"+"__FolderTileTypeMod_StructDestroyTimed_Allocation__allocInit_autoRun")call Vnx(function sWx,"s"+"__TileTypeMod_Allocation__allocInit_autoRun")
call Vnx(function sYx,"s"+"__TileTypeMod_initializer_Init_autoRun")call Vnx(function s2x,"s"+"__UbersplatType_objInits_autoRun")call Vnx(function s3x,"s"+"__UbersplatType_Allocation__allocInit_autoRun")call Vnx(function s4x,"s"+"__FolderUbersplat_StructId_Allocation__allocInit_autoRun")call Vnx(function s5x,"s"+"__FolderUbersplat_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function s6x,"s"+"__FolderUbersplat_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function s7x,"s"+"__FolderUbersplat_StructData_Allocation__allocInit_autoRun")call Vnx(function s8x,"s"+"__FolderUbersplat_StructEvent_Allocation__allocInit_autoRun")
call Vnx(function s9x,"s"+"__FolderUbersplat_StructDestroyTimed_Allocation__allocInit_autoRun")call Vnx(function Svx,"s"+"__FolderUbersplat_FolderColor_StructRed_Allocation__allocInit_autoRun")call Vnx(function Sex,"s"+"__FolderUbersplat_FolderColor_StructGreen_Allocation__allocInit_autoRun")
call Vnx(function Sxx,"s"+"__FolderUbersplat_FolderColor_StructBlue_Allocation__allocInit_autoRun")call Vnx(function Sox,"s"+"__FolderUbersplat_FolderColor_StructAlpha_Allocation__allocInit_autoRun")
call Vnx(function Srx,"s"+"__FolderUbersplat_FolderColor_StructTimed_Allocation__allocInit_autoRun")
call Vnx(function Six,"s"+"__FolderUbersplat_StructColor_Allocation__allocInit_autoRun")
call Vnx(function Sax,"s"+"__FolderUbersplat_FolderPosition_StructX_Allocation__allocInit_autoRun")call Vnx(function Snx,"s"+"__FolderUbersplat_FolderPosition_StructY_Allocation__allocInit_autoRun")call Vnx(function SVx,"s"+"__FolderUbersplat_StructPosition_Allocation__allocInit_autoRun")call Vnx(function SEx,"s"+"__Ubersplat_Allocation__allocInit_autoRun")call Vnx(function Sfx,"s"+"__Ubersplat_initializer_Init_autoRun")call Vnx(function SFx,"s"+"__FolderTextTag_StructPosition_Allocation__allocInit_autoRun")call Vnx(function Sgx,"s"+"__FolderTextTag_StructText_Allocation__allocInit_autoRun")call Vnx(function SGx,"s"+"__FolderTextTag_StructCreateJumping_Allocation__allocInit_autoRun")call Vnx(function Shx,"s"+"__FolderTextTag_StructCreateMoving_Allocation__allocInit_autoRun")call Vnx(function SHx,"s"+"__FolderTextTag_StructCreateRising_Allocation__allocInit_autoRun")call Vnx(function Sjx,"s"+"__FolderTextTag_FolderFadingOut_StructDelay_Allocation__allocInit_autoRun")call Vnx(function SJx,"s"+"__FolderTextTag_StructFadingOut_Allocation__allocInit_autoRun")call Vnx(function Skx,"s"+"__TextTag_Allocation__allocInit_autoRun")
call Vnx(function Slx,"s"+"__TextTag_initializer_Init_autoRun")call Vnx(function SLx,"s"+"__TimerDialog_Allocation__allocInit_autoRun")
call Vnx(function Smx,"s"+"__FolderTriggerTimer_StructId_Allocation__allocInit_autoRun")
call Vnx(function SMx,"s"+"__FolderTriggerTimer_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vnx(function Spx,"s"+"__FolderTriggerTimer_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vnx(function SPx,"s"+"__FolderTriggerTimer_StructData_Allocation__allocInit_autoRun")call Vnx(function Sqx,"s"+"__TriggerTimer_Allocation__allocInit_autoRun")call Vnx(function SQx,"s"+"__FolderTimer_StructId_Allocation__allocInit_autoRun")call Vnx(function Ssx,"s"+"__FolderTimer_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function SSx,"s"+"__FolderTimer_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function Stx,"s"+"__FolderTimer_StructData_Allocation__allocInit_autoRun")call Vnx(function STx,"s"+"__Timer_Allocation__allocInit_autoRun")call Vnx(function SWx,"s"+"__Timer_initializer_Init_autoRun")call Vnx(function Syx,"s"+"__FolderTrigger_StructId_Allocation__allocInit_autoRun")call Vnx(function SYx,"s"+"__FolderTrigger_FolderData_StructBoolean_Allocation__allocInit_autoRun")call Vnx(function Szx,"s"+"__FolderTrigger_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function SZx,"s"+"__FolderTrigger_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function S_x,"s"+"__FolderTrigger_StructData_Allocation__allocInit_autoRun")call Vnx(function S0x,"s"+"__FolderTrigger_FolderEvent_StructNative_Allocation__allocInit_autoRun")call Vnx(function S1x,"s"+"__FolderTrigger_StructEvent_Allocation__allocInit_autoRun")call Vnx(function S2x,"s"+"__FolderTrigger_StructRegisterEvent_Allocation__allocInit_autoRun")call Vnx(function S3x,"s"+"__Trigger_Allocation__allocInit_autoRun")
call Vnx(function S7x,"s"+"__Trigger_initializer_Init_autoRun")call Vnx(function tIx,"s"+"__FolderBJUnit_FolderArmor_StructBonus_objInits_autoRun")
call Vnx(function tAx,"s"+"__FolderBJUnit_FolderArmor_StructBonus_Allocation__allocInit_autoRun")call Vnx(function tNx,"s"+"__FolderBJUnit_StructArmor_Allocation__allocInit_autoRun")call Vnx(function tPx,"s"+"__FolderBJUnit_FolderAttack_FolderSpeed_StructBonusA_objInits_autoRun")call Vnx(function tqx,"s"+"__FolderBJUnit_FolderAttack_FolderSpeed_StructBonusA_Allocation__allocInit_autoRun")call Vnx(function tQx,"s"+"__FolderBJUnit_FolderAttack_StructSpeed_Allocation__allocInit_autoRun")call Vnx(function tSx,"s"+"__FolderBJUnit_StructAttack_objInits_autoRun")call Vnx(function ttx,"s"+"__FolderBJUnit_StructAttack_Allocation__allocInit_autoRun")call Vnx(function t5x,"s"+"__FolderBJUnit_FolderDamage_StructBonus_objInits_autoRun")call Vnx(function t6x,"s"+"__FolderBJUnit_FolderDamage_StructBonus_Allocation__allocInit_autoRun")call Vnx(function Tkx,"s"+"__FolderBJUnit_StructDamage_objInits_autoRun")call Vnx(function TKx,"s"+"__FolderBJUnit_StructDamage_Allocation__allocInit_autoRun")call Vnx(function TLx,"s"+"__FolderBJUnit_StructMovement_objInits_autoRun")call Vnx(function Tmx,"s"+"__FolderBJUnit_StructMovement_Allocation__allocInit_autoRun")
call Vnx(function Tzx,"s"+"__FolderBJUnit_FolderHero_FolderAgility_StructBonusA_objInits_autoRun")call Vnx(function TZx,"s"+"__FolderBJUnit_FolderHero_FolderAgility_StructBonusA_Allocation__allocInit_autoRun")call Vnx(function T_x,"s"+"__FolderBJUnit_FolderHero_StructAgility_Allocation__allocInit_autoRun")call Vnx(function uix,"s"+"__FolderBJUnit_FolderHero_FolderIntelligence_StructBonusA_objInits_autoRun")call Vnx(function uax,"s"+"__FolderBJUnit_FolderHero_FolderIntelligence_StructBonusA_Allocation__allocInit_autoRun")
call Vnx(function unx,"s"+"__FolderBJUnit_FolderHero_StructIntelligence_Allocation__allocInit_autoRun")call Vnx(function uFx,"s"+"__FolderBJUnit_FolderHero_FolderStrength_StructBonusA_objInits_autoRun")call Vnx(function ugx,"s"+"__FolderBJUnit_FolderHero_FolderStrength_StructBonusA_Allocation__allocInit_autoRun")
call Vnx(function uGx,"s"+"__FolderBJUnit_FolderHero_StructStrength_Allocation__allocInit_autoRun")call Vnx(function uhx,"s"+"__FolderBJUnit_StructHero_Allocation__allocInit_autoRun")
call Vnx(function uJx,"s"+"__BJUnit_objInits_autoRun")call Vnx(function ukx,"s"+"__UnitAttackSplash_Allocation__allocInit_autoRun")call Vnx(function uKx,"s"+"__FolderUnitClass_StructId_Allocation__allocInit_autoRun")call Vnx(function ulx,"s"+"__FolderUnitClass_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function uLx,"s"+"__FolderUnitClass_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function umx,"s"+"__FolderUnitClass_StructData_Allocation__allocInit_autoRun")call Vnx(function uMx,"s"+"__UnitClass_Allocation__allocInit_autoRun")call Vnx(function upx,"s"+"__FolderUnitTypePool_StructId_Allocation__allocInit_autoRun")
call Vnx(function uPx,"s"+"__FolderUnitTypePool_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vnx(function uqx,"s"+"__FolderUnitTypePool_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vnx(function uQx,"s"+"__FolderUnitTypePool_FolderData_StructReal_Allocation__allocInit_autoRun")call Vnx(function usx,"s"+"__FolderUnitTypePool_StructData_Allocation__allocInit_autoRun")call Vnx(function uSx,"s"+"__UnitTypePool_Allocation__allocInit_autoRun")call Vnx(function utx,"s"+"__FolderUnit_StructId_Allocation__allocInit_autoRun")
call Vnx(function uTx,"s"+"__FolderUnit_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vnx(function uux,"s"+"__FolderUnit_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vnx(function uUx,"s"+"__FolderUnit_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vnx(function uwx,"s"+"__FolderUnit_FolderData_FolderReal_StructTable_Allocation__allocInit_autoRun")call Vnx(function uWx,"s"+"__FolderUnit_FolderData_StructReal_Allocation__allocInit_autoRun")call Vnx(function uyx,"s"+"__FolderUnit_StructData_Allocation__allocInit_autoRun")call Vnx(function uYx,"s"+"__FolderUnit_FolderEvent_StructCombination_Allocation__allocInit_autoRun")call Vnx(function uzx,"s"+"__FolderUnit_FolderEvent_StructCounted_Allocation__allocInit_autoRun")call Vnx(function uZx,"s"+"__FolderUnit_FolderEvent_StructNative_Allocation__allocInit_autoRun")
call Vnx(function u_x,"s"+"__FolderUnit_StructEvent_Allocation__allocInit_autoRun")call Vnx(function u0x,"s"+"__FolderUnit_FolderAbilities_StructCooldown_Allocation__allocInit_autoRun")call Vnx(function u1x,"s"+"__FolderUnit_FolderAbilities_FolderEvents_StructBegin_Allocation__allocInit_autoRun")
call Vnx(function u7x,"s"+"__FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_objInits_autoRun")call Vnx(function u8x,"s"+"__FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_Allocation__allocInit_autoRun")call Vnx(function Uux,"s"+"__FolderUnit_FolderAbilities_FolderEvents_FolderEffect_StructChanneling_initializer_Buff_Init_autoRun")call Vnx(function UYx,"s"+"__FolderUnit_FolderAbilities_FolderEvents_StructEffect_objInits_autoRun")
call Vnx(function Uzx,"s"+"__FolderUnit_FolderAbilities_FolderEvents_StructEffect_Allocation__allocInit_autoRun")call Vnx(function UZx,"s"+"__FolderUnit_FolderAbilities_FolderEvents_StructFinish_Allocation__allocInit_autoRun")call Vnx(function U_x,"s"+"__FolderUnit_FolderAbilities_FolderEvents_StructLearn_Allocation__allocInit_autoRun")
call Vnx(function U0x,"s"+"__FolderUnit_FolderAbilities_FolderEvents_StructUnlearn_Allocation__allocInit_autoRun")call Vnx(function U1x,"s"+"__FolderUnit_FolderAbilities_StructEvents_Allocation__allocInit_autoRun")
call Vnx(function U2x,"s"+"__FolderUnit_FolderAbilities_StructAutoCast_Allocation__allocInit_autoRun")call Vnx(function U3x,"s"+"__FolderUnit_StructAbilities_Allocation__allocInit_autoRun")call Vnx(function U4x,"s"+"__FolderUnit_StructEffects_Allocation__allocInit_autoRun")call Vnx(function U5x,"s"+"__FolderUnit_StructSounds_Allocation__allocInit_autoRun")
call Vnx(function U6x,"s"+"__FolderUnit_StructAttachments_Allocation__allocInit_autoRun")call Vnx(function U7x,"s"+"__FolderUnit_FolderBuffs_FolderEvents_StructChangeLevel_Allocation__allocInit_autoRun")call Vnx(function U8x,"s"+"__FolderUnit_FolderBuffs_FolderEvents_StructGain_Allocation__allocInit_autoRun")call Vnx(function U9x,"s"+"__FolderUnit_FolderBuffs_FolderEvents_StructLose_Allocation__allocInit_autoRun")call Vnx(function wvx,"s"+"__FolderUnit_FolderBuffs_StructEvents_Allocation__allocInit_autoRun")
call Vnx(function wex,"s"+"__FolderUnit_FolderBuffs_FolderTimed_StructCountdown_Allocation__allocInit_autoRun")call Vnx(function wxx,"s"+"__FolderUnit_FolderBuffs_StructTimed_Allocation__allocInit_autoRun")call Vnx(function wox,"s"+"__FolderUnit_StructBuffs_Allocation__allocInit_autoRun")call Vnx(function wrx,"s"+"__FolderUnit_StructModSets_Allocation__allocInit_autoRun")call Vnx(function wix,"s"+"__FolderUnit_FolderItems_FolderEvents_StructGain_Allocation__allocInit_autoRun")call Vnx(function wax,"s"+"__FolderUnit_FolderItems_FolderEvents_StructLose_Allocation__allocInit_autoRun")call Vnx(function wnx,"s"+"__FolderUnit_FolderItems_FolderEvents_StructMoveInInventory_Allocation__allocInit_autoRun")call Vnx(function wVx,"s"+"__FolderUnit_FolderItems_FolderEvents_StructSell_Allocation__allocInit_autoRun")call Vnx(function wEx,"s"+"__FolderUnit_FolderItems_FolderEvents_StructUse_Allocation__allocInit_autoRun")call Vnx(function wXx,"s"+"__FolderUnit_FolderItems_StructEvents_Allocation__allocInit_autoRun")
call Vnx(function wOx,"s"+"__FolderUnit_StructItems_Allocation__allocInit_autoRun")call Vnx(function wRx,"s"+"__FolderUnit_StructClasses_Allocation__allocInit_autoRun")call Vnx(function wbx,"s"+"__FolderUnit_StructType_objInits_autoRun")call Vnx(function wBx,"s"+"__FolderUnit_StructType_Allocation__allocInit_autoRun")call Vnx(function wcx,"s"+"__FolderUnit_StructColor_Allocation__allocInit_autoRun")call Vnx(function wCx,"s"+"__FolderUnit_StructOwner_Allocation__allocInit_autoRun")call Vnx(function wdx,"s"+"__FolderUnit_FolderArmor_StructBase_Allocation__allocInit_autoRun")call Vnx(function wDx,"s"+"__FolderUnit_FolderArmor_FolderBonus_StructDisplayed_Allocation__allocInit_autoRun")call Vnx(function wfx,"s"+"__FolderUnit_FolderArmor_StructBonus_Allocation__allocInit_autoRun")call Vnx(function wFx,"s"+"__FolderUnit_FolderArmor_FolderIgnoreDamage_StructRelative_Allocation__allocInit_autoRun")call Vnx(function wgx,"s"+"__FolderUnit_FolderArmor_StructIgnoreDamage_Allocation__allocInit_autoRun")call Vnx(function wGx,"s"+"__FolderUnit_FolderArmor_FolderRelative_StructInvisible_Allocation__allocInit_autoRun")call Vnx(function whx,"s"+"__FolderUnit_FolderArmor_StructRelative_Allocation__allocInit_autoRun")call Vnx(function wHx,"s"+"__FolderUnit_FolderArmor_StructResistance_Allocation__allocInit_autoRun")
call Vnx(function wjx,"s"+"__FolderUnit_FolderArmor_StructSpell_Allocation__allocInit_autoRun")call Vnx(function wJx,"s"+"__FolderUnit_FolderArmor_StructTypeA_Allocation__allocInit_autoRun")call Vnx(function wkx,"s"+"__FolderUnit_StructArmor_Allocation__allocInit_autoRun")call Vnx(function wKx,"s"+"__FolderUnit_FolderAttack_FolderEvents_StructAcquire2_Allocation__allocInit_autoRun")
call Vnx(function wlx,"s"+"__FolderUnit_FolderAttack_FolderEvents_StructGround_objInits_autoRun")call Vnx(function wLx,"s"+"__FolderUnit_FolderAttack_FolderEvents_StructGround_Allocation__allocInit_autoRun")call Vnx(function wmx,"s"+"__FolderUnit_FolderAttack_StructEvents_Allocation__allocInit_autoRun")call Vnx(function wMx,"s"+"__FolderUnit_FolderAttack_FolderMissile_StructSpeed_Allocation__allocInit_autoRun")call Vnx(function wpx,"s"+"__FolderUnit_FolderAttack_StructMissile_Allocation__allocInit_autoRun")call Vnx(function wPx,"s"+"__FolderUnit_FolderAttack_StructRange_Allocation__allocInit_autoRun")
call Vnx(function wqx,"s"+"__FolderUnit_FolderAttack_FolderSpeed_StructBaseA_Allocation__allocInit_autoRun")
call Vnx(function wQx,"s"+"__FolderUnit_FolderAttack_FolderSpeed_FolderBonusA_StructDisplayedA_Allocation__allocInit_autoRun")call Vnx(function wsx,"s"+"__FolderUnit_FolderAttack_FolderSpeed_StructBonusA_Allocation__allocInit_autoRun")call Vnx(function wSx,"s"+"__FolderUnit_FolderAttack_StructSpeed_Allocation__allocInit_autoRun")
call Vnx(function wtx,"s"+"__FolderUnit_FolderAttack_FolderSplash_StructTargetFlag_Allocation__allocInit_autoRun")call Vnx(function wTx,"s"+"__FolderUnit_FolderAttack_StructSplash_Allocation__allocInit_autoRun")call Vnx(function wyx,"s"+"__FolderUnit_StructAttack_objInits_autoRun")call Vnx(function wYx,"s"+"__FolderUnit_StructAttack_Allocation__allocInit_autoRun")
call Vnx(function w0x,"s"+"__FolderUnit_StructAttack_initializer_Buff_Init_autoRun")
call Vnx(function w1x,"s"+"__FolderUnit_StructBlood_Allocation__allocInit_autoRun")call Vnx(function w2x,"s"+"__FolderUnit_StructBloodExplosion_Allocation__allocInit_autoRun")
call Vnx(function w3x,"s"+"__FolderUnit_StructCollisionSize_Allocation__allocInit_autoRun")call Vnx(function w4x,"s"+"__FolderUnit_FolderCriticalChanceDefense_StructBase_Allocation__allocInit_autoRun")call Vnx(function w5x,"s"+"__FolderUnit_FolderCriticalChanceDefense_StructBonus_Allocation__allocInit_autoRun")call Vnx(function w6x,"s"+"__FolderUnit_StructCriticalChanceDefense_Allocation__allocInit_autoRun")call Vnx(function w7x,"s"+"__FolderUnit_FolderCriticalChance_StructBase_Allocation__allocInit_autoRun")call Vnx(function w8x,"s"+"__FolderUnit_FolderCriticalChance_StructBonus_Allocation__allocInit_autoRun")
call Vnx(function w9x,"s"+"__FolderUnit_StructCriticalChance_Allocation__allocInit_autoRun")
call Vnx(function Wex,"s"+"__FolderUnit_FolderDeath_StructExplosion_objInits_autoRun")call Vnx(function Wxx,"s"+"__FolderUnit_FolderDeath_StructExplosion_Allocation__allocInit_autoRun")call Vnx(function Wax,"s"+"__FolderUnit_FolderDeath_StructExplosion_initializer_Buff_Init_autoRun")call Vnx(function Wnx,"s"+"__FolderUnit_FolderDeath_StructEvents_Allocation__allocInit_autoRun")
call Vnx(function WEx,"s"+"__FolderUnit_FolderDeath_StructProtection_objInits_autoRun")call Vnx(function WXx,"s"+"__FolderUnit_FolderDeath_StructProtection_Allocation__allocInit_autoRun")
call Vnx(function WAx,"s"+"__FolderUnit_FolderDeath_StructProtection_initializer_Buff_Init_autoRun")
call Vnx(function WNx,"s"+"__FolderUnit_StructDeath_Allocation__allocInit_autoRun")call Vnx(function Wbx,"s"+"__FolderUnit_FolderDecay_StructDuration_Allocation__allocInit_autoRun")call Vnx(function WBx,"s"+"__FolderUnit_FolderDecay_StructEvents_Allocation__allocInit_autoRun")
call Vnx(function Wcx,"s"+"__FolderUnit_FolderDecay_StructTimed_Allocation__allocInit_autoRun")call Vnx(function WCx,"s"+"__FolderUnit_StructDecay_Allocation__allocInit_autoRun")call Vnx(function WDx,"s"+"__FolderUnit_StructDisplay_objInits_autoRun")
call Vnx(function Wfx,"s"+"__FolderUnit_StructDisplay_Allocation__allocInit_autoRun")call Vnx(function WFx,"s"+"__FolderUnit_FolderDrop_StructExp_Allocation__allocInit_autoRun")
call Vnx(function Wgx,"s"+"__FolderUnit_FolderDrop_StructSupply_Allocation__allocInit_autoRun")call Vnx(function WGx,"s"+"__FolderUnit_StructDrop_Allocation__allocInit_autoRun")call Vnx(function Whx,"s"+"__FolderUnit_StructEvasion_Allocation__allocInit_autoRun")call Vnx(function WHx,"s"+"__FolderUnit_FolderEvasionChanceDefense_StructBase_Allocation__allocInit_autoRun")call Vnx(function Wjx,"s"+"__FolderUnit_FolderEvasionChanceDefense_StructBonus_Allocation__allocInit_autoRun")call Vnx(function WJx,"s"+"__FolderUnit_StructEvasionChanceDefense_Allocation__allocInit_autoRun")call Vnx(function Wkx,"s"+"__FolderUnit_FolderEvasionChance_StructBase_Allocation__allocInit_autoRun")call Vnx(function WKx,"s"+"__FolderUnit_FolderEvasionChance_StructBonus_Allocation__allocInit_autoRun")call Vnx(function Wlx,"s"+"__FolderUnit_StructEvasionChance_Allocation__allocInit_autoRun")call Vnx(function WLx,"s"+"__FolderUnit_FolderImpact_StructX_Allocation__allocInit_autoRun")
call Vnx(function Wmx,"s"+"__FolderUnit_FolderImpact_StructY_Allocation__allocInit_autoRun")
call Vnx(function WMx,"s"+"__FolderUnit_FolderImpact_StructZ_Allocation__allocInit_autoRun")
call Vnx(function Wpx,"s"+"__FolderUnit_StructImpact_Allocation__allocInit_autoRun")
call Vnx(function WPx,"s"+"__FolderUnit_StructExp_Allocation__allocInit_autoRun")call Vnx(function Wqx,"s"+"__FolderUnit_FolderOutpact_StructX_Allocation__allocInit_autoRun")call Vnx(function WQx,"s"+"__FolderUnit_FolderOutpact_StructY_Allocation__allocInit_autoRun")call Vnx(function Wsx,"s"+"__FolderUnit_FolderOutpact_StructZ_Allocation__allocInit_autoRun")call Vnx(function WSx,"s"+"__FolderUnit_StructOutpact_Allocation__allocInit_autoRun")call Vnx(function Wtx,"s"+"__FolderUnit_StructLifeLeech_objInits_autoRun")call Vnx(function WTx,"s"+"__FolderUnit_StructLifeLeech_Allocation__allocInit_autoRun")call Vnx(function Wux,"s"+"__FolderUnit_StructManaLeech_objInits_autoRun")call Vnx(function WUx,"s"+"__FolderUnit_StructManaLeech_Allocation__allocInit_autoRun")call Vnx(function Wzx,"s"+"__FolderUnit_StructInvulnerability_objInits_autoRun")
call Vnx(function WZx,"s"+"__FolderUnit_StructInvulnerability_Allocation__allocInit_autoRun")call Vnx(function W5x,"s"+"__FolderUnit_StructInvulnerability_initializer_Buff_Init_autoRun")call Vnx(function W6x,"s"+"__FolderUnit_FolderDamage_FolderBase_StructDisplayed_Allocation__allocInit_autoRun")call Vnx(function W7x,"s"+"__FolderUnit_FolderDamage_StructBase_Allocation__allocInit_autoRun")call Vnx(function W8x,"s"+"__FolderUnit_FolderDamage_FolderBonus_StructDisplayed_Allocation__allocInit_autoRun")
call Vnx(function W9x,"s"+"__FolderUnit_FolderDamage_StructBonus_Allocation__allocInit_autoRun")
call Vnx(function yvx,"s"+"__FolderUnit_FolderDamage_StructDelay_Allocation__allocInit_autoRun")
call Vnx(function yex,"s"+"__FolderUnit_FolderDamage_StructDices_Allocation__allocInit_autoRun")
call Vnx(function yxx,"s"+"__FolderUnit_FolderDamage_StructEvents_Allocation__allocInit_autoRun")call Vnx(function yox,"s"+"__FolderUnit_FolderDamage_FolderRelative_StructInvisible_Allocation__allocInit_autoRun")call Vnx(function yrx,"s"+"__FolderUnit_FolderDamage_StructRelative_Allocation__allocInit_autoRun")call Vnx(function yix,"s"+"__FolderUnit_FolderDamage_StructSides_Allocation__allocInit_autoRun")
call Vnx(function yax,"s"+"__FolderUnit_FolderDamage_StructSpellRelative_Allocation__allocInit_autoRun")
call Vnx(function ynx,"s"+"__FolderUnit_FolderDamage_StructTypeA_Allocation__allocInit_autoRun")
call Vnx(function yVx,"s"+"__FolderUnit_StructDamage_Allocation__allocInit_autoRun")
call Vnx(function yOx,"s"+"__FolderUnit_FolderMagicImmunity_StructSpellShield_objInits_autoRun")
call Vnx(function yRx,"s"+"__FolderUnit_FolderMagicImmunity_StructSpellShield_Allocation__allocInit_autoRun")call Vnx(function ybx,"s"+"__FolderUnit_FolderMagicImmunity_StructSpellShield_initializer_Buff_Init_autoRun")call Vnx(function yCx,"s"+"__FolderUnit_StructMagicImmunity_objInits_autoRun")call Vnx(function ydx,"s"+"__FolderUnit_StructMagicImmunity_Allocation__allocInit_autoRun")call Vnx(function ygx,"s"+"__FolderUnit_StructMagicImmunity_initializer_Buff_Init_autoRun")call Vnx(function yGx,"s"+"__FolderUnit_FolderScale_StructBonus_Allocation__allocInit_autoRun")call Vnx(function yhx,"s"+"__FolderUnit_FolderScale_StructTimed_Allocation__allocInit_autoRun")call Vnx(function rho,"s"+"__FolderUnit_StructScale_objInits_autoRun")call Vnx(function rHo,"s"+"__FolderUnit_StructScale_Allocation__allocInit_autoRun")call Vnx(function rmo,"s"+"__FolderUnit_StructScale_initializer_Buff_Init_autoRun")call Vnx(function rMo,"s"+"__FolderUnit_FolderVertexColor_StructRed_Allocation__allocInit_autoRun")call Vnx(function rpo,"s"+"__FolderUnit_FolderVertexColor_StructGreen_Allocation__allocInit_autoRun")call Vnx(function rPo,"s"+"__FolderUnit_FolderVertexColor_StructBlue_Allocation__allocInit_autoRun")
call Vnx(function rqo,"s"+"__FolderUnit_FolderVertexColor_StructAlpha_Allocation__allocInit_autoRun")call Vnx(function rQo,"s"+"__FolderUnit_FolderVertexColor_StructTimed_Allocation__allocInit_autoRun")call Vnx(function rso,"s"+"__FolderUnit_StructVertexColor_Allocation__allocInit_autoRun")call Vnx(function r_o,"s"+"__FolderUnit_StructCold_objInits_autoRun")call Vnx(function r0o,"s"+"__FolderUnit_StructCold_Allocation__allocInit_autoRun")call Vnx(function r4o,"s"+"__FolderUnit_StructCold_initializer_Buff_Init_autoRun")call Vnx(function r7o,"s"+"__FolderUnit_StructFrost_objInits_autoRun")call Vnx(function r8o,"s"+"__FolderUnit_StructFrost_Allocation__allocInit_autoRun")call Vnx(function ixo,"s"+"__FolderUnit_StructFrost_initializer_Buff_Init_autoRun")call Vnx(function iro,"s"+"__FolderUnit_FolderInvisibility_StructReveal_objInits_autoRun")call Vnx(function iio,"s"+"__FolderUnit_FolderInvisibility_StructReveal_Allocation__allocInit_autoRun")call Vnx(function iEo,"s"+"__FolderUnit_FolderInvisibility_StructReveal_initializer_Buff_Init_autoRun")call Vnx(function iAo,"s"+"__FolderUnit_StructInvisibility_objInits_autoRun")call Vnx(function iNo,"s"+"__FolderUnit_StructInvisibility_Allocation__allocInit_autoRun")call Vnx(function igo,"s"+"__FolderUnit_StructInvisibility_initializer_Buff_Init_autoRun")call Vnx(function iHo,"s"+"__FolderUnit_StructGhost_objInits_autoRun")call Vnx(function ijo,"s"+"__FolderUnit_StructGhost_Allocation__allocInit_autoRun")call Vnx(function ilo,"s"+"__FolderUnit_StructGhost_initializer_Buff_Init_autoRun")call Vnx(function iLo,"s"+"__FolderUnit_StructHealAbility_Allocation__allocInit_autoRun")call Vnx(function imo,"s"+"__FolderUnit_FolderMaxLife_StructBase_Allocation__allocInit_autoRun")
call Vnx(function iMo,"s"+"__FolderUnit_FolderMaxLife_StructBonus_Allocation__allocInit_autoRun")call Vnx(function ipo,"s"+"__FolderUnit_FolderMaxLife_StructRelative_Allocation__allocInit_autoRun")
call Vnx(function iQo,"s"+"__FolderUnit_StructMaxLife_objInits_autoRun")
call Vnx(function iso,"s"+"__FolderUnit_StructMaxLife_Allocation__allocInit_autoRun")call Vnx(function iSo,"s"+"__FolderUnit_StructLife_Allocation__allocInit_autoRun")call Vnx(function ito,"s"+"__FolderUnit_FolderLifeRegeneration_StructBase_Allocation__allocInit_autoRun")call Vnx(function iTo,"s"+"__FolderUnit_FolderLifeRegeneration_StructBonus_Allocation__allocInit_autoRun")call Vnx(function iUo,"s"+"__FolderUnit_FolderLifeRegeneration_StructDisablement_objInits_autoRun")call Vnx(function iwo,"s"+"__FolderUnit_FolderLifeRegeneration_StructDisablement_Allocation__allocInit_autoRun")
call Vnx(function izo,"s"+"__FolderUnit_FolderLifeRegeneration_StructDisablement_initializer_Buff_Init_autoRun")
call Vnx(function iZo,"s"+"__FolderUnit_FolderLifeRegeneration_StructRelative_Allocation__allocInit_autoRun")call Vnx(function i_o,"s"+"__FolderUnit_StructLifeRegeneration_Allocation__allocInit_autoRun")call Vnx(function i0o,"s"+"__FolderUnit_FolderMaxMana_StructBase_Allocation__allocInit_autoRun")
call Vnx(function i1o,"s"+"__FolderUnit_FolderMaxMana_StructBonus_Allocation__allocInit_autoRun")call Vnx(function i2o,"s"+"__FolderUnit_FolderMaxMana_StructRelative_Allocation__allocInit_autoRun")
call Vnx(function i5o,"s"+"__FolderUnit_StructMaxMana_objInits_autoRun")
call Vnx(function i6o,"s"+"__FolderUnit_StructMaxMana_Allocation__allocInit_autoRun")call Vnx(function i7o,"s"+"__FolderUnit_StructMana_Allocation__allocInit_autoRun")call Vnx(function i8o,"s"+"__FolderUnit_FolderManaRegeneration_StructBase_Allocation__allocInit_autoRun")call Vnx(function i9o,"s"+"__FolderUnit_FolderManaRegeneration_StructBonus_Allocation__allocInit_autoRun")call Vnx(function aeo,"s"+"__FolderUnit_FolderManaRegeneration_StructDisablement_objInits_autoRun")call Vnx(function axo,"s"+"__FolderUnit_FolderManaRegeneration_StructDisablement_Allocation__allocInit_autoRun")
call Vnx(function aao,"s"+"__FolderUnit_FolderManaRegeneration_StructDisablement_initializer_Buff_Init_autoRun")
call Vnx(function ano,"s"+"__FolderUnit_FolderManaRegeneration_StructRelative_Allocation__allocInit_autoRun")call Vnx(function aVo,"s"+"__FolderUnit_StructManaRegeneration_Allocation__allocInit_autoRun")call Vnx(function aEo,"s"+"__FolderUnit_FolderMovement_FolderEvents_StructEnterRegion_Allocation__allocInit_autoRun")call Vnx(function aXo,"s"+"__FolderUnit_FolderMovement_FolderEvents_StructInterval_Allocation__allocInit_autoRun")call Vnx(function aOo,"s"+"__FolderUnit_FolderMovement_FolderEvents_StructLeaveRegion_Allocation__allocInit_autoRun")call Vnx(function aRo,"s"+"__FolderUnit_FolderMovement_StructEvents_Allocation__allocInit_autoRun")call Vnx(function aIo,"s"+"__FolderUnit_FolderMovement_FolderSpeed_StructBaseA_Allocation__allocInit_autoRun")call Vnx(function abo,"s"+"__FolderUnit_FolderMovement_FolderSpeed_StructBonusA_objInits_autoRun")call Vnx(function aBo,"s"+"__FolderUnit_FolderMovement_FolderSpeed_StructBonusA_Allocation__allocInit_autoRun")call Vnx(function aco,"s"+"__FolderUnit_FolderMovement_FolderSpeed_StructRelativeA_Allocation__allocInit_autoRun")call Vnx(function aCo,"s"+"__FolderUnit_FolderMovement_StructSpeed_Allocation__allocInit_autoRun")call Vnx(function aDo,"s"+"__FolderUnit_StructMovement_objInits_autoRun")call Vnx(function afo,"s"+"__FolderUnit_StructMovement_Allocation__allocInit_autoRun")call Vnx(function aho,"s"+"__FolderUnit_StructMovement_initializer_Buff_Init_autoRun")call Vnx(function aHo,"s"+"__FolderUnit_FolderOrder_FolderEvents_StructLose_Allocation__allocInit_autoRun")call Vnx(function ajo,"s"+"__FolderUnit_FolderOrder_FolderEvents_FolderGain_StructImmediate_Allocation__allocInit_autoRun")call Vnx(function aJo,"s"+"__FolderUnit_FolderOrder_FolderEvents_FolderGain_StructPoint_Allocation__allocInit_autoRun")call Vnx(function ako,"s"+"__FolderUnit_FolderOrder_FolderEvents_FolderGain_StructTarget_Allocation__allocInit_autoRun")
call Vnx(function aKo,"s"+"__FolderUnit_FolderOrder_FolderEvents_StructGain_Allocation__allocInit_autoRun")call Vnx(function alo,"s"+"__FolderUnit_FolderOrder_FolderEvents_StructIdle_Allocation__allocInit_autoRun")call Vnx(function aLo,"s"+"__FolderUnit_FolderOrder_StructEvents_Allocation__allocInit_autoRun")
call Vnx(function amo,"s"+"__FolderUnit_StructOrder_Allocation__allocInit_autoRun")call Vnx(function aQo,"s"+"__FolderUnit_StructBanish_objInits_autoRun")call Vnx(function aso,"s"+"__FolderUnit_StructBanish_Allocation__allocInit_autoRun")
call Vnx(function auo,"s"+"__FolderUnit_StructBanish_initializer_Buff_Init_autoRun")
call Vnx(function aWo,"s"+"__FolderUnit_StructMadness_objInits_autoRun")
call Vnx(function ayo,"s"+"__FolderUnit_StructMadness_Allocation__allocInit_autoRun")call Vnx(function a0o,"s"+"__FolderUnit_StructMadness_initializer_Buff_Init_autoRun")call Vnx(function a3o,"s"+"__FolderUnit_StructEclipse_objInits_autoRun")
call Vnx(function a4o,"s"+"__FolderUnit_StructEclipse_Allocation__allocInit_autoRun")call Vnx(function a8o,"s"+"__FolderUnit_StructEclipse_initializer_Buff_Init_autoRun")call Vnx(function nro,"s"+"__FolderUnit_StructWhirl_objInits_autoRun")call Vnx(function nio,"s"+"__FolderUnit_StructWhirl_Allocation__allocInit_autoRun")call Vnx(function nEo,"s"+"__FolderUnit_StructWhirl_initializer_Buff_Init_autoRun")call Vnx(function nXo,"s"+"__FolderUnit_StructFacing_Allocation__allocInit_autoRun")
call Vnx(function nIo,"s"+"__FolderUnit_StructBleeding_objInits_autoRun")call Vnx(function nAo,"s"+"__FolderUnit_StructBleeding_Allocation__allocInit_autoRun")call Vnx(function nQo,"s"+"__FolderUnit_StructBleeding_initializer_Buff_Init_autoRun")call Vnx(function nto,"s"+"__FolderUnit_StructIgnited_objInits_autoRun")
call Vnx(function nTo,"s"+"__FolderUnit_StructIgnited_Allocation__allocInit_autoRun")call Vnx(function nyo,"s"+"__FolderUnit_StructIgnited_initializer_Buff_Init_autoRun")call Vnx(function nYo,"s"+"__FolderUnit_StructKnockup_Allocation__allocInit_autoRun")call Vnx(function nZo,"s"+"__FolderUnit_StructKnockup_initializer_Buff_Init_autoRun")call Vnx(function n0o,"s"+"__FolderUnit_StructPathing_objInits_autoRun")
call Vnx(function n1o,"s"+"__FolderUnit_StructPathing_Allocation__allocInit_autoRun")call Vnx(function n5o,"s"+"__FolderUnit_StructPathing_initializer_Buff_Init_autoRun")call Vnx(function n8o,"s"+"__FolderUnit_StructPoisoned_objInits_autoRun")call Vnx(function n9o,"s"+"__FolderUnit_StructPoisoned_Allocation__allocInit_autoRun")call Vnx(function Voo,"s"+"__FolderUnit_StructPoisoned_initializer_Buff_Init_autoRun")call Vnx(function Vro,"s"+"__FolderUnit_FolderRevival_StructAble_Allocation__allocInit_autoRun")
call Vnx(function Vio,"s"+"__FolderUnit_FolderRevival_StructEvents_Allocation__allocInit_autoRun")call Vnx(function Vno,"s"+"__FolderUnit_StructRevival_objInits_autoRun")
call Vnx(function VVo,"s"+"__FolderUnit_StructRevival_Allocation__allocInit_autoRun")call Vnx(function VIo,"s"+"__FolderUnit_StructSilence_objInits_autoRun")
call Vnx(function VAo,"s"+"__FolderUnit_StructSilence_Allocation__allocInit_autoRun")call Vnx(function Vco,"s"+"__FolderUnit_StructSilence_initializer_Buff_Init_autoRun")call Vnx(function Vfo,"s"+"__FolderUnit_StructSleep_objInits_autoRun")call Vnx(function VFo,"s"+"__FolderUnit_StructSleep_Allocation__allocInit_autoRun")call Vnx(function Vko,"s"+"__FolderUnit_StructSleep_initializer_Buff_Init_autoRun")call Vnx(function VKo,"s"+"__FolderUnit_FolderStun_StructCancel_Allocation__allocInit_autoRun")call Vnx(function VMo,"s"+"__FolderUnit_StructStun_objInits_autoRun")call Vnx(function Vpo,"s"+"__FolderUnit_StructStun_Allocation__allocInit_autoRun")call Vnx(function Vso,"s"+"__FolderUnit_StructStun_initializer_Buff_Init_autoRun")call Vnx(function VSo,"s"+"__FolderUnit_FolderAnimation_StructLoop_Allocation__allocInit_autoRun")call Vnx(function Vto,"s"+"__FolderUnit_FolderAnimation_StructSpeed_Allocation__allocInit_autoRun")call Vnx(function VTo,"s"+"__FolderUnit_StructAnimation_Allocation__allocInit_autoRun")call Vnx(function Vuo,"s"+"__FolderUnit_StructSkillPoints_Allocation__allocInit_autoRun")call Vnx(function VUo,"s"+"__FolderUnit_FolderSpellPower_StructBase_Allocation__allocInit_autoRun")call Vnx(function Vwo,"s"+"__FolderUnit_FolderSpellPower_StructBonus_Allocation__allocInit_autoRun")
call Vnx(function VWo,"s"+"__FolderUnit_FolderSpellPower_StructRelative_Allocation__allocInit_autoRun")call Vnx(function Vyo,"s"+"__FolderUnit_StructSpellPower_Allocation__allocInit_autoRun")
call Vnx(function VYo,"s"+"__FolderUnit_FolderSpellVamp_StructBase_Allocation__allocInit_autoRun")call Vnx(function Vzo,"s"+"__FolderUnit_FolderSpellVamp_StructBonus_Allocation__allocInit_autoRun")call Vnx(function VZo,"s"+"__FolderUnit_FolderSpellVamp_StructRelative_Allocation__allocInit_autoRun")call Vnx(function V_o,"s"+"__FolderUnit_StructSpellVamp_Allocation__allocInit_autoRun")call Vnx(function V0o,"s"+"__FolderUnit_FolderMaxRage_StructBase_Allocation__allocInit_autoRun")
call Vnx(function V1o,"s"+"__FolderUnit_FolderMaxRage_StructBonus_Allocation__allocInit_autoRun")call Vnx(function V2o,"s"+"__FolderUnit_FolderMaxRage_StructRelative_Allocation__allocInit_autoRun")
call Vnx(function V3o,"s"+"__FolderUnit_StructMaxRage_Allocation__allocInit_autoRun")call Vnx(function V4o,"s"+"__FolderUnit_StructRage_Allocation__allocInit_autoRun")call Vnx(function V5o,"s"+"__FolderUnit_FolderRageRegeneration_StructBase_Allocation__allocInit_autoRun")call Vnx(function V6o,"s"+"__FolderUnit_FolderRageRegeneration_StructBonus_Allocation__allocInit_autoRun")call Vnx(function V7o,"s"+"__FolderUnit_FolderRageRegeneration_StructRelative_Allocation__allocInit_autoRun")call Vnx(function V8o,"s"+"__FolderUnit_StructRageRegeneration_Allocation__allocInit_autoRun")call Vnx(function V9o,"s"+"__FolderUnit_FolderMaxStamina_StructBase_Allocation__allocInit_autoRun")call Vnx(function Evo,"s"+"__FolderUnit_FolderMaxStamina_StructBonus_Allocation__allocInit_autoRun")
call Vnx(function Eeo,"s"+"__FolderUnit_FolderMaxStamina_StructRelative_Allocation__allocInit_autoRun")call Vnx(function Exo,"s"+"__FolderUnit_StructMaxStamina_Allocation__allocInit_autoRun")
call Vnx(function Ero,"s"+"__FolderUnit_FolderStamina_StructExhaustion_objInits_autoRun")call Vnx(function Eio,"s"+"__FolderUnit_FolderStamina_StructExhaustion_Allocation__allocInit_autoRun")call Vnx(function Eno,"s"+"__FolderUnit_FolderStamina_StructExhaustion_initializer_Buff_Init_autoRun")call Vnx(function EVo,"s"+"__FolderUnit_StructStamina_Allocation__allocInit_autoRun")call Vnx(function EEo,"s"+"__FolderUnit_FolderStaminaRegeneration_StructBase_Allocation__allocInit_autoRun")
call Vnx(function EXo,"s"+"__FolderUnit_FolderStaminaRegeneration_StructBonus_Allocation__allocInit_autoRun")call Vnx(function EOo,"s"+"__FolderUnit_FolderStaminaRegeneration_StructRelative_Allocation__allocInit_autoRun")
call Vnx(function ERo,"s"+"__FolderUnit_StructStaminaRegeneration_Allocation__allocInit_autoRun")call Vnx(function EIo,"s"+"__FolderUnit_FolderBars_StructExpiringCondition_Allocation__allocInit_autoRun")call Vnx(function EAo,"s"+"__FolderUnit_StructBars_objInits_autoRun")call Vnx(function ENo,"s"+"__FolderUnit_StructBars_Allocation__allocInit_autoRun")call Vnx(function EBo,"s"+"__FolderUnit_StructTimedLife_objInits_autoRun")call Vnx(function Eco,"s"+"__FolderUnit_StructTimedLife_Allocation__allocInit_autoRun")call Vnx(function EFo,"s"+"__FolderUnit_StructTimedLife_initializer_Buff_Init_autoRun")call Vnx(function EHo,"s"+"__FolderUnit_StructTransport_objInits_autoRun")call Vnx(function Ejo,"s"+"__FolderUnit_StructTransport_Allocation__allocInit_autoRun")call Vnx(function ESo,"s"+"__FolderUnit_StructTransport_initializer_Buff_Init_autoRun")call Vnx(function Eto,"s"+"__FolderUnit_StructHero_Allocation__allocInit_autoRun")call Vnx(function ETo,"s"+"__FolderUnit_FolderPosition_FolderTimed_StructAccelerated_Allocation__allocInit_autoRun")
call Vnx(function Euo,"s"+"__FolderUnit_FolderPosition_StructTimed_Allocation__allocInit_autoRun")call Vnx(function EUo,"s"+"__FolderUnit_FolderPosition_StructX_Allocation__allocInit_autoRun")call Vnx(function Ewo,"s"+"__FolderUnit_FolderPosition_StructY_Allocation__allocInit_autoRun")call Vnx(function EWo,"s"+"__FolderUnit_FolderPosition_StructZ_Allocation__allocInit_autoRun")call Vnx(function EYo,"s"+"__FolderUnit_StructPosition_objInits_autoRun")call Vnx(function Ezo,"s"+"__FolderUnit_StructPosition_Allocation__allocInit_autoRun")call Vnx(function E_o,"s"+"__FolderUnit_FolderSelection_StructCircle_objInits_autoRun")call Vnx(function E0o,"s"+"__FolderUnit_FolderSelection_StructCircle_Allocation__allocInit_autoRun")
call Vnx(function E2o,"s"+"__FolderUnit_StructSelection_objInits_autoRun")call Vnx(function E3o,"s"+"__FolderUnit_StructSelection_Allocation__allocInit_autoRun")call Vnx(function E4o,"s"+"__FolderUnit_FolderSightRange_StructBase_Allocation__allocInit_autoRun")call Vnx(function E5o,"s"+"__FolderUnit_FolderSightRange_StructBonus_Allocation__allocInit_autoRun")
call Vnx(function E6o,"s"+"__FolderUnit_FolderSightRange_StructRelative_Allocation__allocInit_autoRun")call Vnx(function E9o,"s"+"__FolderUnit_StructSightRange_objInits_autoRun")call Vnx(function Xvo,"s"+"__FolderUnit_StructSightRange_Allocation__allocInit_autoRun")
call Vnx(function Xeo,"s"+"__FolderUnit_FolderLevel_StructEvents_Allocation__allocInit_autoRun")
call Vnx(function Xxo,"s"+"__FolderUnit_StructLevel_objInits_autoRun")call Vnx(function Xoo,"s"+"__FolderUnit_StructLevel_Allocation__allocInit_autoRun")call Vnx(function Xro,"s"+"__FolderUnit_FolderAgility_StructBase_Allocation__allocInit_autoRun")
call Vnx(function Xio,"s"+"__FolderUnit_FolderAgility_FolderBonus_StructDisplayed_Allocation__allocInit_autoRun")call Vnx(function Xao,"s"+"__FolderUnit_FolderAgility_StructBonus_Allocation__allocInit_autoRun")call Vnx(function Xno,"s"+"__FolderUnit_FolderAgility_StructRelative_Allocation__allocInit_autoRun")
call Vnx(function XVo,"s"+"__FolderUnit_StructAgility_objInits_autoRun")
call Vnx(function XEo,"s"+"__FolderUnit_StructAgility_Allocation__allocInit_autoRun")call Vnx(function XXo,"s"+"__FolderUnit_FolderIntelligence_StructBase_Allocation__allocInit_autoRun")call Vnx(function XOo,"s"+"__FolderUnit_FolderIntelligence_FolderBonus_StructDisplayed_Allocation__allocInit_autoRun")call Vnx(function XRo,"s"+"__FolderUnit_FolderIntelligence_StructBonus_Allocation__allocInit_autoRun")call Vnx(function XIo,"s"+"__FolderUnit_FolderIntelligence_StructRelative_Allocation__allocInit_autoRun")call Vnx(function XAo,"s"+"__FolderUnit_StructIntelligence_objInits_autoRun")call Vnx(function XNo,"s"+"__FolderUnit_StructIntelligence_Allocation__allocInit_autoRun")call Vnx(function Xbo,"s"+"__FolderUnit_FolderStrength_StructBase_Allocation__allocInit_autoRun")call Vnx(function XBo,"s"+"__FolderUnit_FolderStrength_FolderBonus_StructDisplayed_Allocation__allocInit_autoRun")call Vnx(function Xco,"s"+"__FolderUnit_FolderStrength_StructBonus_Allocation__allocInit_autoRun")call Vnx(function XCo,"s"+"__FolderUnit_FolderStrength_StructRelative_Allocation__allocInit_autoRun")call Vnx(function Xdo,"s"+"__FolderUnit_StructStrength_objInits_autoRun")call Vnx(function XDo,"s"+"__FolderUnit_StructStrength_Allocation__allocInit_autoRun")call Vnx(function Xfo,"s"+"__FolderUnit_StructRefs_Allocation__allocInit_autoRun")call Vnx(function XHo,"s"+"__Unit_objInits_autoRun")
call Vnx(function Xjo,"s"+"__Unit_Allocation__allocInit_autoRun")call Vnx(function Xpo,"s"+"__Unit_initializer_InitPreplaced_autoRun")call Vnx(function gzo,"s"+"__Unit_initializer_Init_autoRun")
call Vnx(function gZo,"s"+"__UnitState_Allocation__allocInit_autoRun")call Vnx(function g_o,"s"+"__UnitMod_Allocation__allocInit_autoRun")
call Vnx(function g0o,"s"+"__FolderUnitModSet_StructId_Allocation__allocInit_autoRun")call Vnx(function g1o,"s"+"__FolderUnitModSet_FolderData_StructBoolean_Allocation__allocInit_autoRun")call Vnx(function g2o,"s"+"__FolderUnitModSet_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function g3o,"s"+"__FolderUnitModSet_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function g4o,"s"+"__FolderUnitModSet_FolderData_FolderReal_StructTable_Allocation__allocInit_autoRun")call Vnx(function g5o,"s"+"__FolderUnitModSet_FolderData_StructReal_Allocation__allocInit_autoRun")call Vnx(function g6o,"s"+"__FolderUnitModSet_FolderData_FolderString_StructTable_Allocation__allocInit_autoRun")call Vnx(function g7o,"s"+"__FolderUnitModSet_FolderData_StructString_Allocation__allocInit_autoRun")call Vnx(function g8o,"s"+"__FolderUnitModSet_StructData_Allocation__allocInit_autoRun")
call Vnx(function g9o,"s"+"__FolderUnitModSet_StructBoolMods_Allocation__allocInit_autoRun")
call Vnx(function Gvo,"s"+"__FolderUnitModSet_StructRealMods_Allocation__allocInit_autoRun")
call Vnx(function Geo,"s"+"__FolderUnitModSet_StructCustomMods_Allocation__allocInit_autoRun")call Vnx(function Gxo,"s"+"__FolderUnitModSet_StructMods_Allocation__allocInit_autoRun")
call Vnx(function Goo,"s"+"__UnitModSet_Allocation__allocInit_autoRun")call Vnx(function Gro,"s"+"__BuffRef_Allocation__allocInit_autoRun")
call Vnx(function Gio,"s"+"__FolderUnitType_StructId_Allocation__allocInit_autoRun")
call Vnx(function Gao,"s"+"__FolderUnitType_FolderData_FolderBoolean_StructTable_Allocation__allocInit_autoRun")
call Vnx(function Gno,"s"+"__FolderUnitType_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vnx(function GVo,"s"+"__FolderUnitType_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vnx(function GEo,"s"+"__FolderUnitType_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vnx(function GXo,"s"+"__FolderUnitType_FolderData_FolderReal_StructTable_Allocation__allocInit_autoRun")call Vnx(function GOo,"s"+"__FolderUnitType_FolderData_StructReal_Allocation__allocInit_autoRun")call Vnx(function GRo,"s"+"__FolderUnitType_FolderData_FolderString_StructTable_Allocation__allocInit_autoRun")call Vnx(function GIo,"s"+"__FolderUnitType_FolderData_StructString_Allocation__allocInit_autoRun")call Vnx(function GAo,"s"+"__FolderUnitType_StructData_Allocation__allocInit_autoRun")call Vnx(function GNo,"s"+"__FolderUnitType_StructEvent_Allocation__allocInit_autoRun")call Vnx(function Gbo,"s"+"__FolderUnitType_FolderAbilities_StructArrayBuild_Allocation__allocInit_autoRun")
call Vnx(function GBo,"s"+"__FolderUnitType_FolderAbilities_StructHero_Allocation__allocInit_autoRun")call Vnx(function Gco,"s"+"__FolderUnitType_StructAbilities_Allocation__allocInit_autoRun")call Vnx(function GCo,"s"+"__FolderUnitType_FolderArmor_StructType_Allocation__allocInit_autoRun")call Vnx(function Gdo,"s"+"__FolderUnitType_StructArmor_Allocation__allocInit_autoRun")call Vnx(function GDo,"s"+"__FolderUnitType_StructAttachments_Allocation__allocInit_autoRun")call Vnx(function Gfo,"s"+"__FolderUnitType_FolderAttack_FolderMissile_StructSpeed_Allocation__allocInit_autoRun")call Vnx(function GFo,"s"+"__FolderUnitType_FolderAttack_StructMissile_Allocation__allocInit_autoRun")call Vnx(function Ggo,"s"+"__FolderUnitType_FolderAttack_StructRange_Allocation__allocInit_autoRun")
call Vnx(function GGo,"s"+"__FolderUnitType_FolderAttack_StructSpeed_Allocation__allocInit_autoRun")
call Vnx(function Gho,"s"+"__FolderUnitType_FolderAttack_FolderSplash_StructTargetFlag_Allocation__allocInit_autoRun")call Vnx(function GHo,"s"+"__FolderUnitType_FolderAttack_StructSplash_Allocation__allocInit_autoRun")call Vnx(function Gjo,"s"+"__FolderUnitType_StructAttack_Allocation__allocInit_autoRun")
call Vnx(function GJo,"s"+"__FolderUnitType_StructBlood_Allocation__allocInit_autoRun")call Vnx(function Gko,"s"+"__FolderUnitType_StructBloodExplosion_Allocation__allocInit_autoRun")
call Vnx(function GKo,"s"+"__FolderUnitType_StructClasses_Allocation__allocInit_autoRun")call Vnx(function Glo,"s"+"__FolderUnitType_StructCollisionSize_Allocation__allocInit_autoRun")call Vnx(function GLo,"s"+"__FolderUnitType_FolderDamage_StructDelay_Allocation__allocInit_autoRun")
call Vnx(function Gmo,"s"+"__FolderUnitType_FolderDamage_StructDices_Allocation__allocInit_autoRun")
call Vnx(function GMo,"s"+"__FolderUnitType_FolderDamage_StructSides_Allocation__allocInit_autoRun")
call Vnx(function Gpo,"s"+"__FolderUnitType_FolderDamage_StructType_Allocation__allocInit_autoRun")call Vnx(function GPo,"s"+"__FolderUnitType_StructDamage_Allocation__allocInit_autoRun")
call Vnx(function Gqo,"s"+"__FolderUnitType_FolderDecay_StructDuration_Allocation__allocInit_autoRun")call Vnx(function GQo,"s"+"__FolderUnitType_StructDecay_Allocation__allocInit_autoRun")call Vnx(function Gso,"s"+"__FolderUnitType_FolderDrop_StructExp_Allocation__allocInit_autoRun")
call Vnx(function GSo,"s"+"__FolderUnitType_FolderDrop_StructSupply_Allocation__allocInit_autoRun")call Vnx(function Gto,"s"+"__FolderUnitType_StructDrop_Allocation__allocInit_autoRun")call Vnx(function GTo,"s"+"__FolderUnitType_FolderImpact_StructZ_Allocation__allocInit_autoRun")
call Vnx(function Guo,"s"+"__FolderUnitType_StructImpact_Allocation__allocInit_autoRun")
call Vnx(function GUo,"s"+"__FolderUnitType_FolderOutpact_StructZ_Allocation__allocInit_autoRun")call Vnx(function Gwo,"s"+"__FolderUnitType_StructOutpact_Allocation__allocInit_autoRun")call Vnx(function GWo,"s"+"__FolderUnitType_StructLife_Allocation__allocInit_autoRun")call Vnx(function Gyo,"s"+"__FolderUnitType_StructLifeRegeneration_Allocation__allocInit_autoRun")call Vnx(function GYo,"s"+"__FolderUnitType_StructMana_Allocation__allocInit_autoRun")call Vnx(function Gzo,"s"+"__FolderUnitType_StructManaRegeneration_Allocation__allocInit_autoRun")call Vnx(function GZo,"s"+"__FolderUnitType_StructPreload_Allocation__allocInit_autoRun")call Vnx(function G_o,"s"+"__FolderUnitType_StructRevivalable_Allocation__allocInit_autoRun")call Vnx(function G0o,"s"+"__FolderUnitType_StructScale_Allocation__allocInit_autoRun")call Vnx(function G1o,"s"+"__FolderUnitType_StructSightRange_Allocation__allocInit_autoRun")
call Vnx(function G2o,"s"+"__FolderUnitType_StructSpeed_Allocation__allocInit_autoRun")call Vnx(function G3o,"s"+"__FolderUnitType_StructSpellPower_Allocation__allocInit_autoRun")
call Vnx(function G4o,"s"+"__FolderUnitType_StructSpellVamp_Allocation__allocInit_autoRun")call Vnx(function G5o,"s"+"__FolderUnitType_FolderVertexColor_StructRed_Allocation__allocInit_autoRun")call Vnx(function G6o,"s"+"__FolderUnitType_FolderVertexColor_StructGreen_Allocation__allocInit_autoRun")call Vnx(function G7o,"s"+"__FolderUnitType_FolderVertexColor_StructBlue_Allocation__allocInit_autoRun")
call Vnx(function G8o,"s"+"__FolderUnitType_FolderVertexColor_StructAlpha_Allocation__allocInit_autoRun")call Vnx(function G9o,"s"+"__FolderUnitType_StructVertexColor_Allocation__allocInit_autoRun")call Vnx(function hvo,"s"+"__FolderUnitType_FolderHero_StructPrimaryAttribute_Allocation__allocInit_autoRun")call Vnx(function heo,"s"+"__FolderUnitType_FolderHero_FolderAgility_StructPerLevel_Allocation__allocInit_autoRun")call Vnx(function hxo,"s"+"__FolderUnitType_FolderHero_StructAgility_Allocation__allocInit_autoRun")
call Vnx(function hoo,"s"+"__FolderUnitType_FolderHero_StructArmorPerLevel_Allocation__allocInit_autoRun")call Vnx(function hro,"s"+"__FolderUnitType_FolderHero_FolderIntelligence_StructPerLevel_Allocation__allocInit_autoRun")
call Vnx(function hio,"s"+"__FolderUnitType_FolderHero_StructIntelligence_Allocation__allocInit_autoRun")call Vnx(function hao,"s"+"__FolderUnitType_FolderHero_FolderStrength_StructPerLevel_Allocation__allocInit_autoRun")
call Vnx(function hno,"s"+"__FolderUnitType_FolderHero_StructStrength_Allocation__allocInit_autoRun")call Vnx(function hVo,"s"+"__FolderUnitType_StructHero_Allocation__allocInit_autoRun")call Vnx(function Hso,"s"+"__UnitType_objInits_autoRun")
call Vnx(function HSo,"s"+"__UnitType_Allocation__allocInit_autoRun")call Vnx(function Hto,"s"+"__Force_Allocation__allocInit_autoRun")call Vnx(function HTo,"s"+"__PlayerController_Allocation__allocInit_autoRun")call Vnx(function Huo,"s"+"__PlayerSlotState_Allocation__allocInit_autoRun")
call Vnx(function HUo,"s"+"__Team_Allocation__allocInit_autoRun")call Vnx(function Hwo,"s"+"__FolderUser_StructId_Allocation__allocInit_autoRun")
call Vnx(function HWo,"s"+"__FolderUser_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vnx(function Hyo,"s"+"__FolderUser_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vnx(function HYo,"s"+"__FolderUser_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vnx(function Hzo,"s"+"__FolderUser_StructData_Allocation__allocInit_autoRun")call Vnx(function HZo,"s"+"__FolderUser_FolderEvent_StructNative_Allocation__allocInit_autoRun")
call Vnx(function H_o,"s"+"__FolderUser_StructEvent_Allocation__allocInit_autoRun")call Vnx(function H0o,"s"+"__FolderUser_StructController_Allocation__allocInit_autoRun")
call Vnx(function H1o,"s"+"__FolderUser_StructHostAppointment_Allocation__allocInit_autoRun")call Vnx(function H2o,"s"+"__FolderUser_StructHero_Allocation__allocInit_autoRun")call Vnx(function H3o,"s"+"__FolderUser_FolderKeyEvent_StructDownArrow_Allocation__allocInit_autoRun")call Vnx(function H4o,"s"+"__FolderUser_FolderKeyEvent_StructLeftArrow_Allocation__allocInit_autoRun")call Vnx(function H5o,"s"+"__FolderUser_FolderKeyEvent_StructRightArrow_Allocation__allocInit_autoRun")call Vnx(function H6o,"s"+"__FolderUser_FolderKeyEvent_StructUpArrow_Allocation__allocInit_autoRun")
call Vnx(function H7o,"s"+"__FolderUser_StructKeyEvent_Allocation__allocInit_autoRun")call Vnx(function H8o,"s"+"__FolderUser_StructSlotState_Allocation__allocInit_autoRun")call Vnx(function H9o,"s"+"__FolderUser_StructState_Allocation__allocInit_autoRun")call Vnx(function jvo,"s"+"__FolderUser_StructTeam_Allocation__allocInit_autoRun")call Vnx(function jeo,"s"+"__User_objInits_autoRun")
call Vnx(function jxo,"s"+"__User_Allocation__allocInit_autoRun")call Vnx(function JWo,"s"+"__User_initializer_Init_autoRun")
call Vnx(function Jyo,"s"+"__WeatherType_Allocation__allocInit_autoRun")
call Vnx(function J0o,"s"+"__WeatherEffect_objInits_autoRun")call Vnx(function J1o,"s"+"__WeatherEffect_Allocation__allocInit_autoRun")call Vnx(function J9o,"s"+"__WeatherEffect_initializer_Init_autoRun")call Vnx(function kvo,"s"+"__Initialization_Allocation__allocInit_autoRun")call Vnx(function keo,"s"+"__FolderAct_StructId_Allocation__allocInit_autoRun")call Vnx(function kxo,"s"+"__FolderAct_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function koo,"s"+"__FolderAct_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function kro,"s"+"__FolderAct_StructData_Allocation__allocInit_autoRun")call Vnx(function kio,"s"+"__FolderAct_StructEvent_Allocation__allocInit_autoRun")call Vnx(function kao,"s"+"__FolderAct_StructLevelSets_Allocation__allocInit_autoRun")call Vnx(function kno,"s"+"__Act_Allocation__allocInit_autoRun")
call Vnx(function kQo,"s"+"__Act_initializer_Init_autoRun")call Vnx(function kso,"s"+"__ActUpgrades_Allocation__allocInit_autoRun")
call Vnx(function kyo,"s"+"__ActUpgrades_initializer_Init_autoRun")call Vnx(function kYo,"s"+"__AfterIntro_Allocation__allocInit_autoRun")call Vnx(function k_o,"s"+"__AfterIntro_initializer_Init_autoRun")call Vnx(function k0o,"s"+"__BrazierOracle_Allocation__allocInit_autoRun")call Vnx(function KOo,"s"+"__BrazierOracle_initializer_Init_autoRun")call Vnx(function KRo,"s"+"__CameraQuickPosition_Allocation__allocInit_autoRun")
call Vnx(function KBo,"s"+"__CameraQuickPosition_initializer_Init_autoRun")call Vnx(function KCo,"s"+"__MarkOfThePaw_objInits_autoRun")
call Vnx(function Kdo,"s"+"__MarkOfThePaw_Allocation__allocInit_autoRun")call Vnx(function KFo,"s"+"__MarkOfThePaw_initializer_Init_autoRun")
call Vnx(function Kgo,"s"+"__CreepLoot_Allocation__allocInit_autoRun")call Vnx(function KGo,"s"+"__Creep_Allocation__allocInit_autoRun")call Vnx(function Kho,"s"+"__CreepLocation_Allocation__allocInit_autoRun")call Vnx(function KHo,"s"+"__FolderCreepSet_StructId_Allocation__allocInit_autoRun")
call Vnx(function Kjo,"s"+"__FolderCreepSet_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vnx(function KJo,"s"+"__FolderCreepSet_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vnx(function Kko,"s"+"__FolderCreepSet_StructData_Allocation__allocInit_autoRun")call Vnx(function KKo,"s"+"__FolderCreepSet_StructEvent_Allocation__allocInit_autoRun")call Vnx(function Klo,"s"+"__CreepSet_Allocation__allocInit_autoRun")call Vnx(function lgo,"s"+"__CreepSet_initializer_Init_autoRun")
call Vnx(function lGo,"s"+"__DefenderSpawnLocation_Allocation__allocInit_autoRun")call Vnx(function lho,"s"+"__FolderDefenderSpawnType_StructId_Allocation__allocInit_autoRun")call Vnx(function lHo,"s"+"__FolderDefenderSpawnType_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function ljo,"s"+"__FolderDefenderSpawnType_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function lJo,"s"+"__FolderDefenderSpawnType_StructData_Allocation__allocInit_autoRun")call Vnx(function lko,"s"+"__FolderDefenderSpawnType_StructEvent_Allocation__allocInit_autoRun")
call Vnx(function lKo,"s"+"__DefenderSpawnType_Allocation__allocInit_autoRun")call Vnx(function llo,"s"+"__FolderDefenderSpawnGroup_StructId_Allocation__allocInit_autoRun")call Vnx(function lLo,"s"+"__FolderDefenderSpawnGroup_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function lmo,"s"+"__FolderDefenderSpawnGroup_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function lMo,"s"+"__FolderDefenderSpawnGroup_StructData_Allocation__allocInit_autoRun")
call Vnx(function lpo,"s"+"__DefenderSpawnGroup_Allocation__allocInit_autoRun")call Vnx(function lPo,"s"+"__FolderDefenderSpawnWave_StructId_Allocation__allocInit_autoRun")call Vnx(function lqo,"s"+"__FolderDefenderSpawnWave_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function lQo,"s"+"__FolderDefenderSpawnWave_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function lso,"s"+"__FolderDefenderSpawnWave_StructData_Allocation__allocInit_autoRun")call Vnx(function lSo,"s"+"__FolderDefenderSpawnWave_StructGroups_Allocation__allocInit_autoRun")call Vnx(function lto,"s"+"__DefenderSpawnWave_Allocation__allocInit_autoRun")call Vnx(function lTo,"s"+"__DefenderSpawn_Allocation__allocInit_autoRun")call Vnx(function LGo,"s"+"__DefenderSpawn_initializer_Init_autoRun")call Vnx(function Lho,"s"+"__Difficulty_Allocation__allocInit_autoRun")call Vnx(function LHo,"s"+"__Drop_objInits_autoRun")
call Vnx(function Ljo,"s"+"__Drop_Allocation__allocInit_autoRun")call Vnx(function LWo,"s"+"__Drop_initializer_Init_autoRun")
call Vnx(function meo,"s"+"__EternalVial_objInits_autoRun")call Vnx(function mxo,"s"+"__EternalVial_Allocation__allocInit_autoRun")
call Vnx(function mOo,"s"+"__EternalVial_initializer_Init_autoRun")call Vnx(function mRo,"s"+"__Explosive_objInits_autoRun")call Vnx(function mIo,"s"+"__Explosive_Allocation__allocInit_autoRun")call Vnx(function mUo,"s"+"__Explosive_initializer_Init_autoRun")call Vnx(function mWo,"s"+"__GarbageCollector_objInits_autoRun")
call Vnx(function myo,"s"+"__GarbageCollector_Allocation__allocInit_autoRun")call Vnx(function mZo,"s"+"__BoomerangStone_objInits_autoRun")call Vnx(function m_o,"s"+"__BoomerangStone_Allocation__allocInit_autoRun")call Vnx(function pio,"s"+"__BoomerangStone_initializer_Init_autoRun")call Vnx(function pno,"s"+"__Mallet_objInits_autoRun")call Vnx(function pVo,"s"+"__Mallet_Allocation__allocInit_autoRun")call Vnx(function pBo,"s"+"__Mallet_initializer_Init_autoRun")call Vnx(function pdo,"s"+"__PenguinFeather_objInits_autoRun")call Vnx(function pDo,"s"+"__PenguinFeather_Allocation__allocInit_autoRun")call Vnx(function pPo,"s"+"__PenguinFeather_initializer_Init_autoRun")call Vnx(function pQo,"s"+"__RabbitsFoot_objInits_autoRun")call Vnx(function pso,"s"+"__RabbitsFoot_Allocation__allocInit_autoRun")
call Vnx(function pUo,"s"+"__RabbitsFoot_initializer_Init_autoRun")call Vnx(function pWo,"s"+"__RamblersStick_objInits_autoRun")call Vnx(function pyo,"s"+"__RamblersStick_Allocation__allocInit_autoRun")call Vnx(function p0o,"s"+"__RamblersStick_initializer_Init_autoRun")call Vnx(function p2o,"s"+"__GruntAxe_objInits_autoRun")
call Vnx(function p3o,"s"+"__GruntAxe_Allocation__allocInit_autoRun")call Vnx(function p8o,"s"+"__GruntAxe_initializer_Init_autoRun")
call Vnx(function Pvo,"s"+"__RobynsHood_objInits_autoRun")call Vnx(function Peo,"s"+"__RobynsHood_Allocation__allocInit_autoRun")call Vnx(function PVo,"s"+"__RobynsHood_initializer_Init_autoRun")call Vnx(function PXo,"s"+"__ElfinDagger_objInits_autoRun")call Vnx(function POo,"s"+"__ElfinDagger_Allocation__allocInit_autoRun")
call Vnx(function Pco,"s"+"__ElfinDagger_initializer_Init_autoRun")call Vnx(function Pdo,"s"+"__FolderSpearOfTheDefender_StructBuff_objInits_autoRun")call Vnx(function PDo,"s"+"__FolderSpearOfTheDefender_StructBuff_Allocation__allocInit_autoRun")
call Vnx(function PFo,"s"+"__SpearOfTheDefender_objInits_autoRun")call Vnx(function Pgo,"s"+"__SpearOfTheDefender_Allocation__allocInit_autoRun")call Vnx(function Ppo,"s"+"__SpearOfTheDefender_initializer_Init_autoRun")call Vnx(function Pqo,"s"+"__MeteoriteShard_objInits_autoRun")call Vnx(function PQo,"s"+"__MeteoriteShard_Allocation__allocInit_autoRun")call Vnx(function Pwo,"s"+"__MeteoriteShard_initializer_Init_autoRun")call Vnx(function PYo,"s"+"__GoldCoin_objInits_autoRun")
call Vnx(function Pzo,"s"+"__GoldCoin_Allocation__allocInit_autoRun")call Vnx(function qxo,"s"+"__GoldCoin_initializer_Init_autoRun")
call Vnx(function qio,"s"+"__HeroRevival_objInits_autoRun")call Vnx(function qao,"s"+"__HeroRevival_Allocation__allocInit_autoRun")
call Vnx(function qso,"s"+"__HeroRevival_initializer_Init_autoRun")call Vnx(function qSo,"s"+"__HeroSelection_objInits_autoRun")call Vnx(function qto,"s"+"__HeroSelection_Allocation__allocInit_autoRun")call Vnx(function QBo,"s"+"__HeroSelection_initializer_Init_autoRun")call Vnx(function Qco,"s"+"__Hint_Allocation__allocInit_autoRun")call Vnx(function Qho,"s"+"__Hint_initializer_Init_autoRun")
call Vnx(function Qjo,"s"+"__FolderHorseRide_StructTarget_objInits_autoRun")
call Vnx(function QJo,"s"+"__FolderHorseRide_StructTarget_Allocation__allocInit_autoRun")call Vnx(function Qlo,"s"+"__HorseRide_objInits_autoRun")call Vnx(function QLo,"s"+"__HorseRide_Allocation__allocInit_autoRun")call Vnx(function sdo,"s"+"__HorseRide_initializer_Init_autoRun")call Vnx(function sDo,"s"+"__FolderInfoboard_StructUser_Allocation__allocInit_autoRun")call Vnx(function sfo,"s"+"__Infoboard_Allocation__allocInit_autoRun")call Vnx(function SOo,"s"+"__Infoboard_initializer_Init_autoRun")call Vnx(function SRo,"s"+"__Infocard_Allocation__allocInit_autoRun")call Vnx(function SDo,"s"+"__Infocard_initializer_Init_autoRun")
call Vnx(function Sfo,"s"+"__Intro_Allocation__allocInit_autoRun")call Vnx(function TYo,"s"+"__Intro_initializer_Init_autoRun")call Vnx(function Tzo,"s"+"__FolderLevelSet_StructId_Allocation__allocInit_autoRun")
call Vnx(function TZo,"s"+"__FolderLevelSet_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vnx(function T_o,"s"+"__FolderLevelSet_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vnx(function T0o,"s"+"__FolderLevelSet_StructData_Allocation__allocInit_autoRun")call Vnx(function T1o,"s"+"__FolderLevelSet_StructLevels_Allocation__allocInit_autoRun")
call Vnx(function T2o,"s"+"__FolderLevelSet_StructQuery_Allocation__allocInit_autoRun")call Vnx(function T3o,"s"+"__LevelSet_Allocation__allocInit_autoRun")call Vnx(function T4o,"s"+"__FolderLevel_StructId_Allocation__allocInit_autoRun")call Vnx(function T5o,"s"+"__FolderLevel_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function T6o,"s"+"__FolderLevel_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function T7o,"s"+"__FolderLevel_FolderData_StructReal_Allocation__allocInit_autoRun")call Vnx(function T8o,"s"+"__FolderLevel_StructData_Allocation__allocInit_autoRun")call Vnx(function T9o,"s"+"__FolderLevel_StructEvent_Allocation__allocInit_autoRun")
call Vnx(function uvo,"s"+"__Level_Allocation__allocInit_autoRun")call Vnx(function uUo,"s"+"__Level_initializer_Init_autoRun")call Vnx(function uWo,"s"+"__Library_objInits_autoRun")call Vnx(function uyo,"s"+"__Library_Allocation__allocInit_autoRun")
call Vnx(function uZo,"s"+"__Library_initializer_Init_autoRun")call Vnx(function u1o,"s"+"__Lumber_objInits_autoRun")call Vnx(function u2o,"s"+"__Lumber_Allocation__allocInit_autoRun")call Vnx(function Uoo,"s"+"__Lumber_initializer_Init_autoRun")call Vnx(function Uro,"s"+"__FolderNullboard_StructQuestLog_Allocation__allocInit_autoRun")call Vnx(function Uio,"s"+"__Nullboard_Allocation__allocInit_autoRun")call Vnx(function URo,"s"+"__Nullboard_initializer_Init_autoRun")call Vnx(function UIo,"s"+"__FolderOptionsBoard_StructCameraSmoothing_Allocation__allocInit_autoRun")call Vnx(function UAo,"s"+"__FolderOptionsBoard_StructCameraZoom_Allocation__allocInit_autoRun")
call Vnx(function UNo,"s"+"__FolderOptionsBoard_StructEffectLevel_Allocation__allocInit_autoRun")call Vnx(function Ubo,"s"+"__FolderOptionsBoard_StructHint_Allocation__allocInit_autoRun")call Vnx(function UBo,"s"+"__FolderOptionsBoard_StructMusicVolume_Allocation__allocInit_autoRun")call Vnx(function Uco,"s"+"__FolderOptionsBoard_StructSoundVolume_Allocation__allocInit_autoRun")call Vnx(function UCo,"s"+"__OptionsBoard_Allocation__allocInit_autoRun")call Vnx(function UMo,"s"+"__OptionsBoard_initializer_Init_autoRun")
call Vnx(function UPo,"s"+"__Pharmacy_objInits_autoRun")
call Vnx(function Uqo,"s"+"__Pharmacy_Allocation__allocInit_autoRun")call Vnx(function USo,"s"+"__EmergencyProvisions_objInits_autoRun")call Vnx(function Uto,"s"+"__EmergencyProvisions_Allocation__allocInit_autoRun")
call Vnx(function UUo,"s"+"__EmergencyProvisions_initializer_Init_autoRun")call Vnx(function UYo,"s"+"__EyeOfTheFlame_objInits_autoRun")call Vnx(function Uzo,"s"+"__EyeOfTheFlame_Allocation__allocInit_autoRun")call Vnx(function U3o,"s"+"__EyeOfTheFlame_initializer_Init_autoRun")call Vnx(function U7o,"s"+"__TorchLight_objInits_autoRun")call Vnx(function U8o,"s"+"__TorchLight_Allocation__allocInit_autoRun")call Vnx(function wRo,"s"+"__TorchLight_initializer_Init_autoRun")call Vnx(function wbo,"s"+"__HerbalOintment_objInits_autoRun")call Vnx(function wBo,"s"+"__HerbalOintment_Allocation__allocInit_autoRun")call Vnx(function wjo,"s"+"__HerbalOintment_initializer_Init_autoRun")call Vnx(function wko,"s"+"__FolderScrollOfProtection_StructTarget_objInits_autoRun")call Vnx(function wKo,"s"+"__FolderScrollOfProtection_StructTarget_Allocation__allocInit_autoRun")call Vnx(function wmo,"s"+"__ScrollOfProtection_objInits_autoRun")call Vnx(function wMo,"s"+"__ScrollOfProtection_Allocation__allocInit_autoRun")call Vnx(function wTo,"s"+"__ScrollOfProtection_initializer_Init_autoRun")call Vnx(function wUo,"s"+"__FolderFireWater_StructBuff_objInits_autoRun")call Vnx(function wwo,"s"+"__FolderFireWater_StructBuff_Allocation__allocInit_autoRun")call Vnx(function wYo,"s"+"__FireWater_objInits_autoRun")call Vnx(function wzo,"s"+"__FireWater_Allocation__allocInit_autoRun")call Vnx(function w7o,"s"+"__FireWater_initializer_Init_autoRun")call Vnx(function Wxo,"s"+"__IceTea_objInits_autoRun")call Vnx(function Woo,"s"+"__IceTea_Allocation__allocInit_autoRun")call Vnx(function Wao,"s"+"__IceTea_initializer_Init_autoRun")call Vnx(function WEo,"s"+"__Meat_objInits_autoRun")
call Vnx(function WXo,"s"+"__Meat_Allocation__allocInit_autoRun")call Vnx(function Wfo,"s"+"__Meat_initializer_Init_autoRun")
call Vnx(function Who,"s"+"__TeleportScroll_objInits_autoRun")call Vnx(function WHo,"s"+"__TeleportScroll_Allocation__allocInit_autoRun")call Vnx(function WTo,"s"+"__TeleportScroll_initializer_Init_autoRun")call Vnx(function WUo,"s"+"__Rune_objInits_autoRun")
call Vnx(function Wwo,"s"+"__Rune_Allocation__allocInit_autoRun")call Vnx(function yeo,"s"+"__Rune_initializer_Init_autoRun")
call Vnx(function yio,"s"+"__Snowmen_objInits_autoRun")call Vnx(function yao,"s"+"__Snowmen_Allocation__allocInit_autoRun")
call Vnx(function yIo,"s"+"__Snowmen_initializer_Init_autoRun")call Vnx(function yAo,"s"+"__SpawnLocation_Allocation__allocInit_autoRun")call Vnx(function yNo,"s"+"__FolderSpawnGroup_StructId_Allocation__allocInit_autoRun")call Vnx(function ybo,"s"+"__FolderSpawnGroup_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function yBo,"s"+"__FolderSpawnGroup_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function yco,"s"+"__FolderSpawnGroup_StructData_Allocation__allocInit_autoRun")
call Vnx(function yCo,"s"+"__SpawnGroup_Allocation__allocInit_autoRun")call Vnx(function ydo,"s"+"__FolderSpawnWave_StructId_Allocation__allocInit_autoRun")call Vnx(function yDo,"s"+"__FolderSpawnWave_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function yfo,"s"+"__FolderSpawnWave_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function yFo,"s"+"__FolderSpawnWave_FolderData_FolderReal_StructTable_Allocation__allocInit_autoRun")call Vnx(function ygo,"s"+"__FolderSpawnWave_FolderData_StructReal_Allocation__allocInit_autoRun")call Vnx(function yGo,"s"+"__FolderSpawnWave_StructData_Allocation__allocInit_autoRun")call Vnx(function yho,"s"+"__FolderSpawnWave_StructGroups_Allocation__allocInit_autoRun")call Vnx(function yHo,"s"+"__SpawnWave_Allocation__allocInit_autoRun")call Vnx(function yjo,"s"+"__FolderSpawn_StructQueue_Allocation__allocInit_autoRun")
call Vnx(function yko,"s"+"__FolderSpawn_StructShadow_objInits_autoRun")
call Vnx(function yKo,"s"+"__FolderSpawn_StructShadow_Allocation__allocInit_autoRun")call Vnx(function ylo,"s"+"__Spawn_Allocation__allocInit_autoRun")call Vnx(function zQo,"s"+"__Spawn_initializer_Init_autoRun")call Vnx(function zso,"s"+"__FolderSpawnType_StructId_Allocation__allocInit_autoRun")call Vnx(function zSo,"s"+"__FolderSpawnType_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function zto,"s"+"__FolderSpawnType_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function zTo,"s"+"__FolderSpawnType_StructData_Allocation__allocInit_autoRun")call Vnx(function zuo,"s"+"__FolderSpawnType_StructEvent_Allocation__allocInit_autoRun")
call Vnx(function zUo,"s"+"__FolderSpawnType_StructChampion_Allocation__allocInit_autoRun")call Vnx(function zwo,"s"+"__FolderSpawnType_StructItems_Allocation__allocInit_autoRun")
call Vnx(function zWo,"s"+"__SpawnType_Allocation__allocInit_autoRun")call Vnx(function zyo,"s"+"__StructInfo_Allocation__allocInit_autoRun")call Vnx(function z3o,"s"+"__StructInfo_initializer_Init_autoRun")call Vnx(function z5o,"s"+"__Tavern_objInits_autoRun")call Vnx(function z6o,"s"+"__Tavern_Allocation__allocInit_autoRun")call Vnx(function Zvo,"s"+"__TropicalRainbow_objInits_autoRun")call Vnx(function Zeo,"s"+"__TropicalRainbow_Allocation__allocInit_autoRun")
call Vnx(function Zro,"s"+"__TropicalRainbow_initializer_Init_autoRun")call Vnx(function Zao,"s"+"__FolderTomes_StructAgi_objInits_autoRun")call Vnx(function Zno,"s"+"__FolderTomes_StructAgi_Allocation__allocInit_autoRun")call Vnx(function ZEo,"s"+"__FolderTomes_StructInt_objInits_autoRun")call Vnx(function ZXo,"s"+"__FolderTomes_StructInt_Allocation__allocInit_autoRun")call Vnx(function ZRo,"s"+"__FolderTomes_StructStr_objInits_autoRun")call Vnx(function ZIo,"s"+"__FolderTomes_StructStr_Allocation__allocInit_autoRun")call Vnx(function ZAo,"s"+"__Tomes_Allocation__allocInit_autoRun")call Vnx(function ZFo,"s"+"__Tomes_initializer_Init_autoRun")call Vnx(function Zgo,"s"+"__UnitNameTag_Allocation__allocInit_autoRun")
call Vnx(function ZJo,"s"+"__UnitNameTag_initializer_Init_autoRun")call Vnx(function Zko,"s"+"__UnitStatus_Allocation__allocInit_autoRun")call Vnx(function vrr,"s"+"__UnitStatus_initializer_Init_autoRun")call Vnx(function var,"s"+"__VictoryRush_objInits_autoRun")call Vnx(function vnr,"s"+"__VictoryRush_Allocation__allocInit_autoRun")
call Vnx(function vOr,"s"+"__VictoryRush_initializer_Init_autoRun")call Vnx(function vbr,"s"+"__FolderWaypoint_FolderRegionCheck_StructRetreat_objInits_autoRun")call Vnx(function vBr,"s"+"__FolderWaypoint_FolderRegionCheck_StructRetreat_Allocation__allocInit_autoRun")call Vnx(function vcr,"s"+"__FolderWaypoint_StructRegionCheck_Allocation__allocInit_autoRun")call Vnx(function vdr,"s"+"__FolderWaypoint_StructSpawns_objInits_autoRun")call Vnx(function vDr,"s"+"__FolderWaypoint_StructSpawns_Allocation__allocInit_autoRun")
call Vnx(function vfr,"s"+"__Waypoint_Allocation__allocInit_autoRun")call Vnx(function v_r,"s"+"__Waypoint_initializer_Init_autoRun")
call Vnx(function v0r,"s"+"__Zoom_Allocation__allocInit_autoRun")call Vnx(function eOr,"s"+"__Zoom_initializer_Init_autoRun")
call Vnx(function eRr,"s"+"__AxeFighter_Allocation__allocInit_autoRun")call Vnx(function edr,"s"+"__AxeFighter_initializer_Init_autoRun")call Vnx(function eDr,"s"+"__Balduir_Allocation__allocInit_autoRun")
call Vnx(function egr,"s"+"__Balduir_initializer_Init_autoRun")call Vnx(function eGr,"s"+"__FolderAura_StructId_Allocation__allocInit_autoRun")
call Vnx(function ehr,"s"+"__FolderAura_FolderData_StructBoolean_Allocation__allocInit_autoRun")
call Vnx(function eHr,"s"+"__FolderAura_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vnx(function ejr,"s"+"__FolderAura_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vnx(function eJr,"s"+"__FolderAura_StructData_Allocation__allocInit_autoRun")call Vnx(function ekr,"s"+"__FolderAura_StructEvent_Allocation__allocInit_autoRun")call Vnx(function eKr,"s"+"__FolderAura_StructTarget_Allocation__allocInit_autoRun")
call Vnx(function elr,"s"+"__Aura_Allocation__allocInit_autoRun")call Vnx(function e2r,"s"+"__Aura_initializer_Init_autoRun")
call Vnx(function e3r,"s"+"__AIBoost_Allocation__allocInit_autoRun")
call Vnx(function x9r,"s"+"__AIBoost_initializer_Init_autoRun")call Vnx(function oxr,"s"+"__Boost_objInits_autoRun")call Vnx(function oor,"s"+"__Boost_Allocation__allocInit_autoRun")call Vnx(function onr,"s"+"__Boost_initializer_Init_autoRun")call Vnx(function oVr,"s"+"__AIBurningSpirit_Allocation__allocInit_autoRun")
call Vnx(function oGr,"s"+"__AIBurningSpirit_initializer_Init_autoRun")call Vnx(function ojr,"s"+"__BurningSpirit_objInits_autoRun")call Vnx(function oJr,"s"+"__BurningSpirit_Allocation__allocInit_autoRun")call Vnx(function okr,"s"+"__AIChaosBall_Allocation__allocInit_autoRun")
call Vnx(function omr,"s"+"__AIChaosBall_initializer_Init_autoRun")call Vnx(function oPr,"s"+"__ChaosBall_objInits_autoRun")call Vnx(function oqr,"s"+"__ChaosBall_Allocation__allocInit_autoRun")call Vnx(function ror,"s"+"__ChaosBall_initializer_Init_autoRun")call Vnx(function rir,"s"+"__FolderEnergyCharge_StructTarget_objInits_autoRun")call Vnx(function rar,"s"+"__FolderEnergyCharge_StructTarget_Allocation__allocInit_autoRun")
call Vnx(function rEr,"s"+"__EnergyCharge_objInits_autoRun")
call Vnx(function rXr,"s"+"__EnergyCharge_Allocation__allocInit_autoRun")call Vnx(function rgr,"s"+"__EnergyCharge_initializer_Init_autoRun")
call Vnx(function rGr,"s"+"__AIFlamelet_Allocation__allocInit_autoRun")call Vnx(function rJr,"s"+"__AIFlamelet_initializer_Init_autoRun")call Vnx(function rlr,"s"+"__Flamelet_objInits_autoRun")
call Vnx(function rLr,"s"+"__Flamelet_Allocation__allocInit_autoRun")call Vnx(function rWr,"s"+"__Flamelet_initializer_Init_autoRun")
call Vnx(function rYr,"s"+"__FuzzyAttack_objInits_autoRun")call Vnx(function rzr,"s"+"__FuzzyAttack_Allocation__allocInit_autoRun")
call Vnx(function ier,"s"+"__FuzzyAttack_initializer_Init_autoRun")call Vnx(function ior,"s"+"__FolderGreenNova_StructBuff_objInits_autoRun")call Vnx(function irr,"s"+"__FolderGreenNova_StructBuff_Allocation__allocInit_autoRun")call Vnx(function iar,"s"+"__GreenNova_objInits_autoRun")call Vnx(function inr,"s"+"__GreenNova_Allocation__allocInit_autoRun")call Vnx(function icr,"s"+"__GreenNova_initializer_Init_autoRun")call Vnx(function iCr,"s"+"__AIHeal_Allocation__allocInit_autoRun")call Vnx(function iFr,"s"+"__AIHeal_initializer_Init_autoRun")call Vnx(function iGr,"s"+"__Heal_objInits_autoRun")
call Vnx(function ihr,"s"+"__Heal_Allocation__allocInit_autoRun")call Vnx(function iJr,"s"+"__Heal_initializer_Init_autoRun")
call Vnx(function ikr,"s"+"__AIHealExplosion_Allocation__allocInit_autoRun")
call Vnx(function iLr,"s"+"__AIHealExplosion_initializer_Init_autoRun")call Vnx(function iMr,"s"+"__HealExplosion_objInits_autoRun")call Vnx(function ipr,"s"+"__HealExplosion_Allocation__allocInit_autoRun")call Vnx(function iTr,"s"+"__HealExplosion_initializer_Init_autoRun")call Vnx(function iWr,"s"+"__IceArrows_objInits_autoRun")call Vnx(function iyr,"s"+"__IceArrows_Allocation__allocInit_autoRun")call Vnx(function i5r,"s"+"__IceArrows_initializer_Init_autoRun")call Vnx(function i8r,"s"+"__LightningShield_objInits_autoRun")call Vnx(function i9r,"s"+"__LightningShield_Allocation__allocInit_autoRun")
call Vnx(function anr,"s"+"__LightningShield_initializer_Init_autoRun")call Vnx(function aEr,"s"+"__FolderLunarRestoration_StructRevival_objInits_autoRun")
call Vnx(function aXr,"s"+"__FolderLunarRestoration_StructRevival_Allocation__allocInit_autoRun")call Vnx(function aAr,"s"+"__LunarRestoration_objInits_autoRun")
call Vnx(function aNr,"s"+"__LunarRestoration_Allocation__allocInit_autoRun")call Vnx(function apr,"s"+"__LunarRestoration_initializer_Init_autoRun")
call Vnx(function aPr,"s"+"__AIPurge_Allocation__allocInit_autoRun")
call Vnx(function aTr,"s"+"__AIPurge_initializer_Init_autoRun")call Vnx(function awr,"s"+"__Purge_objInits_autoRun")call Vnx(function aWr,"s"+"__Purge_Allocation__allocInit_autoRun")call Vnx(function nRr,"s"+"__Purge_initializer_Init_autoRun")call Vnx(function nAr,"s"+"__FolderSoakingPoison_StructTarget_objInits_autoRun")
call Vnx(function nNr,"s"+"__FolderSoakingPoison_StructTarget_Allocation__allocInit_autoRun")call Vnx(function ncr,"s"+"__SoakingPoison_objInits_autoRun")call Vnx(function nCr,"s"+"__SoakingPoison_Allocation__allocInit_autoRun")call Vnx(function nlr,"s"+"__SoakingPoison_initializer_Init_autoRun")call Vnx(function nMr,"s"+"__Stampede_objInits_autoRun")
call Vnx(function npr,"s"+"__Stampede_Allocation__allocInit_autoRun")call Vnx(function nUr,"s"+"__Stampede_initializer_Init_autoRun")
call Vnx(function nwr,"s"+"__AIStomp_Allocation__allocInit_autoRun")
call Vnx(function nYr,"s"+"__AIStomp_initializer_Init_autoRun")call Vnx(function nZr,"s"+"__Stomp_objInits_autoRun")call Vnx(function n_r,"s"+"__Stomp_Allocation__allocInit_autoRun")call Vnx(function n6r,"s"+"__Stomp_initializer_Init_autoRun")call Vnx(function Vxr,"s"+"__Barrage_objInits_autoRun")call Vnx(function Vor,"s"+"__Barrage_Allocation__allocInit_autoRun")
call Vnx(function VRr,"s"+"__Barrage_initializer_Init_autoRun")call Vnx(function VIr,"s"+"__AIBouncyBomb_Allocation__allocInit_autoRun")call Vnx(function VBr,"s"+"__AIBouncyBomb_initializer_Init_autoRun")
call Vnx(function VCr,"s"+"__BouncyBomb_objInits_autoRun")call Vnx(function Vdr,"s"+"__BouncyBomb_Allocation__allocInit_autoRun")call Vnx(function VSr,"s"+"__BouncyBomb_initializer_Init_autoRun")call Vnx(function VUr,"s"+"__BurningOil_objInits_autoRun")call Vnx(function Vwr,"s"+"__BurningOil_Allocation__allocInit_autoRun")call Vnx(function V8r,"s"+"__BurningOil_initializer_Init_autoRun")call Vnx(function Exr,"s"+"__ChainLightning_objInits_autoRun")call Vnx(function Eor,"s"+"__ChainLightning_Allocation__allocInit_autoRun")call Vnx(function EHr,"s"+"__ChainLightning_initializer_Init_autoRun")call Vnx(function Ejr,"s"+"__FolderCleaver_StructId_Allocation__allocInit_autoRun")call Vnx(function EJr,"s"+"__FolderCleaver_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")call Vnx(function Ekr,"s"+"__FolderCleaver_FolderData_StructInteger_Allocation__allocInit_autoRun")call Vnx(function EKr,"s"+"__FolderCleaver_StructData_Allocation__allocInit_autoRun")call Vnx(function Elr,"s"+"__FolderCleaver_StructWave_objInits_autoRun")
call Vnx(function ELr,"s"+"__FolderCleaver_StructWave_Allocation__allocInit_autoRun")call Vnx(function EMr,"s"+"__Cleaver_objInits_autoRun")call Vnx(function Epr,"s"+"__Cleaver_Allocation__allocInit_autoRun")
call Vnx(function E9r,"s"+"__Cleaver_initializer_Init_autoRun")call Vnx(function Xxr,"s"+"__ColdResistance_objInits_autoRun")call Vnx(function Xor,"s"+"__ColdResistance_Allocation__allocInit_autoRun")call Vnx(function Xnr,"s"+"__ColdResistance_initializer_Init_autoRun")call Vnx(function XEr,"s"+"__DeathAxe_objInits_autoRun")
call Vnx(function XXr,"s"+"__DeathAxe_Allocation__allocInit_autoRun")call Vnx(function XHr,"s"+"__DeathAxe_initializer_Init_autoRun")
call Vnx(function XJr,"s"+"__FolderDrumRoll_StructTarget_objInits_autoRun")call Vnx(function Xkr,"s"+"__FolderDrumRoll_StructTarget_Allocation__allocInit_autoRun")
call Vnx(function XLr,"s"+"__DrumRoll_objInits_autoRun")
call Vnx(function Xmr,"s"+"__DrumRoll_Allocation__allocInit_autoRun")call Vnx(function Oor,"s"+"__DrumRoll_initializer_Init_autoRun")
call Vnx(function Oir,"s"+"__FolderEnvenomedSpears_StructTarget_objInits_autoRun")call Vnx(function Oar,"s"+"__FolderEnvenomedSpears_StructTarget_Allocation__allocInit_autoRun")call Vnx(function OEr,"s"+"__EnvenomedSpears_objInits_autoRun")call Vnx(function OXr,"s"+"__EnvenomedSpears_Allocation__allocInit_autoRun")
call Vnx(function OFr,"s"+"__EnvenomedSpears_initializer_Init_autoRun")call Vnx(function Ogr,"s"+"__AIKnockout_Allocation__allocInit_autoRun")call Vnx(function Ojr,"s"+"__AIKnockout_initializer_Init_autoRun")call Vnx(function Okr,"s"+"__FolderKnockout_StructTarget_objInits_autoRun")call Vnx(function OKr,"s"+"__FolderKnockout_StructTarget_Allocation__allocInit_autoRun")
call Vnx(function OLr,"s"+"__Knockout_objInits_autoRun")
call Vnx(function Omr,"s"+"__Knockout_Allocation__allocInit_autoRun")call Vnx(function Ozr,"s"+"__Knockout_initializer_Init_autoRun")
call Vnx(function OZr,"s"+"__AIMedipack_Allocation__allocInit_autoRun")call Vnx(function O2r,"s"+"__AIMedipack_initializer_Init_autoRun")call Vnx(function O4r,"s"+"__Medipack_objInits_autoRun")
call Vnx(function O5r,"s"+"__Medipack_Allocation__allocInit_autoRun")call Vnx(function O8r,"s"+"__Medipack_initializer_Init_autoRun")
call Vnx(function Rer,"s"+"__MutingShout_objInits_autoRun")call Vnx(function Rxr,"s"+"__MutingShout_Allocation__allocInit_autoRun")
call Vnx(function Rar,"s"+"__MutingShout_initializer_Init_autoRun")call Vnx(function RVr,"s"+"__Realplex_objInits_autoRun")
call Vnx(function REr,"s"+"__Realplex_Allocation__allocInit_autoRun")call Vnx(function RZr,"s"+"__Realplex_initializer_Init_autoRun")
call Vnx(function R1r,"s"+"__SerpentWard_objInits_autoRun")call Vnx(function R2r,"s"+"__SerpentWard_Allocation__allocInit_autoRun")
call Vnx(function Ixr,"s"+"__SerpentWard_initializer_Init_autoRun")call Vnx(function Iir,"s"+"__SpiritWolves_objInits_autoRun")
call Vnx(function Iar,"s"+"__SpiritWolves_Allocation__allocInit_autoRun")call Vnx(function IDr,"s"+"__SpiritWolves_initializer_Init_autoRun")
call Vnx(function IFr,"s"+"__Stormbolt_objInits_autoRun")call Vnx(function Igr,"s"+"__Stormbolt_Allocation__allocInit_autoRun")call Vnx(function Ikr,"s"+"__Stormbolt_initializer_Init_autoRun")call Vnx(function ILr,"s"+"__SummonMinions_objInits_autoRun")call Vnx(function Imr,"s"+"__SummonMinions_Allocation__allocInit_autoRun")call Vnx(function I0r,"s"+"__SummonMinions_initializer_Init_autoRun")call Vnx(function I2r,"s"+"__Artifact_objInits_autoRun")
call Vnx(function I3r,"s"+"__Artifact_Allocation__allocInit_autoRun")call Vnx(function I5r,"s"+"__Artifact_initializer_Init_autoRun")
call Vnx(function I6r,"s"+"__FolderBatSwarm_StructMissile_objInits_autoRun")
call Vnx(function I7r,"s"+"__FolderBatSwarm_StructMissile_Allocation__allocInit_autoRun")call Vnx(function Avr,"s"+"__BatSwarm_objInits_autoRun")
call Vnx(function Aer,"s"+"__BatSwarm_Allocation__allocInit_autoRun")call Vnx(function ACr,"s"+"__BatSwarm_initializer_Init_autoRun")
call Vnx(function AFr,"s"+"__HawkEye_objInits_autoRun")call Vnx(function Agr,"s"+"__HawkEye_Allocation__allocInit_autoRun")
call Vnx(function ATr,"s"+"__HawkEye_initializer_Init_autoRun")call Vnx(function Awr,"s"+"__FolderMagicBottle_StructBuff_objInits_autoRun")
call Vnx(function AWr,"s"+"__FolderMagicBottle_StructBuff_Allocation__allocInit_autoRun")call Vnx(function AYr,"s"+"__MagicBottle_objInits_autoRun")call Vnx(function Azr,"s"+"__MagicBottle_Allocation__allocInit_autoRun")
call Vnx(function A9r,"s"+"__MagicBottle_initializer_Init_autoRun")call Vnx(function Ner,"s"+"__FolderRedwoodValkyrie_StructAir_objInits_autoRun")call Vnx(function Nxr,"s"+"__FolderRedwoodValkyrie_StructAir_Allocation__allocInit_autoRun")
call Vnx(function Nir,"s"+"__RedwoodValkyrie_objInits_autoRun")call Vnx(function Nar,"s"+"__RedwoodValkyrie_Allocation__allocInit_autoRun")
call Vnx(function Njr,"s"+"__RedwoodValkyrie_initializer_Init_autoRun")call Vnx(function Nlr,"s"+"__SapphireblueDagger_objInits_autoRun")call Vnx(function NLr,"s"+"__SapphireblueDagger_Allocation__allocInit_autoRun")call Vnx(function Ntr,"s"+"__SapphireblueDagger_initializer_Init_autoRun")call Vnx(function NUr,"s"+"__SilentBoots_objInits_autoRun")call Vnx(function Nwr,"s"+"__SilentBoots_Allocation__allocInit_autoRun")
call Vnx(function bjr,"s"+"__SilentBoots_initializer_Init_autoRun")call Vnx(function bKr,"s"+"__StoneShield_objInits_autoRun")call Vnx(function blr,"s"+"__StoneShield_Allocation__allocInit_autoRun")
call Vnx(function bTr,"s"+"__StoneShield_initializer_Init_autoRun")call Vnx(function byr,"s"+"__TaintedLeaf_objInits_autoRun")call Vnx(function bYr,"s"+"__TaintedLeaf_Allocation__allocInit_autoRun")
call Vnx(function b7r,"s"+"__TaintedLeaf_initializer_Init_autoRun")call Vnx(function Brr,"s"+"__FolderVioletEarring_StructCharge_objInits_autoRun")
call Vnx(function Bir,"s"+"__FolderVioletEarring_StructCharge_Allocation__allocInit_autoRun")call Vnx(function Bnr,"s"+"__FolderVioletEarring_StructPort_objInits_autoRun")call Vnx(function BVr,"s"+"__FolderVioletEarring_StructPort_Allocation__allocInit_autoRun")call Vnx(function BXr,"s"+"__VioletEarring_objInits_autoRun")call Vnx(function BOr,"s"+"__VioletEarring_Allocation__allocInit_autoRun")call Vnx(function Bmr,"s"+"__VioletEarring_initializer_Init_autoRun")call Vnx(function BPr,"s"+"__FolderVomit_StructTarget_objInits_autoRun")
call Vnx(function Bqr,"s"+"__FolderVomit_StructTarget_Allocation__allocInit_autoRun")call Vnx(function Bsr,"s"+"__Vomit_objInits_autoRun")call Vnx(function BSr,"s"+"__Vomit_Allocation__allocInit_autoRun")call Vnx(function B6r,"s"+"__Vomit_initializer_Init_autoRun")call Vnx(function B9r,"s"+"__FolderWhiteStaff_StructTarget_objInits_autoRun")call Vnx(function cvr,"s"+"__FolderWhiteStaff_StructTarget_Allocation__allocInit_autoRun")call Vnx(function crr,"s"+"__WhiteStaff_objInits_autoRun")call Vnx(function cir,"s"+"__WhiteStaff_Allocation__allocInit_autoRun")call Vnx(function cNr,"s"+"__WhiteStaff_initializer_Init_autoRun")call Vnx(function cBr,"s"+"__FolderBarrier_StructKnockback_objInits_autoRun")call Vnx(function ccr,"s"+"__FolderBarrier_StructKnockback_Allocation__allocInit_autoRun")call Vnx(function cMr,"s"+"__Barrier_objInits_autoRun")call Vnx(function cpr,"s"+"__Barrier_Allocation__allocInit_autoRun")
call Vnx(function cZr,"s"+"__Barrier_initializer_Init_autoRun")call Vnx(function c0r,"s"+"__FolderBlizzard_StructWave_objInits_autoRun")call Vnx(function c1r,"s"+"__FolderBlizzard_StructWave_Allocation__allocInit_autoRun")call Vnx(function c4r,"s"+"__Blizzard_objInits_autoRun")
call Vnx(function c5r,"s"+"__Blizzard_Allocation__allocInit_autoRun")call Vnx(function CRr,"s"+"__Blizzard_initializer_Init_autoRun")
call Vnx(function CNr,"s"+"__FolderChillyBreath_StructBuff_objInits_autoRun")call Vnx(function Cbr,"s"+"__FolderChillyBreath_StructBuff_Allocation__allocInit_autoRun")call Vnx(function CCr,"s"+"__ChillyBreath_objInits_autoRun")
call Vnx(function Cdr,"s"+"__ChillyBreath_Allocation__allocInit_autoRun")call Vnx(function C7r,"s"+"__ChillyBreath_initializer_Init_autoRun")
call Vnx(function C8r,"s"+"__ElementalSpellToHero_Allocation__allocInit_autoRun")call Vnx(function dar,"s"+"__ElementalSpellToHero_initializer_Init_autoRun")
call Vnx(function dEr,"s"+"__FolderFireburst_StructShot_objInits_autoRun")call Vnx(function dXr,"s"+"__FolderFireburst_StructShot_Allocation__allocInit_autoRun")call Vnx(function dIr,"s"+"__Fireburst_objInits_autoRun")call Vnx(function dAr,"s"+"__Fireburst_Allocation__allocInit_autoRun")call Vnx(function dWr,"s"+"__Fireburst_initializer_Init_autoRun")call Vnx(function dYr,"s"+"__FlameTongue_objInits_autoRun")call Vnx(function dzr,"s"+"__FlameTongue_Allocation__allocInit_autoRun")
call Vnx(function Dnr,"s"+"__FlameTongue_initializer_Init_autoRun")call Vnx(function DXr,"s"+"__FolderFrozenStar_StructTarget_objInits_autoRun")call Vnx(function DOr,"s"+"__FolderFrozenStar_StructTarget_Allocation__allocInit_autoRun")call Vnx(function DIr,"s"+"__FolderFrozenStar_StructExplosion_objInits_autoRun")
call Vnx(function DAr,"s"+"__FolderFrozenStar_StructExplosion_Allocation__allocInit_autoRun")call Vnx(function Dbr,"s"+"__FrozenStar_objInits_autoRun")call Vnx(function DBr,"s"+"__FrozenStar_Allocation__allocInit_autoRun")call Vnx(function Dpr,"s"+"__FrozenStar_initializer_Init_autoRun")call Vnx(function DUr,"s"+"__FolderGhostSword_StructSword_objInits_autoRun")
call Vnx(function Dwr,"s"+"__FolderGhostSword_StructSword_Allocation__allocInit_autoRun")call Vnx(function DYr,"s"+"__GhostSword_objInits_autoRun")call Vnx(function Dzr,"s"+"__GhostSword_Allocation__allocInit_autoRun")call Vnx(function fOr,"s"+"__GhostSword_initializer_Init_autoRun")call Vnx(function fAr,"s"+"__FolderHackNSlay_StructTarget_objInits_autoRun")
call Vnx(function fNr,"s"+"__FolderHackNSlay_StructTarget_Allocation__allocInit_autoRun")call Vnx(function fcr,"s"+"__HackNSlay_objInits_autoRun")call Vnx(function fCr,"s"+"__HackNSlay_Allocation__allocInit_autoRun")call Vnx(function fkr,"s"+"__HackNSlay_initializer_Init_autoRun")call Vnx(function fLr,"s"+"__IceBlock_objInits_autoRun")
call Vnx(function fmr,"s"+"__IceBlock_Allocation__allocInit_autoRun")call Vnx(function fPr,"s"+"__IceBlock_initializer_Init_autoRun")
call Vnx(function fSr,"s"+"__IceShock_objInits_autoRun")
call Vnx(function ftr,"s"+"__IceShock_Allocation__allocInit_autoRun")call Vnx(function fwr,"s"+"__IceShock_initializer_Init_autoRun")
call Vnx(function fYr,"s"+"__FolderInnerForce_StructCrit_objInits_autoRun")call Vnx(function fzr,"s"+"__FolderInnerForce_StructCrit_Allocation__allocInit_autoRun")
call Vnx(function f_r,"s"+"__InnerForce_objInits_autoRun")call Vnx(function f0r,"s"+"__InnerForce_Allocation__allocInit_autoRun")call Vnx(function FEr,"s"+"__InnerForce_initializer_Init_autoRun")call Vnx(function FRr,"s"+"__Monolith_objInits_autoRun")
call Vnx(function FIr,"s"+"__Monolith_Allocation__allocInit_autoRun")call Vnx(function Fkr,"s"+"__Monolith_initializer_Init_autoRun")
call Vnx(function FLr,"s"+"__FolderSacredAura_StructTarget_objInits_autoRun")call Vnx(function Fmr,"s"+"__FolderSacredAura_StructTarget_Allocation__allocInit_autoRun")call Vnx(function FPr,"s"+"__SacredAura_objInits_autoRun")call Vnx(function Fqr,"s"+"__SacredAura_Allocation__allocInit_autoRun")call Vnx(function Fwr,"s"+"__SacredAura_initializer_Init_autoRun")call Vnx(function FYr,"s"+"__FolderSeverance_StructBuff_objInits_autoRun")call Vnx(function Fzr,"s"+"__FolderSeverance_StructBuff_Allocation__allocInit_autoRun")call Vnx(function F_r,"s"+"__Severance_objInits_autoRun")call Vnx(function F0r,"s"+"__Severance_Allocation__allocInit_autoRun")call Vnx(function gir,"s"+"__Severance_initializer_Init_autoRun")call Vnx(function gnr,"s"+"__FolderSnowySphere_StructParticle_objInits_autoRun")
call Vnx(function gVr,"s"+"__FolderSnowySphere_StructParticle_Allocation__allocInit_autoRun")call Vnx(function gXr,"s"+"__SnowySphere_objInits_autoRun")call Vnx(function gOr,"s"+"__SnowySphere_Allocation__allocInit_autoRun")
call Vnx(function glr,"s"+"__SnowySphere_initializer_Init_autoRun")call Vnx(function gmr,"s"+"__Thunderstrike_objInits_autoRun")call Vnx(function gMr,"s"+"__Thunderstrike_Allocation__allocInit_autoRun")call Vnx(function g1r,"s"+"__Thunderstrike_initializer_Init_autoRun")call Vnx(function Gvr,"s"+"__TwinWolves_objInits_autoRun")call Vnx(function Ger,"s"+"__TwinWolves_Allocation__allocInit_autoRun")call Vnx(function Gbr,"s"+"__TwinWolves_initializer_Init_autoRun")call Vnx(function GCr,"s"+"__Brotherhood_objInits_autoRun")call Vnx(function Gdr,"s"+"__Brotherhood_Allocation__allocInit_autoRun")
call Vnx(function Gkr,"s"+"__Brotherhood_initializer_Init_autoRun")call Vnx(function Gmr,"s"+"__Carnivore_objInits_autoRun")call Vnx(function GMr,"s"+"__Carnivore_Allocation__allocInit_autoRun")call Vnx(function GQr,"s"+"__Carnivore_initializer_Init_autoRun")call Vnx(function Gtr,"s"+"__WolfsMark_objInits_autoRun")call Vnx(function GTr,"s"+"__WolfsMark_Allocation__allocInit_autoRun")call Vnx(function GUr,"s"+"__WolfsMark_initializer_Init_autoRun")call Vnx(function Gwr,"s"+"__FolderVividMeteor_StructEffects_objInits_autoRun")call Vnx(function GWr,"s"+"__FolderVividMeteor_StructEffects_Allocation__allocInit_autoRun")
call Vnx(function Gzr,"s"+"__VividMeteor_objInits_autoRun")call Vnx(function GZr,"s"+"__VividMeteor_Allocation__allocInit_autoRun")
call Vnx(function hnr,"s"+"__VividMeteor_initializer_Init_autoRun")call Vnx(function hOr,"s"+"__WarmthMagnetism_objInits_autoRun")call Vnx(function hRr,"s"+"__WarmthMagnetism_Allocation__allocInit_autoRun")
call Vnx(function hFr,"s"+"__WarmthMagnetism_initializer_Init_autoRun")call Vnx(function hGr,"s"+"__FolderAmaterasu_StructTarget_objInits_autoRun")
call Vnx(function hhr,"s"+"__FolderAmaterasu_StructTarget_Allocation__allocInit_autoRun")call Vnx(function hJr,"s"+"__Amaterasu_objInits_autoRun")call Vnx(function hkr,"s"+"__Amaterasu_Allocation__allocInit_autoRun")call Vnx(function hQr,"s"+"__Amaterasu_initializer_Init_autoRun")call Vnx(function hTr,"s"+"__FolderArcaneAttractor_StructTarget_objInits_autoRun")call Vnx(function hur,"s"+"__FolderArcaneAttractor_StructTarget_Allocation__allocInit_autoRun")call Vnx(function hWr,"s"+"__ArcaneAttractor_objInits_autoRun")call Vnx(function hyr,"s"+"__ArcaneAttractor_Allocation__allocInit_autoRun")
call Vnx(function h7r,"s"+"__ArcaneAttractor_initializer_Init_autoRun")call Vnx(function Hor,"s"+"__ArcticWolf_objInits_autoRun")call Vnx(function Hrr,"s"+"__ArcticWolf_Allocation__allocInit_autoRun")call Vnx(function HGr,"s"+"__ArcticWolf_initializer_Init_autoRun")call Vnx(function HHr,"s"+"__FolderBoulderCrash_StructVisuals_objInits_autoRun")
call Vnx(function Hjr,"s"+"__FolderBoulderCrash_StructVisuals_Allocation__allocInit_autoRun")call Vnx(function HKr,"s"+"__BoulderCrash_objInits_autoRun")
call Vnx(function Hlr,"s"+"__BoulderCrash_Allocation__allocInit_autoRun")call Vnx(function H6r,"s"+"__BoulderCrash_initializer_Init_autoRun")
call Vnx(function jxr,"s"+"__Conflagration_objInits_autoRun")call Vnx(function jor,"s"+"__Conflagration_Allocation__allocInit_autoRun")call Vnx(function jJr,"s"+"__Conflagration_initializer_Init_autoRun")call Vnx(function jKr,"s"+"__FolderCyclone_StructRelocate_objInits_autoRun")
call Vnx(function jlr,"s"+"__FolderCyclone_StructRelocate_Allocation__allocInit_autoRun")call Vnx(function jMr,"s"+"__Cyclone_objInits_autoRun")call Vnx(function jpr,"s"+"__Cyclone_Allocation__allocInit_autoRun")
call Vnx(function j0r,"s"+"__Cyclone_initializer_Init_autoRun")call Vnx(function j2r,"s"+"__FolderWindDance_StructTarget_objInits_autoRun")
call Vnx(function j3r,"s"+"__FolderWindDance_StructTarget_Allocation__allocInit_autoRun")call Vnx(function j7r,"s"+"__WindDance_objInits_autoRun")call Vnx(function j8r,"s"+"__WindDance_Allocation__allocInit_autoRun")call Vnx(function Jrr,"s"+"__DeprivingShock_objInits_autoRun")call Vnx(function Jir,"s"+"__DeprivingShock_Allocation__allocInit_autoRun")call Vnx(function JNr,"s"+"__DeprivingShock_initializer_Init_autoRun")call Vnx(function Jcr,"s"+"__FolderDoppelganger_StructBigBoom_objInits_autoRun")
call Vnx(function JCr,"s"+"__FolderDoppelganger_StructBigBoom_Allocation__allocInit_autoRun")call Vnx(function Jfr,"s"+"__FolderDoppelganger_StructFireBuff_objInits_autoRun")call Vnx(function JFr,"s"+"__FolderDoppelganger_StructFireBuff_Allocation__allocInit_autoRun")call Vnx(function JHr,"s"+"__FolderDoppelganger_StructIceBuff_objInits_autoRun")
call Vnx(function Jjr,"s"+"__FolderDoppelganger_StructIceBuff_Allocation__allocInit_autoRun")call Vnx(function JLr,"s"+"__Doppelganger_objInits_autoRun")
call Vnx(function Jmr,"s"+"__Doppelganger_Allocation__allocInit_autoRun")call Vnx(function kxr,"s"+"__Doppelganger_initializer_Init_autoRun")
call Vnx(function kir,"s"+"__EbonyShot_objInits_autoRun")call Vnx(function kar,"s"+"__EbonyShot_Allocation__allocInit_autoRun")call Vnx(function kfr,"s"+"__EbonyShot_initializer_Init_autoRun")call Vnx(function kGr,"s"+"__FolderEmphaticBite_StructBuff_objInits_autoRun")call Vnx(function khr,"s"+"__FolderEmphaticBite_StructBuff_Allocation__allocInit_autoRun")call Vnx(function kKr,"s"+"__EmphaticBite_objInits_autoRun")
call Vnx(function klr,"s"+"__EmphaticBite_Allocation__allocInit_autoRun")call Vnx(function kzr,"s"+"__EmphaticBite_initializer_Init_autoRun")
call Vnx(function k_r,"s"+"__EnchantedArrow_objInits_autoRun")call Vnx(function k0r,"s"+"__EnchantedArrow_Allocation__allocInit_autoRun")call Vnx(function Kdr,"s"+"__EnchantedArrow_initializer_Init_autoRun")call Vnx(function KFr,"s"+"__FolderFairyShape_StructRevert_objInits_autoRun")call Vnx(function Kgr,"s"+"__FolderFairyShape_StructRevert_Allocation__allocInit_autoRun")call Vnx(function KMr,"s"+"__FairyShape_objInits_autoRun")call Vnx(function Kpr,"s"+"__FairyShape_Allocation__allocInit_autoRun")call Vnx(function K2r,"s"+"__FairyShape_initializer_Init_autoRun")call Vnx(function K6r,"s"+"__FolderFairysTears_StructTarget_objInits_autoRun")call Vnx(function K7r,"s"+"__FolderFairysTears_StructTarget_Allocation__allocInit_autoRun")call Vnx(function lvr,"s"+"__FairysTears_objInits_autoRun")call Vnx(function ler,"s"+"__FairysTears_Allocation__allocInit_autoRun")
call Vnx(function lAr,"s"+"__FairysTears_initializer_Init_autoRun")call Vnx(function lBr,"s"+"__FountainOfLifeAndDeath_objInits_autoRun")call Vnx(function lcr,"s"+"__FountainOfLifeAndDeath_Allocation__allocInit_autoRun")call Vnx(function lhr,"s"+"__FountainOfLifeAndDeath_initializer_Init_autoRun")call Vnx(function lJr,"s"+"__FolderDecayAura_StructTarget_objInits_autoRun")
call Vnx(function lkr,"s"+"__FolderDecayAura_StructTarget_Allocation__allocInit_autoRun")call Vnx(function lmr,"s"+"__DecayAura_objInits_autoRun")call Vnx(function lMr,"s"+"__DecayAura_Allocation__allocInit_autoRun")call Vnx(function lUr,"s"+"__DecayAura_initializer_Init_autoRun")call Vnx(function lwr,"s"+"__AIPalingenesis_Allocation__allocInit_autoRun")call Vnx(function l0r,"s"+"__AIPalingenesis_initializer_Init_autoRun")call Vnx(function l3r,"s"+"__Palingenesis_objInits_autoRun")
call Vnx(function l4r,"s"+"__Palingenesis_Allocation__allocInit_autoRun")call Vnx(function Ler,"s"+"__Palingenesis_initializer_Init_autoRun")
call Vnx(function Lrr,"s"+"__FolderGarmentsOfTheSalamander_StructRegen_objInits_autoRun")call Vnx(function Lir,"s"+"__FolderGarmentsOfTheSalamander_StructRegen_Allocation__allocInit_autoRun")call Vnx(function LRr,"s"+"__GarmentsOfTheSalamander_objInits_autoRun")call Vnx(function LIr,"s"+"__GarmentsOfTheSalamander_Allocation__allocInit_autoRun")
call Vnx(function Ljr,"s"+"__GarmentsOfTheSalamander_initializer_Init_autoRun")call Vnx(function LJr,"s"+"__FolderHandOfNature_StructId_Allocation__allocInit_autoRun")
call Vnx(function Lkr,"s"+"__FolderHandOfNature_FolderData_FolderInteger_StructTable_Allocation__allocInit_autoRun")
call Vnx(function LKr,"s"+"__FolderHandOfNature_FolderData_StructInteger_Allocation__allocInit_autoRun")
call Vnx(function Llr,"s"+"__FolderHandOfNature_StructData_Allocation__allocInit_autoRun")call Vnx(function Lmr,"s"+"__FolderHandOfNature_StructPrison_objInits_autoRun")call Vnx(function LMr,"s"+"__FolderHandOfNature_StructPrison_Allocation__allocInit_autoRun")
call Vnx(function Lqr,"s"+"__FolderHandOfNature_FolderRoots_StructBuff_objInits_autoRun")call Vnx(function LQr,"s"+"__FolderHandOfNature_FolderRoots_StructBuff_Allocation__allocInit_autoRun")call Vnx(function Lsr,"s"+"__FolderHandOfNature_StructRoots_objInits_autoRun")call Vnx(function LSr,"s"+"__FolderHandOfNature_StructRoots_Allocation__allocInit_autoRun")call Vnx(function Ltr,"s"+"__FolderHandOfNature_StructNova_objInits_autoRun")call Vnx(function LTr,"s"+"__FolderHandOfNature_StructNova_Allocation__allocInit_autoRun")call Vnx(function L_r,"s"+"__HandOfNature_objInits_autoRun")
call Vnx(function L0r,"s"+"__HandOfNature_Allocation__allocInit_autoRun")call Vnx(function mkr,"s"+"__HandOfNature_initializer_Init_autoRun")
call Vnx(function mLr,"s"+"__FolderSlowPoison_StructTarget_objInits_autoRun")call Vnx(function mmr,"s"+"__FolderSlowPoison_StructTarget_Allocation__allocInit_autoRun")call Vnx(function mPr,"s"+"__SlowPoison_objInits_autoRun")call Vnx(function mqr,"s"+"__SlowPoison_Allocation__allocInit_autoRun")call Vnx(function mZr,"s"+"__SlowPoison_initializer_Init_autoRun")call Vnx(function m1r,"s"+"__FolderHopNDrop_FolderSetMines_StructMine_objInits_autoRun")
call Vnx(function m2r,"s"+"__FolderHopNDrop_FolderSetMines_StructMine_Allocation__allocInit_autoRun")call Vnx(function m5r,"s"+"__FolderHopNDrop_StructSetMines_objInits_autoRun")call Vnx(function m6r,"s"+"__FolderHopNDrop_StructSetMines_Allocation__allocInit_autoRun")call Vnx(function m9r,"s"+"__HopNDrop_objInits_autoRun")
call Vnx(function Mvr,"s"+"__HopNDrop_Allocation__allocInit_autoRun")call Vnx(function MCr,"s"+"__HopNDrop_initializer_Init_autoRun")
call Vnx(function MDr,"s"+"__FolderInfection_StructCone_objInits_autoRun")call Vnx(function Mfr,"s"+"__FolderInfection_StructCone_Allocation__allocInit_autoRun")call Vnx(function MGr,"s"+"__FolderInfection_FolderSummon_StructFuniculusUmbilicalis_objInits_autoRun")call Vnx(function Mhr,"s"+"__FolderInfection_FolderSummon_StructFuniculusUmbilicalis_Allocation__allocInit_autoRun")
call Vnx(function Mmr,"s"+"__FolderInfection_StructSummon_objInits_autoRun")
call Vnx(function MMr,"s"+"__FolderInfection_StructSummon_Allocation__allocInit_autoRun")call Vnx(function Mqr,"s"+"__FolderInfection_StructTarget_objInits_autoRun")
call Vnx(function MQr,"s"+"__FolderInfection_StructTarget_Allocation__allocInit_autoRun")call Vnx(function Mtr,"s"+"__Infection_objInits_autoRun")call Vnx(function MTr,"s"+"__Infection_Allocation__allocInit_autoRun")call Vnx(function pir,"s"+"__Infection_initializer_Init_autoRun")call Vnx(function pVr,"s"+"__FolderKhakiRecovery_StructRestoration_objInits_autoRun")call Vnx(function pEr,"s"+"__FolderKhakiRecovery_StructRestoration_Allocation__allocInit_autoRun")call Vnx(function pAr,"s"+"__KhakiRecovery_objInits_autoRun")call Vnx(function pNr,"s"+"__KhakiRecovery_Allocation__allocInit_autoRun")call Vnx(function psr,"s"+"__KhakiRecovery_initializer_Init_autoRun")call Vnx(function pwr,"s"+"__ManaColossus_objInits_autoRun")
call Vnx(function pWr,"s"+"__ManaColossus_Allocation__allocInit_autoRun")call Vnx(function pzr,"s"+"__ManaColossus_initializer_Init_autoRun")
call Vnx(function p0r,"s"+"__FolderTheurgicVessel_StructTarget_objInits_autoRun")call Vnx(function p1r,"s"+"__FolderTheurgicVessel_StructTarget_Allocation__allocInit_autoRun")call Vnx(function p4r,"s"+"__TheurgicVessel_objInits_autoRun")call Vnx(function p5r,"s"+"__TheurgicVessel_Allocation__allocInit_autoRun")call Vnx(function Pxr,"s"+"__TheurgicVessel_initializer_Init_autoRun")call Vnx(function Pir,"s"+"__FolderManaLaser_StructRevert_objInits_autoRun")
call Vnx(function Par,"s"+"__FolderManaLaser_StructRevert_Allocation__allocInit_autoRun")call Vnx(function PEr,"s"+"__ManaLaser_objInits_autoRun")call Vnx(function PXr,"s"+"__ManaLaser_Allocation__allocInit_autoRun")call Vnx(function PMr,"s"+"__ManaLaser_initializer_Init_autoRun")call Vnx(function PPr,"s"+"__FolderMassMimesis_StructCharm_objInits_autoRun")call Vnx(function Pqr,"s"+"__FolderMassMimesis_StructCharm_Allocation__allocInit_autoRun")call Vnx(function PQr,"s"+"__FolderMassMimesis_StructMissile_objInits_autoRun")call Vnx(function Psr,"s"+"__FolderMassMimesis_StructMissile_Allocation__allocInit_autoRun")
call Vnx(function PTr,"s"+"__MassMimesis_objInits_autoRun")call Vnx(function Pur,"s"+"__MassMimesis_Allocation__allocInit_autoRun")
call Vnx(function qvr,"s"+"__MassMimesis_initializer_Init_autoRun")call Vnx(function qar,"s"+"__MountainKing_objInits_autoRun")
call Vnx(function qnr,"s"+"__MountainKing_Allocation__allocInit_autoRun")call Vnx(function qbr,"s"+"__MountainKing_initializer_Init_autoRun")
call Vnx(function qcr,"s"+"__Thunderbringer_objInits_autoRun")call Vnx(function qCr,"s"+"__Thunderbringer_Allocation__allocInit_autoRun")call Vnx(function qFr,"s"+"__Thunderbringer_initializer_Init_autoRun")call Vnx(function qHr,"s"+"__NegationWave_objInits_autoRun")
call Vnx(function qjr,"s"+"__NegationWave_Allocation__allocInit_autoRun")call Vnx(function qUr,"s"+"__NegationWave_initializer_Init_autoRun")
call Vnx(function qZr,"s"+"__FolderNurturingGrounds_StructEgg_objInits_autoRun")
call Vnx(function q_r,"s"+"__FolderNurturingGrounds_StructEgg_Allocation__allocInit_autoRun")call Vnx(function q1r,"s"+"__NurturingGrounds_objInits_autoRun")
call Vnx(function q2r,"s"+"__NurturingGrounds_Allocation__allocInit_autoRun")call Vnx(function Qcr,"s"+"__NurturingGrounds_initializer_Init_autoRun")
call Vnx(function Qdr,"s"+"__FolderPandaPaw_FolderArrival_StructTarget_objInits_autoRun")call Vnx(function QDr,"s"+"__FolderPandaPaw_FolderArrival_StructTarget_Allocation__allocInit_autoRun")call Vnx(function Qgr,"s"+"__FolderPandaPaw_StructArrival_objInits_autoRun")
call Vnx(function QGr,"s"+"__FolderPandaPaw_StructArrival_Allocation__allocInit_autoRun")call Vnx(function Qjr,"s"+"__FolderPandaPaw_StructLeech_objInits_autoRun")call Vnx(function QJr,"s"+"__FolderPandaPaw_StructLeech_Allocation__allocInit_autoRun")call Vnx(function Qlr,"s"+"__PandaPaw_objInits_autoRun")
call Vnx(function QLr,"s"+"__PandaPaw_Allocation__allocInit_autoRun")call Vnx(function sIr,"s"+"__PandaPaw_initializer_Init_autoRun")
call Vnx(function sNr,"s"+"__FolderPurgingRain_StructWave_objInits_autoRun")
call Vnx(function sbr,"s"+"__FolderPurgingRain_StructWave_Allocation__allocInit_autoRun")call Vnx(function sCr,"s"+"__PurgingRain_objInits_autoRun")call Vnx(function sdr,"s"+"__PurgingRain_Allocation__allocInit_autoRun")
call Vnx(function sPr,"s"+"__PurgingRain_initializer_Init_autoRun")call Vnx(function sQr,"s"+"__FolderRazorBladeDrawBack_StructBlade_objInits_autoRun")
call Vnx(function ssr,"s"+"__FolderRazorBladeDrawBack_StructBlade_Allocation__allocInit_autoRun")call Vnx(function str,"s"+"__RazorBladeDrawBack_objInits_autoRun")call Vnx(function sTr,"s"+"__RazorBladeDrawBack_Allocation__allocInit_autoRun")call Vnx(function sZr,"s"+"__RazorBladeDrawBack_initializer_Init_autoRun")call Vnx(function s1r,"s"+"__FolderRazorBlade_StructVamp_objInits_autoRun")call Vnx(function s2r,"s"+"__FolderRazorBlade_StructVamp_Allocation__allocInit_autoRun")
call Vnx(function s5r,"s"+"__RazorBlade_objInits_autoRun")call Vnx(function s6r,"s"+"__RazorBlade_Allocation__allocInit_autoRun")call Vnx(function S1r,"s"+"__RazorBlade_initializer_Init_autoRun")call Vnx(function S4r,"s"+"__FolderRelentlessShiver_StructBuff_objInits_autoRun")call Vnx(function S5r,"s"+"__FolderRelentlessShiver_StructBuff_Allocation__allocInit_autoRun")call Vnx(function S7r,"s"+"__FolderRelentlessShiver_StructMissile_objInits_autoRun")
call Vnx(function S8r,"s"+"__FolderRelentlessShiver_StructMissile_Allocation__allocInit_autoRun")call Vnx(function tor,"s"+"__RelentlessShiver_objInits_autoRun")
call Vnx(function trr,"s"+"__RelentlessShiver_Allocation__allocInit_autoRun")call Vnx(function tfr,"s"+"__RelentlessShiver_initializer_Init_autoRun")
call Vnx(function tgr,"s"+"__FolderRigorMortis_StructAfterBuff_objInits_autoRun")call Vnx(function tGr,"s"+"__FolderRigorMortis_StructAfterBuff_Allocation__allocInit_autoRun")call Vnx(function tHr,"s"+"__RigorMortis_objInits_autoRun")call Vnx(function tjr,"s"+"__RigorMortis_Allocation__allocInit_autoRun")
call Vnx(function tPr,"s"+"__RigorMortis_initializer_Init_autoRun")call Vnx(function tqr,"s"+"__FolderSakeBomb_StructMissile_objInits_autoRun")
call Vnx(function tQr,"s"+"__FolderSakeBomb_StructMissile_Allocation__allocInit_autoRun")call Vnx(function ttr,"s"+"__SakeBomb_objInits_autoRun")
call Vnx(function tTr,"s"+"__SakeBomb_Allocation__allocInit_autoRun")call Vnx(function t9r,"s"+"__SakeBomb_initializer_Init_autoRun")
call Vnx(function Txr,"s"+"__SanguineEyes_objInits_autoRun")
call Vnx(function Tor,"s"+"__SanguineEyes_Allocation__allocInit_autoRun")call Vnx(function TEr,"s"+"__SanguineEyes_initializer_Init_autoRun")
call Vnx(function TOr,"s"+"__FolderShamanicBubble_StructTarget_objInits_autoRun")call Vnx(function TRr,"s"+"__FolderShamanicBubble_StructTarget_Allocation__allocInit_autoRun")call Vnx(function TAr,"s"+"__FolderShamanicBubble_StructTransition_objInits_autoRun")call Vnx(function TNr,"s"+"__FolderShamanicBubble_StructTransition_Allocation__allocInit_autoRun")call Vnx(function Tcr,"s"+"__ShamanicBubble_objInits_autoRun")call Vnx(function TCr,"s"+"__ShamanicBubble_Allocation__allocInit_autoRun")call Vnx(function Tpr,"s"+"__ShamanicBubble_initializer_Init_autoRun")call Vnx(function Tsr,"s"+"__FolderSleepingDraft_StructBuff_objInits_autoRun")call Vnx(function TSr,"s"+"__FolderSleepingDraft_StructBuff_Allocation__allocInit_autoRun")call Vnx(function Tur,"s"+"__SleepingDraft_objInits_autoRun")call Vnx(function TUr,"s"+"__SleepingDraft_Allocation__allocInit_autoRun")call Vnx(function T7r,"s"+"__SleepingDraft_initializer_Init_autoRun")call Vnx(function T8r,"s"+"__FolderSoberUp_StructHealMissile_objInits_autoRun")call Vnx(function T9r,"s"+"__FolderSoberUp_StructHealMissile_Allocation__allocInit_autoRun")
call Vnx(function uxr,"s"+"__SoberUp_objInits_autoRun")call Vnx(function uor,"s"+"__SoberUp_Allocation__allocInit_autoRun")
call Vnx(function uAr,"s"+"__SoberUp_initializer_Init_autoRun")call Vnx(function uBr,"s"+"__FolderSteelImpalement_StructTarget_objInits_autoRun")call Vnx(function ucr,"s"+"__FolderSteelImpalement_StructTarget_Allocation__allocInit_autoRun")call Vnx(function uDr,"s"+"__SteelImpalement_objInits_autoRun")call Vnx(function ufr,"s"+"__SteelImpalement_Allocation__allocInit_autoRun")
call Vnx(function uPr,"s"+"__SteelImpalement_initializer_Init_autoRun")call Vnx(function uqr,"s"+"__FolderSummonPolarBear_FolderSummon_StructCallback_Allocation__allocInit_autoRun")call Vnx(function uWr,"s"+"__FolderSummonPolarBear_StructSummon_objInits_autoRun")call Vnx(function uyr,"s"+"__FolderSummonPolarBear_StructSummon_Allocation__allocInit_autoRun")call Vnx(function uzr,"s"+"__SummonPolarBear_objInits_autoRun")call Vnx(function uZr,"s"+"__SummonPolarBear_Allocation__allocInit_autoRun")
call Vnx(function UOr,"s"+"__SummonPolarBear_initializer_Init_autoRun")call Vnx(function UIr,"s"+"__ArcticBlink_objInits_autoRun")call Vnx(function UAr,"s"+"__ArcticBlink_Allocation__allocInit_autoRun")
call Vnx(function Ugr,"s"+"__ArcticBlink_initializer_Init_autoRun")call Vnx(function Uhr,"s"+"__Devour_objInits_autoRun")call Vnx(function UHr,"s"+"__Devour_Allocation__allocInit_autoRun")call Vnx(function Ukr,"s"+"__Devour_initializer_Init_autoRun")call Vnx(function ULr,"s"+"__Susanoo_objInits_autoRun")call Vnx(function Umr,"s"+"__Susanoo_Allocation__allocInit_autoRun")
call Vnx(function Uwr,"s"+"__Susanoo_initializer_Init_autoRun")call Vnx(function U_r,"s"+"__Swiftness_objInits_autoRun")call Vnx(function U0r,"s"+"__Swiftness_Allocation__allocInit_autoRun")call Vnx(function U5r,"s"+"__Swiftness_initializer_Init_autoRun")call Vnx(function U8r,"s"+"__FolderTempestStrike_StructCriticalAttacks_objInits_autoRun")call Vnx(function U9r,"s"+"__FolderTempestStrike_StructCriticalAttacks_Allocation__allocInit_autoRun")call Vnx(function wxr,"s"+"__TempestStrike_objInits_autoRun")call Vnx(function wor,"s"+"__TempestStrike_Allocation__allocInit_autoRun")call Vnx(function wIr,"s"+"__TempestStrike_initializer_Init_autoRun")call Vnx(function wAr,"s"+"__FolderTsukuyomi_StructMissile_objInits_autoRun")call Vnx(function wNr,"s"+"__FolderTsukuyomi_StructMissile_Allocation__allocInit_autoRun")call Vnx(function wBr,"s"+"__FolderTsukuyomi_StructRelocate_objInits_autoRun")call Vnx(function wcr,"s"+"__FolderTsukuyomi_StructRelocate_Allocation__allocInit_autoRun")call Vnx(function wdr,"s"+"__FolderTsukuyomi_StructTarget_objInits_autoRun")
call Vnx(function wDr,"s"+"__FolderTsukuyomi_StructTarget_Allocation__allocInit_autoRun")call Vnx(function wgr,"s"+"__Tsukuyomi_objInits_autoRun")call Vnx(function wGr,"s"+"__Tsukuyomi_Allocation__allocInit_autoRun")call Vnx(function wzr,"s"+"__Tsukuyomi_initializer_Init_autoRun")call Vnx(function wZr,"s"+"__FolderWanShroud_StructMissile_objInits_autoRun")call Vnx(function w_r,"s"+"__FolderWanShroud_StructMissile_Allocation__allocInit_autoRun")call Vnx(function w2r,"s"+"__FolderWanShroud_StructTarget_objInits_autoRun")
call Vnx(function w3r,"s"+"__FolderWanShroud_StructTarget_Allocation__allocInit_autoRun")call Vnx(function w5r,"s"+"__WanShroud_objInits_autoRun")call Vnx(function w6r,"s"+"__WanShroud_Allocation__allocInit_autoRun")call Vnx(function Wfr,"s"+"__WanShroud_initializer_Init_autoRun")call Vnx(function WGr,"s"+"__FolderWarcry_StructTarget_objInits_autoRun")call Vnx(function Whr,"s"+"__FolderWarcry_StructTarget_Allocation__allocInit_autoRun")call Vnx(function Wjr,"s"+"__Warcry_objInits_autoRun")call Vnx(function WJr,"s"+"__Warcry_Allocation__allocInit_autoRun")call Vnx(function WQr,"s"+"__Warcry_initializer_Init_autoRun")call Vnx(function WWr,"s"+"__FolderWaterBindings_StructSummon_objInits_autoRun")
call Vnx(function Wyr,"s"+"__FolderWaterBindings_StructSummon_Allocation__allocInit_autoRun")call Vnx(function Wzr,"s"+"__WaterBindings_objInits_autoRun")call Vnx(function WZr,"s"+"__WaterBindings_Allocation__allocInit_autoRun")call Vnx(function W4r,"s"+"__WaterBindings_initializer_Init_autoRun")call Vnx(function W8r,"s"+"__Lariat_objInits_autoRun")call Vnx(function W9r,"s"+"__Lariat_Allocation__allocInit_autoRun")call Vnx(function yar,"s"+"__Lariat_initializer_Init_autoRun")call Vnx(function yRr,"s"+"__FolderSoakingAttack_StructTarget_objInits_autoRun")
call Vnx(function yIr,"s"+"__FolderSoakingAttack_StructTarget_Allocation__allocInit_autoRun")call Vnx(function ybr,"s"+"__SoakingAttack_objInits_autoRun")call Vnx(function yBr,"s"+"__SoakingAttack_Allocation__allocInit_autoRun")call Vnx(function yKr,"s"+"__SoakingAttack_initializer_Init_autoRun")call Vnx(function ymr,"s"+"__FolderZodiacAura_StructTarget_objInits_autoRun")call Vnx(function yMr,"s"+"__FolderZodiacAura_StructTarget_Allocation__allocInit_autoRun")call Vnx(function yqr,"s"+"__ZodiacAura_objInits_autoRun")call Vnx(function yQr,"s"+"__ZodiacAura_Allocation__allocInit_autoRun")call Vnx(function yYr,"s"+"__ZodiacAura_initializer_Init_autoRun")call Vnx(function y_r,"s"+"__Zodiac_objInits_autoRun")call Vnx(function y0r,"s"+"__Zodiac_Allocation__allocInit_autoRun")call Vnx(function y8r,"s"+"__Zodiac_initializer_Init_autoRun")call Vnx(function Yxr,"s"+"__BigHealingWave_objInits_autoRun")call Vnx(function Yor,"s"+"__BigHealingWave_Allocation__allocInit_autoRun")call Vnx(function YNr,"s"+"__BigHealingWave_initializer_Init_autoRun")call Vnx(function Ycr,"s"+"__BurningSpiritMeteorite_objInits_autoRun")call Vnx(function YCr,"s"+"__BurningSpiritMeteorite_Allocation__allocInit_autoRun")call Vnx(function YGr,"s"+"__BurningSpiritMeteorite_initializer_Init_autoRun")call Vnx(function YHr,"s"+"__BurnLumber_objInits_autoRun")call Vnx(function Yjr,"s"+"__BurnLumber_Allocation__allocInit_autoRun")call Vnx(function YLr,"s"+"__BurnLumber_initializer_Init_autoRun")call Vnx(function YMr,"s"+"__CoreFusion_objInits_autoRun")call Vnx(function Ypr,"s"+"__CoreFusion_Allocation__allocInit_autoRun")call Vnx(function YWr,"s"+"__CoreFusion_initializer_Init_autoRun")call Vnx(function YZr,"s"+"__DarkAttack_objInits_autoRun")call Vnx(function Y_r,"s"+"__DarkAttack_Allocation__allocInit_autoRun")call Vnx(function Y8r,"s"+"__DarkAttack_initializer_Init_autoRun")call Vnx(function zvr,"s"+"__FolderFountainAura_StructTarget_objInits_autoRun")call Vnx(function zer,"s"+"__FolderFountainAura_StructTarget_Allocation__allocInit_autoRun")
call Vnx(function zrr,"s"+"__FountainAura_objInits_autoRun")
call Vnx(function zir,"s"+"__FountainAura_Allocation__allocInit_autoRun")call Vnx(function zNr,"s"+"__FountainAura_initializer_Init_autoRun")
call Vnx(function zCr,"s"+"__FountainHeal_objInits_autoRun")
call Vnx(function zdr,"s"+"__FountainHeal_Allocation__allocInit_autoRun")call Vnx(function zlr,"s"+"__FountainHeal_initializer_Init_autoRun")
call Vnx(function zpr,"s"+"__FrostAttack_objInits_autoRun")call Vnx(function zPr,"s"+"__FrostAttack_Allocation__allocInit_autoRun")
call Vnx(function zWr,"s"+"__FrostAttack_initializer_Init_autoRun")call Vnx(function zzr,"s"+"__Invisibility_objInits_autoRun")
call Vnx(function zZr,"s"+"__Invisibility_Allocation__allocInit_autoRun")call Vnx(function z4r,"s"+"__Invisibility_initializer_Init_autoRun")
call Vnx(function z7r,"s"+"__Invulnerability_objInits_autoRun")call Vnx(function z8r,"s"+"__Invulnerability_Allocation__allocInit_autoRun")
call Vnx(function Zrr,"s"+"__Invulnerability_initializer_Init_autoRun")call Vnx(function Zar,"s"+"__FolderLapidation_StructBuff_objInits_autoRun")call Vnx(function Znr,"s"+"__FolderLapidation_StructBuff_Allocation__allocInit_autoRun")
call Vnx(function ZEr,"s"+"__Lapidation_objInits_autoRun")call Vnx(function ZXr,"s"+"__Lapidation_Allocation__allocInit_autoRun")call Vnx(function ZFr,"s"+"__Lapidation_initializer_Init_autoRun")call Vnx(function Zjr,"s"+"__LightningAttack_objInits_autoRun")call Vnx(function ZJr,"s"+"__LightningAttack_Allocation__allocInit_autoRun")
call Vnx(function Zyr,"s"+"__LightningAttack_initializer_Init_autoRun")call Vnx(function ZZr,"s"+"__MagicImmunity_objInits_autoRun")call Vnx(function Z_r,"s"+"__MagicImmunity_Allocation__allocInit_autoRun")call Vnx(function Z3r,"s"+"__MagicImmunity_initializer_Init_autoRun")call Vnx(function Z5r,"s"+"__MeteoriteProtection_objInits_autoRun")call Vnx(function Z6r,"s"+"__MeteoriteProtection_Allocation__allocInit_autoRun")
call Vnx(function Z8r,"s"+"__RefreshMana_objInits_autoRun")call Vnx(function Z9r,"s"+"__RefreshMana_Allocation__allocInit_autoRun")
call Vnx(function vai,"s"+"__RefreshMana_initializer_Init_autoRun")call Vnx(function vVi,"s"+"__FolderRevealAura_StructTarget_objInits_autoRun")call Vnx(function vEi,"s"+"__FolderRevealAura_StructTarget_Allocation__allocInit_autoRun")call Vnx(function vRi,"s"+"__RevealAura_objInits_autoRun")call Vnx(function vIi,"s"+"__RevealAura_Allocation__allocInit_autoRun")call Vnx(function vFi,"s"+"__RevealAura_initializer_Init_autoRun")call Vnx(function vGi,"s"+"__Meteorite_objInits_autoRun")call Vnx(function vhi,"s"+"__Meteorite_Allocation__allocInit_autoRun")call Vnx(function vti,"s"+"__Meteorite_initializer_Init_autoRun")call Vnx(function vTi,"s"+"__Pengu_Allocation__allocInit_autoRun")call Vnx(function vWi,"s"+"__Pengu_initializer_Init_autoRun")call Vnx(function vYi,"s"+"__Sebastian_objInits_autoRun")call Vnx(function vzi,"s"+"__Sebastian_Allocation__allocInit_autoRun")call Vnx(function v0i,"s"+"__Sebastian_initializer_Init_autoRun")call Vnx(function v1i,"s"+"__Loading_Allocation__allocInit_autoRun")
return trueendfunctionfunction v3i takes nothing returns nothingcall Ayx(Od,Rd,Id,Ad)endfunctionfunction v4i takes nothing returns nothingset Bd=AZx(Od,Rd)endfunctionfunction v5i takes nothing returns nothingcall Unx(Od)
endfunctionfunction v6i takes nothing returns nothingcall cmo(Od)
endfunctionfunction v7i takes nothing returns nothingcall MUo(Od,Mxv,Mov,Mrv)
endfunctionfunction v8i takes nothing returns nothingcall Egr(Od,Rd,Id,Ad,nte)endfunctionfunction v9i takes nothing returns nothingcall gxr(Od,Mxv,Mov,Mrv,Rd)endfunctionfunction evi takes nothing returns nothingcall Zsr(Od,Rd,Id,Ad,nte)endfunctionfunction eei takes nothing returns booleanset Nd=CreateTrigger()call TriggerAddCondition(Nd,Condition(function v3i))
set cd=CreateTrigger()call TriggerAddCondition(cd,Condition(function v4i))
set xYv=CreateTrigger()call TriggerAddCondition(xYv,Condition(function v5i))set CDv=CreateTrigger()call TriggerAddCondition(CDv,Condition(function v6i))set Miv=CreateTrigger()call TriggerAddCondition(Miv,Condition(function v7i))set nTe=CreateTrigger()call TriggerAddCondition(nTe,Condition(function v8i))set Fke=CreateTrigger()call TriggerAddCondition(Fke,Condition(function v9i))set xtx=CreateTrigger()call TriggerAddCondition(xtx,Condition(function evi))return trueendfunctionfunction main takes nothing returns nothinglocal weathereffect welocal destructable d
local trigger tlocal real lifelocal integer itemID
call Vnx(function Vrx,"DebugExScope__init_debugInittest")call Vnx(function VVx,"funcsTableInitFunctest")call Vnx(function eei,"evalsInitFunctest")call Vnx(function VEx,"keyMacrosInitFunctest")call Vnx(function v2i,"autoRunsFunctest")set e=CreateTrigger()call TriggerRegisterPlayerChatEvent(e,Player(0),"-a ",false)
call TriggerRegisterPlayerChatEvent(e,Player(0),"-r ",false)
call TriggerAddAction(e,function r3x)set qv=CreateTrigger()call TriggerRegisterPlayerChatEvent(qv,Player(0),"-get ",false)call TriggerAddAction(qv,function ixx)set sv=CreateTrigger()call TriggerRegisterPlayerChatEvent(sv,Player(0),"-add ",false)call TriggerRegisterPlayerChatEvent(sv,Player(0),"-rem ",false)call TriggerAddAction(sv,function irx)set tv=CreateTrigger()call TriggerRegisterPlayerChatEvent(tv,Player(0),"say ",false)call TriggerAddAction(tv,function aax)set me=CreateTrigger()call TriggerRegisterPlayerChatEvent(me,Player(0),"-sethp ",false)call TriggerAddAction(me,function anx)set Pe=CreateTrigger()call TriggerRegisterPlayerChatEvent(Pe,Player(0),"-l ",false)call TriggerAddAction(Pe,function aNx)set Ye=CreateTrigger()call TriggerRegisterPlayerChatEvent(Ye,Player(0),"-take",true)call TriggerAddAction(Ye,function afx)set ax=CreateTrigger()call TriggerRegisterPlayerChatEvent(ax,Player(0),"-rpgcam ",false)call TriggerAddAction(ax,function aFx)call SetCameraBounds(-7680.+GetCameraMargin(CAMERA_MARGIN_LEFT),-7680.+GetCameraMargin(CAMERA_MARGIN_BOTTOM),7680.-GetCameraMargin(CAMERA_MARGIN_RIGHT),7680.-GetCameraMargin(CAMERA_MARGIN_TOP),-7680.+GetCameraMargin(CAMERA_MARGIN_LEFT),7680.-GetCameraMargin(CAMERA_MARGIN_TOP),7680.-GetCameraMargin(CAMERA_MARGIN_RIGHT),-7680.+GetCameraMargin(CAMERA_MARGIN_BOTTOM))call SetDayNightModels("UI\\LightEnvTerrain.mdx","UI\\LightEnvUnit.mdx")
call NewSoundEnvironment("Default")call SetMapMusic("Music",true,0)
set Ex=Rect(-4352.,-896.,4352.,3968.)set Xx=Rect(5056.,-6720.,5184.,-6592.)set Ox=Rect(5056.,-5696.,5184.,-5568.)set Rx=Rect(704.,384.,1152.,832.)set we=AddWeatherEffect(Rx,'FDgh')call EnableWeatherEffect(we,true)set Ix=Rect(-1152.,384.,-704.,832.)set we=AddWeatherEffect(Ix,'FDgh')call EnableWeatherEffect(we,true)set Ax=Rect(-1920.,6112.,-1856.,6176.)set Nx=Rect(-1568.,5824.,-1504.,5888.)set bx=Rect(-1600.,6240.,-1536.,6304.)set Bx=Rect(-2016.,5792.,-1952.,5856.)set cx=Rect(-1792.,6208.,-1728.,6272.)set Cx=Rect(-1152.,5792.,-1088.,5856.)set Dx=Rect(-1152.,5952.,-1088.,6016.)set fx=Rect(-1152.,5632.,-1088.,5696.)set Fx=Rect(2208.,5408.,2272.,5472.)
set gx=Rect(2208.,4768.,2272.,4832.)
set Gx=Rect(1760.,4704.,1824.,4768.)
set hx=Rect(2656.,4704.,2720.,4768.)
set Hx=Rect(2912.,5952.,2976.,6016.)
set jx=Rect(2944.,5312.,3008.,5376.)
set Jx=Rect(2560.,5216.,2624.,5280.)
set kx=Rect(1856.,5216.,1920.,5280.)
set Kx=Rect(2016.,5344.,2080.,5408.)
set lx=Rect(2400.,5344.,2464.,5408.)
set Lx=Rect(3136.,5024.,3200.,5088.)
set mx=Rect(1120.,4672.,1184.,4736.)
set Mx=Rect(1696.,4864.,1760.,4928.)
set px=Rect(-704.,-6784.,32.,-5984.)
set Px=Rect(-640.,1152.,640.,2432.)set qx=Rect(-320.,3424.,288.,4000.)set Qx=Rect(-7648.,1600.,-7040.,2304.)set sx=Rect(7008.,1344.,7616.,2240.)
set Sx=Rect(-768.,-224.,-704.,-160.)
set tx=Rect(704.,-224.,768.,-160.)set Tx=Rect(1024.,3968.,3456.,5632.)
set ux=Rect(3136.,3360.,3296.,3424.)
set we=AddWeatherEffect(ux,'FDrl')call EnableWeatherEffect(we,true)set Ux=Rect(1088.,352.,1184.,448.)set wx=Rect(-4992.,-1216.,-4576.,-832.)set Wx=Rect(5312.,-2272.,6272.,-1568.)set yx=Rect(-6400.,-2208.,-5536.,-1600.)
set Yx=Rect(-800.,5504.,-512.,5792.)
set zx=Rect(512.,5504.,800.,5792.)set Zx=Rect(-1888.,6720.,-1312.,6976.)set vo=Rect(2560.,3168.,2816.,3456.)
set eo=Rect(3808.,-6368.,4672.,-5792.)set xo=Rect(5664.,3968.,5920.,4224.)
set oo=Rect(6592.,4704.,6816.,4928.)
set ro=Rect(6336.,2816.,6560.,3072.)
set io=Rect(1792.,-3328.,2048.,-3072.)set ao=Rect(-3168.,-3200.,-2912.,-2944.)
set no=Rect(-3360.,-3136.,-3104.,-2880.)
set Vo=Rect(-6560.,800.,-6304.,1056.)set Eo=Rect(-6912.,2144.,-6656.,2400.)set Xo=Rect(-5824.,2336.,-5568.,2592.)set Oo=Rect(-992.,-5408.,-736.,-5152.)set Ro=Rect(160.,-6112.,416.,-5856.)
set Io=Rect(704.,-6944.,960.,-6688.)
set Ao=Rect(1408.,-6016.,1664.,-5760.)set No=Rect(-7712.,160.,8192.,4000.)
set bo=Rect(-1216.,-8192.,1216.,160.)set Bo=Rect(-3200.,-960.,-2784.,-576.)set co=Rect(-1760.,-1600.,-1344.,-1216.)
set Co=Rect(1472.,-1664.,1888.,-1280.)set do=Rect(3008.,-1184.,3424.,-800.)set Do=Rect(4544.,-2848.,4960.,-2464.)set fo=Rect(-2016.,5984.,-1952.,6048.)set Fo=Rect(-1984.,5632.,-1920.,5696.)set go=Rect(-384.,1408.,384.,2176.)set Go=Rect(-4096.,1536.,-3712.,2048.)set ho=Rect(3584.,1536.,3968.,2048.)
set Ho=Rect(-256.,-832.,256.,-448.)set jo=Rect(-1024.,3968.,1024.,6336.)set Jo=CreateCameraSetup()call CameraSetupSetField(Jo,CAMERA_FIELD_ZOFFSET,.0,.0)call CameraSetupSetField(Jo,CAMERA_FIELD_ROTATION,90.,.0)call CameraSetupSetField(Jo,CAMERA_FIELD_ANGLE_OF_ATTACK,304.,.0)call CameraSetupSetField(Jo,CAMERA_FIELD_TARGET_DISTANCE,2923.1,.0)call CameraSetupSetField(Jo,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(Jo,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)call CameraSetupSetField(Jo,CAMERA_FIELD_FARZ,5000.,.0)call CameraSetupSetDestPosition(Jo,.0,1792.,.0)set ko=CreateCameraSetup()call CameraSetupSetField(ko,CAMERA_FIELD_ZOFFSET,.0,.0)call CameraSetupSetField(ko,CAMERA_FIELD_ROTATION,247.8,.0)call CameraSetupSetField(ko,CAMERA_FIELD_ANGLE_OF_ATTACK,332.4,.0)call CameraSetupSetField(ko,CAMERA_FIELD_TARGET_DISTANCE,1127.,.0)call CameraSetupSetField(ko,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(ko,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)call CameraSetupSetField(ko,CAMERA_FIELD_FARZ,5000.,.0)call CameraSetupSetDestPosition(ko,2190.2,4567.3,.0)
set Ko=CreateCameraSetup()call CameraSetupSetField(Ko,CAMERA_FIELD_ZOFFSET,.0,.0)call CameraSetupSetField(Ko,CAMERA_FIELD_ROTATION,128.9,.0)call CameraSetupSetField(Ko,CAMERA_FIELD_ANGLE_OF_ATTACK,335.8,.0)call CameraSetupSetField(Ko,CAMERA_FIELD_TARGET_DISTANCE,525.7,.0)call CameraSetupSetField(Ko,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(Ko,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)call CameraSetupSetField(Ko,CAMERA_FIELD_FARZ,5000.,.0)call CameraSetupSetDestPosition(Ko,1801.1,5290.,.0)set lo=CreateCameraSetup()call CameraSetupSetField(lo,CAMERA_FIELD_ZOFFSET,.0,.0)call CameraSetupSetField(lo,CAMERA_FIELD_ROTATION,99.3,.0)call CameraSetupSetField(lo,CAMERA_FIELD_ANGLE_OF_ATTACK,328.4,.0)call CameraSetupSetField(lo,CAMERA_FIELD_TARGET_DISTANCE,578.3,.0)call CameraSetupSetField(lo,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(lo,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)call CameraSetupSetField(lo,CAMERA_FIELD_FARZ,5000.,.0)call CameraSetupSetDestPosition(lo,2041.2,5365.6,.0)
set Lo=CreateCameraSetup()call CameraSetupSetField(Lo,CAMERA_FIELD_ZOFFSET,.0,.0)call CameraSetupSetField(Lo,CAMERA_FIELD_ROTATION,100.6,.0)call CameraSetupSetField(Lo,CAMERA_FIELD_ANGLE_OF_ATTACK,322.6,.0)call CameraSetupSetField(Lo,CAMERA_FIELD_TARGET_DISTANCE,846.7,.0)call CameraSetupSetField(Lo,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(Lo,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)call CameraSetupSetField(Lo,CAMERA_FIELD_FARZ,5000.,.0)call CameraSetupSetDestPosition(Lo,2089.8,5374.8,.0)
set mo=CreateCameraSetup()call CameraSetupSetField(mo,CAMERA_FIELD_ZOFFSET,.0,.0)call CameraSetupSetField(mo,CAMERA_FIELD_ROTATION,135.9,.0)call CameraSetupSetField(mo,CAMERA_FIELD_ANGLE_OF_ATTACK,348.2,.0)call CameraSetupSetField(mo,CAMERA_FIELD_TARGET_DISTANCE,636.2,.0)call CameraSetupSetField(mo,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(mo,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)call CameraSetupSetField(mo,CAMERA_FIELD_FARZ,5000.,.0)call CameraSetupSetDestPosition(mo,2020.8,5276.,.0)set Mo=CreateCameraSetup()call CameraSetupSetField(Mo,CAMERA_FIELD_ZOFFSET,.0,.0)call CameraSetupSetField(Mo,CAMERA_FIELD_ROTATION,97.4,.0)call CameraSetupSetField(Mo,CAMERA_FIELD_ANGLE_OF_ATTACK,336.4,.0)call CameraSetupSetField(Mo,CAMERA_FIELD_TARGET_DISTANCE,846.7,.0)call CameraSetupSetField(Mo,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(Mo,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)call CameraSetupSetField(Mo,CAMERA_FIELD_FARZ,5000.,.0)call CameraSetupSetDestPosition(Mo,2106.9,5300.4,.0)
set po=CreateCameraSetup()call CameraSetupSetField(po,CAMERA_FIELD_ZOFFSET,.0,.0)call CameraSetupSetField(po,CAMERA_FIELD_ROTATION,94.8,.0)call CameraSetupSetField(po,CAMERA_FIELD_ANGLE_OF_ATTACK,334.7,.0)call CameraSetupSetField(po,CAMERA_FIELD_TARGET_DISTANCE,846.7,.0)call CameraSetupSetField(po,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(po,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)call CameraSetupSetField(po,CAMERA_FIELD_FARZ,5000.,.0)call CameraSetupSetDestPosition(po,2172.6,5304.4,.0)
set Po=CreateCameraSetup()call CameraSetupSetField(Po,CAMERA_FIELD_ZOFFSET,.0,.0)call CameraSetupSetField(Po,CAMERA_FIELD_ROTATION,58.4,.0)call CameraSetupSetField(Po,CAMERA_FIELD_ANGLE_OF_ATTACK,327.2,.0)call CameraSetupSetField(Po,CAMERA_FIELD_TARGET_DISTANCE,846.7,.0)call CameraSetupSetField(Po,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(Po,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)call CameraSetupSetField(Po,CAMERA_FIELD_FARZ,5000.,.0)call CameraSetupSetDestPosition(Po,3204.7,5098.2,.0)
set qo=CreateCameraSetup()call CameraSetupSetField(qo,CAMERA_FIELD_ZOFFSET,.0,.0)call CameraSetupSetField(qo,CAMERA_FIELD_ROTATION,69.2,.0)call CameraSetupSetField(qo,CAMERA_FIELD_ANGLE_OF_ATTACK,325.5,.0)call CameraSetupSetField(qo,CAMERA_FIELD_TARGET_DISTANCE,931.4,.0)call CameraSetupSetField(qo,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(qo,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)call CameraSetupSetField(qo,CAMERA_FIELD_FARZ,5000.,.0)call CameraSetupSetDestPosition(qo,3078.6,5167.7,.0)
set Qo=CreateCameraSetup()call CameraSetupSetField(Qo,CAMERA_FIELD_ZOFFSET,.0,.0)call CameraSetupSetField(Qo,CAMERA_FIELD_ROTATION,45.8,.0)call CameraSetupSetField(Qo,CAMERA_FIELD_ANGLE_OF_ATTACK,330.6,.0)call CameraSetupSetField(Qo,CAMERA_FIELD_TARGET_DISTANCE,1239.7,.0)call CameraSetupSetField(Qo,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(Qo,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)call CameraSetupSetField(Qo,CAMERA_FIELD_FARZ,5000.,.0)call CameraSetupSetDestPosition(Qo,2045.9,4927.9,.0)
set so=CreateCameraSetup()call CameraSetupSetField(so,CAMERA_FIELD_ZOFFSET,.0,.0)call CameraSetupSetField(so,CAMERA_FIELD_ROTATION,63.6,.0)call CameraSetupSetField(so,CAMERA_FIELD_ANGLE_OF_ATTACK,291.5,.0)call CameraSetupSetField(so,CAMERA_FIELD_TARGET_DISTANCE,3215.4,.0)call CameraSetupSetField(so,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(so,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)call CameraSetupSetField(so,CAMERA_FIELD_FARZ,5000.,.0)call CameraSetupSetDestPosition(so,2138.4,4966.5,.0)
set So=CreateCameraSetup()call CameraSetupSetField(So,CAMERA_FIELD_ZOFFSET,.0,.0)call CameraSetupSetField(So,CAMERA_FIELD_ROTATION,90.,.0)call CameraSetupSetField(So,CAMERA_FIELD_ANGLE_OF_ATTACK,304.,.0)call CameraSetupSetField(So,CAMERA_FIELD_TARGET_DISTANCE,1650.,.0)call CameraSetupSetField(So,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(So,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)call CameraSetupSetField(So,CAMERA_FIELD_FARZ,5000.,.0)call CameraSetupSetDestPosition(So,.0,.0,.0)
set to=CreateCameraSetup()call CameraSetupSetField(to,CAMERA_FIELD_ZOFFSET,.0,.0)call CameraSetupSetField(to,CAMERA_FIELD_ROTATION,309.3,.0)call CameraSetupSetField(to,CAMERA_FIELD_ANGLE_OF_ATTACK,328.8,.0)call CameraSetupSetField(to,CAMERA_FIELD_TARGET_DISTANCE,2657.3,.0)call CameraSetupSetField(to,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(to,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)call CameraSetupSetField(to,CAMERA_FIELD_FARZ,5000.,.0)call CameraSetupSetDestPosition(to,-5540.3,-6175.3,.0)set To=CreateCameraSetup()call CameraSetupSetField(To,CAMERA_FIELD_ZOFFSET,.0,.0)call CameraSetupSetField(To,CAMERA_FIELD_ROTATION,86.6,.0)call CameraSetupSetField(To,CAMERA_FIELD_ANGLE_OF_ATTACK,270.,.0)call CameraSetupSetField(To,CAMERA_FIELD_TARGET_DISTANCE,1996.5,.0)call CameraSetupSetField(To,CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(To,CAMERA_FIELD_FIELD_OF_VIEW,70.,.0)call CameraSetupSetField(To,CAMERA_FIELD_FARZ,5000.,.0)call CameraSetupSetDestPosition(To,24.,6408.5,.0)set uo=CreateDestructable('C005',3328.,4992.,90.,1.,0)set Uo=CreateDestructable('C00H',-3136.,-3584.,270.,1.,0)set wo=CreateDestructable('C00H',-6976.,2560.,270.,1.,0)
set Wo=CreateDestructable('C00H',-3392.,-3520.,270.,1.,0)set yo=CreateDestructable('C00H',-6720.,960.,270.,1.,0)set Yo=CreateDestructable('C00H',-5888.,3008.,270.,1.,0)
set zo=CreateDestructable('C00H',-1216.,-5120.,270.,1.,0)set Zo=CreateDestructable('C00H',1280.,-7104.,270.,1.,0)
set vr=CreateDestructable('C00H',1216.,-5632.,270.,1.,0)
set er=CreateDestructable('C00H',576.,-5632.,270.,1.,0)set xr=CreateDestructable('C00H',1984.,-3840.,270.,1.,0)
set rr=CreateDestructable('C00H',6784.,5056.,270.,1.,0)set ir=CreateDestructable('C00H',6720.,2816.,270.,1.,0)set ar=CreateDestructable('C00H',5504.,4352.,270.,1.,0)call CreateItem('IRun',3.2,4995.9)call CreateItem('ISno',6004.3,2240.)
call CreateItem('ISno',-6400.1,1533.)call CreateItem('ISno',4.6,-2574.6)call ahx()call aHx()call ajx()call aJx()call akx(function n0x)call aKx("init ok")endfunction