scope Constants
    globals
        constant integer ARRAY_MAX = 8191
        constant integer ARRAY_MIN = 0
        constant integer ARRAY_SIZE = 8192
        constant integer COMMAND_FIELD_SIZE = 12
        constant boolean DEBUG = true
        constant integer FRAMES_PER_SECOND_AMOUNT = 64
        constant integer FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT = 32
        constant real INFINITE_DURATION = -1.
        constant integer MAX_INVENTORY_SIZE = 6
        constant integer STRUCT_MAX = 8190
        constant integer STRUCT_MIN = 1
        constant integer ARRAY_EMPTY = ARRAY_MIN - 1
        constant real FRAME_UPDATE_TIME = 1. / FRAMES_PER_SECOND_AMOUNT
        constant integer STRUCT_BASE = STRUCT_MAX + 1
        constant integer STRUCT_EMPTY = STRUCT_MIN - 1
        constant integer NULL = STRUCT_EMPTY
        constant integer STRUCT_INVALID = STRUCT_EMPTY - 1
        constant real WORLD_MAX_X = 8192
        constant real WORLD_MIN_X = -8192
        constant real WORLD_MAX_Y = 8192
        constant real WORLD_MIN_Y = -8192
    endglobals
endscope
function GetExpiredTimerSafe takes nothing returns timer
	if (GetTriggerEventId() != null) then
		return null
	endif
	return GetExpiredTimer()
endfunction
scope DebugExScope
    globals
        boolean DEBUG_EX_ON = true
        integer DEBUG_EX_COUNT = 0
        integer DEBUG_EX_COUNT_MAX_PER_FILE = 500
        timer DEBUG_EX_TIMER = CreateTimer()
        integer SESSION_ID = -1
    endglobals
    function DebugMsg takes string s returns nothing
        call DisplayTimedTextToPlayer(GetLocalPlayer(), 0., 0., 10., s)
    endfunction
    function GetDebugTime takes nothing returns real
        return TimerGetElapsed(DEBUG_EX_TIMER)
    endfunction
    function OutputLine takes string s returns nothing
        set DEBUG_EX_COUNT = DEBUG_EX_COUNT + 1
        if ((DEBUG_EX_COUNT div DEBUG_EX_COUNT_MAX_PER_FILE) != ((DEBUG_EX_COUNT - 1) div DEBUG_EX_COUNT_MAX_PER_FILE)) then
            call PreloadGenClear()
        endif
		set s = "#" + I2S(DEBUG_EX_COUNT) + " (" + R2S(GetDebugTime()) + "): " + s
		local string s2 = "\")" + s
		if (StringLength(s2) > 259) then
			local integer length = StringLength(s)
			local integer c = length div 257 + 1
			local integer i = 1
			call Preload("\")" + ":cmd mergeLines=" + I2S(c))
			loop
				exitwhen (i > c)
				if (i == c) then
					call Preload("\")" + SubString(s, (i - 1) * 257, length))
				else
					call Preload("\")" + SubString(s, (i - 1) * 257, i * 257 + 1))
				endif
				set i = i + 1
			endloop
		else
			call Preload(s2)
		endif
        call PreloadGenEnd("Logs\\Defend Wintercastle\\Session" + I2S(SESSION_ID) + "\\DWC_Errors_" + I2S(DEBUG_EX_COUNT div DEBUG_EX_COUNT_MAX_PER_FILE) + ".txt")
    endfunction
    function InfoEx takes string s returns nothing
        local boolean isDebugPlayer = true
        if (s == null) then
            set s = "null"
        endif
        if not isDebugPlayer then
            return
        endif
        call OutputLine("[INFO] " + s)
    endfunction
    function Debug takes string s returns nothing
        local boolean isDebugPlayer = true
        if (s == null) then
            set s = "null"
        endif
        
        if isDebugPlayer then
            
        endif
        
            
        
        if not isDebugPlayer then
            return
        endif
        call OutputLine("[DEBUG] " + s)
    endfunction
	globals
		string array DEBUG_BUFFER
		integer DEBUG_BUFFER_COUNT = ARRAY_EMPTY
		integer DEBUG_BUFFER_NESTING = 0
	endglobals
	function DebugBuffer takes string s returns nothing
		set DEBUG_BUFFER_COUNT = DEBUG_BUFFER_COUNT + 1
		set DEBUG_BUFFER[DEBUG_BUFFER_COUNT] = s
	endfunction
	function DebugBufferFinish takes nothing returns nothing
		local integer i = DEBUG_BUFFER_COUNT - 1
		local string s
		set DEBUG_BUFFER_NESTING = DEBUG_BUFFER_NESTING - 1
		if (DEBUG_BUFFER_NESTING > 0) then
			return
		endif
		if (DEBUG_BUFFER_COUNT < ARRAY_MIN) then
			return
		endif
 		set s = DEBUG_BUFFER[DEBUG_BUFFER_COUNT]
		set DEBUG_BUFFER_COUNT = ARRAY_EMPTY
		loop
			exitwhen (i < ARRAY_MIN)
			set s = DEBUG_BUFFER[i] + Char.BREAK + Char.TAB + s
			set i = i - 1
		endloop
		call Debug(s)
	endfunction
	function DebugBufferStart takes nothing returns nothing
		
		set DEBUG_BUFFER_NESTING = DEBUG_BUFFER_NESTING + 1
	endfunction
    function DebugFile takes string path, string s returns nothing
        local boolean isDebugPlayer = true
        if (s == null) then
            set s = "null"
        endif
        if isDebugPlayer then
            
        endif
        
            
        
        if not isDebugPlayer then
            return
        endif
    
    
        set DEBUG_EX_COUNT = DEBUG_EX_COUNT + 1
        call Preload("#" + I2S(DEBUG_EX_COUNT) + " (" + R2S(TimerGetElapsed(DEBUG_EX_TIMER)) + "): " + s)
        call PreloadGenEnd(path)
    endfunction
    private function PreloadBatLine takes string s returns nothing
        call Preload("\")\n" + s + "\nREM (\"")
    endfunction
	globals
		integer array RUN_STACK
		integer RUN_STACK_COUNT = ARRAY_EMPTY
	endglobals
	function GetStackString takes nothing returns string
		local string result = ""
		local integer i = RUN_STACK_COUNT
		if (GetExpiredTimerSafe() != null) then
			set result = "-> " + Timer.GetFromSelf(GetExpiredTimerSafe()).GetName()
		endif
		loop
			exitwhen (i < ARRAY_MIN)
			if (result == "") then
				
				set result = "-> " + Code.GetNameById(RUN_STACK[i])
			else
				
				set result = result + Char.BREAK + "-> " + Code.GetNameById(RUN_STACK[i])
			endif
			set i = i - 1
		endloop
		return "stack trace:" + Char.BREAK + result
	endfunction
	function PrintBufferStack takes nothing returns nothing
		local integer i = RUN_STACK_COUNT
		call DebugBuffer("stack trace:")
		
			
		
		loop
			exitwhen (i < ARRAY_MIN)
			
			call DebugBuffer("-> " + Code.GetNameById(RUN_STACK[i]))
			set i = i - 1
		endloop
	endfunction
	function DecStack takes nothing returns nothing
		set RUN_STACK_COUNT = RUN_STACK_COUNT - 1
	endfunction
	function IncStack takes integer codeId returns nothing
		set RUN_STACK_COUNT = RUN_STACK_COUNT + 1
		set RUN_STACK[RUN_STACK_COUNT] = codeId
	endfunction
	function DebugEx takes string source, string line, string s returns nothing
		call DebugBufferStart()
		call DebugBuffer("---/")
		if (s != null) then
			call DebugBuffer(s)
		endif
		call DebugBuffer("")
		if (source != null) then
			call DebugBuffer("in ->" + source)
		endif
		if (line != null) then
			call DebugBuffer("line ->" + line)
		endif
		call DebugBuffer("")
		call PrintBufferStack()
		call DebugBuffer("/---")
		call DebugBufferFinish()
	endfunction
	function PrintStack takes nothing returns nothing
		call DebugEx(null)
	endfunction
    private function init_debugInit takes nothing returns nothing
        local string prevToDScale = GetPlayerName(GetLocalPlayer())
        call TimerStart(DEBUG_EX_TIMER, 99999, true, null)
        call SetPlayerName(GetLocalPlayer(), I2S(SESSION_ID))
		call PreloadGenClear()
		call Preloader("Logs\\Defend Wintercastle\\index.ini")
        set SESSION_ID = S2I(GetPlayerName(GetLocalPlayer())) + 1
        call PreloadGenClear()
        call PreloadGenStart()
        call Preload("\")\n" + "call SetPlayerName(GetLocalPlayer(), \"" + I2S(SESSION_ID) + "\")" + "\ncall Preload(\"")
        call SetPlayerName(GetLocalPlayer(), prevToDScale)
        call PreloadGenEnd("Logs\\Defend Wintercastle\\index.ini")
        call PreloadGenEnd("Logs\\Defend Wintercastle\\signal.ini")
        call PreloadGenClear()
        call PreloadBatLine("DEL \"DWC_Errors.txt\"")
        call PreloadBatLine("DEL takeFile.bat")
        call PreloadBatLine("echo	set file=%%~1>>takeFile.bat")
        call PreloadBatLine("echo	echo %%file%%>>takeFile.bat")
        call PreloadBatLine("echo	for /f \"tokens=*\" %%%%A in (%%file%%) do (call takeLine.bat \"%%%%A\")>>takeFile.bat")
        call PreloadBatLine("REM echo	DEL %%file%%>>takeFile.bat")
        call PreloadBatLine("DEL takeLine.bat")
        call PreloadBatLine("echo	set txt=%%1>>takeLine.bat")
        call PreloadBatLine("echo	set txt=%%txt:call Preload( ^\"^\")=%%>>takeLine.bat")
        call PreloadBatLine("echo	IF %%txt%%==%%1 goto :eof>>takeLine.bat")
        call PreloadBatLine("echo	set txt=%%txt:^\" )=%%>>takeLine.bat")
        call PreloadBatLine("echo	set txt=%%txt:^|=^^^^^^^|%%>>takeLine.bat")
        call PreloadBatLine("echo	set txt=%%txt:^>=^^^^^^^>%%>>takeLine.bat")
        call PreloadBatLine("echo	set txt=%%txt:^\"='%%>>takeLine.bat")
        call PreloadBatLine("echo	IF \"%%txt%%\"==\"\" goto :eof>>takeLine.bat")
        call PreloadBatLine("echo	echo %%txt%%^>^>DWC_Errors.txt>>takeLine.bat")
        call PreloadBatLine("pause")
        call PreloadBatLine("for /f %%f in ('dir /b /od \"DWC_Errors_*.txt\"') do (call takeFile.bat \"%%f\")")
        call PreloadBatLine("DEL takeFile.bat")
        call PreloadBatLine("DEL takeLine.bat")
        call PreloadGenEnd("Logs\\Defend Wintercastle\\Session" + I2S(SESSION_ID) + "\\DWC_Errors_MergeLogs.bat")
        call PreloadGenClear()
        call InfoEx("private session "+I2S(SESSION_ID))
		call Basic.Init()
    endfunction
endscope
struct Basic
    static integer ALLOCATED_OBJS_COUNT = 0
    static integer NATIVE_OBJS_COUNT = 0
	static multiboard ALLOC_MB
    static method onRemoveUnit takes unit u returns nothing
        if (u == null) then
                call DebugEx("Basic.onRemoveUnit: invalid unit")
            return
        endif
        set thistype.NATIVE_OBJS_COUNT = thistype.NATIVE_OBJS_COUNT - 1
    endmethod
    static method onCreateUnit takes player p, integer id, real x, real y, real z returns nothing
        set thistype.NATIVE_OBJS_COUNT = thistype.NATIVE_OBJS_COUNT + 1
    endmethod
	static hashtable STRUCT_TABLE = null
	static integer STRUCT_ALLOC_COUNT_RESULT
	static string array STRUCT_NAMES
	static integer STRUCT_NAMES_COUNT = ARRAY_EMPTY
	static method GetStructAllocCount takes string name returns integer
		local trigger t = LoadTriggerHandle(thistype.STRUCT_TABLE, 0, StringHash(name))
		if (t == null) then
			return -1
		endif
		set thistype.STRUCT_ALLOC_COUNT_RESULT = -1
		call TriggerEvaluate(t)
		return thistype.STRUCT_ALLOC_COUNT_RESULT
	endmethod
	static method AddStruct takes string name, code allocCountFunc returns nothing
		if (thistype.STRUCT_TABLE == null) then
			set thistype.STRUCT_TABLE = InitHashtable()
		endif
		local trigger t = CreateTrigger()
		call TriggerAddCondition(t, Condition(allocCountFunc))
		call SaveTriggerHandle(thistype.STRUCT_TABLE, 0, StringHash(name), t)
		set t = null
		set thistype.STRUCT_NAMES_COUNT = thistype.STRUCT_NAMES_COUNT + 1
		set thistype.STRUCT_NAMES[thistype.STRUCT_NAMES_COUNT] = name
	endmethod
	
	
	static integer ALLOC_MODULES_COUNT = ARRAY_EMPTY
	static integer ALLOC_MODULES_AMOUNT = 0
	static integer array ALLOC_MODULES_ALLOC_COUNT
	static string array ALLOC_MODULES_NAME
	static integer ALLOC_MODULES_ALLOC_QUEUE_FIRST = ARRAY_EMPTY
	static integer array ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF
	static integer ALLOC_MODULES_ALLOC_QUEUE_LAST = ARRAY_EMPTY
	static integer array ALLOC_MODULES_ALLOC_QUEUE_LAST_OF
	static integer array ALLOC_MODULES_ALLOC_QUEUE_NEXT
	static integer array ALLOC_MODULES_ALLOC_QUEUE_PREV
	integer allocModulesAllocQueue_next
	integer allocModulesAllocQueue_prev
	static trigger GET_ALLOC_MODULE_FROM_QUEUE_EXEC
	static integer GET_ALLOC_MODULE_FROM_QUEUE_ARG_OFFSET
	static integer GET_ALLOC_MODULE_FROM_QUEUE_RETURN
	execMethod GetAllocModuleFromQueue_Exec
		local integer offset = thistype.GET_ALLOC_MODULE_FROM_QUEUE_ARG_OFFSET
		local integer cur = thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST
		set offset = offset - 1
		loop
			exitwhen (offset < ARRAY_MIN)
			set cur = thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[cur]
			set offset = offset - 1
		endloop
		set thistype.GET_ALLOC_MODULE_FROM_QUEUE_RETURN = cur
	endmethod
	static method GetAllocModuleFromQueue takes integer offset returns integer
		set thistype.GET_ALLOC_MODULE_FROM_QUEUE_ARG_OFFSET = offset
		if not TriggerEvaluate(thistype.GET_ALLOC_MODULE_FROM_QUEUE_EXEC) then
			call DebugEx("GetAllocModuleFromQueue: " + "thread broken")
		endif
		return thistype.GET_ALLOC_MODULE_FROM_QUEUE_RETURN
	endmethod
	static method GetAllocModuleAllocCount takes integer index returns integer
		return thistype.ALLOC_MODULES_ALLOC_COUNT[index]
	endmethod
	static method GetAllocModuleName takes integer index returns string
		return thistype.ALLOC_MODULES_NAME[index]
	endmethod
	static method PrintAllocModules takes nothing returns nothing
		local integer cur = thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST
		loop
			exitwhen (cur == ARRAY_EMPTY)
			call DebugEx(thistype.GetAllocModuleName(cur))
			set cur = thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[cur]
		endloop
	endmethod
	static integer ALLOC_DEC_ARG_INDEX
	static trigger ALLOC_DEC_EXEC
	execMethod AllocDec_Exec
		local integer index = thistype.ALLOC_DEC_ARG_INDEX
		local integer oldCount = thistype.ALLOC_MODULES_ALLOC_COUNT[index]
		local integer newCount = oldCount - 1
		if (newCount < 0) then
			call DebugEx("AllocDec: cannot fall below zero")
			return
		endif
		set thistype.ALLOC_MODULES_ALLOC_COUNT[index] = newCount
		local integer firstOf = thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF[oldCount]
		local integer lastOf = thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST_OF[oldCount]
		local integer oldPrev = thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[index]
		local integer oldNext = thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[index]
		local integer newPrev
		if (lastOf == index) then
			if (firstOf == index) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST_OF[oldCount] = ARRAY_EMPTY
			else
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST_OF[oldCount] = oldPrev
			endif
			set newPrev = ARRAY_EMPTY
		else
			set newPrev = lastOf
		endif
		if (firstOf == index) then
			if (lastOf == index) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF[oldCount] = ARRAY_EMPTY
			else
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF[oldCount] = oldNext
			endif
		endif
		if (newPrev != ARRAY_EMPTY) then		
			if (oldNext != ARRAY_EMPTY) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[oldNext] = oldPrev
			endif
			if (oldPrev == ARRAY_EMPTY) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST = oldNext
			else
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[oldPrev] = oldNext
			endif
			local integer newNext = thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[newPrev]
			set thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[index] = newNext
			if (newNext == ARRAY_EMPTY) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST = index
			else
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[newNext] = index
			endif
			set thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[newPrev] = index
			set thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[index] = newPrev
		endif
		if ((index == thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST) or (thistype.ALLOC_MODULES_ALLOC_COUNT[thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[index]] < newCount)) then
			set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST_OF[newCount] = index
		endif
		set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF[newCount] = index
		
        set thistype.ALLOCATED_OBJS_COUNT = thistype.ALLOCATED_OBJS_COUNT - 1
	endmethod
	static method AllocDec takes integer index returns nothing
		set thistype.ALLOC_DEC_ARG_INDEX = index
		if not TriggerEvaluate(thistype.ALLOC_DEC_EXEC) then
			call DebugEx("AllocDec: " + "thread broken")
		endif
	endmethod
	static integer ALLOC_INC_ARG_INDEX
	static trigger ALLOC_INC_EXEC
	execMethod AllocInc_Exec
		local integer index = thistype.ALLOC_INC_ARG_INDEX
		local integer oldCount = thistype.ALLOC_MODULES_ALLOC_COUNT[index]
		local integer newCount = oldCount + 1
		set thistype.ALLOC_MODULES_ALLOC_COUNT[index] = newCount
		local integer firstOf = thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF[oldCount]
		local integer lastOf = thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST_OF[oldCount]
		local integer oldNext = thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[index]
		local integer oldPrev = thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[index]
		local integer newNext
		if (firstOf == index) then
			if (lastOf == index) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF[oldCount] = ARRAY_EMPTY
			else
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF[oldCount] = oldNext
			endif
			set newNext = ARRAY_EMPTY
		else
			set newNext = firstOf
		endif
		if (lastOf == index) then
			if (firstOf == index) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST_OF[oldCount] = ARRAY_EMPTY
			else
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST_OF[oldCount] = oldPrev
			endif
		endif
		if (newNext != ARRAY_EMPTY) then
			if (oldPrev != ARRAY_EMPTY) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[oldPrev] = oldNext
			endif
			if (oldNext == ARRAY_EMPTY) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST = oldPrev
			else
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[oldNext] = oldPrev
			endif
			local integer newPrev = thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[newNext]
			set thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[index] = newPrev
			if (newPrev == ARRAY_EMPTY) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST = index
			else
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[newPrev] = index
			endif
			set thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[newNext] = index
			set thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[index] = newNext
		endif
		if ((index == thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST) or (thistype.ALLOC_MODULES_ALLOC_COUNT[thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[index]] > newCount)) then
			set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF[newCount] = index
		endif
		set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST_OF[newCount] = index
		
        set thistype.ALLOCATED_OBJS_COUNT = thistype.ALLOCATED_OBJS_COUNT + 1
	endmethod
	static method AllocInc takes integer index returns nothing
		set thistype.ALLOC_INC_ARG_INDEX = index
		if not TriggerEvaluate(thistype.ALLOC_INC_EXEC) then
			call DebugEx("AllocInc: " + "thread broken")
		endif
	endmethod
	static method RegAllocModule takes string name returns integer
		set thistype.ALLOC_MODULES_AMOUNT = thistype.ALLOC_MODULES_AMOUNT + 1
		local integer index = thistype.ALLOC_MODULES_COUNT + 1
		set thistype.ALLOC_MODULES_COUNT = index
		set thistype.ALLOC_MODULES_ALLOC_COUNT[index] = 0
		set thistype.ALLOC_MODULES_NAME[index] = name
		if (thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST == ARRAY_EMPTY) then
			set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST = index
			set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF[0] = index
		else
			set thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST] = index
		endif
		set thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[index] = ARRAY_EMPTY
		set thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[index] = thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST
		set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST = index
		set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST_OF[0] = index
		return index
	endmethod
	static method Init takes nothing returns nothing
		set thistype.GET_ALLOC_MODULE_FROM_QUEUE_EXEC = CreateTrigger()
		set thistype.ALLOC_DEC_EXEC = CreateTrigger()
		set thistype.ALLOC_INC_EXEC = CreateTrigger()
		call TriggerAddCondition(thistype.GET_ALLOC_MODULE_FROM_QUEUE_EXEC, function thistype.GetAllocModuleFromQueue_Exec)
		call TriggerAddCondition(thistype.ALLOC_DEC_EXEC, function thistype.AllocDec_Exec)
		call TriggerAddCondition(thistype.ALLOC_INC_EXEC, function thistype.AllocInc_Exec)
	endmethod
endstruct
hook RemoveUnit Basic.onRemoveUnit
hook CreateUnit Basic.onCreateUnit
function B2I takes boolean b returns integer
    if b then
        return 1
    endif
    return 0
endfunction
function B2S takes boolean b returns string
    if b then
        return "true"
    endif
    return "false"
endfunction
struct nest
	method abc takes nothing returns nothing
	endmethod
	struct nest2
		integer nest2_abc
		struct nest3
			integer nest3_abc
			integer nest3_def
		endstruct
		integer nest2_ghi
	endstruct
endstruct
globals
    trigger InitLinks_DUMMY_TRIGGER = CreateTrigger()
    integer InitLinks_ITERATION
    integer InitLinks_THREAD_BREAK_COUNTER
    constant integer InitLinks_THREAD_BREAK_LIMIT = 300
endglobals
struct DataStub
	method Destroy takes nothing returns nothing
	endmethod
endstruct
struct EventStub
	method Destroy takes nothing returns nothing
	endmethod
endstruct
struct IdStub
	method Event_Create takes nothing returns nothing
	endmethod
endstruct
struct rootStruct
	DataStub Data
	EventStub Event
	IdStub Id
endstruct
module Allocation
	
	
	
    private static thistype NEXT = NULL
    private static integer array QUEUED
    private static integer QUEUED_COUNT = 0
   
	
	
	
    private static integer COUNT = STRUCT_EMPTY
    private thistype next
	private static integer ALLOC_MODULE_INDEX
	private static method allocInit_autoRun takes nothing returns nothing
	
		set thistype.ALLOC_MODULE_INDEX = Basic.RegAllocModule(thistype.NAME)
	endmethod
	public boolean allocation_allocated
	public boolean allocation_destroyed
	public integer allocation_refs
	method IsAllocated takes nothing returns boolean
		return this.allocation_allocated
	endmethod
	method CountRefs takes nothing returns integer
		return this.allocation_refs
	endmethod
	method deallocate_demount takes nothing returns nothing
		set this.allocation_allocated = false
		injectTarget hook
		call Basic.AllocDec(thistype.ALLOC_MODULE_INDEX)
	endmethod
    private method deallocCustom_confirm takes nothing returns nothing
		if (this.allocation_refs > 0) then
			return
		endif
        static if DEBUG then
            if (this.next != STRUCT_INVALID) then
                call DebugEx(thistype.NAME + " - alloc: unable to deallocate instance " + I2S(this))
                return
            endif
        endif
        set this.next = thistype(NULL).next
        set thistype(NULL).next = this
		call this.deallocate_demount()
    endmethod
	method subRef takes nothing returns nothing
		set this.allocation_refs = this.allocation_refs - 1
		call this.deallocCustom_confirm()
	endmethod
	method deallocCustom takes nothing returns nothing
		call this.subRef()
	endmethod
	static method allocate_mount takes thistype this returns thistype
		
			
			
		
		set this.allocation_allocated = true
		set this.allocation_destroyed = false
		injectTarget hook
		call Basic.AllocInc(thistype.ALLOC_MODULE_INDEX)
		return this
	endmethod
	method addRef takes nothing returns nothing
		set this.allocation_refs = this.allocation_refs + 1
	endmethod
    static method allocCustom takes nothing returns thistype
        local thistype this
        static if DEBUG then
            if (thistype.QUEUED_COUNT == STRUCT_MAX) then
                call DebugEx(thistype.NAME + " - alloc: unable to allocate, reached stack limit")
                return NULL
            endif
        endif
        if (thistype(NULL).next == NULL) then
            set thistype.COUNT = thistype.COUNT + 1
            set this = thistype.COUNT
        else
            set this = thistype(NULL).next
            set thistype(NULL).next = thistype(NULL).next.next
        endif
        static if DEBUG then
            set this.next = STRUCT_INVALID
        endif
		set this.allocation_refs = 1
		call thistype.allocate_mount(this)
        return this
    endmethod
endmodule
module List
    static thistype array ALL
    static integer ALL_COUNT = ARRAY_EMPTY
    integer index
    method GetIndex takes nothing returns integer
        return this.index - 1
    endmethod
    method GetIndexInList takes nothing returns integer
        return this.index
    endmethod
    method IsInList takes nothing returns boolean
        return (this.GetIndexInList() > ARRAY_MIN)
    endmethod
    static method RandomFromList takes integer lowBound, integer highBound returns thistype
        return thistype.ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    method RemoveFromList takes nothing returns boolean
        local integer index = this.GetIndexInList()
        set thistype.ALL[thistype.ALL_COUNT].index = index
        set thistype.ALL[index - 1] = thistype.ALL[thistype.ALL_COUNT]
        set this.index = ARRAY_MIN
        set thistype.ALL_COUNT = thistype.ALL_COUNT - 1
        return (thistype.ALL_COUNT == ARRAY_EMPTY)
    endmethod
    method RemoveFromListSafe takes nothing returns nothing
        if this.IsInList() then
            call this.RemoveFromList()
        endif
    endmethod
    method RemoveFromListSorted takes nothing returns boolean
        local integer iteration = this.GetIndexInList() - 1
        loop
            exitwhen (iteration == thistype.ALL_COUNT)
            set thistype.ALL[iteration] = thistype.ALL[iteration + 1]
            set thistype.ALL[iteration].index = iteration + 1
            set iteration = iteration + 1
        endloop
        set this.index = ARRAY_MIN
        set thistype.ALL_COUNT = thistype.ALL_COUNT - 1
        return (thistype.ALL_COUNT == ARRAY_EMPTY)
    endmethod
    method AddToList takes nothing returns boolean
        set thistype.ALL_COUNT = thistype.ALL_COUNT + 1
        set thistype.ALL[thistype.ALL_COUNT] = this
        set this.index = thistype.ALL_COUNT + 1
        return (thistype.ALL_COUNT == ARRAY_MIN)
    endmethod
endmodule
struct Queue
    implement Allocation
    
    static key NEXT_KEY_ARRAY_DETAIL_BASE
    static key PREV_KEY_ARRAY_DETAIL_BASE
    static constant integer NEXT_KEY_ARRAY_DETAIL = thistype.NEXT_KEY_ARRAY_DETAIL_BASE * ARRAY_SIZE
    static constant integer PREV_KEY_ARRAY_DETAIL = thistype.PREV_KEY_ARRAY_DETAIL_BASE * ARRAY_SIZE
    integer first
    integer last
    method GetFirst takes nothing returns integer
        return this.first
    endmethod
    method GetLast takes nothing returns integer
        return this.last
    endmethod
    method GetNext takes integer el returns integer
        return Memory.IntegerKeys.GetInteger(el, NEXT_KEY_ARRAY_DETAIL + this)
    endmethod
    method GetPrev takes integer el returns integer
        return Memory.IntegerKeys.GetInteger(el, PREV_KEY_ARRAY_DETAIL + this)
    endmethod
    method IsEmpty takes nothing returns boolean
        return (this.GetFirst() == NULL)
    endmethod
    method Contains takes integer el returns boolean
        if (this.GetFirst() == el) then
            return true
        endif
        if ((this.GetPrev(el) != NULL) or (this.GetNext(el) != NULL)) then
            return true
        endif
        return false
    endmethod
    method Count takes nothing returns integer
        local integer iteration = ARRAY_EMPTY
        local integer el = this.GetFirst()
        loop
            exitwhen (el == NULL)
            set el = this.GetNext(el)
            set iteration = iteration + 1
        endloop
        return iteration
    endmethod
    method GetIndex takes integer el returns integer
        local integer iteration
        if (this.Contains(el) == false) then
            return ARRAY_EMPTY
        endif
        set iteration = ARRAY_MIN
        loop
            set el = this.GetPrev(el)
            exitwhen (el == NULL)
            set iteration = iteration + 1
        endloop
        return iteration
    endmethod
    method FetchFirst takes nothing returns integer
        local integer el = this.GetFirst()
        if (el == NULL) then
            return NULL
        endif
        set this.first = Memory.IntegerKeys.GetInteger(el, NEXT_KEY_ARRAY_DETAIL + this)
        call Memory.IntegerKeys.SetInteger(el, NEXT_KEY_ARRAY_DETAIL + this, NULL)
        if (this.GetFirst() == NULL) then
            set this.last = NULL
        else
            call Memory.IntegerKeys.SetInteger(this.GetFirst(), PREV_KEY_ARRAY_DETAIL + this, NULL)
        endif
        return el
    endmethod
    method Clear takes nothing returns nothing
        loop
            exitwhen (this.FetchFirst() == NULL)
        endloop
    endmethod
    method Remove takes integer el returns boolean
        local integer next
        local integer prev
        if (this.Contains(el) == false) then
            return false
        endif
        if (this.GetFirst() == el) then
            call this.FetchFirst()
            return this.IsEmpty()
        endif
        set next = Memory.IntegerKeys.GetInteger(el, NEXT_KEY_ARRAY_DETAIL + this)
        set prev = Memory.IntegerKeys.GetInteger(el, PREV_KEY_ARRAY_DETAIL + this)
        if (prev != NULL) then
            call Memory.IntegerKeys.SetInteger(el, PREV_KEY_ARRAY_DETAIL + this, NULL)
            call Memory.IntegerKeys.SetInteger(prev, NEXT_KEY_ARRAY_DETAIL + this, next)
        endif
        if (next == NULL) then
            set this.last = prev
        else
            call Memory.IntegerKeys.SetInteger(el, NEXT_KEY_ARRAY_DETAIL + this, NULL)
            call Memory.IntegerKeys.SetInteger(next, PREV_KEY_ARRAY_DETAIL + this, prev)
        endif
        return this.IsEmpty()
    endmethod
    method Add takes integer el returns boolean
        if this.Contains(el) then
            return false
        endif
        call Memory.IntegerKeys.SetInteger(el, NEXT_KEY_ARRAY_DETAIL + this, NULL)
        if this.IsEmpty() then
            set this.first = el
            set this.last = el
            return true
        endif
        call Memory.IntegerKeys.SetInteger(el, PREV_KEY_ARRAY_DETAIL + this, this.GetLast())
        call Memory.IntegerKeys.SetInteger(this.GetLast(), NEXT_KEY_ARRAY_DETAIL + this, el)
        set this.last = el
        return false
    endmethod
    method Print takes nothing returns nothing
        local integer el = this.GetFirst()
        call DebugEx("print queue " + I2S(this) + ":")
        loop
            exitwhen (el == NULL)
            call DebugEx("\t" + I2S(el))
            set el = this.GetNext(el)
        endloop
        call DebugEx("---")
    endmethod
   
    method Destroy takes nothing returns nothing
        call this.Clear()
        call this.deallocate()
    endmethod
    static method Create takes nothing returns thistype
        local thistype this = thistype.allocate()
        set this.first = NULL
        set this.last = NULL
        return this
    endmethod
endstruct
module Name
    static method Name takes nothing returns nothing
    endmethod
    static constant string NAME = "<" + thistype.Name.name + ">"
    static constant string NAME_SHORT = thistype.Name.name
endmodule
globals
    boolean TEMP_BOOLEAN
    boolean TEMP_BOOLEAN2
    boolean TEMP_BOOLEAN3
    boolean TEMP_BOOLEAN4
    integer TEMP_INTEGER
    integer TEMP_INTEGER2
    integer TEMP_INTEGER3
    integer TEMP_INTEGER4
    real TEMP_REAL
    real TEMP_REAL2
    real TEMP_REAL3
    real TEMP_REAL4
    real TEMP_REAL5
    real TEMP_REAL6
endglobals
globals
    boolean exit
endglobals
function Exit takes nothing returns boolean
    return exit
endfunction
function booleanToString takes boolean b returns string
    if (b) then
        return "true"
    endif
    return "false"
endfunction
function integerToString takes integer a returns string
    return I2S(a)
endfunction
function realToString takes real a returns string
    return R2S(a)
endfunction
function stringToString takes string s returns string
    return s
endfunction
function Print takes string s returns nothing
    call DisplayTextToPlayer(GetLocalPlayer(), 0., 0., s)
endfunction
function RenderGraphics takes nothing returns nothing
    
    
    
endfunction
struct ObjThread
    implement Allocation
    implement List
    
    static timer CHECK_TIMER = null
    string name
    method AddMark takes string value returns nothing
        set this.name = this.name + ";" + value
    endmethod
    method Destroy takes nothing returns nothing
        call this.deallocate()
        if this.RemoveFromList() then
            call PauseTimer(thistype.CHECK_TIMER)
        endif
    endmethod
    static method PrintErrors takes nothing returns nothing
        local integer i = thistype.ALL_COUNT
		call DebugBufferStart()
        loop
            exitwhen (i < ARRAY_MIN)
            call DebugBuffer("threadBreak (ObjThread): " + thistype.ALL[i].name)
set DEBUG_EX_ON = false
            call thistype.ALL[i].Destroy()
set DEBUG_EX_ON = true
            set i = i - 1
        endloop
		call DebugBufferFinish()
    endmethod
    static method Create takes string name returns thistype
        local thistype this = thistype.allocate()
        set this.name = name
        if this.AddToList() then
            if (thistype.CHECK_TIMER == null) then
                set thistype.CHECK_TIMER = CreateTimer()
            endif
            call TimerStart(thistype.CHECK_TIMER, 1, true, function thistype.PrintErrors)
        endif
        return this
    endmethod
    static method CreateEx takes string name returns thistype
        call InfoEx("init: " + name)
        return thistype.Create(name)
    endmethod
endstruct
    scope FolderMath
    public struct StructInteger
        implement Allocation
        implement List
        
        static integer MAX = 2147483645
        static integer MIN = -2147483645
    endstruct
    public struct StructHex
        implement Allocation
        implement List
        
        static string array MAP
        static method FromDec takes integer dec returns string
            local string result = ""
            local integer value
            if (dec < 0) then
                return Char.MINUS + thistype.FromDec(-dec)
            endif
            loop
                exitwhen (dec < 16)
                set value = Math.MinI(dec div 16, 15)
                set dec = dec - value * 16
                set result = result + thistype.MAP[value]
            endloop
            return (result + thistype.MAP[dec])
        endmethod
        static method ToDec takes string value returns integer
            local integer length = StringLength(value)
            if (SubString(value, 0, 1) == Char.MINUS) then
                return -thistype.ToDec(SubString(value, 1, length))
            endif
			local integer factor = 1
			local integer iteration = length - 1
			local integer result = 0
            loop
                exitwhen (iteration < 0)
                local string digit = StringCase(SubString(value, iteration, iteration + 1), true)
                local integer mapIndex = 15
                loop
                    exitwhen (digit == thistype.MAP[mapIndex])
                    set mapIndex = mapIndex - 1
                endloop
                set result = result + mapIndex * factor
                set factor = factor * 16
                set iteration = iteration - 1
            endloop
            return result
        endmethod
        static method Add takes string a, string b returns string
            return thistype.FromDec(thistype.ToDec(a) + thistype.ToDec(b))
        endmethod
        static method Subtract takes string a, string b returns string
            return thistype.FromDec(thistype.ToDec(a) - thistype.ToDec(b))
        endmethod
        static method Multiply takes string a, string b returns string
            return thistype.FromDec(thistype.ToDec(a) * thistype.ToDec(b))
        endmethod
        static method Divide takes string a, string b returns string
            return thistype.FromDec(thistype.ToDec(a) div thistype.ToDec(b))
        endmethod
        static method Init takes nothing returns nothing
            set thistype.MAP[0] = "0"
            set thistype.MAP[1] = "1"
            set thistype.MAP[2] = "2"
            set thistype.MAP[3] = "3"
            set thistype.MAP[4] = "4"
            set thistype.MAP[5] = "5"
            set thistype.MAP[6] = "6"
            set thistype.MAP[7] = "7"
            set thistype.MAP[8] = "8"
            set thistype.MAP[9] = "9"
            set thistype.MAP[10] = "A"
            set thistype.MAP[11] = "B"
            set thistype.MAP[12] = "C"
            set thistype.MAP[13] = "D"
            set thistype.MAP[14] = "E"
            set thistype.MAP[15] = "F"
        endmethod
    endstruct
    public struct StructShapes
        implement Allocation
        implement List
        
        static method LinearFromCoords takes real x1, real y1, real x2, real y2, real offset returns real
            local real m = (y2 - y1) / (x2 - x1)
            local real n = y1 - m * x1
            return (m * offset + n)
        endmethod
        static method DistToLineOld takes real sourceX, real sourceY, real length, real angle, real widthStart, real widthEnd, real x, real y returns real
            local real dX = x - sourceX
            local real dY = y - sourceY
            local real angleD = Math.AngleDifSign(angle, Math.AtanByDeltas(dY, dX))
            local real d = Math.DistanceByDeltas(dX, dY)
            local real dLength = Math.Cos(angleD) * d
            local real dWidth = Math.Sin(angleD) * d
            if (dLength < 0.) then
                return Math.DistanceByDeltas(dLength, Math.Max(0., dWidth - widthStart))
            endif
            if (dLength > length) then
                return Math.DistanceByDeltas(dLength - length, Math.Max(0., dWidth - widthEnd))
            endif
            return Math.Max(0., dWidth - (widthStart + (widthEnd - widthStart) * dLength / length))
        endmethod
        static method InLineOld takes real sourceX, real sourceY, real length, real angle, real widthStart, real widthEnd, real x, real y returns boolean
            return (thistype.DistToLineOld(sourceX, sourceY, length, angle, widthStart, widthEnd, x, y) == 0.)
        endmethod
        static method InLine takes real sourceX, real sourceY, real length, real angle, real widthStart, real widthEnd, real x, real y returns boolean
            local real dX = x - sourceX
            local real dY = y - sourceY
            
            local real angleD = Math.AngleDifference(angle, Math.AtanByDeltas(dY, dX))
            local real d = Math.DistanceByDeltas(dX, dY)
            
            local real dLength = Math.Cos(angleD) * d
            local real dWidth = Math.Sin(angleD) * d
            
            local real curWidth = widthStart + (widthEnd - widthStart) * (dLength / length)
            
            if ((dLength >= 0.) and (dLength <= length) and (dWidth <= curWidth)) then
                return true
            endif
            
            return false
        endmethod
        static method DistToLine takes real sourceX, real sourceY, real length, real angle, real widthStart, real widthEnd, real x, real y returns real
            local real dX = x - sourceX
            local real dY = y - sourceY
            local real angleDSigned = Math.AngleDifSign(angle, Math.AtanByDeltas(dY, dX))
            local real d = Math.DistanceByDeltas(dX, dY)
            local real angleD = Math.Abs(angleDSigned)
            local real dirFactor = Math.Sign(angleDSigned)
            local real dLength = Math.Cos(angleD) * d
            local real dWidth = Math.Sin(angleD) * d
            local real angleSlope = Math.AtanByDeltas((widthEnd - widthStart), length)
            local real pSlopeAngle = Math.AtanByDeltas((dWidth - widthStart), dLength)
            local real slopeDSigned = pSlopeAngle - angleSlope
            local real slopeD = Math.Abs(slopeDSigned)
            local real slopeDist = Math.DistanceByDeltas(dWidth - widthStart, dLength)
            if thistype.InLine(sourceX, sourceY, length, angle, widthStart, widthEnd, x, y) then
                return 0.
            endif
            local real slopeFar = Math.Cos(slopeD) * slopeDist
            local real slopeWide = Math.Sin(slopeD) * slopeDist
            local real slopeMax = Math.DistanceByDeltas(widthEnd - widthStart, length)
            if (slopeFar < 0) then
                if (dWidth < widthStart) then
                    return (-dLength)
                endif
                
                return slopeDist
            endif
            
            if (slopeFar > slopeMax) then
                if (dWidth < widthEnd) then
                    return (dLength - length)
                endif
                
                return Math.DistanceByDeltas(slopeFar - slopeMax, slopeWide)
            endif
            
            if (dLength < 0) then
                if (dWidth < widthStart) then
                    return (-dLength)
                endif
                
                return slopeWide
            endif
            
            if (dLength > length) then
                if (dWidth < widthEnd) then
                    return (dLength - length)
                endif
                
                return slopeWide
            endif
            
            return slopeWide
        endmethod
        static method AngleToLine takes real sourceX, real sourceY, real length, real angle, real widthStart, real widthEnd, real x, real y returns real
            local real dX = x - sourceX
            local real dY = y - sourceY
            local real angleDSigned = Math.AngleDifSign(angle, Math.AtanByDeltas(dY, dX))
            local real d = Math.DistanceByDeltas(dX, dY)
            local real angleD = Math.Abs(angleDSigned)
            local real dirFactor = Math.Sign(angleDSigned)
            local real dLength = Math.Cos(angleD) * d
            local real dWidth = Math.Sin(angleD) * d
            local real angleSlope = Math.AtanByDeltas((widthEnd - widthStart), length)
            local real pSlopeAngle = Math.AtanByDeltas((dWidth - widthStart), dLength)
            local real slopeDSigned = pSlopeAngle - angleSlope
            local real slopeD = Math.Abs(slopeDSigned)
            local real slopeDist = Math.DistanceByDeltas(dWidth - widthStart, dLength)
            if thistype.InLine(sourceX, sourceY, length, angle, widthStart, widthEnd, x, y) then
                return 0.
            endif
            local real slopeFar = Math.Cos(slopeD) * slopeDist
            local real slopeWide = Math.Sin(slopeD) * slopeDist
            local real slopeMax = Math.DistanceByDeltas(widthEnd - widthStart, length)
            if (slopeFar < 0) then
                if (dWidth < widthStart) then
                    return angle
                endif
                
                return (angle + (dirFactor * pSlopeAngle + Math.HALF_ANGLE))
            endif
            
            if (slopeFar > slopeMax) then
                if (dWidth < widthEnd) then
                    return (angle + Math.HALF_ANGLE)
                endif
                return (angle + dirFactor * (angleSlope + Math.AtanByDeltas(Math.Sin(slopeDSigned) * slopeDist, slopeFar - slopeMax) + Math.HALF_ANGLE))
            endif
            
            if (dLength < 0) then
                if (dWidth < widthStart) then
                    return angle
                endif
                
                return (angle + dirFactor * (angleSlope - Math.QUARTER_ANGLE))
            endif
            
            if (dLength > length) then
                if (dWidth < widthEnd) then
                    return (angle + Math.HALF_ANGLE)
                endif
                
                return (angle + dirFactor * (angleSlope - Math.QUARTER_ANGLE))
            endif
            
            return (angle + dirFactor * (angleSlope - Math.QUARTER_ANGLE))
        endmethod
		static method TestBoltToLine takes real sourceX, real sourceY, real length, real angle, real widthStart, real widthEnd, real x, real y returns nothing
			local Lightning bolt = Lightning.Create(thistype.TEST_BOLT)
			
			local real angleRes = thistype.AngleToLine(sourceX, sourceY, length, angle, widthStart, widthEnd, x, y)
			local real dist = thistype.DistToLine(sourceX, sourceY, length, angle, widthStart, widthEnd, x, y)
			local real targetX = x + dist * Math.Cos(angleRes)
			local real targetY = y + dist * Math.Sin(angleRes)
			call bolt.Move(x, y, Spot.GetHeight(x, y), targetX, targetY, Spot.GetHeight(targetX, targetY))
			call bolt.DestroyTimed.Start(1.)
		endmethod
        static method InTriangle_Child takes real aX, real aY, real bX, real bY, real cX, real cY returns integer
            return Math.Sign(aX * (bY - cY) + aY * (cX - bX) + bX * cY - bY * cX)
        endmethod
        static method InTriangle takes real aX, real aY, real bX, real bY, real cX, real cY, real x, real y returns boolean
            local real avgX = (aX + bX + cX) / 3
            local real avgY = (aY + bY + cY) / 3
            if (thistype.InTriangle_Child(avgX, avgY, aX, aY, bX, bY) == thistype.InTriangle_Child(x, y, aX, aY, bX, bY)) then
                if (thistype.InTriangle_Child(avgX, avgY, aX, aY, cX, cY) == thistype.InTriangle_Child(x, y, aX, aY, cX, cY)) then
                    if (thistype.InTriangle_Child(avgX, avgY, bX, bY, cX, cY) == thistype.InTriangle_Child(x, y, bX, bY, cX, cY)) then
                        return true
                    endif
                endif
            endif
            return false
        endmethod
        static method InQuadrilateral takes real aX, real aY, real bX, real bY, real cX, real cY, real dX, real dY, real x, real y returns boolean
            if ((Math.AngleBetweenVectors(bX - aX, bY - aY, dX - aX, dY - aY) + Math.AngleBetweenVectors(bX - cX, bY - cY, dX - cX, dY - cY)) > (Math.AngleBetweenVectors(aX - bX, aY - bY, cX - bX, cY - bY) + Math.AngleBetweenVectors(aX - dX, aY - dY, cX - dX, cY - dY))) then
                if (thistype.InTriangle(aX, aY, bX, bY, cX, cY, x, y) or thistype.InTriangle(aX, aY, cX, cY, dX, dY, x, y)) then
                    return true
                endif
            else
                if (thistype.InTriangle(aX, aY, bX, bY, dX, dY, x, y) or thistype.InTriangle(bX, bY, cX, cY, dX, dY, x, y)) then
                    return true
                endif
            endif
            return false
        endmethod
    endstruct
endscope
function Acos_Wrapped takes real x returns real
    return Acos(x)
endfunction
function Atan_Wrapped takes real x returns real
    return Atan(x)
endfunction
function Sin_Wrapped takes real x returns real
    return Sin(x)
endfunction
function Cos_Wrapped takes real x returns real
    return Cos(x)
endfunction
function Tan_Wrapped takes real x returns real
    return Tan(x)
endfunction
    struct Math
    static constant real EPSILON = 0.01
    static integer array LOGS_OF_2I
    static constant integer LOGS_OF_2I_COUNT = 1024
    static constant real PI = 3.141592654
    static constant real DEG_TO_RAD = thistype.PI / 180.
    static constant real DOUBLE_PI = 2 * thistype.PI
    static constant real EAST_ANGLE = 0.
    static constant real FULL_ANGLE = thistype.DOUBLE_PI
    static constant real HALF_ANGLE = thistype.PI
    static constant real HALF_PI = thistype.PI / 2
    static constant real NORTH_ANGLE = 0.5 * thistype.PI
    static integer array POWERS_OF_2I
    static constant integer POWERS_OF_2I_COUNT = 20
    static constant real QUARTER_ANGLE = thistype.HALF_PI
    static constant real RAD_TO_DEG = 180. / thistype.PI
    static constant real SOUTH_ANGLE = 1.5 * thistype.PI
    static constant real WEST_ANGLE = thistype.PI
    static FolderMath_StructInteger Integer = NULL
    static FolderMath_StructHex Hex = NULL
    static FolderMath_StructShapes Shapes = NULL
	static method DivCeilI takes integer a, integer b returns integer
		if (a - a div b * b > 0) then
			return (a div b + 1)
		endif
		return (a div b)
	endmethod
	static method DivideInval takes real a, real b, real c returns real
		if (b == 0) then
			return c
		endif
		return (a / b)
	endmethod
    static method Acos takes real x returns real
        return Acos_Wrapped(x)
    endmethod
    static method Atan takes real x returns real
        return Atan_Wrapped(x)
    endmethod
    static method AtanByDeltas takes real y, real x returns real
        return Atan2(y, x)
    endmethod
    static method Cos takes real x returns real
        return Cos_Wrapped(x)
    endmethod
    static method Sin takes real x returns real
        return Sin_Wrapped(x)
    endmethod
    static method Tan takes real x returns real
        return Tan_Wrapped(x)
    endmethod
    static method Square takes real a returns real
        return (a * a)
    endmethod
    static method Sqrt takes real a returns real
        return SquareRoot(a)
    endmethod
    static method DistanceByDeltas takes real x, real y returns real
        return thistype.Sqrt(x * x + y * y)
    endmethod
    static method DistanceSquareByDeltas takes real x, real y returns real
        return (x * x + y * y)
    endmethod
    static method DistanceByDeltasWithZ takes real x, real y, real z returns real
        return thistype.Sqrt(x * x + y * y + z * z)
    endmethod
    static method DistanceSquareByDeltasWithZ takes real x, real y, real z returns real
        return (x * x + y * y + z * z)
    endmethod
    static method Max takes real a, real b returns real
        if (a > b) then
            return a
        endif
        return b
    endmethod
    static method MaxI takes integer a, integer b returns integer
        return Real.ToInt(thistype.Max(a, b))
    endmethod
    static method Min takes real a, real b returns real
        if (a < b) then
            return a
        endif
        return b
    endmethod
    static method GetMovementDuration takes real distance, real speed, real acceleration returns real
        if (acceleration == 0.) then
            if (speed == 0.) then
                if (distance == 0.) then
                    return 0.
                endif
                return -1.
            endif
            return (distance / speed)
        endif
        local real result = -speed / acceleration - thistype.Sqrt(speed * speed / acceleration / acceleration + 2 * distance / acceleration)
        if (result < 0.) then
            return (-speed / acceleration + thistype.Sqrt(speed * speed / acceleration / acceleration + 2 * distance / acceleration))
        endif
        return result
    endmethod
    static method MinI takes integer a, integer b returns integer
        return Real.ToInt(thistype.Min(a, b))
    endmethod
    static method MinMax takes real a, real b, boolean flag returns real
        if flag then
            return thistype.Max(a, b)
        endif
        return thistype.Min(a, b)
    endmethod
    static method MinMaxI takes integer a, integer b, boolean flag returns integer
        return Real.ToInt(thistype.MinMax(a, b, flag))
    endmethod
    static method Abs takes real a returns real
        if (a < 0) then
            return -a
        endif
        return a
    endmethod
    static method Limit takes real value, real min, real max returns real
        return thistype.Min(thistype.Max(min, value), max)
    endmethod
    static method LimitI takes integer value, integer min, integer max returns integer
        return thistype.MinI(thistype.MaxI(min, value), max)
    endmethod
    static method Compare takes real a, limitop whichOperator, real b returns boolean
        if (whichOperator == LESS_THAN) then
            if (a < b) then
                return true
            endif
        elseif (whichOperator == LESS_THAN_OR_EQUAL) then
            if (a <= b) then
                return true
            endif
        elseif (whichOperator == EQUAL) then
            if (a == b) then
                return true
            endif
        elseif (whichOperator == NOT_EQUAL) then
            if (a != b) then
                return true
            endif
        elseif (whichOperator == GREATER_THAN) then
            if (a > b) then
                return true
            endif
        elseif (whichOperator == GREATER_THAN_OR_EQUAL) then
            if (a >= b) then
                return true
            endif
        endif
        return false
    endmethod
    static method CompareMinMax takes real a, real b, boolean flag returns boolean
        if (flag) then
            if (a > b) then
                return true
            endif
        else
            if (a < b) then
                return true
            endif
        endif
        return false
    endmethod
    static method Linear takes real dX, real dY, real min, real max returns real
        if (dY == 0.) then
            return ((max + min) / 2)
        endif
        return thistype.Limit(min + dX / dY * (max - min), min, max)
    endmethod
    static method RandomI takes integer lowBound, integer highBound returns integer
        return GetRandomInt(lowBound, highBound)
    endmethod
    static method Random takes real lowBound, real highBound returns real
        return GetRandomReal(lowBound, highBound)
    endmethod
    static method RandomLowRange takes real lowBound, real range returns real
        return thistype.Random(lowBound, lowBound + range)
    endmethod
    static method RandomAngle takes nothing returns real
        return thistype.Random(0., thistype.FULL_ANGLE)
    endmethod
    static method Sign takes real a returns integer
        if (a < 0) then
            return -1
        endif
        if (a > 0) then
            return 1
        endif
        return 0
    endmethod
    static method Power takes real base, real exponent returns real
        return Pow(base, exponent)
    endmethod
    static method PowerI takes integer base, integer exponent returns integer
        return Real.ToInt(thistype.Power(base, exponent))
    endmethod
    static method PowerOf2I takes integer exponent returns integer
        if (exponent > thistype.POWERS_OF_2I_COUNT) then
            call Game.DebugMsg("PowerOf2I: " + "index was too HIGH ("+I2S(exponent)+")")
            return thistype.PowerI(exponent, 2)
        endif
        return thistype.POWERS_OF_2I[exponent]
    endmethod
    static method AngleBetweenCoords takes real x1, real y1, real x2, real y2 returns real
        return thistype.AtanByDeltas(y2 - y1, x2 - x1)
    endmethod
    static method AngleBetweenVectors takes real aX, real aY, real bX, real bY returns real
        return thistype.Acos((aX * bX + aY * bY) / (thistype.Sqrt(aX * aX + aY * aY) * thistype.Sqrt(bX * bX + bY * bY)))
    endmethod
    static method Mod takes real dividend, real divisor returns real
        
        
		local real result
        if (divisor == 0) then
            set result = -1
        else
            set result = dividend - Real.ToInt(dividend / divisor) * divisor
            if (result < 0) then
                set result = result + divisor
            endif
        endif
        return result
    endmethod
    static method ModI takes integer dividend, integer divisor returns integer
        return (dividend - dividend div divisor * divisor)
    endmethod
    static method RoundTo_GetDifference takes real dividend, real divisor returns real
        return thistype.Abs(dividend - Real.ToInt(dividend / divisor) * divisor)
    endmethod
    static method RoundTo takes real base, real interval returns real
        if (interval == 0) then
            return 0.
        endif
        local real d = thistype.RoundTo_GetDifference(base, interval)
        local real d2 = thistype.Abs(interval) - d
        if (d2 < d) then
            return (base + thistype.Sign(interval) * d2)
        endif
        return (base - thistype.Sign(interval) * d)
    endmethod
    static method AngleDifference takes real a, real b returns real
        set a = thistype.Mod(a, thistype.FULL_ANGLE)
        set b = thistype.Mod(b, thistype.FULL_ANGLE)
        local real result = thistype.Abs(a - b)
        if (result > thistype.HALF_ANGLE) then
            return (thistype.FULL_ANGLE - result)
        endif
        return result
    endmethod
    static method AngleDifSign takes real source, real target returns real
        local real result = thistype.AngleDifference(source, target)
        set source = thistype.Mod(source, thistype.FULL_ANGLE)
        set target = thistype.Mod(target, thistype.FULL_ANGLE)
        set result = target - source
        if (result > thistype.HALF_ANGLE) then
            return -(thistype.FULL_ANGLE - result)
        endif
        if (result < -thistype.HALF_ANGLE) then
            return (thistype.FULL_ANGLE + result)
        endif
        return result
    endmethod
    static method ApproachAngle takes real source, real target, real delta returns real
        if thistype.AngleDifference(source, target) <= delta then
            return target
        endif
        set source = thistype.Mod(source, thistype.FULL_ANGLE)
        set target = thistype.Mod(target, thistype.FULL_ANGLE)
        local real result = thistype.Abs(target - source)
        if (result > thistype.HALF_ANGLE) then
            set result = source - delta
        else
            set result = source + delta
        endif
    endmethod
    static method CompareAngles takes real a, real b returns boolean
        set a = thistype.Mod(a, thistype.FULL_ANGLE)
        set b = thistype.Mod(b, thistype.FULL_ANGLE)
        if (a < b) then
            return false
        endif
        return true
    endmethod
    static method LimitAngle takes real value, real lowBound, real highBound returns real
        
        
        
        local real valueHighBoundD = thistype.AngleDifference(value, highBound)
        local real valueLowBoundD = thistype.AngleDifference(value, lowBound)
        if (valueLowBoundD + valueHighBoundD - EPSILON > thistype.Abs(highBound - lowBound)) then
            if (valueLowBoundD < valueHighBoundD) then
                return lowBound
            endif
            return highBound
        endif
        return value
    endmethod
    static method Log takes real a, real b returns integer
        if (a == 0) then
            return 0
        endif
        local integer result = 0
        loop
            exitwhen (Pow(b, result / 10.) >= a)
            set result = result + 10
        endloop
        loop
            exitwhen (Pow(b, result / 10.) <= a)
            set result = result - 1
        endloop
        return (result div 10)
    endmethod
    static method LogI takes integer a, integer b returns integer
        return thistype.Log(a, b)
    endmethod
    static method LogOf2I takes integer a returns integer
        if (a > thistype.LOGS_OF_2I_COUNT) then
            
            return thistype.LogI(a, 2)
        endif
        return thistype.LOGS_OF_2I[a]
    endmethod
    static method LogOf2I_Init takes nothing returns nothing
        local integer iteration = TEMP_INTEGER
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.LOGS_OF_2I[iteration] = thistype.LogI(iteration, 2)
            set iteration = iteration - 1
            set TEMP_INTEGER2 = TEMP_INTEGER2 + 1
            exitwhen (TEMP_INTEGER2 > 500)
        endloop
        if (iteration > ARRAY_EMPTY) then
            set TEMP_INTEGER = iteration
            set TEMP_INTEGER2 = 0
            call Code.Run(function thistype.LogOf2I_Init)
        endif
    endmethod
    initMethod Init of Header
        local integer iteration = thistype.POWERS_OF_2I_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.POWERS_OF_2I[iteration] = thistype.PowerI(2, iteration)
            set iteration = iteration - 1
        endloop
        set TEMP_INTEGER = thistype.LOGS_OF_2I_COUNT
        set TEMP_INTEGER2 = 0
        call Code.Run(function thistype.LogOf2I_Init)
        call thistype.Hex.Init()
    endmethod
endstruct
    scope FolderGameCache
    public struct StructBoolean
        implement Allocation
        implement List
        
        static constant boolean DEFAULT_VALUE = false
        method Contains takes string missionKey, string key returns boolean
            return HaveStoredBoolean(GameCache(this).self, missionKey, key)
        endmethod
        method Get takes string missionKey, string key returns boolean
            if ((missionKey == null) or (key == null)) then
                call DebugEx("GameCache Get: "+missionKey+";"+key)
                return false
            endif
            return GetStoredBoolean(GameCache(this).self, missionKey, key)
        endmethod
        method Set takes string missionKey, string key, boolean value returns nothing
            if ((missionKey == null) or (key == null)) then
                call DebugEx("GameCache Set: "+missionKey+";"+key)
                return
            endif
            call StoreBoolean(GameCache(this).self, missionKey, key, value)
        endmethod
        method Remove takes string missionKey, string key returns nothing
            call this.Set(missionKey, key, thistype.DEFAULT_VALUE)
        endmethod
        
        method Sync takes string missionKey, string key returns nothing
        	call SyncStoredBoolean(GameCache(this).self, missionKey, key)
        endmethod
        method SetAndSync takes string missionKey, string key, boolean value returns nothing
        	call this.Set(missionKey, key, value)
        	
        	call this.Sync(missionKey, key)
        endmethod
    endstruct
    public struct StructInteger
        implement Allocation
        implement List
        
        static constant integer DEFAULT_VALUE = 0
        method Contains takes string missionKey, string key returns boolean
            return HaveStoredInteger(GameCache(this).self, missionKey, key)
        endmethod
        method Get takes string missionKey, string key returns integer
            if ((missionKey == null) or (key == null)) then
                call DebugEx("GameCache Get: "+missionKey+";"+key)
                return 0
            endif
            return GetStoredInteger(GameCache(this).self, missionKey, key)
        endmethod
        method Set takes string missionKey, string key, integer value returns nothing
            if ((missionKey == null) or (key == null)) then
                call DebugEx("GameCache Set: "+missionKey+";"+key)
                return
            endif
            call StoreInteger(GameCache(this).self, missionKey, key, value)
        endmethod
        method Remove takes string missionKey, string key returns nothing
            call this.Set(missionKey, key, thistype.DEFAULT_VALUE)
        endmethod
        
        method Sync takes string missionKey, string key returns nothing
        	call SyncStoredInteger(GameCache(this).self, missionKey, key)
        endmethod
        method SetAndSync takes string missionKey, string key, integer value returns nothing
        	call this.Set(missionKey, key, value)
        	
        	call this.Sync(missionKey, key)
        endmethod
    endstruct
    public struct StructReal
        implement Allocation
        implement List
        
        static constant real DEFAULT_VALUE = 0.
        method Contains takes string missionKey, string key returns boolean
            return HaveStoredReal(GameCache(this).self, missionKey, key)
        endmethod
        method Get takes string missionKey, string key returns real
            if ((missionKey == null) or (key == null)) then
                call DebugEx("GameCache Get: "+missionKey+";"+key)
                return 0.
            endif
            return GetStoredReal(GameCache(this).self, missionKey, key)
        endmethod
        method Set takes string missionKey, string key, real value returns nothing
            if ((missionKey == null) or (key == null)) then
                call DebugEx("GameCache Set: "+missionKey+";"+key)
                return
            endif
            call StoreReal(GameCache(this).self, missionKey, key, value)
        endmethod
        method Remove takes string missionKey, string key returns nothing
            call this.Set(missionKey, key, thistype.DEFAULT_VALUE)
        endmethod
        
        method Sync takes string missionKey, string key returns nothing
        	call SyncStoredReal(GameCache(this).self, missionKey, key)
        endmethod
        method SetAndSync takes string missionKey, string key, real value returns nothing
        	call this.Set(missionKey, key, value)
        	
        	call this.Sync(missionKey, key)
        endmethod
    endstruct
    public struct StructString
        implement Allocation
        implement List
        
        static constant string DEFAULT_VALUE = null
        method Contains takes string missionKey, string key returns boolean
            return HaveStoredString(GameCache(this).self, missionKey, key)
        endmethod
        method Get takes string missionKey, string key returns string
            if ((missionKey == null) or (key == null)) then
                call DebugEx("GameCache Get: "+missionKey+";"+key)
                return null
            endif
            return GetStoredString(GameCache(this).self, missionKey, key)
        endmethod
        method Set takes string missionKey, string key, string value returns nothing
            if ((missionKey == null) or (key == null)) then
                call DebugEx("GameCache Set: "+missionKey+";"+key)
                return
            endif
            call StoreString(GameCache(this).self, missionKey, key, value)
        endmethod
        method Remove takes string missionKey, string key returns nothing
            call this.Set(missionKey, key, thistype.DEFAULT_VALUE)
        endmethod
        
        method Sync takes string missionKey, string key returns nothing
        	call SyncStoredString(GameCache(this).self, missionKey, key)
        endmethod
        method SetAndSync takes string missionKey, string key, string value returns nothing
        	call this.Set(missionKey, key, value)
        	
        	call this.Sync(missionKey, key)
        endmethod
    endstruct
endscope
    globals
        GameCache GAME_CACHE = STRUCT_BASE
    endglobals
    struct GameCache
        implement Allocation
        implement List
        
    gamecache self
    FolderGameCache_StructBoolean Boolean = this
    FolderGameCache_StructBoolean LinkToStruct_Boolean
    FolderGameCache_StructInteger Integer = this
    FolderGameCache_StructInteger LinkToStruct_Integer
    FolderGameCache_StructReal Real = this
    FolderGameCache_StructReal LinkToStruct_Real
    FolderGameCache_StructString String = this
    FolderGameCache_StructString LinkToStruct_String
    method RemoveChild takes string missionKey returns nothing
        call FlushStoredMission(this.self, missionKey)
    endmethod
    static method Create takes nothing returns thistype
        local thistype this = thistype.allocate()
        set this.self = InitGameCache("bla")
        return this
    endmethod
endstruct
    scope FolderHashTable
    public struct StructBoolean
        implement Allocation
        implement List
        
        static constant boolean DEFAULT_VALUE = false
        method Contains takes integer missionKey, integer key returns boolean
            
            return (LoadBoolean(HashTable(this).self, missionKey, key) != thistype.DEFAULT_VALUE)
        endmethod
        method Get takes integer missionKey, integer key returns boolean
            return LoadBoolean(HashTable(this).self, missionKey, key)
        endmethod
        method Set takes integer missionKey, integer key, boolean value returns nothing
            call SaveBoolean(HashTable(this).self, missionKey, key, value)
        endmethod
        method Remove takes integer missionKey, integer key returns nothing
            call this.Set(missionKey, key, thistype.DEFAULT_VALUE)
            
        endmethod
    endstruct
    public struct StructInteger
        implement Allocation
        implement List
        
        static constant integer DEFAULT_VALUE = 0
        method Contains takes integer missionKey, integer key returns boolean
            
            return (LoadInteger(HashTable(this).self, missionKey, key) != thistype.DEFAULT_VALUE)
        endmethod
        method Get takes integer missionKey, integer key returns integer
            return LoadInteger(HashTable(this).self, missionKey, key)
        endmethod
        method Set takes integer missionKey, integer key, integer value returns nothing
            call SaveInteger(HashTable(this).self, missionKey, key, value)
        endmethod
        method Remove takes integer missionKey, integer key returns nothing
            call this.Set(missionKey, key, thistype.DEFAULT_VALUE)
            
        endmethod
    endstruct
    public struct StructReal
        implement Allocation
        implement List
        
        static constant real DEFAULT_VALUE = 0.
        method Contains takes integer missionKey, integer key returns boolean
            
            return (LoadReal(HashTable(this).self, missionKey, key) != thistype.DEFAULT_VALUE)
        endmethod
        method Get takes integer missionKey, integer key returns real
            return LoadReal(HashTable(this).self, missionKey, key)
        endmethod
        method Set takes integer missionKey, integer key, real value returns nothing
            call SaveReal(HashTable(this).self, missionKey, key, value)
        endmethod
        method Remove takes integer missionKey, integer key returns nothing
            call this.Set(missionKey, key, thistype.DEFAULT_VALUE)
            
        endmethod
    endstruct
    public struct StructString
        implement Allocation
        implement List
        
        static constant string DEFAULT_VALUE = null
        method Contains takes integer missionKey, integer key returns boolean
            
            return (LoadStr(HashTable(this).self, missionKey, key) != thistype.DEFAULT_VALUE)
        endmethod
        method Get takes integer missionKey, integer key returns string
            return LoadStr(HashTable(this).self, missionKey, key)
        endmethod
        method Set takes integer missionKey, integer key, string value returns nothing
            call SaveStr(HashTable(this).self, missionKey, key, value)
        endmethod
        method Remove takes integer missionKey, integer key returns nothing
            call this.Set(missionKey, key, thistype.DEFAULT_VALUE)
            
        endmethod
    endstruct
endscope
    globals
        HashTable HASH_TABLE = STRUCT_BASE
    endglobals
    struct HashTable
        implement Allocation
        implement List
        
    hashtable self
    FolderHashTable_StructBoolean Boolean = this
    FolderHashTable_StructBoolean LinkToStruct_Boolean
    FolderHashTable_StructInteger Integer = this
    FolderHashTable_StructInteger LinkToStruct_Integer
    FolderHashTable_StructReal Real = this
    FolderHashTable_StructReal LinkToStruct_Real
    FolderHashTable_StructString String = this
    FolderHashTable_StructString LinkToStruct_String
    method RemoveChild takes integer missionKey returns nothing
        call FlushChildHashtable(this.self, missionKey)
    endmethod
    static method Create takes nothing returns thistype
        local thistype this = thistype.allocate()
        set this.self = InitHashtable()
        return this
    endmethod
endstruct
    scope FolderDataTableHead
    scope FolderIntegerKeys
    public struct StructD2
        implement Allocation
        implement List
        
            HashTable CACHE
            static constant integer SIZE = 8192
            static method GetFirstKey takes integer pivotKey, integer subject1, integer subject2 returns integer
                set pivotKey = pivotKey - Math.Integer.MIN
				local integer res = (pivotKey div 64 * SIZE * SIZE + subject1 * SIZE + subject2)
                return res
            endmethod
            static method GetSecondKey takes integer pivotKey, integer subject3, integer subject4 returns integer
                set pivotKey = pivotKey - Math.Integer.MIN
                local integer res = ((pivotKey - pivotKey div 64 * 64) * SIZE * SIZE + subject3 * SIZE + subject4)
                return res
            endmethod
                method ContainsBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return this.CACHE.Boolean.Contains(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method GetBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return this.CACHE.Boolean.Get(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method SetBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, boolean value returns nothing
                    call this.CACHE.Boolean.Set(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4), value)
                endmethod
                method RemoveBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call this.CACHE.Boolean.Remove(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method ContainsBooleanWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return cache.Boolean.Contains(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method GetBooleanWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return cache.Boolean.Get(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method SetBooleanWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, boolean value returns nothing
                    call cache.Boolean.Set(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4), value)
                endmethod
                method RemoveBooleanWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call cache.Boolean.Remove(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method ContainsInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return this.CACHE.Integer.Contains(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method GetInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns integer
                    return this.CACHE.Integer.Get(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method SetInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, integer value returns nothing
                    call this.CACHE.Integer.Set(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4), value)
                endmethod
                method RemoveInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call this.CACHE.Integer.Remove(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method ContainsIntegerWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return cache.Integer.Contains(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method GetIntegerWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns integer
                    return cache.Integer.Get(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method SetIntegerWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, integer value returns nothing
                    call cache.Integer.Set(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4), value)
                endmethod
                method RemoveIntegerWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call cache.Integer.Remove(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method ContainsReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return this.CACHE.Real.Contains(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method GetReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns real
                    return this.CACHE.Real.Get(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method SetReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, real value returns nothing
                    call this.CACHE.Real.Set(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4), value)
                endmethod
                method RemoveReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call this.CACHE.Real.Remove(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method ContainsRealWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return cache.Real.Contains(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method GetRealWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns real
                    return cache.Real.Get(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method SetRealWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, real value returns nothing
                    call cache.Real.Set(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4), value)
                endmethod
                method RemoveRealWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call cache.Real.Remove(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method ContainsString takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return this.CACHE.String.Contains(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method GetString takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns string
                    return this.CACHE.String.Get(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method SetString takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, string value returns nothing
                    call this.CACHE.String.Set(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4), value)
                endmethod
                method RemoveString takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call this.CACHE.String.Remove(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method ContainsStringWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return cache.String.Contains(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method GetStringWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns string
                    return cache.String.Get(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                method SetStringWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, string value returns nothing
                    call cache.String.Set(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4), value)
                endmethod
                method RemoveStringWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call cache.String.Remove(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
			method Event_Create takes nothing returns nothing
				set this.CACHE = HashTable.Create()
			endmethod
        endstruct
    endscope
    public struct StructIntegerKeys
        implement Allocation
        implement List
        
        HashTable CACHE
    FolderIntegerKeys_StructD2 D2 = this
    FolderIntegerKeys_StructD2 LinkToStruct_D2
        method RemoveChild takes integer missionKey returns nothing
            call this.CACHE.RemoveChild(missionKey)
        endmethod
            method ContainsBoolean takes integer missionKey, integer key returns boolean
                return this.CACHE.Boolean.Contains(missionKey, key)
            endmethod
            method GetBoolean takes integer missionKey, integer key returns boolean
                return this.CACHE.Boolean.Get(missionKey, key)
            endmethod
            method GetBooleanByHandle takes handle handleSource, integer key returns boolean
                return this.GetBoolean(GetHandleId(handleSource), key)
            endmethod
            method SetBoolean takes integer missionKey, integer key, boolean value returns nothing
                call this.CACHE.Boolean.Set(missionKey, key, value)
            endmethod
            method SetBooleanByHandle takes handle handleSource, integer key, boolean value returns nothing
                call this.SetBoolean(GetHandleId(handleSource), key, value)
            endmethod
            method RemoveBoolean takes integer missionKey, integer key returns nothing
                call this.CACHE.Boolean.Remove(missionKey, key)
            endmethod
            method RemoveBooleanByHandle takes handle handleSource, integer key returns nothing
                call this.RemoveBoolean(GetHandleId(handleSource), key)
            endmethod
            method ContainsInteger takes integer missionKey, integer key returns boolean
                return this.CACHE.Integer.Contains(missionKey, key)
            endmethod
            method GetInteger takes integer missionKey, integer key returns integer
                return this.CACHE.Integer.Get(missionKey, key)
            endmethod
            method GetIntegerByHandle takes handle handleSource, integer key returns integer
                return this.GetInteger(GetHandleId(handleSource), key)
            endmethod
            method SetInteger takes integer missionKey, integer key, integer value returns nothing
                call this.CACHE.Integer.Set(missionKey, key, value)
            endmethod
            method SetIntegerByHandle takes handle handleSource, integer key, integer value returns nothing
                call this.SetInteger(GetHandleId(handleSource), key, value)
            endmethod
            method RemoveInteger takes integer missionKey, integer key returns nothing
                call this.CACHE.Integer.Remove(missionKey, key)
            endmethod
            method RemoveIntegerByHandle takes handle handleSource, integer key returns nothing
                call this.RemoveInteger(GetHandleId(handleSource), key)
            endmethod
            method ContainsReal takes integer missionKey, integer key returns boolean
                return this.CACHE.Real.Contains(missionKey, key)
            endmethod
            method GetReal takes integer missionKey, integer key returns real
                return this.CACHE.Real.Get(missionKey, key)
            endmethod
            method GetRealByHandle takes handle handleSource, integer key returns real
                return this.GetReal(GetHandleId(handleSource), key)
            endmethod
            method SetReal takes integer missionKey, integer key, real value returns nothing
                call this.CACHE.Real.Set(missionKey, key, value)
            endmethod
            method SetRealByHandle takes handle handleSource, integer key, real value returns nothing
                call this.SetReal(GetHandleId(handleSource), key, value)
            endmethod
            method RemoveReal takes integer missionKey, integer key returns nothing
                call this.CACHE.Real.Remove(missionKey, key)
            endmethod
            method RemoveRealByHandle takes handle handleSource, integer key returns nothing
                call this.RemoveReal(GetHandleId(handleSource), key)
            endmethod
            method ContainsString takes integer missionKey, integer key returns boolean
                return this.CACHE.String.Contains(missionKey, key)
            endmethod
            method GetString takes integer missionKey, integer key returns string
                return this.CACHE.String.Get(missionKey, key)
            endmethod
            method GetStringByHandle takes handle handleSource, integer key returns string
                return this.GetString(GetHandleId(handleSource), key)
            endmethod
            method SetString takes integer missionKey, integer key, string value returns nothing
                call this.CACHE.String.Set(missionKey, key, value)
            endmethod
            method SetStringByHandle takes handle handleSource, integer key, string value returns nothing
                call this.SetString(GetHandleId(handleSource), key, value)
            endmethod
            method RemoveString takes integer missionKey, integer key returns nothing
                call this.CACHE.String.Remove(missionKey, key)
            endmethod
            method RemoveStringByHandle takes handle handleSource, integer key returns nothing
                call this.RemoveString(GetHandleId(handleSource), key)
            endmethod
		method Event_Create takes nothing returns nothing
			set this.CACHE = HashTable.Create()
			call this.D2.Event_Create()
		endmethod
    endstruct
    public struct StructStringKeys
        implement Allocation
        implement List
        
        GameCache CACHE
        method RemoveChild takes string missionKey returns nothing
            call this.CACHE.RemoveChild(missionKey)
        endmethod
            method SetBoolean takes string missionKey, string key, boolean value returns nothing
                call this.CACHE.Boolean.Set(missionKey, key, value)
            endmethod
            method RemoveBoolean takes string missionKey, string key returns nothing
                call this.CACHE.Boolean.Remove(missionKey, key)
            endmethod
            method GetBoolean takes string missionKey, string key returns boolean
                return this.CACHE.Boolean.Get(missionKey, key)
            endmethod
            method SetInteger takes string missionKey, string key, integer value returns nothing
                call this.CACHE.Integer.Set(missionKey, key, value)
            endmethod
            method RemoveInteger takes string missionKey, string key returns nothing
                call this.CACHE.Integer.Remove(missionKey, key)
            endmethod
            method GetInteger takes string missionKey, string key returns integer
                return this.CACHE.Integer.Get(missionKey, key)
            endmethod
            method SetReal takes string missionKey, string key, real value returns nothing
                call this.CACHE.Real.Set(missionKey, key, value)
            endmethod
            method RemoveReal takes string missionKey, string key returns nothing
                call this.CACHE.Real.Remove(missionKey, key)
            endmethod
            method GetReal takes string missionKey, string key returns real
                return this.CACHE.Real.Get(missionKey, key)
            endmethod
            method SetString takes string missionKey, string key, string value returns nothing
                call this.CACHE.String.Set(missionKey, key, value)
            endmethod
            method RemoveString takes string missionKey, string key returns nothing
                call this.CACHE.String.Remove(missionKey, key)
            endmethod
            method GetString takes string missionKey, string key returns string
                return this.CACHE.String.Get(missionKey, key)
            endmethod
		method Event_Create takes nothing returns nothing
			set this.CACHE = GameCache.Create()
		endmethod
    endstruct
endscope
    globals
        DataTableHead DATA_TABLE_HEAD = STRUCT_BASE
    endglobals
    struct DataTableHead
        implement Allocation
        implement List
        
    FolderDataTableHead_StructIntegerKeys IntegerKeys = this
    FolderDataTableHead_StructIntegerKeys LinkToStruct_IntegerKeys
    FolderDataTableHead_StructStringKeys StringKeys = this
    FolderDataTableHead_StructStringKeys LinkToStruct_StringKeys
	static method Create takes nothing returns thistype
		local thistype this = thistype.allocate()
		call this.IntegerKeys.Event_Create()
		call this.StringKeys.Event_Create()
		return this
	endmethod
    static method Init takes nothing returns nothing
    endmethod
endstruct
    scope FolderDataTable
    scope FolderIntegerKeys
    scope FolderD2
    public struct StructTable
        implement Allocation
        implement List
        
                static constant integer EMPTY = HASH_TABLE.Integer.DEFAULT_VALUE
                HashTable FIRST_CACHE
                HashTable LAST_CACHE
                HashTable NEXT_CACHE
                HashTable PREV_CACHE
                HashTable PRIO_CACHE
                    method GetFirstBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns boolean
                        return DataTable(this).Head.IntegerKeys.D2.GetBooleanWithCache(this.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0)
                    endmethod
                    method GetLastBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns boolean
                        return DataTable(this).Head.IntegerKeys.D2.GetBooleanWithCache(this.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0)
                    endmethod
                    method GetNextBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, boolean value returns boolean
                        return DataTable(this).Head.IntegerKeys.D2.GetBooleanWithCache(this.NEXT_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(value))
                    endmethod
                    method GetPrevBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, boolean value returns boolean
                        return DataTable(this).Head.IntegerKeys.D2.GetBooleanWithCache(this.PREV_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(value))
                    endmethod
                    method GetBooleanPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3, boolean value returns integer
                        return DataTable(this).Head.IntegerKeys.D2.GetIntegerWithCache(this.PRIO_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(value))
                    endmethod
                    method GetBooleansMaxPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns integer
                    	local boolean value = this.GetFirstBoolean(pivotKey, subject1, subject2, subject3)
                    	local integer result = 0
                        loop
                            exitwhen (value == HASH_TABLE.Boolean.DEFAULT_VALUE)
                            local integer prio = this.GetBooleanPrio(pivotKey, subject1, subject2, subject3, value)
                            if (prio > result) then
                                set result = prio
                            endif
                            set value = this.GetNextBoolean(pivotKey, subject1, subject2, subject3, value)
                        endloop
                        return result
                    endmethod
                    method RemoveBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, boolean value returns nothing
                        local boolean next = this.GetNextBoolean(pivotKey, subject1, subject2, subject3, value)
                        local boolean prev = this.GetPrevBoolean(pivotKey, subject1, subject2, subject3, value)
                        if ((prev == HASH_TABLE.Boolean.DEFAULT_VALUE) and (next == HASH_TABLE.Boolean.DEFAULT_VALUE)) then
                            if (this.GetFirstBoolean(pivotKey, subject1, subject2, subject3) != value) then
                                return
                            endif
                        endif
                        if (next == HASH_TABLE.Boolean.DEFAULT_VALUE) then
                            call DataTable(this).Head.IntegerKeys.D2.SetBooleanWithCache(this.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0, prev)
                        else
                            call DataTable(this).Head.IntegerKeys.D2.SetBooleanWithCache(this.PREV_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(next), prev)
                        endif
                        if (prev == HASH_TABLE.Boolean.DEFAULT_VALUE) then
                            call DataTable(this).Head.IntegerKeys.D2.SetBooleanWithCache(this.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0, next)
                        else
                            
                            call DataTable(this).Head.IntegerKeys.D2.SetBooleanWithCache(this.NEXT_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(prev), next)
                            
                        endif
                    endmethod
                    method FetchFirstBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns boolean
                        local boolean value = this.GetFirstBoolean(pivotKey, subject1, subject2, subject3)
                        if (value == HASH_TABLE.Boolean.DEFAULT_VALUE) then
                            return HASH_TABLE.Boolean.DEFAULT_VALUE
                        endif
                        call this.RemoveBoolean(pivotKey, subject1, subject2, subject3, value)
                        return value
                    endmethod
                    method ClearBooleans takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns nothing
                        loop
                            exitwhen (this.FetchFirstBoolean(pivotKey, subject1, subject2, subject3) == HASH_TABLE.Boolean.DEFAULT_VALUE)
                        endloop
                    endmethod
                    method InsertAfterBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, boolean prev, boolean value returns boolean
                        local boolean next
                        if (prev == HASH_TABLE.Boolean.DEFAULT_VALUE) then
                            set next = this.GetFirstBoolean(pivotKey, subject1, subject2, subject3)
                            call DataTable(this).Head.IntegerKeys.D2.SetBooleanWithCache(this.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0, value)
                        else
                            set next = this.GetNextBoolean(pivotKey, subject1, subject2, subject3, prev)
                            call DataTable(this).Head.IntegerKeys.D2.SetBooleanWithCache(this.NEXT_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(prev), value)
                        endif
                        if (next == HASH_TABLE.Boolean.DEFAULT_VALUE) then
                            call DataTable(this).Head.IntegerKeys.D2.SetBooleanWithCache(this.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0, value)
                        else
                            call DataTable(this).Head.IntegerKeys.D2.SetBooleanWithCache(this.PREV_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(next), value)
                        endif
                        call DataTable(this).Head.IntegerKeys.D2.SetBooleanWithCache(this.NEXT_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(value), next)
                        call DataTable(this).Head.IntegerKeys.D2.SetBooleanWithCache(this.PREV_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(value), prev)
                        return true
                    endmethod
                    method AddBooleanWithPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3, boolean value, integer prio returns boolean
                        local boolean otherValue = this.GetLastBoolean(pivotKey, subject1, subject2, subject3)
                        loop
                            exitwhen (otherValue == HASH_TABLE.Boolean.DEFAULT_VALUE)
                            exitwhen (prio <= this.GetBooleanPrio(pivotKey, subject1, subject2, subject3, otherValue))
                            set otherValue = this.GetPrevBoolean(pivotKey, subject1, subject2, subject3, otherValue)
                        endloop
                        if not this.InsertAfterBoolean(pivotKey, subject1, subject2, subject3, otherValue, value) then
                            return false
                        endif
                        call DataTable(this).Head.IntegerKeys.D2.SetIntegerWithCache(this.PRIO_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(value), prio)
                        return true
                    endmethod
                    method AddBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, boolean value returns boolean
                    
                    
                        
                    
                    
                    
                      
                    
                        return this.AddBooleanWithPrio(pivotKey, subject1, subject2, subject3, value, 0)
                    endmethod
                    method GetFirstInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns integer
                        return DataTable(this).Head.IntegerKeys.D2.GetIntegerWithCache(this.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0)
                    endmethod
                    method GetLastInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns integer
                        return DataTable(this).Head.IntegerKeys.D2.GetIntegerWithCache(this.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0)
                    endmethod
                    method GetNextInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer value returns integer
                        return DataTable(this).Head.IntegerKeys.D2.GetIntegerWithCache(this.NEXT_CACHE, pivotKey, subject1, subject2, subject3, (value))
                    endmethod
                    method GetPrevInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer value returns integer
                        return DataTable(this).Head.IntegerKeys.D2.GetIntegerWithCache(this.PREV_CACHE, pivotKey, subject1, subject2, subject3, (value))
                    endmethod
                    method GetIntegerPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer value returns integer
                        return DataTable(this).Head.IntegerKeys.D2.GetIntegerWithCache(this.PRIO_CACHE, pivotKey, subject1, subject2, subject3, (value))
                    endmethod
                    method GetIntegersMaxPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns integer
                    	local integer value = this.GetFirstInteger(pivotKey, subject1, subject2, subject3)
                    	local integer result = 0
                        loop
                            exitwhen (value == HASH_TABLE.Integer.DEFAULT_VALUE)
                            local integer prio = this.GetIntegerPrio(pivotKey, subject1, subject2, subject3, value)
                            if (prio > result) then
                                set result = prio
                            endif
                            set value = this.GetNextInteger(pivotKey, subject1, subject2, subject3, value)
                        endloop
                        return result
                    endmethod
                    method RemoveInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer value returns nothing
                        local integer next = this.GetNextInteger(pivotKey, subject1, subject2, subject3, value)
                        local integer prev = this.GetPrevInteger(pivotKey, subject1, subject2, subject3, value)
                        if ((prev == HASH_TABLE.Integer.DEFAULT_VALUE) and (next == HASH_TABLE.Integer.DEFAULT_VALUE)) then
                            if (this.GetFirstInteger(pivotKey, subject1, subject2, subject3) != value) then
                                return
                            endif
                        endif
                        if (next == HASH_TABLE.Integer.DEFAULT_VALUE) then
                            call DataTable(this).Head.IntegerKeys.D2.SetIntegerWithCache(this.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0, prev)
                        else
                            call DataTable(this).Head.IntegerKeys.D2.SetIntegerWithCache(this.PREV_CACHE, pivotKey, subject1, subject2, subject3, (next), prev)
                        endif
                        if (prev == HASH_TABLE.Integer.DEFAULT_VALUE) then
                            call DataTable(this).Head.IntegerKeys.D2.SetIntegerWithCache(this.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0, next)
                        else
                            
                            call DataTable(this).Head.IntegerKeys.D2.SetIntegerWithCache(this.NEXT_CACHE, pivotKey, subject1, subject2, subject3, (prev), next)
                            
                        endif
                    endmethod
                    method FetchFirstInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns integer
                        local integer value = this.GetFirstInteger(pivotKey, subject1, subject2, subject3)
                        if (value == HASH_TABLE.Integer.DEFAULT_VALUE) then
                            return HASH_TABLE.Integer.DEFAULT_VALUE
                        endif
                        call this.RemoveInteger(pivotKey, subject1, subject2, subject3, value)
                        return value
                    endmethod
                    method ClearIntegers takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns nothing
                        loop
                            exitwhen (this.FetchFirstInteger(pivotKey, subject1, subject2, subject3) == HASH_TABLE.Integer.DEFAULT_VALUE)
                        endloop
                    endmethod
                    method InsertAfterInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer prev, integer value returns boolean
                        local integer next
                        if (prev == HASH_TABLE.Integer.DEFAULT_VALUE) then
                            set next = this.GetFirstInteger(pivotKey, subject1, subject2, subject3)
                            call DataTable(this).Head.IntegerKeys.D2.SetIntegerWithCache(this.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0, value)
                        else
                            set next = this.GetNextInteger(pivotKey, subject1, subject2, subject3, prev)
                            call DataTable(this).Head.IntegerKeys.D2.SetIntegerWithCache(this.NEXT_CACHE, pivotKey, subject1, subject2, subject3, (prev), value)
                        endif
                        if (next == HASH_TABLE.Integer.DEFAULT_VALUE) then
                            call DataTable(this).Head.IntegerKeys.D2.SetIntegerWithCache(this.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0, value)
                        else
                            call DataTable(this).Head.IntegerKeys.D2.SetIntegerWithCache(this.PREV_CACHE, pivotKey, subject1, subject2, subject3, (next), value)
                        endif
                        call DataTable(this).Head.IntegerKeys.D2.SetIntegerWithCache(this.NEXT_CACHE, pivotKey, subject1, subject2, subject3, (value), next)
                        call DataTable(this).Head.IntegerKeys.D2.SetIntegerWithCache(this.PREV_CACHE, pivotKey, subject1, subject2, subject3, (value), prev)
                        return true
                    endmethod
                    method AddIntegerWithPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer value, integer prio returns boolean
                        local integer otherValue = this.GetLastInteger(pivotKey, subject1, subject2, subject3)
                        loop
                            exitwhen (otherValue == HASH_TABLE.Integer.DEFAULT_VALUE)
                            exitwhen (prio <= this.GetIntegerPrio(pivotKey, subject1, subject2, subject3, otherValue))
                            set otherValue = this.GetPrevInteger(pivotKey, subject1, subject2, subject3, otherValue)
                        endloop
                        if not this.InsertAfterInteger(pivotKey, subject1, subject2, subject3, otherValue, value) then
                            return false
                        endif
                        call DataTable(this).Head.IntegerKeys.D2.SetIntegerWithCache(this.PRIO_CACHE, pivotKey, subject1, subject2, subject3, (value), prio)
                        return true
                    endmethod
                    method AddInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer value returns boolean
                    
                    
                        
                    
                    
                    
                      
                    
                        return this.AddIntegerWithPrio(pivotKey, subject1, subject2, subject3, value, 0)
                    endmethod
                    method GetFirstReal takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns real
                        return DataTable(this).Head.IntegerKeys.D2.GetRealWithCache(this.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0)
                    endmethod
                    method GetLastReal takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns real
                        return DataTable(this).Head.IntegerKeys.D2.GetRealWithCache(this.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0)
                    endmethod
                    method GetNextReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, real value returns real
                        return DataTable(this).Head.IntegerKeys.D2.GetRealWithCache(this.NEXT_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(value))
                    endmethod
                    method GetPrevReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, real value returns real
                        return DataTable(this).Head.IntegerKeys.D2.GetRealWithCache(this.PREV_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(value))
                    endmethod
                    method GetRealPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3, real value returns integer
                        return DataTable(this).Head.IntegerKeys.D2.GetIntegerWithCache(this.PRIO_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(value))
                    endmethod
                    method GetRealsMaxPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns integer
                    	local real value = this.GetFirstReal(pivotKey, subject1, subject2, subject3)
                    	local integer result = 0
                        loop
                            exitwhen (value == HASH_TABLE.Real.DEFAULT_VALUE)
                            local integer prio = this.GetRealPrio(pivotKey, subject1, subject2, subject3, value)
                            if (prio > result) then
                                set result = prio
                            endif
                            set value = this.GetNextReal(pivotKey, subject1, subject2, subject3, value)
                        endloop
                        return result
                    endmethod
                    method RemoveReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, real value returns nothing
                        local real next = this.GetNextReal(pivotKey, subject1, subject2, subject3, value)
                        local real prev = this.GetPrevReal(pivotKey, subject1, subject2, subject3, value)
                        if ((prev == HASH_TABLE.Real.DEFAULT_VALUE) and (next == HASH_TABLE.Real.DEFAULT_VALUE)) then
                            if (this.GetFirstReal(pivotKey, subject1, subject2, subject3) != value) then
                                return
                            endif
                        endif
                        if (next == HASH_TABLE.Real.DEFAULT_VALUE) then
                            call DataTable(this).Head.IntegerKeys.D2.SetRealWithCache(this.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0, prev)
                        else
                            call DataTable(this).Head.IntegerKeys.D2.SetRealWithCache(this.PREV_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(next), prev)
                        endif
                        if (prev == HASH_TABLE.Real.DEFAULT_VALUE) then
                            call DataTable(this).Head.IntegerKeys.D2.SetRealWithCache(this.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0, next)
                        else
                            
                            call DataTable(this).Head.IntegerKeys.D2.SetRealWithCache(this.NEXT_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(prev), next)
                            
                        endif
                    endmethod
                    method FetchFirstReal takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns real
                        local real value = this.GetFirstReal(pivotKey, subject1, subject2, subject3)
                        if (value == HASH_TABLE.Real.DEFAULT_VALUE) then
                            return HASH_TABLE.Real.DEFAULT_VALUE
                        endif
                        call this.RemoveReal(pivotKey, subject1, subject2, subject3, value)
                        return value
                    endmethod
                    method ClearReals takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns nothing
                        loop
                            exitwhen (this.FetchFirstReal(pivotKey, subject1, subject2, subject3) == HASH_TABLE.Real.DEFAULT_VALUE)
                        endloop
                    endmethod
                    method InsertAfterReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, real prev, real value returns boolean
                        local real next
                        if (prev == HASH_TABLE.Real.DEFAULT_VALUE) then
                            set next = this.GetFirstReal(pivotKey, subject1, subject2, subject3)
                            call DataTable(this).Head.IntegerKeys.D2.SetRealWithCache(this.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0, value)
                        else
                            set next = this.GetNextReal(pivotKey, subject1, subject2, subject3, prev)
                            call DataTable(this).Head.IntegerKeys.D2.SetRealWithCache(this.NEXT_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(prev), value)
                        endif
                        if (next == HASH_TABLE.Real.DEFAULT_VALUE) then
                            call DataTable(this).Head.IntegerKeys.D2.SetRealWithCache(this.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0, value)
                        else
                            call DataTable(this).Head.IntegerKeys.D2.SetRealWithCache(this.PREV_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(next), value)
                        endif
                        call DataTable(this).Head.IntegerKeys.D2.SetRealWithCache(this.NEXT_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(value), next)
                        call DataTable(this).Head.IntegerKeys.D2.SetRealWithCache(this.PREV_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(value), prev)
                        return true
                    endmethod
                    method AddRealWithPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3, real value, integer prio returns boolean
                        local real otherValue = this.GetLastReal(pivotKey, subject1, subject2, subject3)
                        loop
                            exitwhen (otherValue == HASH_TABLE.Real.DEFAULT_VALUE)
                            exitwhen (prio <= this.GetRealPrio(pivotKey, subject1, subject2, subject3, otherValue))
                            set otherValue = this.GetPrevReal(pivotKey, subject1, subject2, subject3, otherValue)
                        endloop
                        if not this.InsertAfterReal(pivotKey, subject1, subject2, subject3, otherValue, value) then
                            return false
                        endif
                        call DataTable(this).Head.IntegerKeys.D2.SetIntegerWithCache(this.PRIO_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(value), prio)
                        return true
                    endmethod
                    method AddReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, real value returns boolean
                    
                    
                        
                    
                    
                    
                      
                    
                        return this.AddRealWithPrio(pivotKey, subject1, subject2, subject3, value, 0)
                    endmethod
                    method GetFirstString takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns string
                        return DataTable(this).Head.IntegerKeys.D2.GetStringWithCache(this.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0)
                    endmethod
                    method GetLastString takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns string
                        return DataTable(this).Head.IntegerKeys.D2.GetStringWithCache(this.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0)
                    endmethod
                    method GetNextString takes integer pivotKey, integer subject1, integer subject2, integer subject3, string value returns string
                        return DataTable(this).Head.IntegerKeys.D2.GetStringWithCache(this.NEXT_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(value))
                    endmethod
                    method GetPrevString takes integer pivotKey, integer subject1, integer subject2, integer subject3, string value returns string
                        return DataTable(this).Head.IntegerKeys.D2.GetStringWithCache(this.PREV_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(value))
                    endmethod
                    method GetStringPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3, string value returns integer
                        return DataTable(this).Head.IntegerKeys.D2.GetIntegerWithCache(this.PRIO_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(value))
                    endmethod
                    method GetStringsMaxPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns integer
                    	local string value = this.GetFirstString(pivotKey, subject1, subject2, subject3)
                    	local integer result = 0
                        loop
                            exitwhen (value == HASH_TABLE.String.DEFAULT_VALUE)
                            local integer prio = this.GetStringPrio(pivotKey, subject1, subject2, subject3, value)
                            if (prio > result) then
                                set result = prio
                            endif
                            set value = this.GetNextString(pivotKey, subject1, subject2, subject3, value)
                        endloop
                        return result
                    endmethod
                    method RemoveString takes integer pivotKey, integer subject1, integer subject2, integer subject3, string value returns nothing
                        local string next = this.GetNextString(pivotKey, subject1, subject2, subject3, value)
                        local string prev = this.GetPrevString(pivotKey, subject1, subject2, subject3, value)
                        if ((prev == HASH_TABLE.String.DEFAULT_VALUE) and (next == HASH_TABLE.String.DEFAULT_VALUE)) then
                            if (this.GetFirstString(pivotKey, subject1, subject2, subject3) != value) then
                                return
                            endif
                        endif
                        if (next == HASH_TABLE.String.DEFAULT_VALUE) then
                            call DataTable(this).Head.IntegerKeys.D2.SetStringWithCache(this.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0, prev)
                        else
                            call DataTable(this).Head.IntegerKeys.D2.SetStringWithCache(this.PREV_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(next), prev)
                        endif
                        if (prev == HASH_TABLE.String.DEFAULT_VALUE) then
                            call DataTable(this).Head.IntegerKeys.D2.SetStringWithCache(this.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0, next)
                        else
                            
                            call DataTable(this).Head.IntegerKeys.D2.SetStringWithCache(this.NEXT_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(prev), next)
                            
                        endif
                    endmethod
                    method FetchFirstString takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns string
                        local string value = this.GetFirstString(pivotKey, subject1, subject2, subject3)
                        if (value == HASH_TABLE.String.DEFAULT_VALUE) then
                            return HASH_TABLE.String.DEFAULT_VALUE
                        endif
                        call this.RemoveString(pivotKey, subject1, subject2, subject3, value)
                        return value
                    endmethod
                    method ClearStrings takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns nothing
                        loop
                            exitwhen (this.FetchFirstString(pivotKey, subject1, subject2, subject3) == HASH_TABLE.String.DEFAULT_VALUE)
                        endloop
                    endmethod
                    method InsertAfterString takes integer pivotKey, integer subject1, integer subject2, integer subject3, string prev, string value returns boolean
                        local string next
                        if (prev == HASH_TABLE.String.DEFAULT_VALUE) then
                            set next = this.GetFirstString(pivotKey, subject1, subject2, subject3)
                            call DataTable(this).Head.IntegerKeys.D2.SetStringWithCache(this.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0, value)
                        else
                            set next = this.GetNextString(pivotKey, subject1, subject2, subject3, prev)
                            call DataTable(this).Head.IntegerKeys.D2.SetStringWithCache(this.NEXT_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(prev), value)
                        endif
                        if (next == HASH_TABLE.String.DEFAULT_VALUE) then
                            call DataTable(this).Head.IntegerKeys.D2.SetStringWithCache(this.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0, value)
                        else
                            call DataTable(this).Head.IntegerKeys.D2.SetStringWithCache(this.PREV_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(next), value)
                        endif
                        call DataTable(this).Head.IntegerKeys.D2.SetStringWithCache(this.NEXT_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(value), next)
                        call DataTable(this).Head.IntegerKeys.D2.SetStringWithCache(this.PREV_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(value), prev)
                        return true
                    endmethod
                    method AddStringWithPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3, string value, integer prio returns boolean
                        local string otherValue = this.GetLastString(pivotKey, subject1, subject2, subject3)
                        loop
                            exitwhen (otherValue == HASH_TABLE.String.DEFAULT_VALUE)
                            exitwhen (prio <= this.GetStringPrio(pivotKey, subject1, subject2, subject3, otherValue))
                            set otherValue = this.GetPrevString(pivotKey, subject1, subject2, subject3, otherValue)
                        endloop
                        if not this.InsertAfterString(pivotKey, subject1, subject2, subject3, otherValue, value) then
                            return false
                        endif
                        call DataTable(this).Head.IntegerKeys.D2.SetIntegerWithCache(this.PRIO_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(value), prio)
                        return true
                    endmethod
                    method AddString takes integer pivotKey, integer subject1, integer subject2, integer subject3, string value returns boolean
                    
                    
                        
                    
                    
                    
                      
                    
                        return this.AddStringWithPrio(pivotKey, subject1, subject2, subject3, value, 0)
                    endmethod
				method Event_Create takes nothing returns nothing
                    set this.FIRST_CACHE = HashTable.Create()
                    set this.LAST_CACHE = HashTable.Create()
                    set this.NEXT_CACHE = HashTable.Create()
                    set this.PREV_CACHE = HashTable.Create()
                    set this.PRIO_CACHE = HashTable.Create()
				endmethod
            endstruct
        endscope
    public struct StructD2
        implement Allocation
        implement List
        
    FolderD2_StructTable Table = this
    FolderD2_StructTable LinkToStruct_Table
                method ContainsBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return DataTable(this).Head.IntegerKeys.D2.ContainsBoolean(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                method GetBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return DataTable(this).Head.IntegerKeys.D2.GetBoolean(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                method SetBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, boolean value returns nothing
                    call DataTable(this).Head.IntegerKeys.D2.SetBoolean(pivotKey, subject1, subject2, subject3, subject4, value)
                endmethod
                method RemoveBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call DataTable(this).Head.IntegerKeys.D2.RemoveBoolean(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                method ContainsInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return DataTable(this).Head.IntegerKeys.D2.ContainsInteger(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                method GetInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns integer
                    return DataTable(this).Head.IntegerKeys.D2.GetInteger(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                method SetInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, integer value returns nothing
                    call DataTable(this).Head.IntegerKeys.D2.SetInteger(pivotKey, subject1, subject2, subject3, subject4, value)
                endmethod
                method RemoveInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call DataTable(this).Head.IntegerKeys.D2.RemoveInteger(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                method ContainsReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return DataTable(this).Head.IntegerKeys.D2.ContainsReal(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                method GetReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns real
                    return DataTable(this).Head.IntegerKeys.D2.GetReal(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                method SetReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, real value returns nothing
                    call DataTable(this).Head.IntegerKeys.D2.SetReal(pivotKey, subject1, subject2, subject3, subject4, value)
                endmethod
                method RemoveReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call DataTable(this).Head.IntegerKeys.D2.RemoveReal(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                method ContainsString takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return DataTable(this).Head.IntegerKeys.D2.ContainsString(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                method GetString takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns string
                    return DataTable(this).Head.IntegerKeys.D2.GetString(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                method SetString takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, string value returns nothing
                    call DataTable(this).Head.IntegerKeys.D2.SetString(pivotKey, subject1, subject2, subject3, subject4, value)
                endmethod
                method RemoveString takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call DataTable(this).Head.IntegerKeys.D2.RemoveString(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
			method Event_Create takes nothing returns nothing
				call this.Table.Event_Create()
			endmethod
        endstruct
    public struct StructTable
        implement Allocation
        implement List
        
            static constant integer EMPTY = HASH_TABLE.Integer.DEFAULT_VALUE
            static constant integer OFFSET = 8192
            static constant integer SIZE = 8192
            static constant integer STARTED = thistype.EMPTY + 1
            HashTable POS_CACHE
            HashTable PRIO_CACHE
            static method GetId takes integer key returns integer
                return thistype.OFFSET + (key - Math.Integer.MIN) * thistype.SIZE
            endmethod
            static method GetTableId takes integer key returns integer
                return (key - Math.Integer.MIN - thistype.OFFSET) div thistype.SIZE
            endmethod
            static method GetTableStartId takes integer key returns integer
                local integer tableId = thistype.GetTableId(key)
                if (tableId > 0) then
                    return Math.Integer.MIN + thistype.OFFSET + tableId * thistype.SIZE
                endif
                return 0
            endmethod
            static method GetReverseKey takes integer key, integer value returns integer
                return (value * thistype.SIZE + thistype.GetTableId(key))
            endmethod
            private method SetCount takes integer missionKey, integer key, integer value returns nothing
                call DataTable(this).Head.IntegerKeys.SetInteger(missionKey, key, value - thistype.EMPTY)
            endmethod
            static method ToArrayIndex takes integer index returns integer
                return (index - thistype.STARTED + ARRAY_MIN)
            endmethod
                method GetBooleanPos takes integer missionKey, integer key, boolean value returns integer
                    return this.POS_CACHE.Integer.Get(missionKey, thistype.GetReverseKey(key, Boolean.ToInt(value)))
                endmethod
                method GetBooleanPrio takes integer missionKey, integer key, boolean value returns integer
                    return this.PRIO_CACHE.Integer.Get(missionKey, thistype.GetReverseKey(key, Boolean.ToInt(value)))
                endmethod
                method CountBooleans takes integer missionKey, integer key returns integer
                    return (thistype.EMPTY + DataTable(this).Head.IntegerKeys.GetInteger(missionKey, key))
                endmethod
                method IsEmptyBoolean takes integer missionKey, integer key returns boolean
                    return (DataTable(this).Head.IntegerKeys.GetInteger(missionKey, key) == thistype.EMPTY)
                endmethod
                method GetBoolean takes integer missionKey, integer key, integer index returns boolean
                    return DataTable(this).Head.IntegerKeys.GetBoolean(missionKey, key + index)
                endmethod
                method GetFirstBoolean takes integer missionKey, integer key returns boolean
                    return this.GetBoolean(missionKey, key, thistype.STARTED)
                endmethod
                method GetLastBoolean takes integer missionKey, integer key returns boolean
                    return this.GetBoolean(missionKey, key, this.CountBooleans(missionKey, key))
                endmethod
                method ContainsBoolean takes integer missionKey, integer key, boolean value returns boolean
                    return (this.GetBooleanPos(missionKey, key, value) != HASH_TABLE.Integer.DEFAULT_VALUE)
                endmethod
                method RandomBoolean takes integer missionKey, integer key, integer lowerBound, integer higherBound returns boolean
                    return this.GetBoolean(missionKey, key, Math.RandomI(lowerBound, higherBound))
                endmethod
                method RandomBooleanAll takes integer missionKey, integer key returns boolean
                    return this.RandomBoolean(missionKey, key, thistype.STARTED, this.CountBooleans(missionKey, key))
                endmethod
                method FetchFirstBoolean takes integer missionKey, integer key returns boolean
                    local integer count = this.CountBooleans(missionKey, key)
                    if (count == thistype.EMPTY) then
                        return HASH_TABLE.Boolean.DEFAULT_VALUE
                    endif
                    local boolean value = this.GetBoolean(missionKey, key, count)
                    call this.SetCount(missionKey, key, count - 1)
                    call this.POS_CACHE.Boolean.Remove(missionKey, thistype.GetReverseKey(key, Boolean.ToInt(value)))
                    call DataTable(this).Head.IntegerKeys.RemoveBoolean(missionKey, key + count)
                    return value
                endmethod
                method ClearBooleans takes integer missionKey, integer key returns nothing
                    local integer iteration = this.CountBooleans(missionKey, key)
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        local boolean value = this.GetBoolean(missionKey, key, iteration)
                        call DataTable(this).Head.IntegerKeys.RemoveBoolean(missionKey, key + iteration)
                        call this.POS_CACHE.Integer.Remove(missionKey, thistype.GetReverseKey(key, Boolean.ToInt(value)))
                        set iteration = iteration - 1
                    endloop
					call this.SetCount(missionKey, key, thistype.EMPTY)
                endmethod
                method AddBoolean takes integer missionKey, integer key, boolean value returns boolean
                    if this.ContainsBoolean(missionKey, key, value) then
						call DebugEx(B2S(value)+" already in table "+I2S(missionKey)+";"+I2S(key))
						call this.PrintBooleans(missionKey, key)
                        return false
                    endif
                    local integer count = this.CountBooleans(missionKey, key) + 1
                    call this.SetCount(missionKey, key, count)
                    call this.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, Boolean.ToInt(value)), count)
                    call DataTable(this).Head.IntegerKeys.SetBoolean(missionKey, key + count, value)
                    return (count == thistype.STARTED)
                endmethod
                method AddBooleanMulti takes integer missionKey, integer key, boolean value returns boolean
                    local integer count = this.CountBooleans(missionKey, key) + 1
                    call this.SetCount(missionKey, key, count)
                    call DataTable(this).Head.IntegerKeys.SetBoolean(missionKey, key + count, value)
                    return (count == thistype.STARTED)
                endmethod
               
                method JoinBoolean takes integer missionKey, integer key, DataTable other, integer missionKey2, integer key2 returns nothing
                    local integer count = thistype(other).CountBooleans(missionKey2, key2)
                    if (count == thistype.EMPTY) then
                        return
                    endif
					local integer addCount = 0
                    local integer iteration = thistype.STARTED
                    local integer oldCount = this.CountBooleans(missionKey, key)
                    loop
                        local boolean value = thistype(other).GetBoolean(missionKey2, key2, iteration)
                        if not this.ContainsBoolean(missionKey, key, value) then
                            set addCount = addCount + 1
                            call this.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, Boolean.ToInt(value)), oldCount + addCount)
                            call DataTable(this).Head.IntegerKeys.SetBoolean(missionKey, key + oldCount + addCount, value)
                        endif
                        set iteration = iteration + 1
                        exitwhen (iteration > count)
                    endloop
                    call this.SetCount(missionKey, key, oldCount + addCount)
                endmethod
                method PrintBooleans takes integer missionKey, integer key returns nothing
                	local integer count = this.CountBooleans(missionKey, key)
					call DebugBufferStart()
                    call DebugBuffer("print table " + I2S(missionKey) + ";" + I2S(key) + ";" + I2S(count))
                    local string missionKeyName = DataTable.GetKeyFromValue(missionKey)
                    local string keyName = DataTable.GetKeyFromValue(key)
                    if ((missionKeyName != null) or (keyName != null)) then
                        call DebugBuffer(missionKeyName + ";" + keyName)
                    endif
                    call DebugBuffer("--->")
					local integer iteration = count
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        local boolean value = this.GetBoolean(missionKey, key, iteration)
                        local integer pos = this.GetBooleanPos(missionKey, key, value)
                        call DebugBuffer(Char.TAB + B2S(value) + " on " + I2S(iteration) + ";" + I2S(pos) + ";" + I2S(thistype.GetReverseKey(key, Boolean.ToInt(value))))
                        if (iteration != pos) then
                            call DebugBuffer("TABLE CORRUPTED!")
                        endif
                        call DebugBuffer(Char.TAB + Char.TAB + DataTable.GetKeyFromValue(pos))
                        set iteration = iteration - 1
                    endloop
					
                    call DebugBufferFinish()
                endmethod
                method RemoveBoolean takes integer missionKey, integer key, boolean value returns boolean
                    local integer count = this.CountBooleans(missionKey, key)
                    local integer reverseKey = thistype.GetReverseKey(key, Boolean.ToInt(value))
                    local boolean lastValue = this.GetBoolean(missionKey, key, count)
                    local integer pos = this.POS_CACHE.Integer.Get(missionKey, reverseKey)
                    static if DEBUG then
                        if not this.ContainsBoolean(missionKey, key, value) then
                            call DebugEx(thistype.NAME + ": " + "cannot remove "+B2S(value) + " from " + I2S(missionKey) + ";" + I2S(key) + " reverseKey: "+I2S(reverseKey))
                            call this.PrintBooleans(missionKey, key)
                            return false
                        endif
                    endif
                    call this.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, Boolean.ToInt(lastValue)), pos)
                    call DataTable(this).Head.IntegerKeys.SetBoolean(missionKey, key + pos, lastValue)
                    call this.POS_CACHE.Integer.Remove(missionKey, reverseKey)
                    call DataTable(this).Head.IntegerKeys.RemoveBoolean(missionKey, key + count)
                    set count = count - 1
                    call this.SetCount(missionKey, key, count)
                    return (count == thistype.EMPTY)
                endmethod
                method FetchRandomBoolean takes integer missionKey, integer key, integer lowerBound, integer higherBound returns boolean
                    local integer count = this.CountBooleans(missionKey, key)
                    if (lowerBound > count) then
                        set lowerBound = count
                    endif
                    if (higherBound > count) then
                        set higherBound = count
                    endif
                    if (higherBound <= thistype.EMPTY) then
                        return HASH_TABLE.Boolean.DEFAULT_VALUE
                    endif
                    local integer index = Math.RandomI(lowerBound, higherBound)
                    local boolean value = this.GetBoolean(missionKey, key, index)
                    call this.RemoveBooleanByIndex(missionKey, key, index)
                    return value
                endmethod
                method FetchRandomBooleanAll takes integer missionKey, integer key returns boolean
                    return this.FetchRandomBoolean(missionKey, key, thistype.STARTED, this.CountBooleans(missionKey, key))
                endmethod
                method ShuffleBooleans takes integer missionKey, integer key returns nothing
                    local integer count = this.CountBooleans(missionKey, key)
                    local integer iteration = count
                    local boolean array temp
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        set temp[thistype.ToArrayIndex(iteration)] = this.GetBoolean(missionKey, key, iteration)
                        set iteration = iteration - 1
                    endloop
					call this.ClearBooleans(missionKey, key)
                    set iteration = thistype.ToArrayIndex(count)
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local integer index = Math.RandomI(ARRAY_MIN, iteration)
                        call this.AddBoolean(missionKey, key, temp[index])
                        set temp[index] = temp[iteration]
                        set iteration = iteration - 1
                    endloop
                endmethod
                method RemoveBooleanByIndex takes integer missionKey, integer key, integer index returns boolean
                    return this.RemoveBoolean(missionKey, key, this.GetBoolean(missionKey, key, index))
                endmethod
                
                method CountBooleansByHandle takes handle source, integer key returns integer
                    return this.CountBooleans(GetHandleId(source), key)
                endmethod
                method GetBooleanByHandle takes handle source, integer key, integer index returns boolean
                    return this.GetBoolean(GetHandleId(source), key, index)
                endmethod
                method RandomBooleanByHandle takes handle handleSource, integer key, integer lowerBound, integer higherBound returns boolean
                    return this.RandomBoolean(GetHandleId(handleSource), key, lowerBound, higherBound)
                endmethod
                method AddBooleanByHandle takes handle source, integer key, boolean value returns boolean
                    return this.AddBoolean(GetHandleId(source), key, value)
                endmethod
                method RemoveBooleanByHandle takes handle source, integer key, boolean value returns boolean
                    return this.RemoveBoolean(GetHandleId(source), key, value)
                endmethod
                method GetIntegerPos takes integer missionKey, integer key, integer value returns integer
                    return this.POS_CACHE.Integer.Get(missionKey, thistype.GetReverseKey(key, (value)))
                endmethod
                method GetIntegerPrio takes integer missionKey, integer key, integer value returns integer
                    return this.PRIO_CACHE.Integer.Get(missionKey, thistype.GetReverseKey(key, (value)))
                endmethod
                method CountIntegers takes integer missionKey, integer key returns integer
                    return (thistype.EMPTY + DataTable(this).Head.IntegerKeys.GetInteger(missionKey, key))
                endmethod
                method IsEmptyInteger takes integer missionKey, integer key returns boolean
                    return (DataTable(this).Head.IntegerKeys.GetInteger(missionKey, key) == thistype.EMPTY)
                endmethod
                method GetInteger takes integer missionKey, integer key, integer index returns integer
                    return DataTable(this).Head.IntegerKeys.GetInteger(missionKey, key + index)
                endmethod
                method GetFirstInteger takes integer missionKey, integer key returns integer
                    return this.GetInteger(missionKey, key, thistype.STARTED)
                endmethod
                method GetLastInteger takes integer missionKey, integer key returns integer
                    return this.GetInteger(missionKey, key, this.CountIntegers(missionKey, key))
                endmethod
                method ContainsInteger takes integer missionKey, integer key, integer value returns boolean
                    return (this.GetIntegerPos(missionKey, key, value) != HASH_TABLE.Integer.DEFAULT_VALUE)
                endmethod
                method RandomInteger takes integer missionKey, integer key, integer lowerBound, integer higherBound returns integer
                    return this.GetInteger(missionKey, key, Math.RandomI(lowerBound, higherBound))
                endmethod
                method RandomIntegerAll takes integer missionKey, integer key returns integer
                    return this.RandomInteger(missionKey, key, thistype.STARTED, this.CountIntegers(missionKey, key))
                endmethod
                method FetchFirstInteger takes integer missionKey, integer key returns integer
                    local integer count = this.CountIntegers(missionKey, key)
                    if (count == thistype.EMPTY) then
                        return HASH_TABLE.Integer.DEFAULT_VALUE
                    endif
                    local integer value = this.GetInteger(missionKey, key, count)
                    call this.SetCount(missionKey, key, count - 1)
                    call this.POS_CACHE.Integer.Remove(missionKey, thistype.GetReverseKey(key, (value)))
                    call DataTable(this).Head.IntegerKeys.RemoveInteger(missionKey, key + count)
                    return value
                endmethod
                method ClearIntegers takes integer missionKey, integer key returns nothing
                    local integer iteration = this.CountIntegers(missionKey, key)
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        local integer value = this.GetInteger(missionKey, key, iteration)
                        call DataTable(this).Head.IntegerKeys.RemoveInteger(missionKey, key + iteration)
                        call this.POS_CACHE.Integer.Remove(missionKey, thistype.GetReverseKey(key, (value)))
                        set iteration = iteration - 1
                    endloop
					call this.SetCount(missionKey, key, thistype.EMPTY)
                endmethod
                method AddInteger takes integer missionKey, integer key, integer value returns boolean
                    if this.ContainsInteger(missionKey, key, value) then
						call DebugEx(I2S(value)+" already in table "+I2S(missionKey)+";"+I2S(key))
						call this.PrintIntegers(missionKey, key)
                        return false
                    endif
                    local integer count = this.CountIntegers(missionKey, key) + 1
                    call this.SetCount(missionKey, key, count)
                    call this.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, (value)), count)
                    call DataTable(this).Head.IntegerKeys.SetInteger(missionKey, key + count, value)
                    return (count == thistype.STARTED)
                endmethod
                method AddIntegerMulti takes integer missionKey, integer key, integer value returns boolean
                    local integer count = this.CountIntegers(missionKey, key) + 1
                    call this.SetCount(missionKey, key, count)
                    call DataTable(this).Head.IntegerKeys.SetInteger(missionKey, key + count, value)
                    return (count == thistype.STARTED)
                endmethod
               
                method JoinInteger takes integer missionKey, integer key, DataTable other, integer missionKey2, integer key2 returns nothing
                    local integer count = thistype(other).CountIntegers(missionKey2, key2)
                    if (count == thistype.EMPTY) then
                        return
                    endif
					local integer addCount = 0
                    local integer iteration = thistype.STARTED
                    local integer oldCount = this.CountIntegers(missionKey, key)
                    loop
                        local integer value = thistype(other).GetInteger(missionKey2, key2, iteration)
                        if not this.ContainsInteger(missionKey, key, value) then
                            set addCount = addCount + 1
                            call this.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, (value)), oldCount + addCount)
                            call DataTable(this).Head.IntegerKeys.SetInteger(missionKey, key + oldCount + addCount, value)
                        endif
                        set iteration = iteration + 1
                        exitwhen (iteration > count)
                    endloop
                    call this.SetCount(missionKey, key, oldCount + addCount)
                endmethod
                method PrintIntegers takes integer missionKey, integer key returns nothing
                	local integer count = this.CountIntegers(missionKey, key)
					call DebugBufferStart()
                    call DebugBuffer("print table " + I2S(missionKey) + ";" + I2S(key) + ";" + I2S(count))
                    local string missionKeyName = DataTable.GetKeyFromValue(missionKey)
                    local string keyName = DataTable.GetKeyFromValue(key)
                    if ((missionKeyName != null) or (keyName != null)) then
                        call DebugBuffer(missionKeyName + ";" + keyName)
                    endif
                    call DebugBuffer("--->")
					local integer iteration = count
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        local integer value = this.GetInteger(missionKey, key, iteration)
                        local integer pos = this.GetIntegerPos(missionKey, key, value)
                        call DebugBuffer(Char.TAB + I2S(value) + " on " + I2S(iteration) + ";" + I2S(pos) + ";" + I2S(thistype.GetReverseKey(key, (value))))
                        if (iteration != pos) then
                            call DebugBuffer("TABLE CORRUPTED!")
                        endif
                        call DebugBuffer(Char.TAB + Char.TAB + DataTable.GetKeyFromValue(pos))
                        set iteration = iteration - 1
                    endloop
					
                    call DebugBufferFinish()
                endmethod
                method RemoveInteger takes integer missionKey, integer key, integer value returns boolean
                    local integer count = this.CountIntegers(missionKey, key)
                    local integer reverseKey = thistype.GetReverseKey(key, (value))
                    local integer lastValue = this.GetInteger(missionKey, key, count)
                    local integer pos = this.POS_CACHE.Integer.Get(missionKey, reverseKey)
                    static if DEBUG then
                        if not this.ContainsInteger(missionKey, key, value) then
                            call DebugEx(thistype.NAME + ": " + "cannot remove "+I2S(value) + " from " + I2S(missionKey) + ";" + I2S(key) + " reverseKey: "+I2S(reverseKey))
                            call this.PrintIntegers(missionKey, key)
                            return false
                        endif
                    endif
                    call this.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, (lastValue)), pos)
                    call DataTable(this).Head.IntegerKeys.SetInteger(missionKey, key + pos, lastValue)
                    call this.POS_CACHE.Integer.Remove(missionKey, reverseKey)
                    call DataTable(this).Head.IntegerKeys.RemoveInteger(missionKey, key + count)
                    set count = count - 1
                    call this.SetCount(missionKey, key, count)
                    return (count == thistype.EMPTY)
                endmethod
                method FetchRandomInteger takes integer missionKey, integer key, integer lowerBound, integer higherBound returns integer
                    local integer count = this.CountIntegers(missionKey, key)
                    if (lowerBound > count) then
                        set lowerBound = count
                    endif
                    if (higherBound > count) then
                        set higherBound = count
                    endif
                    if (higherBound <= thistype.EMPTY) then
                        return HASH_TABLE.Integer.DEFAULT_VALUE
                    endif
                    local integer index = Math.RandomI(lowerBound, higherBound)
                    local integer value = this.GetInteger(missionKey, key, index)
                    call this.RemoveIntegerByIndex(missionKey, key, index)
                    return value
                endmethod
                method FetchRandomIntegerAll takes integer missionKey, integer key returns integer
                    return this.FetchRandomInteger(missionKey, key, thistype.STARTED, this.CountIntegers(missionKey, key))
                endmethod
                method ShuffleIntegers takes integer missionKey, integer key returns nothing
                    local integer count = this.CountIntegers(missionKey, key)
                    local integer iteration = count
                    local integer array temp
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        set temp[thistype.ToArrayIndex(iteration)] = this.GetInteger(missionKey, key, iteration)
                        set iteration = iteration - 1
                    endloop
					call this.ClearIntegers(missionKey, key)
                    set iteration = thistype.ToArrayIndex(count)
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local integer index = Math.RandomI(ARRAY_MIN, iteration)
                        call this.AddInteger(missionKey, key, temp[index])
                        set temp[index] = temp[iteration]
                        set iteration = iteration - 1
                    endloop
                endmethod
                method RemoveIntegerByIndex takes integer missionKey, integer key, integer index returns boolean
                    return this.RemoveInteger(missionKey, key, this.GetInteger(missionKey, key, index))
                endmethod
                
                method CountIntegersByHandle takes handle source, integer key returns integer
                    return this.CountIntegers(GetHandleId(source), key)
                endmethod
                method GetIntegerByHandle takes handle source, integer key, integer index returns integer
                    return this.GetInteger(GetHandleId(source), key, index)
                endmethod
                method RandomIntegerByHandle takes handle handleSource, integer key, integer lowerBound, integer higherBound returns integer
                    return this.RandomInteger(GetHandleId(handleSource), key, lowerBound, higherBound)
                endmethod
                method AddIntegerByHandle takes handle source, integer key, integer value returns boolean
                    return this.AddInteger(GetHandleId(source), key, value)
                endmethod
                method RemoveIntegerByHandle takes handle source, integer key, integer value returns boolean
                    return this.RemoveInteger(GetHandleId(source), key, value)
                endmethod
                method GetRealPos takes integer missionKey, integer key, real value returns integer
                    return this.POS_CACHE.Integer.Get(missionKey, thistype.GetReverseKey(key, Real.ToInt(value)))
                endmethod
                method GetRealPrio takes integer missionKey, integer key, real value returns integer
                    return this.PRIO_CACHE.Integer.Get(missionKey, thistype.GetReverseKey(key, Real.ToInt(value)))
                endmethod
                method CountReals takes integer missionKey, integer key returns integer
                    return (thistype.EMPTY + DataTable(this).Head.IntegerKeys.GetInteger(missionKey, key))
                endmethod
                method IsEmptyReal takes integer missionKey, integer key returns boolean
                    return (DataTable(this).Head.IntegerKeys.GetInteger(missionKey, key) == thistype.EMPTY)
                endmethod
                method GetReal takes integer missionKey, integer key, integer index returns real
                    return DataTable(this).Head.IntegerKeys.GetReal(missionKey, key + index)
                endmethod
                method GetFirstReal takes integer missionKey, integer key returns real
                    return this.GetReal(missionKey, key, thistype.STARTED)
                endmethod
                method GetLastReal takes integer missionKey, integer key returns real
                    return this.GetReal(missionKey, key, this.CountReals(missionKey, key))
                endmethod
                method ContainsReal takes integer missionKey, integer key, real value returns boolean
                    return (this.GetRealPos(missionKey, key, value) != HASH_TABLE.Integer.DEFAULT_VALUE)
                endmethod
                method RandomReal takes integer missionKey, integer key, integer lowerBound, integer higherBound returns real
                    return this.GetReal(missionKey, key, Math.RandomI(lowerBound, higherBound))
                endmethod
                method RandomRealAll takes integer missionKey, integer key returns real
                    return this.RandomReal(missionKey, key, thistype.STARTED, this.CountReals(missionKey, key))
                endmethod
                method FetchFirstReal takes integer missionKey, integer key returns real
                    local integer count = this.CountReals(missionKey, key)
                    if (count == thistype.EMPTY) then
                        return HASH_TABLE.Real.DEFAULT_VALUE
                    endif
                    local real value = this.GetReal(missionKey, key, count)
                    call this.SetCount(missionKey, key, count - 1)
                    call this.POS_CACHE.Real.Remove(missionKey, thistype.GetReverseKey(key, Real.ToInt(value)))
                    call DataTable(this).Head.IntegerKeys.RemoveReal(missionKey, key + count)
                    return value
                endmethod
                method ClearReals takes integer missionKey, integer key returns nothing
                    local integer iteration = this.CountReals(missionKey, key)
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        local real value = this.GetReal(missionKey, key, iteration)
                        call DataTable(this).Head.IntegerKeys.RemoveReal(missionKey, key + iteration)
                        call this.POS_CACHE.Integer.Remove(missionKey, thistype.GetReverseKey(key, Real.ToInt(value)))
                        set iteration = iteration - 1
                    endloop
					call this.SetCount(missionKey, key, thistype.EMPTY)
                endmethod
                method AddReal takes integer missionKey, integer key, real value returns boolean
                    if this.ContainsReal(missionKey, key, value) then
						call DebugEx(R2S(value)+" already in table "+I2S(missionKey)+";"+I2S(key))
						call this.PrintReals(missionKey, key)
                        return false
                    endif
                    local integer count = this.CountReals(missionKey, key) + 1
                    call this.SetCount(missionKey, key, count)
                    call this.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, Real.ToInt(value)), count)
                    call DataTable(this).Head.IntegerKeys.SetReal(missionKey, key + count, value)
                    return (count == thistype.STARTED)
                endmethod
                method AddRealMulti takes integer missionKey, integer key, real value returns boolean
                    local integer count = this.CountReals(missionKey, key) + 1
                    call this.SetCount(missionKey, key, count)
                    call DataTable(this).Head.IntegerKeys.SetReal(missionKey, key + count, value)
                    return (count == thistype.STARTED)
                endmethod
               
                method JoinReal takes integer missionKey, integer key, DataTable other, integer missionKey2, integer key2 returns nothing
                    local integer count = thistype(other).CountReals(missionKey2, key2)
                    if (count == thistype.EMPTY) then
                        return
                    endif
					local integer addCount = 0
                    local integer iteration = thistype.STARTED
                    local integer oldCount = this.CountReals(missionKey, key)
                    loop
                        local real value = thistype(other).GetReal(missionKey2, key2, iteration)
                        if not this.ContainsReal(missionKey, key, value) then
                            set addCount = addCount + 1
                            call this.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, Real.ToInt(value)), oldCount + addCount)
                            call DataTable(this).Head.IntegerKeys.SetReal(missionKey, key + oldCount + addCount, value)
                        endif
                        set iteration = iteration + 1
                        exitwhen (iteration > count)
                    endloop
                    call this.SetCount(missionKey, key, oldCount + addCount)
                endmethod
                method PrintReals takes integer missionKey, integer key returns nothing
                	local integer count = this.CountReals(missionKey, key)
					call DebugBufferStart()
                    call DebugBuffer("print table " + I2S(missionKey) + ";" + I2S(key) + ";" + I2S(count))
                    local string missionKeyName = DataTable.GetKeyFromValue(missionKey)
                    local string keyName = DataTable.GetKeyFromValue(key)
                    if ((missionKeyName != null) or (keyName != null)) then
                        call DebugBuffer(missionKeyName + ";" + keyName)
                    endif
                    call DebugBuffer("--->")
					local integer iteration = count
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        local real value = this.GetReal(missionKey, key, iteration)
                        local integer pos = this.GetRealPos(missionKey, key, value)
                        call DebugBuffer(Char.TAB + R2S(value) + " on " + I2S(iteration) + ";" + I2S(pos) + ";" + I2S(thistype.GetReverseKey(key, Real.ToInt(value))))
                        if (iteration != pos) then
                            call DebugBuffer("TABLE CORRUPTED!")
                        endif
                        call DebugBuffer(Char.TAB + Char.TAB + DataTable.GetKeyFromValue(pos))
                        set iteration = iteration - 1
                    endloop
					
                    call DebugBufferFinish()
                endmethod
                method RemoveReal takes integer missionKey, integer key, real value returns boolean
                    local integer count = this.CountReals(missionKey, key)
                    local integer reverseKey = thistype.GetReverseKey(key, Real.ToInt(value))
                    local real lastValue = this.GetReal(missionKey, key, count)
                    local integer pos = this.POS_CACHE.Integer.Get(missionKey, reverseKey)
                    static if DEBUG then
                        if not this.ContainsReal(missionKey, key, value) then
                            call DebugEx(thistype.NAME + ": " + "cannot remove "+R2S(value) + " from " + I2S(missionKey) + ";" + I2S(key) + " reverseKey: "+I2S(reverseKey))
                            call this.PrintReals(missionKey, key)
                            return false
                        endif
                    endif
                    call this.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, Real.ToInt(lastValue)), pos)
                    call DataTable(this).Head.IntegerKeys.SetReal(missionKey, key + pos, lastValue)
                    call this.POS_CACHE.Integer.Remove(missionKey, reverseKey)
                    call DataTable(this).Head.IntegerKeys.RemoveReal(missionKey, key + count)
                    set count = count - 1
                    call this.SetCount(missionKey, key, count)
                    return (count == thistype.EMPTY)
                endmethod
                method FetchRandomReal takes integer missionKey, integer key, integer lowerBound, integer higherBound returns real
                    local integer count = this.CountReals(missionKey, key)
                    if (lowerBound > count) then
                        set lowerBound = count
                    endif
                    if (higherBound > count) then
                        set higherBound = count
                    endif
                    if (higherBound <= thistype.EMPTY) then
                        return HASH_TABLE.Real.DEFAULT_VALUE
                    endif
                    local integer index = Math.RandomI(lowerBound, higherBound)
                    local real value = this.GetReal(missionKey, key, index)
                    call this.RemoveRealByIndex(missionKey, key, index)
                    return value
                endmethod
                method FetchRandomRealAll takes integer missionKey, integer key returns real
                    return this.FetchRandomReal(missionKey, key, thistype.STARTED, this.CountReals(missionKey, key))
                endmethod
                method ShuffleReals takes integer missionKey, integer key returns nothing
                    local integer count = this.CountReals(missionKey, key)
                    local integer iteration = count
                    local real array temp
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        set temp[thistype.ToArrayIndex(iteration)] = this.GetReal(missionKey, key, iteration)
                        set iteration = iteration - 1
                    endloop
					call this.ClearReals(missionKey, key)
                    set iteration = thistype.ToArrayIndex(count)
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local integer index = Math.RandomI(ARRAY_MIN, iteration)
                        call this.AddReal(missionKey, key, temp[index])
                        set temp[index] = temp[iteration]
                        set iteration = iteration - 1
                    endloop
                endmethod
                method RemoveRealByIndex takes integer missionKey, integer key, integer index returns boolean
                    return this.RemoveReal(missionKey, key, this.GetReal(missionKey, key, index))
                endmethod
                
                method CountRealsByHandle takes handle source, integer key returns integer
                    return this.CountReals(GetHandleId(source), key)
                endmethod
                method GetRealByHandle takes handle source, integer key, integer index returns real
                    return this.GetReal(GetHandleId(source), key, index)
                endmethod
                method RandomRealByHandle takes handle handleSource, integer key, integer lowerBound, integer higherBound returns real
                    return this.RandomReal(GetHandleId(handleSource), key, lowerBound, higherBound)
                endmethod
                method AddRealByHandle takes handle source, integer key, real value returns boolean
                    return this.AddReal(GetHandleId(source), key, value)
                endmethod
                method RemoveRealByHandle takes handle source, integer key, real value returns boolean
                    return this.RemoveReal(GetHandleId(source), key, value)
                endmethod
                method GetStringPos takes integer missionKey, integer key, string value returns integer
                    return this.POS_CACHE.Integer.Get(missionKey, thistype.GetReverseKey(key, String.ToIntHash(value)))
                endmethod
                method GetStringPrio takes integer missionKey, integer key, string value returns integer
                    return this.PRIO_CACHE.Integer.Get(missionKey, thistype.GetReverseKey(key, String.ToIntHash(value)))
                endmethod
                method CountStrings takes integer missionKey, integer key returns integer
                    return (thistype.EMPTY + DataTable(this).Head.IntegerKeys.GetInteger(missionKey, key))
                endmethod
                method IsEmptyString takes integer missionKey, integer key returns boolean
                    return (DataTable(this).Head.IntegerKeys.GetInteger(missionKey, key) == thistype.EMPTY)
                endmethod
                method GetString takes integer missionKey, integer key, integer index returns string
                    return DataTable(this).Head.IntegerKeys.GetString(missionKey, key + index)
                endmethod
                method GetFirstString takes integer missionKey, integer key returns string
                    return this.GetString(missionKey, key, thistype.STARTED)
                endmethod
                method GetLastString takes integer missionKey, integer key returns string
                    return this.GetString(missionKey, key, this.CountStrings(missionKey, key))
                endmethod
                method ContainsString takes integer missionKey, integer key, string value returns boolean
                    return (this.GetStringPos(missionKey, key, value) != HASH_TABLE.Integer.DEFAULT_VALUE)
                endmethod
                method RandomString takes integer missionKey, integer key, integer lowerBound, integer higherBound returns string
                    return this.GetString(missionKey, key, Math.RandomI(lowerBound, higherBound))
                endmethod
                method RandomStringAll takes integer missionKey, integer key returns string
                    return this.RandomString(missionKey, key, thistype.STARTED, this.CountStrings(missionKey, key))
                endmethod
                method FetchFirstString takes integer missionKey, integer key returns string
                    local integer count = this.CountStrings(missionKey, key)
                    if (count == thistype.EMPTY) then
                        return HASH_TABLE.String.DEFAULT_VALUE
                    endif
                    local string value = this.GetString(missionKey, key, count)
                    call this.SetCount(missionKey, key, count - 1)
                    call this.POS_CACHE.String.Remove(missionKey, thistype.GetReverseKey(key, String.ToIntHash(value)))
                    call DataTable(this).Head.IntegerKeys.RemoveString(missionKey, key + count)
                    return value
                endmethod
                method ClearStrings takes integer missionKey, integer key returns nothing
                    local integer iteration = this.CountStrings(missionKey, key)
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        local string value = this.GetString(missionKey, key, iteration)
                        call DataTable(this).Head.IntegerKeys.RemoveString(missionKey, key + iteration)
                        call this.POS_CACHE.Integer.Remove(missionKey, thistype.GetReverseKey(key, String.ToIntHash(value)))
                        set iteration = iteration - 1
                    endloop
					call this.SetCount(missionKey, key, thistype.EMPTY)
                endmethod
                method AddString takes integer missionKey, integer key, string value returns boolean
                    if this.ContainsString(missionKey, key, value) then
						call DebugEx((value)+" already in table "+I2S(missionKey)+";"+I2S(key))
						call this.PrintStrings(missionKey, key)
                        return false
                    endif
                    local integer count = this.CountStrings(missionKey, key) + 1
                    call this.SetCount(missionKey, key, count)
                    call this.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, String.ToIntHash(value)), count)
                    call DataTable(this).Head.IntegerKeys.SetString(missionKey, key + count, value)
                    return (count == thistype.STARTED)
                endmethod
                method AddStringMulti takes integer missionKey, integer key, string value returns boolean
                    local integer count = this.CountStrings(missionKey, key) + 1
                    call this.SetCount(missionKey, key, count)
                    call DataTable(this).Head.IntegerKeys.SetString(missionKey, key + count, value)
                    return (count == thistype.STARTED)
                endmethod
               
                method JoinString takes integer missionKey, integer key, DataTable other, integer missionKey2, integer key2 returns nothing
                    local integer count = thistype(other).CountStrings(missionKey2, key2)
                    if (count == thistype.EMPTY) then
                        return
                    endif
					local integer addCount = 0
                    local integer iteration = thistype.STARTED
                    local integer oldCount = this.CountStrings(missionKey, key)
                    loop
                        local string value = thistype(other).GetString(missionKey2, key2, iteration)
                        if not this.ContainsString(missionKey, key, value) then
                            set addCount = addCount + 1
                            call this.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, String.ToIntHash(value)), oldCount + addCount)
                            call DataTable(this).Head.IntegerKeys.SetString(missionKey, key + oldCount + addCount, value)
                        endif
                        set iteration = iteration + 1
                        exitwhen (iteration > count)
                    endloop
                    call this.SetCount(missionKey, key, oldCount + addCount)
                endmethod
                method PrintStrings takes integer missionKey, integer key returns nothing
                	local integer count = this.CountStrings(missionKey, key)
					call DebugBufferStart()
                    call DebugBuffer("print table " + I2S(missionKey) + ";" + I2S(key) + ";" + I2S(count))
                    local string missionKeyName = DataTable.GetKeyFromValue(missionKey)
                    local string keyName = DataTable.GetKeyFromValue(key)
                    if ((missionKeyName != null) or (keyName != null)) then
                        call DebugBuffer(missionKeyName + ";" + keyName)
                    endif
                    call DebugBuffer("--->")
					local integer iteration = count
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        local string value = this.GetString(missionKey, key, iteration)
                        local integer pos = this.GetStringPos(missionKey, key, value)
                        call DebugBuffer(Char.TAB + (value) + " on " + I2S(iteration) + ";" + I2S(pos) + ";" + I2S(thistype.GetReverseKey(key, String.ToIntHash(value))))
                        if (iteration != pos) then
                            call DebugBuffer("TABLE CORRUPTED!")
                        endif
                        call DebugBuffer(Char.TAB + Char.TAB + DataTable.GetKeyFromValue(pos))
                        set iteration = iteration - 1
                    endloop
					
                    call DebugBufferFinish()
                endmethod
                method RemoveString takes integer missionKey, integer key, string value returns boolean
                    local integer count = this.CountStrings(missionKey, key)
                    local integer reverseKey = thistype.GetReverseKey(key, String.ToIntHash(value))
                    local string lastValue = this.GetString(missionKey, key, count)
                    local integer pos = this.POS_CACHE.Integer.Get(missionKey, reverseKey)
                    static if DEBUG then
                        if not this.ContainsString(missionKey, key, value) then
                            call DebugEx(thistype.NAME + ": " + "cannot remove "+(value) + " from " + I2S(missionKey) + ";" + I2S(key) + " reverseKey: "+I2S(reverseKey))
                            call this.PrintStrings(missionKey, key)
                            return false
                        endif
                    endif
                    call this.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, String.ToIntHash(lastValue)), pos)
                    call DataTable(this).Head.IntegerKeys.SetString(missionKey, key + pos, lastValue)
                    call this.POS_CACHE.Integer.Remove(missionKey, reverseKey)
                    call DataTable(this).Head.IntegerKeys.RemoveString(missionKey, key + count)
                    set count = count - 1
                    call this.SetCount(missionKey, key, count)
                    return (count == thistype.EMPTY)
                endmethod
                method FetchRandomString takes integer missionKey, integer key, integer lowerBound, integer higherBound returns string
                    local integer count = this.CountStrings(missionKey, key)
                    if (lowerBound > count) then
                        set lowerBound = count
                    endif
                    if (higherBound > count) then
                        set higherBound = count
                    endif
                    if (higherBound <= thistype.EMPTY) then
                        return HASH_TABLE.String.DEFAULT_VALUE
                    endif
                    local integer index = Math.RandomI(lowerBound, higherBound)
                    local string value = this.GetString(missionKey, key, index)
                    call this.RemoveStringByIndex(missionKey, key, index)
                    return value
                endmethod
                method FetchRandomStringAll takes integer missionKey, integer key returns string
                    return this.FetchRandomString(missionKey, key, thistype.STARTED, this.CountStrings(missionKey, key))
                endmethod
                method ShuffleStrings takes integer missionKey, integer key returns nothing
                    local integer count = this.CountStrings(missionKey, key)
                    local integer iteration = count
                    local string array temp
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        set temp[thistype.ToArrayIndex(iteration)] = this.GetString(missionKey, key, iteration)
                        set iteration = iteration - 1
                    endloop
					call this.ClearStrings(missionKey, key)
                    set iteration = thistype.ToArrayIndex(count)
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local integer index = Math.RandomI(ARRAY_MIN, iteration)
                        call this.AddString(missionKey, key, temp[index])
                        set temp[index] = temp[iteration]
                        set iteration = iteration - 1
                    endloop
                endmethod
                method RemoveStringByIndex takes integer missionKey, integer key, integer index returns boolean
                    return this.RemoveString(missionKey, key, this.GetString(missionKey, key, index))
                endmethod
                
                method CountStringsByHandle takes handle source, integer key returns integer
                    return this.CountStrings(GetHandleId(source), key)
                endmethod
                method GetStringByHandle takes handle source, integer key, integer index returns string
                    return this.GetString(GetHandleId(source), key, index)
                endmethod
                method RandomStringByHandle takes handle handleSource, integer key, integer lowerBound, integer higherBound returns string
                    return this.RandomString(GetHandleId(handleSource), key, lowerBound, higherBound)
                endmethod
                method AddStringByHandle takes handle source, integer key, string value returns boolean
                    return this.AddString(GetHandleId(source), key, value)
                endmethod
                method RemoveStringByHandle takes handle source, integer key, string value returns boolean
                    return this.RemoveString(GetHandleId(source), key, value)
                endmethod
                method AddIntegerSorted takes integer missionKey, integer key, integer value, real sortValue returns boolean
                    local integer count = this.CountIntegers(missionKey, key)
                    local integer iteration = count
                    loop
                        exitwhen (iteration == thistype.EMPTY)
                        exitwhen (value > this.GetInteger(missionKey, key, iteration))
                        set iteration = iteration - 1
                    endloop
					local integer index
                    if (iteration == thistype.EMPTY) then
                        set index = thistype.STARTED
                    endif
                    set count = count + 1
                    set iteration = index + 1
                    call this.SetCount(missionKey, key, count)
                    loop
                        exitwhen (iteration > count)
                        local integer otherValue = this.GetInteger(missionKey, key, iteration - 1)
                        call this.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, (otherValue)), iteration)
                        call DataTable(this).Head.IntegerKeys.SetInteger(missionKey, key + iteration, otherValue)
                        set iteration = iteration + 1
                    endloop
                    call this.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, (value)), index)
                    call DataTable(this).Head.IntegerKeys.SetInteger(missionKey, key + index, value)
                    return (count == thistype.STARTED)
                endmethod
                method RemoveIntegerSorted takes integer missionKey, integer key, integer value returns boolean
                    local integer count = this.CountIntegers(missionKey, key) - 1
                    local integer reverseKey = thistype.GetReverseKey(key, (value))
                    local integer index = this.POS_CACHE.Integer.Get(missionKey, reverseKey)
                    static if DEBUG then
                        if not this.ContainsInteger(missionKey, key, value) then
                            call DebugEx(thistype.NAME + ": " + "cannot remove " + I2S(value) + " from " + I2S(missionKey) + ";" + I2S(key))
                            return false
                        endif
                    endif
                    call this.POS_CACHE.Integer.Remove(missionKey, reverseKey)
                    call DataTable(this).Head.IntegerKeys.RemoveInteger(missionKey, key + index)
                    set count = count - 1
                    local integer iteration = index
                    loop
                        exitwhen (iteration > count)
                        set value = this.GetInteger(missionKey, key, iteration + 1)
                        call this.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, (value)), iteration)
                        call DataTable(this).Head.IntegerKeys.SetInteger(missionKey, key + iteration, value)
                        set iteration = iteration - 1
                    endloop
                    call this.SetCount(missionKey, key, count)
                    return (count == thistype.EMPTY)
                endmethod
                method AddRealSorted takes integer missionKey, integer key, real value, real sortValue returns boolean
                    local integer count = this.CountReals(missionKey, key)
                    local integer iteration = count
                    loop
                        exitwhen (iteration == thistype.EMPTY)
                        exitwhen (value > this.GetReal(missionKey, key, iteration))
                        set iteration = iteration - 1
                    endloop
					local integer index
                    if (iteration == thistype.EMPTY) then
                        set index = thistype.STARTED
                    endif
                    set count = count + 1
                    set iteration = index + 1
                    call this.SetCount(missionKey, key, count)
                    loop
                        exitwhen (iteration > count)
                        local real otherValue = this.GetReal(missionKey, key, iteration - 1)
                        call this.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, Real.ToInt(otherValue)), iteration)
                        call DataTable(this).Head.IntegerKeys.SetReal(missionKey, key + iteration, otherValue)
                        set iteration = iteration + 1
                    endloop
                    call this.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, Real.ToInt(value)), index)
                    call DataTable(this).Head.IntegerKeys.SetReal(missionKey, key + index, value)
                    return (count == thistype.STARTED)
                endmethod
                method RemoveRealSorted takes integer missionKey, integer key, real value returns boolean
                    local integer count = this.CountReals(missionKey, key) - 1
                    local integer reverseKey = thistype.GetReverseKey(key, Real.ToInt(value))
                    local integer index = this.POS_CACHE.Integer.Get(missionKey, reverseKey)
                    static if DEBUG then
                        if not this.ContainsReal(missionKey, key, value) then
                            call DebugEx(thistype.NAME + ": " + "cannot remove " + R2S(value) + " from " + I2S(missionKey) + ";" + I2S(key))
                            return false
                        endif
                    endif
                    call this.POS_CACHE.Integer.Remove(missionKey, reverseKey)
                    call DataTable(this).Head.IntegerKeys.RemoveReal(missionKey, key + index)
                    set count = count - 1
                    local integer iteration = index
                    loop
                        exitwhen (iteration > count)
                        set value = this.GetReal(missionKey, key, iteration + 1)
                        call this.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, Real.ToInt(value)), iteration)
                        call DataTable(this).Head.IntegerKeys.SetReal(missionKey, key + iteration, value)
                        set iteration = iteration - 1
                    endloop
                    call this.SetCount(missionKey, key, count)
                    return (count == thistype.EMPTY)
                endmethod
            method Clear takes integer missionKey, integer key returns nothing
                call this.ClearIntegers(missionKey, key)
            endmethod
			method Event_Create takes nothing returns nothing
                set this.POS_CACHE = HashTable.Create()
                set this.PRIO_CACHE = HashTable.Create()
			endmethod
        endstruct
    endscope
    public struct StructIntegerKeys
        implement Allocation
        implement List
        
    FolderIntegerKeys_StructD2 D2 = this
    FolderIntegerKeys_StructD2 LinkToStruct_D2
    FolderIntegerKeys_StructTable Table = this
    FolderIntegerKeys_StructTable LinkToStruct_Table
        method RemoveChild takes integer missionKey returns nothing
            call DataTable(this).Head.IntegerKeys.RemoveChild(missionKey)
        endmethod
            method ContainsBoolean takes integer missionKey, integer key returns boolean
                return DataTable(this).Head.IntegerKeys.ContainsBoolean(missionKey, key)
            endmethod
            method GetBoolean takes integer missionKey, integer key returns boolean
                return DataTable(this).Head.IntegerKeys.GetBoolean(missionKey, key)
            endmethod
            method GetBooleanByHandle takes handle handleSource, integer key returns boolean
                return DataTable(this).Head.IntegerKeys.GetBooleanByHandle(handleSource, key)
            endmethod
            method SetBoolean takes integer missionKey, integer key, boolean value returns nothing
                call DataTable(this).Head.IntegerKeys.SetBoolean(missionKey, key, value)
            endmethod
            method SetBooleanByHandle takes handle handleSource, integer key, boolean value returns nothing
                call this.SetBoolean(GetHandleId(handleSource), key, value)
            endmethod
            method RemoveBoolean takes integer missionKey, integer key returns nothing
                call DataTable(this).Head.IntegerKeys.RemoveBoolean(missionKey, key)
            endmethod
            method RemoveBooleanByHandle takes handle handleSource, integer key returns nothing
                call DataTable(this).Head.IntegerKeys.RemoveBooleanByHandle(handleSource, key)
            endmethod
            method ContainsInteger takes integer missionKey, integer key returns boolean
                return DataTable(this).Head.IntegerKeys.ContainsInteger(missionKey, key)
            endmethod
            method GetInteger takes integer missionKey, integer key returns integer
                return DataTable(this).Head.IntegerKeys.GetInteger(missionKey, key)
            endmethod
            method GetIntegerByHandle takes handle handleSource, integer key returns integer
                return DataTable(this).Head.IntegerKeys.GetIntegerByHandle(handleSource, key)
            endmethod
            method SetInteger takes integer missionKey, integer key, integer value returns nothing
                call DataTable(this).Head.IntegerKeys.SetInteger(missionKey, key, value)
            endmethod
            method SetIntegerByHandle takes handle handleSource, integer key, integer value returns nothing
                call this.SetInteger(GetHandleId(handleSource), key, value)
            endmethod
            method RemoveInteger takes integer missionKey, integer key returns nothing
                call DataTable(this).Head.IntegerKeys.RemoveInteger(missionKey, key)
            endmethod
            method RemoveIntegerByHandle takes handle handleSource, integer key returns nothing
                call DataTable(this).Head.IntegerKeys.RemoveIntegerByHandle(handleSource, key)
            endmethod
            method ContainsReal takes integer missionKey, integer key returns boolean
                return DataTable(this).Head.IntegerKeys.ContainsReal(missionKey, key)
            endmethod
            method GetReal takes integer missionKey, integer key returns real
                return DataTable(this).Head.IntegerKeys.GetReal(missionKey, key)
            endmethod
            method GetRealByHandle takes handle handleSource, integer key returns real
                return DataTable(this).Head.IntegerKeys.GetRealByHandle(handleSource, key)
            endmethod
            method SetReal takes integer missionKey, integer key, real value returns nothing
                call DataTable(this).Head.IntegerKeys.SetReal(missionKey, key, value)
            endmethod
            method SetRealByHandle takes handle handleSource, integer key, real value returns nothing
                call this.SetReal(GetHandleId(handleSource), key, value)
            endmethod
            method RemoveReal takes integer missionKey, integer key returns nothing
                call DataTable(this).Head.IntegerKeys.RemoveReal(missionKey, key)
            endmethod
            method RemoveRealByHandle takes handle handleSource, integer key returns nothing
                call DataTable(this).Head.IntegerKeys.RemoveRealByHandle(handleSource, key)
            endmethod
            method ContainsString takes integer missionKey, integer key returns boolean
                return DataTable(this).Head.IntegerKeys.ContainsString(missionKey, key)
            endmethod
            method GetString takes integer missionKey, integer key returns string
                return DataTable(this).Head.IntegerKeys.GetString(missionKey, key)
            endmethod
            method GetStringByHandle takes handle handleSource, integer key returns string
                return DataTable(this).Head.IntegerKeys.GetStringByHandle(handleSource, key)
            endmethod
            method SetString takes integer missionKey, integer key, string value returns nothing
                call DataTable(this).Head.IntegerKeys.SetString(missionKey, key, value)
            endmethod
            method SetStringByHandle takes handle handleSource, integer key, string value returns nothing
                call this.SetString(GetHandleId(handleSource), key, value)
            endmethod
            method RemoveString takes integer missionKey, integer key returns nothing
                call DataTable(this).Head.IntegerKeys.RemoveString(missionKey, key)
            endmethod
            method RemoveStringByHandle takes handle handleSource, integer key returns nothing
                call DataTable(this).Head.IntegerKeys.RemoveStringByHandle(handleSource, key)
            endmethod
		method Event_Create takes nothing returns nothing
			call this.D2.Event_Create()
			call this.Table.Event_Create()
		endmethod
    endstruct
    scope FolderStringKeys
    public struct StructTable
        implement Allocation
        implement List
        
            static constant integer EMPTY = -1
            static constant integer STARTED = 0
                method CountBooleans takes string missionKey, string key returns integer
                    return (thistype.EMPTY + DataTable(this).Head.StringKeys.GetInteger(missionKey, key))
                endmethod
                method GetBoolean takes string missionKey, string key, integer index returns boolean
                    return DataTable(this).Head.StringKeys.GetBoolean(missionKey, key + I2S(thistype.EMPTY + index + 2))
                endmethod
                method ContainsBoolean takes string missionKey, string key, boolean value returns boolean
                    local integer iteration = this.CountBooleans(missionKey, key)
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        exitwhen (this.GetBoolean(missionKey, key, iteration) == value)
                        set iteration = iteration - 1
                    endloop
                    if (iteration < thistype.STARTED) then
                        return false
                    endif
                    return true
                endmethod
                method PrintBooleans takes string missionKey, string key returns nothing
					local integer iteration = this.CountBooleans(missionKey, key)
					call DebugBufferStart()
					loop
						exitwhen (iteration < thistype.STARTED)
						call DebugBuffer(B2S(this.GetBoolean(missionKey, key, iteration)))
						set iteration = iteration - 1
					endloop
					call DebugBufferFinish()
                endmethod
                method AddBoolean takes string missionKey, string key, boolean value returns boolean
                    local integer count = this.CountBooleans(missionKey, key) + 1
                    call DataTable(this).Head.StringKeys.SetInteger(missionKey, key, count - thistype.EMPTY)
                    call DataTable(this).Head.StringKeys.SetBoolean(missionKey, key + I2S(thistype.EMPTY + count + 2), value)
                    return (count == thistype.STARTED)
                endmethod
                method RemoveBoolean takes string missionKey, string key, boolean value returns boolean
                    local integer count = this.CountBooleans(missionKey, key)
                    local integer iteration = count
                    loop
debug                        exitwhen (iteration < thistype.STARTED)
                        exitwhen (this.GetBoolean(missionKey, key, iteration) == value)
                        set iteration = iteration - 1
                    endloop
debug                    if (iteration < thistype.STARTED) then
debug                        call Game.DebugMsg("Failed to remove " + B2S(value)+" from table " + key + " of missionKey " + missionKey + " (" + I2S(count) + ")")
debug                    else
                    call DataTable(this).Head.StringKeys.SetBoolean(missionKey, key + I2S(thistype.EMPTY + iteration + 2), this.GetBoolean(missionKey, key, count))
                    set count = count - 1
                    call DataTable(this).Head.StringKeys.SetInteger(missionKey, key, count - thistype.EMPTY)
debug                    endif
                    return (count == thistype.EMPTY)
                endmethod
                method RandomBoolean takes string missionKey, string key, integer lowerBound, integer higherBound returns boolean
                    return this.GetBoolean(missionKey, key, Math.RandomI(lowerBound, higherBound))
                endmethod
                method RandomBooleanAll takes string missionKey, string key returns boolean
                    return this.RandomBoolean(missionKey, key, thistype.STARTED, this.CountBooleans(missionKey, key))
                endmethod
                method CountIntegers takes string missionKey, string key returns integer
                    return (thistype.EMPTY + DataTable(this).Head.StringKeys.GetInteger(missionKey, key))
                endmethod
                method GetInteger takes string missionKey, string key, integer index returns integer
                    return DataTable(this).Head.StringKeys.GetInteger(missionKey, key + I2S(thistype.EMPTY + index + 2))
                endmethod
                method ContainsInteger takes string missionKey, string key, integer value returns boolean
                    local integer iteration = this.CountIntegers(missionKey, key)
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        exitwhen (this.GetInteger(missionKey, key, iteration) == value)
                        set iteration = iteration - 1
                    endloop
                    if (iteration < thistype.STARTED) then
                        return false
                    endif
                    return true
                endmethod
                method PrintIntegers takes string missionKey, string key returns nothing
					local integer iteration = this.CountIntegers(missionKey, key)
					call DebugBufferStart()
					loop
						exitwhen (iteration < thistype.STARTED)
						call DebugBuffer(I2S(this.GetInteger(missionKey, key, iteration)))
						set iteration = iteration - 1
					endloop
					call DebugBufferFinish()
                endmethod
                method AddInteger takes string missionKey, string key, integer value returns boolean
                    local integer count = this.CountIntegers(missionKey, key) + 1
                    call DataTable(this).Head.StringKeys.SetInteger(missionKey, key, count - thistype.EMPTY)
                    call DataTable(this).Head.StringKeys.SetInteger(missionKey, key + I2S(thistype.EMPTY + count + 2), value)
                    return (count == thistype.STARTED)
                endmethod
                method RemoveInteger takes string missionKey, string key, integer value returns boolean
                    local integer count = this.CountIntegers(missionKey, key)
                    local integer iteration = count
                    loop
debug                        exitwhen (iteration < thistype.STARTED)
                        exitwhen (this.GetInteger(missionKey, key, iteration) == value)
                        set iteration = iteration - 1
                    endloop
debug                    if (iteration < thistype.STARTED) then
debug                        call Game.DebugMsg("Failed to remove " + I2S(value)+" from table " + key + " of missionKey " + missionKey + " (" + I2S(count) + ")")
debug                    else
                    call DataTable(this).Head.StringKeys.SetInteger(missionKey, key + I2S(thistype.EMPTY + iteration + 2), this.GetInteger(missionKey, key, count))
                    set count = count - 1
                    call DataTable(this).Head.StringKeys.SetInteger(missionKey, key, count - thistype.EMPTY)
debug                    endif
                    return (count == thistype.EMPTY)
                endmethod
                method RandomInteger takes string missionKey, string key, integer lowerBound, integer higherBound returns integer
                    return this.GetInteger(missionKey, key, Math.RandomI(lowerBound, higherBound))
                endmethod
                method RandomIntegerAll takes string missionKey, string key returns integer
                    return this.RandomInteger(missionKey, key, thistype.STARTED, this.CountIntegers(missionKey, key))
                endmethod
                method CountReals takes string missionKey, string key returns integer
                    return (thistype.EMPTY + DataTable(this).Head.StringKeys.GetInteger(missionKey, key))
                endmethod
                method GetReal takes string missionKey, string key, integer index returns real
                    return DataTable(this).Head.StringKeys.GetReal(missionKey, key + I2S(thistype.EMPTY + index + 2))
                endmethod
                method ContainsReal takes string missionKey, string key, real value returns boolean
                    local integer iteration = this.CountReals(missionKey, key)
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        exitwhen (this.GetReal(missionKey, key, iteration) == value)
                        set iteration = iteration - 1
                    endloop
                    if (iteration < thistype.STARTED) then
                        return false
                    endif
                    return true
                endmethod
                method PrintReals takes string missionKey, string key returns nothing
					local integer iteration = this.CountReals(missionKey, key)
					call DebugBufferStart()
					loop
						exitwhen (iteration < thistype.STARTED)
						call DebugBuffer(R2S(this.GetReal(missionKey, key, iteration)))
						set iteration = iteration - 1
					endloop
					call DebugBufferFinish()
                endmethod
                method AddReal takes string missionKey, string key, real value returns boolean
                    local integer count = this.CountReals(missionKey, key) + 1
                    call DataTable(this).Head.StringKeys.SetInteger(missionKey, key, count - thistype.EMPTY)
                    call DataTable(this).Head.StringKeys.SetReal(missionKey, key + I2S(thistype.EMPTY + count + 2), value)
                    return (count == thistype.STARTED)
                endmethod
                method RemoveReal takes string missionKey, string key, real value returns boolean
                    local integer count = this.CountReals(missionKey, key)
                    local integer iteration = count
                    loop
debug                        exitwhen (iteration < thistype.STARTED)
                        exitwhen (this.GetReal(missionKey, key, iteration) == value)
                        set iteration = iteration - 1
                    endloop
debug                    if (iteration < thistype.STARTED) then
debug                        call Game.DebugMsg("Failed to remove " + R2S(value)+" from table " + key + " of missionKey " + missionKey + " (" + I2S(count) + ")")
debug                    else
                    call DataTable(this).Head.StringKeys.SetReal(missionKey, key + I2S(thistype.EMPTY + iteration + 2), this.GetReal(missionKey, key, count))
                    set count = count - 1
                    call DataTable(this).Head.StringKeys.SetInteger(missionKey, key, count - thistype.EMPTY)
debug                    endif
                    return (count == thistype.EMPTY)
                endmethod
                method RandomReal takes string missionKey, string key, integer lowerBound, integer higherBound returns real
                    return this.GetReal(missionKey, key, Math.RandomI(lowerBound, higherBound))
                endmethod
                method RandomRealAll takes string missionKey, string key returns real
                    return this.RandomReal(missionKey, key, thistype.STARTED, this.CountReals(missionKey, key))
                endmethod
                method CountStrings takes string missionKey, string key returns integer
                    return (thistype.EMPTY + DataTable(this).Head.StringKeys.GetInteger(missionKey, key))
                endmethod
                method GetString takes string missionKey, string key, integer index returns string
                    return DataTable(this).Head.StringKeys.GetString(missionKey, key + I2S(thistype.EMPTY + index + 2))
                endmethod
                method ContainsString takes string missionKey, string key, string value returns boolean
                    local integer iteration = this.CountStrings(missionKey, key)
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        exitwhen (this.GetString(missionKey, key, iteration) == value)
                        set iteration = iteration - 1
                    endloop
                    if (iteration < thistype.STARTED) then
                        return false
                    endif
                    return true
                endmethod
                method PrintStrings takes string missionKey, string key returns nothing
					local integer iteration = this.CountStrings(missionKey, key)
					call DebugBufferStart()
					loop
						exitwhen (iteration < thistype.STARTED)
						call DebugBuffer((this.GetString(missionKey, key, iteration)))
						set iteration = iteration - 1
					endloop
					call DebugBufferFinish()
                endmethod
                method AddString takes string missionKey, string key, string value returns boolean
                    local integer count = this.CountStrings(missionKey, key) + 1
                    call DataTable(this).Head.StringKeys.SetInteger(missionKey, key, count - thistype.EMPTY)
                    call DataTable(this).Head.StringKeys.SetString(missionKey, key + I2S(thistype.EMPTY + count + 2), value)
                    return (count == thistype.STARTED)
                endmethod
                method RemoveString takes string missionKey, string key, string value returns boolean
                    local integer count = this.CountStrings(missionKey, key)
                    local integer iteration = count
                    loop
debug                        exitwhen (iteration < thistype.STARTED)
                        exitwhen (this.GetString(missionKey, key, iteration) == value)
                        set iteration = iteration - 1
                    endloop
debug                    if (iteration < thistype.STARTED) then
debug                        call Game.DebugMsg("Failed to remove " + (value)+" from table " + key + " of missionKey " + missionKey + " (" + I2S(count) + ")")
debug                    else
                    call DataTable(this).Head.StringKeys.SetString(missionKey, key + I2S(thistype.EMPTY + iteration + 2), this.GetString(missionKey, key, count))
                    set count = count - 1
                    call DataTable(this).Head.StringKeys.SetInteger(missionKey, key, count - thistype.EMPTY)
debug                    endif
                    return (count == thistype.EMPTY)
                endmethod
                method RandomString takes string missionKey, string key, integer lowerBound, integer higherBound returns string
                    return this.GetString(missionKey, key, Math.RandomI(lowerBound, higherBound))
                endmethod
                method RandomStringAll takes string missionKey, string key returns string
                    return this.RandomString(missionKey, key, thistype.STARTED, this.CountStrings(missionKey, key))
                endmethod
        endstruct
    endscope
    public struct StructStringKeys
        implement Allocation
        implement List
        
    FolderStringKeys_StructTable Table = this
    FolderStringKeys_StructTable LinkToStruct_Table
        method RemoveChild takes string missionKey returns nothing
            call DataTable(this).Head.StringKeys.RemoveChild(missionKey)
        endmethod
            method SetBoolean takes string missionKey, string key, boolean value returns nothing
                call DataTable(this).Head.StringKeys.SetBoolean(missionKey, key, value)
            endmethod
            method RemoveBoolean takes string missionKey, string key returns nothing
                call DataTable(this).Head.StringKeys.RemoveBoolean(missionKey, key)
            endmethod
            method GetBoolean takes string missionKey, string key returns boolean
                return DataTable(this).Head.StringKeys.GetBoolean(missionKey, key)
            endmethod
            method SetInteger takes string missionKey, string key, integer value returns nothing
                call DataTable(this).Head.StringKeys.SetInteger(missionKey, key, value)
            endmethod
            method RemoveInteger takes string missionKey, string key returns nothing
                call DataTable(this).Head.StringKeys.RemoveInteger(missionKey, key)
            endmethod
            method GetInteger takes string missionKey, string key returns integer
                return DataTable(this).Head.StringKeys.GetInteger(missionKey, key)
            endmethod
            method SetReal takes string missionKey, string key, real value returns nothing
                call DataTable(this).Head.StringKeys.SetReal(missionKey, key, value)
            endmethod
            method RemoveReal takes string missionKey, string key returns nothing
                call DataTable(this).Head.StringKeys.RemoveReal(missionKey, key)
            endmethod
            method GetReal takes string missionKey, string key returns real
                return DataTable(this).Head.StringKeys.GetReal(missionKey, key)
            endmethod
            method SetString takes string missionKey, string key, string value returns nothing
                call DataTable(this).Head.StringKeys.SetString(missionKey, key, value)
            endmethod
            method RemoveString takes string missionKey, string key returns nothing
                call DataTable(this).Head.StringKeys.RemoveString(missionKey, key)
            endmethod
            method GetString takes string missionKey, string key returns string
                return DataTable(this).Head.StringKeys.GetString(missionKey, key)
            endmethod
    endstruct
    public struct StructNative
        implement Allocation
        implement List
        
        hashtable TABLE
        static method GetHandleIdString takes handle h returns string
            return I2S(GetHandleId(h))
        endmethod
            static constant button DEFAULT_VALUE = null
            method ContainsButton takes integer missionKey, integer key returns boolean
                
                return (LoadButtonHandle(this.TABLE, missionKey, key) != thistype.DEFAULT_VALUE)
            endmethod
            method GetButton takes integer missionKey, integer key returns button
                return LoadButtonHandle(this.TABLE, missionKey, key)
            endmethod
            method SetButton takes integer missionKey, integer key, button value returns nothing
                call SaveButtonHandle(this.TABLE, missionKey, key, value)
            endmethod
            method RemoveButton takes integer missionKey, integer key returns nothing
                call this.SetButton(missionKey, key, thistype.DEFAULT_VALUE)
                
            endmethod
        method RemoveChild takes integer missionKey returns nothing
            call FlushChildHashtable(this.TABLE, missionKey)
        endmethod
		method Event_Create takes nothing returns nothing
			set this.TABLE = InitHashtable()
		endmethod
    endstruct
endscope
globals
    hashtable KEY_MACROS_TABLE
    DataTable Memory
endglobals
    globals
        DataTable DATA_TABLE = STRUCT_BASE
    endglobals
    struct DataTable
        implement Allocation
        implement List
        
	static thistype MEMORY
    FolderDataTable_StructIntegerKeys IntegerKeys = this
    FolderDataTable_StructIntegerKeys LinkToStruct_IntegerKeys
    FolderDataTable_StructNative Native = this
    FolderDataTable_StructNative LinkToStruct_Native
    FolderDataTable_StructStringKeys StringKeys = this
    FolderDataTable_StructStringKeys LinkToStruct_StringKeys
	DataTableHead Head
    static method GetKeyFromValue takes integer val returns string
        local integer tableId = thistype(NULL).IntegerKeys.Table.GetTableId(val)
        local integer tableStartId = thistype(NULL).IntegerKeys.Table.GetTableStartId(val)
		local string result
        if (tableId > 0) then
            set result = LoadStr(KEY_MACROS_TABLE, 0, tableStartId)
            if (result == HASH_TABLE.String.DEFAULT_VALUE) then
                return null
            endif
            return (Integer.ToString(tableStartId) + " (table " + Integer.ToString(tableId) + "; index " + Integer.ToString(val - tableStartId) + "): " + result)
        endif
        set result = LoadStr(KEY_MACROS_TABLE, 0, val)
        if (result == HASH_TABLE.String.DEFAULT_VALUE) then
            return null
        endif
        return (Integer.ToString(val) + " (base " + Integer.ToString(val - Math.Integer.MIN) + "): " + result)
    endmethod
	static method Create takes nothing returns thistype
		local thistype this = thistype.allocate()
		set this.Head = DataTableHead.Create()
		call this.IntegerKeys.Event_Create()
		call this.Native.Event_Create()
		
		return this
	endmethod
    initMethod Init of Header
    call InfoEx("memory")
        call DataTableHead.Init()
		set thistype.MEMORY = thistype.Create()
		set Memory = thistype.MEMORY
		call Data.Init()
    endmethod
endstruct
struct Data
	static DataTable array RANDOM_TABLES
	static integer RANDOM_TABLES_COUNT
	static method GetRandomTable takes nothing returns DataTable
		return thistype.RANDOM_TABLES[Math.RandomI(ARRAY_MIN, thistype.RANDOM_TABLES_COUNT)]
	endmethod
	static method Init takes nothing returns nothing
		set thistype.RANDOM_TABLES_COUNT = 10 + ARRAY_EMPTY
		local integer i = thistype.RANDOM_TABLES_COUNT
		loop
			exitwhen (i < ARRAY_MIN)
			set thistype.RANDOM_TABLES[i] = DataTable.Create()
			set i = i - 1
		endloop
	endmethod
endstruct
function InitObject takes integer id returns nothing
    call GetObjectName(id)
endfunction
struct InitAbilityStruct
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static unit PRELOADER_UNIT = null
endstruct
function InitAbility takes integer id, boolean extended returns nothing
    if Memory.IntegerKeys.GetBoolean(InitAbilityStruct.KEY_ARRAY, id) then
        call DebugEx("spell " + GetObjectName(id) + "(" + Integer.ToAscii(id) + ") already preloaded")
        return
    endif
    call Memory.IntegerKeys.SetBoolean(InitAbilityStruct.KEY_ARRAY, id, true)
    if (id == 0) then
        return
    endif
    call InitObject(id)
    if not extended then
        return
    endif
    if (InitAbilityStruct.PRELOADER_UNIT == null) then
        set InitAbilityStruct.PRELOADER_UNIT = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), DummyUnit.PRELOADER_ID, 0, 0, 0)
    endif
    if UnitAddAbility(InitAbilityStruct.PRELOADER_UNIT, id) then
        call UnitRemoveAbility(InitAbilityStruct.PRELOADER_UNIT, id)
    endif
endfunction
function InitBuff takes integer id returns nothing
    call InitObject(id)
endfunction
    globals
        Animation ANIMATION = STRUCT_BASE
    endglobals
    struct Animation
        implement Allocation
        implement List
        
    static constant string ATTACK = "attack"
    static constant string BIRTH = "birth"
    static constant string CHANNEL = "channel"
    static constant string DEATH = "death"
    static constant string STAND = "stand"
    static constant string STAND_READY = "stand ready"
    static constant string SPELL = "spell"
    static constant string SPELL_SLAM = "spell slam"
    static constant string VICTORY = "victory"
endstruct
    globals
        AttachPoint ATTACH_POINT = STRUCT_BASE
    endglobals
    struct AttachPoint
        implement Allocation
        implement List
        
    static constant string CHEST = "chest"
    static constant string CHEST_MOUNT_LEFT = "chest mount left"
    static constant string CHEST_MOUNT_RIGHT = "chest mount right"
    static constant string FOOT = "foot"
    static constant string FOOT_LEFT = "foot left"
    static constant string FOOT_RIGHT = "foot right"
    static constant string HAND = "hand"
    static constant string HAND_LEFT = "hand left"
    static constant string HAND_RIGHT = "hand right"
    static constant string HEAD = "head"
    static constant string MOUNT = "mount"
    static constant string MOUNT_LEFT = "mount left"
    static constant string MOUNT_RIGHT = "mount right"
    static constant string ORIGIN = "origin"
    static constant string OVERHEAD = "overhead"
    static constant string WEAPON = "weapon"
    static constant string WEAPON_LEFT = "weapon left"
    static constant string WEAPON_RIGHT = "weapon right"
endstruct
    globals
        Attack ATTACK = STRUCT_BASE
    endglobals
    struct Attack
        implement Allocation
        implement List
        
    static constant real ARMOR_REDUCTION_FACTOR = 0.06
    static thistype NORMAL = 1
    static thistype MISSILE = 2
    static thistype HOMING_MISSILE = 3
    static thistype ARTILLERY = 4
    static constant integer ARMOR_TYPE_LIGHT = 0
    static constant integer ARMOR_TYPE_MEDIUM = 1
    static constant integer ARMOR_TYPE_LARGE = 2
    static constant integer ARMOR_TYPE_FORT = 3
    static constant integer ARMOR_TYPE_HERO = 4
    static constant integer ARMOR_TYPE_UNARMORED = 5
    static constant integer ARMOR_TYPE_DIVINE = 6
    static constant integer ARMOR_TYPES_AMOUNT = 7
    static real array MULTIPLIERS
    static constant integer DMG_TYPE_NORMAL = 0
    static constant integer DMG_TYPE_PIERCE = 1
    static constant integer DMG_TYPE_SIEGE = 2
    static constant integer DMG_TYPE_MAGIC = 3
    static constant integer DMG_TYPE_CHAOS = 4
    static constant integer DMG_TYPE_HERO = 5
    static constant integer DMG_TYPE_SPELLS = 6
    static method Get takes integer whichDamageType, integer whichArmorType returns real
        return thistype.MULTIPLIERS[whichDamageType * thistype.ARMOR_TYPES_AMOUNT + whichArmorType]
    endmethod
    static method Create takes integer whichDamageType, integer whichArmorType, real amount returns nothing
        set thistype.MULTIPLIERS[whichDamageType * thistype.ARMOR_TYPES_AMOUNT + whichArmorType] = amount
    endmethod
    initMethod Init of Header
        call thistype.Create(thistype.DMG_TYPE_NORMAL, thistype.ARMOR_TYPE_LIGHT, 1.)
        call thistype.Create(thistype.DMG_TYPE_NORMAL, thistype.ARMOR_TYPE_MEDIUM, 1.35)
        call thistype.Create(thistype.DMG_TYPE_NORMAL, thistype.ARMOR_TYPE_LARGE, 1.)
        call thistype.Create(thistype.DMG_TYPE_NORMAL, thistype.ARMOR_TYPE_FORT, 0.7)
        call thistype.Create(thistype.DMG_TYPE_NORMAL, thistype.ARMOR_TYPE_HERO, 1.)
        call thistype.Create(thistype.DMG_TYPE_NORMAL, thistype.ARMOR_TYPE_UNARMORED, 1.)
        call thistype.Create(thistype.DMG_TYPE_NORMAL, thistype.ARMOR_TYPE_DIVINE, 1.)
        call thistype.Create(thistype.DMG_TYPE_PIERCE, thistype.ARMOR_TYPE_LIGHT, 1.5)
        call thistype.Create(thistype.DMG_TYPE_PIERCE, thistype.ARMOR_TYPE_MEDIUM, 0.7)
        call thistype.Create(thistype.DMG_TYPE_PIERCE, thistype.ARMOR_TYPE_LARGE, 1.)
        call thistype.Create(thistype.DMG_TYPE_PIERCE, thistype.ARMOR_TYPE_FORT, 0.35)
        call thistype.Create(thistype.DMG_TYPE_PIERCE, thistype.ARMOR_TYPE_HERO, 0.5)
        call thistype.Create(thistype.DMG_TYPE_PIERCE, thistype.ARMOR_TYPE_UNARMORED, 1.35)
        call thistype.Create(thistype.DMG_TYPE_PIERCE, thistype.ARMOR_TYPE_DIVINE, 1.)
        call thistype.Create(thistype.DMG_TYPE_SIEGE, thistype.ARMOR_TYPE_LIGHT, 1.)
        call thistype.Create(thistype.DMG_TYPE_SIEGE, thistype.ARMOR_TYPE_MEDIUM, 0.65)
        call thistype.Create(thistype.DMG_TYPE_SIEGE, thistype.ARMOR_TYPE_LARGE, 1.)
        call thistype.Create(thistype.DMG_TYPE_SIEGE, thistype.ARMOR_TYPE_FORT, 1.5)
        call thistype.Create(thistype.DMG_TYPE_SIEGE, thistype.ARMOR_TYPE_HERO, 0.35)
        call thistype.Create(thistype.DMG_TYPE_SIEGE, thistype.ARMOR_TYPE_UNARMORED, 1.)
        call thistype.Create(thistype.DMG_TYPE_SIEGE, thistype.ARMOR_TYPE_DIVINE, 1.)
        call thistype.Create(thistype.DMG_TYPE_MAGIC, thistype.ARMOR_TYPE_LIGHT, 1.25)
        call thistype.Create(thistype.DMG_TYPE_MAGIC, thistype.ARMOR_TYPE_MEDIUM, 0.75)
        call thistype.Create(thistype.DMG_TYPE_MAGIC, thistype.ARMOR_TYPE_LARGE, 1.5)
        call thistype.Create(thistype.DMG_TYPE_MAGIC, thistype.ARMOR_TYPE_FORT, 0.35)
        call thistype.Create(thistype.DMG_TYPE_MAGIC, thistype.ARMOR_TYPE_HERO, 0.5)
        call thistype.Create(thistype.DMG_TYPE_MAGIC, thistype.ARMOR_TYPE_UNARMORED, 1.)
        call thistype.Create(thistype.DMG_TYPE_MAGIC, thistype.ARMOR_TYPE_DIVINE, 1.)
        call thistype.Create(thistype.DMG_TYPE_CHAOS, thistype.ARMOR_TYPE_LIGHT, 1.)
        call thistype.Create(thistype.DMG_TYPE_CHAOS, thistype.ARMOR_TYPE_MEDIUM, 1.)
        call thistype.Create(thistype.DMG_TYPE_CHAOS, thistype.ARMOR_TYPE_LARGE, 1.)
        call thistype.Create(thistype.DMG_TYPE_CHAOS, thistype.ARMOR_TYPE_FORT, 1.)
        call thistype.Create(thistype.DMG_TYPE_CHAOS, thistype.ARMOR_TYPE_HERO, 1.)
        call thistype.Create(thistype.DMG_TYPE_CHAOS, thistype.ARMOR_TYPE_UNARMORED, 1.)
        call thistype.Create(thistype.DMG_TYPE_CHAOS, thistype.ARMOR_TYPE_DIVINE, 1.)
        call thistype.Create(thistype.DMG_TYPE_HERO, thistype.ARMOR_TYPE_LIGHT, 1.)
        call thistype.Create(thistype.DMG_TYPE_HERO, thistype.ARMOR_TYPE_MEDIUM, 1.)
        call thistype.Create(thistype.DMG_TYPE_HERO, thistype.ARMOR_TYPE_LARGE, 1.)
        call thistype.Create(thistype.DMG_TYPE_HERO, thistype.ARMOR_TYPE_FORT, 1.)
        call thistype.Create(thistype.DMG_TYPE_HERO, thistype.ARMOR_TYPE_HERO, 1.)
        call thistype.Create(thistype.DMG_TYPE_HERO, thistype.ARMOR_TYPE_UNARMORED, 1.)
        call thistype.Create(thistype.DMG_TYPE_HERO, thistype.ARMOR_TYPE_DIVINE, 1.)
        call thistype.Create(thistype.DMG_TYPE_SPELLS, thistype.ARMOR_TYPE_LIGHT, 1.)
        call thistype.Create(thistype.DMG_TYPE_SPELLS, thistype.ARMOR_TYPE_MEDIUM, 1.)
        call thistype.Create(thistype.DMG_TYPE_SPELLS, thistype.ARMOR_TYPE_LARGE, 1.)
        call thistype.Create(thistype.DMG_TYPE_SPELLS, thistype.ARMOR_TYPE_FORT, 0.5)
        call thistype.Create(thistype.DMG_TYPE_SPELLS, thistype.ARMOR_TYPE_HERO, 1.)
        call thistype.Create(thistype.DMG_TYPE_SPELLS, thistype.ARMOR_TYPE_UNARMORED, 1.)
        call thistype.Create(thistype.DMG_TYPE_SPELLS, thistype.ARMOR_TYPE_DIVINE, 1.)
    endmethod
endstruct
    scope FolderEventResponse
    public struct StructAct
        implement Allocation
        implement List
        
    Act trigger
    method GetTrigger takes nothing returns Act
        return this.trigger
    endmethod
    method SetTrigger takes Act value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructAura
        implement Allocation
        implement List
        
    Aura trigger
    method GetTrigger takes nothing returns Aura
        return this.trigger
    endmethod
    method SetTrigger takes Aura value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructBool
        implement Allocation
        implement List
        
    boolean added
    method GetAdded takes nothing returns boolean
        return this.added
    endmethod
    method SetAdded takes boolean value returns nothing
        set this.added = value
    endmethod
    boolean val
    method GetVal takes nothing returns boolean
        return this.val
    endmethod
    method SetVal takes boolean value returns nothing
        set this.val = value
    endmethod
    endstruct
    public struct StructBuff
        implement Allocation
        implement List
        
    integer data
    method GetData takes nothing returns integer
        return this.data
    endmethod
    method SetData takes integer value returns nothing
        set this.data = value
    endmethod
    Buff trigger
    method GetTrigger takes nothing returns Buff
        return this.trigger
    endmethod
    method SetTrigger takes Buff value returns nothing
        set this.trigger = value
    endmethod
    integer level
    method GetLevel takes nothing returns integer
        return this.level
    endmethod
    method SetLevel takes integer value returns nothing
        set this.level = value
    endmethod
    integer sourceLevel
    method GetSourceLevel takes nothing returns integer
        return this.sourceLevel
    endmethod
    method SetSourceLevel takes integer value returns nothing
        set this.sourceLevel = value
    endmethod
    endstruct
    public struct StructDefenderSpawnType
        implement Allocation
        implement List
        
    DefenderSpawnType trigger
    method GetTrigger takes nothing returns DefenderSpawnType
        return this.trigger
    endmethod
    method SetTrigger takes DefenderSpawnType value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructDestructable
        implement Allocation
        implement List
        
    Destructable trigger
    method GetTrigger takes nothing returns Destructable
        return this.trigger
    endmethod
    method SetTrigger takes Destructable value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructDestructableType
        implement Allocation
        implement List
        
    DestructableType trigger
    method GetTrigger takes nothing returns DestructableType
        return this.trigger
    endmethod
    method SetTrigger takes DestructableType value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructDialog
        implement Allocation
        implement List
        
    Dialog trigger
    method GetTrigger takes nothing returns Dialog
        return this.trigger
    endmethod
    method SetTrigger takes Dialog value returns nothing
        set this.trigger = value
    endmethod
    DialogButton triggerButton
    method GetTriggerButton takes nothing returns DialogButton
        return this.triggerButton
    endmethod
    method SetTriggerButton takes DialogButton value returns nothing
        set this.triggerButton = value
    endmethod
    endstruct
    public struct StructDummyUnit
        implement Allocation
        implement List
        
    DummyUnit trigger
    method GetTrigger takes nothing returns DummyUnit
        return this.trigger
    endmethod
    method SetTrigger takes DummyUnit value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructDynamic
        implement Allocation
        implement List
        
    static key GetKeyMacro_LOCAL_KEY
    static constant integer LOCAL_KEY = Math.Integer.MIN + GetKeyMacro_LOCAL_KEY
            method GetBoolean takes integer key returns boolean
                return Memory.IntegerKeys.D2.GetBoolean(LOCAL_KEY, this, key, NULL, NULL)
            endmethod
            method SetBoolean takes integer key, boolean val returns nothing
                call Memory.IntegerKeys.D2.SetBoolean(LOCAL_KEY, this, key, NULL, NULL, val)
            endmethod
            method GetInteger takes integer key returns integer
                return Memory.IntegerKeys.D2.GetInteger(LOCAL_KEY, this, key, NULL, NULL)
            endmethod
            method SetInteger takes integer key, integer val returns nothing
                call Memory.IntegerKeys.D2.SetInteger(LOCAL_KEY, this, key, NULL, NULL, val)
            endmethod
            method GetReal takes integer key returns real
                return Memory.IntegerKeys.D2.GetReal(LOCAL_KEY, this, key, NULL, NULL)
            endmethod
            method SetReal takes integer key, real val returns nothing
                call Memory.IntegerKeys.D2.SetReal(LOCAL_KEY, this, key, NULL, NULL, val)
            endmethod
            method GetString takes integer key returns string
                return Memory.IntegerKeys.D2.GetString(LOCAL_KEY, this, key, NULL, NULL)
            endmethod
            method SetString takes integer key, string val returns nothing
                call Memory.IntegerKeys.D2.SetString(LOCAL_KEY, this, key, NULL, NULL, val)
            endmethod
    endstruct
    public struct StructEvent
        implement Allocation
        implement List
        
    Event trigger
    method GetTrigger takes nothing returns Event
        return this.trigger
    endmethod
    method SetTrigger takes Event value returns nothing
        set this.trigger = value
    endmethod
		method Destroy takes nothing returns nothing
		endmethod
    endstruct
    public struct StructItem
        implement Allocation
        implement List
        
    Item target
    method GetTarget takes nothing returns Item
        return this.target
    endmethod
    method SetTarget takes Item value returns nothing
        set this.target = value
    endmethod
    integer targetSlot
    method GetTargetSlot takes nothing returns integer
        return this.targetSlot
    endmethod
    method SetTargetSlot takes integer value returns nothing
        set this.targetSlot = value
    endmethod
    Item trigger
    method GetTrigger takes nothing returns Item
        return this.trigger
    endmethod
    method SetTrigger takes Item value returns nothing
        set this.trigger = value
    endmethod
    integer triggerSlot
    method GetTriggerSlot takes nothing returns integer
        return this.triggerSlot
    endmethod
    method SetTriggerSlot takes integer value returns nothing
        set this.triggerSlot = value
    endmethod
    endstruct
    public struct StructItemType
        implement Allocation
        implement List
        
    ItemType trigger
    method GetTrigger takes nothing returns ItemType
        return this.trigger
    endmethod
    method SetTrigger takes ItemType value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructLevel
        implement Allocation
        implement List
        
    Level trigger
    method GetTrigger takes nothing returns Level
        return this.trigger
    endmethod
    method SetTrigger takes Level value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructLightning
        implement Allocation
        implement List
        
    Lightning trigger
    method GetTrigger takes nothing returns Lightning
        return this.trigger
    endmethod
    method SetTrigger takes Lightning value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructMissile
        implement Allocation
        implement List
        
    Missile trigger
    method GetTrigger takes nothing returns Missile
        return this.trigger
    endmethod
    method SetTrigger takes Missile value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructMissileCheckpoint
        implement Allocation
        implement List
        
    MissileCheckpoint trigger
    method GetTrigger takes nothing returns MissileCheckpoint
        return this.trigger
    endmethod
    method SetTrigger takes MissileCheckpoint value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructOrder
        implement Allocation
        implement List
        
    Order trigger
    method GetTrigger takes nothing returns Order
        return this.trigger
    endmethod
    method SetTrigger takes Order value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructReal
        implement Allocation
        implement List
        
    real damage
    method GetDamage takes nothing returns real
        return this.damage
    endmethod
    method SetDamage takes real value returns nothing
        set this.damage = value
    endmethod
    real distanceSquare
    method GetDistanceSquare takes nothing returns real
        return this.distanceSquare
    endmethod
    method SetDistanceSquare takes real value returns nothing
        set this.distanceSquare = value
    endmethod
    real healedAmount
    method GetHealedAmount takes nothing returns real
        return this.healedAmount
    endmethod
    method SetHealedAmount takes real value returns nothing
        set this.healedAmount = value
    endmethod
    real intervalWeight
    method GetIntervalWeight takes nothing returns real
        return this.intervalWeight
    endmethod
    method SetIntervalWeight takes real value returns nothing
        set this.intervalWeight = value
    endmethod
    real val
    method GetVal takes nothing returns real
        return this.val
    endmethod
    method SetVal takes real value returns nothing
        set this.val = value
    endmethod
    endstruct
    public struct StructRect
        implement Allocation
        implement List
        
    Rectangle trigger
    method GetTrigger takes nothing returns Rectangle
        return this.trigger
    endmethod
    method SetTrigger takes Rectangle value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructRegion
        implement Allocation
        implement List
        
    Region trigger
    method GetTrigger takes nothing returns Region
        return this.trigger
    endmethod
    method SetTrigger takes Region value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructSpawnType
        implement Allocation
        implement List
        
    SpawnType trigger
    method GetTrigger takes nothing returns SpawnType
        return this.trigger
    endmethod
    method SetTrigger takes SpawnType value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructSpell
        implement Allocation
        implement List
        
    boolean channelComplete
    method IsChannelComplete takes nothing returns boolean
        return this.channelComplete
    endmethod
    method SetChannelComplete takes boolean value returns nothing
        set this.channelComplete = value
    endmethod
    Spell source
    method GetSource takes nothing returns Spell
        return this.source
    endmethod
    method SetSource takes Spell value returns nothing
        set this.source = value
    endmethod
    Spell trigger
    method GetTrigger takes nothing returns Spell
        return this.trigger
    endmethod
    method SetTrigger takes Spell value returns nothing
        set this.trigger = value
    endmethod
    integer level
    method GetLevel takes nothing returns integer
        return this.level
    endmethod
    method SetLevel takes integer value returns nothing
        set this.level = value
    endmethod
    endstruct
    public struct StructSpellInstance
        implement Allocation
        implement List
        
    SpellInstance trigger
    method GetTrigger takes nothing returns SpellInstance
        return this.trigger
    endmethod
    method SetTrigger takes SpellInstance value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructSpot
        implement Allocation
        implement List
        
    real targetX
    method GetTargetX takes nothing returns real
        return this.targetX
    endmethod
    method SetTargetX takes real value returns nothing
        set this.targetX = value
    endmethod
    real targetY
    method GetTargetY takes nothing returns real
        return this.targetY
    endmethod
    method SetTargetY takes real value returns nothing
        set this.targetY = value
    endmethod
    endstruct
    public struct StructString
        implement Allocation
        implement List
        
    string chat
    method GetChat takes nothing returns string
        return this.chat
    endmethod
    method SetChat takes string value returns nothing
        set this.chat = value
    endmethod
    string match
    method GetMatch takes nothing returns string
        return this.match
    endmethod
    method SetMatch takes string value returns nothing
        set this.match = value
    endmethod
    endstruct
    public struct StructTile
        implement Allocation
        implement List
        
    Tile trigger
    method GetTrigger takes nothing returns Tile
        return this.trigger
    endmethod
    method SetTrigger takes Tile value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructUbersplat
        implement Allocation
        implement List
        
    Ubersplat trigger
    method GetTrigger takes nothing returns Ubersplat
        return this.trigger
    endmethod
    method SetTrigger takes Ubersplat value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructUnit
        implement Allocation
        implement List
        
    Unit damager
    method GetDamager takes nothing returns Unit
        return this.damager
    endmethod
    method SetDamager takes Unit value returns nothing
        set this.damager = value
    endmethod
    Unit killer
    method GetKiller takes nothing returns Unit
        return this.killer
    endmethod
    method SetKiller takes Unit value returns nothing
        set this.killer = value
    endmethod
    Unit target
    method GetTarget takes nothing returns Unit
        return this.target
    endmethod
    method SetTarget takes Unit value returns nothing
        set this.target = value
    endmethod
    Unit trigger
    method GetTrigger takes nothing returns Unit
        return this.trigger
    endmethod
    method SetTrigger takes Unit value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructUnitEffect
        implement Allocation
        implement List
        
    UnitEffect trigger
    method GetTrigger takes nothing returns UnitEffect
        return this.trigger
    endmethod
    method SetTrigger takes UnitEffect value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructUnitMod
        implement Allocation
        implement List
        
    UnitMod trigger
    method GetTrigger takes nothing returns UnitMod
        return this.trigger
    endmethod
    method SetTrigger takes UnitMod value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructUnitType
        implement Allocation
        implement List
        
    UnitType source
    method GetSource takes nothing returns UnitType
        return this.source
    endmethod
    method SetSource takes UnitType value returns nothing
        set this.source = value
    endmethod
    UnitType target
    method GetTarget takes nothing returns UnitType
        return this.target
    endmethod
    method SetTarget takes UnitType value returns nothing
        set this.target = value
    endmethod
    UnitType trigger
    method GetTrigger takes nothing returns UnitType
        return this.trigger
    endmethod
    method SetTrigger takes UnitType value returns nothing
        set this.trigger = value
    endmethod
    endstruct
    public struct StructUser
        implement Allocation
        implement List
        
    User trigger
    method GetTrigger takes nothing returns User
        return this.trigger
    endmethod
    method SetTrigger takes User value returns nothing
        set this.trigger = value
    endmethod
    User source
    method GetSource takes nothing returns User
        return this.source
    endmethod
    method SetSource takes User value returns nothing
        set this.source = value
    endmethod
    User target
    method GetTarget takes nothing returns User
        return this.target
    endmethod
    method SetTarget takes User value returns nothing
        set this.target = value
    endmethod
    endstruct
endscope
    globals
        EventResponse EVENT_RESPONSE = STRUCT_BASE
    endglobals
    struct EventResponse
        implement Allocation
        implement List
        
    static constant integer DIRECT_SUBJECT_ID = 0
    static constant integer STATIC_SUBJECT_ID = 0
    static constant integer STRING_DATA_SUBJECT_ID = 0
    static thistype TRIGGER
    static method GetTrigger takes nothing returns thistype
        return thistype.TRIGGER
    endmethod
    static method SetTrigger takes thistype value returns nothing
        set thistype.TRIGGER = value
    endmethod
    integer data
    method GetData takes nothing returns integer
        return this.data
    endmethod
    method SetData takes integer value returns nothing
        set this.data = value
    endmethod
    integer subjectId
    method GetSubjectId takes nothing returns integer
        return this.subjectId
    endmethod
    method SetSubjectId takes integer value returns nothing
        set this.subjectId = value
    endmethod
    FolderEventResponse_StructAct Act = this
    FolderEventResponse_StructAct LinkToStruct_Act
    FolderEventResponse_StructAura Aura = this
    FolderEventResponse_StructAura LinkToStruct_Aura
    FolderEventResponse_StructBool Bool = this
    FolderEventResponse_StructBool LinkToStruct_Bool
    FolderEventResponse_StructBuff Buff = this
    FolderEventResponse_StructBuff LinkToStruct_Buff
    FolderEventResponse_StructDefenderSpawnType DefenderSpawnType = this
    FolderEventResponse_StructDefenderSpawnType LinkToStruct_DefenderSpawnType
    FolderEventResponse_StructDestructable Destructable = this
    FolderEventResponse_StructDestructable LinkToStruct_Destructable
    FolderEventResponse_StructDestructableType DestructableType = this
    FolderEventResponse_StructDestructableType LinkToStruct_DestructableType
    FolderEventResponse_StructDialog Dialog = this
    FolderEventResponse_StructDialog LinkToStruct_Dialog
    FolderEventResponse_StructDummyUnit DummyUnit = this
    FolderEventResponse_StructDummyUnit LinkToStruct_DummyUnit
    FolderEventResponse_StructDynamic Dynamic = this
    FolderEventResponse_StructDynamic LinkToStruct_Dynamic
    FolderEventResponse_StructEvent Event = this
    FolderEventResponse_StructEvent LinkToStruct_Event
    FolderEventResponse_StructItem Item = this
    FolderEventResponse_StructItem LinkToStruct_Item
    FolderEventResponse_StructItemType ItemType = this
    FolderEventResponse_StructItemType LinkToStruct_ItemType
    FolderEventResponse_StructLevel Level = this
    FolderEventResponse_StructLevel LinkToStruct_Level
    FolderEventResponse_StructLightning Lightning = this
    FolderEventResponse_StructLightning LinkToStruct_Lightning
    FolderEventResponse_StructMissile Missile = this
    FolderEventResponse_StructMissile LinkToStruct_Missile
    FolderEventResponse_StructMissileCheckpoint MissileCheckpoint = this
    FolderEventResponse_StructMissileCheckpoint LinkToStruct_MissileCheckpoint
    FolderEventResponse_StructOrder Order = this
    FolderEventResponse_StructOrder LinkToStruct_Order
    FolderEventResponse_StructReal Real = this
    FolderEventResponse_StructReal LinkToStruct_Real
    FolderEventResponse_StructRect Rect = this
    FolderEventResponse_StructRect LinkToStruct_Rect
    FolderEventResponse_StructRegion Region = this
    FolderEventResponse_StructRegion LinkToStruct_Region
    FolderEventResponse_StructSpawnType SpawnType = this
    FolderEventResponse_StructSpawnType LinkToStruct_SpawnType
    FolderEventResponse_StructSpell Spell = this
    FolderEventResponse_StructSpell LinkToStruct_Spell
    FolderEventResponse_StructSpellInstance SpellInstance = this
    FolderEventResponse_StructSpellInstance LinkToStruct_SpellInstance
    FolderEventResponse_StructSpot Spot = this
    FolderEventResponse_StructSpot LinkToStruct_Spot
    FolderEventResponse_StructString String = this
    FolderEventResponse_StructString LinkToStruct_String
    FolderEventResponse_StructTile Tile = this
    FolderEventResponse_StructTile LinkToStruct_Tile
    FolderEventResponse_StructUbersplat Ubersplat = this
    FolderEventResponse_StructUbersplat LinkToStruct_Ubersplat
    FolderEventResponse_StructUnit Unit = this
    FolderEventResponse_StructUnit LinkToStruct_Unit
    FolderEventResponse_StructUnitEffect UnitEffect = this
    FolderEventResponse_StructUnitEffect LinkToStruct_UnitEffect
    FolderEventResponse_StructUnitMod UnitMod = this
    FolderEventResponse_StructUnitMod LinkToStruct_UnitMod
    FolderEventResponse_StructUnitType UnitType = this
    FolderEventResponse_StructUnitType LinkToStruct_UnitType
    FolderEventResponse_StructUser User = this
    FolderEventResponse_StructUser LinkToStruct_User
    method Destroy takes nothing returns nothing
        call this.deallocate()
    endmethod
    static method Create takes integer subjectId returns thistype
        local thistype this = thistype.allocate()
        call this.SetSubjectId(subjectId)
        return this
    endmethod
endstruct
    globals
        EventPriority EVENT_PRIORITY = STRUCT_BASE
    endglobals
    struct EventPriority
        implement Allocation
        implement List
        
    static integer ALL_AMOUNT
    static thistype AI
    static thistype COMBINATION
    static thistype CONTENT
    static thistype CONTENT2
    static thistype EVENTS
    static thistype HEADER
    static thistype HEADER_TOP
    static thistype ITEMS
    static thistype MISC
    static thistype MISC2
    static thistype SPEECHES
    static thistype SPELLS
    static thistype UNIT_TYPES
    string name
    method GetName takes nothing returns string
        return this.name
    endmethod
    method SetName takes string value returns nothing
        set this.name = value
    endmethod
    static method Create takes string name returns thistype
        local thistype this = thistype.allocate()
        call this.SetName(name)
        call this.AddToList()
        return this
    endmethod
    static method Init takes nothing returns nothing
        set thistype.HEADER = thistype.Create("Header")
        set thistype.HEADER_TOP = thistype.Create("HeaderTop")
        set thistype.COMBINATION = thistype.Create("Combination")
        set thistype.AI = thistype.Create("AI")
        set thistype.EVENTS = thistype.Create("Events")
        set thistype.CONTENT = thistype.Create("Content")
        set thistype.CONTENT2 = thistype.Create("Content2")
        set thistype.ITEMS = thistype.CONTENT
        set thistype.MISC = thistype.CONTENT
        set thistype.MISC2 = thistype.CONTENT2
        set thistype.SPEECHES = thistype.CONTENT
        set thistype.SPELLS = thistype.CONTENT
        set thistype.UNIT_TYPES = thistype.CONTENT
        set thistype.ALL_AMOUNT = thistype.ALL_COUNT + 1
    endmethod
endstruct
    globals
        EventType EVENT_TYPE = STRUCT_BASE
    endglobals
    struct EventType
        implement Allocation
        implement List
        
    static thistype START
    static method Create takes nothing returns thistype
        return thistype.allocate()
    endmethod
    static method Init takes nothing returns nothing
        set thistype.START = thistype.Create()
    endmethod
endstruct
    scope FolderEvent
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    public struct StructBoolean
        implement Allocation
        implement List
        
    method Get takes integer key returns boolean
        return Event(this).Data.table.IntegerKeys.GetBoolean(Event(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Event(this).Data.table.IntegerKeys.RemoveBoolean(Event(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call Event(this).Data.table.IntegerKeys.SetBoolean(Event(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return Event(this).Data.table.IntegerKeys.Table.ContainsInteger(Event(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Event(this).Data.table.IntegerKeys.Table.CountIntegers(Event(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Event(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Event(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Event(this).Data.table.IntegerKeys.Table.GetInteger(Event(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Event(this).Data.table.IntegerKeys.Table.GetFirstInteger(Event(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Event(this).Data.table.IntegerKeys.Table.GetLastInteger(Event(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Event(this).Data.table.IntegerKeys.Table.Clear(Event(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Event(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Event(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Event(this).Data.table.IntegerKeys.Table.RemoveInteger(Event(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Event(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Event(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Event(this).Data.table.IntegerKeys.Table.AddInteger(Event(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Event(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Event(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Event(this).Data.table.IntegerKeys.Table.JoinInteger(Event(this).Id.Get(), key, Event(other).Data.table, Event(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Event(this).Data.table.IntegerKeys.Table.RandomInteger(Event(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Event(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Event(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Event(this).Data.table.IntegerKeys.Table.PrintIntegers(Event(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return Event(this).Data.table.IntegerKeys.GetInteger(Event(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Event(this).Data.table.IntegerKeys.RemoveInteger(Event(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Event(this).Data.table.IntegerKeys.SetInteger(Event(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Event(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Event.Allocation.deallocate_demount.hook
		call Event(this).Data.Destroy()
	endinject
	inject Event.Allocation.allocate_mount.hook
		call Event(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructLimit
        implement Allocation
        implement List
        
        boolean is
        integer value
        limitop whichOperator
        method GetValue takes nothing returns integer
            return this.value
        endmethod
        method GetOperator takes nothing returns limitop
            return this.whichOperator
        endmethod
        method Is takes nothing returns boolean
            return this.is
        endmethod
        method Set takes integer value, limitop whichOperator returns nothing
            set this.is = true
            set this.value = value
            set this.whichOperator = whichOperator
        endmethod
        method Event_Create takes nothing returns nothing
            set this.is = false
            set this.value = 0
            set this.whichOperator = null
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
endscope
    globals
        Event EVENT = STRUCT_BASE
    endglobals
    struct Event
        implement Allocation
        implement List
        
    static EventType DESTROY_EVENT_TYPE
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static constant integer KEY_ARRAY = 1
    static key GetKeyMacro_STATICS_KEY
    static constant integer STATICS_KEY = Math.Integer.MIN + GetKeyMacro_STATICS_KEY
    static key GetKeyMacro_STATICS_PARENT_KEY
    static constant integer STATICS_PARENT_KEY = Math.Integer.MIN + GetKeyMacro_STATICS_PARENT_KEY
	static DataTable array RANDOM_TABLES
	static integer RANDOM_TABLES_COUNT
    Trigger action
    FolderEvent_StructData Data = this
    FolderEvent_StructData LinkToStruct_Data
    FolderEvent_StructId Id = this
    FolderEvent_StructId LinkToStruct_Id
    FolderEvent_StructLimit Limit = this
    FolderEvent_StructLimit LinkToStruct_Limit
    static thistype TRIGGER
    static method GetTrigger takes nothing returns thistype
        return thistype.TRIGGER
    endmethod
    static method SetTrigger takes thistype value returns nothing
        set thistype.TRIGGER = value
    endmethod
    integer key
    method GetKey takes nothing returns integer
        return this.key
    endmethod
    method SetKey takes integer value returns nothing
        set this.key = value
    endmethod
    string name
    method GetName takes nothing returns string
        return this.name
    endmethod
    method SetName takes string value returns nothing
        set this.name = value
    endmethod
    EventPriority priority
    method GetPriority takes nothing returns EventPriority
        return this.priority
    endmethod
    method SetPriority takes EventPriority value returns nothing
        set this.priority = value
    endmethod
    EventResponse response
    method GetResponse takes nothing returns EventResponse
        return this.response
    endmethod
    method SetResponse takes EventResponse value returns nothing
        set this.response = value
    endmethod
    BoolExpr whichConditions
    method GetConditions takes nothing returns BoolExpr
        return this.whichConditions
    endmethod
    method SetConditions takes BoolExpr value returns nothing
        set this.whichConditions = value
    endmethod
    EventType whichType
    method GetType takes nothing returns EventType
        return this.whichType
    endmethod
    method SetType takes EventType value returns nothing
        set this.whichType = value
    endmethod
	static method GetRandomTable takes nothing returns DataTable
		return thistype.RANDOM_TABLES[Math.RandomI(ARRAY_MIN, thistype.RANDOM_TABLES_COUNT)]
	endmethod
    static method GetKeyFromTypePriority takes EventType whichType, EventPriority priority returns integer
        return KEY_ARRAY + Memory.IntegerKeys.Table.SIZE * ((whichType - 1) * EventPriority.ALL_AMOUNT + (priority - 1))
    endmethod
    method GetAction takes nothing returns Trigger
        return this.action
    endmethod
    static method GetFromAction takes Trigger action returns thistype
        return action.Data.Integer.Get(KEY)
    endmethod
	method GetNameEx takes nothing returns string
		if (this.action != NULL) then
			if (this.action.GetNameEx() != null) then
				return this.action.GetNameEx()
			endif
		endif
		return this.name
	endmethod
    method Destroy_TriggerEvents takes nothing returns nothing
        local integer iteration = EventPriority.ALL_COUNT
        local integer iteration2
        local EventResponse params = EventResponse.Create(this.Id.Get())
        local EventPriority priority
        call params.Event.SetTrigger(this)
        loop
            exitwhen (iteration < ARRAY_MIN)
            set priority = EventPriority.ALL[iteration]
            set iteration2 = this.CountEvents(thistype.DESTROY_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.GetEvent(thistype.DESTROY_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    method Destroy takes nothing returns nothing
        call this.Destroy_TriggerEvents()
        call this.deallocate()        
    endmethod
    method CountEvents takes EventType whichType, EventPriority priority returns integer
        return Event(this).Data.Integer.Table.Count(Event.GetKeyFromTypePriority(whichType, priority))
    endmethod
    method GetEvent takes EventType whichType, EventPriority priority, integer index returns Event
        return Event(this).Data.Integer.Table.Get(Event.GetKeyFromTypePriority(whichType, priority), index)
    endmethod
    method RemoveEvent takes Event whichEvent returns nothing
        call Event(this).Data.Integer.Table.Remove(whichEvent.GetKey(), whichEvent)
    endmethod
    method AddEvent takes Event whichEvent returns nothing
        call Event(this).Data.Integer.Table.Add(whichEvent.GetKey(), whichEvent)
    endmethod
    static method CountAtStatics takes EventType whichType, EventPriority priority returns integer
        return Memory.IntegerKeys.Table.CountIntegers(STATICS_PARENT_KEY, thistype.GetKeyFromTypePriority(whichType, priority))
    endmethod
    static method GetFromStatics takes EventType whichType, EventPriority priority, integer index returns thistype
        return Memory.IntegerKeys.Table.GetInteger(STATICS_PARENT_KEY, thistype.GetKeyFromTypePriority(whichType, priority), index)
    endmethod
    method IsStatic takes nothing returns boolean
        return this.Data.Boolean.Get(STATICS_KEY)
    endmethod
    method RemoveFromStatics takes nothing returns nothing
        call this.Data.Boolean.Set(STATICS_KEY, false)
        call Memory.IntegerKeys.Table.RemoveInteger(STATICS_PARENT_KEY, this.GetKey(), this)
    endmethod
    method AddToStatics takes nothing returns nothing
if (this == NULL) then
	call DebugEx("event is null")
endif
        call this.Data.Boolean.Set(STATICS_KEY, true)
        call Memory.IntegerKeys.Table.AddInteger(STATICS_PARENT_KEY, this.GetKey(), this)
    endmethod
    method Run takes EventResponse params returns nothing
        call thistype.SetTrigger(this)
        call EventResponse.SetTrigger(params)
        if this.GetConditions().Run() then
            call this.GetAction().Run()
        endif
    endmethod
    method SetAction takes code actionFunction returns nothing
        local Trigger action = this.GetAction()
        if (action != NULL) then
            call action.Clear()
        endif
        call action.Data.Integer.Set(KEY, this)
        call action.AddCode(actionFunction)
    endmethod
    static method CreateBasic takes nothing returns thistype
        local thistype this = thistype.allocate()
        set this.action = NULL
        call this.SetConditions(NULL)
        call this.SetKey(0)
        call this.SetPriority(NULL)
        call this.SetType(NULL)
        call this.Id.Event_Create()
        call this.Limit.Event_Create()
        return this
    endmethod
    static method Create takes string name, EventType whichType, EventPriority priority, code actionFunction returns thistype
        local thistype this = thistype.CreateBasic()
		local Trigger action = Trigger.CreateWithName(name)
        set this.action = action
        call this.SetConditions(NULL)
        call this.SetKey(thistype.GetKeyFromTypePriority(whichType, priority))
        call this.SetName(name)
        call this.SetPriority(priority)
        call this.SetType(whichType)
        call this.SetAction(actionFunction)
        return this
    endmethod
    static method CreateLimit takes string name, EventType whichType, EventPriority priority, integer value, limitop whichOperator, code actionFunction returns thistype
        local thistype this = thistype.Create(name, whichType, priority, actionFunction)
        call this.Limit.Set(value, whichOperator)
        return this
    endmethod
    initMethod Init of Header_Event
        set thistype.DESTROY_EVENT_TYPE = EventType.Create()
		set thistype.RANDOM_TABLES_COUNT = 10 + ARRAY_EMPTY
		local integer i = thistype.RANDOM_TABLES_COUNT
		loop
			exitwhen (i < ARRAY_MIN)
			set thistype.RANDOM_TABLES[i] = DataTable.Create()
			set i = i - 1
		endloop
        call EventPriority.Init()
        call EventType.Init()
    endmethod
endstruct
    globals
        CharacterSpeech CHARACTER_SPEECH = STRUCT_BASE
    endglobals
    struct CharacterSpeech
        implement Allocation
        implement List
        
    static constant string INPUT = "!"
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        local Unit whichUnit = whichPlayer.Hero.Get()
        set input = String.SubRight(input, String.MIN_LENGTH)
        if (whichUnit != NULL) then
            call whichUnit.AddRisingTextTag(whichPlayer.GetColoredName() + ": " + input, TextTag.STANDARD_SIZE, 100., 2., 3. + 0.1 * String.Length(input), TextTag.GetFreeId()).Position.SetCentered()
        endif
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        ClearSpawns CLEAR_SPAWNS = STRUCT_BASE
    endglobals
    struct ClearSpawns
        implement Allocation
        implement List
        
    static constant string INPUT = "-clearSpawns"
    eventMethod Event_Chat
        call Spawn.RemoveAllUnits()
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        CommandAutoCast COMMAND_AUTO_CAST = STRUCT_BASE
    endglobals
    struct CommandAutoCast
        implement Allocation
        implement List
        
    static constant string INPUT = "-autocast"
    static Spell WHICH_SPELL
    enumMethod Enum
        call UNIT.Event.Native.GetEnum().Abilities.AutoCast.Change(thistype.WHICH_SPELL)
    endmethod
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        local Spell whichSpell = Spell.GetFromName(String.Word(input, 1))
        if (whichSpell == NULL) then
            call DebugEx("invalid spell")
            return
        endif
        set thistype.WHICH_SPELL = whichSpell
        call whichPlayer.EnumSelectedUnits(function thistype.Enum)
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        CommandBuff COMMAND_BUFF = STRUCT_BASE
    endglobals
    struct CommandBuff
        implement Allocation
        implement List
        
    static constant string INPUT = "-buff"
    static constant string INPUT_LIST_ALL = "-buffListAll"
    static integer LEVEL
    static Buff WHICH_BUFF
    static real DURATION
    eventMethod Event_ListAll_Chat
        local string input = params.String.GetChat()
        local integer iteration = Buff.ALL_COUNT
        local User whichPlayer = params.User.GetTrigger()
        call PreloadGenStart()
        loop
            exitwhen (iteration < ARRAY_MIN)
            call DebugEx(Buff.ALL[iteration].GetName())
            set iteration = iteration - 1
        endloop
    endmethod
    enumMethod Enum
        if (thistype.LEVEL == 0) then
            call UNIT.Event.Native.GetEnum().Buffs.Remove(thistype.WHICH_BUFF)
            return
        endif
        if (thistype.DURATION == 0) then
            call UNIT.Event.Native.GetEnum().Buffs.SetLevel(thistype.WHICH_BUFF, thistype.LEVEL, NULL)
        else
            call UNIT.Event.Native.GetEnum().Buffs.Timed.DoWithLevel(thistype.WHICH_BUFF, thistype.LEVEL, NULL, thistype.DURATION)
        endif
    endmethod
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        local string buffWord = String.Word(input, 1)
        local Buff whichBuff = Buff.GetFromName(buffWord)
        local integer level = String.ToInt(String.Word(input, 2))
        local real duration = String.ToReal(String.Word(input, 3))
        if (whichBuff == NULL) then
            set whichBuff = String.ToIntWithInvalid(buffWord, ARRAY_EMPTY)
            if (whichBuff == ARRAY_EMPTY) then
                call DebugEx("invalid buff")
                return
            endif
        endif
        set thistype.LEVEL = level
        set thistype.WHICH_BUFF = whichBuff
        set thistype.DURATION = duration
        call whichPlayer.EnumSelectedUnits(function thistype.Enum)
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
        call CommandHeader.RegisterEvent(thistype.INPUT_LIST_ALL, function thistype.Event_ListAll_Chat)
    endmethod
endstruct
    globals
        CommandCreateDestructable COMMAND_CREATE_DESTRUCTABLE = STRUCT_BASE
    endglobals
    struct CommandCreateDestructable
        implement Allocation
        implement List
        
    static constant string INPUT = "-createDestructable"
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        local DestructableType whichType = DestructableType.GetFromName(String.Word(input, 1))
        local real x = String.ToReal(String.Word(input, 2))
        local real y = String.ToReal(String.Word(input, 3))
        local real z = String.ToRealWithInvalid(String.Word(input, 4), Spot.GetHeight(x, y))
        local real angle = String.ToRealWithInvalid(String.Word(input, 5), 1.)
        local real scale = String.ToRealWithInvalid(String.Word(input, 6), 1.)
        local integer variation = String.ToIntWithInvalid(String.Word(input, 3), -1)
		if (whichType == NULL) then
			call InfoEx("invalid destructable type")
			return
		endif
        call Destructable.Create(whichType, x, y, z, angle, scale, variation)
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        CommandCreateItem COMMAND_CREATE_ITEM = STRUCT_BASE
    endglobals
    struct CommandCreateItem
        implement Allocation
        implement List
        
    static constant string INPUT = "-createItem"
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        local ItemType whichType = ItemType.GetFromName(String.Word(input, 1))
        local real x = String.ToReal(String.Word(input, 2))
        local real y = String.ToReal(String.Word(input, 3))
		if (whichType == NULL) then
			call InfoEx("invalid item type")
			return
		endif
        call Item.Create(whichType, x, y)
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        CommandCreateQuake COMMAND_CREATE_QUAKE = STRUCT_BASE
    endglobals
    struct CommandCreateQuake
        implement Allocation
        implement List
        
    static constant string INPUT = "-quake"
    static constant string INPUT_SHAKE = "-shake"
	eventMethod Event_Shake_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        
		local real power = String.ToReal(String.Word(input, 1))
		local string inputTargetPlayer = String.Word(input, 2)
		local real duration = String.ToReal(String.Word(input, 3))
		
		local User targetPlayer
		
		if (inputTargetPlayer == null) then
            set targetPlayer = whichPlayer
        else
            set targetPlayer = User.GetFromNativeIndex(String.ToInt(inputTargetPlayer)) 
        endif
		if (power == 0.) then
			set power = 10.
		endif
		if (duration == 0.) then
			set duration = 5.
		endif
		
		if (targetPlayer != NULL) then
			call CAMERA.Shake.Add(whichPlayer, power, duration)
		endif
	endmethod
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        local real x = String.ToReal(String.Word(input, 1))
        local real y = String.ToReal(String.Word(input, 2))
        local real z = String.ToReal(String.Word(input, 3))
		local real powerMax = String.ToReal(String.Word(input, 4))
		local real powerMin = String.ToReal(String.Word(input, 5))
		local real falloff = String.ToReal(String.Word(input, 6))
		local real speed = String.ToReal(String.Word(input, 7))
		if (powerMax == 0.) then
			set powerMax = 1000.
		endif
		if (falloff == 0.) then
			set falloff = 99999.
		endif
		if (speed == 0.) then
			set speed = 1000.
		endif
        call CAMERA.Seismic.Create(x, y, z, powerMax, powerMin, falloff, speed)
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
        call CommandHeader.RegisterEvent(thistype.INPUT_SHAKE, function thistype.Event_Shake_Chat)
    endmethod
endstruct
    globals
        CommandCreateUnit COMMAND_CREATE_UNIT = STRUCT_BASE
    endglobals
    struct CommandCreateUnit
        implement Allocation
        implement List
        
    static constant string INPUT = "-create"
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        local UnitType whichType = UnitType.GetFromName(String.Word(input, 1))
        local User owner
        local string input1 = String.Word(input, 2)
        local real x = String.ToReal(String.Word(input, 3))
        local real y = String.ToReal(String.Word(input, 4))
        if (input1 == null) then
            set owner = whichPlayer
        else
            set owner = User.GetFromNativeIndex(String.ToInt(input1))
        endif
		if (whichType == NULL) then
			call InfoEx("invalid unit type")
			return
		endif
        call Unit.Create(whichType, owner, x, y, UNIT.Facing.STANDARD)
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        CommandDebug COMMAND_DEBUG = STRUCT_BASE
    endglobals
    struct CommandDebug
        implement Allocation
        implement List
        
    static constant string INPUT = "-debug"
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        call DebugEx(String.Word(input, 1))
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        CommandExp COMMAND_EXP = STRUCT_BASE
    endglobals
    struct CommandExp
        implement Allocation
        implement List
        
    static constant string INPUT = "-exp"
    static real VAL
    enumMethod Enum
        call UNIT.Event.Native.GetEnum().Exp.Set(thistype.VAL)
    endmethod
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        local real val = String.ToReal(String.Word(input, 1))
        set thistype.VAL = val
        call whichPlayer.EnumSelectedUnits(function thistype.Enum)
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        CommandHeader COMMAND_HEADER = STRUCT_BASE
    endglobals
    struct CommandHeader
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    Trigger action
    condEventMethod Conditions
        local string input = params.String.GetChat()
        local string match = params.String.GetMatch()
        local boolean result = (String.Word(input, 0) == match)
        local string array args
        local integer argsC
        local string argsLine
        if result then
            set argsC = 0
            set argsLine = null
            loop
                exitwhen (String.Word(input, argsC + 1) == null)
                set argsC = argsC + 1
                set args[ARRAY_EMPTY + argsC] = String.Word(input, argsC)
                if (argsC == 1) then
                    set argsLine = args[ARRAY_EMPTY + argsC]
                else
                    set argsLine = argsLine + " " + args[ARRAY_EMPTY + argsC]
                endif
            endloop
            if (argsLine == null) then
                call InfoEx("execute " + match)
            else
                call InfoEx("execute " + match + " with " + argsLine)
            endif
        endif
        return result
    endmethod
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local thistype this = StringData.Data.Integer.Get(params.String.GetMatch(), thistype.KEY)
        local integer repeatTokenPos = String.Find(input, "^", 0)
        if (repeatTokenPos != String.INVALID_INDEX) then
            local integer repeats = String.ToIntWithInvalid(String.SubRight(input, repeatTokenPos + 1), 0)
            call params.String.SetChat(String.SubLeft(input, repeatTokenPos - 1))
            call InfoEx("repeat " + I2S(repeats) + ": " + input)
            loop
                exitwhen (repeats < 1)
                call this.action.RunWithParams(params)
                set repeats = repeats - 1
            endloop
            return
        endif
        call this.action.Run()
    endmethod
    static method RegisterEvent takes string input, code actionFunc returns nothing
        local thistype this = thistype.allocate()
        local Event whichEvent = Event.Create(User.CHAT_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Chat)
        set this.action = Trigger.GetFromCode(actionFunc)
        call StringData.Data.Integer.Set(input, thistype.KEY, this)
        call whichEvent.SetConditions(BoolExpr.GetFromFunction(function thistype.Conditions))
        call StringData.Event.Add(input, whichEvent)
    endmethod
endstruct
    globals
        CommandHeroAttribute COMMAND_HERO_ATTRIBUTE = STRUCT_BASE
    endglobals
    struct CommandHeroAttribute
        implement Allocation
        implement List
        
    static constant string INPUT_AGI = "-agi"
    static constant string INPUT_INT = "-int"
    static constant string INPUT_STR = "-str"
    static string ATTR
    static real VAL
    enumMethod Enum
        if (thistype.ATTR == "-agi") then
            call UNIT.Event.Native.GetEnum().Agility.Base.Add(thistype.VAL)
        elseif (thistype.ATTR == "-int") then
            call UNIT.Event.Native.GetEnum().Intelligence.Base.Add(thistype.VAL)
        elseif (thistype.ATTR == "-str") then
            call UNIT.Event.Native.GetEnum().Strength.Base.Add(thistype.VAL)
        else
            call DebugEx("unrecognized")
        endif
    endmethod
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        local string attr = params.String.GetMatch()
        local real val = String.ToReal(String.Word(input, 1))
        set thistype.ATTR = attr
        set thistype.VAL = val
        call whichPlayer.EnumSelectedUnits(function thistype.Enum)
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT_AGI, function thistype.Event_Chat)
        call CommandHeader.RegisterEvent(thistype.INPUT_INT, function thistype.Event_Chat)
        call CommandHeader.RegisterEvent(thistype.INPUT_STR, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        CommandKillUnit COMMAND_KILL_UNIT = STRUCT_BASE
    endglobals
    struct CommandKillUnit
        implement Allocation
        implement List
        
    static constant string INPUT = "-kill"
    enumMethod Enum
        call UNIT.Event.Native.GetEnum().Kill()
    endmethod
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        call whichPlayer.EnumSelectedUnits(function thistype.Enum)
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        CommandRefreshAbility COMMAND_REFRESH_ABILITY = STRUCT_BASE
    endglobals
    struct CommandRefreshAbility
        implement Allocation
        implement List
        
    static constant string INPUT = "-refresh"
    static constant string INPUT_NO_CD = "-nocd"
    static Event NO_CD_CAST_EVENT
    static boolean NO_CD = false
    static Spell WHICH_SPELL
    eventMethod Event_NoCd_Cast
        call params.Unit.GetTrigger().Abilities.Refresh(params.Spell.GetTrigger())
    endmethod
    enumMethod NoCd_Chat_Enum
        call UNIT.Event.Native.GetEnum().Abilities.RefreshAll()
    endmethod
    eventMethod Event_NoCd_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        set thistype.NO_CD = not thistype.NO_CD
        if thistype.NO_CD then
            call thistype.NO_CD_CAST_EVENT.AddToStatics()
        else
            call thistype.NO_CD_CAST_EVENT.RemoveFromStatics()
        endif
        call UnitList.WORLD.Do(function thistype.NoCd_Chat_Enum)
    endmethod
    enumMethod Enum
        if (thistype.WHICH_SPELL == NULL) then
            call UNIT.Event.Native.GetEnum().Abilities.RefreshAll()
        else
            call UNIT.Event.Native.GetEnum().Abilities.Refresh(thistype.WHICH_SPELL)
        endif
    endmethod
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
		local string whichSpellName = String.Word(input, 1)
		if (whichSpellName == null) then
			call InfoEx("no spell given")
			return
		endif
        local Spell whichSpell = Spell.GetFromName(whichSpellName)
        if (whichSpell == NULL) then
            if (String.Word(input, 1) != "all") then
                call InfoEx("invalid spell")
                return
            endif
        endif
        set thistype.WHICH_SPELL = whichSpell
        call whichPlayer.EnumSelectedUnits(function thistype.Enum)
    endmethod
    initMethod Init of Commands
        set thistype.NO_CD_CAST_EVENT = Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_NoCd_Cast)
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
        call CommandHeader.RegisterEvent(thistype.INPUT_NO_CD, function thistype.Event_NoCd_Chat)
    endmethod
endstruct
    globals
        CommandRemoveUnit COMMAND_REMOVE_UNIT = STRUCT_BASE
    endglobals
    struct CommandRemoveUnit
        implement Allocation
        implement List
        
    static constant string INPUT = "-remove"
    enumMethod Enum
        call UNIT.Event.Native.GetEnum().Destroy()
    endmethod
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        call whichPlayer.EnumSelectedUnits(function thistype.Enum)
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        CommandScaleUnit COMMAND_SCALE_UNIT = STRUCT_BASE
    endglobals
    struct CommandScaleUnit
        implement Allocation
        implement List
        
    static constant string INPUT = "-scale"
    static real DURATION
    static real SCALE
    enumMethod Enum
        call UNIT.Event.Native.GetEnum().Scale.Timed.Add(thistype.SCALE, thistype.DURATION)
    endmethod
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        local real scale = String.ToReal(String.Word(input, 1))
        local real duration = String.ToReal(String.Word(input, 2))
        set thistype.DURATION = duration
        set thistype.SCALE = scale
        call whichPlayer.EnumSelectedUnits(function thistype.Enum)
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        CommandSpell COMMAND_SPELL = STRUCT_BASE
    endglobals
    struct CommandSpell
        implement Allocation
        implement List
        
    static constant string INPUT = "-spell"
    static constant string INPUT_LIST_ALL = "-spellListAll"
    static integer LEVEL
    static Spell WHICH_SPELL
    eventMethod Event_ListAll_Chat
        local string input = params.String.GetChat()
        local integer iteration = Spell.ALL_COUNT
        local User whichPlayer = params.User.GetTrigger()
        call PreloadGenStart()
        loop
            exitwhen (iteration < ARRAY_MIN)
            call DebugEx(Spell.ALL[iteration].GetName())
            set iteration = iteration - 1
        endloop
    endmethod
    enumMethod Enum
        call UNIT.Event.Native.GetEnum().Abilities.AddWithLevel(thistype.WHICH_SPELL, thistype.LEVEL)
    endmethod
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        local string spellWord = String.Word(input, 1)
        local Spell whichSpell = Spell.GetFromName(spellWord)
        local integer level = String.ToInt(String.Word(input, 2))
        if (whichSpell == NULL) then
            set whichSpell = String.ToIntWithInvalid(spellWord, ARRAY_EMPTY)
            if (whichSpell == ARRAY_EMPTY) then
                call DebugEx("invalid spell")
                return
            endif
        endif
        set thistype.LEVEL = level
        set thistype.WHICH_SPELL = whichSpell
        call whichPlayer.EnumSelectedUnits(function thistype.Enum)
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
        call CommandHeader.RegisterEvent(thistype.INPUT_LIST_ALL, function thistype.Event_ListAll_Chat)
    endmethod
endstruct
    globals
        CommandSwift COMMAND_SWIFT = STRUCT_BASE
    endglobals
    struct CommandSwift
        implement Allocation
        implement List
        
    static constant string INPUT = "-swift"
    static real DURATION
    static integer LEVEL
    enumMethod Enum
        call Swiftness.Start(UNIT.Event.Native.GetEnum(), thistype.LEVEL)
    endmethod
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        local integer level = String.ToInt(String.Word(input, 1))
        local real duration = String.ToReal(String.Word(input, 2))
        set thistype.DURATION = duration
        set thistype.LEVEL = level
        call whichPlayer.EnumSelectedUnits(function thistype.Enum)
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        CommandTest COMMAND_TEST = STRUCT_BASE
    endglobals
    struct CommandTest
        implement Allocation
        implement List
        
    static constant string INPUT = "-test"
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        call Memory.IntegerKeys.D2.Table.AddInteger(-2147483376, 45, 53, 0, 186)
        local integer val = Memory.IntegerKeys.D2.Table.FetchFirstInteger(-2147483376, 47, 123, 0)
        call DebugEx("TEST: " + I2S(val))
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        CommandVertexColorUnit COMMAND_VERTEX_COLOR_UNIT = STRUCT_BASE
    endglobals
    struct CommandVertexColorUnit
        implement Allocation
        implement List
        
    static constant string INPUT = "-vertexcolor"
    static real RED
    static real GREEN
    static real BLUE
    static real ALPHA
    static real DURATION
    enumMethod Enum
        local Unit target = UNIT.Event.Native.GetEnum()
        local real red = thistype.RED
        local real green = thistype.GREEN
        local real blue = thistype.BLUE
        local real alpha = thistype.ALPHA
        if (red == -1) then
            set red = target.VertexColor.Red.Get()
        endif
        if (green == -1) then
            set green = target.VertexColor.Green.Get()
        endif
        if (blue == -1) then
            set blue = target.VertexColor.Blue.Get()
        endif
        if (alpha == -1) then
            set alpha = target.VertexColor.Alpha.Get()
        endif
        call target.VertexColor.Timed.Add(red, green, blue, alpha, thistype.DURATION)
    endmethod
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        local real red = String.ToRealWithInvalid(String.Word(input, 1), -1)
        local real green = String.ToRealWithInvalid(String.Word(input, 2), -1)
        local real blue = String.ToRealWithInvalid(String.Word(input, 3), -1)
        local real alpha = String.ToRealWithInvalid(String.Word(input, 4), -1)
        local real duration = String.ToReal(String.Word(input, 5))
        set thistype.RED = red
        set thistype.GREEN = green
        set thistype.BLUE = blue
        set thistype.ALPHA = alpha
        set thistype.DURATION = duration
        call whichPlayer.EnumSelectedUnits(function thistype.Enum)
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        MoveUnit MOVE_UNIT = STRUCT_BASE
    endglobals
    struct MoveUnit
        implement Allocation
        implement List
        
    static constant string INPUT = "-move"
    static real X
    static real Y
    enumMethod Enum
        call UNIT.Event.Native.GetEnum().Position.SetXY(thistype.X, thistype.Y)
    endmethod
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        local real x = String.ToReal(String.Word(input, 1))
        local real y = String.ToReal(String.Word(input, 2))
        set thistype.X = x
        set thistype.Y = y
        call whichPlayer.EnumSelectedUnits(function thistype.Enum)
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        PingSpawns PING_SPAWNS = STRUCT_BASE
    endglobals
    struct PingSpawns
        implement Allocation
        implement List
        
    static constant string INPUT = "-pingSpawns"
    static boolean DEBUG_MSG
    enumMethod Enum
        call UNIT.Event.Native.GetEnum().Ping(thistype.DEBUG_MSG)
    endmethod
    eventMethod Event_Chat
        set thistype.DEBUG_MSG = String.ToBoolean(String.Word(params.String.GetChat(), 1))
        call Spawn.ALL_GROUP.Do(function thistype.Enum)
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        RequestEvent REQUEST_EVENT = STRUCT_BASE
    endglobals
    struct RequestEvent
        implement Allocation
        implement List
        
    static constant string INPUT = "-event"
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local integer id = String.ToInt(String.Word(input, 1))
        call DebugEx(Event(id).GetName())
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        RequestKeyMacro REQUEST_KEY_MACRO = STRUCT_BASE
    endglobals
    struct RequestKeyMacro
        implement Allocation
        implement List
        
    static constant string INPUT = "-key"
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local string value = String.Word(input, 1)
        if (value == null) then
            call DebugEx("invalid syntax")
            return
        endif
        local integer valueI = String.ToInt(value)
        if (valueI == 0) then
            call DebugEx("invalid syntax")
            return
        endif
        local string result = Memory.GetKeyFromValue(valueI)
        if (result == null) then
            call DebugEx("no key found under " + Integer.ToString(valueI))
            return
        endif
        call DebugEx(result)
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        RequestTimers REQUEST_TIMERS = STRUCT_BASE
    endglobals
    struct RequestTimers
        implement Allocation
        implement List
        
    static constant string INPUT = "-timers"
    eventMethod Event_Chat
        call Timer.RequestRunningList()
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        SetDmgTest SET_DMG_TEST = STRUCT_BASE
    endglobals
    struct SetDmgTest
        implement Allocation
        implement List
        
    static constant string INPUT = "-dmgtest"
    static real VAL
    enumMethod Enum
        call BJUnit.Damage.Add(UNIT.Event.Native.GetEnum().self, thistype.VAL)
    endmethod
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        local real val = String.ToReal(String.Word(input, 1))
        set thistype.VAL = val
        call whichPlayer.EnumSelectedUnits(function thistype.Enum)
    endmethod
    initMethod Init of Commands
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    globals
        SetVar SET_VAR = STRUCT_BASE
    endglobals
    struct SetVar
        implement Allocation
        implement List
        
    static constant string INPUT = "-var"
    static GameCache TABLE
    static method GetVal takes string name returns string
        return thistype.TABLE.String.Get(name, "var")
    endmethod
    static method GetValDef takes string name, string inval returns string
        if thistype.TABLE.String.Contains(name, "var") then
            return thistype.GetVal(name)
        endif
        return inval
    endmethod
    static method GetValDefI takes string name, integer inval returns integer
        if thistype.TABLE.String.Contains(name, "var") then
            return String.ToInt(thistype.GetVal(name))
        endif
        return inval
    endmethod
    static method GetValDefR takes string name, real inval returns real
        if thistype.TABLE.String.Contains(name, "var") then
            return String.ToReal(thistype.GetVal(name))
        endif
        return inval
    endmethod
    eventMethod Event_Chat
        local string input = params.String.GetChat()
        local User whichPlayer = params.User.GetTrigger()
        local string name = String.Word(input, 1)
        local string val = String.Word(input, 2)
        if (name == null) then
            call DebugEx("SetVar: no name given")
            return
        endif
        call thistype.TABLE.String.Set(name, "var", val)
        call DebugEx("SetVar: value of " + name + ":" + thistype.GetVal(name))
    endmethod
    initMethod Init of Commands
        set thistype.TABLE = GameCache.Create()
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
    scope FolderVoteHost
    public struct StructVotes
        implement Allocation
        implement List
        
        static Event CHAT_EVENT
        static Dialog DUMMY_DIALOG
        static constant string INPUT = "-vote"
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_PLAYER_BUTTON_KEY
    static constant integer PLAYER_BUTTON_KEY = Math.Integer.MIN + GetKeyMacro_PLAYER_BUTTON_KEY
        trigMethod ClickTrig
            local DialogButton dummyButton = DialogButton(NULL).Event.Native.GetClicked()
            local User dummyPlayer = User(NULL).Event.Native.GetTrigger()
            local User votedFor = dummyButton.Data.Integer.Get(KEY)
            call Game.DisplayTextTimed(User.ANY, dummyPlayer.GetColoredName() + " voted for " + votedFor.GetColoredName(), 5.)
        endmethod
        eventMethod Event_Chat
            local string chat = params.String.GetChat()
            if (chat != thistype.INPUT) then
                return
            endif
            call thistype.DUMMY_DIALOG.Display(params.User.GetTrigger(), true)
        endmethod
        static method Ending takes nothing returns nothing
            call StringData.Event.Remove(thistype.INPUT, thistype.CHAT_EVENT)
        endmethod
        static method Start takes nothing returns nothing
            call StringData.Event.Add(thistype.INPUT, thistype.CHAT_EVENT)
        endmethod
        eventMethod Event_Leave
            local User dummyPlayer = params.User.GetTrigger()
            local DialogButton dummyButton = dummyPlayer.Data.Integer.Get(PLAYER_BUTTON_KEY)
            call dummyPlayer.Data.Integer.Remove(PLAYER_BUTTON_KEY)
            call thistype.DUMMY_DIALOG.Buttons.Destroy(dummyButton)
        endmethod
        static method Init takes nothing returns nothing
            local DialogButton dummyButton
            local User dummyPlayer
            local integer iteration = User.PLAYING_HUMANS_COUNT
            set thistype.CHAT_EVENT = Event.Create(User.CHAT_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Chat)
            set thistype.DUMMY_DIALOG = Dialog.Create()
            call thistype.DUMMY_DIALOG.SetTitle("Who shall be host?")
            loop
                exitwhen (iteration < ARRAY_MIN)
                set dummyPlayer = User.PLAYING_HUMANS[iteration]
                set dummyButton = thistype.DUMMY_DIALOG.Buttons.Create(dummyPlayer.GetColoredName(), 0)
                call dummyButton.Data.Integer.Set(KEY, dummyPlayer)
                call dummyPlayer.Data.Integer.Set(PLAYER_BUTTON_KEY, dummyButton)
                set iteration = iteration - 1
            endloop
            call Event.Create(User.LEAVE_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Leave).AddToStatics()
            call Trigger.CreateFromCode(function thistype.ClickTrig).RegisterEvent.Dialog(thistype.DUMMY_DIALOG)
        endmethod
    endstruct
endscope
    globals
        VoteHost VOTE_HOST = STRUCT_BASE
    endglobals
    struct VoteHost
        implement Allocation
        implement List
        
    static boolean ACTIVE = false
    static Timer COOLDOWN_TIMER
    static boolean ON_COOLDOWN = false
    static constant string INPUT = "-votehost"
    FolderVoteHost_StructVotes Votes = this
    FolderVoteHost_StructVotes LinkToStruct_Votes
    eventMethod Event_Chat
        local User whichPlayer = params.User.GetTrigger()
        if thistype.ACTIVE then
            call Game.DisplayTextTimed(whichPlayer, "A vote is already in process.", 5.)
            return
        elseif thistype.ON_COOLDOWN then
            call Game.DisplayTextTimed(whichPlayer, "The vote option is on cooldown for another " + Real.ToString(thistype.COOLDOWN_TIMER.GetRemaining()) + "seconds.", 5.)
            return
        endif
        set thistype.ACTIVE = true
        call thistype(NULL).Votes.Start()
    endmethod
    initMethod Init of Commands
        set thistype.COOLDOWN_TIMER = Timer.Create()
        call CommandHeader.RegisterEvent(thistype.INPUT, function thistype.Event_Chat)
    endmethod
endstruct
scope herospell initializer Init
    globals
        private trigger thisTrig=null
    endglobals
    private function Actions takes nothing returns nothing
        local string input = GetEventPlayerChatString()
        local User this = USER.Event.Native.GetTrigger()
        if (SubString(input, 0, 3) == "-r ") then
            call this.Hero.Get().Abilities.Remove(Spell.GetFromName(SubString(input, 3, String.Length(input))))
        elseif (SubString(input, 0, 3) == "-a ") then
            call this.Hero.Get().Abilities.Add(Spell.GetFromName(SubString(input, 3, String.Length(input))))
        endif
    endfunction
    
    private function Init takes nothing returns nothing
        set thisTrig = CreateTrigger(  )
        call TriggerRegisterPlayerChatEvent( thisTrig, Player(0), "-a ", false )
        call TriggerRegisterPlayerChatEvent( thisTrig, Player(0), "-r ", false )
        call TriggerAddAction( thisTrig, function Actions )
    endfunction
endscope
scope loadmem initializer Init
    globals
        private trigger thisTrig=null
    endglobals
    private function Actions takes nothing returns nothing
        local string val = GetEventPlayerChatString()
        local integer keyStart = String.Find(val, ";", 0)
call BJDebugMsg("load "+String.Sub(val, 5, keyStart - 1))
call BJDebugMsg("loadB "+String.Sub(val, keyStart+1, StringLength(val)-1))
        call BJDebugMsg(I2S(Memory.IntegerKeys.GetInteger(S2I(String.Sub(val, 0, keyStart - 2)), S2I(String.Sub(val, keyStart, StringLength(val))))))
    endfunction
    
    private function Init takes nothing returns nothing
        set thisTrig = CreateTrigger(  )
        call TriggerRegisterPlayerChatEvent( thisTrig, Player(0), "-get ", false )
        call TriggerAddAction( thisTrig, function Actions )
    endfunction
endscope
struct memtableteststruct
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
endstruct
scope memtabletest initializer Init
    globals
        private trigger thisTrig=null
    endglobals
    private function Actions takes nothing returns nothing
        local integer i=Memory.IntegerKeys.Table.STARTED
        local integer key = memtableteststruct.KEY_ARRAY
        local integer missionKey = 40000
        local integer val = S2I(SubString(GetEventPlayerChatString(), 5, StringLength(GetEventPlayerChatString())))
        if (SubString(GetEventPlayerChatString(), 0, 4) == "-add") then
        call BJDebugMsg("add")
            call Memory.IntegerKeys.Table.AddInteger(missionKey, key, val)
        else
        call BJDebugMsg("rem")
            call Memory.IntegerKeys.Table.RemoveInteger(missionKey, key, val)
        endif
        call BJDebugMsg("count "+I2S(Memory.IntegerKeys.Table.CountIntegers(missionKey, key)))
        loop
            exitwhen (i>10)
            call BJDebugMsg(I2S(i)+" --> "+I2S(Memory.IntegerKeys.Table.GetInteger(missionKey, key, i)))
            set i=i+1
        endloop
    endfunction
    
    private function Init takes nothing returns nothing
        set thisTrig = CreateTrigger(  )
        call TriggerRegisterPlayerChatEvent( thisTrig, Player(0), "-add ", false )
        call TriggerRegisterPlayerChatEvent( thisTrig, Player(0), "-rem ", false )
        call TriggerAddAction( thisTrig, function Actions )
    endfunction
endscope
scope say initializer init
    globals
        private trigger thisTrig=null
    endglobals
function Trig_Unbezeichneter_Ausl__ser_002_Actions takes nothing returns nothing
call Game.DisplayTextTimed( User.ANY, String.Color.Gradient(GetEventPlayerChatString(), String.Color.RED, String.Color.GOLD), 3. )
    call Game.DisplayTextTimed( User.GetFromSelf(GetTriggerPlayer()), SubStringBJ(GetEventPlayerChatString(), 5, StringLength(GetEventPlayerChatString())), 3. )
endfunction
private function init takes nothing returns nothing
    set thisTrig = CreateTrigger(  )
    call TriggerRegisterPlayerChatEvent( thisTrig, Player(0), "say ", false )
    call TriggerAddAction( thisTrig, function Trig_Unbezeichneter_Ausl__ser_002_Actions )
endfunction
endscope
scope sethp initializer Init
    globals
        private trigger thisTrig=null
    endglobals
    private function Actions takes nothing returns nothing
        local real value = S2R(SubStringBJ(GetEventPlayerChatString(), 8, StringLength(GetEventPlayerChatString())) )
        if (value > 0.5) then
            call Difficulty.SELECTED.SetLifeFactor(value)
        endif
    endfunction
    
    private function Init takes nothing returns nothing
        set thisTrig = CreateTrigger(  )
        call TriggerRegisterPlayerChatEvent( thisTrig, Player(0), "-sethp ", false )
        call TriggerAddAction( thisTrig, function Actions )
    endfunction
endscope
scope setlvl initializer Init
    globals
        private trigger thisTrig=null
    endglobals
    private function Actions takes nothing returns nothing
        call Level.ALL[S2I(SubStringBJ(GetEventPlayerChatString(), 4, StringLength(GetEventPlayerChatString())) )].Start()
    endfunction
    
    private function Init takes nothing returns nothing
        set thisTrig = CreateTrigger(  )
        call TriggerRegisterPlayerChatEvent( thisTrig, Player(0), "-l ", false )
        call TriggerAddAction( thisTrig, function Actions )
    endfunction
endscope
scope takeunit initializer init
    globals
        private trigger thisTrig=null
    endglobals
    function Trig_takeunit_Enum takes nothing returns nothing
        call Unit.GetFromSelf(GetEnumUnit()).Owner.Set(User.GetFromSelf(GetTriggerPlayer()))
    endfunction
    function Trig_takeunit_Actions takes nothing returns nothing
        call ForGroupBJ( GetUnitsSelectedAll(Player(0)), function Trig_takeunit_Enum )
    endfunction
    private function init takes nothing returns nothing
        set thisTrig = CreateTrigger(  )
        call TriggerRegisterPlayerChatEvent( thisTrig, Player(0), "-take", true )
        call TriggerAddAction( thisTrig, function Trig_takeunit_Actions )
    endfunction
endscope
    globals
        PathingBlockers PATHING_BLOCKERS = STRUCT_BASE
    endglobals
    struct PathingBlockers
        implement Allocation
        implement List
        
	static method Enum
		local destructable d = GetFilterDestructable()
		if (GetDestructableTypeId(d) == PathingBlockers.P_G4X4_ID) then
			call KillDestructable(d)
		endif
		set d = null
	endmethod
	initMethod Init of Misc
		call EnumDestructablesInRect(Rectangle.WORLD.self, null, function thistype.Enum)
	endmethod
endstruct
struct preplaced
implement Allocation
implement List
static thistype unit_36
static thistype unit_16
static thistype unit_2
static thistype unit_3
static thistype unit_34
static thistype unit_5
static thistype unit_6
static thistype unit_15
static thistype unit_0
static thistype unit_8
static thistype unit_9
static thistype unit_10
static thistype unit_11
static thistype unit_12
static thistype unit_13
static thistype unit_38
static thistype unit_90
static thistype unit_17
static thistype unit_33
static thistype unit_50
static thistype unit_65
static thistype unit_23
static thistype unit_51
static thistype unit_46
static thistype unit_14
static thistype unit_32
static thistype unit_35
static thistype unit_4
static thistype unit_1
static thistype unit_39
static thistype unit_40
static thistype unit_42
static thistype unit_45
static thistype unit_29
static thistype unit_44
static thistype unit_86
static thistype unit_134
static thistype unit_7
static thistype unit_22
static thistype unit_18
static thistype unit_83
static thistype unit_49
static thistype unit_88
static thistype unit_87
static thistype unit_99
static thistype unit_69
static thistype unit_67
static thistype unit_66
static thistype unit_31
static thistype unit_68
static thistype unit_122
static thistype unit_115
static thistype unit_106
static thistype unit_110
static thistype unit_97
static thistype unit_123
static thistype unit_102
static thistype unit_112
static thistype unit_111
static thistype unit_114
static thistype unit_132
static thistype unit_116
static thistype unit_124
static thistype unit_79
static thistype unit_133
static thistype unit_117
static thistype unit_81
static thistype unit_113
static thistype unit_19
static thistype unit_20
static thistype unit_21
static thistype unit_24
static thistype unit_25
static thistype unit_26
static thistype unit_27
static thistype unit_28
static thistype unit_30
static thistype unit_37
static thistype unit_41
boolean enabled
integer ownerIndex
integer typeId
real x
real y
real angle
thistype waygateTarget
    static thistype array UNITS_ALL
    static integer UNITS_ALL_COUNT = ARRAY_EMPTY
    integer UNITS_index
    static method UNITS_Count takes nothing returns integer
        return thistype.UNITS_ALL_COUNT
    endmethod
    static method UNITS_IsEmpty takes nothing returns boolean
        return (thistype.UNITS_Count() == ARRAY_EMPTY)
    endmethod
    static method UNITS_Get takes integer index returns thistype
        return thistype.UNITS_ALL[index]
    endmethod
    static method UNITS_GetIndex takes thistype this returns integer
        return this.UNITS_index
    endmethod
    static method UNITS_Contains takes thistype this returns boolean
        return (thistype.UNITS_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method UNITS_Random takes integer lowBound, integer highBound returns thistype
        return thistype.UNITS_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method UNITS_RandomAll takes nothing returns thistype
        return thistype.UNITS_Random(ARRAY_MIN, thistype.UNITS_ALL_COUNT)
    endmethod
    static method UNITS_Remove takes thistype this returns boolean
        if not thistype.UNITS_Contains(this) then
            return false
        endif
        set thistype.UNITS_ALL[thistype.UNITS_ALL_COUNT].UNITS_index = this.UNITS_index
        set thistype.UNITS_ALL[this.UNITS_index - 1] = thistype.UNITS_ALL[thistype.UNITS_ALL_COUNT]
        set this.UNITS_index = ARRAY_MIN
        set thistype.UNITS_ALL_COUNT = thistype.UNITS_ALL_COUNT - 1
        return (thistype.UNITS_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method UNITS_Add takes thistype this returns boolean
        if thistype.UNITS_Contains(this) then
            return false
        endif
        set thistype.UNITS_ALL_COUNT = thistype.UNITS_ALL_COUNT + 1
        set thistype.UNITS_ALL[thistype.UNITS_ALL_COUNT] = this
        set this.UNITS_index = thistype.UNITS_ALL_COUNT + 1
        return (thistype.UNITS_ALL_COUNT == ARRAY_MIN)
    endmethod
static method createUnit takes boolean enabled, integer typeId, integer ownerIndex, real x, real y, real angle, thistype waygateTarget returns thistype
local thistype this = thistype.allocate()
set this.enabled = enabled
set this.ownerIndex = ownerIndex
set this.typeId = typeId
set this.x = x
set this.y = y
set this.angle = angle
set this.waygateTarget = waygateTarget
call thistype.UNITS_Add(this)
return this
endmethod
static method initUnits
set thistype.unit_36 = thistype.createUnit(true, 'sloc', 0, 0, 0, 4.710, NULL)
set thistype.unit_16 = thistype.createUnit(true, 'UMet', 0, 0, 5760, 4.710, NULL)
set thistype.unit_2 = thistype.createUnit(true, 'uLib', 7, 0, 1792, 4.710, NULL)
set thistype.unit_3 = thistype.createUnit(true, 'uFou', 7, 2048, 1792, 4.710, NULL)
set thistype.unit_34 = thistype.createUnit(true, 'uTav', 15, -6144, -1984, 0.000, NULL)
set thistype.unit_5 = thistype.createUnit(true, 'uPha', 7, -1728, 4288, 4.710, NULL)
set thistype.unit_6 = thistype.createUnit(true, 'uGaC', 7, 1728, 4288, 4.710, NULL)
set thistype.unit_15 = thistype.createUnit(true, 'uTow', 11, 704, -128, 4.710, NULL)
set thistype.unit_0 = thistype.createUnit(true, 'sloc', 1, 0, 0, 4.710, NULL)
set thistype.unit_8 = thistype.createUnit(true, 'sloc', 2, 0, 0, 4.710, NULL)
set thistype.unit_9 = thistype.createUnit(true, 'sloc', 3, 0, 0, 4.710, NULL)
set thistype.unit_10 = thistype.createUnit(true, 'sloc', 4, 0, 0, 4.710, NULL)
set thistype.unit_11 = thistype.createUnit(true, 'sloc', 5, 0, 0, 4.710, NULL)
set thistype.unit_12 = thistype.createUnit(true, 'sloc', 6, 0, 0, 4.710, NULL)
set thistype.unit_13 = thistype.createUnit(true, 'sloc', 7, 0, 0, 4.710, NULL)
set thistype.unit_38 = thistype.createUnit(true, 'uRes', 7, 832, -448, 4.710, NULL)
set thistype.unit_90 = thistype.createUnit(true, 'uArS', 15, 4416, -5376, 4.710, NULL)
set thistype.unit_17 = thistype.createUnit(true, 'uGaC', 7, -3264, 448, 4.710, NULL)
set thistype.unit_33 = thistype.createUnit(true, 'uPen', 8, -5607.96, -5022.64, 5.360, NULL)
set thistype.unit_50 = thistype.createUnit(true, 'ISno', 15, 4.59, -2574.64, 4.710, NULL)
set thistype.unit_65 = thistype.createUnit(true, 'uBTw', 11, -928, 2656, 4.710, NULL)
set thistype.unit_23 = thistype.createUnit(true, 'uRes', 7, -1408, 4352, 4.710, NULL)
set thistype.unit_51 = thistype.createUnit(true, 'ISno', 15, 6004.32, 2239.96, 4.710, NULL)
set thistype.unit_46 = thistype.createUnit(true, 'sloc', 11, 0, 0, 4.710, NULL)
set thistype.unit_14 = thistype.createUnit(true, 'sloc', 8, 0, 0, 4.710, NULL)
set thistype.unit_32 = thistype.createUnit(true, 'uPen', 8, -4436.59, -6030.5, 5.920, NULL)
set thistype.unit_35 = thistype.createUnit(true, 'uTav', 15, 6272, -1600, 4.710, NULL)
set thistype.unit_4 = thistype.createUnit(true, 'uFou', 7, -2048, 1792, 4.710, NULL)
set thistype.unit_1 = thistype.createUnit(true, 'uPha', 7, 3264, 448, 4.710, NULL)
set thistype.unit_39 = thistype.createUnit(true, 'uRes', 7, -3520, 2688, 4.710, NULL)
set thistype.unit_40 = thistype.createUnit(true, 'uSeb', 7, -74.06, 1659.47, 4.570, NULL)
set thistype.unit_42 = thistype.createUnit(true, 'IRun', 15, 3.18, 4995.94, 4.710, NULL)
set thistype.unit_45 = thistype.createUnit(true, 'sloc', 10, 0, 0, 4.710, NULL)
set thistype.unit_29 = thistype.createUnit(true, 'sloc', 9, 0, 0, 4.710, NULL)
set thistype.unit_44 = thistype.createUnit(true, 'uRiS', 7, 3392, 1088, 4.710, NULL)
set thistype.unit_86 = thistype.createUnit(true, 'uPen', 8, -3996.7, -6982.05, 0.100, NULL)
set thistype.unit_134 = thistype.createUnit(false, 'uTrP', 0, 4842.5, -2666.6, 1.150, NULL)
set thistype.unit_7 = thistype.createUnit(true, 'uRes', 7, 1408, 4352, 4.710, NULL)
set thistype.unit_22 = thistype.createUnit(true, 'uRes', 7, 3584, 2944, 4.710, NULL)
set thistype.unit_18 = thistype.createUnit(true, 'uRiS', 7, -3456, 2432, 4.710, NULL)
set thistype.unit_83 = thistype.createUnit(false, 'uPan', 0, -2933.68, -710.26, 5.180, NULL)
set thistype.unit_49 = thistype.createUnit(true, 'ISno', 15, -6400.1, 1532.99, 4.710, NULL)
set thistype.unit_88 = thistype.createUnit(true, 'uPeL', 15, -5590.03, -7097.49, 2.620, NULL)
set thistype.unit_87 = thistype.createUnit(true, 'uPen', 8, -4690.55, -6965.2, 2.820, NULL)
set thistype.unit_99 = thistype.createUnit(false, 'uTus', 0, -1550.46, -1407.35, 2.640, NULL)
set thistype.unit_69 = thistype.createUnit(true, 'uBTw', 11, -672, -160, 4.710, NULL)
set thistype.unit_67 = thistype.createUnit(true, 'uBTw', 11, -3872, 1120, 4.710, NULL)
set thistype.unit_66 = thistype.createUnit(true, 'uBTw', 11, 928, 2656, 4.710, NULL)
set thistype.unit_31 = thistype.createUnit(true, 'uPen', 8, -5808.83, -6672.78, 0.100, NULL)
set thistype.unit_68 = thistype.createUnit(true, 'uBTw', 11, 3872, 1120, 4.710, NULL)
set thistype.unit_122 = thistype.createUnit(false, 'uWoM', 0, 3244.42, -898.11, 4.310, NULL)
set thistype.unit_115 = thistype.createUnit(false, 'uKoM', 0, -4896.15, -1000.41, 4.170, NULL)
set thistype.unit_106 = thistype.createUnit(true, 'nogr', 0, -2668.68, -923.61, 5.100, NULL)
set thistype.unit_110 = thistype.createUnit(false, 'uFuM', 0, -4761.15, -978.84, 4.050, NULL)
set thistype.unit_97 = thistype.createUnit(false, 'uWol', 0, 3092.35, -965.9, 4.510, NULL)
set thistype.unit_123 = thistype.createUnit(false, 'uWol', 0, 3295.54, -1068.42, 3.960, NULL)
set thistype.unit_102 = thistype.createUnit(false, 'uKoB', 0, 1603.14, -1488.02, 1.130, NULL)
set thistype.unit_112 = thistype.createUnit(false, 'uTus', 0, -1666.84, -1546.88, 2.630, NULL)
set thistype.unit_111 = thistype.createUnit(true, 'nogr', 0, -2788.83, -1018.31, 5.490, NULL)
set thistype.unit_114 = thistype.createUnit(false, 'uKoR', 0, 1774.88, -1418.17, 1.010, NULL)
set thistype.unit_132 = thistype.createUnit(false, 'uTrG', 0, 4714.97, -2739.71, 1.460, NULL)
set thistype.unit_116 = thistype.createUnit(false, 'uKoM', 0, -4719.19, -1132.61, 3.770, NULL)
set thistype.unit_124 = thistype.createUnit(false, 'uKoB', 0, 1686.55, -1549.23, 1.040, NULL)
set thistype.unit_79 = thistype.createUnit(false, 'uPan', 0, -3084.7, -845.33, 5.840, NULL)
set thistype.unit_133 = thistype.createUnit(false, 'uTrP', 0, 4603.89, -2603.4, 1.110, NULL)
set thistype.unit_117 = thistype.createUnit(false, 'uBDS', 0, -1471, -1470.95, 2.870, NULL)
set thistype.unit_81 = thistype.createUnit(false, 'uBDS', 0, -1571.35, -1640.34, 2.210, NULL)
set thistype.unit_113 = thistype.createUnit(false, 'uKoR', 0, 1582.36, -1361.09, 0.960, NULL)
set thistype.unit_19 = thistype.createUnit(false, 'UAru', 15, -1703.85, 6098.26, 3.550, NULL)
set thistype.unit_20 = thistype.createUnit(false, 'UDra', 15, -1110.24, 6281.83, 4.160, NULL)
set thistype.unit_21 = thistype.createUnit(false, 'UJot', 15, -1601.65, 5037.67, 2.880, NULL)
set thistype.unit_24 = thistype.createUnit(false, 'UKer', 15, -1965.03, 6124.93, 5.450, NULL)
set thistype.unit_25 = thistype.createUnit(false, 'UMan', 15, -2376.73, 5319.46, 5.980, NULL)
set thistype.unit_26 = thistype.createUnit(false, 'URoc', 15, -2293.22, 6337.23, 4.310, NULL)
set thistype.unit_27 = thistype.createUnit(false, 'USmo', 15, -2105.35, 5143.41, 1.860, NULL)
set thistype.unit_28 = thistype.createUnit(false, 'USto', 15, -2625.32, 6390.22, 5.140, NULL)
set thistype.unit_30 = thistype.createUnit(false, 'UThr', 15, -1248.28, 5694.68, 2.460, NULL)
set thistype.unit_37 = thistype.createUnit(true, 'qwrp', 15, -3200, 5376, 4.710, rect_BasementStairwayUpTargetLeft)
set thistype.unit_41 = thistype.createUnit(true, 'qwrp', 15, -1472, 6848, 4.710, rect_BasementStairwayUpTargetRight)
endmethod
static thistype rect_ArtifactIntroTarget
static thistype rect_BasementStairwayUpLeft
static thistype rect_BasementStairwayUpRight
static thistype rect_BasementStairwayUpTargetLeft
static thistype rect_BasementStairwayUpTargetRight
static thistype rect_Castle
static thistype rect_Chamber
static thistype rect_Creeps_Left_Air
static thistype rect_Creeps_Left_Boss
static thistype rect_Creeps_Left_Melee
static thistype rect_Creeps_Right_Buff
static thistype rect_Creeps_Right_Demon
static thistype rect_Creeps_Right_Minor
static thistype rect_DefenderSpawn_SourceCenter
static thistype rect_DefenderSpawn_TargetBottom
static thistype rect_DefenderSpawn_TargetLeft
static thistype rect_DefenderSpawn_TargetRight
static thistype rect_Gebiet_034_Kopieren
static thistype rect_Gebiet_034_Kopieren_2
static thistype rect_HeroRevival
static thistype rect_HeroRevival2
static thistype rect_HeroSelection_Aruruw
static thistype rect_HeroSelection_Center
static thistype rect_HeroSelection_Drakul
static thistype rect_HeroSelection_Jota
static thistype rect_HeroSelection_Kera
static thistype rect_HeroSelection_Lizzy
static thistype rect_HeroSelection_Rocketeye
static thistype rect_HeroSelection_Smokealot
static thistype rect_HeroSelection_Stormy
static thistype rect_HeroSelection_Tajran
static thistype rect_Introduction
static thistype rect_Introduction_Aruruw
static thistype rect_Introduction_Drakul
static thistype rect_Introduction_Light
static thistype rect_Introduction_Light2
static thistype rect_Introduction_Lizzy
static thistype rect_Introduction_Lizzy2
static thistype rect_Introduction_Lizzy3
static thistype rect_Introduction_Rocketeye
static thistype rect_Introduction_Smokealot
static thistype rect_Introduction_Stormy
static thistype rect_Introduction_Stormy2
static thistype rect_Introduction_Tajran
static thistype rect_Introduction_Tajran2
static thistype rect_LeftBrazier
static thistype rect_LeftTavern
static thistype rect_Lumber
static thistype rect_Lumber10
static thistype rect_Lumber11
static thistype rect_Lumber12
static thistype rect_Lumber13
static thistype rect_Lumber2
static thistype rect_Lumber3
static thistype rect_Lumber4
static thistype rect_Lumber5
static thistype rect_Lumber6
static thistype rect_Lumber7
static thistype rect_Lumber8
static thistype rect_Lumber9
static thistype rect_RightBrazier
static thistype rect_RightTavern
static thistype rect_Rosa
static thistype rect_SpawnBottomIn
static thistype rect_SpawnCenter
static thistype rect_SpawnDestination
static thistype rect_SpawnLeftIn
static thistype rect_SpawnRightIn
static thistype rect_StairsDownDarknessFog
static thistype rect_Tower
static thistype rect_Tower2
static thistype rect_Waypoint_RegionCheck
static thistype rect_Waypoint_RegionCheck2
static thistype rect_Waypoint_RegionCheck3
real minX
real minY
real maxX
real maxY
    static thistype array RECTS_ALL
    static integer RECTS_ALL_COUNT = ARRAY_EMPTY
    integer RECTS_index
    static method RECTS_Count takes nothing returns integer
        return thistype.RECTS_ALL_COUNT
    endmethod
    static method RECTS_IsEmpty takes nothing returns boolean
        return (thistype.RECTS_Count() == ARRAY_EMPTY)
    endmethod
    static method RECTS_Get takes integer index returns thistype
        return thistype.RECTS_ALL[index]
    endmethod
    static method RECTS_GetIndex takes thistype this returns integer
        return this.RECTS_index
    endmethod
    static method RECTS_Contains takes thistype this returns boolean
        return (thistype.RECTS_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method RECTS_Random takes integer lowBound, integer highBound returns thistype
        return thistype.RECTS_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method RECTS_RandomAll takes nothing returns thistype
        return thistype.RECTS_Random(ARRAY_MIN, thistype.RECTS_ALL_COUNT)
    endmethod
    static method RECTS_Remove takes thistype this returns boolean
        if not thistype.RECTS_Contains(this) then
            return false
        endif
        set thistype.RECTS_ALL[thistype.RECTS_ALL_COUNT].RECTS_index = this.RECTS_index
        set thistype.RECTS_ALL[this.RECTS_index - 1] = thistype.RECTS_ALL[thistype.RECTS_ALL_COUNT]
        set this.RECTS_index = ARRAY_MIN
        set thistype.RECTS_ALL_COUNT = thistype.RECTS_ALL_COUNT - 1
        return (thistype.RECTS_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method RECTS_Add takes thistype this returns boolean
        if thistype.RECTS_Contains(this) then
            return false
        endif
        set thistype.RECTS_ALL_COUNT = thistype.RECTS_ALL_COUNT + 1
        set thistype.RECTS_ALL[thistype.RECTS_ALL_COUNT] = this
        set this.RECTS_index = thistype.RECTS_ALL_COUNT + 1
        return (thistype.RECTS_ALL_COUNT == ARRAY_MIN)
    endmethod
static method createRect takes real minX, real maxX, real minY, real maxY returns thistype
local thistype this = thistype.allocate()
set this.minX = minX
set this.maxX = maxX
set this.minY = minY
set this.maxY = maxY
set this.x = (minX + maxX) / 2
set this.y = (minY + maxY) / 2
call this.RECTS_Add(this)
return this
endmethod
static method initRects
set thistype.rect_ArtifactIntroTarget = thistype.createRect(3808, 4672, -6368, -5792)
set thistype.rect_BasementStairwayUpLeft = thistype.createRect(-3328, -3072, 4928, 5504)
set thistype.rect_BasementStairwayUpRight = thistype.createRect(-1888, -1312, 6720, 6976)
set thistype.rect_BasementStairwayUpTargetLeft = thistype.createRect(-3072, -2816, 3456, 3712)
set thistype.rect_BasementStairwayUpTargetRight = thistype.createRect(2560, 2816, 3264, 3520)
set thistype.rect_Castle = thistype.createRect(-4352, 4352, -896, 3968)
set thistype.rect_Chamber = thistype.createRect(-3456, -768, 4512, 7456)
set thistype.rect_Creeps_Left_Air = thistype.createRect(-1760, -1344, -1600, -1216)
set thistype.rect_Creeps_Left_Boss = thistype.createRect(-4992, -4576, -1216, -832)
set thistype.rect_Creeps_Left_Melee = thistype.createRect(-3200, -2784, -960, -576)
set thistype.rect_Creeps_Right_Buff = thistype.createRect(3008, 3424, -1184, -800)
set thistype.rect_Creeps_Right_Demon = thistype.createRect(4544, 4960, -2848, -2464)
set thistype.rect_Creeps_Right_Minor = thistype.createRect(1472, 1888, -1664, -1280)
set thistype.rect_DefenderSpawn_SourceCenter = thistype.createRect(-384, 384, 1408, 2176)
set thistype.rect_DefenderSpawn_TargetBottom = thistype.createRect(-256, 256, -832, -448)
set thistype.rect_DefenderSpawn_TargetLeft = thistype.createRect(-4096, -3712, 1536, 2048)
set thistype.rect_DefenderSpawn_TargetRight = thistype.createRect(3584, 3968, 1536, 2048)
set thistype.rect_Gebiet_034_Kopieren = thistype.createRect(5056, 5184, -6720, -6592)
set thistype.rect_Gebiet_034_Kopieren_2 = thistype.createRect(5056, 5184, -5696, -5568)
set thistype.rect_HeroRevival = thistype.createRect(704, 1152, 384, 832)
set thistype.rect_HeroRevival2 = thistype.createRect(-1152, -704, 384, 832)
set thistype.rect_HeroSelection_Aruruw = thistype.createRect(-1760, -1696, 6208, 6272)
set thistype.rect_HeroSelection_Center = thistype.createRect(-2400, -2208, 5664, 5856)
set thistype.rect_HeroSelection_Drakul = thistype.createRect(-1152, -1088, 6240, 6304)
set thistype.rect_HeroSelection_Jota = thistype.createRect(-1632, -1568, 4992, 5056)
set thistype.rect_HeroSelection_Kera = thistype.createRect(-1984, -1920, 6240, 6304)
set thistype.rect_HeroSelection_Lizzy = thistype.createRect(-2400, -2336, 5280, 5344)
set thistype.rect_HeroSelection_Rocketeye = thistype.createRect(-2656, -2592, 6336, 6400)
set thistype.rect_HeroSelection_Smokealot = thistype.createRect(-2144, -2080, 5120, 5184)
set thistype.rect_HeroSelection_Stormy = thistype.createRect(-2336, -2272, 6304, 6368)
set thistype.rect_HeroSelection_Tajran = thistype.createRect(-1280, -1216, 5664, 5728)
set thistype.rect_Introduction = thistype.createRect(1024, 3456, 3968, 5632)
set thistype.rect_Introduction_Aruruw = thistype.createRect(2208, 2272, 5408, 5472)
set thistype.rect_Introduction_Drakul = thistype.createRect(2208, 2272, 4768, 4832)
set thistype.rect_Introduction_Light = thistype.createRect(1760, 1824, 4704, 4768)
set thistype.rect_Introduction_Light2 = thistype.createRect(2656, 2720, 4704, 4768)
set thistype.rect_Introduction_Lizzy = thistype.createRect(2912, 2976, 5952, 6016)
set thistype.rect_Introduction_Lizzy2 = thistype.createRect(2944, 3008, 5312, 5376)
set thistype.rect_Introduction_Lizzy3 = thistype.createRect(2560, 2624, 5216, 5280)
set thistype.rect_Introduction_Rocketeye = thistype.createRect(1856, 1920, 5216, 5280)
set thistype.rect_Introduction_Smokealot = thistype.createRect(2016, 2080, 5344, 5408)
set thistype.rect_Introduction_Stormy = thistype.createRect(2400, 2464, 5344, 5408)
set thistype.rect_Introduction_Stormy2 = thistype.createRect(3136, 3200, 5024, 5088)
set thistype.rect_Introduction_Tajran = thistype.createRect(1120, 1184, 4672, 4736)
set thistype.rect_Introduction_Tajran2 = thistype.createRect(1696, 1760, 4864, 4928)
set thistype.rect_LeftBrazier = thistype.createRect(-800, -512, 5504, 5792)
set thistype.rect_LeftTavern = thistype.createRect(-6400, -5536, -2208, -1600)
set thistype.rect_Lumber = thistype.createRect(5664, 5920, 3968, 4224)
set thistype.rect_Lumber10 = thistype.createRect(-992, -736, -5408, -5152)
set thistype.rect_Lumber11 = thistype.createRect(160, 416, -6112, -5856)
set thistype.rect_Lumber12 = thistype.createRect(704, 960, -6944, -6688)
set thistype.rect_Lumber13 = thistype.createRect(1408, 1664, -6016, -5760)
set thistype.rect_Lumber2 = thistype.createRect(6592, 6816, 4704, 4928)
set thistype.rect_Lumber3 = thistype.createRect(6336, 6560, 2816, 3072)
set thistype.rect_Lumber4 = thistype.createRect(1792, 2048, -3328, -3072)
set thistype.rect_Lumber5 = thistype.createRect(-3168, -2912, -3200, -2944)
set thistype.rect_Lumber6 = thistype.createRect(-3360, -3104, -3136, -2880)
set thistype.rect_Lumber7 = thistype.createRect(-6560, -6304, 800, 1056)
set thistype.rect_Lumber8 = thistype.createRect(-6912, -6656, 2144, 2400)
set thistype.rect_Lumber9 = thistype.createRect(-5824, -5568, 2336, 2592)
set thistype.rect_RightBrazier = thistype.createRect(512, 800, 5504, 5792)
set thistype.rect_RightTavern = thistype.createRect(5312, 6272, -2272, -1568)
set thistype.rect_Rosa = thistype.createRect(1088, 1184, 352, 448)
set thistype.rect_SpawnBottomIn = thistype.createRect(-704, 32, -6784, -5984)
set thistype.rect_SpawnCenter = thistype.createRect(-640, 640, 1152, 2432)
set thistype.rect_SpawnDestination = thistype.createRect(-320, 288, 3424, 4000)
set thistype.rect_SpawnLeftIn = thistype.createRect(-7648, -7040, 1600, 2304)
set thistype.rect_SpawnRightIn = thistype.createRect(7008, 7616, 1344, 2240)
set thistype.rect_StairsDownDarknessFog = thistype.createRect(3136, 3296, 3360, 3424)
set thistype.rect_Tower = thistype.createRect(-768, -704, -224, -160)
set thistype.rect_Tower2 = thistype.createRect(704, 768, -224, -160)
set thistype.rect_Waypoint_RegionCheck = thistype.createRect(-7712, 8192, 160, 4992)
set thistype.rect_Waypoint_RegionCheck2 = thistype.createRect(-1216, 1216, -8192, 160)
set thistype.rect_Waypoint_RegionCheck3 = thistype.createRect(-1024, 1024, 3968, 6336)
endmethod
endstruct
    globals
        BoolExpr BOOL_EXPR = STRUCT_BASE
    endglobals
    struct BoolExpr
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static HashTable TABLE
    static thistype DEFAULT_TRUE
    boolexpr self
    method Destroy takes nothing returns nothing
        local boolexpr self = this.self
        call this.deallocate()
        call DestroyBoolExpr(self)
        set self = null
    endmethod
    static method GetByAnd takes BoolExpr a, BoolExpr b returns thistype
        local thistype this = thistype.TABLE.Integer.Get(a, b)
        if (this == HASH_TABLE.Integer.DEFAULT_VALUE) then
            set this = thistype.allocate()
            set this.self = And(a.self, b.self)
            call thistype.TABLE.Integer.Set(a, b, this)
        endif
        return this
    endmethod
    static method GetFromFunction takes code whichFunction returns thistype
        local integer whichFunctionId = Code.GetId(whichFunction)
        local thistype this = thistype.TABLE.Integer.Get(whichFunctionId, KEY)
        if (this == HASH_TABLE.Integer.DEFAULT_VALUE) then
            set this = thistype.allocate()
            set this.self = Condition(whichFunction)
            call thistype.TABLE.Integer.Set(whichFunctionId, KEY, this)
        endif
        return this
    endmethod
    method GetSelf takes nothing returns boolexpr
        return this.self
    endmethod
    static method DefaultTrue takes nothing returns boolean
        return true
    endmethod
    method Run takes nothing returns boolean
        if (this == NULL) then
            return true
        endif
        local trigger whichTrigger = CreateTrigger()
        call TriggerAddCondition(whichTrigger, this.self)
        local boolean result = TriggerEvaluate(whichTrigger)
        call DestroyTrigger(whichTrigger)
        set whichTrigger = null
        return result
    endmethod
    method RunWithParams takes EventResponse params returns boolean
        call EventResponse.SetTrigger(params)
        return this.Run()
    endmethod
    initMethod Init of Header_2
        set thistype.TABLE = HashTable.Create()
        set thistype(NULL).self = null
        set thistype.DEFAULT_TRUE = BoolExpr.GetFromFunction(function thistype.DefaultTrue)
    endmethod
endstruct
    scope FolderBuff
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    public struct StructBoolean
        implement Allocation
        implement List
        
    method Get takes integer key returns boolean
        return Buff(this).Data.table.IntegerKeys.GetBoolean(Buff(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Buff(this).Data.table.IntegerKeys.RemoveBoolean(Buff(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call Buff(this).Data.table.IntegerKeys.SetBoolean(Buff(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return Buff(this).Data.table.IntegerKeys.Table.ContainsInteger(Buff(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Buff(this).Data.table.IntegerKeys.Table.CountIntegers(Buff(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Buff(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Buff(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Buff(this).Data.table.IntegerKeys.Table.GetInteger(Buff(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Buff(this).Data.table.IntegerKeys.Table.GetFirstInteger(Buff(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Buff(this).Data.table.IntegerKeys.Table.GetLastInteger(Buff(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Buff(this).Data.table.IntegerKeys.Table.Clear(Buff(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Buff(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Buff(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Buff(this).Data.table.IntegerKeys.Table.RemoveInteger(Buff(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Buff(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Buff(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Buff(this).Data.table.IntegerKeys.Table.AddInteger(Buff(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Buff(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Buff(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Buff(this).Data.table.IntegerKeys.Table.JoinInteger(Buff(this).Id.Get(), key, Buff(other).Data.table, Buff(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Buff(this).Data.table.IntegerKeys.Table.RandomInteger(Buff(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Buff(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Buff(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Buff(this).Data.table.IntegerKeys.Table.PrintIntegers(Buff(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return Buff(this).Data.table.IntegerKeys.GetInteger(Buff(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Buff(this).Data.table.IntegerKeys.RemoveInteger(Buff(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Buff(this).Data.table.IntegerKeys.SetInteger(Buff(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderReal
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, real value returns boolean
        return Buff(this).Data.table.IntegerKeys.Table.ContainsReal(Buff(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Buff(this).Data.table.IntegerKeys.Table.CountReals(Buff(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Buff(this).Data.table.IntegerKeys.Table.IsEmptyReal(Buff(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns real
        return Buff(this).Data.table.IntegerKeys.Table.GetReal(Buff(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns real
        return Buff(this).Data.table.IntegerKeys.Table.GetFirstReal(Buff(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns real
        return Buff(this).Data.table.IntegerKeys.Table.GetLastReal(Buff(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Buff(this).Data.table.IntegerKeys.Table.Clear(Buff(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns real
        return Buff(this).Data.table.IntegerKeys.Table.FetchFirstReal(Buff(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, real value returns boolean
        return Buff(this).Data.table.IntegerKeys.Table.RemoveReal(Buff(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Buff(this).Data.table.IntegerKeys.Table.RemoveRealByIndex(Buff(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, real value returns boolean
        return Buff(this).Data.table.IntegerKeys.Table.AddReal(Buff(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, real value returns boolean
        return Buff(this).Data.table.IntegerKeys.Table.AddRealMulti(Buff(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Buff(this).Data.table.IntegerKeys.Table.JoinReal(Buff(this).Id.Get(), key, Buff(other).Data.table, Buff(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns real
        return Buff(this).Data.table.IntegerKeys.Table.RandomReal(Buff(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns real
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Buff(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Buff(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Buff(this).Data.table.IntegerKeys.Table.PrintReals(Buff(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructReal
        implement Allocation
        implement List
        
    FolderReal_StructTable Table = this
    FolderReal_StructTable LinkToStruct_Table
    method Get takes integer key returns real
        return Buff(this).Data.table.IntegerKeys.GetReal(Buff(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Real.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Buff(this).Data.table.IntegerKeys.RemoveReal(Buff(this).Id.Get(), key)
    endmethod
    method Set takes integer key, real value returns nothing
        call Buff(this).Data.table.IntegerKeys.SetReal(Buff(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderString
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, string value returns boolean
        return Buff(this).Data.table.IntegerKeys.Table.ContainsString(Buff(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Buff(this).Data.table.IntegerKeys.Table.CountStrings(Buff(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Buff(this).Data.table.IntegerKeys.Table.IsEmptyString(Buff(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns string
        return Buff(this).Data.table.IntegerKeys.Table.GetString(Buff(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns string
        return Buff(this).Data.table.IntegerKeys.Table.GetFirstString(Buff(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns string
        return Buff(this).Data.table.IntegerKeys.Table.GetLastString(Buff(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Buff(this).Data.table.IntegerKeys.Table.Clear(Buff(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns string
        return Buff(this).Data.table.IntegerKeys.Table.FetchFirstString(Buff(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, string value returns boolean
        return Buff(this).Data.table.IntegerKeys.Table.RemoveString(Buff(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Buff(this).Data.table.IntegerKeys.Table.RemoveStringByIndex(Buff(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, string value returns boolean
        return Buff(this).Data.table.IntegerKeys.Table.AddString(Buff(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, string value returns boolean
        return Buff(this).Data.table.IntegerKeys.Table.AddStringMulti(Buff(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Buff(this).Data.table.IntegerKeys.Table.JoinString(Buff(this).Id.Get(), key, Buff(other).Data.table, Buff(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns string
        return Buff(this).Data.table.IntegerKeys.Table.RandomString(Buff(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns string
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Buff(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Buff(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Buff(this).Data.table.IntegerKeys.Table.PrintStrings(Buff(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructString
        implement Allocation
        implement List
        
    FolderString_StructTable Table = this
    FolderString_StructTable LinkToStruct_Table
    method Get takes integer key returns string
        return Buff(this).Data.table.IntegerKeys.GetString(Buff(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.String.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Buff(this).Data.table.IntegerKeys.RemoveString(Buff(this).Id.Get(), key)
    endmethod
    method Set takes integer key, string value returns nothing
        call Buff(this).Data.table.IntegerKeys.SetString(Buff(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
    FolderData_StructReal Real = this
    FolderData_StructReal LinkToStruct_Real
    FolderData_StructString String = this
    FolderData_StructString LinkToStruct_String
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Buff(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Buff.Allocation.deallocate_demount.hook
		call Buff(this).Data.Destroy()
	endinject
	inject Buff.Allocation.allocate_mount.hook
		call Buff(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructEvent
        implement Allocation
        implement List
        
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(Buff(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(Buff(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(Buff(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(Buff(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(Buff(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(Buff(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(Buff(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(Buff(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject Buff.Allocation.deallocate_demount.hook
			call Buff(this).Event.Destroy()
		endinject
		inject Buff.Allocation.allocate_mount.hook
			call Buff(this).Event.Event_Create()
		endinject
    endstruct
    public struct StructTargetEffects
        implement Allocation
        implement List
        
    static key GetKeyMacro_ATTACH_POINTS_KEY_ARRAY
    static constant integer ATTACH_POINTS_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_ATTACH_POINTS_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_LEVELS_KEY_ARRAY
    static constant integer LEVELS_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_LEVELS_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_PATHS_KEY_ARRAY
    static constant integer PATHS_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_PATHS_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    boolean shownOnApply
    method IsShownOnApply takes nothing returns boolean
        return this.shownOnApply
    endmethod
    method SetShownOnApply takes boolean value returns nothing
        set this.shownOnApply = value
    endmethod
        method Count takes nothing returns integer
            return Buff(this).Data.String.Table.Count(PATHS_KEY_ARRAY)
        endmethod
        method GetAttachPoint takes integer index returns string
            return Buff(this).Data.String.Table.Get(ATTACH_POINTS_KEY_ARRAY, index)
        endmethod
        method GetLevel takes integer index returns integer
            return Buff(this).Data.Integer.Table.Get(LEVELS_KEY_ARRAY, index)
        endmethod
        method GetPath takes integer index returns string
            return Buff(this).Data.String.Table.Get(PATHS_KEY_ARRAY, index)
        endmethod
        method Add takes string path, string attachPoint, EffectLevel level returns nothing
            call Buff(this).Data.String.Table.AddMulti(ATTACH_POINTS_KEY_ARRAY, attachPoint)
            call Buff(this).Data.Integer.Table.AddMulti(LEVELS_KEY_ARRAY, level)
            call Buff(this).Data.String.Table.AddMulti(PATHS_KEY_ARRAY, path)
            call Effect.PreloadPath(path)
        endmethod
		method Event_Create takes nothing returns nothing
			call this.SetShownOnApply(true)
		endmethod
    endstruct
    public struct StructLoopSounds
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        method Count takes nothing returns integer
            return Buff(this).Data.String.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns integer
            return Buff(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method Add takes SoundType val returns nothing
            call Buff(this).Data.Integer.Table.AddMulti(KEY_ARRAY, val)
        endmethod
	endstruct
    public struct StructVariants
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_PARENT_KEY_ARRAY
    static constant integer PARENT_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_PARENT_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        method Count takes nothing returns integer
            return Buff(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns Buff
            return Buff(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method CountParents takes nothing returns integer
            return Buff(this).Data.Integer.Table.Count(PARENT_KEY_ARRAY)
        endmethod
        method GetParent takes integer index returns Buff
            return Buff(this).Data.Integer.Table.Get(PARENT_KEY_ARRAY, index)
        endmethod
        method Add takes Buff child returns nothing
            local Buff parent = this
            call child.Data.Integer.Table.Add(PARENT_KEY_ARRAY, parent)
            call parent.Data.Integer.Table.Add(KEY_ARRAY, child)
        endmethod
        method Event_Create takes nothing returns nothing
        endmethod
    endstruct
    public struct StructUnitMods
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY_DETAIL_VAL
    static constant integer KEY_ARRAY_DETAIL_VAL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL_VAL * Memory.IntegerKeys.Table.SIZE
        method Count takes nothing returns integer
            return Buff(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns UnitState
            return Buff(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method GetVal takes UnitState state returns real
            return Buff(this).Data.Real.Get(KEY_ARRAY_DETAIL_VAL + state)
        endmethod
        method Add takes UnitState state, real val returns nothing
            call Buff(this).Data.Integer.Table.Add(KEY_ARRAY, state)
            call Buff(this).Data.Real.Set(KEY_ARRAY_DETAIL_VAL + state, val)
        endmethod
    endstruct
    public struct StructUnitModSets
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
        method Get takes integer level returns UnitState
            return Buff(this).Data.Integer.Get(KEY_ARRAY_DETAIL + level)
        endmethod
        method Add takes integer level, UnitModSet val returns nothing
            call Buff(this).Data.Integer.Set(KEY_ARRAY_DETAIL + level, val)
        endmethod
    endstruct
endscope
    globals
        Buff BUFF = STRUCT_BASE
    endglobals
    struct Buff
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static thistype TEMP
    FolderBuff_StructData Data = this
    FolderBuff_StructData LinkToStruct_Data
    FolderBuff_StructEvent Event = this
    FolderBuff_StructEvent LinkToStruct_Event
    FolderBuff_StructId Id = this
    FolderBuff_StructId LinkToStruct_Id
    FolderBuff_StructLoopSounds LoopSounds = this
    FolderBuff_StructLoopSounds LinkToStruct_LoopSounds
    FolderBuff_StructTargetEffects TargetEffects = this
    FolderBuff_StructTargetEffects LinkToStruct_TargetEffects
    FolderBuff_StructUnitMods UnitMods = this
    FolderBuff_StructUnitMods LinkToStruct_UnitMods
    FolderBuff_StructUnitModSets UnitModSets = this
    FolderBuff_StructUnitModSets LinkToStruct_UnitModSets
    FolderBuff_StructVariants Variants = this
    FolderBuff_StructVariants LinkToStruct_Variants
    static method GetFromName takes string name returns thistype
        return StringData.Data.Integer.Get(name, KEY)
    endmethod
    static method GetFromSelf takes integer self returns thistype
        return Memory.IntegerKeys.GetInteger(self, KEY)
    endmethod
    integer dummySpellId
    method GetDummySpellId takes nothing returns integer
        return this.dummySpellId
    endmethod
    method SetDummySpellId takes integer value returns nothing
        set this.dummySpellId = value
    endmethod
    boolean hidden
    method IsHidden takes nothing returns boolean
        return this.hidden
    endmethod
    method SetHidden takes boolean value returns nothing
        set this.hidden = value
    endmethod
    string icon
    method GetIcon takes nothing returns string
        return this.icon
    endmethod
    method SetIcon takes string value returns nothing
        set this.icon = value
    endmethod
    boolean lostOnDeath
    method IsLostOnDeath takes nothing returns boolean
        return this.lostOnDeath
    endmethod
    method SetLostOnDeath takes boolean value returns nothing
        set this.lostOnDeath = value
    endmethod
    boolean lostOnDispel
    method IsLostOnDispel takes nothing returns boolean
        return this.lostOnDispel
    endmethod
    method SetLostOnDispel takes boolean value returns nothing
        set this.lostOnDispel = value
    endmethod
    string name
    method GetName takes nothing returns string
        return this.name
    endmethod
    method SetName takes string value returns nothing
        set this.name = value
    endmethod
    boolean positive
    method IsPositive takes nothing returns boolean
        return this.positive
    endmethod
    method SetPositive takes boolean value returns nothing
        set this.positive = value
    endmethod
    integer self
    method GetSelf takes nothing returns integer
        return this.self
    endmethod
    method SetSelf takes integer value returns nothing
        set this.self = value
    endmethod
    boolean showCountdown
    method IsShowCountdown takes nothing returns boolean
        return this.showCountdown
    endmethod
    method SetShowCountdown takes boolean value returns nothing
        set this.showCountdown = value
    endmethod
    static method Create takes integer self, string name, integer spellId returns thistype
        local thistype this = thistype.allocate()
        set this.self = self
        call Memory.IntegerKeys.SetInteger(self, KEY, this)
		call this.Id.Event_Create()
        call this.SetDummySpellId(spellId)
        call this.SetHidden(false)
        call this.SetLostOnDeath(false)
        call this.SetLostOnDispel(false)
        call this.SetName(name)
        call this.SetShowCountdown(false)
		call this.TargetEffects.Event_Create()
        call this.Variants.Event_Create()
        call InitBuff(self)
        call InitAbility(spellId, true)
        call StringData.Data.Integer.Set(this.GetName(), KEY, this)
        call this.AddToList()
        return this
    endmethod
    static key GetKeyMacro_INIT_KEY_ARRAY
    static constant integer INIT_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_INIT_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static method AddInit takes code c, string name returns nothing
        call Trigger.AddObjectInit(INIT_KEY_ARRAY, c, name)
    endmethod
    static method CreateHidden takes string name returns thistype
        local thistype this = thistype.allocate()
		call this.Id.Event_Create()
        call this.SetHidden(true)
        call this.SetLostOnDeath(false)
        call this.SetLostOnDispel(false)
        call this.SetName(name + " (hidden)")
		call this.TargetEffects.Event_Create()
        call this.Variants.Event_Create()
        call StringData.Data.Integer.Set(this.GetName(), KEY, this)
        call this.AddToList()
        return this
    endmethod
    initMethod Init of Header_2
    endmethod
endstruct
    scope FolderCameraField
    public struct StructTimed
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    static constant real UPDATE_TIME = (1 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (1 * 1.))
        static Timer UPDATE_TIMER
        Timer durationTimer
        CameraField parent
        real remainingWavesAmount
        real value
        User whichPlayer
        method Ending takes Timer durationTimer, CameraField parent, User whichPlayer returns nothing
            call this.deallocate()
            call durationTimer.Destroy()
            if this.RemoveFromList() then
                call thistype.UPDATE_TIMER.Pause()
            endif
            call whichPlayer.Data.Integer.Remove(KEY_ARRAY_DETAIL + parent)
        endmethod
        static method EndingByTimer takes nothing returns nothing
            local Timer durationTimer = Timer.GetExpired()
            local thistype this = durationTimer.GetData()
            local CameraField parent = this.parent
            local real value = this.value
            local User whichPlayer = this.whichPlayer
            call this.Ending(durationTimer, parent, whichPlayer)
            call parent.Set(whichPlayer, value)
        endmethod
        static method Update takes nothing returns nothing
            local integer iteration = thistype.ALL_COUNT
            loop
                local thistype this = thistype.ALL[iteration]
                local CameraField parent = this.parent
                local real remainingWavesAmount = this.remainingWavesAmount
                local real oldValue = parent.Get()
                set this.remainingWavesAmount = remainingWavesAmount - 1
                call parent.Set(this.whichPlayer, oldValue + (this.value - oldValue) / remainingWavesAmount)
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
        endmethod
        method Set takes User whichPlayer, real value, real duration returns nothing
            local CameraField parent = this
            set this = whichPlayer.Data.Integer.Get(KEY_ARRAY_DETAIL + parent)
            if (this != NULL) then
                call this.Ending(this.durationTimer, parent, whichPlayer)
            endif
            set this = thistype.allocate()
			local Timer durationTimer = Timer.Create()
            set this.durationTimer = durationTimer
            set this.parent = parent
            set this.remainingWavesAmount = duration / thistype.UPDATE_TIME
            set this.value = value
            set this.whichPlayer = whichPlayer
            call durationTimer.SetData(this)
            call whichPlayer.Data.Integer.Set(KEY_ARRAY_DETAIL + parent, this)
            if this.AddToList() then
                call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
            endif
            call durationTimer.Start(duration, false, function thistype.EndingByTimer)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.UPDATE_TIMER = Timer.Create()
        endmethod
    endstruct
endscope
    globals
        CameraField CAMERA_FIELD = STRUCT_BASE
    endglobals
    struct CameraField
        implement Allocation
        implement List
        
    static thistype FAR_Z
    static thistype FIELD_OF_VIEW
    static thistype PITCH
    static thistype ROLL
    static thistype TARGET_DISTANCE
    static thistype YAW
    static thistype Z
    camerafield self
    FolderCameraField_StructTimed Timed = this
    FolderCameraField_StructTimed LinkToStruct_Timed
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes User whichPlayer, real value returns nothing
        if whichPlayer.IsLocal() then
            set this.value = value
            call SetCameraField(this.self, value, 0.)
        endif
    endmethod
    static method Create takes camerafield self returns thistype
        local thistype this = thistype.allocate()
        set this.self = self
        return this
    endmethod
    static method Init takes nothing returns nothing
        call thistype(NULL).Timed.Init()
        
        set thistype.FAR_Z = thistype.Create(CAMERA_FIELD_FARZ)
        
        set thistype.FIELD_OF_VIEW = thistype.Create(CAMERA_FIELD_FIELD_OF_VIEW)
        
        set thistype.PITCH = thistype.Create(CAMERA_FIELD_ANGLE_OF_ATTACK)
        
        set thistype.ROLL = thistype.Create(CAMERA_FIELD_ROLL)
        
        set thistype.TARGET_DISTANCE = thistype.Create(CAMERA_FIELD_TARGET_DISTANCE)
        
        set thistype.YAW = thistype.Create(CAMERA_FIELD_ROTATION)
        
        set thistype.Z = thistype.Create(CAMERA_FIELD_ZOFFSET)
    endmethod
endstruct
    scope FolderCamera
    public struct StructEye
        implement Allocation
        implement List
        
        static method GetX takes nothing returns real
            return GetCameraEyePositionX()
        endmethod
        static method GetY takes nothing returns real
            return GetCameraEyePositionY()
        endmethod
        static method GetZ takes nothing returns real
            return GetCameraEyePositionZ()
        endmethod
    endstruct
    public struct StructTarget
        implement Allocation
        implement List
        
        static method GetX takes nothing returns real
            return GetCameraTargetPositionX()
        endmethod
        static method GetY takes nothing returns real
            return GetCameraTargetPositionY()
        endmethod
        static method GetZ takes nothing returns real
            return GetCameraTargetPositionZ()
        endmethod
    endstruct
    
    public struct StructPanTimedViaBounds
        implement Allocation
        implement List
        
    static thistype array ACTIVE_LIST_ALL
    static integer ACTIVE_LIST_ALL_COUNT = ARRAY_EMPTY
    integer ACTIVE_LIST_index
    static method ACTIVE_LIST_Count takes nothing returns integer
        return thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static method ACTIVE_LIST_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Get takes integer index returns thistype
        return thistype.ACTIVE_LIST_ALL[index]
    endmethod
    static method ACTIVE_LIST_GetIndex takes thistype this returns integer
        return this.ACTIVE_LIST_index
    endmethod
    static method ACTIVE_LIST_Contains takes thistype this returns boolean
        return (thistype.ACTIVE_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ACTIVE_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ACTIVE_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ACTIVE_LIST_RandomAll takes nothing returns thistype
        return thistype.ACTIVE_LIST_Random(ARRAY_MIN, thistype.ACTIVE_LIST_ALL_COUNT)
    endmethod
    static method ACTIVE_LIST_Remove takes thistype this returns boolean
        if not thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT].ACTIVE_LIST_index = this.ACTIVE_LIST_index
        set thistype.ACTIVE_LIST_ALL[this.ACTIVE_LIST_index - 1] = thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT]
        set this.ACTIVE_LIST_index = ARRAY_MIN
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT - 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Add takes thistype this returns boolean
        if thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT + 1
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT] = this
        set this.ACTIVE_LIST_index = thistype.ACTIVE_LIST_ALL_COUNT + 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static constant real UPDATE_TIME = (1 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (1 * 1.))
    	static Timer UPDATE_TIMER
		Timer durationTimer
		boolean running
    	real xAdd
    	real yAdd
    	
    	static method EndingByTimer takes nothing returns nothing
    		local thistype this = Timer.GetExpired().GetData()
			local User whichPlayer = this
    		set this.running = false
    		
    		if thistype.ACTIVE_LIST_Remove(this) then
    			call thistype.UPDATE_TIMER.Pause()
    		endif
    		
    		call Camera.UpdateBounds(whichPlayer)
    	endmethod
    	
    	static code UPDATE_ALL_FUNC
    	
    	timerMethod UpdateReset
    		local integer i = thistype.ACTIVE_LIST_ALL_COUNT
    		loop
    			exitwhen (i < ARRAY_MIN)
    			
    			local thistype this = thistype.ACTIVE_LIST_ALL[i]
    			
    			local User whichPlayer = this
    			
    			if whichPlayer.IsLocal() then
    				call Camera.UpdateBounds(whichPlayer)
    			endif
    			
    			set i = i - 1
    		endloop
    		
    		call Timer.GetExpired().Start(0.03, false, thistype.UPDATE_ALL_FUNC)
    	endmethod
    	
    	timerMethod UpdateAll
    		local integer i = thistype.ACTIVE_LIST_ALL_COUNT
    		
    		loop
    			exitwhen (i < ARRAY_MIN)
    			
    			local thistype this = thistype.ACTIVE_LIST_ALL[i]
    			
    			local User whichPlayer = this
    			
    			local real xAdd = this.xAdd
    			local real yAdd = this.yAdd
                local real x = CAMERA.Target.GetX() + xAdd
                local real y = CAMERA.Target.GetY() + yAdd
                
                if whichPlayer.IsLocal() then
                    if whichPlayer.KeyEvent.LeftArrow.IsPressing() then
                        set x = x - 6000 * thistype.UPDATE_TIME
                        
                    endif
                    if whichPlayer.KeyEvent.RightArrow.IsPressing() then
                        set x = x + 6000 * thistype.UPDATE_TIME
                        
                    endif
                    if whichPlayer.KeyEvent.DownArrow.IsPressing() then
                        set y = y - 6000 * thistype.UPDATE_TIME
                        
                    endif
                    if whichPlayer.KeyEvent.UpArrow.IsPressing() then
                        set y = y + 6000 * thistype.UPDATE_TIME
                        
                    endif
                	
                endif
                
                if whichPlayer.IsLocal() then
                	call SetCameraBounds(x, y, x, y, x, y, x, y)
                endif
                
                set i = i - 1
    		endloop
    		
    		call Timer.GetExpired().Start(0.03, false, function thistype.UpdateReset)
    	endmethod
    	
    	static method Start takes User whichPlayer, real x, real y, real duration returns nothing
    		local real dX = x - CAMERA.Target.GetX()
    		local real dY = y - CAMERA.Target.GetY()
    		
    		local thistype this = whichPlayer
    		set this.xAdd = dX * thistype.UPDATE_TIME / duration
    		set this.yAdd = dY * thistype.UPDATE_TIME / duration
    		
    		call this.durationTimer.Start(duration, false, function thistype.EndingByTimer)
    		
    		if this.running then
                return
            endif
    		
    		set this.running = true
    		
    		if thistype.ACTIVE_LIST_Add(this) then
    			call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.UpdateAll)
    		endif
    	endmethod
    	
    	enumMethod InitPlayer
    		local User whichPlayer = params.User.GetTrigger()
    		
    		local thistype this = whichPlayer
			local Timer durationTimer = Timer.Create()
			set this.durationTimer = durationTimer
			set this.running = false
			call durationTimer.SetData(this)
    	endmethod
    	
    	static method Init takes nothing returns nothing
    		set thistype.UPDATE_ALL_FUNC = function thistype.UpdateAll
    		set thistype.UPDATE_TIMER = Timer.Create()
    		
    		call Force.ALL_USERS.Do(function thistype.InitPlayer, NULL)
    	endmethod
    endstruct
    
    public struct StructShake
        implement Allocation
        implement List
        
    static thistype array ACTIVE_LIST_ALL
    static integer ACTIVE_LIST_ALL_COUNT = ARRAY_EMPTY
    integer ACTIVE_LIST_index
    static method ACTIVE_LIST_Count takes nothing returns integer
        return thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static method ACTIVE_LIST_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Get takes integer index returns thistype
        return thistype.ACTIVE_LIST_ALL[index]
    endmethod
    static method ACTIVE_LIST_GetIndex takes thistype this returns integer
        return this.ACTIVE_LIST_index
    endmethod
    static method ACTIVE_LIST_Contains takes thistype this returns boolean
        return (thistype.ACTIVE_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ACTIVE_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ACTIVE_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ACTIVE_LIST_RandomAll takes nothing returns thistype
        return thistype.ACTIVE_LIST_Random(ARRAY_MIN, thistype.ACTIVE_LIST_ALL_COUNT)
    endmethod
    static method ACTIVE_LIST_Remove takes thistype this returns boolean
        if not thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT].ACTIVE_LIST_index = this.ACTIVE_LIST_index
        set thistype.ACTIVE_LIST_ALL[this.ACTIVE_LIST_index - 1] = thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT]
        set this.ACTIVE_LIST_index = ARRAY_MIN
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT - 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Add takes thistype this returns boolean
        if thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT + 1
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT] = this
        set this.ACTIVE_LIST_index = thistype.ACTIVE_LIST_ALL_COUNT + 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
    	static Timer UPDATE_TIMER
    	
    	real cur
    	real power
    	real powerAdd
    	real xAdd
    	real yAdd
    	
    	timerMethod UpdateAll
    		local integer i = thistype.ACTIVE_LIST_ALL_COUNT
    		
    		loop
    			exitwhen (i < ARRAY_MIN)
    			
    			local thistype this = thistype.ACTIVE_LIST_ALL[i]
    			
    			local User whichPlayer = this
    			
    			local real power = this.power + this.powerAdd
    			if (power < 1) then
                     call CAMERA.PanTimedViaBounds.Start(whichPlayer, CAMERA.Target.GetX() - this.xAdd, CAMERA.Target.GetY() - this.yAdd, 1.)
                     
                     set this.cur = 0.
                     set this.power = 0.
                     set this.xAdd = 0.
                     set this.yAdd = 0.
                     
                     if thistype.ACTIVE_LIST_Remove(this) then
					     call thistype.UPDATE_TIMER.Pause()
                     endif
                else
                    local real angle = Math.RandomAngle()
                    local real cur = this.cur + 0.9
                    
                    local real curSin = Math.Sin(cur)
                    
                    set this.cur = cur
                    set this.power = power
                    set this.xAdd = Math.Cos(angle) * curSin * power
                    set this.yAdd = Math.Sin(angle) * curSin * power
                    
                    call CAMERA.PanTimedViaBounds.Start(whichPlayer, CAMERA.Target.GetX() + this.xAdd, CAMERA.Target.GetY() + this.yAdd, 1.)
                endif
                
                set i = i - 1
    		endloop
    	endmethod
    	
    	static method Add takes User whichPlayer, real power, real duration returns nothing
    		local thistype this = whichPlayer
    		
    		set this.power = this.power + power
    		set this.powerAdd = this.powerAdd + (-power / duration * thistype.UPDATE_TIME)
    		
    		if thistype.ACTIVE_LIST_Add(this) then
    			call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.UpdateAll)
    		endif
    	endmethod
    	
    	enumMethod InitPlayer
    		local User whichPlayer = params.User.GetTrigger()
    		local thistype this = whichPlayer
    		set this.cur = 0.
    		set this.power = 0.
    		set this.powerAdd = 0.
    		set this.xAdd = 0.
    		set this.yAdd = 0.
    	endmethod
    	
    	static method Init takes nothing returns nothing
    		set thistype.UPDATE_TIMER = Timer.Create()
    		
    		call Force.ALL_USERS.Do(function thistype.InitPlayer, NULL)
    	endmethod
    endstruct
    
    public struct StructSeismic
        implement Allocation
        implement List
        
    static thistype array ACTIVE_LIST_ALL
    static integer ACTIVE_LIST_ALL_COUNT = ARRAY_EMPTY
    integer ACTIVE_LIST_index
    static method ACTIVE_LIST_Count takes nothing returns integer
        return thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static method ACTIVE_LIST_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Get takes integer index returns thistype
        return thistype.ACTIVE_LIST_ALL[index]
    endmethod
    static method ACTIVE_LIST_GetIndex takes thistype this returns integer
        return this.ACTIVE_LIST_index
    endmethod
    static method ACTIVE_LIST_Contains takes thistype this returns boolean
        return (thistype.ACTIVE_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ACTIVE_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ACTIVE_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ACTIVE_LIST_RandomAll takes nothing returns thistype
        return thistype.ACTIVE_LIST_Random(ARRAY_MIN, thistype.ACTIVE_LIST_ALL_COUNT)
    endmethod
    static method ACTIVE_LIST_Remove takes thistype this returns boolean
        if not thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT].ACTIVE_LIST_index = this.ACTIVE_LIST_index
        set thistype.ACTIVE_LIST_ALL[this.ACTIVE_LIST_index - 1] = thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT]
        set this.ACTIVE_LIST_index = ARRAY_MIN
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT - 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Add takes thistype this returns boolean
        if thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT + 1
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT] = this
        set this.ACTIVE_LIST_index = thistype.ACTIVE_LIST_ALL_COUNT + 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    	static GameCache SYNC_CACHE
    static constant real UPDATE_TIME = (4 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (4 * 1.))
    	static Timer UPDATE_TIMER
    	
    	static boolean SYNCING = false
    	
    	Timer durationTimer
    	real falloff
    	real length
    	real lengthAdd
    	real powerMax
    	real powerMin
    	Force targetForce
    	real x
    	real y
    	real z
    	
    	method Ending takes nothing returns nothing
    		local Timer durationTimer = this.durationTimer
    		local Force targetForce = this.targetForce
    		
    		call durationTimer.Destroy()
    		call targetForce.Destroy()
    		
    		call this.deallocate()
    		
    		if thistype.ACTIVE_LIST_Remove(this) then
                call thistype.UPDATE_TIMER.Pause()
    		endif
    	endmethod
    	
    	static method EndingByTimer takes nothing returns nothing
    		local thistype this = Timer.GetExpired().GetData()
    		
    		call this.Ending()
    	endmethod
    	
    	static string array SYNC_X_KEYS
    	static string array SYNC_Y_KEYS
    	static string array SYNC_Z_KEYS
    	
    	static method UpdateAll_Exec takes nothing returns nothing
			local real eyeX = CAMERA.Eye.GetX()
			local real eyeY = CAMERA.Eye.GetY()
			local real eyeZ = CAMERA.Eye.GetZ()
    		local real array eyeXs
    		local real array eyeYs
    		local real array eyeZs
    		local real length
    		local thistype this
    		local User whichPlayer
			local string syncXKey
			local string syncYKey
			local string syncZKey
    		local integer i = thistype.ACTIVE_LIST_ALL_COUNT
    		loop
    			exitwhen (i < ARRAY_MIN)
    			
    			set this = thistype.ACTIVE_LIST_ALL[i]
    			
    			set length = this.length + this.lengthAdd 
    		
    			set this.length = length
    			set i = i - 1
    		endloop
    		if thistype.SYNCING then
                return
            endif
    		set i = User.PLAYING_HUMANS_COUNT 
    		loop
    			exitwhen (i < ARRAY_MIN)
    			
    			set whichPlayer = User.PLAYING_HUMANS[i]
    			
    			if whichPlayer.IsLocal() then
                	set syncXKey = SYNC_X_KEYS[whichPlayer]
                	set syncYKey = SYNC_Y_KEYS[whichPlayer]
                	set syncZKey = SYNC_Z_KEYS[whichPlayer]
                    
                    call thistype.SYNC_CACHE.Real.SetAndSync(syncXKey, syncXKey, CAMERA.Eye.GetX())
                    call thistype.SYNC_CACHE.Real.SetAndSync(syncYKey, syncYKey, CAMERA.Eye.GetY())                    
                    call thistype.SYNC_CACHE.Real.SetAndSync(syncZKey, syncZKey, CAMERA.Eye.GetZ())
                endif
    			
    			set i = i - 1
    		endloop
			set thistype.SYNCING = true
            call TriggerSyncStart()
            call TriggerSyncReady()
			set thistype.SYNCING = false
    		set i = User.PLAYING_HUMANS_COUNT
    		
    		loop
    			exitwhen (i < ARRAY_MIN)
				set whichPlayer = User.PLAYING_HUMANS[i]
                set syncXKey = SYNC_X_KEYS[whichPlayer]
                set syncYKey = SYNC_Y_KEYS[whichPlayer]
                set syncZKey = SYNC_Z_KEYS[whichPlayer]
                
                set eyeXs[whichPlayer] = thistype.SYNC_CACHE.Real.Get(syncXKey, syncXKey)
                set eyeYs[whichPlayer] = thistype.SYNC_CACHE.Real.Get(syncYKey, syncYKey)
                set eyeZs[whichPlayer] = thistype.SYNC_CACHE.Real.Get(syncZKey, syncZKey)
    			
    			set i = i - 1
    		endloop
    		
    		set i = thistype.ACTIVE_LIST_ALL_COUNT
    		loop
    			exitwhen (i < ARRAY_MIN)
    			
    			set this = thistype.ACTIVE_LIST_ALL[i]
    			
    			set length = this.length
    			
    			local integer playerIndex = User.PLAYING_HUMANS_COUNT
    			
    			loop
    				exitwhen (playerIndex < ARRAY_MIN)
    				
    				set whichPlayer = User.PLAYING_HUMANS[i]
    				if (this.targetForce.ContainsPlayer(whichPlayer) == false) then
    					set eyeX = eyeXs[whichPlayer]
    					set eyeY = eyeYs[whichPlayer]
    					set eyeZ = eyeZs[whichPlayer]
    				
    					local real camDist = Math.DistanceByDeltasWithZ(this.x - eyeX, this.y - eyeY, this.z - eyeZ) - length * length
    					if (camDist < this.falloff) then
                            
                            
                        	call CAMERA.Shake.Add(User.PLAYING_HUMANS[whichPlayer], (1. - Math.Abs(camDist - length) / this.falloff) * (this.powerMin + (this.powerMax - this.powerMin) * (1 - length / this.falloff)), 5.)
                    	endif
                    endif
    				
    				set playerIndex = playerIndex - 1
    			endloop
    			
    			set i = i - 1
    		endloop
    	endmethod
    	
    	static trigger DUMMY_TRIGGER
    	
    	static method UpdateAll takes nothing returns nothing
    		call TriggerExecute(thistype.DUMMY_TRIGGER)
    	endmethod
    	
    	static method Create takes real x, real y, real z, real powerMax, real powerMin, real falloff, real speed returns nothing
    		local thistype this = thistype.allocate()
			local Timer durationTimer = Timer.Create()
			set this.durationTimer = durationTimer
			set this.falloff = falloff
			set this.length = 0.
			set this.lengthAdd = speed * thistype.UPDATE_TIME
			set this.powerMax = powerMax
			set this.powerMin = powerMin
			set this.targetForce = Force.Create()
    		set this.x = x
    		set this.y = y
    		set this.z = z
    		call durationTimer.SetData(this)
    		call durationTimer.Start(Math.GetMovementDuration(falloff, speed, 0.), false, function thistype.EndingByTimer)
    		
    		if thistype.ACTIVE_LIST_Add(this) then
                call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.UpdateAll)
            endif
    	endmethod
    	
    	static method Init takes nothing returns nothing
    		set thistype.DUMMY_TRIGGER = CreateTrigger()
    		set thistype.SYNC_CACHE = GameCache.Create()
    		set thistype.UPDATE_TIMER = Timer.Create()
			call TriggerAddAction(thistype.DUMMY_TRIGGER, function thistype.UpdateAll_Exec)
    		local integer i = User.PLAYING_HUMANS_COUNT
    		
    		loop
    			exitwhen (i < ARRAY_MIN)
				local User whichPlayer = User.PLAYING_HUMANS[i] 
				set SYNC_X_KEYS[whichPlayer] = "x" + Integer.ToString(whichPlayer)
				set SYNC_Y_KEYS[whichPlayer] = "y" + Integer.ToString(whichPlayer)
				set SYNC_Z_KEYS[whichPlayer] = "z" + Integer.ToString(whichPlayer) 
    			
    			set i = i - 1
    		endloop
    	endmethod
    endstruct
endscope
    globals
        Camera CAMERA = STRUCT_BASE
    endglobals
    struct Camera
        implement Allocation
        implement List
        
    static real BOUNDS_X
    static real BOUNDS_X2
    static real BOUNDS_X3
    static real BOUNDS_X4
    static real BOUNDS_Y
    static real BOUNDS_Y2
    static real BOUNDS_Y3
    static real BOUNDS_Y4
    static integer LOCK_AMOUNT = 0
    camerasetup self
    FolderCamera_StructEye Eye = this
    FolderCamera_StructEye LinkToStruct_Eye
    FolderCamera_StructPanTimedViaBounds PanTimedViaBounds = this
    FolderCamera_StructPanTimedViaBounds LinkToStruct_PanTimedViaBounds
    FolderCamera_StructSeismic Seismic = this
    FolderCamera_StructSeismic LinkToStruct_Seismic
    FolderCamera_StructShake Shake = this
    FolderCamera_StructShake LinkToStruct_Shake
    FolderCamera_StructTarget Target = this
    FolderCamera_StructTarget LinkToStruct_Target
    method Apply takes boolean pan, real duration returns nothing
        call CameraSetupApplyForceDuration(this.self, pan, duration)
    endmethod
    static method Lock takes User whichPlayer returns nothing
        if whichPlayer.IsLocal() then
            set thistype.LOCK_AMOUNT = thistype.LOCK_AMOUNT + 1
            if (thistype.LOCK_AMOUNT == 1) then
                local real x = Target.GetX()
                local real y = Target.GetY()
                call SetCameraBounds(x, y, x, y, x, y, x, y)
            endif
        endif
    endmethod
    static method Unlock takes User whichPlayer returns nothing
        if whichPlayer.IsLocal() then
            set thistype.LOCK_AMOUNT = thistype.LOCK_AMOUNT - 1
            if (thistype.LOCK_AMOUNT == 0) then
                call SetCameraBounds(thistype.BOUNDS_X, thistype.BOUNDS_Y, thistype.BOUNDS_X2, thistype.BOUNDS_Y2, thistype.BOUNDS_X3, thistype.BOUNDS_Y3, thistype.BOUNDS_X4, thistype.BOUNDS_Y4)
            endif
        endif
    endmethod
    static method LockToDummyUnit takes User whichPlayer, DummyUnit whichUnit returns nothing
        if whichPlayer.IsLocal() then
            call SetCameraTargetController(whichUnit.self, 0., 0., false)
        endif
    endmethod
    static method UnlockFromUnit takes User whichPlayer returns nothing
        call thistype.Reset(whichPlayer, 0.)
    endmethod
    static method PanTimed takes User whichPlayer, real x, real y, real duration returns nothing
        if whichPlayer.IsLocal() then
            call PanCameraToTimed(x, y, duration)
        endif
    endmethod
    static method Reset takes User whichPlayer, real duration returns nothing
        if whichPlayer.IsLocal() then
            call ResetToGameCamera(duration)
        endif
    endmethod
	static method UpdateBounds takes User whichPlayer returns nothing
		if whichPlayer.IsLocal() then
			call SetCameraBounds(CAMERA.BOUNDS_X, CAMERA.BOUNDS_Y, CAMERA.BOUNDS_X2, CAMERA.BOUNDS_Y2, CAMERA.BOUNDS_X3, CAMERA.BOUNDS_Y3, CAMERA.BOUNDS_X4, CAMERA.BOUNDS_Y4)
		endif
	endmethod
    static method SetBounds takes User whichPlayer, real x, real y, real x2, real y2, real x3, real y3, real x4, real y4 returns nothing
        if whichPlayer.IsLocal() then
            set thistype.BOUNDS_X = x
            set thistype.BOUNDS_X2 = x2
            set thistype.BOUNDS_X3 = x3
            set thistype.BOUNDS_X4 = x4
            set thistype.BOUNDS_Y = y
            set thistype.BOUNDS_Y2 = y2
            set thistype.BOUNDS_Y3 = y3
            set thistype.BOUNDS_Y4 = y4
            call SetCameraBounds(x, y, x2, y2, x3, y3, x4, y4)
        endif
    endmethod
    static method SetSmoothing takes User whichPlayer, real value returns nothing
        if whichPlayer.IsLocal() then
            call CameraSetSmoothingFactor(value)
        endif
    endmethod
    static method CreateFromSelf takes camerasetup self returns thistype
        local thistype this = thistype.allocate()
        set this.self = self
        return this
    endmethod
    initMethod Init of Header_4
    	call thistype(NULL).PanTimedViaBounds.Init()
    	call thistype(NULL).Seismic.Init()
    	call thistype(NULL).Shake.Init()
    	
        call CameraField.Init()
    endmethod
endstruct
    scope FolderDestructableType
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    public struct StructBoolean
        implement Allocation
        implement List
        
    method Get takes integer key returns boolean
        return DestructableType(this).Data.table.IntegerKeys.GetBoolean(DestructableType(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call DestructableType(this).Data.table.IntegerKeys.RemoveBoolean(DestructableType(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call DestructableType(this).Data.table.IntegerKeys.SetBoolean(DestructableType(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return DestructableType(this).Data.table.IntegerKeys.Table.ContainsInteger(DestructableType(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return DestructableType(this).Data.table.IntegerKeys.Table.CountIntegers(DestructableType(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return DestructableType(this).Data.table.IntegerKeys.Table.IsEmptyInteger(DestructableType(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return DestructableType(this).Data.table.IntegerKeys.Table.GetInteger(DestructableType(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return DestructableType(this).Data.table.IntegerKeys.Table.GetFirstInteger(DestructableType(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return DestructableType(this).Data.table.IntegerKeys.Table.GetLastInteger(DestructableType(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call DestructableType(this).Data.table.IntegerKeys.Table.Clear(DestructableType(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return DestructableType(this).Data.table.IntegerKeys.Table.FetchFirstInteger(DestructableType(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return DestructableType(this).Data.table.IntegerKeys.Table.RemoveInteger(DestructableType(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return DestructableType(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(DestructableType(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return DestructableType(this).Data.table.IntegerKeys.Table.AddInteger(DestructableType(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return DestructableType(this).Data.table.IntegerKeys.Table.AddIntegerMulti(DestructableType(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call DestructableType(this).Data.table.IntegerKeys.Table.JoinInteger(DestructableType(this).Id.Get(), key, DestructableType(other).Data.table, DestructableType(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return DestructableType(this).Data.table.IntegerKeys.Table.RandomInteger(DestructableType(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call DestructableType(this).Data.table.IntegerKeys.Table.ShuffleIntegers(DestructableType(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call DestructableType(this).Data.table.IntegerKeys.Table.PrintIntegers(DestructableType(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return DestructableType(this).Data.table.IntegerKeys.GetInteger(DestructableType(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call DestructableType(this).Data.table.IntegerKeys.RemoveInteger(DestructableType(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call DestructableType(this).Data.table.IntegerKeys.SetInteger(DestructableType(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderReal
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, real value returns boolean
        return DestructableType(this).Data.table.IntegerKeys.Table.ContainsReal(DestructableType(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return DestructableType(this).Data.table.IntegerKeys.Table.CountReals(DestructableType(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return DestructableType(this).Data.table.IntegerKeys.Table.IsEmptyReal(DestructableType(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns real
        return DestructableType(this).Data.table.IntegerKeys.Table.GetReal(DestructableType(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns real
        return DestructableType(this).Data.table.IntegerKeys.Table.GetFirstReal(DestructableType(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns real
        return DestructableType(this).Data.table.IntegerKeys.Table.GetLastReal(DestructableType(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call DestructableType(this).Data.table.IntegerKeys.Table.Clear(DestructableType(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns real
        return DestructableType(this).Data.table.IntegerKeys.Table.FetchFirstReal(DestructableType(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, real value returns boolean
        return DestructableType(this).Data.table.IntegerKeys.Table.RemoveReal(DestructableType(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return DestructableType(this).Data.table.IntegerKeys.Table.RemoveRealByIndex(DestructableType(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, real value returns boolean
        return DestructableType(this).Data.table.IntegerKeys.Table.AddReal(DestructableType(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, real value returns boolean
        return DestructableType(this).Data.table.IntegerKeys.Table.AddRealMulti(DestructableType(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call DestructableType(this).Data.table.IntegerKeys.Table.JoinReal(DestructableType(this).Id.Get(), key, DestructableType(other).Data.table, DestructableType(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns real
        return DestructableType(this).Data.table.IntegerKeys.Table.RandomReal(DestructableType(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns real
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call DestructableType(this).Data.table.IntegerKeys.Table.ShuffleIntegers(DestructableType(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call DestructableType(this).Data.table.IntegerKeys.Table.PrintReals(DestructableType(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructReal
        implement Allocation
        implement List
        
    FolderReal_StructTable Table = this
    FolderReal_StructTable LinkToStruct_Table
    method Get takes integer key returns real
        return DestructableType(this).Data.table.IntegerKeys.GetReal(DestructableType(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Real.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call DestructableType(this).Data.table.IntegerKeys.RemoveReal(DestructableType(this).Id.Get(), key)
    endmethod
    method Set takes integer key, real value returns nothing
        call DestructableType(this).Data.table.IntegerKeys.SetReal(DestructableType(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
    FolderData_StructReal Real = this
    FolderData_StructReal LinkToStruct_Real
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(DestructableType(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject DestructableType.Allocation.deallocate_demount.hook
		call DestructableType(this).Data.Destroy()
	endinject
	inject DestructableType.Allocation.allocate_mount.hook
		call DestructableType(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructEvent
        implement Allocation
        implement List
        
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(DestructableType(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(DestructableType(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(DestructableType(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(DestructableType(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(DestructableType(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(DestructableType(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(DestructableType(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(DestructableType(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject DestructableType.Allocation.deallocate_demount.hook
			call DestructableType(this).Event.Destroy()
		endinject
		inject DestructableType.Allocation.allocate_mount.hook
			call DestructableType(this).Event.Event_Create()
		endinject
    endstruct
    public struct StructPreload
        implement Allocation
        implement List
        
        method Event_Create takes nothing returns nothing
            call RemoveDestructable(CreateDestructable(DestructableType(this).self, 0., 0., 0., 0., 0))
        endmethod
    endstruct
endscope
    globals
        DestructableType DESTRUCTABLE_TYPE = STRUCT_BASE
    endglobals
    struct DestructableType
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    string name
    integer self
    FolderDestructableType_StructData Data = this
    FolderDestructableType_StructData LinkToStruct_Data
    FolderDestructableType_StructEvent Event = this
    FolderDestructableType_StructEvent LinkToStruct_Event
    FolderDestructableType_StructId Id = this
    FolderDestructableType_StructId LinkToStruct_Id
    FolderDestructableType_StructPreload Preload = this
    FolderDestructableType_StructPreload LinkToStruct_Preload
    static method GetFromSelf takes integer self returns thistype
        return Memory.IntegerKeys.GetInteger(self, KEY)
    endmethod
    static method GetFromName takes string name returns thistype
        return StringData.Data.Integer.Get(name, KEY)
    endmethod
    method GetName takes nothing returns string
        return this.name
    endmethod
    method Name_Event_Create takes nothing returns nothing
        local destructable dummyDestructable = CreateDestructable(this.self, 0., 0., 0., 0., 0)
        set this.name = GetDestructableName(dummyDestructable)
        call RemoveDestructable(dummyDestructable)
        set dummyDestructable = null
    endmethod
    method GetSelf takes nothing returns integer
        return this.self
    endmethod
    static key GetKeyMacro_INIT_KEY_ARRAY
    static constant integer INIT_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_INIT_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static method AddInit takes code c, string name returns nothing
        call Trigger.AddObjectInit(INIT_KEY_ARRAY, c, name)
    endmethod
    static method Create takes integer self returns thistype
        local thistype this = thistype.allocate()
        set this.self = self
        call Memory.IntegerKeys.SetInteger(self, KEY, this)
        call this.Name_Event_Create()
        call this.Id.Event_Create()
        call this.Preload.Event_Create()
		call StringData.Data.Integer.Set(this.GetName(), KEY, this)
        return this
    endmethod
    static method Init takes nothing returns nothing
    endmethod
endstruct
    scope FolderDestructable
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    public struct StructBoolean
        implement Allocation
        implement List
        
    method Get takes integer key returns boolean
        return Destructable(this).Data.table.IntegerKeys.GetBoolean(Destructable(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Destructable(this).Data.table.IntegerKeys.RemoveBoolean(Destructable(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call Destructable(this).Data.table.IntegerKeys.SetBoolean(Destructable(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return Destructable(this).Data.table.IntegerKeys.Table.ContainsInteger(Destructable(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Destructable(this).Data.table.IntegerKeys.Table.CountIntegers(Destructable(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Destructable(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Destructable(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Destructable(this).Data.table.IntegerKeys.Table.GetInteger(Destructable(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Destructable(this).Data.table.IntegerKeys.Table.GetFirstInteger(Destructable(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Destructable(this).Data.table.IntegerKeys.Table.GetLastInteger(Destructable(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Destructable(this).Data.table.IntegerKeys.Table.Clear(Destructable(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Destructable(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Destructable(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Destructable(this).Data.table.IntegerKeys.Table.RemoveInteger(Destructable(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Destructable(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Destructable(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Destructable(this).Data.table.IntegerKeys.Table.AddInteger(Destructable(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Destructable(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Destructable(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Destructable(this).Data.table.IntegerKeys.Table.JoinInteger(Destructable(this).Id.Get(), key, Destructable(other).Data.table, Destructable(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Destructable(this).Data.table.IntegerKeys.Table.RandomInteger(Destructable(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Destructable(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Destructable(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Destructable(this).Data.table.IntegerKeys.Table.PrintIntegers(Destructable(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return Destructable(this).Data.table.IntegerKeys.GetInteger(Destructable(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Destructable(this).Data.table.IntegerKeys.RemoveInteger(Destructable(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Destructable(this).Data.table.IntegerKeys.SetInteger(Destructable(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderReal
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, real value returns boolean
        return Destructable(this).Data.table.IntegerKeys.Table.ContainsReal(Destructable(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Destructable(this).Data.table.IntegerKeys.Table.CountReals(Destructable(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Destructable(this).Data.table.IntegerKeys.Table.IsEmptyReal(Destructable(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns real
        return Destructable(this).Data.table.IntegerKeys.Table.GetReal(Destructable(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns real
        return Destructable(this).Data.table.IntegerKeys.Table.GetFirstReal(Destructable(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns real
        return Destructable(this).Data.table.IntegerKeys.Table.GetLastReal(Destructable(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Destructable(this).Data.table.IntegerKeys.Table.Clear(Destructable(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns real
        return Destructable(this).Data.table.IntegerKeys.Table.FetchFirstReal(Destructable(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, real value returns boolean
        return Destructable(this).Data.table.IntegerKeys.Table.RemoveReal(Destructable(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Destructable(this).Data.table.IntegerKeys.Table.RemoveRealByIndex(Destructable(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, real value returns boolean
        return Destructable(this).Data.table.IntegerKeys.Table.AddReal(Destructable(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, real value returns boolean
        return Destructable(this).Data.table.IntegerKeys.Table.AddRealMulti(Destructable(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Destructable(this).Data.table.IntegerKeys.Table.JoinReal(Destructable(this).Id.Get(), key, Destructable(other).Data.table, Destructable(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns real
        return Destructable(this).Data.table.IntegerKeys.Table.RandomReal(Destructable(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns real
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Destructable(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Destructable(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Destructable(this).Data.table.IntegerKeys.Table.PrintReals(Destructable(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructReal
        implement Allocation
        implement List
        
    FolderReal_StructTable Table = this
    FolderReal_StructTable LinkToStruct_Table
    method Get takes integer key returns real
        return Destructable(this).Data.table.IntegerKeys.GetReal(Destructable(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Real.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Destructable(this).Data.table.IntegerKeys.RemoveReal(Destructable(this).Id.Get(), key)
    endmethod
    method Set takes integer key, real value returns nothing
        call Destructable(this).Data.table.IntegerKeys.SetReal(Destructable(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
    FolderData_StructReal Real = this
    FolderData_StructReal LinkToStruct_Real
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Destructable(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Destructable.Allocation.deallocate_demount.hook
		call Destructable(this).Data.Destroy()
	endinject
	inject Destructable.Allocation.allocate_mount.hook
		call Destructable(this).Data.Event_Create()
	endinject
    endstruct
    scope FolderEvent
    public struct StructNative
        implement Allocation
        implement List
        
                static method GetDying takes nothing returns Destructable
                    return Destructable.GetFromSelf(GetDyingDestructable())
                endmethod
                static method GetFilter takes nothing returns Destructable
                    return Destructable.GetFromSelf(GetFilterDestructable())
                endmethod
                static method GetEnum takes nothing returns Destructable
                    return Destructable.GetFromSelf(GetEnumDestructable())
                endmethod
        endstruct
    endscope
    public struct StructEvent
        implement Allocation
        implement List
        
    FolderEvent_StructNative Native = this
    FolderEvent_StructNative LinkToStruct_Native
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(Destructable(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(Destructable(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(Destructable(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(Destructable(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(Destructable(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(Destructable(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(Destructable(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(Destructable(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject Destructable.Allocation.deallocate_demount.hook
			call Destructable(this).Event.Destroy()
		endinject
		inject Destructable.Allocation.allocate_mount.hook
			call Destructable(this).Event.Event_Create()
		endinject
    endstruct
    public struct StructType
        implement Allocation
        implement List
        
    DestructableType value
    method Get takes nothing returns DestructableType
        return this.value
    endmethod
    method Set takes DestructableType value returns nothing
        set this.value = value
    endmethod
    method Add takes DestructableType value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(DestructableType.GetFromSelf(GetDestructableTypeId(Destructable(this).self)))
    endmethod
    method Subtract takes DestructableType value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    public struct StructTimedLife
        implement Allocation
        implement List
        
        static Event DEATH_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
        Timer durationTimer
        Destructable parent
        method Ending takes Timer durationTimer, Destructable parent returns nothing
            call this.deallocate()
            call durationTimer.Destroy()
            call parent.Data.Integer.Remove(KEY)
            call parent.Event.Remove(DEATH_EVENT)
        endmethod
        timerMethod EndingByTimer
            local Timer durationTimer = Timer.GetExpired()
            local thistype this = durationTimer.GetData()
            call this.Ending(durationTimer, this.parent)
            call parent.Kill()
        endmethod
        eventMethod Event_Death
            local Destructable parent = params.Destructable.GetTrigger()
            local thistype this = parent.Data.Integer.Get(KEY)
            call this.Ending(this.durationTimer, parent)
        endmethod
        method Start takes real duration returns nothing
            local Destructable parent = this
            set this = thistype.allocate()
			local Timer durationTimer = Timer.Create()
            set this.durationTimer = durationTimer
            set this.parent = parent
            call durationTimer.SetData(this)
            call parent.Data.Integer.Set(KEY, this)
            call parent.Event.Add(DEATH_EVENT)
            call durationTimer.Start(duration, false, function thistype.EndingByTimer)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DEATH_EVENT = Event.Create(Destructable.DEATH_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Death)
        endmethod
    endstruct
    scope FolderEnum
    public struct StructInRange
        implement Allocation
        implement List
        
            static Rectangle DUMMY_RECT
            static BoolExpr TARGET_FILTER
            static method Conditions takes nothing returns boolean
                local Destructable filterDestructable = DESTRUCTABLE.Event.Native.GetFilter()
                if (Math.DistanceSquareByDeltas(filterDestructable.x - TEMP_REAL, filterDestructable.y - TEMP_REAL2) > TEMP_REAL3) then
                    return false
                endif
                return true
            endmethod
            static method Do takes real x, real y, real areaRange, code action returns nothing
                call thistype.DUMMY_RECT.Set(x - areaRange, y - areaRange, x + areaRange, y + areaRange)
                set TEMP_REAL = x
                set TEMP_REAL2 = y
                set TEMP_REAL3 = areaRange * areaRange
                call EnumDestructablesInRect(thistype.DUMMY_RECT.self, thistype.TARGET_FILTER.self, action)
            endmethod
            static method Init takes nothing returns nothing
                set thistype.DUMMY_RECT = Rectangle.Create(0., 0., 0., 0.)
                set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
            endmethod
        endstruct
    endscope
    public struct StructEnum
        implement Allocation
        implement List
        
    FolderEnum_StructInRange InRange = this
    FolderEnum_StructInRange LinkToStruct_InRange
        static method Init takes nothing returns nothing
            call thistype(NULL).InRange.Init()
        endmethod
    endstruct
    public struct StructLife
        implement Allocation
        implement List
        
        real value
        method Get takes nothing returns real
            return GetDestructableLife(Destructable(this).self)
        endmethod
        method Set takes real value returns nothing
            call SetDestructableLife(Destructable(this).self, value)
        endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
endscope
    globals
        Destructable DESTRUCTABLE = STRUCT_BASE
    endglobals
    struct Destructable
        implement Allocation
        implement List
        
    static EventType CREATE_EVENT_TYPE
    static EventType DEATH_EVENT_TYPE
    static Trigger DEATH_TRIGGER
    static EventType DESTROY_EVENT_TYPE
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    destructable self
    real x
    real y
    real z
    FolderDestructable_StructData Data = this
    FolderDestructable_StructData LinkToStruct_Data
    FolderDestructable_StructEnum Enum = this
    FolderDestructable_StructEnum LinkToStruct_Enum
    FolderDestructable_StructEvent Event = this
    FolderDestructable_StructEvent LinkToStruct_Event
    FolderDestructable_StructId Id = this
    FolderDestructable_StructId LinkToStruct_Id
    FolderDestructable_StructLife Life = this
    FolderDestructable_StructLife LinkToStruct_Life
    FolderDestructable_StructTimedLife TimedLife = this
    FolderDestructable_StructTimedLife LinkToStruct_TimedLife
    FolderDestructable_StructType Type = this
    FolderDestructable_StructType LinkToStruct_Type
    static method GetFromSelf takes destructable self returns thistype
        return Memory.IntegerKeys.GetIntegerByHandle(self, KEY)
    endmethod
    method GetName takes nothing returns string
        return GetDestructableName(this.self)
    endmethod
    method GetSelf takes nothing returns destructable
        return this.self
    endmethod
    method GetX takes nothing returns real
        return this.x
    endmethod
    method GetY takes nothing returns real
        return this.y
    endmethod
    method GetZ takes nothing returns real
        return this.z
    endmethod
    method Destroy_TriggerEvents takes nothing returns nothing
        local EventResponse params = EventResponse.Create(this.Id.Get())
        call params.Destructable.SetTrigger(this)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = this.Event.Count(thistype.DESTROY_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.DESTROY_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    method Destroy takes nothing returns nothing
        local destructable self = this.self
        call this.Destroy_TriggerEvents()
        call this.deallocate()
        call RemoveDestructable(self)
        set self = null
    endmethod
    method ApplyTimedLife takes real duration returns nothing
        call this.TimedLife.Start(duration)
    endmethod
    method Death_TriggerEvents takes nothing returns nothing
        local EventResponse params = EventResponse.Create(this.Id.Get())
        call params.Destructable.SetTrigger(this)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = this.Event.Count(thistype.DEATH_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.DEATH_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    trigMethod Death_Trig
        call thistype(NULL).Event.Native.GetDying().Death_TriggerEvents()
    endmethod
    method Kill takes nothing returns nothing
        call KillDestructable(this.self)
    endmethod
    method Create_TriggerEvents takes nothing returns nothing
        local DestructableType thisType = this.Type.Get()
        local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
        call params.Destructable.SetTrigger(this)
        call params.DestructableType.SetTrigger(thisType)
		local EventResponse typeParams = EventResponse.Create(thisType.Id.Get())
        call typeParams.Destructable.SetTrigger(this)
        call typeParams.DestructableType.SetTrigger(thisType)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = Event.CountAtStatics(thistype.CREATE_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call Event.GetFromStatics(thistype.CREATE_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration2 = thisType.Event.Count(thistype.CREATE_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call thisType.Event.Get(thistype.CREATE_EVENT_TYPE, priority, iteration2).Run(typeParams)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
        call typeParams.Destroy()
    endmethod
    static method CreateFromSelf takes destructable self returns thistype
        local thistype this = thistype.allocate()
        set this.self = self
        set this.x = GetDestructableX(self)
        set this.y = GetDestructableY(self)
        set this.z = 0.
        call Memory.IntegerKeys.SetIntegerByHandle(self, KEY, this)
        call this.Id.Event_Create()
        call this.Type.Event_Create()
        call thistype.DEATH_TRIGGER.RegisterEvent.DestructableDeath(this)
        call this.Create_TriggerEvents()
        return this
    endmethod
    static method Create takes DestructableType whichType, real x, real y, real z, real angle, real scale, integer variation returns thistype
        local thistype this = thistype.allocate()
		local destructable self = CreateDestructableZ(whichType.self, x, y, z, angle * Math.RAD_TO_DEG, scale, variation)
        set this.self = self
        set this.x = x
        set this.y = y
        set this.z = z
        call Memory.IntegerKeys.SetIntegerByHandle(self, KEY, this)
        set self = null
        call this.Id.Event_Create()
        call this.Type.Event_Create()
        call thistype.DEATH_TRIGGER.RegisterEvent.DestructableDeath(this)
        call this.Create_TriggerEvents()
        return this
    endmethod
    enumMethod Start_Enum
        local destructable enumDestructableSelf = GetEnumDestructable()
        if (thistype.GetFromSelf(enumDestructableSelf) == NULL) then
            call thistype.CreateFromSelf(enumDestructableSelf)
        endif
        set enumDestructableSelf = null
    endmethod
    eventMethod Event_Start
        call EnumDestructablesInRect(Rectangle.WORLD.self, null, function thistype.Start_Enum)
    endmethod
    initMethod Init of Header_5
        set thistype.CREATE_EVENT_TYPE = EventType.Create()
        set thistype.DEATH_EVENT_TYPE = EventType.Create()
        set thistype.DESTROY_EVENT_TYPE = EventType.Create()
        set thistype.DEATH_TRIGGER = Trigger.CreateFromCode(function thistype.Death_Trig)
        call Event.Create(EventType.START, EventPriority.HEADER, function thistype.Event_Start).AddToStatics()
        call thistype(NULL).Enum.Init()
        call thistype(NULL).TimedLife.Init()
        call DestructableType.Init()
    endmethod
endstruct
    scope FolderDialogButton
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return DialogButton(this).Data.table.IntegerKeys.Table.ContainsInteger(DialogButton(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return DialogButton(this).Data.table.IntegerKeys.Table.CountIntegers(DialogButton(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return DialogButton(this).Data.table.IntegerKeys.Table.IsEmptyInteger(DialogButton(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return DialogButton(this).Data.table.IntegerKeys.Table.GetInteger(DialogButton(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return DialogButton(this).Data.table.IntegerKeys.Table.GetFirstInteger(DialogButton(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return DialogButton(this).Data.table.IntegerKeys.Table.GetLastInteger(DialogButton(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call DialogButton(this).Data.table.IntegerKeys.Table.Clear(DialogButton(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return DialogButton(this).Data.table.IntegerKeys.Table.FetchFirstInteger(DialogButton(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return DialogButton(this).Data.table.IntegerKeys.Table.RemoveInteger(DialogButton(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return DialogButton(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(DialogButton(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return DialogButton(this).Data.table.IntegerKeys.Table.AddInteger(DialogButton(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return DialogButton(this).Data.table.IntegerKeys.Table.AddIntegerMulti(DialogButton(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call DialogButton(this).Data.table.IntegerKeys.Table.JoinInteger(DialogButton(this).Id.Get(), key, DialogButton(other).Data.table, DialogButton(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return DialogButton(this).Data.table.IntegerKeys.Table.RandomInteger(DialogButton(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call DialogButton(this).Data.table.IntegerKeys.Table.ShuffleIntegers(DialogButton(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call DialogButton(this).Data.table.IntegerKeys.Table.PrintIntegers(DialogButton(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructBoolean
        implement Allocation
        implement List
        
    method Get takes integer key returns boolean
        return DialogButton(this).Data.table.IntegerKeys.GetBoolean(DialogButton(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call DialogButton(this).Data.table.IntegerKeys.RemoveBoolean(DialogButton(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call DialogButton(this).Data.table.IntegerKeys.SetBoolean(DialogButton(this).Id.Get(), key, value)
    endmethod
        endstruct
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return DialogButton(this).Data.table.IntegerKeys.GetInteger(DialogButton(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call DialogButton(this).Data.table.IntegerKeys.RemoveInteger(DialogButton(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call DialogButton(this).Data.table.IntegerKeys.SetInteger(DialogButton(this).Id.Get(), key, value)
    endmethod
        endstruct
    public struct StructReal
        implement Allocation
        implement List
        
    method Get takes integer key returns real
        return DialogButton(this).Data.table.IntegerKeys.GetReal(DialogButton(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Real.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call DialogButton(this).Data.table.IntegerKeys.RemoveReal(DialogButton(this).Id.Get(), key)
    endmethod
    method Set takes integer key, real value returns nothing
        call DialogButton(this).Data.table.IntegerKeys.SetReal(DialogButton(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
    FolderData_StructReal Real = this
    FolderData_StructReal LinkToStruct_Real
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(DialogButton(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject DialogButton.Allocation.deallocate_demount.hook
		call DialogButton(this).Data.Destroy()
	endinject
	inject DialogButton.Allocation.allocate_mount.hook
		call DialogButton(this).Data.Event_Create()
	endinject
    endstruct
    scope FolderEvent
    public struct StructNative
        implement Allocation
        implement List
        
            static method GetClicked takes nothing returns DialogButton
                return Memory.IntegerKeys.GetIntegerByHandle(GetClickedButton(), Dialog(NULL).Buttons.KEY)
            endmethod
        endstruct
    endscope
    public struct StructEvent
        implement Allocation
        implement List
        
    FolderEvent_StructNative Native = this
    FolderEvent_StructNative LinkToStruct_Native
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(DialogButton(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(DialogButton(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(DialogButton(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(DialogButton(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(DialogButton(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(DialogButton(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(DialogButton(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(DialogButton(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject DialogButton.Allocation.deallocate_demount.hook
			call DialogButton(this).Event.Destroy()
		endinject
		inject DialogButton.Allocation.allocate_mount.hook
			call DialogButton(this).Event.Event_Create()
		endinject
    endstruct
endscope
    globals
        DialogButton DIALOG_BUTTON = STRUCT_BASE
    endglobals
    struct DialogButton
        implement Allocation
        implement List
        
    integer hotkey
    method GetHotkey takes nothing returns integer
        return this.hotkey
    endmethod
    method SetHotkey takes integer value returns nothing
        set this.hotkey = value
    endmethod
    string text
    method GetText takes nothing returns string
        return this.text
    endmethod
    method SetText takes string value returns nothing
        set this.text = value
    endmethod
    FolderDialogButton_StructData Data = this
    FolderDialogButton_StructData LinkToStruct_Data
    FolderDialogButton_StructEvent Event = this
    FolderDialogButton_StructEvent LinkToStruct_Event
    FolderDialogButton_StructId Id = this
    FolderDialogButton_StructId LinkToStruct_Id
    method Destroy takes nothing returns nothing
        call this.deallocate()
        call Dialog(NULL).Buttons.Event_ButtonDestroy(this)
    endmethod
    static method Create takes string text, integer hotkey returns thistype
        local thistype this = thistype.allocate()
        call this.Id.Event_Create()
        call this.SetHotkey(hotkey)
        call this.SetText(text)
        return this
    endmethod
    static method Init takes nothing returns nothing
    endmethod
endstruct
    scope FolderDialog
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return Dialog(this).Data.table.IntegerKeys.Table.ContainsInteger(Dialog(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Dialog(this).Data.table.IntegerKeys.Table.CountIntegers(Dialog(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Dialog(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Dialog(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Dialog(this).Data.table.IntegerKeys.Table.GetInteger(Dialog(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Dialog(this).Data.table.IntegerKeys.Table.GetFirstInteger(Dialog(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Dialog(this).Data.table.IntegerKeys.Table.GetLastInteger(Dialog(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Dialog(this).Data.table.IntegerKeys.Table.Clear(Dialog(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Dialog(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Dialog(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Dialog(this).Data.table.IntegerKeys.Table.RemoveInteger(Dialog(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Dialog(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Dialog(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Dialog(this).Data.table.IntegerKeys.Table.AddInteger(Dialog(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Dialog(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Dialog(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Dialog(this).Data.table.IntegerKeys.Table.JoinInteger(Dialog(this).Id.Get(), key, Dialog(other).Data.table, Dialog(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Dialog(this).Data.table.IntegerKeys.Table.RandomInteger(Dialog(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Dialog(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Dialog(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Dialog(this).Data.table.IntegerKeys.Table.PrintIntegers(Dialog(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructBoolean
        implement Allocation
        implement List
        
    method Get takes integer key returns boolean
        return Dialog(this).Data.table.IntegerKeys.GetBoolean(Dialog(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Dialog(this).Data.table.IntegerKeys.RemoveBoolean(Dialog(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call Dialog(this).Data.table.IntegerKeys.SetBoolean(Dialog(this).Id.Get(), key, value)
    endmethod
        endstruct
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return Dialog(this).Data.table.IntegerKeys.GetInteger(Dialog(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Dialog(this).Data.table.IntegerKeys.RemoveInteger(Dialog(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Dialog(this).Data.table.IntegerKeys.SetInteger(Dialog(this).Id.Get(), key, value)
    endmethod
        endstruct
    public struct StructReal
        implement Allocation
        implement List
        
    method Get takes integer key returns real
        return Dialog(this).Data.table.IntegerKeys.GetReal(Dialog(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Real.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Dialog(this).Data.table.IntegerKeys.RemoveReal(Dialog(this).Id.Get(), key)
    endmethod
    method Set takes integer key, real value returns nothing
        call Dialog(this).Data.table.IntegerKeys.SetReal(Dialog(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
    FolderData_StructReal Real = this
    FolderData_StructReal LinkToStruct_Real
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Dialog(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Dialog.Allocation.deallocate_demount.hook
		call Dialog(this).Data.Destroy()
	endinject
	inject Dialog.Allocation.allocate_mount.hook
		call Dialog(this).Data.Event_Create()
	endinject
    endstruct
    scope FolderEvent
    public struct StructNative
        implement Allocation
        implement List
        
            static method GetClicked takes nothing returns Dialog
                return Dialog.GetFromSelf(GetClickedDialog())
            endmethod
        endstruct
    endscope
    public struct StructEvent
        implement Allocation
        implement List
        
    FolderEvent_StructNative Native = this
    FolderEvent_StructNative LinkToStruct_Native
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(Dialog(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(Dialog(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(Dialog(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(Dialog(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(Dialog(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(Dialog(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(Dialog(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(Dialog(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject Dialog.Allocation.deallocate_demount.hook
			call Dialog(this).Event.Destroy()
		endinject
		inject Dialog.Allocation.allocate_mount.hook
			call Dialog(this).Event.Event_Create()
		endinject
    endstruct
    public struct StructButtons
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_PARENT_KEY_ARRAY
    static constant integer PARENT_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_PARENT_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        method GetFromSelf takes button self returns DialogButton
            return Memory.IntegerKeys.GetIntegerByHandle(self, KEY)
        endmethod
        method ClearNatives takes nothing returns nothing
            local DialogButton but
            local button butSelf
            local integer iteration = Dialog(this).Data.Integer.Table.Count(KEY_ARRAY)
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                set but = Dialog(this).Data.Integer.Table.Get(KEY_ARRAY, iteration)
                set butSelf = Memory.Native.GetButton(PARENT_KEY_ARRAY + this, KEY_ARRAY_DETAIL + but)
                call Memory.IntegerKeys.RemoveIntegerByHandle(butSelf, KEY)
                call Memory.Native.RemoveButton(PARENT_KEY_ARRAY + this, KEY_ARRAY_DETAIL + but)
                set iteration = iteration - 1
            endloop
            set butSelf = null
            call DialogClear(Dialog(this).self)
        endmethod
        method Clear takes nothing returns nothing
            call this.ClearNatives()
            call Dialog(this).Data.Integer.Table.Clear(KEY_ARRAY)
        endmethod
        method AddNative takes DialogButton but returns nothing
            local button butSelf = DialogAddButton(Dialog(this).self, but.text, but.hotkey)
            call Memory.IntegerKeys.SetIntegerByHandle(butSelf, KEY, but)
            call Memory.Native.SetButton(PARENT_KEY_ARRAY + this, KEY_ARRAY_DETAIL + but, butSelf)
            set butSelf = null
        endmethod
        method AddNatives takes nothing returns nothing
            local integer count = Dialog(this).Data.Integer.Table.Count(KEY_ARRAY)
            local integer iteration = Memory.IntegerKeys.Table.STARTED
            loop
                exitwhen (iteration > count)
                call this.AddNative(Dialog(this).Data.Integer.Table.Get(KEY_ARRAY, iteration))
                set iteration = iteration + 1
            endloop
        endmethod
        method UpdateNatives takes nothing returns nothing
            call this.ClearNatives()
            call this.AddNatives()
        endmethod
        method Remove takes DialogButton val returns nothing
            local DialogButton but
            local integer iteration
            call this.ClearNatives()
            call Dialog(this).Data.Integer.Table.Remove(KEY_ARRAY, val)
            call val.Data.Integer.Table.Remove(KEY_ARRAY, this)
            call this.AddNatives()
        endmethod
        static method Event_ButtonDestroy takes DialogButton val returns nothing
            local integer iteration = val.Data.Integer.Table.Count(KEY_ARRAY)
            local Dialog parent
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                set parent = val.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                call thistype(parent).Remove(val)
                set iteration = iteration - 1
            endloop
        endmethod
        method Destroy takes DialogButton val returns nothing
            call this.Remove(val)
            call val.Destroy()
        endmethod
        method Add takes DialogButton val returns nothing
            call Dialog(this).Data.Integer.Table.Add(KEY_ARRAY, val)
            call val.Data.Integer.Table.Add(KEY_ARRAY, this)
            call this.AddNative(val)
        endmethod
        method Create takes string text, integer hotkey returns DialogButton
            local DialogButton result = DialogButton.Create(text, hotkey)
            call this.Add(result)
            return result
        endmethod
    endstruct
endscope
    globals
        Dialog DIALOG = STRUCT_BASE
    endglobals
    struct Dialog
        implement Allocation
        implement List
        
    static EventType CLICK_EVENT_TYPE
    static Trigger CLICK_TRIGGER
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_PLAYER_CUR_SHOWN_KEY
    static constant integer PLAYER_CUR_SHOWN_KEY = Math.Integer.MIN + GetKeyMacro_PLAYER_CUR_SHOWN_KEY
    static key GetKeyMacro_PLAYER_CUR_SHOWN_KEY_ARRAY
    static constant integer PLAYER_CUR_SHOWN_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_PLAYER_CUR_SHOWN_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_PLAYER_SHOWN_KEY
    static constant integer PLAYER_SHOWN_KEY = Math.Integer.MIN + GetKeyMacro_PLAYER_SHOWN_KEY
    static key GetKeyMacro_PLAYER_SHOWN_KEY_ARRAY
    static constant integer PLAYER_SHOWN_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_PLAYER_SHOWN_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    dialog self
    boolean shown
    method IsShown takes nothing returns boolean
        return this.shown
    endmethod
    method SetShown takes boolean value returns nothing
        set this.shown = value
    endmethod
    FolderDialog_StructButtons Buttons = this
    FolderDialog_StructButtons LinkToStruct_Buttons
    FolderDialog_StructData Data = this
    FolderDialog_StructData LinkToStruct_Data
    FolderDialog_StructEvent Event = this
    FolderDialog_StructEvent LinkToStruct_Event
    FolderDialog_StructId Id = this
    FolderDialog_StructId LinkToStruct_Id
    static method GetFromSelf takes dialog self returns thistype
        return Memory.IntegerKeys.GetIntegerByHandle(self, KEY)
    endmethod
    static method GetFromPlayer takes User whichPlayer returns thistype
        return whichPlayer.Data.Integer.Get(PLAYER_CUR_SHOWN_KEY)
    endmethod
    method GetSelf takes nothing returns dialog
        return this.self
    endmethod
    method Destroy takes nothing returns nothing
        local dialog self = this.self
        call this.deallocate()
        call DialogDestroy(self)
        set self = null
    endmethod
    method Show takes User whichPlayer returns nothing
        local boolean isFirst
        local integer iteration
        if (whichPlayer == User.ANY) then
            set iteration = User.PLAYING_HUMANS_COUNT
            loop
                call this.Show(User.PLAYING_HUMANS[iteration])
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
            return
        endif
        set isFirst = whichPlayer.Data.Integer.Table.IsEmpty(PLAYER_SHOWN_KEY_ARRAY)
        if ((isFirst == false) and whichPlayer.Data.Integer.Table.Contains(PLAYER_SHOWN_KEY_ARRAY, this)) then
            return
        endif
        call this.Data.Integer.Table.Add(PLAYER_SHOWN_KEY_ARRAY, whichPlayer)
        call whichPlayer.Data.Integer.Table.Add(PLAYER_SHOWN_KEY_ARRAY, this)
        if isFirst then
            call this.Data.Integer.Table.Add(PLAYER_CUR_SHOWN_KEY_ARRAY, whichPlayer)
            call whichPlayer.Data.Integer.Set(PLAYER_CUR_SHOWN_KEY, this)
            call DialogDisplay(whichPlayer.self, this.self, true)
        endif
    endmethod
    method Hide takes User whichPlayer returns nothing
        local boolean hasNext
        local integer iteration
        if (whichPlayer == User.ANY) then
            set iteration = User.PLAYING_HUMANS_COUNT
            loop
                call this.Hide(User.PLAYING_HUMANS[iteration])
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
            return
        endif
        if (whichPlayer.Data.Integer.Table.Contains(PLAYER_SHOWN_KEY_ARRAY, this) == false) then
            return
        endif
        call this.Data.Integer.Table.Remove(PLAYER_SHOWN_KEY_ARRAY, whichPlayer)
        call whichPlayer.Data.Integer.Table.Remove(PLAYER_SHOWN_KEY_ARRAY, this)
        if (thistype.GetFromPlayer(whichPlayer) == this) then
            call this.Data.Integer.Table.Remove(PLAYER_CUR_SHOWN_KEY_ARRAY, whichPlayer)
            if whichPlayer.Data.Integer.Table.IsEmpty(PLAYER_SHOWN_KEY_ARRAY) then
                call whichPlayer.Data.Integer.Remove(PLAYER_CUR_SHOWN_KEY)
                call DialogDisplay(whichPlayer.self, this.self, false)
                call MULTIBOARD.Shown.Update(whichPlayer)
            else
                set this = whichPlayer.Data.Integer.Table.GetFirst(PLAYER_SHOWN_KEY_ARRAY)
                call this.Data.Integer.Table.Add(PLAYER_CUR_SHOWN_KEY_ARRAY, whichPlayer)
                call whichPlayer.Data.Integer.Set(PLAYER_CUR_SHOWN_KEY, this)
                call DialogDisplay(whichPlayer.self, this.self, true)
            endif
        endif
    endmethod
    method Display takes User whichPlayer, boolean flag returns nothing
        if flag then
            call this.Show(whichPlayer)
        else
            call this.Hide(whichPlayer)
        endif
    endmethod
    method UpdateDisplay takes nothing returns nothing
        local integer iteration = this.Data.Integer.Table.Count(PLAYER_CUR_SHOWN_KEY_ARRAY)
        local User whichPlayer
        loop
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            set whichPlayer = this.Data.Integer.Table.Get(PLAYER_CUR_SHOWN_KEY_ARRAY, iteration)
            call DialogDisplay(whichPlayer.self, this.self, true)
            set iteration = iteration - 1
        endloop
    endmethod
    method Click_TriggerEvents takes DialogButton but returns nothing
        local integer iteration = EventPriority.ALL_COUNT
        local integer iteration2
        local EventPriority priority
        local EventResponse params = EventResponse.Create(this.Id.Get())
        call params.Dialog.SetTrigger(this)
        call params.Dialog.SetTriggerButton(but)
        loop
            exitwhen (iteration < ARRAY_MIN)
            set priority = EventPriority.ALL[iteration]
            set iteration2 = this.Event.Count(thistype.CLICK_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.CLICK_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    trigMethod ClickTrig
        local DialogButton but = DIALOG_BUTTON.Event.Native.GetClicked()
        local thistype this = thistype(NULL).Event.Native.GetClicked()
        local User whichPlayer = USER.Event.Native.GetTrigger()
        call this.Hide(whichPlayer)
        call this.Click_TriggerEvents(but)
        if not whichPlayer.Data.Integer.Table.IsEmpty(PLAYER_SHOWN_KEY_ARRAY) then
            call thistype(whichPlayer.Data.Integer.Table.GetFirst(PLAYER_SHOWN_KEY_ARRAY)).Show(whichPlayer)
        endif
    endmethod
    method SetTitle takes string title returns nothing
        call DialogSetMessage(this.self, title)
    endmethod
    static method Create takes nothing returns thistype
        local dialog self = DialogCreate()
        local thistype this = thistype.allocate()
        set this.self = self
        call Memory.IntegerKeys.SetIntegerByHandle(self, KEY, this)
        set self = null
        call this.Id.Event_Create()
        call thistype.CLICK_TRIGGER.RegisterEvent.Dialog(this)
        return this
    endmethod
    initMethod Init of Header_4
        set thistype.CLICK_EVENT_TYPE = EventType.Create()
        set thistype.CLICK_TRIGGER = Trigger.CreateFromCode(function thistype.ClickTrig)
        call DialogButton.Init()
    endmethod
endstruct
    globals
        EffectLevel EFFECT_LEVEL = STRUCT_BASE
    endglobals
    struct EffectLevel
        implement Allocation
        implement List
        
    static thistype CURRENT
    static thistype LOW
    static thistype NORMAL
    string name
    method GetName takes nothing returns string
        return this.name
    endmethod
    method SetName takes string value returns nothing
        set this.name = value
    endmethod
    operatorMethod < takes thistype other returns boolean
        return (this.index < other.index)
    endmethod
   
    static method Random takes thistype this, thistype other returns thistype
        return thistype.ALL[Math.RandomI(this.index, other.index)]
    endmethod
    method Select takes nothing returns nothing
        set thistype.CURRENT = this
    endmethod
    static method Create takes string name returns thistype
        local thistype this = thistype.allocate()
        call this.SetName(name)
        call this.AddToList()
        return this
    endmethod
    static method Init takes nothing returns boolean
        set thistype.LOW = thistype.Create("low")
        set thistype.NORMAL = thistype.Create("normal")
        set thistype.CURRENT = thistype.NORMAL
		return true
    endmethod
endstruct
    scope FolderSpotEffectWithSize
    public struct StructDestroyTimed
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
        SpotEffectWithSize parent
        timerMethod Ending
            local Timer durationTimer = Timer.GetExpired()
            local thistype this = durationTimer.GetData()
            local SpotEffectWithSize parent = this.parent
            call this.deallocate()
            call durationTimer.Destroy()
            call parent.Destroy()
        endmethod
        method Start takes real duration returns nothing
            local SpotEffectWithSize parent = this
            set this = thistype.allocate()
			local Timer durationTimer = Timer.Create()
            set this.parent = parent
            call durationTimer.SetData(this)
            call durationTimer.Start(duration, false, function thistype.Ending)
        endmethod
    endstruct
endscope
    globals
        SpotEffectWithSize SPOT_EFFECT_WITH_SIZE = STRUCT_BASE
    endglobals
    struct SpotEffectWithSize
        implement Allocation
        implement List
        
    static constant string DUMMY_UNIT_ATTACH_POINT = AttachPoint.ORIGIN
    DummyUnit dummyUnit
    effect self
    FolderSpotEffectWithSize_StructDestroyTimed DestroyTimed = this
    FolderSpotEffectWithSize_StructDestroyTimed LinkToStruct_DestroyTimed
    method Destroy takes nothing returns nothing
        local DummyUnit dummyUnit = this.dummyUnit
        local effect self = this.self
        call this.deallocate()
        call dummyUnit.Destroy()
        call DestroyEffect(self)
        set self = null
    endmethod
	method AddScale takes real val, real duration returns nothing
		call this.dummyUnit.Scale.Timed.Add(val, duration)
	endmethod
    static method Create takes real x, real y, string modelPath, EffectLevel level, real size returns thistype
        local thistype this = thistype.allocate()
		local DummyUnit dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, x, y, Spot.GetHeight(x, y), DUMMY_UNIT.Facing.STANDARD)
        set this.dummyUnit = dummyUnit
        set this.self = AddSpecialEffectTarget(String.If(EffectLevel.CURRENT >= level, modelPath), dummyUnit.self, thistype.DUMMY_UNIT_ATTACH_POINT)
        call dummyUnit.Scale.Set(size)
        return this
    endmethod
    static method CreateWithZ takes real x, real y, real z, string modelPath, EffectLevel level, real size returns thistype
        local thistype this = thistype.Create(x, y, modelPath, level, size)
        call this.dummyUnit.Position.Z.Set(z)
        return this
    endmethod
    static method Init takes nothing returns nothing
    endmethod
endstruct
    globals
        DummyUnitEffect DUMMY_UNIT_EFFECT = STRUCT_BASE
    endglobals
    struct DummyUnitEffect
        implement Allocation
        implement List
        
    static Event DEATH_EVENT
    static Event DESTROY_EVENT
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    DummyUnit dummyUnit
    effect self
    method Destroy takes nothing returns nothing
        local DummyUnit dummyUnit = this.dummyUnit
        local effect self = this.self
        call this.deallocate()
        call DestroyEffect(self)
        set self = null
        if dummyUnit.Data.Integer.Table.Remove(KEY_ARRAY, this) then
            call dummyUnit.Event.Remove(DEATH_EVENT)
            call dummyUnit.Event.Remove(DESTROY_EVENT)
        endif
    endmethod
    eventMethod Event_Death
        local DummyUnit dummyUnit = params.DummyUnit.GetTrigger()
        local integer iteration = dummyUnit.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            local thistype this = dummyUnit.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            call this.Destroy()
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
    endmethod
    eventMethod Event_Destroy
        local DummyUnit dummyUnit = params.DummyUnit.GetTrigger()
        local integer iteration = dummyUnit.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            local thistype this = dummyUnit.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            call this.Destroy()
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
    endmethod
    static method Create takes DummyUnit dummyUnit, string modelPath, string attachPoint, EffectLevel level returns thistype
        local thistype this = thistype.allocate()
        set this.dummyUnit = dummyUnit
        set this.self = AddSpecialEffectTarget(String.If(EffectLevel.CURRENT >= level, modelPath), dummyUnit.self, attachPoint)
        if dummyUnit.Data.Integer.Table.Add(KEY_ARRAY, this) then
            call dummyUnit.Event.Add(DEATH_EVENT)
            call dummyUnit.Event.Add(DESTROY_EVENT)
        endif
        return this
    endmethod
    static method Init takes nothing returns nothing
        set thistype.DEATH_EVENT = Event.Create(DummyUnit.DEATH_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Death)
        set thistype.DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
    endmethod
endstruct
    scope FolderSpotEffect
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return SpotEffect(this).Data.table.IntegerKeys.Table.ContainsInteger(SpotEffect(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return SpotEffect(this).Data.table.IntegerKeys.Table.CountIntegers(SpotEffect(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return SpotEffect(this).Data.table.IntegerKeys.Table.IsEmptyInteger(SpotEffect(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return SpotEffect(this).Data.table.IntegerKeys.Table.GetInteger(SpotEffect(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return SpotEffect(this).Data.table.IntegerKeys.Table.GetFirstInteger(SpotEffect(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return SpotEffect(this).Data.table.IntegerKeys.Table.GetLastInteger(SpotEffect(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call SpotEffect(this).Data.table.IntegerKeys.Table.Clear(SpotEffect(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return SpotEffect(this).Data.table.IntegerKeys.Table.FetchFirstInteger(SpotEffect(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return SpotEffect(this).Data.table.IntegerKeys.Table.RemoveInteger(SpotEffect(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return SpotEffect(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(SpotEffect(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return SpotEffect(this).Data.table.IntegerKeys.Table.AddInteger(SpotEffect(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return SpotEffect(this).Data.table.IntegerKeys.Table.AddIntegerMulti(SpotEffect(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call SpotEffect(this).Data.table.IntegerKeys.Table.JoinInteger(SpotEffect(this).Id.Get(), key, SpotEffect(other).Data.table, SpotEffect(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return SpotEffect(this).Data.table.IntegerKeys.Table.RandomInteger(SpotEffect(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call SpotEffect(this).Data.table.IntegerKeys.Table.ShuffleIntegers(SpotEffect(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call SpotEffect(this).Data.table.IntegerKeys.Table.PrintIntegers(SpotEffect(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructBoolean
        implement Allocation
        implement List
        
    method Get takes integer key returns boolean
        return SpotEffect(this).Data.table.IntegerKeys.GetBoolean(SpotEffect(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call SpotEffect(this).Data.table.IntegerKeys.RemoveBoolean(SpotEffect(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call SpotEffect(this).Data.table.IntegerKeys.SetBoolean(SpotEffect(this).Id.Get(), key, value)
    endmethod
        endstruct
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return SpotEffect(this).Data.table.IntegerKeys.GetInteger(SpotEffect(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call SpotEffect(this).Data.table.IntegerKeys.RemoveInteger(SpotEffect(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call SpotEffect(this).Data.table.IntegerKeys.SetInteger(SpotEffect(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(SpotEffect(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject SpotEffect.Allocation.deallocate_demount.hook
		call SpotEffect(this).Data.Destroy()
	endinject
	inject SpotEffect.Allocation.allocate_mount.hook
		call SpotEffect(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructEvent
        implement Allocation
        implement List
        
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(SpotEffect(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(SpotEffect(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(SpotEffect(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(SpotEffect(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(SpotEffect(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(SpotEffect(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(SpotEffect(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(SpotEffect(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject SpotEffect.Allocation.deallocate_demount.hook
			call SpotEffect(this).Event.Destroy()
		endinject
		inject SpotEffect.Allocation.allocate_mount.hook
			call SpotEffect(this).Event.Event_Create()
		endinject
    endstruct
    public struct StructDestroyTimed
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
        SpotEffect parent
        timerMethod Ending
            local Timer durationTimer = Timer.GetExpired()
            local thistype this = durationTimer.GetData()
            local SpotEffect parent = this.parent
            call this.deallocate()
            call durationTimer.Destroy()
            call parent.Destroy()
        endmethod
        method Start takes real duration returns nothing
            local SpotEffect parent = this
            set this = thistype.allocate()
			local Timer durationTimer = Timer.Create()
            set this.parent = parent
            call durationTimer.SetData(this)
            call durationTimer.Start(duration, false, function thistype.Ending)
        endmethod
    endstruct
endscope
    globals
        SpotEffect SPOT_EFFECT = STRUCT_BASE
    endglobals
    struct SpotEffect
        implement Allocation
        implement List
        
    static EventType DESTROY_EVENT_TYPE
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    EffectLevel level
    string modelPath
    effect self
    real x
    real y
    FolderSpotEffect_StructDestroyTimed DestroyTimed = this
    FolderSpotEffect_StructDestroyTimed LinkToStruct_DestroyTimed
    FolderSpotEffect_StructData Data = this
    FolderSpotEffect_StructData LinkToStruct_Data
    FolderSpotEffect_StructEvent Event = this
    FolderSpotEffect_StructEvent LinkToStruct_Event
    FolderSpotEffect_StructId Id = this
    FolderSpotEffect_StructId LinkToStruct_Id
    method Destroy takes nothing returns nothing
        local effect self = this.self
        call this.deallocate()
        if (self != null) then
            call DestroyEffect(self)
            set self = null
        endif
    endmethod
    method Hide takes nothing returns nothing
        call DestroyEffect(this.self)
        set this.self = null
    endmethod
    method Show takes nothing returns nothing
        set this.self = AddSpecialEffect(String.If(EffectLevel.CURRENT >= this.level, this.modelPath), this.x, this.y)
    endmethod
    static method Create takes real x, real y, string modelPath, EffectLevel level returns thistype
        local thistype this = thistype.allocate()
        set this.level = level
        set this.modelPath = modelPath
        set this.x = x
        set this.y = y
        call this.Show()
        return this
    endmethod
    static method CreateOnDestructable takes Destructable whichDestructable, string modelPath, EffectLevel level returns thistype
        return thistype.Create(whichDestructable.x, whichDestructable.y, modelPath, level)
    endmethod
    static method CreateWithZ takes real x, real y, real z, string modelPath, EffectLevel level returns thistype
		local destructable dummyDestructable = CreateDestructableZ(thistype.WITH_Z_DUMMY_DESTRUCTABLE_ID, x, y, z, 0., 1., 0)
        local thistype this = thistype.Create(x, y, modelPath, level)
        call RemoveDestructable(dummyDestructable)
        set dummyDestructable = null
        return this
    endmethod
    static method Init takes nothing returns nothing
        set thistype.DESTROY_EVENT_TYPE = EventType.Create()
    endmethod
endstruct
    scope FolderUnitEffect
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return UnitEffect(this).Data.table.IntegerKeys.Table.ContainsInteger(UnitEffect(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return UnitEffect(this).Data.table.IntegerKeys.Table.CountIntegers(UnitEffect(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return UnitEffect(this).Data.table.IntegerKeys.Table.IsEmptyInteger(UnitEffect(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return UnitEffect(this).Data.table.IntegerKeys.Table.GetInteger(UnitEffect(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return UnitEffect(this).Data.table.IntegerKeys.Table.GetFirstInteger(UnitEffect(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return UnitEffect(this).Data.table.IntegerKeys.Table.GetLastInteger(UnitEffect(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call UnitEffect(this).Data.table.IntegerKeys.Table.Clear(UnitEffect(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return UnitEffect(this).Data.table.IntegerKeys.Table.FetchFirstInteger(UnitEffect(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return UnitEffect(this).Data.table.IntegerKeys.Table.RemoveInteger(UnitEffect(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return UnitEffect(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(UnitEffect(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return UnitEffect(this).Data.table.IntegerKeys.Table.AddInteger(UnitEffect(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return UnitEffect(this).Data.table.IntegerKeys.Table.AddIntegerMulti(UnitEffect(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call UnitEffect(this).Data.table.IntegerKeys.Table.JoinInteger(UnitEffect(this).Id.Get(), key, UnitEffect(other).Data.table, UnitEffect(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return UnitEffect(this).Data.table.IntegerKeys.Table.RandomInteger(UnitEffect(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call UnitEffect(this).Data.table.IntegerKeys.Table.ShuffleIntegers(UnitEffect(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call UnitEffect(this).Data.table.IntegerKeys.Table.PrintIntegers(UnitEffect(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructBoolean
        implement Allocation
        implement List
        
    method Get takes integer key returns boolean
        return UnitEffect(this).Data.table.IntegerKeys.GetBoolean(UnitEffect(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call UnitEffect(this).Data.table.IntegerKeys.RemoveBoolean(UnitEffect(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call UnitEffect(this).Data.table.IntegerKeys.SetBoolean(UnitEffect(this).Id.Get(), key, value)
    endmethod
        endstruct
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return UnitEffect(this).Data.table.IntegerKeys.GetInteger(UnitEffect(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call UnitEffect(this).Data.table.IntegerKeys.RemoveInteger(UnitEffect(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call UnitEffect(this).Data.table.IntegerKeys.SetInteger(UnitEffect(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(UnitEffect(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject UnitEffect.Allocation.deallocate_demount.hook
		call UnitEffect(this).Data.Destroy()
	endinject
	inject UnitEffect.Allocation.allocate_mount.hook
		call UnitEffect(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructEvent
        implement Allocation
        implement List
        
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(UnitEffect(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(UnitEffect(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(UnitEffect(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(UnitEffect(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(UnitEffect(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(UnitEffect(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(UnitEffect(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(UnitEffect(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject UnitEffect.Allocation.deallocate_demount.hook
			call UnitEffect(this).Event.Destroy()
		endinject
		inject UnitEffect.Allocation.allocate_mount.hook
			call UnitEffect(this).Event.Event_Create()
		endinject
    endstruct
    public struct StructDestroyTimed
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
        UnitEffect parent
        timerMethod Ending
            local Timer durationTimer = Timer.GetExpired()
            local thistype this = durationTimer.GetData()
            local UnitEffect parent = this.parent
            call this.deallocate()
            call durationTimer.Destroy()
            call parent.Destroy()
        endmethod
        method Start takes real duration returns nothing
            local UnitEffect parent = this
            set this = thistype.allocate()
			local Timer durationTimer = Timer.Create()
            set this.parent = parent
            call durationTimer.SetData(this)
            call durationTimer.Start(duration, false, function thistype.Ending)
        endmethod
    endstruct
endscope
    globals
        UnitEffect UNIT_EFFECT = STRUCT_BASE
    endglobals
    struct UnitEffect
        implement Allocation
        implement List
        
    static Event DESTROY_EVENT
    static EventType DESTROY_EVENT_TYPE
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static Event UNIT_DEATH_EVENT
    static Event UNIT_REVIVE_EVENT
    static Event UNIT_DESTROY_EVENT
    static Event UNIT_TYPE_CHANGE_EVENT
    string attachPoint
    boolean dead
    boolean hidden
    effect hiddenSelf
    EffectLevel level
    string modelPath
    effect self
    Unit whichUnit
    FolderUnitEffect_StructDestroyTimed DestroyTimed = this
    FolderUnitEffect_StructDestroyTimed LinkToStruct_DestroyTimed
    FolderUnitEffect_StructData Data = this
    FolderUnitEffect_StructData LinkToStruct_Data
    FolderUnitEffect_StructEvent Event = this
    FolderUnitEffect_StructEvent LinkToStruct_Event
    FolderUnitEffect_StructId Id = this
    FolderUnitEffect_StructId LinkToStruct_Id
    method Ending takes Unit whichUnit returns nothing
        call this.Event.Remove(DESTROY_EVENT)
        if whichUnit.Data.Integer.Table.Remove(KEY_ARRAY, this) then
            call whichUnit.Event.Remove(UNIT_DESTROY_EVENT)
            call whichUnit.Event.Remove(UNIT_TYPE_CHANGE_EVENT)
            if this.dead then
                call whichUnit.Event.Remove(UNIT_REVIVE_EVENT)
            else
                call whichUnit.Event.Remove(UNIT_DEATH_EVENT)
            endif
        endif
    endmethod
    eventMethod Event_Destroy
        local thistype this = params.UnitEffect.GetTrigger()
        local Unit whichUnit = this.whichUnit
        call this.Ending(whichUnit)
    endmethod
    method Destroy_TriggerEvents takes nothing returns nothing
        local EventResponse params = EventResponse.Create(this.Id.Get())
        call params.UnitEffect.SetTrigger(this)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = this.Event.Count(thistype.DESTROY_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.DESTROY_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    method Hide takes nothing returns nothing
        if this.hidden then
            return
        endif
        set this.hidden = true
        if (this.hiddenSelf == null) then
            call DestroyEffect(this.self)
            set this.self = null
        else
            call DestroyEffect(this.hiddenSelf)
            set this.hiddenSelf = null
        endif
    endmethod
    destroyMethod Destroy
        call this.Destroy_TriggerEvents()
        call this.Hide()
        
        call this.RemoveFromList()
    endmethod
    eventMethod Event_Unit_Destroy
        local Unit whichUnit = params.Unit.GetTrigger()
        local integer iteration = whichUnit.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            local thistype this = whichUnit.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            call this.Destroy()
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
    endmethod
    method Show takes nothing returns nothing
        if not this.hidden then
            return
        endif
        set this.hidden = false
        if (EffectLevel.CURRENT >= this.level) then
            set this.self = AddSpecialEffectTarget(this.modelPath, this.whichUnit.self, this.attachPoint)
            if (this.self == null) then
                
            endif
        else
            set this.hiddenSelf = AddSpecialEffectTarget(null, this.whichUnit.self, this.attachPoint)
        endif
    endmethod
    method Update takes nothing returns nothing
        if this.hidden then
            return
        endif
        if (this.hiddenSelf == null) then
            call DestroyEffect(this.self)
            set this.self = null
        else
            call DestroyEffect(this.hiddenSelf)
            set this.hiddenSelf = null
        endif
        if (EffectLevel.CURRENT >= this.level) then
            set this.self = AddSpecialEffectTarget(this.modelPath, this.whichUnit.self, this.attachPoint)
            if (this.self == null) then
                set this.self = AddSpecialEffect(null, 0., 0.)
            endif
        else
            set this.hiddenSelf = AddSpecialEffect(null, 0., 0.)
        endif
    endmethod
    static method UpdateAll takes nothing returns nothing
        local integer iteration = thistype.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_EMPTY)
            local thistype this = thistype.ALL[iteration]
            call this.Update()
            set iteration = iteration - 1
        endloop
    endmethod
    eventMethod Event_Unit_TypeChange
        local Unit whichUnit = params.Unit.GetTrigger()
        local integer iteration = whichUnit.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            local thistype this = whichUnit.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            call this.Update()
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
    endmethod
    eventMethod Event_Unit_Death
        local Unit whichUnit = params.Unit.GetTrigger()
        local integer iteration = whichUnit.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            local thistype this = whichUnit.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            call this.Hide()
			set this.dead = true
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
        call whichUnit.Event.Remove(UNIT_DEATH_EVENT)
        call whichUnit.Event.Add(UNIT_REVIVE_EVENT)
    endmethod
    eventMethod Event_Unit_Revive
        local Unit whichUnit = params.Unit.GetTrigger()
        local integer iteration = whichUnit.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            local thistype this = whichUnit.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            call this.Show()
			set this.dead = false
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
        call whichUnit.Event.Remove(UNIT_REVIVE_EVENT)
        call whichUnit.Event.Add(UNIT_DEATH_EVENT)
        call whichUnit.Color.Update()
    endmethod
	static method CreateHidden takes Unit whichUnit, string modelPath, string attachPoint, EffectLevel level returns thistype
        local boolean whichUnitDead = whichUnit.Classes.Contains(UnitClass.DEAD)
		local thistype this = thistype.allocate()
        set this.attachPoint = attachPoint
        set this.dead = whichUnitDead
        set this.hidden = true
        set this.hiddenSelf = null
        set this.level = level
        set this.modelPath = modelPath
        set this.self = null
        set this.whichUnit = whichUnit
        if whichUnit.Data.Integer.Table.Add(KEY_ARRAY, this) then
            if whichUnitDead then
                call whichUnit.Event.Add(UNIT_REVIVE_EVENT)
            else
                call whichUnit.Event.Add(UNIT_DEATH_EVENT)
            endif
            call whichUnit.Event.Add(UNIT_DESTROY_EVENT)
            call whichUnit.Event.Add(UNIT_TYPE_CHANGE_EVENT)
        endif
        call this.Id.Event_Create()
        call this.Event.Add(DESTROY_EVENT)
        call this.AddToList()
        return this
	endmethod
    static method Create takes Unit whichUnit, string modelPath, string attachPoint, EffectLevel level returns thistype
        local boolean hidden = whichUnit.Classes.Contains(UnitClass.DEAD)
		local thistype this = thistype.CreateHidden(whichUnit, modelPath, attachPoint, level)
        if not hidden then
            call this.Show()
        endif
        return this
    endmethod
    static method Init takes nothing returns nothing
        set thistype.DESTROY_EVENT_TYPE = EventType.Create()
        set thistype.DESTROY_EVENT = Event.Create(thistype.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
        set thistype.UNIT_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Unit_Death)
        set thistype.UNIT_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Unit_Destroy)
        set thistype.UNIT_REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Unit_Revive)
        set thistype.UNIT_TYPE_CHANGE_EVENT = Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Unit_TypeChange)
    endmethod
endstruct
    globals
        Effect EFFECT = STRUCT_BASE
    endglobals
    struct Effect
        implement Allocation
        implement List
        
    static method PreloadPath takes string path returns nothing
        call DestroyEffect(AddSpecialEffect(path, 0., 0.))
    endmethod
    initMethod Init of Header_7
        
        call DummyUnitEffect.Init()
        call SpotEffect.Init()
        call SpotEffectWithSize.Init()
        call UnitEffect.Init()
    endmethod
endstruct
    scope FolderEventMemoryHead
    scope FolderIntegerKeys
    public struct StructD2
        implement Allocation
        implement List
        
            static HashTable CACHE
            static constant integer SIZE = 8192
            static method GetFirstKey takes integer pivotKey, integer subject1, integer subject2 returns integer
                set pivotKey = pivotKey - Math.Integer.MIN
				local integer res = (pivotKey div 64 * SIZE * SIZE + subject1 * SIZE + subject2)
                return res
            endmethod
            static method GetSecondKey takes integer pivotKey, integer subject3, integer subject4 returns integer
                set pivotKey = pivotKey - Math.Integer.MIN
                local integer res = ((pivotKey - pivotKey div 64 * 64) * SIZE * SIZE + subject3 * SIZE + subject4)
                return res
            endmethod
                static method ContainsBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return thistype.CACHE.Boolean.Contains(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method GetBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return thistype.CACHE.Boolean.Get(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method SetBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, boolean value returns nothing
                    call thistype.CACHE.Boolean.Set(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4), value)
                endmethod
                static method RemoveBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call thistype.CACHE.Boolean.Remove(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method ContainsBooleanWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return cache.Boolean.Contains(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method GetBooleanWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return cache.Boolean.Get(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method SetBooleanWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, boolean value returns nothing
                    call cache.Boolean.Set(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4), value)
                endmethod
                static method RemoveBooleanWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call cache.Boolean.Remove(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method ContainsInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return thistype.CACHE.Integer.Contains(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method GetInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns integer
                    return thistype.CACHE.Integer.Get(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method SetInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, integer value returns nothing
                    call thistype.CACHE.Integer.Set(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4), value)
                endmethod
                static method RemoveInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call thistype.CACHE.Integer.Remove(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method ContainsIntegerWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return cache.Integer.Contains(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method GetIntegerWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns integer
                    return cache.Integer.Get(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method SetIntegerWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, integer value returns nothing
                    call cache.Integer.Set(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4), value)
                endmethod
                static method RemoveIntegerWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call cache.Integer.Remove(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method ContainsReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return thistype.CACHE.Real.Contains(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method GetReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns real
                    return thistype.CACHE.Real.Get(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method SetReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, real value returns nothing
                    call thistype.CACHE.Real.Set(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4), value)
                endmethod
                static method RemoveReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call thistype.CACHE.Real.Remove(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method ContainsRealWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return cache.Real.Contains(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method GetRealWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns real
                    return cache.Real.Get(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method SetRealWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, real value returns nothing
                    call cache.Real.Set(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4), value)
                endmethod
                static method RemoveRealWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call cache.Real.Remove(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method ContainsString takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return thistype.CACHE.String.Contains(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method GetString takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns string
                    return thistype.CACHE.String.Get(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method SetString takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, string value returns nothing
                    call thistype.CACHE.String.Set(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4), value)
                endmethod
                static method RemoveString takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call thistype.CACHE.String.Remove(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method ContainsStringWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return cache.String.Contains(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method GetStringWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns string
                    return cache.String.Get(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
                static method SetStringWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, string value returns nothing
                    call cache.String.Set(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4), value)
                endmethod
                static method RemoveStringWithCache takes HashTable cache, integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call cache.String.Remove(thistype.GetFirstKey(pivotKey, subject1, subject2), thistype.GetSecondKey(pivotKey, subject3, subject4))
                endmethod
            static method Init takes nothing returns nothing
                set thistype.CACHE = HashTable.Create()
            endmethod
        endstruct
    endscope
    public struct StructIntegerKeys
        implement Allocation
        implement List
        
        static HashTable CACHE
    static FolderIntegerKeys_StructD2 D2 = NULL
        static method RemoveChild takes integer missionKey returns nothing
            call thistype.CACHE.RemoveChild(missionKey)
        endmethod
            static method ContainsBoolean takes integer missionKey, integer key returns boolean
                return thistype.CACHE.Boolean.Contains(missionKey, key)
            endmethod
            static method GetBoolean takes integer missionKey, integer key returns boolean
                return thistype.CACHE.Boolean.Get(missionKey, key)
            endmethod
            static method GetBooleanByHandle takes handle handleSource, integer key returns boolean
                return thistype.GetBoolean(GetHandleId(handleSource), key)
            endmethod
            static method SetBoolean takes integer missionKey, integer key, boolean value returns nothing
                call thistype.CACHE.Boolean.Set(missionKey, key, value)
            endmethod
            static method SetBooleanByHandle takes handle handleSource, integer key, boolean value returns nothing
                call thistype.SetBoolean(GetHandleId(handleSource), key, value)
            endmethod
            static method RemoveBoolean takes integer missionKey, integer key returns nothing
                call thistype.CACHE.Boolean.Remove(missionKey, key)
            endmethod
            static method RemoveBooleanByHandle takes handle handleSource, integer key returns nothing
                call thistype.RemoveBoolean(GetHandleId(handleSource), key)
            endmethod
            static method ContainsInteger takes integer missionKey, integer key returns boolean
                return thistype.CACHE.Integer.Contains(missionKey, key)
            endmethod
            static method GetInteger takes integer missionKey, integer key returns integer
                return thistype.CACHE.Integer.Get(missionKey, key)
            endmethod
            static method GetIntegerByHandle takes handle handleSource, integer key returns integer
                return thistype.GetInteger(GetHandleId(handleSource), key)
            endmethod
            static method SetInteger takes integer missionKey, integer key, integer value returns nothing
                call thistype.CACHE.Integer.Set(missionKey, key, value)
            endmethod
            static method SetIntegerByHandle takes handle handleSource, integer key, integer value returns nothing
                call thistype.SetInteger(GetHandleId(handleSource), key, value)
            endmethod
            static method RemoveInteger takes integer missionKey, integer key returns nothing
                call thistype.CACHE.Integer.Remove(missionKey, key)
            endmethod
            static method RemoveIntegerByHandle takes handle handleSource, integer key returns nothing
                call thistype.RemoveInteger(GetHandleId(handleSource), key)
            endmethod
            static method ContainsReal takes integer missionKey, integer key returns boolean
                return thistype.CACHE.Real.Contains(missionKey, key)
            endmethod
            static method GetReal takes integer missionKey, integer key returns real
                return thistype.CACHE.Real.Get(missionKey, key)
            endmethod
            static method GetRealByHandle takes handle handleSource, integer key returns real
                return thistype.GetReal(GetHandleId(handleSource), key)
            endmethod
            static method SetReal takes integer missionKey, integer key, real value returns nothing
                call thistype.CACHE.Real.Set(missionKey, key, value)
            endmethod
            static method SetRealByHandle takes handle handleSource, integer key, real value returns nothing
                call thistype.SetReal(GetHandleId(handleSource), key, value)
            endmethod
            static method RemoveReal takes integer missionKey, integer key returns nothing
                call thistype.CACHE.Real.Remove(missionKey, key)
            endmethod
            static method RemoveRealByHandle takes handle handleSource, integer key returns nothing
                call thistype.RemoveReal(GetHandleId(handleSource), key)
            endmethod
            static method ContainsString takes integer missionKey, integer key returns boolean
                return thistype.CACHE.String.Contains(missionKey, key)
            endmethod
            static method GetString takes integer missionKey, integer key returns string
                return thistype.CACHE.String.Get(missionKey, key)
            endmethod
            static method GetStringByHandle takes handle handleSource, integer key returns string
                return thistype.GetString(GetHandleId(handleSource), key)
            endmethod
            static method SetString takes integer missionKey, integer key, string value returns nothing
                call thistype.CACHE.String.Set(missionKey, key, value)
            endmethod
            static method SetStringByHandle takes handle handleSource, integer key, string value returns nothing
                call thistype.SetString(GetHandleId(handleSource), key, value)
            endmethod
            static method RemoveString takes integer missionKey, integer key returns nothing
                call thistype.CACHE.String.Remove(missionKey, key)
            endmethod
            static method RemoveStringByHandle takes handle handleSource, integer key returns nothing
                call thistype.RemoveString(GetHandleId(handleSource), key)
            endmethod
        static method Init takes nothing returns nothing
            set thistype.CACHE = HashTable.Create()
            call thistype.D2.Init()
        endmethod
    endstruct
endscope
    struct EventMemoryHead
    static FolderEventMemoryHead_StructIntegerKeys IntegerKeys = NULL
    static method Init takes nothing returns nothing
        call thistype.IntegerKeys.Init()
    endmethod
endstruct
    scope FolderEventMemory
    scope FolderIntegerKeys
    scope FolderD2
    public struct StructTable
        implement Allocation
        implement List
        
                static constant integer EMPTY = HASH_TABLE.Integer.DEFAULT_VALUE
                static HashTable FIRST_CACHE
                static HashTable LAST_CACHE
                static HashTable NEXT_CACHE
                static HashTable PREV_CACHE
                static HashTable PRIO_CACHE
                    static method GetFirstBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns boolean
                        return EventMemoryHead.IntegerKeys.D2.GetBooleanWithCache(thistype.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0)
                    endmethod
                    static method GetLastBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns boolean
                        return EventMemoryHead.IntegerKeys.D2.GetBooleanWithCache(thistype.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0)
                    endmethod
                    static method GetNextBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, boolean value returns boolean
                        return EventMemoryHead.IntegerKeys.D2.GetBooleanWithCache(thistype.NEXT_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(value))
                    endmethod
                    static method GetPrevBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, boolean value returns boolean
                        return EventMemoryHead.IntegerKeys.D2.GetBooleanWithCache(thistype.PREV_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(value))
                    endmethod
                    static method GetBooleanPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3, boolean value returns integer
                        return EventMemoryHead.IntegerKeys.D2.GetIntegerWithCache(thistype.PRIO_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(value))
                    endmethod
                    static method GetBooleansMaxPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns integer
                    	local boolean value = thistype.GetFirstBoolean(pivotKey, subject1, subject2, subject3)
                    	local integer result = 0
                        loop
                            exitwhen (value == HASH_TABLE.Boolean.DEFAULT_VALUE)
                            local integer prio = thistype.GetBooleanPrio(pivotKey, subject1, subject2, subject3, value)
                            if (prio > result) then
                                set result = prio
                            endif
                            set value = thistype.GetNextBoolean(pivotKey, subject1, subject2, subject3, value)
                        endloop
                        return result
                    endmethod
                    static method RemoveBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, boolean value returns nothing
                        local boolean next = thistype.GetNextBoolean(pivotKey, subject1, subject2, subject3, value)
                        local boolean prev = thistype.GetPrevBoolean(pivotKey, subject1, subject2, subject3, value)
                        if ((prev == HASH_TABLE.Boolean.DEFAULT_VALUE) and (next == HASH_TABLE.Boolean.DEFAULT_VALUE)) then
                            if (thistype.GetFirstBoolean(pivotKey, subject1, subject2, subject3) != value) then
                                return
                            endif
                        endif
                
                  
                
                        if (next == HASH_TABLE.Boolean.DEFAULT_VALUE) then
                            call EventMemoryHead.IntegerKeys.D2.SetBooleanWithCache(thistype.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0, prev)
                        else
                            call EventMemoryHead.IntegerKeys.D2.SetBooleanWithCache(thistype.PREV_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(next), prev)
                        endif
                
                    
                
                        if (prev == HASH_TABLE.Boolean.DEFAULT_VALUE) then
                            
                            call EventMemoryHead.IntegerKeys.D2.SetBooleanWithCache(thistype.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0, next)
                            
                        else
                            
                            call EventMemoryHead.IntegerKeys.D2.SetBooleanWithCache(thistype.NEXT_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(prev), next)
                            
                        endif
                
                    
                
                    endmethod
                    static method FetchFirstBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns boolean
                        local boolean value = thistype.GetFirstBoolean(pivotKey, subject1, subject2, subject3)
	
                        if (value == HASH_TABLE.Boolean.DEFAULT_VALUE) then
                            return HASH_TABLE.Boolean.DEFAULT_VALUE
                        endif
                    
                        
                    
                        call thistype.RemoveBoolean(pivotKey, subject1, subject2, subject3, value)
                    
                        
                    
                        return value
                    endmethod
                    static method ClearBooleans takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns nothing
                        loop
                            exitwhen (thistype.FetchFirstBoolean(pivotKey, subject1, subject2, subject3) == HASH_TABLE.Boolean.DEFAULT_VALUE)
                        endloop
                    endmethod
                    static method InsertAfterBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, boolean prev, boolean value returns boolean
                        local boolean next
                        if (prev == HASH_TABLE.Boolean.DEFAULT_VALUE) then
                            set next = thistype.GetFirstBoolean(pivotKey, subject1, subject2, subject3)
                            call EventMemoryHead.IntegerKeys.D2.SetBooleanWithCache(thistype.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0, value)
                        else
                            set next = thistype.GetNextBoolean(pivotKey, subject1, subject2, subject3, prev)
                            call EventMemoryHead.IntegerKeys.D2.SetBooleanWithCache(thistype.NEXT_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(prev), value)
                        endif
                        if (next == HASH_TABLE.Boolean.DEFAULT_VALUE) then
                            call EventMemoryHead.IntegerKeys.D2.SetBooleanWithCache(thistype.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0, value)
                        else
                            call EventMemoryHead.IntegerKeys.D2.SetBooleanWithCache(thistype.PREV_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(next), value)
                        endif
                        call EventMemoryHead.IntegerKeys.D2.SetBooleanWithCache(thistype.NEXT_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(value), next)
                        call EventMemoryHead.IntegerKeys.D2.SetBooleanWithCache(thistype.PREV_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(value), prev)
                        return true
                    endmethod
                    static method AddBooleanWithPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3, boolean value, integer prio returns boolean
                        local boolean otherValue = thistype.GetLastBoolean(pivotKey, subject1, subject2, subject3)
                        loop
                            exitwhen (otherValue == HASH_TABLE.Boolean.DEFAULT_VALUE)
                            exitwhen (prio <= thistype.GetBooleanPrio(pivotKey, subject1, subject2, subject3, otherValue))
                            set otherValue = thistype.GetPrevBoolean(pivotKey, subject1, subject2, subject3, otherValue)
                        endloop
                        if not thistype.InsertAfterBoolean(pivotKey, subject1, subject2, subject3, otherValue, value) then
                            return false
                        endif
                        call EventMemoryHead.IntegerKeys.D2.SetIntegerWithCache(thistype.PRIO_CACHE, pivotKey, subject1, subject2, subject3, Boolean.ToInt(value), prio)
                        return true
                    endmethod
                    static method AddBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, boolean value returns boolean
                    
                    
                        
                    
                    
                    
                      
                    
                        return thistype.AddBooleanWithPrio(pivotKey, subject1, subject2, subject3, value, 0)
                    endmethod
                    static method GetFirstInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns integer
                        return EventMemoryHead.IntegerKeys.D2.GetIntegerWithCache(thistype.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0)
                    endmethod
                    static method GetLastInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns integer
                        return EventMemoryHead.IntegerKeys.D2.GetIntegerWithCache(thistype.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0)
                    endmethod
                    static method GetNextInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer value returns integer
                        return EventMemoryHead.IntegerKeys.D2.GetIntegerWithCache(thistype.NEXT_CACHE, pivotKey, subject1, subject2, subject3, (value))
                    endmethod
                    static method GetPrevInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer value returns integer
                        return EventMemoryHead.IntegerKeys.D2.GetIntegerWithCache(thistype.PREV_CACHE, pivotKey, subject1, subject2, subject3, (value))
                    endmethod
                    static method GetIntegerPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer value returns integer
                        return EventMemoryHead.IntegerKeys.D2.GetIntegerWithCache(thistype.PRIO_CACHE, pivotKey, subject1, subject2, subject3, (value))
                    endmethod
                    static method GetIntegersMaxPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns integer
                    	local integer value = thistype.GetFirstInteger(pivotKey, subject1, subject2, subject3)
                    	local integer result = 0
                        loop
                            exitwhen (value == HASH_TABLE.Integer.DEFAULT_VALUE)
                            local integer prio = thistype.GetIntegerPrio(pivotKey, subject1, subject2, subject3, value)
                            if (prio > result) then
                                set result = prio
                            endif
                            set value = thistype.GetNextInteger(pivotKey, subject1, subject2, subject3, value)
                        endloop
                        return result
                    endmethod
                    static method RemoveInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer value returns nothing
                        local integer next = thistype.GetNextInteger(pivotKey, subject1, subject2, subject3, value)
                        local integer prev = thistype.GetPrevInteger(pivotKey, subject1, subject2, subject3, value)
                        if ((prev == HASH_TABLE.Integer.DEFAULT_VALUE) and (next == HASH_TABLE.Integer.DEFAULT_VALUE)) then
                            if (thistype.GetFirstInteger(pivotKey, subject1, subject2, subject3) != value) then
                                return
                            endif
                        endif
                
                  
                
                        if (next == HASH_TABLE.Integer.DEFAULT_VALUE) then
                            call EventMemoryHead.IntegerKeys.D2.SetIntegerWithCache(thistype.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0, prev)
                        else
                            call EventMemoryHead.IntegerKeys.D2.SetIntegerWithCache(thistype.PREV_CACHE, pivotKey, subject1, subject2, subject3, (next), prev)
                        endif
                
                    
                
                        if (prev == HASH_TABLE.Integer.DEFAULT_VALUE) then
                            
                            call EventMemoryHead.IntegerKeys.D2.SetIntegerWithCache(thistype.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0, next)
                            
                        else
                            
                            call EventMemoryHead.IntegerKeys.D2.SetIntegerWithCache(thistype.NEXT_CACHE, pivotKey, subject1, subject2, subject3, (prev), next)
                            
                        endif
                
                    
                
                    endmethod
                    static method FetchFirstInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns integer
                        local integer value = thistype.GetFirstInteger(pivotKey, subject1, subject2, subject3)
	
                        if (value == HASH_TABLE.Integer.DEFAULT_VALUE) then
                            return HASH_TABLE.Integer.DEFAULT_VALUE
                        endif
                    
                        
                    
                        call thistype.RemoveInteger(pivotKey, subject1, subject2, subject3, value)
                    
                        
                    
                        return value
                    endmethod
                    static method ClearIntegers takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns nothing
                        loop
                            exitwhen (thistype.FetchFirstInteger(pivotKey, subject1, subject2, subject3) == HASH_TABLE.Integer.DEFAULT_VALUE)
                        endloop
                    endmethod
                    static method InsertAfterInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer prev, integer value returns boolean
                        local integer next
                        if (prev == HASH_TABLE.Integer.DEFAULT_VALUE) then
                            set next = thistype.GetFirstInteger(pivotKey, subject1, subject2, subject3)
                            call EventMemoryHead.IntegerKeys.D2.SetIntegerWithCache(thistype.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0, value)
                        else
                            set next = thistype.GetNextInteger(pivotKey, subject1, subject2, subject3, prev)
                            call EventMemoryHead.IntegerKeys.D2.SetIntegerWithCache(thistype.NEXT_CACHE, pivotKey, subject1, subject2, subject3, (prev), value)
                        endif
                        if (next == HASH_TABLE.Integer.DEFAULT_VALUE) then
                            call EventMemoryHead.IntegerKeys.D2.SetIntegerWithCache(thistype.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0, value)
                        else
                            call EventMemoryHead.IntegerKeys.D2.SetIntegerWithCache(thistype.PREV_CACHE, pivotKey, subject1, subject2, subject3, (next), value)
                        endif
                        call EventMemoryHead.IntegerKeys.D2.SetIntegerWithCache(thistype.NEXT_CACHE, pivotKey, subject1, subject2, subject3, (value), next)
                        call EventMemoryHead.IntegerKeys.D2.SetIntegerWithCache(thistype.PREV_CACHE, pivotKey, subject1, subject2, subject3, (value), prev)
                        return true
                    endmethod
                    static method AddIntegerWithPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer value, integer prio returns boolean
                        local integer otherValue = thistype.GetLastInteger(pivotKey, subject1, subject2, subject3)
                        loop
                            exitwhen (otherValue == HASH_TABLE.Integer.DEFAULT_VALUE)
                            exitwhen (prio <= thistype.GetIntegerPrio(pivotKey, subject1, subject2, subject3, otherValue))
                            set otherValue = thistype.GetPrevInteger(pivotKey, subject1, subject2, subject3, otherValue)
                        endloop
                        if not thistype.InsertAfterInteger(pivotKey, subject1, subject2, subject3, otherValue, value) then
                            return false
                        endif
                        call EventMemoryHead.IntegerKeys.D2.SetIntegerWithCache(thistype.PRIO_CACHE, pivotKey, subject1, subject2, subject3, (value), prio)
                        return true
                    endmethod
                    static method AddInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer value returns boolean
                    
                    
                        
                    
                    
                    
                      
                    
                        return thistype.AddIntegerWithPrio(pivotKey, subject1, subject2, subject3, value, 0)
                    endmethod
                    static method GetFirstReal takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns real
                        return EventMemoryHead.IntegerKeys.D2.GetRealWithCache(thistype.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0)
                    endmethod
                    static method GetLastReal takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns real
                        return EventMemoryHead.IntegerKeys.D2.GetRealWithCache(thistype.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0)
                    endmethod
                    static method GetNextReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, real value returns real
                        return EventMemoryHead.IntegerKeys.D2.GetRealWithCache(thistype.NEXT_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(value))
                    endmethod
                    static method GetPrevReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, real value returns real
                        return EventMemoryHead.IntegerKeys.D2.GetRealWithCache(thistype.PREV_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(value))
                    endmethod
                    static method GetRealPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3, real value returns integer
                        return EventMemoryHead.IntegerKeys.D2.GetIntegerWithCache(thistype.PRIO_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(value))
                    endmethod
                    static method GetRealsMaxPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns integer
                    	local real value = thistype.GetFirstReal(pivotKey, subject1, subject2, subject3)
                    	local integer result = 0
                        loop
                            exitwhen (value == HASH_TABLE.Real.DEFAULT_VALUE)
                            local integer prio = thistype.GetRealPrio(pivotKey, subject1, subject2, subject3, value)
                            if (prio > result) then
                                set result = prio
                            endif
                            set value = thistype.GetNextReal(pivotKey, subject1, subject2, subject3, value)
                        endloop
                        return result
                    endmethod
                    static method RemoveReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, real value returns nothing
                        local real next = thistype.GetNextReal(pivotKey, subject1, subject2, subject3, value)
                        local real prev = thistype.GetPrevReal(pivotKey, subject1, subject2, subject3, value)
                        if ((prev == HASH_TABLE.Real.DEFAULT_VALUE) and (next == HASH_TABLE.Real.DEFAULT_VALUE)) then
                            if (thistype.GetFirstReal(pivotKey, subject1, subject2, subject3) != value) then
                                return
                            endif
                        endif
                
                  
                
                        if (next == HASH_TABLE.Real.DEFAULT_VALUE) then
                            call EventMemoryHead.IntegerKeys.D2.SetRealWithCache(thistype.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0, prev)
                        else
                            call EventMemoryHead.IntegerKeys.D2.SetRealWithCache(thistype.PREV_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(next), prev)
                        endif
                
                    
                
                        if (prev == HASH_TABLE.Real.DEFAULT_VALUE) then
                            
                            call EventMemoryHead.IntegerKeys.D2.SetRealWithCache(thistype.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0, next)
                            
                        else
                            
                            call EventMemoryHead.IntegerKeys.D2.SetRealWithCache(thistype.NEXT_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(prev), next)
                            
                        endif
                
                    
                
                    endmethod
                    static method FetchFirstReal takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns real
                        local real value = thistype.GetFirstReal(pivotKey, subject1, subject2, subject3)
	
                        if (value == HASH_TABLE.Real.DEFAULT_VALUE) then
                            return HASH_TABLE.Real.DEFAULT_VALUE
                        endif
                    
                        
                    
                        call thistype.RemoveReal(pivotKey, subject1, subject2, subject3, value)
                    
                        
                    
                        return value
                    endmethod
                    static method ClearReals takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns nothing
                        loop
                            exitwhen (thistype.FetchFirstReal(pivotKey, subject1, subject2, subject3) == HASH_TABLE.Real.DEFAULT_VALUE)
                        endloop
                    endmethod
                    static method InsertAfterReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, real prev, real value returns boolean
                        local real next
                        if (prev == HASH_TABLE.Real.DEFAULT_VALUE) then
                            set next = thistype.GetFirstReal(pivotKey, subject1, subject2, subject3)
                            call EventMemoryHead.IntegerKeys.D2.SetRealWithCache(thistype.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0, value)
                        else
                            set next = thistype.GetNextReal(pivotKey, subject1, subject2, subject3, prev)
                            call EventMemoryHead.IntegerKeys.D2.SetRealWithCache(thistype.NEXT_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(prev), value)
                        endif
                        if (next == HASH_TABLE.Real.DEFAULT_VALUE) then
                            call EventMemoryHead.IntegerKeys.D2.SetRealWithCache(thistype.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0, value)
                        else
                            call EventMemoryHead.IntegerKeys.D2.SetRealWithCache(thistype.PREV_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(next), value)
                        endif
                        call EventMemoryHead.IntegerKeys.D2.SetRealWithCache(thistype.NEXT_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(value), next)
                        call EventMemoryHead.IntegerKeys.D2.SetRealWithCache(thistype.PREV_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(value), prev)
                        return true
                    endmethod
                    static method AddRealWithPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3, real value, integer prio returns boolean
                        local real otherValue = thistype.GetLastReal(pivotKey, subject1, subject2, subject3)
                        loop
                            exitwhen (otherValue == HASH_TABLE.Real.DEFAULT_VALUE)
                            exitwhen (prio <= thistype.GetRealPrio(pivotKey, subject1, subject2, subject3, otherValue))
                            set otherValue = thistype.GetPrevReal(pivotKey, subject1, subject2, subject3, otherValue)
                        endloop
                        if not thistype.InsertAfterReal(pivotKey, subject1, subject2, subject3, otherValue, value) then
                            return false
                        endif
                        call EventMemoryHead.IntegerKeys.D2.SetIntegerWithCache(thistype.PRIO_CACHE, pivotKey, subject1, subject2, subject3, Real.ToInt(value), prio)
                        return true
                    endmethod
                    static method AddReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, real value returns boolean
                    
                    
                        
                    
                    
                    
                      
                    
                        return thistype.AddRealWithPrio(pivotKey, subject1, subject2, subject3, value, 0)
                    endmethod
                    static method GetFirstString takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns string
                        return EventMemoryHead.IntegerKeys.D2.GetStringWithCache(thistype.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0)
                    endmethod
                    static method GetLastString takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns string
                        return EventMemoryHead.IntegerKeys.D2.GetStringWithCache(thistype.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0)
                    endmethod
                    static method GetNextString takes integer pivotKey, integer subject1, integer subject2, integer subject3, string value returns string
                        return EventMemoryHead.IntegerKeys.D2.GetStringWithCache(thistype.NEXT_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(value))
                    endmethod
                    static method GetPrevString takes integer pivotKey, integer subject1, integer subject2, integer subject3, string value returns string
                        return EventMemoryHead.IntegerKeys.D2.GetStringWithCache(thistype.PREV_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(value))
                    endmethod
                    static method GetStringPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3, string value returns integer
                        return EventMemoryHead.IntegerKeys.D2.GetIntegerWithCache(thistype.PRIO_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(value))
                    endmethod
                    static method GetStringsMaxPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns integer
                    	local string value = thistype.GetFirstString(pivotKey, subject1, subject2, subject3)
                    	local integer result = 0
                        loop
                            exitwhen (value == HASH_TABLE.String.DEFAULT_VALUE)
                            local integer prio = thistype.GetStringPrio(pivotKey, subject1, subject2, subject3, value)
                            if (prio > result) then
                                set result = prio
                            endif
                            set value = thistype.GetNextString(pivotKey, subject1, subject2, subject3, value)
                        endloop
                        return result
                    endmethod
                    static method RemoveString takes integer pivotKey, integer subject1, integer subject2, integer subject3, string value returns nothing
                        local string next = thistype.GetNextString(pivotKey, subject1, subject2, subject3, value)
                        local string prev = thistype.GetPrevString(pivotKey, subject1, subject2, subject3, value)
                        if ((prev == HASH_TABLE.String.DEFAULT_VALUE) and (next == HASH_TABLE.String.DEFAULT_VALUE)) then
                            if (thistype.GetFirstString(pivotKey, subject1, subject2, subject3) != value) then
                                return
                            endif
                        endif
                
                  
                
                        if (next == HASH_TABLE.String.DEFAULT_VALUE) then
                            call EventMemoryHead.IntegerKeys.D2.SetStringWithCache(thistype.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0, prev)
                        else
                            call EventMemoryHead.IntegerKeys.D2.SetStringWithCache(thistype.PREV_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(next), prev)
                        endif
                
                    
                
                        if (prev == HASH_TABLE.String.DEFAULT_VALUE) then
                            
                            call EventMemoryHead.IntegerKeys.D2.SetStringWithCache(thistype.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0, next)
                            
                        else
                            
                            call EventMemoryHead.IntegerKeys.D2.SetStringWithCache(thistype.NEXT_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(prev), next)
                            
                        endif
                
                    
                
                    endmethod
                    static method FetchFirstString takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns string
                        local string value = thistype.GetFirstString(pivotKey, subject1, subject2, subject3)
	
                        if (value == HASH_TABLE.String.DEFAULT_VALUE) then
                            return HASH_TABLE.String.DEFAULT_VALUE
                        endif
                    
                        
                    
                        call thistype.RemoveString(pivotKey, subject1, subject2, subject3, value)
                    
                        
                    
                        return value
                    endmethod
                    static method ClearStrings takes integer pivotKey, integer subject1, integer subject2, integer subject3 returns nothing
                        loop
                            exitwhen (thistype.FetchFirstString(pivotKey, subject1, subject2, subject3) == HASH_TABLE.String.DEFAULT_VALUE)
                        endloop
                    endmethod
                    static method InsertAfterString takes integer pivotKey, integer subject1, integer subject2, integer subject3, string prev, string value returns boolean
                        local string next
                        if (prev == HASH_TABLE.String.DEFAULT_VALUE) then
                            set next = thistype.GetFirstString(pivotKey, subject1, subject2, subject3)
                            call EventMemoryHead.IntegerKeys.D2.SetStringWithCache(thistype.FIRST_CACHE, pivotKey, subject1, subject2, subject3, 0, value)
                        else
                            set next = thistype.GetNextString(pivotKey, subject1, subject2, subject3, prev)
                            call EventMemoryHead.IntegerKeys.D2.SetStringWithCache(thistype.NEXT_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(prev), value)
                        endif
                        if (next == HASH_TABLE.String.DEFAULT_VALUE) then
                            call EventMemoryHead.IntegerKeys.D2.SetStringWithCache(thistype.LAST_CACHE, pivotKey, subject1, subject2, subject3, 0, value)
                        else
                            call EventMemoryHead.IntegerKeys.D2.SetStringWithCache(thistype.PREV_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(next), value)
                        endif
                        call EventMemoryHead.IntegerKeys.D2.SetStringWithCache(thistype.NEXT_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(value), next)
                        call EventMemoryHead.IntegerKeys.D2.SetStringWithCache(thistype.PREV_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(value), prev)
                        return true
                    endmethod
                    static method AddStringWithPrio takes integer pivotKey, integer subject1, integer subject2, integer subject3, string value, integer prio returns boolean
                        local string otherValue = thistype.GetLastString(pivotKey, subject1, subject2, subject3)
                        loop
                            exitwhen (otherValue == HASH_TABLE.String.DEFAULT_VALUE)
                            exitwhen (prio <= thistype.GetStringPrio(pivotKey, subject1, subject2, subject3, otherValue))
                            set otherValue = thistype.GetPrevString(pivotKey, subject1, subject2, subject3, otherValue)
                        endloop
                        if not thistype.InsertAfterString(pivotKey, subject1, subject2, subject3, otherValue, value) then
                            return false
                        endif
                        call EventMemoryHead.IntegerKeys.D2.SetIntegerWithCache(thistype.PRIO_CACHE, pivotKey, subject1, subject2, subject3, String.ToIntHash(value), prio)
                        return true
                    endmethod
                    static method AddString takes integer pivotKey, integer subject1, integer subject2, integer subject3, string value returns boolean
                    
                    
                        
                    
                    
                    
                      
                    
                        return thistype.AddStringWithPrio(pivotKey, subject1, subject2, subject3, value, 0)
                    endmethod
                static method Init takes nothing returns nothing
                    set thistype.FIRST_CACHE = HashTable.Create()
                    set thistype.LAST_CACHE = HashTable.Create()
                    set thistype.NEXT_CACHE = HashTable.Create()
                    set thistype.PREV_CACHE = HashTable.Create()
                    set thistype.PRIO_CACHE = HashTable.Create()
                endmethod
            endstruct
        endscope
    public struct StructD2
        implement Allocation
        implement List
        
    static FolderD2_StructTable Table = NULL
                static method ContainsBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return EventMemoryHead.IntegerKeys.D2.ContainsBoolean(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                static method GetBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return EventMemoryHead.IntegerKeys.D2.GetBoolean(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                static method SetBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, boolean value returns nothing
                    call EventMemoryHead.IntegerKeys.D2.SetBoolean(pivotKey, subject1, subject2, subject3, subject4, value)
                endmethod
                static method RemoveBoolean takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call EventMemoryHead.IntegerKeys.D2.RemoveBoolean(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                static method ContainsInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return EventMemoryHead.IntegerKeys.D2.ContainsInteger(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                static method GetInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns integer
                    return EventMemoryHead.IntegerKeys.D2.GetInteger(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                static method SetInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, integer value returns nothing
                    call EventMemoryHead.IntegerKeys.D2.SetInteger(pivotKey, subject1, subject2, subject3, subject4, value)
                endmethod
                static method RemoveInteger takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call EventMemoryHead.IntegerKeys.D2.RemoveInteger(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                static method ContainsReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return EventMemoryHead.IntegerKeys.D2.ContainsReal(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                static method GetReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns real
                    return EventMemoryHead.IntegerKeys.D2.GetReal(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                static method SetReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, real value returns nothing
                    call EventMemoryHead.IntegerKeys.D2.SetReal(pivotKey, subject1, subject2, subject3, subject4, value)
                endmethod
                static method RemoveReal takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call EventMemoryHead.IntegerKeys.D2.RemoveReal(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                static method ContainsString takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns boolean
                    return EventMemoryHead.IntegerKeys.D2.ContainsString(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                static method GetString takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns string
                    return EventMemoryHead.IntegerKeys.D2.GetString(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
                static method SetString takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4, string value returns nothing
                    call EventMemoryHead.IntegerKeys.D2.SetString(pivotKey, subject1, subject2, subject3, subject4, value)
                endmethod
                static method RemoveString takes integer pivotKey, integer subject1, integer subject2, integer subject3, integer subject4 returns nothing
                    call EventMemoryHead.IntegerKeys.D2.RemoveString(pivotKey, subject1, subject2, subject3, subject4)
                endmethod
            static method Init takes nothing returns nothing
                call thistype.Table.Init()
            endmethod
        endstruct
    public struct StructTable
        implement Allocation
        implement List
        
            static constant integer EMPTY = HASH_TABLE.Integer.DEFAULT_VALUE
            static constant integer OFFSET = 8192
            static HashTable POS_CACHE
            static HashTable PRIO_CACHE
            static constant integer SIZE = 8192
            static constant integer STARTED = thistype.EMPTY + 1
            static method GetId takes integer key returns integer
                return thistype.OFFSET + (key - Math.Integer.MIN) * thistype.SIZE
            endmethod
            static method GetTableId takes integer key returns integer
                return (key - Math.Integer.MIN - thistype.OFFSET) div thistype.SIZE
            endmethod
            static method GetTableStartId takes integer key returns integer
                local integer tableId = thistype.GetTableId(key)
                if (tableId > 0) then
                    return Math.Integer.MIN + thistype.OFFSET + tableId * thistype.SIZE
                endif
                return 0
            endmethod
            static method GetReverseKey takes integer key, integer value returns integer
                return (value * thistype.SIZE + thistype.GetTableId(key))
            endmethod
            private static method SetCount takes integer missionKey, integer key, integer value returns nothing
                call EventMemoryHead.IntegerKeys.SetInteger(missionKey, key, value - thistype.EMPTY)
            endmethod
            static method ToArrayIndex takes integer index returns integer
                return (index - thistype.STARTED + ARRAY_MIN)
            endmethod
                static method GetBooleanPos takes integer missionKey, integer key, boolean value returns integer
                    return thistype.POS_CACHE.Integer.Get(missionKey, thistype.GetReverseKey(key, Boolean.ToInt(value)))
                endmethod
                static method GetBooleanPrio takes integer missionKey, integer key, boolean value returns integer
                    return thistype.PRIO_CACHE.Integer.Get(missionKey, thistype.GetReverseKey(key, Boolean.ToInt(value)))
                endmethod
                static method CountBooleans takes integer missionKey, integer key returns integer
                    return (thistype.EMPTY + EventMemoryHead.IntegerKeys.GetInteger(missionKey, key))
                endmethod
                static method IsEmptyBoolean takes integer missionKey, integer key returns boolean
                    return (EventMemoryHead.IntegerKeys.GetInteger(missionKey, key) == thistype.EMPTY)
                endmethod
                static method GetBoolean takes integer missionKey, integer key, integer index returns boolean
                    return EventMemoryHead.IntegerKeys.GetBoolean(missionKey, key + index)
                endmethod
                static method GetFirstBoolean takes integer missionKey, integer key returns boolean
                    return thistype.GetBoolean(missionKey, key, thistype.STARTED)
                endmethod
                static method GetLastBoolean takes integer missionKey, integer key returns boolean
                    return thistype.GetBoolean(missionKey, key, thistype.CountBooleans(missionKey, key))
                endmethod
                static method ContainsBoolean takes integer missionKey, integer key, boolean value returns boolean
                    return (thistype.GetBooleanPos(missionKey, key, value) != HASH_TABLE.Integer.DEFAULT_VALUE)
                endmethod
                static method RandomBoolean takes integer missionKey, integer key, integer lowerBound, integer higherBound returns boolean
                    return thistype.GetBoolean(missionKey, key, Math.RandomI(lowerBound, higherBound))
                endmethod
                static method RandomBooleanAll takes integer missionKey, integer key returns boolean
                    return thistype.RandomBoolean(missionKey, key, thistype.STARTED, thistype.CountBooleans(missionKey, key))
                endmethod
                static method FetchFirstBoolean takes integer missionKey, integer key returns boolean
                    local integer count = thistype.CountBooleans(missionKey, key)
                    if (count == thistype.EMPTY) then
                        return HASH_TABLE.Boolean.DEFAULT_VALUE
                    endif
                    local boolean value = thistype.GetBoolean(missionKey, key, count)
                    call thistype.SetCount(missionKey, key, count - 1)
                    call thistype.POS_CACHE.Boolean.Remove(missionKey, thistype.GetReverseKey(key, Boolean.ToInt(value)))
                    call EventMemoryHead.IntegerKeys.RemoveBoolean(missionKey, key + count)
                    return value
                endmethod
                static method ClearBooleans takes integer missionKey, integer key returns nothing
                    local integer iteration = thistype.CountBooleans(missionKey, key)
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        local boolean value = thistype.GetBoolean(missionKey, key, iteration)
                        call EventMemoryHead.IntegerKeys.RemoveBoolean(missionKey, key + iteration)
                        call thistype.POS_CACHE.Integer.Remove(missionKey, thistype.GetReverseKey(key, Boolean.ToInt(value)))
                        set iteration = iteration - 1
                    endloop
					call thistype.SetCount(missionKey, key, thistype.EMPTY)
                endmethod
                static method AddBoolean takes integer missionKey, integer key, boolean value returns boolean
                    if thistype.ContainsBoolean(missionKey, key, value) then
call DebugEx(B2S(value)+" already in table "+I2S(missionKey)+";"+I2S(key))
call thistype.PrintBooleans(missionKey, key)
                        return false
                    endif
                    local integer count = thistype.CountBooleans(missionKey, key) + 1
    
                    call thistype.SetCount(missionKey, key, count)
                    call thistype.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, Boolean.ToInt(value)), count)
                    call EventMemoryHead.IntegerKeys.SetBoolean(missionKey, key + count, value)
                    return (count == thistype.STARTED)
                endmethod
                static method AddBooleanMulti takes integer missionKey, integer key, boolean value returns boolean
                    local integer count = thistype.CountBooleans(missionKey, key) + 1
                    call thistype.SetCount(missionKey, key, count)
                    call EventMemoryHead.IntegerKeys.SetBoolean(missionKey, key + count, value)
                    return (count == thistype.STARTED)
                endmethod
               
                static method JoinBoolean takes integer missionKey, integer key, integer missionKey2, integer key2 returns nothing
                    local integer count = thistype.CountBooleans(missionKey2, key2)
                    if (count == thistype.EMPTY) then
                        return
                    endif
					local integer addCount = 0
                    local integer iteration = thistype.STARTED
                    local integer oldCount = thistype.CountBooleans(missionKey, key)
                    loop
                        local boolean value = thistype.GetBoolean(missionKey2, key2, iteration)
                        if not thistype.ContainsBoolean(missionKey, key, value) then
                            set addCount = addCount + 1
                            call thistype.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, Boolean.ToInt(value)), oldCount + addCount)
                            call EventMemoryHead.IntegerKeys.SetBoolean(missionKey, key + oldCount + addCount, value)
                        endif
                        set iteration = iteration + 1
                        exitwhen (iteration > count)
                    endloop
                    call thistype.SetCount(missionKey, key, oldCount + addCount)
                endmethod
                static method PrintBooleans takes integer missionKey, integer key returns nothing
                	local integer count = thistype.CountBooleans(missionKey, key)
					call DebugBufferStart()
                    call DebugBuffer("print table " + I2S(missionKey) + ";" + I2S(key) + ";" + I2S(count))
                    local string missionKeyName = Memory.GetKeyFromValue(missionKey)
                    local string keyName = Memory.GetKeyFromValue(key)
                    if ((missionKeyName != null) or (keyName != null)) then
                        call DebugBuffer(missionKeyName + ";" + keyName)
                    endif
                    call DebugBuffer("--->")
					local integer iteration = count
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        local boolean value = thistype.GetBoolean(missionKey, key, iteration)
                        local integer pos = thistype.GetBooleanPos(missionKey, key, value)
                        call DebugBuffer(Char.TAB + B2S(value) + " on " + I2S(iteration) + ";" + I2S(pos) + ";" + I2S(thistype.GetReverseKey(key, Boolean.ToInt(value))))
                        if (iteration != pos) then
                            call DebugBuffer("TABLE CORRUPTED!")
                        endif
                        call DebugBuffer(Char.TAB + Char.TAB + Memory.GetKeyFromValue(pos))
                        set iteration = iteration - 1
                    endloop
					
                    call DebugBufferFinish()
                endmethod
                static method RemoveBoolean takes integer missionKey, integer key, boolean value returns boolean
                    local integer count = thistype.CountBooleans(missionKey, key)
                    local integer reverseKey = thistype.GetReverseKey(key, Boolean.ToInt(value))
                    local boolean lastValue = thistype.GetBoolean(missionKey, key, count)
                    local integer pos = thistype.POS_CACHE.Integer.Get(missionKey, reverseKey)
                    static if DEBUG then
                        if not thistype.ContainsBoolean(missionKey, key, value) then
                            call DebugEx(thistype.NAME + ": " + "cannot remove "+B2S(value) + " from " + I2S(missionKey) + ";" + I2S(key) + " reverseKey: "+I2S(reverseKey))
                            call thistype.PrintBooleans(missionKey, key)
                            return false
                        endif
                    endif
                    call thistype.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, Boolean.ToInt(lastValue)), pos)
                    call EventMemoryHead.IntegerKeys.SetBoolean(missionKey, key + pos, lastValue)
                    call thistype.POS_CACHE.Integer.Remove(missionKey, reverseKey)
                    call EventMemoryHead.IntegerKeys.RemoveBoolean(missionKey, key + count)
                    set count = count - 1
                    call thistype.SetCount(missionKey, key, count)
                    return (count == thistype.EMPTY)
                endmethod
                static method FetchRandomBoolean takes integer missionKey, integer key, integer lowerBound, integer higherBound returns boolean
                    local integer count = thistype.CountBooleans(missionKey, key)
                    if (lowerBound > count) then
                        set lowerBound = count
                    endif
                    if (higherBound > count) then
                        set higherBound = count
                    endif
                    if (higherBound <= thistype.EMPTY) then
                        return HASH_TABLE.Boolean.DEFAULT_VALUE
                    endif
                    local integer index = Math.RandomI(lowerBound, higherBound)
                    local boolean value = thistype.GetBoolean(missionKey, key, index)
                    call thistype.RemoveBooleanByIndex(missionKey, key, index)
                    return value
                endmethod
                static method FetchRandomBooleanAll takes integer missionKey, integer key returns boolean
                    return thistype.FetchRandomBoolean(missionKey, key, EventMemory.IntegerKeys.Table.STARTED, thistype.CountBooleans(missionKey, key))
                endmethod
                static method ShuffleBooleans takes integer missionKey, integer key returns nothing
                    local integer count = thistype.CountBooleans(missionKey, key)
                    local integer iteration = count
                    local boolean array temp
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        set temp[thistype.ToArrayIndex(iteration)] = thistype.GetBoolean(missionKey, key, iteration)
                        set iteration = iteration - 1
                    endloop
					call thistype.ClearBooleans(missionKey, key)
                    set iteration = thistype.ToArrayIndex(count)
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local integer index = Math.RandomI(ARRAY_MIN, iteration)
                        call thistype.AddBoolean(missionKey, key, temp[index])
                        set temp[index] = temp[iteration]
                        set iteration = iteration - 1
                    endloop
                endmethod
                static method RemoveBooleanByIndex takes integer missionKey, integer key, integer index returns boolean
                    return thistype.RemoveBoolean(missionKey, key, thistype.GetBoolean(missionKey, key, index))
                endmethod
                
                static method CountBooleansByHandle takes handle source, integer key returns integer
                    return thistype.CountBooleans(GetHandleId(source), key)
                endmethod
                static method GetBooleanByHandle takes handle source, integer key, integer index returns boolean
                    return thistype.GetBoolean(GetHandleId(source), key, index)
                endmethod
                static method RandomBooleanByHandle takes handle handleSource, integer key, integer lowerBound, integer higherBound returns boolean
                    return thistype.RandomBoolean(GetHandleId(handleSource), key, lowerBound, higherBound)
                endmethod
                static method AddBooleanByHandle takes handle source, integer key, boolean value returns boolean
                    return thistype.AddBoolean(GetHandleId(source), key, value)
                endmethod
                static method RemoveBooleanByHandle takes handle source, integer key, boolean value returns boolean
                    return thistype.RemoveBoolean(GetHandleId(source), key, value)
                endmethod
                static method GetIntegerPos takes integer missionKey, integer key, integer value returns integer
                    return thistype.POS_CACHE.Integer.Get(missionKey, thistype.GetReverseKey(key, (value)))
                endmethod
                static method GetIntegerPrio takes integer missionKey, integer key, integer value returns integer
                    return thistype.PRIO_CACHE.Integer.Get(missionKey, thistype.GetReverseKey(key, (value)))
                endmethod
                static method CountIntegers takes integer missionKey, integer key returns integer
                    return (thistype.EMPTY + EventMemoryHead.IntegerKeys.GetInteger(missionKey, key))
                endmethod
                static method IsEmptyInteger takes integer missionKey, integer key returns boolean
                    return (EventMemoryHead.IntegerKeys.GetInteger(missionKey, key) == thistype.EMPTY)
                endmethod
                static method GetInteger takes integer missionKey, integer key, integer index returns integer
                    return EventMemoryHead.IntegerKeys.GetInteger(missionKey, key + index)
                endmethod
                static method GetFirstInteger takes integer missionKey, integer key returns integer
                    return thistype.GetInteger(missionKey, key, thistype.STARTED)
                endmethod
                static method GetLastInteger takes integer missionKey, integer key returns integer
                    return thistype.GetInteger(missionKey, key, thistype.CountIntegers(missionKey, key))
                endmethod
                static method ContainsInteger takes integer missionKey, integer key, integer value returns boolean
                    return (thistype.GetIntegerPos(missionKey, key, value) != HASH_TABLE.Integer.DEFAULT_VALUE)
                endmethod
                static method RandomInteger takes integer missionKey, integer key, integer lowerBound, integer higherBound returns integer
                    return thistype.GetInteger(missionKey, key, Math.RandomI(lowerBound, higherBound))
                endmethod
                static method RandomIntegerAll takes integer missionKey, integer key returns integer
                    return thistype.RandomInteger(missionKey, key, thistype.STARTED, thistype.CountIntegers(missionKey, key))
                endmethod
                static method FetchFirstInteger takes integer missionKey, integer key returns integer
                    local integer count = thistype.CountIntegers(missionKey, key)
                    if (count == thistype.EMPTY) then
                        return HASH_TABLE.Integer.DEFAULT_VALUE
                    endif
                    local integer value = thistype.GetInteger(missionKey, key, count)
                    call thistype.SetCount(missionKey, key, count - 1)
                    call thistype.POS_CACHE.Integer.Remove(missionKey, thistype.GetReverseKey(key, (value)))
                    call EventMemoryHead.IntegerKeys.RemoveInteger(missionKey, key + count)
                    return value
                endmethod
                static method ClearIntegers takes integer missionKey, integer key returns nothing
                    local integer iteration = thistype.CountIntegers(missionKey, key)
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        local integer value = thistype.GetInteger(missionKey, key, iteration)
                        call EventMemoryHead.IntegerKeys.RemoveInteger(missionKey, key + iteration)
                        call thistype.POS_CACHE.Integer.Remove(missionKey, thistype.GetReverseKey(key, (value)))
                        set iteration = iteration - 1
                    endloop
					call thistype.SetCount(missionKey, key, thistype.EMPTY)
                endmethod
                static method AddInteger takes integer missionKey, integer key, integer value returns boolean
                    if thistype.ContainsInteger(missionKey, key, value) then
call DebugEx(I2S(value)+" already in table "+I2S(missionKey)+";"+I2S(key))
call thistype.PrintIntegers(missionKey, key)
                        return false
                    endif
                    local integer count = thistype.CountIntegers(missionKey, key) + 1
    
                    call thistype.SetCount(missionKey, key, count)
                    call thistype.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, (value)), count)
                    call EventMemoryHead.IntegerKeys.SetInteger(missionKey, key + count, value)
                    return (count == thistype.STARTED)
                endmethod
                static method AddIntegerMulti takes integer missionKey, integer key, integer value returns boolean
                    local integer count = thistype.CountIntegers(missionKey, key) + 1
                    call thistype.SetCount(missionKey, key, count)
                    call EventMemoryHead.IntegerKeys.SetInteger(missionKey, key + count, value)
                    return (count == thistype.STARTED)
                endmethod
               
                static method JoinInteger takes integer missionKey, integer key, integer missionKey2, integer key2 returns nothing
                    local integer count = thistype.CountIntegers(missionKey2, key2)
                    if (count == thistype.EMPTY) then
                        return
                    endif
					local integer addCount = 0
                    local integer iteration = thistype.STARTED
                    local integer oldCount = thistype.CountIntegers(missionKey, key)
                    loop
                        local integer value = thistype.GetInteger(missionKey2, key2, iteration)
                        if not thistype.ContainsInteger(missionKey, key, value) then
                            set addCount = addCount + 1
                            call thistype.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, (value)), oldCount + addCount)
                            call EventMemoryHead.IntegerKeys.SetInteger(missionKey, key + oldCount + addCount, value)
                        endif
                        set iteration = iteration + 1
                        exitwhen (iteration > count)
                    endloop
                    call thistype.SetCount(missionKey, key, oldCount + addCount)
                endmethod
                static method PrintIntegers takes integer missionKey, integer key returns nothing
                	local integer count = thistype.CountIntegers(missionKey, key)
					call DebugBufferStart()
                    call DebugBuffer("print table " + I2S(missionKey) + ";" + I2S(key) + ";" + I2S(count))
                    local string missionKeyName = Memory.GetKeyFromValue(missionKey)
                    local string keyName = Memory.GetKeyFromValue(key)
                    if ((missionKeyName != null) or (keyName != null)) then
                        call DebugBuffer(missionKeyName + ";" + keyName)
                    endif
                    call DebugBuffer("--->")
					local integer iteration = count
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        local integer value = thistype.GetInteger(missionKey, key, iteration)
                        local integer pos = thistype.GetIntegerPos(missionKey, key, value)
                        call DebugBuffer(Char.TAB + I2S(value) + " on " + I2S(iteration) + ";" + I2S(pos) + ";" + I2S(thistype.GetReverseKey(key, (value))))
                        if (iteration != pos) then
                            call DebugBuffer("TABLE CORRUPTED!")
                        endif
                        call DebugBuffer(Char.TAB + Char.TAB + Memory.GetKeyFromValue(pos))
                        set iteration = iteration - 1
                    endloop
					
                    call DebugBufferFinish()
                endmethod
                static method RemoveInteger takes integer missionKey, integer key, integer value returns boolean
                    local integer count = thistype.CountIntegers(missionKey, key)
                    local integer reverseKey = thistype.GetReverseKey(key, (value))
                    local integer lastValue = thistype.GetInteger(missionKey, key, count)
                    local integer pos = thistype.POS_CACHE.Integer.Get(missionKey, reverseKey)
                    static if DEBUG then
                        if not thistype.ContainsInteger(missionKey, key, value) then
                            call DebugEx(thistype.NAME + ": " + "cannot remove "+I2S(value) + " from " + I2S(missionKey) + ";" + I2S(key) + " reverseKey: "+I2S(reverseKey))
                            call thistype.PrintIntegers(missionKey, key)
                            return false
                        endif
                    endif
                    call thistype.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, (lastValue)), pos)
                    call EventMemoryHead.IntegerKeys.SetInteger(missionKey, key + pos, lastValue)
                    call thistype.POS_CACHE.Integer.Remove(missionKey, reverseKey)
                    call EventMemoryHead.IntegerKeys.RemoveInteger(missionKey, key + count)
                    set count = count - 1
                    call thistype.SetCount(missionKey, key, count)
                    return (count == thistype.EMPTY)
                endmethod
                static method FetchRandomInteger takes integer missionKey, integer key, integer lowerBound, integer higherBound returns integer
                    local integer count = thistype.CountIntegers(missionKey, key)
                    if (lowerBound > count) then
                        set lowerBound = count
                    endif
                    if (higherBound > count) then
                        set higherBound = count
                    endif
                    if (higherBound <= thistype.EMPTY) then
                        return HASH_TABLE.Integer.DEFAULT_VALUE
                    endif
                    local integer index = Math.RandomI(lowerBound, higherBound)
                    local integer value = thistype.GetInteger(missionKey, key, index)
                    call thistype.RemoveIntegerByIndex(missionKey, key, index)
                    return value
                endmethod
                static method FetchRandomIntegerAll takes integer missionKey, integer key returns integer
                    return thistype.FetchRandomInteger(missionKey, key, EventMemory.IntegerKeys.Table.STARTED, thistype.CountIntegers(missionKey, key))
                endmethod
                static method ShuffleIntegers takes integer missionKey, integer key returns nothing
                    local integer count = thistype.CountIntegers(missionKey, key)
                    local integer iteration = count
                    local integer array temp
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        set temp[thistype.ToArrayIndex(iteration)] = thistype.GetInteger(missionKey, key, iteration)
                        set iteration = iteration - 1
                    endloop
					call thistype.ClearIntegers(missionKey, key)
                    set iteration = thistype.ToArrayIndex(count)
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local integer index = Math.RandomI(ARRAY_MIN, iteration)
                        call thistype.AddInteger(missionKey, key, temp[index])
                        set temp[index] = temp[iteration]
                        set iteration = iteration - 1
                    endloop
                endmethod
                static method RemoveIntegerByIndex takes integer missionKey, integer key, integer index returns boolean
                    return thistype.RemoveInteger(missionKey, key, thistype.GetInteger(missionKey, key, index))
                endmethod
                
                static method CountIntegersByHandle takes handle source, integer key returns integer
                    return thistype.CountIntegers(GetHandleId(source), key)
                endmethod
                static method GetIntegerByHandle takes handle source, integer key, integer index returns integer
                    return thistype.GetInteger(GetHandleId(source), key, index)
                endmethod
                static method RandomIntegerByHandle takes handle handleSource, integer key, integer lowerBound, integer higherBound returns integer
                    return thistype.RandomInteger(GetHandleId(handleSource), key, lowerBound, higherBound)
                endmethod
                static method AddIntegerByHandle takes handle source, integer key, integer value returns boolean
                    return thistype.AddInteger(GetHandleId(source), key, value)
                endmethod
                static method RemoveIntegerByHandle takes handle source, integer key, integer value returns boolean
                    return thistype.RemoveInteger(GetHandleId(source), key, value)
                endmethod
                static method GetRealPos takes integer missionKey, integer key, real value returns integer
                    return thistype.POS_CACHE.Integer.Get(missionKey, thistype.GetReverseKey(key, Real.ToInt(value)))
                endmethod
                static method GetRealPrio takes integer missionKey, integer key, real value returns integer
                    return thistype.PRIO_CACHE.Integer.Get(missionKey, thistype.GetReverseKey(key, Real.ToInt(value)))
                endmethod
                static method CountReals takes integer missionKey, integer key returns integer
                    return (thistype.EMPTY + EventMemoryHead.IntegerKeys.GetInteger(missionKey, key))
                endmethod
                static method IsEmptyReal takes integer missionKey, integer key returns boolean
                    return (EventMemoryHead.IntegerKeys.GetInteger(missionKey, key) == thistype.EMPTY)
                endmethod
                static method GetReal takes integer missionKey, integer key, integer index returns real
                    return EventMemoryHead.IntegerKeys.GetReal(missionKey, key + index)
                endmethod
                static method GetFirstReal takes integer missionKey, integer key returns real
                    return thistype.GetReal(missionKey, key, thistype.STARTED)
                endmethod
                static method GetLastReal takes integer missionKey, integer key returns real
                    return thistype.GetReal(missionKey, key, thistype.CountReals(missionKey, key))
                endmethod
                static method ContainsReal takes integer missionKey, integer key, real value returns boolean
                    return (thistype.GetRealPos(missionKey, key, value) != HASH_TABLE.Integer.DEFAULT_VALUE)
                endmethod
                static method RandomReal takes integer missionKey, integer key, integer lowerBound, integer higherBound returns real
                    return thistype.GetReal(missionKey, key, Math.RandomI(lowerBound, higherBound))
                endmethod
                static method RandomRealAll takes integer missionKey, integer key returns real
                    return thistype.RandomReal(missionKey, key, thistype.STARTED, thistype.CountReals(missionKey, key))
                endmethod
                static method FetchFirstReal takes integer missionKey, integer key returns real
                    local integer count = thistype.CountReals(missionKey, key)
                    if (count == thistype.EMPTY) then
                        return HASH_TABLE.Real.DEFAULT_VALUE
                    endif
                    local real value = thistype.GetReal(missionKey, key, count)
                    call thistype.SetCount(missionKey, key, count - 1)
                    call thistype.POS_CACHE.Real.Remove(missionKey, thistype.GetReverseKey(key, Real.ToInt(value)))
                    call EventMemoryHead.IntegerKeys.RemoveReal(missionKey, key + count)
                    return value
                endmethod
                static method ClearReals takes integer missionKey, integer key returns nothing
                    local integer iteration = thistype.CountReals(missionKey, key)
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        local real value = thistype.GetReal(missionKey, key, iteration)
                        call EventMemoryHead.IntegerKeys.RemoveReal(missionKey, key + iteration)
                        call thistype.POS_CACHE.Integer.Remove(missionKey, thistype.GetReverseKey(key, Real.ToInt(value)))
                        set iteration = iteration - 1
                    endloop
					call thistype.SetCount(missionKey, key, thistype.EMPTY)
                endmethod
                static method AddReal takes integer missionKey, integer key, real value returns boolean
                    if thistype.ContainsReal(missionKey, key, value) then
call DebugEx(R2S(value)+" already in table "+I2S(missionKey)+";"+I2S(key))
call thistype.PrintReals(missionKey, key)
                        return false
                    endif
                    local integer count = thistype.CountReals(missionKey, key) + 1
    
                    call thistype.SetCount(missionKey, key, count)
                    call thistype.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, Real.ToInt(value)), count)
                    call EventMemoryHead.IntegerKeys.SetReal(missionKey, key + count, value)
                    return (count == thistype.STARTED)
                endmethod
                static method AddRealMulti takes integer missionKey, integer key, real value returns boolean
                    local integer count = thistype.CountReals(missionKey, key) + 1
                    call thistype.SetCount(missionKey, key, count)
                    call EventMemoryHead.IntegerKeys.SetReal(missionKey, key + count, value)
                    return (count == thistype.STARTED)
                endmethod
               
                static method JoinReal takes integer missionKey, integer key, integer missionKey2, integer key2 returns nothing
                    local integer count = thistype.CountReals(missionKey2, key2)
                    if (count == thistype.EMPTY) then
                        return
                    endif
					local integer addCount = 0
                    local integer iteration = thistype.STARTED
                    local integer oldCount = thistype.CountReals(missionKey, key)
                    loop
                        local real value = thistype.GetReal(missionKey2, key2, iteration)
                        if not thistype.ContainsReal(missionKey, key, value) then
                            set addCount = addCount + 1
                            call thistype.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, Real.ToInt(value)), oldCount + addCount)
                            call EventMemoryHead.IntegerKeys.SetReal(missionKey, key + oldCount + addCount, value)
                        endif
                        set iteration = iteration + 1
                        exitwhen (iteration > count)
                    endloop
                    call thistype.SetCount(missionKey, key, oldCount + addCount)
                endmethod
                static method PrintReals takes integer missionKey, integer key returns nothing
                	local integer count = thistype.CountReals(missionKey, key)
					call DebugBufferStart()
                    call DebugBuffer("print table " + I2S(missionKey) + ";" + I2S(key) + ";" + I2S(count))
                    local string missionKeyName = Memory.GetKeyFromValue(missionKey)
                    local string keyName = Memory.GetKeyFromValue(key)
                    if ((missionKeyName != null) or (keyName != null)) then
                        call DebugBuffer(missionKeyName + ";" + keyName)
                    endif
                    call DebugBuffer("--->")
					local integer iteration = count
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        local real value = thistype.GetReal(missionKey, key, iteration)
                        local integer pos = thistype.GetRealPos(missionKey, key, value)
                        call DebugBuffer(Char.TAB + R2S(value) + " on " + I2S(iteration) + ";" + I2S(pos) + ";" + I2S(thistype.GetReverseKey(key, Real.ToInt(value))))
                        if (iteration != pos) then
                            call DebugBuffer("TABLE CORRUPTED!")
                        endif
                        call DebugBuffer(Char.TAB + Char.TAB + Memory.GetKeyFromValue(pos))
                        set iteration = iteration - 1
                    endloop
					
                    call DebugBufferFinish()
                endmethod
                static method RemoveReal takes integer missionKey, integer key, real value returns boolean
                    local integer count = thistype.CountReals(missionKey, key)
                    local integer reverseKey = thistype.GetReverseKey(key, Real.ToInt(value))
                    local real lastValue = thistype.GetReal(missionKey, key, count)
                    local integer pos = thistype.POS_CACHE.Integer.Get(missionKey, reverseKey)
                    static if DEBUG then
                        if not thistype.ContainsReal(missionKey, key, value) then
                            call DebugEx(thistype.NAME + ": " + "cannot remove "+R2S(value) + " from " + I2S(missionKey) + ";" + I2S(key) + " reverseKey: "+I2S(reverseKey))
                            call thistype.PrintReals(missionKey, key)
                            return false
                        endif
                    endif
                    call thistype.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, Real.ToInt(lastValue)), pos)
                    call EventMemoryHead.IntegerKeys.SetReal(missionKey, key + pos, lastValue)
                    call thistype.POS_CACHE.Integer.Remove(missionKey, reverseKey)
                    call EventMemoryHead.IntegerKeys.RemoveReal(missionKey, key + count)
                    set count = count - 1
                    call thistype.SetCount(missionKey, key, count)
                    return (count == thistype.EMPTY)
                endmethod
                static method FetchRandomReal takes integer missionKey, integer key, integer lowerBound, integer higherBound returns real
                    local integer count = thistype.CountReals(missionKey, key)
                    if (lowerBound > count) then
                        set lowerBound = count
                    endif
                    if (higherBound > count) then
                        set higherBound = count
                    endif
                    if (higherBound <= thistype.EMPTY) then
                        return HASH_TABLE.Real.DEFAULT_VALUE
                    endif
                    local integer index = Math.RandomI(lowerBound, higherBound)
                    local real value = thistype.GetReal(missionKey, key, index)
                    call thistype.RemoveRealByIndex(missionKey, key, index)
                    return value
                endmethod
                static method FetchRandomRealAll takes integer missionKey, integer key returns real
                    return thistype.FetchRandomReal(missionKey, key, EventMemory.IntegerKeys.Table.STARTED, thistype.CountReals(missionKey, key))
                endmethod
                static method ShuffleReals takes integer missionKey, integer key returns nothing
                    local integer count = thistype.CountReals(missionKey, key)
                    local integer iteration = count
                    local real array temp
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        set temp[thistype.ToArrayIndex(iteration)] = thistype.GetReal(missionKey, key, iteration)
                        set iteration = iteration - 1
                    endloop
					call thistype.ClearReals(missionKey, key)
                    set iteration = thistype.ToArrayIndex(count)
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local integer index = Math.RandomI(ARRAY_MIN, iteration)
                        call thistype.AddReal(missionKey, key, temp[index])
                        set temp[index] = temp[iteration]
                        set iteration = iteration - 1
                    endloop
                endmethod
                static method RemoveRealByIndex takes integer missionKey, integer key, integer index returns boolean
                    return thistype.RemoveReal(missionKey, key, thistype.GetReal(missionKey, key, index))
                endmethod
                
                static method CountRealsByHandle takes handle source, integer key returns integer
                    return thistype.CountReals(GetHandleId(source), key)
                endmethod
                static method GetRealByHandle takes handle source, integer key, integer index returns real
                    return thistype.GetReal(GetHandleId(source), key, index)
                endmethod
                static method RandomRealByHandle takes handle handleSource, integer key, integer lowerBound, integer higherBound returns real
                    return thistype.RandomReal(GetHandleId(handleSource), key, lowerBound, higherBound)
                endmethod
                static method AddRealByHandle takes handle source, integer key, real value returns boolean
                    return thistype.AddReal(GetHandleId(source), key, value)
                endmethod
                static method RemoveRealByHandle takes handle source, integer key, real value returns boolean
                    return thistype.RemoveReal(GetHandleId(source), key, value)
                endmethod
                static method GetStringPos takes integer missionKey, integer key, string value returns integer
                    return thistype.POS_CACHE.Integer.Get(missionKey, thistype.GetReverseKey(key, String.ToIntHash(value)))
                endmethod
                static method GetStringPrio takes integer missionKey, integer key, string value returns integer
                    return thistype.PRIO_CACHE.Integer.Get(missionKey, thistype.GetReverseKey(key, String.ToIntHash(value)))
                endmethod
                static method CountStrings takes integer missionKey, integer key returns integer
                    return (thistype.EMPTY + EventMemoryHead.IntegerKeys.GetInteger(missionKey, key))
                endmethod
                static method IsEmptyString takes integer missionKey, integer key returns boolean
                    return (EventMemoryHead.IntegerKeys.GetInteger(missionKey, key) == thistype.EMPTY)
                endmethod
                static method GetString takes integer missionKey, integer key, integer index returns string
                    return EventMemoryHead.IntegerKeys.GetString(missionKey, key + index)
                endmethod
                static method GetFirstString takes integer missionKey, integer key returns string
                    return thistype.GetString(missionKey, key, thistype.STARTED)
                endmethod
                static method GetLastString takes integer missionKey, integer key returns string
                    return thistype.GetString(missionKey, key, thistype.CountStrings(missionKey, key))
                endmethod
                static method ContainsString takes integer missionKey, integer key, string value returns boolean
                    return (thistype.GetStringPos(missionKey, key, value) != HASH_TABLE.Integer.DEFAULT_VALUE)
                endmethod
                static method RandomString takes integer missionKey, integer key, integer lowerBound, integer higherBound returns string
                    return thistype.GetString(missionKey, key, Math.RandomI(lowerBound, higherBound))
                endmethod
                static method RandomStringAll takes integer missionKey, integer key returns string
                    return thistype.RandomString(missionKey, key, thistype.STARTED, thistype.CountStrings(missionKey, key))
                endmethod
                static method FetchFirstString takes integer missionKey, integer key returns string
                    local integer count = thistype.CountStrings(missionKey, key)
                    if (count == thistype.EMPTY) then
                        return HASH_TABLE.String.DEFAULT_VALUE
                    endif
                    local string value = thistype.GetString(missionKey, key, count)
                    call thistype.SetCount(missionKey, key, count - 1)
                    call thistype.POS_CACHE.String.Remove(missionKey, thistype.GetReverseKey(key, String.ToIntHash(value)))
                    call EventMemoryHead.IntegerKeys.RemoveString(missionKey, key + count)
                    return value
                endmethod
                static method ClearStrings takes integer missionKey, integer key returns nothing
                    local integer iteration = thistype.CountStrings(missionKey, key)
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        local string value = thistype.GetString(missionKey, key, iteration)
                        call EventMemoryHead.IntegerKeys.RemoveString(missionKey, key + iteration)
                        call thistype.POS_CACHE.Integer.Remove(missionKey, thistype.GetReverseKey(key, String.ToIntHash(value)))
                        set iteration = iteration - 1
                    endloop
					call thistype.SetCount(missionKey, key, thistype.EMPTY)
                endmethod
                static method AddString takes integer missionKey, integer key, string value returns boolean
                    if thistype.ContainsString(missionKey, key, value) then
call DebugEx((value)+" already in table "+I2S(missionKey)+";"+I2S(key))
call thistype.PrintStrings(missionKey, key)
                        return false
                    endif
                    local integer count = thistype.CountStrings(missionKey, key) + 1
    
                    call thistype.SetCount(missionKey, key, count)
                    call thistype.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, String.ToIntHash(value)), count)
                    call EventMemoryHead.IntegerKeys.SetString(missionKey, key + count, value)
                    return (count == thistype.STARTED)
                endmethod
                static method AddStringMulti takes integer missionKey, integer key, string value returns boolean
                    local integer count = thistype.CountStrings(missionKey, key) + 1
                    call thistype.SetCount(missionKey, key, count)
                    call EventMemoryHead.IntegerKeys.SetString(missionKey, key + count, value)
                    return (count == thistype.STARTED)
                endmethod
               
                static method JoinString takes integer missionKey, integer key, integer missionKey2, integer key2 returns nothing
                    local integer count = thistype.CountStrings(missionKey2, key2)
                    if (count == thistype.EMPTY) then
                        return
                    endif
					local integer addCount = 0
                    local integer iteration = thistype.STARTED
                    local integer oldCount = thistype.CountStrings(missionKey, key)
                    loop
                        local string value = thistype.GetString(missionKey2, key2, iteration)
                        if not thistype.ContainsString(missionKey, key, value) then
                            set addCount = addCount + 1
                            call thistype.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, String.ToIntHash(value)), oldCount + addCount)
                            call EventMemoryHead.IntegerKeys.SetString(missionKey, key + oldCount + addCount, value)
                        endif
                        set iteration = iteration + 1
                        exitwhen (iteration > count)
                    endloop
                    call thistype.SetCount(missionKey, key, oldCount + addCount)
                endmethod
                static method PrintStrings takes integer missionKey, integer key returns nothing
                	local integer count = thistype.CountStrings(missionKey, key)
					call DebugBufferStart()
                    call DebugBuffer("print table " + I2S(missionKey) + ";" + I2S(key) + ";" + I2S(count))
                    local string missionKeyName = Memory.GetKeyFromValue(missionKey)
                    local string keyName = Memory.GetKeyFromValue(key)
                    if ((missionKeyName != null) or (keyName != null)) then
                        call DebugBuffer(missionKeyName + ";" + keyName)
                    endif
                    call DebugBuffer("--->")
					local integer iteration = count
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        local string value = thistype.GetString(missionKey, key, iteration)
                        local integer pos = thistype.GetStringPos(missionKey, key, value)
                        call DebugBuffer(Char.TAB + (value) + " on " + I2S(iteration) + ";" + I2S(pos) + ";" + I2S(thistype.GetReverseKey(key, String.ToIntHash(value))))
                        if (iteration != pos) then
                            call DebugBuffer("TABLE CORRUPTED!")
                        endif
                        call DebugBuffer(Char.TAB + Char.TAB + Memory.GetKeyFromValue(pos))
                        set iteration = iteration - 1
                    endloop
					
                    call DebugBufferFinish()
                endmethod
                static method RemoveString takes integer missionKey, integer key, string value returns boolean
                    local integer count = thistype.CountStrings(missionKey, key)
                    local integer reverseKey = thistype.GetReverseKey(key, String.ToIntHash(value))
                    local string lastValue = thistype.GetString(missionKey, key, count)
                    local integer pos = thistype.POS_CACHE.Integer.Get(missionKey, reverseKey)
                    static if DEBUG then
                        if not thistype.ContainsString(missionKey, key, value) then
                            call DebugEx(thistype.NAME + ": " + "cannot remove "+(value) + " from " + I2S(missionKey) + ";" + I2S(key) + " reverseKey: "+I2S(reverseKey))
                            call thistype.PrintStrings(missionKey, key)
                            return false
                        endif
                    endif
                    call thistype.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, String.ToIntHash(lastValue)), pos)
                    call EventMemoryHead.IntegerKeys.SetString(missionKey, key + pos, lastValue)
                    call thistype.POS_CACHE.Integer.Remove(missionKey, reverseKey)
                    call EventMemoryHead.IntegerKeys.RemoveString(missionKey, key + count)
                    set count = count - 1
                    call thistype.SetCount(missionKey, key, count)
                    return (count == thistype.EMPTY)
                endmethod
                static method FetchRandomString takes integer missionKey, integer key, integer lowerBound, integer higherBound returns string
                    local integer count = thistype.CountStrings(missionKey, key)
                    if (lowerBound > count) then
                        set lowerBound = count
                    endif
                    if (higherBound > count) then
                        set higherBound = count
                    endif
                    if (higherBound <= thistype.EMPTY) then
                        return HASH_TABLE.String.DEFAULT_VALUE
                    endif
                    local integer index = Math.RandomI(lowerBound, higherBound)
                    local string value = thistype.GetString(missionKey, key, index)
                    call thistype.RemoveStringByIndex(missionKey, key, index)
                    return value
                endmethod
                static method FetchRandomStringAll takes integer missionKey, integer key returns string
                    return thistype.FetchRandomString(missionKey, key, EventMemory.IntegerKeys.Table.STARTED, thistype.CountStrings(missionKey, key))
                endmethod
                static method ShuffleStrings takes integer missionKey, integer key returns nothing
                    local integer count = thistype.CountStrings(missionKey, key)
                    local integer iteration = count
                    local string array temp
                    loop
                        exitwhen (iteration < thistype.STARTED)
                        set temp[thistype.ToArrayIndex(iteration)] = thistype.GetString(missionKey, key, iteration)
                        set iteration = iteration - 1
                    endloop
					call thistype.ClearStrings(missionKey, key)
                    set iteration = thistype.ToArrayIndex(count)
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local integer index = Math.RandomI(ARRAY_MIN, iteration)
                        call thistype.AddString(missionKey, key, temp[index])
                        set temp[index] = temp[iteration]
                        set iteration = iteration - 1
                    endloop
                endmethod
                static method RemoveStringByIndex takes integer missionKey, integer key, integer index returns boolean
                    return thistype.RemoveString(missionKey, key, thistype.GetString(missionKey, key, index))
                endmethod
                
                static method CountStringsByHandle takes handle source, integer key returns integer
                    return thistype.CountStrings(GetHandleId(source), key)
                endmethod
                static method GetStringByHandle takes handle source, integer key, integer index returns string
                    return thistype.GetString(GetHandleId(source), key, index)
                endmethod
                static method RandomStringByHandle takes handle handleSource, integer key, integer lowerBound, integer higherBound returns string
                    return thistype.RandomString(GetHandleId(handleSource), key, lowerBound, higherBound)
                endmethod
                static method AddStringByHandle takes handle source, integer key, string value returns boolean
                    return thistype.AddString(GetHandleId(source), key, value)
                endmethod
                static method RemoveStringByHandle takes handle source, integer key, string value returns boolean
                    return thistype.RemoveString(GetHandleId(source), key, value)
                endmethod
                static method AddIntegerSorted takes integer missionKey, integer key, integer value, real sortValue returns boolean
                    local integer count = thistype.CountIntegers(missionKey, key)
                    local integer iteration = count
                    loop
                        exitwhen (iteration == thistype.EMPTY)
                        exitwhen (value > thistype.GetInteger(missionKey, key, iteration))
                        set iteration = iteration - 1
                    endloop
					local integer index
                    if (iteration == thistype.EMPTY) then
                        set index = thistype.STARTED
                    endif
                    set count = count + 1
                    set iteration = index + 1
                    call thistype.SetCount(missionKey, key, count)
                    loop
                        exitwhen (iteration > count)
                        local integer otherValue = thistype.GetInteger(missionKey, key, iteration - 1)
                        call thistype.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, (otherValue)), iteration)
                        call EventMemoryHead.IntegerKeys.SetInteger(missionKey, key + iteration, otherValue)
                        set iteration = iteration + 1
                    endloop
                    call thistype.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, (value)), index)
                    call EventMemoryHead.IntegerKeys.SetInteger(missionKey, key + index, value)
                    return (count == thistype.STARTED)
                endmethod
                static method RemoveIntegerSorted takes integer missionKey, integer key, integer value returns boolean
                    local integer count = thistype.CountIntegers(missionKey, key) - 1
                    local integer reverseKey = thistype.GetReverseKey(key, (value))
                    local integer index = thistype.POS_CACHE.Integer.Get(missionKey, reverseKey)
                    static if DEBUG then
                        if not thistype.ContainsInteger(missionKey, key, value) then
                            call DebugEx(thistype.NAME + ": " + "cannot remove " + I2S(value) + " from " + I2S(missionKey) + ";" + I2S(key))
                            return false
                        endif
                    endif
                    call thistype.POS_CACHE.Integer.Remove(missionKey, reverseKey)
                    call EventMemoryHead.IntegerKeys.RemoveInteger(missionKey, key + index)
                    set count = count - 1
                    local integer iteration = index
                    loop
                        exitwhen (iteration > count)
                        set value = thistype.GetInteger(missionKey, key, iteration + 1)
                        call thistype.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, (value)), iteration)
                        call EventMemoryHead.IntegerKeys.SetInteger(missionKey, key + iteration, value)
                        set iteration = iteration - 1
                    endloop
                    call thistype.SetCount(missionKey, key, count)
                    return (count == thistype.EMPTY)
                endmethod
                static method AddRealSorted takes integer missionKey, integer key, real value, real sortValue returns boolean
                    local integer count = thistype.CountReals(missionKey, key)
                    local integer iteration = count
                    loop
                        exitwhen (iteration == thistype.EMPTY)
                        exitwhen (value > thistype.GetReal(missionKey, key, iteration))
                        set iteration = iteration - 1
                    endloop
					local integer index
                    if (iteration == thistype.EMPTY) then
                        set index = thistype.STARTED
                    endif
                    set count = count + 1
                    set iteration = index + 1
                    call thistype.SetCount(missionKey, key, count)
                    loop
                        exitwhen (iteration > count)
                        local real otherValue = thistype.GetReal(missionKey, key, iteration - 1)
                        call thistype.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, Real.ToInt(otherValue)), iteration)
                        call EventMemoryHead.IntegerKeys.SetReal(missionKey, key + iteration, otherValue)
                        set iteration = iteration + 1
                    endloop
                    call thistype.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, Real.ToInt(value)), index)
                    call EventMemoryHead.IntegerKeys.SetReal(missionKey, key + index, value)
                    return (count == thistype.STARTED)
                endmethod
                static method RemoveRealSorted takes integer missionKey, integer key, real value returns boolean
                    local integer count = thistype.CountReals(missionKey, key) - 1
                    local integer reverseKey = thistype.GetReverseKey(key, Real.ToInt(value))
                    local integer index = thistype.POS_CACHE.Integer.Get(missionKey, reverseKey)
                    static if DEBUG then
                        if not thistype.ContainsReal(missionKey, key, value) then
                            call DebugEx(thistype.NAME + ": " + "cannot remove " + R2S(value) + " from " + I2S(missionKey) + ";" + I2S(key))
                            return false
                        endif
                    endif
                    call thistype.POS_CACHE.Integer.Remove(missionKey, reverseKey)
                    call EventMemoryHead.IntegerKeys.RemoveReal(missionKey, key + index)
                    set count = count - 1
                    local integer iteration = index
                    loop
                        exitwhen (iteration > count)
                        set value = thistype.GetReal(missionKey, key, iteration + 1)
                        call thistype.POS_CACHE.Integer.Set(missionKey, thistype.GetReverseKey(key, Real.ToInt(value)), iteration)
                        call EventMemoryHead.IntegerKeys.SetReal(missionKey, key + iteration, value)
                        set iteration = iteration - 1
                    endloop
                    call thistype.SetCount(missionKey, key, count)
                    return (count == thistype.EMPTY)
                endmethod
            static method Clear takes integer missionKey, integer key returns nothing
                call thistype.ClearIntegers(missionKey, key)
            endmethod
        	static method RemoveChild takes integer missionKey returns nothing
            	call EventMemoryHead.IntegerKeys.RemoveChild(missionKey)
            	call thistype.POS_CACHE.RemoveChild(missionKey)
            	call thistype.PRIO_CACHE.RemoveChild(missionKey)
        	endmethod
            static method Init takes nothing returns nothing
                set thistype.POS_CACHE = HashTable.Create()
                set thistype.PRIO_CACHE = HashTable.Create()
            endmethod
        endstruct
    endscope
    public struct StructIntegerKeys
        implement Allocation
        implement List
        
    static FolderIntegerKeys_StructD2 D2 = NULL
    static FolderIntegerKeys_StructTable Table = NULL
        static method RemoveChild takes integer missionKey returns nothing
            call EventMemoryHead.IntegerKeys.RemoveChild(missionKey)
        endmethod
            static method ContainsBoolean takes integer missionKey, integer key returns boolean
                return EventMemoryHead.IntegerKeys.ContainsBoolean(missionKey, key)
            endmethod
            static method GetBoolean takes integer missionKey, integer key returns boolean
                return EventMemoryHead.IntegerKeys.GetBoolean(missionKey, key)
            endmethod
            static method GetBooleanByHandle takes handle handleSource, integer key returns boolean
                return EventMemoryHead.IntegerKeys.GetBooleanByHandle(handleSource, key)
            endmethod
            static method SetBoolean takes integer missionKey, integer key, boolean value returns nothing
                call EventMemoryHead.IntegerKeys.SetBoolean(missionKey, key, value)
            endmethod
            static method SetBooleanByHandle takes handle handleSource, integer key, boolean value returns nothing
                call thistype.SetBoolean(GetHandleId(handleSource), key, value)
            endmethod
            static method RemoveBoolean takes integer missionKey, integer key returns nothing
                call EventMemoryHead.IntegerKeys.RemoveBoolean(missionKey, key)
            endmethod
            static method RemoveBooleanByHandle takes handle handleSource, integer key returns nothing
                call EventMemoryHead.IntegerKeys.RemoveBooleanByHandle(handleSource, key)
            endmethod
            static method ContainsInteger takes integer missionKey, integer key returns boolean
                return EventMemoryHead.IntegerKeys.ContainsInteger(missionKey, key)
            endmethod
            static method GetInteger takes integer missionKey, integer key returns integer
                return EventMemoryHead.IntegerKeys.GetInteger(missionKey, key)
            endmethod
            static method GetIntegerByHandle takes handle handleSource, integer key returns integer
                return EventMemoryHead.IntegerKeys.GetIntegerByHandle(handleSource, key)
            endmethod
            static method SetInteger takes integer missionKey, integer key, integer value returns nothing
                call EventMemoryHead.IntegerKeys.SetInteger(missionKey, key, value)
            endmethod
            static method SetIntegerByHandle takes handle handleSource, integer key, integer value returns nothing
                call thistype.SetInteger(GetHandleId(handleSource), key, value)
            endmethod
            static method RemoveInteger takes integer missionKey, integer key returns nothing
                call EventMemoryHead.IntegerKeys.RemoveInteger(missionKey, key)
            endmethod
            static method RemoveIntegerByHandle takes handle handleSource, integer key returns nothing
                call EventMemoryHead.IntegerKeys.RemoveIntegerByHandle(handleSource, key)
            endmethod
            static method ContainsReal takes integer missionKey, integer key returns boolean
                return EventMemoryHead.IntegerKeys.ContainsReal(missionKey, key)
            endmethod
            static method GetReal takes integer missionKey, integer key returns real
                return EventMemoryHead.IntegerKeys.GetReal(missionKey, key)
            endmethod
            static method GetRealByHandle takes handle handleSource, integer key returns real
                return EventMemoryHead.IntegerKeys.GetRealByHandle(handleSource, key)
            endmethod
            static method SetReal takes integer missionKey, integer key, real value returns nothing
                call EventMemoryHead.IntegerKeys.SetReal(missionKey, key, value)
            endmethod
            static method SetRealByHandle takes handle handleSource, integer key, real value returns nothing
                call thistype.SetReal(GetHandleId(handleSource), key, value)
            endmethod
            static method RemoveReal takes integer missionKey, integer key returns nothing
                call EventMemoryHead.IntegerKeys.RemoveReal(missionKey, key)
            endmethod
            static method RemoveRealByHandle takes handle handleSource, integer key returns nothing
                call EventMemoryHead.IntegerKeys.RemoveRealByHandle(handleSource, key)
            endmethod
            static method ContainsString takes integer missionKey, integer key returns boolean
                return EventMemoryHead.IntegerKeys.ContainsString(missionKey, key)
            endmethod
            static method GetString takes integer missionKey, integer key returns string
                return EventMemoryHead.IntegerKeys.GetString(missionKey, key)
            endmethod
            static method GetStringByHandle takes handle handleSource, integer key returns string
                return EventMemoryHead.IntegerKeys.GetStringByHandle(handleSource, key)
            endmethod
            static method SetString takes integer missionKey, integer key, string value returns nothing
                call EventMemoryHead.IntegerKeys.SetString(missionKey, key, value)
            endmethod
            static method SetStringByHandle takes handle handleSource, integer key, string value returns nothing
                call thistype.SetString(GetHandleId(handleSource), key, value)
            endmethod
            static method RemoveString takes integer missionKey, integer key returns nothing
                call EventMemoryHead.IntegerKeys.RemoveString(missionKey, key)
            endmethod
            static method RemoveStringByHandle takes handle handleSource, integer key returns nothing
                call EventMemoryHead.IntegerKeys.RemoveStringByHandle(handleSource, key)
            endmethod
        static method Init takes nothing returns nothing
            call thistype.D2.Init()
            call thistype.Table.Init()
        endmethod
    endstruct
endscope
    struct EventMemory
    static FolderEventMemory_StructIntegerKeys IntegerKeys = NULL
    initMethod Init of Header_Event
        call EventMemoryHead.Init()
        call thistype.IntegerKeys.Init()
    endmethod
endstruct
    globals
        EventPair EVENT_PAIR = STRUCT_BASE
    endglobals
    struct EventPair
        implement Allocation
        implement List
        
    static key GetKeyMacro_PARTNER_KEY
    static constant integer PARTNER_KEY = Math.Integer.MIN + GetKeyMacro_PARTNER_KEY
    Event negativeEvent
    Event positiveEvent
    BoolExpr startConditions
    method GetStartConditions takes nothing returns BoolExpr
        return this.startConditions
    endmethod
    method SetStartConditions takes BoolExpr value returns nothing
        set this.startConditions = value
    endmethod
    method GetNegativeEvent takes nothing returns Event
        return this.negativeEvent
    endmethod
    method GetPositiveEvent takes nothing returns Event
        return this.positiveEvent
    endmethod
    static method GetPartnerEvent takes Event source returns Event
        return source.Data.Integer.Get(PARTNER_KEY)
    endmethod
    method SetNegativeEvent takes Event value returns nothing
        local Event positiveEvent = this.GetPositiveEvent()
        set this.negativeEvent = value
        if (positiveEvent != NULL) then
            call positiveEvent.Data.Integer.Set(PARTNER_KEY, value)
            call value.Data.Integer.Set(PARTNER_KEY, positiveEvent)
        endif
    endmethod
    method SetPositiveEvent takes Event value returns nothing
        local Event negativeEvent = this.GetNegativeEvent()
        set this.positiveEvent = value
        if (negativeEvent != NULL) then
            call negativeEvent.Data.Integer.Set(PARTNER_KEY, value)
            call value.Data.Integer.Set(PARTNER_KEY, negativeEvent)
        endif
    endmethod
    static method Create takes Event negativeEvent, Event positiveEvent, BoolExpr startConditions returns thistype
        local thistype this = thistype.allocate()
        set this.negativeEvent = NULL
        set this.positiveEvent = NULL
        call this.SetNegativeEvent(negativeEvent)
        call this.SetPositiveEvent(positiveEvent)
        call this.SetStartConditions(startConditions)
        return this
    endmethod
endstruct
    scope FolderEventCombination
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    public struct StructBoolean
        implement Allocation
        implement List
        
    method Get takes integer key returns boolean
        return EventCombination(this).Data.table.IntegerKeys.GetBoolean(EventCombination(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call EventCombination(this).Data.table.IntegerKeys.RemoveBoolean(EventCombination(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call EventCombination(this).Data.table.IntegerKeys.SetBoolean(EventCombination(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return EventCombination(this).Data.table.IntegerKeys.Table.ContainsInteger(EventCombination(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return EventCombination(this).Data.table.IntegerKeys.Table.CountIntegers(EventCombination(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return EventCombination(this).Data.table.IntegerKeys.Table.IsEmptyInteger(EventCombination(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return EventCombination(this).Data.table.IntegerKeys.Table.GetInteger(EventCombination(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return EventCombination(this).Data.table.IntegerKeys.Table.GetFirstInteger(EventCombination(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return EventCombination(this).Data.table.IntegerKeys.Table.GetLastInteger(EventCombination(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call EventCombination(this).Data.table.IntegerKeys.Table.Clear(EventCombination(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return EventCombination(this).Data.table.IntegerKeys.Table.FetchFirstInteger(EventCombination(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return EventCombination(this).Data.table.IntegerKeys.Table.RemoveInteger(EventCombination(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return EventCombination(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(EventCombination(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return EventCombination(this).Data.table.IntegerKeys.Table.AddInteger(EventCombination(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return EventCombination(this).Data.table.IntegerKeys.Table.AddIntegerMulti(EventCombination(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call EventCombination(this).Data.table.IntegerKeys.Table.JoinInteger(EventCombination(this).Id.Get(), key, EventCombination(other).Data.table, EventCombination(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return EventCombination(this).Data.table.IntegerKeys.Table.RandomInteger(EventCombination(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call EventCombination(this).Data.table.IntegerKeys.Table.ShuffleIntegers(EventCombination(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call EventCombination(this).Data.table.IntegerKeys.Table.PrintIntegers(EventCombination(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return EventCombination(this).Data.table.IntegerKeys.GetInteger(EventCombination(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call EventCombination(this).Data.table.IntegerKeys.RemoveInteger(EventCombination(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call EventCombination(this).Data.table.IntegerKeys.SetInteger(EventCombination(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(EventCombination(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject EventCombination.Allocation.deallocate_demount.hook
		call EventCombination(this).Data.Destroy()
	endinject
	inject EventCombination.Allocation.allocate_mount.hook
		call EventCombination(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructRemainingEventsAmount
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
        method Get takes integer subjectId returns integer
            return Memory.IntegerKeys.GetInteger(subjectId, KEY_ARRAY_DETAIL + this)
        endmethod
        method Event_SubjectRemove takes integer subjectId returns nothing
            call Memory.IntegerKeys.RemoveInteger(subjectId, KEY_ARRAY_DETAIL + this)
        endmethod
        method Set takes integer subjectId, integer value returns nothing
            call Memory.IntegerKeys.SetInteger(subjectId, KEY_ARRAY_DETAIL + this, value)
        endmethod
        method Subtract takes integer subjectId returns boolean
            local integer value = this.Get(subjectId) - 1
            call this.Set(subjectId, value)
            return (value == 0)
        endmethod
        method Add takes integer subjectId returns boolean
            local integer value = this.Get(subjectId) + 1
            call this.Set(subjectId, value)
            return (value == 1)
        endmethod
    endstruct
    public struct StructEvents
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        static method GetParent takes Event whichEvent returns EventCombination
            return whichEvent.Data.Integer.Get(KEY)
        endmethod
        method Count takes nothing returns integer
            return EventCombination(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns Event
            return EventCombination(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            call EventCombination(this).Data.Integer.Table.Remove(KEY_ARRAY, whichEvent)
            call whichEvent.Data.Integer.Remove(KEY)
        endmethod
        method Event_Destroy takes nothing returns nothing
            local integer iteration = this.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                call this.Remove(this.Get(iteration))
                set iteration = iteration - 1
            endloop
        endmethod
        method Event_PairAdd takes EventPair value returns nothing
            call value.GetNegativeEvent().Data.Integer.Set(KEY, this)
            call value.GetPositiveEvent().Data.Integer.Set(KEY, this)
        endmethod
        eventMethod Event_Passive
            local Event whichEvent = Event.GetTrigger()
            local EventCombination parent = thistype.GetParent(whichEvent)
            if (parent.RemainingEventsAmount.Get(params.GetSubjectId()) == 0) then
                call parent.Run(whichEvent)
            endif
        endmethod
        method Create takes EventType whichType, EventPriority priority, BoolExpr whichConditions returns Event
            local Event result = Event.Create(whichType, priority, function thistype.Event_Passive)
            call result.Data.Integer.Set(KEY, this)
            call EventCombination(this).Data.Integer.Table.Add(KEY_ARRAY, result)
            call result.SetConditions(whichConditions)
            return result
        endmethod
    endstruct
    public struct StructSubjects
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        method Count takes nothing returns integer
            return EventCombination(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns integer
            return EventCombination(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method Remove takes integer subjectId returns nothing
            local integer iteration = EventCombination(this).Pairs.Count()
            local EventPair whichPair
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                set whichPair = EventCombination(this).Pairs.Get(iteration)
                call whichPair.GetNegativeEvent().Data.Boolean.Remove(subjectId)
                call whichPair.GetPositiveEvent().Data.Boolean.Remove(subjectId)
                set iteration = iteration - 1
            endloop
            call EventCombination(this).Data.Integer.Table.Remove(KEY_ARRAY, subjectId)
            if (EventCombination(this).RemainingEventsAmount.Get(subjectId) == 0) then
                call EventCombination(this).Periodic.Pause(subjectId)
            endif
            call EventCombination(this).RemainingEventsAmount.Event_SubjectRemove(subjectId)
        endmethod
        method Event_Destroy takes nothing returns nothing
            local integer iteration = this.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                call this.Remove(this.Get(iteration))
                set iteration = iteration - 1
            endloop
        endmethod
        method Add takes integer subjectId returns nothing
            local integer count = 0
            local integer iteration = EventCombination(this).Pairs.Count()
            local boolean startActive
            local EventPair whichPair
            
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                set whichPair = EventCombination(this).Pairs.Get(iteration)
                call EventResponse.GetTrigger().SetSubjectId(subjectId)
                call EventCombination.SetTrigger(this)
                set startActive = whichPair.GetStartConditions().Run()
                call EventCombination(this).Pairs.EnableEvent(whichPair.GetNegativeEvent(), subjectId, startActive)
                call EventCombination(this).Pairs.EnableEvent(whichPair.GetPositiveEvent(), subjectId, not startActive)
                if not startActive then
                    set count = count + 1
                endif
                set iteration = iteration - 1
            endloop
            call EventCombination(this).Data.Integer.Table.Add(KEY_ARRAY, subjectId)
            if (count == 0) then
                call EventCombination(this).Periodic.Start(subjectId)
            endif
            call EventCombination(this).RemainingEventsAmount.Set(subjectId, count)
        endmethod
    endstruct
    scope FolderPeriodic
    public struct StructSubjectsA
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
            static method Count takes TriggerTimer intervalTimer returns integer
                return intervalTimer.Data.Integer.Table.Count(KEY_ARRAY)
            endmethod
            static method Get takes TriggerTimer intervalTimer, integer index returns integer
                return intervalTimer.Data.Integer.Table.Get(KEY_ARRAY, index)
            endmethod
            method Remove takes TriggerTimer intervalTimer, integer value returns boolean
                return intervalTimer.Data.Integer.Table.Remove(KEY_ARRAY, value)
            endmethod
            method Add takes TriggerTimer intervalTimer, integer value returns boolean
                return intervalTimer.Data.Integer.Table.Add(KEY_ARRAY, value)
            endmethod
        endstruct
    endscope
    public struct StructPeriodic
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    FolderPeriodic_StructSubjectsA SubjectsA = this
    FolderPeriodic_StructSubjectsA LinkToStruct_SubjectsA
        method Count takes nothing returns integer
            return EventCombination(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns TriggerTimer
            return EventCombination(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method Event_Destroy takes nothing returns nothing
            local TriggerTimer intervalTimer
            local integer iteration = this.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                set intervalTimer = this.Get(iteration)
                call intervalTimer.Destroy()
                call EventCombination(this).Data.Integer.Table.Remove(KEY_ARRAY, intervalTimer)
                set iteration = iteration - 1
            endloop
        endmethod
        method Pause takes integer subjectId returns nothing
            local integer iteration = this.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local TriggerTimer intervalTimer = this.Get(iteration)
                if thistype(NULL).SubjectsA.Remove(intervalTimer, subjectId) then
                    call intervalTimer.Pause()
                endif
                set iteration = iteration - 1
            endloop
        endmethod
        method Start takes integer subjectId returns nothing
            local integer iteration = this.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local TriggerTimer intervalTimer = this.Get(iteration)
                if thistype(NULL).SubjectsA.Add(intervalTimer, subjectId) then
                    call intervalTimer.Resume()
                endif
                set iteration = iteration - 1
            endloop
        endmethod
        trigMethod Interval
            local TriggerTimer intervalTimer = TriggerTimer.GetExpired()
            local integer iteration = thistype(NULL).SubjectsA.Count(intervalTimer)
            local thistype this = intervalTimer.GetData()
            loop
                call EventResponse.GetTrigger().SetSubjectId(thistype(NULL).SubjectsA.Get(intervalTimer, iteration))
                call EventCombination(this).Run(NULL)
                set iteration = iteration - 1
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            endloop
        endmethod
        method Add takes real interval returns nothing
            local TriggerTimer intervalTimer = TriggerTimer.Create()
            local integer iteration = thistype(NULL).SubjectsA.Count(intervalTimer)
            call intervalTimer.AddTrigger(Trigger.CreateFromCode(function thistype.Interval))
            call intervalTimer.SetData(this)
            call intervalTimer.SetPeriodic(true)
            call intervalTimer.SetTimeout(interval)
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local integer subjectId = thistype(NULL).SubjectsA.Get(intervalTimer, iteration)
                if (EventCombination(this).RemainingEventsAmount.Get(subjectId) > 0) then
                    if thistype(NULL).SubjectsA.Add(intervalTimer, subjectId) then
                        call intervalTimer.Start()
                    endif
                endif
                set iteration = iteration - 1
            endloop
            call EventCombination(this).Data.Integer.Table.Add(KEY_ARRAY, intervalTimer)
        endmethod
    endstruct
    public struct StructPairs
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        method Count takes nothing returns integer
            return EventCombination(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns EventPair
            return EventCombination(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        static method EnableEvent takes Event whichEvent, integer subjectId, boolean flag returns nothing
            call whichEvent.Data.Boolean.Set(subjectId, HASH_TABLE.Boolean.DEFAULT_VALUE == flag)
        endmethod
        static method ToggleLockerEventsActivated takes Event whichEvent, integer subjectId returns boolean
            if (whichEvent.Data.Boolean.Get(subjectId) == HASH_TABLE.Boolean.DEFAULT_VALUE) then
                call thistype.EnableEvent(whichEvent, subjectId, false)
                call thistype.EnableEvent(EventPair.GetPartnerEvent(whichEvent), subjectId, true)
                return true
            endif
            return false
        endmethod
        eventMethod Event_Negative
            local integer subjectId = params.GetSubjectId()
            local Event whichEvent = Event.GetTrigger()
            local EventCombination parent = EVENT_COMBINATION.Events.GetParent(whichEvent)
            if thistype.ToggleLockerEventsActivated(whichEvent, subjectId) then
                if parent.RemainingEventsAmount.Add(subjectId) then
                    call parent.Periodic.Pause(subjectId)
                endif
            endif
        endmethod
        eventMethod Event_Positive
            local integer subjectId = params.GetSubjectId()
            local Event whichEvent = Event.GetTrigger()
            local EventCombination parent = EVENT_COMBINATION.Events.GetParent(whichEvent)
            if thistype.ToggleLockerEventsActivated(whichEvent, subjectId) then
                if parent.RemainingEventsAmount.Subtract(subjectId) then
                    call parent.Periodic.Start(subjectId)
                    if (parent.Periodic.Count() > Memory.IntegerKeys.Table.EMPTY) then
                        call parent.Run(whichEvent)
                    endif
                endif
            endif
        endmethod
        method Add takes EventPair whichPair returns nothing
            local Event negativeEvent = whichPair.GetNegativeEvent()
            local Event positiveEvent = whichPair.GetPositiveEvent()
            local BoolExpr startConditions = whichPair.GetStartConditions()
            
			local integer iteration = EventCombination(this).Periodic.Count()
			local integer subjectId
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local TriggerTimer intervalTimer = EventCombination(this).Periodic.Get(iteration)
                local integer iteration2 = EVENT_COMBINATION.Periodic.SubjectsA.Count(intervalTimer)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    set subjectId = EVENT_COMBINATION.Periodic.SubjectsA.Get(intervalTimer, iteration2)
                    call EventResponse.GetTrigger().SetSubjectId(subjectId)
                    call EventCombination.SetTrigger(this)
                    if not startConditions.Run() then
                        call EVENT_COMBINATION.Periodic.SubjectsA.Remove(intervalTimer, subjectId)
                    endif
                    set iteration2 = iteration2 - 1
                endloop
                call intervalTimer.Pause()
                set iteration = iteration - 1
            endloop
            call EventCombination(this).Data.Integer.Table.Add(KEY_ARRAY, whichPair)
            set iteration = EventCombination(this).Subjects.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                set subjectId = EventCombination(this).Subjects.Get(iteration)
                call EventResponse.GetTrigger().SetSubjectId(subjectId)
                call EventCombination.SetTrigger(this)
                local boolean startActive = startConditions.Run()
                call thistype.EnableEvent(negativeEvent, subjectId, startActive)
                call thistype.EnableEvent(positiveEvent, subjectId, not startActive)
                set iteration = iteration - 1
            endloop
            call EventCombination(this).Events.Event_PairAdd(whichPair)
        endmethod
        method Create takes EventType positiveType, BoolExpr positiveConditions, EventType negativeType, BoolExpr negativeConditions, BoolExpr startConditions returns EventPair
            local Event negativeEvent = Event.Create(negativeType, EventPriority.COMBINATION, function thistype.Event_Negative)
            local Event positiveEvent = Event.Create(positiveType, EventPriority.COMBINATION, function thistype.Event_Positive)
            local EventPair result = EventPair.Create(negativeEvent, positiveEvent, startConditions)
            call negativeEvent.SetConditions(negativeConditions)
            call positiveEvent.SetConditions(positiveConditions)
            call this.Add(result)
            return result
        endmethod
        method CreateLimit takes EventType whichType, integer value, limitop whichOperator, BoolExpr startConditions returns EventPair
            local Event negativeEvent = Event.Create(whichType, EventPriority.COMBINATION, function thistype.Event_Negative)
            local Event positiveEvent = Event.Create(whichType, EventPriority.COMBINATION, function thistype.Event_Positive)
            local EventPair result = EventPair.Create(negativeEvent, positiveEvent, startConditions)
            call negativeEvent.Limit.Set(value, LimitOp.GetComplement(whichOperator))
            call positiveEvent.Limit.Set(value, whichOperator)
            call this.Add(result)
            return result
        endmethod
    endstruct
endscope
    globals
        EventCombination EVENT_COMBINATION = STRUCT_BASE
    endglobals
    struct EventCombination
        implement Allocation
        implement List
        
    Trigger action
    FolderEventCombination_StructData Data = this
    FolderEventCombination_StructData LinkToStruct_Data
    FolderEventCombination_StructEvents Events = this
    FolderEventCombination_StructEvents LinkToStruct_Events
    FolderEventCombination_StructId Id = this
    FolderEventCombination_StructId LinkToStruct_Id
    FolderEventCombination_StructPeriodic Periodic = this
    FolderEventCombination_StructPeriodic LinkToStruct_Periodic
    FolderEventCombination_StructSubjects Subjects = this
    FolderEventCombination_StructSubjects LinkToStruct_Subjects
    FolderEventCombination_StructPairs Pairs = this
    FolderEventCombination_StructPairs LinkToStruct_Pairs
    FolderEventCombination_StructRemainingEventsAmount RemainingEventsAmount = this
    FolderEventCombination_StructRemainingEventsAmount LinkToStruct_RemainingEventsAmount
    static thistype TRIGGER = NULL
    static method GetTrigger takes nothing returns thistype
        return thistype.TRIGGER
    endmethod
    static method SetTrigger takes thistype value returns nothing
        set thistype.TRIGGER = value
    endmethod
    BoolExpr whichConditions
    method GetConditions takes nothing returns BoolExpr
        return this.whichConditions
    endmethod
    method SetConditions takes BoolExpr value returns nothing
        set this.whichConditions = value
    endmethod
    method GetAction takes nothing returns Trigger
        return this.action
    endmethod
    method SetAction takes code action returns nothing
        set this.action = Trigger.GetFromCode(action)
    endmethod
    method Destroy takes nothing returns nothing
        call this.Events.Event_Destroy()
        call this.Periodic.Event_Destroy()
        call this.Subjects.Event_Destroy()
        call this.deallocate()
    endmethod
    method Run takes Event fromWhichEvent returns nothing
        call thistype.SetTrigger(this)
        if this.whichConditions.Run() then
            call this.action.Run()
        endif
    endmethod
    static method Create takes code action returns thistype
        local thistype this = thistype.allocate()
        set this.whichConditions = NULL
        call this.Id.Event_Create()
        call this.SetAction(action)
        call this.SetConditions(NULL)
        return this
    endmethod
    initMethod Init of Header_5
    endmethod
endstruct
    globals
        Announcement ANNOUNCEMENT = STRUCT_BASE
    endglobals
    struct Announcement
        implement Allocation
        implement List
        
    static Timer RESET_TIMER
    static thistype CURRENT
    integer value
    static method Reset takes nothing returns nothing
        set thistype.CURRENT = NULL
        call User.ANY.State.Set(PLAYER_STATE_RESOURCE_FOOD_USED, 0)
    endmethod
    method Start takes nothing returns nothing
        if (thistype.CURRENT == this) then
            return
        endif
        set thistype.CURRENT = this
        call User.ANY.State.Set(PLAYER_STATE_RESOURCE_FOOD_USED, this.value + 1)
    endmethod
    method StartTimed takes real duration returns nothing
        call this.Start()
        call thistype.RESET_TIMER.Start(duration, false, function thistype.Reset)
    endmethod
    static method Create takes integer value returns thistype
        local thistype this = thistype.allocate()
        set this.value = value
        return this
    endmethod
    static method Init takes nothing returns nothing
        set thistype.CURRENT = NULL
        set thistype.RESET_TIMER = Timer.Create()
    endmethod
endstruct
    globals
        GameMessage GAME_MESSAGE = STRUCT_BASE
    endglobals
    struct GameMessage
        implement Allocation
        implement List
        
    static boolean INITIALIZED = false
    boolean destroyTimed
    Timer durationTimer
    boolean exists
    User forWhichPlayer
    string text
    static method UpdateDisplay takes User forWhichPlayer returns nothing
        if not forWhichPlayer.IsLocal() then
            return
        endif
        if (thistype.ALL_COUNT > ARRAY_EMPTY + 4) then
            set thistype.ALL[ARRAY_MIN].exists = false
            call thistype.ALL[ARRAY_MIN].RemoveFromListSorted()
        endif
        local integer iteration = Math.MaxI(ARRAY_MIN, thistype.ALL_COUNT + 1 - 4)
        local player p = GetLocalPlayer()
        call ClearTextMessages()
        loop
            local thistype this = thistype.ALL[iteration]
            if this.destroyTimed then
                call DisplayTimedTextToPlayer(p, -0.1, 1.2, Math.Max(0.001, this.durationTimer.GetRemaining() - 3.), this.text)
            else
                call DisplayTimedTextToPlayer(p, -0.1, 1.2, 0., this.text)
            endif
            set iteration = iteration + 1
            exitwhen (iteration > thistype.ALL_COUNT)
        endloop
        set p = null
    endmethod
    method Destroy takes nothing returns nothing
        local Timer durationTimer = this.durationTimer
        local User forWhichPlayer = this.forWhichPlayer
        call this.deallocate()
        call durationTimer.Destroy()
        if forWhichPlayer.IsLocal() then
            if this.exists then
                call this.RemoveFromListSorted()
            endif
        endif
        call thistype.UpdateDisplay(forWhichPlayer)
    endmethod
    static method EndingByTimer takes nothing returns nothing
        local thistype this = Timer.GetExpired().GetData()
        call this.Destroy()
    endmethod
    method DestroyTimed takes real duration returns nothing
        set this.destroyTimed = true
        call this.durationTimer.Start(duration, false, function thistype.EndingByTimer)
    endmethod
    static method Create takes string text, User forWhichPlayer returns thistype
        local thistype this = thistype.allocate()
		local Timer durationTimer = Timer.Create()
        set this.destroyTimed = false
        set this.durationTimer = durationTimer
        set this.exists = true
        set this.forWhichPlayer = forWhichPlayer
        set this.text = text
        call durationTimer.SetData(this)
        if forWhichPlayer.IsLocal() then
            call this.AddToList()
        endif
        call thistype.UpdateDisplay(forWhichPlayer)
        return this
    endmethod
    static method Init takes nothing returns nothing
        set thistype.INITIALIZED = true
    endmethod
endstruct
    globals
        CineFilter CINE_FILTER = STRUCT_BASE
    endglobals
    struct CineFilter
        implement Allocation
        implement List
        
    string texture
    method GetTexture takes nothing returns string
        return this.texture
    endmethod
    method SetTexture takes string value returns nothing
        set this.texture = value
    endmethod
    blendmode whichBlendMode
    method GetBlendMode takes nothing returns blendmode
        return this.whichBlendMode
    endmethod
    method SetBlendMode takes blendmode value returns nothing
        set this.whichBlendMode = value
    endmethod
    texmapflags whichTexMapFlags
    method GetTexMapFlags takes nothing returns texmapflags
        return this.whichTexMapFlags
    endmethod
    method SetTexMapFlags takes texmapflags value returns nothing
        set this.whichTexMapFlags = value
    endmethod
    integer redEnd
    method GetRedEnd takes nothing returns integer
        return this.redEnd
    endmethod
    method SetRedEnd takes integer value returns nothing
        set this.redEnd = value
    endmethod
    integer greenEnd
    method GetGreenEnd takes nothing returns integer
        return this.greenEnd
    endmethod
    method SetGreenEnd takes integer value returns nothing
        set this.greenEnd = value
    endmethod
    integer blueEnd
    method GetBlueEnd takes nothing returns integer
        return this.blueEnd
    endmethod
    method SetBlueEnd takes integer value returns nothing
        set this.blueEnd = value
    endmethod
    integer alphaEnd
    method GetAlphaEnd takes nothing returns integer
        return this.alphaEnd
    endmethod
    method SetAlphaEnd takes integer value returns nothing
        set this.alphaEnd = value
    endmethod
    integer redStart
    method GetRedStart takes nothing returns integer
        return this.redStart
    endmethod
    method SetRedStart takes integer value returns nothing
        set this.redStart = value
    endmethod
    integer greenStart
    method GetGreenStart takes nothing returns integer
        return this.greenStart
    endmethod
    method SetGreenStart takes integer value returns nothing
        set this.greenStart = value
    endmethod
    integer blueStart
    method GetBlueStart takes nothing returns integer
        return this.blueStart
    endmethod
    method SetBlueStart takes integer value returns nothing
        set this.blueStart = value
    endmethod
    integer alphaStart
    method GetAlphaStart takes nothing returns integer
        return this.alphaStart
    endmethod
    method SetAlphaStart takes integer value returns nothing
        set this.alphaStart = value
    endmethod
    real uMaxEnd
    method GetUMaxEnd takes nothing returns real
        return this.uMaxEnd
    endmethod
    method SetUMaxEnd takes real value returns nothing
        set this.uMaxEnd = value
    endmethod
    real uMinEnd
    method GetUMinEnd takes nothing returns real
        return this.uMinEnd
    endmethod
    method SetUMinEnd takes real value returns nothing
        set this.uMinEnd = value
    endmethod
    real vMaxEnd
    method GetVMaxEnd takes nothing returns real
        return this.vMaxEnd
    endmethod
    method SetVMaxEnd takes real value returns nothing
        set this.vMaxEnd = value
    endmethod
    real vMinEnd
    method GetVMinEnd takes nothing returns real
        return this.vMinEnd
    endmethod
    method SetVMinEnd takes real value returns nothing
        set this.vMinEnd = value
    endmethod
    real uMaxStart
    method GetUMaxStart takes nothing returns real
        return this.uMaxStart
    endmethod
    method SetUMaxStart takes real value returns nothing
        set this.uMaxStart = value
    endmethod
    real uMinStart
    method GetUMinStart takes nothing returns real
        return this.uMinStart
    endmethod
    method SetUMinStart takes real value returns nothing
        set this.uMinStart = value
    endmethod
    real vMaxStart
    method GetVMaxStart takes nothing returns real
        return this.vMaxStart
    endmethod
    method SetVMaxStart takes real value returns nothing
        set this.vMaxStart = value
    endmethod
    real vMinStart
    method GetVMinStart takes nothing returns real
        return this.vMinStart
    endmethod
    method SetVMinStart takes real value returns nothing
        set this.vMinStart = value
    endmethod
    method SetColorEnd takes integer red, integer green, integer blue, integer alpha returns nothing
        call this.SetRedEnd(red)
        call this.SetGreenEnd(green)
        call this.SetBlueEnd(blue)
        call this.SetAlphaEnd(alpha)
    endmethod
    method SetColorStart takes integer red, integer green, integer blue, integer alpha returns nothing
        call this.SetRedStart(red)
        call this.SetGreenStart(green)
        call this.SetBlueStart(blue)
        call this.SetAlphaStart(alpha)
    endmethod
    method SetUVEnd takes real minU, real minV, real maxU, real maxV returns nothing
        call this.SetUMaxEnd(maxU)
        call this.SetUMinEnd(minU)
        call this.SetVMaxEnd(maxV)
        call this.SetVMinEnd(minV)
    endmethod
    method SetUVStart takes real minU, real minV, real maxU, real maxV returns nothing
        call this.SetUMaxStart(maxU)
        call this.SetUMinStart(minU)
        call this.SetVMaxStart(maxV)
        call this.SetVMinStart(minV)
    endmethod
    method Ending takes User whichPlayer returns nothing
        if not whichPlayer.IsLocal() then
            return
        endif
        call DisplayCineFilter(false)
    endmethod
    method Start takes real duration, User whichPlayer returns nothing
        if not whichPlayer.IsLocal() then
            return
        endif
        call SetCineFilterBlendMode(this.GetBlendMode())
        call SetCineFilterEndColor(this.redEnd, this.greenEnd, this.blueEnd, this.alphaEnd)
        call SetCineFilterEndUV(this.uMinEnd, this.vMinEnd, this.uMaxEnd, this.vMaxEnd)
        call SetCineFilterStartColor(this.redStart, this.greenStart, this.blueStart, this.alphaStart)
        call SetCineFilterStartUV(this.uMinStart, this.vMinStart, this.uMaxStart, this.vMaxStart)
        call SetCineFilterTexMapFlags(this.GetTexMapFlags())
        call SetCineFilterTexture(this.GetTexture())
        call SetCineFilterDuration(duration)
        call DisplayCineFilter(true)
    endmethod
    static method Create takes nothing returns thistype
        local thistype this = thistype.allocate()
        call this.SetBlendMode(BLEND_MODE_BLEND)
        call this.SetColorEnd(255, 255, 255, 255)
        call this.SetColorStart(0, 0, 0, 0)
        call this.SetTexMapFlags(TEXMAP_FLAG_NONE)
        call this.SetTexture(null)
        call this.SetUVEnd(0., 0., 1., 1.)
        call this.SetUVStart(0., 0., 1., 1.)
        return this
    endmethod
endstruct
    struct Cinematic
    static method EndScene takes nothing returns nothing
        call EndCinematicScene()
    endmethod
    static method SetScene takes integer unitId, playercolor color, string name, string text, real sceneDuration, real voiceDuration returns nothing
        call SetCinematicScene(unitId, color, name, text, sceneDuration, voiceDuration)
    endmethod
endstruct
    scope FolderGame
    public struct StructFloatState
        implement Allocation
        implement List
        
        static method Get takes fgamestate whichState returns real
            return GetFloatGameState(whichState)
        endmethod
        static method Set takes fgamestate whichState, real value returns nothing
            call SetFloatGameState(whichState, value)
        endmethod
        static method Add takes fgamestate whichState, real value returns nothing
            call SetFloatGameState(whichState, Get(whichState) + value)
        endmethod
    endstruct
    public struct StructTimeOfDay
        implement Allocation
        implement List
        
        static real SCALE
        method Get takes nothing returns real
            return Game.FloatState.Get(GAME_STATE_TIME_OF_DAY)
        endmethod
        method GetScale takes nothing returns real
            return thistype.SCALE
        endmethod
        method Set takes real time returns nothing
            call Game.FloatState.Set(GAME_STATE_TIME_OF_DAY, time)
        endmethod
        method SetScale takes real scale returns nothing
            set thistype.SCALE = scale
            call SetTimeOfDayScale(scale)
        endmethod
        method Suspend takes boolean flag returns nothing
            call SuspendTimeOfDay(flag)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.SCALE = GetTimeOfDayScale()
        endmethod
    endstruct
endscope
function ClearTextMessages_Wrapped takes nothing returns nothing
    call ClearTextMessages()
endfunction
function PingMinimap_Wrapped takes real x, real y, real duration returns nothing
    call PingMinimap(x, y, duration)
endfunction
    struct Game
    static FolderGame_StructFloatState FloatState = NULL
    static FolderGame_StructTimeOfDay TimeOfDay = NULL
    static method ClearTextMessages takes User whichPlayer returns nothing
        if whichPlayer.IsLocal() then
            call ClearTextMessages_Wrapped()
        endif
    endmethod
    static method DisplayInterface takes User whichPlayer, boolean flag, real duration returns nothing
        if whichPlayer.IsLocal() then
            call ShowInterface(flag, duration)
        endif
    endmethod
    static method DisplayTextTimed takes User whichPlayer, string text, real duration returns GameMessage
        local GameMessage result = GameMessage.Create(text, whichPlayer)
        call result.DestroyTimed(duration)
        return result
    endmethod
    static method DebugMsg takes string text returns GameMessage
        if not GameMessage.INITIALIZED then
            call BJDebugMsg("Debug (uninit): " + text)
        endif
        return thistype.DisplayTextTimed(User.ANY, "Debug: " + text, 15.)
    endmethod
    static method DisplaySpeech takes UnitType speaker, string text, real duration returns GameMessage
        return thistype.DisplayTextTimed(User.ANY, String.Color.GOLD + speaker.GetName() + ": " + String.Color.RESET + text, duration)
    endmethod
    static method EnableControl takes User whichPlayer, boolean flag returns nothing
        if whichPlayer.IsLocal() then
            call EnableUserControl(flag)
        endif
    endmethod
    static method EnableTimeOfDay takes boolean flag returns nothing
        call SuspendTimeOfDay(not flag)
    endmethod
    static method PingMinimap takes real x, real y, real duration returns nothing
        call PingMinimap_Wrapped(x, y, duration)
    endmethod
    static method PingMinimapColored takes real x, real y, integer red, integer green, integer blue, real duration returns nothing
        call PingMinimapEx(x, y, duration, red, green, blue, false)
    endmethod
    static method DisplaySpeechFromUnit takes Unit speaker, string text, real duration returns nothing
        call thistype.DisplayTextTimed(User.ANY, String.Color.GOLD + speaker.GetName() + ": " + String.Color.RESET + text, duration)
        call thistype.PingMinimap(speaker.Position.X.Get(), speaker.Position.Y.Get(), 1.)
        call speaker.Flash(255, 255, 255, 255)
    endmethod
    initMethod Init of Header_4
        call thistype(NULL).TimeOfDay.Init()
        call Announcement.Init()
        call GameMessage.Init()
        call Ping.Init()
        call PingColor.Init()
    endmethod
endstruct
    globals
        PingColor PING_COLOR = STRUCT_BASE
    endglobals
    struct PingColor
        implement Allocation
        implement List
        
    static thistype BLUE
    static thistype GREEN
    static thistype RED
    static thistype MAGENTA
    static thistype TEAL
    static thistype YELLOW
    static thistype array UNUSED_ALL
    static integer UNUSED_ALL_COUNT = ARRAY_EMPTY
    integer UNUSED_index
    static method UNUSED_Count takes nothing returns integer
        return thistype.UNUSED_ALL_COUNT
    endmethod
    static method UNUSED_IsEmpty takes nothing returns boolean
        return (thistype.UNUSED_Count() == ARRAY_EMPTY)
    endmethod
    static method UNUSED_Get takes integer index returns thistype
        return thistype.UNUSED_ALL[index]
    endmethod
    static method UNUSED_GetIndex takes thistype this returns integer
        return this.UNUSED_index
    endmethod
    static method UNUSED_Contains takes thistype this returns boolean
        return (thistype.UNUSED_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method UNUSED_Random takes integer lowBound, integer highBound returns thistype
        return thistype.UNUSED_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method UNUSED_RandomAll takes nothing returns thistype
        return thistype.UNUSED_Random(ARRAY_MIN, thistype.UNUSED_ALL_COUNT)
    endmethod
    static method UNUSED_Remove takes thistype this returns boolean
        if not thistype.UNUSED_Contains(this) then
            return false
        endif
        set thistype.UNUSED_ALL[thistype.UNUSED_ALL_COUNT].UNUSED_index = this.UNUSED_index
        set thistype.UNUSED_ALL[this.UNUSED_index - 1] = thistype.UNUSED_ALL[thistype.UNUSED_ALL_COUNT]
        set this.UNUSED_index = ARRAY_MIN
        set thistype.UNUSED_ALL_COUNT = thistype.UNUSED_ALL_COUNT - 1
        return (thistype.UNUSED_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method UNUSED_Add takes thistype this returns boolean
        if thistype.UNUSED_Contains(this) then
            return false
        endif
        set thistype.UNUSED_ALL_COUNT = thistype.UNUSED_ALL_COUNT + 1
        set thistype.UNUSED_ALL[thistype.UNUSED_ALL_COUNT] = this
        set this.UNUSED_index = thistype.UNUSED_ALL_COUNT + 1
        return (thistype.UNUSED_ALL_COUNT == ARRAY_MIN)
    endmethod
    boolean used
    string name
    method GetName takes nothing returns string
        return this.name
    endmethod
    method SetName takes string value returns nothing
        set this.name = value
    endmethod
    integer red
    method GetRed takes nothing returns integer
        return this.red
    endmethod
    method SetRed takes integer value returns nothing
        set this.red = value
    endmethod
    integer green
    method GetGreen takes nothing returns integer
        return this.green
    endmethod
    method SetGreen takes integer value returns nothing
        set this.green = value
    endmethod
    integer blue
    method GetBlue takes nothing returns integer
        return this.blue
    endmethod
    method SetBlue takes integer value returns nothing
        set this.blue = value
    endmethod
    static method RandomUnused takes nothing returns thistype
        return thistype.UNUSED_RandomAll()
    endmethod
    method SetUsed takes boolean value returns nothing
        local boolean oldValue = this.used
        if (value == oldValue) then
            return
        endif
        set this.used = value
        if value then
            call thistype.UNUSED_Remove(this)
        else
            call thistype.UNUSED_Add(this)
        endif
    endmethod
    static method Create takes string name, integer red, integer green, integer blue returns thistype
        local thistype this = thistype.allocate()
        set this.used = false
        call this.SetName(String.Color.Do(name, String.Color.GetFrom255(red, green, blue, 255)))
        call this.SetRed(red)
        call this.SetGreen(green)
        call this.SetBlue(blue)
        call thistype.UNUSED_Add(this)
        return this
    endmethod
    static method Init takes nothing returns nothing
        set thistype.BLUE = thistype.Create("Blue", 0, 0, 255)
        set thistype.GREEN = thistype.Create("Green", 0, 255, 0)
        set thistype.RED = thistype.Create("Red", 255, 0, 0)
        set thistype.MAGENTA = thistype.Create("Magenta", 255, 0, 255)
        set thistype.TEAL = thistype.Create("Teal", 0, 255, 255)
        set thistype.YELLOW = thistype.Create("Yellow", 255, 255, 0)
    endmethod
endstruct
    globals
        Ping PING = STRUCT_BASE
    endglobals
    struct Ping
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static constant real UPDATE_TIME = 5.
    static Timer UPDATE_TIMER
    integer red
    integer green
    integer blue
    boolean show
    real x
    real y
    PingColor whichColor
    method GetColor takes nothing returns PingColor
        return this.whichColor
    endmethod
    method SetColor takes PingColor value returns nothing
        set this.whichColor = value
    endmethod
    method Destroy takes nothing returns nothing
        local PingColor whichColor = this.whichColor
        if (whichColor != NULL) then
            call whichColor.SetUsed(false)
        endif
        call this.deallocate()
        if this.RemoveFromList() then
            call thistype.UPDATE_TIMER.Pause()
        endif
    endmethod
    method Hide takes nothing returns nothing
        set this.show = false
    endmethod
    method Show takes nothing returns nothing
        set this.show = true
        call Game.PingMinimapColored(this.x, this.y, this.red, this.green, this.blue, thistype.UPDATE_TIME)
    endmethod
    static method Update takes nothing returns nothing
        local integer iteration = thistype.ALL_COUNT
        loop
            local thistype this = thistype.ALL[iteration]
            if show then
                call Game.PingMinimapColored(this.x, this.y, this.red, this.green, this.blue, thistype.UPDATE_TIME)
            endif
            set iteration = iteration - 1
            exitwhen (iteration < ARRAY_MIN)
        endloop
    endmethod
    method Start takes nothing returns nothing
        if this.AddToList() then
            call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
        endif
    endmethod
    static method Create takes real x, real y, PingColor whichColor returns thistype
        local thistype this = thistype.allocate()
        set this.red = whichColor.GetRed()
        set this.green = whichColor.GetGreen()
        set this.blue = whichColor.GetBlue()
        set this.whichColor = whichColor
        set this.x = x
        set this.y = y
        call whichColor.SetUsed(true)
        return this
    endmethod
    static method Init takes nothing returns nothing
        set thistype.UPDATE_TIMER = Timer.Create()
    endmethod
endstruct
    scope FolderGroup
    public struct StructRefs
        implement Allocation
        implement List
        
        boolean waiting
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
        method CheckForDestroy takes nothing returns boolean
            if (this.Get() > 0) then
                set this.waiting = true
                return false
            endif
            return true
        endmethod
        method Add takes nothing returns nothing
            set this.value = this.Get() + 1
        endmethod
        method Remove takes nothing returns nothing
            local integer value = this.Get() - 1
            set this.value = value
            if ((value == 0) and this.waiting) then
                call Group(this).Destroy()
            endif
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0
            set this.waiting = false
        endmethod
    endstruct
    public struct StructCountUnits
        implement Allocation
        implement List
        
        static Group ENUM_GROUP
        method Do takes nothing returns integer
            local integer result = 0
            loop
                local Unit enumUnit = Group(this).FetchFirst()
                exitwhen (enumUnit == NULL)
                call thistype.ENUM_GROUP.AddUnit(enumUnit)
                set result = result + 1
            endloop
            call Group(this).AddGroupClear(thistype.ENUM_GROUP)
            return result
        endmethod
        static method Init takes nothing returns nothing
            set thistype.ENUM_GROUP = Group.Create()
        endmethod
    endstruct
    public struct StructNearestUnit
        implement Allocation
        implement List
        
        static Group ENUM_GROUP
        method Do takes real x, real y returns Unit
            local Unit enumUnit = Group(this).FetchFirst()
            if (enumUnit == NULL) then
                return NULL
            endif
            local real currentRange
            local Unit currentUnit
            local boolean found = false
            loop
                local real enumUnitRange = Math.DistanceSquareByDeltas(enumUnit.Position.X.Get() - x, enumUnit.Position.Y.Get() - y)
                call thistype.ENUM_GROUP.AddUnit(enumUnit)
                if not found then
                    set currentRange = enumUnitRange
                    set currentUnit = enumUnit
                    set found = true
                elseif (enumUnitRange < currentRange) then
                    set currentRange = enumUnitRange
                    set currentUnit = enumUnit
                endif
                set enumUnit = Group(this).FetchFirst()
                exitwhen (enumUnit == NULL)
            endloop
            call Group(this).AddGroupClear(thistype.ENUM_GROUP)
            return currentUnit
        endmethod
        method DoWithCollision takes real x, real y returns Unit            
            local Unit enumUnit = Group(this).FetchFirst()
            if (enumUnit == NULL) then
                return NULL
            endif
			local real currentRange
			local Unit currentUnit
            local boolean found = false
            loop
                local real enumUnitRange = Math.Max(0., Math.DistanceByDeltas(enumUnit.Position.X.Get() - x, enumUnit.Position.Y.Get() - y) - enumUnit.CollisionSize.Get(true))
                call thistype.ENUM_GROUP.AddUnit(enumUnit)
                if not found then
                    set currentRange = enumUnitRange
                    set currentUnit = enumUnit
                    set found = true
                elseif (enumUnitRange < currentRange) then
                    set currentRange = enumUnitRange
                    set currentUnit = enumUnit
                endif
                set enumUnit = Group(this).FetchFirst()
                exitwhen (enumUnit == NULL)
            endloop
            call Group(this).AddGroupClear(thistype.ENUM_GROUP)
            return currentUnit
        endmethod
        method DoWithZ takes real x, real y, real z returns Unit
            local Unit enumUnit = Group(this).FetchFirst()
            if (enumUnit == NULL) then
                return NULL
            endif
			local real currentRange
			local Unit currentUnit
            local boolean found = false
            loop
                local real enumUnitX = enumUnit.Position.X.Get()
                local real enumUnitY = enumUnit.Position.Y.Get()
                local real enumUnitRange = Math.DistanceByDeltasWithZ(enumUnitX - x, enumUnitY - y, enumUnit.Position.Z.GetByCoords(enumUnitX, enumUnitY) - z)
                call thistype.ENUM_GROUP.AddUnit(enumUnit)
                if not found then
                    set currentRange = enumUnitRange
                    set currentUnit = enumUnit
                    set found = true
                elseif (enumUnitRange < currentRange) then
                    set currentRange = enumUnitRange
                    set currentUnit = enumUnit
                endif
                set enumUnit = Group(this).FetchFirst()
                exitwhen (enumUnit == NULL)
            endloop
            call Group(this).AddGroupClear(thistype.ENUM_GROUP)
            return currentUnit
        endmethod
        static method Init takes nothing returns nothing
            set thistype.ENUM_GROUP = Group.Create()
        endmethod
    endstruct
    public struct StructOrder
        implement Allocation
        implement List
        
        method IssuePointTarget takes Order value, real x, real y returns nothing
            call GroupPointOrderById(Group(this).self, value.self, x, y)
        endmethod
    endstruct
    public struct StructRandomUnit
        implement Allocation
        implement List
        
        static Group ENUM_GROUP
        method Do takes nothing returns Unit
            local Unit enumUnit = Group(this).GetFirst()
            if (enumUnit == NULL) then
                return NULL
            endif
            local integer iteration = 1
            local integer random = Math.RandomI(1, Group(this).CountUnits.Do())
            loop
                exitwhen (iteration == random)
                set iteration = iteration + 1
                set enumUnit = Group(this).FetchFirst()
                call thistype.ENUM_GROUP.AddUnit(enumUnit)
            endloop
            local Unit result = Group(this).GetFirst()
            call Group(this).AddGroupClear(thistype.ENUM_GROUP)
            return result
        endmethod
        static method Init takes nothing returns nothing
            set thistype.ENUM_GROUP = Group.Create()
        endmethod
    endstruct
    scope FolderEnumUnits
    scope FolderInLine
    public struct StructWithCollision
        implement Allocation
        implement List
        
                static real ANGLE
                static BoolExpr DUMMY_FILTER
                static Rectangle DUMMY_RECT
                static constant real MAX_COL_SIZE = 128
                static real LENGTH
                static real SOURCE_X
                static real SOURCE_Y
                static real WIDTH_END
                static real WIDTH_START
                static method Conditions takes nothing returns boolean
                    local Unit filterUnit = UNIT.Event.Native.GetFilter()
                    if not filterUnit.Position.InLine(thistype.SOURCE_X, thistype.SOURCE_Y, thistype.LENGTH, thistype.ANGLE, thistype.WIDTH_START, thistype.WIDTH_END) then
                        
                        return false
                    endif
                    if (filterUnit.self == DummyUnit.WORLD_CASTER.self) then
                        return false
                    endif
                    return true
                endmethod
                method Do takes real sourceX, real sourceY, real length, real angle, real widthStart, real widthEnd, BoolExpr whichFilter returns nothing
                    local real size = Math.Max(length, Math.Max(widthEnd, widthStart)) + thistype.MAX_COL_SIZE
                    if (whichFilter == NULL) then
                        set whichFilter = BoolExpr.DEFAULT_TRUE
                    endif
                    set whichFilter = BoolExpr.GetByAnd(thistype.DUMMY_FILTER, whichFilter)
                    set thistype.ANGLE = angle
                    set thistype.LENGTH = length
                    set thistype.SOURCE_X = sourceX
                    set thistype.SOURCE_Y = sourceY
                    set thistype.WIDTH_END = widthEnd
                    set thistype.WIDTH_START = widthStart
                    call thistype.DUMMY_RECT.Set(sourceX - size, sourceY - size, sourceX + size, sourceY + size)
                    call GroupEnumUnitsInRect(Group(this).self, thistype.DUMMY_RECT.self, whichFilter.self)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DUMMY_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
                    set thistype.DUMMY_RECT = Rectangle.Create(0., 0., 0., 0.)
                endmethod
            endstruct
        endscope
    public struct StructInLine
        implement Allocation
        implement List
        
            static real ANGLE
            static BoolExpr DUMMY_FILTER
            static Rectangle DUMMY_RECT
            static real LENGTH
            static real SOURCE_X
            static real SOURCE_Y
            static real WIDTH_END
            static real WIDTH_START
    FolderInLine_StructWithCollision WithCollision = this
    FolderInLine_StructWithCollision LinkToStruct_WithCollision
            static method Conditions takes nothing returns boolean
                local Unit filterUnit = UNIT.Event.Native.GetFilter()
                if not Math.Shapes.InLine(thistype.SOURCE_X, thistype.SOURCE_Y, thistype.LENGTH, thistype.ANGLE, thistype.WIDTH_START, thistype.WIDTH_END, filterUnit.Position.X.Get(), filterUnit.Position.Y.Get()) then
                    return false
                endif
                if (filterUnit.self == DummyUnit.WORLD_CASTER.self) then
                    return false
                endif
                return true
            endmethod
            method Do takes real sourceX, real sourceY, real length, real angle, real widthStart, real widthEnd, BoolExpr whichFilter returns nothing
                local real size = Math.Max(length, Math.Max(widthEnd, widthStart))
                if (whichFilter == NULL) then
                    set whichFilter = BoolExpr.DEFAULT_TRUE
                endif
                set whichFilter = BoolExpr.GetByAnd(thistype.DUMMY_FILTER, whichFilter)
                set thistype.ANGLE = angle
                set thistype.LENGTH = length
                set thistype.SOURCE_X = sourceX
                set thistype.SOURCE_Y = sourceY
                set thistype.WIDTH_END = widthEnd
                set thistype.WIDTH_START = widthStart
                call thistype.DUMMY_RECT.Set(sourceX - size, sourceY - size, sourceX + size, sourceY + size)
                call GroupEnumUnitsInRect(Group(this).self, thistype.DUMMY_RECT.self, whichFilter.self)
            endmethod
            static method Init takes nothing returns nothing
                set thistype.DUMMY_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
                set thistype.DUMMY_RECT = Rectangle.Create(0., 0., 0., 0.)
                call thistype(NULL).WithCollision.Init()
            endmethod
        endstruct
    scope FolderInRange
    public struct StructWithCollision
        implement Allocation
        implement List
        
                static BoolExpr DUMMY_FILTER
                static BoolExpr DUMMY_FILTER_WITH_Z
                static constant real MAX_SIZE = 128
                static real RADIUS
                static real X
                static real Y
                static real Z
                static method Conditions takes nothing returns boolean
                    local Unit filterUnit = UNIT.Event.Native.GetFilter()
                    if not filterUnit.Position.InRangeWithCollision(thistype.X, thistype.Y, thistype.RADIUS) then
                        return false
                    endif
                    if (filterUnit.self == DummyUnit.WORLD_CASTER.self) then
                        return false
                    endif
                    return true
                endmethod
                method Do takes real x, real y, real radius, BoolExpr whichFilter returns nothing
                    if (whichFilter == NULL) then
                        set whichFilter = BoolExpr.DEFAULT_TRUE
                    endif
                    set whichFilter = BoolExpr.GetByAnd(thistype.DUMMY_FILTER, whichFilter)
                    set thistype.RADIUS = radius
                    set thistype.X = x
                    set thistype.Y = y
                    call Group(this).EnumUnits.InRange.Pick(x, y, radius + thistype.MAX_SIZE, whichFilter)
                endmethod
                static method GetNearest takes real x, real y, real radius, BoolExpr whichFilter returns Unit
                    call thistype(Group.DUMMY).Do(x, y, radius, whichFilter)
                    return Group.DUMMY.GetNearest(x, y)
                endmethod
                static method GetRandom takes real x, real y, real radius, BoolExpr whichFilter returns Unit
                    call thistype(Group.DUMMY).Do(x, y, radius, whichFilter)
                    return Group.DUMMY.GetRandom()
                endmethod
                static method ConditionsWithZ takes nothing returns boolean
                    local Unit filterUnit = UNIT.Event.Native.GetFilter()
                    if not filterUnit.Position.InRangeWithCollisionWithZ(thistype.X, thistype.Y, thistype.Z, thistype.RADIUS) then
                        return false
                    endif
                    if (filterUnit.self == DummyUnit.WORLD_CASTER.self) then
                        return false
                    endif
                    return true
                endmethod
                method DoWithZ takes real x, real y, real z, real radius, BoolExpr whichFilter returns nothing
                    if (whichFilter == NULL) then
                        set whichFilter = BoolExpr.DEFAULT_TRUE
                    endif
                    set whichFilter = BoolExpr.GetByAnd(thistype.DUMMY_FILTER, whichFilter)
                    set thistype.RADIUS = radius
                    set thistype.X = x
                    set thistype.Y = y
                    set thistype.Z = z
                    call Group(this).EnumUnits.InRange.Pick(x, y, radius + thistype.MAX_SIZE, whichFilter)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DUMMY_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
                    set thistype.DUMMY_FILTER_WITH_Z = BoolExpr.GetFromFunction(function thistype.ConditionsWithZ)
                endmethod
            endstruct
        endscope
    public struct StructInRange
        implement Allocation
        implement List
        
            static BoolExpr DUMMY_FILTER
    FolderInRange_StructWithCollision WithCollision = this
    FolderInRange_StructWithCollision LinkToStruct_WithCollision
            static method Conditions takes nothing returns boolean
                if (UNIT.Event.Native.GetFilter().self == DummyUnit.WORLD_CASTER.self) then
                    return false
                endif
                return true
            endmethod
            method Pick takes real x, real y, real radius, BoolExpr whichFilter returns nothing
                call GroupEnumUnitsInRange(Group(this).self, x, y, radius, whichFilter.self)
            endmethod
            method Do takes real x, real y, real radius, BoolExpr whichFilter returns nothing
                if (whichFilter == NULL) then
                    set whichFilter = BoolExpr.DEFAULT_TRUE
                endif
                set whichFilter = BoolExpr.GetByAnd(thistype.DUMMY_FILTER, whichFilter)
                call this.Pick(x, y, radius, whichFilter)
            endmethod
            static method Init takes nothing returns nothing
                set thistype.DUMMY_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
                call thistype(NULL).WithCollision.Init()
            endmethod
        endstruct
    scope FolderInRect
    public struct StructWithCollision
        implement Allocation
        implement List
        
                static BoolExpr DUMMY_FILTER
                static Rectangle DUMMY_RECT
                static constant real MAX_SIZE = 1024
                static real MAX_X
                static real MAX_Y
                static real MIN_X
                static real MIN_Y
                static method Conditions takes nothing returns boolean
                    local Unit filterUnit = UNIT.Event.Native.GetFilter()
                    local real maxX = thistype.MAX_X
                    local real maxY = thistype.MAX_Y
                    local real minX = thistype.MIN_X
                    local real minY = thistype.MIN_Y
                    local real x = filterUnit.Position.X.Get()
                    local real y = filterUnit.Position.Y.Get()
                    if ((x <= maxX) and (y <= maxY) and (x >= minX) and (y >= minY)) then
                        return true
                    endif
                    if (filterUnit.Position.InRangeWithCollision(Math.Min(Math.Max(minX, x), maxX), Math.Min(Math.Max(minY, y), maxY), 0.)) then
                        return true
                    endif
                    if (filterUnit.self == DummyUnit.WORLD_CASTER.self) then
                        return false
                    endif
                    return false
                endmethod
                method Do takes Rectangle whichRect, BoolExpr whichFilter returns nothing
                    local real maxX = whichRect.GetMaxX()
                    local real maxY = whichRect.GetMaxY()
                    local real minX = whichRect.GetMinX()
                    local real minY = whichRect.GetMinY()
                    if (whichFilter == NULL) then
                        set whichFilter = BoolExpr.DEFAULT_TRUE
                    endif
                    set thistype.MAX_X = maxX
                    set thistype.MAX_Y = maxY
                    set thistype.MIN_X = minX
                    set thistype.MIN_Y = minY
                    set whichFilter = BoolExpr.GetByAnd(thistype.DUMMY_FILTER, whichFilter)
                    call thistype.DUMMY_RECT.Set(minX - thistype.MAX_SIZE, minY - thistype.MAX_SIZE, maxX + thistype.MAX_SIZE, maxY + thistype.MAX_SIZE)
                    call Group(this).EnumUnits.InRect.Pick(thistype.DUMMY_RECT, whichFilter)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DUMMY_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
                    set thistype.DUMMY_RECT = Rectangle.Create(0., 0., 0., 0.)
                endmethod
            endstruct
        endscope
    public struct StructInRect
        implement Allocation
        implement List
        
            static BoolExpr DUMMY_FILTER
    FolderInRect_StructWithCollision WithCollision = this
    FolderInRect_StructWithCollision LinkToStruct_WithCollision
            static method Conditions takes nothing returns boolean
                if (UNIT.Event.Native.GetFilter().self == DummyUnit.WORLD_CASTER.self) then
                    return false
                endif
                return true
            endmethod
            method Pick takes Rectangle whichRect, BoolExpr whichFilter returns nothing
                call GroupEnumUnitsInRect(Group(this).self, whichRect.self, whichFilter.self)
            endmethod
            method Do takes Rectangle whichRect, BoolExpr whichFilter returns nothing
                if (whichFilter == NULL) then
                    set whichFilter = BoolExpr.DEFAULT_TRUE
                endif
                set whichFilter = BoolExpr.GetByAnd(thistype.DUMMY_FILTER, whichFilter)
                call this.Pick(whichRect, whichFilter)
            endmethod
            static method Init takes nothing returns nothing
                set thistype.DUMMY_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
                call thistype(NULL).WithCollision.Init()
            endmethod
        endstruct
    endscope
    public struct StructEnumUnits
        implement Allocation
        implement List
        
        static User FILTER_USER
    FolderEnumUnits_StructInLine InLine = this
    FolderEnumUnits_StructInLine LinkToStruct_InLine
    FolderEnumUnits_StructInRange InRange = this
    FolderEnumUnits_StructInRange LinkToStruct_InRange
    FolderEnumUnits_StructInRect InRect = this
    FolderEnumUnits_StructInRect LinkToStruct_InRect
        method All takes BoolExpr whichFilter returns nothing
            call GroupEnumUnitsInRect(Group(this).self, Rectangle.WORLD.self, whichFilter.self)
        endmethod
        static method Init takes nothing returns nothing
            call thistype(NULL).InLine.Init()
            call thistype(NULL).InRange.Init()
            call thistype(NULL).InRect.Init()
        endmethod
    endstruct
endscope
    globals
        Group GROUP = STRUCT_BASE
    endglobals
    struct Group
        implement Allocation
        implement List
        
    static integer QUEUE_SIZE = ARRAY_EMPTY
    static thistype array QUEUED
    static thistype DUMMY
    static thistype TEMP
    static thistype array TEMPS
    group self
    FolderGroup_StructCountUnits CountUnits = this
    FolderGroup_StructCountUnits LinkToStruct_CountUnits
    FolderGroup_StructEnumUnits EnumUnits = this
    FolderGroup_StructEnumUnits LinkToStruct_EnumUnits
    FolderGroup_StructNearestUnit NearestUnit = this
    FolderGroup_StructNearestUnit LinkToStruct_NearestUnit
    FolderGroup_StructOrder Order = this
    FolderGroup_StructOrder LinkToStruct_Order
    FolderGroup_StructRandomUnit RandomUnit = this
    FolderGroup_StructRandomUnit LinkToStruct_RandomUnit
    FolderGroup_StructRefs Refs = this
    FolderGroup_StructRefs LinkToStruct_Refs
    method Destroy takes nothing returns nothing
        if not this.Refs.CheckForDestroy() then
            return
        endif
        set thistype.QUEUE_SIZE = thistype.QUEUE_SIZE + 1
        set thistype.QUEUED[thistype.QUEUE_SIZE] = this
        call GroupClear(this.self)
    endmethod
    method Contains takes Unit whichUnit returns boolean
        return IsUnitInGroup(whichUnit.self, this.self)
    endmethod
    method ContainsUnit takes Unit whichUnit returns boolean
        return IsUnitInGroup(whichUnit.self, this.self)
    endmethod
    method Count takes nothing returns integer
        return this.CountUnits.Do()
    endmethod
    method GetFirst takes nothing returns Unit
        return Unit.GetFromSelf(FirstOfGroup(this.self))
    endmethod
    method GetNearest takes real x, real y returns Unit
        return this.NearestUnit.Do(x, y)
    endmethod
    method GetNearestWithCollision takes real x, real y returns Unit
        return this.NearestUnit.DoWithCollision(x, y)
    endmethod
    method GetRandom takes nothing returns Unit
        return this.RandomUnit.Do()
    endmethod
    method IsEmpty takes nothing returns boolean
        return (this.GetFirst() == NULL)
    endmethod
    method Clear takes nothing returns nothing
        call GroupClear(this.self)
    endmethod
    method RemoveUnit takes Unit whichUnit returns nothing
        call GroupRemoveUnit(this.self, whichUnit.self)
    endmethod
    method FetchFirst takes nothing returns Unit
        local Unit result = this.GetFirst()
        if (result == NULL) then
            return NULL
        endif
        call this.RemoveUnit(result)
        return result
    endmethod
    method AddGroupClear takes Group whichGroup returns nothing
        loop
            local Unit currentUnit = whichGroup.FetchFirst()
            exitwhen (currentUnit == NULL)
            call this.AddUnit(currentUnit)
        endloop
    endmethod
    method AddUnit takes Unit whichUnit returns nothing
        call GroupAddUnit(this.self, whichUnit.self)
    endmethod
    method Do takes code actionFunction returns nothing
        call ForGroup(this.self, actionFunction)
    endmethod
    static Buff array ADD_BUFF_BUFF
    static real array ADD_BUFF_DURATION
    static integer array ADD_BUFF_LEVEL
    static integer ADD_BUFF_NESTING = ARRAY_EMPTY
    static method AddBuff_Enum takes nothing returns nothing
        call UNIT.Event.Native.GetEnum().Buffs.Timed.Start(thistype.ADD_BUFF_BUFF[thistype.ADD_BUFF_NESTING], thistype.ADD_BUFF_LEVEL[thistype.ADD_BUFF_NESTING], thistype.ADD_BUFF_DURATION[thistype.ADD_BUFF_NESTING])
    endmethod
    method AddBuff takes Buff whichBuff, integer level, real duration returns nothing
        set thistype.ADD_BUFF_NESTING = thistype.ADD_BUFF_NESTING + 1
        set thistype.ADD_BUFF_BUFF[thistype.ADD_BUFF_NESTING] = whichBuff
        set thistype.ADD_BUFF_DURATION[thistype.ADD_BUFF_NESTING] = duration
        set thistype.ADD_BUFF_LEVEL[thistype.ADD_BUFF_NESTING] = level
        call this.Do(function thistype.AddBuff_Enum)
        set thistype.ADD_BUFF_NESTING = thistype.ADD_BUFF_NESTING - 1
    endmethod
    static integer array DATA_STACK
    static Trigger array DATA_STACK_ACTION
    static integer DATA_STACK_NESTING = -1
    static method DoEx_Enum takes nothing returns nothing
        local EventResponse params = EventResponse.Create(EventResponse.DIRECT_SUBJECT_ID)
        call params.Unit.SetTrigger(UNIT.Event.Native.GetEnum())
        call params.SetData(thistype.DATA_STACK[thistype.DATA_STACK_NESTING])
        call thistype.DATA_STACK_ACTION[thistype.DATA_STACK_NESTING].RunWithParams(params)
        call params.Destroy()
    endmethod
    method DoEx takes code action, integer data returns nothing
        set thistype.DATA_STACK_NESTING = thistype.DATA_STACK_NESTING + 1
        set thistype.DATA_STACK[thistype.DATA_STACK_NESTING] = data
        set thistype.DATA_STACK_ACTION[thistype.DATA_STACK_NESTING] = Trigger.GetFromCode(action)
        call ForGroup(this.self, function thistype.DoEx_Enum)
        set thistype.DATA_STACK_NESTING = thistype.DATA_STACK_NESTING - 1
    endmethod
    static method Create takes nothing returns thistype
        local thistype this
        if (thistype.QUEUE_SIZE == ARRAY_EMPTY) then
            set this = thistype.allocate()
            
            set this.self = CreateGroup()
        else
            set this = thistype.QUEUED[thistype.QUEUE_SIZE]
            set thistype.QUEUE_SIZE = thistype.QUEUE_SIZE - 1
        endif
        call this.Refs.Event_Create()
        return this
    endmethod
    initMethod Init of Header_Group
        set thistype.DUMMY = thistype.Create()
        call thistype(NULL).CountUnits.Init()
        call thistype(NULL).EnumUnits.Init()
        call thistype(NULL).NearestUnit.Init()
        call thistype(NULL).RandomUnit.Init()
        call UnitList.Init()
    endmethod
endstruct
    scope FolderUnitList
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return UnitList(this).Data.table.IntegerKeys.Table.ContainsInteger(UnitList(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return UnitList(this).Data.table.IntegerKeys.Table.CountIntegers(UnitList(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return UnitList(this).Data.table.IntegerKeys.Table.IsEmptyInteger(UnitList(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return UnitList(this).Data.table.IntegerKeys.Table.GetInteger(UnitList(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return UnitList(this).Data.table.IntegerKeys.Table.GetFirstInteger(UnitList(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return UnitList(this).Data.table.IntegerKeys.Table.GetLastInteger(UnitList(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call UnitList(this).Data.table.IntegerKeys.Table.Clear(UnitList(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return UnitList(this).Data.table.IntegerKeys.Table.FetchFirstInteger(UnitList(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return UnitList(this).Data.table.IntegerKeys.Table.RemoveInteger(UnitList(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return UnitList(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(UnitList(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return UnitList(this).Data.table.IntegerKeys.Table.AddInteger(UnitList(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return UnitList(this).Data.table.IntegerKeys.Table.AddIntegerMulti(UnitList(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call UnitList(this).Data.table.IntegerKeys.Table.JoinInteger(UnitList(this).Id.Get(), key, UnitList(other).Data.table, UnitList(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return UnitList(this).Data.table.IntegerKeys.Table.RandomInteger(UnitList(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call UnitList(this).Data.table.IntegerKeys.Table.ShuffleIntegers(UnitList(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call UnitList(this).Data.table.IntegerKeys.Table.PrintIntegers(UnitList(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return UnitList(this).Data.table.IntegerKeys.GetInteger(UnitList(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call UnitList(this).Data.table.IntegerKeys.RemoveInteger(UnitList(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call UnitList(this).Data.table.IntegerKeys.SetInteger(UnitList(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(UnitList(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject UnitList.Allocation.deallocate_demount.hook
		call UnitList(this).Data.Destroy()
	endinject
	inject UnitList.Allocation.allocate_mount.hook
		call UnitList(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructRefs
        implement Allocation
        implement List
        
        boolean waiting
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
        method CheckForDestroy takes nothing returns boolean
            if (this.Get() > 0) then
                set this.waiting = true
                return false
            endif
            return true
        endmethod
        method Add takes nothing returns nothing
            set this.value = this.Get() + 1
        endmethod
        method Remove takes nothing returns nothing
            local integer value = this.Get() - 1
            set this.value = value
            if ((value == 0) and this.waiting) then
                call UnitList(this).Destroy()
            endif
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0
            set this.waiting = false
        endmethod
    endstruct
endscope
    globals
        UnitList UNIT_LIST = STRUCT_BASE
    endglobals
    struct UnitList
        implement Allocation
        implement List
        
    static key GetKeyMacro_MEMBERS_KEY_ARRAY
    static constant integer MEMBERS_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_MEMBERS_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static thistype ALIVE
    static thistype WORLD
    static thistype TEMP
    string name
    method GetName takes nothing returns string
        return this.name
    endmethod
    method SetName takes string value returns nothing
        set this.name = value
    endmethod
    FolderUnitList_StructData Data = this
    FolderUnitList_StructData LinkToStruct_Data
    FolderUnitList_StructId Id = this
    FolderUnitList_StructId LinkToStruct_Id
    FolderUnitList_StructRefs Refs = this
    FolderUnitList_StructRefs LinkToStruct_Refs
    method Contains takes Unit value returns boolean
        return this.Data.Integer.Table.Contains(MEMBERS_KEY_ARRAY, value)
    endmethod
    method Count takes nothing returns integer
        return this.Data.Integer.Table.Count(MEMBERS_KEY_ARRAY)
    endmethod
    method IsEmpty takes nothing returns boolean
        return this.Data.Integer.Table.IsEmpty(MEMBERS_KEY_ARRAY)
    endmethod
    method GetFirst takes nothing returns Unit
        return this.Data.Integer.Table.GetFirst(MEMBERS_KEY_ARRAY)
    endmethod
    method FetchFirst takes nothing returns Unit
        return this.Data.Integer.Table.FetchFirst(MEMBERS_KEY_ARRAY)
    endmethod
    method Clear takes nothing returns nothing
        call this.Data.Integer.Table.Clear(MEMBERS_KEY_ARRAY)
    endmethod
    method DoEx takes code action, integer data returns nothing
        local integer iteration = this.Data.Integer.Table.Count(MEMBERS_KEY_ARRAY)
        if (iteration < Memory.IntegerKeys.Table.STARTED) then
            return
        endif
        local Group dummyGroup = Group.Create()
        loop
            call dummyGroup.AddUnit(this.Data.Integer.Table.Get(MEMBERS_KEY_ARRAY, iteration))
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
        call dummyGroup.DoEx(action, data)
        call dummyGroup.Destroy()
    endmethod
    method Do takes code action returns nothing
        call this.DoEx(action, NULL)
    endmethod
    method Destroy takes nothing returns nothing
        call this.Clear()
        if not this.Refs.CheckForDestroy() then
            return
        endif
        call this.deallocate()
    endmethod
    method Remove takes Unit value returns nothing
        static if DEBUG then
            if not this.Contains(value) then
                call DebugEx(thistype.NAME + " Remove: " + value.GetName() + " not in " + this.GetName())
                return
            endif
        endif
        call this.Data.Integer.Table.Remove(MEMBERS_KEY_ARRAY, value)
    endmethod
    method AddGroupClear takes UnitList value returns nothing
        call this.Data.Integer.Table.Join(MEMBERS_KEY_ARRAY, value)
        call value.Clear()
    endmethod
	method GetDifferenceGroupEx takes Group sub, UnitList targetList returns nothing
		local integer iteration = this.Data.Integer.Table.Count(MEMBERS_KEY_ARRAY)
		
		loop
			exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
			local Unit member = this.Data.Integer.Table.Get(MEMBERS_KEY_ARRAY, iteration)
			if not sub.ContainsUnit(member) then
				call targetList.Add(member)
			endif
			set iteration = iteration - 1
		endloop
	endmethod
    method AddGroup2Clear takes Group val returns nothing
        loop
            local Unit cur = val.FetchFirst()
            exitwhen (cur == NULL)
            call this.Add(cur)
        endloop
    endmethod
    method Add takes Unit value returns nothing
        static if DEBUG then
            if this.Contains(value) then
                call DebugEx(thistype.NAME + " Add: " + value.GetName() + " already in " + this.GetName())
                return
            endif
        endif
        call this.Data.Integer.Table.Add(MEMBERS_KEY_ARRAY, value)
    endmethod
    static method Create takes string name returns thistype
        local thistype this = thistype.allocate()
        call this.SetName(name)
        call this.Id.Event_Create()
		call this.Refs.Event_Create()
        return this
    endmethod
    static method Init takes nothing returns nothing
        set thistype.WORLD = thistype.Create("world")
    endmethod
endstruct
    scope FolderItemClass
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return ItemClass(this).Data.table.IntegerKeys.Table.ContainsInteger(ItemClass(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return ItemClass(this).Data.table.IntegerKeys.Table.CountIntegers(ItemClass(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return ItemClass(this).Data.table.IntegerKeys.Table.IsEmptyInteger(ItemClass(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return ItemClass(this).Data.table.IntegerKeys.Table.GetInteger(ItemClass(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return ItemClass(this).Data.table.IntegerKeys.Table.GetFirstInteger(ItemClass(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return ItemClass(this).Data.table.IntegerKeys.Table.GetLastInteger(ItemClass(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call ItemClass(this).Data.table.IntegerKeys.Table.Clear(ItemClass(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return ItemClass(this).Data.table.IntegerKeys.Table.FetchFirstInteger(ItemClass(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return ItemClass(this).Data.table.IntegerKeys.Table.RemoveInteger(ItemClass(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return ItemClass(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(ItemClass(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return ItemClass(this).Data.table.IntegerKeys.Table.AddInteger(ItemClass(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return ItemClass(this).Data.table.IntegerKeys.Table.AddIntegerMulti(ItemClass(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call ItemClass(this).Data.table.IntegerKeys.Table.JoinInteger(ItemClass(this).Id.Get(), key, ItemClass(other).Data.table, ItemClass(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return ItemClass(this).Data.table.IntegerKeys.Table.RandomInteger(ItemClass(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call ItemClass(this).Data.table.IntegerKeys.Table.ShuffleIntegers(ItemClass(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call ItemClass(this).Data.table.IntegerKeys.Table.PrintIntegers(ItemClass(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return ItemClass(this).Data.table.IntegerKeys.GetInteger(ItemClass(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call ItemClass(this).Data.table.IntegerKeys.RemoveInteger(ItemClass(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call ItemClass(this).Data.table.IntegerKeys.SetInteger(ItemClass(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(ItemClass(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject ItemClass.Allocation.deallocate_demount.hook
		call ItemClass(this).Data.Destroy()
	endinject
	inject ItemClass.Allocation.allocate_mount.hook
		call ItemClass(this).Data.Event_Create()
	endinject
    endstruct
endscope
    globals
        ItemClass ITEM_CLASS = STRUCT_BASE
    endglobals
    struct ItemClass
        implement Allocation
        implement List
        
    static thistype SCROLL
    static thistype POWER_UP
    FolderItemClass_StructData Data = this
    FolderItemClass_StructData LinkToStruct_Data
    FolderItemClass_StructId Id = this
    FolderItemClass_StructId LinkToStruct_Id
    static method Create takes nothing returns thistype
        local thistype this = thistype.allocate()
        call this.AddToList()
        call this.Id.Event_Create()
        return this
    endmethod
    static method Init takes nothing returns nothing
        set thistype.SCROLL = thistype.Create()
        set thistype.POWER_UP = thistype.Create()
    endmethod
endstruct
    scope FolderItem
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    public struct StructBoolean
        implement Allocation
        implement List
        
    method Get takes integer key returns boolean
        return Item(this).Data.table.IntegerKeys.GetBoolean(Item(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Item(this).Data.table.IntegerKeys.RemoveBoolean(Item(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call Item(this).Data.table.IntegerKeys.SetBoolean(Item(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return Item(this).Data.table.IntegerKeys.Table.ContainsInteger(Item(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Item(this).Data.table.IntegerKeys.Table.CountIntegers(Item(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Item(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Item(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Item(this).Data.table.IntegerKeys.Table.GetInteger(Item(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Item(this).Data.table.IntegerKeys.Table.GetFirstInteger(Item(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Item(this).Data.table.IntegerKeys.Table.GetLastInteger(Item(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Item(this).Data.table.IntegerKeys.Table.Clear(Item(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Item(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Item(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Item(this).Data.table.IntegerKeys.Table.RemoveInteger(Item(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Item(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Item(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Item(this).Data.table.IntegerKeys.Table.AddInteger(Item(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Item(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Item(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Item(this).Data.table.IntegerKeys.Table.JoinInteger(Item(this).Id.Get(), key, Item(other).Data.table, Item(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Item(this).Data.table.IntegerKeys.Table.RandomInteger(Item(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Item(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Item(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Item(this).Data.table.IntegerKeys.Table.PrintIntegers(Item(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return Item(this).Data.table.IntegerKeys.GetInteger(Item(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Item(this).Data.table.IntegerKeys.RemoveInteger(Item(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Item(this).Data.table.IntegerKeys.SetInteger(Item(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Item(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Item.Allocation.deallocate_demount.hook
		call Item(this).Data.Destroy()
	endinject
	inject Item.Allocation.allocate_mount.hook
		call Item(this).Data.Event_Create()
	endinject
    endstruct
    scope FolderEvent
    public struct StructNative
        implement Allocation
        implement List
        
            static method GetDying takes nothing returns Item
                return Memory.IntegerKeys.GetIntegerByHandle(GetTriggerWidget(), Item.KEY)
            endmethod
                static method GetOrderTarget takes nothing returns Item
                    return Item.GetFromSelf(GetOrderTargetItem())
                endmethod
                static method GetSpellTarget takes nothing returns Item
                    return Item.GetFromSelf(GetSpellTargetItem())
                endmethod
                static method GetTrigger takes nothing returns Item
                    return Item.GetFromSelf(GetManipulatedItem())
                endmethod
        endstruct
    endscope
    public struct StructEvent
        implement Allocation
        implement List
        
    FolderEvent_StructNative Native = this
    FolderEvent_StructNative LinkToStruct_Native
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(Item(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(Item(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(Item(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(Item(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(Item(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(Item(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(Item(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(Item(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject Item.Allocation.deallocate_demount.hook
			call Item(this).Event.Destroy()
		endinject
		inject Item.Allocation.allocate_mount.hook
			call Item(this).Event.Event_Create()
		endinject
    endstruct
    public struct StructClasses
        implement Allocation
        implement List
        
        static Event DESTROY_EVENT
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        method Contains takes ItemClass whichType returns boolean
            return Item(this).Data.Integer.Table.Contains(KEY_ARRAY, whichType)
        endmethod
        method Remove takes ItemClass whichType returns nothing
            if Item(this).Data.Integer.Table.Remove(KEY_ARRAY, whichType) then
                call Item(this).Event.Remove(DESTROY_EVENT)
            endif
        endmethod
        method Add takes ItemClass whichType returns nothing
            if Item(this).Data.Integer.Table.Add(KEY_ARRAY, whichType) then
                call Item(this).Event.Add(DESTROY_EVENT)
            endif
        endmethod
        eventMethod Event_Destroy
            local Item parent = params.Item.GetTrigger()
            call parent.Data.Integer.Table.Clear(KEY_ARRAY)
            call parent.Event.Remove(DESTROY_EVENT)
        endmethod
        method Event_Create takes nothing returns nothing
            local ItemType thisType = Item(this).Type.Get()
            local integer iteration = thisType.Classes.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                call this.Add(thisType.Classes.Get(iteration))
                set iteration = iteration - 1
            endloop
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DESTROY_EVENT = Event.Create(Item.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
        endmethod
    endstruct
    public struct StructType
        implement Allocation
        implement List
        
        ItemType type
        method Get takes nothing returns ItemType
            return this.type
        endmethod
        method Event_Create takes nothing returns nothing
            set this.type = ItemType.GetFromSelf(GetItemTypeId(Item(this).self))
        endmethod
    endstruct
    public struct StructAbilities
        implement Allocation
        implement List
        
        static Event DESTROY_EVENT
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
        method Count takes nothing returns integer
            return Item(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns Spell
            return Item(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method GetLevel takes Spell whichSpell returns integer
            return Item(this).Data.Integer.Get(KEY_ARRAY_DETAIL + whichSpell)
        endmethod
        method Remove takes Spell whichSpell returns nothing
            if Item(this).Data.Integer.Table.Remove(KEY_ARRAY, whichSpell) then
                call Item(this).Event.Remove(DESTROY_EVENT)
            endif
            call Item(this).Data.Integer.Remove(KEY_ARRAY_DETAIL + whichSpell)
        endmethod
        method Add takes Spell whichSpell returns nothing
            if Item(this).Data.Integer.Table.Add(KEY_ARRAY, whichSpell) then
                call Item(this).Event.Add(DESTROY_EVENT)
            endif
            call Item(this).Data.Integer.Set(KEY_ARRAY_DETAIL + whichSpell, 1)
        endmethod
        method SetLevel takes Spell whichSpell, integer level returns nothing
            if (level == 0) then
                call this.Remove(whichSpell)
                return
            endif
            if (this.GetLevel(whichSpell) == 0) then
                call this.Add(whichSpell)
            endif
            call Item(this).Data.Integer.Set(KEY_ARRAY_DETAIL + whichSpell, level)
        endmethod
        method AddLevel takes Spell whichSpell, integer value returns nothing
            call this.SetLevel(whichSpell, this.GetLevel(whichSpell) + value)
        endmethod
        eventMethod Event_Destroy
            local Item parent = params.Item.GetTrigger()
            local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local Spell whichSpell = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                call parent.Data.Integer.Table.Remove(KEY_ARRAY, whichSpell)
                call parent.Data.Integer.Remove(KEY_ARRAY_DETAIL + whichSpell)
                set iteration = iteration - 1
            endloop
            call parent.Event.Remove(DESTROY_EVENT)
        endmethod
        method Event_Create takes nothing returns nothing
            local ItemType thisType = Item(this).Type.Get()
            local integer iteration = thisType.Abilities.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local Spell whichSpell = thisType.Abilities.Get(iteration)
                call this.SetLevel(whichSpell, thisType.Abilities.GetLevel(whichSpell))
                set iteration = iteration - 1
            endloop
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DESTROY_EVENT = Event.Create(Item.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
        endmethod
    endstruct
    public struct StructChargesAmount
        implement Allocation
        implement List
        
        static EventType DUMMY_EVENT_TYPE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
        method TriggerEvents takes integer amount returns nothing
            local Item parent = this
            local EventResponse params = EventResponse.Create(parent.Id.Get())
            call params.Item.SetTrigger(parent)
			local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = parent.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            call params.Destroy()
        endmethod
        method Set takes integer amount returns nothing
            set this.value = amount
            call SetItemCharges(Item(this).self, amount)
            call this.TriggerEvents(amount)
            if ((amount == 0) and (Item(this).Type.Get().ChargesAmount.Get() > 0)) then
                call Item(this).Destroy()
            endif
        endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(Item(this).Type.Get().ChargesAmount.Get())
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        static method Init takes nothing returns nothing
            set thistype.DUMMY_EVENT_TYPE = EventType.Create()
        endmethod
    endstruct
    public struct StructPosition
        implement Allocation
        implement List
        
        method GetX takes nothing returns real
            return GetItemX(Item(this).self)
        endmethod
        method GetY takes nothing returns real
            return GetItemY(Item(this).self)
        endmethod
        method GetZ takes nothing returns real
            return Spot.GetHeight(this.GetX(), this.GetY())
        endmethod
        method Set takes real x, real y returns nothing
            call SetItemPosition(Item(this).self, x, y)
        endmethod
    endstruct
endscope
    globals
        Item ITEM = STRUCT_BASE
    endglobals
    struct Item
        implement Allocation
        implement List
        
    static EventType CREATE_EVENT_TYPE
    static EventType DEATH_EVENT_TYPE
    static EventType DESTROY_EVENT_TYPE
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static thistype TEMP
    static thistype array TEMPS
    item self
    integer slot
    FolderItem_StructAbilities Abilities = this
    FolderItem_StructAbilities LinkToStruct_Abilities
    FolderItem_StructChargesAmount ChargesAmount = this
    FolderItem_StructChargesAmount LinkToStruct_ChargesAmount
    FolderItem_StructClasses Classes = this
    FolderItem_StructClasses LinkToStruct_Classes
    FolderItem_StructData Data = this
    FolderItem_StructData LinkToStruct_Data
    FolderItem_StructEvent Event = this
    FolderItem_StructEvent LinkToStruct_Event
    FolderItem_StructId Id = this
    FolderItem_StructId LinkToStruct_Id
    FolderItem_StructPosition Position = this
    FolderItem_StructPosition LinkToStruct_Position
    FolderItem_StructType Type = this
    FolderItem_StructType LinkToStruct_Type
    static method GetFromSelf takes item self returns thistype
        return Memory.IntegerKeys.GetIntegerByHandle(self, KEY)
    endmethod
    method GetSelf takes nothing returns item
        return this.self
    endmethod
    method GetSlot takes nothing returns integer
        return this.slot
    endmethod
    method Destroy_TriggerEvents takes nothing returns nothing
        local EventResponse params = EventResponse.Create(this.Id.Get())
        call params.Item.SetTrigger(this)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = this.Event.Count(thistype.DESTROY_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.DESTROY_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    method Destroy takes nothing returns nothing
        local item self = this.self
        call SetItemPosition(self, 0., 0.)
        call this.Destroy_TriggerEvents()
        call this.deallocate()
        call Memory.IntegerKeys.SetIntegerByHandle(self, KEY, this)
        call RemoveItem(self)
        set self = null
    endmethod
    method SetLife takes real value returns nothing
        call SetWidgetLife(this.self, value)
    endmethod
    method GetName takes nothing returns string
        return GetItemName(this.self)
    endmethod
    method Death_TriggerEvents takes nothing returns nothing
        local EventResponse params = EventResponse.Create(this.Id.Get())
        call params.Item.SetTrigger(this)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = this.Event.Count(thistype.DEATH_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.DEATH_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    trigMethod DeathTrig
        local thistype this = ITEM.Event.Native.GetDying()
        call this.Death_TriggerEvents()
    endmethod
    method Kill takes nothing returns nothing
        call SetWidgetLife(this.self, 0.)
    endmethod
    method SetInvulnerable takes boolean flag returns nothing
        call SetItemInvulnerable(this.self, flag)
    endmethod
    method SetSlot takes integer value returns nothing
        set this.slot = value
    endmethod
    method RecreateSelf takes Unit owner returns nothing
        local item self = this.self
        local real x = this.Position.GetX()
        local real y = this.Position.GetY()
        call Memory.IntegerKeys.SetIntegerByHandle(self, KEY, this)
        call RemoveItem(self)
        set self = CreateItem(this.Type.Get().self, x, y)
        set this.self = self
        call Memory.IntegerKeys.SetIntegerByHandle(self, KEY, this)
        if (owner != NULL) then
            call owner.Items.Add(this)
        endif
        set self = null
    endmethod
    method Create_TriggerEvents takes nothing returns nothing
        local ItemType thisType = Item(this).Type.Get()
        local EventResponse params = EventResponse.Create(thisType.Id.Get())
        call params.Item.SetTrigger(this)
        call params.ItemType.SetTrigger(thisType)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = thisType.Event.Count(thistype.CREATE_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call thisType.Event.Get(thistype.CREATE_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    static method CreateFromSelf takes item self returns thistype
        local thistype this = thistype.allocate()
        set this.self = self
        call Memory.IntegerKeys.SetIntegerByHandle(self, KEY, this)
        call this.SetSlot(-1)
        call this.Id.Event_Create()
        call this.Type.Event_Create()
        call this.Abilities.Event_Create()
        call this.ChargesAmount.Event_Create()
        call this.Classes.Event_Create()
        call this.Create_TriggerEvents()
        return this
    endmethod
    static method Create takes ItemType whichType, real x, real y returns thistype
        return thistype.CreateFromSelf(CreateItem(whichType.self, x, y))
    endmethod
    static method CreateHidden takes ItemType whichType returns thistype
        return thistype.Create(whichType, 0., 0.)
    endmethod
    static method Start_Enum takes nothing returns nothing
        call Item.CreateFromSelf(GetEnumItem())
    endmethod
    eventMethod Event_Start
        call EnumItemsInRect(Rectangle.WORLD.self, null, function thistype.Start_Enum)
    endmethod
    initMethod Init of Header_5
        call ItemClass.Init()
        set thistype.CREATE_EVENT_TYPE = EventType.Create()
        set thistype.DEATH_EVENT_TYPE = EventType.Create()
        set thistype.DESTROY_EVENT_TYPE = EventType.Create()
        call Event.Create(EventType.START, EventPriority.HEADER, function thistype.Event_Start).AddToStatics()
        call thistype(NULL).Abilities.Init()
        call thistype(NULL).ChargesAmount.Init()
        call thistype(NULL).Classes.Init()
        call ItemType.Init()
    endmethod
endstruct
    scope FolderItemType
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    public struct StructBoolean
        implement Allocation
        implement List
        
    method Get takes integer key returns boolean
        return ItemType(this).Data.table.IntegerKeys.GetBoolean(ItemType(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call ItemType(this).Data.table.IntegerKeys.RemoveBoolean(ItemType(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call ItemType(this).Data.table.IntegerKeys.SetBoolean(ItemType(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return ItemType(this).Data.table.IntegerKeys.Table.ContainsInteger(ItemType(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return ItemType(this).Data.table.IntegerKeys.Table.CountIntegers(ItemType(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return ItemType(this).Data.table.IntegerKeys.Table.IsEmptyInteger(ItemType(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return ItemType(this).Data.table.IntegerKeys.Table.GetInteger(ItemType(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return ItemType(this).Data.table.IntegerKeys.Table.GetFirstInteger(ItemType(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return ItemType(this).Data.table.IntegerKeys.Table.GetLastInteger(ItemType(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call ItemType(this).Data.table.IntegerKeys.Table.Clear(ItemType(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return ItemType(this).Data.table.IntegerKeys.Table.FetchFirstInteger(ItemType(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return ItemType(this).Data.table.IntegerKeys.Table.RemoveInteger(ItemType(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return ItemType(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(ItemType(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return ItemType(this).Data.table.IntegerKeys.Table.AddInteger(ItemType(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return ItemType(this).Data.table.IntegerKeys.Table.AddIntegerMulti(ItemType(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call ItemType(this).Data.table.IntegerKeys.Table.JoinInteger(ItemType(this).Id.Get(), key, ItemType(other).Data.table, ItemType(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return ItemType(this).Data.table.IntegerKeys.Table.RandomInteger(ItemType(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call ItemType(this).Data.table.IntegerKeys.Table.ShuffleIntegers(ItemType(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call ItemType(this).Data.table.IntegerKeys.Table.PrintIntegers(ItemType(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return ItemType(this).Data.table.IntegerKeys.GetInteger(ItemType(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call ItemType(this).Data.table.IntegerKeys.RemoveInteger(ItemType(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call ItemType(this).Data.table.IntegerKeys.SetInteger(ItemType(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(ItemType(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject ItemType.Allocation.deallocate_demount.hook
		call ItemType(this).Data.Destroy()
	endinject
	inject ItemType.Allocation.allocate_mount.hook
		call ItemType(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructEvent
        implement Allocation
        implement List
        
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(ItemType(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(ItemType(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(ItemType(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(ItemType(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(ItemType(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(ItemType(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(ItemType(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(ItemType(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject ItemType.Allocation.deallocate_demount.hook
			call ItemType(this).Event.Destroy()
		endinject
		inject ItemType.Allocation.allocate_mount.hook
			call ItemType(this).Event.Event_Create()
		endinject
    endstruct
    public struct StructAbilities
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
        method Count takes nothing returns integer
            return ItemType(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns Spell
            return ItemType(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method GetLevel takes Spell whichSpell returns integer
            return ItemType(this).Data.Integer.Get(KEY_ARRAY_DETAIL + whichSpell)
        endmethod
        method AddWithLevel takes Spell whichSpell, integer level returns nothing
            call ItemType(this).Data.Integer.Table.Add(KEY_ARRAY, whichSpell)
            call ItemType(this).Data.Integer.Set(KEY_ARRAY_DETAIL + whichSpell, level)
        endmethod
        method Add takes Spell whichSpell returns nothing
            call this.AddWithLevel(whichSpell, 1)
        endmethod
    endstruct
    public struct StructChargesAmount
        implement Allocation
        implement List
        
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    public struct StructClasses
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        method Count takes nothing returns integer
            return ItemType(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns ItemClass
            return ItemType(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method Add takes ItemClass value returns nothing
            call ItemType(this).Data.Integer.Table.Add(KEY_ARRAY, value)
        endmethod
    endstruct
    public struct StructPreload
        implement Allocation
        implement List
        
        method Event_Create takes nothing returns nothing
            call RemoveItem(CreateItem(ItemType(this).self, 0., 0.))
        endmethod
    endstruct
    public struct StructUsageGoldCost
        implement Allocation
        implement List
        
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
endscope
    globals
        ItemType ITEM_TYPE = STRUCT_BASE
    endglobals
    struct ItemType
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    integer self
    FolderItemType_StructAbilities Abilities = this
    FolderItemType_StructAbilities LinkToStruct_Abilities
    FolderItemType_StructChargesAmount ChargesAmount = this
    FolderItemType_StructChargesAmount LinkToStruct_ChargesAmount
    FolderItemType_StructClasses Classes = this
    FolderItemType_StructClasses LinkToStruct_Classes
    FolderItemType_StructData Data = this
    FolderItemType_StructData LinkToStruct_Data
    FolderItemType_StructEvent Event = this
    FolderItemType_StructEvent LinkToStruct_Event
    FolderItemType_StructId Id = this
    FolderItemType_StructId LinkToStruct_Id
    FolderItemType_StructUsageGoldCost UsageGoldCost = this
    FolderItemType_StructUsageGoldCost LinkToStruct_UsageGoldCost
    string icon
    method GetIcon takes nothing returns string
        return this.icon
    endmethod
    method SetIcon takes string value returns nothing
        set this.icon = value
    endmethod
    static method GetFromSelf takes integer self returns thistype
        return Memory.IntegerKeys.GetInteger(self, KEY)
    endmethod
    static method GetFromName takes string name returns thistype
        return StringData.Data.Integer.Get(name, KEY)
    endmethod
    method GetName takes nothing returns string
        return GetObjectName(this.self)
    endmethod
    method GetSelf takes nothing returns integer
        return this.self
    endmethod
    static key GetKeyMacro_INIT_KEY_ARRAY
    static constant integer INIT_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_INIT_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static method AddInit takes code c, string name returns nothing
        call Trigger.AddObjectInit(INIT_KEY_ARRAY, c, name)
    endmethod
    static method CreateFromSelf takes integer self returns thistype
        local thistype this = thistype.allocate()
        set this.self = self
        call Memory.IntegerKeys.SetInteger(self, KEY, this)
        call this.Id.Event_Create()
        call this.ChargesAmount.Event_Create()
        call this.UsageGoldCost.Event_Create()
call InfoEx("item "+this.GetName())
		call StringData.Data.Integer.Set(this.GetName(), KEY, this)
        return this
    endmethod
    static method Init takes nothing returns nothing
    endmethod
endstruct
    globals
        LightningType LIGHTNING_TYPE = STRUCT_BASE
    endglobals
    struct LightningType
        implement Allocation
        implement List
        
    string self
    method GetSelf takes nothing returns string
        return this.self
    endmethod
    method SetSelf takes string value returns nothing
        set this.self = value
    endmethod
    static method Create takes string self returns thistype
        local thistype this = thistype.allocate()
        call this.SetSelf(self)
        return this
    endmethod
    static key GetKeyMacro_INIT_KEY_ARRAY
    static constant integer INIT_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_INIT_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static method AddInit takes code c, string name returns nothing
        call Trigger.AddObjectInit(INIT_KEY_ARRAY, c, name)
    endmethod
    static method Init takes nothing returns nothing
    endmethod
endstruct
    scope FolderLightning
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return Lightning(this).Data.table.IntegerKeys.Table.ContainsInteger(Lightning(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Lightning(this).Data.table.IntegerKeys.Table.CountIntegers(Lightning(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Lightning(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Lightning(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Lightning(this).Data.table.IntegerKeys.Table.GetInteger(Lightning(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Lightning(this).Data.table.IntegerKeys.Table.GetFirstInteger(Lightning(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Lightning(this).Data.table.IntegerKeys.Table.GetLastInteger(Lightning(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Lightning(this).Data.table.IntegerKeys.Table.Clear(Lightning(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Lightning(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Lightning(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Lightning(this).Data.table.IntegerKeys.Table.RemoveInteger(Lightning(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Lightning(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Lightning(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Lightning(this).Data.table.IntegerKeys.Table.AddInteger(Lightning(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Lightning(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Lightning(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Lightning(this).Data.table.IntegerKeys.Table.JoinInteger(Lightning(this).Id.Get(), key, Lightning(other).Data.table, Lightning(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Lightning(this).Data.table.IntegerKeys.Table.RandomInteger(Lightning(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Lightning(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Lightning(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Lightning(this).Data.table.IntegerKeys.Table.PrintIntegers(Lightning(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return Lightning(this).Data.table.IntegerKeys.GetInteger(Lightning(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Lightning(this).Data.table.IntegerKeys.RemoveInteger(Lightning(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Lightning(this).Data.table.IntegerKeys.SetInteger(Lightning(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Lightning(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Lightning.Allocation.deallocate_demount.hook
		call Lightning(this).Data.Destroy()
	endinject
	inject Lightning.Allocation.allocate_mount.hook
		call Lightning(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructEvent
        implement Allocation
        implement List
        
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(Lightning(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(Lightning(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(Lightning(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(Lightning(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(Lightning(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(Lightning(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(Lightning(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(Lightning(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject Lightning.Allocation.deallocate_demount.hook
			call Lightning(this).Event.Destroy()
		endinject
		inject Lightning.Allocation.allocate_mount.hook
			call Lightning(this).Event.Event_Create()
		endinject
    endstruct
    scope FolderColor
    public struct StructRed
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(GetLightningColorR(Lightning(this).self))
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructGreen
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(GetLightningColorG(Lightning(this).self))
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructBlue
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(GetLightningColorB(Lightning(this).self))
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructAlpha
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(GetLightningColorA(Lightning(this).self))
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructTimed
        implement Allocation
        implement List
        
            static Event DESTROY_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static constant real UPDATE_TIME = FRAME_UPDATE_TIME * 4
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = 4
            static Timer UPDATE_TIMER
            real bonusRedPerInterval
            real bonusGreenPerInterval
            real bonusBluePerInterval
            real bonusAlphaPerInterval
            Timer durationTimer
            Lightning parent
            method Ending takes Timer durationTimer, Lightning parent returns nothing
                call this.deallocate()
                call durationTimer.Destroy()
                if parent.Data.Integer.Table.Remove(KEY_ARRAY, this) then
                    call parent.Event.Remove(DESTROY_EVENT)
                endif
                if this.RemoveFromList() then
                    call thistype.UPDATE_TIMER.Pause()
                endif
            endmethod
            eventMethod Event_Destroy
                local Lightning parent = params.Lightning.GetTrigger()
                local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                loop
                    local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                    call this.Ending(this.durationTimer, parent)
                    set iteration = iteration - 1
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                endloop
            endmethod
            timerMethod EndingByTimer
                local Timer durationTimer = Timer.GetExpired()
                local thistype this = durationTimer.GetData()
                call this.Ending(durationTimer, this.parent)
            endmethod
            timerMethod Update
                local integer iteration = thistype.ALL_COUNT
                loop
                    local thistype this = thistype.ALL[iteration]
                    call this.parent.Color.Add(this.bonusRedPerInterval, this.bonusGreenPerInterval, this.bonusBluePerInterval, this.bonusAlphaPerInterval)
                    set iteration = iteration - 1
                    exitwhen (iteration < ARRAY_MIN)
                endloop
            endmethod
            method Add takes real red, real green, real blue, real alpha, real duration returns nothing
                local Lightning parent = this
                if (duration == 0.) then
                    call Lightning(this).Color.Add(red, green, blue, alpha)
                    return
                endif
                
                local integer wavesAmount = Real.ToInt(duration / thistype.UPDATE_TIME)
				set this = thistype.allocate()
				local Timer durationTimer = Timer.Create()
                set this.bonusRedPerInterval = red / wavesAmount
                set this.bonusGreenPerInterval = green / wavesAmount
                set this.bonusBluePerInterval = blue / wavesAmount
                set this.bonusAlphaPerInterval = alpha / wavesAmount
                set this.durationTimer = durationTimer
                set this.parent = parent
                call durationTimer.SetData(this)
                if parent.Data.Integer.Table.Add(KEY_ARRAY, this) then
                    call parent.Event.Add(DESTROY_EVENT)
                endif
                if this.AddToList() then
                    call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
                endif
                call durationTimer.Start(duration, false, function thistype.EndingByTimer)
            endmethod
            method Subtract takes real red, real green, real blue, real alpha, real duration returns nothing
                call this.Add(-red, -green, -blue, -alpha, duration)
            endmethod
            static method Init takes nothing returns nothing
                set thistype.DESTROY_EVENT = Event.Create(Lightning.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
                set thistype.UPDATE_TIMER = Timer.Create()
            endmethod
        endstruct
    endscope
    public struct StructColor
        implement Allocation
        implement List
        
    FolderColor_StructRed Red = this
    FolderColor_StructRed LinkToStruct_Red
    FolderColor_StructGreen Green = this
    FolderColor_StructGreen LinkToStruct_Green
    FolderColor_StructBlue Blue = this
    FolderColor_StructBlue LinkToStruct_Blue
    FolderColor_StructAlpha Alpha = this
    FolderColor_StructAlpha LinkToStruct_Alpha
    FolderColor_StructTimed Timed = this
    FolderColor_StructTimed LinkToStruct_Timed
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method Set takes real red, real green, real blue, real alpha returns nothing
            local User whichPlayer = User.GetLocal()
            call this.Red.Set(red)
            call this.Green.Set(green)
            call this.Blue.Set(blue)
            call this.Alpha.Set(alpha)
            set red = Math.Limit(red, 0., 1.)
            set green = Math.Limit(green, 0., 1.)
            set blue = Math.Limit(blue, 0., 1.)
            set alpha = Math.Limit(alpha, 0., 1.)
            call SetLightningColor(Lightning(this).self, red, green, blue, alpha)
        endmethod
        method Add takes real red, real green, real blue, real alpha returns nothing
            call this.Set(this.Red.Get() + red, this.Green.Get() + green, this.Blue.Get() + blue, this.Alpha.Get() + alpha)
        endmethod
        method Subtract takes real red, real green, real blue, real alpha returns nothing
            call this.Add(-red, -green, -blue, -alpha)
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.Red.Get(), this.Green.Get(), this.Blue.Get(), this.Alpha.Get())
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Red.Event_Create()
            call this.Green.Event_Create()
            call this.Blue.Event_Create()
            call this.Alpha.Event_Create()
            call this.Set(this.Red.Get(), this.Green.Get(), this.Blue.Get(), this.Alpha.Get())
        endmethod
        static method Init takes nothing returns nothing
            call thistype(NULL).Timed.Init()
        endmethod
    endstruct
    public struct StructFromDummyUnitToUnit
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        static Event PARENT_STOP_EVENT
        static Event SOURCE_DESTROY_EVENT
        static Event TARGET_DESTROY_EVENT
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
        static Timer UPDATE_TIMER
        Lightning parent
        DummyUnit source
        real sourceX
        real sourceY
        real sourceZ
        real sourceZOffset
        Unit target
        real targetX
        real targetY
        real targetZ
        timerMethod Update
            local integer iteration = thistype.ALL_COUNT
            loop
                local thistype this = thistype.ALL[iteration]
                local DummyUnit source = this.source
                local Unit target = this.target
	            local real sourceX
	            local real sourceY
	            local real sourceZ
                if (source == NULL) then
                    set sourceX = this.sourceX
                    set sourceY = this.sourceY
                    set sourceZ = this.sourceZ
                else
                    set sourceX = source.Position.X.Get()
                    set sourceY = source.Position.Y.Get()
                    set sourceZ = source.Position.Z.Get() + this.sourceZOffset
                endif
	            local real targetX
	            local real targetY
	            local real targetZ
                if (target == NULL) then
                    set targetX = this.targetX
                    set targetY = this.targetY
                    set targetZ = this.targetZ
                else
                    set targetX = target.Position.X.Get()
                    set targetY = target.Position.Y.Get()
                    set targetZ = target.Position.Z.GetByCoords(targetX, targetY) + target.Impact.Z.Get(true)
                endif
                call this.parent.Move(sourceX, sourceY, sourceZ, targetX, targetY, targetZ)
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
        endmethod
        method SourceEnding takes DummyUnit source returns nothing
            if source.Data.Integer.Table.Remove(KEY_ARRAY, this) then
                call source.Event.Remove(SOURCE_DESTROY_EVENT)
            endif
        endmethod
        method TargetEnding takes Unit target returns nothing
            if target.Data.Integer.Table.Remove(KEY_ARRAY, this) then
                call target.Event.Remove(TARGET_DESTROY_EVENT)
                call target.Refs.Subtract()
            endif
        endmethod
        method Ending takes Lightning parent, DummyUnit source, Unit target returns nothing
            call this.deallocate()
            call parent.Data.Integer.Remove(KEY)
            call parent.Event.Remove(PARENT_STOP_EVENT)
            if (source != NULL) then
                call this.SourceEnding(source)
            endif
            if (target != NULL) then
                call this.TargetEnding(target)
            endif
            if this.RemoveFromList() then
                call thistype.UPDATE_TIMER.Pause()
            endif
        endmethod
        eventMethod Event_Parent_Stop
            local Lightning parent = params.Lightning.GetTrigger()
            local thistype this = parent.Data.Integer.Get(KEY)
            call this.Ending(parent, this.source, this.target)
        endmethod
        eventMethod Event_Source_Destroy
            local DummyUnit source = params.DummyUnit.GetTrigger()
            local integer iteration = source.Data.Integer.Table.Count(KEY_ARRAY)
            loop
                local thistype this = source.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                if (this.target == NULL) then
                    call this.Ending(this.parent, source, NULL)
                    call parent.Destroy()
                else
                    call this.SourceEnding(source)
                    set this.source = NULL
                    set this.sourceX = source.Position.X.Get()
                    set this.sourceY = source.Position.Y.Get()
                    set this.sourceZ = source.Position.Z.Get() + this.sourceZOffset
                endif
                set iteration = iteration - 1
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            endloop
        endmethod
        eventMethod Event_Target_Destroy
            local Unit target = params.Unit.GetTrigger()
            local integer iteration = target.Data.Integer.Table.Count(KEY_ARRAY)
            loop
                local thistype this = target.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                if (this.source == NULL) then
                    call this.Ending(this.parent, NULL, target)
                    call parent.Destroy()
                else
                    local real targetX = target.Position.X.Get()
                    local real targetY = target.Position.Y.Get()
                    call this.TargetEnding(target)
                    set this.target = NULL
                    set this.targetX = targetX
                    set this.targetY = targetY
                    set this.targetZ = target.Position.Z.GetByCoords(targetX, targetY) + target.Impact.Z.Get(true)
                endif
                set iteration = iteration - 1
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            endloop
        endmethod
        method Start takes DummyUnit source, real sourceZOffset, Unit target returns nothing
            local Lightning parent = this
            local real targetX = target.Position.X.Get()
            local real targetY = target.Position.Y.Get()
            call parent.Start()
            set this = thistype.allocate()
            set this.parent = parent
            set this.source = source
            set this.sourceZOffset = sourceZOffset
            set this.target = target
            call parent.Data.Integer.Set(KEY, this)
            call parent.Event.Add(PARENT_STOP_EVENT)
            if source.Data.Integer.Table.Add(KEY_ARRAY, this) then
                call source.Event.Add(SOURCE_DESTROY_EVENT)
            endif
            if target.Data.Integer.Table.Add(KEY_ARRAY, this) then
                call target.Event.Add(TARGET_DESTROY_EVENT)
                call target.Refs.Add()
            endif
            call parent.Move(source.Position.X.Get(), source.Position.Y.Get(), source.Position.Z.Get() + sourceZOffset, targetX, targetY, target.Position.Z.GetByCoords(targetX, targetY) + target.Impact.Z.Get(true))
            if this.AddToList() then
                call UPDATE_TIMER.Start(UPDATE_TIME, true, function thistype.Update)
            endif
        endmethod
        static method Init takes nothing returns nothing
            set thistype.PARENT_STOP_EVENT = Event.Create(Lightning.STOP_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Parent_Stop)
            set thistype.SOURCE_DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Source_Destroy)
            set thistype.TARGET_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Target_Destroy)
            set thistype.UPDATE_TIMER = Timer.Create()
        endmethod
    endstruct
    public struct StructFromSpotToDummyUnit
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        static Event PARENT_STOP_EVENT
        static Event TARGET_DESTROY_EVENT
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
        static Timer UPDATE_TIMER
        Lightning parent
        real sourceX
        real sourceY
        real sourceZ
        DummyUnit target
        real targetX
        real targetY
        real targetZ
        timerMethod Update
            local integer iteration = thistype.ALL_COUNT
            loop
                local thistype this = thistype.ALL[iteration]
                local DummyUnit target = this.target
	            local real targetX
	            local real targetY
	            local real targetZ
                if (target == NULL) then
                    set targetX = this.targetX
                    set targetY = this.targetY
                    set targetZ = this.targetZ
                else
                    set targetX = target.Position.X.Get()
                    set targetY = target.Position.Y.Get()
                    set targetZ = target.Position.Z.Get()
                endif
                call this.parent.Move(this.sourceX, this.sourceY, this.sourceZ, targetX, targetY, targetZ)
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
        endmethod
        method Ending takes Lightning parent, DummyUnit target returns nothing
            call this.deallocate()
            call parent.Data.Integer.Remove(KEY)
            call parent.Event.Remove(PARENT_STOP_EVENT)
            if target.Data.Integer.Table.Remove(KEY_ARRAY, this) then
                call target.Event.Remove(TARGET_DESTROY_EVENT)
                
            endif
            if this.RemoveFromList() then
                call thistype.UPDATE_TIMER.Pause()
            endif
        endmethod
        eventMethod Event_Parent_Stop
            local Lightning parent = params.Lightning.GetTrigger()
            local thistype this = parent.Data.Integer.Get(KEY)
            call this.Ending(parent, this.target)
        endmethod
        eventMethod Event_Target_Destroy
            local DummyUnit target = params.DummyUnit.GetTrigger()
            local integer iteration = target.Data.Integer.Table.Count(KEY_ARRAY)
            loop
                local thistype this = target.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                call this.Ending(this.parent, target)
                call parent.Destroy()
                set iteration = iteration - 1
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            endloop
        endmethod
        method Start takes real sourceX, real sourceY, real sourceZ, DummyUnit target returns nothing
            local Lightning parent = this
            local real targetX = target.Position.X.Get()
            local real targetY = target.Position.Y.Get()
            local real targetZ = target.Position.Z.Get()
            call parent.Start()
            set this = thistype.allocate()
            set this.parent = parent
            set this.sourceX = sourceX
            set this.sourceY = sourceY
            set this.sourceZ = sourceZ
            set this.target = target
            call parent.Data.Integer.Set(KEY, this)
            call parent.Event.Add(PARENT_STOP_EVENT)
            if target.Data.Integer.Table.Add(KEY_ARRAY, this) then
                call target.Event.Add(TARGET_DESTROY_EVENT)
                
            endif
            call parent.Move(sourceX, sourceY, sourceZ, targetX, targetY, targetZ)
            if this.AddToList() then
                call thistype.UPDATE_TIMER.Start(UPDATE_TIME, true, function thistype.Update)
            endif
        endmethod
        static method Init takes nothing returns nothing
            set thistype.PARENT_STOP_EVENT = Event.Create(Lightning.STOP_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Parent_Stop)
            set thistype.TARGET_DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Target_Destroy)
            set thistype.UPDATE_TIMER = Timer.Create()
        endmethod
    endstruct
    public struct StructFromSpotToSpot
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY * Memory.IntegerKeys.Table.SIZE
        static Event PARENT_STOP_EVENT
        Lightning parent
        real sourceX
        real sourceY
        real sourceZ
        real targetX
        real targetY
        real targetZ
        method Ending takes Lightning parent returns nothing
            call this.deallocate()
            call parent.Data.Integer.Remove(KEY)
            call parent.Event.Remove(PARENT_STOP_EVENT)
        endmethod
        eventMethod Event_Parent_Stop
            local Lightning parent = params.Lightning.GetTrigger()
            local thistype this = parent.Data.Integer.Get(KEY)
            call this.Ending(parent)
        endmethod
        method Start takes real sourceX, real sourceY, real sourceZ, real targetX, real targetY, real targetZ returns nothing
            local Lightning parent = this
            call parent.Start()
            set this = thistype.allocate()
            set this.parent = parent
            set this.sourceX = sourceX
            set this.sourceY = sourceY
            set this.sourceZ = sourceZ
            set this.targetX = targetX
            set this.targetY = targetY
            set this.targetZ = targetZ
            call parent.Data.Integer.Set(KEY, this)
            call parent.Event.Add(PARENT_STOP_EVENT)
            call parent.Move(sourceX, sourceY, sourceZ, targetX, targetY, targetZ)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.PARENT_STOP_EVENT = Event.Create(Lightning.STOP_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Parent_Stop)
        endmethod
    endstruct
    public struct StructFromSpotToUnit
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        static Event PARENT_STOP_EVENT
        static Event TARGET_DESTROY_EVENT
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
        static Timer UPDATE_TIMER
        Lightning parent
        real sourceX
        real sourceY
        real sourceZ
        Unit target
        real targetX
        real targetY
        real targetZ
        timerMethod Update
            local integer iteration = thistype.ALL_COUNT
            loop
                local thistype this = thistype.ALL[iteration]
                local Unit target = this.target
	            local real targetX
	            local real targetY
	            local real targetZ
                if (target == NULL) then
                    set targetX = this.targetX
                    set targetY = this.targetY
                    set targetZ = this.targetZ
                else
                    set targetX = target.Position.X.Get()
                    set targetY = target.Position.Y.Get()
                    set targetZ = target.Position.Z.GetByCoords(targetX, targetY) + target.Impact.Z.Get(true)
                endif
                call this.parent.Move(this.sourceX, this.sourceY, this.sourceZ, targetX, targetY, targetZ)
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
        endmethod
        method Ending takes Lightning parent, Unit target returns nothing
            call this.deallocate()
            call parent.Data.Integer.Remove(KEY)
            call parent.Event.Remove(PARENT_STOP_EVENT)
            if target.Data.Integer.Table.Remove(KEY_ARRAY, this) then
                call target.Event.Remove(TARGET_DESTROY_EVENT)
                call target.Refs.Subtract()
            endif
            if this.RemoveFromList() then
                call thistype.UPDATE_TIMER.Pause()
            endif
        endmethod
        eventMethod Event_Parent_Stop
            local Lightning parent = params.Lightning.GetTrigger()
            local thistype this = parent.Data.Integer.Get(KEY)
            call this.Ending(parent, this.target)
        endmethod
        eventMethod Event_Target_Destroy
            local Unit target = params.Unit.GetTrigger()
            local integer iteration = target.Data.Integer.Table.Count(KEY_ARRAY)
            loop
                local thistype this = target.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                call this.Ending(this.parent, target)
                call parent.Destroy()
                set iteration = iteration - 1
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            endloop
        endmethod
        method Start takes real sourceX, real sourceY, real sourceZ, Unit target returns nothing
            local Lightning parent = this
            local real targetX = target.Position.X.Get()
            local real targetY = target.Position.Y.Get()
            call parent.Start()
            set this = thistype.allocate()
            set this.parent = parent
            set this.sourceX = sourceX
            set this.sourceY = sourceY
            set this.sourceZ = sourceZ
            set this.target = target
            call parent.Data.Integer.Set(KEY, this)
            call parent.Event.Add(PARENT_STOP_EVENT)
            if target.Data.Integer.Table.Add(KEY_ARRAY, this) then
                call target.Event.Add(TARGET_DESTROY_EVENT)
                call target.Refs.Add()
            endif
            call parent.Move(sourceX, sourceY, sourceZ, targetX, targetY, target.Position.Z.GetByCoords(targetX, targetY) + target.Impact.Z.Get(true))
            if this.AddToList() then
                call thistype.UPDATE_TIMER.Start(UPDATE_TIME, true, function thistype.Update)
            endif
        endmethod
        static method Init takes nothing returns nothing
            set thistype.PARENT_STOP_EVENT = Event.Create(Lightning.STOP_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Parent_Stop)
            set thistype.TARGET_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Target_Destroy)
            set thistype.UPDATE_TIMER = Timer.Create()
        endmethod
    endstruct
    public struct StructFromUnitToUnit
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        static Event PARENT_STOP_EVENT
        static Event POST_DESTROY_EVENT
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
        static Timer UPDATE_TIMER
        Lightning parent
        Unit source
        real sourceX
        real sourceY
        real sourceZ
        Unit target
        real targetX
        real targetY
        real targetZ
        timerMethod Update
            local integer iteration = thistype.ALL_COUNT
            loop
                local thistype this = thistype.ALL[iteration]
                local Unit source = this.source
                local Unit target = this.target
	            local real sourceX
	            local real sourceY
	            local real sourceZ
                if (source == NULL) then
                    set sourceX = this.sourceX
                    set sourceY = this.sourceY
                    set sourceZ = this.sourceZ
                else
                    set sourceX = source.Position.X.Get()
                    set sourceY = source.Position.Y.Get()
                    set sourceZ = source.Position.Z.GetByCoords(sourceX, sourceY) + source.Outpact.Z.Get(true)
                endif
	            local real targetX
	            local real targetY
	            local real targetZ
                if (target == NULL) then
                    set targetX = this.targetX
                    set targetY = this.targetY
                    set targetZ = this.targetZ
                else
                    set targetX = target.Position.X.Get()
                    set targetY = target.Position.Y.Get()
                    set targetZ = target.Position.Z.GetByCoords(targetX, targetY) + target.Impact.Z.Get(true)
                endif
                call this.parent.Move(sourceX, sourceY, sourceZ, targetX, targetY, targetZ)
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
        endmethod
        method PostEnding takes Unit post returns nothing
            if post.Data.Integer.Table.Remove(KEY_ARRAY, this) then
                call post.Event.Remove(POST_DESTROY_EVENT)
                call post.Refs.Subtract()
            endif
        endmethod
        method Ending takes Lightning parent, Unit source, Unit target returns nothing
            call this.deallocate()
            call parent.Data.Integer.Remove(KEY)
            call parent.Event.Remove(PARENT_STOP_EVENT)
            if (source != NULL) then
                call this.PostEnding(source)
            endif
            if (target != NULL) then
                call this.PostEnding(target)
            endif
            if this.RemoveFromList() then
                call thistype.UPDATE_TIMER.Pause()
            endif
        endmethod
        eventMethod Event_Parent_Stop
            local Lightning parent = params.Lightning.GetTrigger()
            local thistype this = parent.Data.Integer.Get(KEY)
            call this.Ending(parent, this.source, this.target)
        endmethod
        eventMethod Event_Post_Destroy
            local Unit post = params.Unit.GetTrigger()
            local integer iteration = post.Data.Integer.Table.Count(KEY_ARRAY)
            loop
                local thistype this = post.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                if (post == this.source) then
                    if (this.target == NULL) then
                        call this.Ending(this.parent, post, NULL)
                        call parent.Destroy()
                    else
                        call this.PostEnding(post)
                        set this.source = NULL
                        set this.sourceX = post.Position.X.Get()
                        set this.sourceY = post.Position.Y.Get()
                        set this.sourceZ = post.Position.Z.Get() + post.Outpact.Z.Get(true)
                    endif
                else
                    if (this.source == NULL) then
                        call this.Ending(this.parent, NULL, post)
                        call parent.Destroy()
                    else
                        call this.PostEnding(post)
                        set this.target = NULL
                        set this.targetX = post.Position.X.Get()
                        set this.targetY = post.Position.Y.Get()
                        set this.targetZ = post.Position.Z.Get() + post.Impact.Z.Get(true)
                    endif
                endif
                set iteration = iteration - 1
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            endloop
        endmethod
        method Start takes Unit source, Unit target returns nothing
            local Lightning parent = this
			if (source == target) then
				return
			endif
            local real sourceX = source.Position.X.Get()
            local real sourceY = source.Position.Y.Get()
            local real targetX = target.Position.X.Get()
            local real targetY = target.Position.Y.Get()
            call parent.Start()
            set this = thistype.allocate()
            set this.parent = parent
            set this.source = source
            set this.target = target
            call parent.Data.Integer.Set(KEY, this)
            call parent.Event.Add(PARENT_STOP_EVENT)
            if source.Data.Integer.Table.Add(KEY_ARRAY, this) then
                call source.Event.Add(POST_DESTROY_EVENT)
                call source.Refs.Add()
            endif
            if target.Data.Integer.Table.Add(KEY_ARRAY, this) then
                call target.Event.Add(POST_DESTROY_EVENT)
                call target.Refs.Add()
            endif
            call parent.Move(source.Position.X.Get(), source.Position.Y.Get(), source.Position.Z.GetByCoords(sourceX, sourceY) + source.Outpact.Z.Get(true), targetX, targetY, target.Position.Z.GetByCoords(targetX, targetY) + target.Impact.Z.Get(true))
            if this.AddToList() then
                call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
            endif
        endmethod
        static method Init takes nothing returns nothing
            set thistype.PARENT_STOP_EVENT = Event.Create(Lightning.STOP_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Parent_Stop)
            set thistype.POST_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Post_Destroy)
            set thistype.UPDATE_TIMER = Timer.Create()
        endmethod
    endstruct
    public struct StructDestroyTimed
        implement Allocation
        implement List
        
        static Event DESTROY_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
        Timer durationTimer
        Lightning parent
        method Ending takes Timer durationTimer, Lightning parent returns nothing
            call this.deallocate()
            call durationTimer.Destroy()
            call parent.Data.Integer.Remove(KEY)
            call parent.Event.Remove(DESTROY_EVENT)
        endmethod
        timerMethod EndingByTimer
            local Timer durationTimer = Timer.GetExpired()
            local thistype this = durationTimer.GetData()
            local Lightning parent = this.parent
            call this.Ending(durationTimer, parent)
            call parent.Destroy()
        endmethod
        eventMethod Event_Destroy
            local Lightning parent = params.Lightning.GetTrigger()
            local thistype this = parent.Data.Integer.Get(KEY)
            call this.Ending(this.durationTimer, parent)
        endmethod
        method Start takes real duration returns nothing
            local Lightning parent = this
            set this = parent.Data.Integer.Get(KEY)
            if (this != NULL) then
                call this.Ending(this.durationTimer, parent)
            endif
            set this = thistype.allocate()
			local Timer durationTimer = Timer.Create()
            set this.durationTimer = durationTimer
            set this.parent = parent
            call durationTimer.SetData(this)
            call parent.Data.Integer.Set(KEY, this)
            call parent.Event.Add(DESTROY_EVENT)
            call durationTimer.Start(duration, false, function thistype.EndingByTimer)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DESTROY_EVENT = Event.Create(Lightning.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
        endmethod
    endstruct
endscope
    globals
        Lightning LIGHTNING = STRUCT_BASE
    endglobals
    struct Lightning
        implement Allocation
        implement List
        
    static real FADE_OUT_DURATION = 0.35
    static EventType DESTROY_EVENT_TYPE
    static EventType STOP_EVENT_TYPE
    static thistype TEMP
    FolderLightning_StructColor Color = this
    FolderLightning_StructColor LinkToStruct_Color
    FolderLightning_StructData Data = this
    FolderLightning_StructData LinkToStruct_Data
    FolderLightning_StructDestroyTimed DestroyTimed = this
    FolderLightning_StructDestroyTimed LinkToStruct_DestroyTimed
    FolderLightning_StructEvent Event = this
    FolderLightning_StructEvent LinkToStruct_Event
    FolderLightning_StructFromDummyUnitToUnit FromDummyUnitToUnit = this
    FolderLightning_StructFromDummyUnitToUnit LinkToStruct_FromDummyUnitToUnit
    FolderLightning_StructFromSpotToDummyUnit FromSpotToDummyUnit = this
    FolderLightning_StructFromSpotToDummyUnit LinkToStruct_FromSpotToDummyUnit
    FolderLightning_StructFromSpotToSpot FromSpotToSpot = this
    FolderLightning_StructFromSpotToSpot LinkToStruct_FromSpotToSpot
    FolderLightning_StructFromSpotToUnit FromSpotToUnit = this
    FolderLightning_StructFromSpotToUnit LinkToStruct_FromSpotToUnit
    FolderLightning_StructFromUnitToUnit FromUnitToUnit = this
    FolderLightning_StructFromUnitToUnit LinkToStruct_FromUnitToUnit
    FolderLightning_StructId Id = this
    FolderLightning_StructId LinkToStruct_Id
    boolean hiddenInFog
    method IsHiddenInFog takes nothing returns boolean
        return this.hiddenInFog
    endmethod
    method SetHiddenInFog takes boolean value returns nothing
        set this.hiddenInFog = value
    endmethod
    lightning self
    method GetSelf takes nothing returns lightning
        return this.self
    endmethod
    method SetSelf takes lightning value returns nothing
        set this.self = value
    endmethod
    boolean moving
    method SetColor takes integer red, integer green, integer blue, integer alpha returns nothing
        call SetLightningColor(this.self, red / 255., green / 255., blue / 255., alpha / 255.)
    endmethod
    method Stop_TriggerEvents takes nothing returns nothing
        local EventResponse params = EventResponse.Create(this.Id.Get())
        call params.Lightning.SetTrigger(this)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = this.Event.Count(thistype.STOP_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.STOP_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    method Stop takes nothing returns nothing
        if this.moving then
            set this.moving = false
            call this.Stop_TriggerEvents()
        endif
    endmethod
    method Start takes nothing returns nothing
        if this.moving then
            call this.Stop()
        endif
        set this.moving = true
    endmethod
    method Destroy_TriggerEvents takes nothing returns nothing
        local EventResponse params = EventResponse.Create(this.Id.Get())
        call params.Lightning.SetTrigger(this)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = this.Event.Count(thistype.DESTROY_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.DESTROY_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    timerMethod CleanUp
        local Timer cleanUpTimer = Timer.GetExpired()
        local thistype this = cleanUpTimer.GetData()
        local lightning self = this.self
        call cleanUpTimer.Destroy()
        call this.deallocate()
        call DestroyLightning(self)
        set self = null
    endmethod
    method Destroy takes nothing returns nothing
        call this.Stop()
        local Timer cleanUpTimer = Timer.Create()
        call cleanUpTimer.SetData(this)
        call this.Destroy_TriggerEvents()
        call this.Color.Timed.Subtract(0., 0., 0., this.Color.Alpha.Get(), thistype.FADE_OUT_DURATION)
        call cleanUpTimer.Start(thistype.FADE_OUT_DURATION, false, function thistype.CleanUp)
    endmethod
    method Move takes real x, real y, real z, real x2, real y2, real z2 returns nothing
        call MoveLightningEx(this.self, this.hiddenInFog, x, y, z, x2, y2, z2)
    endmethod
    static method Create takes LightningType whichType returns thistype
        local thistype this = thistype.allocate()
		local lightning self = AddLightningEx(whichType.GetSelf(), false, 0., 0., 0., 0., 0., 0.)
        set this.hiddenInFog = true
        set this.moving = false
        set this.self = self
        call this.Id.Event_Create()
        call this.Color.Event_Create()
        return this
    endmethod
    static method CreatePrimarySecondary takes boolean takePrimary, LightningType primary, LightningType secondary returns thistype
        if takePrimary then
            return thistype.Create(primary)
        endif
        return thistype.Create(secondary)
    endmethod
    initMethod Init of Header_7
        call LightningType.Init()
        set thistype.DESTROY_EVENT_TYPE = EventType.Create()
        set thistype.STOP_EVENT_TYPE = EventType.Create()
        call thistype(NULL).Color.Init()
        call thistype(NULL).DestroyTimed.Init()
        call thistype(NULL).FromDummyUnitToUnit.Init()
        call thistype(NULL).FromSpotToDummyUnit.Init()
        call thistype(NULL).FromSpotToSpot.Init()
        call thistype(NULL).FromSpotToUnit.Init()
        call thistype(NULL).FromUnitToUnit.Init()
    endmethod
endstruct
    struct LimitOp
    static method GetComplement takes limitop self returns limitop
        if (self == LESS_THAN) then
            return GREATER_THAN_OR_EQUAL
        endif
        if (self == LESS_THAN_OR_EQUAL) then
            return GREATER_THAN
        endif
        if (self == EQUAL) then
            return NOT_EQUAL
        endif
        if (self == NOT_EQUAL) then
            return EQUAL
        endif
        if (self == GREATER_THAN) then
            return LESS_THAN_OR_EQUAL
        endif
        if (self == GREATER_THAN_OR_EQUAL) then
            return LESS_THAN
        endif
        return null
    endmethod
endstruct
    globals
        LoadingEx LOADING_EX = STRUCT_BASE
    endglobals
    struct LoadingEx
        implement Allocation
        implement List
        
endstruct
    globals
        AIAutoCast A_I_AUTO_CAST = STRUCT_BASE
    endglobals
    struct AIAutoCast
        implement Allocation
        implement List
        
    static BoolExpr COOLDOWN_CONDITIONS
    static BoolExpr COOLDOWN_ENDING_EVENT_CONDITIONS
    static BoolExpr COOLDOWN_START_EVENT_CONDITIONS
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY * Memory.IntegerKeys.Table.SIZE
    static BoolExpr MANA_CONDITIONS
    static key GetKeyMacro_SPELL_KEY
    static constant integer SPELL_KEY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_SPELL_KEY * Memory.IntegerKeys.Table.SIZE
    static BoolExpr AUTO_CAST_OFF_CONDITIONS
    static BoolExpr AUTO_CAST_ON_CONDITIONS
    static BoolExpr AUTO_CAST_CONDITIONS
    condEventMethod Event_CooldownStart_Conditions
        local EventCombination whichCombination = EVENT_COMBINATION.Events.GetParent(Event.GetTrigger())
        if (params.Spell.GetTrigger() != whichCombination.Data.Integer.Get(SPELL_KEY)) then
            return false
        endif
        return true
    endmethod
    condEventMethod Event_CooldownEnding_Conditions
        local EventCombination whichCombination = EVENT_COMBINATION.Events.GetParent(Event.GetTrigger())
        if (params.Spell.GetTrigger() != whichCombination.Data.Integer.Get(SPELL_KEY)) then
            return false
        endif
        return true
    endmethod
    condEventMethod GeneralConditions
        local Unit caster = Unit.GetFromId(params.GetSubjectId())
        return true
    endmethod
    condEventMethod Cooldown_Conditions
        local Unit caster = Unit.GetFromId(params.GetSubjectId())
        local EventCombination whichCombination = EventCombination.GetTrigger()
        if caster.Abilities.Cooldown.Is(whichCombination.Data.Integer.Get(SPELL_KEY)) then
            return false
        endif
        return true
    endmethod
    condEventMethod Mana_Conditions
        local Unit caster = Unit.GetFromId(params.GetSubjectId())
        local Spell whichSpell = EventCombination.GetTrigger().Data.Integer.Get(SPELL_KEY)
        if (caster.Mana.Get() < whichSpell.GetManaCost(1)) then
            return false
        endif
        return true
    endmethod
    condEventMethod Event_AutoCastOff_Conditions
        local Spell sourceSpell = params.Spell.GetSource()
        local EventCombination whichCombination = EVENT_COMBINATION.Events.GetParent(Event.GetTrigger())
        local Spell whichSpell = whichCombination.Data.Integer.Get(SPELL_KEY)
        return (sourceSpell == whichSpell)
    endmethod
    condEventMethod Event_AutoCastOn_Conditions
        local Spell triggerSpell = params.Spell.GetTrigger()
        local EventCombination whichCombination = EVENT_COMBINATION.Events.GetParent(Event.GetTrigger())
        local Spell whichSpell = whichCombination.Data.Integer.Get(SPELL_KEY)
        return (triggerSpell == whichSpell)
    endmethod
    condEventMethod AutoCast_Conditions
        local Unit caster = Unit.GetFromId(params.GetSubjectId())
        local Spell whichSpell = EventCombination.GetTrigger().Data.Integer.Get(SPELL_KEY)
        return (caster.Abilities.AutoCast.Get() == whichSpell)
    endmethod
    eventMethod Event_Unlearn
        local EventCombination whichCombination = params.Spell.GetTrigger().Data.Integer.Get(KEY)
        call params.Unit.GetTrigger().Event.Combination.Remove(whichCombination)
    endmethod
    eventMethod Event_Learn
        local EventCombination whichCombination = params.Spell.GetTrigger().Data.Integer.Get(KEY)
        call params.Unit.GetTrigger().Event.Combination.Add(whichCombination)
    endmethod
    static method CreateBasics takes Spell whichSpell, code action returns EventCombination
        local EventCombination whichCombination = EventCombination.Create(action)
        call whichCombination.SetConditions(BoolExpr.GetFromFunction(function thistype.GeneralConditions))
        if (whichSpell.GetCooldown(1) > 0.) then
            call whichCombination.Pairs.Create(UNIT.Abilities.Cooldown.ENDING_EVENT_TYPE, thistype.COOLDOWN_ENDING_EVENT_CONDITIONS, UNIT.Abilities.Cooldown.START_EVENT_TYPE, thistype.COOLDOWN_START_EVENT_CONDITIONS, thistype.COOLDOWN_CONDITIONS)
        endif
        if (whichSpell.GetManaCost(1) > 0.) then
            call whichCombination.Pairs.CreateLimit(UNIT.Mana.DUMMY_EVENT_TYPE, Real.ToInt(whichSpell.GetManaCost(1)), GREATER_THAN_OR_EQUAL, thistype.MANA_CONDITIONS)
        endif
        call whichCombination.Data.Integer.Set(SPELL_KEY, whichSpell)
        call whichSpell.Data.Integer.Set(KEY, whichCombination)
        call whichSpell.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.AI, function thistype.Event_Learn))
        call whichSpell.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.AI, function thistype.Event_Unlearn))
        call whichCombination.Pairs.Create(UNIT.Abilities.AutoCast.DUMMY_EVENT_TYPE, thistype.AUTO_CAST_ON_CONDITIONS, UNIT.Abilities.AutoCast.DUMMY_EVENT_TYPE, thistype.AUTO_CAST_OFF_CONDITIONS, thistype.AUTO_CAST_CONDITIONS)
        return whichCombination
    endmethod
    initMethod Init of AI_Header
        set thistype.COOLDOWN_CONDITIONS = BoolExpr.GetFromFunction(function thistype.Cooldown_Conditions)
        set thistype.COOLDOWN_ENDING_EVENT_CONDITIONS = BoolExpr.GetFromFunction(function thistype.Event_CooldownEnding_Conditions)
        set thistype.COOLDOWN_START_EVENT_CONDITIONS = BoolExpr.GetFromFunction(function thistype.Event_CooldownStart_Conditions)
        set thistype.MANA_CONDITIONS = BoolExpr.GetFromFunction(function thistype.Mana_Conditions)
        set thistype.AUTO_CAST_OFF_CONDITIONS = BoolExpr.GetFromFunction(function thistype.Event_AutoCastOff_Conditions)
        set thistype.AUTO_CAST_ON_CONDITIONS = BoolExpr.GetFromFunction(function thistype.Event_AutoCastOn_Conditions)
        set thistype.AUTO_CAST_CONDITIONS = BoolExpr.GetFromFunction(function thistype.AutoCast_Conditions)
    endmethod
endstruct
    globals
        AICastSpell A_I_CastSpell = STRUCT_BASE
    endglobals
    struct AICastSpell
        implement Allocation
        implement List
        
    static BoolExpr COOLDOWN_CONDITIONS
    static BoolExpr COOLDOWN_ENDING_EVENT_CONDITIONS
    static BoolExpr COOLDOWN_START_EVENT_CONDITIONS
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY * Memory.IntegerKeys.Table.SIZE
    static BoolExpr MANA_CONDITIONS
    static key GetKeyMacro_SPELL_KEY
    static constant integer SPELL_KEY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_SPELL_KEY * Memory.IntegerKeys.Table.SIZE
    condEventMethod Event_CooldownStart_Conditions takes nothing returns boolean
        local EventCombination whichCombination = EVENT_COMBINATION.Events.GetParent(Event.GetTrigger())
        if (params.Spell.GetTrigger() != whichCombination.Data.Integer.Get(SPELL_KEY)) then
            return false
        endif
        return true
    endmethod
    condEventMethod Event_CooldownEnding_Conditions
        local EventCombination whichCombination = EVENT_COMBINATION.Events.GetParent(Event.GetTrigger())
        if (params.Spell.GetTrigger() != whichCombination.Data.Integer.Get(SPELL_KEY)) then
            return false
        endif
        return true
    endmethod
    condEventMethod GeneralConditions
        local Unit caster = Unit.GetFromId(params.GetSubjectId())
        if (caster.Owner.Get().Controller.Get() != PlayerController.CPU) then
            return false
        endif
        return true
    endmethod
    condEventMethod Cooldown_Conditions
        local Unit caster = Unit.GetFromId(params.GetSubjectId())
        local EventCombination whichCombination = EventCombination.GetTrigger()
        if caster.Abilities.Cooldown.Is(whichCombination.Data.Integer.Get(SPELL_KEY)) then
            return false
        endif
        return true
    endmethod
    condEventMethod Mana_Conditions
        local Unit caster = Unit.GetFromId(params.GetSubjectId())
        local Spell whichSpell = EventCombination.GetTrigger().Data.Integer.Get(SPELL_KEY)
        if (caster.Mana.Get() < whichSpell.GetManaCost(1)) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_Unlearn
        local EventCombination whichCombination = params.Spell.GetTrigger().Data.Integer.Get(KEY)
        call params.Unit.GetTrigger().Event.Combination.Remove(whichCombination)
    endmethod
    eventMethod Event_Learn
        local EventCombination whichCombination = params.Spell.GetTrigger().Data.Integer.Get(KEY)
        call params.Unit.GetTrigger().Event.Combination.Add(whichCombination)
    endmethod
    static method CreateBasics takes Spell whichSpell, code action returns EventCombination
        local EventCombination whichCombination = EventCombination.Create(action)
        call whichCombination.SetConditions(BoolExpr.GetFromFunction(function thistype.GeneralConditions))
        if (whichSpell.GetCooldown(1) > 0.) then
            call whichCombination.Pairs.Create(UNIT.Abilities.Cooldown.ENDING_EVENT_TYPE, thistype.COOLDOWN_ENDING_EVENT_CONDITIONS, UNIT.Abilities.Cooldown.START_EVENT_TYPE, thistype.COOLDOWN_START_EVENT_CONDITIONS, thistype.COOLDOWN_CONDITIONS)
        endif
        if (whichSpell.GetManaCost(1) > 0.) then
            call whichCombination.Pairs.CreateLimit(UNIT.Mana.DUMMY_EVENT_TYPE, Real.ToInt(whichSpell.GetManaCost(1)), GREATER_THAN_OR_EQUAL, thistype.MANA_CONDITIONS)
        endif
        call whichCombination.Data.Integer.Set(SPELL_KEY, whichSpell)
        call whichSpell.Data.Integer.Set(KEY, whichCombination)
        call whichSpell.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.AI, function thistype.Event_Learn))
        call whichSpell.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.AI, function thistype.Event_Unlearn))
        return whichCombination
    endmethod
    initMethod Init of AI_Header
        set thistype.COOLDOWN_CONDITIONS = BoolExpr.GetFromFunction(function thistype.Cooldown_Conditions)
        set thistype.COOLDOWN_ENDING_EVENT_CONDITIONS = BoolExpr.GetFromFunction(function thistype.Event_CooldownEnding_Conditions)
        set thistype.COOLDOWN_START_EVENT_CONDITIONS = BoolExpr.GetFromFunction(function thistype.Event_CooldownStart_Conditions)
        set thistype.MANA_CONDITIONS = BoolExpr.GetFromFunction(function thistype.Mana_Conditions)
    endmethod
endstruct
    globals
        CustomDrop CUSTOM_DROP = STRUCT_BASE
    endglobals
    struct CustomDrop
        implement Allocation
        implement List
        
    string whichEffectAttachPoint
    integer whichEffectLevel
    string whichEffectPath
    Event whichEvent
    method GetEffectAttachPoint takes nothing returns string
        return this.whichEffectAttachPoint
    endmethod
    method GetEffectLevel takes nothing returns integer
        return this.whichEffectLevel
    endmethod
    method GetEffectPath takes nothing returns string
        return this.whichEffectPath
    endmethod
    method GetEvent takes nothing returns Event
        return this.whichEvent
    endmethod
    static method Create takes Event whichEvent, string whichEffectPath, string whichEffectAttachPoint, EffectLevel whichEffectLevel returns thistype
        local thistype this = thistype.allocate()
        set this.whichEffectAttachPoint = whichEffectAttachPoint
        set this.whichEffectLevel = whichEffectLevel
        set this.whichEffectPath = whichEffectPath
        set this.whichEvent = whichEvent
        return this
    endmethod
endstruct
    scope FolderDummyUnit
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return DummyUnit(this).Data.table.IntegerKeys.Table.ContainsInteger(DummyUnit(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return DummyUnit(this).Data.table.IntegerKeys.Table.CountIntegers(DummyUnit(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return DummyUnit(this).Data.table.IntegerKeys.Table.IsEmptyInteger(DummyUnit(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return DummyUnit(this).Data.table.IntegerKeys.Table.GetInteger(DummyUnit(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return DummyUnit(this).Data.table.IntegerKeys.Table.GetFirstInteger(DummyUnit(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return DummyUnit(this).Data.table.IntegerKeys.Table.GetLastInteger(DummyUnit(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call DummyUnit(this).Data.table.IntegerKeys.Table.Clear(DummyUnit(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return DummyUnit(this).Data.table.IntegerKeys.Table.FetchFirstInteger(DummyUnit(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return DummyUnit(this).Data.table.IntegerKeys.Table.RemoveInteger(DummyUnit(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return DummyUnit(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(DummyUnit(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return DummyUnit(this).Data.table.IntegerKeys.Table.AddInteger(DummyUnit(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return DummyUnit(this).Data.table.IntegerKeys.Table.AddIntegerMulti(DummyUnit(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call DummyUnit(this).Data.table.IntegerKeys.Table.JoinInteger(DummyUnit(this).Id.Get(), key, DummyUnit(other).Data.table, DummyUnit(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return DummyUnit(this).Data.table.IntegerKeys.Table.RandomInteger(DummyUnit(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call DummyUnit(this).Data.table.IntegerKeys.Table.ShuffleIntegers(DummyUnit(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call DummyUnit(this).Data.table.IntegerKeys.Table.PrintIntegers(DummyUnit(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return DummyUnit(this).Data.table.IntegerKeys.GetInteger(DummyUnit(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call DummyUnit(this).Data.table.IntegerKeys.RemoveInteger(DummyUnit(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call DummyUnit(this).Data.table.IntegerKeys.SetInteger(DummyUnit(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(DummyUnit(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject DummyUnit.Allocation.deallocate_demount.hook
		call DummyUnit(this).Data.Destroy()
	endinject
	inject DummyUnit.Allocation.allocate_mount.hook
		call DummyUnit(this).Data.Event_Create()
	endinject
    endstruct
    scope FolderEvent
    public struct StructNative
        implement Allocation
        implement List
        
                static method GetTrigger takes nothing returns DummyUnit
                    return DummyUnit.GetFromSelf(GetTriggerUnit())
                endmethod
        endstruct
    endscope
    public struct StructEvent
        implement Allocation
        implement List
        
    FolderEvent_StructNative Native = this
    FolderEvent_StructNative LinkToStruct_Native
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(DummyUnit(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(DummyUnit(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(DummyUnit(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(DummyUnit(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(DummyUnit(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(DummyUnit(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(DummyUnit(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(DummyUnit(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject DummyUnit.Allocation.deallocate_demount.hook
			call DummyUnit(this).Event.Destroy()
		endinject
		inject DummyUnit.Allocation.allocate_mount.hook
			call DummyUnit(this).Event.Event_Create()
		endinject
    endstruct
    public struct StructAbilities
        implement Allocation
        implement List
        
        method GetLevelBySelf takes integer spellSelf returns integer
            return GetUnitAbilityLevel(DummyUnit(this).self, spellSelf)
        endmethod
        method GetLevel takes Spell whichSpell returns integer
            return this.GetLevelBySelf(whichSpell.self)
        endmethod
        method SetLevelBySelf takes integer spellSelf, integer level returns integer
            return SetUnitAbilityLevel(DummyUnit(this).self, spellSelf, level)
        endmethod
        method SetLevel takes Spell whichSpell, integer level returns integer
            return this.SetLevelBySelf(whichSpell.self, level)
        endmethod
        method RemoveBySelf takes integer spellSelf returns boolean
            return UnitRemoveAbility(DummyUnit(this).self, spellSelf)
        endmethod
        method Remove takes Spell whichSpell returns boolean
            return this.RemoveBySelf(whichSpell.self)
        endmethod
        method AddBySelf takes integer spellSelf returns boolean
            return UnitAddAbility(DummyUnit(this).self, spellSelf)
        endmethod
        method Add takes Spell whichSpell returns boolean
            return this.AddBySelf(whichSpell.self)
        endmethod
    endstruct
    public struct StructAnimation
        implement Allocation
        implement List
        
        method Queue takes string whichAnimation returns nothing
            call QueueUnitAnimation(DummyUnit(this).self, whichAnimation)
        endmethod
        method Set takes string whichAnimation returns nothing
            call SetUnitAnimation(DummyUnit(this).self, whichAnimation)
        endmethod
        method SetByIndex takes integer whichAnimation returns nothing
            call SetUnitAnimationByIndex(DummyUnit(this).self, whichAnimation)
        endmethod
    endstruct
    public struct StructDestroyTimed
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
        DummyUnit parent
        static method Ending takes nothing returns nothing
            local Timer durationTimer = Timer.GetExpired()
            local thistype this = durationTimer.GetData()
            local DummyUnit parent = this.parent
            call this.deallocate()
            call durationTimer.Destroy()
            call parent.DestroyInstantly()
        endmethod
        method Start takes real duration returns nothing
            local DummyUnit parent = this
            set this = thistype.allocate()
			local Timer durationTimer = Timer.Create()
            set this.parent = parent
            call durationTimer.SetData(this)
            call durationTimer.Start(duration, false, function thistype.Ending)
        endmethod
    endstruct
    public struct StructDestruction
        implement Allocation
        implement List
        
        static constant real DURATION = 5.
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
        DummyUnit parent
        static method Ending takes nothing returns nothing
            local Timer durationTimer = Timer.GetExpired()
            local thistype this = durationTimer.GetData()
            local DummyUnit parent = this.parent
            call this.deallocate()
            call durationTimer.Destroy()
            call parent.DestroyInstantly()
        endmethod
        method Start takes nothing returns nothing
            local DummyUnit parent = this
            set this = thistype.allocate()
			local Timer durationTimer = Timer.Create()
            set this.parent = parent
            call durationTimer.SetData(this)
            call durationTimer.Start(thistype.DURATION, false, function thistype.Ending)
        endmethod
    endstruct
    public struct StructFacing
        implement Allocation
        implement List
        
        static constant real STANDARD = Math.SOUTH_ANGLE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method GetNative takes nothing returns real
            return (GetUnitFacing(DummyUnit(this).self) * Math.DEG_TO_RAD)
        endmethod
        method Set takes real value returns nothing
            set this.value = value
            call SetUnitFacing(DummyUnit(this).self, value * Math.RAD_TO_DEG)
           
        endmethod
        method SetToDestructable takes Destructable target returns nothing
            call this.Set(Math.AtanByDeltas(target.GetY() - DummyUnit(this).Position.Y.Get(), target.GetX() - DummyUnit(this).Position.X.Get()))
        endmethod
        method SetToOtherDummyUnit takes DummyUnit otherDummyUnit returns nothing
            call this.Set(Math.AtanByDeltas(otherDummyUnit.Position.Y.Get() - DummyUnit(this).Position.Y.Get(), otherDummyUnit.Position.X.Get() - DummyUnit(this).Position.X.Get()))
        endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    public struct StructPlayerColor
        implement Allocation
        implement List
        
        method Set takes playercolor value returns nothing
            call SetUnitColor(DummyUnit(this).self, value)
        endmethod
    endstruct
    public struct StructOrder
        implement Allocation
        implement List
        
        method GetNative takes nothing returns Order
            return Order.GetFromSelf(GetUnitCurrentOrder(DummyUnit(this).self))
        endmethod
        method Immediate takes Order whichOrder returns boolean
            return IssueImmediateOrderById(DummyUnit(this).self, whichOrder.self)
        endmethod
        method PointTarget takes Order whichOrder, real x, real y returns boolean
            return IssuePointOrderById(DummyUnit(this).self, whichOrder.self, x, y)
        endmethod
        method UnitTarget takes Order whichOrder, Unit target returns boolean
            return IssueTargetOrderById(DummyUnit(this).self, whichOrder.self, Unit(target).self)
        endmethod
        method UnitTargetInstantly takes Order whichOrder, Unit target returns boolean
            call DummyUnit(this).Position.X.Set(target.Position.X.Get())
            call DummyUnit(this).Position.Y.Set(target.Position.Y.Get())
            return this.UnitTarget(whichOrder, target)
        endmethod
    endstruct
    public struct StructOwner
        implement Allocation
        implement List
        
        User owner
        method Get takes nothing returns User
            return this.owner
        endmethod
        method Set takes User owner returns nothing
            set this.owner = owner
            call SetUnitOwner(DummyUnit(this).self, owner.self, true)
        endmethod
        method Event_Create takes User owner returns nothing
            set this.owner = owner
        endmethod
    endstruct
    scope FolderPosition
    public struct StructX
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method GetNative takes nothing returns real
                return GetUnitX(DummyUnit(this).self)
            endmethod
            method Set takes real val returns nothing
                if ((val < WORLD_MIN_X) or (val > WORLD_MAX_X)) then
                    call DebugEx(thistype.NAME + " out of bounds " + DummyUnit(this).GetName() + " " + R2S(val))
                    return
                endif
                set this.value = val
                call SetUnitX(DummyUnit(this).self, val)
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructY
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method GetNative takes nothing returns real
                return GetUnitY(DummyUnit(this).self)
            endmethod
            method Set takes real val returns nothing
                if ((val < WORLD_MIN_Y) or (val > WORLD_MAX_Y)) then
                    call DebugEx(thistype.NAME + " out of bounds " + DummyUnit(this).GetName() + " " + R2S(val))
                    return
                endif
                set this.value = val
                call SetUnitY(DummyUnit(this).self, val)
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructZ
        implement Allocation
        implement List
        
            real value
            method Get takes nothing returns real
                return this.value
            endmethod
            method GetFlyHeight takes nothing returns real
                return (this.value - Spot.GetHeight(DummyUnit(this).Position.X.Get(), DummyUnit(this).Position.Y.Get()))
            endmethod
            method GetFlyHeightNative takes nothing returns real
                return GetUnitFlyHeight(DummyUnit(this).self)
            endmethod
            method GetNative takes nothing returns real
                return (Spot.GetHeight(DummyUnit(this).Position.X.GetNative(), DummyUnit(this).Position.Y.GetNative()) + this.GetFlyHeightNative())
            endmethod
            method SetByCoords takes real x, real y, real z returns nothing
                set this.value = z
                call SetUnitFlyHeight(DummyUnit(this).self, z - Spot.GetHeight(x, y), 0.)
            endmethod
            method UpdateByCoords takes real x, real y returns nothing
                call this.SetByCoords(x, y, this.value)
            endmethod
            method Set takes real z returns nothing
                call this.SetByCoords(DummyUnit(this).Position.X.Get(), DummyUnit(this).Position.Y.Get(), z)
            endmethod
            method SetFlyHeightNative takes real height, real duration returns nothing
                if (duration > 0) then
                    call SetUnitFlyHeight(DummyUnit(this).self, height, (height - this.GetFlyHeightNative()) / duration)
                else
                    call SetUnitFlyHeight(DummyUnit(this).self, height, 0.)
                endif
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes real x, real y, real z returns nothing
                call DummyUnit(this).Abilities.AddBySelf(BJUnit.Z_ENABLER_SPELL_ID)
                call DummyUnit(this).Abilities.RemoveBySelf(BJUnit.Z_ENABLER_SPELL_ID)
                call this.SetByCoords(x, y, z)
            endmethod
        endstruct
    endscope
    public struct StructPosition
        implement Allocation
        implement List
        
    FolderPosition_StructX X = this
    FolderPosition_StructX LinkToStruct_X
    FolderPosition_StructY Y = this
    FolderPosition_StructY LinkToStruct_Y
    FolderPosition_StructZ Z = this
    FolderPosition_StructZ LinkToStruct_Z
        method Set takes real x, real y, real z returns nothing
            call this.X.Set(x)
            call this.Y.Set(y)
            call this.Z.SetByCoords(x, y, z)
        endmethod
        method Add takes real x, real y, real z returns nothing
            call this.Set(this.X.Get() + x, this.Y.Get() + y, this.Z.Get() + z)
        endmethod
        method SetXY takes real x, real y returns nothing
            call this.X.Set(x)
            call this.Y.Set(y)
            call this.Z.SetByCoords(x, y, this.Z.Get())
        endmethod
        method AddXY takes real x, real y returns nothing
            call this.SetXY(this.X.Get() + x, this.Y.Get() + y)
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.X.Get(), this.Y.Get(), this.Z.Get())
        endmethod
    endstruct
    public struct StructFollowDummyUnit
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
        static Event PARENT_DESTROY_EVENT
        static Event TARGET_DESTROY_EVENT
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
        static Timer UPDATE_TIMER
        real offsetX
        real offsetY
        real offsetZ
        DummyUnit target
        boolean useScale
        method Ending takes DummyUnit parent, DummyUnit target returns nothing
            call parent.Event.Remove(PARENT_DESTROY_EVENT)
            call target.Data.Integer.Remove(KEY)
            
            if this.RemoveFromList() then
                call thistype.UPDATE_TIMER.Pause()
            endif
        endmethod
        eventMethod Event_ParentDestroy
            local DummyUnit parent = params.DummyUnit.GetTrigger()
            local thistype this = parent
            call this.Ending(parent, this.target)
        endmethod
        eventMethod Event_TargetDestroy
            local DummyUnit target = params.DummyUnit.GetTrigger()
            local thistype this = target.Data.Integer.Get(KEY)
            call this.Ending(this, target)
        endmethod
        timerMethod Update
            local integer iteration = thistype.ALL_COUNT
            loop
                local thistype this = thistype.ALL[iteration]
                local real offsetX = this.offsetX
                local real offsetY = this.offsetY
                local real offsetZ = this.offsetZ
                local DummyUnit target = this.target
                if this.useScale then
                    local real scale = target.Scale.Get()
                    set offsetX = offsetX * scale
                    set offsetY = offsetY * scale
                    set offsetZ = offsetZ * scale
                endif
                call DummyUnit(this).Position.Set(target.Position.X.GetNative() + offsetX, target.Position.Y.GetNative() + offsetY, target.Position.Z.Get() + offsetZ)
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
        endmethod
        method Start takes DummyUnit target, boolean useScale, real offsetX, real offsetY, real offsetZ returns nothing
            set this.offsetX = offsetX
            set this.offsetY = offsetY
            set this.offsetZ = offsetZ
            set this.target = target
            set this.useScale = useScale
            call DummyUnit(this).Event.Add(PARENT_DESTROY_EVENT)
            
            if this.AddToList() then
                call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
            endif
        endmethod
        static method Init takes nothing returns nothing
            set thistype.PARENT_DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_ParentDestroy)
            
            set thistype.UPDATE_TIMER = Timer.Create()
        endmethod
    endstruct
    public struct StructFollowUnit
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
        static Event PARENT_DESTROY_EVENT
        static Event TARGET_DESTROY_EVENT
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
        static Timer UPDATE_TIMER
        real offsetX
        real offsetY
        real offsetZ
        Unit target
        boolean useOutpact
        boolean useScale
        method Ending takes DummyUnit parent, Unit target returns nothing
            call parent.Event.Remove(PARENT_DESTROY_EVENT)
            call target.Data.Integer.Remove(KEY)
            
            if this.RemoveFromList() then
                call thistype.UPDATE_TIMER.Pause()
            endif
        endmethod
        eventMethod Event_ParentDestroy
            local DummyUnit parent = params.DummyUnit.GetTrigger()
            local thistype this = parent
            call this.Ending(parent, this.target)
        endmethod
        eventMethod Event_TargetDestroy
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target.Data.Integer.Get(KEY)
            call this.Ending(this, target)
        endmethod
        timerMethod Update
            local integer iteration = thistype.ALL_COUNT
            loop
                local thistype this = thistype.ALL[iteration]
                local real offsetX = this.offsetX
                local real offsetY = this.offsetY
                local real offsetZ = this.offsetZ
                local Unit target = this.target
                if this.useOutpact then
                    set offsetX = offsetX + target.Outpact.X.Get(false)
                    set offsetY = offsetY + target.Outpact.Y.Get(false)
                    set offsetZ = offsetZ + target.Outpact.Z.Get(false)
                endif
                if this.useScale then
                    local real scale = target.Scale.Get()
                    set offsetX = offsetX * scale
                    set offsetY = offsetY * scale
                    set offsetZ = offsetZ * scale
                endif
                call DummyUnit(this).Position.Set(target.Position.X.Get() + offsetX, target.Position.Y.Get() + offsetY, target.Position.Z.Get() + offsetZ)
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
        endmethod
        method Start takes Unit target, boolean useOutpact, boolean useScale, real offsetX, real offsetY, real offsetZ returns nothing
            set this.offsetX = offsetX
            set this.offsetY = offsetY
            set this.offsetZ = offsetZ
            set this.target = target
            set this.useOutpact = useOutpact
            set this.useScale = useScale
            call DummyUnit(this).Event.Add(PARENT_DESTROY_EVENT)
            
            if this.AddToList() then
                call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
            endif
        endmethod
        static method Init takes nothing returns nothing
            set thistype.PARENT_DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_ParentDestroy)
            
            set thistype.UPDATE_TIMER = Timer.Create()
        endmethod
    endstruct
    public struct StructRotate
        implement Allocation
        implement List
        
        static Event DESTROY_EVENT
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
        static Timer UPDATE_TIMER
        real add
        method Ending takes nothing returns nothing
            call DummyUnit(this).Event.Remove(DESTROY_EVENT)
            if this.RemoveFromList() then
                call thistype.UPDATE_TIMER.Pause()
            endif
        endmethod
        eventMethod Event_Destroy
            local thistype this = params.DummyUnit.GetTrigger()
            call this.Ending()
        endmethod
        timerMethod Update
            local integer iteration = thistype.ALL_COUNT
            loop
                local thistype this = thistype.ALL[iteration]
                call DummyUnit(this).Facing.Add(this.add)
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
        endmethod
        method Start takes real speed returns nothing
            set this.add = speed * thistype.UPDATE_TIME
            call DummyUnit(this).Event.Add(DESTROY_EVENT)
            if this.AddToList() then
                call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
            endif
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
            set thistype.UPDATE_TIMER = Timer.Create()
        endmethod
    endstruct
    scope FolderScale
    public struct StructTimed
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static constant real UPDATE_TIME = (1 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (1 * 1.))
            static Timer UPDATE_TIMER
            real bonusScalePerInterval
            Timer durationTimer
            DummyUnit parent
            private method Ending takes Timer durationTimer, DummyUnit parent returns nothing
                call this.deallocate()
                call durationTimer.Destroy()
                call parent.Data.Integer.Table.Remove(KEY_ARRAY, this)
                if this.RemoveFromList() then
                    call thistype.UPDATE_TIMER.Pause()
                endif
            endmethod
            eventMethod Event_Decay
                local DummyUnit parent = params.DummyUnit.GetTrigger()
                local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                if (iteration > Memory.IntegerKeys.Table.EMPTY) then
                    loop
                        local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                        call this.Ending(this.durationTimer, parent)
                        set iteration = iteration - 1
                        exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    endloop
                endif
            endmethod
            timerMethod EndingByTimer
                local Timer durationTimer = Timer.GetExpired()
                local thistype this = durationTimer.GetData()
                call this.Ending(durationTimer, this.parent)
            endmethod
            timerMethod Update
                local integer iteration = thistype.ALL_COUNT
                loop
                    local thistype this = thistype.ALL[iteration]
                    call this.parent.Scale.Add(this.bonusScalePerInterval)
                    set iteration = iteration - 1
                    exitwhen (iteration < ARRAY_MIN)
                endloop
            endmethod
            method Add takes real scale, real duration returns nothing
                local DummyUnit parent = this
                if (duration == 0.) then
                    call DummyUnit(this).Scale.Add(scale)
                    return
                endif
				local integer wavesAmount = Real.ToInt(duration / thistype.UPDATE_TIME)
                set this = thistype.allocate()
				local Timer durationTimer = Timer.Create()
                set this.bonusScalePerInterval = scale / wavesAmount
                set this.durationTimer = durationTimer
                set this.parent = parent
                call durationTimer.SetData(this)
                call parent.Data.Integer.Table.Add(KEY_ARRAY, this)
                if this.AddToList() then
                    call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
                endif
                call durationTimer.Start(duration, false, function thistype.EndingByTimer)
            endmethod
            method Subtract takes real scale, real duration returns nothing
                call this.Add(-scale, duration)
            endmethod
            static method Init takes nothing returns nothing
                set thistype.UPDATE_TIMER = Timer.Create()
            endmethod
        endstruct
    endscope
    public struct StructScale
        implement Allocation
        implement List
        
    FolderScale_StructTimed Timed = this
    FolderScale_StructTimed LinkToStruct_Timed
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method Set takes real value returns nothing
            set this.value = value
            call SetUnitScale(DummyUnit(this).self, value, value, value)
        endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(1.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        static method Init takes nothing returns nothing
            call thistype(NULL).Timed.Init()
        endmethod
    endstruct
    scope FolderVertexColor
    public struct StructRed
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(255.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructGreen
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(255.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructBlue
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(255.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructAlpha
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(255.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructTimed
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
            static Timer UPDATE_TIMER
            real bonusRedPerInterval
            real bonusGreenPerInterval
            real bonusBluePerInterval
            real bonusAlphaPerInterval
            Timer durationTimer
            DummyUnit parent
            private method Ending takes Timer durationTimer, DummyUnit parent returns nothing
                call this.deallocate()
                call durationTimer.Destroy()
                call parent.Data.Integer.Table.Remove(KEY_ARRAY, this)
                if this.RemoveFromList() then
                    call thistype.UPDATE_TIMER.Pause()
                endif
            endmethod
            eventMethod Event_Decay
                local DummyUnit parent = params.DummyUnit.GetTrigger()
                local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                if (iteration > Memory.IntegerKeys.Table.EMPTY) then
                    loop
                        local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                        call this.Ending(this.durationTimer, parent)
                        set iteration = iteration - 1
                        exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    endloop
                endif
            endmethod
            timerMethod EndingByTimer
                local Timer durationTimer = Timer.GetExpired()
                local thistype this = durationTimer.GetData()
                call this.Ending(durationTimer, this.parent)
            endmethod
            timerMethod Update
                local integer iteration = thistype.ALL_COUNT
                loop
                    local thistype this = thistype.ALL[iteration]
                    call this.parent.VertexColor.Add(this.bonusRedPerInterval, this.bonusGreenPerInterval, this.bonusBluePerInterval, this.bonusAlphaPerInterval)
                    set iteration = iteration - 1
                    exitwhen (iteration < ARRAY_MIN)
                endloop
            endmethod
            method Add takes real red, real green, real blue, real alpha, real duration returns nothing
                local DummyUnit parent = this
                if (duration == 0.) then
                    call DummyUnit(this).VertexColor.Add(red, green, blue, alpha)
                    return
                endif
				local integer wavesAmount = Real.ToInt(duration / thistype.UPDATE_TIME)
                set this = thistype.allocate()
                local Timer durationTimer = Timer.Create()
                set this.bonusRedPerInterval = red / wavesAmount
                set this.bonusGreenPerInterval = green / wavesAmount
                set this.bonusBluePerInterval = blue / wavesAmount
                set this.bonusAlphaPerInterval = alpha / wavesAmount
                set this.durationTimer = durationTimer
                set this.parent = parent
                call durationTimer.SetData(this)
                call parent.Data.Integer.Table.Add(KEY_ARRAY, this)
                if this.AddToList() then
                    call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
                endif
                call durationTimer.Start(duration, false, function thistype.EndingByTimer)
            endmethod
            method Subtract takes real red, real green, real blue, real alpha, real duration returns nothing
                call this.Add(-red, -green, -blue, -alpha, duration)
            endmethod
            static method Init takes nothing returns nothing
                set thistype.UPDATE_TIMER = Timer.Create()
            endmethod
        endstruct
    endscope
    public struct StructVertexColor
        implement Allocation
        implement List
        
    FolderVertexColor_StructRed Red = this
    FolderVertexColor_StructRed LinkToStruct_Red
    FolderVertexColor_StructGreen Green = this
    FolderVertexColor_StructGreen LinkToStruct_Green
    FolderVertexColor_StructBlue Blue = this
    FolderVertexColor_StructBlue LinkToStruct_Blue
    FolderVertexColor_StructAlpha Alpha = this
    FolderVertexColor_StructAlpha LinkToStruct_Alpha
    FolderVertexColor_StructTimed Timed = this
    FolderVertexColor_StructTimed LinkToStruct_Timed
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method Set takes real red, real green, real blue, real alpha returns nothing
            call this.Red.Set(red)
            call this.Green.Set(green)
            call this.Blue.Set(blue)
            call this.Alpha.Set(alpha)
            call SetUnitVertexColor(DummyUnit(this).self, Real.ToInt(red), Real.ToInt(green), Real.ToInt(blue), Real.ToInt(alpha))
        endmethod
        method Add takes real red, real green, real blue, real alpha returns nothing
            call this.Set(this.Red.Get() + red, this.Green.Get() + green, this.Blue.Get() + blue, this.Alpha.Get() + alpha)
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.Red.Get(), this.Green.Get(), this.Blue.Get(), this.Alpha.Get())
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(255., 255., 255., 255.)
        endmethod
        static method Init takes nothing returns nothing
            call thistype(NULL).Timed.Init()
        endmethod
    endstruct
endscope
    globals
        DummyUnit DUMMY_UNIT = STRUCT_BASE
    endglobals
    struct DummyUnit
        implement Allocation
        implement List
        
    static EventType DEATH_EVENT_TYPE
    static EventType DESTROY_EVENT_TYPE
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static constant integer NONE_ID = 0
    static thistype WORLD_CASTER
    unit self
    integer typeId
    FolderDummyUnit_StructAbilities Abilities = this
    FolderDummyUnit_StructAbilities LinkToStruct_Abilities
    FolderDummyUnit_StructAnimation Animation = this
    FolderDummyUnit_StructAnimation LinkToStruct_Animation
    FolderDummyUnit_StructData Data = this
    FolderDummyUnit_StructData LinkToStruct_Data
    FolderDummyUnit_StructDestroyTimed DestroyTimed = this
    FolderDummyUnit_StructDestroyTimed LinkToStruct_DestroyTimed
    FolderDummyUnit_StructDestruction Destruction = this
    FolderDummyUnit_StructDestruction LinkToStruct_Destruction
    FolderDummyUnit_StructEvent Event = this
    FolderDummyUnit_StructEvent LinkToStruct_Event
    FolderDummyUnit_StructFacing Facing = this
    FolderDummyUnit_StructFacing LinkToStruct_Facing
    FolderDummyUnit_StructFollowDummyUnit FollowDummyUnit = this
    FolderDummyUnit_StructFollowDummyUnit LinkToStruct_FollowDummyUnit
    FolderDummyUnit_StructFollowUnit FollowUnit = this
    FolderDummyUnit_StructFollowUnit LinkToStruct_FollowUnit
    FolderDummyUnit_StructId Id = this
    FolderDummyUnit_StructId LinkToStruct_Id
    FolderDummyUnit_StructOrder Order = this
    FolderDummyUnit_StructOrder LinkToStruct_Order
    FolderDummyUnit_StructOwner Owner = this
    FolderDummyUnit_StructOwner LinkToStruct_Owner
    FolderDummyUnit_StructPlayerColor PlayerColor = this
    FolderDummyUnit_StructPlayerColor LinkToStruct_PlayerColor
    FolderDummyUnit_StructPosition Position = this
    FolderDummyUnit_StructPosition LinkToStruct_Position
    FolderDummyUnit_StructRotate Rotate = this
    FolderDummyUnit_StructRotate LinkToStruct_Rotate
    FolderDummyUnit_StructScale Scale = this
    FolderDummyUnit_StructScale LinkToStruct_Scale
    FolderDummyUnit_StructVertexColor VertexColor = this
    FolderDummyUnit_StructVertexColor LinkToStruct_VertexColor
    static method GetFromSelf takes unit self returns thistype
        return Memory.IntegerKeys.GetIntegerByHandle(self, KEY)
    endmethod
    method GetName takes nothing returns string
        return GetUnitName(this.self)
    endmethod
    method GetSelf takes nothing returns unit
        return this.self
    endmethod
    method GetProperName takes nothing returns string
        return GetHeroProperName(this.self)
    endmethod
    method GetTypeId takes nothing returns integer
        return this.typeId
    endmethod
    method DestroyInstantly takes nothing returns nothing
        local EventResponse params = EventResponse.Create(this.Id.Get())
        call params.DummyUnit.SetTrigger(this)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = this.Event.Count(thistype.DESTROY_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.DESTROY_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
		local unit self = this.self
        call this.deallocate()
        call RemoveUnit(self)
        set self = null
    endmethod
    method Destroy takes nothing returns nothing
        local EventResponse params = EventResponse.Create(this.Id.Get())
        call params.DummyUnit.SetTrigger(this)
if (GetUnitAbilityLevel(this.self, thistype.LOCUST_SPELL_ID) == 0) then
	call DebugEx(GetUnitName(this.self) + " had no locust")
endif
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = this.Event.Count(thistype.DEATH_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.DEATH_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
        call this.Animation.Set(Animation.DEATH)
        call this.Animation.Queue(null)
        call this.Destruction.Start()
    endmethod
    method Flash takes integer red, integer green, integer blue, integer alpha returns nothing
        call AddIndicator(this.self, red, green, blue, alpha)
    endmethod
    method Kill takes nothing returns nothing
        call KillUnit(this.self)
    endmethod
    method SetMoveSpeed takes real value returns nothing
        call SetUnitMoveSpeed(this.self, value)
    endmethod
    method SetMoveWindow takes real value returns nothing
        call SetUnitPropWindow(this.self, value)
    endmethod
    method SetLocust takes nothing returns nothing
        call UnitAddAbility(this.self, thistype.LOCUST_SPELL_ID)
    endmethod
    method SetScale takes real scale returns nothing
        call SetUnitScale(this.self, scale, scale, scale)
    endmethod
    method SetTimeScale takes real scale returns nothing
        call SetUnitTimeScale(this.self, scale)
    endmethod
    method SetTurnSpeed takes real value returns nothing
        call SetUnitTurnSpeed(this.self, value)
    endmethod
    method AddEffect takes string path, string attachPoint, EffectLevel level returns DummyUnitEffect
        return DummyUnitEffect.Create(this, path, attachPoint, level)
    endmethod
    method CreateEffect takes string path, string attachPoint, EffectLevel level returns DummyUnitEffect
        return DummyUnitEffect.Create(this, path, attachPoint, level)
    endmethod
    static method Create takes integer unitId, real x, real y, real z, real angle returns thistype
    	local thistype this = thistype.allocate()
        local unit self = CreateUnit(User.DUMMY.self, unitId, 0., 0., angle * Math.RAD_TO_DEG)
        set this.self = self
        set this.typeId = unitId
        call Memory.IntegerKeys.SetIntegerByHandle(self, KEY, this)
        call this.Id.Event_Create()
        set self = null
        call this.Facing.Set(angle)
        call this.Owner.Set(User.DUMMY)
        call this.Position.X.Set(x)
        call this.Position.Y.Set(y)
        call this.Position.Z.Event_Create(x, y, z)
        call this.Scale.Event_Create()
        call this.VertexColor.Event_Create()
        return this
    endmethod
    static method Init takes nothing returns nothing
        set thistype.DEATH_EVENT_TYPE = EventType.Create()
        set thistype.DESTROY_EVENT_TYPE = EventType.Create()
        call thistype(NULL).FollowDummyUnit.Init()
        call thistype(NULL).FollowUnit.Init()
        call thistype(NULL).Scale.Init()
        call thistype(NULL).Rotate.Init()
        call thistype(NULL).VertexColor.Init()
        
        set thistype.WORLD_CASTER = thistype.Create(thistype.WORLD_CASTER_ID, 0., 0., 0., 0.)
    endmethod
endstruct
    globals
        TargetFlag TARGET_FLAG = STRUCT_BASE
    endglobals
    struct TargetFlag
        implement Allocation
        implement List
        
    static constant integer ALLY = 0
endstruct
    globals
        Misc MISC = STRUCT_BASE
    endglobals
    struct Misc
        implement Allocation
        implement List
        
    initMethod Init of Header_5
        call Attack.Init()
        call DummyUnit.Init()
    endmethod
endstruct
    scope FolderMissileCheckpoint
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    public struct StructBoolean
        implement Allocation
        implement List
        
    method Get takes integer key returns boolean
        return MissileCheckpoint(this).Data.table.IntegerKeys.GetBoolean(MissileCheckpoint(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call MissileCheckpoint(this).Data.table.IntegerKeys.RemoveBoolean(MissileCheckpoint(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call MissileCheckpoint(this).Data.table.IntegerKeys.SetBoolean(MissileCheckpoint(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return MissileCheckpoint(this).Data.table.IntegerKeys.Table.ContainsInteger(MissileCheckpoint(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return MissileCheckpoint(this).Data.table.IntegerKeys.Table.CountIntegers(MissileCheckpoint(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return MissileCheckpoint(this).Data.table.IntegerKeys.Table.IsEmptyInteger(MissileCheckpoint(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return MissileCheckpoint(this).Data.table.IntegerKeys.Table.GetInteger(MissileCheckpoint(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return MissileCheckpoint(this).Data.table.IntegerKeys.Table.GetFirstInteger(MissileCheckpoint(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return MissileCheckpoint(this).Data.table.IntegerKeys.Table.GetLastInteger(MissileCheckpoint(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call MissileCheckpoint(this).Data.table.IntegerKeys.Table.Clear(MissileCheckpoint(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return MissileCheckpoint(this).Data.table.IntegerKeys.Table.FetchFirstInteger(MissileCheckpoint(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return MissileCheckpoint(this).Data.table.IntegerKeys.Table.RemoveInteger(MissileCheckpoint(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return MissileCheckpoint(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(MissileCheckpoint(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return MissileCheckpoint(this).Data.table.IntegerKeys.Table.AddInteger(MissileCheckpoint(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return MissileCheckpoint(this).Data.table.IntegerKeys.Table.AddIntegerMulti(MissileCheckpoint(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call MissileCheckpoint(this).Data.table.IntegerKeys.Table.JoinInteger(MissileCheckpoint(this).Id.Get(), key, MissileCheckpoint(other).Data.table, MissileCheckpoint(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return MissileCheckpoint(this).Data.table.IntegerKeys.Table.RandomInteger(MissileCheckpoint(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call MissileCheckpoint(this).Data.table.IntegerKeys.Table.ShuffleIntegers(MissileCheckpoint(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call MissileCheckpoint(this).Data.table.IntegerKeys.Table.PrintIntegers(MissileCheckpoint(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return MissileCheckpoint(this).Data.table.IntegerKeys.GetInteger(MissileCheckpoint(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call MissileCheckpoint(this).Data.table.IntegerKeys.RemoveInteger(MissileCheckpoint(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call MissileCheckpoint(this).Data.table.IntegerKeys.SetInteger(MissileCheckpoint(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(MissileCheckpoint(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject MissileCheckpoint.Allocation.deallocate_demount.hook
		call MissileCheckpoint(this).Data.Destroy()
	endinject
	inject MissileCheckpoint.Allocation.allocate_mount.hook
		call MissileCheckpoint(this).Data.Event_Create()
	endinject
    endstruct
endscope
    globals
        MissileCheckpoint MISSILE_CHECKPOINT = STRUCT_BASE
    endglobals
    struct MissileCheckpoint
        implement Allocation
        implement List
        
    FolderMissileCheckpoint_StructData Data = this
    FolderMissileCheckpoint_StructData LinkToStruct_Data
    FolderMissileCheckpoint_StructId Id = this
    FolderMissileCheckpoint_StructId LinkToStruct_Id
    real x
    method GetX takes nothing returns real
        return this.x
    endmethod
    method SetX takes real value returns nothing
        set this.x = value
    endmethod
    real y
    method GetY takes nothing returns real
        return this.y
    endmethod
    method SetY takes real value returns nothing
        set this.y = value
    endmethod
    real z
    method GetZ takes nothing returns real
        return this.z
    endmethod
    method SetZ takes real value returns nothing
        set this.z = value
    endmethod
    method Destroy takes nothing returns nothing
        call this.deallocate()
    endmethod
    static method Create takes real x, real y, real z returns thistype
        local thistype this = thistype.allocate()
        call this.Id.Event_Create()
        call this.SetX(x)
        call this.SetY(y)
        call this.SetZ(z)
        return this
    endmethod
endstruct
    scope FolderMissile
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    public struct StructBoolean
        implement Allocation
        implement List
        
    method Get takes integer key returns boolean
        return Missile(this).Data.table.IntegerKeys.GetBoolean(Missile(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Missile(this).Data.table.IntegerKeys.RemoveBoolean(Missile(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call Missile(this).Data.table.IntegerKeys.SetBoolean(Missile(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return Missile(this).Data.table.IntegerKeys.Table.ContainsInteger(Missile(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Missile(this).Data.table.IntegerKeys.Table.CountIntegers(Missile(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Missile(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Missile(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Missile(this).Data.table.IntegerKeys.Table.GetInteger(Missile(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Missile(this).Data.table.IntegerKeys.Table.GetFirstInteger(Missile(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Missile(this).Data.table.IntegerKeys.Table.GetLastInteger(Missile(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Missile(this).Data.table.IntegerKeys.Table.Clear(Missile(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Missile(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Missile(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Missile(this).Data.table.IntegerKeys.Table.RemoveInteger(Missile(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Missile(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Missile(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Missile(this).Data.table.IntegerKeys.Table.AddInteger(Missile(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Missile(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Missile(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Missile(this).Data.table.IntegerKeys.Table.JoinInteger(Missile(this).Id.Get(), key, Missile(other).Data.table, Missile(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Missile(this).Data.table.IntegerKeys.Table.RandomInteger(Missile(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Missile(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Missile(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Missile(this).Data.table.IntegerKeys.Table.PrintIntegers(Missile(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return Missile(this).Data.table.IntegerKeys.GetInteger(Missile(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Missile(this).Data.table.IntegerKeys.RemoveInteger(Missile(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Missile(this).Data.table.IntegerKeys.SetInteger(Missile(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Missile(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Missile.Allocation.deallocate_demount.hook
		call Missile(this).Data.Destroy()
	endinject
	inject Missile.Allocation.allocate_mount.hook
		call Missile(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructEvent
        implement Allocation
        implement List
        
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(Missile(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(Missile(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(Missile(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(Missile(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(Missile(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(Missile(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(Missile(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(Missile(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject Missile.Allocation.deallocate_demount.hook
			call Missile(this).Event.Destroy()
		endinject
		inject Missile.Allocation.allocate_mount.hook
			call Missile(this).Event.Event_Create()
		endinject
    endstruct
    public struct StructArc
        implement Allocation
        implement List
        
        real acceleration
        real distance
        real duration
        real speed
        real startX
        real startY
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        method GetHeight takes nothing returns real
            local real distance = Math.DistanceByDeltas(Missile(this).GetTargetX() - this.startX, Missile(this).GetTargetY() - this.startY)
            if (distance == 0.) then
                return 0.
            endif
            local real duration = this.duration
            if (duration == 0.) then
                return 0.
            endif
            local real distFactor = Math.Limit(Math.DistanceByDeltas(Missile(this).Position.X.Get() - this.startX, Missile(this).Position.Y.Get() - this.startY) / distance, 0, 1)
            local real time = (1 - distFactor) * duration
            return ((this.acceleration / 2) * time * time + this.speed * time)
        endmethod
        method SetByPerc takes real value returns nothing
            call this.Set(Math.QUARTER_ANGLE * value)
        endmethod
        method Start takes nothing returns nothing
            local real distance = Missile(this).GetTargetDistanceXY()
            local real speed = Missile(this).Speed.GetX()
            local real duration = Math.GetMovementDuration(distance, speed, Missile(this).Acceleration.GetX())
            if (duration == 0.) then
                set this.acceleration = 0.
                set this.distance = 0.
                set this.duration = 0.
                set this.speed = 0.
                set this.startX = Missile(this).Position.X.Get()
                set this.startY = Missile(this).Position.Y.Get()
                return
            endif
            set this.distance = distance
            set distance = distance * Math.Tan(this.Get())
            set speed = distance / duration
            local real acceleration = -2 * speed / duration
            set this.acceleration = acceleration
            set this.duration = duration
            set this.speed = speed
            set this.startX = Missile(this).Position.X.Get()
            set this.startY = Missile(this).Position.Y.Get()
        endmethod
        method Event_Create takes nothing returns nothing
            set this.acceleration = 0.
            set this.distance = 0.
            set this.duration = 0.
            set this.speed = 0.
            call this.Set(0.)
        endmethod
    endstruct
    public struct StructImpact
        implement Allocation
        implement List
        
        Trigger action
    BoolExpr filter
    method GetFilter takes nothing returns BoolExpr
        return this.filter
    endmethod
    method SetFilter takes BoolExpr value returns nothing
        set this.filter = value
    endmethod
        method Do takes real x, real y, real z returns nothing
            local BoolExpr filter = this.filter
            local EventResponse params = EventResponse.Create(Missile(this).Id.Get())
            set this.filter = NULL
            call Missile(this).Position.Set(x, y, z)
            set this.filter = filter
            call params.Missile.SetTrigger(this)
            call params.Unit.SetTrigger(NULL)
            call EventResponse.SetTrigger(params)
            call this.action.Run()
            call params.Destroy()
        endmethod
		method DoCur takes nothing returns nothing
			call this.Do(Missile(this).Position.X.Get(), Missile(this).Position.Y.Get(), Missile(this).Position.Z.Get())
		endmethod
        method DoOnUnit takes Unit target returns nothing
            local BoolExpr filter = this.filter
            local EventResponse params = EventResponse.Create(Missile(this).Id.Get())
            set this.filter = NULL
            call Missile(this).Position.SetToUnit(target)
            set this.filter = filter
            call params.Missile.SetTrigger(this)
            call params.Unit.SetTrigger(target)
            call EventResponse.SetTrigger(params)
            call this.action.Run()
            call params.Destroy()
        endmethod
        method SetAction takes code actionFunction returns nothing
            set this.action = Trigger.GetFromCode(actionFunction)
        endmethod
        method Event_Create takes nothing returns nothing
            set this.action = NULL
            set this.filter = NULL
        endmethod
    endstruct
    public struct StructCollisionSize
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    public struct StructDummyUnit
        implement Allocation
        implement List
        
        static Event DESTROY_EVENT
        static Event PARENT_DESTROY_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
        boolean facingLocked
        real facing
    DummyUnit value
    method Get takes nothing returns DummyUnit
        return this.value
    endmethod
        method Set takes DummyUnit value returns nothing
            local DummyUnit oldValue = this.Get()
            if (oldValue != NULL) then
                call oldValue.Data.Integer.Remove(KEY)
                call oldValue.Event.Remove(DESTROY_EVENT)
                call Missile(this).Event.Remove(PARENT_DESTROY_EVENT)
            endif
            set this.value = value
            if (value != NULL) then
                call Missile(this).Event.Add(PARENT_DESTROY_EVENT)
                call value.Data.Integer.Set(KEY, this)
                call value.Event.Add(DESTROY_EVENT)
            endif
        endmethod
        eventMethod Event_Destroy
            local DummyUnit value = params.DummyUnit.GetTrigger()
            local thistype this = value.Data.Integer.Get(KEY)
            call this.Set(NULL)
        endmethod
        eventMethod Event_ParentDestroy
            local Missile parent = params.Missile.GetTrigger()
            local thistype this = parent
            local DummyUnit value = this.Get()
            call this.Set(NULL)
            call value.Destroy()
        endmethod
        method Update takes nothing returns nothing
            local DummyUnit val = this.Get()
            if (val != NULL) then
                if this.facingLocked then
                    
                else
                    call val.Facing.Set(Missile(this).Angle.GetXY())
                endif
            endif
        endmethod
        method LockFacing takes real val returns nothing
            set this.facing = val
            set this.facingLocked = true
            call this.Update()
        endmethod
        method Create takes integer id, real scale returns DummyUnit
            local real facing
            if this.facingLocked then
                set facing = this.facing
            else
                set facing = Missile(this).Angle.GetXY()
            endif
            local DummyUnit value = DummyUnit.Create(id, Missile(this).Position.X.Get(), Missile(this).Position.Y.Get(), Missile(this).Position.Z.Get(), facing)
            call this.Set(value)
            call value.Scale.Set(scale)
            return value
        endmethod
        method CreateWithAngle takes integer id, real scale, real facing returns DummyUnit
            local DummyUnit value = DummyUnit.Create(id, Missile(this).Position.X.Get(), Missile(this).Position.Y.Get(), Missile(this).Position.Z.Get(), facing)
            call this.Set(value)
            call value.Scale.Set(scale)
            return value
        endmethod
        method Event_Create takes nothing returns nothing
            set this.facingLocked = false
            set this.value = NULL
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
            set thistype.PARENT_DESTROY_EVENT = Event.Create(Missile.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_ParentDestroy)
        endmethod
    endstruct
    public struct StructAngle
        implement Allocation
        implement List
        
    real xPart
    method GetXPart takes nothing returns real
        return this.xPart
    endmethod
    method SetXPart takes real value returns nothing
        set this.xPart = value
    endmethod
    real yPart
    method GetYPart takes nothing returns real
        return this.yPart
    endmethod
    method SetYPart takes real value returns nothing
        set this.yPart = value
    endmethod
    real zPart
    method GetZPart takes nothing returns real
        return this.zPart
    endmethod
    method SetZPart takes real value returns nothing
        set this.zPart = value
    endmethod
        method GetXY takes nothing returns real
            return Math.AtanByDeltas(this.GetYPart(), this.GetXPart())
        endmethod
        method Set takes real dX, real dY, real dZ returns nothing
            local real d = Math.DistanceByDeltasWithZ(dX, dY, dZ)
            call this.SetXPart(dX / d)
            call this.SetYPart(dY / d)
            call this.SetZPart(dZ / d)
            call Missile(this).DummyUnit.Update()
        endmethod
        method DirectToSpot takes real x, real y, real z returns nothing
            call this.Set(x - Missile(this).Position.X.Get(), y - Missile(this).Position.Y.Get(), z - Missile(this).Position.Z.Get())
        endmethod
    endstruct
    scope FolderPosition
    public struct StructX
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructY
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructZ
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    endscope
    public struct StructPosition
        implement Allocation
        implement List
        
        static Group ENUM_GROUP
        Trigger collisionAction
        BoolExpr collisionFilter
    FolderPosition_StructX X = this
    FolderPosition_StructX LinkToStruct_X
    FolderPosition_StructY Y = this
    FolderPosition_StructY LinkToStruct_Y
    FolderPosition_StructZ Z = this
    FolderPosition_StructZ LinkToStruct_Z
        method Set takes real x, real y, real z returns nothing
            local DummyUnit dummyUnit = Missile(this).DummyUnit.Get()
            local BoolExpr impactFilter = Missile(this).Impact.GetFilter()
            call this.X.Set(x)
            call this.Y.Set(y)
            call this.Z.Set(z)
            if (dummyUnit != NULL) then
                call dummyUnit.Position.Set(x, y, z + Missile(this).Arc.GetHeight())
            endif
			local Unit impactUnit
			local EventResponse params
            if (impactFilter != NULL) then
                set params = EventResponse.Create(EventResponse.DIRECT_SUBJECT_ID)
                call params.Missile.SetTrigger(this)
                call EventResponse.SetTrigger(params)
                call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, Missile(this).CollisionSize.Get(), impactFilter)
                call params.Destroy()
                set impactUnit = thistype.ENUM_GROUP.GetFirst()
                if (impactUnit != NULL) then
                    call Missile(this).Impact.DoOnUnit(impactUnit)
                endif
            endif
            if (this.collisionFilter != NULL) then
                set params = EventResponse.Create(EventResponse.DIRECT_SUBJECT_ID)
                call params.Missile.SetTrigger(this)
                call EventResponse.SetTrigger(params)
                call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, Missile(this).CollisionSize.Get(), this.collisionFilter)
                set impactUnit = thistype.ENUM_GROUP.FetchFirst()
                if (impactUnit != NULL) then
                    loop
                        call EventResponse.SetTrigger(params)
                        call params.Unit.SetTrigger(impactUnit)
                        call this.collisionAction.Run()
                        set impactUnit = thistype.ENUM_GROUP.FetchFirst()
                        exitwhen (impactUnit == NULL)
                    endloop
                endif
                call params.Destroy()
            endif
        endmethod
        method Add takes real x, real y, real z returns nothing
            call this.Set(this.X.Get() + x, this.Y.Get() + y, this.Z.Get() + z)
        endmethod
        method AddCollision takes code actionFunction, BoolExpr filter returns nothing
            set this.collisionAction = Trigger.GetFromCode(actionFunction)
            set this.collisionFilter = filter
        endmethod
        method SetFromUnit takes Unit source returns nothing
            local real angle = source.Facing.Get()
            local real width = source.Outpact.X.Get(true)
            local real length = source.Outpact.Y.Get(true)
            local real x = source.Position.X.Get() + length * Math.Cos(angle) + width * Math.Cos(angle - Math.QUARTER_ANGLE)
            local real y = source.Position.Y.Get() + length * Math.Sin(angle) + width * Math.Sin(angle - Math.QUARTER_ANGLE)
            local real z = source.Position.Z.Get() + source.Outpact.Z.Get(true)
            call this.Set(x, y, z)
        endmethod
        method SetToUnitWithOffset takes Unit target, real offsetX, real offsetY, real offsetZ returns nothing
            call this.Set(target.Position.X.Get() + target.Impact.X.Get(true) + offsetX, target.Position.Y.Get() + target.Impact.Y.Get(true) + offsetY, target.Position.Z.Get() + target.Impact.Z.Get(true) + offsetZ)
        endmethod
        method SetToUnit takes Unit target returns nothing
            call this.SetToUnitWithOffset(target, 0., 0., 0.)
        endmethod
        method Event_Create takes nothing returns nothing
        	set this.collisionAction = NULL
        	set this.collisionFilter = NULL
            call this.X.Event_Create()
            call this.Y.Event_Create()
            call this.Z.Event_Create()
        endmethod
        static method Init takes nothing returns nothing
            set thistype.ENUM_GROUP = Group.Create()
        endmethod
    endstruct
    public struct StructUpdateTime
        implement Allocation
        implement List
        
    static constant real VALUE = (1 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer VALUE_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (1 * 1.))
        
        method Get takes nothing returns real
        	return thistype.VALUE
        endmethod
    endstruct
    public struct StructAcceleration
        implement Allocation
        implement List
        
    real x
    method GetX takes nothing returns real
        return this.x
    endmethod
    method SetX takes real value returns nothing
        set this.x = value
    endmethod
    real xAdd
    method GetXAdd takes nothing returns real
        return this.xAdd
    endmethod
    method SetXAdd takes real value returns nothing
        set this.xAdd = value
    endmethod
    real y
    method GetY takes nothing returns real
        return this.y
    endmethod
    method SetY takes real value returns nothing
        set this.y = value
    endmethod
    real yAdd
    method GetYAdd takes nothing returns real
        return this.yAdd
    endmethod
    method SetYAdd takes real value returns nothing
        set this.yAdd = value
    endmethod
    real z
    method GetZ takes nothing returns real
        return this.z
    endmethod
    method SetZ takes real value returns nothing
        set this.z = value
    endmethod
    real zAdd
    method GetZAdd takes nothing returns real
        return this.zAdd
    endmethod
    method SetZAdd takes real value returns nothing
        set this.zAdd = value
    endmethod
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method SetPolar takes real x, real y, real z returns nothing
            set this.x = x
            set this.xAdd = x * MISSILE.UpdateTime.VALUE
            set this.y = y
            set this.yAdd = y * MISSILE.UpdateTime.VALUE
            set this.z = z
            set this.zAdd = z * MISSILE.UpdateTime.VALUE
        endmethod
        method Set takes real value returns nothing
            set this.value = value
            call this.SetPolar(value, 0., 0.)
        endmethod
        method AddPolar takes real x, real y, real z returns nothing
            call this.SetPolar(this.GetX() + x, this.GetY() + y, this.GetZ() + z)
        endmethod
        method Add takes real value returns nothing
            call this.Set(this.GetX() + value)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(0.)
        endmethod
    endstruct
    public struct StructSpeed
        implement Allocation
        implement List
        
    real x
    method GetX takes nothing returns real
        return this.x
    endmethod
    method SetX takes real value returns nothing
        set this.x = value
    endmethod
    real xAdd
    method GetXAdd takes nothing returns real
        return this.xAdd
    endmethod
    method SetXAdd takes real value returns nothing
        set this.xAdd = value
    endmethod
    real y
    method GetY takes nothing returns real
        return this.y
    endmethod
    method SetY takes real value returns nothing
        set this.y = value
    endmethod
    real yAdd
    method GetYAdd takes nothing returns real
        return this.yAdd
    endmethod
    method SetYAdd takes real value returns nothing
        set this.yAdd = value
    endmethod
    real z
    method GetZ takes nothing returns real
        return this.z
    endmethod
    method SetZ takes real value returns nothing
        set this.z = value
    endmethod
    real zAdd
    method GetZAdd takes nothing returns real
        return this.zAdd
    endmethod
    method SetZAdd takes real value returns nothing
        set this.zAdd = value
    endmethod
        real min
        boolean minSet
        real minSquare
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method SetPolar takes real x, real y, real z returns nothing
        	local real d = Math.DistanceByDeltasWithZ(x, y, z)
            if this.minSet then
				local real min
                if (d > 0) then
                    if (d < this.min) then
                        set min = this.min
                        set x = x / d * min
                        set y = y / d * min
                        set z = z / d * min
                    endif
                else
                    set min = this.min
                    if (min == 0) then
                        set x = 0.
                        set y = 0.
                        set z = 0.
                    else
                        return
                    endif
                endif
            endif
			set this.value = d
            set this.x = x
            set this.xAdd = x * MISSILE.UpdateTime.VALUE
            set this.y = y
            set this.yAdd = y * MISSILE.UpdateTime.VALUE
            set this.z = z
            set this.zAdd = z * MISSILE.UpdateTime.VALUE
        endmethod
        method SetMin takes real val returns nothing
            set this.min = val
            set this.minSet = true
            set this.minSquare = val * val
        endmethod
        method Set takes real value returns nothing
            if (value < this.min) then
                set value = this.min
            endif
            set this.value = value
            call this.SetPolar(value, 0., 0.)
        endmethod
        method AddPolar takes real x, real y, real z returns nothing
            call this.SetPolar(this.GetX() + x, this.GetY() + y, this.GetZ() + z)
        endmethod
        method Add takes real value returns nothing
            call this.Set(this.GetX() + value)
        endmethod
        method Event_Create takes nothing returns nothing
            set this.min = 0.
            set this.minSet = false
            set this.minSquare = 0.
            call this.Set(0.)
        endmethod
    endstruct
    public struct StructGoToSpot
        implement Allocation
        implement List
        
        static Event STOP_EVENT
        static Timer UPDATE_TIMER
        real targetX
        real targetY
        real targetZ
    static thistype array ACTIVE_LIST_ALL
    static integer ACTIVE_LIST_ALL_COUNT = ARRAY_EMPTY
    integer ACTIVE_LIST_index
    static method ACTIVE_LIST_Count takes nothing returns integer
        return thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static method ACTIVE_LIST_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Get takes integer index returns thistype
        return thistype.ACTIVE_LIST_ALL[index]
    endmethod
    static method ACTIVE_LIST_GetIndex takes thistype this returns integer
        return this.ACTIVE_LIST_index
    endmethod
    static method ACTIVE_LIST_Contains takes thistype this returns boolean
        return (thistype.ACTIVE_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ACTIVE_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ACTIVE_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ACTIVE_LIST_RandomAll takes nothing returns thistype
        return thistype.ACTIVE_LIST_Random(ARRAY_MIN, thistype.ACTIVE_LIST_ALL_COUNT)
    endmethod
    static method ACTIVE_LIST_Remove takes thistype this returns boolean
        if not thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT].ACTIVE_LIST_index = this.ACTIVE_LIST_index
        set thistype.ACTIVE_LIST_ALL[this.ACTIVE_LIST_index - 1] = thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT]
        set this.ACTIVE_LIST_index = ARRAY_MIN
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT - 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Add takes thistype this returns boolean
        if thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT + 1
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT] = this
        set this.ACTIVE_LIST_index = thistype.ACTIVE_LIST_ALL_COUNT + 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static thistype array FOR_EACH_LIST_ALL
    static integer FOR_EACH_LIST_ALL_COUNT = ARRAY_EMPTY
    static method FOR_EACH_LIST_FetchFirst takes nothing returns thistype
        local thistype result
        if (thistype.FOR_EACH_LIST_ALL_COUNT < ARRAY_MIN) then
            return NULL
        endif
        set result = thistype.FOR_EACH_LIST_ALL[ARRAY_MIN]
        set thistype.FOR_EACH_LIST_ALL[ARRAY_MIN] = thistype.FOR_EACH_LIST_ALL[thistype.FOR_EACH_LIST_ALL_COUNT]
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.FOR_EACH_LIST_ALL_COUNT - 1
        return result
    endmethod
    static method FOR_EACH_LIST_Set takes nothing returns nothing
        local integer iteration = thistype.ACTIVE_LIST_ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.FOR_EACH_LIST_ALL[iteration] = thistype.ACTIVE_LIST_ALL[iteration]
            set iteration = iteration - 1
        endloop
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
        method Ending takes nothing returns nothing
            call Missile(this).Event.Remove(STOP_EVENT)
            if thistype.ACTIVE_LIST_Remove(this) then
                call thistype.UPDATE_TIMER.Pause()
            endif
        endmethod
        eventMethod Event_Stop
            local thistype this = params.Missile.GetTrigger()
            call this.Ending()
        endmethod
        timerMethod Update
            call thistype.FOR_EACH_LIST_Set()
            loop
                local thistype this = thistype.FOR_EACH_LIST_FetchFirst()
                exitwhen (this == NULL)
                local real speedX = Missile(this).Speed.GetXAdd()
                local real speedY = Missile(this).Speed.GetYAdd()
                local real speedZ = Missile(this).Speed.GetZAdd()
                local real targetX = this.targetX
                local real targetY = this.targetY
                local real targetZ = this.targetZ
                local real dX = targetX - Missile(this).Position.X.Get()
                local real dY = targetY - Missile(this).Position.Y.Get()
                local real dZ = targetZ - Missile(this).Position.Z.Get()
                local real d = Math.DistanceByDeltasWithZ(dX, dY, dZ)
                if (d < speedX + Missile(this).CollisionSize.Get()) then
                    call this.Ending()
                    call Missile(this).Impact.Do(targetX, targetY, targetZ)
                else
                    set dX = dX / d
                    set dY = dY / d
                    set dZ = dZ / d
                    call Missile(this).Speed.AddPolar(Missile(this).Acceleration.GetXAdd(), Missile(this).Acceleration.GetYAdd(), Missile(this).Acceleration.GetZAdd())
                    call Missile(this).Position.Add(speedX * dX, speedX * dY, speedX * dZ)
                endif
            endloop
        endmethod
        method Start takes real targetX, real targetY, real targetZ returns nothing
            call Missile(this).Start(targetX, targetY, targetZ)
            set this.targetX = targetX
            set this.targetY = targetY
            set this.targetZ = targetZ
            call Missile(this).Event.Add(STOP_EVENT)
            call Missile(this).Angle.Set(targetX - Missile(this).Position.X.Get(), targetY - Missile(this).Position.Y.Get(), targetZ - Missile(this).Position.Z.Get())
            call Missile(this).Arc.Start()
            if thistype.ACTIVE_LIST_Add(this) then
                call thistype.UPDATE_TIMER.Start(MISSILE.UpdateTime.VALUE, true, function thistype.Update)
            endif
        endmethod
        static method Init takes nothing returns nothing
            set thistype.STOP_EVENT = Event.Create(Missile.STOP_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Stop)
            set thistype.UPDATE_TIMER = Timer.Create()
        endmethod
    endstruct
    public struct StructCheckpoints
        implement Allocation
        implement List
        
        static EventType ADD_EVENT_TYPE
        static EventType IMPACT_EVENT_TYPE
        static Event DESTROY_EVENT
        Queue vals
        method Impact_TriggerEvents takes MissileCheckpoint point returns nothing
            local EventResponse params = EventResponse.Create(Missile(this).Id.Get())
            call params.Missile.SetTrigger(this)
            call params.MissileCheckpoint.SetTrigger(point)
			local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = Missile(this).Event.Count(thistype.IMPACT_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call Missile(this).Event.Get(thistype.IMPACT_EVENT_TYPE, priority, iteration2).Run(params)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            call params.Destroy()
        endmethod
        method Impact takes MissileCheckpoint point returns nothing
            call this.Impact_TriggerEvents(point)
        endmethod
        method Count takes nothing returns integer
            return this.vals.Count()
        endmethod
        method GetFirst takes nothing returns MissileCheckpoint
            return this.vals.GetFirst()
        endmethod
        method GetNext takes MissileCheckpoint val returns MissileCheckpoint
            return this.vals.GetNext(val)
        endmethod
        method GetPrev takes MissileCheckpoint val returns MissileCheckpoint
            return this.vals.GetPrev(val)
        endmethod
        method Clear takes nothing returns nothing
            call this.vals.Clear()
        endmethod
        eventMethod Event_Destroy
            local Missile parent = params.Missile.GetTrigger()
            local thistype this = parent
            call parent.Event.Remove(DESTROY_EVENT)
            call this.Clear()
            call this.vals.Destroy()
        endmethod
        method Remove takes MissileCheckpoint point returns boolean
            if (this.vals == NULL) then
                return false
            endif
            return this.vals.Remove(point)
        endmethod
        method Add_TriggerEvents takes MissileCheckpoint point returns nothing
            local EventResponse params = EventResponse.Create(Missile(this).Id.Get())
            call params.Missile.SetTrigger(this)
            call params.MissileCheckpoint.SetTrigger(point)
			local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = Missile(this).Event.Count(thistype.ADD_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call Missile(this).Event.Get(thistype.ADD_EVENT_TYPE, priority, iteration2).Run(params)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            call params.Destroy()
        endmethod
        method Add takes MissileCheckpoint point returns boolean
            if (this.vals == NULL) then
                set this.vals = Queue.Create()
                call Missile(this).Event.Add(DESTROY_EVENT)
            endif
            local boolean result = this.vals.Add(point)
            call this.Add_TriggerEvents(point)
            return result
        endmethod
        method Create takes real x, real y, real z returns MissileCheckpoint
            local MissileCheckpoint result = MissileCheckpoint.Create(x, y, z)
            call this.Add(result)
            return result
        endmethod
        method Event_Create takes nothing returns nothing
            set this.vals = NULL
        endmethod
        static method Init takes nothing returns nothing
            set thistype.ADD_EVENT_TYPE = EventType.Create()
            set thistype.IMPACT_EVENT_TYPE = EventType.Create()
            set thistype.DESTROY_EVENT = Event.Create(Missile.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
        endmethod
    endstruct
    public struct StructGoToUnit
        implement Allocation
        implement List
        
        static Event CHECKPOINT_ADD_EVENT
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        static Event STOP_EVENT
        static Event TARGET_DEATH_EVENT
        static Event TARGET_DESTROY_EVENT
        static Timer UPDATE_TIMER
        boolean cancelOnTargetDeath
        MissileCheckpoint nextCheckpoint
        real offsetX
        real offsetY
        real offsetZ
        Unit target
        real targetX
        real targetY
        real targetZ
        Trigger targetResetAction
    static thistype array ACTIVE_LIST_ALL
    static integer ACTIVE_LIST_ALL_COUNT = ARRAY_EMPTY
    integer ACTIVE_LIST_index
    static method ACTIVE_LIST_Count takes nothing returns integer
        return thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static method ACTIVE_LIST_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Get takes integer index returns thistype
        return thistype.ACTIVE_LIST_ALL[index]
    endmethod
    static method ACTIVE_LIST_GetIndex takes thistype this returns integer
        return this.ACTIVE_LIST_index
    endmethod
    static method ACTIVE_LIST_Contains takes thistype this returns boolean
        return (thistype.ACTIVE_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ACTIVE_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ACTIVE_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ACTIVE_LIST_RandomAll takes nothing returns thistype
        return thistype.ACTIVE_LIST_Random(ARRAY_MIN, thistype.ACTIVE_LIST_ALL_COUNT)
    endmethod
    static method ACTIVE_LIST_Remove takes thistype this returns boolean
        if not thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT].ACTIVE_LIST_index = this.ACTIVE_LIST_index
        set thistype.ACTIVE_LIST_ALL[this.ACTIVE_LIST_index - 1] = thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT]
        set this.ACTIVE_LIST_index = ARRAY_MIN
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT - 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Add takes thistype this returns boolean
        if thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT + 1
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT] = this
        set this.ACTIVE_LIST_index = thistype.ACTIVE_LIST_ALL_COUNT + 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static thistype array FOR_EACH_LIST_ALL
    static integer FOR_EACH_LIST_ALL_COUNT = ARRAY_EMPTY
    static method FOR_EACH_LIST_FetchFirst takes nothing returns thistype
        local thistype result
        if (thistype.FOR_EACH_LIST_ALL_COUNT < ARRAY_MIN) then
            return NULL
        endif
        set result = thistype.FOR_EACH_LIST_ALL[ARRAY_MIN]
        set thistype.FOR_EACH_LIST_ALL[ARRAY_MIN] = thistype.FOR_EACH_LIST_ALL[thistype.FOR_EACH_LIST_ALL_COUNT]
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.FOR_EACH_LIST_ALL_COUNT - 1
        return result
    endmethod
    static method FOR_EACH_LIST_Set takes nothing returns nothing
        local integer iteration = thistype.ACTIVE_LIST_ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.FOR_EACH_LIST_ALL[iteration] = thistype.ACTIVE_LIST_ALL[iteration]
            set iteration = iteration - 1
        endloop
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
        method ReleaseFromTarget takes Unit target returns nothing
            if target.Data.Integer.Table.Remove(KEY_ARRAY, this) then
                call target.Event.Remove(TARGET_DEATH_EVENT)
                call target.Event.Remove(TARGET_DESTROY_EVENT)
                call target.Refs.Subtract()
            endif
        endmethod
        method Ending takes Unit target returns nothing
            if (target != NULL) then
                call this.ReleaseFromTarget(target)
            endif
            call Missile(this).Event.Remove(CHECKPOINT_ADD_EVENT)
            call Missile(this).Event.Remove(STOP_EVENT)
            if thistype.ACTIVE_LIST_Remove(this) then
                call thistype.UPDATE_TIMER.Pause()
            endif
        endmethod
        eventMethod Event_Stop
            local thistype this = params.Missile.GetTrigger()
            call this.Ending(this.target)
        endmethod
		static method ResetFromTarget takes Unit target, EventResponse resetParams returns nothing
            local real targetX = target.Position.X.Get()
            local real targetY = target.Position.Y.Get()
            local real targetZ = target.Position.Z.GetByCoords(targetX, targetY) + target.Impact.Z.Get(true)
			local integer iteration = target.Data.Integer.Table.Count(KEY_ARRAY)
            loop
                local thistype this = target.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                call this.ReleaseFromTarget(target)
                set this.target = NULL
                set this.targetX = targetX + this.offsetX
                set this.targetY = targetY + this.offsetY
                set this.targetZ = targetZ + this.offsetZ
				if (this.targetResetAction != NULL) then
					call resetParams.Missile.SetTrigger(this)
					call this.targetResetAction.RunWithParams(resetParams)
				endif
                set iteration = iteration - 1
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            endloop
		endmethod
        eventMethod Event_TargetDeath
            local Unit target = params.Unit.GetTrigger()
			call thistype.ResetFromTarget(target, params)
        endmethod
		eventMethod Event_TargetDestroy
            local Unit target = params.Unit.GetTrigger()
            call thistype.ResetFromTarget(target, params)
		endmethod
        timerMethod Update
            call thistype.FOR_EACH_LIST_Set()
            loop
                local thistype this = thistype.FOR_EACH_LIST_FetchFirst()
                exitwhen (this == NULL)
                local MissileCheckpoint nextCheckpoint = this.nextCheckpoint
                local real speedX = Missile(this).Speed.GetXAdd()
                local real speedY = Missile(this).Speed.GetYAdd()
                local real speedZ = Missile(this).Speed.GetZAdd()
                local real x = Missile(this).Position.X.Get()
                local real y = Missile(this).Position.Y.Get()
                local real z = Missile(this).Position.Z.Get()
				local Unit target = this.target
				local real targetX
				local real targetY
				local real targetZ
                if (nextCheckpoint != NULL) then
                    set targetX = nextCheckpoint.GetX()
                    set targetY = nextCheckpoint.GetY()
                    set targetZ = nextCheckpoint.GetZ()
                elseif (target == NULL) then
                    set targetX = this.targetX
                    set targetY = this.targetY
                    set targetZ = this.targetZ
                else
                    set targetX = target.Position.X.Get() + this.offsetX
                    set targetY = target.Position.Y.Get() + this.offsetY
                    set targetZ = target.Position.Z.GetByCoords(targetX, targetY) + target.Impact.Z.Get(true) + this.offsetZ
                endif
                local real dX = targetX - x
                local real dY = targetY - y
                local real dZ = targetZ - z
                local real d = Math.DistanceByDeltasWithZ(dX, dY, dZ)
                if (d < speedX + Missile(this).CollisionSize.Get()) then
                    if (nextCheckpoint == NULL) then
                        call this.Ending(target)
                        if (target == NULL) then
                            call Missile(this).Impact.Do(targetX, targetY, targetZ)
                        else
                            call Missile(this).Impact.DoOnUnit(target)
                        endif
                    else
                        set this.nextCheckpoint = Missile(this).Checkpoints.GetNext(nextCheckpoint)
                        call Missile(this).Checkpoints.Impact(nextCheckpoint)
                    endif
                else
                    set dX = dX / d
                    set dY = dY / d
                    set dZ = dZ / d
                    call Missile(this).Angle.Set(dX, dY, dZ)
                    call Missile(this).Speed.AddPolar(Missile(this).Acceleration.GetXAdd(), Missile(this).Acceleration.GetYAdd(), Missile(this).Acceleration.GetZAdd())
                    call Missile(this).Position.Add(speedX * dX, speedX * dY, speedX * dZ)
                endif
            endloop
        endmethod
        eventMethod Event_CheckpointAdd
            local Missile parent = params.Missile.GetTrigger()
            if (thistype(parent).nextCheckpoint != NULL) then
                return
            endif
            set thistype(parent).nextCheckpoint = params.MissileCheckpoint.GetTrigger()
        endmethod
        method StartWithOffset takes Unit target, real offsetX, real offsetY, real offsetZ, code targetResetActionFunc returns nothing
            call Missile(this).Start(target.Position.X.Get() + offsetX, target.Position.Y.Get() + offsetY, target.Position.Z.Get() + target.Impact.Z.Get(true) + offsetZ)
            set this.cancelOnTargetDeath = cancelOnTargetDeath
            set this.nextCheckpoint = Missile(this).Checkpoints.GetFirst()
            set this.offsetX = offsetX
            set this.offsetY = offsetY
            set this.offsetZ = offsetZ
            set this.target = target
            set this.targetResetAction = Trigger.GetFromCode(targetResetActionFunc)
            if target.Data.Integer.Table.Add(KEY_ARRAY, this) then
                call target.Event.Add(TARGET_DEATH_EVENT)
                call target.Event.Add(TARGET_DESTROY_EVENT)
                call target.Refs.Add()
            endif
            call Missile(this).Event.Add(CHECKPOINT_ADD_EVENT)
            call Missile(this).Event.Add(STOP_EVENT)
            call Missile(this).Arc.Start()
            if thistype.ACTIVE_LIST_Add(this) then
                call thistype.UPDATE_TIMER.Start(MISSILE.UpdateTime.VALUE, true, function thistype.Update)
            endif
        endmethod
        method Start takes Unit target, code targetResetActionFunc returns nothing
            call this.StartWithOffset(target, 0., 0., 0., targetResetActionFunc)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.CHECKPOINT_ADD_EVENT = Event.Create(MISSILE.Checkpoints.ADD_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_CheckpointAdd)
            set thistype.STOP_EVENT = Event.Create(Missile.STOP_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Stop)
            set thistype.TARGET_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TargetDeath)
            set thistype.TARGET_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TargetDestroy)
            set thistype.UPDATE_TIMER = Timer.Create()
        endmethod
    endstruct
endscope
    globals
        Missile MISSILE = STRUCT_BASE
    endglobals
    struct Missile
        implement Allocation
        implement List
        
    static EventType DESTROY_EVENT_TYPE
    static EventType STOP_EVENT_TYPE
    boolean moving
    FolderMissile_StructAcceleration Acceleration = this
    FolderMissile_StructAcceleration LinkToStruct_Acceleration
    FolderMissile_StructAngle Angle = this
    FolderMissile_StructAngle LinkToStruct_Angle
    FolderMissile_StructArc Arc = this
    FolderMissile_StructArc LinkToStruct_Arc
    FolderMissile_StructCheckpoints Checkpoints = this
    FolderMissile_StructCheckpoints LinkToStruct_Checkpoints
    FolderMissile_StructCollisionSize CollisionSize = this
    FolderMissile_StructCollisionSize LinkToStruct_CollisionSize
    FolderMissile_StructData Data = this
    FolderMissile_StructData LinkToStruct_Data
    FolderMissile_StructDummyUnit DummyUnit = this
    FolderMissile_StructDummyUnit LinkToStruct_DummyUnit
    FolderMissile_StructEvent Event = this
    FolderMissile_StructEvent LinkToStruct_Event
    FolderMissile_StructGoToSpot GoToSpot = this
    FolderMissile_StructGoToSpot LinkToStruct_GoToSpot
    FolderMissile_StructGoToUnit GoToUnit = this
    FolderMissile_StructGoToUnit LinkToStruct_GoToUnit
    FolderMissile_StructId Id = this
    FolderMissile_StructId LinkToStruct_Id
    FolderMissile_StructImpact Impact = this
    FolderMissile_StructImpact LinkToStruct_Impact
    FolderMissile_StructPosition Position = this
    FolderMissile_StructPosition LinkToStruct_Position
    FolderMissile_StructSpeed Speed = this
    FolderMissile_StructSpeed LinkToStruct_Speed
    FolderMissile_StructUpdateTime UpdateTime = this
    FolderMissile_StructUpdateTime LinkToStruct_UpdateTime
    integer data
    method GetData takes nothing returns integer
        return this.data
    endmethod
    method SetData takes integer value returns nothing
        set this.data = value
    endmethod
    real targetX
    method GetTargetX takes nothing returns real
        return this.targetX
    endmethod
    method SetTargetX takes real value returns nothing
        set this.targetX = value
    endmethod
    real targetY
    method GetTargetY takes nothing returns real
        return this.targetY
    endmethod
    method SetTargetY takes real value returns nothing
        set this.targetY = value
    endmethod
    real targetZ
    method GetTargetZ takes nothing returns real
        return this.targetZ
    endmethod
    method SetTargetZ takes real value returns nothing
        set this.targetZ = value
    endmethod
    method GetTargetDistanceXY takes nothing returns real
        return Math.DistanceByDeltas(this.Position.X.Get() - this.GetTargetX(), this.Position.Y.Get() - this.GetTargetY())
    endmethod
    method GetTargetDistance takes nothing returns real
        return Math.DistanceByDeltasWithZ(this.Position.X.Get() - this.GetTargetX(), this.Position.Y.Get() - this.GetTargetY(), this.Position.Z.Get() - this.GetTargetZ())
    endmethod
    method Stop_TriggerEvents takes nothing returns nothing
        local EventResponse params = EventResponse.Create(this.Id.Get())
        call params.Missile.SetTrigger(this)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = this.Event.Count(thistype.STOP_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.STOP_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    method Stop takes nothing returns nothing
        if this.moving then
            set this.moving = false
            call this.Stop_TriggerEvents()
        endif
    endmethod
    method Start takes real targetX, real targetY, real targetZ returns nothing
        if this.moving then
            call this.Stop()
        endif
        set this.moving = true
        call this.SetTargetX(targetX)
        call this.SetTargetY(targetY)
        call this.SetTargetZ(targetZ)
    endmethod
    method Destroy_TriggerEvents takes nothing returns nothing
        local EventResponse params = EventResponse.Create(this.Id.Get())
        call params.Missile.SetTrigger(this)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = this.Event.Count(thistype.DESTROY_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.DESTROY_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    method Destroy takes nothing returns nothing
        call this.Stop()
        call this.Destroy_TriggerEvents()
        call this.deallocate()
    endmethod
	eventMethod Destruction
		call params.Missile.GetTrigger().Destroy()
	endmethod
    static method Create takes nothing returns thistype
        local thistype this = thistype.allocate()
        set this.moving = false
        call this.Acceleration.Event_Create()
        call this.Arc.Event_Create()
        call this.Checkpoints.Event_Create()
        call this.CollisionSize.Event_Create()
        call this.DummyUnit.Event_Create()
        call this.Id.Event_Create()
        call this.Impact.Event_Create()
        call this.Position.Event_Create()
        call this.Speed.Event_Create()
        return this
    endmethod
    initMethod Init of Header_7
        set thistype.DESTROY_EVENT_TYPE = EventType.Create()
        set thistype.STOP_EVENT_TYPE = EventType.Create()
        call thistype(NULL).Checkpoints.Init()
        call thistype(NULL).DummyUnit.Init()
        call thistype(NULL).GoToSpot.Init()
        call thistype(NULL).GoToUnit.Init()
        call thistype(NULL).Position.Init()
    endmethod
endstruct
    globals
        MultiboardItem MULTIBOARD_ITEM = STRUCT_BASE
    endglobals
    struct MultiboardItem
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    integer column
    integer row
    multiboarditem self
    string icon
    string value
    real width
    method Destroy takes nothing returns nothing
        local multiboarditem self = this.self
        call this.deallocate()
        call Memory.IntegerKeys.RemoveIntegerByHandle(self, KEY)
        call MultiboardReleaseItem(self)
        set self = null
    endmethod
    method SetIcon takes string value returns nothing
        set this.icon = value
        if (value == null) then
            call MultiboardSetItemStyle(this.self, true, false)
        else
            call MultiboardSetItemIcon(this.self, value)
            call MultiboardSetItemStyle(this.self, true, true)
        endif
    endmethod
    method SetValue takes string value returns nothing
        set this.value = value
        call MultiboardSetItemValue(this.self, value)
    endmethod
    method SetWidth takes real value returns nothing
        set this.width = value
        call MultiboardSetItemWidth(this.self, value)
    endmethod
    method Use takes nothing returns nothing
        call this.SetIcon(null)
        call this.SetWidth(0.)
    endmethod
    static method Create takes Multiboard whichBoard, integer row, integer column returns thistype
        local thistype this = thistype.allocate()
        set this.column = column
        set this.row = row
        set this.self = MultiboardGetItem(whichBoard.self, row, column)
        call Memory.IntegerKeys.SetIntegerByHandle(self, KEY, this)
        return this
    endmethod
endstruct
    scope FolderMultiboard
    public struct StructColumn
        implement Allocation
        implement List
        
        method SetIcon takes integer column, string iconPath returns nothing
            local integer row = Multiboard(this).GetRowCount()
            loop
                exitwhen (row < 0)
                call Multiboard(this).SetIcon(row, column, iconPath)
                set row = row - 1
            endloop
        endmethod
        method SetWidth takes integer column, real value returns nothing
            local integer row = Multiboard(this).GetRowCount()
            loop
                exitwhen (row < 0)
                call Multiboard(this).SetWidth(row, column, value)
                set row = row - 1
            endloop
        endmethod
    endstruct
    public struct StructColumnSpan
        implement Allocation
        implement List
        
        method SetIcon takes integer row, integer columnStart, integer columnEnd, string iconPath returns nothing
            if (columnStart > columnEnd) then
                call this.SetIcon(row, columnEnd, columnStart, iconPath)
            else
                loop
                    exitwhen (columnStart > columnEnd)
                    call Multiboard(this).SetIcon(row, columnStart, iconPath)
                    set columnStart = columnStart + 1
                endloop
            endif
        endmethod
        method SetWidth takes integer row, integer columnStart, integer columnEnd, real value returns nothing
            if (columnStart > columnEnd) then
                call this.SetWidth(row, columnEnd, columnStart, value)
            else
                loop
                    exitwhen (columnStart > columnEnd)
                    call Multiboard(this).SetWidth(row, columnStart, value)
                    set columnStart = columnStart + 1
                endloop
            endif
        endmethod
    endstruct
    public struct StructRow
        implement Allocation
        implement List
        
        method SetIcon takes integer row, string iconPath returns nothing
            call Multiboard(this).ColumnSpan.SetIcon(row, 0, Multiboard(this).GetColumnCount(), iconPath)
        endmethod
        method SetWidth takes integer row, real value returns nothing
            call Multiboard(this).ColumnSpan.SetWidth(row, 0, Multiboard(this).GetColumnCount(), value)
        endmethod
    endstruct
    public struct StructTitle
        implement Allocation
        implement List
        
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
        static Timer UPDATE_TIMER
        string text
        method Get takes nothing returns string
            return this.text
        endmethod
        method Update takes nothing returns nothing
            if MULTIBOARD.Shown.AdjustTitle() then
                return
            endif
            call MultiboardSetTitleText(Multiboard(this).self, String.Color.Do("[" + Real.ToStringWithDecimals(GetDebugTime(), 0) + "]\n", String.Color.DWC) + "\t" + this.Get())
        endmethod
        method Set takes string text returns nothing
            set this.text = text
            call this.Update()
        endmethod
        timerMethod UpdateByTimer
            local thistype this = MULTIBOARD.Shown.GetCurrent(User.GetLocal())
            if (this == NULL) then
                return
            endif
            call this.Update()
        endmethod
        eventMethod Event_Start
            call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.UpdateByTimer)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.UPDATE_TIMER = Timer.Create()
            call Event.Create(EventType.START, EventPriority.HEADER, function thistype.Event_Start).AddToStatics()
        endmethod
    endstruct
    scope FolderShown
    scope FolderControl
    public struct StructPageSwitch
        implement Allocation
        implement List
        
                static Event LEFT_EVENT
                static Event RIGHT_EVENT
                boolean active
                static method IsActive takes User whichPlayer returns boolean
                    return thistype(whichPlayer).active
                endmethod
                static method ChangeBoard takes Multiboard parent, User whichPlayer returns nothing
                    call parent.Shown.Show(whichPlayer)
                    call OptionsBoard.Event_MultiboardChange(parent, whichPlayer)
                    call StructInfo.Event_MultiboardChange(parent, whichPlayer)
                endmethod
                eventMethod Event_Left
                    local User whichPlayer = params.User.GetTrigger()
                    local Queue activeQueue = MULTIBOARD.Shown.GetActiveQueue(whichPlayer)
                    local Multiboard parent = activeQueue.GetPrev(MULTIBOARD.Shown.GetCurrent(whichPlayer))
                    if (parent == NULL) then
                        set parent = activeQueue.GetLast()
                    endif
                    call thistype.ChangeBoard(parent, whichPlayer)
                endmethod
                eventMethod Event_Right
                    local User whichPlayer = params.User.GetTrigger()
                    local Queue activeQueue = MULTIBOARD.Shown.GetActiveQueue(whichPlayer)
                    local Multiboard parent = activeQueue.GetNext(MULTIBOARD.Shown.GetCurrent(whichPlayer))
                    if (parent == NULL) then
                        set parent = activeQueue.GetFirst()
                    endif
                    call thistype.ChangeBoard(parent, whichPlayer)
                endmethod
                static method Deactivate takes User whichPlayer returns nothing
                    local thistype this = whichPlayer
                    if not this.active then
                        return
                    endif
                    set this.active = false
                    call whichPlayer.Event.Remove(thistype.LEFT_EVENT)
                    call whichPlayer.Event.Remove(thistype.RIGHT_EVENT)
                    call MULTIBOARD.Shown.GetCurrent(User.GetLocal()).Title.Update()
                endmethod
                static method Activate takes User whichPlayer returns nothing
                    local thistype this = whichPlayer
                    if this.active then
                        return
                    endif
                    set this.active = true
                    call whichPlayer.Event.Add(thistype.LEFT_EVENT)
                    call whichPlayer.Event.Add(thistype.RIGHT_EVENT)
                    call MULTIBOARD.Shown.GetCurrent(User.GetLocal()).Title.Update()
                endmethod
                static method Create takes User whichPlayer returns thistype
                    local thistype this = whichPlayer
                    set this.active = false
                    return this
                endmethod
                static method InitPlayers takes nothing returns nothing
                    local integer iteration = User.PLAYING_HUMANS_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local User curPlayer = User.PLAYING_HUMANS[iteration]
                        call thistype.Create(curPlayer)
                        set iteration = iteration - 1
                    endloop
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.LEFT_EVENT = Event.Create(USER.KeyEvent.LeftArrow.PRESS_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Left)
                    set thistype.RIGHT_EVENT = Event.Create(USER.KeyEvent.RightArrow.PRESS_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Right)
                    call thistype.InitPlayers()
                endmethod
            endstruct
        endscope
    public struct StructControl
        implement Allocation
        implement List
        
            boolean active
    FolderControl_StructPageSwitch PageSwitch = this
    FolderControl_StructPageSwitch LinkToStruct_PageSwitch
            static method Deactivate takes User whichPlayer returns nothing
                local thistype this = whichPlayer
                if not this.active then
                    return
                endif
                set this.active = false
                call Camera.Unlock(whichPlayer)
                call OptionsBoard.Event_MultiboardControlDeactivate(whichPlayer)
                call StructInfo.Event_MultiboardControlDeactivate(whichPlayer)
                call thistype(NULL).PageSwitch.Deactivate(whichPlayer)
            endmethod
            static method Activate takes User whichPlayer returns nothing
                local thistype this = whichPlayer
                if this.active then
                    return
                endif
                set this.active = true
                call Camera.Lock(whichPlayer)
                call OptionsBoard.Event_MultiboardControlActivate(whichPlayer)
                call StructInfo.Event_MultiboardControlActivate(whichPlayer)
                call thistype(NULL).PageSwitch.Activate(whichPlayer)
            endmethod
            eventMethod Event_Esc
                local User whichPlayer = params.User.GetTrigger()
                local thistype this = whichPlayer
                if this.active then
                    call thistype.Deactivate(whichPlayer)
                    return
                endif
                call thistype.Activate(whichPlayer)
            endmethod
            static method Create takes User whichPlayer returns thistype
                local thistype this = whichPlayer
                set this.active = false
                return this
            endmethod
            static method InitPlayers takes nothing returns nothing
                local integer iteration = User.PLAYING_HUMANS_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local User curPlayer = User.PLAYING_HUMANS[iteration]
                    call thistype.Create(curPlayer)
                    set iteration = iteration - 1
                endloop
            endmethod
            static method Init takes nothing returns nothing
                call Event.Create(USER.KeyEvent.ESC_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Esc).AddToStatics()
                call thistype.InitPlayers()
                call thistype(NULL).PageSwitch.Init()
            endmethod
        endstruct
    endscope
    public struct StructShown
        implement Allocation
        implement List
        
        Queue activeQueue
        Multiboard current
    FolderShown_StructControl Control = this
    FolderShown_StructControl LinkToStruct_Control
        static method GetCurrent takes User whichPlayer returns Multiboard
            local thistype this = whichPlayer
            return this.current
        endmethod
        static method GetActiveQueue takes User whichPlayer returns Multiboard
            local thistype this = whichPlayer
            return this.activeQueue
        endmethod
        static method AdjustTitle takes nothing returns boolean
            local User whichPlayer = User.GetLocal()
            local Multiboard parent = thistype.GetCurrent(whichPlayer)
            local thistype this = whichPlayer
            if thistype(NULL).Control.PageSwitch.IsActive(whichPlayer) then
                call MultiboardSetTitleText(parent.self, String.Color.Do("<<<", String.Color.GOLD) + " " + Integer.ToString(this.activeQueue.GetIndex(parent) + 1) + "/" + Integer.ToString(this.activeQueue.Count() + 1) + " - " + String.Color.Do(parent.Title.Get(), String.Color.BONUS) + " " + String.Color.Do(">>>", String.Color.GOLD))
                return true
            endif
            return false
        endmethod
        method Show takes User whichPlayer returns nothing
            local Multiboard parent = this
            set this = whichPlayer
            set this.current = parent
            if not whichPlayer.IsLocal() then
                return
            endif
            call MultiboardDisplay(parent.self, true)
            call MultiboardMinimize(parent.self, false)
            call parent.Title.Update()
        endmethod
        method Event_Destroy takes nothing returns nothing
        	local Multiboard parent = this
            local integer iteration = User.PLAYING_HUMANS_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local User curPlayer = User.PLAYING_HUMANS[iteration]
                set this = curPlayer
                call this.activeQueue.Remove(parent)
                if (this.current == parent) then
                    local Multiboard new = this.activeQueue.GetFirst()
                    if (new == NULL) then
                        set this.current = NULL
                    else
                        call new.Show(curPlayer)
                    endif
                endif
                set iteration = iteration - 1
            endloop
            call parent.Title.Update()
        endmethod
        method Event_Show takes User whichPlayer returns nothing
            local Multiboard parent = this
            set this = whichPlayer
            if this.activeQueue.Add(parent) then
                call thistype(parent).Show(whichPlayer)
            else
                call parent.Title.Update()
            endif
        endmethod
        static method Create takes User whichPlayer returns thistype
            local thistype this = whichPlayer
            set this.activeQueue = Queue.Create()
            set this.current = NULL
            return this
        endmethod
        static method Update takes User whichPlayer returns nothing
            if not whichPlayer.IsLocal() then
                return
            endif
            local thistype this = whichPlayer
            if (this.current == NULL) then
                return
            endif
            call MultiboardDisplay(this.current.self, true)
        endmethod
        static method InitPlayers takes nothing returns nothing
            local integer iteration = User.PLAYING_HUMANS_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local User curPlayer = User.PLAYING_HUMANS[iteration]
                call thistype.Create(curPlayer)
                set iteration = iteration - 1
            endloop
        endmethod
        static method Init takes nothing returns nothing
            call thistype.InitPlayers()
            call thistype(NULL).Control.Init()
        endmethod
    endstruct
endscope
    globals
        Multiboard MULTIBOARD = STRUCT_BASE
    endglobals
    struct Multiboard
        implement Allocation
        implement List
        
    static key GetKeyMacro_ITEMS_KEY_ARRAY
    static constant integer ITEMS_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_ITEMS_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static constant integer MAX_COLUMN_AMOUNT = 50
    static constant integer MAX_ROW_AMOUNT = 32
    static thistype TEMP
    integer columnCount = -1
    integer rowCount = -1
    multiboard self
    FolderMultiboard_StructColumn Column = this
    FolderMultiboard_StructColumn LinkToStruct_Column
    FolderMultiboard_StructColumnSpan ColumnSpan = this
    FolderMultiboard_StructColumnSpan LinkToStruct_ColumnSpan
    FolderMultiboard_StructRow Row = this
    FolderMultiboard_StructRow LinkToStruct_Row
    FolderMultiboard_StructShown Shown = this
    FolderMultiboard_StructShown LinkToStruct_Shown
    FolderMultiboard_StructTitle Title = this
    FolderMultiboard_StructTitle LinkToStruct_Title
    method GetItem takes integer row, integer column returns MultiboardItem
        
        return Memory.IntegerKeys.GetIntegerByHandle(this.self, ITEMS_KEY_ARRAY + row * thistype.MAX_COLUMN_AMOUNT + column)
    endmethod
    method SetItem takes integer row, integer column returns nothing
        
        
        call this.GetItem(row, column).Use()
    endmethod
    method CreateItem takes integer row, integer column, multiboard self returns nothing
        local MultiboardItem newItem = MultiboardItem.Create(this, row, column)
        call Memory.IntegerKeys.SetIntegerByHandle(self, ITEMS_KEY_ARRAY + row * thistype.MAX_COLUMN_AMOUNT + column, newItem)
    endmethod
    method GetColumnCount takes nothing returns integer
        return this.columnCount
    endmethod
    method GetRowCount takes nothing returns integer
        return this.rowCount
    endmethod
    method SetColumnCount takes integer count returns nothing
        local integer columnCount = this.GetColumnCount()
        local integer rowCount = this.GetRowCount()
        local multiboard self = this.self
        set this.columnCount = count
		local integer column
		local integer row
        if (count > columnCount) then
            set column = columnCount + 1
            call MultiboardSetColumnCount(self, count + 1)
            loop
                exitwhen (column > count)
                set row = rowCount
                loop
                    exitwhen (row < ARRAY_MIN)
                    call this.SetItem(row, column)
                    set row = row - 1
                endloop
                set column = column + 1
            endloop
        elseif (count < columnCount) then
            set column = columnCount
            loop
                exitwhen (column < ARRAY_MIN)
                set row = rowCount
                loop
                    exitwhen (row < ARRAY_MIN)
                    call this.SetItem(row, column)
                    set row = row - 1
                endloop
                set column = column - 1
            endloop
           
            call MultiboardSetColumnCount(self, count + 1)
        endif
        set self = null
    endmethod
    method SetRowCount takes integer count returns nothing
        local integer columnCount = this.GetColumnCount()
        local integer row = this.GetRowCount()
        local multiboard self = this.self
        set this.rowCount = count
		local integer column
        if (count > row) then
            set row = row + 1
			local integer i = row
			loop
				exitwhen (i > count)
            	call MultiboardSetRowCount(self, i + 1)
				set i = i + 1
            endloop
            loop
                exitwhen (row > count)
                set column = columnCount
                loop
                    exitwhen (column < ARRAY_MIN)
                    call this.SetItem(row, column)
                    set column = column - 1
                endloop
                set row = row + 1
            endloop
        elseif (count < row) then
           
			set row = row - 1
			loop
				exitwhen (row < count)
            	call MultiboardSetRowCount(self, row + 1)
            	set row = row - 1
            endloop
        endif
        set self = null
    endmethod
    method Destroy takes nothing returns nothing
        local multiboard self = this.self
        call this.SetColumnCount(-1)
        call this.SetRowCount(-1)
        call this.Shown.Event_Destroy()
        call this.deallocate()
        call DestroyMultiboard(self)
        set self = null
    endmethod
    method AddColumnCount takes integer amount returns nothing
        call this.SetColumnCount(this.GetColumnCount() + amount)
    endmethod
    method GetNewColumn takes nothing returns integer
        local integer count = this.GetColumnCount() + 1
        call this.SetColumnCount(count)
        return count
    endmethod
    method AddRowCount takes integer amount returns nothing
        call this.SetRowCount(this.GetRowCount() + amount)
    endmethod
    method GetNewRow takes nothing returns integer
        local integer count = this.GetRowCount() + 1
        call this.SetRowCount(count)
        return count
    endmethod
    method CheckCellAvailable takes integer row, integer column returns nothing
        if (column > this.columnCount) then
            call this.SetColumnCount(column)
        endif
        if (row > this.rowCount) then
            call this.SetRowCount(row)
        endif
    endmethod
    method SetIcon takes integer row, integer column, string value returns nothing
        call this.CheckCellAvailable(row, column)
        call this.GetItem(row, column).SetIcon(value)
    endmethod
    method SetTitle takes string val returns nothing
        call this.Title.Set(val)
    endmethod
	method ClearVals takes nothing returns nothing
        local integer columnCount = this.GetColumnCount()
        local integer rowCount = this.GetRowCount()
		local integer col = columnCount
		loop
			exitwhen (col < ARRAY_MIN)
			local integer row = rowCount
			loop
				exitwhen (row < ARRAY_MIN)
				call this.GetItem(row, col).SetValue("")
				set row = row - 1
			endloop
			set col = col - 1
		endloop
	endmethod
    method SetValue takes integer row, integer column, string value returns nothing
        call this.CheckCellAvailable(row, column)
        call this.GetItem(row, column).SetValue(value)
    endmethod
    method SetWidth takes integer row, integer column, real value returns nothing
        call this.CheckCellAvailable(row, column)
        call this.GetItem(row, column).SetWidth(value)
    endmethod
    method Show takes User whichPlayer returns nothing
        call this.Shown.Event_Show(whichPlayer)
    endmethod
    execMethod Create_Executed
        local thistype this = thistype.TEMP
        local multiboard self = this.self
		local integer column = 0
        loop
            local integer row = 0
            loop
                call this.CreateItem(row, column, self)
                set row = row + 1
                exitwhen (row == thistype.MAX_ROW_AMOUNT)
            endloop
            set column = column + 1
            exitwhen (column == thistype.MAX_COLUMN_AMOUNT)
        endloop
        set self = null
    endmethod
    static method Create takes nothing returns Multiboard
        local thistype this = thistype.allocate()
        set this.columnCount = -1
        set this.rowCount = -1
        set this.self = CreateMultiboard()
        set thistype.TEMP = this
        call Code.Run(function thistype.Create_Executed)
        return this
    endmethod
    initMethod Init of Header_5
        call thistype(NULL).Shown.Init()
        call thistype(NULL).Title.Init()
    endmethod
endstruct
    scope FolderOrder
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return Order(this).Data.table.IntegerKeys.Table.ContainsInteger(Order(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Order(this).Data.table.IntegerKeys.Table.CountIntegers(Order(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Order(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Order(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Order(this).Data.table.IntegerKeys.Table.GetInteger(Order(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Order(this).Data.table.IntegerKeys.Table.GetFirstInteger(Order(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Order(this).Data.table.IntegerKeys.Table.GetLastInteger(Order(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Order(this).Data.table.IntegerKeys.Table.Clear(Order(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Order(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Order(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Order(this).Data.table.IntegerKeys.Table.RemoveInteger(Order(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Order(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Order(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Order(this).Data.table.IntegerKeys.Table.AddInteger(Order(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Order(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Order(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Order(this).Data.table.IntegerKeys.Table.JoinInteger(Order(this).Id.Get(), key, Order(other).Data.table, Order(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Order(this).Data.table.IntegerKeys.Table.RandomInteger(Order(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Order(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Order(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Order(this).Data.table.IntegerKeys.Table.PrintIntegers(Order(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return Order(this).Data.table.IntegerKeys.GetInteger(Order(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Order(this).Data.table.IntegerKeys.RemoveInteger(Order(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Order(this).Data.table.IntegerKeys.SetInteger(Order(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Order(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Order.Allocation.deallocate_demount.hook
		call Order(this).Data.Destroy()
	endinject
	inject Order.Allocation.allocate_mount.hook
		call Order(this).Data.Event_Create()
	endinject
    endstruct
    scope FolderEvent
    public struct StructNative
        implement Allocation
        implement List
        
                static method GetTrigger takes nothing returns Order
                    return Order.GetFromSelf(GetIssuedOrderId())
                endmethod
        endstruct
    endscope
    public struct StructEvent
        implement Allocation
        implement List
        
    FolderEvent_StructNative Native = this
    FolderEvent_StructNative LinkToStruct_Native
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(Order(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(Order(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(Order(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(Order(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(Order(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(Order(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(Order(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(Order(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject Order.Allocation.deallocate_demount.hook
			call Order(this).Event.Destroy()
		endinject
		inject Order.Allocation.allocate_mount.hook
			call Order(this).Event.Event_Create()
		endinject
    endstruct
endscope
    globals
        Order ORDER = STRUCT_BASE
    endglobals
    struct Order
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static thistype ACID_BOMB
    static thistype ANCESTRAL_SPIRIT
    static thistype ANIMATE_DEAD
    static thistype ATTACK
    static thistype AVATAR
    static thistype BANISH
    static thistype BERSERK
    static thistype BLIZZARD
    static thistype BLOOD_LUST
    static thistype BREATH_OF_FIRE
    static thistype BREATH_OF_FROST
    static thistype CANNIBALIZE
    static thistype CARRION_SWARM
    static thistype CHAIN_LIGHTNING
    static thistype CHANNEL
    static thistype CLUSTER_ROCKETS
    static thistype CRIPPLE
	static thistype CYCLONE
    static thistype DARK_CONVERSION
    static thistype DARK_PORTAL
    static thistype DEATH_AND_DECAY
    static thistype DEATH_COIL
    static thistype DOOM
    static thistype DRUNKEN_HAZE
    static thistype EAT_TREE
    static thistype ENSNARE
    static thistype ENTANGLING_ROOTS
    static thistype EVIL_EYE
    static thistype FIREBOLT
    static thistype FRENZY
    static thistype FRENZY_OFF
    static thistype FRENZY_ON
    static thistype HEAL
    static thistype HEALING_WAVE
    static thistype HEX
    static thistype HOLD_POSITION
    static thistype HOWL_OF_TERROR
    static thistype IMPALE
    static thistype INFERNO
    static thistype INNER_FIRE
    static thistype LIGHTNING_SHIELD
    static thistype LOAD
    static thistype MANA_BURN
    static thistype MANA_SHIELD_ON
    static thistype MIRROR_IMAGE
    static thistype MONSOON
    static thistype MOVE
    static thistype MOVE_ITEM_TO_SLOT_0
    static thistype MOVE_ITEM_TO_SLOT_1
    static thistype MOVE_ITEM_TO_SLOT_2
    static thistype MOVE_ITEM_TO_SLOT_3
    static thistype MOVE_ITEM_TO_SLOT_4
    static thistype MOVE_ITEM_TO_SLOT_5
    static thistype PATROL
    static thistype PHASE_SHIFT
    static thistype PURGE
    static thistype RAISE_DEAD
    static thistype RESURRECTION
    static thistype ROAR
    static thistype SANCTUARY
    static thistype SELF_DESTRUCT
    static thistype SHOCK_WAVE
    static thistype SLEEP
    static thistype SMART
    static thistype SOULBURN
    static thistype SPIRIT_WOLF
    static thistype STAR_FALL
    static thistype STASIS_TRAP
    static thistype STOP
    static thistype STUNNED
    static thistype SUMMON_FACTORY
    static thistype SUMMON_GRIZZLY
    static thistype SUMMON_WAR_EAGLE
    static thistype TAUNT
    static thistype THUNDER_BOLT
    static thistype THUNDER_CLAP
    static thistype USE_ITEM_IN_SLOT_0
    static thistype USE_ITEM_IN_SLOT_1
    static thistype USE_ITEM_IN_SLOT_2
    static thistype USE_ITEM_IN_SLOT_3
    static thistype USE_ITEM_IN_SLOT_4
    static thistype USE_ITEM_IN_SLOT_5
    static thistype VOODOO
    static thistype WARD
    static thistype WINDWALK
    integer self
    FolderOrder_StructData Data = this
    FolderOrder_StructData LinkToStruct_Data
    FolderOrder_StructEvent Event = this
    FolderOrder_StructEvent LinkToStruct_Event
    FolderOrder_StructId Id = this
    FolderOrder_StructId LinkToStruct_Id
    string name
    method GetName takes nothing returns string
        return this.name
    endmethod
    method SetName takes string value returns nothing
        set this.name = value
    endmethod
    boolean parallel
    method IsParallel takes nothing returns boolean
        return this.parallel
    endmethod
    method SetParallel takes boolean value returns nothing
        set this.parallel = value
    endmethod
    static method GetFromSelf takes integer self returns thistype
        return Memory.IntegerKeys.GetInteger(self, KEY)
    endmethod
    method GetSelf takes nothing returns integer
        return this.self
    endmethod
    method GetInventoryIndex takes nothing returns integer
        return (this - thistype.USE_ITEM_IN_SLOT_0)
    endmethod
    method IsInventoryUse takes nothing returns boolean
        return ((this >= thistype.USE_ITEM_IN_SLOT_0) and (this <= thistype.USE_ITEM_IN_SLOT_5))
    endmethod
    static method Create takes string name, integer self returns thistype
        local thistype this = thistype.allocate()
        set this.self = self
        call Memory.IntegerKeys.SetInteger(self, KEY, this)
        call this.Id.Event_Create()
        call this.SetName(name)
        call this.SetParallel(false)
        return this
    endmethod
    initMethod Init of Header_2
        set thistype.ACID_BOMB = thistype.Create("acid bomb", 852662)
        set thistype.ANCESTRAL_SPIRIT = thistype.Create("ancestral spirit", 852490)
        set thistype.ANIMATE_DEAD = thistype.Create("animate dead", 852217)
        set thistype.ATTACK = thistype.Create("attack", 851983)
        set thistype.AVATAR = thistype.Create("avatar", 852086)
        set thistype.BANISH = thistype.Create("banish", 852486)
        set thistype.BERSERK = thistype.Create("berserk", 852100)
        set thistype.BLIZZARD = thistype.Create("blizzard", 852089)
        set thistype.BLOOD_LUST = thistype.Create("blood lust", 852101)
        set thistype.BREATH_OF_FIRE = thistype.Create("breath of fire", 852580)
        set thistype.BREATH_OF_FROST = thistype.Create("breath of frost", 852560)
        set thistype.CANNIBALIZE = thistype.Create("cannibalize", 852188)
        set thistype.CARRION_SWARM = thistype.Create("carrion swarm", 852218)
        set thistype.CHAIN_LIGHTNING = thistype.Create("chain lightning", 852119)
        set thistype.CHANNEL = thistype.Create("channel", 852600)
        set thistype.CLUSTER_ROCKETS = thistype.Create("cluster rockets", 852652)
        set thistype.CRIPPLE = thistype.Create("cripple", 852189)
        set thistype.CYCLONE = thistype.Create("cyclone", 852144)
        set thistype.DARK_CONVERSION = thistype.Create("dark conversion", 852228)
        set thistype.DARK_PORTAL = thistype.Create("dark portal", 852229)
        set thistype.DEATH_AND_DECAY = thistype.Create("death and decay", 852221)
        set thistype.DEATH_COIL = thistype.Create("death coil", 852222)
        set thistype.DOOM = thistype.Create("doom", 852583)
        set thistype.DRUNKEN_HAZE = thistype.Create("drunken haze", 852585)
        set thistype.EAT_TREE = thistype.Create("eat tree", 852146)
        set thistype.ENSNARE = thistype.Create("ensnare", 852106)
        set thistype.ENTANGLING_ROOTS = thistype.Create("entangling roots", 852171)
        set thistype.EVIL_EYE = thistype.Create("evil eye", 852105)
        set thistype.FIREBOLT = thistype.Create("firebolt", 852231)
        set thistype.FRENZY = thistype.Create("frenzy", 852561)
        set thistype.FRENZY_OFF = thistype.Create("frenzyOff", 852563)
        set thistype.FRENZY_ON = thistype.Create("frenzyOn", 852562)
        set thistype.HEAL = thistype.Create("heal", 852063)
        set thistype.HEALING_WAVE = thistype.Create("healing wave", 852501)
        set thistype.HEX = thistype.Create("hex", 852502)
        set thistype.HOLD_POSITION = thistype.Create("hold position", 851993)
        set thistype.HOWL_OF_TERROR = thistype.Create("howl of terror", 852588)
        set thistype.IMPALE = thistype.Create("impale", 852555)
        set thistype.INFERNO = thistype.Create("inferno", 852232)
        set thistype.INNER_FIRE = thistype.Create("inner fire", 852066)
        set thistype.LIGHTNING_SHIELD = thistype.Create("lightning shield", 852110)
        set thistype.LOAD = thistype.Create("load", 852046)
        set thistype.MANA_BURN = thistype.Create("mana burn", 852179)
        set thistype.MANA_SHIELD_ON = thistype.Create("mana shield on", 852589)
        set thistype.MIRROR_IMAGE = thistype.Create("mirror image", 852123)
        set thistype.MONSOON = thistype.Create("monsoon", 851591)
        set thistype.MOVE = thistype.Create("move", 851986)
        set thistype.MOVE_ITEM_TO_SLOT_0 = thistype.Create("move item to slot 0", 852002)
        set thistype.MOVE_ITEM_TO_SLOT_1 = thistype.Create("move item to slot 1", 852003)
        set thistype.MOVE_ITEM_TO_SLOT_2 = thistype.Create("move item to slot 2", 852004)
        set thistype.MOVE_ITEM_TO_SLOT_3 = thistype.Create("move item to slot 3", 852005)
        set thistype.MOVE_ITEM_TO_SLOT_4 = thistype.Create("move item to slot 4", 852006)
        set thistype.MOVE_ITEM_TO_SLOT_5 = thistype.Create("move item to slot 5", 852007)
        set thistype.PATROL = thistype.Create("phase shift", 851990)
        set thistype.PHASE_SHIFT = thistype.Create("phase shift", 852514)
        set thistype.PURGE = thistype.Create("purge", 852111)
        set thistype.RAISE_DEAD = thistype.Create("raise dead", 852197)
        set thistype.RESURRECTION = thistype.Create("resurrection", 852094)
        set thistype.ROAR = thistype.Create("roar", 852164)
        set thistype.SELF_DESTRUCT = thistype.Create("self destruct", 852040)
        set thistype.SANCTUARY = thistype.Create("sanctuary", 852569)
        set thistype.SHOCK_WAVE = thistype.Create("shock wave", 852125)
        set thistype.SLEEP = thistype.Create("sleep", 852227)
        set thistype.SMART = thistype.Create("smart", 851971)
        set thistype.SOULBURN = thistype.Create("soulburn", 852668)
        set thistype.SPIRIT_WOLF = thistype.Create("spirit wolf", 852126)
        set thistype.STAR_FALL = thistype.Create("star fall", 852183)
        set thistype.STASIS_TRAP = thistype.Create("stasis trap", 852114)
        set thistype.STOP = thistype.Create("stop", 851972)
        set thistype.STUNNED = thistype.Create("stunned", 851973)
        set thistype.SUMMON_FACTORY = thistype.Create("summon factory", 852658)
        set thistype.SUMMON_GRIZZLY = thistype.Create("summon grizzly", 852594)
        set thistype.SUMMON_WAR_EAGLE = thistype.Create("summon war eagle", 852596)
        set thistype.TAUNT = thistype.Create("taunt", 852520)
        set thistype.THUNDER_BOLT = thistype.Create("thunder bolt", 852095)
        set thistype.THUNDER_CLAP = thistype.Create("tunder clap", 852096)
        set thistype.USE_ITEM_IN_SLOT_0 = thistype.Create("use item in slot 0", 852008)
        set thistype.USE_ITEM_IN_SLOT_1 = thistype.Create("use item in slot 1", 852009)
        set thistype.USE_ITEM_IN_SLOT_2 = thistype.Create("use item in slot 2", 852010)
        set thistype.USE_ITEM_IN_SLOT_3 = thistype.Create("use item in slot 3", 852011)
        set thistype.USE_ITEM_IN_SLOT_4 = thistype.Create("use item in slot 4", 852012)
        set thistype.USE_ITEM_IN_SLOT_5 = thistype.Create("use item in slot 5", 852013)
        set thistype.VOODOO = thistype.Create("voodoo", 852503)
        set thistype.WARD = thistype.Create("ward", 852504)
        set thistype.WINDWALK = thistype.Create("windwalk", 852129)
		call thistype.BERSERK.SetParallel(true)
		call thistype.WINDWALK.SetParallel(true)
    endmethod
endstruct
    scope FolderOrderInstance
    public struct StructRefs
        implement Allocation
        implement List
        
        boolean waiting
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
        method CheckForDestroy takes nothing returns boolean
            if (this.Get() > 0) then
                set this.waiting = true
                return false
            endif
            return true
        endmethod
        method Subtract takes nothing returns nothing
            local integer value = this.Get() - 1
            set this.value = value
            if ((value == 0) and (this.waiting)) then
                call OrderInstance(this).Destroy()
            endif
        endmethod
        method Add takes nothing returns nothing
            set this.value = this.Get() + 1
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0
            set this.waiting = false
        endmethod
    endstruct
endscope
    globals
        OrderInstance ORDER_INSTANCE = STRUCT_BASE
    endglobals
    struct OrderInstance
        implement Allocation
        implement List
        
    static thistype TEMP
    FolderOrderInstance_StructRefs Refs = this
    FolderOrderInstance_StructRefs LinkToStruct_Refs
    Item targetItem
    method GetTargetItem takes nothing returns Item
        return this.targetItem
    endmethod
    method SetTargetItem takes Item value returns nothing
        set this.targetItem = value
    endmethod
    Unit targetUnit
    method GetTargetUnit takes nothing returns Unit
        return this.targetUnit
    endmethod
    method SetTargetUnit takes Unit value returns nothing
        set this.targetUnit = value
    endmethod
    integer targetType
    method GetTargetType takes nothing returns integer
        return this.targetType
    endmethod
    method SetTargetType takes integer value returns nothing
        set this.targetType = value
    endmethod
    real targetX
    method GetTargetX takes nothing returns real
        return this.targetX
    endmethod
    method SetTargetX takes real value returns nothing
        set this.targetX = value
    endmethod
    real targetY
    method GetTargetY takes nothing returns real
        return this.targetY
    endmethod
    method SetTargetY takes real value returns nothing
        set this.targetY = value
    endmethod
    Order whichOrder
    method GetOrder takes nothing returns Order
        return this.whichOrder
    endmethod
    method SetOrder takes Order value returns nothing
        set this.whichOrder = value
    endmethod
    method GetCurrentTargetX takes nothing returns real
        local Item targetItem = this.GetTargetItem()
        if (targetItem != NULL) then
            return targetItem.Position.GetX()
        endif
        local Unit targetUnit = this.GetTargetUnit()
        if (targetUnit != NULL) then
            return targetUnit.Position.X.Get()
        endif
        return this.GetTargetX()
    endmethod
    method GetCurrentTargetY takes nothing returns real
        local Item targetItem = this.GetTargetItem()
        if (targetItem != NULL) then
            return targetItem.Position.GetY()
        endif
        local Unit targetUnit = this.GetTargetUnit()
        if (targetUnit != NULL) then
            return targetUnit.Position.Y.Get()
        endif
        return this.GetTargetY()
    endmethod
    method Reset takes nothing returns nothing
        call this.SetOrder(NULL)
        call this.SetTargetItem(NULL)
        call this.SetTargetUnit(NULL)
        call this.SetTargetX(0.)
        call this.SetTargetY(0.)
    endmethod
    method Destroy takes nothing returns nothing
        if not this.Refs.CheckForDestroy() then
            return
        endif
        call this.deallocate()
    endmethod
    static method Create takes nothing returns thistype
        local thistype this = thistype.allocate()
        call this.Reset()
        call this.Refs.Event_Create()
        return this
    endmethod
endstruct
    globals
        AILetOff AI_LET_OFF = STRUCT_BASE
    endglobals
    struct AILetOff
        implement Allocation
        implement List
        
    static Event ACQUIRE_EVENT
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static Unit TARGET
    static Timer UPDATE_TIMER
    static constant real MAX_RANGE_SQUARE = thistype.MAX_RANGE * thistype.MAX_RANGE
    Unit target
    static thistype array ACTIVE_LIST_ALL
    static integer ACTIVE_LIST_ALL_COUNT = ARRAY_EMPTY
    integer ACTIVE_LIST_index
    static method ACTIVE_LIST_Count takes nothing returns integer
        return thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static method ACTIVE_LIST_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Get takes integer index returns thistype
        return thistype.ACTIVE_LIST_ALL[index]
    endmethod
    static method ACTIVE_LIST_GetIndex takes thistype this returns integer
        return this.ACTIVE_LIST_index
    endmethod
    static method ACTIVE_LIST_Contains takes thistype this returns boolean
        return (thistype.ACTIVE_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ACTIVE_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ACTIVE_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ACTIVE_LIST_RandomAll takes nothing returns thistype
        return thistype.ACTIVE_LIST_Random(ARRAY_MIN, thistype.ACTIVE_LIST_ALL_COUNT)
    endmethod
    static method ACTIVE_LIST_Remove takes thistype this returns boolean
        if not thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT].ACTIVE_LIST_index = this.ACTIVE_LIST_index
        set thistype.ACTIVE_LIST_ALL[this.ACTIVE_LIST_index - 1] = thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT]
        set this.ACTIVE_LIST_index = ARRAY_MIN
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT - 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Add takes thistype this returns boolean
        if thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT + 1
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT] = this
        set this.ACTIVE_LIST_index = thistype.ACTIVE_LIST_ALL_COUNT + 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static thistype array FOR_EACH_LIST_ALL
    static integer FOR_EACH_LIST_ALL_COUNT = ARRAY_EMPTY
    static method FOR_EACH_LIST_FetchFirst takes nothing returns thistype
        local thistype result
        if (thistype.FOR_EACH_LIST_ALL_COUNT < ARRAY_MIN) then
            return NULL
        endif
        set result = thistype.FOR_EACH_LIST_ALL[ARRAY_MIN]
        set thistype.FOR_EACH_LIST_ALL[ARRAY_MIN] = thistype.FOR_EACH_LIST_ALL[thistype.FOR_EACH_LIST_ALL_COUNT]
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.FOR_EACH_LIST_ALL_COUNT - 1
        return result
    endmethod
    static method FOR_EACH_LIST_Set takes nothing returns nothing
        local integer iteration = thistype.ACTIVE_LIST_ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.FOR_EACH_LIST_ALL[iteration] = thistype.ACTIVE_LIST_ALL[iteration]
            set iteration = iteration - 1
        endloop
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    timerMethod Update
        call thistype.FOR_EACH_LIST_Set()
        loop
            local thistype this = thistype.FOR_EACH_LIST_FetchFirst()
            exitwhen (this == NULL)
            local Unit source = this
            local Unit target = this.target
            if (Math.DistanceSquareByDeltas(target.Position.Y.Get() - source.Position.Y.Get(), target.Position.X.Get() - source.Position.X.Get()) > thistype.MAX_RANGE_SQUARE) then
                call source.Buffs.Remove(thistype.DUMMY_BUFF)
                call WAYPOINT.Spawns.Update(source)
            endif
        endloop
    endmethod
    eventMethod Event_TargetBuffLose
        local Unit target = params.Unit.GetTrigger()
        loop
            local thistype this = target.Data.Integer.Table.Get(KEY_ARRAY, Memory.IntegerKeys.Table.STARTED)
            exitwhen (this == NULL)
            call Unit(this).Buffs.Remove(thistype.DUMMY_BUFF)
        endloop
    endmethod
    eventMethod Event_TargetBuffGain
    endmethod
    eventMethod Event_BuffLose
        local Unit source = params.Unit.GetTrigger()
        local thistype this = source
        local Unit target = this.target
        if target.Data.Integer.Table.Remove(KEY_ARRAY, this) then
            call target.Buffs.Remove(thistype.TARGET_BUFF)
        endif
        if thistype.ACTIVE_LIST_Remove(this) then
            call thistype.UPDATE_TIMER.Pause()
        endif
    endmethod
    eventMethod Event_BuffGain
        local Unit source = params.Unit.GetTrigger()
        local Unit target = thistype.TARGET
        local thistype this = source
        set this.target = target
        if target.Data.Integer.Table.Add(KEY_ARRAY, this) then
            call target.Buffs.Add(thistype.TARGET_BUFF, 1)
        endif
        call source.Order.UnitTarget(Order.ATTACK, target)
        if thistype.ACTIVE_LIST_Add(this) then
            call thistype.UPDATE_TIMER.Start(3., true, function thistype.Update)
        endif
    endmethod
    eventMethod Event_Acquire
        local Unit source = params.Unit.GetTrigger()
        local Unit target = params.Unit.GetTarget()
        if not target.Classes.Contains(UnitClass.HERO) then
            return
        endif
        set thistype.TARGET = target
        call source.Buffs.Add(thistype.DUMMY_BUFF, 1)
    endmethod
    eventMethod Event_Spawn
        local Unit source = params.Unit.GetTrigger()
        call source.Event.Add(thistype.ACQUIRE_EVENT)
    endmethod
    initMethod Init of AI_Misc
        set thistype.ACQUIRE_EVENT = Event.Create(UNIT.Attack.Events.ACQUIRE_EVENT_TYPE, EventPriority.AI, function thistype.Event_Acquire)
        set thistype.UPDATE_TIMER = Timer.Create()
        call Event.Create(Spawn.DUMMY_EVENT_TYPE, EventPriority.AI, function thistype.Event_Spawn).AddToStatics()
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.AI, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.AI, function thistype.Event_BuffLose))
        call thistype.TARGET_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.AI, function thistype.Event_TargetBuffGain))
        call thistype.TARGET_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.AI, function thistype.Event_TargetBuffLose))
    endmethod
endstruct
globals
    boolean asciiMapInited = false
    string array asciiMap
endglobals
function AsciiToChar takes integer index returns string
    if (asciiMapInited == false) then
        set asciiMapInited = true
        set asciiMap[0] = "{0}"
        set asciiMap[1] = "{1}"
        set asciiMap[2] = "{2}"
        set asciiMap[3] = "{3}"
        set asciiMap[4] = "{4}"
        set asciiMap[5] = "{5}"
        set asciiMap[6] = "{6}"
        set asciiMap[7] = "{7}"
        set asciiMap[8] = "{8}"
        set asciiMap[9] = "{9}"
        set asciiMap[10] = "{10}"
        set asciiMap[11] = "{11}"
        set asciiMap[12] = "{12}"
        set asciiMap[13] = "{13}"
        set asciiMap[14] = "{14}"
        set asciiMap[15] = "{15}"
        set asciiMap[16] = "{16}"
        set asciiMap[17] = "{17}"
        set asciiMap[18] = "{18}"
        set asciiMap[19] = "{19}"
        set asciiMap[20] = "{20}"
        set asciiMap[21] = "{21}"
        set asciiMap[22] = "{22}"
        set asciiMap[23] = "{23}"
        set asciiMap[24] = "{24}"
        set asciiMap[25] = "{25}"
        set asciiMap[26] = "{26}"
        set asciiMap[27] = "{27}"
        set asciiMap[28] = "{28}"
        set asciiMap[29] = "{29}"
        set asciiMap[30] = "{30}"
        set asciiMap[31] = "{31}"
        set asciiMap[32] = " "
        set asciiMap[33] = "!"
        set asciiMap[34] = "\""
        set asciiMap[35] = "#"
        set asciiMap[36] = "$"
        set asciiMap[37] = "%"
        set asciiMap[38] = "&"
        set asciiMap[39] = "'"
        set asciiMap[40] = "("
        set asciiMap[41] = ")"
        set asciiMap[42] = "*"
        set asciiMap[43] = "+"
        set asciiMap[44] = ","
        set asciiMap[45] = "-"
        set asciiMap[46] = "."
        set asciiMap[47] = "/"
        set asciiMap[48] = "0"
        set asciiMap[49] = "1"
        set asciiMap[50] = "2"
        set asciiMap[51] = "3"
        set asciiMap[52] = "4"
        set asciiMap[53] = "5"
        set asciiMap[54] = "6"
        set asciiMap[55] = "7"
        set asciiMap[56] = "8"
        set asciiMap[57] = "9"
        set asciiMap[58] = ":"
        set asciiMap[59] = ";"
        set asciiMap[60] = "<"
        set asciiMap[61] = "="
        set asciiMap[62] = ">"
        set asciiMap[63] = "?"
        set asciiMap[64] = "@"
        set asciiMap[65] = "A"
        set asciiMap[66] = "B"
        set asciiMap[67] = "C"
        set asciiMap[68] = "D"
        set asciiMap[69] = "E"
        set asciiMap[70] = "F"
        set asciiMap[71] = "G"
        set asciiMap[72] = "H"
        set asciiMap[73] = "I"
        set asciiMap[74] = "J"
        set asciiMap[75] = "K"
        set asciiMap[76] = "L"
        set asciiMap[77] = "M"
        set asciiMap[78] = "N"
        set asciiMap[79] = "O"
        set asciiMap[80] = "P"
        set asciiMap[81] = "Q"
        set asciiMap[82] = "R"
        set asciiMap[83] = "S"
        set asciiMap[84] = "T"
        set asciiMap[85] = "U"
        set asciiMap[86] = "V"
        set asciiMap[87] = "W"
        set asciiMap[88] = "X"
        set asciiMap[89] = "Y"
        set asciiMap[90] = "Z"
        set asciiMap[91] = "["
        set asciiMap[92] = "\\"
        set asciiMap[93] = "]"
        set asciiMap[94] = "^"
        set asciiMap[95] = "_"
        set asciiMap[96] = "`"
        set asciiMap[97] = "a"
        set asciiMap[98] = "b"
        set asciiMap[99] = "c"
        set asciiMap[100] = "d"
        set asciiMap[101] = "e"
        set asciiMap[102] = "f"
        set asciiMap[103] = "g"
        set asciiMap[104] = "h"
        set asciiMap[105] = "i"
        set asciiMap[106] = "j"
        set asciiMap[107] = "k"
        set asciiMap[108] = "l"
        set asciiMap[109] = "m"
        set asciiMap[110] = "n"
        set asciiMap[111] = "o"
        set asciiMap[112] = "p"
        set asciiMap[113] = "q"
        set asciiMap[114] = "r"
        set asciiMap[115] = "s"
        set asciiMap[116] = "t"
        set asciiMap[117] = "u"
        set asciiMap[118] = "v"
        set asciiMap[119] = "w"
        set asciiMap[120] = "x"
        set asciiMap[121] = "y"
        set asciiMap[122] = "z"
        set asciiMap[123] = "{"
        set asciiMap[124] = "|"
        set asciiMap[125] = "}"
        set asciiMap[126] = "~"
        set asciiMap[127] = "{DEL}"
        set asciiMap[128] = "€"
        set asciiMap[129] = "{129}"
        set asciiMap[130] = "‚"
        set asciiMap[131] = "ƒ"
        set asciiMap[132] = "„"
        set asciiMap[133] = "…"
        set asciiMap[134] = "†"
        set asciiMap[135] = "‡"
        set asciiMap[136] = "ˆ"
        set asciiMap[137] = "‰"
        set asciiMap[138] = "Š"
        set asciiMap[139] = "‹"
        set asciiMap[140] = "Œ"
        set asciiMap[141] = "{141}"
        set asciiMap[142] = "Ž"
        set asciiMap[143] = "{143}"
        set asciiMap[144] = "{144}"
        set asciiMap[145] = "‘"
        set asciiMap[146] = "’"
        set asciiMap[147] = "“"
        set asciiMap[148] = "”"
        set asciiMap[149] = "•"
        set asciiMap[150] = "–"
        set asciiMap[151] = "—"
        set asciiMap[152] = "˜"
        set asciiMap[153] = "™"
        set asciiMap[154] = "š"
        set asciiMap[155] = "›"
        set asciiMap[156] = "œ"
        set asciiMap[157] = "{157}"
        set asciiMap[158] = "ž"
        set asciiMap[159] = "Ÿ"
        set asciiMap[160] = " "
        set asciiMap[161] = "¡"
        set asciiMap[162] = "¢"
        set asciiMap[163] = "£"
        set asciiMap[164] = "¤"
        set asciiMap[165] = "¥"
        set asciiMap[166] = "¦"
        set asciiMap[167] = "§"
        set asciiMap[168] = "¨"
        set asciiMap[169] = "©"
        set asciiMap[170] = "ª"
        set asciiMap[171] = "«"
        set asciiMap[172] = "¬"
        set asciiMap[173] = "{173}"
        set asciiMap[174] = "®"
        set asciiMap[175] = "¯"
        set asciiMap[176] = "°"
        set asciiMap[177] = "±"
        set asciiMap[178] = "²"
        set asciiMap[179] = "³"
        set asciiMap[180] = "´"
        set asciiMap[181] = "µ"
        set asciiMap[182] = "¶"
        set asciiMap[183] = "·"
        set asciiMap[184] = "¸"
        set asciiMap[185] = "¹"
        set asciiMap[186] = "º"
        set asciiMap[187] = "»"
        set asciiMap[188] = "¼"
        set asciiMap[189] = "½"
        set asciiMap[190] = "¾"
        set asciiMap[191] = "¿"
        set asciiMap[192] = "À"
        set asciiMap[193] = "Á"
        set asciiMap[194] = "Â"
        set asciiMap[195] = "Ã"
        set asciiMap[196] = "Ä"
        set asciiMap[197] = "Å"
        set asciiMap[198] = "Æ"
        set asciiMap[199] = "Ç"
        set asciiMap[200] = "È"
        set asciiMap[201] = "É"
        set asciiMap[202] = "Ê"
        set asciiMap[203] = "Ë"
        set asciiMap[204] = "Ì"
        set asciiMap[205] = "Í"
        set asciiMap[206] = "Î"
        set asciiMap[207] = "Ï"
        set asciiMap[208] = "Ð"
        set asciiMap[209] = "Ñ"
        set asciiMap[210] = "Ò"
        set asciiMap[211] = "Ó"
        set asciiMap[212] = "Ô"
        set asciiMap[213] = "Õ"
        set asciiMap[214] = "Ö"
        set asciiMap[215] = "×"
        set asciiMap[216] = "Ø"
        set asciiMap[217] = "Ù"
        set asciiMap[218] = "Ú"
        set asciiMap[219] = "Û"
        set asciiMap[220] = "Ü"
        set asciiMap[221] = "Ý"
        set asciiMap[222] = "Þ"
        set asciiMap[223] = "ß"
        set asciiMap[224] = "à"
        set asciiMap[225] = "á"
        set asciiMap[226] = "â"
        set asciiMap[227] = "ã"
        set asciiMap[228] = "ä"
        set asciiMap[229] = "å"
        set asciiMap[230] = "æ"
        set asciiMap[231] = "ç"
        set asciiMap[232] = "è"
        set asciiMap[233] = "é"
        set asciiMap[234] = "ê"
        set asciiMap[235] = "ë"
        set asciiMap[236] = "ì"
        set asciiMap[237] = "í"
        set asciiMap[238] = "î"
        set asciiMap[239] = "ï"
        set asciiMap[240] = "ð"
        set asciiMap[241] = "ñ"
        set asciiMap[242] = "ò"
        set asciiMap[243] = "ó"
        set asciiMap[244] = "ô"
        set asciiMap[245] = "õ"
        set asciiMap[246] = "ö"
        set asciiMap[247] = "÷"
        set asciiMap[248] = "ø"
        set asciiMap[249] = "ù"
        set asciiMap[250] = "ú"
        set asciiMap[251] = "û"
        set asciiMap[252] = "ü"
        set asciiMap[253] = "ý"
        set asciiMap[254] = "þ"
        set asciiMap[255] = "ÿ"
    endif
    return asciiMap[index]
endfunction
    struct Boolean
    static method ToInt takes boolean self returns integer
        if self then
            return 1
        endif
        return 0
    endmethod
    static method ToIntEx takes boolean self returns integer
        if self then
            return 1
        endif
        return -1
    endmethod
    static method Init takes nothing returns nothing
    endmethod
endstruct
    struct Char
    static constant string BREAK = "\n"
    static constant string EXCLAMATION_MARK = "!"
    static constant string MINUS = "-"
    static constant string PERCENT = "%"
    static constant string PLUS = "+"
    static constant string TAB = "\t"
    static constant string QUOTE = "\""
    static method FromAscii takes integer val returns string
        return AsciiToChar(val)
    endmethod
    static method Init takes nothing returns nothing
    endmethod
endstruct
    struct Code
    static hashtable CACHE = InitHashtable()
    static trigger DUMMY_TRIGGER = CreateTrigger()
    static triggeraction DUMMY_TRIGGER_ACTION = null
    static trigger LIST_DUMMY_TRIGGER = CreateTrigger()
    static force DUMMY_FORCE
    static trigger array TO_RUN
    static integer TO_RUN_COUNT = ARRAY_EMPTY
    static integer TO_RUN_ITERATION
    static method GetId takes code self returns integer
        return GetHandleId(Condition(self))
    endmethod
    static method GetName takes code self returns string
        return LoadStr(FUNCS_TABLE, thistype.GetId(self), 0)
    endmethod
    static method GetNameById takes integer id returns string
        return LoadStr(FUNCS_TABLE, id, 0)
    endmethod
    static method ClearRunList takes nothing returns nothing
        call TriggerClearActions(thistype.LIST_DUMMY_TRIGGER)
    endmethod
    static method GetThreadName takes nothing returns string
        if (GetTriggeringTrigger() == null) then
            return I2S(Timer.GetFromSelf(GetExpiredTimer())) + "; native " + I2S(GetHandleId(GetExpiredTimer())) + " (timer)"
        endif
		local Trigger t = Trigger.GetFromSelf(GetTriggeringTrigger())
		if (t == NULL) then
			return "native " + I2S(GetHandleId(GetTriggeringTrigger())) + " (trigger); event: " + I2S(GetHandleId(GetTriggerEventId()))
		endif
        return I2S(t) + "; native " + I2S(GetHandleId(GetTriggeringTrigger())) + " (trigger); event: " + I2S(GetHandleId(GetTriggerEventId()))
    endmethod
	static hashtable DATA
	static trigger TEMP_TRIGGER
    static key GetKeyMacro_SELF_TRIGGER_KEY
    static constant integer SELF_TRIGGER_KEY = Math.Integer.MIN + GetKeyMacro_SELF_TRIGGER_KEY
	static method GetSelfTrigger takes code self returns trigger
        local integer id = thistype.GetId(self)
        local trigger result = LoadTriggerHandle(thistype.DATA, id, SELF_TRIGGER_KEY)
        if (result == null) then
            set result = CreateTrigger()
			call TriggerAddCondition(result, Condition(self))
            call SaveTriggerHandle(thistype.DATA, id, SELF_TRIGGER_KEY, result)
        endif
		set thistype.TEMP_TRIGGER = result
		set result = null
        return thistype.TEMP_TRIGGER
	endmethod
	static method RunBoolExpr_sign takes nothing returns nothing
	endmethod
	static method RunBoolExpr takes boolexpr b returns boolean
		if (b == null) then
			return false
		endif
		local trigger t = CreateTrigger()
		call TriggerAddCondition(t, b)
		call IncStack(Code.GetId(function thistype.RunBoolExpr_sign))
		local boolean result = TriggerEvaluate(t)
		call DecStack()
		call DestroyTrigger(t)
		set t = null
		return result
	endmethod
	static method RunName_sign takes nothing returns nothing
	endmethod
	static method RunName takes string s returns boolean
		call IncStack(Code.GetId(function thistype.RunName_sign))
		call ExecuteFunc(s)
		call DecStack()
		return true
	endmethod
	static method PrintThreadInfo takes nothing returns nothing
		call DebugBufferStart()
		call DebugBuffer("thread info:")
		call DebugBuffer(Char.TAB + thistype.GetThreadName())
		call ObjThread.PrintErrors()
		call DebugBuffer("---thread info")
		call DebugBufferFinish()
	endmethod
    static method AddToRunList takes code self returns nothing
        local trigger dummyTrigger = CreateTrigger()
        set thistype.TO_RUN_COUNT = thistype.TO_RUN_COUNT + 1
        set thistype.TO_RUN[thistype.TO_RUN_COUNT] = dummyTrigger
        call TriggerAddCondition(dummyTrigger, Condition(self))
        set dummyTrigger = null
        
    endmethod
    timerMethod RunList_ByTimer
    	call IncStack(Code.GetId(function thistype.RunList_ByTimer))
        call TriggerEvaluate(thistype.TO_RUN[thistype.TO_RUN_ITERATION])
		call DecStack()
        set thistype.TO_RUN_ITERATION = thistype.TO_RUN_ITERATION + 1
        if (thistype.TO_RUN_ITERATION > thistype.TO_RUN_COUNT) then
            call PauseTimer(GetExpiredTimer())
        endif
    endmethod
    static method RunList takes nothing returns nothing
        set thistype.TO_RUN_ITERATION = ARRAY_MIN
        if (thistype.TO_RUN_COUNT > ARRAY_EMPTY) then
            call TimerStart(CreateTimer(), 0.5, true, function thistype.RunList_ByTimer)
        endif
        
        
    endmethod
    static method Run takes code self returns nothing
        if (thistype.DUMMY_TRIGGER_ACTION != null) then
            call TriggerRemoveAction(thistype.DUMMY_TRIGGER, thistype.DUMMY_TRIGGER_ACTION)
        endif
        set thistype.DUMMY_TRIGGER_ACTION = TriggerAddAction(thistype.DUMMY_TRIGGER, self)
		call IncStack(Code.GetId(self))
        call TriggerExecuteWait(thistype.DUMMY_TRIGGER)
		call DecStack()
    endmethod
    static method Init takes nothing returns nothing
    	set thistype.DATA = InitHashtable()
        set thistype.DUMMY_FORCE = CreateForce()
        
    endmethod
endstruct
    struct Integer
    static method ToBoolean takes integer self returns boolean
        if (self > 0) then
            return true
        endif
        return false
    endmethod
    static method ToAscii takes integer self returns string
        local integer pos = -1
        local string s = ""
        loop
            local integer num = Math.ModI(self, 256)
            set s = Char.FromAscii(num) + s
            set pos = pos + 1
            set self = (self - num) div 256
            exitwhen (self == 0)
        endloop
        return s
    endmethod
    static method ToString takes integer self returns string
        return I2S(self)
    endmethod
    static method Init takes nothing returns nothing
    endmethod
endstruct
    scope FolderReal
    public struct StructEvent
        implement Allocation
        implement List
        
            static real TRIGGER
            static method GetTrigger takes nothing returns real
                return thistype.TRIGGER
            endmethod
            static method SetTrigger takes real self returns nothing
                set thistype.TRIGGER = self
            endmethod
    endstruct
endscope
    struct Real
    static FolderReal_StructEvent Event = NULL
    static method Case takes string whichString, boolean flag returns string
        return StringCase(whichString, flag)
    endmethod
    static method ToInt takes real self returns integer
        return R2I(self)
    endmethod
    static method ToIntString takes real self returns string
        return Integer.ToString(thistype.ToInt(self))
    endmethod
    static method ToPercentString takes real self returns string
        return (Integer.ToString(thistype.ToInt(self)) + Char.PERCENT)
    endmethod
    static method ToString takes real self returns string
        return R2S(self)
    endmethod
    static method ToStringWithDecimals takes real self, integer decimals returns string
        if (self == 0.) then
            return ("0." + String.Repeat("0", decimals))
        endif
        local integer iteration = decimals
        local integer selfI = Real.ToInt(self)
        loop
            exitwhen (iteration < 1)
            set self = self * 10
            set iteration = iteration - 1
        endloop
        local string result = Integer.ToString(Real.ToInt(self))
        set result = (Integer.ToString(selfI) + "." + String.SubRightByWidth(result, decimals))
        return result
    endmethod
    static method Init takes nothing returns nothing
    endmethod
endstruct
    scope FolderString
    public struct StructColor
        implement Allocation
        implement List
        
        static constant string RESET = "|r"
        static constant string START = "|c"
        static constant string BLACK = "ff000000"
        static constant string BONUS = "ff00ff00"
        static constant string DWC = "ff00bfff"
        static constant string GOLD = "ffffcc00"
        static constant string GREEN = "ff00ff00"
        static constant string LIGHT_SEA_GREEN = "ff20b2aa"
        static constant string LUMBER = "ff00c850"
        static constant string MAGENTA = "ffff00ff"
        static constant string MALUS = "ffff0000"
        static constant string RED = "ffff0000"
        static constant string WHITE = "ffffffff"
        static method GetRedPartDec takes string value returns integer
            return Math.Hex.ToDec(SubString(value, 2, 4))
        endmethod
        static method GetGreenPartDec takes string value returns integer
            return Math.Hex.ToDec(SubString(value, 4, 6))
        endmethod
        static method GetBluePartDec takes string value returns integer
            return Math.Hex.ToDec(SubString(value, 6, 8))
        endmethod
        static method GetAlphaPartDec takes string value returns integer
            return Math.Hex.ToDec(SubString(value, 0, 2))
        endmethod
        static method HexToColorHex takes string value returns string
            return (String.If(String.Length(value) == String.MIN_LENGTH, Math.Hex.MAP[0]) + value)
        endmethod
        static method RelativeTo takes real red, real green, real blue, real alpha returns string
            local string result = thistype.HexToColorHex(Math.Hex.FromDec(Real.ToInt(alpha * 255.)))
            set result = result + thistype.HexToColorHex(Math.Hex.FromDec(Real.ToInt(red * 255.)))
            set result = result + thistype.HexToColorHex(Math.Hex.FromDec(Real.ToInt(green * 255.)))
            set result = result + thistype.HexToColorHex(Math.Hex.FromDec(Real.ToInt(blue * 255.)))
            return result
        endmethod
        static method GetFrom255 takes real red, real green, real blue, real alpha returns string
            return thistype.RelativeTo(red / 255., green / 255., blue / 255., alpha / 255.)
        endmethod
        static method Do takes string self, string value returns string
            if (value == null) then
                return self
            endif
            return (thistype.START + value + self + thistype.RESET)
        endmethod
        static method Gradient takes string self, string startValue, string endValue returns string
            local integer length = String.Length(self)
            local integer endRed = thistype.GetRedPartDec(endValue)
            local integer endGreen = thistype.GetGreenPartDec(endValue)
            local integer endBlue = thistype.GetBluePartDec(endValue)
            local integer endAlpha = thistype.GetAlphaPartDec(endValue)
            local integer currentRed = endRed
            local integer currentGreen = endGreen
            local integer currentBlue = endBlue
            local integer currentAlpha = endAlpha
            local integer addRed = (thistype.GetRedPartDec(startValue) - endRed) div length
            local integer addGreen = (thistype.GetGreenPartDec(startValue) - endGreen) div length
            local integer addBlue = (thistype.GetBluePartDec(startValue) - endBlue) div length
            local integer addAlpha = (thistype.GetAlphaPartDec(startValue)- endAlpha) div length
			local integer end = length - String.START - 1
            local integer iteration = end - 1
            local string result = ""
            loop
                exitwhen (iteration < String.START + 1)
                set currentRed = currentRed + addRed
                set currentGreen = currentGreen + addGreen
                set currentBlue = currentBlue + addBlue
                set currentAlpha = currentAlpha + addAlpha
                set result = thistype.Do(String.Sub(self, iteration, iteration), thistype.GetFrom255(currentRed, currentGreen, currentBlue, currentAlpha)) + result
                set iteration = iteration - 1
            endloop
            set result = thistype.Do(String.Sub(self, String.START, String.START), startValue) + result
            set result = result + thistype.Do(String.Sub(self, end, end), endValue)
            return result
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
endscope
    struct String
    static constant integer INVALID_INDEX = -1
    static constant integer MIN_LENGTH = 1
    static constant integer START = 0
    static FolderString_StructColor Color = NULL
    static method Case takes string self, boolean flag returns string
        return StringCase(self, flag)
    endmethod
    static method If takes boolean flag, string self returns string
        if flag then
            return self
        endif
        return ""
    endmethod
    static method IfElse takes boolean flag, string self, string self2 returns string
        if flag then
            return self
        endif
        return self2
    endmethod
    static method Length takes string self returns integer
        return StringLength(self)
    endmethod
    static method LastIndex takes string self returns integer
        return thistype.Length(self) - thistype.MIN_LENGTH
    endmethod
    static method Sub takes string self, integer start, integer end returns string
        local integer endMax = thistype.LastIndex(self)
        if (end > endMax) then
            call DebugEx("String Sub: end above upper limit (" + self + ";" + I2S(start) + ";" + I2S(end) + ")")
            set end = endMax
        endif
        if (start < thistype.START) then
            call DebugEx("String Sub: start below lower limit (" + self + ";" + I2S(start) + ";" + I2S(end) + ")")
            set start = thistype.START
        elseif (start > end) then
            return null
        endif
        return SubString(self, start, end + thistype.MIN_LENGTH)
    endmethod
    static method SubLength takes string self, integer start, integer length returns string
        return thistype.Sub(self, start, start + length - thistype.MIN_LENGTH)
    endmethod
    static method SubLeft takes string self, integer end returns string
        return thistype.Sub(self, thistype.START, end)
    endmethod
    static method SubRight takes string self, integer start returns string
        return thistype.Sub(self, start, thistype.LastIndex(self))
    endmethod
    static method Reconcat takes string self, string insertVal returns string
        local integer lastPos = thistype.INVALID_INDEX
        local integer pos = thistype.LastIndex(self)
        loop
            exitwhen (pos < thistype.START + 1)
            if (thistype.Sub(self, pos - String.Length(String.Color.BLACK) - String.Length(String.Color.START) + 1, pos - String.Length(String.Color.BLACK)) == String.Color.START) then
                set pos = pos - String.Length(String.Color.BLACK) - String.Length(String.Color.START)
            elseif (thistype.Sub(self, pos - String.Length(String.Color.RESET) + 1, pos) == String.Color.RESET) then
                set pos = pos - String.Length(String.Color.RESET)
            else
                if (lastPos != thistype.INVALID_INDEX) then
                    set self = thistype.SubLeft(self, lastPos - 1) + insertVal + thistype.SubRight(self, lastPos)
                endif
                set lastPos = pos
                set pos = pos - 1
            endif
        endloop
        return self
    endmethod
    static method Find takes string self, string value, integer index returns integer
        local integer iteration = thistype.START - 1
        local integer lastPos = thistype.LastIndex(self)
        local integer valueLength = thistype.Length(value)
        loop
            exitwhen (index < 0)
            set iteration = iteration + 1
            loop
                if (iteration + valueLength - 1 > lastPos) then
                    return thistype.INVALID_INDEX
                endif
                exitwhen (thistype.Sub(self, iteration, iteration + valueLength - thistype.MIN_LENGTH) == value)
                set iteration = iteration + 1
            endloop
            set index = index - 1
        endloop
        return iteration
    endmethod
    static method Unfind takes string self, string value, integer index returns integer
        local integer iteration = thistype.START - 1
        local integer lastPos = thistype.LastIndex(self)
        local integer valueLength = thistype.Length(value)
        loop
            exitwhen (index < 0)
            set iteration = iteration + 1
            loop
                if (iteration + valueLength - 1 > lastPos) then
                    return thistype.INVALID_INDEX
                endif
                exitwhen (thistype.Sub(self, iteration, iteration + valueLength - thistype.MIN_LENGTH) != value)
                set iteration = iteration + 1
            endloop
            set index = index - 1
        endloop
        return iteration
    endmethod
    static method Reduce takes string self returns string
        local integer index = thistype.Find(self, thistype.Color.START, 0)
        if (index != thistype.INVALID_INDEX) then
            return thistype.Reduce(thistype.SubLeft(self, index - 1) + thistype.SubRight(self, index + thistype.Length(thistype.Color.START) + 8))
        endif
        set index = thistype.Find(self, thistype.Color.RESET, 0)
        if (index != thistype.INVALID_INDEX) then
            return thistype.Reduce(thistype.SubLeft(self, index - 1) + thistype.SubRight(self, index + thistype.Length(thistype.Color.RESET)))
        endif
        return self
    endmethod
    static method Repeat takes string self, integer amount returns string
        local string result = ""
        loop
            exitwhen (amount < 1)
            set result = result + self
            set amount = amount - 1
        endloop
        return result
    endmethod
    static method SubRightByWidth takes string self, integer width returns string
        local integer lastIndex = thistype.LastIndex(self)
        return thistype.Sub(self, lastIndex - width + 1, lastIndex)
    endmethod
    static method ToBoolean takes string self returns boolean
        if (self == "true") then
            return true
        endif
        return false
    endmethod
    static method ToInt takes string self returns integer
        return S2I(self)
    endmethod
    static method ToIntWithInvalid takes string self, integer inval returns integer
        local integer val = S2I(self)
        if (self == "0") then
            return val
        endif
        if (val == 0) then
            return inval
        endif
        return val
    endmethod
    static method ToIntHash takes string self returns integer
        return StringHash(self)
    endmethod
    static method ToReal takes string self returns real
        return S2R(self)
    endmethod
    static method ToRealWithInvalid takes string self, real inval returns real
        local real val = S2R(self)
        if (val != 0.) then
            return val
        endif
        if ((self == "0") or (self == "0.")) then
            return val
        endif
        set self = thistype.SubRight(self, thistype.START + 1)
        if (thistype.Unfind(self, "0", 0) == thistype.INVALID_INDEX) then
            return val
        endif
        return inval
    endmethod
    static method Word takes string self, integer index returns string
        local integer pos = thistype.Unfind(self, " ", 0)
        if (pos == thistype.INVALID_INDEX) then
            return null
        endif
        set self = thistype.SubRight(self, pos)
        set pos = thistype.Find(self, " ", 0)
        if (index == 0) then
            if (pos == thistype.INVALID_INDEX) then
                return self
            endif
            return thistype.SubLeft(self, pos - 1)
        elseif (pos == thistype.INVALID_INDEX) then
            return null
        endif
		local boolean insideQuotes = false
        set index = index - 1
        loop
            set self = thistype.SubRight(self, pos)
            set pos = thistype.Unfind(self, " ", 0)
            if (pos == thistype.INVALID_INDEX) then
                return null
            endif
            if (thistype.Sub(self, pos, pos) == "\"") then
                set self = thistype.SubRight(self, pos + 1)
                set pos = thistype.Find(self, "\"", 0)
                set insideQuotes = true
            else
                set self = thistype.SubRight(self, pos)
                set pos = thistype.Find(self, " ", 0)
            endif
            if (index == 0) then
                if (pos == thistype.INVALID_INDEX) then
                    return self
                endif
                return thistype.SubLeft(self, pos - 1)
            elseif (pos == thistype.INVALID_INDEX) then
                return null
            endif
            set index = index - 1
            exitwhen (index < 0)
            if insideQuotes then
                set insideQuotes = false
                set pos = pos + 1
            endif
        endloop
        return null
    endmethod
    static method Init takes nothing returns nothing
        call thistype.Color.Init()
    endmethod
endstruct
    struct Primitive
    initMethod Init of Header
        call Boolean.Init()
        call Char.Init()
        call Code.Init()
        call Integer.Init()
        call Real.Init()
        call String.Init()
    endmethod
endstruct
    scope FolderRectangle
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return Rectangle(this).Data.table.IntegerKeys.Table.ContainsInteger(Rectangle(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Rectangle(this).Data.table.IntegerKeys.Table.CountIntegers(Rectangle(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Rectangle(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Rectangle(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Rectangle(this).Data.table.IntegerKeys.Table.GetInteger(Rectangle(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Rectangle(this).Data.table.IntegerKeys.Table.GetFirstInteger(Rectangle(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Rectangle(this).Data.table.IntegerKeys.Table.GetLastInteger(Rectangle(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Rectangle(this).Data.table.IntegerKeys.Table.Clear(Rectangle(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Rectangle(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Rectangle(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Rectangle(this).Data.table.IntegerKeys.Table.RemoveInteger(Rectangle(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Rectangle(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Rectangle(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Rectangle(this).Data.table.IntegerKeys.Table.AddInteger(Rectangle(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Rectangle(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Rectangle(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Rectangle(this).Data.table.IntegerKeys.Table.JoinInteger(Rectangle(this).Id.Get(), key, Rectangle(other).Data.table, Rectangle(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Rectangle(this).Data.table.IntegerKeys.Table.RandomInteger(Rectangle(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Rectangle(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Rectangle(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Rectangle(this).Data.table.IntegerKeys.Table.PrintIntegers(Rectangle(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return Rectangle(this).Data.table.IntegerKeys.GetInteger(Rectangle(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Rectangle(this).Data.table.IntegerKeys.RemoveInteger(Rectangle(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Rectangle(this).Data.table.IntegerKeys.SetInteger(Rectangle(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Rectangle(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Rectangle.Allocation.deallocate_demount.hook
		call Rectangle(this).Data.Destroy()
	endinject
	inject Rectangle.Allocation.allocate_mount.hook
		call Rectangle(this).Data.Event_Create()
	endinject
    endstruct
endscope
    globals
        Rectangle RECTANGLE = STRUCT_BASE
    endglobals
    struct Rectangle
        implement Allocation
        implement List
        
    static thistype TEMP
    static thistype array TEMPS
    static thistype WORLD
    real centerX
    real centerY
    real maxX
    real maxY
    real minX
    real minY
    rect self
    FolderRectangle_StructData Data = this
    FolderRectangle_StructData LinkToStruct_Data
    FolderRectangle_StructId Id = this
    FolderRectangle_StructId LinkToStruct_Id
    method Remove takes nothing returns nothing
        local rect self = this.self
        call this.deallocate()
        call RemoveRect(self)
        set self = null
    endmethod
    method GetCenterX takes nothing returns real
        return this.centerX
    endmethod
    method GetCenterY takes nothing returns real
        return this.centerY
    endmethod
    method GetMaxX takes nothing returns real
        return this.maxX
    endmethod
    method GetMaxY takes nothing returns real
        return this.maxY
    endmethod
    method GetMinX takes nothing returns real
        return this.minX
    endmethod
    method GetMinY takes nothing returns real
        return this.minY
    endmethod
    method GetSelf takes nothing returns rect
        return this.self
    endmethod
    method ContainsCoords takes real x, real y returns boolean
        return not ((x < this.GetMinX()) or (y < this.GetMinY()) or (x > this.GetMaxX()) or (y > this.GetMaxY()))
    endmethod
    method RandomX takes nothing returns real
        return Math.Random(this.GetMinX(), this.GetMaxX())
    endmethod
    method RandomY takes nothing returns real
        return Math.Random(this.GetMinY(), this.GetMaxY())
    endmethod
    method Set takes real minX, real minY, real maxX, real maxY returns nothing
        set this.centerX = (minX + maxX) / 2
        set this.centerY = (minY + maxY) / 2
    	set this.minX = minX
    	set this.maxX = maxX
    	set this.minY = minY
    	set this.maxY = maxY
        call SetRect(this.self, minX, minY, maxX, maxY)
    endmethod
    static method CreateBasic takes real minX, real minY, real maxX, real maxY returns thistype
        local thistype this = thistype.allocate()
        set this.centerX = (minX + maxX) / 2
        set this.centerY = (minY + maxY) / 2
        set this.maxX = maxX
        set this.maxY = maxY
        set this.minX = minX
        set this.minY = minY
        return this
    endmethod
    static method Create takes real minX, real minY, real maxX, real maxY returns thistype
        local thistype this = CreateBasic(minX, minY, maxX, maxY)
        set this.self = Rect(minX, minY, maxX, maxY)
        call this.Id.Event_Create()
        return this
    endmethod
    static method CreateWithSize takes real x, real y, real width, real height returns thistype
        set height = height / 2.
        set width = width / 2.
        return thistype.Create(x - width, y - height, x + width, y + height)
    endmethod
    static method CreateFromSelf takes rect self returns thistype
        local thistype this = CreateBasic(GetRectMinX(self), GetRectMinY(self), GetRectMaxX(self), GetRectMaxY(self))
        set this.self = self
        call this.Id.Event_Create()
        return this
    endmethod
    static method Init takes nothing returns nothing
        set thistype.WORLD = thistype.CreateFromSelf(GetWorldBounds())
    endmethod
endstruct
    scope FolderRegion
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return Region(this).Data.table.IntegerKeys.Table.ContainsInteger(Region(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Region(this).Data.table.IntegerKeys.Table.CountIntegers(Region(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Region(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Region(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Region(this).Data.table.IntegerKeys.Table.GetInteger(Region(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Region(this).Data.table.IntegerKeys.Table.GetFirstInteger(Region(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Region(this).Data.table.IntegerKeys.Table.GetLastInteger(Region(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Region(this).Data.table.IntegerKeys.Table.Clear(Region(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Region(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Region(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Region(this).Data.table.IntegerKeys.Table.RemoveInteger(Region(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Region(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Region(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Region(this).Data.table.IntegerKeys.Table.AddInteger(Region(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Region(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Region(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Region(this).Data.table.IntegerKeys.Table.JoinInteger(Region(this).Id.Get(), key, Region(other).Data.table, Region(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Region(this).Data.table.IntegerKeys.Table.RandomInteger(Region(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Region(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Region(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Region(this).Data.table.IntegerKeys.Table.PrintIntegers(Region(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return Region(this).Data.table.IntegerKeys.GetInteger(Region(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Region(this).Data.table.IntegerKeys.RemoveInteger(Region(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Region(this).Data.table.IntegerKeys.SetInteger(Region(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Region(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Region.Allocation.deallocate_demount.hook
		call Region(this).Data.Destroy()
	endinject
	inject Region.Allocation.allocate_mount.hook
		call Region(this).Data.Event_Create()
	endinject
    endstruct
    scope FolderEvent
    public struct StructNative
        implement Allocation
        implement List
        
                static method GetTrigger takes nothing returns Region
                    return Region.GetFromSelf(GetTriggeringRegion())
                endmethod
        endstruct
    endscope
    public struct StructEvent
        implement Allocation
        implement List
        
    FolderEvent_StructNative Native = this
    FolderEvent_StructNative LinkToStruct_Native
    static Region TRIGGER = NULL
    static method GetTrigger takes nothing returns Region
        return thistype.TRIGGER
    endmethod
    static method SetTrigger takes Region value returns nothing
        set thistype.TRIGGER = value
    endmethod
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(Region(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(Region(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(Region(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(Region(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(Region(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(Region(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(Region(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(Region(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject Region.Allocation.deallocate_demount.hook
			call Region(this).Event.Destroy()
		endinject
		inject Region.Allocation.allocate_mount.hook
			call Region(this).Event.Event_Create()
		endinject
    endstruct
endscope
    globals
        Region REGION = STRUCT_BASE
    endglobals
    struct Region
        implement Allocation
        implement List
        
	static EventType DESTROY_EVENT_TYPE
	static EventType ADD_RECT_EVENT_TYPE
	static Rectangle DUMMY_RECT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static EventType REMOVE_RECT_EVENT_TYPE
    static thistype TEMP
    static thistype array TEMPS
    region self
    FolderRegion_StructData Data = this
    FolderRegion_StructData LinkToStruct_Data
    FolderRegion_StructEvent Event = this
    FolderRegion_StructEvent LinkToStruct_Event
    FolderRegion_StructId Id = this
    FolderRegion_StructId LinkToStruct_Id
    static method GetFromSelf takes region self returns thistype
        return Memory.IntegerKeys.GetIntegerByHandle(self, KEY)
    endmethod
    static method GetTrigger takes nothing returns thistype
        return GetFromSelf(GetTriggeringRegion())
    endmethod
	method ContainsUnit takes Unit whichUnit returns boolean
		return IsUnitInRegion(this.self, whichUnit.self)
	endmethod
    method RemoveRect_TriggerEvents takes Rectangle whichRect
        local EventResponse params = EventResponse.Create(this.Id.Get())
        call params.Region.SetTrigger(this)
        call params.Rect.SetTrigger(whichRect)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = this.Event.Count(thistype.REMOVE_RECT_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.REMOVE_RECT_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    method RemoveRect takes Rectangle whichRect returns nothing
        call RegionClearRect(this.self, whichRect.self)
		call this.RemoveRect_TriggerEvents(whichRect)
    endmethod
	method RemoveCells takes real minX, real minY, real maxX, real maxY
		call thistype.DUMMY_RECT.Set(minX, minY, maxX, maxY)
		call this.RemoveRect(thistype.DUMMY_RECT)
	endmethod
	method Clear
		call this.RemoveRect(Rectangle.WORLD)
	endmethod
    method AddRect_TriggerEvents takes Rectangle whichRect
        local EventResponse params = EventResponse.Create(this.Id.Get())
        call params.Region.SetTrigger(this)
        call params.Rect.SetTrigger(whichRect)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = this.Event.Count(thistype.ADD_RECT_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.ADD_RECT_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    method AddRect takes Rectangle whichRect returns nothing
        call RegionAddRect(this.self, whichRect.self)
		call this.AddRect_TriggerEvents(whichRect)
    endmethod
	method AddCells takes real minX, real minY, real maxX, real maxY
		call thistype.DUMMY_RECT.Set(minX, minY, maxX, maxY)
		call this.AddRect(thistype.DUMMY_RECT)
	endmethod
    method Destroy_TriggerEvents
        local EventResponse params = EventResponse.Create(this.Id.Get())
        call params.Region.SetTrigger(this)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = this.Event.Count(thistype.DESTROY_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.DESTROY_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    method Destroy takes nothing returns nothing
        local region self = this.self
		call this.Destroy_TriggerEvents()
        call RemoveRegion(self)
        set self = null
		call this.deallocate()
    endmethod
    static method Create takes nothing returns thistype
        local thistype this = thistype.allocate()
        set this.self = CreateRegion()
        call Memory.IntegerKeys.SetIntegerByHandle(self, KEY, this)
        call this.Id.Event_Create()
        return this
    endmethod
    static method CreateFromRectangle takes Rectangle whichRect returns thistype
        local thistype this = thistype.Create()
        call this.AddRect(whichRect)
        return this
    endmethod
    initMethod Init of Header_2
        call Rectangle.Init()
		set thistype.DUMMY_RECT = Rectangle.Create(0, 0, 0, 0)
		set thistype.DESTROY_EVENT_TYPE = EventType.Create()
		set thistype.ADD_RECT_EVENT_TYPE = EventType.Create()
		set thistype.REMOVE_RECT_EVENT_TYPE = EventType.Create()
    endmethod
endstruct
    globals
        Music MUSIC = STRUCT_BASE
    endglobals
    struct Music
        implement Allocation
        implement List
        
    static thistype array PLAY_LIST
    static integer PLAY_LIST_COUNT = ARRAY_EMPTY
    integer playListIndex
    integer priority
    string self
    method Play takes nothing returns nothing
        if (this.playListIndex != ARRAY_EMPTY) then
            return
        endif
        local integer priority = this.priority
        local integer iteration = thistype.PLAY_LIST_COUNT
        set thistype.PLAY_LIST_COUNT = iteration + 1
        loop
        	exitwhen (iteration < ARRAY_MIN)
            exitwhen (thistype.PLAY_LIST[iteration].priority < priority)
            set thistype.PLAY_LIST[iteration].playListIndex = iteration + 1
            set thistype.PLAY_LIST[iteration + 1] = thistype.PLAY_LIST[iteration]
            set iteration = iteration - 1
        endloop
        set iteration = iteration + 1
        set thistype.PLAY_LIST[iteration] = this
        set this.playListIndex = iteration
        if (iteration == thistype.PLAY_LIST_COUNT) then
            call PlayMusic(this.self)
        endif
    endmethod
    method Stop takes nothing returns nothing
        local integer iteration = this.playListIndex
        if (iteration == ARRAY_EMPTY) then
            return
        endif
        set this.playListIndex = ARRAY_EMPTY
        local boolean wasCurrent = (iteration == thistype.PLAY_LIST_COUNT)
        set thistype.PLAY_LIST_COUNT = thistype.PLAY_LIST_COUNT - 1
        loop
            exitwhen (iteration > thistype.PLAY_LIST_COUNT)
            set thistype.PLAY_LIST[iteration] = thistype.PLAY_LIST[iteration + 1]
            set thistype.PLAY_LIST[iteration + 1].playListIndex = iteration
            set iteration = iteration + 1
        endloop
        if wasCurrent then
            if (thistype.PLAY_LIST_COUNT > ARRAY_EMPTY) then
                call StopMusic(false)
                call PlayMusic(thistype.PLAY_LIST[thistype.PLAY_LIST_COUNT].self)
            else
                call StopMusic(true)
            endif
        endif
    endmethod
    static method SetVolume takes real value returns nothing
        call SetMusicVolume(Real.ToInt(value * 127.))
    endmethod
    static method Create takes string self, integer priority returns thistype
        local thistype this = thistype.allocate()
        set this.playListIndex = ARRAY_EMPTY
        set this.priority = priority
        set this.self = self
        return this
    endmethod
    static method Init takes nothing returns nothing
    endmethod
endstruct
    globals
        SoundChannel SOUND_CHANNEL = STRUCT_BASE
    endglobals
    struct SoundChannel
        implement Allocation
        implement List
        
    static real OVERALL_VOLUME = 1.
    static constant integer AMBIENT_LOOP = 10
    static constant integer ANIMATION = 11
    static constant integer BIRTH = 13
    static constant integer COMBAT = 5
    static constant integer CONSTRUCTION = 12
    static constant integer ERROR = 6
    static constant integer FIRE = 14
    static constant integer GENERAL = 0
    static constant integer MOVE_LOOP = 9
    static constant integer MUSIC = 7
    static constant integer UI = 8
    static constant integer UNIT_ACK = 2
    static constant integer UNIT_MOVE = 3
    static constant integer UNIT_READY = 4
    static constant integer UNIT_SELECT = 1
    real volume
    volumegroup whichVolumeGroup
    method GetVolume takes nothing returns real
        return this.volume
    endmethod
    method SetVolume takes real value returns nothing
        set this.volume = value
        call VolumeGroupSetVolume(this.whichVolumeGroup, value)
    endmethod
    static method SetVolumeOverall takes real value returns nothing
        local integer iteration = thistype.ALL_COUNT
        set thistype.OVERALL_VOLUME = value
        loop
            exitwhen (iteration < ARRAY_MIN)
            call VolumeGroupSetVolume(thistype.ALL[iteration].whichVolumeGroup, value)
            set iteration = iteration - 1
        endloop
    endmethod
    static method Create takes thistype this, volumegroup whichVolumeGroup returns thistype
        set this.whichVolumeGroup = whichVolumeGroup
        call this.SetVolume(1.)
        call this.AddToList()
        return this
    endmethod
    static method Init takes nothing returns nothing
        call thistype.Create(thistype.AMBIENT_LOOP, SOUND_VOLUMEGROUP_AMBIENTSOUNDS)
        call thistype.Create(thistype.ANIMATION, null)
        call thistype.Create(thistype.BIRTH, null)
        call thistype.Create(thistype.COMBAT, SOUND_VOLUMEGROUP_COMBAT)
        call thistype.Create(thistype.CONSTRUCTION, null)
        call thistype.Create(thistype.ERROR, SOUND_VOLUMEGROUP_UI)
        call thistype.Create(thistype.FIRE, SOUND_VOLUMEGROUP_FIRE)
        call thistype.Create(thistype.GENERAL, null)
        call thistype.Create(thistype.MOVE_LOOP, SOUND_VOLUMEGROUP_UNITMOVEMENT)
        
        call thistype.Create(thistype.UI, SOUND_VOLUMEGROUP_UI)
        call thistype.Create(thistype.UNIT_ACK, SOUND_VOLUMEGROUP_UNITSOUNDS)
        call thistype.Create(thistype.UNIT_MOVE, SOUND_VOLUMEGROUP_UNITSOUNDS)
        call thistype.Create(thistype.UNIT_READY, SOUND_VOLUMEGROUP_UNITSOUNDS)
        call thistype.Create(thistype.UNIT_SELECT, SOUND_VOLUMEGROUP_UNITSOUNDS)
    endmethod
endstruct
    globals
        SoundEax SOUND_EAX = STRUCT_BASE
    endglobals
    struct SoundEax
        implement Allocation
        implement List
        
    static thistype COMBAT
    static thistype DEFAULT
    static thistype DOODAD
    static thistype HERO_ACKS
    static thistype KOTO_DRUMS
    static thistype MISSILE
    static thistype SPELL
    string self
    method GetSelf takes nothing returns string
        return this.self
    endmethod
    method SetSelf takes string value returns nothing
        set this.self = value
    endmethod
    
    static method Create takes string self returns thistype
    	local thistype this = thistype.allocate()
    	
    	call this.SetSelf(self)
    	
    	return this
    endmethod
    
    static method Init takes nothing returns nothing
    	set thistype.COMBAT = thistype.Create("CombatSoundsEAX")
    	set thistype.DEFAULT = thistype.Create("DefaultEAXON")
    	set thistype.DOODAD = thistype.Create("DoodadsEAX")
    	set thistype.HERO_ACKS = thistype.Create("HeroAcksEAX")
    	set thistype.KOTO_DRUMS = thistype.Create("KotoDrumsEAX")
    	set thistype.MISSILE = thistype.Create("MissilesEAX")
    	set thistype.SPELL = thistype.Create("SpellsEAX")
    endmethod
endstruct
    globals
        SoundType SOUND_TYPE = STRUCT_BASE
    endglobals
    struct SoundType
        implement Allocation
        implement List
        
    string filePath
    method GetFilePath takes nothing returns string
        return this.filePath
    endmethod
    method SetFilePath takes string value returns nothing
        set this.filePath = value
    endmethod
	
    SoundChannel channel
    method GetChannel takes nothing returns SoundChannel
        return this.channel
    endmethod
    method SetChannel takes SoundChannel value returns nothing
        set this.channel = value
    endmethod
    SoundEax eax
    method GetEax takes nothing returns SoundEax
        return this.eax
    endmethod
    method SetEax takes SoundEax value returns nothing
        set this.eax = value
    endmethod
    real pitch
    method GetPitch takes nothing returns real
        return this.pitch
    endmethod
    method SetPitch takes real value returns nothing
        set this.pitch = value
    endmethod
    real pitchVariance
    method GetPitchVariance takes nothing returns real
        return this.pitchVariance
    endmethod
    method SetPitchVariance takes real value returns nothing
        set this.pitchVariance = value
    endmethod
    integer priority
    method GetPriority takes nothing returns integer
        return this.priority
    endmethod
    method SetPriority takes integer value returns nothing
        set this.priority = value
    endmethod
    real volume
    method GetVolume takes nothing returns real
        return this.volume
    endmethod
    method SetVolume takes real value returns nothing
        set this.volume = value
    endmethod
	
    real fadeIn
    method GetFadeIn takes nothing returns real
        return this.fadeIn
    endmethod
    method SetFadeIn takes real value returns nothing
        set this.fadeIn = value
    endmethod
    real fadeOut
    method GetFadeOut takes nothing returns real
        return this.fadeOut
    endmethod
    method SetFadeOut takes real value returns nothing
        set this.fadeOut = value
    endmethod
    boolean looping
    method IsLooping takes nothing returns boolean
        return this.looping
    endmethod
    method SetLooping takes boolean value returns nothing
        set this.looping = value
    endmethod
    boolean stopping
    method IsStopping takes nothing returns boolean
        return this.stopping
    endmethod
    method SetStopping takes boolean value returns nothing
        set this.stopping = value
    endmethod
	
    boolean is3d
    method Is3D takes nothing returns boolean
        return this.is3d
    endmethod
    method Set3D takes boolean value returns nothing
        set this.is3d = value
    endmethod
    real minDist
    method GetMinDist takes nothing returns real
        return this.minDist
    endmethod
    method SetMinDist takes real value returns nothing
        set this.minDist = value
    endmethod
    real maxDist
    method GetMaxDist takes nothing returns real
        return this.maxDist
    endmethod
    method SetMaxDist takes real value returns nothing
        set this.maxDist = value
    endmethod
    real cutoffDist
    method GetCutoffDist takes nothing returns real
        return this.cutoffDist
    endmethod
    method SetCutoffDist takes real value returns nothing
        set this.cutoffDist = value
    endmethod
	
    real insideAngle
    method GetInsideAngle takes nothing returns real
        return this.insideAngle
    endmethod
    method SetInsideAngle takes real value returns nothing
        set this.insideAngle = value
    endmethod
    real outsideAngle
    method GetOutsideAngle takes nothing returns real
        return this.outsideAngle
    endmethod
    method SetOutsideAngle takes real value returns nothing
        set this.outsideAngle = value
    endmethod
    real outsideVolume
    method GetOutsideVolume takes nothing returns real
        return this.outsideVolume
    endmethod
    method SetOutsideVolume takes real value returns nothing
        set this.outsideVolume = value
    endmethod
    real orientationX
    method GetOrientationX takes nothing returns real
        return this.orientationX
    endmethod
    method SetOrientationX takes real value returns nothing
        set this.orientationX = value
    endmethod
    real orientationY
    method GetOrientationY takes nothing returns real
        return this.orientationY
    endmethod
    method SetOrientationY takes real value returns nothing
        set this.orientationY = value
    endmethod
    real orientationZ
    method GetOrientationZ takes nothing returns real
        return this.orientationZ
    endmethod
    method SetOrientationZ takes real value returns nothing
        set this.orientationZ = value
    endmethod
    static key GetKeyMacro_INIT_KEY_ARRAY
    static constant integer INIT_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_INIT_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static method AddInit takes code c, string name returns nothing
        call Trigger.AddObjectInit(INIT_KEY_ARRAY, c, name)
    endmethod
	static method Create takes nothing returns thistype
		local thistype this = thistype.allocate()
		
		call this.SetFilePath(null)
		
		call this.SetChannel(SoundChannel.GENERAL)
		call this.SetEax(SoundEax.DEFAULT)
		call this.SetPitch(1.)
		call this.SetPitchVariance(1.)
		call this.SetPriority(1)
		call this.SetVolume(127.)
		
		call this.SetFadeIn(10.)
		call this.SetFadeOut(10.)
		
		call this.SetLooping(false)
		call this.SetStopping(false)
		
		call this.Set3D(false)
		call this.SetMinDist(0.)
		call this.SetMaxDist(0.)
		call this.SetCutoffDist(0.)
		
		call this.SetInsideAngle(0.)
		call this.SetOutsideAngle(0.)
		call this.SetOutsideVolume(0.)
		call this.SetOrientationX(0.)
		call this.SetOrientationY(0.)
		call this.SetOrientationZ(0.)
		
		return this
	endmethod
endstruct
    globals
        Sound SOUND = STRUCT_BASE
    endglobals
    struct Sound
        implement Allocation
        implement List
        
    static thistype ERROR
    sound self
    Timer stopEx_delayTimer
    boolean stopEx_destroyAfter
    boolean stopEx_fadeOut
    string filePath
    method GetFilePath takes nothing returns string
        return this.filePath
    endmethod
    method SetFilePath takes string value returns nothing
        set this.filePath = value
    endmethod
	
    SoundChannel channel
    method GetChannel2 takes nothing returns SoundChannel
        return this.channel
    endmethod
    method SetChannel2 takes SoundChannel value returns nothing
        set this.channel = value
    endmethod
    SoundEax eax
    method GetEax takes nothing returns SoundEax
        return this.eax
    endmethod
    method SetEax takes SoundEax value returns nothing
        set this.eax = value
    endmethod
    real pitch
    method GetPitch takes nothing returns real
        return this.pitch
    endmethod
    method SetPitch takes real value returns nothing
        set this.pitch = value
    endmethod
    real pitchVariance
    method GetPitchVariance takes nothing returns real
        return this.pitchVariance
    endmethod
    method SetPitchVariance takes real value returns nothing
        set this.pitchVariance = value
    endmethod
    integer priority
    method GetPriority takes nothing returns integer
        return this.priority
    endmethod
    method SetPriority takes integer value returns nothing
        set this.priority = value
    endmethod
    real volume
    method GetVolume takes nothing returns real
        return this.volume
    endmethod
    method SetVolume takes real value returns nothing
        set this.volume = value
    endmethod
	
    real fadeIn
    method GetFadeIn takes nothing returns real
        return this.fadeIn
    endmethod
    method SetFadeIn takes real value returns nothing
        set this.fadeIn = value
    endmethod
    real fadeOut
    method GetFadeOut takes nothing returns real
        return this.fadeOut
    endmethod
    method SetFadeOut takes real value returns nothing
        set this.fadeOut = value
    endmethod
    boolean looping
    method IsLooping takes nothing returns boolean
        return this.looping
    endmethod
    method SetLooping takes boolean value returns nothing
        set this.looping = value
    endmethod
    boolean stopping
    method IsStopping takes nothing returns boolean
        return this.stopping
    endmethod
    method SetStopping takes boolean value returns nothing
        set this.stopping = value
    endmethod
	
    boolean is3d
    method Is3D takes nothing returns boolean
        return this.is3d
    endmethod
    method Set3D takes boolean value returns nothing
        set this.is3d = value
    endmethod
    real minDist
    method GetMinDist takes nothing returns real
        return this.minDist
    endmethod
    method SetMinDist takes real value returns nothing
        set this.minDist = value
    endmethod
    real maxDist
    method GetMaxDist takes nothing returns real
        return this.maxDist
    endmethod
    method SetMaxDist takes real value returns nothing
        set this.maxDist = value
    endmethod
    real cutoffDist
    method GetCutoffDist takes nothing returns real
        return this.cutoffDist
    endmethod
    method SetCutoffDist takes real value returns nothing
        set this.cutoffDist = value
    endmethod
	
    real insideAngle
    method GetInsideAngle takes nothing returns real
        return this.insideAngle
    endmethod
    method SetInsideAngle takes real value returns nothing
        set this.insideAngle = value
    endmethod
    real outsideAngle
    method GetOutsideAngle takes nothing returns real
        return this.outsideAngle
    endmethod
    method SetOutsideAngle takes real value returns nothing
        set this.outsideAngle = value
    endmethod
    real outsideVolume
    method GetOutsideVolume takes nothing returns real
        return this.outsideVolume
    endmethod
    method SetOutsideVolume takes real value returns nothing
        set this.outsideVolume = value
    endmethod
    real orientationX
    method GetOrientationX takes nothing returns real
        return this.orientationX
    endmethod
    method SetOrientationX takes real value returns nothing
        set this.orientationX = value
    endmethod
    real orientationY
    method GetOrientationY takes nothing returns real
        return this.orientationY
    endmethod
    method SetOrientationY takes real value returns nothing
        set this.orientationY = value
    endmethod
    real orientationZ
    method GetOrientationZ takes nothing returns real
        return this.orientationZ
    endmethod
    method SetOrientationZ takes real value returns nothing
        set this.orientationZ = value
    endmethod
    Unit targetUnit
    method GetTargetUnit takes nothing returns Unit
        return this.targetUnit
    endmethod
    method SetTargetUnit takes Unit value returns nothing
        set this.targetUnit = value
    endmethod
	//! inject Allocation.allocate_mount.hook
		set this.targetUnit = NULL
	//! endinject
    real x
    method GetX takes nothing returns real
        return this.x
    endmethod
    method SetX takes real value returns nothing
        set this.x = value
    endmethod
	//! inject Allocation.allocate_mount.hook
		set this.x = 0
	//! endinject
    real y
    method GetY takes nothing returns real
        return this.y
    endmethod
    method SetY takes real value returns nothing
        set this.y = value
    endmethod
	//! inject Allocation.allocate_mount.hook
		set this.y = 0
	//! endinject
    real z
    method GetZ takes nothing returns real
        return this.z
    endmethod
    method SetZ takes real value returns nothing
        set this.z = value
    endmethod
	//! inject Allocation.allocate_mount.hook
		set this.z = 0
	//! endinject
	method GetXEx returns real
		if (this.GetTargetUnit() != NULL) then
			return this.GetTargetUnit().Position.X.Get()
		endif
		return this.GetX()
	endmethod
	method GetYEx returns real
		if (this.GetTargetUnit() != NULL) then
			return this.GetTargetUnit().Position.Y.Get()
		endif
		return this.GetY()
	endmethod
	method GetZEx returns real
		if (this.GetTargetUnit() != NULL) then
			return this.GetTargetUnit().Position.Z.Get()
		endif
		return this.GetZ()
	endmethod
    static method StopEx_Delay takes nothing returns nothing
        local Timer delayTimer = Timer.GetExpired()
        local thistype this = delayTimer.GetData()
        set this.stopEx_delayTimer = NULL
        call StopSound(this.self, this.stopEx_destroyAfter, this.stopEx_fadeOut)
        call this.subRef()
    endmethod
    method StopEx takes boolean destroyAfter, boolean fadeOut returns nothing
        local Timer delayTimer = this.stopEx_delayTimer
        if (delayTimer == NULL) then
            set delayTimer = Timer.Create()
            call delayTimer.SetData(this)
            call this.addRef()
        endif
        set this.stopEx_delayTimer = delayTimer
        set this.stopEx_destroyAfter = destroyAfter
        set this.stopEx_fadeOut = fadeOut
        call delayTimer.Start(0.07, false, function thistype.StopEx_Delay)
    endmethod
    destroyMethod Destroy takes boolean waitForPlayed
        local sound self = this.self
        if waitForPlayed then
            call this.StopEx(true, true)
        else
            if this.IsLooping() then
                call this.StopEx(true, waitForPlayed)
            else
                call KillSoundWhenDone(self)
            endif
        endif
        set self = null
    endmethod
    method LimitToPlayer takes User whichPlayer returns nothing
        if whichPlayer.IsLocal() then
            call SetSoundVolume(this.self, 0)
        endif
    endmethod
    method Play takes nothing returns nothing
        call SetSoundVolume(this.self, Real.ToInt(this.volume * this.GetChannel2().GetVolume() * SoundChannel.OVERALL_VOLUME * 127.))
        call StartSound(this.self)
		if this.Is3D() then
			local TextTag t = TEXT_TAG.CreateRising.Create(this.GetFilePath(), 0.02 * this.GetVolume(), this.GetXEx(), this.GetYEx(), this.GetZEx(), 300, 0, 2, TextTag.GetFreeId())
			call t.Color.SetRandomRGB()
			call t.Position.SetCentered()
		endif
    endmethod
    method PlayForPlayer takes User whichPlayer returns nothing
        if whichPlayer.IsLocal() then
            call this.Play()
        endif
    endmethod
    method SetChannel takes SoundChannel val returns nothing
    	call this.SetChannel2(val)
    	if (this.self != null) then
        	call SetSoundChannel(this.self, val)
        endif
    endmethod
    method SetPosition takes real x, real y, real z returns nothing
    	call this.SetTargetUnit(NULL)
    	call this.SetX(x)
    	call this.SetY(y)
    	call this.SetZ(z)
        call SetSoundPosition(this.self, x, y, z)
    endmethod
    method SetPositionAndPlay takes real x, real y, real z returns nothing
        call this.SetPosition(x, y, z)
        call this.Play()
    endmethod
	method AttachToUnitAndPlay takes Unit target returns nothing
		call this.SetTargetUnit(target)
    	call this.SetX(target.Position.X.Get())
    	call this.SetY(target.Position.Y.Get())
    	call this.SetZ(target.Position.Z.Get())
		call AttachSoundToUnit(this.self, target.self)
		
		call this.Play()
	endmethod
    method Stop takes boolean fadeOut returns nothing
        call this.StopEx(false, fadeOut)
    endmethod
    static method Create takes string filePath, boolean looping, boolean is3d, boolean stop, real fadeIn, real fadeOut, SoundEax eax returns thistype
        local thistype this = thistype.allocate()
        
        set this.stopEx_delayTimer = NULL
		
		call this.SetFilePath(filePath)
		
		call this.SetChannel(SoundChannel.GENERAL)
		call this.SetEax(eax)
		call this.SetVolume(1.)
		call this.SetFadeIn(fadeIn)
		call this.SetFadeOut(fadeOut)
        call this.SetLooping(looping)
        call this.SetStopping(stop)
		call this.Set3D(is3d)        
		call this.Recreate()
        return this
    endmethod
	method Recreate takes nothing returns nothing
		local string eax = this.GetEax().GetSelf()
		
		if (eax == null) then
			set eax = ""
		endif
		set this.self = CreateSound(this.GetFilePath(), this.IsLooping(), this.Is3D(), this.IsStopping(), Real.ToInt(this.GetFadeIn()), Real.ToInt(this.GetFadeOut()), eax)
	endmethod
	static method CreateFromType takes SoundType whichType returns thistype
        local thistype this = thistype.allocate()
		set this.stopEx_delayTimer = NULL
		call this.SetFilePath(whichType.GetFilePath())
        call this.SetChannel(whichType.GetChannel())
        call this.SetEax(whichType.GetEax())
        call this.SetPitch(whichType.GetPitch())
        call this.SetPitchVariance(whichType.GetPitchVariance())
        call this.SetPriority(whichType.GetPriority())
        call this.SetVolume(whichType.GetVolume())
        
        call this.SetFadeIn(whichType.GetFadeIn())
        call this.SetFadeOut(whichType.GetFadeOut())
        call this.SetLooping(whichType.IsLooping())
        call this.SetStopping(whichType.IsStopping())
        
        call this.Set3D(whichType.Is3D())
        call this.SetMinDist(whichType.GetMinDist())
        call this.SetMaxDist(whichType.GetMaxDist())
        call this.SetCutoffDist(whichType.GetCutoffDist())
        
        call this.SetInsideAngle(whichType.GetInsideAngle())
		call this.SetOutsideAngle(whichType.GetOutsideAngle())
		call this.SetOutsideVolume(whichType.GetOutsideVolume())
		call this.SetOrientationX(whichType.GetOrientationX())
		call this.SetOrientationY(whichType.GetOrientationY())
		call this.SetOrientationZ(whichType.GetOrientationZ())
		call this.Recreate()
        return this
	endmethod
    initMethod Init of Header_2
    	call SoundEax.Init()
        call SoundChannel.Init()
        set thistype.ERROR = thistype.Create("Sound\\Interface\\Error.wav", false, false, false, 10, 10, NULL)
        call thistype.ERROR.SetChannel(SoundChannel.UI)
        call Music.Init()
    endmethod
endstruct
    globals
        UnitSound UNIT_SOUND = STRUCT_BASE
    endglobals
    struct UnitSound
        implement Allocation
        implement List
        
	Sound thisSound
	method Destroy takes nothing returns nothing
		call this.thisSound.Destroy(true)
		call this.deallocate()
	endmethod
	static method Create takes Unit whichUnit, SoundType whichSoundType returns thistype
		local thistype this = thistype.allocate()
		local Sound thisSound = Sound.CreateFromType(whichSoundType)
		set this.thisSound = thisSound
		call thisSound.AttachToUnitAndPlay(whichUnit)
		return this
	endmethod
endstruct
    globals
        HeroSpell HERO_SPELL = STRUCT_BASE
    endglobals
    struct HeroSpell
        implement Allocation
        implement List
        
    static key GetKeyMacro_BASE_SPELL_KEY
    static constant integer BASE_SPELL_KEY = Math.Integer.MIN + GetKeyMacro_BASE_SPELL_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    static Event LEARN_EVENT
    static Trigger LEARNER_TRIGGER
    static Event LEVEL_CHANGE_EVENT
    static Event SPELL_REMOVE_EVENT
    integer hidePlaceholderId
    method GetHidePlaceholderId takes nothing returns integer
        return this.hidePlaceholderId
    endmethod
    method SetHidePlaceholderId takes integer value returns nothing
        set this.hidePlaceholderId = value
    endmethod
    integer hideReplacerId
    method GetHideReplacerId takes nothing returns integer
        return this.hideReplacerId
    endmethod
    method SetHideReplacerId takes integer value returns nothing
        set this.hideReplacerId = value
    endmethod
    integer learnerSpellBaseId
    method GetLearnerSpellBaseId takes nothing returns integer
        return this.learnerSpellBaseId
    endmethod
    method SetLearnerSpellBaseId takes integer value returns nothing
        set this.learnerSpellBaseId = value
    endmethod
    integer replacerBaseId
    method GetReplacerBaseId takes nothing returns integer
        return this.replacerBaseId
    endmethod
    method SetReplacerBaseId takes integer value returns nothing
        set this.replacerBaseId = value
    endmethod
    static method GetFromUnit takes Unit whichUnit, SpellClass whichClass returns Spell
        return whichUnit.Data.Integer.Get(KEY_ARRAY_DETAIL + whichClass)
    endmethod
    static method GetLearnerSpellId takes Spell whichSpell, integer level returns integer
        return (whichSpell.GetClass().GetLearnPrefix() + thistype(whichSpell).GetLearnerSpellBaseId() + level)
    endmethod
    static method GetReplacerId takes Spell whichSpell returns integer
        return (thistype(whichSpell).GetReplacerBaseId() + whichSpell.GetClass().GetLearnPositionIndex())
    endmethod
    static method AdjustReplacer takes integer level, Spell whichSpell, Unit whichUnit returns nothing
        local integer prevLevel = whichUnit.Abilities.GetLevelBySelf(thistype.GetReplacerId(whichSpell)) - 1
        local integer prevLearner = thistype.GetLearnerSpellId(whichSpell, prevLevel)
        call whichUnit.Abilities.RemoveBySelf(thistype.GetReplacerId(whichSpell))
        call whichUnit.Abilities.SetLevelBySelf(prevLearner, 0)
        call whichUnit.Abilities.SetLevelBySelf(thistype.SLOT_ID + whichSpell.GetClass().GetLearnPositionIndex(), level)
        if (level < whichSpell.GetLevelsAmount()) then
            call whichUnit.Abilities.SetLevelBySelf(thistype.GetReplacerId(whichSpell), level + 1)
        else
            call whichUnit.Abilities.RemoveBySelf(thistype.GetReplacerId(whichSpell))
        endif
    endmethod
    eventMethod Event_LevelChange
        local integer level = params.Spell.GetLevel()
        local Spell whichSpell = params.Spell.GetTrigger()
        local Unit whichUnit = params.Unit.GetTrigger()
        call thistype.AdjustReplacer(level, whichSpell, whichUnit)
    endmethod
    eventMethod Event_SpellRemove
        local Spell whichSpell = params.Spell.GetTrigger()
        local Unit whichUnit = params.Unit.GetTrigger()
        call thistype.AdjustReplacer(0, whichSpell, whichUnit)
    endmethod
    eventMethod Event_Learn
        local integer level = params.Spell.GetLevel()
        local Spell whichSpell = params.Spell.GetTrigger()
        local Unit whichUnit = params.Unit.GetTrigger()
        call thistype.AdjustReplacer(level, whichSpell, whichUnit)
    endmethod
    trigMethod LearnerTrig
        local integer learnerId = GetLearnedSkill()
        local integer level = GetLearnedSkillLevel()
        local Unit whichUnit = UNIT.Event.Native.GetTrigger()
        local Spell whichSpell = Memory.IntegerKeys.GetInteger(learnerId, BASE_SPELL_KEY)
        call whichUnit.Abilities.SetLevel(whichSpell, level)
    endmethod
    static method RemoveFromUnit takes Spell whichSpell, Unit whichUnit returns nothing
        call whichUnit.Data.Integer.Table.Remove(KEY_ARRAY, whichSpell)
        call whichUnit.Data.Integer.Remove(KEY_ARRAY_DETAIL + whichSpell.GetClass())
        call whichUnit.Abilities.RemoveBySelf(thistype.GetReplacerId(whichSpell))
        call whichUnit.Abilities.Remove(whichSpell)
        call whichUnit.Abilities.AddBySelf(thistype(whichSpell).GetHideReplacerId())
    endmethod
    static method ClearAtUnit takes Unit whichUnit returns nothing
        local integer iteration = whichUnit.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            local Spell whichSpell = whichUnit.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            call thistype.RemoveFromUnit(whichSpell, whichUnit)
            set iteration = iteration - 1
        endloop
    endmethod
    static method AddToUnit takes Spell whichSpell, Unit whichUnit returns nothing
        local SpellClass whichClass = whichSpell.GetClass()
        local Spell oldSpell = thistype.GetFromUnit(whichUnit, whichClass)
        local integer level = whichUnit.Abilities.GetLevel(oldSpell)
        if (oldSpell != NULL) then
            call thistype.RemoveFromUnit(oldSpell, whichUnit)
        endif
        call whichUnit.Data.Integer.Table.Add(KEY_ARRAY, whichSpell)
        call whichUnit.Data.Integer.Set(KEY_ARRAY_DETAIL + whichClass, whichSpell)
        call whichUnit.Abilities.RemoveBySelf(thistype(whichSpell).GetHideReplacerId())
        call whichUnit.Abilities.SetLevel(whichSpell, level)
        if (level < whichSpell.GetLevelsAmount()) then
            call whichUnit.Abilities.SetLevelBySelf(thistype.GetReplacerId(whichSpell), level + 1)
        endif
    endmethod
    static method ReplaceSlot takes SpellClass whichClass, Spell newSpell, Unit whichUnit returns nothing
        if (thistype.GetFromUnit(whichUnit, whichClass) != NULL) then
            call thistype.AddToUnit(newSpell, whichUnit)
        endif
    endmethod
    static method InitSpell takes Spell whichSpell, integer learnerSpellId, integer levelsAmount, integer replacerId, integer hidePlaceholderId, integer hideReplacerId returns nothing
        local SpellClass whichClass = whichSpell.GetClass()
        local integer abilityId = (replacerId + whichClass.GetLearnPositionIndex())
        local integer learnerPrefix = whichClass.GetLearnPrefix()
        local integer level = (levelsAmount - 1)
        
        call InitAbility(hidePlaceholderId, false)
        call InitAbility(hideReplacerId, false)
        call User.ANY.EnableAbilityBySelf(abilityId, false)
        call User.ANY.EnableAbilityBySelf(hidePlaceholderId, false)
        call User.ANY.EnableAbilityBySelf(hideReplacerId, false)
        call thistype(whichSpell).SetHidePlaceholderId(hidePlaceholderId)
        call thistype(whichSpell).SetHideReplacerId(hideReplacerId)
        call thistype(whichSpell).SetLearnerSpellBaseId(learnerSpellId)
        call thistype(whichSpell).SetReplacerBaseId(replacerId)
        call whichSpell.Event.Add(thistype.LEARN_EVENT)
        call whichSpell.Event.Add(thistype.LEVEL_CHANGE_EVENT)
        call whichSpell.Event.Add(thistype.SPELL_REMOVE_EVENT)
        loop
            exitwhen (level < 0)
            set abilityId = (learnerPrefix + learnerSpellId + level)
            call Memory.IntegerKeys.SetInteger(abilityId, BASE_SPELL_KEY, whichSpell)
            call InitAbility(abilityId, false)
            set level = level - 1
        endloop
    endmethod
    static method Init takes nothing returns nothing
        local integer iteration = thistype.MAX_SLOTS - 1
        set thistype.LEARN_EVENT = Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Learn)
        set thistype.LEVEL_CHANGE_EVENT = Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_LevelChange)
        set thistype.SPELL_REMOVE_EVENT = Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_SpellRemove)
        loop
            exitwhen (iteration < ARRAY_MIN)
            call User.ANY.EnableAbilityBySelf(thistype.SLOT_ID + iteration, false)
            set iteration = iteration - 1
        endloop
        set thistype.LEARNER_TRIGGER = Trigger.CreateFromCode(function thistype.LearnerTrig)
        call thistype.LEARNER_TRIGGER.RegisterEvent.PlayerUnit(User.ANY, EVENT_PLAYER_HERO_SKILL, null)
    endmethod
endstruct
    globals
        SpellClass SPELL_CLASS = STRUCT_BASE
    endglobals
    struct SpellClass
        implement Allocation
        implement List
        
    static constant integer LEARN_PREFIX_BASE = 'F000'
    static thistype HERO_FIRST
    static thistype HERO_SECOND
    static thistype ARTIFACT
    static thistype ELEMENTAL
    static thistype HERO_ULTIMATE
    static thistype HERO_ULTIMATE_EX
    static thistype ITEM
    static thistype NORMAL
    boolean hero
    method IsHero takes nothing returns boolean
        return this.hero
    endmethod
    method SetHero takes boolean value returns nothing
        set this.hero = value
    endmethod
    integer learnPositionIndex
    method GetLearnPositionIndex takes nothing returns integer
        return this.learnPositionIndex
    endmethod
    method SetLearnPositionIndex takes integer value returns nothing
        set this.learnPositionIndex = value
    endmethod
    integer learnPrefix
    method GetLearnPrefix takes nothing returns integer
        return this.learnPrefix
    endmethod
    method SetLearnPrefix takes integer value returns nothing
        set this.learnPrefix = value
    endmethod
    static method Create takes boolean isHero, integer learnPositionIndex, integer learnPrefix returns thistype
        local thistype this = thistype.allocate()
        if (learnPrefix != 0) then
            set learnPrefix = learnPrefix - thistype.LEARN_PREFIX_BASE
        endif
        call this.SetLearnPositionIndex(learnPositionIndex)
        call this.SetLearnPrefix(learnPrefix)
        call this.SetHero(isHero)
        return this
    endmethod
    static method Init takes nothing returns nothing
        set thistype.HERO_FIRST = thistype.Create(true, 0, 'F000')
        set thistype.HERO_SECOND = thistype.Create(true, 1, 'G000')
        set thistype.ARTIFACT = thistype.Create(false, 0, 0)
        set thistype.ELEMENTAL = thistype.Create(true, 4, 'K000')
        set thistype.HERO_ULTIMATE = thistype.Create(true, 2, 'H000')
        set thistype.HERO_ULTIMATE_EX = thistype.Create(true, 3, 'J000')
        set thistype.ITEM = thistype.Create(false, 0, 0)
        set thistype.NORMAL = thistype.Create(false, 0, 0)
    endmethod
endstruct
    scope FolderSpell
    globals
        constant integer MAX_SPELL_LEVEL_Wrapped = 3
    endglobals
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return Spell(this).Data.table.IntegerKeys.Table.ContainsInteger(Spell(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Spell(this).Data.table.IntegerKeys.Table.CountIntegers(Spell(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Spell(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Spell(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Spell(this).Data.table.IntegerKeys.Table.GetInteger(Spell(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Spell(this).Data.table.IntegerKeys.Table.GetFirstInteger(Spell(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Spell(this).Data.table.IntegerKeys.Table.GetLastInteger(Spell(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Spell(this).Data.table.IntegerKeys.Table.Clear(Spell(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Spell(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Spell(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Spell(this).Data.table.IntegerKeys.Table.RemoveInteger(Spell(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Spell(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Spell(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Spell(this).Data.table.IntegerKeys.Table.AddInteger(Spell(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Spell(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Spell(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Spell(this).Data.table.IntegerKeys.Table.JoinInteger(Spell(this).Id.Get(), key, Spell(other).Data.table, Spell(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Spell(this).Data.table.IntegerKeys.Table.RandomInteger(Spell(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Spell(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Spell(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Spell(this).Data.table.IntegerKeys.Table.PrintIntegers(Spell(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructBoolean
        implement Allocation
        implement List
        
    method Get takes integer key returns boolean
        return Spell(this).Data.table.IntegerKeys.GetBoolean(Spell(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Spell(this).Data.table.IntegerKeys.RemoveBoolean(Spell(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call Spell(this).Data.table.IntegerKeys.SetBoolean(Spell(this).Id.Get(), key, value)
    endmethod
        endstruct
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return Spell(this).Data.table.IntegerKeys.GetInteger(Spell(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Spell(this).Data.table.IntegerKeys.RemoveInteger(Spell(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Spell(this).Data.table.IntegerKeys.SetInteger(Spell(this).Id.Get(), key, value)
    endmethod
        endstruct
    public struct StructReal
        implement Allocation
        implement List
        
    method Get takes integer key returns real
        return Spell(this).Data.table.IntegerKeys.GetReal(Spell(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Real.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Spell(this).Data.table.IntegerKeys.RemoveReal(Spell(this).Id.Get(), key)
    endmethod
    method Set takes integer key, real value returns nothing
        call Spell(this).Data.table.IntegerKeys.SetReal(Spell(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
    FolderData_StructReal Real = this
    FolderData_StructReal LinkToStruct_Real
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Spell(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Spell.Allocation.deallocate_demount.hook
		call Spell(this).Data.Destroy()
	endinject
	inject Spell.Allocation.allocate_mount.hook
		call Spell(this).Data.Event_Create()
	endinject
    endstruct
    scope FolderEvent
    public struct StructNative
        implement Allocation
        implement List
        
                static method GetCast takes nothing returns Spell
                    return Spell.GetFromSelf(GetSpellAbilityId())
                endmethod
                static method GetLearned takes nothing returns Spell
                    return Spell.GetFromSelf(GetLearnedSkill())
                endmethod
        endstruct
    endscope
    public struct StructEvent
        implement Allocation
        implement List
        
    FolderEvent_StructNative Native = this
    FolderEvent_StructNative LinkToStruct_Native
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(Spell(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(Spell(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(Spell(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(Spell(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(Spell(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(Spell(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(Spell(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(Spell(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject Spell.Allocation.deallocate_demount.hook
			call Spell(this).Event.Destroy()
		endinject
		inject Spell.Allocation.allocate_mount.hook
			call Spell(this).Event.Event_Create()
		endinject
    endstruct
endscope
    globals
        Spell SPELL = STRUCT_BASE
    endglobals
    struct Spell
        implement Allocation
        implement List
        
    static key GetKeyMacro_AREA_RANGE_KEY_ARRAY_DETAIL
    static constant integer AREA_RANGE_KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_AREA_RANGE_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_CHANNEL_TIME_KEY_ARRAY_DETAIL
    static constant integer CHANNEL_TIME_KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_CHANNEL_TIME_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_COOLDOWN_KEY_ARRAY_DETAIL
    static constant integer COOLDOWN_KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_COOLDOWN_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    static constant string DEFAULT_NAME = "Default string"
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_MANA_COST_KEY_ARRAY_DETAIL
    static constant integer MANA_COST_KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_MANA_COST_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_RANGE_KEY_ARRAY_DETAIL
    static constant integer RANGE_KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_RANGE_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    static constant integer TARGET_TYPE_IMMEDIATE = 0
    static constant integer TARGET_TYPE_PASSIVE = 1
    static constant integer TARGET_TYPE_POINT = 2
    static constant integer TARGET_TYPE_POINT_OR_UNIT = 3
    static constant integer TARGET_TYPE_UNIT = 4
    static thistype TEMP
    static constant integer TYPE_HERO_FIRST_LEVELS_AMOUNT = 5
    static constant integer TYPE_HERO_SECOND_LEVELS_AMOUNT = 5
    static constant integer TYPE_HERO_ULTIMATE_EX_LEVELS_AMOUNT = 3
    static constant integer TYPE_HERO_ULTIMATE_LEVELS_AMOUNT = 3
    static constant integer TYPE_NORMAL_LEVELS_AMOUNT = 1
    FolderSpell_StructData Data = this
    FolderSpell_StructData LinkToStruct_Data
    FolderSpell_StructEvent Event = this
    FolderSpell_StructEvent LinkToStruct_Event
    FolderSpell_StructId Id = this
    FolderSpell_StructId LinkToStruct_Id
    string animation
    method GetAnimation takes nothing returns string
        return this.animation
    endmethod
    method SetAnimation takes string value returns nothing
        set this.animation = value
    endmethod
    Order autoCastOrderOff
    method GetAutoCastOrderOff takes nothing returns Order
        return this.autoCastOrderOff
    endmethod
    method SetAutoCastOrderOff takes Order value returns nothing
        set this.autoCastOrderOff = value
    endmethod
    Order autoCastOrderOn
    method GetAutoCastOrderOn takes nothing returns Order
        return this.autoCastOrderOn
    endmethod
    method SetAutoCastOrderOn takes Order value returns nothing
        set this.autoCastOrderOn = value
    endmethod
    boolean heroSpell
    method IsHeroSpell takes nothing returns boolean
        return this.heroSpell
    endmethod
    method SetHeroSpell takes boolean value returns nothing
        set this.heroSpell = value
    endmethod
    string icon
    method GetIcon takes nothing returns string
        return this.icon
    endmethod
    method SetIcon takes string value returns nothing
        set this.icon = value
    endmethod
    integer levelsAmount
    method GetLevelsAmount takes nothing returns integer
        return this.levelsAmount
    endmethod
    method SetLevelsAmount takes integer value returns nothing
        set this.levelsAmount = value
    endmethod
    BoolExpr orderConditions
    method GetOrderConditions takes nothing returns BoolExpr
        return this.orderConditions
    endmethod
    method SetOrderConditions takes BoolExpr value returns nothing
        set this.orderConditions = value
    endmethod
    Order thisOrder
    method GetOrder takes nothing returns Order
        return this.thisOrder
    endmethod
    method SetOrder takes Order value returns nothing
        set this.thisOrder = value
    endmethod
    string name
    method GetName takes nothing returns string
        return this.name
    endmethod
    method SetName takes string value returns nothing
        set this.name = value
    endmethod
    integer self
    method GetSelf takes nothing returns integer
        return this.self
    endmethod
    method SetSelf takes integer value returns nothing
        set this.self = value
    endmethod
    integer targetType
    method GetTargetType takes nothing returns integer
        return this.targetType
    endmethod
    method SetTargetType takes integer value returns nothing
        set this.targetType = value
    endmethod
    SpellClass whichClass
    method GetClass takes nothing returns SpellClass
        return this.whichClass
    endmethod
    method SetClass takes SpellClass value returns nothing
        set this.whichClass = value
    endmethod
    
        static key GetKeyMacro_AreaRange_KEY_ARRAY_DETAIL
        static constant integer AreaRange_KEY_ARRAY_DETAIL = Math.Integer.MIN + DATA_TABLE.IntegerKeys.Table.OFFSET + GetKeyMacro_AreaRange_KEY_ARRAY_DETAIL * DATA_TABLE.IntegerKeys.Table.SIZE
    
    method GetAreaRange takes integer index returns real
        return this.Data.Real.Get(AreaRange_KEY_ARRAY_DETAIL + index)
    endmethod
    method SetAreaRange takes integer index, real value returns nothing
        call this.Data.Real.Set(AreaRange_KEY_ARRAY_DETAIL + index, value)
    endmethod
    
        static key GetKeyMacro_CastTime_KEY_ARRAY_DETAIL
        static constant integer CastTime_KEY_ARRAY_DETAIL = Math.Integer.MIN + DATA_TABLE.IntegerKeys.Table.OFFSET + GetKeyMacro_CastTime_KEY_ARRAY_DETAIL * DATA_TABLE.IntegerKeys.Table.SIZE
    
    method GetCastTime takes integer index returns real
        return this.Data.Real.Get(CastTime_KEY_ARRAY_DETAIL + index)
    endmethod
    method SetCastTime takes integer index, real value returns nothing
        call this.Data.Real.Set(CastTime_KEY_ARRAY_DETAIL + index, value)
    endmethod
    
        static key GetKeyMacro_ChannelTime_KEY_ARRAY_DETAIL
        static constant integer ChannelTime_KEY_ARRAY_DETAIL = Math.Integer.MIN + DATA_TABLE.IntegerKeys.Table.OFFSET + GetKeyMacro_ChannelTime_KEY_ARRAY_DETAIL * DATA_TABLE.IntegerKeys.Table.SIZE
    
    method GetChannelTime takes integer index returns real
        return this.Data.Real.Get(ChannelTime_KEY_ARRAY_DETAIL + index)
    endmethod
    method SetChannelTime takes integer index, real value returns nothing
        call this.Data.Real.Set(ChannelTime_KEY_ARRAY_DETAIL + index, value)
    endmethod
    
        static key GetKeyMacro_Cooldown_KEY_ARRAY_DETAIL
        static constant integer Cooldown_KEY_ARRAY_DETAIL = Math.Integer.MIN + DATA_TABLE.IntegerKeys.Table.OFFSET + GetKeyMacro_Cooldown_KEY_ARRAY_DETAIL * DATA_TABLE.IntegerKeys.Table.SIZE
    
    method GetCooldown takes integer index returns real
        return this.Data.Real.Get(Cooldown_KEY_ARRAY_DETAIL + index)
    endmethod
    method SetCooldown takes integer index, real value returns nothing
        call this.Data.Real.Set(Cooldown_KEY_ARRAY_DETAIL + index, value)
    endmethod
    
        static key GetKeyMacro_ManaCost_KEY_ARRAY_DETAIL
        static constant integer ManaCost_KEY_ARRAY_DETAIL = Math.Integer.MIN + DATA_TABLE.IntegerKeys.Table.OFFSET + GetKeyMacro_ManaCost_KEY_ARRAY_DETAIL * DATA_TABLE.IntegerKeys.Table.SIZE
    
    method GetManaCost takes integer index returns real
        return this.Data.Real.Get(ManaCost_KEY_ARRAY_DETAIL + index)
    endmethod
    method SetManaCost takes integer index, real value returns nothing
        call this.Data.Real.Set(ManaCost_KEY_ARRAY_DETAIL + index, value)
    endmethod
    
        static key GetKeyMacro_Range_KEY_ARRAY_DETAIL
        static constant integer Range_KEY_ARRAY_DETAIL = Math.Integer.MIN + DATA_TABLE.IntegerKeys.Table.OFFSET + GetKeyMacro_Range_KEY_ARRAY_DETAIL * DATA_TABLE.IntegerKeys.Table.SIZE
    
    method GetRange takes integer index returns real
        return this.Data.Real.Get(Range_KEY_ARRAY_DETAIL + index)
    endmethod
    method SetRange takes integer index, real value returns nothing
        call this.Data.Real.Set(Range_KEY_ARRAY_DETAIL + index, value)
    endmethod
    static method GetFromName takes string name returns thistype
        return StringData.Data.Integer.Get(name, KEY)
    endmethod
    static method GetFromSelf takes integer self returns thistype
        return Memory.IntegerKeys.GetInteger(self, KEY)
    endmethod
    static method SelfExists takes integer self returns boolean
        return (GetObjectName(self) != DEFAULT_NAME)
    endmethod
    static key GetKeyMacro_INIT_KEY_ARRAY
    static constant integer INIT_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_INIT_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static method AddInit takes code c, string name returns nothing
        call Trigger.AddObjectInit(INIT_KEY_ARRAY, c, name)
    endmethod
    static method CreateBasic takes string name returns thistype
        local thistype this = thistype.allocate()
        set this.levelsAmount = 0
        call this.SetHeroSpell(false)
        call this.SetName(name)
        call this.Id.Event_Create()
        
        call StringData.Data.Integer.Set(this.GetName(), KEY, this)
        call this.AddToList()
        return this
    endmethod
    static method CreateFromSelf takes integer self returns thistype
        local thistype this = thistype.CreateBasic(GetObjectName(self))
        set this.self = self
        call Memory.IntegerKeys.SetInteger(self, KEY, this)
        return this
    endmethod
    static method CreateHidden takes string name returns thistype
        return thistype.CreateBasic(name)
    endmethod
    initMethod Init of Header_7
        call SpellClass.Init()
        call HeroSpell.Init()
    endmethod
endstruct
    scope FolderSpellInstance
    public struct StructRefs
        implement Allocation
        implement List
        
        boolean waiting
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
        method CheckForDestroy takes nothing returns boolean
            if (this.Get() > 0) then
                set this.waiting = true
                return false
            endif
            return true
        endmethod
        method Subtract takes nothing returns nothing
            local integer value = this.Get() - 1
            set this.value = value
            if ((value == 0) and (this.waiting)) then
                call SpellInstance(this).Destroy()
            endif
        endmethod
        method Add takes nothing returns nothing
            set this.value = this.Get() + 1
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0
            set this.waiting = false
        endmethod
    endstruct
endscope
    globals
        SpellInstance SPELL_INSTANCE = STRUCT_BASE
    endglobals
    struct SpellInstance
        implement Allocation
        implement List
        
    static thistype TEMP
    FolderSpellInstance_StructRefs Refs = this
    FolderSpellInstance_StructRefs LinkToStruct_Refs
    real angle
    method GetAngle takes nothing returns real
        return this.angle
    endmethod
    method SetAngle takes real value returns nothing
        set this.angle = value
    endmethod
    Unit caster
    method GetCaster takes nothing returns Unit
        return this.caster
    endmethod
    method SetCaster takes Unit value returns nothing
        set this.caster = value
    endmethod
    integer critFlag
    method GetCritFlag takes nothing returns integer
        return this.critFlag
    endmethod
    method SetCritFlag takes integer value returns nothing
        set this.critFlag = value
    endmethod
    real damageMod
    method GetDamageMod takes nothing returns real
        return this.damageMod
    endmethod
    method SetDamageMod takes real value returns nothing
        set this.damageMod = value
    endmethod
    real dealtDamage
    method GetDealtDamage takes nothing returns real
        return this.dealtDamage
    endmethod
    method SetDealtDamage takes real value returns nothing
        set this.dealtDamage = value
    endmethod
    integer level
    method GetLevel takes nothing returns integer
        return this.level
    endmethod
    method SetLevel takes integer value returns nothing
        set this.level = value
    endmethod
    real spellPowerMod
    method GetSpellPowerMod takes nothing returns real
        return this.spellPowerMod
    endmethod
    method SetSpellPowerMod takes real value returns nothing
        set this.spellPowerMod = value
    endmethod
    Item targetItem
    method GetTargetItem takes nothing returns Item
        return this.targetItem
    endmethod
    method SetTargetItem takes Item value returns nothing
        set this.targetItem = value
    endmethod
    Unit targetUnit
    method GetTargetUnit takes nothing returns Unit
        return this.targetUnit
    endmethod
    method SetTargetUnit takes Unit value returns nothing
        set this.targetUnit = value
    endmethod
    real targetX
    method GetTargetX takes nothing returns real
        return this.targetX
    endmethod
    method SetTargetX takes real value returns nothing
        set this.targetX = value
    endmethod
    real targetY
    method GetTargetY takes nothing returns real
        return this.targetY
    endmethod
    method SetTargetY takes real value returns nothing
        set this.targetY = value
    endmethod
    Spell whichSpell
    method GetSpell takes nothing returns Spell
        return this.whichSpell
    endmethod
    method SetSpell takes Spell value returns nothing
        set this.whichSpell = value
    endmethod
    method GetCurrentTargetX takes nothing returns real
        local Item targetItem = this.GetTargetItem()
        if (targetItem != NULL) then
            return targetItem.Position.GetX()
        endif
        local Unit targetUnit = this.GetTargetUnit()
        if (targetUnit != NULL) then
            return targetUnit.Position.X.Get()
        endif
        return this.GetTargetX()
    endmethod
    method GetCurrentTargetY takes nothing returns real
        local Item targetItem = this.GetTargetItem()
        if (targetItem != NULL) then
            return targetItem.Position.GetY()
        endif
        local Unit targetUnit = this.GetTargetUnit()
        if (targetUnit != NULL) then
            return targetUnit.Position.Y.Get()
        endif
        return this.GetTargetY()
    endmethod
    method Destroy takes nothing returns nothing
        if not this.Refs.CheckForDestroy() then
            return
        endif
        call this.deallocate()
    endmethod
    method AddDamage takes real damage, boolean crit returns nothing
        if (damage > 0.) then
            call this.SetCritFlag(this.GetCritFlag() + Boolean.ToIntEx(crit))
            call this.SetDealtDamage(this.GetDealtDamage() + damage)
        endif
    endmethod
    static method Create takes Unit caster, Spell whichSpell returns thistype
        local thistype this = thistype.allocate()
        call this.SetAngle(0.)
        call this.SetCaster(caster)
        call this.SetCritFlag(0)
        call this.SetDamageMod(caster.Damage.Get())
        call this.SetDealtDamage(0.)
        call this.SetLevel(caster.Abilities.GetLevel(whichSpell))
        call this.SetSpell(whichSpell)
        call this.SetSpellPowerMod(caster.SpellPower.Get())
        call this.SetTargetItem(NULL)
        call this.SetTargetUnit(NULL)
        call this.SetTargetX(0.)
        call this.SetTargetY(0.)
        call this.Refs.Event_Create()
        return this
    endmethod
endstruct
function GetSpellTargetX_Wrapped takes nothing returns real
    return GetSpellTargetX()
endfunction
function GetSpellTargetY_Wrapped takes nothing returns real
    return GetSpellTargetY()
endfunction
    scope FolderSpot
    scope FolderEvent
    public struct StructNative
        implement Allocation
        implement List
        
            static method GetOrderTargetX takes nothing returns real
                return GetOrderPointX()
            endmethod
            static method GetOrderTargetY takes nothing returns real
                return GetOrderPointY()
            endmethod
            static method HasSpellTarget takes nothing returns boolean
                local Spot target = Spot.CreateFromSelf(GetSpellTargetLoc())
                local boolean result = (target.self != null)
                call target.Destroy()
                return result
            endmethod
            static method GetSpellTargetX takes nothing returns real
                return GetSpellTargetX_Wrapped()
            endmethod
            static method GetSpellTargetY takes nothing returns real
                return GetSpellTargetY_Wrapped()
            endmethod
        endstruct
    endscope
    public struct StructEvent
        implement Allocation
        implement List
        
    FolderEvent_StructNative Native = this
    FolderEvent_StructNative LinkToStruct_Native
    endstruct
    public struct StructBlockCheck
        implement Allocation
        implement List
        
		static item DUMMY_ITEM
		static boolexpr HIDE_BOOLEXPR
		static rect HIDE_RECT
		static item array HIDDEN
		static integer HIDDEN_COUNT = ARRAY_EMPTY
		static method Hide
			if not IsItemVisible(GetFilterItem()) then
				return
			endif
			set thistype.HIDDEN_COUNT = thistype.HIDDEN_COUNT + 1
			set thistype.HIDDEN[thistype.HIDDEN_COUNT] = GetFilterItem()
		endmethod
		static method Do takes real x, real y returns boolean
			call MoveRectTo(thistype.HIDE_RECT, x, y)
	
			call EnumItemsInRect(thistype.HIDE_RECT, thistype.HIDE_BOOLEXPR, null)
	        call SetItemPosition(thistype.DUMMY_ITEM, x, y)
	        local real targetX = GetWidgetX(thistype.DUMMY_ITEM)
	        local real targetY = GetWidgetY(thistype.DUMMY_ITEM)
			call SetItemVisible(thistype.DUMMY_ITEM, false)
	
			loop
				exitwhen (thistype.HIDDEN_COUNT < ARRAY_MIN)
				call SetItemVisible(thistype.HIDDEN[thistype.HIDDEN_COUNT], true)
				set thistype.HIDDEN_COUNT = thistype.HIDDEN_COUNT - 1
			endloop
	
	        local real d = Math.DistanceSquareByDeltas(targetX - x, targetY - y)
	
	        return (d > 1.)
		endmethod
		static constant real HEIGHT_TOLERANCE = 0.
		method DoWithZ takes real x, real y, real z returns boolean
			if not (z < Spot.GetHeight(x, y) - thistype.HEIGHT_TOLERANCE) then
				return false
			endif
			return this.Do(x, y)
		endmethod
		static method Init
			set thistype.DUMMY_ITEM = CreateItem(thistype.DUMMY_ITEM_ID, 0, 0)
			set thistype.HIDE_BOOLEXPR = Condition(function thistype.Hide)
			set thistype.HIDE_RECT = Rect(0, 0, 64, 64)
			call SetItemVisible(thistype.DUMMY_ITEM, false)
		endmethod
	endstruct
    public struct StructDeformNova
        implement Allocation
        implement List
        
        static constant real ANGLE_ADD = Math.FULL_ANGLE / 5
        static constant real UPDATE_TIME = 16 * FRAME_UPDATE_TIME
        static Timer UPDATE_TIMER
        real depth
        real length
        real lengthAdd
        real x
        real y
        static method Update takes nothing returns nothing
            local integer iteration = thistype.ALL_COUNT
            loop
                local real angle = Math.FULL_ANGLE
                local thistype this = thistype.ALL[iteration]
                local real depth = this.depth
                local real length = this.length + this.lengthAdd
                local real x = this.x
                local real y = this.y
                set this.length = length
                loop
                    call TerrainDeformCrater(x + length * Math.Cos(angle), y + length * Math.Sin(angle), 1., depth, 1000, false)
                    set angle = angle - ANGLE_ADD
                    exitwhen (angle < 0)
                endloop
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
        endmethod
        static method Ending takes nothing returns nothing
            local Timer durationTimer = Timer.GetExpired()
            local thistype this = durationTimer.GetData()
            call this.deallocate()
            call durationTimer.Destroy()
            if this.RemoveFromList() then
                call thistype.UPDATE_TIMER.Pause()
            endif
        endmethod
        static method Create takes real x, real y, real depth, real length, real speed returns nothing
            local real duration = length / speed
            local thistype this = thistype.allocate()
			local Timer durationTimer = Timer.Create()
            set this.depth = depth
            set this.length = 0.
            set this.lengthAdd = speed * UPDATE_TIME
            set this.x = x
            set this.y = y
            call durationTimer.SetData(this)
            if this.AddToList() then
                call thistype.UPDATE_TIMER.Start(UPDATE_TIME, true, function thistype.Update)
            endif
            call durationTimer.Start(duration, false, function thistype.Ending)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.UPDATE_TIMER = Timer.Create()
        endmethod
    endstruct
endscope
    globals
        Spot SPOT = STRUCT_BASE
    endglobals
    struct Spot
        implement Allocation
        implement List
        
    static thistype DUMMY
    static constant real SLOPE_PRECISION = 2.
    location self
    FolderSpot_StructBlockCheck BlockCheck = this
    FolderSpot_StructBlockCheck LinkToStruct_BlockCheck
    FolderSpot_StructDeformNova DeformNova = this
    FolderSpot_StructDeformNova LinkToStruct_DeformNova
    FolderSpot_StructEvent Event = this
    FolderSpot_StructEvent LinkToStruct_Event
    method Destroy takes nothing returns nothing
        local location self = this.self
        call this.deallocate()
        call RemoveLocation(self)
        set self = null
    endmethod
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    method GetZ takes nothing returns real
        return GetLocationZ(this.self)
    endmethod
	static method IsBlocked takes real x, real y returns boolean
        return thistype(NULL).BlockCheck.Do(x, y)
    endmethod
    static method IsWalkable takes real x, real y returns boolean
        return not IsTerrainPathable(x, y, PATHING_TYPE_WALKABILITY)
    endmethod
    method Move takes real x, real y returns nothing
        call MoveLocation(this.self, x, y)
    endmethod
	static method GetCliffLevel takes real x, real y returns integer
		return GetTerrainCliffLevel(x, y)
	endmethod
    static method GetHeight takes real x, real y returns real
        call thistype.DUMMY.Move(x, y)
        return thistype.DUMMY.GetZ()
    endmethod
    method GetSlopeX takes real x, real y returns real
        return (Math.QUARTER_ANGLE - Math.Atan(thistype.GetHeight(x + thistype.SLOPE_PRECISION / 2., y) - thistype.GetHeight(x - thistype.SLOPE_PRECISION / 2., y) / SLOPE_PRECISION))
    endmethod
    method GetSlopeNormalX takes real x, real y returns real
        return (2. * Math.QUARTER_ANGLE - Math.Atan(thistype.GetHeight(x + thistype.SLOPE_PRECISION / 2., y) - thistype.GetHeight(x - thistype.SLOPE_PRECISION / 2., y) / SLOPE_PRECISION))
    endmethod
    method GetSlopeY takes real x, real y returns real
        return (Math.QUARTER_ANGLE - Math.Atan(thistype.GetHeight(x, y + thistype.SLOPE_PRECISION / 2.) - thistype.GetHeight(x, y - thistype.SLOPE_PRECISION / 2.) / SLOPE_PRECISION))
    endmethod
    method GetSlopeNormalY takes real x, real y returns real
        return (2. * Math.QUARTER_ANGLE - Math.Atan(thistype.GetHeight(x, y + thistype.SLOPE_PRECISION / 2.) - thistype.GetHeight(x, y - thistype.SLOPE_PRECISION / 2.) / SLOPE_PRECISION))
    endmethod
    static method SetHeight takes real x, real y, real value returns nothing
        call TerrainDeformCrater(x, y, 1., -(value - Spot.GetHeight(x, y)), 1, true)
    endmethod
    static method AddHeight takes real x, real y, real value returns nothing
        call thistype.SetHeight(x, y, Spot.GetHeight(x, y) + value)
    endmethod
    static method CreateRipple takes real x, real y, real startRadius, real endRadius, real depth, real duration returns nothing
        local real radiusFactor = startRadius / endRadius
        call TerrainDeformRipple(x, y, endRadius, depth, Real.ToInt(duration * 1000), 1, 0., 1., radiusFactor, false)
    endmethod
    static method CreateWave takes real x, real y, real length, real speed, real angle, real radius, real depth returns nothing
        call TerrainDeformWave(x, y, Math.Cos(angle), Math.Sin(angle), length, speed, radius, depth, 0, 1)
    endmethod
    static method CreateFromSelf takes location self returns thistype
        local thistype this = thistype.allocate()
        set this.self = self
        return this
    endmethod
    static method Create takes real x, real y returns thistype
        return thistype.CreateFromSelf(Location(x, y))
    endmethod
    static method CreateEffect takes real x, real y, string modelPath, EffectLevel level returns SpotEffect
        return SpotEffect.Create(x, y, modelPath, level)
    endmethod
    static method CreateEffectWithZ takes real x, real y, real z, string modelPath, EffectLevel level returns SpotEffect
        return SpotEffect.CreateWithZ(x, y, z, modelPath, level)
    endmethod
    static method CreateEffectWithSize takes real x, real y, string modelPath, EffectLevel level, real size returns SpotEffectWithSize
        return SpotEffectWithSize.Create(x, y, modelPath, level, size)
    endmethod
    static method GetSpellTargetX takes nothing returns real
        return GetSpellTargetX()
    endmethod
    static method GetSpellTargetY takes nothing returns real
        return GetSpellTargetY()
    endmethod
    static method GetSpellTarget takes nothing returns thistype
        return CreateFromSelf(GetSpellTargetLoc())
    endmethod
    initMethod Init of Header_2
        set thistype.DUMMY = Create(0., 0.)
		call thistype(NULL).BlockCheck.Init()
        call thistype(NULL).DeformNova.Init()
    endmethod
endstruct
    scope FolderStringData
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    static method Count takes string whichString, integer key returns integer
        return Memory.StringKeys.Table.CountIntegers(whichString, Integer.ToString(key))
    endmethod
    static method Get takes string whichString, integer key, integer index returns integer
        return Memory.StringKeys.Table.GetInteger(whichString, Integer.ToString(key), index)
    endmethod
    static method Remove takes string whichString, integer key, integer value returns boolean
        return Memory.StringKeys.Table.RemoveInteger(whichString, Integer.ToString(key), value)
    endmethod
    static method Add takes string whichString, integer key, integer value returns boolean
        return Memory.StringKeys.Table.AddInteger(whichString, Integer.ToString(key), value)
    endmethod
    static method Random takes string whichString, integer key, integer lowerBound, integer higherBound returns integer
        return Memory.StringKeys.Table.RandomInteger(whichString, Integer.ToString(key), lowerBound, higherBound)
    endmethod
    static method RandomAll takes string whichString, integer key returns integer
        return thistype.Random(whichString, key, DATA_TABLE.IntegerKeys.Table.STARTED, thistype.Count(whichString, key))
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    static method Get takes string whichString, integer key returns integer
        return Memory.StringKeys.GetInteger(whichString, Integer.ToString(key))
    endmethod
    static method Remove takes string whichString, integer key returns nothing
        call Memory.StringKeys.RemoveInteger(whichString, Integer.ToString(key))
    endmethod
    static method Set takes string whichString, integer key, integer value returns nothing
        call Memory.StringKeys.SetInteger(whichString, Integer.ToString(key), value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
    method Destroy takes string whichString returns nothing
        call Memory.StringKeys.RemoveChild(whichString)
    endmethod
    endstruct
    scope FolderEvent
    public struct StructNative
        implement Allocation
        implement List
        
            static method GetChat takes nothing returns string
                return GetEventPlayerChatString()
            endmethod
        endstruct
    endscope
    public struct StructEvent
        implement Allocation
        implement List
        
    FolderEvent_StructNative Native = this
    FolderEvent_StructNative LinkToStruct_Native
        method Count takes string self, EventType whichType, EventPriority priority returns integer
            return StringData.Data.Integer.Table.Count(self, Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes string self, EventType whichType, EventPriority priority, integer index returns Event
            return StringData.Data.Integer.Table.Get(self, Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes string self, Event whichEvent returns nothing
            call StringData.Data.Integer.Table.Remove(self, whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes string self, Event whichEvent returns nothing
            call StringData.Data.Integer.Table.Add(self, whichEvent.GetKey(), whichEvent)
        endmethod
    endstruct
endscope
    globals
        StringData STRING_DATA = STRUCT_BASE
    endglobals
    struct StringData
        implement Allocation
        implement List
        
    static FolderStringData_StructData Data = NULL
    static FolderStringData_StructEvent Event = NULL
    initMethod Init of Header
    endmethod
endstruct
    globals
        TileType TILE_TYPE = STRUCT_BASE
    endglobals
    struct TileType
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    integer self
    static method GetFromSelf takes integer self returns thistype
        return Memory.IntegerKeys.GetInteger(self, KEY)
    endmethod
    method Destroy takes nothing returns nothing
        call this.deallocate()
    endmethod
    static method CreateFromSelf takes integer self returns thistype
        local thistype this = thistype.allocate()
        set this.self = self
        call Memory.IntegerKeys.SetInteger(self, KEY, this)
        return this
    endmethod
    static key GetKeyMacro_INIT_KEY_ARRAY
    static constant integer INIT_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_INIT_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static method AddInit takes code c, string name returns nothing
        call Trigger.AddObjectInit(INIT_KEY_ARRAY, c, name)
    endmethod
    initMethod Init of Header_5
    endmethod
endstruct
    scope FolderTile
    public struct StructType
        implement Allocation
        implement List
        
        TileType orig
        Queue vals
        method GetNative takes nothing returns TileType
            return TileType.GetFromSelf(GetTerrainType(Tile(this).GetX(), Tile(this).GetY()))
        endmethod
        method SetNative takes TileType val returns nothing
            call SetTerrainType(Tile(this).GetX(), Tile(this).GetY(), val.self, -1, 1, 0)
        endmethod
        method Remove takes TileTypeMod val returns nothing
            if (this.vals == NULL) then
                call DebugEx(thistype.NAME + " tile " + I2S(this) + " has not " + I2S(val))
                return
            endif
            call this.vals.Remove(val)
            if vals.IsEmpty() then
                call vals.Destroy()
                set this.vals = NULL
                call this.SetNative(this.orig)
            else
                set val = this.vals.GetLast()
                call this.SetNative(val.GetVal())
            endif
        endmethod
        method Add takes TileTypeMod val returns nothing
            if (this.vals == NULL) then
                set this.orig = this.GetNative()
                set this.vals = Queue.Create()
            endif
            call this.vals.Add(val)
            call this.SetNative(val.GetVal())
        endmethod
        method Event_Create takes nothing returns nothing
            set this.vals = NULL
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
endscope
    globals
        Tile TILE = STRUCT_BASE
    endglobals
    struct Tile
        implement Allocation
        implement List
        
	static constant integer CELL_DIST = 128
    static HashTable TABLE
    integer x
    method GetX takes nothing returns integer
        return this.x
    endmethod
    method SetX takes integer value returns nothing
        set this.x = value
    endmethod
    integer y
    method GetY takes nothing returns integer
        return this.y
    endmethod
    method SetY takes integer value returns nothing
        set this.y = value
    endmethod
    FolderTile_StructType Type = this
    FolderTile_StructType LinkToStruct_Type
    integer refs
    static method GetFromCoords2 takes real x, real y returns thistype
        local integer xI = Real.ToInt(x - WORLD_MIN_X) div 128
        local integer yI = Real.ToInt(y - WORLD_MIN_Y) div 128
        return thistype(yI * Real.ToInt(WORLD_MAX_X - WORLD_MIN_X) div 128 + xI)
    endmethod
    method GetFirstKey takes nothing returns integer
        return (this div 8192)
    endmethod
    method GetSecondKey takes nothing returns integer
        return Math.ModI(this, 8192)
    endmethod
    method GetX2 takes nothing returns real
        return (WORLD_MIN_X + Math.ModI(this, Real.ToInt(WORLD_MAX_X - WORLD_MIN_X) div 128) * 128)
    endmethod
    method GetY2 takes nothing returns real
        return (WORLD_MIN_Y + this / (Real.ToInt(WORLD_MAX_X - WORLD_MIN_X) div 128) * 128)
    endmethod
    method RemoveRef takes nothing returns nothing
        if (this.refs == 1) then
            call thistype.TABLE.Integer.Remove(Real.ToInt(this.GetX()) div 128, Real.ToInt(this.GetY()) div 128)
            call this.deallocate()
            return
        endif
        set this.refs = this.refs - 1
    endmethod
    static method GetFromCoords takes real x, real y returns thistype
        local integer xI = Real.ToInt(Math.RoundTo(x, 128)) div 128
        local integer yI = Real.ToInt(Math.RoundTo(y, 128)) div 128
        local thistype this = thistype.TABLE.Integer.Get(xI, yI)
        if (this == NULL) then
            set this = thistype.allocate()
            call thistype.TABLE.Integer.Set(xI, yI, this)
            set this.refs = 1
            call this.SetX(xI * 128)
            call this.SetY(yI * 128)
            call this.Type.Event_Create()
        else
            set this.refs = this.refs + 1
        endif
        return this
    endmethod
    initMethod Init of Header_5
        set thistype.TABLE = HashTable.Create()
    endmethod
endstruct
    scope FolderTileTypeMod
    public struct StructDestroyTimed
        implement Allocation
        implement List
        
        Timer durationTimer
        method Ending takes nothing returns nothing
            call this.durationTimer.Destroy()
        endmethod
        static method EndingByTimer takes nothing returns nothing
            local thistype this = Timer.GetExpired().GetData()
            call this.Ending()
            call TileTypeMod(this).Destroy()
        endmethod
        method Start takes real duration returns nothing
            local Timer durationTimer = Timer.Create()
            set this.durationTimer = durationTimer
            call durationTimer.SetData(this)
            call durationTimer.Start(duration, false, function thistype.EndingByTimer)
        endmethod
    endstruct
endscope
    globals
        TileTypeMod TILE_TYPE_MOD = STRUCT_BASE
    endglobals
    struct TileTypeMod
        implement Allocation
        implement List
        
    Tile tile
    method GetTile takes nothing returns Tile
        return this.tile
    endmethod
    method SetTile takes Tile value returns nothing
        set this.tile = value
    endmethod
    TileType val
    method GetVal takes nothing returns TileType
        return this.val
    endmethod
    method SetVal takes TileType value returns nothing
        set this.val = value
    endmethod
    FolderTileTypeMod_StructDestroyTimed DestroyTimed = this
    FolderTileTypeMod_StructDestroyTimed LinkToStruct_DestroyTimed
    method Destroy takes nothing returns nothing
        local Tile tile = this.GetTile()
        call tile.Type.Remove(this)
        call tile.RemoveRef()
        call this.deallocate()
    endmethod
    static method Create takes real x, real y, TileType val returns thistype
        local Tile tile = Tile.GetFromCoords(x, y)
        local thistype this = thistype.allocate()
        call this.SetTile(tile)
        call this.SetVal(val)
        call tile.Type.Add(this)
        return this
    endmethod
    initMethod Init of Header_5
    endmethod
endstruct
    globals
        UbersplatType UBERSPLAT_TYPE = STRUCT_BASE
    endglobals
    struct UbersplatType
        implement Allocation
        implement List
        
    string self
    method Destroy takes nothing returns nothing
        call this.deallocate()
    endmethod
    static method Create takes string self returns thistype
        local thistype this = thistype.allocate()
        set this.self = self
        return this
    endmethod
    static key GetKeyMacro_INIT_KEY_ARRAY
    static constant integer INIT_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_INIT_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static method AddInit takes code c, string name returns nothing
        call Trigger.AddObjectInit(INIT_KEY_ARRAY, c, name)
    endmethod
endstruct
    scope FolderUbersplat
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return Ubersplat(this).Data.table.IntegerKeys.Table.ContainsInteger(Ubersplat(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Ubersplat(this).Data.table.IntegerKeys.Table.CountIntegers(Ubersplat(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Ubersplat(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Ubersplat(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Ubersplat(this).Data.table.IntegerKeys.Table.GetInteger(Ubersplat(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Ubersplat(this).Data.table.IntegerKeys.Table.GetFirstInteger(Ubersplat(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Ubersplat(this).Data.table.IntegerKeys.Table.GetLastInteger(Ubersplat(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Ubersplat(this).Data.table.IntegerKeys.Table.Clear(Ubersplat(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Ubersplat(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Ubersplat(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Ubersplat(this).Data.table.IntegerKeys.Table.RemoveInteger(Ubersplat(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Ubersplat(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Ubersplat(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Ubersplat(this).Data.table.IntegerKeys.Table.AddInteger(Ubersplat(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Ubersplat(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Ubersplat(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Ubersplat(this).Data.table.IntegerKeys.Table.JoinInteger(Ubersplat(this).Id.Get(), key, Ubersplat(other).Data.table, Ubersplat(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Ubersplat(this).Data.table.IntegerKeys.Table.RandomInteger(Ubersplat(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Ubersplat(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Ubersplat(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Ubersplat(this).Data.table.IntegerKeys.Table.PrintIntegers(Ubersplat(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return Ubersplat(this).Data.table.IntegerKeys.GetInteger(Ubersplat(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Ubersplat(this).Data.table.IntegerKeys.RemoveInteger(Ubersplat(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Ubersplat(this).Data.table.IntegerKeys.SetInteger(Ubersplat(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Ubersplat(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Ubersplat.Allocation.deallocate_demount.hook
		call Ubersplat(this).Data.Destroy()
	endinject
	inject Ubersplat.Allocation.allocate_mount.hook
		call Ubersplat(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructEvent
        implement Allocation
        implement List
        
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(Ubersplat(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(Ubersplat(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(Ubersplat(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(Ubersplat(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(Ubersplat(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(Ubersplat(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(Ubersplat(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(Ubersplat(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject Ubersplat.Allocation.deallocate_demount.hook
			call Ubersplat(this).Event.Destroy()
		endinject
		inject Ubersplat.Allocation.allocate_mount.hook
			call Ubersplat(this).Event.Event_Create()
		endinject
    endstruct
    public struct StructDestroyTimed
        implement Allocation
        implement List
        
        Timer durationTimer
        method Ending takes nothing returns nothing
            call this.durationTimer.Destroy()
        endmethod
        timerMethod EndingByTimer
            local thistype this = Timer.GetExpired().GetData()
            call this.Ending()
            call Ubersplat(this).Destroy()
        endmethod
        method Start takes real duration returns nothing
            local Timer durationTimer = Timer.Create()
            set this.durationTimer = durationTimer
            call durationTimer.SetData(this)
            call durationTimer.Start(duration, false, function thistype.EndingByTimer)
            call Ubersplat(this).Color.Timed.Subtract(0., 0., 0., Ubersplat(this).Color.Alpha.Get(), duration)
        endmethod
    endstruct
    scope FolderColor
    public struct StructRed
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(255.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructGreen
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(255.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructBlue
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(255.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructAlpha
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(255.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructTimed
        implement Allocation
        implement List
        
            static Event DESTROY_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
            static Timer UPDATE_TIMER
            real redAdd
            real greenAdd
            real blueAdd
            real alphaAdd
            Timer durationTimer
            Ubersplat parent
            timerMethod Update
                local integer iteration = thistype.ALL_COUNT
                loop
                    local thistype this = thistype.ALL[iteration]
                    call this.parent.Color.Add(this.redAdd, this.greenAdd, this.blueAdd, this.alphaAdd)
                    set iteration = iteration - 1
                    exitwhen (iteration < ARRAY_MIN)
                endloop
            endmethod
            private method Ending takes Timer durationTimer, Ubersplat parent returns nothing
                call this.deallocate()
                call durationTimer.Destroy()
                call parent.Data.Integer.Table.Remove(KEY_ARRAY, this)
                call parent.Event.Remove(DESTROY_EVENT)
                if this.RemoveFromList() then
                    call thistype.UPDATE_TIMER.Pause()
                endif
            endmethod
            eventMethod Event_Destroy
                local Ubersplat parent = params.Ubersplat.GetTrigger()
                local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                if (iteration > Memory.IntegerKeys.Table.EMPTY) then
                    loop
                        local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                        call this.Ending(this.durationTimer, parent)
                        set iteration = iteration - 1
                        exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    endloop
                endif
            endmethod
            timerMethod EndingByTimer
                local Timer durationTimer = Timer.GetExpired()
                local thistype this = durationTimer.GetData()
                call this.Ending(durationTimer, this.parent)
            endmethod
            method Add takes real red, real green, real blue, real alpha, real duration returns nothing
                local Ubersplat parent = this
                if (duration == 0.) then
                    call parent.Color.Add(red, green, blue, alpha)
                    return
                endif
				local integer wavesAmount = Real.ToInt(duration / thistype.UPDATE_TIME)
				set this = thistype.allocate()
                local Timer durationTimer = Timer.Create()
                set this.redAdd = red / wavesAmount
                set this.greenAdd = green / wavesAmount
                set this.blueAdd = blue / wavesAmount
                set this.alphaAdd = alpha / wavesAmount
                set this.durationTimer = durationTimer
                set this.parent = parent
                call durationTimer.SetData(this)
                call parent.Data.Integer.Table.Add(KEY_ARRAY, this)
                call parent.Event.Add(DESTROY_EVENT)
                if this.AddToList() then
                    call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
                endif
                call durationTimer.Start(duration, false, function thistype.EndingByTimer)
            endmethod
            method Subtract takes real red, real green, real blue, real alpha, real duration returns nothing
                call this.Add(-red, -green, -blue, -alpha, duration)
            endmethod
            static method Init takes nothing returns nothing
                set thistype.DESTROY_EVENT = Event.Create(Ubersplat.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
                set thistype.UPDATE_TIMER = Timer.Create()
            endmethod
        endstruct
    endscope
    public struct StructColor
        implement Allocation
        implement List
        
    FolderColor_StructRed Red = this
    FolderColor_StructRed LinkToStruct_Red
    FolderColor_StructGreen Green = this
    FolderColor_StructGreen LinkToStruct_Green
    FolderColor_StructBlue Blue = this
    FolderColor_StructBlue LinkToStruct_Blue
    FolderColor_StructAlpha Alpha = this
    FolderColor_StructAlpha LinkToStruct_Alpha
    FolderColor_StructTimed Timed = this
    FolderColor_StructTimed LinkToStruct_Timed
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method Set takes real red, real green, real blue, real alpha returns nothing
            call this.Red.Set(red)
            call this.Green.Set(green)
            call this.Blue.Set(blue)
            call this.Alpha.Set(alpha)
            call Ubersplat(this).Recreate()
        endmethod
        method Add takes real red, real green, real blue, real alpha returns nothing
            call this.Set(this.Red.Get() + red, this.Green.Get() + green, this.Blue.Get() + blue, this.Alpha.Get() + alpha)
        endmethod
        method Subtract takes real red, real green, real blue, real alpha returns nothing
            call this.Add(-red, -green, -blue, -alpha)
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.Red.Get(), this.Green.Get(), this.Blue.Get(), this.Alpha.Get())
        endmethod
        method Event_Create takes real red, real green, real blue, real alpha returns nothing
            call this.Red.Set(red)
            call this.Green.Set(green)
            call this.Blue.Set(blue)
            call this.Alpha.Set(alpha)
        endmethod
        static method Init takes nothing returns nothing
            call thistype(NULL).Timed.Init()
        endmethod
    endstruct
    scope FolderPosition
    public struct StructX
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real val returns nothing
                set this.value = val
                call Ubersplat(this).Recreate()
            endmethod
            method Event_Create takes real val returns nothing
                set this.value = val
            endmethod
        endstruct
    public struct StructY
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real val returns nothing
                set this.value = val
                call Ubersplat(this).Recreate()
            endmethod
            method Event_Create takes real val returns nothing
                set this.value = val
            endmethod
        endstruct
    endscope
    public struct StructPosition
        implement Allocation
        implement List
        
    FolderPosition_StructX X = this
    FolderPosition_StructX LinkToStruct_X
    FolderPosition_StructY Y = this
    FolderPosition_StructY LinkToStruct_Y
        method Set takes real x, real y returns nothing
            call this.X.Set(x)
            call this.Y.Set(y)
        endmethod
        method Add takes real x, real y returns nothing
            call this.Set(this.X.Get() + x, this.Y.Get() + y)
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.X.Get(), this.Y.Get())
        endmethod
        method Event_Create takes real x, real y returns nothing
            call this.X.Event_Create(x)
            call this.Y.Event_Create(y)
        endmethod
    endstruct
endscope
    globals
        Ubersplat UBERSPLAT = STRUCT_BASE
    endglobals
    struct Ubersplat
        implement Allocation
        implement List
        
    static EventType DESTROY_EVENT_TYPE
    ubersplat self
    boolean selfCreated
    boolean noBirthTime
    method IsNoBirthTime takes nothing returns boolean
        return this.noBirthTime
    endmethod
    method SetNoBirthTime takes boolean value returns nothing
        set this.noBirthTime = value
    endmethod
    boolean forcePaused
    method IsForcePaused takes nothing returns boolean
        return this.forcePaused
    endmethod
    method SetForcePaused takes boolean value returns nothing
        set this.forcePaused = value
    endmethod
    UbersplatType whichType
    method GetType takes nothing returns UbersplatType
        return this.whichType
    endmethod
    method SetType takes UbersplatType value returns nothing
        set this.whichType = value
    endmethod
    FolderUbersplat_StructData Data = this
    FolderUbersplat_StructData LinkToStruct_Data
    FolderUbersplat_StructId Id = this
    FolderUbersplat_StructId LinkToStruct_Id
    FolderUbersplat_StructEvent Event = this
    FolderUbersplat_StructEvent LinkToStruct_Event
    FolderUbersplat_StructColor Color = this
    FolderUbersplat_StructColor LinkToStruct_Color
    FolderUbersplat_StructDestroyTimed DestroyTimed = this
    FolderUbersplat_StructDestroyTimed LinkToStruct_DestroyTimed
    FolderUbersplat_StructPosition Position = this
    FolderUbersplat_StructPosition LinkToStruct_Position
    method ContainsSelf takes nothing returns boolean
        return this.selfCreated
    endmethod
    method Destroy_TriggerEvents takes nothing returns nothing
        local EventResponse params = EventResponse.Create(this.Id.Get())
        call params.Ubersplat.SetTrigger(this)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = this.Event.Count(thistype.DESTROY_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.DESTROY_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    method Recreate takes nothing returns nothing
        if this.ContainsSelf() then
            call DestroyUbersplat(this.self)
        endif
        set this.self = CreateUbersplat(this.Position.X.Get(), this.Position.Y.Get(), this.GetType().self, Math.LimitI(Real.ToInt(this.Color.Red.Get()), 0, 255), Math.LimitI(Real.ToInt(this.Color.Green.Get()), 0, 255), Math.LimitI(Real.ToInt(this.Color.Blue.Get()), 0, 255), Math.LimitI(Real.ToInt(this.Color.Alpha.Get()), 0, 255), this.IsForcePaused(), this.IsNoBirthTime())
        set this.selfCreated = (GetHandleId(this.self) != -1)
        call SetUbersplatRenderAlways(this.self, true)
    endmethod
    method Destroy takes nothing returns nothing
        call this.Destroy_TriggerEvents()
        if this.ContainsSelf() then
            call DestroyUbersplat(this.self)
        endif
        call this.deallocate()
    endmethod
    static method Create takes UbersplatType whichType, real x, real y, real red, real green, real blue, real alpha, boolean forcePaused, boolean noBirthTime returns thistype
        local thistype this = thistype.allocate()
        set this.self = null
        set this.selfCreated = false
        call this.Id.Event_Create()
        call this.SetForcePaused(forcePaused)
        call this.SetNoBirthTime(noBirthTime)
        call this.SetType(whichType)
        call this.Color.Event_Create(red, green, blue, alpha)
        call this.Position.Event_Create(x, y)
        call this.Recreate()
        return this
    endmethod
    initMethod Init of Header_5
        set thistype.DESTROY_EVENT_TYPE = EventType.Create()
        call thistype(NULL).Color.Init()
    endmethod
endstruct
    scope FolderTextTag
    public struct StructColor
        implement Allocation
        implement List
        
    real red
    method GetRed takes nothing returns real
        return this.red
    endmethod
    method SetRed takes real value returns nothing
        set this.red = value
    endmethod
    real green
    method GetGreen takes nothing returns real
        return this.green
    endmethod
    method SetGreen takes real value returns nothing
        set this.green = value
    endmethod
    real blue
    method GetBlue takes nothing returns real
        return this.blue
    endmethod
    method SetBlue takes real value returns nothing
        set this.blue = value
    endmethod
    real alpha
    method GetAlpha takes nothing returns real
        return this.alpha
    endmethod
    method SetAlpha takes real value returns nothing
        set this.alpha = value
    endmethod
		method Set takes real red, real green, real blue, real alpha returns nothing
			call this.SetRed(red)
			call this.SetGreen(green)
			call this.SetBlue(blue)
			call this.SetAlpha(alpha)
			if TextTag(this).FadingOut.Is() then
				call SetTextTagColor(TextTag(this).self, Real.ToInt(red), Real.ToInt(green), Real.ToInt(blue), Real.ToInt(TextTag(this).FadingOut.GetAlpha()))
			else
				call SetTextTagColor(TextTag(this).self, Real.ToInt(red), Real.ToInt(green), Real.ToInt(blue), Real.ToInt(alpha))
			endif
		endmethod
		method SetRandomRGB
			call this.Set(Math.Random(0, 255), Math.Random(0, 255), Math.Random(0, 255), this.GetAlpha())
		endmethod
		method Update
			if TextTag(this).FadingOut.Is() then
				call SetTextTagColor(TextTag(this).self, Real.ToInt(red), Real.ToInt(green), Real.ToInt(blue), Real.ToInt(TextTag(this).FadingOut.GetAlpha()))
			else
				call SetTextTagColor(TextTag(this).self, Real.ToInt(red), Real.ToInt(green), Real.ToInt(blue), Real.ToInt(alpha))
			endif
		endmethod
		method Event_Create
			set this.red = 255
			set this.green = 255
			set this.blue = 255
			set this.alpha = 255
		endmethod
	endstruct
    public struct StructPosition
        implement Allocation
        implement List
        
        boolean centered
        real x
        real y
        real z
        method GetX takes nothing returns real
            return this.x
        endmethod
        method SetIgnoreFloor takes real x, real y, real z returns nothing
            if this.centered then
                set x = x - String.Length(TextTag(this).Text.reducedValue) / 2 * 16.5
            endif
            call SetTextTagPos(TextTag(this).self, x, y, z - Spot.GetHeight(x, y))
        endmethod
        method SetX takes real x returns nothing
            set this.x = x
            call this.SetIgnoreFloor(this.x, this.y, z)
        endmethod
        method AddX takes real x returns nothing
            call this.SetX(this.GetX() + x)
        endmethod
        method GetY takes nothing returns real
            return this.y
        endmethod
        method SetY takes real y returns nothing
            set this.y = y
            call this.SetIgnoreFloor(this.x, this.y, z)
        endmethod
        method AddY takes real y returns nothing
            call this.SetY(this.GetY() + y)
        endmethod
        method GetZ takes nothing returns real
            return this.z
        endmethod
        method SetZ takes real z returns nothing
            set this.z = z
            call this.SetIgnoreFloor(this.x, this.y, z)
        endmethod
        method AddZ takes real z returns nothing
            call this.SetZ(this.GetZ() + z)
        endmethod
        method Set takes real x, real y, real z returns nothing
            set this.x = x
            set this.y = y
            set this.z = z
            call this.SetIgnoreFloor(x, y, z)
        endmethod
        method Add takes real x, real y, real z returns nothing
            call this.Set(this.GetX() + x, this.GetY() + y, this.GetZ() + z)
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.x, this.y, this.z)
        endmethod
        method SetCentered takes nothing returns nothing
            set this.centered = true
            call this.Update()
        endmethod
        method Event_Create takes nothing returns nothing
            set this.centered = false
            call this.Set(0., 0., 0.)
        endmethod
    endstruct
    public struct StructText
        implement Allocation
        implement List
        
        real fontSize
        string reducedValue
        string value
        method Set takes string text, real fontSize returns nothing
            set this.fontSize = fontSize
            set this.reducedValue = String.Reduce(text)
            set this.value = text
            call SetTextTagText(TextTag(this).self, text, fontSize)
            call TextTag(this).Position.Update()
        endmethod
        method SetFontSize takes real value returns nothing
            set this.fontSize = value
            call SetTextTagText(TextTag(this).self, this.value, value)
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = ""
        endmethod
    endstruct
    public struct StructCreateJumping
        implement Allocation
        implement List
        
        static constant real DURATION = 1.5
        static constant real FADE_POINT = 0.75
        static constant real FONT_SIZE_FACTOR_BONUS_END = 0.
        static constant real FONT_SIZE_FACTOR_BONUS_PEAK = 0.25
        static constant real FONT_SIZE_FACTOR_START = 1.
        static constant real SPEED = 20.
    static constant real UPDATE_TIME = (1 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (1 * 1.))
        static Timer UPDATE_TIMER
        static constant real Z_BONUS_END = 25.
        static constant real Z_BONUS_PEAK = 100.
        static constant real FONT_SIZE_FACTOR_BONUS_PEAK_PER_DURATION = thistype.FONT_SIZE_FACTOR_BONUS_PEAK / thistype.DURATION
        static constant real Z_BONUS_PEAK_PER_DURATION = thistype.Z_BONUS_PEAK / thistype.DURATION
        static constant real FONT_SIZE_FACTOR_SPEED = 2 / thistype.DURATION * (thistype.FONT_SIZE_FACTOR_BONUS_PEAK + SquareRoot(thistype.FONT_SIZE_FACTOR_BONUS_PEAK * (thistype.FONT_SIZE_FACTOR_BONUS_PEAK - thistype.FONT_SIZE_FACTOR_BONUS_END)))
        static constant real Z_SPEED = 2 / thistype.DURATION * (thistype.Z_BONUS_PEAK + SquareRoot(thistype.Z_BONUS_PEAK * (thistype.Z_BONUS_PEAK - thistype.Z_BONUS_END)))
        static constant real FONT_SIZE_FACTOR_ACCELERATION = -0.5 * thistype.FONT_SIZE_FACTOR_SPEED * thistype.FONT_SIZE_FACTOR_SPEED / thistype.FONT_SIZE_FACTOR_BONUS_PEAK
        static constant real Z_ACCELERATION = -0.5 * thistype.Z_SPEED * thistype.Z_SPEED / thistype.Z_BONUS_PEAK
        Timer durationTimer
        real fontSizeFactor
        real fontSizeFactorAdd
        real fontSizeFactorAddAdd
        real fontSizeStart
        boolean running
        real xAdd
        real yAdd
        real zAdd
        real zAddAdd
        static method Move takes nothing returns nothing
            local integer iteration = thistype.ALL_COUNT
            loop
                local thistype this = thistype.ALL[iteration]
                local real fontSizeFactorAdd = this.fontSizeFactorAdd + this.fontSizeFactorAddAdd
                local real zAdd = this.zAdd + this.zAddAdd
                local real fontSizeFactor = this.fontSizeFactor + fontSizeFactorAdd
                set this.fontSizeFactor = fontSizeFactor
                set this.fontSizeFactorAdd = fontSizeFactorAdd
                set this.zAdd = zAdd
                call TextTag(this).Position.Add(this.xAdd, this.yAdd, zAdd)
                call TextTag(this).Text.SetFontSize(fontSizeFactor * this.fontSizeStart)
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
        endmethod
        method Ending takes Timer durationTimer returns nothing
            set this.running = false
            call durationTimer.Destroy()
            if this.RemoveFromList() then
                call thistype.UPDATE_TIMER.Pause()
            endif
        endmethod
        method Event_Destroy takes nothing returns nothing
            if this.running then
                call this.Ending(this.durationTimer)
            endif
        endmethod
        static method EndingByTimer takes nothing returns nothing
            local Timer durationTimer = Timer.GetExpired()
            local thistype this = durationTimer.GetData()
            call this.Ending(durationTimer)
            call TextTag(this).Destroy()
        endmethod
        static method Create takes string text, real fontSize, real x, real y, real z, integer id returns TextTag
            local TextTag parent = TextTag.Create(id)
            if (parent == NULL) then
                return NULL
            endif
            local real angle = Math.RandomAngle()
            local thistype this = parent
			local Timer durationTimer = Timer.Create()
            set this.fontSizeFactor = thistype.FONT_SIZE_FACTOR_START
            set this.fontSizeFactorAdd = thistype.FONT_SIZE_FACTOR_SPEED * thistype.UPDATE_TIME
            set this.fontSizeFactorAddAdd = thistype.FONT_SIZE_FACTOR_ACCELERATION * thistype.UPDATE_TIME * thistype.UPDATE_TIME
            set this.fontSizeStart = fontSize
            set this.xAdd = Math.Cos(angle) * thistype.SPEED * thistype.UPDATE_TIME
            set this.yAdd = Math.Sin(angle) * thistype.SPEED * thistype.UPDATE_TIME
            set this.zAdd = thistype.Z_SPEED * thistype.UPDATE_TIME
            set this.zAddAdd = thistype.Z_ACCELERATION * thistype.UPDATE_TIME * thistype.UPDATE_TIME
            set this.durationTimer = durationTimer
            set this.running = true
            call durationTimer.SetData(this)
            call parent.Position.Set(x, y, z)
            call parent.Text.Set(text, fontSize)
            if this.AddToList() then
                call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Move)
            endif
            call durationTimer.Start(thistype.DURATION, false, function thistype.EndingByTimer)
            call parent.FadingOut.StartWithDelay(thistype.FADE_POINT, thistype.DURATION)
            return parent
        endmethod
        static method Init takes nothing returns nothing
            set thistype.UPDATE_TIMER = Timer.Create()
        endmethod
    endstruct
    public struct StructCreateMoving
        implement Allocation
        implement List
        
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
        static Timer UPDATE_TIMER
        real bonusXPerInterval
        real bonusYPerInterval
        real bonusZPerInterval
        Timer durationTimer
        boolean running
        static method Move takes nothing returns nothing
            local integer iteration = thistype.ALL_COUNT
            loop
                local thistype this = thistype.ALL[iteration]
                call TextTag(this).Position.Add(this.bonusXPerInterval, this.bonusYPerInterval, this.bonusZPerInterval)
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
        endmethod
        method Ending takes Timer durationTimer returns nothing
            set this.running = false
            call durationTimer.Destroy()
            if this.RemoveFromList() then
                call thistype.UPDATE_TIMER.Pause()
            endif
        endmethod
        method Event_Destroy takes nothing returns nothing
            if this.running then
                call this.Ending(this.durationTimer)
            endif
        endmethod
        static method EndingByTimer takes nothing returns nothing
            local Timer durationTimer = Timer.GetExpired()
            local thistype this = durationTimer.GetData()
            call this.Ending(durationTimer)
            call TextTag(this).Destroy()
        endmethod
        static method Create takes string text, real fontSize, real x, real y, real z, real speedX, real speedY, real speedZ, real fadePoint, real duration, integer id returns TextTag
            if (duration == 0.) then
                return NULL
            endif
            local TextTag parent = TextTag.Create(id)
            if (parent == NULL) then
                return NULL
            endif
            local thistype this = parent
			local Timer durationTimer = Timer.Create()
            set this.bonusXPerInterval = speedX * thistype.UPDATE_TIME
            set this.bonusYPerInterval = speedY * thistype.UPDATE_TIME
            set this.bonusZPerInterval = speedZ * thistype.UPDATE_TIME
            set this.durationTimer = durationTimer
            set this.running = true
            call durationTimer.SetData(this)
            call parent.Position.Set(x, y, z)
            call parent.Text.Set(text, fontSize)
            if this.AddToList() then
                call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Move)
            endif
            call durationTimer.Start(duration, false, function thistype.EndingByTimer)
            call parent.FadingOut.StartWithDelay(fadePoint, duration)
            return parent
        endmethod
        static method Init takes nothing returns nothing
            set thistype.UPDATE_TIMER = Timer.Create()
        endmethod
    endstruct
    public struct StructCreateRising
        implement Allocation
        implement List
        
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
        static Timer UPDATE_TIMER
        real bonusZPerInterval
        Timer durationTimer
        boolean running
        static method Move takes nothing returns nothing
            local integer iteration = thistype.ALL_COUNT
            loop
                local thistype this = thistype.ALL[iteration]
                call TextTag(this).Position.AddZ(this.bonusZPerInterval)
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
        endmethod
        method Ending takes Timer durationTimer returns nothing
            set this.running = false
            call durationTimer.Destroy()
            if this.RemoveFromList() then
                call thistype.UPDATE_TIMER.Pause()
            endif
        endmethod
        method Event_Destroy takes nothing returns nothing
            if this.running then
                call this.Ending(this.durationTimer)
            endif
        endmethod
        static method EndingByTimer takes nothing returns nothing
            local Timer durationTimer = Timer.GetExpired()
            local thistype this = durationTimer.GetData()
            call this.Ending(durationTimer)
            call TextTag(this).Destroy()
        endmethod
        static method Create takes string text, real fontSize, real x, real y, real z, real speedZ, real fadePoint, real duration, integer id returns TextTag
            if (duration == 0.) then
                return NULL
            endif
            local TextTag parent = TextTag.Create(id)
            if (parent == NULL) then
                return NULL
            endif
            local thistype this = parent
			local Timer durationTimer = Timer.Create()
            set this.bonusZPerInterval = speedZ * thistype.UPDATE_TIME
            set this.durationTimer = durationTimer
            set this.running = true
            call durationTimer.SetData(this)
            call parent.Position.Set(x, y, z)
            call parent.Text.Set(text, fontSize)
            if this.AddToList() then
                call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Move)
            endif
            call durationTimer.Start(duration, false, function thistype.EndingByTimer)
            call parent.FadingOut.StartWithDelay(fadePoint, duration)
            return parent
        endmethod
        static method Init takes nothing returns nothing
            set thistype.UPDATE_TIMER = Timer.Create()
        endmethod
    endstruct
    scope FolderFadingOut
    public struct StructDelay
        implement Allocation
        implement List
        
            Timer delayTimer
            real restDuration
            method Ending takes nothing returns nothing
                call this.delayTimer.Destroy()
            endmethod
            static method EndingByTimer takes nothing returns nothing
                local thistype this = Timer.GetExpired().GetData()
                call this.Ending()
                call TextTag(this).FadingOut.Start(this.restDuration)
            endmethod
            method Start takes real delay, real totalDuration returns nothing
                if (delay <= 0.) then
                    call TextTag(this).FadingOut.Start(totalDuration)
                    return
                endif
                local Timer delayTimer = Timer.Create()
                set this.delayTimer = delayTimer
                set this.restDuration = totalDuration - delay
                call delayTimer.SetData(this)
                call delayTimer.Start(delay, false, function thistype.EndingByTimer)
            endmethod
        endstruct
    endscope
    public struct StructFadingOut
        implement Allocation
        implement List
        
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
        static Timer UPDATE_TIMER
        real alphaAdd
        real curAlpha
    FolderFadingOut_StructDelay Delay = this
    FolderFadingOut_StructDelay LinkToStruct_Delay
		method Is returns boolean
			return this.IsInList()
		endmethod
		method GetAlpha returns real
			return this.curAlpha
		endmethod
        static method Update takes nothing returns nothing
            local integer iteration = thistype.ALL_COUNT
            loop
                local thistype this = thistype.ALL[iteration]
                local real newAlpha = this.curAlpha + this.alphaAdd
                set this.curAlpha = newAlpha
                call TextTag(this).Color.Update()
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
        endmethod
        method Ending takes nothing returns nothing
            if this.RemoveFromList() then
                call thistype.UPDATE_TIMER.Pause()
            endif
        endmethod
        method Event_Destroy takes nothing returns nothing
            if this.IsInList() then
                call this.Ending()
            endif
        endmethod
        method Start takes real duration returns nothing
            set this.alphaAdd = -255 / duration * thistype.UPDATE_TIME
            set this.curAlpha = 255
            call SetTextTagPermanent(TextTag(this).self, false)
            if this.AddToList() then
                call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
            endif
        endmethod
        method StartWithDelay takes real delay, real totalDuration returns nothing
            call this.Delay.Start(delay, totalDuration)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.UPDATE_TIMER = Timer.Create()
        endmethod
    endstruct
endscope
    globals
        TextTag TEXT_TAG = STRUCT_BASE
    endglobals
    struct TextTag
        implement Allocation
        implement List
        
    static integer ALL_AMOUNT = 0
    static key GetKeyMacro_PARENT_KEY
    static constant integer PARENT_KEY = Math.Integer.MIN + GetKeyMacro_PARENT_KEY
    static real STANDARD_SIZE = 0.023
    integer id
    texttag self
    FolderTextTag_StructColor Color = this
    FolderTextTag_StructColor LinkToStruct_Color
    FolderTextTag_StructCreateJumping CreateJumping = this
    FolderTextTag_StructCreateJumping LinkToStruct_CreateJumping
    FolderTextTag_StructCreateMoving CreateMoving = this
    FolderTextTag_StructCreateMoving LinkToStruct_CreateMoving
    FolderTextTag_StructCreateRising CreateRising = this
    FolderTextTag_StructCreateRising LinkToStruct_CreateRising
    FolderTextTag_StructFadingOut FadingOut = this
    FolderTextTag_StructFadingOut LinkToStruct_FadingOut
    FolderTextTag_StructPosition Position = this
    FolderTextTag_StructPosition LinkToStruct_Position
    FolderTextTag_StructText Text = this
    FolderTextTag_StructText LinkToStruct_Text
    real value
    method GetValue takes nothing returns real
        return this.value
    endmethod
    method SetValue takes real value returns nothing
        set this.value = value
    endmethod
    static method GetFreeId takes nothing returns integer
        return 0
    endmethod
    static method GetFromId takes integer id returns thistype
        return Memory.IntegerKeys.GetInteger(PARENT_KEY, id)
    endmethod
    method Destroy takes nothing returns nothing
        local integer id = this.id
        local texttag self = this.self
        set thistype.ALL_AMOUNT = thistype.ALL_AMOUNT - 1
        call this.CreateJumping.Event_Destroy()
        call this.CreateMoving.Event_Destroy()
        call this.CreateRising.Event_Destroy()
        call this.FadingOut.Event_Destroy()
        call this.deallocate()
        call DestroyTextTag(self)
        call Memory.IntegerKeys.RemoveInteger(PARENT_KEY, id)
        set self = null
    endmethod
    method LimitTextTagVisibilityToPlayer takes player whichPlayer returns nothing
        call SetTextTagVisibility(this.self, (GetLocalPlayer() == whichPlayer))
    endmethod
    static method Create takes integer id returns thistype
        if ((id != 0) and (Memory.IntegerKeys.GetInteger(PARENT_KEY, id) != NULL)) then
            return NULL
            
        endif
        if (thistype.ALL_AMOUNT == 100) then
            call DebugEx(thistype.Create.name + ": limit exceeded")
            return NULL
        endif
		set thistype.ALL_AMOUNT = thistype.ALL_AMOUNT + 1
        local thistype this = thistype.allocate()
        set this.id = id
        set this.self = CreateTextTag()
        call Memory.IntegerKeys.SetInteger(PARENT_KEY, id, this)
        set this.value = 0.
		call this.Color.Event_Create()
        call this.Text.Event_Create()
        call this.Position.Event_Create()
        return this
    endmethod
    initMethod Init of Header_2
        call thistype(NULL).CreateJumping.Init()
        call thistype(NULL).CreateMoving.Init()
        call thistype(NULL).CreateRising.Init()
        call thistype(NULL).FadingOut.Init()
    endmethod
endstruct
    globals
        TimerDialog TIMER_DIALOG = STRUCT_BASE
    endglobals
    struct TimerDialog
        implement Allocation
        implement List
        
    timerdialog self
    method Destroy takes nothing returns nothing
        local timerdialog self = this.self
        call this.deallocate()
        call DestroyTimerDialog(self)
        set self = null
    endmethod
    method Hide takes nothing returns nothing
        call TimerDialogDisplay(this.self, false)
    endmethod
    method Show takes nothing returns nothing
        call TimerDialogDisplay(this.self, true)
    endmethod
    method SetTitle takes string title returns nothing
        call TimerDialogSetTitle(this.self, title)
    endmethod
    static method CreateFromTimer takes Timer source returns thistype
        local thistype this = thistype.allocate()
        set this.self = CreateTimerDialog(source.self)
        return this
    endmethod
    static method Init takes nothing returns nothing
    endmethod
endstruct
    scope FolderTriggerTimer
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return TriggerTimer(this).Data.table.IntegerKeys.Table.ContainsInteger(TriggerTimer(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return TriggerTimer(this).Data.table.IntegerKeys.Table.CountIntegers(TriggerTimer(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return TriggerTimer(this).Data.table.IntegerKeys.Table.IsEmptyInteger(TriggerTimer(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return TriggerTimer(this).Data.table.IntegerKeys.Table.GetInteger(TriggerTimer(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return TriggerTimer(this).Data.table.IntegerKeys.Table.GetFirstInteger(TriggerTimer(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return TriggerTimer(this).Data.table.IntegerKeys.Table.GetLastInteger(TriggerTimer(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call TriggerTimer(this).Data.table.IntegerKeys.Table.Clear(TriggerTimer(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return TriggerTimer(this).Data.table.IntegerKeys.Table.FetchFirstInteger(TriggerTimer(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return TriggerTimer(this).Data.table.IntegerKeys.Table.RemoveInteger(TriggerTimer(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return TriggerTimer(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(TriggerTimer(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return TriggerTimer(this).Data.table.IntegerKeys.Table.AddInteger(TriggerTimer(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return TriggerTimer(this).Data.table.IntegerKeys.Table.AddIntegerMulti(TriggerTimer(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call TriggerTimer(this).Data.table.IntegerKeys.Table.JoinInteger(TriggerTimer(this).Id.Get(), key, TriggerTimer(other).Data.table, TriggerTimer(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return TriggerTimer(this).Data.table.IntegerKeys.Table.RandomInteger(TriggerTimer(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call TriggerTimer(this).Data.table.IntegerKeys.Table.ShuffleIntegers(TriggerTimer(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call TriggerTimer(this).Data.table.IntegerKeys.Table.PrintIntegers(TriggerTimer(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return TriggerTimer(this).Data.table.IntegerKeys.GetInteger(TriggerTimer(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call TriggerTimer(this).Data.table.IntegerKeys.RemoveInteger(TriggerTimer(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call TriggerTimer(this).Data.table.IntegerKeys.SetInteger(TriggerTimer(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(TriggerTimer(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject TriggerTimer.Allocation.deallocate_demount.hook
		call TriggerTimer(this).Data.Destroy()
	endinject
	inject TriggerTimer.Allocation.allocate_mount.hook
		call TriggerTimer(this).Data.Event_Create()
	endinject
    endstruct
endscope
    globals
        TriggerTimer TRIGGER_TIMER = STRUCT_BASE
    endglobals
    struct TriggerTimer
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    boolean periodic
    timer self
    real timeout
    FolderTriggerTimer_StructData Data = this
    FolderTriggerTimer_StructData LinkToStruct_Data
    FolderTriggerTimer_StructId Id = this
    FolderTriggerTimer_StructId LinkToStruct_Id
    integer data
    method GetData takes nothing returns integer
        return this.data
    endmethod
    method SetData takes integer value returns nothing
        set this.data = value
    endmethod
    static method GetExpired takes nothing returns TriggerTimer
        return Memory.IntegerKeys.GetIntegerByHandle(GetExpiredTimer(), KEY)
    endmethod
    method Pause takes nothing returns nothing
        call PauseTimer(this.self)
    endmethod
    method Destroy takes nothing returns nothing
        local timer self = this.self
        call this.deallocate()
        call this.Pause()
        call DestroyTimer(self)
        set self = null
    endmethod
    method SetPeriodic takes boolean value returns nothing
        set this.periodic = value
    endmethod
    method SetTimeout takes real value returns nothing
        set this.timeout = value
    endmethod
    method Start takes nothing returns nothing
        call TimerStart(this.self, this.timeout, this.periodic, null)
    endmethod
    method Resume takes nothing returns nothing
        call this.Start()
    endmethod
    method AddTrigger takes Trigger whichTrigger returns nothing
        call TriggerRegisterTimerExpireEvent(whichTrigger.self, this.self)
    endmethod
    static method Create takes nothing returns thistype
        local thistype this = thistype.allocate()
		local timer self = CreateTimer()
        set this.self = self
        call Memory.IntegerKeys.SetIntegerByHandle(self, KEY, this)
        set self = null
        call this.Id.Event_Create()
        return this
    endmethod
    static method Init takes nothing returns nothing
    endmethod
endstruct
    scope FolderTimer
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return Timer(this).Data.table.IntegerKeys.Table.ContainsInteger(Timer(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Timer(this).Data.table.IntegerKeys.Table.CountIntegers(Timer(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Timer(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Timer(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Timer(this).Data.table.IntegerKeys.Table.GetInteger(Timer(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Timer(this).Data.table.IntegerKeys.Table.GetFirstInteger(Timer(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Timer(this).Data.table.IntegerKeys.Table.GetLastInteger(Timer(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Timer(this).Data.table.IntegerKeys.Table.Clear(Timer(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Timer(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Timer(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Timer(this).Data.table.IntegerKeys.Table.RemoveInteger(Timer(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Timer(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Timer(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Timer(this).Data.table.IntegerKeys.Table.AddInteger(Timer(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Timer(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Timer(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Timer(this).Data.table.IntegerKeys.Table.JoinInteger(Timer(this).Id.Get(), key, Timer(other).Data.table, Timer(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Timer(this).Data.table.IntegerKeys.Table.RandomInteger(Timer(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Timer(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Timer(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Timer(this).Data.table.IntegerKeys.Table.PrintIntegers(Timer(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return Timer(this).Data.table.IntegerKeys.GetInteger(Timer(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Timer(this).Data.table.IntegerKeys.RemoveInteger(Timer(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Timer(this).Data.table.IntegerKeys.SetInteger(Timer(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Timer(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Timer.Allocation.deallocate_demount.hook
		call Timer(this).Data.Destroy()
	endinject
	inject Timer.Allocation.allocate_mount.hook
		call Timer(this).Data.Event_Create()
	endinject
    endstruct
endscope
    globals
        Timer TIMER = STRUCT_BASE
    endglobals
    struct Timer
        implement Allocation
        implement List
        
    static key KEY
    private static integer QUEUE_SIZE = ARRAY_EMPTY
    private static thistype array QUEUED
    static thistype array RUNNING_LIST_ALL
    static integer RUNNING_LIST_ALL_COUNT = ARRAY_EMPTY
    integer RUNNING_LIST_index
    static method RUNNING_LIST_Count takes nothing returns integer
        return thistype.RUNNING_LIST_ALL_COUNT
    endmethod
    static method RUNNING_LIST_IsEmpty takes nothing returns boolean
        return (thistype.RUNNING_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method RUNNING_LIST_Get takes integer index returns thistype
        return thistype.RUNNING_LIST_ALL[index]
    endmethod
    static method RUNNING_LIST_GetIndex takes thistype this returns integer
        return this.RUNNING_LIST_index
    endmethod
    static method RUNNING_LIST_Contains takes thistype this returns boolean
        return (thistype.RUNNING_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method RUNNING_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.RUNNING_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method RUNNING_LIST_RandomAll takes nothing returns thistype
        return thistype.RUNNING_LIST_Random(ARRAY_MIN, thistype.RUNNING_LIST_ALL_COUNT)
    endmethod
    static method RUNNING_LIST_Remove takes thistype this returns boolean
        if not thistype.RUNNING_LIST_Contains(this) then
            return false
        endif
        set thistype.RUNNING_LIST_ALL[thistype.RUNNING_LIST_ALL_COUNT].RUNNING_LIST_index = this.RUNNING_LIST_index
        set thistype.RUNNING_LIST_ALL[this.RUNNING_LIST_index - 1] = thistype.RUNNING_LIST_ALL[thistype.RUNNING_LIST_ALL_COUNT]
        set this.RUNNING_LIST_index = ARRAY_MIN
        set thistype.RUNNING_LIST_ALL_COUNT = thistype.RUNNING_LIST_ALL_COUNT - 1
        return (thistype.RUNNING_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method RUNNING_LIST_Add takes thistype this returns boolean
        if thistype.RUNNING_LIST_Contains(this) then
            return false
        endif
        set thistype.RUNNING_LIST_ALL_COUNT = thistype.RUNNING_LIST_ALL_COUNT + 1
        set thistype.RUNNING_LIST_ALL[thistype.RUNNING_LIST_ALL_COUNT] = this
        set this.RUNNING_LIST_index = thistype.RUNNING_LIST_ALL_COUNT + 1
        return (thistype.RUNNING_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static thistype array FOR_EACH_RUNNING_LIST_ALL
    static integer FOR_EACH_RUNNING_LIST_ALL_COUNT = ARRAY_EMPTY
    static method FOR_EACH_RUNNING_LIST_FetchFirst takes nothing returns thistype
        local thistype result
        if (thistype.FOR_EACH_RUNNING_LIST_ALL_COUNT < ARRAY_MIN) then
            return NULL
        endif
        set result = thistype.FOR_EACH_RUNNING_LIST_ALL[ARRAY_MIN]
        set thistype.FOR_EACH_RUNNING_LIST_ALL[ARRAY_MIN] = thistype.FOR_EACH_RUNNING_LIST_ALL[thistype.FOR_EACH_RUNNING_LIST_ALL_COUNT]
        set thistype.FOR_EACH_RUNNING_LIST_ALL_COUNT = thistype.FOR_EACH_RUNNING_LIST_ALL_COUNT - 1
        return result
    endmethod
    static method FOR_EACH_RUNNING_LIST_Set takes nothing returns nothing
        local integer iteration = thistype.RUNNING_LIST_ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.FOR_EACH_RUNNING_LIST_ALL[iteration] = thistype.RUNNING_LIST_ALL[iteration]
            set iteration = iteration - 1
        endloop
        set thistype.FOR_EACH_RUNNING_LIST_ALL_COUNT = thistype.RUNNING_LIST_ALL_COUNT
    endmethod
    timer self
    FolderTimer_StructData Data = this
    FolderTimer_StructData LinkToStruct_Data
    FolderTimer_StructId Id = this
    FolderTimer_StructId LinkToStruct_Id
    Trigger action
    method GetAction takes nothing returns Trigger
        return this.action
    endmethod
    method SetAction takes Trigger value returns nothing
        set this.action = value
    endmethod
    integer actionFunc
    method GetActionFunc takes nothing returns integer
        return this.actionFunc
    endmethod
    method SetActionFunc takes integer value returns nothing
        set this.actionFunc = value
    endmethod
    integer data
    method GetData takes nothing returns integer
        return this.data
    endmethod
    method SetData takes integer value returns nothing
        set this.data = value
    endmethod
    string name
    method GetName takes nothing returns string
        return this.name
    endmethod
    method SetName takes string value returns nothing
        set this.name = value
    endmethod
    real timeout
    method GetTimeout takes nothing returns real
        return this.timeout
    endmethod
    method SetTimeout takes real value returns nothing
        set this.timeout = value
    endmethod
    real timeoutMax
    method GetTimeoutMax takes nothing returns real
        return this.timeoutMax
    endmethod
    method SetTimeoutMax takes real value returns nothing
        set this.timeoutMax = value
    endmethod
    real timeoutMin
    method GetTimeoutMin takes nothing returns real
        return this.timeoutMin
    endmethod
    method SetTimeoutMin takes real value returns nothing
        set this.timeoutMin = value
    endmethod
    static method GetFromSelf takes timer self returns thistype
        return Memory.IntegerKeys.GetIntegerByHandle(self, KEY)
    endmethod
    static method GetExpired takes nothing returns thistype
        
        return thistype.GetFromSelf(GetExpiredTimer())
    endmethod
    method GetSelf takes nothing returns timer
        return this.self
    endmethod
    method GetElapsed takes nothing returns real
        return TimerGetElapsed(this.self)
    endmethod
    method GetRemaining takes nothing returns real
        return TimerGetRemaining(this.self)
    endmethod
    method Pause takes nothing returns nothing
        call PauseTimer(this.self)
        call thistype.RUNNING_LIST_Remove(this)
    endmethod
    method Abort takes nothing returns nothing
        call this.Pause()
        call this.SetTimeout(0.)
    endmethod
   
    method Resume takes nothing returns nothing
        call ResumeTimer(this.self)
    endmethod
    method Destroy takes nothing returns nothing
        set thistype.QUEUE_SIZE = thistype.QUEUE_SIZE + 1
        set thistype.QUEUED[thistype.QUEUE_SIZE] = this
        call this.Pause()
    endmethod
    static method RequestRunningList takes nothing returns nothing
        call DebugEx(thistype.NAME + " Request running list:")
        call thistype.FOR_EACH_RUNNING_LIST_Set()
        loop
            local thistype this = thistype.FOR_EACH_RUNNING_LIST_FetchFirst()
            exitwhen (this == NULL)
            call DebugEx(Code.GetNameById(this.GetActionFunc()))
        endloop
        call DebugEx(thistype.NAME + " end of Request running list")
    endmethod
    method Start takes real timeout, boolean periodic, code actionFunction returns nothing
        call this.SetActionFunc(Code.GetId(actionFunction))
        call this.SetName(Code.GetName(actionFunction))
        call this.SetTimeout(timeout)
        call TimerStart(this.self, timeout, periodic, actionFunction)
        if periodic then
            call thistype.RUNNING_LIST_Add(this)
        endif
    endmethod
    static method StartPeriodicRange_Timeout takes nothing returns nothing
        local thistype this = Timer.GetExpired()
        call TimerStart(this.self, Math.Random(this.GetTimeoutMin(), this.GetTimeoutMax()), false, function thistype.StartPeriodicRange_Timeout)
        call this.GetAction().Run()
    endmethod
    method StartPeriodicRange takes real timeoutMin, real timeoutMax, code actionFunction returns nothing
        local real timeout = Math.Random(timeoutMin, timeoutMax)
        call this.SetAction(Trigger.GetFromCode(actionFunction))
        call this.SetActionFunc(Code.GetId(actionFunction))
        call this.SetName(Code.GetName(actionFunction))
        call this.SetTimeout(timeout)
        call this.SetTimeoutMax(timeoutMax)
        call this.SetTimeoutMin(timeoutMin)
        call TimerStart(this.self, timeout, false, function thistype.StartPeriodicRange_Timeout)
        call thistype.RUNNING_LIST_Add(this)
    endmethod
    static method Create takes nothing returns thistype
        local thistype this
        if (thistype.QUEUE_SIZE == ARRAY_EMPTY) then
            set this = thistype.allocate()
			local timer self = CreateTimer()
            
            
            set this.self = self
            call Memory.IntegerKeys.SetIntegerByHandle(self, KEY, this)
            set self = null
            call this.Id.Event_Create()
            return this
        endif
        set this = thistype.QUEUED[thistype.QUEUE_SIZE]
        set thistype.QUEUE_SIZE = thistype.QUEUE_SIZE - 1
		call this.SetName(null)
        call this.SetTimeout(0.)
        return this
    endmethod
    initMethod Init of Header_2
        call TimerDialog.Init()
        call TriggerTimer.Init()
    endmethod
endstruct
    scope FolderTrigger
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    public struct StructBoolean
        implement Allocation
        implement List
        
    method Get takes integer key returns boolean
        return Trigger(this).Data.table.IntegerKeys.GetBoolean(Trigger(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Trigger(this).Data.table.IntegerKeys.RemoveBoolean(Trigger(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call Trigger(this).Data.table.IntegerKeys.SetBoolean(Trigger(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return Trigger(this).Data.table.IntegerKeys.Table.ContainsInteger(Trigger(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Trigger(this).Data.table.IntegerKeys.Table.CountIntegers(Trigger(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Trigger(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Trigger(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Trigger(this).Data.table.IntegerKeys.Table.GetInteger(Trigger(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Trigger(this).Data.table.IntegerKeys.Table.GetFirstInteger(Trigger(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Trigger(this).Data.table.IntegerKeys.Table.GetLastInteger(Trigger(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Trigger(this).Data.table.IntegerKeys.Table.Clear(Trigger(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Trigger(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Trigger(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Trigger(this).Data.table.IntegerKeys.Table.RemoveInteger(Trigger(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Trigger(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Trigger(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Trigger(this).Data.table.IntegerKeys.Table.AddInteger(Trigger(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Trigger(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Trigger(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Trigger(this).Data.table.IntegerKeys.Table.JoinInteger(Trigger(this).Id.Get(), key, Trigger(other).Data.table, Trigger(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Trigger(this).Data.table.IntegerKeys.Table.RandomInteger(Trigger(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Trigger(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Trigger(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Trigger(this).Data.table.IntegerKeys.Table.PrintIntegers(Trigger(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return Trigger(this).Data.table.IntegerKeys.GetInteger(Trigger(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Trigger(this).Data.table.IntegerKeys.RemoveInteger(Trigger(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Trigger(this).Data.table.IntegerKeys.SetInteger(Trigger(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Trigger(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Trigger.Allocation.deallocate_demount.hook
		call Trigger(this).Data.Destroy()
	endinject
	inject Trigger.Allocation.allocate_mount.hook
		call Trigger(this).Data.Event_Create()
	endinject
    endstruct
    scope FolderEvent
    public struct StructNative
        implement Allocation
        implement List
        
            static method GetLearnedSpellId takes nothing returns integer
                return GetLearnedSkill()
            endmethod
            static method GetSpellId takes nothing returns integer
                return GetSpellAbilityId()
            endmethod
            static method GetDamage takes nothing returns real
                return GetEventDamage()
            endmethod
            static method GetTrigger takes nothing returns Trigger
                return Trigger.GetFromSelf(GetTriggeringTrigger())
            endmethod
        endstruct
    endscope
    public struct StructEvent
        implement Allocation
        implement List
        
    FolderEvent_StructNative Native = this
    FolderEvent_StructNative LinkToStruct_Native
    static real DAMAGE = 0.
    static method GetDamage takes nothing returns real
        return thistype.DAMAGE
    endmethod
    static method SetDamage takes real value returns nothing
        set thistype.DAMAGE = value
    endmethod
    endstruct
    public struct StructRegisterEvent
        implement Allocation
        implement List
        
        method DestructableDeath takes Destructable whichDestructable returns nothing
            call TriggerRegisterDeathEvent(Trigger(this).self, whichDestructable.self)
        endmethod
        method Dialog takes Dialog whichDialog returns nothing
            call TriggerRegisterDialogEvent(Trigger(this).self, whichDialog.self)
        endmethod
        method DummyUnit takes DummyUnit whichUnit, unitevent whichUnitEvent returns nothing
            call TriggerRegisterUnitEvent(Trigger(this).self, whichUnit.self, whichUnitEvent)
        endmethod
        method EnterRegion takes Region whichRegion, code whichFilter returns nothing
            call TriggerRegisterEnterRegion(Trigger(this).self, whichRegion.self, Condition(whichFilter))
        endmethod
        method LeaveRegion takes Region whichRegion, code whichFilter returns nothing
            call TriggerRegisterLeaveRegion(Trigger(this).self, whichRegion.self, Condition(whichFilter))
        endmethod
        method User takes User whichPlayer, playerevent whichPlayerEvent returns nothing
            if (whichPlayer == User.ANY) then
                local integer iteration = User.ALL_COUNT
                loop
                    call this.User(User.ALL[iteration], whichPlayerEvent)
                    set iteration = iteration - 1
                    exitwhen (iteration < ARRAY_MIN)
                endloop
            endif
            call TriggerRegisterPlayerEvent(Trigger(this).self, whichPlayer.self, whichPlayerEvent)
        endmethod
        method UserChat takes User whichPlayer, string input, boolean exactMatch returns nothing
            if (whichPlayer == User.ANY) then
                local integer iteration = User.ALL_COUNT
                loop
                    call this.UserChat(User.ALL[iteration], input, exactMatch)
                    set iteration = iteration - 1
                    exitwhen (iteration < ARRAY_MIN)
                endloop
            endif
            call TriggerRegisterPlayerChatEvent(Trigger(this).self, whichPlayer.self, input, exactMatch)
        endmethod
        method PlayerUnit takes User whichPlayer, playerunitevent whichPlayerUnitEvent, code whichFilter returns nothing
            if (whichPlayer == User.ANY) then
                local integer iteration = User.ALL_COUNT
                loop
                    call this.PlayerUnit(User.ALL[iteration], whichPlayerUnitEvent, whichFilter)
                    set iteration = iteration - 1
                    exitwhen (iteration < ARRAY_MIN)
                endloop
            endif
            call TriggerRegisterPlayerUnitEvent(Trigger(this).self, whichPlayer.self, whichPlayerUnitEvent, Condition(whichFilter))
        endmethod
        method Unit takes Unit whichUnit, unitevent whichUnitEvent returns nothing
            call TriggerRegisterUnitEvent(Trigger(this).self, whichUnit.self, whichUnitEvent)
        endmethod
    endstruct
endscope
    globals
        Trigger TRIGGER = STRUCT_BASE
    endglobals
    struct Trigger
        implement Allocation
        implement List
        
    static key GetKeyMacro_CODE_KEY
    static constant integer CODE_KEY = Math.Integer.MIN + GetKeyMacro_CODE_KEY
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static integer RUN_COUNT = 0
    static HashTable TABLE
    static boolexpr TRIG_BOOL_EXPR
    trigger actions
    integer codeId
    string codeNameString
    trigger conditions
    string name
    string nameId
    trigger self
    FolderTrigger_StructData Data = this
    FolderTrigger_StructData LinkToStruct_Data
    FolderTrigger_StructEvent Event = this
    FolderTrigger_StructEvent LinkToStruct_Event
    FolderTrigger_StructId Id = this
    FolderTrigger_StructId LinkToStruct_Id
    FolderTrigger_StructRegisterEvent RegisterEvent = this
    FolderTrigger_StructRegisterEvent LinkToStruct_RegisterEvent
    static method GetFromSelf takes trigger self returns thistype
        return Memory.IntegerKeys.GetIntegerByHandle(self, KEY)
    endmethod
	method GetNameEx takes nothing returns string
		if (this.codeNameString == null) then
			return this.name
		endif
		return this.codeNameString
	endmethod
    method Destroy takes nothing returns nothing
        local trigger self = this.self
        call this.deallocate()
        
        call DisableTrigger(self)
        set self = null
    endmethod
    method Clear takes nothing returns nothing
        
        
    endmethod
    method AddCode takes code value returns nothing
        if (value == null) then
            return
        endif
        set this.actions = CreateTrigger()
        set this.codeId = Code.GetId(value)
        set this.nameId = Integer.ToString(Code.GetId(value))
        if (this.codeNameString != null) then
        	set this.codeNameString = this.codeNameString + ";"
        endif
		set this.codeNameString = this.codeNameString + Code.GetName(value)
        call Memory.IntegerKeys.SetIntegerByHandle(this.actions, KEY, this)
        call TriggerAddCondition(this.actions, Condition(value))
    endmethod
    method AddConditions takes code value returns nothing
        if (value == null) then
            return
        endif
        set this.conditions = CreateTrigger()
        call Memory.IntegerKeys.SetIntegerByHandle(this.conditions, KEY, this)
        call TriggerAddCondition(this.conditions, Condition(value))
    endmethod
    method Disable takes nothing returns nothing
        call DisableTrigger(this.self)
    endmethod
    method Enable takes nothing returns nothing
        call EnableTrigger(this.self)
    endmethod
    method Run takes nothing returns nothing
        set thistype.RUN_COUNT = thistype.RUN_COUNT + 1
		if (this.actions == null) then
			call DebugEx(thistype.NAME + ": no action" + "(" + I2S(this) + ")")
			return
		endif
		if (this.codeId == 0) then
			call DebugEx(thistype.NAME + ": no code" + "(" + I2S(this) + ")")
			return
		endif
		call IncStack(this.codeId)
        if not TriggerEvaluate(this.actions) then
            call DebugEx("trigThread broken: " + this.name + ";" + this.nameId + " (" + this.codeNameString + ")")
        endif
		call DecStack()
    endmethod
    method RunWithParams takes EventResponse params returns nothing
        call EventResponse.SetTrigger(params)
        call this.Run()
    endmethod
    static method Sleep takes real timeOut returns nothing
        call TriggerSleepAction(timeOut)
    endmethod
    static method Trig takes nothing returns nothing
        local thistype this = thistype(NULL).Event.Native.GetTrigger()
        if (this.conditions != null) then
            if not TriggerEvaluate(this.conditions) then
                return
            endif
        endif
        
          
        
        call this.Run()
    endmethod
    static method Create takes nothing returns thistype
        local thistype this = thistype.allocate()
		local trigger self = CreateTrigger()
        set this.actions = null
        set this.codeId = 0
        set this.codeNameString = null
        set this.conditions = null
        set this.name = "default"
        set this.nameId = null
        set this.self = self
        call Memory.IntegerKeys.SetIntegerByHandle(self, KEY, this)
        call this.Id.Event_Create()
        call TriggerAddCondition(self, thistype.TRIG_BOOL_EXPR)
        set self = null
        return this
    endmethod
	static method CreateWithName takes string name returns thistype
		local thistype this = thistype.Create()
		set this.name = name
		return this
	endmethod
    static method CreateFromCode takes code action returns thistype
    	if (action == null) then
            return NULL
        endif
        local thistype this = thistype.CreateWithName(Code.GetName(action))
        call this.AddCode(action)
        return this
    endmethod
    static method GetFromCode takes code action returns thistype
        local integer actionId = Code.GetId(action)
        local thistype this = thistype.TABLE.Integer.Get(actionId, CODE_KEY)
        if (this == HASH_TABLE.Integer.DEFAULT_VALUE) then
            call thistype.TABLE.Integer.Set(actionId, CODE_KEY, this)
            return thistype.CreateFromCode(action)
        endif
        return this
    endmethod
    static key GetKeyMacro_INIT_PARENT_KEY_ARRAY
    static constant integer INIT_PARENT_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_INIT_PARENT_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static hashtable INIT_TABLE = null
    static hashtable INIT_CODE_ID_TABLE = null
    static hashtable INIT_MSG_TABLE = null
    static hashtable INIT_MSG_TABLE2 = null
static boolean objTest=false
    static method ObjInitMsg takes nothing returns nothing
local string s=LoadStr(thistype.INIT_MSG_TABLE, GetHandleId(GetTriggeringTrigger()), 0)
if s!=null then
endif
    endmethod
    static method AddObjectInit takes integer tableKey, code c, string name returns nothing
        local trigger t = CreateTrigger()
        
        call TriggerAddCondition(t, Condition(c))
        if (thistype.INIT_TABLE == null) then
            set thistype.INIT_TABLE = InitHashtable()
            set thistype.INIT_CODE_ID_TABLE = InitHashtable()
            set thistype.INIT_MSG_TABLE = InitHashtable()
            set thistype.INIT_MSG_TABLE2 = InitHashtable()
        endif
        local integer count = LoadInteger(thistype.INIT_TABLE, tableKey, 0) + 1
        call SaveInteger(thistype.INIT_TABLE, tableKey, 0, count)
        call SaveTriggerHandle(thistype.INIT_TABLE, tableKey, count, t)
        call SaveStr(thistype.INIT_MSG_TABLE2, tableKey, count, name)
        call SaveInteger(thistype.INIT_CODE_ID_TABLE, tableKey, count, Code.GetId(c))
        
            
        
    endmethod
    static key GetKeyMacro_INIT_NORMAL_KEY_ARRAY
    static constant integer INIT_NORMAL_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_INIT_NORMAL_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static method AddObjectInitNormal takes code s, string name returns nothing
        call thistype.AddObjectInit(INIT_NORMAL_KEY_ARRAY, s, name)
    endmethod
    static key GetKeyMacro_INIT_NATIVE_KEY_ARRAY
    static constant integer INIT_NATIVE_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_INIT_NATIVE_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static method AddNativeInit takes code s returns nothing
        call thistype.AddObjectInit(INIT_NATIVE_KEY_ARRAY, s, null)
    endmethod
    static integer TABLE_KEY
    static integer ITERATION
    static integer ITERATION_END
    static integer STEP_SIZE
    static method RunObjectInits_Exec_Exec takes nothing returns nothing
        local integer iEnd = Math.MinI(thistype.ITERATION + thistype.STEP_SIZE, thistype.ITERATION_END)
        local integer tableKey = thistype.TABLE_KEY
        loop
            exitwhen (thistype.ITERATION > iEnd)
            local trigger t = LoadTriggerHandle(thistype.INIT_TABLE, tableKey, thistype.ITERATION)
            local integer codeId = LoadInteger(thistype.INIT_CODE_ID_TABLE, tableKey, thistype.ITERATION)
            local string name = LoadStr(thistype.INIT_MSG_TABLE2, tableKey, thistype.ITERATION)
            call Loading.Queue(t, codeId, name)
            set thistype.ITERATION = thistype.ITERATION + 1
        endloop
    endmethod
	static integer MIN
	static integer MAX
    static method RunObjectInits_Exec takes nothing returns nothing
        local integer tableKey = thistype.TABLE_KEY
        local integer count = LoadInteger(thistype.INIT_TABLE, tableKey, 0)
		local ObjThread th = ObjThread.Create("OBJECT INITS " + I2S(tableKey))
        set thistype.ITERATION = thistype.MIN
        set thistype.ITERATION_END = Math.MinI(count, thistype.MAX)
        set thistype.STEP_SIZE = 1500
        loop
            exitwhen (thistype.ITERATION > thistype.ITERATION_END)
            call Code.Run(function thistype.RunObjectInits_Exec_Exec)
        endloop
        call th.Destroy()
    endmethod
    static method RunObjectInits takes integer tableKey returns nothing
        set thistype.TABLE_KEY = tableKey
		set thistype.MIN = 1
		set thistype.MAX = 99999
        call Code.Run(function thistype.RunObjectInits_Exec)
    endmethod
    static method RunObjectInitsLimited takes integer tableKey, integer min, integer max returns nothing
        set thistype.TABLE_KEY = tableKey
		set thistype.MIN = min
		set thistype.MAX = max
        call Code.Run(function thistype.RunObjectInits_Exec)
    endmethod
    initMethod Init of Header_2
        set thistype.TABLE = HashTable.Create()
        set thistype.TRIG_BOOL_EXPR = Condition(function thistype.Trig)
    endmethod
endstruct
    globals
        KnockbackAccelerated KNOCKBACK_ACCELERATED = STRUCT_BASE
    endglobals
    struct KnockbackAccelerated
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static thistype array TARGET_LIST_ALL
    static integer TARGET_LIST_ALL_COUNT = ARRAY_EMPTY
    integer TARGET_LIST_index
    static method TARGET_LIST_Count takes nothing returns integer
        return thistype.TARGET_LIST_ALL_COUNT
    endmethod
    static method TARGET_LIST_IsEmpty takes nothing returns boolean
        return (thistype.TARGET_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method TARGET_LIST_Get takes integer index returns thistype
        return thistype.TARGET_LIST_ALL[index]
    endmethod
    static method TARGET_LIST_GetIndex takes thistype this returns integer
        return this.TARGET_LIST_index
    endmethod
    static method TARGET_LIST_Contains takes thistype this returns boolean
        return (thistype.TARGET_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method TARGET_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.TARGET_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method TARGET_LIST_RandomAll takes nothing returns thistype
        return thistype.TARGET_LIST_Random(ARRAY_MIN, thistype.TARGET_LIST_ALL_COUNT)
    endmethod
    static method TARGET_LIST_Remove takes thistype this returns boolean
        if not thistype.TARGET_LIST_Contains(this) then
            return false
        endif
        set thistype.TARGET_LIST_ALL[thistype.TARGET_LIST_ALL_COUNT].TARGET_LIST_index = this.TARGET_LIST_index
        set thistype.TARGET_LIST_ALL[this.TARGET_LIST_index - 1] = thistype.TARGET_LIST_ALL[thistype.TARGET_LIST_ALL_COUNT]
        set this.TARGET_LIST_index = ARRAY_MIN
        set thistype.TARGET_LIST_ALL_COUNT = thistype.TARGET_LIST_ALL_COUNT - 1
        return (thistype.TARGET_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method TARGET_LIST_Add takes thistype this returns boolean
        if thistype.TARGET_LIST_Contains(this) then
            return false
        endif
        set thistype.TARGET_LIST_ALL_COUNT = thistype.TARGET_LIST_ALL_COUNT + 1
        set thistype.TARGET_LIST_ALL[thistype.TARGET_LIST_ALL_COUNT] = this
        set this.TARGET_LIST_index = thistype.TARGET_LIST_ALL_COUNT + 1
        return (thistype.TARGET_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
	Unit target
	TranslationAccelerated trans
	destroyMethod Destroy
		local Unit target = this.target
		local TranslationAccelerated trans = this.trans
		if target.Data.Integer.Table.Remove(KEY_ARRAY, this) then
			call thistype.TARGET_LIST_Remove(target)
		endif
		call trans.Data.Integer.Remove(KEY)
		call trans.Destroy()
		
		call target.Movement.Add()
	endmethod
	static method Event_TransDestroy takes TranslationAccelerated trans
		local thistype this = trans.Data.Integer.Get(KEY)
		call this.Destroy()
	endmethod
	static method Event_Move takes Unit target, real x, real y returns boolean
		if not thistype.TARGET_LIST_Contains(target) then
			return false
		endif
		if (Spot.GetCliffLevel(x, y) < Spot.GetCliffLevel(target.Position.X.Get(), target.Position.Y.Get())) then
			return false
		endif
		if not SPOT.BlockCheck.DoWithZ(x, y, target.Position.Z.Get()) then
			return false
		endif
        local integer iteration = target.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            local thistype this = target.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            call this.Destroy()
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
		return true
	endmethod
	static method Create takes Unit target, real speed, real acceleration, real angle, real duration returns thistype
		local TranslationAccelerated trans = TranslationAccelerated.CreateSpeedDirection(target, speed, acceleration, angle, duration)
		if (trans == NULL) then
			return NULL
		endif
		local thistype this = thistype.allocate()
		set this.trans = trans
		set this.target = target
		call trans.Data.Integer.Set(KEY, this)
		if target.Data.Integer.Table.Add(KEY_ARRAY, this) then
			call thistype.TARGET_LIST_Add(target)
		endif
		call target.Movement.Subtract()
		return this
	endmethod
	static method Init
	endmethod
endstruct
    globals
        Knockback KNOCKBACK = STRUCT_BASE
    endglobals
    struct Knockback
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static thistype array TARGET_LIST_ALL
    static integer TARGET_LIST_ALL_COUNT = ARRAY_EMPTY
    integer TARGET_LIST_index
    static method TARGET_LIST_Count takes nothing returns integer
        return thistype.TARGET_LIST_ALL_COUNT
    endmethod
    static method TARGET_LIST_IsEmpty takes nothing returns boolean
        return (thistype.TARGET_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method TARGET_LIST_Get takes integer index returns thistype
        return thistype.TARGET_LIST_ALL[index]
    endmethod
    static method TARGET_LIST_GetIndex takes thistype this returns integer
        return this.TARGET_LIST_index
    endmethod
    static method TARGET_LIST_Contains takes thistype this returns boolean
        return (thistype.TARGET_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method TARGET_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.TARGET_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method TARGET_LIST_RandomAll takes nothing returns thistype
        return thistype.TARGET_LIST_Random(ARRAY_MIN, thistype.TARGET_LIST_ALL_COUNT)
    endmethod
    static method TARGET_LIST_Remove takes thistype this returns boolean
        if not thistype.TARGET_LIST_Contains(this) then
            return false
        endif
        set thistype.TARGET_LIST_ALL[thistype.TARGET_LIST_ALL_COUNT].TARGET_LIST_index = this.TARGET_LIST_index
        set thistype.TARGET_LIST_ALL[this.TARGET_LIST_index - 1] = thistype.TARGET_LIST_ALL[thistype.TARGET_LIST_ALL_COUNT]
        set this.TARGET_LIST_index = ARRAY_MIN
        set thistype.TARGET_LIST_ALL_COUNT = thistype.TARGET_LIST_ALL_COUNT - 1
        return (thistype.TARGET_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method TARGET_LIST_Add takes thistype this returns boolean
        if thistype.TARGET_LIST_Contains(this) then
            return false
        endif
        set thistype.TARGET_LIST_ALL_COUNT = thistype.TARGET_LIST_ALL_COUNT + 1
        set thistype.TARGET_LIST_ALL[thistype.TARGET_LIST_ALL_COUNT] = this
        set this.TARGET_LIST_index = thistype.TARGET_LIST_ALL_COUNT + 1
        return (thistype.TARGET_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
	Unit target
	Translation trans
	destroyMethod Destroy
		local Unit target = this.target
		local Translation trans = this.trans
		if target.Data.Integer.Table.Remove(KEY_ARRAY, this) then
			call thistype.TARGET_LIST_Remove(target)
		endif
		call trans.Data.Integer.Remove(KEY)
		call trans.Destroy()
		
		call target.Movement.Add()
	endmethod
	static method Event_TransDestroy takes Translation trans
		local thistype this = trans.Data.Integer.Get(KEY)
		call this.Destroy()
	endmethod
	static method Event_Move takes Unit target, real x, real y returns boolean
		if not thistype.TARGET_LIST_Contains(target) then
			return false
		endif
		if (Spot.GetCliffLevel(x, y) < Spot.GetCliffLevel(target.Position.X.Get(), target.Position.Y.Get())) then
			return false
		endif
		if not SPOT.BlockCheck.DoWithZ(x, y, target.Position.Z.Get()) then
			return false
		endif
        local integer iteration = target.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            local thistype this = target.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            call this.Destroy()
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
		return true
	endmethod
	static method Create takes Unit target, real speed, real angle, real duration returns thistype
		local Translation trans = Translation.CreateSpeedDirection(target, speed, angle, duration)
		if (trans == NULL) then
			return NULL
		endif
		local thistype this = thistype.allocate()
		set this.trans = trans
		set this.target = target
		call trans.Data.Integer.Set(KEY, this)
		if target.Data.Integer.Table.Add(KEY_ARRAY, this) then
			call thistype.TARGET_LIST_Add(target)
		endif
		call target.Movement.Subtract()
		return this
	endmethod
	static method Init
		call KnockbackAccelerated.Init()
	endmethod
endstruct
    globals
        TranslationAccelerated TRANSLATION_ACCELERATED = STRUCT_BASE
    endglobals
    struct TranslationAccelerated
        implement Allocation
        implement List
        
    static Event DEATH_EVENT
    static Event DESTROY_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static constant real UPDATE_TIME = FRAME_UPDATE_TIME * 4
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = 4
    static Timer UPDATE_TIMER
    Timer durationTimer
    Unit target
    real xAdd
    real xAddAdd
    real yAdd
    real yAddAdd
    real zAdd
    real zAddAdd
	struct Id
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
		inject TranslationAccelerated.Allocation.allocate_mount.hook
			call this.Id.Event_Create()
		endinject
	endstruct
	struct Data
		struct Boolean
			struct Table
    method Contains takes integer key, boolean value returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.ContainsBoolean(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.CountBooleans(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.IsEmptyBoolean(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.GetBoolean(TranslationAccelerated(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.GetFirstBoolean(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.GetLastBoolean(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.Table.Clear(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.FetchFirstBoolean(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, boolean value returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.RemoveBoolean(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.RemoveBooleanByIndex(TranslationAccelerated(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, boolean value returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.AddBoolean(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, boolean value returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.AddBooleanMulti(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.Table.JoinBoolean(TranslationAccelerated(this).Id.Get(), key, TranslationAccelerated(other).Data.table, TranslationAccelerated(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.RandomBoolean(TranslationAccelerated(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns boolean
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.Table.ShuffleIntegers(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.Table.PrintBooleans(TranslationAccelerated(this).Id.Get(), key)
    endmethod
			endstruct
    method Get takes integer key returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.GetBoolean(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.RemoveBoolean(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.SetBoolean(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
    method Add takes integer key returns boolean
        local boolean oldValue = this.Get(key)
        call this.Set(key, not HASH_TABLE.Boolean.DEFAULT_VALUE)
        return (oldValue == HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Subtract takes integer key returns boolean
        local boolean oldValue = this.Get(key)
        call this.Set(key, HASH_TABLE.Boolean.DEFAULT_VALUE)
        return (oldValue != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
		endstruct
		struct Integer
			struct Table
    method Contains takes integer key, integer value returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.ContainsInteger(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.CountIntegers(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.IsEmptyInteger(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.GetInteger(TranslationAccelerated(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.GetFirstInteger(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.GetLastInteger(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.Table.Clear(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.FetchFirstInteger(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.RemoveInteger(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(TranslationAccelerated(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.AddInteger(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.AddIntegerMulti(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.Table.JoinInteger(TranslationAccelerated(this).Id.Get(), key, TranslationAccelerated(other).Data.table, TranslationAccelerated(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.RandomInteger(TranslationAccelerated(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.Table.ShuffleIntegers(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.Table.PrintIntegers(TranslationAccelerated(this).Id.Get(), key)
    endmethod
			endstruct
    method Get takes integer key returns integer
        return TranslationAccelerated(this).Data.table.IntegerKeys.GetInteger(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.RemoveInteger(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.SetInteger(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
    method Contains takes integer key returns boolean
        return (this.Get(key) > HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Add takes integer key, integer value returns boolean
        local integer oldValue = this.Get(key)
        call this.Set(key, oldValue + value)
        if (oldValue != HASH_TABLE.Integer.DEFAULT_VALUE) then
            return false
        endif
        return (value != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Subtract takes integer key, integer value returns boolean
        local integer oldValue = this.Get(key)
        set value = (oldValue - value)
        call this.Set(key, value)
        if (oldValue == HASH_TABLE.Integer.DEFAULT_VALUE) then
            return false
        endif
        return (value == HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
		endstruct
		struct Real
			struct Table
    method Contains takes integer key, real value returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.ContainsReal(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.CountReals(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.IsEmptyReal(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns real
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.GetReal(TranslationAccelerated(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns real
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.GetFirstReal(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns real
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.GetLastReal(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.Table.Clear(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns real
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.FetchFirstReal(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, real value returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.RemoveReal(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.RemoveRealByIndex(TranslationAccelerated(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, real value returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.AddReal(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, real value returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.AddRealMulti(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.Table.JoinReal(TranslationAccelerated(this).Id.Get(), key, TranslationAccelerated(other).Data.table, TranslationAccelerated(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns real
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.RandomReal(TranslationAccelerated(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns real
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.Table.ShuffleIntegers(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.Table.PrintReals(TranslationAccelerated(this).Id.Get(), key)
    endmethod
			endstruct
    method Get takes integer key returns real
        return TranslationAccelerated(this).Data.table.IntegerKeys.GetReal(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Real.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.RemoveReal(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Set takes integer key, real value returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.SetReal(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
    method Add takes integer key, real value returns boolean
        local real oldValue = this.Get(key)
        call this.Set(key, oldValue + value)
        if (oldValue != HASH_TABLE.Real.DEFAULT_VALUE) then
            return false
        endif
        return (value != HASH_TABLE.Real.DEFAULT_VALUE)
    endmethod
    method Subtract takes integer key, real value returns boolean
        local real oldValue = this.Get(key)
        set value = (oldValue - value)
        call this.Set(key, value)
        if (oldValue == HASH_TABLE.Real.DEFAULT_VALUE) then
            return false
        endif
        return (value == HASH_TABLE.Real.DEFAULT_VALUE)
    endmethod
		endstruct
		struct String
			struct Table
    method Contains takes integer key, string value returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.ContainsString(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.CountStrings(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.IsEmptyString(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns string
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.GetString(TranslationAccelerated(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns string
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.GetFirstString(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns string
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.GetLastString(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.Table.Clear(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns string
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.FetchFirstString(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, string value returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.RemoveString(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.RemoveStringByIndex(TranslationAccelerated(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, string value returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.AddString(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, string value returns boolean
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.AddStringMulti(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.Table.JoinString(TranslationAccelerated(this).Id.Get(), key, TranslationAccelerated(other).Data.table, TranslationAccelerated(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns string
        return TranslationAccelerated(this).Data.table.IntegerKeys.Table.RandomString(TranslationAccelerated(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns string
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.Table.ShuffleIntegers(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.Table.PrintStrings(TranslationAccelerated(this).Id.Get(), key)
    endmethod
			endstruct
    method Get takes integer key returns string
        return TranslationAccelerated(this).Data.table.IntegerKeys.GetString(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.String.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.RemoveString(TranslationAccelerated(this).Id.Get(), key)
    endmethod
    method Set takes integer key, string value returns nothing
        call TranslationAccelerated(this).Data.table.IntegerKeys.SetString(TranslationAccelerated(this).Id.Get(), key, value)
    endmethod
		endstruct
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(TranslationAccelerated(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject TranslationAccelerated.Allocation.deallocate_demount.hook
		call TranslationAccelerated(this).Data.Destroy()
	endinject
	inject TranslationAccelerated.Allocation.allocate_mount.hook
		call TranslationAccelerated(this).Data.Event_Create()
	endinject
    endstruct
    timerMethod Update
        local integer iteration = thistype.ALL_COUNT
        loop
            local thistype this = thistype.ALL[iteration]
            local Unit target = this.target
            local real xAdd = this.xAdd + this.xAddAdd
            local real yAdd = this.yAdd + this.yAddAdd
            local real zAdd = this.zAdd + this.zAddAdd
            set this.xAdd = xAdd
            set this.yAdd = yAdd
            set this.zAdd = zAdd
            call target.Position.X.Add(xAdd)
            call target.Position.Y.Add(yAdd)
            call target.Position.Z.Add(zAdd)
            set iteration = iteration - 1
            exitwhen (iteration < ARRAY_MIN)
        endloop
    endmethod
    destroyMethod Destroy
    	local Unit target = this.target
        call this.durationTimer.Destroy()
        if target.Data.Integer.Table.Remove(KEY_ARRAY, this) then
            call target.Event.Remove(DEATH_EVENT)
            call target.Event.Remove(DESTROY_EVENT)
        endif
        if this.RemoveFromList() then
            call thistype.UPDATE_TIMER.Pause()
        endif
		
		call target.Position.Nudge()
    endmethod
	static method EndAllOfTarget takes Unit target
        local integer iteration = target.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            local thistype this = target.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            call this.Destroy()
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
	endmethod
    eventMethod Event_Death
		call thistype.EndAllOfTarget(params.Unit.GetTrigger())
    endmethod
    eventMethod Event_Destroy
		call thistype.EndAllOfTarget(params.Unit.GetTrigger())
    endmethod
    timerMethod DestroyByTimer
        local thistype this = Timer.GetExpired().GetData()
        call this.Destroy()
    endmethod
    static method CreateIn takes Unit target, real xAdd, real yAdd, real zAdd, real xAddAdd, real yAddAdd, real zAddAdd, real duration returns thistype
        if not Translation.ValidTarget(target) then
            return NULL
        endif
        local integer wavesAmount = Math.MaxI(1, Real.ToInt(duration / thistype.UPDATE_TIME + 0.5))
        local thistype this = thistype.allocate()
		local Timer durationTimer = Timer.Create()
        set this.durationTimer = durationTimer
        set this.target = target
        set this.xAdd = xAdd / wavesAmount
        set this.xAddAdd = xAddAdd / wavesAmount * thistype.UPDATE_TIME
        set this.yAdd = yAdd / wavesAmount
        set this.yAddAdd = yAddAdd / wavesAmount * thistype.UPDATE_TIME
        set this.zAdd = zAdd / wavesAmount
        set this.zAddAdd = zAddAdd / wavesAmount * thistype.UPDATE_TIME
        call durationTimer.SetData(this)
        if target.Data.Integer.Table.Add(KEY_ARRAY, this) then
            call target.Event.Add(DEATH_EVENT)
            call target.Event.Add(DESTROY_EVENT)
        endif
        if this.AddToList() then
            call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
        endif
        call durationTimer.Start(duration, false, function thistype.DestroyByTimer)
    endmethod
    static method CreateForNoCheck takes Unit target, real xAdd, real yAdd, real zAdd, real xAddAdd, real yAddAdd, real zAddAdd, real duration returns thistype
        local thistype this = thistype.allocate()
		local Timer durationTimer = Timer.Create()
        set this.durationTimer = durationTimer
        set this.target = target
        set this.xAdd = xAdd
        set this.xAddAdd = xAddAdd
        set this.yAdd = yAdd
        set this.yAddAdd = yAddAdd
        set this.zAdd = zAdd
        set this.zAddAdd = zAddAdd
        call durationTimer.SetData(this)
        if target.Data.Integer.Table.Add(KEY_ARRAY, this) then
            call target.Event.Add(DEATH_EVENT)
            call target.Event.Add(DESTROY_EVENT)
        endif
        if this.AddToList() then
            call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
        endif
        call durationTimer.Start(duration, false, function thistype.DestroyByTimer)
		return this
    endmethod
    static method CreateFor takes Unit target, real xAdd, real yAdd, real zAdd, real xAddAdd, real yAddAdd, real zAddAdd, real duration returns thistype
        if not Translation.ValidTarget(target) then
            return NULL
        endif
		return thistype.CreateForNoCheck(target, xAdd, yAdd, zAdd, xAddAdd, yAddAdd, zAddAdd, duration)
    endmethod
    static method CreateForMundane takes Unit target, real xSpeed, real ySpeed, real zSpeed, real xAcc, real yAcc, real zAcc, real duration returns thistype
        if not Translation.ValidTarget(target) then
            return NULL
        endif
		return thistype.CreateForNoCheck(target, xSpeed * thistype.UPDATE_TIME, ySpeed * thistype.UPDATE_TIME, zSpeed * thistype.UPDATE_TIME, xAcc * thistype.UPDATE_TIME * thistype.UPDATE_TIME, yAcc * thistype.UPDATE_TIME * thistype.UPDATE_TIME, zAcc * thistype.UPDATE_TIME * thistype.UPDATE_TIME, duration)
    endmethod
    static method CreateSpeedDirection takes Unit target, real speed, real acceleration, real angle, real duration returns thistype
        local real xPart = Math.Cos(angle)
        local real yPart = Math.Sin(angle)
        set acceleration = acceleration * thistype.UPDATE_TIME * thistype.UPDATE_TIME
        set speed = speed * thistype.UPDATE_TIME
        return thistype.CreateFor(target, speed * xPart, speed * yPart, 0., acceleration * xPart, acceleration * yPart, 0., duration)
    endmethod
    static method Init
        set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Death)
        set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
        set thistype.UPDATE_TIMER = Timer.Create()
    endmethod
endstruct
    globals
        Translation TRANSLATION = STRUCT_BASE
    endglobals
    struct Translation
        implement Allocation
        implement List
        
    static Event DEATH_EVENT
    static Event DESTROY_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static constant real UPDATE_TIME = FRAME_UPDATE_TIME * 4
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = 4
    static Timer UPDATE_TIMER
    Timer durationTimer
    Unit target
    real xAdd
    real yAdd
    real zAdd
	struct Id
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
		inject Translation.Allocation.allocate_mount.hook
			call this.Id.Event_Create()
		endinject
	endstruct
	struct Data
		struct Boolean
			struct Table
    method Contains takes integer key, boolean value returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.ContainsBoolean(Translation(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Translation(this).Data.table.IntegerKeys.Table.CountBooleans(Translation(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.IsEmptyBoolean(Translation(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.GetBoolean(Translation(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.GetFirstBoolean(Translation(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.GetLastBoolean(Translation(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Translation(this).Data.table.IntegerKeys.Table.Clear(Translation(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.FetchFirstBoolean(Translation(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, boolean value returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.RemoveBoolean(Translation(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.RemoveBooleanByIndex(Translation(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, boolean value returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.AddBoolean(Translation(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, boolean value returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.AddBooleanMulti(Translation(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Translation(this).Data.table.IntegerKeys.Table.JoinBoolean(Translation(this).Id.Get(), key, Translation(other).Data.table, Translation(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.RandomBoolean(Translation(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns boolean
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Translation(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Translation(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Translation(this).Data.table.IntegerKeys.Table.PrintBooleans(Translation(this).Id.Get(), key)
    endmethod
			endstruct
    method Get takes integer key returns boolean
        return Translation(this).Data.table.IntegerKeys.GetBoolean(Translation(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Translation(this).Data.table.IntegerKeys.RemoveBoolean(Translation(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call Translation(this).Data.table.IntegerKeys.SetBoolean(Translation(this).Id.Get(), key, value)
    endmethod
    method Add takes integer key returns boolean
        local boolean oldValue = this.Get(key)
        call this.Set(key, not HASH_TABLE.Boolean.DEFAULT_VALUE)
        return (oldValue == HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Subtract takes integer key returns boolean
        local boolean oldValue = this.Get(key)
        call this.Set(key, HASH_TABLE.Boolean.DEFAULT_VALUE)
        return (oldValue != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
		endstruct
		struct Integer
			struct Table
    method Contains takes integer key, integer value returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.ContainsInteger(Translation(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Translation(this).Data.table.IntegerKeys.Table.CountIntegers(Translation(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Translation(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Translation(this).Data.table.IntegerKeys.Table.GetInteger(Translation(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Translation(this).Data.table.IntegerKeys.Table.GetFirstInteger(Translation(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Translation(this).Data.table.IntegerKeys.Table.GetLastInteger(Translation(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Translation(this).Data.table.IntegerKeys.Table.Clear(Translation(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Translation(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Translation(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.RemoveInteger(Translation(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Translation(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.AddInteger(Translation(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Translation(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Translation(this).Data.table.IntegerKeys.Table.JoinInteger(Translation(this).Id.Get(), key, Translation(other).Data.table, Translation(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Translation(this).Data.table.IntegerKeys.Table.RandomInteger(Translation(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Translation(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Translation(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Translation(this).Data.table.IntegerKeys.Table.PrintIntegers(Translation(this).Id.Get(), key)
    endmethod
			endstruct
    method Get takes integer key returns integer
        return Translation(this).Data.table.IntegerKeys.GetInteger(Translation(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Translation(this).Data.table.IntegerKeys.RemoveInteger(Translation(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Translation(this).Data.table.IntegerKeys.SetInteger(Translation(this).Id.Get(), key, value)
    endmethod
    method Contains takes integer key returns boolean
        return (this.Get(key) > HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Add takes integer key, integer value returns boolean
        local integer oldValue = this.Get(key)
        call this.Set(key, oldValue + value)
        if (oldValue != HASH_TABLE.Integer.DEFAULT_VALUE) then
            return false
        endif
        return (value != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Subtract takes integer key, integer value returns boolean
        local integer oldValue = this.Get(key)
        set value = (oldValue - value)
        call this.Set(key, value)
        if (oldValue == HASH_TABLE.Integer.DEFAULT_VALUE) then
            return false
        endif
        return (value == HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
		endstruct
		struct Real
			struct Table
    method Contains takes integer key, real value returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.ContainsReal(Translation(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Translation(this).Data.table.IntegerKeys.Table.CountReals(Translation(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.IsEmptyReal(Translation(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns real
        return Translation(this).Data.table.IntegerKeys.Table.GetReal(Translation(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns real
        return Translation(this).Data.table.IntegerKeys.Table.GetFirstReal(Translation(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns real
        return Translation(this).Data.table.IntegerKeys.Table.GetLastReal(Translation(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Translation(this).Data.table.IntegerKeys.Table.Clear(Translation(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns real
        return Translation(this).Data.table.IntegerKeys.Table.FetchFirstReal(Translation(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, real value returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.RemoveReal(Translation(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.RemoveRealByIndex(Translation(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, real value returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.AddReal(Translation(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, real value returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.AddRealMulti(Translation(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Translation(this).Data.table.IntegerKeys.Table.JoinReal(Translation(this).Id.Get(), key, Translation(other).Data.table, Translation(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns real
        return Translation(this).Data.table.IntegerKeys.Table.RandomReal(Translation(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns real
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Translation(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Translation(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Translation(this).Data.table.IntegerKeys.Table.PrintReals(Translation(this).Id.Get(), key)
    endmethod
			endstruct
    method Get takes integer key returns real
        return Translation(this).Data.table.IntegerKeys.GetReal(Translation(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Real.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Translation(this).Data.table.IntegerKeys.RemoveReal(Translation(this).Id.Get(), key)
    endmethod
    method Set takes integer key, real value returns nothing
        call Translation(this).Data.table.IntegerKeys.SetReal(Translation(this).Id.Get(), key, value)
    endmethod
    method Add takes integer key, real value returns boolean
        local real oldValue = this.Get(key)
        call this.Set(key, oldValue + value)
        if (oldValue != HASH_TABLE.Real.DEFAULT_VALUE) then
            return false
        endif
        return (value != HASH_TABLE.Real.DEFAULT_VALUE)
    endmethod
    method Subtract takes integer key, real value returns boolean
        local real oldValue = this.Get(key)
        set value = (oldValue - value)
        call this.Set(key, value)
        if (oldValue == HASH_TABLE.Real.DEFAULT_VALUE) then
            return false
        endif
        return (value == HASH_TABLE.Real.DEFAULT_VALUE)
    endmethod
		endstruct
		struct String
			struct Table
    method Contains takes integer key, string value returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.ContainsString(Translation(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Translation(this).Data.table.IntegerKeys.Table.CountStrings(Translation(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.IsEmptyString(Translation(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns string
        return Translation(this).Data.table.IntegerKeys.Table.GetString(Translation(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns string
        return Translation(this).Data.table.IntegerKeys.Table.GetFirstString(Translation(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns string
        return Translation(this).Data.table.IntegerKeys.Table.GetLastString(Translation(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Translation(this).Data.table.IntegerKeys.Table.Clear(Translation(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns string
        return Translation(this).Data.table.IntegerKeys.Table.FetchFirstString(Translation(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, string value returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.RemoveString(Translation(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.RemoveStringByIndex(Translation(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, string value returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.AddString(Translation(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, string value returns boolean
        return Translation(this).Data.table.IntegerKeys.Table.AddStringMulti(Translation(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Translation(this).Data.table.IntegerKeys.Table.JoinString(Translation(this).Id.Get(), key, Translation(other).Data.table, Translation(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns string
        return Translation(this).Data.table.IntegerKeys.Table.RandomString(Translation(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns string
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Translation(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Translation(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Translation(this).Data.table.IntegerKeys.Table.PrintStrings(Translation(this).Id.Get(), key)
    endmethod
			endstruct
    method Get takes integer key returns string
        return Translation(this).Data.table.IntegerKeys.GetString(Translation(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.String.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Translation(this).Data.table.IntegerKeys.RemoveString(Translation(this).Id.Get(), key)
    endmethod
    method Set takes integer key, string value returns nothing
        call Translation(this).Data.table.IntegerKeys.SetString(Translation(this).Id.Get(), key, value)
    endmethod
		endstruct
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Translation(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Translation.Allocation.deallocate_demount.hook
		call Translation(this).Data.Destroy()
	endinject
	inject Translation.Allocation.allocate_mount.hook
		call Translation(this).Data.Event_Create()
	endinject
    endstruct
    timerMethod Update
        local integer iteration = thistype.ALL_COUNT
        loop
            local thistype this = thistype.ALL[iteration]
            local Unit target = this.target
            call target.Position.X.Add(this.xAdd)
            call target.Position.Y.Add(this.yAdd)
            call target.Position.Z.Add(this.zAdd)
            set iteration = iteration - 1
            exitwhen (iteration < ARRAY_MIN)
        endloop
    endmethod
    destroyMethod Destroy
    	local Unit target = this.target
        call durationTimer.Destroy()
        if target.Data.Integer.Table.Remove(KEY_ARRAY, this) then
            call target.Event.Remove(DEATH_EVENT)
            call target.Event.Remove(DESTROY_EVENT)
        endif
        if this.RemoveFromList() then
            call thistype.UPDATE_TIMER.Pause()
        endif
		
        call target.Position.Nudge()
    endmethod
	static method EndAllOfTarget takes Unit target
        local integer iteration = target.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            local thistype this = target.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            call this.Destroy()
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
	endmethod
    eventMethod Event_Death
		call thistype.EndAllOfTarget(params.Unit.GetTrigger())
    endmethod
    eventMethod Event_Destroy
		call thistype.EndAllOfTarget(params.Unit.GetTrigger())
    endmethod
    timerMethod DestroyByTimer
        local thistype this = Timer.GetExpired().GetData()
        call this.Destroy()
    endmethod
    static method ValidTarget takes Unit target returns boolean
        if (target.Type.Get().Speed.Get() <= 0.) then
            return false
        endif
        return true
    endmethod
    static method CreateNoCheck takes Unit target, real xAdd, real yAdd, real zAdd, real duration returns thistype
        local integer wavesAmount = Real.ToInt(duration / thistype.UPDATE_TIME)
        local thistype this = thistype.allocate()
		local Timer durationTimer = Timer.Create()
        set this.durationTimer = durationTimer
        set this.target = target
        set this.xAdd = xAdd / wavesAmount
        set this.yAdd = yAdd / wavesAmount
        set this.zAdd = zAdd / wavesAmount
        call durationTimer.SetData(this)
        if target.Data.Integer.Table.Add(KEY_ARRAY, this) then
            call target.Event.Add(DEATH_EVENT)
            call target.Event.Add(DESTROY_EVENT)
        endif
        if this.AddToList() then
            call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
        endif
        call durationTimer.Start(duration, false, function thistype.DestroyByTimer)
		return this
    endmethod
    static method Create takes Unit target, real xAdd, real yAdd, real zAdd, real duration returns thistype
        if not thistype.ValidTarget(target) then
            return NULL
        endif
        return thistype.CreateNoCheck(target, xAdd, yAdd, zAdd, duration)
    endmethod
    static method CreateSpeedDirection takes Unit target, real speed, real angle, real duration returns thistype
        
        return thistype.Create(target, speed * Math.Cos(angle), speed * Math.Sin(angle), 0., duration)
    endmethod
    static method CreateTo takes Unit target, real x, real y, real z, real duration
        call thistype.Create(target, x - target.Position.X.Get(), y - target.Position.Y.Get(), z - target.Position.Z.Get(), duration)
    endmethod
    static method CreateToXY takes Unit target, real x, real y, real duration
        call thistype.CreateTo(target, x, y, Spot.GetHeight(x, y) + target.Position.Z.GetFlyHeight(), duration)
    endmethod
    static method Init
        set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Death)
        set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
        set thistype.UPDATE_TIMER = Timer.Create()
        call TranslationAccelerated.Init()
        call Knockback.Init()
    endmethod
endstruct
    scope FolderBJUnit
    scope FolderArmor
    public struct StructBonus
        implement Allocation
        implement List
        
        method Set takes unit self, real amount, real oldAmount returns nothing
            local integer packet
            local integer packetLevel
			set amount = amount * 1
			set oldAmount = oldAmount * 1
            if (amount * oldAmount <= 0.) then
                if (oldAmount < 0.) then
                    set packetLevel = thistype.DECREASING_SPELLS_MAX
                    loop
                        call UnitRemoveAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        set packetLevel = packetLevel - 1
                        exitwhen (packetLevel < ARRAY_MIN)
                    endloop
                else
                    set packetLevel = thistype.INCREASING_SPELLS_MAX
                    loop
                        call UnitRemoveAbility(self, thistype.INCREASING_SPELLS_ID[packetLevel])
                        set packetLevel = packetLevel - 1
                        exitwhen (packetLevel < ARRAY_MIN)
                    endloop
                endif
                if (amount < 0.) then
                    set amount = -amount
                    set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.DECREASING_SPELLS_MAX)
                    loop
                        exitwhen (amount < 1.)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            call UnitAddAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                else
                    set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.INCREASING_SPELLS_MAX)
                    loop
                        exitwhen (amount < 1.)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            call UnitAddAbility(self, thistype.INCREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                endif
            else
                set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.DECREASING_SPELLS_MAX)
                if (amount < 0.) then
                    set amount = -amount
                    loop
                        exitwhen (packetLevel < ARRAY_MIN)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            call UnitAddAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        else
                            call UnitRemoveAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                else
                    set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.INCREASING_SPELLS_MAX)
                    loop
                        exitwhen (packetLevel < ARRAY_MIN)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            
                        else
                            call UnitRemoveAbility(self, thistype.INCREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                endif
            endif
        endmethod
            static method Init takes nothing returns nothing
            endmethod
        endstruct
    endscope
    public struct StructArmor
        implement Allocation
        implement List
        
    static FolderArmor_StructBonus Bonus = NULL
        static method Init takes nothing returns nothing
            call thistype(NULL).Bonus.Init()
        endmethod
    endstruct
    scope FolderAttack
    scope FolderSpeed
    public struct StructBonusA
        implement Allocation
        implement List
        
        method Set takes unit self, real amount, real oldAmount returns nothing
            local integer packet
            local integer packetLevel
			set amount = amount * 100
			set oldAmount = oldAmount * 100
            if (amount * oldAmount <= 0.) then
                if (oldAmount < 0.) then
                    set packetLevel = thistype.DECREASING_SPELLS_MAX
                    loop
                        call UnitRemoveAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        set packetLevel = packetLevel - 1
                        exitwhen (packetLevel < ARRAY_MIN)
                    endloop
                else
                    set packetLevel = thistype.INCREASING_SPELLS_MAX
                    loop
                        call UnitRemoveAbility(self, thistype.INCREASING_SPELLS_ID[packetLevel])
                        set packetLevel = packetLevel - 1
                        exitwhen (packetLevel < ARRAY_MIN)
                    endloop
                endif
                if (amount < 0.) then
                    set amount = -amount
                    set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.DECREASING_SPELLS_MAX)
                    loop
                        exitwhen (amount < 1.)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            call UnitAddAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                else
                    set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.INCREASING_SPELLS_MAX)
                    loop
                        exitwhen (amount < 1.)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            call UnitAddAbility(self, thistype.INCREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                endif
            else
                set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.DECREASING_SPELLS_MAX)
                if (amount < 0.) then
                    set amount = -amount
                    loop
                        exitwhen (packetLevel < ARRAY_MIN)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            call UnitAddAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        else
                            call UnitRemoveAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                else
                    set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.INCREASING_SPELLS_MAX)
                    loop
                        exitwhen (packetLevel < ARRAY_MIN)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            
                        else
                            call UnitRemoveAbility(self, thistype.INCREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                endif
            endif
        endmethod
                static method Init takes nothing returns nothing
                endmethod
            endstruct
        endscope
    public struct StructSpeed
        implement Allocation
        implement List
        
    static FolderSpeed_StructBonusA BonusA = NULL
            static method Init takes nothing returns nothing
                call thistype(NULL).BonusA.Init()
            endmethod
        endstruct
    endscope
    public struct StructAttack
        implement Allocation
        implement List
        
    static FolderAttack_StructSpeed Speed = NULL
        static method Init takes nothing returns nothing
            call thistype(NULL).Speed.Init()
        endmethod
    endstruct
    scope FolderDamage
    public struct StructBonus
        implement Allocation
        implement List
        
        method Set takes unit self, real amount, real oldAmount returns nothing
            local integer packet
            local integer packetLevel
			set amount = amount * 1
			set oldAmount = oldAmount * 1
            if (amount * oldAmount <= 0.) then
                if (oldAmount < 0.) then
                    set packetLevel = thistype.DECREASING_SPELLS_MAX
                    loop
                        call UnitRemoveAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        set packetLevel = packetLevel - 1
                        exitwhen (packetLevel < ARRAY_MIN)
                    endloop
                else
                    set packetLevel = thistype.INCREASING_SPELLS_MAX
                    loop
                        call UnitRemoveAbility(self, thistype.INCREASING_SPELLS_ID[packetLevel])
                        set packetLevel = packetLevel - 1
                        exitwhen (packetLevel < ARRAY_MIN)
                    endloop
                endif
                if (amount < 0.) then
                    set amount = -amount
                    set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.DECREASING_SPELLS_MAX)
                    loop
                        exitwhen (amount < 1.)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            call UnitAddAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                else
                    set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.INCREASING_SPELLS_MAX)
                    loop
                        exitwhen (amount < 1.)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            call UnitAddAbility(self, thistype.INCREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                endif
            else
                set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.DECREASING_SPELLS_MAX)
                if (amount < 0.) then
                    set amount = -amount
                    loop
                        exitwhen (packetLevel < ARRAY_MIN)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            call UnitAddAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        else
                            call UnitRemoveAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                else
                    set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.INCREASING_SPELLS_MAX)
                    loop
                        exitwhen (packetLevel < ARRAY_MIN)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            
                        else
                            call UnitRemoveAbility(self, thistype.INCREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                endif
            endif
        endmethod
            static method Init takes nothing returns nothing
            endmethod
        endstruct
    endscope
    public struct StructDamage
        implement Allocation
        implement List
        
        static item array DECREASING_ITEMS
        static item array INCREASING_ITEMS
    static FolderDamage_StructBonus Bonus = NULL
        method Add takes unit self, real amount returns nothing
            local boolean hasInventory = (UnitInventorySize(self) > 0)
            local integer packet
            local integer packetLevel
            if not hasInventory then
                call UnitAddAbility(self, Unit.HERO_INVENTORY_SPELL_ID)
            endif
            if (amount < 0) then
                set amount = -amount
                set packetLevel = thistype.DECREASING_ITEMS_MAX
                loop
                    exitwhen (amount < 1)
                    set packet = PACKETS[packetLevel]
                    loop
                        exitwhen (amount < packet)
                        call UnitAddItem(self, thistype.DECREASING_ITEMS[packetLevel])
                        set amount = amount - packet
                    endloop
                    set packetLevel = packetLevel - 1
                endloop
            else
                set packetLevel = thistype.INCREASING_ITEMS_MAX
                loop
                    exitwhen (amount < 1)
                    set packet = thistype.PACKETS[packetLevel]
                    loop
                        exitwhen (amount < packet)
                        call UnitAddItem(self, thistype.INCREASING_ITEMS[packetLevel])
                        set amount = amount - packet
                    endloop
                    set packetLevel = packetLevel - 1
                endloop
            endif
            if not hasInventory then
                call UnitRemoveAbility(self, Unit.HERO_INVENTORY_SPELL_ID)
            endif
        endmethod
        static method Init takes nothing returns nothing
            local integer iteration = thistype.DECREASING_ITEMS_MAX
            loop
                exitwhen (iteration < 0)
                set thistype.DECREASING_ITEMS[iteration] = CreateItem('Idd0' + iteration, 0., 0.)
                set iteration = iteration - 1
            endloop
            set iteration = thistype.INCREASING_ITEMS_MAX
            loop
                exitwhen (iteration < 0)
                set thistype.INCREASING_ITEMS[iteration] = CreateItem('Iid0' + iteration, 0., 0.)
                set iteration = iteration - 1
            endloop
            call thistype(NULL).Bonus.Init()
        endmethod
    endstruct
    public struct StructMovement
        implement Allocation
        implement List
        
    endstruct
    scope FolderHero
    scope FolderAgility
    public struct StructBonusA
        implement Allocation
        implement List
        
        method Set takes unit self, real amount, real oldAmount returns nothing
            local integer packet
            local integer packetLevel
			set amount = amount * 1
			set oldAmount = oldAmount * 1
            if (amount * oldAmount <= 0.) then
                if (oldAmount < 0.) then
                    set packetLevel = thistype.DECREASING_SPELLS_MAX
                    loop
                        call UnitRemoveAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        set packetLevel = packetLevel - 1
                        exitwhen (packetLevel < ARRAY_MIN)
                    endloop
                else
                    set packetLevel = thistype.INCREASING_SPELLS_MAX
                    loop
                        call UnitRemoveAbility(self, thistype.INCREASING_SPELLS_ID[packetLevel])
                        set packetLevel = packetLevel - 1
                        exitwhen (packetLevel < ARRAY_MIN)
                    endloop
                endif
                if (amount < 0.) then
                    set amount = -amount
                    set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.DECREASING_SPELLS_MAX)
                    loop
                        exitwhen (amount < 1.)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            call UnitAddAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                else
                    set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.INCREASING_SPELLS_MAX)
                    loop
                        exitwhen (amount < 1.)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            call UnitAddAbility(self, thistype.INCREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                endif
            else
                set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.DECREASING_SPELLS_MAX)
                if (amount < 0.) then
                    set amount = -amount
                    loop
                        exitwhen (packetLevel < ARRAY_MIN)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            call UnitAddAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        else
                            call UnitRemoveAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                else
                    set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.INCREASING_SPELLS_MAX)
                    loop
                        exitwhen (packetLevel < ARRAY_MIN)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            
                        else
                            call UnitRemoveAbility(self, thistype.INCREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                endif
            endif
        endmethod
	
	            static method Init takes nothing returns nothing
	            endmethod
	        endstruct
		endscope
    public struct StructAgility
        implement Allocation
        implement List
        
    static FolderAgility_StructBonusA BonusA = NULL
			static method Init takes nothing returns nothing
				call thistype.BonusA.Init()
			endmethod
		endstruct
    scope FolderIntelligence
    public struct StructBonusA
        implement Allocation
        implement List
        
        method Set takes unit self, real amount, real oldAmount returns nothing
            local integer packet
            local integer packetLevel
			set amount = amount * 1
			set oldAmount = oldAmount * 1
            if (amount * oldAmount <= 0.) then
                if (oldAmount < 0.) then
                    set packetLevel = thistype.DECREASING_SPELLS_MAX
                    loop
                        call UnitRemoveAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        set packetLevel = packetLevel - 1
                        exitwhen (packetLevel < ARRAY_MIN)
                    endloop
                else
                    set packetLevel = thistype.INCREASING_SPELLS_MAX
                    loop
                        call UnitRemoveAbility(self, thistype.INCREASING_SPELLS_ID[packetLevel])
                        set packetLevel = packetLevel - 1
                        exitwhen (packetLevel < ARRAY_MIN)
                    endloop
                endif
                if (amount < 0.) then
                    set amount = -amount
                    set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.DECREASING_SPELLS_MAX)
                    loop
                        exitwhen (amount < 1.)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            call UnitAddAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                else
                    set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.INCREASING_SPELLS_MAX)
                    loop
                        exitwhen (amount < 1.)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            call UnitAddAbility(self, thistype.INCREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                endif
            else
                set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.DECREASING_SPELLS_MAX)
                if (amount < 0.) then
                    set amount = -amount
                    loop
                        exitwhen (packetLevel < ARRAY_MIN)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            call UnitAddAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        else
                            call UnitRemoveAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                else
                    set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.INCREASING_SPELLS_MAX)
                    loop
                        exitwhen (packetLevel < ARRAY_MIN)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            
                        else
                            call UnitRemoveAbility(self, thistype.INCREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                endif
            endif
        endmethod
	
	            static method Init takes nothing returns nothing
	            endmethod
	        endstruct
		endscope
    public struct StructIntelligence
        implement Allocation
        implement List
        
    static FolderIntelligence_StructBonusA BonusA = NULL
			static method Init takes nothing returns nothing
				call thistype.BonusA.Init()
			endmethod
		endstruct
    scope FolderStrength
    public struct StructBonusA
        implement Allocation
        implement List
        
        method Set takes unit self, real amount, real oldAmount returns nothing
            local integer packet
            local integer packetLevel
			set amount = amount * 1
			set oldAmount = oldAmount * 1
            if (amount * oldAmount <= 0.) then
                if (oldAmount < 0.) then
                    set packetLevel = thistype.DECREASING_SPELLS_MAX
                    loop
                        call UnitRemoveAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        set packetLevel = packetLevel - 1
                        exitwhen (packetLevel < ARRAY_MIN)
                    endloop
                else
                    set packetLevel = thistype.INCREASING_SPELLS_MAX
                    loop
                        call UnitRemoveAbility(self, thistype.INCREASING_SPELLS_ID[packetLevel])
                        set packetLevel = packetLevel - 1
                        exitwhen (packetLevel < ARRAY_MIN)
                    endloop
                endif
                if (amount < 0.) then
                    set amount = -amount
                    set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.DECREASING_SPELLS_MAX)
                    loop
                        exitwhen (amount < 1.)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            call UnitAddAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                else
                    set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.INCREASING_SPELLS_MAX)
                    loop
                        exitwhen (amount < 1.)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            call UnitAddAbility(self, thistype.INCREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                endif
            else
                set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.DECREASING_SPELLS_MAX)
                if (amount < 0.) then
                    set amount = -amount
                    loop
                        exitwhen (packetLevel < ARRAY_MIN)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            call UnitAddAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        else
                            call UnitRemoveAbility(self, thistype.DECREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                else
                    set packetLevel = Math.MinI(Math.LogOf2I(Real.ToInt(Math.Max(Math.Abs(oldAmount), Math.Abs(amount)))), thistype.INCREASING_SPELLS_MAX)
                    loop
                        exitwhen (packetLevel < ARRAY_MIN)
                        set packet = thistype.PACKETS[packetLevel]
                        if (packet <= amount) then
                            set amount = amount - packet
                            
                        else
                            call UnitRemoveAbility(self, thistype.INCREASING_SPELLS_ID[packetLevel])
                        endif
                        set packetLevel = packetLevel - 1
                    endloop
                endif
            endif
        endmethod
	
	            static method Init takes nothing returns nothing
	            endmethod
	        endstruct
		endscope
    public struct StructStrength
        implement Allocation
        implement List
        
    static FolderStrength_StructBonusA BonusA = NULL
			static method Init takes nothing returns nothing
				call thistype.BonusA.Init()
			endmethod
		endstruct
	endscope
    public struct StructHero
        implement Allocation
        implement List
        
    static FolderHero_StructAgility Agility = NULL
    static FolderHero_StructIntelligence Intelligence = NULL
    static FolderHero_StructStrength Strength = NULL
		static method Init takes nothing returns nothing
			call thistype.Agility.Init()
			call thistype.Intelligence.Init()
			call thistype.Strength.Init()
		endmethod
    endstruct
endscope
    struct BJUnit
    static FolderBJUnit_StructArmor Armor = NULL
    static FolderBJUnit_StructAttack Attack = NULL
    static FolderBJUnit_StructDamage Damage = NULL
    static FolderBJUnit_StructHero Hero = NULL
    static FolderBJUnit_StructMovement Movement = NULL
    static method Init takes nothing returns nothing
        call thistype(NULL).Armor.Init()
        call thistype(NULL).Attack.Init()
        call thistype(NULL).Damage.Init()
        call thistype(NULL).Hero.Init()
    endmethod
endstruct
    globals
        UnitAttackSplash UNIT_ATTACK_SPLASH = STRUCT_BASE
    endglobals
    struct UnitAttackSplash
        implement Allocation
        implement List
        
    real areaRange
    method GetAreaRange takes nothing returns real
        return this.areaRange
    endmethod
    method SetAreaRange takes real value returns nothing
        set this.areaRange = value
    endmethod
    real damageFactor
    method GetDamageFactor takes nothing returns real
        return this.damageFactor
    endmethod
    method SetDamageFactor takes real value returns nothing
        set this.damageFactor = value
    endmethod
    method Destroy takes nothing returns nothing
        call this.deallocate()
    endmethod
    static method Create takes real areaRange, real damageFactor returns thistype
        local thistype this = thistype.allocate()
        set this.areaRange = areaRange
        set this.damageFactor = damageFactor
        return this
    endmethod
endstruct
    scope FolderUnitClass
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return UnitClass(this).Data.table.IntegerKeys.Table.ContainsInteger(UnitClass(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return UnitClass(this).Data.table.IntegerKeys.Table.CountIntegers(UnitClass(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return UnitClass(this).Data.table.IntegerKeys.Table.IsEmptyInteger(UnitClass(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return UnitClass(this).Data.table.IntegerKeys.Table.GetInteger(UnitClass(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return UnitClass(this).Data.table.IntegerKeys.Table.GetFirstInteger(UnitClass(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return UnitClass(this).Data.table.IntegerKeys.Table.GetLastInteger(UnitClass(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call UnitClass(this).Data.table.IntegerKeys.Table.Clear(UnitClass(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return UnitClass(this).Data.table.IntegerKeys.Table.FetchFirstInteger(UnitClass(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return UnitClass(this).Data.table.IntegerKeys.Table.RemoveInteger(UnitClass(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return UnitClass(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(UnitClass(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return UnitClass(this).Data.table.IntegerKeys.Table.AddInteger(UnitClass(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return UnitClass(this).Data.table.IntegerKeys.Table.AddIntegerMulti(UnitClass(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call UnitClass(this).Data.table.IntegerKeys.Table.JoinInteger(UnitClass(this).Id.Get(), key, UnitClass(other).Data.table, UnitClass(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return UnitClass(this).Data.table.IntegerKeys.Table.RandomInteger(UnitClass(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call UnitClass(this).Data.table.IntegerKeys.Table.ShuffleIntegers(UnitClass(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call UnitClass(this).Data.table.IntegerKeys.Table.PrintIntegers(UnitClass(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return UnitClass(this).Data.table.IntegerKeys.GetInteger(UnitClass(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call UnitClass(this).Data.table.IntegerKeys.RemoveInteger(UnitClass(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call UnitClass(this).Data.table.IntegerKeys.SetInteger(UnitClass(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(UnitClass(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject UnitClass.Allocation.deallocate_demount.hook
		call UnitClass(this).Data.Destroy()
	endinject
	inject UnitClass.Allocation.allocate_mount.hook
		call UnitClass(this).Data.Event_Create()
	endinject
    endstruct
endscope
    globals
        UnitClass UNIT_CLASS = STRUCT_BASE
    endglobals
    struct UnitClass
        implement Allocation
        implement List
        
    static thistype AIR
    static thistype DEAD
    static thistype GROUND
    static thistype HERO
    static thistype ILLUSION
    static thistype MECHANICAL
    static thistype NEUTRAL
    static thistype STRUCTURE
    static thistype SUMMON
    static thistype UNDECAYABLE
    static thistype UPGRADED
    static thistype WARD
    string name
    method GetName takes nothing returns string
        return this.name
    endmethod
    method SetName takes string value returns nothing
        set this.name = value
    endmethod
    FolderUnitClass_StructData Data = this
    FolderUnitClass_StructData LinkToStruct_Data
    FolderUnitClass_StructId Id = this
    FolderUnitClass_StructId LinkToStruct_Id
    static method Create takes string name returns thistype
        local thistype this = thistype.allocate()
        call this.SetName(name)
        call this.AddToList()
        call this.Id.Event_Create()
        return this
    endmethod
    static method Init takes nothing returns nothing
        set thistype.AIR = thistype.Create("air")
        set thistype.DEAD = thistype.Create("dead")
        set thistype.GROUND = thistype.Create("ground")
        set thistype.HERO = thistype.Create("hero")
        set thistype.ILLUSION = thistype.Create("illusion")
        set thistype.MECHANICAL = thistype.Create("mechanical")
        set thistype.NEUTRAL = thistype.Create("neutral")
        set thistype.STRUCTURE = thistype.Create("structure")
        set thistype.SUMMON = thistype.Create("summon")
        set thistype.UNDECAYABLE = thistype.Create("undecayable")
        set thistype.UPGRADED = thistype.Create("upgraded")
        set thistype.WARD = thistype.Create("ward")
    endmethod
endstruct
    scope FolderUnitTypePool
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return UnitTypePool(this).Data.table.IntegerKeys.Table.ContainsInteger(UnitTypePool(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return UnitTypePool(this).Data.table.IntegerKeys.Table.CountIntegers(UnitTypePool(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return UnitTypePool(this).Data.table.IntegerKeys.Table.IsEmptyInteger(UnitTypePool(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return UnitTypePool(this).Data.table.IntegerKeys.Table.GetInteger(UnitTypePool(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return UnitTypePool(this).Data.table.IntegerKeys.Table.GetFirstInteger(UnitTypePool(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return UnitTypePool(this).Data.table.IntegerKeys.Table.GetLastInteger(UnitTypePool(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call UnitTypePool(this).Data.table.IntegerKeys.Table.Clear(UnitTypePool(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return UnitTypePool(this).Data.table.IntegerKeys.Table.FetchFirstInteger(UnitTypePool(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return UnitTypePool(this).Data.table.IntegerKeys.Table.RemoveInteger(UnitTypePool(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return UnitTypePool(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(UnitTypePool(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return UnitTypePool(this).Data.table.IntegerKeys.Table.AddInteger(UnitTypePool(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return UnitTypePool(this).Data.table.IntegerKeys.Table.AddIntegerMulti(UnitTypePool(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call UnitTypePool(this).Data.table.IntegerKeys.Table.JoinInteger(UnitTypePool(this).Id.Get(), key, UnitTypePool(other).Data.table, UnitTypePool(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return UnitTypePool(this).Data.table.IntegerKeys.Table.RandomInteger(UnitTypePool(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call UnitTypePool(this).Data.table.IntegerKeys.Table.ShuffleIntegers(UnitTypePool(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call UnitTypePool(this).Data.table.IntegerKeys.Table.PrintIntegers(UnitTypePool(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return UnitTypePool(this).Data.table.IntegerKeys.GetInteger(UnitTypePool(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call UnitTypePool(this).Data.table.IntegerKeys.RemoveInteger(UnitTypePool(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call UnitTypePool(this).Data.table.IntegerKeys.SetInteger(UnitTypePool(this).Id.Get(), key, value)
    endmethod
        endstruct
    public struct StructReal
        implement Allocation
        implement List
        
    method Get takes integer key returns real
        return UnitTypePool(this).Data.table.IntegerKeys.GetReal(UnitTypePool(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Real.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call UnitTypePool(this).Data.table.IntegerKeys.RemoveReal(UnitTypePool(this).Id.Get(), key)
    endmethod
    method Set takes integer key, real value returns nothing
        call UnitTypePool(this).Data.table.IntegerKeys.SetReal(UnitTypePool(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
    FolderData_StructReal Real = this
    FolderData_StructReal LinkToStruct_Real
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(UnitTypePool(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject UnitTypePool.Allocation.deallocate_demount.hook
		call UnitTypePool(this).Data.Destroy()
	endinject
	inject UnitTypePool.Allocation.allocate_mount.hook
		call UnitTypePool(this).Data.Event_Create()
	endinject
    endstruct
endscope
    globals
        UnitTypePool UNIT_TYPE_POOL = STRUCT_BASE
    endglobals
    struct UnitTypePool
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_WEIGHT_KEY_ARRAY_DETAIL
    static constant integer WEIGHT_KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_WEIGHT_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    real weightAll
    FolderUnitTypePool_StructData Data = this
    FolderUnitTypePool_StructData LinkToStruct_Data
    FolderUnitTypePool_StructId Id = this
    FolderUnitTypePool_StructId LinkToStruct_Id
    method Random takes nothing returns UnitType
        local integer iteration = Memory.IntegerKeys.Table.STARTED
        local real random = Math.Random(0., this.weightAll)
        local real typeRandom = 0.
        local UnitType whichType
        loop
            set whichType = this.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            set typeRandom = typeRandom + this.Data.Real.Get(WEIGHT_KEY_ARRAY_DETAIL + whichType)
            exitwhen (random <= typeRandom)
            set iteration = iteration + 1
        endloop
        return whichType
    endmethod
    method AddType takes UnitType whichType, real weight returns nothing
        set this.weightAll = this.weightAll + weight
        call this.Data.Integer.Table.Add(KEY_ARRAY, whichType)
        call this.Data.Real.Set(WEIGHT_KEY_ARRAY_DETAIL + whichType, weight)
    endmethod
    static method Create takes nothing returns thistype
        local thistype this = thistype.allocate()
        set this.weightAll = 0.
        call this.Id.Event_Create()
        return this
    endmethod
    static method Init takes nothing returns nothing
    endmethod
endstruct
    scope FolderUnit
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_PARENT_KEY_ARRAY
    static constant integer PARENT_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_PARENT_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        static method GetParent takes integer value returns Unit
            return Memory.IntegerKeys.GetInteger(PARENT_KEY_ARRAY + value, KEY)
        endmethod
        method Event_Create takes nothing returns nothing
            local integer value = GetHandleId(Unit(this).self)
            call this.Set(value)
            call Memory.IntegerKeys.SetInteger(PARENT_KEY_ARRAY + value, KEY, this)
        endmethod
    endstruct
    scope FolderData
    public struct StructBoolean
        implement Allocation
        implement List
        
    method Get takes integer key returns boolean
        return Unit(this).Data.table.IntegerKeys.GetBoolean(Unit(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Unit(this).Data.table.IntegerKeys.RemoveBoolean(Unit(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call Unit(this).Data.table.IntegerKeys.SetBoolean(Unit(this).Id.Get(), key, value)
    endmethod
    method Add takes integer key returns boolean
        local boolean oldValue = this.Get(key)
        call this.Set(key, not HASH_TABLE.Boolean.DEFAULT_VALUE)
        return (oldValue == HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Subtract takes integer key returns boolean
        local boolean oldValue = this.Get(key)
        call this.Set(key, HASH_TABLE.Boolean.DEFAULT_VALUE)
        return (oldValue != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
        endstruct
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return Unit(this).Data.table.IntegerKeys.Table.ContainsInteger(Unit(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Unit(this).Data.table.IntegerKeys.Table.CountIntegers(Unit(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Unit(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Unit(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Unit(this).Data.table.IntegerKeys.Table.GetInteger(Unit(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Unit(this).Data.table.IntegerKeys.Table.GetFirstInteger(Unit(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Unit(this).Data.table.IntegerKeys.Table.GetLastInteger(Unit(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Unit(this).Data.table.IntegerKeys.Table.Clear(Unit(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Unit(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Unit(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Unit(this).Data.table.IntegerKeys.Table.RemoveInteger(Unit(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Unit(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Unit(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Unit(this).Data.table.IntegerKeys.Table.AddInteger(Unit(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Unit(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Unit(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Unit(this).Data.table.IntegerKeys.Table.JoinInteger(Unit(this).Id.Get(), key, Unit(other).Data.table, Unit(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Unit(this).Data.table.IntegerKeys.Table.RandomInteger(Unit(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Unit(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Unit(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Unit(this).Data.table.IntegerKeys.Table.PrintIntegers(Unit(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return Unit(this).Data.table.IntegerKeys.GetInteger(Unit(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Unit(this).Data.table.IntegerKeys.RemoveInteger(Unit(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Unit(this).Data.table.IntegerKeys.SetInteger(Unit(this).Id.Get(), key, value)
    endmethod
    method Contains takes integer key returns boolean
        return (this.Get(key) > HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Add takes integer key, integer value returns boolean
        local integer oldValue = this.Get(key)
        call this.Set(key, oldValue + value)
        if (oldValue != HASH_TABLE.Integer.DEFAULT_VALUE) then
            return false
        endif
        return (value != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Subtract takes integer key, integer value returns boolean
        local integer oldValue = this.Get(key)
        set value = (oldValue - value)
        call this.Set(key, value)
        if (oldValue == HASH_TABLE.Integer.DEFAULT_VALUE) then
            return false
        endif
        return (value == HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
        endstruct
    scope FolderReal
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, real value returns boolean
        return Unit(this).Data.table.IntegerKeys.Table.ContainsReal(Unit(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Unit(this).Data.table.IntegerKeys.Table.CountReals(Unit(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Unit(this).Data.table.IntegerKeys.Table.IsEmptyReal(Unit(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns real
        return Unit(this).Data.table.IntegerKeys.Table.GetReal(Unit(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns real
        return Unit(this).Data.table.IntegerKeys.Table.GetFirstReal(Unit(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns real
        return Unit(this).Data.table.IntegerKeys.Table.GetLastReal(Unit(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Unit(this).Data.table.IntegerKeys.Table.Clear(Unit(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns real
        return Unit(this).Data.table.IntegerKeys.Table.FetchFirstReal(Unit(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, real value returns boolean
        return Unit(this).Data.table.IntegerKeys.Table.RemoveReal(Unit(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Unit(this).Data.table.IntegerKeys.Table.RemoveRealByIndex(Unit(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, real value returns boolean
        return Unit(this).Data.table.IntegerKeys.Table.AddReal(Unit(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, real value returns boolean
        return Unit(this).Data.table.IntegerKeys.Table.AddRealMulti(Unit(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Unit(this).Data.table.IntegerKeys.Table.JoinReal(Unit(this).Id.Get(), key, Unit(other).Data.table, Unit(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns real
        return Unit(this).Data.table.IntegerKeys.Table.RandomReal(Unit(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns real
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Unit(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Unit(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Unit(this).Data.table.IntegerKeys.Table.PrintReals(Unit(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructReal
        implement Allocation
        implement List
        
    FolderReal_StructTable Table = this
    FolderReal_StructTable LinkToStruct_Table
    method Get takes integer key returns real
        return Unit(this).Data.table.IntegerKeys.GetReal(Unit(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Real.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Unit(this).Data.table.IntegerKeys.RemoveReal(Unit(this).Id.Get(), key)
    endmethod
    method Set takes integer key, real value returns nothing
        call Unit(this).Data.table.IntegerKeys.SetReal(Unit(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
    FolderData_StructReal Real = this
    FolderData_StructReal LinkToStruct_Real
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Unit(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Unit.Allocation.deallocate_demount.hook
		call Unit(this).Data.Destroy()
	endinject
	inject Unit.Allocation.allocate_mount.hook
		call Unit(this).Data.Event_Create()
	endinject
    endstruct
    scope FolderEvent
    public struct StructCombination
        implement Allocation
        implement List
        
            method Remove takes EventCombination whichCombination returns nothing
                local integer iteration = whichCombination.Events.Count()
                loop
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    call Unit(this).Event.Remove(whichCombination.Events.Get(iteration))
                    set iteration = iteration - 1
                endloop
                set iteration = whichCombination.Pairs.Count()
                loop
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    local EventPair thisPair = whichCombination.Pairs.Get(iteration)
                    call Unit(this).Event.Remove(thisPair.GetNegativeEvent())
                    call Unit(this).Event.Remove(thisPair.GetPositiveEvent())
                    set iteration = iteration - 1
                endloop
                call whichCombination.Subjects.Remove(Unit(this).Id.Get())
            endmethod
            method Add takes EventCombination whichCombination returns nothing
                local integer iteration = whichCombination.Events.Count()
                loop
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    call Unit(this).Event.Add(whichCombination.Events.Get(iteration))
                    set iteration = iteration - 1
                endloop
                set iteration = whichCombination.Pairs.Count()
                loop
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    local EventPair thisPair = whichCombination.Pairs.Get(iteration)
                    call Unit(this).Event.Add(thisPair.GetNegativeEvent())
                    call Unit(this).Event.Add(thisPair.GetPositiveEvent())
                    set iteration = iteration - 1
                endloop
                call whichCombination.Subjects.Add(Unit(this).Id.Get())
            endmethod
        endstruct
    public struct StructCounted
        implement Allocation
        implement List
        
            static Event DESTROY_EVENT
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
            method Ending takes Event whichEvent, boolean byDestroy returns nothing
                if byDestroy then
                    call Unit(this).Data.Integer.Remove(KEY_ARRAY_DETAIL + whichEvent)
                endif
                if Unit(this).Data.Integer.Table.Remove(KEY_ARRAY, whichEvent) then
                    call Unit(this).Event.Remove(DESTROY_EVENT)
                endif
                call Unit(this).Event.Remove(whichEvent)
            endmethod
            method Subtract takes Event whichEvent returns nothing
                if Unit(this).Data.Integer.Subtract(KEY_ARRAY_DETAIL + whichEvent, 1) then
                    call this.Ending(whichEvent, false)
                endif
            endmethod
            eventMethod Event_Destroy
                local thistype parentThis = params.Unit.GetTrigger()
                loop
                    local Event whichEvent = Unit(parentThis).Data.Integer.Table.GetFirst(KEY_ARRAY)
                    exitwhen (whichEvent == NULL)
                    call parentThis.Ending(whichEvent, true)
                endloop
            endmethod
            method Add takes Event whichEvent returns nothing
                if Unit(this).Data.Integer.Add(KEY_ARRAY_DETAIL + whichEvent, 1) then
                    if Unit(this).Data.Integer.Table.Add(KEY_ARRAY, whichEvent) then
                        call Unit(this).Event.Add(DESTROY_EVENT)
                    endif
                    call Unit(this).Event.Add(whichEvent)
                endif
            endmethod
            static method Init takes nothing returns nothing
                set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
            endmethod
        endstruct
        function GetAttacker_Wrapped takes nothing returns unit
            return GetAttacker()
        endfunction
    public struct StructNative
        implement Allocation
        implement List
        
                static method GetAcquiredTarget takes nothing returns Unit
                    local unit self = GetEventTargetUnit()
                    if (GetUnitAbilityLevel(self, DummyUnit.LOCUST_SPELL_ID) > 0) then
                        set self = null
                        return STRUCT_INVALID
                    endif
                    local Unit result = Unit.GetFromSelf(self)
                    set self = null
                    return result
                endmethod
                static method GetAttacker takes nothing returns Unit
                    local unit self = GetAttacker_Wrapped()
                    if (GetUnitAbilityLevel(self, DummyUnit.LOCUST_SPELL_ID) > 0) then
                        set self = null
                        return STRUCT_INVALID
                    endif
                    local Unit result = Unit.GetFromSelf(self)
                    set self = null
                    return result
                endmethod
                static method GetDamager takes nothing returns Unit
                    local unit self = GetEventDamageSource()
                    if (GetUnitAbilityLevel(self, DummyUnit.LOCUST_SPELL_ID) > 0) then
                        set self = null
                        return STRUCT_INVALID
                    endif
                    local Unit result = Unit.GetFromSelf(self)
                    set self = null
                    return result
                endmethod
                static method GetEnum takes nothing returns Unit
                    local unit self = GetEnumUnit()
                    if (GetUnitAbilityLevel(self, DummyUnit.LOCUST_SPELL_ID) > 0) then
                        set self = null
                        return STRUCT_INVALID
                    endif
                    local Unit result = Unit.GetFromSelf(self)
                    set self = null
                    return result
                endmethod
                static method GetFilter takes nothing returns Unit
                    local unit self = GetFilterUnit()
                    if (GetUnitAbilityLevel(self, DummyUnit.LOCUST_SPELL_ID) > 0) then
                        set self = null
                        return STRUCT_INVALID
                    endif
                    local Unit result = Unit.GetFromSelf(self)
                    set self = null
                    return result
                endmethod
                static method GetKiller takes nothing returns Unit
                    local unit self = GetKillingUnit()
                    if (GetUnitAbilityLevel(self, DummyUnit.LOCUST_SPELL_ID) > 0) then
                        set self = null
                        return STRUCT_INVALID
                    endif
                    local Unit result = Unit.GetFromSelf(self)
                    set self = null
                    return result
                endmethod
                static method GetOrderTarget takes nothing returns Unit
                    local unit self = GetOrderTargetUnit()
                    if (GetUnitAbilityLevel(self, DummyUnit.LOCUST_SPELL_ID) > 0) then
                        set self = null
                        return STRUCT_INVALID
                    endif
                    local Unit result = Unit.GetFromSelf(self)
                    set self = null
                    return result
                endmethod
                static method GetPurchaser takes nothing returns Unit
                    local unit self = GetBuyingUnit()
                    if (GetUnitAbilityLevel(self, DummyUnit.LOCUST_SPELL_ID) > 0) then
                        set self = null
                        return STRUCT_INVALID
                    endif
                    local Unit result = Unit.GetFromSelf(self)
                    set self = null
                    return result
                endmethod
                static method GetSpellTarget takes nothing returns Unit
                    local unit self = GetSpellTargetUnit()
                    if (GetUnitAbilityLevel(self, DummyUnit.LOCUST_SPELL_ID) > 0) then
                        set self = null
                        return STRUCT_INVALID
                    endif
                    local Unit result = Unit.GetFromSelf(self)
                    set self = null
                    return result
                endmethod
                static method GetTrigger takes nothing returns Unit
                    local unit self = GetTriggerUnit()
                    if (GetUnitAbilityLevel(self, DummyUnit.LOCUST_SPELL_ID) > 0) then
                        set self = null
                        return STRUCT_INVALID
                    endif
                    local Unit result = Unit.GetFromSelf(self)
                    set self = null
                    return result
                endmethod
        endstruct
    endscope
    public struct StructEvent
        implement Allocation
        implement List
        
    FolderEvent_StructCombination Combination = this
    FolderEvent_StructCombination LinkToStruct_Combination
    FolderEvent_StructCounted Counted = this
    FolderEvent_StructCounted LinkToStruct_Counted
    FolderEvent_StructNative Native = this
    FolderEvent_StructNative LinkToStruct_Native
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(Unit(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(Unit(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(Unit(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(Unit(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(Unit(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(Unit(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(Unit(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(Unit(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject Unit.Allocation.deallocate_demount.hook
			call Unit(this).Event.Destroy()
		endinject
		inject Unit.Allocation.allocate_mount.hook
			call Unit(this).Event.Event_Create()
		endinject
        static method Init takes nothing returns nothing
            call thistype(NULL).Counted.Init()
        endmethod
    endstruct
    scope FolderAbilities
    public struct StructCooldown
        implement Allocation
        implement List
        
            static Event DESTROY_EVENT
            static EventType ENDING_EVENT_TYPE
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
            static EventType START_EVENT_TYPE
            Timer durationTimer
            Unit parent
            Spell whichSpell
            method Is takes Spell whichSpell returns boolean
                return (whichSpell.Data.Integer.Get(KEY_ARRAY_DETAIL + this) != NULL)
            endmethod
            static method Ending_TriggerEvents takes Unit parent, Spell whichSpell returns nothing
                local EventResponse params = EventResponse.Create(parent.Id.Get())
                call params.Spell.SetTrigger(whichSpell)
                call params.Unit.SetTrigger(parent)
				local EventResponse spellParams = EventResponse.Create(whichSpell.Id.Get())
                call spellParams.Spell.SetTrigger(whichSpell)
                call spellParams.Unit.SetTrigger(parent)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = parent.Event.Count(thistype.ENDING_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call parent.Event.Get(thistype.ENDING_EVENT_TYPE, priority, iteration2).Run(params)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration2 = whichSpell.Event.Count(thistype.ENDING_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call whichSpell.Event.Get(thistype.ENDING_EVENT_TYPE, priority, iteration2).Run(spellParams)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call params.Destroy()
                call spellParams.Destroy()
            endmethod
            method Ending takes Timer durationTimer, Unit parent, Spell whichSpell returns nothing
                call this.deallocate()
                call durationTimer.Destroy()
                if parent.Data.Integer.Table.Remove(KEY_ARRAY, this) then
                    call parent.Event.Remove(DESTROY_EVENT)
                endif
                call parent.Data.Integer.Remove(KEY_ARRAY_DETAIL + whichSpell)
                if whichSpell.Data.Integer.Table.Remove(KEY_ARRAY, this) then
                    
                endif
                call whichSpell.Data.Integer.Remove(KEY_ARRAY_DETAIL + parent)
                call thistype.Ending_TriggerEvents(parent, whichSpell)
            endmethod
            method EndingByParent takes Spell whichSpell returns nothing
                local Unit parent = this
                local integer whichSpellSelf = whichSpell.self
                set this = parent.Data.Integer.Get(KEY_ARRAY_DETAIL + whichSpell)
                if (this == NULL) then
                    return
                endif
                local integer level = parent.Abilities.GetLevel(whichSpell)
                call parent.Order.Events.Lock()
                call parent.Abilities.RemoveBySelf(whichSpellSelf)
                call parent.Abilities.AddBySelf(whichSpellSelf)
                call parent.Abilities.SetLevelBySelf(whichSpellSelf, level)
                call parent.Order.Events.Unlock()
                call this.Ending(this.durationTimer, parent, whichSpell)
            endmethod
            timerMethod EndingByTimer
                local Timer durationTimer = Timer.GetExpired()
                local thistype this = durationTimer.GetData()
                call this.Ending(durationTimer, this.parent, this.whichSpell)
            endmethod
            eventMethod Event_Destroy
                local Unit parent = params.Unit.GetTrigger()
                local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                loop
                    local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                    call this.Ending(this.durationTimer, parent, this.whichSpell)
                    set iteration = iteration - 1
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                endloop
            endmethod
            static method Start_TriggerEvents takes Unit parent, Spell whichSpell returns nothing
                local EventResponse params = EventResponse.Create(parent.Id.Get())
                call params.Spell.SetTrigger(whichSpell)
                call params.Unit.SetTrigger(parent)
				local EventResponse spellParams = EventResponse.Create(whichSpell.Id.Get())
                call spellParams.Spell.SetTrigger(whichSpell)
                call spellParams.Unit.SetTrigger(parent)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = parent.Event.Count(thistype.START_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED) 
                        call parent.Event.Get(thistype.START_EVENT_TYPE, priority, iteration2).Run(params)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration2 = whichSpell.Event.Count(thistype.START_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED) 
                        call whichSpell.Event.Get(thistype.START_EVENT_TYPE, priority, iteration2).Run(spellParams)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call params.Destroy()
                call spellParams.Destroy()
            endmethod
            method StartEx takes Spell whichSpell returns nothing
                local Unit parent = this
                local real duration = whichSpell.GetCooldown(parent.Abilities.GetLevel(whichSpell))
                if (duration == 0.) then
                    return
                endif
                set this = thistype.allocate()
				local Timer durationTimer = Timer.Create()
                set this.durationTimer = durationTimer
                set this.parent = parent
                set this.whichSpell = whichSpell
                call durationTimer.SetData(this)
                if parent.Data.Integer.Table.Add(KEY_ARRAY, this) then
                    call parent.Event.Add(DESTROY_EVENT)
                endif
                call parent.Data.Integer.Set(KEY_ARRAY_DETAIL + whichSpell, this)
                if whichSpell.Data.Integer.Table.Add(KEY_ARRAY, this) then
                    
                endif
                call whichSpell.Data.Integer.Set(KEY_ARRAY_DETAIL + parent, this)
                call durationTimer.Start(duration, false, function thistype.EndingByTimer)
                call thistype.Start_TriggerEvents(parent, whichSpell)
            endmethod
            method Start takes Spell whichSpell returns nothing
            endmethod
            static method Init takes nothing returns nothing
                set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
                set thistype.ENDING_EVENT_TYPE = EventType.Create()
                set thistype.START_EVENT_TYPE = EventType.Create()
            endmethod
        endstruct
    scope FolderEvents
    public struct StructBegin
        implement Allocation
        implement List
        
                static EventType DUMMY_EVENT_TYPE
                static Trigger DUMMY_TRIGGER
                static UnitList REG_GROUP
                static method TriggerEvents takes Unit caster, integer level, Unit targetUnit, real targetX, real targetY, Spell whichSpell returns nothing
                    local EventResponse casterParams = EventResponse.Create(caster.Id.Get())
                    call casterParams.Spell.SetLevel(level)
                    call casterParams.Spell.SetTrigger(whichSpell)
                    call casterParams.Spot.SetTargetX(targetX)
                    call casterParams.Spot.SetTargetY(targetY)
                    call casterParams.Unit.SetTarget(targetUnit)
                    call casterParams.Unit.SetTrigger(caster)
					local EventResponse spellParams = EventResponse.Create(whichSpell.Id.Get())
                    call spellParams.Spell.SetLevel(level)
                    call spellParams.Spell.SetTrigger(whichSpell)
                    call spellParams.Spot.SetTargetX(targetX)
                    call spellParams.Spot.SetTargetY(targetY)
                    call spellParams.Unit.SetTarget(targetUnit)
                    call spellParams.Unit.SetTrigger(caster)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = whichSpell.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call whichSpell.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(casterParams)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration2 = caster.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call caster.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(spellParams)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call casterParams.Destroy()
                    call spellParams.Destroy()
                endmethod
                condTrigMethod TrigConds
                    if not thistype.REG_GROUP.Contains(UNIT.Event.Native.GetTrigger()) then
                        return false
                    endif
                    if (SPELL.Event.Native.GetCast() == NULL) then
                        return false
                    endif
                    return true
                endmethod
                trigMethod Trig
                    local Unit caster = UNIT.Event.Native.GetTrigger()
                    local Unit targetUnit = UNIT.Event.Native.GetSpellTarget()
                    local real targetX = SPOT.Event.Native.GetSpellTargetX()
                    local real targetY = SPOT.Event.Native.GetSpellTargetY()
                    local Spell whichSpell = SPELL.Event.Native.GetCast()
                    local integer level = caster.Abilities.GetLevel(whichSpell)
                    call thistype.TriggerEvents(caster, level, targetUnit, targetX, targetY, whichSpell)
                endmethod
                method Event_Destroy takes nothing returns nothing
                    call thistype.REG_GROUP.Remove(this)
                endmethod
                method Event_Create takes nothing returns nothing
                    call thistype.REG_GROUP.Add(this)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                    set thistype.DUMMY_TRIGGER = Trigger.CreateFromCode(function thistype.Trig)
                    set thistype.REG_GROUP = UnitList.Create()
                    call thistype.DUMMY_TRIGGER.AddConditions(function thistype.TrigConds)
                    call thistype.DUMMY_TRIGGER.RegisterEvent.PlayerUnit(User.ANY, EVENT_PLAYER_UNIT_SPELL_CAST, null)
                endmethod
            endstruct
    scope FolderEffect
    public struct StructChanneling
        implement Allocation
        implement List
        
                    static constant real ANIMATION_TIME = 0.25
                    static Timer ANIMATION_TIMER
    static key GetKeyMacro_CASTER_KEY_ARRAY
    static constant integer CASTER_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_CASTER_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
                    static real DURATION
                    static Event DEATH_EVENT
                    static Event ORDER_EVENT
                    static Event ORDER_POINT_EVENT
                    static Event ORDER_TARGET_EVENT
                    static Event STUN_EVENT
                    static Event TARGET_DEATH_EVENT
                    static Event TARGET_DESTROY_EVENT
                    static Event UNLEARN_EVENT
                    static SpellInstance WHICH_INSTANCE
    static thistype array ACTIVE_LIST_ALL
    static integer ACTIVE_LIST_ALL_COUNT = ARRAY_EMPTY
    integer ACTIVE_LIST_index
    static method ACTIVE_LIST_Count takes nothing returns integer
        return thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static method ACTIVE_LIST_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Get takes integer index returns thistype
        return thistype.ACTIVE_LIST_ALL[index]
    endmethod
    static method ACTIVE_LIST_GetIndex takes thistype this returns integer
        return this.ACTIVE_LIST_index
    endmethod
    static method ACTIVE_LIST_Contains takes thistype this returns boolean
        return (thistype.ACTIVE_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ACTIVE_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ACTIVE_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ACTIVE_LIST_RandomAll takes nothing returns thistype
        return thistype.ACTIVE_LIST_Random(ARRAY_MIN, thistype.ACTIVE_LIST_ALL_COUNT)
    endmethod
    static method ACTIVE_LIST_Remove takes thistype this returns boolean
        if not thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT].ACTIVE_LIST_index = this.ACTIVE_LIST_index
        set thistype.ACTIVE_LIST_ALL[this.ACTIVE_LIST_index - 1] = thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT]
        set this.ACTIVE_LIST_index = ARRAY_MIN
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT - 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Add takes thistype this returns boolean
        if thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT + 1
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT] = this
        set this.ACTIVE_LIST_index = thistype.ACTIVE_LIST_ALL_COUNT + 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static thistype array FOR_EACH_LIST_ALL
    static integer FOR_EACH_LIST_ALL_COUNT = ARRAY_EMPTY
    static method FOR_EACH_LIST_FetchFirst takes nothing returns thistype
        local thistype result
        if (thistype.FOR_EACH_LIST_ALL_COUNT < ARRAY_MIN) then
            return NULL
        endif
        set result = thistype.FOR_EACH_LIST_ALL[ARRAY_MIN]
        set thistype.FOR_EACH_LIST_ALL[ARRAY_MIN] = thistype.FOR_EACH_LIST_ALL[thistype.FOR_EACH_LIST_ALL_COUNT]
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.FOR_EACH_LIST_ALL_COUNT - 1
        return result
    endmethod
    static method FOR_EACH_LIST_Set takes nothing returns nothing
        local integer iteration = thistype.ACTIVE_LIST_ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.FOR_EACH_LIST_ALL[iteration] = thistype.ACTIVE_LIST_ALL[iteration]
            set iteration = iteration - 1
        endloop
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
                    Timer durationTimer
                    boolean running
                    SpellInstance whichInstance
                    method Is takes nothing returns boolean
                        return this.running
                    endmethod
                    method Animate takes nothing returns nothing
                        local Unit caster = this
                        local SpellInstance whichInstance = this.whichInstance
                        if (whichInstance.GetSpell().GetTargetType() != Spell.TARGET_TYPE_IMMEDIATE) then
                            local real angle = caster.CastAngle(whichInstance.GetCurrentTargetX() - caster.Position.X.Get(), whichInstance.GetCurrentTargetY() - caster.Position.Y.Get())
                            if (caster.Facing.Get() != angle) then
                                call caster.Facing.Set(angle)
                            endif
                        endif
                    endmethod
                    timerMethod AnimateByTimer
                        call thistype.FOR_EACH_LIST_Set()
                        loop
                            local thistype this = thistype.FOR_EACH_LIST_FetchFirst()
                            exitwhen (this == NULL)
                            call this.Animate()
                        endloop
                    endmethod
                    eventMethod Event_Death
                        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
                    endmethod
                    eventMethod Event_Order
                        local Unit caster = params.Unit.GetTrigger()
                        local Order whichOrder = params.Order.GetTrigger()
                        if (whichOrder == Order.HOLD_POSITION) then
                            call caster.Buffs.Remove(thistype.DUMMY_BUFF)
                        elseif (whichOrder == Order.SMART) then
                            local User casterOwner = caster.Owner.Get()
                            if ((caster.Selection.CountAtPlayer(casterOwner) == Memory.IntegerKeys.Table.STARTED) and (caster.Selection.GetFromPlayer(casterOwner, Memory.IntegerKeys.Table.STARTED) == caster)) then
                                call caster.Buffs.Remove(thistype.DUMMY_BUFF)
                            endif
                        endif
                    endmethod
                    eventMethod Event_Stun
                        local Unit caster = params.Unit.GetTrigger()
                        if (params.Order.GetTrigger() == Order.STUNNED) then
                            call caster.Buffs.Remove(thistype.DUMMY_BUFF)
                        endif
                    endmethod
					eventMethod Event_Unlearn
						local Unit caster = params.Unit.GetTrigger()
						local Spell whichSpell = params.Spell.GetTrigger()
						
						local thistype this = caster
						
						if (this.whichInstance.GetSpell() == whichSpell) then
							call caster.Buffs.Remove(thistype.DUMMY_BUFF)
						endif
					endmethod
                    static method TargetEnding takes Unit target returns nothing
                        local integer iteration = target.Data.Integer.Table.Count(CASTER_KEY_ARRAY)
                        loop
                            local Unit caster = target.Data.Integer.Table.Get(CASTER_KEY_ARRAY, iteration)
                            call caster.Buffs.Remove(thistype.DUMMY_BUFF)
                            set iteration = iteration - 1
                            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                        endloop
                    endmethod
                    eventMethod Event_TargetDeath
                        call thistype.TargetEnding(params.Unit.GetTrigger())
                    endmethod
                    eventMethod Event_TargetDestroy
                        call thistype.TargetEnding(params.Unit.GetTrigger())
                    endmethod
                    eventMethod Event_BuffLose
                        local Unit caster = params.Unit.GetTrigger()
                        local thistype this = caster
                        local Timer durationTimer = this.durationTimer
                        local SpellInstance whichInstance = this.whichInstance
                        local boolean completed = (durationTimer.GetRemaining() < 0.1)
                        local Unit target = whichInstance.GetTargetUnit()
                        call durationTimer.Destroy()
                        if thistype.ACTIVE_LIST_Remove(this) then
                            call thistype.ANIMATION_TIMER.Pause()
                        endif
                        set this.running = false
                        call caster.Event.Remove(DEATH_EVENT)
                        call caster.Event.Remove(ORDER_EVENT)
                        call caster.Event.Remove(ORDER_POINT_EVENT)
                        call caster.Event.Remove(ORDER_TARGET_EVENT)
                        call caster.Event.Remove(STUN_EVENT)
                        call caster.Event.Remove(UNLEARN_EVENT)
                        if (target != NULL) then
                            if target.Data.Integer.Table.Remove(CASTER_KEY_ARRAY, caster) then
                                call target.Event.Remove(TARGET_DEATH_EVENT)
                                call target.Event.Remove(TARGET_DESTROY_EVENT)
                            endif
                        endif
                        call caster.Animation.Reset()
                        call caster.Attack.Add()
                        call caster.Movement.Add()
                        call caster.Bars.EndChannel()
                        call UNIT.Abilities.Events.Finish.Start(whichInstance, completed)
                        call whichInstance.Refs.Subtract()
                    endmethod
                    eventMethod Event_BuffGain
                        local Unit caster = params.Unit.GetTrigger()
                        local real duration = thistype.DURATION
                        local SpellInstance whichInstance = thistype.WHICH_INSTANCE
                        local Unit target = whichInstance.GetTargetUnit()
                        local thistype this = caster
						local Timer durationTimer = Timer.Create()
                        set this.durationTimer = durationTimer
                        set this.running = true
                        set this.whichInstance = whichInstance
                        call caster.Event.Add(DEATH_EVENT)
                        call caster.Event.Add(ORDER_EVENT)
                        call caster.Event.Add(ORDER_POINT_EVENT)
                        call caster.Event.Add(ORDER_TARGET_EVENT)
                        call caster.Event.Add(STUN_EVENT)
                        call caster.Event.Add(UNLEARN_EVENT)
                        if (target != NULL) then
                            if target.Data.Integer.Table.Add(CASTER_KEY_ARRAY, caster) then
                                call target.Event.Add(TARGET_DEATH_EVENT)
                                call target.Event.Add(TARGET_DESTROY_EVENT)
                            endif
                        endif
                        call durationTimer.Start(duration + 0.01, false, null)
                        call Unit(this).Animation.Loop.Start(whichInstance.GetSpell().GetAnimation())
                        call Unit(this).Attack.Subtract()
                        call Unit(this).Movement.Subtract()
                        call whichInstance.Refs.Add()
                        if thistype.ACTIVE_LIST_Add(this) then
                            call thistype.ANIMATION_TIMER.Start(thistype.ANIMATION_TIME, true, function thistype.AnimateByTimer)
                        endif
                        call this.Animate()
                        call caster.Bars.StartChannel(duration)
                    endmethod
                    static method Start takes SpellInstance whichInstance returns nothing
                        local real duration = whichInstance.GetSpell().GetChannelTime(whichInstance.GetLevel())
                        if (duration == 0.) then
                            return
                        endif
                        call whichInstance.GetCaster().Buffs.Remove(thistype.DUMMY_BUFF)
                        set thistype.DURATION = duration
                        set thistype.WHICH_INSTANCE = whichInstance
                        call whichInstance.GetCaster().Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, duration)
                    endmethod
                    method Event_Create takes nothing returns nothing
                        set this.running = false
                    endmethod
                    initMethod Buff_Init of Header_Buffs
                        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
                        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
                    endmethod
                    static method Init takes nothing returns nothing
                        set thistype.ANIMATION_TIMER = Timer.Create()
                        set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Death)
                        set thistype.ORDER_EVENT = Event.Create(UNIT.Order.Events.Gain.Immediate.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Order)
                        set thistype.ORDER_POINT_EVENT = Event.Create(UNIT.Order.Events.Gain.Point.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Order)
                        set thistype.ORDER_TARGET_EVENT = Event.Create(UNIT.Order.Events.Gain.Target.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Order)
                        set thistype.STUN_EVENT = Event.Create(UNIT.Order.Events.Gain.Target.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Stun)
                        set thistype.TARGET_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TargetDeath)
                        set thistype.TARGET_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TargetDestroy)
                        set thistype.UNLEARN_EVENT = Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Unlearn)
                    endmethod
                endstruct
            endscope
    public struct StructEffect
        implement Allocation
        implement List
        
                static EventType DUMMY_EVENT_TYPE
                static Trigger DUMMY_TRIGGER
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
                static EventType PRE_EVENT_TYPE
                static Trigger PRE_TRIGGER
                static UnitList REG_GROUP
                boolean inventoryUse
                SpellInstance whichInstance
    FolderEffect_StructChanneling Channeling = this
    FolderEffect_StructChanneling LinkToStruct_Channeling
                static method TriggerEvents takes SpellInstance whichInstance, Item fromWhichItem returns nothing
                    local Unit caster = whichInstance.GetCaster()
                    local integer level = whichInstance.GetLevel()
                    local Item targetItem = whichInstance.GetTargetItem()
                    local Unit targetUnit = whichInstance.GetTargetUnit()
                    local real targetX = whichInstance.GetTargetX()
                    local real targetY = whichInstance.GetTargetY()
                    local Spell whichSpell = whichInstance.GetSpell()
                    local EventResponse casterParams = EventResponse.Create(caster.Id.Get())
                    call casterParams.Item.SetTarget(targetItem)
                    call casterParams.Item.SetTrigger(fromWhichItem)
                    call casterParams.Spell.SetLevel(level)
                    call casterParams.Spell.SetTrigger(whichSpell)
                    call casterParams.SpellInstance.SetTrigger(whichInstance)
                    call casterParams.Spot.SetTargetX(targetX)
                    call casterParams.Spot.SetTargetY(targetY)
                    call casterParams.Unit.SetTarget(targetUnit)
                    call casterParams.Unit.SetTrigger(caster)
					local EventResponse spellParams = EventResponse.Create(whichSpell.Id.Get())
                    call spellParams.Item.SetTarget(targetItem)
                    call spellParams.Item.SetTrigger(fromWhichItem)
                    call spellParams.Spell.SetLevel(level)
                    call spellParams.Spell.SetTrigger(whichSpell)
                    call spellParams.SpellInstance.SetTrigger(whichInstance)
                    call spellParams.Spot.SetTargetX(targetX)
                    call spellParams.Spot.SetTargetY(targetY)
                    call spellParams.Unit.SetTarget(targetUnit)
                    call spellParams.Unit.SetTrigger(caster)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = Event.CountAtStatics(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call Event.GetFromStatics(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(casterParams)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration2 = caster.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call caster.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(casterParams)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration2 = whichSpell.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call whichSpell.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(spellParams)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call casterParams.Destroy()
                    call spellParams.Destroy()
                endmethod
                static method Start takes SpellInstance whichInstance, Item fromWhichItem returns nothing
                    local Unit caster = whichInstance.GetCaster()
                    local integer level = whichInstance.GetLevel()
                    local Unit targetUnit = whichInstance.GetTargetUnit()
                    local Spell whichSpell = whichInstance.GetSpell()
                    local boolean hasTargetUnit = (targetUnit != NULL)
                    local thistype this = caster
                    call thistype(NULL).Channeling.Start(whichInstance)
                    call caster.Abilities.Cooldown.StartEx(whichSpell)
                    call caster.Mana.SubtractNoNative(whichSpell.GetManaCost(level))
					local boolean isNotCasterAlly
                    if hasTargetUnit then
                        set isNotCasterAlly = not caster.IsAllyOf(targetUnit.Owner.Get())
                    endif
                    if caster.Classes.Contains(UnitClass.HERO) then
                        call caster.AddJumpingTextTagEx2(String.Color.Do(whichInstance.GetSpell().GetName(), "ff00ffff"), S2R(SetVar.GetValDef("size", "0.021")), TextTag.GetFreeId(), false, -caster.CollisionSize.Get(true), 0.)
                    endif
                    call thistype.TriggerEvents(whichInstance, fromWhichItem)
                    if hasTargetUnit then
                        if isNotCasterAlly then
                            set UNIT.Damage.Events.IGNORE_NEXT = true
                        endif
                    endif
                    call whichInstance.Destroy()
                    set this.whichInstance = NULL
                endmethod
                condTrigMethod TrigConds
                    local Unit caster = UNIT.Event.Native.GetTrigger()
                    if (caster == NULL) then
                        return false
                    endif
                    if (caster.Abilities.GetLevelBySelf(Spell.PARALLEL_CAST_BUFF_ID) > 0) then
                        call caster.Buffs.RemoveBySelf(Spell.PARALLEL_CAST_BUFF_ID)
                    endif
                    if not thistype.REG_GROUP.Contains(caster) then
                        return false
                    endif
                    if (SPELL.Event.Native.GetCast() == NULL) then
                        return false
                    endif
                    return true
                endmethod
                static integer array TARGET_TYPE_DUMMY_CAST_SPELL_IDS
                trigMethod Trig
                    local Unit caster = UNIT.Event.Native.GetTrigger()
                    local thistype this = caster
                    local SpellInstance whichInstance = this.whichInstance
                    if (whichInstance == NULL) then
                        return
                    endif
                    if this.inventoryUse then
                        return
                    endif
                    local integer targetType = whichInstance.GetSpell().GetTargetType()
                    local integer dummyCastSpellId = thistype.TARGET_TYPE_DUMMY_CAST_SPELL_IDS[targetType]
                    if (dummyCastSpellId != 0) then
                        call caster.Abilities.AddBySelf(dummyCastSpellId)
                        
                        local OrderInstance dummyOrderData = OrderInstance.Create()
                        call dummyOrderData.SetOrder(Order.CHANNEL)
                        call dummyOrderData.SetTargetType(targetType)
                        call dummyOrderData.SetTargetUnit(whichInstance.GetTargetUnit())
                        call dummyOrderData.SetTargetX(whichInstance.GetTargetX())
                        call dummyOrderData.SetTargetY(whichInstance.GetTargetY())
                        
                        call dummyOrderData.Destroy()
                        
                    endif
                    call thistype.Start(whichInstance, NULL)
                endmethod
                method StartByItem takes SpellInstance whichInstance, Item whichItem returns nothing
                    call thistype.Start(whichInstance, whichItem)
                endmethod
                static method PreTriggerEvents takes SpellInstance whichInstance returns nothing
                    local Unit caster = whichInstance.GetCaster()
                    local integer level = whichInstance.GetLevel()
                    local Item targetItem = whichInstance.GetTargetItem()
                    local Unit targetUnit = whichInstance.GetTargetUnit()
                    local real targetX = whichInstance.GetTargetX()
                    local real targetY = whichInstance.GetTargetY()
                    local Spell whichSpell = whichInstance.GetSpell()
                    local EventResponse casterParams = EventResponse.Create(caster.Id.Get())
                    call casterParams.Item.SetTarget(targetItem)
                    call casterParams.Spell.SetLevel(level)
                    call casterParams.Spell.SetTrigger(whichSpell)
                    call casterParams.SpellInstance.SetTrigger(whichInstance)
                    call casterParams.Spot.SetTargetX(targetX)
                    call casterParams.Spot.SetTargetY(targetY)
                    call casterParams.Unit.SetTarget(targetUnit)
                    call casterParams.Unit.SetTrigger(caster)
					local EventResponse spellParams = EventResponse.Create(whichSpell.Id.Get())
                    call spellParams.Item.SetTarget(targetItem)
                    call spellParams.Spell.SetLevel(level)
                    call spellParams.Spell.SetTrigger(whichSpell)
                    call spellParams.SpellInstance.SetTrigger(whichInstance)
                    call spellParams.Spot.SetTargetX(targetX)
                    call spellParams.Spot.SetTargetY(targetY)
                    call spellParams.Unit.SetTarget(targetUnit)
                    call spellParams.Unit.SetTrigger(caster)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = caster.Event.Count(thistype.PRE_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call caster.Event.Get(thistype.PRE_EVENT_TYPE, priority, iteration2).Run(casterParams)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration2 = whichSpell.Event.Count(thistype.PRE_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call whichSpell.Event.Get(thistype.PRE_EVENT_TYPE, priority, iteration2).Run(spellParams)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call casterParams.Destroy()
                    call spellParams.Destroy()
                endmethod
                method GetSpellInstance takes nothing returns SpellInstance
                    return this.whichInstance
                endmethod
                trigMethod PreTrig
                    local Unit caster = UNIT.Event.Native.GetTrigger()
                    local Spell whichSpell = SPELL.Event.Native.GetCast()
                    local Order casterOrder = caster.Order.Get()
                    local thistype this = caster
                    local SpellInstance whichInstance = SpellInstance.Create(caster, whichSpell)
					local integer level
                    if casterOrder.IsInventoryUse() then
                        set level = caster.Items.GetFromSlot(casterOrder.GetInventoryIndex()).Abilities.GetLevel(whichSpell)
                        set this.inventoryUse = true
                    else
                        set level = caster.Abilities.GetLevel(whichSpell)
                        set this.inventoryUse = false
                    endif
                    set this.whichInstance = whichInstance
                    local real targetX = SPOT.Event.Native.GetSpellTargetX()
                    local real targetY = SPOT.Event.Native.GetSpellTargetY()
					local Item targetItem
					local Unit targetUnit
					if (whichInstance.GetSpell().GetTargetType() == Spell.TARGET_TYPE_IMMEDIATE) then
						set targetItem = NULL
						set targetUnit = NULL
					else
						set targetItem = ITEM.Event.Native.GetSpellTarget()
						set targetUnit = UNIT.Event.Native.GetSpellTarget()
					endif
                    call whichInstance.SetAngle(caster.CastAngle(targetX - caster.Position.X.Get(), targetY - caster.Position.Y.Get()))
                    call whichInstance.SetLevel(level)
                    call whichInstance.SetTargetItem(targetItem)
                    call whichInstance.SetTargetUnit(targetUnit)
                    call whichInstance.SetTargetX(targetX)
                    call whichInstance.SetTargetY(targetY)
                    call thistype.PreTriggerEvents(whichInstance)
                endmethod
                method Event_Destroy takes nothing returns nothing
                    call thistype.REG_GROUP.Remove(this)
                endmethod
                method Event_Create takes nothing returns nothing
                    set this.whichInstance = NULL
                    call thistype.REG_GROUP.Add(this)
                    call this.Channeling.Event_Create()
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                    set thistype.DUMMY_TRIGGER = Trigger.CreateFromCode(function thistype.Trig)
                    set thistype.PRE_EVENT_TYPE = EventType.Create()
                    set thistype.PRE_TRIGGER = Trigger.CreateFromCode(function thistype.PreTrig)
                    set thistype.REG_GROUP = UnitList.Create()
                    call thistype.DUMMY_TRIGGER.AddConditions(function thistype.TrigConds)
                    call thistype.DUMMY_TRIGGER.RegisterEvent.PlayerUnit(User.ANY, EVENT_PLAYER_UNIT_SPELL_ENDCAST, null)
                    call thistype.PRE_TRIGGER.AddConditions(function thistype.TrigConds)
                    call thistype.PRE_TRIGGER.RegisterEvent.PlayerUnit(User.ANY, EVENT_PLAYER_UNIT_SPELL_EFFECT, null)
                    set thistype.TARGET_TYPE_DUMMY_CAST_SPELL_IDS[Spell.TARGET_TYPE_IMMEDIATE] = thistype.IMMEDIATE_DUMMY_SPELL_ID
                    set thistype.TARGET_TYPE_DUMMY_CAST_SPELL_IDS[Spell.TARGET_TYPE_POINT] = thistype.POINT_DUMMY_SPELL_ID
                    set thistype.TARGET_TYPE_DUMMY_CAST_SPELL_IDS[Spell.TARGET_TYPE_POINT_OR_UNIT] = thistype.POINT_OR_UNIT_DUMMY_SPELL_ID
                    set thistype.TARGET_TYPE_DUMMY_CAST_SPELL_IDS[Spell.TARGET_TYPE_UNIT] = thistype.UNIT_DUMMY_SPELL_ID
                    call thistype(NULL).Channeling.Init()
                endmethod
            endstruct
    public struct StructFinish
        implement Allocation
        implement List
        
                static EventType DUMMY_EVENT_TYPE
                static EventType SUCCESS_EVENT_TYPE
                static method TriggerEvents takes SpellInstance whichInstance, boolean channelComplete returns nothing
                    local Unit caster = whichInstance.GetCaster()
                    local integer level = whichInstance.GetLevel()
                    local Item targetItem = whichInstance.GetTargetItem()
                    local Unit targetUnit = whichInstance.GetTargetUnit()
                    local real targetX = whichInstance.GetTargetX()
                    local real targetY = whichInstance.GetTargetY()
                    local Spell whichSpell = whichInstance.GetSpell()
                    local EventResponse casterParams = EventResponse.Create(caster.Id.Get())
                    call casterParams.Spell.SetChannelComplete(channelComplete)
                    call casterParams.Spell.SetLevel(level)
                    call casterParams.Spell.SetTrigger(whichSpell)
                    call casterParams.SpellInstance.SetTrigger(whichInstance)
                    call casterParams.Unit.SetTrigger(caster)
					local EventResponse spellParams = EventResponse.Create(whichSpell.Id.Get())
                    call spellParams.Spell.SetChannelComplete(channelComplete)
                    call spellParams.Spell.SetLevel(level)
                    call spellParams.Spell.SetTrigger(whichSpell)
                    call spellParams.SpellInstance.SetTrigger(whichInstance)
                    call spellParams.Unit.SetTrigger(caster)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = whichSpell.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call whichSpell.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(spellParams)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration2 = whichSpell.Event.Count(thistype.SUCCESS_EVENT_TYPE, priority)
                        if channelComplete then
                            loop
                                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                                call whichSpell.Event.Get(thistype.SUCCESS_EVENT_TYPE, priority, iteration2).Run(spellParams)
                                set iteration2 = iteration2 - 1
                            endloop
                        endif
                        set iteration2 = caster.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call caster.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(casterParams)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call casterParams.Destroy()
                    call spellParams.Destroy()
                endmethod
                static method Start takes SpellInstance whichInstance, boolean channelComplete returns nothing
                    call thistype.TriggerEvents(whichInstance, channelComplete)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                    set thistype.SUCCESS_EVENT_TYPE = EventType.Create()
                endmethod
            endstruct
    public struct StructLearn
        implement Allocation
        implement List
        
                static EventType CHANGE_LEVEL_EVENT_TYPE
                static EventType DUMMY_EVENT_TYPE
                static Trigger DUMMY_TRIGGER
                static UnitList REG_GROUP
                method ChangeLevel_TriggerEvents takes Spell whichSpell, integer level returns nothing
                    local EventResponse spellParams = EventResponse.Create(whichSpell.Id.Get())
                    call spellParams.Spell.SetLevel(level)
                    call spellParams.Spell.SetTrigger(whichSpell)
                    call spellParams.Unit.SetTrigger(this)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = whichSpell.Event.Count(thistype.CHANGE_LEVEL_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call whichSpell.Event.Get(thistype.CHANGE_LEVEL_EVENT_TYPE, priority, iteration2).Run(spellParams)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call spellParams.Destroy()
                endmethod
                method ChangeLevel takes Spell whichSpell, integer level returns nothing
                    call this.ChangeLevel_TriggerEvents(whichSpell, level)
                endmethod
                method TriggerEvents takes integer level, Spell whichSpell returns nothing
                    local EventResponse spellParams = EventResponse.Create(whichSpell.Id.Get())
                    call spellParams.Spell.SetLevel(level)
                    call spellParams.Spell.SetTrigger(whichSpell)
                    call spellParams.Unit.SetTrigger(this)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = whichSpell.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call whichSpell.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(spellParams)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call spellParams.Destroy()
                endmethod
                method Start takes Spell whichSpell returns nothing
                    local integer level = Unit(this).Abilities.GetLevel(whichSpell)
                    call this.TriggerEvents(level, whichSpell)
                endmethod
                static method TrigConds takes Unit parent returns boolean
                    if not thistype.REG_GROUP.Contains(parent) then
                        return false
                    endif
                    return true
                endmethod
                trigMethod Trig
                    local Unit parent = UNIT.Event.Native.GetTrigger()
                    if not thistype.TrigConds(parent) then
                        return
                    endif
                    call parent.SkillPoints.UpdateByLearn()
                    call thistype(parent).Start(SPELL.Event.Native.GetLearned())
                endmethod
                method Event_Destroy takes nothing returns nothing
                    call thistype.REG_GROUP.Remove(this)
                endmethod
                method Event_Create takes nothing returns nothing
                    call thistype.REG_GROUP.Add(this)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.CHANGE_LEVEL_EVENT_TYPE = EventType.Create()
                    set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                    set thistype.DUMMY_TRIGGER = Trigger.CreateFromCode(function thistype.Trig)
                    set thistype.REG_GROUP = UnitList.Create()
                    call thistype.DUMMY_TRIGGER.RegisterEvent.PlayerUnit(User.ANY, EVENT_PLAYER_HERO_SKILL, null)
                endmethod
            endstruct
    public struct StructUnlearn
        implement Allocation
        implement List
        
                static EventType DUMMY_EVENT_TYPE
                method TriggerEvents takes Spell whichSpell returns nothing
                	local Unit parent = this
                    local EventResponse params = EventResponse.Create(parent.Id.Get())
                    call params.Spell.SetTrigger(whichSpell)
                    call params.Unit.SetTrigger(parent)
                    local EventResponse spellParams = EventResponse.Create(whichSpell.Id.Get())
                    call spellParams.Spell.SetTrigger(whichSpell)
                    call spellParams.Unit.SetTrigger(parent)
                    local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = parent.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration2 = whichSpell.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call whichSpell.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(spellParams)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
					call params.Destroy()
                    call spellParams.Destroy()
                endmethod
                method Start takes Spell whichSpell returns nothing
                    call this.TriggerEvents(whichSpell)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                endmethod
            endstruct
        endscope
    public struct StructEvents
        implement Allocation
        implement List
        
    FolderEvents_StructBegin Begin = this
    FolderEvents_StructBegin LinkToStruct_Begin
    FolderEvents_StructEffect Effect = this
    FolderEvents_StructEffect LinkToStruct_Effect
    FolderEvents_StructFinish Finish = this
    FolderEvents_StructFinish LinkToStruct_Finish
    FolderEvents_StructLearn Learn = this
    FolderEvents_StructLearn LinkToStruct_Learn
    FolderEvents_StructUnlearn Unlearn = this
    FolderEvents_StructUnlearn LinkToStruct_Unlearn
            method Event_Destroy takes nothing returns nothing
                call this.Begin.Event_Destroy()
                call this.Effect.Event_Destroy()
                call this.Learn.Event_Destroy()
            endmethod
            method Event_Create takes nothing returns nothing
                call this.Begin.Event_Create()
                call this.Effect.Event_Create()
                call this.Learn.Event_Create()
            endmethod
            static method Init takes nothing returns nothing
                call thistype(NULL).Begin.Init()
                call thistype(NULL).Finish.Init()
                call thistype(NULL).Learn.Init()
                call thistype(NULL).Unlearn.Init()
                
                call thistype(NULL).Effect.Init()
            endmethod
        endstruct
    public struct StructAutoCast
        implement Allocation
        implement List
        
            static EventType DUMMY_EVENT_TYPE
            Spell val
            method Get takes nothing returns Spell
                return this.val
            endmethod
            method TriggerEvents takes Spell sourceSpell, Spell whichSpell returns nothing
                local Unit parent = this
                local EventResponse parentParams = EventResponse.Create(parent.Id.Get())
                call parentParams.Spell.SetSource(sourceSpell)
                call parentParams.Spell.SetTrigger(whichSpell)
                call parentParams.Unit.SetTrigger(this)
                local EventResponse spellParams = EventResponse.Create(whichSpell.Id.Get())
                call spellParams.Spell.SetSource(sourceSpell)
                call spellParams.Spell.SetTrigger(whichSpell)
                call spellParams.Unit.SetTrigger(this)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = whichSpell.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call whichSpell.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(spellParams)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration2 = parent.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(parentParams)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call parentParams.Destroy()
                call spellParams.Destroy()
            endmethod
            method Set takes Spell whichSpell returns nothing
                local Spell oldVal = this.Get()
                if (whichSpell == oldVal) then
                    return
                endif
                set this.val = whichSpell
                call this.TriggerEvents(oldVal, whichSpell)
            endmethod
            method Change takes Spell whichSpell returns nothing
                if (whichSpell == NULL) then
                    if (this.Get() != NULL) then
                        if Unit(this).Order.ImmediateNoTrig(whichSpell.GetAutoCastOrderOff()) then
                            call this.Set(NULL)
                        endif
                    endif
                else
                    if Unit(this).Order.ImmediateNoTrig(whichSpell.GetAutoCastOrderOn()) then
                        call this.Set(whichSpell)
                    endif
                endif
            endmethod
            method Event_Create takes nothing returns nothing
                set this.val = NULL
            endmethod
            static method Init takes nothing returns nothing
                set thistype.DUMMY_EVENT_TYPE = EventType.Create()
            endmethod
        endstruct
    endscope
    public struct StructAbilities
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_LEVEL_KEY_ARRAY_DETAIL
    static constant integer LEVEL_KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_LEVEL_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    FolderAbilities_StructAutoCast AutoCast = this
    FolderAbilities_StructAutoCast LinkToStruct_AutoCast
    FolderAbilities_StructCooldown Cooldown = this
    FolderAbilities_StructCooldown LinkToStruct_Cooldown
    FolderAbilities_StructEvents Events = this
    FolderAbilities_StructEvents LinkToStruct_Events
        method Count takes nothing returns integer
            return Unit(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns Spell
            return Unit(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
       method GetFromOrder takes Order whichOrder returns Spell
            local integer iteration = this.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local Spell whichSpell = this.Get(iteration)
                if ((whichSpell.GetOrder() == whichOrder) or (whichSpell.GetAutoCastOrderOff() == whichOrder) or (whichSpell.GetAutoCastOrderOn() == whichOrder)) then
                    return whichSpell
                endif
                set iteration = iteration - 1
            endloop
            return NULL
        endmethod
        method GetLevelBySelf takes integer spellSelf returns integer
            return GetUnitAbilityLevel(Unit(this).self, spellSelf)
        endmethod
        method GetLevel takes Spell whichSpell returns integer
            return Unit(this).Data.Integer.Get(LEVEL_KEY_ARRAY_DETAIL + whichSpell)
        endmethod
        method Contains takes Spell whichSpell returns boolean
            return (this.GetLevel(whichSpell) > 0)
        endmethod
        method RemoveBySelf takes integer spellSelf returns nothing
            call UnitRemoveAbility(Unit(this).self, spellSelf)
        endmethod
        method AddBySelf takes integer spellSelf returns nothing
            call UnitAddAbility(Unit(this).self, spellSelf)
            call UnitMakeAbilityPermanent(Unit(this).self, true, spellSelf)
        endmethod
        method SetLevelBySelf takes integer spellSelf, integer level returns nothing
            if (level == 0) then
                call this.RemoveBySelf(spellSelf)
                return
            endif
            if (this.GetLevelBySelf(spellSelf) == 0) then
                call this.AddBySelf(spellSelf)
            endif
            call SetUnitAbilityLevel(Unit(this).self, spellSelf, level)
        endmethod
        method Remove takes Spell whichSpell returns nothing
            if not this.Contains(whichSpell) then
                return
            endif
            if (whichSpell.self != 0) then
                call this.RemoveBySelf(whichSpell.self)
            endif
            call Unit(this).Data.Integer.Table.Remove(KEY_ARRAY, whichSpell)
            call Unit(this).Data.Integer.Remove(LEVEL_KEY_ARRAY_DETAIL + whichSpell)
            call this.Events.Unlearn.Start(whichSpell)
        endmethod
        method StartCooldown takes Spell whichSpell returns nothing
            call this.Cooldown.StartEx(whichSpell)
        endmethod
        method AddWithLevel takes Spell whichSpell, integer level returns nothing
            call this.SetLevel(whichSpell, level)
        endmethod
        method Add takes Spell whichSpell returns nothing
            call this.AddWithLevel(whichSpell, 1)
        endmethod
        method SetLevel takes Spell whichSpell, integer level returns nothing
            local boolean added
            if (level == 0) then
                call this.Remove(whichSpell)
                return
            endif
            set added = not this.Contains(whichSpell)
            if added then
                if (whichSpell.self != 0) then
                    call this.AddBySelf(whichSpell.self)
                endif
                call Unit(this).Data.Integer.Table.Add(KEY_ARRAY, whichSpell)
                call Unit(this).Data.Integer.Set(LEVEL_KEY_ARRAY_DETAIL + whichSpell, level)
                call this.Events.Learn.Start(whichSpell)
                return
            endif
            call Unit(this).Data.Integer.Set(LEVEL_KEY_ARRAY_DETAIL + whichSpell, level)
            call this.SetLevelBySelf(whichSpell.self, level)
            call this.Events.Learn.ChangeLevel(whichSpell, level)
        endmethod
        method AddLevel takes Spell whichSpell, integer value returns nothing
            call this.SetLevel(whichSpell, this.GetLevel(whichSpell) + value)
        endmethod
        method Replace takes Spell oldSpell, Spell newSpell returns nothing
            local integer level = this.GetLevel(oldSpell)
            if (level > 0) then
                call this.Remove(oldSpell)
                call this.SetLevel(newSpell, level)
            endif
        endmethod
        method Refresh takes Spell whichSpell returns nothing
            call this.Cooldown.EndingByParent(whichSpell)
        endmethod
        method RefreshAll takes nothing returns nothing
            local integer iteration = this.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                call this.Refresh(this.Get(iteration))
                set iteration = iteration - 1
            endloop
        endmethod
        method Clear takes nothing returns nothing
            local integer iteration = this.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                call this.Remove(this.Get(iteration))
                set iteration = iteration - 1
            endloop
        endmethod
        eventMethod Event_TypeChange
            local UnitType sourceType = params.UnitType.GetSource()
            local UnitType targetType = params.UnitType.GetTrigger()
            local thistype this = params.Unit.GetTrigger()
            if Unit(this).Classes.Contains(UnitClass.HERO) then
                return
            endif
            call this.Clear()
            local integer iteration = targetType.Abilities.Count()
            loop
                exitwhen (iteration < ARRAY_MIN)
                local Spell whichSpell = targetType.Abilities.Get(iteration)
                call this.AddLevel(whichSpell, targetType.Abilities.GetLevel(whichSpell))
                set iteration = iteration - 1
            endloop
        endmethod
        method Event_Create takes nothing returns nothing
            local Spell whichSpell
            local UnitType thisType = Unit(this).Type.Get()
            local integer iteration = thisType.Abilities.Count()
            call this.AutoCast.Event_Create()
            loop
                exitwhen (iteration < ARRAY_MIN)
                set whichSpell = thisType.Abilities.Get(iteration)
                call this.AddLevel(whichSpell, thisType.Abilities.GetLevel(whichSpell))
                set iteration = iteration - 1
            endloop
            call this.Events.Event_Create()
            set iteration = thisType.Abilities.Hero.Count()
            loop
                exitwhen (iteration < ARRAY_MIN)
                call HeroSpell.AddToUnit(thisType.Abilities.Hero.Get(iteration), this)
                set iteration = iteration - 1
            endloop
        endmethod
        static method Init takes nothing returns nothing
            call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            call thistype(NULL).AutoCast.Init()
            call thistype(NULL).Cooldown.Init()
            call thistype(NULL).Events.Init()
        endmethod
    endstruct
    public struct StructEffects
        implement Allocation
        implement List
        
        method Create takes string modelPath, string attachPoint, EffectLevel level returns UnitEffect
            return UnitEffect.Create(this, modelPath, attachPoint, level)
        endmethod
    endstruct
    public struct StructSounds
        implement Allocation
        implement List
        
        method Create takes SoundType whichSoundType returns UnitSound
            return UnitSound.Create(this, whichSoundType)
        endmethod
    endstruct
    public struct StructAttachments
        implement Allocation
        implement List
        
        method Add takes string path, string attachPoint, EffectLevel level returns nothing
            call Unit(this).Effects.Create(path, attachPoint, level)
        endmethod
        eventMethod Event_TypeChange
            local UnitType targetType = params.UnitType.GetTrigger()
            local thistype this = params.Unit.GetTrigger()
            local integer iteration = targetType.Attachments.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                call this.Add(targetType.Attachments.GetPath(iteration), targetType.Attachments.GetAttachPoint(iteration), targetType.Attachments.GetLevel(iteration))
                set iteration = iteration - 1
            endloop
        endmethod
        method Event_Create takes nothing returns nothing
            local UnitType parentType = Unit(this).Type.Get()
            local integer iteration = parentType.Attachments.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                call this.Add(parentType.Attachments.GetPath(iteration), parentType.Attachments.GetAttachPoint(iteration), parentType.Attachments.GetLevel(iteration))
                set iteration = iteration - 1
            endloop
        endmethod
        static method Init takes nothing returns nothing
            call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
        endmethod
    endstruct
    scope FolderBuffs
    scope FolderEvents
    public struct StructChangeLevel
        implement Allocation
        implement List
        
                static EventType DUMMY_EVENT_TYPE
                method TriggerEvents takes Buff whichBuff, integer oldLevel, integer level, integer data returns nothing
                    local EventResponse buffParams = EventResponse.Create(whichBuff.Id.Get())
                    call buffParams.Buff.SetData(data)
                    call buffParams.Buff.SetLevel(level)
                    call buffParams.Buff.SetSourceLevel(oldLevel)
                    call buffParams.Buff.SetTrigger(whichBuff)
                    call buffParams.Unit.SetTrigger(this)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = whichBuff.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call whichBuff.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(buffParams)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call buffParams.Destroy()
                endmethod
                method Start takes Buff whichBuff, integer oldLevel, integer level, integer data returns nothing
                    local UnitModSet modSet = whichBuff.UnitModSets.Get(oldLevel)
                    if (modSet != NULL) then
                        call Unit(this).ModSets.Remove(modSet)
                    endif
                    set modSet = whichBuff.UnitModSets.Get(level)
                    if (modSet != NULL) then
                        call Unit(this).ModSets.Add(modSet)
                    endif
                    call this.TriggerEvents(whichBuff, oldLevel, level, data)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                endmethod
            endstruct
    public struct StructGain
        implement Allocation
        implement List
        
                static EventType DUMMY_EVENT_TYPE
                method TriggerEvents takes Buff whichBuff, integer level, integer data returns nothing
                    local EventResponse buffParams = EventResponse.Create(whichBuff.Id.Get())
                    call buffParams.Buff.SetData(data)
                    call buffParams.Buff.SetLevel(level)
                    call buffParams.Buff.SetTrigger(whichBuff)
                    call buffParams.Unit.SetTrigger(this)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = whichBuff.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call whichBuff.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(buffParams)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call buffParams.Destroy()
                endmethod
                method Start takes Buff whichBuff, integer level, integer data returns nothing
                    local UnitModSet modSet = whichBuff.UnitModSets.Get(level)
                    if (modSet != NULL) then
                        call Unit(this).ModSets.Add(modSet)
                    endif
                    call this.TriggerEvents(whichBuff, level, data)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                endmethod
            endstruct
    public struct StructLose
        implement Allocation
        implement List
        
                static EventType DUMMY_EVENT_TYPE
                method TriggerEvents takes Buff whichBuff, integer level returns nothing
                    local Unit parent = this
                    local EventResponse buffParams = EventResponse.Create(whichBuff.Id.Get())
                    call buffParams.Buff.SetLevel(level)
                    call buffParams.Buff.SetTrigger(whichBuff)
                    call buffParams.Unit.SetTrigger(parent)
					local EventResponse params = EventResponse.Create(parent.Id.Get())
                    call params.Buff.SetLevel(level)
                    call params.Buff.SetTrigger(whichBuff)
                    call params.Unit.SetTrigger(parent)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = parent.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration2 = whichBuff.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call whichBuff.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(buffParams)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call buffParams.Destroy()
                    call params.Destroy()
                endmethod
                method Start takes Buff whichBuff, integer level returns nothing
                    local UnitModSet modSet = whichBuff.UnitModSets.Get(level)
                    if (modSet != NULL) then
                        call Unit(this).ModSets.Remove(modSet)
                    endif
                    call this.TriggerEvents(whichBuff, level)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                endmethod
            endstruct
        endscope
    public struct StructEvents
        implement Allocation
        implement List
        
    FolderEvents_StructChangeLevel ChangeLevel = this
    FolderEvents_StructChangeLevel LinkToStruct_ChangeLevel
    FolderEvents_StructGain Gain = this
    FolderEvents_StructGain LinkToStruct_Gain
    FolderEvents_StructLose Lose = this
    FolderEvents_StructLose LinkToStruct_Lose
            static method Init takes nothing returns nothing
                call thistype(NULL).ChangeLevel.Init()
                call thistype(NULL).Gain.Init()
                call thistype(NULL).Lose.Init()
            endmethod
        endstruct
    scope FolderTimed
    public struct StructCountdown
        implement Allocation
        implement List
        
                static Event DEATH_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
                static constant integer SHOW_FROM = 3
                integer count
                Timer countdownTimer
                Timer durationTimer
                boolean firstCount
                Unit parent
                Buff whichBuff
                method Ending takes Timer durationTimer, Unit parent returns nothing
                    local Timer countdownTimer = this.countdownTimer
                    local Buff whichBuff = this.whichBuff
                    call this.deallocate()
                    call countdownTimer.Destroy()
                    call durationTimer.Destroy()
                    if parent.Data.Integer.Table.Remove(KEY_ARRAY, this) then
                        call parent.Event.Remove(DEATH_EVENT)
                    endif
                    call parent.Data.Integer.Remove(KEY_ARRAY_DETAIL + whichBuff)
                endmethod
                timerMethod EndingByTimer
                    local Timer durationTimer = Timer.GetExpired()
                    local thistype this = durationTimer.GetData()
                    call this.Ending(durationTimer, this.parent)
                endmethod
                method EndingByParent takes Buff whichBuff returns nothing
                    local Unit parent = this
                    set this = parent.Data.Integer.Get(KEY_ARRAY_DETAIL + whichBuff)
                    if (this != NULL) then
                        call this.Ending(this.durationTimer, parent)
                    endif
                endmethod
                eventMethod Event_Death
                    local Unit parent = params.Unit.GetTrigger()
                    local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                    loop
                        local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                        call this.Ending(this.durationTimer, parent)
                        set iteration = iteration - 1
                        exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    endloop
                endmethod
                method Interval takes nothing returns nothing
                    local integer count = this.count
                    local boolean firstCount = this.firstCount
                    if firstCount then
                        set this.firstCount = false
                        call this.parent.AddRisingTextTag(String.Color.Do(this.whichBuff.GetName() + " vanishes in " + Char.BREAK + Integer.ToString(count), "ff00ffff"), 0.022, 120., 1., 2., TextTag.GetFreeId())
                    else
                        call this.parent.AddRisingTextTag(String.Color.Do(Integer.ToString(count), "ff00ffff"), 0.022, 120., 1., 2., TextTag.GetFreeId())
                    endif
                    set this.count = count - 1
                endmethod
                timerMethod IntervalByTimer
                    local thistype this = Timer.GetExpired().GetData()
                    call this.Interval()
                endmethod
                static method StartCountdown takes nothing returns nothing
                    
                endmethod
                method Start takes Buff whichBuff, real duration returns nothing
                    local Unit parent = this
                    set this = parent.Data.Integer.Get(KEY_ARRAY_DETAIL + whichBuff)
                    if (this != NULL) then
                        call this.Ending(this.durationTimer, parent)
                    endif
                   
                    local integer count = Math.MinI(Real.ToInt(duration), thistype.SHOW_FROM)
                    local Timer countdownTimer = Timer.Create()
                    local Timer durationTimer = Timer.Create()
                    set this = thistype.allocate()
                    local real countdownStart = duration - count - 1.
                    set this.count = count
                    set this.countdownTimer = countdownTimer
                    set this.durationTimer = durationTimer
                    set this.firstCount = true
                    set this.parent = parent
                    set this.whichBuff = whichBuff
                    call countdownTimer.SetData(this)
                    call durationTimer.SetData(this)
                    if parent.Data.Integer.Table.Add(KEY_ARRAY, this) then
                        call parent.Event.Add(DEATH_EVENT)
                    endif
                    call parent.Data.Integer.Set(KEY_ARRAY_DETAIL + whichBuff, this)
                    call countdownTimer.Start(countdownStart, false, function thistype.StartCountdown)
                    if (countdownStart < 0.) then
                        call this.Interval()
                    endif
                    
                    call durationTimer.Start(duration - 1+0.01, false, function thistype.EndingByTimer)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Death)
                endmethod
            endstruct
        endscope
    public struct StructTimed
        implement Allocation
        implement List
        
            static Event DEATH_EVENT
            static constant real INFINITE = -1.
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
            static Event LOSE_EVENT
    FolderTimed_StructCountdown Countdown = this
    FolderTimed_StructCountdown LinkToStruct_Countdown
            Timer durationTimer
            Unit parent
            BuffRef whichBuffRef
            method Get takes Buff whichBuff, integer level returns BuffRef
                return Memory.IntegerKeys.D2.GetInteger(KEY, this, whichBuff, level, NULL)
            endmethod
            method GetRemainingDuration takes Buff whichBuff, integer level returns real
                set this = this.Get(whichBuff, level)
                if (this == NULL) then
                    return 0.
                endif
                return this.durationTimer.GetRemaining()
            endmethod
            method Destroy takes nothing returns nothing
                local Timer durationTimer = this.durationTimer
                local Unit parent = this.parent
                local BuffRef whichBuffRef = this.whichBuffRef
                local integer level = whichBuffRef.level
                local Buff whichBuff = whichBuffRef.whichBuff
                call this.deallocate()
                call durationTimer.Destroy()
                call Memory.IntegerKeys.D2.RemoveInteger(KEY, parent, whichBuff, level, NULL)
                call thistype(parent).Countdown.EndingByParent(whichBuff)
                if parent.Data.Integer.Table.Remove(KEY_ARRAY, this) then
                    call parent.Event.Remove(DEATH_EVENT)
                    call parent.Event.Remove(LOSE_EVENT)
                endif
                call whichBuffRef.Destroy()
                call whichBuffRef.SubtractRef()
            endmethod
            timerMethod EndingByTimer
                local thistype this = Timer.GetExpired().GetData()
                call this.Destroy()
            endmethod
            method EndingByParentWithLevel takes Buff whichBuff, integer level returns nothing
                local Unit parent = this
                set this = thistype(parent).Get(whichBuff, level)
                if (this != NULL) then
                    call this.Destroy()
                endif
            endmethod
            method EndingByParent takes Buff whichBuff returns nothing
                call this.EndingByParentWithLevel(whichBuff, 1)
            endmethod
            eventMethod Event_Lose
                local integer level = params.Buff.GetLevel()
                local Unit parent = params.Unit.GetTrigger()
                local Buff whichBuff = params.Buff.GetTrigger()
                local thistype this = thistype(parent).Get(whichBuff, level)
                if (this != NULL) then
                    call this.Destroy()
                endif
            endmethod
            eventMethod Event_Death
                local Unit parent = params.Unit.GetTrigger()
                local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                loop
                    local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                    call this.Destroy()
                    set iteration = iteration - 1
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                endloop
            endmethod
            method AddTime takes Buff whichBuff, real duration returns nothing
                local Unit parent = this
                set this = thistype(parent).Get(whichBuff, Unit(this).Buffs.GetLevel(whichBuff))
                local Timer durationTimer = this.durationTimer
                call thistype(parent).Countdown.EndingByParent(whichBuff)
                set duration = duration + durationTimer.GetRemaining()
                call durationTimer.Start(duration, false, function thistype.EndingByTimer)
                if not whichBuff.IsHidden() then
                    if (parent.Classes.Contains(UnitClass.HERO) or whichBuff.IsShowCountdown()) then
                        call thistype(parent).Countdown.Start(whichBuff, duration)
                    endif
                endif
            endmethod
            method StartEx takes Buff whichBuff, integer level, integer data, real duration returns BuffRef
                local Unit parent = this
                set this = this.Get(whichBuff, level)
				local Timer durationTimer
				local BuffRef whichBuffRef
                if (this == NULL) then
                    set whichBuffRef = parent.Buffs.CreateWithLevel(whichBuff, level, data)
                    if (whichBuffRef == NULL) then
                        return NULL
                    endif
                    set durationTimer = Timer.Create()
                    set this = thistype.allocate()
                    set this.durationTimer = durationTimer
                    set this.parent = parent
                    set this.whichBuffRef = whichBuffRef
                    call durationTimer.SetData(this)
                    call Memory.IntegerKeys.D2.SetInteger(KEY, parent, whichBuff, level, NULL, this)
                    call durationTimer.Start(duration, false, function thistype.EndingByTimer)
                    if parent.Data.Integer.Table.Add(KEY_ARRAY, this) then
                        call parent.Event.Add(DEATH_EVENT)
                        call parent.Event.Add(LOSE_EVENT)
                    endif
                    call whichBuffRef.AddRef()
                else
                    set durationTimer = this.durationTimer
                    if (duration > durationTimer.GetRemaining()) then
                        call durationTimer.Start(duration, false, function thistype.EndingByTimer)
                    endif
                    return NULL
                endif
                if not whichBuff.IsHidden() then
                    if (duration != thistype.INFINITE) then
                        if (parent.Classes.Contains(UnitClass.HERO) or whichBuff.IsShowCountdown()) then
                            call thistype(parent).Countdown.Start(whichBuff, duration)
                        endif
                    endif
                endif
                return whichBuffRef
            endmethod
            method Start takes Buff whichBuff, integer level, real duration returns BuffRef
                return this.StartEx(whichBuff, level, NULL, duration)
            endmethod
            method DoWithLevel takes Buff whichBuff, integer level, integer data, real duration returns BuffRef
                return this.StartEx(whichBuff, level, data, duration)
            endmethod
            method Do takes Buff whichBuff, integer data, real duration returns BuffRef
                return this.DoWithLevel(whichBuff, 1, data, duration)
            endmethod
            static method Init takes nothing returns nothing
                set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Death)
                set thistype.LOSE_EVENT = Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Lose)
                call thistype(NULL).Countdown.Init()
            endmethod
        endstruct
    endscope
    public struct StructBuffs
        implement Allocation
        implement List
        
        static Event DEATH_EVENT
        static Event DESTROY_EVENT
        static constant string DISPEL_EFFECT_ATTACH_POINT = AttachPoint.ORIGIN
        static constant string DISPEL_EFFECT_PATH = "Abilities\\Spells\\Human\\DispelMagic\\DispelMagicTarget.mdl"
    static key GetKeyMacro_EFFECTS_KEY
    static constant integer EFFECTS_KEY = Math.Integer.MIN + GetKeyMacro_EFFECTS_KEY
        static constant real INFINITE_DURATION = -1.
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_LEVELS_KEY_ARRAY_DETAIL
    static constant integer LEVELS_KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_LEVELS_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_LOOP_SOUNDS_KEY
    static constant integer LOOP_SOUNDS_KEY = Math.Integer.MIN + GetKeyMacro_LOOP_SOUNDS_KEY
    FolderBuffs_StructEvents Events = this
    FolderBuffs_StructEvents LinkToStruct_Events
    FolderBuffs_StructTimed Timed = this
    FolderBuffs_StructTimed LinkToStruct_Timed
        method Contains takes Buff whichBuff returns boolean
            return Unit(this).Data.Integer.Contains(KEY_ARRAY_DETAIL + whichBuff)
        endmethod
        method Count takes nothing returns integer
            return Unit(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns Buff
            return Unit(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method GetRemainingDuration takes Buff whichBuff, integer level returns real
            local real result
            if not this.Contains(whichBuff) then
                return 0.
            endif
            set result = this.Timed.GetRemainingDuration(whichBuff, level)
            if (result == 0.) then
                return thistype.INFINITE_DURATION
            endif
            return result
        endmethod
        method CountVisible takes nothing returns integer
            local integer iteration = this.Count()
            local integer result = Memory.IntegerKeys.Table.EMPTY
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                if not this.Get(iteration).IsHidden() then
                    set result = result + 1
                endif
                set iteration = iteration - 1
            endloop
            return result
        endmethod
        method CountVisibleEx takes boolean negative, boolean positive returns integer
            local boolean isPositive
            local integer iteration = this.Count()
            local integer result = Memory.IntegerKeys.Table.EMPTY
            local Buff whichBuff
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                set whichBuff = this.Get(iteration)
                if not whichBuff.IsHidden() then
                    set isPositive = whichBuff.IsPositive()
                    if ((negative and not isPositive) or (positive and isPositive)) then
                        set result = result + 1
                    endif
                endif
                set iteration = iteration - 1
            endloop
            return result
        endmethod
        method GetVisible takes integer index returns Buff
            local integer count = this.Count()
            local Buff current
            local integer found = Memory.IntegerKeys.Table.EMPTY
            local integer iteration = Memory.IntegerKeys.Table.STARTED
            loop
                exitwhen (iteration > count)
                set current = this.Get(iteration)
                if not current.IsHidden() then
                    set found = found + 1
                    if (found == index) then
                        return current
                    endif
                endif
                set iteration = iteration + 1
            endloop
            return NULL
        endmethod
        method GetLevel takes Buff whichBuff returns integer
            return Unit(this).Data.Integer.Get(LEVELS_KEY_ARRAY_DETAIL + whichBuff)
        endmethod
        method RemoveBySelf takes integer buffId returns nothing
            call Unit(this).Abilities.RemoveBySelf(buffId)
        endmethod
    static key GetKeyMacro_LOCAL_REFS_KEY
    static constant integer LOCAL_REFS_KEY = Math.Integer.MIN + GetKeyMacro_LOCAL_REFS_KEY
        method Remove [autoExec] takes Buff whichBuff returns boolean
            if not this.Contains(whichBuff) then
                return false
            endif
            local integer dummySpellId = whichBuff.GetDummySpellId()
            local integer level = this.GetLevel(whichBuff)
            if (dummySpellId != 0) then
                call Unit(this).Abilities.RemoveBySelf(dummySpellId)
                call Unit(this).Abilities.RemoveBySelf(whichBuff.self)
            endif
            call Unit(this).Data.Integer.Remove(KEY_ARRAY_DETAIL + whichBuff)
            call Unit(this).Data.Integer.Remove(LEVELS_KEY_ARRAY_DETAIL + whichBuff)
call Memory.IntegerKeys.D2.Table.ClearIntegers(LOCAL_REFS_KEY, this, whichBuff, NULL)
            if Unit(this).Data.Integer.Table.Remove(KEY_ARRAY, whichBuff) then
                call Unit(this).Event.Remove(DEATH_EVENT)
                call Unit(this).Event.Remove(DESTROY_EVENT)
            endif
            local UnitEffect whichEffect = Memory.IntegerKeys.D2.Table.FetchFirstInteger(EFFECTS_KEY, this, whichBuff, NULL)
            loop
                exitwhen (whichEffect == NULL)
                call whichEffect.Destroy()
                set whichEffect = Memory.IntegerKeys.D2.Table.FetchFirstInteger(EFFECTS_KEY, this, whichBuff, NULL)
            endloop
            local UnitSound whichSound = Memory.IntegerKeys.D2.Table.FetchFirstInteger(LOOP_SOUNDS_KEY, this, whichBuff, NULL)
            loop
                exitwhen (whichSound == NULL)
                call whichSound.Destroy()
                set whichSound = Memory.IntegerKeys.D2.Table.FetchFirstInteger(LOOP_SOUNDS_KEY, this, whichBuff, NULL)
            endloop
            call BuffRef.Event_BuffLose(whichBuff, this)
            call this.Events.Lose.Start(whichBuff, level)
            local integer iteration = whichBuff.Variants.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                
                call this.Remove(whichBuff.Variants.Get(iteration))
                set iteration = iteration - 1
            endloop
            call this.RemoveVariantParents(whichBuff)
            return true
        endmethod
        method AddRaw [autoExec] takes Buff whichBuff, integer level, integer data returns boolean
            if this.Contains(whichBuff) then
                local integer oldLevel = this.GetLevel(whichBuff)
                if (level != oldLevel) then
                    call Unit(this).Data.Integer.Set(LEVELS_KEY_ARRAY_DETAIL + whichBuff, level)
                    call this.Events.ChangeLevel.Start(whichBuff, oldLevel, level, data)
                endif
                return false
            endif
            if Unit(this).IsDestroyed() then
                return false
            endif
            if (whichBuff.IsLostOnDeath() and Unit(this).Classes.Contains(UnitClass.DEAD)) then
                return false
            endif
            if Unit(this).Data.Integer.Table.Add(KEY_ARRAY, whichBuff) then
                call Unit(this).Event.Add(DEATH_EVENT)
                call Unit(this).Event.Add(DESTROY_EVENT)
            endif
            call Unit(this).Data.Integer.Add(KEY_ARRAY_DETAIL + whichBuff, 1)
            call Unit(this).Data.Integer.Set(LEVELS_KEY_ARRAY_DETAIL + whichBuff, level)
            local integer dummySpellId = whichBuff.GetDummySpellId()
            if (dummySpellId != 0) then
                call Unit(this).Abilities.AddBySelf(dummySpellId)
                call Unit(this).Abilities.SetLevelBySelf(dummySpellId, level)
            endif
            local integer iteration
			if whichBuff.TargetEffects.IsShownOnApply() then
				set iteration = whichBuff.TargetEffects.Count()
	            loop
	                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
	
	                call Memory.IntegerKeys.D2.Table.AddInteger(EFFECTS_KEY, this, whichBuff, NULL, Unit(this).Effects.Create(whichBuff.TargetEffects.GetPath(iteration), whichBuff.TargetEffects.GetAttachPoint(iteration), whichBuff.TargetEffects.GetLevel(iteration)))
	
	                set iteration = iteration - 1
	            endloop
            endif
            set iteration = whichBuff.LoopSounds.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                call Memory.IntegerKeys.D2.Table.AddInteger(LOOP_SOUNDS_KEY, this, whichBuff, NULL, Unit(this).Sounds.Create(whichBuff.LoopSounds.Get(iteration)))
                set iteration = iteration - 1
            endloop
            call this.AddVariantParents(whichBuff, level, data)
            call this.Events.Gain.Start(whichBuff, level, data)
            return true
        endmethod
        method SetLevel takes Buff whichBuff, integer level, integer data returns nothing
            local integer oldLevel = this.GetLevel(whichBuff)
            if (oldLevel == level) then
                return
            endif
            if (level > 0) then
                call this.AddRaw(whichBuff, level, data)
            else
                call this.Remove(whichBuff)
            endif
        endmethod
        method Dispel takes boolean negative, boolean positive, boolean useUI returns integer
            if useUI then
                call Unit(this).Effects.Create(thistype.DISPEL_EFFECT_PATH, thistype.DISPEL_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
            endif
            local integer count = 0
            local integer iteration = this.Count()
            loop
                local Buff whichBuff = this.Get(iteration)
                if whichBuff.IsLostOnDispel() then
                    if whichBuff.IsPositive() then
                        if positive then
                            set count = count + 1
                            call this.Remove(whichBuff)
                        endif
                    else
                        if negative then
                            set count = count + 1
                            call this.Remove(whichBuff)
                        endif
                    endif
                endif
                set iteration = iteration - 1
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            endloop
            
            return count
        endmethod
        method Steal takes Unit target, boolean negative, boolean positive, integer level returns nothing
            local thistype targetThis = target
			local integer count = ARRAY_EMPTY
			local real array duration
            local integer iteration = targetThis.Count()
            local Buff array temp
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local Buff current = targetThis.Get(iteration)
                if (not current.IsHidden() and ((current.IsPositive() and positive) or (not current.IsPositive() and negative)) and (target.Buffs.GetLevel(current) <= level)) then
                    set count = count + 1
                    set duration[count] = target.Buffs.GetRemainingDuration(current, target.Buffs.GetLevel(current))
                    set temp[count] = current
                    call target.Buffs.Remove(current)
                endif
                set iteration = iteration - 1
            endloop
            loop
                exitwhen (count < ARRAY_MIN)
                call this.AddWithDuration(temp[count], level, NULL, duration[count])
                set count = count - 1
            endloop
        endmethod
        eventMethod Event_Death
            local thistype this = params.Unit.GetTrigger()
            local integer iteration = this.Count()
            loop
                local Buff whichBuff = this.Get(iteration)
                if whichBuff.IsLostOnDeath() then
                    call this.Remove(whichBuff)
                endif
                set iteration = iteration - 1
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            endloop
        endmethod
        eventMethod Event_Destroy
            local thistype this = params.Unit.GetTrigger()
            local integer iteration = this.Count()
            loop
                local Buff whichBuff = this.Get(iteration)
                call this.Remove(whichBuff)
                set iteration = iteration - 1
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            endloop
        endmethod
        method Create takes Buff whichBuff, integer data returns BuffRef
            local BuffRef whichRef = BuffRef.Create(whichBuff, this, data)
            return whichRef
        endmethod
        method CreateWithLevel takes Buff whichBuff, integer level, integer data returns BuffRef
            local BuffRef whichRef = BuffRef.CreateWithLevel(whichBuff, level, this, data)
            return whichRef
        endmethod
    static key GetKeyMacro_VARIANT_REFS_KEY
    static constant integer VARIANT_REFS_KEY = Math.Integer.MIN + GetKeyMacro_VARIANT_REFS_KEY
        method RemoveVariantParents takes Buff whichBuff returns nothing
            local BuffRef whichRef = Memory.IntegerKeys.D2.Table.FetchFirstInteger(VARIANT_REFS_KEY, this, whichBuff, NULL)
            loop
                exitwhen (whichRef == NULL)
                call whichRef.Destroy()
                set whichRef = Memory.IntegerKeys.D2.Table.FetchFirstInteger(VARIANT_REFS_KEY, this, whichBuff, NULL)
            endloop
        endmethod
        method AddVariantParents takes Buff whichBuff, integer level, integer data returns nothing
            local integer iteration = whichBuff.Variants.CountParents()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                call Memory.IntegerKeys.D2.Table.AddInteger(VARIANT_REFS_KEY, this, whichBuff, NULL, this.CreateWithLevel(whichBuff.Variants.GetParent(iteration), level, data))
                set iteration = iteration - 1
            endloop
        endmethod
        method Subtract takes Buff whichBuff returns boolean
        
          
        
            local BuffRef whichRef = Memory.IntegerKeys.D2.Table.FetchFirstInteger(LOCAL_REFS_KEY, this, whichBuff, NULL)
        
          
        
            if (whichRef == NULL) then
                return false
            endif
if whichBuff!=whichRef.whichBuff then
	call DebugEx(I2S(LOCAL_REFS_KEY)+"\t\t subtract CORRUPT buffref"+whichBuff.GetName()+";"+I2S(whichBuff)+";"+I2S(whichRef)+";"+I2S(whichRef.whichBuff))
endif
            call whichRef.Destroy()
            return true
        endmethod
        method AddEx takes Buff whichBuff, integer level, integer data returns boolean
            local BuffRef whichRef = this.CreateWithLevel(whichBuff, level, data)
            if (whichRef == NULL) then
                return false
            endif
	
	
            call Memory.IntegerKeys.D2.Table.AddInteger(LOCAL_REFS_KEY, this, whichBuff, NULL, whichRef)
            return true
        endmethod
        method Add takes Buff whichBuff, integer level returns boolean
            return this.AddEx(whichBuff, level, NULL)
        endmethod
        method AddFresh takes Buff whichBuff, integer level returns boolean
            call this.Remove(whichBuff)
            return this.Add(whichBuff, level)
        endmethod
        method AddFreshEx takes Buff whichBuff, integer level, integer data returns boolean
            call this.Remove(whichBuff)
            return this.AddEx(whichBuff, level, data)
        endmethod
        method AddWithDuration takes Buff whichBuff, integer level, integer data, real duration returns BuffRef
            if (duration == thistype.INFINITE_DURATION) then
                return this.CreateWithLevel(whichBuff, level, data)
            endif
            return this.Timed.DoWithLevel(whichBuff, level, data, duration)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Death)
            set thistype.DESTROY_EVENT = Event.Create(UNIT.DESTROY_EVENT_TYPE, EventPriority.HEADER_TOP, function thistype.Event_Destroy)
            call thistype(NULL).Events.Init()
            call thistype(NULL).Timed.Init()
        endmethod
    endstruct
    public struct StructModSets
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        method Remove takes UnitModSet val returns nothing
            call Unit(this).Data.Integer.Table.Remove(KEY_ARRAY, val)
            call val.RemoveFromUnit(this)
        endmethod
        method Add takes UnitModSet val returns nothing
            call Unit(this).Data.Integer.Table.Add(KEY_ARRAY, val)
            call val.AddToUnit(this)
        endmethod
    endstruct
    scope FolderItems
    scope FolderEvents
    public struct StructGain
        implement Allocation
        implement List
        
                static EventType DUMMY_EVENT_TYPE
                static Trigger DUMMY_TRIGGER
                static boolean IGNORE_NEXT = false
                static UnitList REG_GROUP
                method TriggerEvents takes Item whichItem, integer whichSlot returns nothing
                    local Unit parent = this
                    local ItemType whichItemType = whichItem.Type.Get()
                    local EventResponse itemTypeParams = EventResponse.Create(whichItemType.Id.Get())
                    call itemTypeParams.Item.SetTrigger(whichItem)
                    call itemTypeParams.Item.SetTriggerSlot(whichSlot)
                    call itemTypeParams.ItemType.SetTrigger(whichItemType)
                    call itemTypeParams.Unit.SetTrigger(parent)
					local EventResponse params = EventResponse.Create(parent.Id.Get())
                    call params.Item.SetTrigger(whichItem)
                    call params.Item.SetTriggerSlot(whichSlot)
                    call params.ItemType.SetTrigger(whichItemType)
                    call params.Unit.SetTrigger(parent)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = whichItemType.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call whichItemType.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(itemTypeParams)
                            if not parent.Items.Contains(whichItem) then
                                return
                            endif
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration2 = parent.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                            if not parent.Items.Contains(whichItem) then
                                return
                            endif
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call itemTypeParams.Destroy()
                    call params.Destroy()
                endmethod
                static method TrigConds takes Unit parent returns boolean
                    if not thistype.REG_GROUP.Contains(parent) then
                        return false
                    endif
                    return true
                endmethod
                trigMethod Trig
                    local Unit parent = UNIT.Event.Native.GetTrigger()
                    if not thistype.TrigConds(parent) then
                        return
                    endif
                    if thistype.IGNORE_NEXT then
                        set thistype.IGNORE_NEXT = false
                        return
                    endif
                    local Item whichItem = ITEM.Event.Native.GetTrigger()
                    if (whichItem == NULL) then
                        return
                    endif
                    if whichItem.Classes.Contains(ItemClass.POWER_UP) then
                        call parent.Items.Events.Use.StartByPowerUp(whichItem)
                        return
                    endif
                    local integer whichSlot = parent.Items.AddOnlySave(whichItem)
                    call thistype(parent).TriggerEvents(whichItem, whichSlot)
                endmethod
                method Event_Destroy takes nothing returns nothing
                    call thistype.REG_GROUP.Remove(this)
                endmethod
                method Event_Create takes nothing returns nothing
                    call thistype.REG_GROUP.Add(this)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                    set thistype.DUMMY_TRIGGER = Trigger.CreateFromCode(function thistype.Trig)
                    set thistype.REG_GROUP = UnitList.Create()
                    call thistype.DUMMY_TRIGGER.RegisterEvent.PlayerUnit(User.ANY, EVENT_PLAYER_UNIT_PICKUP_ITEM, null)
                endmethod
            endstruct
    public struct StructLose
        implement Allocation
        implement List
        
                static EventType DUMMY_EVENT_TYPE
                static Trigger DUMMY_TRIGGER
                static boolean IGNORE_NEXT = false
                static UnitList REG_GROUP
                method TriggerEvents takes Item whichItem, integer whichSlot returns nothing
                    local Unit parent = this
                    local ItemType whichItemType = whichItem.Type.Get()
                    local EventResponse itemTypeParams = EventResponse.Create(whichItemType.Id.Get())
                    call itemTypeParams.Item.SetTrigger(whichItem)
                    call itemTypeParams.Item.SetTriggerSlot(whichSlot)
                    call itemTypeParams.ItemType.SetTrigger(whichItemType)
                    call itemTypeParams.Unit.SetTrigger(parent)
					local EventResponse params = EventResponse.Create(parent.Id.Get())
                    call params.Item.SetTrigger(whichItem)
                    call params.Item.SetTriggerSlot(whichSlot)
                    call params.ItemType.SetTrigger(whichItemType)
                    call params.Unit.SetTrigger(parent)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = whichItemType.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call whichItemType.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(itemTypeParams)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration2 = parent.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call itemTypeParams.Destroy()
                    call params.Destroy()
                endmethod
                static method TrigConds takes Unit parent returns boolean
                    if not thistype.REG_GROUP.Contains(parent) then
                        return false
                    endif
                    return true
                endmethod
                trigMethod Trig                    
                    local Unit parent = UNIT.Event.Native.GetTrigger()
                    if not thistype.TrigConds(parent) then
                        return
                    endif
                    if thistype.IGNORE_NEXT then
                        set thistype.IGNORE_NEXT = false
                        return
                    endif
                    local Item whichItem = ITEM.Event.Native.GetTrigger()
                    if (whichItem == NULL) then
                        return
                    endif
                    local integer whichSlot = parent.Items.RemoveOnlySave(whichItem)
                    call thistype(parent).TriggerEvents(whichItem, whichSlot)
                endmethod
                method Event_Destroy takes nothing returns nothing
                    call thistype.REG_GROUP.Remove(this)
                endmethod
                method Event_Create takes nothing returns nothing
                    call thistype.REG_GROUP.Add(this)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                    set thistype.DUMMY_TRIGGER = Trigger.CreateFromCode(function thistype.Trig)
                    set thistype.REG_GROUP = UnitList.Create()
                    call thistype.DUMMY_TRIGGER.RegisterEvent.PlayerUnit(User.ANY, EVENT_PLAYER_UNIT_DROP_ITEM, null)
                endmethod
            endstruct
    public struct StructMoveInInventory
        implement Allocation
        implement List
        
                static EventType DUMMY_EVENT_TYPE
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
                static Event ORDER_EVENT
                static method TriggerEvents takes Item whichItem, integer whichSlot, Item targetItem, integer targetSlot, Unit whichUnit returns nothing
                    local EventResponse unitParams = EventResponse.Create(whichUnit.Id.Get())
                    call unitParams.Item.SetTarget(targetItem)
                    call unitParams.Item.SetTargetSlot(targetSlot)
                    call unitParams.Item.SetTrigger(whichItem)
                    call unitParams.Item.SetTriggerSlot(whichSlot)
                    call unitParams.Unit.SetTrigger(whichUnit)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = whichUnit.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call whichUnit.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(unitParams)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call unitParams.Destroy()
                endmethod
                eventMethod Event_Order
                    local Item sourceItem = params.Item.GetTarget()
                    local integer targetSlot = params.Order.GetTrigger().Data.Integer.Get(KEY)
                    local Unit whichUnit = params.Unit.GetTrigger()
                    local integer sourceSlot = whichUnit.Items.GetSlot(sourceItem)
                    local Item targetItem = whichUnit.Items.GetFromSlot(targetSlot)
                    call whichUnit.Items.SetSlotOnlySave(sourceItem, targetSlot)
                    if (targetItem != NULL) then
                        call whichUnit.Items.SetSlotOnlySave(targetItem, sourceSlot)
                    endif
                    call thistype.TriggerEvents(sourceItem, sourceSlot, targetItem, targetSlot, whichUnit)
                endmethod
                static method Create takes Order whichOrder, integer slot returns nothing
                    call whichOrder.Data.Integer.Set(KEY, slot)
                    call whichOrder.Event.Add(ORDER_EVENT)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                    set thistype.ORDER_EVENT = Event.Create(UNIT.Order.Events.Gain.Target.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Order)
                    call thistype.Create(Order.MOVE_ITEM_TO_SLOT_0, 0)
                    call thistype.Create(Order.MOVE_ITEM_TO_SLOT_1, 1)
                    call thistype.Create(Order.MOVE_ITEM_TO_SLOT_2, 2)
                    call thistype.Create(Order.MOVE_ITEM_TO_SLOT_3, 3)
                    call thistype.Create(Order.MOVE_ITEM_TO_SLOT_4, 4)
                    call thistype.Create(Order.MOVE_ITEM_TO_SLOT_5, 5)
                endmethod
            endstruct
    public struct StructSell
        implement Allocation
        implement List
        
                static EventType DUMMY_EVENT_TYPE
                static Trigger DUMMY_TRIGGER
                static UnitList REG_GROUP
                method TriggerEvents takes Unit purchaser, Item whichItem returns nothing
                    local ItemType whichItemType = whichItem.Type.Get()
                    local EventResponse itemTypeParams = EventResponse.Create(whichItemType.Id.Get())
                    call itemTypeParams.Item.SetTrigger(whichItem)
                    call itemTypeParams.ItemType.SetTrigger(whichItemType)
                    call itemTypeParams.Unit.SetTarget(purchaser)
                    call itemTypeParams.Unit.SetTrigger(this)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = whichItemType.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call whichItemType.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(itemTypeParams)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call itemTypeParams.Destroy()
                endmethod
                static method TrigConds takes Unit parent returns boolean
                    if not thistype.REG_GROUP.Contains(parent) then
                        return false
                    endif
                    return true
                endmethod
                trigMethod Trig
                    local Unit shop = UNIT.Event.Native.GetTrigger()
                    if not thistype.TrigConds(shop) then
                        return
                    endif
                    local Unit purchaser = UNIT.Event.Native.GetPurchaser()
                    local Item whichItem = Item.CreateFromSelf(GetSoldItem())
                    call purchaser.Effects.Create("Abilities\\Spells\\Items\\TomeOfRetraining\\TomeOfRetrainingCaster.mdl", AttachPoint.ORIGIN, EffectLevel.NORMAL).Destroy()
                    call thistype(shop).TriggerEvents(purchaser, whichItem)
                endmethod
                method Event_Destroy takes nothing returns nothing
                    call thistype.REG_GROUP.Remove(this)
                endmethod
                method Event_Create takes nothing returns nothing
                    call thistype.REG_GROUP.Add(this)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                    set thistype.DUMMY_TRIGGER = Trigger.CreateFromCode(function thistype.Trig)
                    set thistype.REG_GROUP = UnitList.Create()
                    call thistype.DUMMY_TRIGGER.RegisterEvent.PlayerUnit(User.ANY, EVENT_PLAYER_UNIT_SELL_ITEM, null)
                endmethod
            endstruct
    public struct StructUse
        implement Allocation
        implement List
        
                static EventType DUMMY_EVENT_TYPE
                static Trigger DUMMY_TRIGGER
                static boolean IGNORE_NEXT = false
                static UnitList REG_GROUP
                static Buff SCROLL_COOLDOWN_BUFF
                method TriggerSpells_Enum takes Item whichItem, Spell whichSpell, integer level, Item targetItem, Unit targetUnit, real targetX, real targetY returns nothing
                    local SpellInstance whichInstance = SpellInstance.Create(this, whichSpell)
                    call whichInstance.SetLevel(level)
                    call whichInstance.SetTargetItem(targetItem)
                    call whichInstance.SetTargetUnit(targetUnit)
                    call whichInstance.SetTargetX(targetX)
                    call whichInstance.SetTargetY(targetY)
                    call Unit(this).Abilities.Events.Effect.StartByItem(whichInstance, whichItem)
                endmethod
                method TriggerSpells takes Item whichItem returns nothing
                    local integer iteration = whichItem.Abilities.Count()
                    local integer level
                    local SpellInstance triggerInstance = Unit(this).Abilities.Events.Effect.GetSpellInstance()
                    local Spell whichSpell
                    local Item targetItem = triggerInstance.GetTargetItem()
                    local Unit targetUnit = triggerInstance.GetTargetUnit()
                    local real targetX = triggerInstance.GetTargetX()
                    local real targetY = triggerInstance.GetTargetY()
                    loop
                        exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                        set whichSpell = whichItem.Abilities.Get(iteration)
                        set level = whichItem.Abilities.GetLevel(whichSpell)
                        call this.TriggerSpells_Enum(whichItem, whichSpell, level, targetItem, targetUnit, targetX, targetY)
                        set iteration = iteration - 1
                    endloop
                endmethod
                method TriggerEvents takes Item whichItem returns nothing
                    local ItemType whichItemType = whichItem.Type.Get()
                    local EventResponse itemTypeParams = EventResponse.Create(whichItemType.Id.Get())
                    call itemTypeParams.Item.SetTrigger(whichItem)
                    call itemTypeParams.ItemType.SetTrigger(whichItemType)
                    call itemTypeParams.Unit.SetTrigger(this)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = whichItemType.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call whichItemType.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(itemTypeParams)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call itemTypeParams.Destroy()
                    call this.TriggerSpells(whichItem)
                endmethod
                static method TrigConds takes Unit parent returns boolean
                    if not thistype.REG_GROUP.Contains(parent) then
                        return false
                    endif
                    return true
                endmethod
                method Start takes Item whichItem returns nothing
                    local boolean isScroll = whichItem.Classes.Contains(ItemClass.SCROLL)
                    if (not isScroll or not Unit(this).Buffs.Contains(thistype.SCROLL_COOLDOWN_BUFF)) then
                        call this.TriggerEvents(whichItem)
                    endif
                    if isScroll then
                        call Unit(this).Buffs.Timed.Start(thistype.SCROLL_COOLDOWN_BUFF, 1, 0.01)
                        call whichItem.ChargesAmount.Update()
                    elseif whichItem.Classes.Contains(ItemClass.POWER_UP) then
                        call whichItem.Destroy()
                    else
                        if (whichItem.ChargesAmount.Get() > 0) then
                            call whichItem.ChargesAmount.Subtract(1)
                        endif
                    endif
                endmethod
                method StartByPowerUp takes Item whichItem returns nothing
                    
                    call this.Start(whichItem)
                endmethod
                trigMethod Trig
                    local Unit parent = UNIT.Event.Native.GetTrigger()
                    if not thistype.TrigConds(parent) then
                        return
                    endif
                    local Item whichItem = ITEM.Event.Native.GetTrigger()
                    call thistype(parent).Start(whichItem)
                endmethod
                method Event_Destroy takes nothing returns nothing
                    call thistype.REG_GROUP.Remove(this)
                endmethod
                method Event_Create takes nothing returns nothing
                    call thistype.REG_GROUP.Add(this)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                    set thistype.DUMMY_TRIGGER = Trigger.CreateFromCode(function thistype.Trig)
                    set thistype.REG_GROUP = UnitList.Create()
                    set thistype.SCROLL_COOLDOWN_BUFF = Buff.CreateHidden(thistype.NAME)
                    call thistype.DUMMY_TRIGGER.RegisterEvent.PlayerUnit(User.ANY, EVENT_PLAYER_UNIT_USE_ITEM, null)
                endmethod
            endstruct
        endscope
    public struct StructEvents
        implement Allocation
        implement List
        
    FolderEvents_StructGain Gain = this
    FolderEvents_StructGain LinkToStruct_Gain
    FolderEvents_StructLose Lose = this
    FolderEvents_StructLose LinkToStruct_Lose
    FolderEvents_StructMoveInInventory MoveInInventory = this
    FolderEvents_StructMoveInInventory LinkToStruct_MoveInInventory
    FolderEvents_StructSell Sell = this
    FolderEvents_StructSell LinkToStruct_Sell
    FolderEvents_StructUse Use = this
    FolderEvents_StructUse LinkToStruct_Use
            method Event_Destroy takes nothing returns nothing
                call this.Gain.Event_Destroy()
                call this.Lose.Event_Destroy()
                call this.Sell.Event_Destroy()
                call this.Use.Event_Destroy()
            endmethod
            method Event_Create takes nothing returns nothing
                call this.Gain.Event_Create()
                call this.Lose.Event_Create()
                call this.Sell.Event_Create()
                call this.Use.Event_Create()
            endmethod
            static method Init takes nothing returns nothing
                call thistype(NULL).Gain.Init()
                call thistype(NULL).Lose.Init()
                call thistype(NULL).MoveInInventory.Init()
                call thistype(NULL).Sell.Init()
                call thistype(NULL).Use.Init()
            endmethod
        endstruct
    endscope
    public struct StructItems
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_SLOT_KEY_ARRAY_DETAIL
    static constant integer SLOT_KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_SLOT_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    FolderItems_StructEvents Events = this
    FolderItems_StructEvents LinkToStruct_Events
        method GetFromSlot takes integer slot returns Item
            return Unit(this).Data.Integer.Get(KEY_ARRAY_DETAIL + slot)
        endmethod
        method GetInventorySize takes nothing returns integer
            return UnitInventorySize(Unit(this).self)
        endmethod
        method GetFirstFreeIndex takes nothing returns integer
            local integer inventorySize = this.GetInventorySize() - 1
            local integer iteration = 0
            loop
                exitwhen (iteration > inventorySize)
                if (this.GetFromSlot(iteration) == NULL) then
                    return iteration
                endif
                set iteration = iteration + 1
            endloop
            return -1
        endmethod
        method GetFirstOfType takes ItemType whichType returns Item
            local integer inventorySize = this.GetInventorySize() - 1
            local integer iteration = 0
            local Item thisItem
            loop
                exitwhen (iteration > inventorySize)
                set thisItem = this.GetFromSlot(iteration)
                if (thisItem.Type.Get() == whichType) then
                    return thisItem
                endif
                set iteration = iteration + 1
            endloop
            return NULL
        endmethod
        method GetSlot takes Item whichItem returns integer
            local integer result = Unit(this).Data.Integer.Get(SLOT_KEY_ARRAY_DETAIL + whichItem)
            if (result == HASH_TABLE.Integer.DEFAULT_VALUE) then
                return -1
            endif
            return (result - HASH_TABLE.Integer.DEFAULT_VALUE - 1)
        endmethod
        method Contains takes Item whichItem returns boolean
            return (this.GetSlot(whichItem) != -1)
        endmethod
        method RemoveOnlySave takes Item whichItem returns integer
            if not whichItem.Classes.Contains(ItemClass.POWER_UP) then
                local integer whichSlot = this.GetSlot(whichItem)
                call Unit(this).Data.Integer.Remove(KEY_ARRAY_DETAIL + whichSlot)
                call Unit(this).Data.Integer.Remove(SLOT_KEY_ARRAY_DETAIL + whichItem)
                call whichItem.SetSlot(-1)
                return whichSlot
            endif
            return -1
        endmethod
        method Remove takes Item whichItem returns nothing
            call this.RemoveOnlySave(whichItem)
            call whichItem.Position.Set(Unit(this).Position.X.Get(), Unit(this).Position.Y.Get())
        endmethod
        method SetSlotOnlySave takes Item whichItem, integer slot returns nothing
            call Unit(this).Data.Integer.Remove(KEY_ARRAY_DETAIL + this.GetSlot(whichItem))
            call Unit(this).Data.Integer.Remove(SLOT_KEY_ARRAY_DETAIL + whichItem)
            call Unit(this).Data.Integer.Set(KEY_ARRAY_DETAIL + slot, whichItem)
            call Unit(this).Data.Integer.Set(SLOT_KEY_ARRAY_DETAIL + whichItem, HASH_TABLE.Integer.DEFAULT_VALUE + 1 + slot)
            call whichItem.SetSlot(slot)
        endmethod
        method SetSlot takes Item whichItem, integer slot returns nothing
            call this.SetSlotOnlySave(whichItem, slot)
            call UnitDropItemSlot(Unit(this).self, whichItem.self, slot)
        endmethod
        method AddOnlySave takes Item whichItem returns integer
            if whichItem.Classes.Contains(ItemClass.POWER_UP) then
                return -1
            endif
            local integer whichSlot = this.GetFirstFreeIndex()
            call Unit(this).Data.Integer.Set(KEY_ARRAY_DETAIL + whichSlot, whichItem)
            call Unit(this).Data.Integer.Set(SLOT_KEY_ARRAY_DETAIL + whichItem, HASH_TABLE.Integer.DEFAULT_VALUE + 1 + whichSlot)
            call whichItem.SetSlot(whichSlot)
            return whichSlot
        endmethod
        method Add takes Item whichItem returns nothing
            call UnitAddItem(Unit(this).self, whichItem.self)
        endmethod
        method AddPowerup takes nothing returns nothing
        endmethod
        method Create takes ItemType whichType, boolean test returns nothing
            call this.Add(Item.Create(whichType, Unit(this).Position.X.Get(), Unit(this).Position.Y.Get()))
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Events.Event_Create()
        endmethod
        static method Init takes nothing returns nothing
            call thistype(NULL).Events.Init()
        endmethod
    endstruct
    public struct StructClasses
        implement Allocation
        implement List
        
        static Event DESTROY_EVENT
        UnitList dummyGroup
        method Contains takes UnitClass whichType returns boolean
            return thistype(whichType).dummyGroup.Contains(this)
        endmethod
        method IsNative takes unittype whichUnitType returns boolean
            return IsUnitType(Unit(this).self, whichUnitType)
        endmethod
        method Remove takes UnitClass whichType returns nothing
            static if DEBUG then
                if not this.Contains(whichType) then
                    call DebugEx(thistype.NAME + ": cannot remove class " + whichType.GetName() + " from " + Unit(this).GetName())
                    return
                endif
            endif
            call thistype(whichType).dummyGroup.Remove(this)
        endmethod
        method RemoveNative takes unittype whichUnitType returns nothing
            call UnitRemoveType(Unit(this).self, whichUnitType)
        endmethod
        method Clear takes nothing returns nothing
            local integer iteration = UnitClass.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                if this.Contains(UnitClass.ALL[iteration]) then
                    call this.Remove(UnitClass.ALL[iteration])
                endif
                set iteration = iteration - 1
            endloop
        endmethod
        method Add takes UnitClass whichType returns nothing
            static if DEBUG then
                if this.Contains(whichType) then
                    call DebugEx(thistype.NAME + ": " + Unit(this).GetName() + " is already of class " + whichType.GetName())
                    return
                endif
            endif
            call thistype(whichType).dummyGroup.Add(this)
        endmethod
        method AddIllusion takes nothing returns nothing
            local integer iteration = Unit(this).Abilities.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                call Unit(this).Abilities.Remove(Unit(this).Abilities.Get(iteration))
                set iteration = iteration - 1
            endloop
            call this.Add(UnitClass.ILLUSION)
        endmethod
        method AddNative takes unittype whichUnitType returns nothing
            call UnitAddType(Unit(this).self, whichUnitType)
        endmethod
        eventMethod Event_TypeChange
            local UnitType targetType = params.UnitType.GetTrigger()
            local thistype this = params.Unit.GetTrigger()
            local integer iteration = targetType.Classes.Count()
            call this.Clear()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                call this.Add(targetType.Classes.Get(iteration))
                set iteration = iteration - 1
            endloop
        endmethod
        eventMethod Event_Destroy
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
            call parent.Event.Remove(thistype.DESTROY_EVENT)
            call this.Clear()
        endmethod
        method Event_Create takes nothing returns nothing
            local UnitType thisType = Unit(this).Type.Get()
            local integer iteration = thisType.Classes.Count()
            call Unit(this).Event.Add(thistype.DESTROY_EVENT)
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                call this.Add(thisType.Classes.Get(iteration))
                set iteration = iteration - 1
            endloop
        endmethod
        static method Create takes UnitClass whichClass returns thistype
            local thistype this = whichClass
            set this.dummyGroup = UnitList.Create()
            return this
        endmethod
        static method Init takes nothing returns nothing
            local integer iteration = UnitClass.ALL_COUNT
            set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
            call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            loop
                exitwhen (iteration < ARRAY_MIN)
                call thistype.Create(UnitClass.ALL[iteration])
                set iteration = iteration - 1
            endloop
        endmethod
    endstruct
    public struct StructType
        implement Allocation
        implement List
        
        static EventType DUMMY_EVENT_TYPE
        UnitType value
        method Get takes nothing returns UnitType
            return this.value
        endmethod
        method TriggerEvents takes UnitType sourceType, UnitType targetType returns nothing
        	local Unit parent = this
        	
            local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
            call params.Unit.SetTrigger(parent)
            call params.UnitType.SetSource(sourceType)
            call params.UnitType.SetTarget(targetType)
            call params.UnitType.SetTrigger(targetType)
            local EventResponse parentParams = EventResponse.Create(parent.Id.Get())
            call parentParams.Unit.SetTrigger(parent)
            call parentParams.UnitType.SetSource(sourceType)
            call parentParams.UnitType.SetTarget(targetType)
            call parentParams.UnitType.SetTrigger(targetType)
            local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = Event.CountAtStatics(thistype.DUMMY_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call Event.GetFromStatics(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration2 = parent.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(parentParams)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            call params.Destroy()
            call parentParams.Destroy()
        endmethod
        method Set takes UnitType targetType returns nothing
            local UnitType sourceType = this.Get()
            set this.value = targetType
            if ((sourceType == NULL) or (sourceType == targetType)) then
                return
            endif
            call this.TriggerEvents(sourceType, targetType)
        endmethod
        method SetWithChangerAbility takes UnitType targetType, integer abil returns nothing
            call Unit(this).Abilities.AddBySelf(abil)
            call Unit(this).Abilities.RemoveBySelf(abil)
            call this.Set(targetType)
        endmethod
        trigMethod UpgradeFinishTrig
            local thistype this = Unit.GetFromSelf(GetTriggerUnit())
            call this.Set(UnitType.GetFromSelf(GetUnitTypeId(GetTriggerUnit())))
            call Unit(this).Stop()
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = UnitType.GetFromSelf(GetUnitTypeId(Unit(this).self))
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DUMMY_EVENT_TYPE = EventType.Create()
            call Trigger.CreateFromCode(function thistype.UpgradeFinishTrig).RegisterEvent.PlayerUnit(User.ANY, EVENT_PLAYER_UNIT_UPGRADE_FINISH, null)
        endmethod
    endstruct
    public struct StructColor
        implement Allocation
        implement List
        
    playercolor value
    method Get takes nothing returns playercolor
        return this.value
    endmethod
        method Set takes playercolor value returns nothing
            set this.value = value
            call SetUnitColor(Unit(this).self, value)
        endmethod
        method Update takes nothing returns nothing
            call SetUnitColor(Unit(this).self, this.Get())
        endmethod
    endstruct
    public struct StructOwner
        implement Allocation
        implement List
        
        static EventType DUMMY_EVENT_TYPE
        User owner
        method Get takes nothing returns User
            return this.owner
        endmethod
        method TriggerEvents takes User value, User oldValue
            local Unit parent = this
            local EventResponse params = EventResponse.Create(parent.Id.Get())
            call params.Unit.SetTrigger(this)
            call params.User.SetSource(oldValue)
            call params.User.SetTarget(value)
            call params.User.SetTrigger(value)
			local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = parent.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            call params.Destroy()
        endmethod
		method SetNative takes User value, boolean doColor
			if (GetOwningPlayer(Unit(this).self) == value.self) then
				return
			endif
            if not GetPlayerAlliance(value.self, GetLocalPlayer(), ALLIANCE_SHARED_CONTROL) then
                
            endif
			call SetUnitOwner(Unit(this).self, value.self, doColor)
		endmethod
        method Set takes User value
            local User oldValue = this.Get()
            set this.owner = value
            if Unit(this).Madness.Is() then
                call this.SetNative(User.NEUTRAL_AGGRESSIVE, true)
            else
                call this.SetNative(value, true)
            endif
            call Unit(this).Color.Set(value.GetColor())
            if (value == oldValue) then
                return
            endif
            call this.TriggerEvents(value, oldValue)
        endmethod
		method Update takes nothing returns nothing
			call this.Set(this.Get())
		endmethod
        method Event_Create takes User value returns nothing
            set this.owner = value
            call Unit(this).Color.Set(value.GetColor())
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DUMMY_EVENT_TYPE = EventType.Create()
        endmethod
    endstruct
    scope FolderArmor
    public struct StructBase
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).Armor.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_TypeChange
                local UnitType sourceType = params.UnitType.GetSource()
                local UnitType targetType = params.UnitType.GetTrigger()
                local thistype this = params.Unit.GetTrigger()
                call this.Add(targetType.Armor.Get() - sourceType.Armor.Get())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = Unit(this).Type.Get().Armor.Get()
            endmethod
            static method Init takes nothing returns nothing
                call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            endmethod
        endstruct
    scope FolderBonus
    public struct StructDisplayed
        implement Allocation
        implement List
        
        static constant boolean WAIT_FOR_SELECTION = true
        real value
        method Get takes nothing returns real
            return this.value
        endmethod
        static if true then
            static Event SELECTION_EVENT
            real nativeValue
            boolean waitForSelection
            method SetNative takes real value, real oldValue returns nothing
                set this.nativeValue = value
                call BJUnit.Armor.Bonus.Set(Unit(this).self, value, oldValue)
            endmethod
            eventMethod Event_Selection
                local thistype this = params.Unit.GetTrigger()
                set this.waitForSelection = false
                call Unit(this).Event.Remove(SELECTION_EVENT)
                call this.SetNative(this.Get(), this.nativeValue)
            endmethod
            method SetDisplay takes real value returns nothing
                local real nativeValue = this.nativeValue
                set this.value = value
                if (value == nativeValue) then
                    if this.waitForSelection then
                        set this.waitForSelection = false
                        call Unit(this).Event.Remove(SELECTION_EVENT)
                    endif
                    return
                endif
                if Unit(this).Selection.IsEmpty() then
                    if not this.waitForSelection then
                        set this.waitForSelection = true
                        call Unit(this).Event.Add(SELECTION_EVENT)
                    endif
                else
                    call this.SetNative(value, nativeValue)
                endif
            endmethod
        else
            method SetDisplay takes real value returns nothing
                local real oldValue = this.Get()
                set this.value = value
                call BJUnit.Armor.Bonus.Set(Unit(this).self, value, oldValue)
            endmethod
        endif
        method AddOnlySave takes real value returns nothing
            set this.value = this.Get() + value
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0.
            static if true then
                set this.nativeValue = 0.
                set this.waitForSelection = false
            endif
        endmethod
				method Set takes real val returns nothing
					call this.SetDisplay(val)
				endmethod
                method Update takes nothing returns nothing
                    call this.Set(Unit(this).Armor.Base.Get() * (Unit(this).Armor.Relative.Get() - 1) + Unit(this).Armor.Bonus.Get())
                endmethod
                static method Init takes nothing returns nothing
                    static if thistype.WAIT_FOR_SELECTION then
                        set thistype.SELECTION_EVENT = Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Selection)
                    endif
                endmethod
            endstruct
        endscope
    public struct StructBonus
        implement Allocation
        implement List
        
            static UnitState STATE
    FolderBonus_StructDisplayed Displayed = this
    FolderBonus_StructDisplayed LinkToStruct_Displayed
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).Armor.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
                call this.Displayed.Event_Create()
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
                call thistype(NULL).Displayed.Init()
            endmethod
        endstruct
    scope FolderIgnoreDamage
    public struct StructRelative
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            endstruct
        endscope
    public struct StructIgnoreDamage
        implement Allocation
        implement List
        
    FolderIgnoreDamage_StructRelative Relative = this
    FolderIgnoreDamage_StructRelative LinkToStruct_Relative
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                call this.Relative.Event_Create()
            endmethod
        endstruct
    scope FolderRelative
    public struct StructInvisible
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
                method Set takes real value returns nothing
                    set this.value = value
                    call Unit(this).Armor.Update()
                endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
                method Event_Create takes nothing returns nothing
                    set this.value = 1.
                endmethod
            endstruct
        endscope
    public struct StructRelative
        implement Allocation
        implement List
        
        	static UnitState STATE
    FolderRelative_StructInvisible Invisible = this
    FolderRelative_StructInvisible LinkToStruct_Invisible
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).Armor.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 1.
                call Invisible.Event_Create()
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    public struct StructResistance
        implement Allocation
        implement List
        
            static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    public struct StructSpell
        implement Allocation
        implement List
        
        	static UnitState STATE
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
			method Event_Create
				set this.value = 0.
			endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    public struct StructTypeA
        implement Allocation
        implement List
        
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(Unit(this).Type.Get().Armor.Type.Get())
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_TypeChange
                local UnitType targetType = params.UnitType.GetTrigger()
                local thistype this = params.Unit.GetTrigger()
                call this.Set(targetType.Armor.Type.Get())
            endmethod
            static method Init takes nothing returns nothing
                call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            endmethod
        endstruct
    endscope
    public struct StructArmor
        implement Allocation
        implement List
        
    FolderArmor_StructBase Base = this
    FolderArmor_StructBase LinkToStruct_Base
    FolderArmor_StructBonus Bonus = this
    FolderArmor_StructBonus LinkToStruct_Bonus
    FolderArmor_StructIgnoreDamage IgnoreDamage = this
    FolderArmor_StructIgnoreDamage LinkToStruct_IgnoreDamage
    FolderArmor_StructRelative Relative = this
    FolderArmor_StructRelative LinkToStruct_Relative
    FolderArmor_StructResistance Resistance = this
    FolderArmor_StructResistance LinkToStruct_Resistance
    FolderArmor_StructSpell Spell = this
    FolderArmor_StructSpell LinkToStruct_Spell
    FolderArmor_StructTypeA TypeA = this
    FolderArmor_StructTypeA LinkToStruct_TypeA
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        real visVal
        real visBonusVal
        static method GetDamageFactor takes real value returns real
            if (value < 0.) then
                return (2. - Math.Power((1. - Attack.ARMOR_REDUCTION_FACTOR), -value))
            endif
            return (1. / (1. + Attack.ARMOR_REDUCTION_FACTOR * value))
        endmethod
        method GetVisible takes nothing returns real
            return this.visVal
        endmethod
        method GetVisibleBonus takes nothing returns real
            return this.visBonusVal
        endmethod
        method Set takes real value returns nothing
            set this.value = value
            call this.Bonus.Displayed.Update()
        endmethod
        method Update takes nothing returns nothing
            local real baseVal = this.Base.Get()
            local real relVal = this.Relative.Get()
            local real bonusVal = this.Bonus.Get()
            set this.visVal = baseVal * relVal + bonusVal
            set this.visBonusVal = baseVal * (relVal - 1) + bonusVal
            call this.Set(baseVal * relVal * this.Relative.Invisible.Get() + bonusVal)
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0.
            set this.visVal = 0.
            set this.visBonusVal = 0.
            call this.Base.Event_Create()
            call this.Bonus.Event_Create()
            call this.IgnoreDamage.Event_Create()
            call this.Relative.Event_Create()
            call this.Resistance.Event_Create()
            call this.Spell.Event_Create()
            call this.TypeA.Event_Create()
            call this.Update()
        endmethod
        static method Init takes nothing returns nothing
            call thistype(NULL).Base.Init()
            call thistype(NULL).Bonus.Init()
            call thistype(NULL).Relative.Init()
            call thistype(NULL).Resistance.Init()
            call thistype(NULL).Spell.Init()
            call thistype(NULL).TypeA.Init()
        endmethod
    endstruct
    scope FolderAttack
    scope FolderEvents
    public struct StructAcquire2
        implement Allocation
        implement List
        
                static Event DESTROY_EVENT
                static EventType DUMMY_EVENT_TYPE
                Timer delayTimer
                boolean running
                Unit target
                method Ending takes Timer delayTimer, Unit parent returns nothing
                    local Unit target = this.target
                    call delayTimer.Destroy()
                    set this.running = false
                    call target.Refs.Subtract()
                endmethod
                eventMethod Event_Destroy
                    local Unit parent = params.Unit.GetTrigger()
                    local thistype this = parent
                    call parent.Event.Remove(DESTROY_EVENT)
                    if this.running then
                        call this.Ending(this.delayTimer, parent)
                    endif
                endmethod
                method TriggerEvents takes Unit target returns nothing
                    local Unit parent = this
                    local EventResponse params = EventResponse.Create(parent.Id.Get())
                    call params.Unit.SetTarget(target)
                    call params.Unit.SetTrigger(this)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = Unit(this).Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call params.Destroy()
                endmethod
                timerMethod EndingByTimer
                    local Timer delayTimer = Timer.GetExpired()
                    local thistype this = delayTimer.GetData()
                    call this.Ending(delayTimer, this)
                    call this.TriggerEvents(target)
                endmethod
                method Start takes Unit target returns nothing
                    local Timer delayTimer = Timer.Create()
                    if this.running then
                        call this.Ending(this.delayTimer, this)
                    endif
                    set this.delayTimer = delayTimer
                    set this.running = true
                    set this.target = target
                    call delayTimer.SetData(this)
                    call target.Refs.Add()
                    call delayTimer.Start(0.01, false, function thistype.EndingByTimer)
                endmethod
                method Event_Create takes nothing returns nothing
                    set this.running = false
                    call Unit(this).Event.Add(DESTROY_EVENT)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
                    set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                endmethod
            endstruct
    public struct StructGround
        implement Allocation
        implement List
        
                static Event ATTACK_EVENT
                static Trigger DAMAGE_TRIGGER
                static Event DESTROY_EVENT
                static EventType DUMMY_EVENT_TYPE
                static Event DUMMY_UNIT_DESTROY_EVENT
                static constant real DURATION_TOLERANCE = 2.
                static Group ENUM_GROUP
                static UnitList ENUM_GROUP2
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
                static constant real MAX_DURATION = 30.
                static BoolExpr TARGET_FILTER
                Unit parent
                method DealPhysical_Single takes Unit target, real amount, integer whichType returns nothing
                    set amount = amount * (1. - target.Armor.IgnoreDamage.Relative.Get())
                    set amount = amount * UNIT.Armor.GetDamageFactor(target.Armor.Get())
                    set amount = amount * Attack.Get(whichType, target.Armor.TypeA.Get())
                    call target.Death.Explosion.Add()
                    call Unit(this).DamageUnit(target, amount, false)
                    call target.Death.Explosion.Subtract()
                endmethod
                condMethod Conditions
                    local Unit target = UNIT.Event.Native.GetFilter()
                    if (not TEMP_BOOLEAN and target.IsAllyOf(User.TEMP)) then
                        return false
                    endif
                    if target.Classes.Contains(UnitClass.DEAD) then
                        return false
                    endif
                    if not target.Classes.Contains(UnitClass.GROUND) then
                        return false
                    endif
                    return true
                endmethod
                method DealPhysical takes real x, real y returns nothing
                    local boolean affectsAlly = Unit(this).Attack.Splash.TargetFlag.Is(TargetFlag.ALLY)
                    local real damageAmount = Unit(this).Damage.Get() + Unit(this).Damage.Bonus.Get()
                    local integer damageSides = Unit(this).Damage.Sides.Get()
                    local integer damageType = Unit(this).Damage.TypeA.Get()
                    local integer iteration = Unit(this).Damage.Dices.Get()
                    local integer iterationEnd = Unit(this).Attack.Splash.Count()
                    local User parentOwner = Unit(this).Owner.Get()
                    local real rangeDamageAmount
                    local UnitAttackSplash splash
                    local Unit target
                    local real array targetFactorAll
                    loop
                        exitwhen (iteration < 1)
                        set damageAmount = damageAmount + Math.RandomI(1, damageSides)
                        set iteration = iteration - 1
                    endloop
                    set damageAmount = damageAmount * Unit(this).Damage.Relative.Get() * Unit(this).Damage.Relative.Invisible.Get()
                    set iteration = Memory.IntegerKeys.Table.STARTED
                    loop
                        exitwhen (iteration > iterationEnd)
                        set splash = Unit(this).Attack.Splash.Get(iteration)
                        set TEMP_BOOLEAN = affectsAlly
                        set User.TEMP = parentOwner
                        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, splash.GetAreaRange(), thistype.TARGET_FILTER)
                        loop
                            set target = thistype.ENUM_GROUP.FetchFirst()
                            exitwhen (target == NULL)
                            if not thistype.ENUM_GROUP2.Contains(target) then
                                set targetFactorAll[target] = 0.
                                call thistype.ENUM_GROUP2.Add(target)
                            endif
                            set targetFactorAll[target] = targetFactorAll[target] + splash.GetDamageFactor()
                        endloop
                        set iteration = iteration + 1
                    endloop
                    loop
                        set target = thistype.ENUM_GROUP2.FetchFirst()
                        exitwhen (target == NULL)
                        call this.DealPhysical_Single(target, damageAmount * targetFactorAll[target], damageType)
                    endloop
                endmethod
                method TriggerEvents takes real x, real y returns nothing
                    local Unit parent = this
                    local EventResponse params = EventResponse.Create(parent.Id.Get())
                    call params.Spot.SetTargetX(x)
                    call params.Spot.SetTargetY(y)
                    call params.Unit.SetTrigger(this)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = parent.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call params.Destroy()
                    call this.DealPhysical(x, y)
                endmethod
                eventMethod Event_Destroy
                    local Unit parent = params.Unit.GetTrigger()
                    call parent.Event.Remove(ATTACK_EVENT)
                    call parent.Event.Remove(DESTROY_EVENT)
                endmethod
                method Ending takes DummyUnit dummyUnit, Unit parent returns nothing
                    call this.deallocate()
                    call dummyUnit.Data.Integer.Remove(KEY)
                    call dummyUnit.Event.Remove(DUMMY_UNIT_DESTROY_EVENT)
                    call parent.Data.Integer.Table.Remove(KEY_ARRAY, this)
                    call parent.Refs.Subtract()
                endmethod
                eventMethod Event_DummyUnitDestroy
                    local DummyUnit dummyUnit = params.DummyUnit.GetTrigger()
                    local thistype this = dummyUnit.Data.Integer.Get(KEY)
                    call this.Ending(dummyUnit, this.parent)
                endmethod
                trigMethod DamageTrig
                    local DummyUnit dummyUnit = DUMMY_UNIT.Event.Native.GetTrigger()
                    local Unit parent = UNIT.Event.Native.GetDamager()
                    local thistype this = dummyUnit.Data.Integer.Get(KEY)
                    if (parent != this.parent) then
                        return
                    endif
                    local real x = dummyUnit.Position.X.Get()
                    local real y = dummyUnit.Position.Y.Get()
                    call this.Ending(dummyUnit, parent)
                    call thistype(parent).TriggerEvents(x, y)
                endmethod
                eventMethod Event_Attack
                    local Unit target = params.Unit.GetTarget()
                    local Unit parent = params.Unit.GetTrigger()
                    local real targetX = target.Position.X.Get()
                    local real targetY = target.Position.Y.Get()
					local thistype this = thistype.allocate()
                    local DummyUnit dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, targetX, targetY, 0., 0.)
                    set this.parent = parent
                    call thistype.DAMAGE_TRIGGER.RegisterEvent.DummyUnit(dummyUnit, EVENT_UNIT_DAMAGED)
                    call dummyUnit.Data.Integer.Set(KEY, this)
                    call dummyUnit.Event.Add(DUMMY_UNIT_DESTROY_EVENT)
                    call parent.Data.Integer.Table.Add(KEY_ARRAY, this)
                    call parent.Refs.Add()
                    call dummyUnit.DestroyTimed.Start(Math.DistanceByDeltas(targetX - parent.Position.X.Get(), targetY - parent.Position.Y.Get()) / parent.Attack.Missile.Speed.Get() + thistype.DURATION_TOLERANCE)
                endmethod
                eventMethod Event_TypeChange
                    local Unit parent = params.Unit.GetTrigger()
                    local UnitType sourceType = params.UnitType.GetSource()
                    local UnitType targetType = params.UnitType.GetTrigger()
                    local boolean hasArtillery = (targetType.Attack.Get() == Attack.ARTILLERY)
                    if ((sourceType.Attack.Get() == Attack.ARTILLERY) == hasArtillery) then
                        return
                    endif
                    if hasArtillery then
                        call parent.Event.Add(ATTACK_EVENT)
                        call parent.Event.Add(DESTROY_EVENT)
                    else
                        call parent.Event.Remove(ATTACK_EVENT)
                        call parent.Event.Remove(DESTROY_EVENT)
                    endif
                endmethod
                eventMethod Event_Create
                    local Unit parent = params.Unit.GetTrigger()
                    if (parent.Attack.GetType() == Attack.ARTILLERY) then
                        call parent.Event.Add(ATTACK_EVENT)
                        call parent.Event.Add(DESTROY_EVENT)
                    endif
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DAMAGE_TRIGGER = Trigger.CreateFromCode(function thistype.DamageTrig)
                    set thistype.ATTACK_EVENT = Event.Create(UNIT.Attack.Events.DUMMY_EVENT_TYPE, EventPriority.EVENTS, function thistype.Event_Attack)
                    set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.EVENTS, function thistype.Event_Destroy)
                    set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                    set thistype.DUMMY_UNIT_DESTROY_EVENT = Event.Create(DummyUnit.DESTROY_EVENT_TYPE, EventPriority.EVENTS, function thistype.Event_DummyUnitDestroy)
                    set thistype.ENUM_GROUP = Group.Create()
                    set thistype.ENUM_GROUP2 = UnitList.Create()
                    set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
                    
                    call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
                endmethod
            endstruct
        endscope
    public struct StructEvents
        implement Allocation
        implement List
        
            static EventType ACQUIRE_EVENT_TYPE
            static Trigger ACQUIRE_TRIGGER
            static EventType DUMMY_EVENT_TYPE
            static Trigger DUMMY_TRIGGER
            static EventType OFFENDED_EVENT_TYPE
            static UnitList OFFENDED_REG_GROUP
            static EventType OFFENDED_REVERSED_EVENT_TYPE
            static Trigger OFFENDED_TRIGGER
    FolderEvents_StructAcquire2 Acquire2 = this
    FolderEvents_StructAcquire2 LinkToStruct_Acquire2
    FolderEvents_StructGround Ground = this
    FolderEvents_StructGround LinkToStruct_Ground
            method TriggerEvents takes Unit target returns nothing
                local Unit parent = this
                local UnitType parentType = parent.Type.Get()
                local EventResponse params = EventResponse.Create(parent.Id.Get())
                call params.Unit.SetTarget(target)
                call params.Unit.SetTrigger(this)
				local EventResponse typeParams = EventResponse.Create(parentType.Id.Get())
                call typeParams.Unit.SetTarget(target)
                call typeParams.Unit.SetTrigger(this)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = parent.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration2 = parentType.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call parentType.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(typeParams)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call params.Destroy()
                call typeParams.Destroy()
            endmethod
            trigMethod Trig
                local Unit parent = UNIT.Event.Native.GetTrigger()
                local Unit target = UNIT.Event.Native.GetAcquiredTarget()
                call thistype(parent).TriggerEvents(target)
            endmethod
            method Acquire_TriggerEvents takes Unit target returns nothing
                local Unit parent = this
                local UnitType parentType = parent.Type.Get()
                local EventResponse params = EventResponse.Create(parent.Id.Get())
                call params.Unit.SetTarget(target)
                call params.Unit.SetTrigger(this)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = parent.Event.Count(thistype.ACQUIRE_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call parent.Event.Get(thistype.ACQUIRE_EVENT_TYPE, priority, iteration2).Run(params)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call params.Destroy()
            endmethod
            trigMethod AcquireTrig
                local Unit parent = UNIT.Event.Native.GetTrigger()
                local Unit target = UNIT.Event.Native.GetAcquiredTarget()
                if (target.IsEnemyOf(parent.Owner.Get()) and (target.Order.Get() == NULL)) then
                    call parent.Order.UnitTarget(Order.ATTACK, target)
                endif
                call thistype(parent).Acquire_TriggerEvents(target)
                call thistype(parent).Acquire2.Start(target)
            endmethod
            method Offended_TriggerEvents takes Unit attacker returns nothing
                local Unit parent = this
                local EventResponse attackerParams = EventResponse.Create(attacker.Id.Get())
                call attackerParams.Unit.SetTarget(this)
                call attackerParams.Unit.SetTrigger(attacker)
				local EventResponse params = EventResponse.Create(parent.Id.Get())
                call params.Unit.SetTarget(attacker)
                call params.Unit.SetTrigger(this)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = attacker.Event.Count(thistype.OFFENDED_REVERSED_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call attacker.Event.Get(thistype.OFFENDED_REVERSED_EVENT_TYPE, priority, iteration2).Run(attackerParams)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration2 = parent.Event.Count(thistype.OFFENDED_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call parent.Event.Get(thistype.OFFENDED_EVENT_TYPE, priority, iteration2).Run(params)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call attackerParams.Destroy()
                call params.Destroy()
            endmethod
            static method OffendedTrigConds takes Unit parent returns boolean
                if not thistype.OFFENDED_REG_GROUP.Contains(parent) then
                    return false
                endif
                return true
            endmethod
            trigMethod OffendedTrig
                local Unit parent = UNIT.Event.Native.GetTrigger()
                if not thistype.OffendedTrigConds(parent) then
                    return
                endif
                call thistype(parent).Offended_TriggerEvents(UNIT.Event.Native.GetAttacker())
            endmethod
            method Event_Destroy takes nothing returns nothing
                call thistype.OFFENDED_REG_GROUP.Remove(this)
            endmethod
            method Event_Create takes nothing returns nothing
                call thistype.ACQUIRE_TRIGGER.RegisterEvent.Unit(this, EVENT_UNIT_ACQUIRED_TARGET)
                call thistype.DUMMY_TRIGGER.RegisterEvent.Unit(this, EVENT_UNIT_TARGET_IN_RANGE)
                call thistype.OFFENDED_REG_GROUP.Add(this)
                call this.Acquire2.Event_Create()
                call this.Ground.Event_Create()
            endmethod
            static method Init takes nothing returns nothing
                set thistype.ACQUIRE_EVENT_TYPE = EventType.Create()
                set thistype.ACQUIRE_TRIGGER = Trigger.CreateFromCode(function thistype.AcquireTrig)
                set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                set thistype.DUMMY_TRIGGER = Trigger.CreateFromCode(function thistype.Trig)
                set thistype.OFFENDED_EVENT_TYPE = EventType.Create()
                set thistype.OFFENDED_REG_GROUP = UnitList.Create()
                set thistype.OFFENDED_REVERSED_EVENT_TYPE = EventType.Create()
                set thistype.OFFENDED_TRIGGER = Trigger.CreateFromCode(function thistype.OffendedTrig)
                call thistype.OFFENDED_TRIGGER.RegisterEvent.PlayerUnit(User.ANY, EVENT_PLAYER_UNIT_ATTACKED, null)
                call thistype(NULL).Acquire2.Init()
                call thistype(NULL).Ground.Init()
            endmethod
        endstruct
    scope FolderMissile
    public struct StructSpeed
        implement Allocation
        implement List
        
                method Get takes nothing returns real
                    return Unit(this).Type.Get().Attack.Missile.Speed.Get()
                endmethod
            endstruct
        endscope
    public struct StructMissile
        implement Allocation
        implement List
        
    FolderMissile_StructSpeed Speed = this
    FolderMissile_StructSpeed LinkToStruct_Speed
        endstruct
    public struct StructRange
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(Unit(this).Type.Get().Attack.Range.Get())
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    scope FolderSpeed
    public struct StructBaseA
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
                method Set takes real value returns nothing
                    set this.value = value
                    call Unit(this).Attack.Speed.Update()
                endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
                eventMethod Event_TypeChange
                    local UnitType sourceType = params.UnitType.GetSource()
                    local UnitType targetType = params.UnitType.GetTrigger()
                    local thistype this = params.Unit.GetTrigger()
                    call this.Add(targetType.Attack.Speed.Get() - sourceType.Attack.Speed.Get())
                endmethod
                method Event_Create takes nothing returns nothing
                    set this.value = Unit(this).Type.Get().Attack.Speed.Get()
                endmethod
                static method Init takes nothing returns nothing
                    call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
                endmethod
            endstruct
    scope FolderBonusA
    public struct StructDisplayedA
        implement Allocation
        implement List
        
        static constant boolean WAIT_FOR_SELECTION = false
        real value
        method Get takes nothing returns real
            return this.value
        endmethod
        static if false then
            static Event SELECTION_EVENT
            real nativeValue
            boolean waitForSelection
            method SetNative takes real value, real oldValue returns nothing
                set this.nativeValue = value
                call BJUnit.Attack.Speed.BonusA.Set(Unit(this).self, value, oldValue)
            endmethod
            eventMethod Event_Selection
                local thistype this = params.Unit.GetTrigger()
                set this.waitForSelection = false
                call Unit(this).Event.Remove(SELECTION_EVENT)
                call this.SetNative(this.Get(), this.nativeValue)
            endmethod
            method SetDisplay takes real value returns nothing
                local real nativeValue = this.nativeValue
                set this.value = value
                if (value == nativeValue) then
                    if this.waitForSelection then
                        set this.waitForSelection = false
                        call Unit(this).Event.Remove(SELECTION_EVENT)
                    endif
                    return
                endif
                if Unit(this).Selection.IsEmpty() then
                    if not this.waitForSelection then
                        set this.waitForSelection = true
                        call Unit(this).Event.Add(SELECTION_EVENT)
                    endif
                else
                    call this.SetNative(value, nativeValue)
                endif
            endmethod
        else
            method SetDisplay takes real value returns nothing
                local real oldValue = this.Get()
                set this.value = value
                call BJUnit.Attack.Speed.BonusA.Set(Unit(this).self, value, oldValue)
            endmethod
        endif
        method AddOnlySave takes real value returns nothing
            set this.value = this.Get() + value
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0.
            static if false then
                set this.nativeValue = 0.
                set this.waitForSelection = false
            endif
        endmethod
					method Set takes real val returns nothing
						call this.SetDisplay(val)
					endmethod
                    method Update takes nothing returns nothing
                        call this.Set(Unit(this).Attack.Speed.BonusA.Get())
                    endmethod
                    method UpdateOnlySave takes nothing returns nothing
                        set this.value = Unit(this).Attack.Speed.BonusA.Get()
                    endmethod
                    static method Init takes nothing returns nothing
                        static if thistype.WAIT_FOR_SELECTION then
                            set thistype.SELECTION_EVENT = Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Selection)
                        endif
                    endmethod
                endstruct
            endscope
    public struct StructBonusA
        implement Allocation
        implement List
        
                static UnitState STATE
    FolderBonusA_StructDisplayedA DisplayedA = this
    FolderBonusA_StructDisplayedA LinkToStruct_DisplayedA
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
                method Set takes real value returns nothing
                    set this.value = value
                    call this.DisplayedA.Update()
                    call Unit(this).Attack.Speed.Update()
                endmethod
                method AddOnlySave takes real value returns nothing
                    set this.value = this.Get() + value
                    call this.DisplayedA.UpdateOnlySave()
                endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
                eventMethod Event_State
                    call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
                endmethod
                method Event_Create takes nothing returns nothing
                    set this.value = 0.
                    call this.DisplayedA.Event_Create()
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
                    call thistype(NULL).DisplayedA.Init()
                endmethod
            endstruct
        endscope
    public struct StructSpeed
        implement Allocation
        implement List
        
    FolderSpeed_StructBaseA BaseA = this
    FolderSpeed_StructBaseA LinkToStruct_BaseA
    FolderSpeed_StructBonusA BonusA = this
    FolderSpeed_StructBonusA LinkToStruct_BonusA
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
            endmethod
            method Update takes nothing returns nothing
                call this.Set(this.BaseA.Get() + this.BonusA.Get())
            endmethod
            method Event_Create takes nothing returns nothing
                call this.BaseA.Event_Create()
                call this.BonusA.Event_Create()
                call this.Update()
            endmethod
            static method Init takes nothing returns nothing
                call thistype(NULL).BaseA.Init()
                call thistype(NULL).BonusA.Init()
            endmethod
        endstruct
    scope FolderSplash
    public struct StructTargetFlag
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
                method Is takes integer whichFlag returns boolean
                    return Unit(this).Type.Get().Attack.Splash.TargetFlag.Is(whichFlag)
                endmethod
            endstruct
        endscope
    public struct StructSplash
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_TYPE_BOUND_KEY_ARRAY
    static constant integer TYPE_BOUND_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_TYPE_BOUND_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    FolderSplash_StructTargetFlag TargetFlag = this
    FolderSplash_StructTargetFlag LinkToStruct_TargetFlag
            method Count takes nothing returns integer
                return Unit(this).Data.Integer.Table.Count(KEY_ARRAY)
            endmethod
            method Get takes integer index returns UnitAttackSplash
                return Unit(this).Data.Integer.Table.Get(KEY_ARRAY, index)
            endmethod
            method GetMaxAreaRange takes nothing returns real
                local integer iteration = this.Count()
                local real result = 0.
                loop
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    set result = Math.Max(result, this.Get(iteration).GetAreaRange())
                    set iteration = iteration - 1
                endloop
                return result
            endmethod
            method Destroy takes UnitAttackSplash splash returns nothing
                call Unit(this).Data.Integer.Table.Remove(KEY_ARRAY, splash)
                call splash.Destroy()
            endmethod
            method Create takes real areaRange, real damageFactor returns UnitAttackSplash
                local UnitAttackSplash splash = UnitAttackSplash.Create(areaRange, damageFactor)
                call Unit(this).Data.Integer.Table.Add(KEY_ARRAY, splash)
                return splash
            endmethod
            eventMethod Event_TypeChange
                local UnitType targetType = params.UnitType.GetTrigger()
                local thistype this = params.Unit.GetTrigger()
                local integer iteration = Unit(this).Data.Integer.Table.Count(TYPE_BOUND_KEY_ARRAY)
                loop
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    local UnitAttackSplash splash = Unit(this).Data.Integer.Table.Get(TYPE_BOUND_KEY_ARRAY, iteration)
                    call splash.Destroy()
                    set iteration = iteration - 1
                endloop
                call Unit(this).Data.Integer.Table.Clear(TYPE_BOUND_KEY_ARRAY)
                set iteration = targetType.Attack.Splash.Count()
                loop
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    call Unit(this).Data.Integer.Table.Add(TYPE_BOUND_KEY_ARRAY, this.Create(targetType.Attack.Splash.GetAreaRange(iteration), targetType.Attack.Splash.GetDamageFactor(iteration)))
                    set iteration = iteration - 1
                endloop
            endmethod
            method Event_Create takes nothing returns nothing
                local UnitType thisType = Unit(this).Type.Get()
                local integer iteration = thisType.Attack.Splash.Count()
                loop
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    call Unit(this).Data.Integer.Table.Add(TYPE_BOUND_KEY_ARRAY, this.Create(thisType.Attack.Splash.GetAreaRange(iteration), thisType.Attack.Splash.GetDamageFactor(iteration)))
                    set iteration = iteration - 1
                endloop
                
            endmethod
            static method Init takes nothing returns nothing
                call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            endmethod
        endstruct
    endscope
    public struct StructAttack
        implement Allocation
        implement List
        
    	static UnitState DISABLE_STATE
    FolderAttack_StructEvents Events = this
    FolderAttack_StructEvents LinkToStruct_Events
    FolderAttack_StructMissile Missile = this
    FolderAttack_StructMissile LinkToStruct_Missile
    FolderAttack_StructRange Range = this
    FolderAttack_StructRange LinkToStruct_Range
    FolderAttack_StructSpeed Speed = this
    FolderAttack_StructSpeed LinkToStruct_Speed
    FolderAttack_StructSplash Splash = this
    FolderAttack_StructSplash LinkToStruct_Splash
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        method GetType takes nothing returns Attack
            return Unit(this).Type.Get().Attack.Get()
        endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(true)
            call parent.Abilities.RemoveBySelf(thistype.DISABLE_SPELL_ID)
            call parent.Abilities.RemoveBySelf(thistype.ICON_SPELL_ID)
        endmethod
        eventMethod Event_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(false)
            call parent.Abilities.AddBySelf(thistype.DISABLE_SPELL_ID)
            call parent.Abilities.AddBySelf(thistype.ICON_SPELL_ID)
        endmethod
        method Subtract takes nothing returns nothing
            call Unit(this).Buffs.Add(thistype.DISABLE_BUFF, 1)
        endmethod
        method Add takes nothing returns nothing
            call Unit(this).Buffs.Subtract(thistype.DISABLE_BUFF)
        endmethod
        method DisableTimed takes real duration returns nothing
            call Unit(this).Buffs.Timed.Start(thistype.DISABLE_BUFF, 1, duration)
        endmethod
        method Change takes boolean val returns nothing
            if val then
                call this.Add()
            else
                call this.Subtract()
            endif
        endmethod
        eventMethod Event_Disable_State
            call thistype(params.Unit.GetTrigger()).Change(not params.Bool.GetVal())
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(true)
            call this.Events.Event_Create()
            call this.Range.Event_Create()
            call this.Speed.Event_Create()
            call this.Splash.Event_Create()
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DISABLE_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DISABLE_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            call thistype.NORMAL_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.NORMAL_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
        static method Init takes nothing returns nothing
        	set thistype.DISABLE_STATE = UnitState.Create(thistype.NAME, function thistype.Event_Disable_State)
            call thistype(NULL).Events.Init()
            call thistype(NULL).Speed.Init()
            call thistype(NULL).Splash.Init()
        endmethod
    endstruct
    public struct StructBlood
        implement Allocation
        implement List
        
    string value
    method Get takes nothing returns string
        return this.value
    endmethod
    method Set takes string value returns nothing
        set this.value = value
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(Unit(this).Type.Get().Blood.Get())
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        eventMethod Event_TypeChange
            local UnitType targetType = params.UnitType.GetTrigger()
            local thistype this = params.Unit.GetTrigger()
            call this.Set(targetType.Blood.Get())
        endmethod
        static method Init takes nothing returns nothing
            call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
        endmethod
    endstruct
    public struct StructBloodExplosion
        implement Allocation
        implement List
        
    string summon
    method GetSummon takes nothing returns string
        return this.summon
    endmethod
    method SetSummon takes string value returns nothing
        set this.summon = value
    endmethod
    string value
    method Get takes nothing returns string
        return this.value
    endmethod
    method Set takes string value returns nothing
        set this.value = value
    endmethod
        eventMethod Event_TypeChange
            local UnitType targetType = params.UnitType.GetTrigger()
            local thistype this = params.Unit.GetTrigger()
            call this.Set(targetType.BloodExplosion.Get())
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(Unit(this).Type.Get().BloodExplosion.Get())
            call this.SetSummon(null)
        endmethod
        static method Init takes nothing returns nothing
            call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
        endmethod
    endstruct
    public struct StructCollisionSize
        implement Allocation
        implement List
        
        real value
        method Get takes boolean useScale returns real
            if useScale then
                return (this.value * Unit(this).Scale.Get())
            endif
            return this.value
        endmethod
        method GetSquare takes boolean useScale returns real
            return (this.Get(useScale) * this.Get(useScale))
        endmethod
        method Set takes real value returns nothing
            set this.value = value
        endmethod
        method Add takes real value, boolean useScale returns nothing
            call this.Set(this.Get(false) + value)
        endmethod
    method Event_Create takes nothing returns nothing
        set this.value = Unit(this).Type.Get().CollisionSize.Get()
    endmethod
        eventMethod Event_TypeChange
            local UnitType sourceType = params.UnitType.GetSource()
            local UnitType targetType = params.UnitType.GetTrigger()
            local thistype this = params.Unit.GetTrigger()
            call this.Add(targetType.CollisionSize.Get() - sourceType.CollisionSize.Get(), true)
        endmethod
        static method Init takes nothing returns nothing
            call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
        endmethod
    endstruct
    scope FolderCriticalChanceDefense
    public struct StructBase
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).CriticalChanceDefense.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
        endstruct
    public struct StructBonus
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).CriticalChanceDefense.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
        endstruct
    endscope
    public struct StructCriticalChanceDefense
        implement Allocation
        implement List
        
    FolderCriticalChanceDefense_StructBase Base = this
    FolderCriticalChanceDefense_StructBase LinkToStruct_Base
    FolderCriticalChanceDefense_StructBonus Bonus = this
    FolderCriticalChanceDefense_StructBonus LinkToStruct_Bonus
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method Set takes real value returns nothing
            set this.value = value
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.Base.Get() + this.Bonus.Get())
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0.
            call this.Base.Event_Create()
            call this.Bonus.Event_Create()
            call this.Update()
        endmethod
    endstruct
    scope FolderCriticalChance
    public struct StructBase
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).CriticalChance.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
        endstruct
    public struct StructBonus
        implement Allocation
        implement List
        
            static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).CriticalChance.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    endscope
    public struct StructCriticalChance
        implement Allocation
        implement List
        
        static constant real CHANCE_EXPONENT = 0.1
        static constant real CHANCE_FACTOR = 1.
        static constant real DAMAGE_FACTOR = 2.
        static EventType DUMMY_EVENT_TYPE
    FolderCriticalChance_StructBase Base = this
    FolderCriticalChance_StructBase LinkToStruct_Base
    FolderCriticalChance_StructBonus Bonus = this
    FolderCriticalChance_StructBonus LinkToStruct_Bonus
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method VsUnit takes Unit target returns real
            
            return Math.Limit((this.Get() - target.CriticalChanceDefense.Get()) / 100, 0., 1.)
        endmethod
        method Random takes Unit target returns boolean
            if (Unit(this).Invisibility.Is() and not Unit(this).Invisibility.Reveal.Is()) then
                return true
            endif
            if target.Sleep.Is() then
                return true
            endif
            return (Math.Random(0., 1.) <= this.VsUnit(target))
        endmethod
		method Do_TriggerEvents takes Unit target, real amount returns nothing
			local Unit parent = this
            local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
            call params.Unit.SetTrigger(parent)
            call params.Unit.SetTarget(target)
			local EventResponse parentParams = EventResponse.Create(parent.Id.Get())
            call parentParams.Unit.SetTrigger(parent)
            call parentParams.Unit.SetTarget(target)
			local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = Event.CountAtStatics(thistype.DUMMY_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call Event.GetFromStatics(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration2 = parent.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(parentParams)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            call params.Destroy()
            call parentParams.Destroy()
		endmethod
		method Do takes Unit target, real amount returns real
			set amount = amount * thistype.DAMAGE_FACTOR
			call this.Do_TriggerEvents(target, amount)
			return amount
		endmethod
        method Set takes real value returns nothing
            set this.value = value
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.Base.Get() + this.Bonus.Get())
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0.
            call this.Base.Event_Create()
            call this.Bonus.Event_Create()
            call this.Update()
        endmethod
        static method Init takes nothing returns nothing
        	set thistype.DUMMY_EVENT_TYPE = EventType.Create()
            call thistype(NULL).Bonus.Init()
        endmethod
    endstruct
    scope FolderDeath
    public struct StructExplosion
        implement Allocation
        implement List
        
            static BoolExpr TARGET_FILTER
            condTrigMethod Conditions
                local Unit target = UNIT.Event.Native.GetFilter()
                if target.Classes.Contains(UnitClass.DEAD) then
                    return false
                endif
                if not target.Classes.Contains(UnitClass.GROUND) then
                    return false
                endif
                if target.IsAllyOf(User.TEMP) then
                    return false
                endif
                return true
            endmethod
            method SpawnBloodExplosion takes real x, real y returns nothing
                local string modelPath = Unit(this).BloodExplosion.Get()
                if (modelPath != null) then
                    
                    call SpotEffectWithSize.Create(x, y, thistype.COMMON_BLOOD_EXPLOSION_PATH, EffectLevel.LOW, Unit(this).Scale.Get()).Destroy()
                endif
            endmethod
            method SpawnBloodExplosionSummon takes real x, real y returns nothing
                local string modelPath = Unit(this).BloodExplosion.GetSummon()
                if (modelPath != null) then
                    call SpotEffectWithSize.Create(x, y, modelPath, EffectLevel.LOW, Unit(this).Scale.Get()).DestroyTimed.Start(5.)
                endif
            endmethod
            method Do takes Unit killer returns nothing
                local real damage = Unit(this).MaxLife.Get() * thistype.DAMAGE_LIFE_FACTOR
                local User killerOwner = killer.Owner.Get()
                local real x = Unit(this).Position.X.Get()
                local real y = Unit(this).Position.Y.Get()
                call this.SpawnBloodExplosion(x, y)
               
                if (killerOwner.Team.Get() != Team.DEFENDERS) then
                    return
                endif
				local Group explosionGroup = Group.Create()
				set User.TEMP = killer.Owner.Get()
                call explosionGroup.EnumUnits.InRange.WithCollision.Do(x, y, Unit(this).CollisionSize.Get(true) * 5, thistype.TARGET_FILTER)
				local integer count = explosionGroup.Count()
				if (count > 0) then
					set damage = damage / count
	                loop
	                    local Unit target = explosionGroup.FetchFirst()
	                    exitwhen (target == NULL)
	
	                    call killer.DamageUnit(target, damage, false)
	                endloop
                endif
            endmethod
            method Subtract takes nothing returns nothing
                call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
            endmethod
            method Add takes nothing returns nothing
                call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
            endmethod
            method Try takes Unit killer returns nothing
                if this.Is() then
                    call this.Do(killer)
                elseif Unit(this).Classes.Contains(UnitClass.SUMMON) then
                    call this.SpawnBloodExplosionSummon(Unit(this).Position.X.Get(), Unit(this).Position.Y.Get())
                endif
            endmethod
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
            eventMethod Event_BuffLose
                local Unit parent = params.Unit.GetTrigger()
                local thistype this = parent
                call this.Set(false)
            endmethod
            eventMethod Event_BuffGain
                local Unit parent = params.Unit.GetTrigger()
                local thistype this = parent
                call this.Set(true)
            endmethod
            method Event_Create takes nothing returns nothing
                call this.Set(false)
            endmethod
            initMethod Buff_Init of Header_Buffs
                call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
                call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            endmethod
            static method Init takes nothing returns nothing
                set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
            endmethod
        endstruct
    public struct StructEvents
        implement Allocation
        implement List
        
            static EventType BEFORE_EVENT_TYPE
            static EventType DUMMY_EVENT_TYPE
            static Trigger DUMMY_TRIGGER
            static Unit DYING_UNIT
            static Unit KILLER
            static EventType KILLER_EVENT_TYPE
            static boolean NEXT_DECAYS_INSTANTLY = false
            static UnitList REG_GROUP
            method Before_TriggerEvents takes Unit killer returns nothing
                local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
                call params.Unit.SetKiller(killer)
                call params.Unit.SetTrigger(this)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = Event.CountAtStatics(thistype.BEFORE_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call Event.GetFromStatics(thistype.BEFORE_EVENT_TYPE, priority, iteration2).Run(params)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call params.Destroy()
            endmethod
            method Before_Event_Life takes Unit killer returns nothing
                call this.Before_TriggerEvents(killer)
                set thistype.KILLER = killer
            endmethod
            method TriggerEvents takes Unit killer returns nothing
                local Unit parent = this
                local EventResponse killerParams = EventResponse.Create(killer.Id.Get())
                call killerParams.Unit.SetTarget(parent)
                call killerParams.Unit.SetTrigger(killer)
				local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
                call params.Unit.SetKiller(killer)
                call params.Unit.SetTrigger(parent)
				local EventResponse unitParams = EventResponse.Create(parent.Id.Get())
                call unitParams.Unit.SetKiller(killer)
                call unitParams.Unit.SetTrigger(parent)
                local Event array eventsToRun
                local integer eventsToRunCount = ARRAY_EMPTY
                local integer array eventsToRunType
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = Event.CountAtStatics(thistype.DUMMY_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        set eventsToRunCount = eventsToRunCount + 1
                        set eventsToRun[eventsToRunCount] = Event.GetFromStatics(thistype.DUMMY_EVENT_TYPE, priority, iteration2)
                        set eventsToRunType[eventsToRunCount] = 0
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration2 = killer.Event.Count(thistype.KILLER_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        set eventsToRunCount = eventsToRunCount + 1
                        set eventsToRun[eventsToRunCount] = killer.Event.Get(thistype.KILLER_EVENT_TYPE, priority, iteration2)
                        set eventsToRunType[eventsToRunCount] = 1
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration2 = parent.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        set eventsToRunCount = eventsToRunCount + 1
                        set eventsToRun[eventsToRunCount] = parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2)
                        set eventsToRunType[eventsToRunCount] = 2
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                set iteration = ARRAY_MIN
                loop
                    exitwhen (iteration > eventsToRunCount)
                    if (eventsToRunType[iteration] == 0) then
                        if eventsToRun[iteration].IsStatic() then
                            call eventsToRun[iteration].Run(params)
                            if not Unit(this).Classes.Contains(UnitClass.DEAD) then
                                return
                            endif
                        endif
                    elseif (eventsToRunType[iteration] == 1) then
                        if killer.Event.Contains(eventsToRun[iteration]) then
                            call eventsToRun[iteration].Run(killerParams)
                            if not Unit(this).Classes.Contains(UnitClass.DEAD) then
                                return
                            endif
                        endif
                    else
                        if parent.Event.Contains(eventsToRun[iteration]) then
                            call eventsToRun[iteration].Run(unitParams)
                            if not parent.Classes.Contains(UnitClass.DEAD) then
                                return
                            endif
                        endif
                    endif
                    set iteration = iteration + 1
                endloop
                call killerParams.Destroy()
                call params.Destroy()
                call unitParams.Destroy()
            endmethod
            method TriggerEvents2 takes Unit killer returns nothing
                local Unit parent = this
                local EventResponse killerParams = EventResponse.Create(killer.Id.Get())
                call killerParams.Unit.SetTarget(this)
                call killerParams.Unit.SetTrigger(killer)
				local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
                call params.Unit.SetKiller(killer)
                call params.Unit.SetTrigger(this)
				local EventResponse unitParams = EventResponse.Create(parent.Id.Get())
                call unitParams.Unit.SetKiller(killer)
                call unitParams.Unit.SetTrigger(this)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = Event.CountAtStatics(thistype.DUMMY_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call Event.GetFromStatics(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration2 = killer.Event.Count(thistype.KILLER_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call killer.Event.Get(thistype.KILLER_EVENT_TYPE, priority, iteration2).Run(killerParams)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration2 = parent.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(unitParams)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call killerParams.Destroy()
                call params.Destroy()
                call unitParams.Destroy()
            endmethod
            method Start takes Unit killer returns nothing
                local boolean decaysInstantly = thistype.NEXT_DECAYS_INSTANTLY
                call Unit(this).Refs.Add()
                if decaysInstantly then
                    set thistype.NEXT_DECAYS_INSTANTLY = false
                endif
                call Unit(this).Classes.Add(UnitClass.DEAD)
                if ((Unit(this).Classes.Contains(UnitClass.HERO) and not Unit(this).Classes.Contains(UnitClass.ILLUSION)) or Unit(this).Classes.Contains(UnitClass.UNDECAYABLE)) then
                    call this.TriggerEvents(killer)
                else
                    local real decayDuration = Unit(this).Decay.Duration.Get()
                    set decaysInstantly = (decaysInstantly or Unit(this).Death.Explosion.Is() or (decayDuration == 0.))
                    if decaysInstantly then
                        call Unit(this).Death.Explosion.Try(killer)
                        call this.TriggerEvents(killer)
                        if not Unit(this).IsDestroyed() then
                            call Unit(this).Decay.Do()
                        endif
                    else
                        call Unit(this).Decay.Timed.Start(decayDuration)
                        call this.TriggerEvents(killer)
                    endif
                endif
                call Unit(this).Drop.Exp.DoHeal(killer)
                call Unit(this).Refs.Subtract()
            endmethod
            static method TrigConds takes Unit parent returns boolean
                if not thistype.REG_GROUP.Contains(parent) then
                    return false
                endif
                return true
            endmethod
            trigMethod Trig
                local Unit parent = UNIT.Event.Native.GetTrigger()
                if not thistype.TrigConds(parent) then
                    return
                endif
                local Unit killer = thistype.KILLER
                set thistype.KILLER = NULL
                call thistype(parent).Start(killer)
            endmethod
            method Event_Destroy takes nothing returns nothing
                call thistype.REG_GROUP.Remove(this)
            endmethod
            method Event_Create takes nothing returns nothing
                call thistype.REG_GROUP.Add(this)
            endmethod
            static method Init takes nothing returns nothing
                set thistype.BEFORE_EVENT_TYPE = EventType.Create()
                set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                set thistype.DUMMY_TRIGGER = Trigger.CreateFromCode(function thistype.Trig)
                set thistype.KILLER_EVENT_TYPE = EventType.Create()
                set thistype.REG_GROUP = UnitList.Create()
                call thistype.DUMMY_TRIGGER.RegisterEvent.PlayerUnit(User.ANY, EVENT_PLAYER_UNIT_DEATH, null)
            endmethod
        endstruct
        
    public struct StructProtection
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        	static constant string TRY_TEXT = "Immortal!!"
        	
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
	        method Try takes nothing returns boolean
	            if not this.Is() then
	                return false
	            endif
	
	            call Unit(this).AddJumpingTextTag(String.Color.Do(thistype.TRY_TEXT, "ff777777"), 0.02, KEY_ARRAY + this)
	
	            return true
	        endmethod
	
	        eventMethod Event_BuffLose
	            local Unit parent = params.Unit.GetTrigger()
	
	            call thistype(parent).Set(false)
	        endmethod
	
	        eventMethod Event_BuffGain
	            local Unit parent = params.Unit.GetTrigger()
	
	            call thistype(parent).Set(true)
	        endmethod
	
	        method Subtract takes nothing returns nothing
	            call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
	        endmethod
	
	        method Add takes nothing returns nothing
	            call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
	        endmethod
	
	        method Event_Create takes nothing returns nothing
	            call this.Set(false)
	        endmethod
	
	        initMethod Buff_Init of Header_Buffs
	            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
	            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
	        endmethod
        endstruct
    endscope
    public struct StructDeath
        implement Allocation
        implement List
        
    FolderDeath_StructEvents Events = this
    FolderDeath_StructEvents LinkToStruct_Events
    FolderDeath_StructExplosion Explosion = this
    FolderDeath_StructExplosion LinkToStruct_Explosion
    FolderDeath_StructProtection Protection = this
    FolderDeath_StructProtection LinkToStruct_Protection
        method Event_Destroy takes nothing returns nothing
            call this.Events.Event_Destroy()
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Events.Event_Create()
            call this.Protection.Event_Create()
        endmethod
        method Do takes Unit killer returns nothing
        	if this.Protection.Try() then
                return
            endif
            
            set thistype(NULL).Events.KILLER = killer
            call KillUnit(Unit(this).self)
        endmethod
        static method Init takes nothing returns nothing
            call thistype(NULL).Events.Init()
            call thistype(NULL).Explosion.Init()
        endmethod
    endstruct
    scope FolderDecay
    public struct StructDuration
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(Unit(this).Type.Get().Decay.Duration.Get())
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_TypeChange
                local UnitType sourceType = params.UnitType.GetSource()
                local UnitType targetType = params.UnitType.GetTrigger()
                local thistype this = params.Unit.GetTrigger()
                call this.Add(targetType.Decay.Duration.Get() - sourceType.Decay.Duration.Get())
            endmethod
            static method Init takes nothing returns nothing
                call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            endmethod
        endstruct
    public struct StructEvents
        implement Allocation
        implement List
        
            static Trigger DUMMY_TRIGGER
            static UnitList REG_GROUP
            static unit array TIMER_UNIT
            condTrigMethod TrigConds
                if not thistype.REG_GROUP.Contains(UNIT.Event.Native.GetFilter()) then
                    return false
                endif
                return true
            endmethod
            timerMethod Delay
                local Timer dummyTimer = Timer.GetExpired()
                call Unit.GetFromSelf(thistype.TIMER_UNIT[dummyTimer]).Decay.Suspend(true)
                call dummyTimer.Destroy()
            endmethod
            trigMethod Trig
                local Timer dummyTimer = Timer.Create()
                set thistype.TIMER_UNIT[dummyTimer] = UNIT.Event.Native.GetTrigger().self
                call dummyTimer.Start(0., false, function thistype.Delay)
            endmethod
            method Event_Destroy takes nothing returns nothing
                call thistype.REG_GROUP.Remove(this)
            endmethod
            method Event_Create takes nothing returns nothing
                call thistype.REG_GROUP.Add(this)
            endmethod
            static method Init takes nothing returns nothing
                set thistype.DUMMY_TRIGGER = Trigger.CreateFromCode(function thistype.Trig)
                set thistype.REG_GROUP = UnitList.Create()
                call thistype.DUMMY_TRIGGER.RegisterEvent.PlayerUnit(User.ANY, EVENT_PLAYER_UNIT_DECAY, function thistype.TrigConds)
            endmethod
        endstruct
    public struct StructTimed
        implement Allocation
        implement List
        
            static Event DESTROY_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
            static Event REVIVE_EVENT
            Timer durationTimer
            Unit parent
            method Ending takes Timer durationTimer, Unit parent returns nothing
                call this.deallocate()
                call durationTimer.Destroy()
                call parent.Data.Integer.Remove(KEY)
                call parent.Event.Remove(DESTROY_EVENT)
                call parent.Event.Remove(REVIVE_EVENT)
            endmethod
            timerMethod EndingByTimer
                local Timer durationTimer = Timer.GetExpired()
                local thistype this = durationTimer.GetData()
                local Unit parent = this.parent
                call this.Ending(durationTimer, parent)
                call parent.Decay.Do()
            endmethod
            eventMethod Event_Destroy
                local Unit parent = params.Unit.GetTrigger()
                local thistype this = parent.Data.Integer.Get(KEY)
                call this.Ending(this.durationTimer, parent)
            endmethod
            eventMethod Event_Revive
                local Unit parent = params.Unit.GetTrigger()
                local thistype this = parent.Data.Integer.Get(KEY)
                call this.Ending(this.durationTimer, parent)
            endmethod
            method Start takes real duration returns nothing
                local Unit parent = this
                set this = thistype.allocate()
				local Timer durationTimer = Timer.Create()
                set this.durationTimer = durationTimer
                set this.parent = parent
                call durationTimer.SetData(this)
                call parent.Data.Integer.Set(KEY, this)
                call parent.Event.Add(DESTROY_EVENT)
                call parent.Event.Add(REVIVE_EVENT)
                call durationTimer.Start(duration, false, function thistype.EndingByTimer)
            endmethod
            static method Init takes nothing returns nothing
                set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
                set thistype.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Revive)
            endmethod
        endstruct
    endscope
    public struct StructDecay
        implement Allocation
        implement List
        
    FolderDecay_StructDuration Duration = this
    FolderDecay_StructDuration LinkToStruct_Duration
    FolderDecay_StructEvents Events = this
    FolderDecay_StructEvents LinkToStruct_Events
    FolderDecay_StructTimed Timed = this
    FolderDecay_StructTimed LinkToStruct_Timed
        method Do takes nothing returns nothing
            call Unit(this).Destroy()
        endmethod
        method Suspend takes boolean flag returns nothing
            call UnitSuspendDecay(Unit(this).self, flag)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Duration.Event_Create()
            call this.Events.Event_Create()
        endmethod
        static method Init takes nothing returns nothing
            call thistype(NULL).Duration.Init()
            call thistype(NULL).Events.Init()
            call thistype(NULL).Timed.Init()
        endmethod
    endstruct
    public struct StructDisplay
        implement Allocation
        implement List
        
        method Update takes nothing returns nothing
            call Unit(this).Abilities.AddBySelf(thistype.DUMMY_SPELL_ID)
            call Unit(this).Abilities.RemoveBySelf(thistype.DUMMY_SPELL_ID)
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
    scope FolderDrop
    public struct StructExp
        implement Allocation
        implement List
        
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(Unit(this).Type.Get().Drop.Exp.Get())
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method DoHeal takes Unit target returns nothing
            return
            	if (this == NULL) then
                    return
                endif
                if (target == NULL) then
                    return
                endif
                if (target.Owner.Get().Team.Get() != Team.DEFENDERS) then
                    return
                endif
                if target.IsAllyOf(Unit(this).Owner.Get()) then
                    return
                endif
				if target.Classes.Contains(UnitClass.DEAD) then
					return
				endif
				if target.Classes.Contains(UnitClass.MECHANICAL) then
					return
				endif
				if target.Classes.Contains(UnitClass.STRUCTURE) then
					return
				endif
				if target.Classes.Contains(UnitClass.WARD) then
					return
				endif
                
                local real val = this.Get()
                if (val <= 0) then
                    return
                endif
                call target.Life.Add(val)
                call target.Mana.Add(val)
                call target.Stamina.Add(val)
            endmethod
            eventMethod Event_TypeChange
                local UnitType sourceType = params.UnitType.GetSource()
                local UnitType targetType = params.UnitType.GetTrigger()
                local thistype this = params.Unit.GetTrigger()
                call this.Add(targetType.Drop.Exp.Get() - sourceType.Drop.Exp.Get())
            endmethod
            static method Init takes nothing returns nothing
                call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            endmethod
        endstruct
    public struct StructSupply
        implement Allocation
        implement List
        
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(Unit(this).Type.Get().Drop.Supply.Get())
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_TypeChange
                local UnitType sourceType = params.UnitType.GetSource()
                local UnitType targetType = params.UnitType.GetTrigger()
                local thistype this = params.Unit.GetTrigger()
                call this.Add(targetType.Drop.Supply.Get() - sourceType.Drop.Supply.Get())
            endmethod
            static method Init takes nothing returns nothing
                call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            endmethod
        endstruct
    endscope
    public struct StructDrop
        implement Allocation
        implement List
        
        static Event DESTROY_EVENT
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    FolderDrop_StructExp Exp = this
    FolderDrop_StructExp LinkToStruct_Exp
    FolderDrop_StructSupply Supply = this
    FolderDrop_StructSupply LinkToStruct_Supply
        eventMethod Event_Destroy
            local Unit parent = params.Unit.GetTrigger()
            local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
            call parent.Event.Remove(DESTROY_EVENT)
            loop
                local CustomDrop value = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                call parent.Event.Remove(value.GetEvent())
                set iteration = iteration - 1
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            endloop
            call parent.Data.Integer.Table.Clear(KEY_ARRAY)
        endmethod
        method Add takes CustomDrop value returns nothing
            if Unit(this).Data.Integer.Table.Add(KEY_ARRAY, value) then
                call Unit(this).Event.Add(DESTROY_EVENT)
            endif
            call Unit(this).Event.Add(value.GetEvent())
            call Unit(this).Effects.Create(value.GetEffectPath(), value.GetEffectAttachPoint(), value.GetEffectLevel())
        endmethod
        method Clear takes nothing returns nothing
            local Unit parent = this
            local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
            if (iteration < Memory.IntegerKeys.Table.STARTED) then
                return
            endif
            call parent.Event.Remove(DESTROY_EVENT)
            loop
                local CustomDrop value = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                call parent.Event.Remove(value.GetEvent())
                set iteration = iteration - 1
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            endloop
            call parent.Data.Integer.Table.Clear(KEY_ARRAY)
        endmethod
        eventMethod Event_TypeChange
            local UnitType targetType = params.UnitType.GetTrigger()
            local thistype this = params.Unit.GetTrigger()
            call this.Clear()
			local integer iteration = targetType.Drop.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                call this.Add(targetType.Drop.Get(iteration))
                set iteration = iteration - 1
            endloop
        endmethod
        method Event_Create takes nothing returns nothing
            local UnitType whichType = Unit(this).Type.Get()
            local integer iteration = whichType.Drop.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                call this.Add(whichType.Drop.Get(iteration))
                set iteration = iteration - 1
            endloop
            call this.Exp.Event_Create()
            call this.Supply.Event_Create()
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
            call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            call thistype(NULL).Exp.Init()
            call thistype(NULL).Supply.Init()
        endmethod
    endstruct
    public struct StructEvasion
        implement Allocation
        implement List
        
        static constant string TRY_TEXT = "patzer"
    integer flag
    method Get takes nothing returns integer
        return this.flag
    endmethod
    method Is takes nothing returns boolean
        return (this.flag > 0)
    endmethod
    method Set takes integer flag returns nothing
        set this.flag = flag
    endmethod
    method Subtract takes nothing returns nothing
        call this.Set(this.Get() - 1)
    endmethod
    method Add takes nothing returns nothing
        call this.Set(this.Get() + 1)
    endmethod
        method Try takes Unit target returns boolean
            if not thistype(target).Is() then
                return false
            endif
            if target.Sleep.Is() then
                return false
            endif
            if Unit(this).Invisibility.Is() then
                return false
            endif
            if (Math.Random(0., 1.) > Unit(this).EvasionChance.VsUnit(target)) then
                return false
            endif
            call Unit(this).AddRisingTextTag(String.Color.Do(thistype.TRY_TEXT, "dfffdfdf"), 0.02, 140., 0., 1.5, TextTag.GetFreeId())
            call target.Effects.Create("Abilities\\Spells\\Orc\\MirrorImage\\MirrorImageDeathCaster.mdl", AttachPoint.CHEST, EffectLevel.NORMAL).Destroy()
            return true
        endmethod
        method Event_Create takes nothing returns nothing
            if (Unit(this).Classes.Contains(UnitClass.STRUCTURE) or Unit(this).Classes.Contains(UnitClass.WARD)) then
                call this.Set(0)
            else
                call this.Set(1)
            endif
        endmethod
    endstruct
    scope FolderEvasionChanceDefense
    public struct StructBase
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).EvasionChanceDefense.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
        endstruct
    public struct StructBonus
        implement Allocation
        implement List
        
            static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).EvasionChanceDefense.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    endscope
    public struct StructEvasionChanceDefense
        implement Allocation
        implement List
        
    FolderEvasionChanceDefense_StructBase Base = this
    FolderEvasionChanceDefense_StructBase LinkToStruct_Base
    FolderEvasionChanceDefense_StructBonus Bonus = this
    FolderEvasionChanceDefense_StructBonus LinkToStruct_Bonus
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method Set takes real value returns nothing
            set this.value = value
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.Base.Get() + this.Bonus.Get())
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0.
            call this.Base.Event_Create()
            call this.Bonus.Event_Create()
            call this.Update()
        endmethod
        static method Init takes nothing returns nothing
            call thistype(NULL).Bonus.Init()
        endmethod
    endstruct
    scope FolderEvasionChance
    public struct StructBase
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).EvasionChance.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
        endstruct
    public struct StructBonus
        implement Allocation
        implement List
        
            static UnitState STATE
            
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).EvasionChance.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    endscope
    public struct StructEvasionChance
        implement Allocation
        implement List
        
        static constant real CHANCE_EXPONENT = 0.1
        static constant real CHANCE_FACTOR = 1.
        static constant real MAX = 0.5
        static constant real MIN = 0.05
    FolderEvasionChance_StructBase Base = this
    FolderEvasionChance_StructBase LinkToStruct_Base
    FolderEvasionChance_StructBonus Bonus = this
    FolderEvasionChance_StructBonus LinkToStruct_Bonus
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method VsUnit takes Unit target returns real
            
            return Math.Limit((thistype(target).Get() - Unit(this).EvasionChanceDefense.Get()) / 100, thistype.MIN, thistype.MAX)
        endmethod
        method Set takes real value returns nothing
            set this.value = value
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.Base.Get() + this.Bonus.Get())
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0.
            call this.Base.Event_Create()
            call this.Bonus.Event_Create()
            call this.Update()
        endmethod
        
        static method Init takes nothing returns nothing
            call thistype(NULL).Bonus.Init()
        endmethod
    endstruct
    scope FolderImpact
    public struct StructX
        implement Allocation
        implement List
        
            real value
            method Get takes boolean useScale returns real
                if useScale then
                    return (this.value * Unit(this).Scale.Get())
                endif
                return this.value
            endmethod
            method Set takes real value returns nothing
                set this.value = value
            endmethod
            method Add takes real value returns nothing
                call this.Set(this.Get(false) + value)
            endmethod
    method Event_Create takes nothing returns nothing
        set this.value = 0.
    endmethod
        endstruct
    public struct StructY
        implement Allocation
        implement List
        
            real value
            method Get takes boolean useScale returns real
                if useScale then
                    return (this.value * Unit(this).Scale.Get())
                endif
                return this.value
            endmethod
            method Set takes real value returns nothing
                set this.value = value
            endmethod
            method Add takes real value returns nothing
                call this.Set(this.Get(false) + value)
            endmethod
    method Event_Create takes nothing returns nothing
        set this.value = 0.
    endmethod
        endstruct
    public struct StructZ
        implement Allocation
        implement List
        
            real value
            method Get takes boolean useScale returns real
                if useScale then
                    return (this.value * Unit(this).Scale.Get())
                endif
                return this.value
            endmethod
            method Set takes real value returns nothing
                set this.value = value
            endmethod
            method Add takes real value returns nothing
                call this.Set(this.Get(false) + value)
            endmethod
    method Event_Create takes nothing returns nothing
        set this.value = Unit(this).Type.Get().Impact.Z.Get()
    endmethod
            method Event_TypeChange takes UnitType sourceType, UnitType targetType returns nothing
                call this.Add(targetType.Impact.Z.Get() - sourceType.Impact.Z.Get())
            endmethod
        endstruct
    endscope
    public struct StructImpact
        implement Allocation
        implement List
        
    FolderImpact_StructX X = this
    FolderImpact_StructX LinkToStruct_X
    FolderImpact_StructY Y = this
    FolderImpact_StructY LinkToStruct_Y
    FolderImpact_StructZ Z = this
    FolderImpact_StructZ LinkToStruct_Z
        eventMethod Event_TypeChange
            local UnitType sourceType = params.UnitType.GetSource()
            local UnitType targetType = params.UnitType.GetTrigger()
            local thistype this = params.Unit.GetTrigger()
            call this.Z.Event_TypeChange(sourceType, targetType)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.X.Event_Create()
            call this.Y.Event_Create()
            call this.Z.Event_Create()
        endmethod
        static method Init takes nothing returns nothing
            call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
        endmethod
    endstruct
    public struct StructExp
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method Set takes real value returns nothing
            set this.value = value
            call SetHeroXP(Unit(this).self, Real.ToInt(value), false)
        endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(GetHeroXP(Unit(this).self))
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderOutpact
    public struct StructX
        implement Allocation
        implement List
        
            real value
            method Get takes boolean useScale returns real
                if useScale then
                    return (this.value * Unit(this).Scale.Get())
                endif
                return this.value
            endmethod
            method Set takes real value returns nothing
                set this.value = value
            endmethod
            method Add takes real value returns nothing
                call this.Set(this.Get(false) + value)
            endmethod
    method Event_Create takes nothing returns nothing
        set this.value = 0.
    endmethod
        endstruct
    public struct StructY
        implement Allocation
        implement List
        
            real value
            method Get takes boolean useScale returns real
                if useScale then
                    return (this.value * Unit(this).Scale.Get())
                endif
                return this.value
            endmethod
            method Set takes real value returns nothing
                set this.value = value
            endmethod
            method Add takes real value returns nothing
                call this.Set(this.Get(false) + value)
            endmethod
    method Event_Create takes nothing returns nothing
        set this.value = 60.
    endmethod
        endstruct
    public struct StructZ
        implement Allocation
        implement List
        
            real value
            method Get takes boolean useScale returns real
                if useScale then
                    return (this.value * Unit(this).Scale.Get())
                endif
                return this.value
            endmethod
            method Set takes real value returns nothing
                set this.value = value
            endmethod
            method Add takes real value returns nothing
                call this.Set(this.Get(false) + value)
            endmethod
    method Event_Create takes nothing returns nothing
        set this.value = Unit(this).Type.Get().Outpact.Z.Get()
    endmethod
            method Event_TypeChange takes UnitType sourceType, UnitType targetType returns nothing
                call this.Add(targetType.Outpact.Z.Get() - sourceType.Outpact.Z.Get())
            endmethod
        endstruct
    endscope
    public struct StructOutpact
        implement Allocation
        implement List
        
    FolderOutpact_StructX X = this
    FolderOutpact_StructX LinkToStruct_X
    FolderOutpact_StructY Y = this
    FolderOutpact_StructY LinkToStruct_Y
    FolderOutpact_StructZ Z = this
    FolderOutpact_StructZ LinkToStruct_Z
        eventMethod Event_TypeChange
            local UnitType sourceType = params.UnitType.GetSource()
            local UnitType targetType = params.UnitType.GetTrigger()
            local thistype this = params.Unit.GetTrigger()
            call this.Z.Event_TypeChange(sourceType, targetType)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.X.Event_Create()
            call this.Y.Event_Create()
            call this.Z.Event_Create()
        endmethod
        static method Init takes nothing returns nothing
            call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
        endmethod
    endstruct
    public struct StructLifeLeech
        implement Allocation
        implement List
        
        static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        eventMethod Event_State
            call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
        endmethod
        method Do takes Unit target returns nothing
            local Unit parent = this
            if target.IsAllyOf(parent) then
                return
            endif
            local real val = this.Get()
            if (val <= 0.) then
                return
            endif
            call parent.AddRisingTextTag(String.Color.Do(Char.PLUS + Integer.ToString(Real.ToInt(val)), "ffc80000"), 0.02, 80., 0., 3., TextTag.GetFreeId())
            call parent.Effects.Create(thistype.SPECIAL_EFFECT_PATH, thistype.SPECIAL_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
            call parent.Life.Add(val)
        endmethod
        method DoWithVal takes Unit target, real val returns nothing
            local Unit parent = this
            if target.IsAllyOf(parent) then
                return
            endif
            if (val <= 0.) then
                return
            endif
            call parent.AddRisingTextTag(String.Color.Do(Char.PLUS + Integer.ToString(Real.ToInt(val)), "ffc80000"), 0.02, 80., 0., 3., TextTag.GetFreeId())
            call parent.Effects.Create(thistype.SPECIAL_EFFECT_PATH, thistype.SPECIAL_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
            call parent.Life.Add(val)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
        endmethod
    endstruct
    public struct StructManaLeech
        implement Allocation
        implement List
        
        static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        eventMethod Event_State
            call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
        endmethod
        method Do takes Unit target returns nothing
            local Unit parent = this
            if target.IsAllyOf(parent) then
                return
            endif
            local real val = this.Get()
            if (val <= 0.) then
                return
            endif
            call parent.AddRisingTextTag(String.Color.Do(Char.PLUS + Integer.ToString(Real.ToInt(val)), "ffc80000"), 0.02, 80., 0., 3., TextTag.GetFreeId())
            call parent.Effects.Create(thistype.SPECIAL_EFFECT_PATH, thistype.SPECIAL_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
            call parent.Mana.Add(val)
        endmethod
        method DoWithVal takes Unit target, real val returns nothing
            local Unit parent = this
            if target.IsAllyOf(parent) then
                return
            endif
            if (val <= 0.) then
                return
            endif
            call parent.AddRisingTextTag(String.Color.Do(Char.PLUS + Integer.ToString(Real.ToInt(val)), "ffc80000"), 0.02, 80., 0., 3., TextTag.GetFreeId())
            call parent.Effects.Create(thistype.SPECIAL_EFFECT_PATH, thistype.SPECIAL_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
            call parent.Mana.Add(val)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
        endmethod
    endstruct
    public struct StructInvulnerability
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        static UnitState STATE
        static constant string TRY_TEXT = "Invulnerable!!"
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        method Try takes nothing returns boolean
            if not this.Is() then
                return false
            endif
            call Unit(this).AddJumpingTextTag(String.Color.Do(thistype.TRY_TEXT, "ffff0000"), 0.02, KEY_ARRAY + this)
            return true
        endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(false)
        endmethod
        eventMethod Event_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(true)
        endmethod
        method Subtract takes nothing returns nothing
            call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
        endmethod
        method Add takes nothing returns nothing
            call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
        endmethod
        method AddTimed takes real duration returns nothing
            call Unit(this).Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, duration)
        endmethod
        method Change takes boolean val returns nothing
            if val then
                call this.Add()
            else
                call this.Subtract()
            endif
        endmethod
        eventMethod Event_State
            call thistype(params.Unit.GetTrigger()).Change(params.Bool.GetVal())
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(false)
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_BuffLose))
            call thistype.DUMMY_BUFF.Variants.Add(thistype.NORMAL_BUFF)
        endmethod
        static method Init takes nothing returns nothing
        	set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
        endmethod
    endstruct
    scope FolderDamage
    scope FolderBase
    public struct StructDisplayed
        implement Allocation
        implement List
        
                static constant boolean WAIT_FOR_SELECTION = true
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
                static if thistype.WAIT_FOR_SELECTION then
                    static Event SELECTION_EVENT
                    real nativeValue
                    boolean waitForSelection
                    method SetNative takes real value, real oldValue returns boolean
                        if IsUnitPaused(Unit(this).self) then
                            return false
                        endif
                        set this.nativeValue = value
                        call UNIT.Items.Events.Gain.DUMMY_TRIGGER.Disable()
                        call UNIT.Items.Events.Lose.DUMMY_TRIGGER.Disable()
                        call BJUnit.Damage.Add(Unit(this).self, Real.ToInt(value) - Real.ToInt(oldValue))
                        call UNIT.Items.Events.Gain.DUMMY_TRIGGER.Enable()
                        call UNIT.Items.Events.Lose.DUMMY_TRIGGER.Enable()
                        return true
                    endmethod
                    eventMethod Event_Selection
                        local thistype this = params.Unit.GetTrigger()
                        if this.SetNative(this.Get(), this.nativeValue) then
                            set this.waitForSelection = false
                            call Unit(this).Event.Remove(SELECTION_EVENT)
                        endif
                    endmethod
                    method Set takes real value returns nothing
                        local real nativeValue = this.nativeValue
                        set this.value = value
                        if (value == nativeValue) then
                            if this.waitForSelection then
                                set this.waitForSelection = false
                                call Unit(this).Event.Remove(SELECTION_EVENT)
                            endif
                            return
                        endif
                        if Unit(this).Selection.IsEmpty() then
                            if not this.waitForSelection then
                                set this.waitForSelection = true
                                call Unit(this).Event.Add(SELECTION_EVENT)
                            endif
                        else
                            call this.SetNative(value, nativeValue)
                        endif
                    endmethod
                else
                    method Set takes real value returns nothing
                        local real oldValue = this.value
                        set this.value = value
                        call UNIT.Items.Events.Gain.DUMMY_TRIGGER.Disable()
                        call UNIT.Items.Events.Lose.DUMMY_TRIGGER.Disable()
                        call BJUnit.Damage.Add(Unit(this).self, Real.ToInt(value) - Real.ToInt(oldValue))
                        call UNIT.Items.Events.Gain.DUMMY_TRIGGER.Enable()
                        call UNIT.Items.Events.Lose.DUMMY_TRIGGER.Enable()
                    endmethod
                endif
                method Update takes nothing returns nothing
                    
                    call this.Set(Unit(this).Damage.Base.Get())
                endmethod
                method Event_TypeChange takes UnitType targetType returns nothing
                    static if thistype.WAIT_FOR_SELECTION then
                        set this.nativeValue = targetType.Damage.GetBJ()
                        set this.waitForSelection = false
                    endif
                endmethod
                method Event_Create takes nothing returns nothing
                    local UnitType thisType = Unit(this).Type.Get()
                    set this.value = thisType.Damage.Get()
                    static if thistype.WAIT_FOR_SELECTION then
                        set this.nativeValue = thisType.Damage.GetBJ()
                        set this.waitForSelection = false
                    endif
                endmethod
                static method Init takes nothing returns nothing
                    
                    static if thistype.WAIT_FOR_SELECTION then
                        set thistype.SELECTION_EVENT = Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Selection)
                    endif
                endmethod
            endstruct
        endscope
    public struct StructBase
        implement Allocation
        implement List
        
    FolderBase_StructDisplayed Displayed = this
    FolderBase_StructDisplayed LinkToStruct_Displayed
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call this.Displayed.Update()
                call Unit(this).Damage.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_TypeChange
                local UnitType sourceType = params.UnitType.GetSource()
                local UnitType targetType = params.UnitType.GetTrigger()
                local thistype this = params.Unit.GetTrigger()
                call this.Displayed.Event_TypeChange(targetType)
                call this.Add(targetType.Damage.Get() - sourceType.Damage.Get())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = Unit(this).Type.Get().Damage.Get()
                call this.Displayed.Event_Create()
            endmethod
            static method Init takes nothing returns nothing
                call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
                call thistype(NULL).Displayed.Init()
            endmethod
        endstruct
    scope FolderBonus
    public struct StructDisplayed
        implement Allocation
        implement List
        
        static constant boolean WAIT_FOR_SELECTION = true
        real value
        method Get takes nothing returns real
            return this.value
        endmethod
        static if true then
            static Event SELECTION_EVENT
            real nativeValue
            boolean waitForSelection
            method SetNative takes real value, real oldValue returns nothing
                set this.nativeValue = value
                call BJUnit.Damage.Bonus.Set(Unit(this).self, value, oldValue)
            endmethod
            eventMethod Event_Selection
                local thistype this = params.Unit.GetTrigger()
                set this.waitForSelection = false
                call Unit(this).Event.Remove(SELECTION_EVENT)
                call this.SetNative(this.Get(), this.nativeValue)
            endmethod
            method SetDisplay takes real value returns nothing
                local real nativeValue = this.nativeValue
                set this.value = value
                if (value == nativeValue) then
                    if this.waitForSelection then
                        set this.waitForSelection = false
                        call Unit(this).Event.Remove(SELECTION_EVENT)
                    endif
                    return
                endif
                if Unit(this).Selection.IsEmpty() then
                    if not this.waitForSelection then
                        set this.waitForSelection = true
                        call Unit(this).Event.Add(SELECTION_EVENT)
                    endif
                else
                    call this.SetNative(value, nativeValue)
                endif
            endmethod
        else
            method SetDisplay takes real value returns nothing
                local real oldValue = this.Get()
                set this.value = value
                call BJUnit.Damage.Bonus.Set(Unit(this).self, value, oldValue)
            endmethod
        endif
        method AddOnlySave takes real value returns nothing
            set this.value = this.Get() + value
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0.
            static if true then
                set this.nativeValue = 0.
                set this.waitForSelection = false
            endif
        endmethod
				method Set takes real val returns nothing
					call this.SetDisplay(val)
				endmethod
                method Update takes nothing returns nothing
                    call this.Set(Unit(this).Damage.Base.Get() * (Unit(this).Damage.Relative.Get() - 1) + Unit(this).Damage.Bonus.Get())
                endmethod
                static method Init takes nothing returns nothing
                    static if thistype.WAIT_FOR_SELECTION then
                        set thistype.SELECTION_EVENT = Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Selection)
                    endif
                endmethod
            endstruct
        endscope
    public struct StructBonus
        implement Allocation
        implement List
        
        	static UnitState STATE
    FolderBonus_StructDisplayed Displayed = this
    FolderBonus_StructDisplayed LinkToStruct_Displayed
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).Damage.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
                call this.Displayed.Event_Create()
            endmethod
            static method Init takes nothing returns nothing
            	set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
                call thistype(NULL).Displayed.Init()
            endmethod
        endstruct
    public struct StructDelay
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(Unit(this).Type.Get().Damage.Delay.Get())
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructDices
        implement Allocation
        implement List
        
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(Unit(this).Type.Get().Damage.Dices.Get())
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_TypeChange
                local UnitType targetType = params.UnitType.GetTrigger()
                local thistype this = params.Unit.GetTrigger()
                call this.Set(targetType.Damage.Dices.Get())
            endmethod
            static method Init takes nothing returns nothing
                call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            endmethod
        endstruct
    public struct StructEvents
        implement Allocation
        implement List
        
            static EventType ATTACKER_EDIT_EVENT_TYPE
            static EventType ATTACKER_EVENT_TYPE
            static Trigger DUMMY_TRIGGER
            static boolean IGNORE_NEXT = false
            static boolean SPELL_NEXT = false
            static BoolExpr SPLASH_FILTER
            static Group SPLASH_GROUP
            static UnitList SPLASH_GROUP2
            static EventType TARGET_EDIT_EVENT_TYPE
            static EventType TARGET_EVENT_TYPE
    static key GetKeyMacro_TEXT_TAG_KEY_ARRAY
    static constant integer TEXT_TAG_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_TEXT_TAG_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
            method TriggerEvents takes real amount, Unit target, boolean isSpell returns real
                local Unit parent = this
                local EventResponse params = EventResponse.Create(parent.Id.Get())
                call params.Real.SetDamage(amount)
                call params.Unit.SetDamager(parent)
                call params.Unit.SetTarget(target)
                call params.Unit.SetTrigger(target)
				local EventResponse targetParams = EventResponse.Create(target.Id.Get())
                call targetParams.Real.SetDamage(amount)
                call targetParams.Unit.SetDamager(parent)
                call targetParams.Unit.SetTrigger(target)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = target.Event.Count(thistype.TARGET_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call target.Event.Get(thistype.TARGET_EVENT_TYPE, priority, iteration2).Run(targetParams)
                        call params.Real.SetDamage(targetParams.Real.GetDamage())
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration2 = parent.Event.Count(thistype.ATTACKER_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call parent.Event.Get(thistype.ATTACKER_EVENT_TYPE, priority, iteration2).Run(params)
                        call targetParams.Real.SetDamage(params.Real.GetDamage())
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call params.Destroy()
                call targetParams.Destroy()
                set amount = params.Real.GetDamage()
                return amount
            endmethod
            condMethod SplashConditions
                local Unit target = UNIT.Event.Native.GetFilter()
                if thistype.SPLASH_GROUP2.Contains(target) then
                    return false
                endif
                if (not TEMP_BOOLEAN and target.IsAllyOf(User.TEMP)) then
                    return false
                endif
                if target.Classes.Contains(UnitClass.DEAD) then
                    return false
                endif
                if not target.Classes.Contains(UnitClass.GROUND) then
                    return false
                endif
                return true
            endmethod
            method DealSplash_Single takes Unit target, real amount, integer whichType returns nothing
                set amount = amount * (1. - target.Armor.IgnoreDamage.Relative.Get())
                set amount = amount * UNIT.Armor.GetDamageFactor(target.Armor.Get())
                set amount = amount * Attack.Get(whichType, target.Armor.TypeA.Get())
                call Unit(this).DamageUnit(target, amount, false)
            endmethod
            method DealSplash takes real damageAmount, integer damageType, real x, real y, Unit primaryTarget returns nothing
                local integer iterationEnd = Unit(this).Attack.Splash.Count()
                if (iterationEnd < Memory.IntegerKeys.Table.STARTED) then
                    return
                endif
                local boolean affectsAlly = Unit(this).Attack.Splash.TargetFlag.Is(TargetFlag.ALLY)
                local User parentOwner = Unit(this).Owner.Get()
                call thistype.SPLASH_GROUP2.Add(primaryTarget)
				local integer iteration = Memory.IntegerKeys.Table.STARTED
                loop
                    local UnitAttackSplash splash = Unit(this).Attack.Splash.Get(iteration)
                    set TEMP_BOOLEAN = affectsAlly
                    set User.TEMP = parentOwner
                    call thistype.SPLASH_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, splash.GetAreaRange(), thistype.SPLASH_FILTER)
                    local Unit target = thistype.SPLASH_GROUP.FetchFirst()
                    if (target != NULL) then
                        local real rangeDamageAmount = damageAmount * splash.GetDamageFactor()
                        loop
                            call thistype.SPLASH_GROUP2.Add(target)
                            call this.DealSplash_Single(target, rangeDamageAmount, damageType)
                            set target = thistype.SPLASH_GROUP.FetchFirst()
                            exitwhen (target == NULL)
                        endloop
                    endif
                    set iteration = iteration + 1
                    exitwhen (iteration > iterationEnd)
                endloop
                call thistype.SPLASH_GROUP2.Clear()
            endmethod
            method VsUnit takes Unit target, boolean triggerEvents, real amount returns nothing
                local real armorAmount = target.Armor.Get()
                local boolean crit = false
                local integer damageType = Unit(this).Damage.TypeA.Get()
                local real dealtAmount
                local TextTag oldTextTag
                local Unit parent = this
                local real targetX = target.Position.X.Get()
                local real targetY = target.Position.Y.Get()
                local integer iteration = parent.Damage.Dices.Get()
                local integer sides = parent.Damage.Sides.Get()
                if parent.Evasion.Try(target) then
                    return
                endif
                if target.Invulnerability.Try() then
                    return
                endif
                loop
                    exitwhen (iteration < 1)
                    set amount = amount + Math.RandomI(1, sides)
                    set iteration = iteration - 1
                endloop
                set amount = amount * (1. - target.Armor.IgnoreDamage.Relative.Get())
                set amount = amount * UNIT.Armor.GetDamageFactor(target.Armor.Get())
                set amount = amount * Attack.Get(parent.Damage.TypeA.Get(), target.Armor.TypeA.Get())
                set crit = parent.CriticalChance.Random(target)
                set amount = this.TriggerEvents(amount, target, false)
                set dealtAmount = parent.DamageUnit(target, amount, false)
                if crit then
                    set dealtAmount = parent.CriticalChance.Do(target, dealtAmount)
                    if (dealtAmount > 0.) then
                        call target.ReplaceRisingTextTagIfMinorValue(String.Color.Do(Real.ToIntString(dealtAmount) + Char.EXCLAMATION_MARK, parent.Owner.Get().GetColorString()), Math.Linear(dealtAmount, target.MaxLife.Get() / 2., 0.024, 0.028), 160., 0., 1., TEXT_TAG_KEY_ARRAY + target, dealtAmount / 2)
                    endif
                else
                    if (dealtAmount > 0.) then
                        call target.ReplaceRisingTextTagIfMinorValue(String.Color.Do(Real.ToIntString(dealtAmount), parent.Owner.Get().GetColorString()), Math.Linear(dealtAmount, target.MaxLife.Get() / 2., 0.016, 0.022), 160., 0., 1., TEXT_TAG_KEY_ARRAY + target, dealtAmount / 2)
                    endif
                endif
                call parent.LifeLeech.Do(target)
                call parent.ManaLeech.Do(target)
                call this.DealSplash(amount, damageType, targetX, targetY, target)
            endmethod
            trigMethod Trig
                local Unit parent = UNIT.Event.Native.GetDamager()
                local boolean isSpell = thistype.SPELL_NEXT
                local Unit target = UNIT.Event.Native.GetTrigger()
                if ((parent == STRUCT_INVALID) or (TRIGGER.Event.Native.GetDamage() == 0.) or (parent.Attack.GetType() == Attack.ARTILLERY)) then
                    set thistype.IGNORE_NEXT = true
                endif
                set thistype.SPELL_NEXT = false
                if thistype.IGNORE_NEXT then
                    set thistype.IGNORE_NEXT = false
                else
                    if isSpell then
                        call thistype(parent).TriggerEvents(0., target, true)
                    else
                        call thistype(parent).VsUnit(target, true, parent.Damage.Get())
                    endif
                endif
            endmethod
            method Event_Create takes nothing returns nothing
                call thistype.DUMMY_TRIGGER.RegisterEvent.Unit(this, EVENT_UNIT_DAMAGED)
            endmethod
            static method Init takes nothing returns nothing
                set thistype.ATTACKER_EDIT_EVENT_TYPE = EventType.Create()
                set thistype.ATTACKER_EVENT_TYPE = EventType.Create()
                set thistype.DUMMY_TRIGGER = Trigger.CreateFromCode(function thistype.Trig)
                set thistype.SPLASH_FILTER = BoolExpr.GetFromFunction(function thistype.SplashConditions)
                set thistype.SPLASH_GROUP = Group.Create()
                set thistype.SPLASH_GROUP2 = UnitList.Create()
                set thistype.TARGET_EDIT_EVENT_TYPE = EventType.Create()
                set thistype.TARGET_EVENT_TYPE = EventType.Create()
            endmethod
        endstruct
    scope FolderRelative
    public struct StructInvisible
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
                method Set takes real value returns nothing
                    set this.value = value
                    call Unit(this).Damage.Update()
                endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
                method Event_Create takes nothing returns nothing
                    set this.value = 1.
                endmethod
            endstruct
        endscope
    public struct StructRelative
        implement Allocation
        implement List
        
            static UnitState STATE
    FolderRelative_StructInvisible Invisible = this
    FolderRelative_StructInvisible LinkToStruct_Invisible
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).Damage.Bonus.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 1.
                call Invisible.Event_Create()
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    public struct StructSides
        implement Allocation
        implement List
        
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(Unit(this).Type.Get().Damage.Sides.Get())
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_TypeChange
                local UnitType targetType = params.UnitType.GetTrigger()
                local thistype this = params.Unit.GetTrigger()
                call this.Set(targetType.Damage.Sides.Get())
            endmethod
            static method Init takes nothing returns nothing
                call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            endmethod
        endstruct
    public struct StructSpellRelative
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(1.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructTypeA
        implement Allocation
        implement List
        
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(Unit(this).Type.Get().Damage.Type.Get())
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_TypeChange
                local UnitType targetType = params.UnitType.GetTrigger()
                local thistype this = params.Unit.GetTrigger()
                call this.Set(targetType.Damage.Type.Get())
            endmethod
            static method Init takes nothing returns nothing
                call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            endmethod
        endstruct
    endscope
    public struct StructDamage
        implement Allocation
        implement List
        
        real visVal
        real visBonusVal
    FolderDamage_StructBase Base = this
    FolderDamage_StructBase LinkToStruct_Base
    FolderDamage_StructBonus Bonus = this
    FolderDamage_StructBonus LinkToStruct_Bonus
    FolderDamage_StructDelay Delay = this
    FolderDamage_StructDelay LinkToStruct_Delay
    FolderDamage_StructDices Dices = this
    FolderDamage_StructDices LinkToStruct_Dices
    FolderDamage_StructEvents Events = this
    FolderDamage_StructEvents LinkToStruct_Events
    FolderDamage_StructRelative Relative = this
    FolderDamage_StructRelative LinkToStruct_Relative
    FolderDamage_StructSides Sides = this
    FolderDamage_StructSides LinkToStruct_Sides
    FolderDamage_StructSpellRelative SpellRelative = this
    FolderDamage_StructSpellRelative LinkToStruct_SpellRelative
    FolderDamage_StructTypeA TypeA = this
    FolderDamage_StructTypeA LinkToStruct_TypeA
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method GetVisible takes nothing returns real
            return this.visVal
        endmethod
        method GetVisibleBonus takes nothing returns real
            return this.visBonusVal
        endmethod
        method Set takes real value returns nothing
            set this.value = value
            call this.Bonus.Displayed.Update()
        endmethod
        method Update takes nothing returns nothing
            local real baseVal = this.Base.Get()
            local real bonusVal = this.Bonus.Get()
            local real relVal = this.Relative.Get()
            set this.visVal = baseVal * relVal + bonusVal
            set this.visBonusVal = baseVal * (relVal - 1) + bonusVal
            call this.Set(baseVal * relVal * this.Relative.Invisible.Get() + bonusVal)
        endmethod
        method Do takes Unit target, real amount, boolean triggerEvents returns real
            if target.Invulnerability.Try() then
                return 0.
            endif
            set amount = amount * (1. - target.Armor.Resistance.Get())
            if (amount > 0.) then
                if triggerEvents then
                    set amount = this.Events.TriggerEvents(amount, target, false)
                endif
                set amount = Math.Min(amount, target.Life.Get())
                call UnitDamageTarget(Unit(this).self, target.self, 0., false, false, null, null, null)
                set UNIT.Life.DAMAGE_SOURCE = this
                call target.Life.Subtract(amount)
                return amount
            endif
            return 0.
        endmethod
        method DoBySpell takes Unit target, real amount, boolean magical, boolean triggerEvents returns real
            local boolean crit = false
            if (amount > 0.) then
                if magical then
                    if target.MagicImmunity.Try() then
                        return 0.
                    endif
                    set amount = amount * Unit(this).SpellPower.GetDamageFactor(target.SpellPower.Get() - Unit(this).SpellPower.Get()) * (1. - target.Armor.Spell.Get()) * Math.Random(0.9, 1.1)
                else
                    set amount = amount * Unit(this).Armor.GetDamageFactor(target.Armor.Get())
                endif
                if (not magical and Unit(this).CriticalChance.Random(target)) then
                    set amount = amount * UNIT.CriticalChance.DAMAGE_FACTOR
                    set crit = true
                endif
            endif
            set amount = this.Do(target, amount, triggerEvents)
            call Unit(this).SpellVamp.Do(amount, crit)
            return amount
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0.
            call this.Base.Event_Create()
            call this.Bonus.Event_Create()
            call this.Delay.Event_Create()
            call this.Dices.Event_Create()
            call this.Events.Event_Create()
            call this.Relative.Event_Create()
            call this.Sides.Event_Create()
            call this.SpellRelative.Event_Create()
            call this.TypeA.Event_Create()
            call this.Update()
        endmethod
        static method Init takes nothing returns nothing
            call thistype(NULL).Base.Init()
            call thistype(NULL).Bonus.Init()
            call thistype(NULL).Dices.Init()
            call thistype(NULL).Events.Init()
            call thistype(NULL).Relative.Init()
            call thistype(NULL).Sides.Init()
            call thistype(NULL).TypeA.Init()
        endmethod
    endstruct
    scope FolderMagicImmunity
    public struct StructSpellShield
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
            static constant string TRY_TEXT = "Blocked!!"
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
            method Try takes nothing returns boolean
                if not this.Is() then
                    return false
                endif
                call Unit(this).AddJumpingTextTag(String.Color.Do(thistype.TRY_TEXT, "d4e019aa"), 0.02, KEY_ARRAY + this)
                call Unit(this).Effects.Create("Abilities\\Spells\\Other\\HealingSpray\\HealBottleMissile.mdl", AttachPoint.CHEST, EffectLevel.LOW).Destroy()
                call Unit(this).Buffs.Remove(Unit(this).Data.Integer.Table.Get(KEY_ARRAY, Memory.IntegerKeys.Table.STARTED))
                return true
            endmethod
            eventMethod Event_BuffLose
                local Buff whichBuff = params.Buff.GetData()
                local Unit parent = params.Unit.GetTrigger()
                local thistype this = parent
                call this.Set(false)
                call parent.Data.Integer.Table.Remove(KEY_ARRAY, whichBuff)
            endmethod
            eventMethod Event_BuffGain
                local Buff whichBuff = params.Buff.GetData()
                local Unit parent = params.Unit.GetTrigger()
                local thistype this = parent
                call this.Set(true)
                call parent.Data.Integer.Table.Add(KEY_ARRAY, whichBuff)
            endmethod
            method Event_Create takes nothing returns nothing
                call this.Set(false)
            endmethod
            initMethod Buff_Init of Header_Buffs
                call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_BuffGain))
                call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_BuffLose))
                call thistype.DUMMY_BUFF.Variants.Add(thistype.NORMAL_BUFF)
            endmethod
            static method Init takes nothing returns nothing
            endmethod
        endstruct
    endscope
    public struct StructMagicImmunity
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        static UnitState STATE
        static constant string TRY_TEXT = "Magic immune!!"
    FolderMagicImmunity_StructSpellShield SpellShield = this
    FolderMagicImmunity_StructSpellShield LinkToStruct_SpellShield
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        method Try takes nothing returns boolean
            if not this.Is() then
                return this.SpellShield.Try()
            endif
            call Unit(this).AddJumpingTextTag(String.Color.Do(thistype.TRY_TEXT, "d4e019aa"), 0.02, KEY_ARRAY + this)
            return true
        endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(false)
        endmethod
        eventMethod Event_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(true)
        endmethod
        method Subtract takes nothing returns nothing
            call Unit(this).Buffs.Subtract(thistype.NORMAL_BUFF)
        endmethod
        method Add takes nothing returns nothing
            call Unit(this).Buffs.Add(thistype.NORMAL_BUFF, 1)
        endmethod
        method AddTimed takes real duration returns nothing
            call Unit(this).Buffs.Timed.Start(thistype.NORMAL_BUFF, 1, duration)
        endmethod
        method Change takes boolean val returns nothing
            if val then
                call this.Add()
            else
                call this.Subtract()
            endif
        endmethod
        eventMethod Event_State
            call thistype(params.Unit.GetTrigger()).Change(params.Bool.GetVal())
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(false)
            call this.SpellShield.Event_Create()
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_BuffLose))
            call thistype.DUMMY_BUFF.Variants.Add(thistype.NORMAL_BUFF)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            
            call thistype(NULL).SpellShield.Init()
        endmethod
    endstruct
    scope FolderScale
    public struct StructBonus
        implement Allocation
        implement List
        
            static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).Scale.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    public struct StructTimed
        implement Allocation
        implement List
        
            static Event DESTROY_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
            static Timer UPDATE_TIMER
            static UnitState STATE
            real scaleAdd
            Timer durationTimer
            Unit parent
            timerMethod Update
                local integer iteration = thistype.ALL_COUNT
                loop
                    local thistype this = thistype.ALL[iteration]
                    call this.parent.Scale.AddSimple(this.scaleAdd)
                    set iteration = iteration - 1
                    exitwhen (iteration < ARRAY_MIN)
                endloop
            endmethod
            method Ending takes Timer durationTimer, Unit parent returns nothing
                call this.deallocate()
                call durationTimer.Destroy()
                if parent.Data.Integer.Table.Remove(KEY_ARRAY, this) then
                    call parent.Event.Remove(DESTROY_EVENT)
                endif
                if this.RemoveFromList() then
                    call thistype.UPDATE_TIMER.Pause()
                endif
            endmethod
            eventMethod Event_Destroy
                local Unit parent = params.Unit.GetTrigger()
                local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                loop
                    local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                    call this.Ending(this.durationTimer, parent)
                    set iteration = iteration - 1
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                endloop
            endmethod
            timerMethod EndingByTimer
                local Timer durationTimer = Timer.GetExpired()
                local thistype this = durationTimer.GetData()
                call this.Ending(durationTimer, this.parent)
                call this.parent.Scale.Update()
            endmethod
            method Add takes real scale, real duration returns nothing
                local Unit parent = this
                if (duration == 0.) then
                    call Unit(this).Scale.Add(scale)
                    return
                endif
                local integer wavesAmount = Real.ToInt(duration / thistype.UPDATE_TIME)
				set this = thistype.allocate()
				local Timer durationTimer = Timer.Create()
                set this.durationTimer = durationTimer
                set this.parent = parent
                set this.scaleAdd = scale / wavesAmount
                call durationTimer.SetData(this)
                if parent.Data.Integer.Table.Add(KEY_ARRAY, this) then
                    call parent.Event.Add(DESTROY_EVENT)
                endif
                if this.AddToList() then
                    call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
                endif
                call durationTimer.Start(duration, false, function thistype.EndingByTimer)
            endmethod
            method Subtract takes real scale, real duration returns nothing
                call this.Add(-scale, duration)
            endmethod
    static key GetKeyMacro_STATE_SCALE_KEY
    static constant integer STATE_SCALE_KEY = Math.Integer.MIN + GetKeyMacro_STATE_SCALE_KEY
    static key GetKeyMacro_STATE_DURATION_KEY
    static constant integer STATE_DURATION_KEY = Math.Integer.MIN + GetKeyMacro_STATE_DURATION_KEY
            eventMethod Event_State
                
                
                
                local UnitMod mod = params.UnitMod.GetTrigger()
                
                local real scale = thistype(mod).mod_scale
                local real dur = thistype(mod).mod_dur
                if not params.Bool.GetAdded() then
                    set scale = -scale
                endif
                call thistype(params.Unit.GetTrigger()).Add(scale, dur)
            endmethod
            real mod_scale
            real mod_dur
            eventMethod Event_ModLose
                local UnitMod mod = params.UnitMod.GetTrigger()
                call thistype(params.Unit.GetTrigger()).Subtract(thistype(mod).mod_scale, thistype(mod).mod_dur)
            endmethod
            eventMethod Event_ModGain
                local UnitMod mod = params.UnitMod.GetTrigger()
                call thistype(params.Unit.GetTrigger()).Add(thistype(mod).mod_scale, thistype(mod).mod_dur)
            endmethod
            method CreateMod takes real scale, real dur returns UnitMod
                local UnitMod mod = UnitMod.Create(thistype.STATE, function thistype.Event_ModGain, function thistype.Event_ModLose)
                set thistype(mod).mod_scale = scale
                set thistype(mod).mod_dur = dur
                return mod
            endmethod
            static method Init takes nothing returns nothing
                set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
                set thistype.UPDATE_TIMER = Timer.Create()
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    endscope
    public struct StructScale
        implement Allocation
        implement List
        
        static Event MODDED_DEATH_EVENT
        static Event MODDED_REVIVE_EVENT
    FolderScale_StructBonus Bonus = this
    FolderScale_StructBonus LinkToStruct_Bonus
    FolderScale_StructTimed Timed = this
    FolderScale_StructTimed LinkToStruct_Timed
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method GetAll takes nothing returns real
            return (this.Get() + this.Bonus.Get())
        endmethod
        method UpdateSimple takes nothing returns nothing
            local real val = this.GetAll()
            call SetUnitScale(Unit(this).self, val, val, val)
        endmethod
        eventMethod Event_Modded_Death
            call thistype(params.Unit.GetTrigger()).UpdateSimple()
        endmethod
        eventMethod Event_Modded_Revive
            call thistype(params.Unit.GetTrigger()).Update()
        endmethod
        eventMethod Event_Modded_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
            call Unit(this).Event.Remove(MODDED_DEATH_EVENT)
            call Unit(this).Event.Remove(MODDED_REVIVE_EVENT)
        endmethod
        eventMethod Event_Modded_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
            call Unit(this).Event.Add(MODDED_DEATH_EVENT)
            call Unit(this).Event.Add(MODDED_REVIVE_EVENT)
        endmethod
        Timer trans_delayTimer
        timerMethod Trans_Delay
            local thistype this = Timer.GetExpired().GetData()
            call Unit(this).Buffs.Remove(thistype.TRANS_BUFF)
            call this.UpdateSimple()
        endmethod
        eventMethod Event_Trans_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
            local Timer delayTimer = this.trans_delayTimer
            call delayTimer.Destroy()
        endmethod
        eventMethod Event_Trans_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
            local Timer delayTimer = Timer.Create()
            set this.trans_delayTimer = delayTimer
            call delayTimer.SetData(this)
            call delayTimer.Start(1.01, false, function thistype.Trans_Delay)
        endmethod
        method Update takes nothing returns nothing
            local real valD = this.GetAll() - Unit(this).Type.Get().Scale.Get()
            call Unit(this).Buffs.RemoveBySelf(thistype.DUMMY_BUFF_ID)
            if (valD == 0) then
                call Unit(this).Buffs.Remove(thistype.MODDED_BUFF)
                call this.UpdateSimple()
                return
            endif
            if Unit(this).Classes.Contains(UnitClass.DEAD) then
                call this.UpdateSimple()
                return
            endif
            local integer dummySpellId = thistype.DUMMY_SPELLS_ID[Math.LimitI(Real.ToInt(((valD) - thistype.MIN) / thistype.STEP_SIZE), thistype.MIN_INDEX, thistype.MAX_INDEX)]
            call DummyUnit.WORLD_CASTER.Abilities.AddBySelf(dummySpellId)
            call DummyUnit.WORLD_CASTER.Order.UnitTargetInstantly(Order.BLOOD_LUST, this)
            call DummyUnit.WORLD_CASTER.Abilities.RemoveBySelf(dummySpellId)
            call this.UpdateSimple()
            call Unit(this).Buffs.Add(thistype.MODDED_BUFF, 1)
            call Unit(this).Buffs.Add(thistype.TRANS_BUFF, 1)
            
            call Unit(this).Selection.UpdateCircle()
        endmethod
        method SetSimple takes real val returns nothing
            set this.value = val
            call this.UpdateSimple()
        endmethod
        method Set takes real val returns nothing
            set this.value = val
            call this.Update()
        endmethod
        method AddSimple takes real val returns nothing
            call this.SetSimple(this.Get() + val)
        endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
        eventMethod Event_TypeChange
            local UnitType sourceType = params.UnitType.GetSource()
            local UnitType targetType = params.UnitType.GetTrigger()
            local thistype this = params.Unit.GetTrigger()
            call this.Add(targetType.Scale.Get() - sourceType.Scale.Get())
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = Unit(this).Type.Get().Scale.Get()
            call this.Bonus.Event_Create()
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.MODDED_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Modded_BuffGain))
            call thistype.MODDED_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Modded_BuffLose))
            call thistype.TRANS_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Trans_BuffGain))
            call thistype.TRANS_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Trans_BuffLose))
        endmethod
        static method Init takes nothing returns nothing
            call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            set thistype.MODDED_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Modded_Death)
            set thistype.MODDED_REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Modded_Revive)
            call thistype(NULL).Bonus.Init()
            call thistype(NULL).Timed.Init()
        endmethod
    endstruct
    scope FolderVertexColor
    public struct StructRed
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(Unit(this).Type.Get().VertexColor.Red.Get())
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructGreen
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(Unit(this).Type.Get().VertexColor.Green.Get())
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructBlue
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(Unit(this).Type.Get().VertexColor.Blue.Get())
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructAlpha
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(Unit(this).Type.Get().VertexColor.Alpha.Get())
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructTimed
        implement Allocation
        implement List
        
            static Event DESTROY_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
            static UnitState STATE
    static constant real UPDATE_TIME = FRAME_UPDATE_TIME * 16
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = 16
            static Timer UPDATE_TIMER
            real bonusRedPerInterval
            real bonusGreenPerInterval
            real bonusBluePerInterval
            real bonusAlphaPerInterval
            Timer durationTimer
            Unit parent
            method Ending takes Timer durationTimer, Unit parent returns nothing
                call this.deallocate()
                call durationTimer.Destroy()
                if parent.Data.Integer.Table.Remove(KEY_ARRAY, this) then
                    call parent.Event.Remove(DESTROY_EVENT)
                endif
                if this.RemoveFromList() then
                    call thistype.UPDATE_TIMER.Pause()
                endif
            endmethod
            eventMethod Event_Destroy
                local Unit parent = params.Unit.GetTrigger()
                local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                loop
                    local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                    call this.Ending(this.durationTimer, parent)
                    set iteration = iteration - 1
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                endloop
            endmethod
            timerMethod EndingByTimer
                local Timer durationTimer = Timer.GetExpired()
                local thistype this = durationTimer.GetData()
                call this.Ending(durationTimer, this.parent)
            endmethod
            static method Update takes nothing returns nothing
                local integer iteration = thistype.ALL_COUNT
                loop
                    local thistype this = thistype.ALL[iteration]
                    call this.parent.VertexColor.Add(this.bonusRedPerInterval, this.bonusGreenPerInterval, this.bonusBluePerInterval, this.bonusAlphaPerInterval)
                    set iteration = iteration - 1
                    exitwhen (iteration < ARRAY_MIN)
                endloop
            endmethod
            method Add takes real red, real green, real blue, real alpha, real duration returns nothing
                local Unit parent = this
                if (duration == 0.) then
                    call Unit(this).VertexColor.Add(red, green, blue, alpha)
                    return
                endif
				local integer wavesAmount = Real.ToInt(duration / UPDATE_TIME)
                set this = thistype.allocate()
				local Timer durationTimer = Timer.Create()
                set this.bonusRedPerInterval = red / wavesAmount
                set this.bonusGreenPerInterval = green / wavesAmount
                set this.bonusBluePerInterval = blue / wavesAmount
                set this.bonusAlphaPerInterval = alpha / wavesAmount
                set this.durationTimer = durationTimer
                set this.parent = parent
                call durationTimer.SetData(this)
                if parent.Data.Integer.Table.Add(KEY_ARRAY, this) then
                    call parent.Event.Add(DESTROY_EVENT)
                endif
                if this.AddToList() then
                    call thistype.UPDATE_TIMER.Start(UPDATE_TIME, true, function thistype.Update)
                endif
                call durationTimer.Start(duration, false, function thistype.EndingByTimer)
            endmethod
            method Subtract takes real red, real green, real blue, real alpha, real duration returns nothing
                call this.Add(-red, -green, -blue, -alpha, duration)
            endmethod
	        real mod_red
	        real mod_green
	        real mod_blue
	        real mod_alpha
	        real mod_duration
	        eventMethod Event_State	
				local UnitMod mod = params.UnitMod.GetTrigger()
	
				local real red = thistype(mod).mod_red
				local real green = thistype(mod).mod_green
				local real blue = thistype(mod).mod_blue
				local real alpha = thistype(mod).mod_alpha
				local real duration = thistype(mod).mod_duration
	
	            if params.Bool.GetAdded() then
	                call thistype(params.Unit.GetTrigger()).Add(red, green, blue, alpha, duration)
	            else
	                call thistype(params.Unit.GetTrigger()).Subtract(red, green, blue, alpha, duration)
	            endif
	        endmethod
	        eventMethod Event_ModLose
	            local UnitMod mod = params.UnitMod.GetTrigger()
	
	            call thistype(params.Unit.GetTrigger()).Subtract(thistype(mod).mod_red, thistype(mod).mod_green, thistype(mod).mod_blue, thistype(mod).mod_alpha, thistype(mod).mod_duration)
	        endmethod
	
	        eventMethod Event_ModGain
	            local UnitMod mod = params.UnitMod.GetTrigger()
	
	            call thistype(params.Unit.GetTrigger()).Add(thistype(mod).mod_red, thistype(mod).mod_green, thistype(mod).mod_blue, thistype(mod).mod_alpha, thistype(mod).mod_duration)
	        endmethod
	
	        method CreateMod takes real red, real green, real blue, real alpha, real duration returns UnitMod
	            local UnitMod mod = UnitMod.Create(thistype.STATE, function thistype.Event_ModGain, function thistype.Event_ModLose)
	
	            set thistype(mod).mod_red = red
	            set thistype(mod).mod_green = green
	            set thistype(mod).mod_blue = blue
	            set thistype(mod).mod_alpha = alpha
	            set thistype(mod).mod_duration = duration
	
	            return mod
	        endmethod
            static method Init takes nothing returns nothing
                set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
                set thistype.UPDATE_TIMER = Timer.Create()
            endmethod
        endstruct
    endscope
    public struct StructVertexColor
        implement Allocation
        implement List
        
        static Event DESTROY_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        static UnitState STATE
    static key GetKeyMacro_RED_KEY_ARRAY_DETAIL
    static constant integer RED_KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_RED_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_GREEN_KEY_ARRAY_DETAIL
    static constant integer GREEN_KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_GREEN_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_BLUE_KEY_ARRAY_DETAIL
    static constant integer BLUE_KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_BLUE_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_ALPHA_KEY_ARRAY_DETAIL
    static constant integer ALPHA_KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_ALPHA_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    FolderVertexColor_StructRed Red = this
    FolderVertexColor_StructRed LinkToStruct_Red
    FolderVertexColor_StructGreen Green = this
    FolderVertexColor_StructGreen LinkToStruct_Green
    FolderVertexColor_StructBlue Blue = this
    FolderVertexColor_StructBlue LinkToStruct_Blue
    FolderVertexColor_StructAlpha Alpha = this
    FolderVertexColor_StructAlpha LinkToStruct_Alpha
    FolderVertexColor_StructTimed Timed = this
    FolderVertexColor_StructTimed LinkToStruct_Timed
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method GetRedForPlayer takes User whichPlayer returns real
            return Unit(this).Data.Real.Get(RED_KEY_ARRAY_DETAIL + whichPlayer)
        endmethod
        method GetGreenForPlayer takes User whichPlayer returns real
            return Unit(this).Data.Real.Get(GREEN_KEY_ARRAY_DETAIL + whichPlayer)
        endmethod
        method GetBlueForPlayer takes User whichPlayer returns real
            return Unit(this).Data.Real.Get(BLUE_KEY_ARRAY_DETAIL + whichPlayer)
        endmethod
        method GetAlphaForPlayer takes User whichPlayer returns real
            return Unit(this).Data.Real.Get(ALPHA_KEY_ARRAY_DETAIL + whichPlayer)
        endmethod
        method Set takes real red, real green, real blue, real alpha returns nothing
            local User whichPlayer = User.GetLocal()
            call this.Red.Set(red)
            call this.Green.Set(green)
            call this.Blue.Set(blue)
            call this.Alpha.Set(alpha)
            if Unit(this).Invisibility.Is() then
                set alpha = UNIT.Invisibility.ALPHA
            endif
            call SetUnitVertexColor(Unit(this).self, Real.ToInt(red + this.GetRedForPlayer(whichPlayer)), Real.ToInt(green + this.GetGreenForPlayer(whichPlayer)), Real.ToInt(blue + this.GetBlueForPlayer(whichPlayer)), Real.ToInt(alpha + this.GetAlphaForPlayer(whichPlayer)))
        endmethod
        eventMethod Event_Destroy
            local Unit parent = params.Unit.GetTrigger()
            local User whichPlayer
            local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
            call parent.Event.Remove(DESTROY_EVENT)
            loop
                set whichPlayer = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                call parent.Data.Integer.Table.Remove(KEY_ARRAY, whichPlayer)
                call parent.Data.Integer.Remove(RED_KEY_ARRAY_DETAIL + whichPlayer)
                call parent.Data.Integer.Remove(GREEN_KEY_ARRAY_DETAIL + whichPlayer)
                call parent.Data.Integer.Remove(BLUE_KEY_ARRAY_DETAIL + whichPlayer)
                call parent.Data.Integer.Remove(ALPHA_KEY_ARRAY_DETAIL + whichPlayer)
                call whichPlayer.Data.Integer.Remove(KEY)
                set iteration = iteration - 1
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            endloop
        endmethod
        method SetForPlayer takes real red, real green, real blue, real alpha, User whichPlayer returns nothing
            if not whichPlayer.Data.Boolean.Is(KEY) then
                call whichPlayer.Data.Boolean.Add(KEY)
                if Unit(this).Data.Integer.Table.Add(KEY_ARRAY, whichPlayer) then
                    call Unit(this).Event.Add(DESTROY_EVENT)
                endif
            endif
            call Unit(this).Data.Real.Set(RED_KEY_ARRAY_DETAIL + whichPlayer, red)
            call Unit(this).Data.Real.Set(GREEN_KEY_ARRAY_DETAIL + whichPlayer, green)
            call Unit(this).Data.Real.Set(BLUE_KEY_ARRAY_DETAIL + whichPlayer, blue)
            call Unit(this).Data.Real.Set(ALPHA_KEY_ARRAY_DETAIL + whichPlayer, alpha)
            call SetUnitVertexColor(Unit(this).self, Real.ToInt(this.Red.Get() + red), Real.ToInt(this.Green.Get() + green), Real.ToInt(this.Blue.Get() + blue), Real.ToInt(this.Alpha.Get() + alpha))
        endmethod
        method Add takes real red, real green, real blue, real alpha returns nothing
            call this.Set(this.Red.Get() + red, this.Green.Get() + green, this.Blue.Get() + blue, this.Alpha.Get() + alpha)
        endmethod
        method AddForPlayer takes real red, real green, real blue, real alpha, User whichPlayer returns nothing
            call this.SetForPlayer(this.GetRedForPlayer(whichPlayer) + red, this.GetGreenForPlayer(whichPlayer) + green, this.GetBlueForPlayer(whichPlayer) + blue, this.GetAlphaForPlayer(whichPlayer) + alpha, whichPlayer)
        endmethod
        method Subtract takes real red, real green, real blue, real alpha returns nothing
            call this.Add(-red, -green, -blue, -alpha)
        endmethod
        method SubtractForPlayer takes real red, real green, real blue, real alpha, User whichPlayer returns nothing
            call this.AddForPlayer(-red, -green, -blue, -alpha, whichPlayer)
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.Red.Get(), this.Green.Get(), this.Blue.Get(), this.Alpha.Get())
        endmethod
    static key GetKeyMacro_STATE_RED_KEY
    static constant integer STATE_RED_KEY = Math.Integer.MIN + GetKeyMacro_STATE_RED_KEY
    static key GetKeyMacro_STATE_GREEN_KEY
    static constant integer STATE_GREEN_KEY = Math.Integer.MIN + GetKeyMacro_STATE_GREEN_KEY
    static key GetKeyMacro_STATE_BLUE_KEY
    static constant integer STATE_BLUE_KEY = Math.Integer.MIN + GetKeyMacro_STATE_BLUE_KEY
    static key GetKeyMacro_STATE_ALPHA_KEY
    static constant integer STATE_ALPHA_KEY = Math.Integer.MIN + GetKeyMacro_STATE_ALPHA_KEY
        real mod_red
        real mod_green
        real mod_blue
        real mod_alpha
        eventMethod Event_State
            
            
            
            
			local UnitMod mod = params.UnitMod.GetTrigger()
			local real red = thistype(mod).mod_red
			local real green = thistype(mod).mod_green
			local real blue = thistype(mod).mod_blue
			local real alpha = thistype(mod).mod_alpha
            if params.Bool.GetAdded() then
                call thistype(params.Unit.GetTrigger()).Add(red, green, blue, alpha)
            else
                call thistype(params.Unit.GetTrigger()).Subtract(red, green, blue, alpha)
            endif
        endmethod
        eventMethod Event_ModLose
            local UnitMod mod = params.UnitMod.GetTrigger()
            call thistype(params.Unit.GetTrigger()).Subtract(thistype(mod).mod_red, thistype(mod).mod_green, thistype(mod).mod_blue, thistype(mod).mod_alpha)
        endmethod
        eventMethod Event_ModGain
            local UnitMod mod = params.UnitMod.GetTrigger()
            call thistype(params.Unit.GetTrigger()).Add(thistype(mod).mod_red, thistype(mod).mod_green, thistype(mod).mod_blue, thistype(mod).mod_alpha)
        endmethod
        method CreateMod takes real red, real green, real blue, real alpha returns UnitMod
            local UnitMod mod = UnitMod.Create(thistype.STATE, function thistype.Event_ModGain, function thistype.Event_ModLose)
            set thistype(mod).mod_red = red
            set thistype(mod).mod_green = green
            set thistype(mod).mod_blue = blue
            set thistype(mod).mod_alpha = alpha
            return mod
        endmethod
        eventMethod Event_TypeChange
            local UnitType sourceType = params.UnitType.GetSource()
            local UnitType targetType = params.UnitType.GetTrigger()
            local thistype this = params.Unit.GetTrigger()
            call this.Add(targetType.VertexColor.Red.Get() - sourceType.VertexColor.Red.Get(), targetType.VertexColor.Green.Get() - sourceType.VertexColor.Green.Get(), targetType.VertexColor.Blue.Get() - sourceType.VertexColor.Blue.Get(), targetType.VertexColor.Alpha.Get() - sourceType.VertexColor.Alpha.Get())
        endmethod
        method Event_Create takes nothing returns nothing
            local UnitType thisType = Unit(this).Type.Get()
            set this.Red.value = thisType.VertexColor.Red.Get()
            set this.Green.value = thisType.VertexColor.Green.Get()
            set this.Blue.value = thisType.VertexColor.Blue.Get()
            set this.Alpha.value = thisType.VertexColor.Alpha.Get()
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
            call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            call thistype(NULL).Timed.Init()
        endmethod
    endstruct
    public struct StructCold
        implement Allocation
        implement List
        
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(false)
        endmethod
        eventMethod Event_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(true)
        endmethod
        method Subtract takes nothing returns nothing
            call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
        endmethod
        method Add takes nothing returns nothing
            call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
        endmethod
        method AddTimed takes real duration returns nothing
            call Unit(this).Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, duration)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(false)
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
    public struct StructFrost
        implement Allocation
        implement List
        
		eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            
            call parent.BloodExplosion.Set(parent.Type.Get().BloodExplosion.Get())
        endmethod
        
		eventMethod Event_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            call parent.BloodExplosion.Set(thistype.SPECIAL_EFFECT_PATH)
        endmethod
            
        initMethod Buff_Init of Header_Buffs
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            call thistype.DUMMY_BUFF.Variants.Add(thistype.NORMAL_BUFF)
            
            call UNIT.Cold.DUMMY_BUFF.Variants.Add(thistype.DUMMY_BUFF)
            call UNIT.Death.Explosion.DUMMY_BUFF.Variants.Add(thistype.DUMMY_BUFF)
            call UNIT.Stun.DUMMY_BUFF.Variants.Add(thistype.DUMMY_BUFF)
        endmethod
        static method Init takes nothing returns nothing
        endmethod
	endstruct
    scope FolderInvisibility
    public struct StructReveal
        implement Allocation
        implement List
        
            static constant real STANDARD_DURATION = 2.
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
            eventMethod Event_BuffLose
                local Unit parent = params.Unit.GetTrigger()
                call thistype(parent).Set(false)
                if parent.Invisibility.Is() then
                    call parent.Abilities.AddBySelf(UNIT.Invisibility.DUMMY_SPELL_ID)
                endif
            endmethod
            eventMethod Event_BuffGain
                local Unit parent = params.Unit.GetTrigger()
                call thistype(parent).Set(true)
                if parent.Invisibility.Is() then
                    call parent.Abilities.RemoveBySelf(UNIT.Invisibility.DUMMY_SPELL_ID)
                    call parent.Effects.Create(thistype.SPECIAL_EFFECT_PATH, thistype.SPECIAL_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
                    call SetUnitVertexColor(parent.self, Real.ToInt(parent.VertexColor.Red.Get()), Real.ToInt(parent.VertexColor.Green.Get()), Real.ToInt(parent.VertexColor.Blue.Get()), UNIT.Invisibility.ALPHA)
                endif
            endmethod
            method Subtract takes nothing returns nothing
                call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
            endmethod
            method Add takes nothing returns nothing
                call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
            endmethod
            method AddTimed takes real duration returns nothing
                call Unit(this).Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, duration)
            endmethod
            method Event_Create takes nothing returns nothing
                call this.Set(false)
            endmethod
            initMethod Buff_Init of Header_Buffs
                call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
                call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            endmethod
            static method Init takes nothing returns nothing
            endmethod
        endstruct
    endscope
    public struct StructInvisibility
        implement Allocation
        implement List
        
        static constant integer ALPHA = 128
        static Event ATTACK_EVENT
        static Event CAST_EVENT
        static EventType ENDING_EVENT_TYPE
        Timer attackTimer
    FolderInvisibility_StructReveal Reveal = this
    FolderInvisibility_StructReveal LinkToStruct_Reveal
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
    boolean perm
    method IsPerm takes nothing returns boolean
        return this.perm
    endmethod
    method SetPerm takes boolean value returns nothing
        set this.perm = value
    endmethod
        method Ending_TriggerEvents takes nothing returns nothing
            local Unit parent = this
            local EventResponse params = EventResponse.Create(parent.Id.Get())
            call params.Unit.SetTrigger(this)
			local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = parent.Event.Count(thistype.ENDING_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call parent.Event.Get(thistype.ENDING_EVENT_TYPE, priority, iteration2).Run(params)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            call params.Destroy()
        endmethod
        timerMethod EndingByAttackTimer
            local thistype this = Timer.GetExpired().GetData()
            local Unit parent = this
			if this.IsPerm() then
				return
			endif
            call this.Reveal.AddTimed(UNIT.Invisibility.Reveal.STANDARD_DURATION)
            call parent.Buffs.Remove(thistype.TIMED_BUFF)
        endmethod
        eventMethod Event_Attack
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
            call this.attackTimer.Start(parent.Damage.Delay.Get() + 0.01, false, function thistype.EndingByAttackTimer)
        endmethod
        eventMethod Event_Cast
            local Unit parent = params.Unit.GetTrigger()
            call parent.Buffs.Remove(thistype.TIMED_BUFF)
        endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
            call this.Set(false)
            call parent.Event.Remove(ATTACK_EVENT)
            call parent.Event.Remove(CAST_EVENT)
            call this.attackTimer.Destroy()
            call parent.Abilities.RemoveBySelf(thistype.DUMMY_SPELL_ID)
            call parent.Classes.RemoveNative(UNIT_TYPE_PEON)
            call parent.VertexColor.Update()
            call this.Ending_TriggerEvents()
        endmethod
        eventMethod Event_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
            call this.Set(true)
            local Timer attackTimer = Timer.Create()
            set this.attackTimer = attackTimer
            call attackTimer.SetData(this)
            call parent.Event.Add(ATTACK_EVENT)
            call parent.Event.Add(CAST_EVENT)
			call parent.Classes.AddNative(UNIT_TYPE_PEON)
            if not this.Reveal.Is() then
                call parent.Abilities.AddBySelf(thistype.DUMMY_SPELL_ID)
            endif
			if not parent.Classes.Contains(UnitClass.DEAD) then
				call parent.Order.Deaggravate()
			endif
        endmethod
        method Subtract takes nothing returns nothing
            call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
        endmethod
        method Add takes nothing returns nothing
            call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
        endmethod
        method AddTimed takes real duration returns nothing
            call Unit(this).Buffs.Timed.Start(thistype.TIMED_BUFF, 1, duration)
        endmethod
        eventMethod Event_PermBuffLose
            local Unit parent = params.Unit.GetTrigger()
			call thistype(parent).SetPerm(false)
            call thistype(parent).Subtract()
        endmethod
        eventMethod Event_PermBuffGain
            local Unit parent = params.Unit.GetTrigger()
			call thistype(parent).SetPerm(true)
            call thistype(parent).Add()
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(false)
            call this.SetPerm(false)
            call this.Reveal.Event_Create()
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            call thistype.TIMED_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.TIMED_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            call thistype.PERM_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_PermBuffGain))
            call thistype.PERM_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_PermBuffLose))
        endmethod
        static method Init takes nothing returns nothing
            set thistype.ATTACK_EVENT = Event.Create(UNIT.Attack.Events.OFFENDED_REVERSED_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Attack)
            set thistype.CAST_EVENT = Event.Create(UNIT.Abilities.Events.Begin.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Cast)
            set thistype.ENDING_EVENT_TYPE = EventType.Create()
            call thistype(NULL).Reveal.Init()
        endmethod
    endstruct
    public struct StructGhost
        implement Allocation
        implement List
        
        static UnitState STATE
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(false)
            call parent.Abilities.RemoveBySelf(thistype.DUMMY_SPELL_ID)
            call parent.VertexColor.Update()
        endmethod
        eventMethod Event_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(true)
            call parent.Abilities.AddBySelf(thistype.DUMMY_SPELL_ID)
        endmethod
        method Subtract takes nothing returns nothing
            call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
        endmethod
        method Add takes nothing returns nothing
            call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
        endmethod
        method Change takes boolean val returns nothing
            if val then
                call this.Add()
            else
                call this.Subtract()
            endif
        endmethod
        eventMethod Event_State
            call thistype(params.Unit.GetTrigger()).Change(params.Bool.GetVal())
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(false)
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
        static method Init takes nothing returns nothing
            set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
        endmethod
    endstruct
    public struct StructHealAbility
        implement Allocation
        implement List
        
        static UnitState BONUS_STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(1.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        eventMethod Event_State
            call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
        endmethod
        static method Init takes nothing returns nothing
            set thistype.BONUS_STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
        endmethod
    endstruct
    scope FolderMaxLife
    public struct StructBase
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).MaxLife.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = Unit(this).Type.Get().Life.Get()
            endmethod
            static method Init takes nothing returns nothing
            endmethod
        endstruct
    public struct StructBonus
        implement Allocation
        implement List
        
            static UnitState STATE
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).MaxLife.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    public struct StructRelative
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).MaxLife.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 1.
            endmethod
        endstruct
    endscope
    public struct StructMaxLife
        implement Allocation
        implement List
        
    FolderMaxLife_StructBase Base = this
    FolderMaxLife_StructBase LinkToStruct_Base
    FolderMaxLife_StructBonus Bonus = this
    FolderMaxLife_StructBonus LinkToStruct_Bonus
    FolderMaxLife_StructRelative Relative = this
    FolderMaxLife_StructRelative LinkToStruct_Relative
        method SetEx takes real oldValue, real value returns nothing
            local real curLife = Unit(this).Life.Get()
            if (curLife == 0.) then
                return
            endif
            call Unit(this).Life.Set(curLife / oldValue * value)
        endmethod
        real value
        method Get takes nothing returns real
            return this.value
        endmethod
        method AddNative takes integer amount returns nothing
            local integer neededMaxPacketsAmount
            local integer packetAbil
            if (amount < 0) then
                set amount = -amount
                set neededMaxPacketsAmount = amount div thistype.DEC_MAX_PACKET
                set amount = amount - neededMaxPacketsAmount * thistype.DEC_MAX_PACKET
                loop
                    exitwhen (neededMaxPacketsAmount < 1)
                    call Unit(this).Abilities.AddBySelf(thistype.DEC_MAX_PACKET_RAW)
                    call Unit(this).Abilities.SetLevelBySelf(thistype.DEC_MAX_PACKET_RAW, 2)
                    call Unit(this).Abilities.RemoveBySelf(thistype.DEC_MAX_PACKET_RAW)
                    set neededMaxPacketsAmount = neededMaxPacketsAmount - 1
                endloop
                set packetAbil = thistype.DEC_RAWS[amount]
                call Unit(this).Abilities.AddBySelf(packetAbil)
                call Unit(this).Abilities.SetLevelBySelf(packetAbil, 2)
                call Unit(this).Abilities.RemoveBySelf(packetAbil)
            else
                set neededMaxPacketsAmount = amount div thistype.INC_MAX_PACKET
                set amount = amount - neededMaxPacketsAmount * thistype.INC_MAX_PACKET
                loop
                    exitwhen (neededMaxPacketsAmount < 1)
                    call Unit(this).Abilities.AddBySelf(thistype.INC_MAX_PACKET_RAW)
                    call Unit(this).Abilities.SetLevelBySelf(thistype.INC_MAX_PACKET_RAW, 2)
                    call Unit(this).Abilities.RemoveBySelf(thistype.INC_MAX_PACKET_RAW)
                    set neededMaxPacketsAmount = neededMaxPacketsAmount - 1
                endloop
                set packetAbil = thistype.INC_RAWS[amount]
                call Unit(this).Abilities.AddBySelf(packetAbil)
                call Unit(this).Abilities.SetLevelBySelf(packetAbil, 2)
                call Unit(this).Abilities.RemoveBySelf(packetAbil)
            endif
        endmethod
        method Set takes real value returns nothing
            local real oldValue = this.value
            if (oldValue == value) then
                return
            endif
            set this.value = value
            call this.AddNative(Real.ToInt(value - oldValue))
            static if thistype.SetEx.exists then
                if (oldValue != 0.) then
                    call this.SetEx(oldValue, value)
                endif
            endif
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.Base.Get() * this.Relative.Get() + this.Bonus.Get())
        endmethod
        method UpdateByNative takes nothing returns nothing
            set this.value = GetUnitState(Unit(this).self, UNIT_STATE_MAX_LIFE)
            call this.Update()
        endmethod
        eventMethod Event_TypeChange
            local UnitType sourceType = params.UnitType.GetSource()
            local UnitType targetType = params.UnitType.GetTrigger()
            local thistype this = params.Unit.GetTrigger()
            
            set this.value = this.Get() + targetType.Life.GetBJ() - sourceType.Life.GetBJ()
			call this.Base.Add(targetType.Life.Get() - sourceType.Life.Get())
			call Unit(this).Life.UpdateByNative()
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = Unit(this).Type.Get().Life.GetBJ()
            call this.Base.Event_Create()
            call this.Bonus.Event_Create()
            call this.Relative.Event_Create()
            call this.Update()
        endmethod
        static method Init takes nothing returns nothing
        	call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            call thistype(NULL).Base.Init()
            call thistype(NULL).Bonus.Init()
        endmethod
    endstruct
    public struct StructLife
        implement Allocation
        implement List
        
        static Unit DAMAGE_SOURCE = NULL
        static EventType DUMMY_EVENT_TYPE
        static constant real LIMIT_OF_DEATH = 0.405
        static constant real IMMORTAL = thistype.LIMIT_OF_DEATH + 1.
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        static method TriggerEvents takes Unit parent, real oldValue, real value returns nothing
            local EventResponse params = EventResponse.Create(parent.Id.Get())
            call params.Unit.SetTrigger(parent)
			local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = parent.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    local Event whichEvent = parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2)
                    if whichEvent.Limit.Is() then
                        local limitop limitOperator = whichEvent.Limit.GetOperator()
                        local integer limitValue = whichEvent.Limit.GetValue()
                        if (Math.Compare(value, limitOperator, limitValue) and not Math.Compare(oldValue, limitOperator, limitValue)) then
                            call whichEvent.Run(params)
                        endif
                    else
                        call whichEvent.Run(params)
                    endif
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            call params.Destroy()
        endmethod
        method TriggerBeforeDeathEvent takes nothing returns nothing
            local Unit killer = thistype.DAMAGE_SOURCE
            set thistype.DAMAGE_SOURCE = NULL
            call Unit(this).Death.Events.Before_Event_Life(killer)
        endmethod
        method Set takes real value returns nothing
            local real oldValue = this.Get()
            local boolean causesDeath = (not Unit(this).Classes.Contains(UnitClass.DEAD) and (value < thistype.LIMIT_OF_DEATH))
            set value = Math.Limit(value, 0., Unit(this).MaxLife.Get())
            set this.value = value
            if causesDeath then
                if Unit(this).Death.Protection.Try() then
                    set causesDeath = false
                    set value = thistype.IMMORTAL
                else
                    call this.TriggerBeforeDeathEvent()
                endif
            endif
            
            call SetWidgetLife(Unit(this).self, value)
            call thistype.TriggerEvents(this, oldValue, value)
        endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        method Event_Create takes nothing returns nothing
            local real value = Unit(this).MaxLife.Get()
            set this.value = value
            call SetWidgetLife(Unit(this).self, value)
        endmethod
        method UpdateByNative takes nothing returns nothing
            call this.Set(GetUnitState(Unit(this).self, UNIT_STATE_LIFE))
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DUMMY_EVENT_TYPE = EventType.Create()
        endmethod
    endstruct
    scope FolderLifeRegeneration
    public struct StructBase
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).LifeRegeneration.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_TypeChange
                local UnitType sourceType = params.UnitType.GetSource()
                local UnitType targetType = params.UnitType.GetTrigger()
                local thistype this = params.Unit.GetTrigger()
                call this.Add(targetType.LifeRegeneration.Get() - sourceType.LifeRegeneration.Get())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = Unit(this).Type.Get().LifeRegeneration.Get()
            endmethod
            static method Init takes nothing returns nothing
                call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            endmethod
        endstruct
    public struct StructBonus
        implement Allocation
        implement List
        
            static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).LifeRegeneration.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    public struct StructDisablement
        implement Allocation
        implement List
        
        	static UnitState STATE
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
            eventMethod Event_BuffLose
                local Unit parent = params.Unit.GetTrigger()
                call thistype(parent).Set(false)
                if (parent.LifeRegeneration.Get() > 0.) then
                    call parent.LifeRegeneration.Activate()
                endif
            endmethod
            eventMethod Event_BuffGain
                local Unit parent = params.Unit.GetTrigger()
                call thistype(parent).Set(true)
                call parent.LifeRegeneration.Deactivate()
            endmethod
            method Subtract takes nothing returns nothing
                call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
            endmethod
            method Add takes nothing returns nothing
                call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
            endmethod
	        method Change takes boolean val returns nothing
	            if val then
	                call this.Add()
	            else
	                call this.Subtract()
	            endif
	        endmethod
	
	        eventMethod Event_State
	            call thistype(params.Unit.GetTrigger()).Change(not params.Bool.GetVal())
	        endmethod
            eventMethod Event_Death
                call thistype(params.Unit.GetTrigger()).Add()
            endmethod
            eventMethod Event_Revive
                call thistype(params.Unit.GetTrigger()).Subtract()
            endmethod
            method Event_Create takes nothing returns nothing
                call this.Set(false)
            endmethod
            initMethod Buff_Init of Header_Buffs
                call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
                call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            endmethod
            static method Init takes nothing returns nothing
            	set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
                call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Death).AddToStatics()
                call Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Revive).AddToStatics()
            endmethod
        endstruct
    public struct StructRelative
        implement Allocation
        implement List
        
        	static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).LifeRegeneration.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 1.
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    endscope
    public struct StructLifeRegeneration
        implement Allocation
        implement List
        
        static constant real INTERVAL = 1.5
        static Timer INTERVAL_TIMER
    FolderLifeRegeneration_StructBase Base = this
    FolderLifeRegeneration_StructBase LinkToStruct_Base
    FolderLifeRegeneration_StructBonus Bonus = this
    FolderLifeRegeneration_StructBonus LinkToStruct_Bonus
    FolderLifeRegeneration_StructDisablement Disablement = this
    FolderLifeRegeneration_StructDisablement LinkToStruct_Disablement
    FolderLifeRegeneration_StructRelative Relative = this
    FolderLifeRegeneration_StructRelative LinkToStruct_Relative
    static thistype array ACTIVE_LIST_ALL
    static integer ACTIVE_LIST_ALL_COUNT = ARRAY_EMPTY
    integer ACTIVE_LIST_index
    static method ACTIVE_LIST_Count takes nothing returns integer
        return thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static method ACTIVE_LIST_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Get takes integer index returns thistype
        return thistype.ACTIVE_LIST_ALL[index]
    endmethod
    static method ACTIVE_LIST_GetIndex takes thistype this returns integer
        return this.ACTIVE_LIST_index
    endmethod
    static method ACTIVE_LIST_Contains takes thistype this returns boolean
        return (thistype.ACTIVE_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ACTIVE_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ACTIVE_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ACTIVE_LIST_RandomAll takes nothing returns thistype
        return thistype.ACTIVE_LIST_Random(ARRAY_MIN, thistype.ACTIVE_LIST_ALL_COUNT)
    endmethod
    static method ACTIVE_LIST_Remove takes thistype this returns boolean
        if not thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT].ACTIVE_LIST_index = this.ACTIVE_LIST_index
        set thistype.ACTIVE_LIST_ALL[this.ACTIVE_LIST_index - 1] = thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT]
        set this.ACTIVE_LIST_index = ARRAY_MIN
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT - 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Add takes thistype this returns boolean
        if thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT + 1
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT] = this
        set this.ACTIVE_LIST_index = thistype.ACTIVE_LIST_ALL_COUNT + 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static thistype array FOR_EACH_LIST_ALL
    static integer FOR_EACH_LIST_ALL_COUNT = ARRAY_EMPTY
    static method FOR_EACH_LIST_FetchFirst takes nothing returns thistype
        local thistype result
        if (thistype.FOR_EACH_LIST_ALL_COUNT < ARRAY_MIN) then
            return NULL
        endif
        set result = thistype.FOR_EACH_LIST_ALL[ARRAY_MIN]
        set thistype.FOR_EACH_LIST_ALL[ARRAY_MIN] = thistype.FOR_EACH_LIST_ALL[thistype.FOR_EACH_LIST_ALL_COUNT]
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.FOR_EACH_LIST_ALL_COUNT - 1
        return result
    endmethod
    static method FOR_EACH_LIST_Set takes nothing returns nothing
        local integer iteration = thistype.ACTIVE_LIST_ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.FOR_EACH_LIST_ALL[iteration] = thistype.ACTIVE_LIST_ALL[iteration]
            set iteration = iteration - 1
        endloop
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method Disable takes nothing returns nothing
            call this.Disablement.Add()
        endmethod
        method Enable takes nothing returns nothing
            call this.Disablement.Subtract()
        endmethod
        timerMethod Interval
            call thistype.FOR_EACH_LIST_Set()
            loop
                local thistype this = thistype.FOR_EACH_LIST_FetchFirst()
                exitwhen (this == NULL)
                call Unit(this).Life.Add(this.Get() * thistype.INTERVAL)
            endloop
        endmethod
        method Activate takes nothing returns nothing
            if thistype.ACTIVE_LIST_Add(this) then
                call thistype.INTERVAL_TIMER.Start(thistype.INTERVAL, true, function thistype.Interval)
            endif
        endmethod
        method Deactivate takes nothing returns nothing
            if thistype.ACTIVE_LIST_Remove(this) then
                call thistype.INTERVAL_TIMER.Pause()
            endif
        endmethod
        eventMethod Event_Destroy
            local thistype this = params.Unit.GetTrigger()
            call this.Deactivate()
        endmethod
        eventMethod Event_Death
            call thistype(params.Unit.GetTrigger()).Disable()
        endmethod
        eventMethod Event_Revive
            call thistype(params.Unit.GetTrigger()).Enable()
        endmethod
        method Set takes real value returns nothing
            local real oldValue = this.value
            set this.value = value
            if ((oldValue > 0.) == (value > 0.)) then
                return
            endif
            if Unit(this).Buffs.Contains(thistype(NULL).Disablement.DUMMY_BUFF) then
                return
            endif
            if (value > 0.) then
                call this.Activate()
            else
                call this.Deactivate()
            endif
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.Base.Get() * this.Relative.Get() + this.Bonus.Get())
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0.
            call this.Base.Event_Create()
            call this.Bonus.Event_Create()
            call this.Disablement.Event_Create()
            call this.Relative.Event_Create()
            call this.Update()
        endmethod
        static method Init takes nothing returns nothing
            set thistype.INTERVAL_TIMER = Timer.Create()
            call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Death).AddToStatics()
            call Event.Create(UNIT.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy).AddToStatics()
            call Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Revive).AddToStatics()
            call thistype(NULL).Base.Init()
            call thistype(NULL).Bonus.Init()
            call thistype(NULL).Disablement.Init()
            call thistype(NULL).Relative.Init()
        endmethod
    endstruct
    scope FolderMaxMana
    public struct StructBase
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).MaxMana.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = Unit(this).Type.Get().Mana.Get()
            endmethod
            static method Init takes nothing returns nothing
            endmethod
        endstruct
    public struct StructBonus
        implement Allocation
        implement List
        
            static UnitState STATE
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).MaxMana.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    public struct StructRelative
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).MaxMana.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 1.
            endmethod
        endstruct
    endscope
    public struct StructMaxMana
        implement Allocation
        implement List
        
    FolderMaxMana_StructBase Base = this
    FolderMaxMana_StructBase LinkToStruct_Base
    FolderMaxMana_StructBonus Bonus = this
    FolderMaxMana_StructBonus LinkToStruct_Bonus
    FolderMaxMana_StructRelative Relative = this
    FolderMaxMana_StructRelative LinkToStruct_Relative
        method SetEx takes real oldValue, real value returns nothing
            if (Unit(this).Mana.Get() == 0.) then
                return
            endif
            call Unit(this).Mana.Set(Unit(this).Mana.Get() / oldValue * value)
        endmethod
        real value
        method Get takes nothing returns real
            return this.value
        endmethod
        method AddNative takes integer amount returns nothing
            local integer neededMaxPacketsAmount
            local integer packetAbil
            if (amount < 0) then
                set amount = -amount
                set neededMaxPacketsAmount = amount div thistype.DEC_MAX_PACKET
                set amount = amount - neededMaxPacketsAmount * thistype.DEC_MAX_PACKET
                loop
                    exitwhen (neededMaxPacketsAmount < 1)
                    call Unit(this).Abilities.AddBySelf(thistype.DEC_MAX_PACKET_RAW)
                    call Unit(this).Abilities.SetLevelBySelf(thistype.DEC_MAX_PACKET_RAW, 2)
                    call Unit(this).Abilities.RemoveBySelf(thistype.DEC_MAX_PACKET_RAW)
                    set neededMaxPacketsAmount = neededMaxPacketsAmount - 1
                endloop
                set packetAbil = thistype.DEC_RAWS[amount]
                call Unit(this).Abilities.AddBySelf(packetAbil)
                call Unit(this).Abilities.SetLevelBySelf(packetAbil, 2)
                call Unit(this).Abilities.RemoveBySelf(packetAbil)
            else
                set neededMaxPacketsAmount = amount div thistype.INC_MAX_PACKET
                set amount = amount - neededMaxPacketsAmount * thistype.INC_MAX_PACKET
                loop
                    exitwhen (neededMaxPacketsAmount < 1)
                    call Unit(this).Abilities.AddBySelf(thistype.INC_MAX_PACKET_RAW)
                    call Unit(this).Abilities.SetLevelBySelf(thistype.INC_MAX_PACKET_RAW, 2)
                    call Unit(this).Abilities.RemoveBySelf(thistype.INC_MAX_PACKET_RAW)
                    set neededMaxPacketsAmount = neededMaxPacketsAmount - 1
                endloop
                set packetAbil = thistype.INC_RAWS[amount]
                call Unit(this).Abilities.AddBySelf(packetAbil)
                call Unit(this).Abilities.SetLevelBySelf(packetAbil, 2)
                call Unit(this).Abilities.RemoveBySelf(packetAbil)
            endif
        endmethod
        method Set takes real value returns nothing
            local real oldValue = this.value
            if (oldValue == value) then
                return
            endif
            set this.value = value
            call this.AddNative(Real.ToInt(value - oldValue))
            static if thistype.SetEx.exists then
                if (oldValue != 0.) then
                    call this.SetEx(oldValue, value)
                endif
            endif
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.Base.Get() * this.Relative.Get() + this.Bonus.Get())
        endmethod
        eventMethod Event_TypeChange
            local UnitType sourceType = params.UnitType.GetSource()
            local UnitType targetType = params.UnitType.GetTrigger()
            local thistype this = params.Unit.GetTrigger()
            
            set this.value = this.Get() + targetType.Mana.GetBJ() - sourceType.Mana.GetBJ()
			call this.Base.Add(targetType.Mana.Get() - sourceType.Mana.Get())
			call Unit(this).Mana.UpdateByNative()
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = Unit(this).Type.Get().Mana.GetBJ()
            call this.Base.Event_Create()
            call this.Bonus.Event_Create()
            call this.Relative.Event_Create()
            call this.Update()
        endmethod
        static method Init takes nothing returns nothing
        	call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            call thistype(NULL).Base.Init()
            call thistype(NULL).Bonus.Init()
        endmethod
    endstruct
    public struct StructMana
        implement Allocation
        implement List
        
        static EventType DUMMY_EVENT_TYPE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        static method TriggerEvents takes Unit parent, real oldValue, real value returns nothing
            local EventResponse params = EventResponse.Create(parent.Id.Get())
            call params.Unit.SetTrigger(parent)
			local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = parent.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    local Event whichEvent = parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2)
                    local limitop limitOperator = whichEvent.Limit.GetOperator()
                    local integer limitValue = whichEvent.Limit.GetValue()
                    if (Math.Compare(value, limitOperator, limitValue) and not Math.Compare(oldValue, limitOperator, limitValue)) then
                        call whichEvent.Run(params)
                    endif
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            call params.Destroy()
        endmethod
        method Set takes real value returns nothing
            local real oldValue = this.Get()
            set value = Math.Limit(value, 0., Unit(this).MaxMana.Get())
            set this.value = value
            call SetUnitState(Unit(this).self, UNIT_STATE_MANA, value)
            call thistype.TriggerEvents(this, oldValue, value)
        endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        method Event_Create takes nothing returns nothing
            local real value = Unit(this).MaxMana.Get()
            set this.value = value
            call SetUnitState(Unit(this).self, UNIT_STATE_MANA, value)
        endmethod
        method SubtractNoNative takes real value returns nothing
            local real oldValue = this.Get()
            set value = Math.Limit(oldValue - value, 0., Unit(this).MaxMana.Get())
            set this.value = value
            call thistype.TriggerEvents(this, oldValue, value)
        endmethod
        method UpdateByNative takes nothing returns nothing
            call this.Set(GetUnitState(Unit(this).self, UNIT_STATE_MANA))
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DUMMY_EVENT_TYPE = EventType.Create()
        endmethod
    endstruct
    scope FolderManaRegeneration
    public struct StructBase
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).ManaRegeneration.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_TypeChange
                local UnitType sourceType = params.UnitType.GetSource()
                local UnitType targetType = params.UnitType.GetTrigger()
                local thistype this = params.Unit.GetTrigger()
                call this.Add(targetType.ManaRegeneration.Get() - sourceType.ManaRegeneration.Get())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = Unit(this).Type.Get().ManaRegeneration.Get()
            endmethod
            static method Init takes nothing returns nothing
                call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            endmethod
        endstruct
    public struct StructBonus
        implement Allocation
        implement List
        
            static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).ManaRegeneration.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    public struct StructDisablement
        implement Allocation
        implement List
        
        	static UnitState STATE
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
            eventMethod Event_BuffLose
                local Unit parent = params.Unit.GetTrigger()
                call thistype(parent).Set(false)
                if (parent.ManaRegeneration.Get() > 0.) then
                    call parent.ManaRegeneration.Activate()
                endif
            endmethod
            eventMethod Event_BuffGain
                local Unit parent = params.Unit.GetTrigger()
                call thistype(parent).Set(true)
                call parent.ManaRegeneration.Deactivate()
            endmethod
            method Subtract takes nothing returns nothing
                call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
            endmethod
            method Add takes nothing returns nothing
                call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
            endmethod
	        method Change takes boolean val returns nothing
	            if val then
	                call this.Add()
	            else
	                call this.Subtract()
	            endif
	        endmethod
	
	        eventMethod Event_State
	            call thistype(params.Unit.GetTrigger()).Change(not params.Bool.GetVal())
	        endmethod
            eventMethod Event_Death
                call thistype(params.Unit.GetTrigger()).Add()
            endmethod
            eventMethod Event_Revive
                call thistype(params.Unit.GetTrigger()).Subtract()
            endmethod
            method Event_Create takes nothing returns nothing
                call this.Set(false)
            endmethod
            initMethod Buff_Init of Header_Buffs
                call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
                call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            endmethod
            static method Init takes nothing returns nothing
            	set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
                call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Death).AddToStatics()
                call Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Revive).AddToStatics()
            endmethod
        endstruct
    public struct StructRelative
        implement Allocation
        implement List
        
        	static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).ManaRegeneration.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 1.
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    endscope
    public struct StructManaRegeneration
        implement Allocation
        implement List
        
        static constant real INTERVAL = 1.5
        static Timer INTERVAL_TIMER
    FolderManaRegeneration_StructBase Base = this
    FolderManaRegeneration_StructBase LinkToStruct_Base
    FolderManaRegeneration_StructBonus Bonus = this
    FolderManaRegeneration_StructBonus LinkToStruct_Bonus
    FolderManaRegeneration_StructDisablement Disablement = this
    FolderManaRegeneration_StructDisablement LinkToStruct_Disablement
    FolderManaRegeneration_StructRelative Relative = this
    FolderManaRegeneration_StructRelative LinkToStruct_Relative
    static thistype array ACTIVE_LIST_ALL
    static integer ACTIVE_LIST_ALL_COUNT = ARRAY_EMPTY
    integer ACTIVE_LIST_index
    static method ACTIVE_LIST_Count takes nothing returns integer
        return thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static method ACTIVE_LIST_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Get takes integer index returns thistype
        return thistype.ACTIVE_LIST_ALL[index]
    endmethod
    static method ACTIVE_LIST_GetIndex takes thistype this returns integer
        return this.ACTIVE_LIST_index
    endmethod
    static method ACTIVE_LIST_Contains takes thistype this returns boolean
        return (thistype.ACTIVE_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ACTIVE_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ACTIVE_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ACTIVE_LIST_RandomAll takes nothing returns thistype
        return thistype.ACTIVE_LIST_Random(ARRAY_MIN, thistype.ACTIVE_LIST_ALL_COUNT)
    endmethod
    static method ACTIVE_LIST_Remove takes thistype this returns boolean
        if not thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT].ACTIVE_LIST_index = this.ACTIVE_LIST_index
        set thistype.ACTIVE_LIST_ALL[this.ACTIVE_LIST_index - 1] = thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT]
        set this.ACTIVE_LIST_index = ARRAY_MIN
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT - 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Add takes thistype this returns boolean
        if thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT + 1
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT] = this
        set this.ACTIVE_LIST_index = thistype.ACTIVE_LIST_ALL_COUNT + 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static thistype array FOR_EACH_LIST_ALL
    static integer FOR_EACH_LIST_ALL_COUNT = ARRAY_EMPTY
    static method FOR_EACH_LIST_FetchFirst takes nothing returns thistype
        local thistype result
        if (thistype.FOR_EACH_LIST_ALL_COUNT < ARRAY_MIN) then
            return NULL
        endif
        set result = thistype.FOR_EACH_LIST_ALL[ARRAY_MIN]
        set thistype.FOR_EACH_LIST_ALL[ARRAY_MIN] = thistype.FOR_EACH_LIST_ALL[thistype.FOR_EACH_LIST_ALL_COUNT]
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.FOR_EACH_LIST_ALL_COUNT - 1
        return result
    endmethod
    static method FOR_EACH_LIST_Set takes nothing returns nothing
        local integer iteration = thistype.ACTIVE_LIST_ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.FOR_EACH_LIST_ALL[iteration] = thistype.ACTIVE_LIST_ALL[iteration]
            set iteration = iteration - 1
        endloop
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method Disable takes nothing returns nothing
            call this.Disablement.Add()
        endmethod
        method Enable takes nothing returns nothing
            call this.Disablement.Subtract()
        endmethod
        timerMethod Interval
            call thistype.FOR_EACH_LIST_Set()
            loop
                local thistype this = thistype.FOR_EACH_LIST_FetchFirst()
                exitwhen (this == NULL)
                call Unit(this).Mana.Add(this.Get() * thistype.INTERVAL)
            endloop
        endmethod
        method Activate takes nothing returns nothing
            if thistype.ACTIVE_LIST_Add(this) then
                call thistype.INTERVAL_TIMER.Start(thistype.INTERVAL, true, function thistype.Interval)
            endif
        endmethod
        method Deactivate takes nothing returns nothing
            if thistype.ACTIVE_LIST_Remove(this) then
                call thistype.INTERVAL_TIMER.Pause()
            endif
        endmethod
        eventMethod Event_Destroy
            local thistype this = params.Unit.GetTrigger()
            call this.Deactivate()
        endmethod
        eventMethod Event_Death
            call thistype(params.Unit.GetTrigger()).Disable()
        endmethod
        eventMethod Event_Revive
            call thistype(params.Unit.GetTrigger()).Enable()
        endmethod
        method Set takes real value returns nothing
            local real oldValue = this.value
            set this.value = value
            if ((oldValue > 0.) == (value > 0.)) then
                return
            endif
            if Unit(this).Buffs.Contains(thistype(NULL).Disablement.DUMMY_BUFF) then
                return
            endif
            if (value > 0.) then
                call this.Activate()
            else
                call this.Deactivate()
            endif
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.Base.Get() * this.Relative.Get() + this.Bonus.Get())
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0.
            call this.Base.Event_Create()
            call this.Bonus.Event_Create()
            call this.Disablement.Event_Create()
            call this.Relative.Event_Create()
            call this.Update()
        endmethod
        static method Init takes nothing returns nothing
            set thistype.INTERVAL_TIMER = Timer.Create()
            call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Death).AddToStatics()
            call Event.Create(UNIT.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy).AddToStatics()
            call Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Revive).AddToStatics()
            call thistype(NULL).Base.Init()
            call thistype(NULL).Bonus.Init()
            call thistype(NULL).Disablement.Init()
            call thistype(NULL).Relative.Init()
        endmethod
    endstruct
    scope FolderMovement
    scope FolderEvents
    public struct StructInterval
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
                static Event MOVE_ENDING_EVENT
                static Event MOVE_START_EVENT
                real interval
                Timer intervalTimer
                Unit parent
                Event whichEvent
                real x
                real y
                eventMethod Event_Move_Ending
                    local Unit parent = params.Unit.GetTrigger()
                    local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                    loop
                        local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                        call this.intervalTimer.Pause()
                        set iteration = iteration - 1
                        exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    endloop
                endmethod
                timerMethod Interval
                    local thistype this = Timer.GetExpired().GetData()
                    local Unit parent = this.parent
                    local real parentX = parent.Position.X.Get()
                    local real parentY = parent.Position.Y.Get()
                    local EventResponse params = EventResponse.Create(parent.Id.Get())
                    call params.Real.SetDistanceSquare(Math.DistanceSquareByDeltas(parentX - this.x, parentY - this.y))
                    call params.Unit.SetTrigger(parent)
                    set this.x = parentX
                    set this.y = parentY
                    call this.whichEvent.Run(params)
                    call params.Destroy()
                endmethod
                eventMethod Event_Move_Start
                    local Unit parent = params.Unit.GetTrigger()
                    local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                    loop
                        local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                        set this.x = parent.Position.X.Get()
                        set this.y = parent.Position.Y.Get()
                        call this.intervalTimer.Start(this.interval, true, function thistype.Interval)
                        set iteration = iteration - 1
                        exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    endloop
                endmethod
                method Remove takes Event whichEvent returns nothing
                    local Unit parent = this
                    set this = whichEvent.Data.Integer.Get(KEY_ARRAY_DETAIL + parent)
                    if (this == NULL) then
                        call DebugEx("not listed " + whichEvent.GetName() + ";" + parent.GetName() + ";" + I2S(parent))
                        return
                    endif
                    local Timer intervalTimer = this.intervalTimer
                    call this.deallocate()
                    call intervalTimer.Destroy()
                    call whichEvent.Data.Integer.Remove(KEY_ARRAY_DETAIL + parent)
                    if parent.Data.Integer.Table.Remove(KEY_ARRAY, this) then
                        call parent.Movement.Events.Unreg(MOVE_ENDING_EVENT)
                        call parent.Movement.Events.Unreg(MOVE_START_EVENT)
                    endif
                endmethod
                method Add takes Event whichEvent, real interval returns nothing
                    local Unit parent = this
					set this = whichEvent.Data.Integer.Get(KEY_ARRAY_DETAIL + parent)
					if (this != NULL) then
						call DebugEx("already listed " + whichEvent.GetName() + ";" + parent.GetName())
						return
					endif
                    set this = thistype.allocate()
					local Timer intervalTimer = Timer.Create()
                    set this.interval = interval
                    set this.intervalTimer = intervalTimer
                    set this.parent = parent
                    set this.whichEvent = whichEvent
                    call intervalTimer.SetData(this)
                    if parent.Data.Integer.Table.Add(KEY_ARRAY, this) then
                        call parent.Movement.Events.Reg(MOVE_ENDING_EVENT)
                        call parent.Movement.Events.Reg(MOVE_START_EVENT)
                    endif
                    call whichEvent.Data.Integer.Set(KEY_ARRAY_DETAIL + parent, this)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.MOVE_ENDING_EVENT = Event.Create(UNIT.Movement.Events.ENDING_EVENT_TYPE, EventPriority.EVENTS, function thistype.Event_Move_Ending)
                    set thistype.MOVE_START_EVENT = Event.Create(UNIT.Movement.Events.START_EVENT_TYPE, EventPriority.EVENTS, function thistype.Event_Move_Start)
                endmethod
            endstruct
    public struct StructEnterRegion
        implement Allocation
        implement List
        
            	static Event REGION_DESTROY_EVENT
            	static Event ADD_RECT_EVENT
                static EventType DUMMY_EVENT_TYPE
                static Group ENUM_GROUP
				UnitList inGroup
                UnitList regGroup
                condTrigMethod TrigConditions
                    return true
                endmethod
				method TriggerEvents takes Unit parent
                    if not this.regGroup.Contains(parent) then
                        return
                    endif
					local Region whichRegion = this
                    local EventResponse params = EventResponse.Create(whichRegion.Id.Get())
					call params.Region.SetTrigger(whichRegion)
                    call params.Unit.SetTrigger(parent)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = whichRegion.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call whichRegion.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call params.Destroy()
				endmethod
				method Do takes Region whichRegion
					local Unit parent = this
					set this = whichRegion
					if this.inGroup.Contains(parent) then
						call DebugEx("Already contains unit " + parent.GetName())
						return
					endif
					call this.inGroup.Add(parent)
					call thistype(whichRegion).TriggerEvents(parent)
				endmethod
                trigMethod Trig
                    local Unit parent = UNIT.Event.Native.GetTrigger()
                    local Region whichRegion = REGION.Event.Native.GetTrigger()
                    call thistype(parent).Do(whichRegion)
                endmethod
				enumMethod AddRect_Enum
					local thistype this = params.GetData()
					local Unit parent = params.Unit.GetTrigger()
					if this.inGroup.Contains(parent) then
						return
					endif
					local Region whichRegion = this
					if not whichRegion.ContainsUnit(parent) then
						return
					endif
					call thistype(parent).Do(whichRegion)
				endmethod
				eventMethod Event_AddRect
					local Region whichRegion = params.Region.GetTrigger()
					local Rectangle whichRect = params.Rect.GetTrigger()
					local thistype this = whichRegion
					call thistype.ENUM_GROUP.EnumUnits.InRect.Do(whichRect, NULL)
					call thistype.ENUM_GROUP.DoEx(function thistype.AddRect_Enum, this)
				endmethod
                method Reg2 takes Region whichRegion returns nothing
                    local Unit parent = this
                    set this = whichRegion
                    call this.regGroup.Add(parent)
                endmethod
                method Unreg takes Region whichRegion returns nothing
                    local Unit parent = this
                    set this = whichRegion
                    call this.regGroup.Remove(parent)
                endmethod
				eventMethod Event_RegionDestroy
					local Region whichRegion = params.Region.GetTrigger()
					call whichRegion.Clear()
					call whichRegion.Event.Remove(REGION_DESTROY_EVENT)
					call whichRegion.Event.Remove(ADD_RECT_EVENT)
				endmethod
                static method InitRegion takes Region whichRegion returns nothing
                    local thistype this = whichRegion
                    set this.regGroup = UnitList.Create()
					call whichRegion.Event.Add(REGION_DESTROY_EVENT)
					call whichRegion.Event.Add(ADD_RECT_EVENT)
                    call Trigger.CreateFromCode(function thistype.Trig).RegisterEvent.EnterRegion(whichRegion, function thistype.TrigConditions)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                    set thistype.ENUM_GROUP = Group.Create()
					set thistype.ADD_RECT_EVENT = Event.Create(Region.ADD_RECT_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_AddRect)
					set thistype.REGION_DESTROY_EVENT = Event.Create(Region.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_RegionDestroy)
                endmethod
        	endstruct
    public struct StructRegion
        implement Allocation
        implement List
        
            	static Rectangle DUMMY_RECT
            	static Event REGION_DESTROY_EVENT
            	static Event ADD_RECT_EVENT
            	static Event REMOVE_RECT_EVENT
            	static Event PARENT_DESTROY_EVENT
                static Group ENUM_GROUP
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
                static EventType ENTER_EVENT_TYPE
                static EventType LEAVE_EVENT_TYPE
				UnitList inGroup
                UnitList regGroup
                condTrigMethod TrigConditions
                    return true
                endmethod
				method Enter_TriggerEvents takes Unit parent
                    if not this.regGroup.Contains(parent) then
                        
                    endif
					local Region whichRegion = this
                    local EventResponse params = EventResponse.Create(whichRegion.Id.Get())
					call params.Region.SetTrigger(whichRegion)
                    call params.Unit.SetTrigger(parent)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = whichRegion.Event.Count(thistype.ENTER_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call whichRegion.Event.Get(thistype.ENTER_EVENT_TYPE, priority, iteration2).Run(params)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call params.Destroy()
				endmethod
				method Enter takes Region whichRegion
					local Unit parent = this
					set this = whichRegion
					if this.inGroup.Contains(parent) then
						call DebugEx("Already contains unit " + parent.GetName())
						return
					endif
					call this.inGroup.Add(parent)
					if parent.Data.Integer.Table.Add(KEY_ARRAY, this) then
						call parent.Event.Add(PARENT_DESTROY_EVENT)
					endif
					call thistype(whichRegion).Enter_TriggerEvents(parent)
				endmethod
                trigMethod EnterTrig
                    local Unit parent = UNIT.Event.Native.GetTrigger()
                    local Region whichRegion = REGION.Event.Native.GetTrigger()
					if (parent == STRUCT_INVALID) then
						return
					endif
                    call thistype(parent).Enter(whichRegion)
                endmethod
				method Leave_TriggerEvents takes Unit parent
                    if not this.regGroup.Contains(parent) then
                        
                    endif
					local Region whichRegion = this
                    local EventResponse params = EventResponse.Create(whichRegion.Id.Get())
					call params.Region.SetTrigger(whichRegion)
                    call params.Unit.SetTrigger(parent)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = whichRegion.Event.Count(thistype.LEAVE_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call whichRegion.Event.Get(thistype.LEAVE_EVENT_TYPE, priority, iteration2).Run(params)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call params.Destroy()
				endmethod
				method Leave takes Region whichRegion
					local Unit parent = this
					set this = whichRegion
					if not this.inGroup.Contains(parent) then
						call DebugEx("Does not contain unit " + parent.GetName())
						return
					endif
					call this.inGroup.Remove(parent)
					if parent.Data.Integer.Table.Remove(KEY_ARRAY, this) then
						call parent.Event.Remove(PARENT_DESTROY_EVENT)
					endif
					call thistype(whichRegion).Leave_TriggerEvents(parent)
				endmethod
                trigMethod LeaveTrig
                    local Unit parent = UNIT.Event.Native.GetTrigger()
                    local Region whichRegion = REGION.Event.Native.GetTrigger()
					if (parent == STRUCT_INVALID) then
						return
					endif
                    call thistype(parent).Leave(whichRegion)
                endmethod
				enumMethod AddRect_Enum
					local thistype this = params.GetData()
					local Unit parent = params.Unit.GetTrigger()
					if this.inGroup.Contains(parent) then
						return
					endif
					local Region whichRegion = this
					if not whichRegion.ContainsUnit(parent) then
						return
					endif
					call thistype(parent).Enter(whichRegion)
				endmethod
				eventMethod Event_AddRect
					local Region whichRegion = params.Region.GetTrigger()
					local Rectangle whichRect = params.Rect.GetTrigger()
					local thistype this = whichRegion
					call thistype.DUMMY_RECT.Set(whichRect.minX - 32, whichRect.minY - 32, whichRect.maxX + 32, whichRect.maxY + 32)
					call thistype.ENUM_GROUP.EnumUnits.InRect.Do(thistype.DUMMY_RECT, NULL)
					call thistype.ENUM_GROUP.DoEx(function thistype.AddRect_Enum, this)
				endmethod
				enumMethod RemoveRect_Enum
					local thistype this = params.GetData()
					local Unit parent = params.Unit.GetTrigger()
					if not this.inGroup.Contains(parent) then
						return
					endif
					local Region whichRegion = this
					if whichRegion.ContainsUnit(parent) then
						return
					endif
					call thistype(parent).Leave(whichRegion)
				endmethod
				eventMethod Event_RemoveRect
					local Region whichRegion = params.Region.GetTrigger()
					local Rectangle whichRect = params.Rect.GetTrigger()
					local thistype this = whichRegion
					call thistype.DUMMY_RECT.Set(whichRect.minX - 32, whichRect.minY - 32, whichRect.maxX + 32, whichRect.maxY + 32)
					call thistype.ENUM_GROUP.EnumUnits.InRect.Do(thistype.DUMMY_RECT, NULL)
					call thistype.ENUM_GROUP.DoEx(function thistype.RemoveRect_Enum, this)
				endmethod
                method Reg takes Region whichRegion returns nothing
                    local Unit parent = this
                    set this = whichRegion
                    call this.regGroup.Add(parent)
                endmethod
                method Unreg takes Region whichRegion returns nothing
                    local Unit parent = this
                    set this = whichRegion
                    call this.regGroup.Remove(parent)
                endmethod
				eventMethod Event_ParentDestroy
					local Unit parent = params.Unit.GetTrigger()
					local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
					loop
						local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
						
						call thistype(parent).Leave(this)
						set iteration = iteration - 1
						exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
					endloop
				endmethod
				eventMethod Event_RegionDestroy
					local Region whichRegion = params.Region.GetTrigger()
					local thistype this = whichRegion
					call whichRegion.Clear()
					call whichRegion.Event.Remove(REGION_DESTROY_EVENT)
					call whichRegion.Event.Remove(ADD_RECT_EVENT)
					call whichRegion.Event.Remove(REMOVE_RECT_EVENT)
					call this.inGroup.Destroy()
					call this.regGroup.Destroy()
				endmethod
                static method InitRegion takes Region whichRegion returns nothing
                    local thistype this = whichRegion
					set this.inGroup = UnitList.Create()
                    set this.regGroup = UnitList.Create()
					call whichRegion.Event.Add(REGION_DESTROY_EVENT)
					call whichRegion.Event.Add(ADD_RECT_EVENT)
					call whichRegion.Event.Add(REMOVE_RECT_EVENT)
                    call Trigger.CreateFromCode(function thistype.EnterTrig).RegisterEvent.EnterRegion(whichRegion, function thistype.TrigConditions)
                    call Trigger.CreateFromCode(function thistype.LeaveTrig).RegisterEvent.LeaveRegion(whichRegion, function thistype.TrigConditions)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.ENTER_EVENT_TYPE = EventType.Create()
                    set thistype.LEAVE_EVENT_TYPE = EventType.Create()
                    set thistype.DUMMY_RECT = Rectangle.Create(0, 0, 0, 0)
                    set thistype.ENUM_GROUP = Group.Create()
					set thistype.ADD_RECT_EVENT = Event.Create(Region.ADD_RECT_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_AddRect)
					set thistype.REMOVE_RECT_EVENT = Event.Create(Region.REMOVE_RECT_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_RemoveRect)
					set thistype.REGION_DESTROY_EVENT = Event.Create(Region.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_RegionDestroy)
					set thistype.PARENT_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_ParentDestroy)
                endmethod
            endstruct
    public struct StructLeaveRegion
        implement Allocation
        implement List
        
            	static Event REGION_DESTROY_EVENT
            	static Event REMOVE_RECT_EVENT
                static EventType DUMMY_EVENT_TYPE
                static Group ENUM_GROUP
				UnitList inGroup
                UnitList regGroup
                condTrigMethod TrigConditions
                    return true
                endmethod
				method TriggerEvents takes Unit parent
                    if not this.regGroup.Contains(parent) then
                        return
                    endif
					local Region whichRegion = this
                    local EventResponse params = EventResponse.Create(whichRegion.Id.Get())
					call params.Region.SetTrigger(whichRegion)
                    call params.Unit.SetTrigger(parent)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = whichRegion.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call whichRegion.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call params.Destroy()
				endmethod
				method Do takes Region whichRegion
					local Unit parent = this
					set this = whichRegion
					if not this.inGroup.Contains(parent) then
						call DebugEx("Does not contain unit " + parent.GetName())
						return
					endif
					call this.inGroup.Remove(parent)
					call thistype(whichRegion).TriggerEvents(parent)
				endmethod
                trigMethod Trig
                    local Unit parent = UNIT.Event.Native.GetTrigger()
                    local Region whichRegion = REGION.Event.Native.GetTrigger()
                    call thistype(parent).Do(whichRegion)
                endmethod
				enumMethod RemoveRect_Enum
					local thistype this = params.GetData()
					local Unit parent = params.Unit.GetTrigger()
					if not this.inGroup.Contains(parent) then
						return
					endif
					local Region whichRegion = this
					if whichRegion.ContainsUnit(parent) then
						return
					endif
					call thistype(parent).Do(whichRegion)
				endmethod
				eventMethod Event_RemoveRect
					local Region whichRegion = params.Region.GetTrigger()
					local Rectangle whichRect = params.Rect.GetTrigger()
					local thistype this = whichRegion
					call thistype.ENUM_GROUP.EnumUnits.InRect.Do(whichRect, NULL)
					call thistype.ENUM_GROUP.DoEx(function thistype.RemoveRect_Enum, this)
				endmethod
                method Reg2 takes Region whichRegion returns nothing
                    local Unit parent = this
                    set this = whichRegion
                    call this.regGroup.Add(parent)
                endmethod
                method Unreg takes Region whichRegion returns nothing
                    local Unit parent = this
                    set this = whichRegion
                    call this.regGroup.Remove(parent)
                endmethod
				eventMethod Event_RegionDestroy
					local Region whichRegion = params.Region.GetTrigger()
					call whichRegion.Clear()
					call whichRegion.Event.Remove(REGION_DESTROY_EVENT)
					call whichRegion.Event.Remove(REMOVE_RECT_EVENT)
				endmethod
                static method InitRegion takes Region whichRegion returns nothing
                    local thistype this = whichRegion
                    set this.regGroup = UnitList.Create()
					call whichRegion.Event.Add(REGION_DESTROY_EVENT)
					call whichRegion.Event.Add(REMOVE_RECT_EVENT)
                    call Trigger.CreateFromCode(function thistype.Trig).RegisterEvent.LeaveRegion(whichRegion, function thistype.TrigConditions)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                    set thistype.ENUM_GROUP = Group.Create()
					set thistype.REMOVE_RECT_EVENT = Event.Create(Region.REMOVE_RECT_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_RemoveRect)
					set thistype.REGION_DESTROY_EVENT = Event.Create(Region.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_RegionDestroy)
                endmethod
            endstruct
        endscope
    public struct StructEvents
        implement Allocation
        implement List
        
            static Trigger DUMMY_TRIGGER
            static EventType ENDING_EVENT_TYPE
            static UnitList ENUM_GROUP
            static UnitList EVENT_GROUP
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
            static UnitList MOVING_GROUP
            static EventType START_EVENT_TYPE
            static constant real THRESHOLD = 0.1
    static constant real UPDATE_TIME = FRAME_UPDATE_TIME * 16
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = 16
            static Timer UPDATE_TIMER
            static constant real THRESHOLD_SQUARE = (thistype.THRESHOLD * thistype.THRESHOLD)
            real x
            real y
    FolderEvents_StructInterval Interval = this
    FolderEvents_StructInterval LinkToStruct_Interval
    FolderEvents_StructRegion Region = this
    FolderEvents_StructRegion LinkToStruct_Region
            method GetOldX takes nothing returns real
                return this.x
            endmethod
            method GetOldY takes nothing returns real
                return this.y
            endmethod
            method Ending_TriggerEvents takes real distanceSquare returns nothing                
                local Unit parent = this
                local EventResponse params = EventResponse.Create(parent.Id.Get())
                call params.Real.SetDistanceSquare(distanceSquare)
                call params.Unit.SetTrigger(parent)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = parent.Event.Count(thistype.ENDING_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call parent.Event.Get(thistype.ENDING_EVENT_TYPE, priority, iteration2).Run(params)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call params.Destroy()
            endmethod
            method Start_TriggerEvents takes real distanceSquare returns nothing                
                local Unit parent = this
                local EventResponse params = EventResponse.Create(parent.Id.Get())
                call params.Real.SetDistanceSquare(distanceSquare)
                call params.Unit.SetTrigger(parent)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = parent.Event.Count(thistype.START_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call parent.Event.Get(thistype.START_EVENT_TYPE, priority, iteration2).Run(params)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call params.Destroy()
            endmethod
            timerMethod Trig
                loop
                    local Unit parent = thistype.EVENT_GROUP.FetchFirst()
                    exitwhen (parent == NULL)
                    local thistype this = parent
                    local real x = parent.Position.X.Get()
                    local real y = parent.Position.Y.Get()
                    local real distanceSquare = Math.DistanceSquareByDeltas(x - this.x, y - this.y)
                    call thistype.ENUM_GROUP.Add(parent)
                    if thistype.MOVING_GROUP.Contains(parent) then
                        if (distanceSquare < thistype.THRESHOLD_SQUARE) then
                            call thistype.MOVING_GROUP.Remove(parent)
                            call this.Ending_TriggerEvents(distanceSquare)
                        
                            
                        endif
                        set this.x = x
                        set this.y = y
                    else
                        if (distanceSquare > thistype.THRESHOLD_SQUARE) then
                            set this.x = x
                            set this.y = y
                            call thistype.MOVING_GROUP.Add(parent)
                            call this.Start_TriggerEvents(distanceSquare)
                        endif
                    endif
                endloop
                call thistype.EVENT_GROUP.AddGroupClear(thistype.ENUM_GROUP)
            endmethod
            method SetStatus takes boolean moving returns nothing
                if (moving == thistype.MOVING_GROUP.Contains(this)) then
                    return
                endif
                if moving then
                    call thistype.MOVING_GROUP.Add(this)
                else
                    call thistype.MOVING_GROUP.Remove(this)
                endif
            endmethod
            method Reg takes Event whichEvent returns nothing
                local Unit parent = this
				if not parent.Data.Integer.Add(KEY_ARRAY_DETAIL + whichEvent, 1) then
					return
				endif
				call parent.Event.Add(whichEvent)
                if not parent.Data.Integer.Add(KEY, 1) then
                    return
                endif
                if thistype.EVENT_GROUP.IsEmpty() then
                    call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Trig)
                endif
                set this.x = parent.Position.X.Get()
                set this.y = parent.Position.Y.Get()
                call thistype.EVENT_GROUP.Add(parent)
            endmethod
            method RegWithInterval takes Event whichEvent, real interval returns nothing
                call this.Interval.Add(whichEvent, interval)
                call this.Reg(whichEvent)
            endmethod
            method Unreg takes Event whichEvent returns nothing
                local Unit parent = this
				if not parent.Data.Integer.Subtract(KEY_ARRAY_DETAIL + whichEvent, 1) then
					return
				endif
				call parent.Event.Remove(whichEvent)
                if not parent.Data.Integer.Subtract(KEY, 1) then
                    return
                endif
                call thistype.EVENT_GROUP.Remove(parent)
                if thistype.EVENT_GROUP.IsEmpty() then
                    call thistype.UPDATE_TIMER.Pause()
                endif
                
            endmethod
            static method Init takes nothing returns nothing
                set thistype.DUMMY_TRIGGER = Trigger.Create()
                set thistype.ENDING_EVENT_TYPE = EventType.Create()
                set thistype.ENUM_GROUP = UnitList.Create()
                set thistype.EVENT_GROUP = UnitList.Create()
                set thistype.MOVING_GROUP = UnitList.Create()
                set thistype.START_EVENT_TYPE = EventType.Create()
                set thistype.UPDATE_TIMER = Timer.Create()
                call thistype.DUMMY_TRIGGER.AddCode(function thistype.Trig)
                
                call thistype(NULL).Interval.Init()
                
                call thistype(NULL).Region.Init()
            endmethod
        endstruct
    scope FolderSpeed
    public struct StructBaseA
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
                method Set takes real value returns nothing
                    set this.value = value
                    call Unit(this).Movement.Speed.Update()
                endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
                eventMethod Event_TypeChange
                    local UnitType sourceType = params.UnitType.GetSource()
                    local UnitType targetType = params.UnitType.GetTrigger()
                    local thistype this = params.Unit.GetTrigger()
                    call this.Add(targetType.Speed.Get() - sourceType.Speed.Get())
                endmethod
                method Event_Create takes nothing returns nothing
                    set this.value = Unit(this).Type.Get().Speed.Get()
                endmethod
                static method Init takes nothing returns nothing
                    call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
                endmethod
            endstruct
    public struct StructBonusA
        implement Allocation
        implement List
        
                static UnitState STATE
                static constant real ZERO_CAP = 0.1
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
                method Set takes real value returns nothing
                    set this.value = value
                    set value = (value + Unit(this).Movement.Speed.BaseA.Get()) * (Unit(this).Movement.Speed.RelativeA.Get() - 1.)
                    if (Math.Abs(value) < thistype.ZERO_CAP) then
                        set value = 0.
                    endif
					local integer abilityLevel
                    if (value > 0.) then
                        set abilityLevel = 3
                    else
                        set abilityLevel = 1 + B2I(value < 0.)
                    endif
                    call Unit(this).Movement.Speed.Update()
                    call Unit(this).Abilities.SetLevelBySelf(thistype.DUMMY_SPELL_ID, abilityLevel)
                    call Unit(this).Display.Update()
                endmethod
                method Event_Create takes nothing returns nothing
                    set this.value = 0.
                    call Unit(this).Abilities.AddBySelf(thistype.STORAGE_SPELL_ID)
                endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
                eventMethod Event_State
                    call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
                endmethod
                static method Init takes nothing returns nothing
                    call User.ANY.EnableAbilityBySelf(thistype.STORAGE_SPELL_ID, false)
                    set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
                endmethod
            endstruct
    public struct StructRelativeA
        implement Allocation
        implement List
        
                static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
                method Set takes real value returns nothing
                    set this.value = value
                    call Unit(this).Movement.Speed.BonusA.Update()
                endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
                eventMethod Event_State
                    call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
                endmethod
                method Event_Create takes nothing returns nothing
                    set this.value = 1.
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
                endmethod
            endstruct
        endscope
    public struct StructSpeed
        implement Allocation
        implement List
        
            static constant real LOWER_CAP = 100.
            static constant real UPPER_CAP = 522.
            static constant real STAMINA_FACTOR_MAX = 1.2
            static constant real STAMINA_FACTOR_MIN = 0.6
            real bonusVal
    FolderSpeed_StructBaseA BaseA = this
    FolderSpeed_StructBaseA LinkToStruct_BaseA
    FolderSpeed_StructBonusA BonusA = this
    FolderSpeed_StructBonusA LinkToStruct_BonusA
    FolderSpeed_StructRelativeA RelativeA = this
    FolderSpeed_StructRelativeA LinkToStruct_RelativeA
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method GetBonus takes nothing returns real
                return this.bonusVal
            endmethod
            method StaminaReduce takes real value returns real
                if (Unit(this).MaxStamina.Get() > 0) then
                    set value = thistype.LOWER_CAP + (value - thistype.LOWER_CAP) * ((thistype.STAMINA_FACTOR_MAX - thistype.STAMINA_FACTOR_MIN) * Unit(this).Stamina.GetFactor() + thistype.STAMINA_FACTOR_MIN)
                endif
                set value = Math.Max(thistype.LOWER_CAP, value)
                set value = Math.Min(value, thistype.UPPER_CAP)
                return value
            endmethod
            method UpdateNative takes nothing returns nothing
                call SetUnitMoveSpeed(Unit(this).self, this.StaminaReduce(this.Get()) - Math.Sign(this.GetBonus()))
            endmethod
            method Set takes real val returns nothing
                local real bonusVal = value - this.BaseA.Get()
                local real typeVal = Unit(this).Type.Get().Speed.Get()
                set this.bonusVal = bonusVal
                set this.value = val
				set val = this.StaminaReduce(val)
                call SetUnitMoveSpeed(Unit(this).self, val - Math.Sign(bonusVal))
                if (typeVal > 0) then
                    call SetUnitTimeScale(Unit(this).self, val / typeVal)
                endif
            endmethod
            method Update takes nothing returns nothing
                call this.Set(this.BaseA.Get() * this.RelativeA.Get() + this.BonusA.Get())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
                call this.BaseA.Event_Create()
                call this.BonusA.Event_Create()
                call this.RelativeA.Event_Create()
                call this.Update()
            endmethod
            static method Init takes nothing returns nothing
            	call thistype(NULL).BaseA.Init()
                call thistype(NULL).BonusA.Init()
                call thistype(NULL).RelativeA.Init()
            endmethod
        endstruct
    endscope
    public struct StructMovement
        implement Allocation
        implement List
        
    	static UnitState DISABLE_STATE
        static constant integer MOVE_SPELL_ID = BJUnit.Movement.MOVE_ID
    FolderMovement_StructEvents Events = this
    FolderMovement_StructEvents LinkToStruct_Events
    FolderMovement_StructSpeed Speed = this
    FolderMovement_StructSpeed LinkToStruct_Speed
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(true)
            call SetUnitPropWindow(parent.self, 60.)
        endmethod
        eventMethod Event_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(false)
            call SetUnitPropWindow(parent.self, 0.)
        endmethod
        method Subtract takes nothing returns nothing
            call Unit(this).Buffs.Add(thistype.DISABLE_BUFF, 1)
        endmethod
        method SubtractTimed takes real duration returns nothing
            call Unit(this).Buffs.Timed.Start(thistype.DISABLE_BUFF, 1, duration)
        endmethod
        method RemovePermanently takes nothing returns nothing
            call this.Subtract()
            call Unit(this).Abilities.RemoveBySelf(thistype.MOVE_SPELL_ID)
        endmethod
        method Add takes nothing returns nothing
            call Unit(this).Buffs.Subtract(thistype.DISABLE_BUFF)
        endmethod
        method Change takes boolean val returns nothing
            if val then
                call this.Add()
            else
                call this.Subtract()
            endif
        endmethod
        eventMethod Event_Disable_State
            call thistype(params.Unit.GetTrigger()).Change(not params.Bool.GetVal())
        endmethod
        eventMethod Event_TypeChange
            local UnitType sourceType = params.UnitType.GetSource()
            local UnitType targetType = params.UnitType.GetTrigger()
            local thistype this = params.Unit.GetTrigger()
            local boolean hasSpeed = (targetType.Speed.Get() > 0.)
            if ((sourceType.Speed.Get() > 0.) == hasSpeed) then
                if not hasSpeed then
                    call this.RemovePermanently()
                endif
                return
            endif
            if hasSpeed then
                call this.Add()
            else
                call this.RemovePermanently()
            endif
        endmethod
        method Event_Create takes nothing returns nothing
            if (Unit(this).Type.Get().Speed.Get() > 0.) then
                call this.Set(true)
            else
                call this.RemovePermanently()
            endif
            call this.Speed.Event_Create()
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DISABLE_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DISABLE_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
        static method Init takes nothing returns nothing
        	set thistype.DISABLE_STATE = UnitState.Create(thistype.NAME, function thistype.Event_Disable_State)
            call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            call thistype(NULL).Events.Init()
            call thistype(NULL).Speed.Init()
        endmethod
    endstruct
    scope FolderOrder
    scope FolderEvents
    public struct StructLose
        implement Allocation
        implement List
        
                static Event DESTROY_EVENT
                static UnitList ENUM_GROUP
                static UnitList REG_GROUP
                static UnitList UPDATE_GROUP
    static constant real UPDATE_TIME = FRAME_UPDATE_TIME * 16
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = 16
                static Timer UPDATE_TIMER
                method Unreg takes nothing returns nothing
                    call thistype.REG_GROUP.Remove(this)
                    call Unit(this).Event.Remove(DESTROY_EVENT)
                    if not thistype.UPDATE_GROUP.Contains(this) then
                        return
                    endif
                    call thistype.UPDATE_GROUP.Remove(this)
                    if thistype.UPDATE_GROUP.IsEmpty() then
                        call thistype.UPDATE_TIMER.Pause()
                    endif
                endmethod
                eventMethod Event_Destroy
                    call thistype(params.Unit.GetTrigger()).Unreg()
                endmethod
                method TriggerEvents takes nothing returns nothing
                    local Unit parent = this
                endmethod
                method Start takes nothing returns nothing
                    call Unit(this).Order.ResetData()
                    call this.TriggerEvents()
                endmethod
                timerMethod Update
                    loop
                        local Unit parent = thistype.UPDATE_GROUP.FetchFirst()
                        exitwhen (parent == NULL)
                        if (parent.Order.GetNative() == NULL) then
                            call thistype(parent).Start()
                        else
                            call thistype.ENUM_GROUP.Add(parent)
                        endif
                    endloop
                    if thistype.ENUM_GROUP.IsEmpty() then
                        call thistype.UPDATE_TIMER.Pause()
                    else
                        call thistype.UPDATE_GROUP.AddGroupClear(thistype.ENUM_GROUP)
                    endif
                endmethod
                method AddToUpdateGroup takes nothing returns nothing
                    if thistype.UPDATE_GROUP.Contains(this) then
                        return
                    endif
                    if thistype.UPDATE_GROUP.IsEmpty() then
                        call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
                    endif
                    call thistype.UPDATE_GROUP.Add(this)
                endmethod
                method StartByGain takes OrderInstance newData returns nothing
                    if not thistype.REG_GROUP.Contains(this) then
                        return
                    endif
					if newData.GetOrder().IsParallel() then
						return
					endif
                    call this.Start()
                    call Unit(this).Order.SetData(newData)
                    call this.AddToUpdateGroup()
                endmethod
                method Reg takes nothing returns nothing
                    call thistype.REG_GROUP.Add(this)
                    call Unit(this).Event.Add(DESTROY_EVENT)
                    if (Unit(this).Order.GetNative() == NULL) then
                        return
                    endif
                    call this.AddToUpdateGroup()
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
                    set thistype.ENUM_GROUP = UnitList.Create()
                    set thistype.REG_GROUP = UnitList.Create()
                    set thistype.UPDATE_GROUP = UnitList.Create()
                    set thistype.UPDATE_TIMER = Timer.Create()
                endmethod
            endstruct
    scope FolderGain
    public struct StructImmediate
        implement Allocation
        implement List
        
    static key GetKeyMacro_CANCEL_ITEM_USAGE_KEY_ARRAY
    static constant integer CANCEL_ITEM_USAGE_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_CANCEL_ITEM_USAGE_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
                    static EventType DUMMY_EVENT_TYPE
                    static Trigger DUMMY_TRIGGER
                    method TriggerEvents takes OrderInstance data returns nothing
                    	local Unit parent = this
                        local Order whichOrder = data.GetOrder()
                        local EventResponse orderParams = EventResponse.Create(whichOrder.Id.Get())
                        call orderParams.Order.SetTrigger(whichOrder)
                        call orderParams.Unit.SetTrigger(parent)
						local EventResponse params = EventResponse.Create(parent.Id.Get())
                        call params.Order.SetTrigger(whichOrder)
                        call params.Unit.SetTrigger(parent)
						local integer iteration = EventPriority.ALL_COUNT
                        loop
                            exitwhen (iteration < ARRAY_MIN)
                            local EventPriority priority = EventPriority.ALL[iteration]
                            local integer iteration2 = parent.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                            loop
                                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                                call parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                                set iteration2 = iteration2 - 1
                            endloop
                            set iteration2 = whichOrder.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                            loop
                                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                                call whichOrder.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(orderParams)
                                set iteration2 = iteration2 - 1
                            endloop
                            set iteration = iteration - 1
                        endloop
                        call orderParams.Destroy()
                        call params.Destroy()
                    endmethod
                    method Start takes OrderInstance data returns nothing
                        local Order whichOrder = data.GetOrder()
						local Spell triggerSpell = Unit(this).Abilities.GetFromOrder(whichOrder)
                        local boolean cancel = false
                        if (triggerSpell != NULL) then
                            if (triggerSpell.GetAutoCastOrderOff() == whichOrder) then
                                call Unit(this).Abilities.AutoCast.Set(NULL)
                            elseif (triggerSpell.GetAutoCastOrderOn() == whichOrder) then
                                call Unit(this).Abilities.AutoCast.Set(triggerSpell)
                            else
                                local BoolExpr orderConditions = triggerSpell.GetOrderConditions()
                                if (orderConditions != NULL) then
                                    local EventResponse params = EventResponse.Create(EventResponse.DIRECT_SUBJECT_ID)
                                    call params.Order.SetTrigger(whichOrder)
                                    call params.Unit.SetTrigger(this)
                                    call params.Spell.SetLevel(Unit(this).Abilities.GetLevel(triggerSpell))
                                    call params.Spell.SetTrigger(triggerSpell)
                                    if not orderConditions.RunWithParams(params) then
                                        call Unit(this).Stop()
                                        set cancel = true
                                    endif
                                    call params.Destroy()
                                    if cancel then
                                        return
                                    endif
                                endif
                            endif
                        endif
                        if whichOrder.IsInventoryUse() then
                            local User parentOwner = Unit(this).Owner.Get()
                            local Item triggerItem = Unit(this).Items.GetFromSlot(whichOrder.GetInventoryIndex())
                            local integer goldCost = triggerItem.Type.Get().UsageGoldCost.Get()
                            if (goldCost > parentOwner.State.Get(PLAYER_STATE_RESOURCE_GOLD)) then
                                call triggerItem.RecreateSelf(this)
                                call Unit(this).AddJumpingTextTag(String.Color.Do("Not enough gold!", String.Color.MALUS), 0.022, CANCEL_ITEM_USAGE_KEY_ARRAY + this)
                                return
                            endif
                            call parentOwner.State.Subtract(PLAYER_STATE_RESOURCE_GOLD, goldCost)
                            if (triggerItem.Classes.Contains(ItemClass.SCROLL) and Unit(this).Stun.Is()) then
                                call Unit(this).Items.Events.Use.TriggerEvents(triggerItem)
                            endif
                        endif
                        call Unit(this).Order.Events.Lose.StartByGain(data)
                        call this.TriggerEvents(data)
                    endmethod
                    boolean locked
                    OrderInstance lockData
                    method Unlock takes nothing returns nothing
                        set this.locked = false
                        local OrderInstance data = this.lockData
                        if (data == NULL) then
                            return
                        endif
                        set this.lockData = NULL
                        call this.Start(data)
                    endmethod
                    method Lock takes nothing returns nothing
                        set this.locked = true
                    endmethod
                    trigMethod Trig
                        local thistype this = UNIT.Event.Native.GetTrigger()
                        local Order whichOrder = ORDER.Event.Native.GetTrigger()
                        local OrderInstance data = OrderInstance.Create()
                        call data.SetOrder(whichOrder)
                        call data.SetTargetType(Spell.TARGET_TYPE_IMMEDIATE)
                        if this.locked then
                            if (this.lockData != NULL) then
                                call this.lockData.Destroy()
                            endif
                            set this.lockData = data
                            return
                        endif
                        if Unit(this).Transport.Is() then
                            return
                        endif
                        call this.Start(data)
                    endmethod
                    method Reg takes nothing returns nothing
                        set this.lockData = NULL
                        set this.locked = false
                        call thistype.DUMMY_TRIGGER.RegisterEvent.Unit(this, EVENT_UNIT_ISSUED_ORDER)
                    endmethod
                    static method Init takes nothing returns nothing
                        set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                        set thistype.DUMMY_TRIGGER = Trigger.CreateFromCode(function thistype.Trig)
                    endmethod
                endstruct
    public struct StructPoint
        implement Allocation
        implement List
        
                    static EventType DUMMY_EVENT_TYPE
                    static Trigger DUMMY_TRIGGER
                    method TriggerEvents takes OrderInstance data returns nothing
                    	local Unit parent = this
                        local Order whichOrder = data.GetOrder()
                        local real targetX = data.GetTargetX()
                        local real targetY = data.GetTargetY()
                        local EventResponse orderParams = EventResponse.Create(whichOrder.Id.Get())
                        call orderParams.Order.SetTrigger(whichOrder)
                        call orderParams.Spot.SetTargetX(targetX)
                        call orderParams.Spot.SetTargetY(targetY)
                        call orderParams.Unit.SetTrigger(parent)
						local EventResponse params = EventResponse.Create(parent.Id.Get())
                        call params.Order.SetTrigger(whichOrder)
                        call params.Spot.SetTargetX(targetX)
                        call params.Spot.SetTargetY(targetY)
                        call params.Unit.SetTrigger(parent)
						local integer iteration = EventPriority.ALL_COUNT
                        loop
                            exitwhen (iteration < ARRAY_MIN)
                            local EventPriority priority = EventPriority.ALL[iteration]
                            local integer iteration2 = parent.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                            loop
                                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                                call parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                                set iteration2 = iteration2 - 1
                            endloop
                            set iteration2 = whichOrder.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                            loop
                                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                                call whichOrder.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(orderParams)
                                set iteration2 = iteration2 - 1
                            endloop
                            set iteration = iteration - 1
                        endloop
                        call orderParams.Destroy()
                        call params.Destroy()
                    endmethod
                    method Start takes OrderInstance data returns nothing
                        call Unit(this).Order.Events.Lose.StartByGain(data)
                        call this.TriggerEvents(data)
                    endmethod
                    boolean locked
                    OrderInstance lockData
                    method Unlock takes nothing returns nothing
                        set this.locked = false
                        local OrderInstance data = this.lockData
                        if (data == NULL) then
                            return
                        endif
                        set this.lockData = NULL
                        call this.Start(data)
                    endmethod
                    method Lock takes nothing returns nothing
                        set this.locked = true
                    endmethod
                    trigMethod Trig
                        local real targetX = SPOT.Event.Native.GetOrderTargetX()
                        local real targetY = SPOT.Event.Native.GetOrderTargetY()
                        local thistype this = UNIT.Event.Native.GetTrigger()
                        local Order whichOrder = ORDER.Event.Native.GetTrigger()
                        local OrderInstance data = OrderInstance.Create()
                        call data.SetOrder(whichOrder)
                        call data.SetTargetX(targetX)
                        call data.SetTargetY(targetY)
                        call data.SetTargetType(Spell.TARGET_TYPE_POINT)
                        if this.locked then
                            if (this.lockData != NULL) then
                                call this.lockData.Destroy()
                            endif
                            set this.lockData = data
                            return
                        endif
                        call this.Start(data)
                    endmethod
                    method Reg takes nothing returns nothing
                        set this.lockData = NULL
                        set this.locked = false
                        call thistype.DUMMY_TRIGGER.RegisterEvent.Unit(this, EVENT_UNIT_ISSUED_POINT_ORDER)
                    endmethod
                    static method Init takes nothing returns nothing
                        set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                        set thistype.DUMMY_TRIGGER = Trigger.CreateFromCode(function thistype.Trig)
                    endmethod
                endstruct
    public struct StructTarget
        implement Allocation
        implement List
        
                    static EventType DUMMY_EVENT_TYPE
                    static Trigger DUMMY_TRIGGER
                    static EventType TARGET_EVENT_TYPE
                    method TriggerEvents takes OrderInstance data returns nothing
                    	local Unit parent = this
                        local Order whichOrder = data.GetOrder()
                        local Item targetItem = data.GetTargetItem()
                        local Unit targetUnit = data.GetTargetUnit()
                        local EventResponse orderParams = EventResponse.Create(whichOrder.Id.Get())
                        call orderParams.Item.SetTarget(targetItem)
                        call orderParams.Order.SetTrigger(whichOrder)
                        call orderParams.Unit.SetTarget(targetUnit)
                        call orderParams.Unit.SetTrigger(parent)
						local EventResponse params = EventResponse.Create(parent.Id.Get())
                        call params.Item.SetTarget(targetItem)
                        call params.Order.SetTrigger(whichOrder)
                        call params.Unit.SetTarget(targetUnit)
                        call params.Unit.SetTrigger(parent)
						local EventResponse targetUnitParams = EventResponse.Create(targetUnit.Id.Get())
                        call targetUnitParams.Item.SetTarget(targetItem)
                        call targetUnitParams.Order.SetTrigger(whichOrder)
                        call targetUnitParams.Unit.SetTarget(parent)
                        call targetUnitParams.Unit.SetTrigger(targetUnit)
						local integer iteration = EventPriority.ALL_COUNT
                        loop
                            exitwhen (iteration < ARRAY_MIN)
                            local EventPriority priority = EventPriority.ALL[iteration]
                            local integer iteration2 = parent.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                            loop
                                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                                call parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                                set iteration2 = iteration2 - 1
                            endloop
                            set iteration2 = whichOrder.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                            loop
                                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                                call whichOrder.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(orderParams)
                                set iteration2 = iteration2 - 1
                            endloop
                            set iteration2 = targetUnit.Event.Count(thistype.TARGET_EVENT_TYPE, priority)
                            loop
                                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                                call targetUnit.Event.Get(thistype.TARGET_EVENT_TYPE, priority, iteration2).Run(targetUnitParams)
                                set iteration2 = iteration2 - 1
                            endloop
                            set iteration = iteration - 1
                        endloop
                        call orderParams.Destroy()
                        call params.Destroy()
                        call targetUnitParams.Destroy()
                    endmethod
                    method Start takes OrderInstance data returns nothing
                        call Unit(this).Order.Events.Lose.StartByGain(data)
                        call this.TriggerEvents(data)
                    endmethod
                    boolean locked
                    OrderInstance lockData
                    method Unlock takes nothing returns nothing
                        set this.locked = false
                        local OrderInstance data = this.lockData
                        if (data == NULL) then
                            return
                        endif
                        set this.lockData = NULL
                        call this.Start(data)
                    endmethod
                    method Lock takes nothing returns nothing
                        set this.locked = true
                    endmethod
                    trigMethod Trig
                        local Item targetItem = ITEM.Event.Native.GetOrderTarget()
                        local Unit targetUnit = UNIT.Event.Native.GetOrderTarget()
                        local thistype this = UNIT.Event.Native.GetTrigger()
                        local Order whichOrder = ORDER.Event.Native.GetTrigger()
                        local OrderInstance data = OrderInstance.Create()
                        call data.SetOrder(whichOrder)
                        call data.SetTargetItem(targetItem)
                        call data.SetTargetUnit(targetUnit)
                        call data.SetTargetType(Spell.TARGET_TYPE_UNIT)
                        if this.locked then
                            if (this.lockData != NULL) then
                                call this.lockData.Destroy()
                            endif
                            set this.lockData = data
                            return
                        endif
                        call this.Start(data)
                    endmethod
                    method Reg takes nothing returns nothing
                        set this.lockData = NULL
                        set this.locked = false
                        call thistype.DUMMY_TRIGGER.RegisterEvent.Unit(this, EVENT_UNIT_ISSUED_TARGET_ORDER)
                    endmethod
                    static method Init takes nothing returns nothing
                        set thistype.DUMMY_EVENT_TYPE = EventType.Create()
                        set thistype.DUMMY_TRIGGER = Trigger.CreateFromCode(function thistype.Trig)
                        set thistype.TARGET_EVENT_TYPE = EventType.Create()
                    endmethod
                endstruct
            endscope
    public struct StructGain
        implement Allocation
        implement List
        
    FolderGain_StructImmediate Immediate = this
    FolderGain_StructImmediate LinkToStruct_Immediate
    FolderGain_StructPoint Point = this
    FolderGain_StructPoint LinkToStruct_Point
    FolderGain_StructTarget Target = this
    FolderGain_StructTarget LinkToStruct_Target
                method Event_Create takes nothing returns nothing
                    call this.Immediate.Reg()
                    call this.Point.Reg()
                    call this.Target.Reg()
                endmethod
                static method Init takes nothing returns nothing
                    call thistype(NULL).Immediate.Init()
                    call thistype(NULL).Point.Init()
                    call thistype(NULL).Target.Init()
                endmethod
            endstruct
    public struct StructIdle
        implement Allocation
        implement List
        
                static Event DESTROY_EVENT
                static EventType ENDING_EVENT_TYPE
                static EventType INTERVAL_EVENT_TYPE
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
                static EventType START_EVENT_TYPE
                static constant real UPDATE_TIME = 0.75
                static Timer UPDATE_TIMER
    static thistype array ACTIVE_LIST_ALL
    static integer ACTIVE_LIST_ALL_COUNT = ARRAY_EMPTY
    integer ACTIVE_LIST_index
    static method ACTIVE_LIST_Count takes nothing returns integer
        return thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static method ACTIVE_LIST_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Get takes integer index returns thistype
        return thistype.ACTIVE_LIST_ALL[index]
    endmethod
    static method ACTIVE_LIST_GetIndex takes thistype this returns integer
        return this.ACTIVE_LIST_index
    endmethod
    static method ACTIVE_LIST_Contains takes thistype this returns boolean
        return (thistype.ACTIVE_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ACTIVE_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ACTIVE_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ACTIVE_LIST_RandomAll takes nothing returns thistype
        return thistype.ACTIVE_LIST_Random(ARRAY_MIN, thistype.ACTIVE_LIST_ALL_COUNT)
    endmethod
    static method ACTIVE_LIST_Remove takes thistype this returns boolean
        if not thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT].ACTIVE_LIST_index = this.ACTIVE_LIST_index
        set thistype.ACTIVE_LIST_ALL[this.ACTIVE_LIST_index - 1] = thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT]
        set this.ACTIVE_LIST_index = ARRAY_MIN
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT - 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Add takes thistype this returns boolean
        if thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT + 1
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT] = this
        set this.ACTIVE_LIST_index = thistype.ACTIVE_LIST_ALL_COUNT + 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static thistype array EVENT_LIST_ALL
    static integer EVENT_LIST_ALL_COUNT = ARRAY_EMPTY
    integer EVENT_LIST_index
    static method EVENT_LIST_Count takes nothing returns integer
        return thistype.EVENT_LIST_ALL_COUNT
    endmethod
    static method EVENT_LIST_IsEmpty takes nothing returns boolean
        return (thistype.EVENT_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method EVENT_LIST_Get takes integer index returns thistype
        return thistype.EVENT_LIST_ALL[index]
    endmethod
    static method EVENT_LIST_GetIndex takes thistype this returns integer
        return this.EVENT_LIST_index
    endmethod
    static method EVENT_LIST_Contains takes thistype this returns boolean
        return (thistype.EVENT_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method EVENT_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.EVENT_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method EVENT_LIST_RandomAll takes nothing returns thistype
        return thistype.EVENT_LIST_Random(ARRAY_MIN, thistype.EVENT_LIST_ALL_COUNT)
    endmethod
    static method EVENT_LIST_Remove takes thistype this returns boolean
        if not thistype.EVENT_LIST_Contains(this) then
            return false
        endif
        set thistype.EVENT_LIST_ALL[thistype.EVENT_LIST_ALL_COUNT].EVENT_LIST_index = this.EVENT_LIST_index
        set thistype.EVENT_LIST_ALL[this.EVENT_LIST_index - 1] = thistype.EVENT_LIST_ALL[thistype.EVENT_LIST_ALL_COUNT]
        set this.EVENT_LIST_index = ARRAY_MIN
        set thistype.EVENT_LIST_ALL_COUNT = thistype.EVENT_LIST_ALL_COUNT - 1
        return (thistype.EVENT_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method EVENT_LIST_Add takes thistype this returns boolean
        if thistype.EVENT_LIST_Contains(this) then
            return false
        endif
        set thistype.EVENT_LIST_ALL_COUNT = thistype.EVENT_LIST_ALL_COUNT + 1
        set thistype.EVENT_LIST_ALL[thistype.EVENT_LIST_ALL_COUNT] = this
        set this.EVENT_LIST_index = thistype.EVENT_LIST_ALL_COUNT + 1
        return (thistype.EVENT_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static thistype array FOR_EACH_LIST_ALL
    static integer FOR_EACH_LIST_ALL_COUNT = ARRAY_EMPTY
    static method FOR_EACH_LIST_FetchFirst takes nothing returns thistype
        local thistype result
        if (thistype.FOR_EACH_LIST_ALL_COUNT < ARRAY_MIN) then
            return NULL
        endif
        set result = thistype.FOR_EACH_LIST_ALL[ARRAY_MIN]
        set thistype.FOR_EACH_LIST_ALL[ARRAY_MIN] = thistype.FOR_EACH_LIST_ALL[thistype.FOR_EACH_LIST_ALL_COUNT]
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.FOR_EACH_LIST_ALL_COUNT - 1
        return result
    endmethod
    static method FOR_EACH_LIST_Set takes nothing returns nothing
        local integer iteration = thistype.ACTIVE_LIST_ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.FOR_EACH_LIST_ALL[iteration] = thistype.ACTIVE_LIST_ALL[iteration]
            set iteration = iteration - 1
        endloop
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static thistype array IDLING_LIST_ALL
    static integer IDLING_LIST_ALL_COUNT = ARRAY_EMPTY
    integer IDLING_LIST_index
    static method IDLING_LIST_Count takes nothing returns integer
        return thistype.IDLING_LIST_ALL_COUNT
    endmethod
    static method IDLING_LIST_IsEmpty takes nothing returns boolean
        return (thistype.IDLING_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method IDLING_LIST_Get takes integer index returns thistype
        return thistype.IDLING_LIST_ALL[index]
    endmethod
    static method IDLING_LIST_GetIndex takes thistype this returns integer
        return this.IDLING_LIST_index
    endmethod
    static method IDLING_LIST_Contains takes thistype this returns boolean
        return (thistype.IDLING_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method IDLING_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.IDLING_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method IDLING_LIST_RandomAll takes nothing returns thistype
        return thistype.IDLING_LIST_Random(ARRAY_MIN, thistype.IDLING_LIST_ALL_COUNT)
    endmethod
    static method IDLING_LIST_Remove takes thistype this returns boolean
        if not thistype.IDLING_LIST_Contains(this) then
            return false
        endif
        set thistype.IDLING_LIST_ALL[thistype.IDLING_LIST_ALL_COUNT].IDLING_LIST_index = this.IDLING_LIST_index
        set thistype.IDLING_LIST_ALL[this.IDLING_LIST_index - 1] = thistype.IDLING_LIST_ALL[thistype.IDLING_LIST_ALL_COUNT]
        set this.IDLING_LIST_index = ARRAY_MIN
        set thistype.IDLING_LIST_ALL_COUNT = thistype.IDLING_LIST_ALL_COUNT - 1
        return (thistype.IDLING_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method IDLING_LIST_Add takes thistype this returns boolean
        if thistype.IDLING_LIST_Contains(this) then
            return false
        endif
        set thistype.IDLING_LIST_ALL_COUNT = thistype.IDLING_LIST_ALL_COUNT + 1
        set thistype.IDLING_LIST_ALL[thistype.IDLING_LIST_ALL_COUNT] = this
        set this.IDLING_LIST_index = thistype.IDLING_LIST_ALL_COUNT + 1
        return (thistype.IDLING_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
                method Ending_TriggerEvents takes nothing returns nothing                    
                    local Unit parent = this
                    local EventResponse params = EventResponse.Create(parent.Id.Get())
                    call params.Unit.SetTrigger(this)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = parent.Event.Count(thistype.ENDING_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call parent.Event.Get(thistype.ENDING_EVENT_TYPE, priority, iteration2).Run(params)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call params.Destroy()
                endmethod
                method Interval_TriggerEvents takes nothing returns nothing
                    local Unit parent = this
                    local EventResponse params = EventResponse.Create(parent.Id.Get())
                    call params.Unit.SetTrigger(this)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = parent.Event.Count(thistype.INTERVAL_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call parent.Event.Get(thistype.INTERVAL_EVENT_TYPE, priority, iteration2).Run(params)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call params.Destroy()
                endmethod
                method Start_TriggerEvents takes nothing returns nothing
                    local Unit parent = this
                    local EventResponse params = EventResponse.Create(parent.Id.Get())
                    call params.Unit.SetTrigger(this)
					local integer iteration = EventPriority.ALL_COUNT
                    loop
                        exitwhen (iteration < ARRAY_MIN)
                        local EventPriority priority = EventPriority.ALL[iteration]
                        local integer iteration2 = parent.Event.Count(thistype.START_EVENT_TYPE, priority)
                        loop
                            exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                            call parent.Event.Get(thistype.START_EVENT_TYPE, priority, iteration2).Run(params)
                            set iteration2 = iteration2 - 1
                        endloop
                        set iteration = iteration - 1
                    endloop
                    call params.Destroy()
                endmethod
                timerMethod Update
                    call thistype.FOR_EACH_LIST_Set()
                    loop
                        local thistype this = thistype.FOR_EACH_LIST_FetchFirst()
                        exitwhen (this == NULL)
                        if thistype.IDLING_LIST_Contains(this) then
                            if (Unit(this).Order.GetNative() == NULL) then
                                call this.Interval_TriggerEvents()
                            else
                                call thistype.IDLING_LIST_Remove(this)
                                call this.Ending_TriggerEvents()
                            endif
                        else
                            if (Unit(this).Order.GetNative() == NULL) then
                                call thistype.IDLING_LIST_Add(this)
                                call this.Start_TriggerEvents()
                            endif
                        endif
                    endloop
                endmethod
                method Reg takes Event whichEvent returns nothing
                    if Unit(this).Data.Integer.Table.Add(KEY_ARRAY, whichEvent) then
                        call Unit(this).Event.Add(DESTROY_EVENT)
                        call thistype.EVENT_LIST_Add(this)
                        if not Unit(this).Classes.Contains(UnitClass.DEAD) then
                            if thistype.ACTIVE_LIST_Add(this) then
                                call UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
                            endif
                        endif
                    endif
                    call Unit(this).Event.Add(whichEvent)
                endmethod
                method Unreg takes Event whichEvent returns nothing
                    if Unit(this).Data.Integer.Table.Remove(KEY_ARRAY, whichEvent) then
                        call thistype.EVENT_LIST_Remove(this)
                        call Unit(this).Event.Remove(DESTROY_EVENT)
                        if thistype.ACTIVE_LIST_Remove(this) then
                            call thistype.UPDATE_TIMER.Pause()
                        endif
                    endif
                    call Unit(this).Event.Remove(whichEvent)
                endmethod
                eventMethod Event_Death
                    local thistype this = params.Unit.GetTrigger()
                    if not thistype.EVENT_LIST_Contains(this) then
                        return
                    endif
                    call thistype.ACTIVE_LIST_Remove(this)
                    if thistype.IDLING_LIST_Contains(this) then
                        call thistype.IDLING_LIST_Remove(this)
                        call this.Ending_TriggerEvents()
                    endif
                endmethod
                eventMethod Event_Revive
                    local thistype this = params.Unit.GetTrigger()
                    if not thistype.EVENT_LIST_Contains(this) then
                        return
                    endif
                    call thistype.ACTIVE_LIST_Add(this)
                    call thistype.IDLING_LIST_Add(this)
                    call this.Start_TriggerEvents()
                endmethod
                eventMethod Event_Destroy
                    local Unit parent = params.Unit.GetTrigger()
                    local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                    loop
                        call thistype(parent).Unreg(parent.Data.Integer.Table.Get(KEY_ARRAY, iteration))
                        set iteration = iteration - 1
                        exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    endloop
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
                    set thistype.ENDING_EVENT_TYPE = EventType.Create()
                    set thistype.INTERVAL_EVENT_TYPE = EventType.Create()
                    set thistype.START_EVENT_TYPE = EventType.Create()
                    set thistype.UPDATE_TIMER = Timer.Create()
                    call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Death).AddToStatics()
                    call Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Revive).AddToStatics()
                endmethod
            endstruct
        endscope
    public struct StructEvents
        implement Allocation
        implement List
        
    FolderEvents_StructGain Gain = this
    FolderEvents_StructGain LinkToStruct_Gain
    FolderEvents_StructIdle Idle = this
    FolderEvents_StructIdle LinkToStruct_Idle
    FolderEvents_StructLose Lose = this
    FolderEvents_StructLose LinkToStruct_Lose
            method Unlock takes nothing returns nothing
                call this.Gain.Immediate.Unlock()
                call this.Gain.Point.Unlock()
                call this.Gain.Target.Unlock()
            endmethod
            method Lock takes nothing returns nothing
                call this.Gain.Immediate.Lock()
                call this.Gain.Point.Lock()
                call this.Gain.Target.Lock()
            endmethod
            method Event_Create takes nothing returns nothing
                call this.Gain.Event_Create()
                call this.Lose.Reg()
            endmethod
            static method Init takes nothing returns nothing
                call thistype(NULL).Gain.Init()
                call thistype(NULL).Idle.Init()
                call thistype(NULL).Lose.Init()
            endmethod
        endstruct
    endscope
    public struct StructOrder
        implement Allocation
        implement List
        
        OrderInstance data
    FolderOrder_StructEvents Events = this
    FolderOrder_StructEvents LinkToStruct_Events
        method Get takes nothing returns Order
            return this.data.GetOrder()
        endmethod
        method GetData takes nothing returns OrderInstance
            return this.data
        endmethod
        method GetNative takes nothing returns Order
            return Order.GetFromSelf(GetUnitCurrentOrder(Unit(this).self))
        endmethod
        method AddImmediate takes Order whichOrder returns nothing
        endmethod
        method Immediate takes Order whichOrder returns boolean
            if not IssueImmediateOrderById(Unit(this).self, whichOrder.self) then
                return false
            endif
            return true
        endmethod
        method ImmediateNoTrig takes Order whichOrder returns boolean
            call thistype(NULL).Events.Gain.Immediate.DUMMY_TRIGGER.Disable()
            local boolean result = this.Immediate(whichOrder)
            call thistype(NULL).Events.Gain.Immediate.DUMMY_TRIGGER.Enable()
            return result
        endmethod
        method ImmediateBySpell takes Spell whichSpell returns boolean
            return this.Immediate(whichSpell.GetOrder())
        endmethod
        method PointTarget takes Order whichOrder, real x, real y returns boolean
            if not IssuePointOrderById(Unit(this).self, whichOrder.self, x, y) then
                return false
            endif
            return true
        endmethod
        method PointTargetNoTrig takes Order whichOrder, real x, real y returns boolean
            call thistype(NULL).Events.Gain.Point.DUMMY_TRIGGER.Disable()
            local boolean result = this.PointTarget(whichOrder, x, y)
            call thistype(NULL).Events.Gain.Point.DUMMY_TRIGGER.Enable()
            return result
        endmethod
        method PointTargetBySpell takes Spell whichSpell, real x, real y returns boolean
            return this.PointTarget(whichSpell.GetOrder(), x, y)
        endmethod
        method UnitTarget takes Order whichOrder, Unit target returns boolean
            if not IssueTargetOrderById(Unit(this).self, whichOrder.self, Unit(target).self) then
                return false
            endif
            return true
        endmethod
        method UnitTargetNoTrig takes Order whichOrder, Unit target returns boolean
            call thistype(NULL).Events.Gain.Target.DUMMY_TRIGGER.Disable()
            local boolean result = this.UnitTarget(whichOrder, target)
            call thistype(NULL).Events.Gain.Target.DUMMY_TRIGGER.Enable()
            return result
        endmethod
        method UnitTargetBySpell takes Spell whichSpell, Unit target returns boolean
            return this.UnitTarget(whichSpell.GetOrder(), target)
        endmethod
        method ItemTarget takes Order whichOrder, Item target returns boolean
            if not IssueTargetOrderById(Unit(this).self, whichOrder.self, Item(target).self) then
                return false
            endif
            return true
        endmethod
        method ItemTargetNoTrig takes Order whichOrder, Item target returns boolean
            call thistype(NULL).Events.Gain.Target.DUMMY_TRIGGER.Disable()
            local boolean result = this.ItemTarget(whichOrder, target)
            call thistype(NULL).Events.Gain.Target.DUMMY_TRIGGER.Enable()
            return result
        endmethod
        method Do takes OrderInstance data returns nothing
            local integer targetType = data.GetTargetType()
            local Item targetItem = data.GetTargetItem()
            local Unit targetUnit = data.GetTargetUnit()
            local Order whichOrder = data.GetOrder()
            local real x = data.GetTargetX()
            local real y = data.GetTargetY()
            if (targetType == Spell.TARGET_TYPE_IMMEDIATE) then
                call this.Immediate(whichOrder)
            elseif (targetType == Spell.TARGET_TYPE_POINT) then
                call this.PointTarget(whichOrder, x, y)
            else
                if (targetUnit != NULL) then
                    call this.UnitTarget(whichOrder, targetUnit)
                elseif (targetItem != NULL) then
                    call this.ItemTarget(whichOrder, targetItem)
                else
                    call this.PointTarget(whichOrder, x, y)
                endif
            endif
        endmethod
        method DoNoTrig takes OrderInstance data returns nothing
            local integer targetType = data.GetTargetType()
            local Unit targetUnit = data.GetTargetUnit()
            local Order whichOrder = data.GetOrder()
            local real x = data.GetTargetX()
            local real y = data.GetTargetY()
            if (targetType == Spell.TARGET_TYPE_IMMEDIATE) then
                call this.ImmediateNoTrig(whichOrder)
            elseif (targetType == Spell.TARGET_TYPE_POINT) then
                call this.PointTargetNoTrig(whichOrder, x, y)
            else
                if (targetUnit == NULL) then
                    call this.PointTargetNoTrig(whichOrder, x, y)
                else
                    call this.UnitTargetNoTrig(whichOrder, targetUnit)
                endif
            endif
        endmethod
		method Restore
            local OrderInstance data = this.GetData()
            if (data == NULL) then
                return
            endif
			call this.DoNoTrig(data)
		endmethod
		method Deaggravate
		
            local OrderInstance data = this.GetData()
            if (data == NULL) then
                return
            endif
			local Order whichOrder = data.GetOrder()
			if (whichOrder == Order.ATTACK) then
				local Unit targetUnit = data.GetTargetUnit()
				if (targetUnit != NULL) then
					call this.UnitTarget(Order.MOVE, targetUnit)
					return
				endif
				local Unit targetItem = data.GetTargetItem()
				if (targetItem != NULL) then
					call this.ItemTarget(Order.MOVE, targetItem)
					return
				endif
				return
			endif
			local Unit target = data.GetTargetUnit()
			if (whichOrder == Order.SMART) then
				set targetUnit = data.GetTargetUnit()
				if (targetUnit != NULL) then
					if targetUnit.IsEnemyOf(Unit(this).Owner.Get()) then
						call this.UnitTarget(Order.MOVE, targetUnit)
					endif
				endif
			endif
		endmethod
        method Update takes nothing returns nothing
            local OrderInstance data = this.GetData()
            if (data == NULL) then
                return
            endif
            call this.Do(data)
        endmethod
        method Spell takes Spell whichSpell, Unit target, real x, real y returns boolean
            local integer targetType = whichSpell.GetTargetType()
            if (targetType == Spell.TARGET_TYPE_IMMEDIATE) then
                return this.ImmediateBySpell(whichSpell)
            elseif (targetType == Spell.TARGET_TYPE_POINT) then
                return this.PointTargetBySpell(whichSpell, x, y)
            else
                if (target == NULL) then
                    return this.PointTargetBySpell(whichSpell, x, y)
                endif
            endif
            return this.UnitTargetBySpell(whichSpell, target)
        endmethod
        method ResetData takes nothing returns nothing
            local OrderInstance data = this.GetData()
            if (data == NULL) then
                return
            endif
            set this.data = NULL
            call data.Destroy()
        endmethod
        method SetData takes OrderInstance val returns nothing
            set this.data = val
        endmethod
        static Event DESTROY_EVENT
        eventMethod Event_Destroy
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
            call parent.Event.Remove(DESTROY_EVENT)
            call this.ResetData()
        endmethod
        method Event_Create takes nothing returns nothing
            set this.data = NULL
            call Unit(this).Event.Add(DESTROY_EVENT)
            call this.Events.Event_Create()
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
            call thistype(NULL).Events.Init()
        endmethod
    endstruct
    public struct StructBanish
        implement Allocation
        implement List
        
        static Event REVIVE_EVENT
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        eventMethod Event_Revive
            call DummyUnit.WORLD_CASTER.Order.UnitTargetInstantly(Order.BANISH, params.Unit.GetTrigger())
        endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(false)
            call parent.Event.Remove(REVIVE_EVENT)
            call parent.Buffs.RemoveBySelf(thistype.BAN_BUFF_ID)
        endmethod
        eventMethod Event_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(true)
            call parent.Event.Add(REVIVE_EVENT)
            call DummyUnit.WORLD_CASTER.Order.UnitTargetInstantly(Order.BANISH, parent)
        endmethod
        method Subtract takes nothing returns nothing
            call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
        endmethod
        method Add takes nothing returns nothing
            call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
        endmethod
        method AddTimed takes real duration returns nothing
            call Unit(this).Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, duration)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(false)
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_BuffLose))
            call thistype.DUMMY_BUFF.Variants.Add(thistype.NORMAL_BUFF)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Revive)
            call DummyUnit.WORLD_CASTER.Abilities.AddBySelf(thistype.BAN_SPELL_ID)
        endmethod
    endstruct
    public struct StructMadness
        implement Allocation
        implement List
        
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(false)
            call parent.Owner.Update()
        endmethod
        eventMethod Event_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(true)
            call parent.Owner.SetNative(User.NEUTRAL_AGGRESSIVE, false)
			call parent.Stop()
        endmethod
        method Subtract takes nothing returns nothing
            call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
        endmethod
        method Add takes nothing returns nothing
            call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
        endmethod
        method AddTimed takes real duration returns nothing
            call Unit(this).Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, duration)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(false)
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_BuffLose))
            call thistype.DUMMY_BUFF.Variants.Add(thistype.NORMAL_BUFF)
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
    public struct StructEclipse
        implement Allocation
        implement List
        
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(false)
        endmethod
        eventMethod Event_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(true)
        endmethod
        method Subtract takes nothing returns nothing
            call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
        endmethod
        method Add takes nothing returns nothing
            call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
        endmethod
        method AddTimed takes real duration returns nothing
            call Unit(this).Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, duration)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(false)
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
    public struct StructWhirl
        implement Allocation
        implement List
        
        static Event REVIVE_EVENT
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        eventMethod Event_Revive
            call DummyUnit.WORLD_CASTER.Order.UnitTargetInstantly(Order.CYCLONE, params.Unit.GetTrigger())
        endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(false)
            call parent.Event.Remove(REVIVE_EVENT)
            call parent.Buffs.RemoveBySelf(thistype.CYCLONE_BUFF_EXTRA_ID)
        endmethod
        eventMethod Event_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(true)
            call parent.Event.Add(REVIVE_EVENT)
            
            
            local real x = parent.Position.X.Get()
            local real y = parent.Position.Y.Get()
            call UnitAddType(parent.self, UNIT_TYPE_SAPPER)
            call DummyUnit.WORLD_CASTER.Order.UnitTargetInstantly(Order.IMPALE, parent)
            call UnitRemoveType(parent.self, UNIT_TYPE_SAPPER)
        endmethod
        method Subtract takes nothing returns nothing
            call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
        endmethod
        method Add takes nothing returns nothing
            call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
        endmethod
        method AddTimed takes real duration returns nothing
            call Unit(this).Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, duration)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(false)
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_BuffLose))
            call thistype.DUMMY_BUFF.Variants.Add(thistype.NORMAL_BUFF)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Revive)
            call DummyUnit.WORLD_CASTER.Abilities.AddBySelf(thistype.CYCLONE_SPELL_ID)
            call DummyUnit.WORLD_CASTER.Abilities.AddBySelf(thistype.IMPALE_SPELL_ID)
        endmethod
    endstruct
    public struct StructFacing
        implement Allocation
        implement List
        
        static real STANDARD = Math.SOUTH_ANGLE
        method Get takes nothing returns real
            return (GetUnitFacing(Unit(this).self) * Math.DEG_TO_RAD)
        endmethod
        method Set takes real value returns nothing
            call SetUnitFacing(Unit(this).self, value * Math.RAD_TO_DEG)
        endmethod
        method SetToUnit takes Unit target returns nothing
            local real targetX = target.Position.X.Get()
            local real targetY = target.Position.Y.Get()
            local real thisX = Unit(this).Position.X.Get()
            local real thisY = Unit(this).Position.Y.Get()
            if ((targetX != thisX) or (targetY != thisY)) then
                call this.Set(Math.AtanByDeltas(targetY - thisY, targetX - thisX))
            endif
        endmethod
    endstruct
    public struct StructBleeding
        implement Allocation
        implement List
        
        static constant real INTERVAL = 1.
        static constant real REL_DMG_PER_INTERVAL = thistype.REL_DMG_PER_SECOND * thistype.INTERVAL
        static constant real REL_DMG_HERO_PER_INTERVAL = thistype.REL_DMG_HERO_PER_SECOND * thistype.INTERVAL
        Unit caster
        Timer intervalTimer
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        timerMethod Interval
            local thistype this = Timer.GetExpired().GetData()
            local Unit target = this
            call target.Effects.Create(target.Blood.Get(), AttachPoint.CHEST, EffectLevel.NORMAL).Destroy()
            if target.Classes.Contains(UnitClass.HERO) then
                call this.caster.DamageUnitBySpell(target, thistype.REL_DMG_HERO_PER_INTERVAL * target.MaxLife.Get(), false, false)
            else
                call this.caster.DamageUnitBySpell(target, thistype.REL_DMG_PER_INTERVAL * target.MaxLife.Get(), false, false)
            endif
        endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
            call this.Set(false)
            call this.intervalTimer.Destroy()
            call parent.Invisibility.Reveal.Subtract()
        endmethod
        eventMethod Event_BuffGain
            local Unit caster = params.Buff.GetData()
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
            call this.Set(true)
			local Timer intervalTimer = Timer.Create()
            set this.caster = caster
            set this.intervalTimer = intervalTimer
            call intervalTimer.SetData(this)
            call parent.Invisibility.Reveal.Add()
            call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(false)
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
			
            call thistype.DUMMY_BUFF.Variants.Add(thistype.NORMAL_BUFF)
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
    public struct StructIgnited
        implement Allocation
        implement List
        
        static constant real INTERVAL = 1.
        static constant real REL_DMG_PER_INTERVAL = thistype.REL_DMG_PER_SECOND * thistype.INTERVAL
        static constant real REL_DMG_HERO_PER_INTERVAL = thistype.REL_DMG_HERO_PER_SECOND * thistype.INTERVAL
        Unit caster
        Timer intervalTimer
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        timerMethod Interval
            local thistype this = Timer.GetExpired().GetData()
            local Unit target = this
            if target.Classes.Contains(UnitClass.HERO) then
                call this.caster.DamageUnitBySpell(target, thistype.REL_DMG_HERO_PER_INTERVAL * target.MaxLife.Get(), true, false)
            else
                call this.caster.DamageUnitBySpell(target, thistype.REL_DMG_PER_INTERVAL * target.MaxLife.Get(), true, false)
            endif
        endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
            call this.Set(false)
            call this.intervalTimer.Destroy()
            call parent.Invisibility.Reveal.Subtract()
        endmethod
        eventMethod Event_BuffGain
            local Unit caster = params.Buff.GetData()
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
            call this.Set(true)
			local Timer intervalTimer = Timer.Create()
            set this.caster = caster
            set this.intervalTimer = intervalTimer
            call intervalTimer.SetData(this)
            call parent.Invisibility.Reveal.Add()
            call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(false)
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            call thistype.DUMMY_BUFF.Variants.Add(thistype.NORMAL_BUFF)
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
    public struct StructKnockup
        implement Allocation
        implement List
        
        static constant real DURATION = 1.
        method Start takes nothing returns nothing
            local real dur = thistype.DURATION
            local real height = 250. * 32. / (16. + Unit(this).CollisionSize.Get(true))
            local real acc = -8 * height / dur / dur
            local real speed = -acc / 2 * dur
            call Unit(this).Position.Timed.Accelerated.AddIn(0., 0., speed, 0., 0., acc, dur)
        endmethod
        initMethod Buff_Init of Header_Buffs
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
    public struct StructPathing
        implement Allocation
        implement List
        
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(true)
            call SetUnitPathing(parent.self, true)
        endmethod
        eventMethod Event_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(false)
            call SetUnitPathing(parent.self, false)
        endmethod
        method Subtract takes nothing returns nothing
            call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
        endmethod
        method Add takes nothing returns nothing
            call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
        endmethod
        method Update takes nothing returns nothing
            call SetUnitPathing(Unit(this).self, this.Is())
        endmethod
        eventMethod Event_TypeChange
            call thistype(params.Unit.GetTrigger()).Update()
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(true)
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
        static method Init takes nothing returns nothing
            call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
        endmethod
    endstruct
    public struct StructPoisoned
        implement Allocation
        implement List
        
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(false)
        endmethod
        eventMethod Event_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(true)
        endmethod
        method Subtract takes nothing returns nothing
            call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
        endmethod
        method Add takes nothing returns nothing
            call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
        endmethod
        method AddTimed takes real duration returns nothing
            call Unit(this).Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, duration)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(false)
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            call thistype.DUMMY_BUFF.Variants.Add(thistype.NORMAL_BUFF)
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
    scope FolderRevival
    public struct StructAble
        implement Allocation
        implement List
        
    integer flag
    method Get takes nothing returns integer
        return this.flag
    endmethod
    method Is takes nothing returns boolean
        return (this.flag > 0)
    endmethod
    method Set takes integer flag returns nothing
        set this.flag = flag
    endmethod
    method Subtract takes nothing returns nothing
        call this.Set(this.Get() - 1)
    endmethod
    method SubtractValue takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Add takes nothing returns nothing
        call this.Set(this.Get() + 1)
    endmethod
    method AddValue takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(Boolean.ToInt(Unit(this).Type.Get().Revivalable.Is()))
    endmethod
            eventMethod Event_TypeChange
                local UnitType sourceType = params.UnitType.GetSource()
                local UnitType targetType = params.UnitType.GetTrigger()
                local thistype this = params.Unit.GetTrigger()
                call this.AddValue(Boolean.ToInt(targetType.Revivalable.Is()) - Boolean.ToInt(sourceType.Revivalable.Is()))
            endmethod
            static method Init takes nothing returns nothing
                call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            endmethod
        endstruct
    public struct StructEvents
        implement Allocation
        implement List
        
            static EventType DUMMY_EVENT_TYPE
            static Trigger DUMMY_TRIGGER
            method TriggerEvents takes nothing returns nothing
                local Unit parent = this
                local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
                call params.Unit.SetTrigger(this)
				local EventResponse unitParams = EventResponse.Create(parent.Id.Get())
                call unitParams.Unit.SetTrigger(this)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = Event.CountAtStatics(thistype.DUMMY_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call Event.GetFromStatics(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration2 = parent.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call parent.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(unitParams)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call params.Destroy()
                call unitParams.Destroy()
            endmethod
            method Start takes nothing returns nothing
                call this.TriggerEvents()
            endmethod
            static method Init takes nothing returns nothing
                set thistype.DUMMY_EVENT_TYPE = EventType.Create()
            endmethod
        endstruct
    endscope
    public struct StructRevival
        implement Allocation
        implement List
        
    FolderRevival_StructAble Able = this
    FolderRevival_StructAble LinkToStruct_Able
    FolderRevival_StructEvents Events = this
    FolderRevival_StructEvents LinkToStruct_Events
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        method Do takes nothing returns boolean
            if not this.Able.Is() then
                return false
            endif
            if not Unit(this).Classes.IsNative(UNIT_TYPE_DEAD) then
                return false
            endif
            local boolean isStructure = Unit(this).Classes.IsNative(UNIT_TYPE_STRUCTURE)
            local User thisOwner = Unit(this).Owner.Get()
            call DummyUnit.WORLD_CASTER.Owner.Set(thisOwner)
            call DummyUnit.WORLD_CASTER.Position.X.Set(Unit(this).Position.X.Get())
            call DummyUnit.WORLD_CASTER.Position.Y.Set(Unit(this).Position.Y.Get())
            call Unit(this).Classes.AddNative(UNIT_TYPE_TAUREN)
            call UnitShareVision(Unit(this).self, thisOwner.self, true)
            local boolean result = DummyUnit.WORLD_CASTER.Order.Immediate(Order.ANCESTRAL_SPIRIT)
            call DummyUnit.WORLD_CASTER.Owner.Set(User.DUMMY)
            call Unit(this).Classes.RemoveNative(UNIT_TYPE_TAUREN)
            if result then
                if isStructure then
                    call ShowUnit(Unit(this).self, false)
                endif
                call this.Set(false)
                call Unit(this).Classes.Remove(UnitClass.DEAD)
                if isStructure then
                    call ShowUnit(Unit(this).self, true)
                endif
                call Unit(this).Life.Set(Unit(this).MaxLife.Get())
                call this.Events.Start()
                return true
            endif
            return false
        endmethod
        method Event_Create takes nothing returns nothing
            set this.flag = false
            call this.Able.Event_Create()
        endmethod
        static method Init takes nothing returns nothing
            call DummyUnit.WORLD_CASTER.Abilities.AddBySelf(thistype.DUMMY_SPELL_ID)
            call thistype(NULL).Able.Init()
            call thistype(NULL).Events.Init()
        endmethod
    endstruct
    public struct StructSilence
        implement Allocation
        implement List
        
        static Event REVIVE_EVENT
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        eventMethod Event_Revive
            call DummyUnit.WORLD_CASTER.Order.UnitTargetInstantly(Order.SOULBURN, params.Unit.GetTrigger())
        endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(false)
            call parent.Event.Remove(REVIVE_EVENT)
            call parent.Buffs.RemoveBySelf(thistype.SIL_BUFF_ID)
        endmethod
        eventMethod Event_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(true)
            call parent.Event.Add(REVIVE_EVENT)
            call DummyUnit.WORLD_CASTER.Order.UnitTargetInstantly(Order.SOULBURN, parent)
        endmethod
        method Subtract takes nothing returns nothing
            call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
        endmethod
        method Add takes nothing returns nothing
            call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
        endmethod
        method AddTimed takes real duration returns nothing
            call Unit(this).Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, duration)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(false)
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_BuffLose))
            call thistype.DUMMY_BUFF.Variants.Add(thistype.NORMAL_BUFF)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Revive)
            call DummyUnit.WORLD_CASTER.Abilities.AddBySelf(thistype.SIL_SPELL_ID)
        endmethod
    endstruct
    public struct StructSleep
        implement Allocation
        implement List
        
        static Event DAMAGE_EVENT
        static EventType ENDING_EVENT_TYPE
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        eventMethod Event_Damage
            call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
        endmethod
        method Ending_TriggerEvents takes nothing returns nothing
            local Unit parent = this
            local EventResponse params = EventResponse.Create(parent.Id.Get())
            call params.Unit.SetTrigger(this)
			local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = parent.Event.Count(thistype.ENDING_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call parent.Event.Get(thistype.ENDING_EVENT_TYPE, priority, iteration2).Run(params)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            call params.Destroy()
        endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(false)
            call parent.Event.Remove(DAMAGE_EVENT)
            call parent.Stun.Subtract()
            call parent.Buffs.RemoveBySelf(thistype.PAUSE_BUFF_ID)
            call parent.Buffs.RemoveBySelf(thistype.SLEEP_BUFF_ID)
            call thistype(parent).Ending_TriggerEvents()
        endmethod
        eventMethod Event_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
            call thistype(parent).Set(true)
            call parent.Event.Add(DAMAGE_EVENT)
            call parent.Stun.Add()
            call DummyUnit.WORLD_CASTER.Order.UnitTargetInstantly(Order.SLEEP, parent)
            call parent.Buffs.RemoveBySelf(thistype.PAUSE_BUFF_ID)
        endmethod
        method Subtract takes nothing returns nothing
            call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
        endmethod
        method Add takes nothing returns nothing
            call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
        endmethod
        method AbortTimed takes nothing returns nothing
            call Unit(this).Buffs.Timed.EndingByParent(thistype.DUMMY_BUFF)
        endmethod
        method AddTimed takes real duration returns nothing
            call Unit(this).Buffs.Timed.Do(thistype.DUMMY_BUFF, NULL, duration)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(false)
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_BuffLose))
            call thistype.DUMMY_BUFF.Variants.Add(thistype.NORMAL_BUFF)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Damage)
            set thistype.ENDING_EVENT_TYPE = EventType.Create()
            call DummyUnit.WORLD_CASTER.Abilities.AddBySelf(thistype.SLEEP_SPELL_ID)
        endmethod
    endstruct
    scope FolderStun
    public struct StructCancel
        implement Allocation
        implement List
        
            static Event DEATH_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
            Timer delayTimer
            Unit parent
            method Ending takes Timer delayTimer, Unit parent returns nothing
                call this.deallocate()
                call delayTimer.Destroy()
                call parent.Data.Integer.Remove(KEY)
                call parent.Event.Remove(DEATH_EVENT)
                call parent.Buffs.RemoveBySelf(UNIT.Stun.STUN_BUFF_ID)
            endmethod
            eventMethod Event_Death
                local Unit parent = params.Unit.GetTrigger()
                local thistype this = parent.Data.Integer.Get(KEY)
                call this.Ending(this.delayTimer, parent)
            endmethod
            timerMethod EndingByTimer
                local Timer delayTimer = Timer.GetExpired()
                local thistype this = delayTimer.GetData()
                call this.Ending(delayTimer, this.parent)
            endmethod
            eventMethod Event_Order
                local Unit parent = params.Unit.GetTrigger()
                local thistype this = parent.Data.Integer.Get(KEY)
                if not parent.Stun.Is() then
                    if (parent.Data.Integer.Get(KEY) == NULL) then
                        set this = thistype.allocate()
                        local Timer delayTimer = Timer.Create()
                        set this.delayTimer = delayTimer
                        set this.parent = parent
                        call delayTimer.SetData(this)
                        call parent.Data.Integer.Set(KEY, this)
                        call parent.Event.Add(DEATH_EVENT)
                        call delayTimer.Start(0., false, function thistype.EndingByTimer)
                    endif
                endif
            endmethod
            static method Init takes nothing returns nothing
                set DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Order)
                call Order.STUNNED.Event.Add(Event.Create(UNIT.Order.Events.Gain.Target.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Order))
            endmethod
        endstruct
    endscope
    public struct StructStun
        implement Allocation
        implement List
        
        static UnitState STATE
    FolderStun_StructCancel Cancel = this
    FolderStun_StructCancel LinkToStruct_Cancel
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(false)
            call parent.Buffs.RemoveBySelf(thistype.STUN_BUFF_ID)
        endmethod
        eventMethod Event_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Set(true)
            call DummyUnit.WORLD_CASTER.Order.UnitTargetInstantly(Order.THUNDER_BOLT, parent)
        endmethod
        method Subtract takes nothing returns nothing
            call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
        endmethod
        method Add takes nothing returns nothing
            call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
        endmethod
        method AddTimed takes real duration returns nothing
            call Unit(this).Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, duration)
        endmethod
        method AddTimedBy takes Buff whichBuff, real duration returns nothing
            call Unit(this).Buffs.Timed.Start(whichBuff, 1, duration)
        endmethod
        method Change takes boolean val returns nothing
            if val then
                call this.Add()
            else
                call this.Subtract()
            endif
        endmethod
        eventMethod Event_State
            call thistype(params.Unit.GetTrigger()).Change(params.Bool.GetVal())
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(false)
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_BuffLose))
            call thistype.DUMMY_BUFF.Variants.Add(thistype.NORMAL_BUFF)
        endmethod
        static method Init takes nothing returns nothing
            call DummyUnit.WORLD_CASTER.Abilities.AddBySelf(thistype.STUN_SPELL_ID)
            set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            call thistype(NULL).Cancel.Init()
        endmethod
    endstruct
    scope FolderAnimation
    public struct StructLoop
        implement Allocation
        implement List
        
            static Event DEATH_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static constant real UPDATE_TIME = FRAME_UPDATE_TIME * 32
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = 32
            static Timer UPDATE_TIMER
            Unit parent
            string whichAnimation
            timerMethod Update
                local integer iteration = thistype.ALL_COUNT
                loop
                    local thistype this = thistype.ALL[iteration]
                    call this.parent.Animation.Queue(this.whichAnimation)
                    set iteration = iteration - 1
                    exitwhen (iteration < ARRAY_MIN)
                endloop
            endmethod
            method Ending takes Unit parent returns nothing
                call this.deallocate()
                call parent.Data.Integer.Remove(KEY)
                call parent.Event.Remove(DEATH_EVENT)
                if this.RemoveFromList() then
                    call thistype.UPDATE_TIMER.Pause()
                endif
                call this.parent.Animation.Reset()
            endmethod
            method Abort takes nothing returns nothing
                local Unit parent = this
                set this = parent.Data.Integer.Get(KEY)
                if (this != NULL) then
                    call this.Ending(parent)
                endif
            endmethod
            eventMethod Event_Death
                local Unit parent = params.Unit.GetTrigger()
                local thistype this = parent.Data.Integer.Get(KEY)
                call this.Ending(parent)
            endmethod
            method Start takes string whichAnimation returns nothing
                local Unit parent = this
                call thistype(parent).Abort()
                set this = thistype.allocate()
                set this.parent = parent
                set this.whichAnimation = whichAnimation
                call parent.Data.Integer.Set(KEY, this)
                call parent.Event.Add(DEATH_EVENT)
                if this.AddToList() then
                    call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
                endif
                call parent.Animation.Set(whichAnimation)
            endmethod
            static method Init takes nothing returns nothing
                set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Death)
                set thistype.UPDATE_TIMER = Timer.Create()
            endmethod
        endstruct
    public struct StructSpeed
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call SetUnitTimeScale(Unit(this).self, value)
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(1.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    endscope
    public struct StructAnimation
        implement Allocation
        implement List
        
        static constant string ALTERNATE = "alternate"
        static constant string ATTACK = "attack"
        static constant string BIRTH = "birth"
        static constant string MORPH = "morph"
        static constant string SPELL = "spell"
        static constant string SPELL_SLAM = "spell slam"
        static constant string STAND = "stand"
        static constant string SWIM = "swim"
        static constant string WORK = "work"
    FolderAnimation_StructLoop Loop = this
    FolderAnimation_StructLoop LinkToStruct_Loop
    FolderAnimation_StructSpeed Speed = this
    FolderAnimation_StructSpeed LinkToStruct_Speed
        method Remove takes string whichAnimation returns nothing
            call AddUnitAnimationProperties(Unit(this).self, whichAnimation, false)
            call Unit(this).Color.Update()
        endmethod
        method Queue takes string whichAnimation returns nothing
            call QueueUnitAnimation(Unit(this).self, whichAnimation)
        endmethod
        method Set takes string whichAnimation returns nothing
            call SetUnitAnimation(Unit(this).self, whichAnimation)
        endmethod
        method Reset takes nothing returns nothing
            call this.Loop.Abort()
            call this.Set(Animation.STAND)
            call this.Queue(Animation.STAND)
        endmethod
        method Add takes string whichAnimation returns nothing
            call AddUnitAnimationProperties(Unit(this).self, whichAnimation, true)
            call Unit(this).Color.Update()
        endmethod
        method SetByIndex takes integer whichAnimation returns nothing
            call SetUnitAnimationByIndex(Unit(this).self, whichAnimation)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Speed.Event_Create()
        endmethod
        static method Init takes nothing returns nothing
            call thistype(NULL).Loop.Init()
        endmethod
    endstruct
    public struct StructSkillPoints
        implement Allocation
        implement List
        
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
        method AddNative takes integer value returns nothing
            if (value == 0) then
                return
            endif
            call UnitModifySkillPoints(Unit(this).self, value)
        endmethod
        method Set takes integer value returns nothing
            local integer oldValue = this.Get()
            set this.value = value
            call UnitModifySkillPoints(Unit(this).self, value - oldValue)
        endmethod
        method UpdateByLearn takes nothing returns nothing
            set this.value = GetHeroSkillPoints(Unit(this).self) - 1
        endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0
            call this.AddNative(-GetHeroSkillPoints(Unit(this).self))
        endmethod
    endstruct
    scope FolderSpellPower
    public struct StructBase
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).SpellPower.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_TypeChange
                local UnitType sourceType = params.UnitType.GetSource()
                local UnitType targetType = params.UnitType.GetTrigger()
                local thistype this = params.Unit.GetTrigger()
                call this.Add(targetType.SpellPower.Get() - sourceType.SpellPower.Get())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = Unit(this).Type.Get().SpellPower.Get()
            endmethod
            static method Init takes nothing returns nothing
                call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            endmethod
        endstruct
    public struct StructBonus
        implement Allocation
        implement List
        
            static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).SpellPower.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    public struct StructRelative
        implement Allocation
        implement List
        
            static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).SpellPower.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 1.
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    endscope
    public struct StructSpellPower
        implement Allocation
        implement List
        
        static constant real SCALE_FACTOR = 1. / 10.
    FolderSpellPower_StructBase Base = this
    FolderSpellPower_StructBase LinkToStruct_Base
    FolderSpellPower_StructBonus Bonus = this
    FolderSpellPower_StructBonus LinkToStruct_Bonus
    FolderSpellPower_StructRelative Relative = this
    FolderSpellPower_StructRelative LinkToStruct_Relative
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        real bonusVal
        method GetBonus takes nothing returns real
            return this.bonusVal
        endmethod
        static method GetDamageFactor takes real value returns real
            if (value < 0.) then
                return (2. - Math.Power((1. - Attack.ARMOR_REDUCTION_FACTOR), -value * thistype.SCALE_FACTOR))
            endif
            return (1. / (1. + Attack.ARMOR_REDUCTION_FACTOR * value * thistype.SCALE_FACTOR))
        endmethod
        method Set takes real value returns nothing
            set this.bonusVal = value - this.Base.Get()
            set this.value = value
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.Base.Get() * this.Relative.Get() + this.Bonus.Get())
        endmethod
        method Event_Create takes nothing returns nothing
            set this.bonusVal = 0.
            set this.value = 0.
            call this.Base.Event_Create()
            call this.Bonus.Event_Create()
            call this.Relative.Event_Create()
            call this.Update()
        endmethod
        static method Init takes nothing returns nothing
            call thistype(NULL).Base.Init()
            call thistype(NULL).Bonus.Init()
            call thistype(NULL).Relative.Init()
        endmethod
    endstruct
    scope FolderSpellVamp
    public struct StructBase
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).SpellVamp.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_TypeChange
                local UnitType sourceType = params.UnitType.GetSource()
                local UnitType targetType = params.UnitType.GetTrigger()
                local thistype this = params.Unit.GetTrigger()
                call this.Add(targetType.SpellVamp.Get() - sourceType.SpellVamp.Get())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = Unit(this).Type.Get().SpellVamp.Get()
            endmethod
            static method Init takes nothing returns nothing
                call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            endmethod
        endstruct
    public struct StructBonus
        implement Allocation
        implement List
        
            static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).SpellVamp.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    public struct StructRelative
        implement Allocation
        implement List
        
            static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).SpellVamp.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 1.
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    endscope
    public struct StructSpellVamp
        implement Allocation
        implement List
        
    FolderSpellVamp_StructBase Base = this
    FolderSpellVamp_StructBase LinkToStruct_Base
    FolderSpellVamp_StructBonus Bonus = this
    FolderSpellVamp_StructBonus LinkToStruct_Bonus
    FolderSpellVamp_StructRelative Relative = this
    FolderSpellVamp_StructRelative LinkToStruct_Relative
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        real bonusAllVal
        method GetBonusAll takes nothing returns real
            return this.bonusAllVal
        endmethod
    static key GetKeyMacro_TEXT_TAG_KEY_ARRAY
    static constant integer TEXT_TAG_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_TEXT_TAG_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        method Do takes real amount, boolean crit returns nothing
            set amount = amount * this.Get()
            if (amount <= 0.) then
                return
            endif
            call Unit(this).ReplaceRisingTextTagIfMinorValue(String.Color.Gradient("~" + Real.ToIntString(amount) + String.If(crit, Char.EXCLAMATION_MARK) + "~", Unit(this).Owner.Get().GetColorString(), String.Color.LIGHT_SEA_GREEN), Math.Linear(amount, Unit(this).MaxLife.Get() / 2., 0.016, 0.022), 160., 0., 1., thistype.TEXT_TAG_KEY_ARRAY + this, amount / 2)
            call Unit(this).Life.Add(amount)
        endmethod
        method Set takes real value returns nothing
            set this.bonusAllVal = value - this.Base.Get()
            set this.value = value
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.Base.Get() * this.Relative.Get() + this.Bonus.Get())
        endmethod
        method Event_Create takes nothing returns nothing
            set this.bonusAllVal = 0.
            set this.value = 0.
            call this.Base.Event_Create()
            call this.Bonus.Event_Create()
            call this.Relative.Event_Create()
            call this.Update()
        endmethod
        static method Init takes nothing returns nothing
            call thistype(NULL).Base.Init()
            call thistype(NULL).Bonus.Init()
            call thistype(NULL).Relative.Init()
        endmethod
    endstruct
    scope FolderMaxRage
    public struct StructBase
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).MaxRage.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
        endstruct
    public struct StructBonus
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).MaxRage.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
        endstruct
    public struct StructRelative
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).MaxRage.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 1.
            endmethod
        endstruct
    endscope
    public struct StructMaxRage
        implement Allocation
        implement List
        
    FolderMaxRage_StructBase Base = this
    FolderMaxRage_StructBase LinkToStruct_Base
    FolderMaxRage_StructBonus Bonus = this
    FolderMaxRage_StructBonus LinkToStruct_Bonus
    FolderMaxRage_StructRelative Relative = this
    FolderMaxRage_StructRelative LinkToStruct_Relative
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method Set takes real value returns nothing
            local real oldValue = this.Get()
            set this.value = value
            if (oldValue == 0.) then
                return
            endif
            call Unit(this).Rage.Set(Unit(this).Rage.Get() / oldValue * value)
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.Base.Get() * this.Relative.Get() + this.Bonus.Get())
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0.
            call this.Base.Event_Create()
            call this.Bonus.Event_Create()
            call this.Relative.Event_Create()
            call this.Update()
        endmethod
    endstruct
    public struct StructRage
        implement Allocation
        implement List
        
    	static Event ATTACK_EVENT
        static Event DESTROY_EVENT
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method Set takes real value returns nothing
            local real max = Unit(this).MaxRage.Get()
            local real oldValue = this.Get()
            set value = Math.Limit(value, 0., Unit(this).MaxRage.Get())
            set this.value = value
            call Unit(this).CriticalChance.Bonus.Add(value - oldValue)
            call Unit(this).EvasionChance.Bonus.Add(value - oldValue)
        endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        eventMethod Event_Attack
        	local Unit parent = params.Unit.GetTrigger()
            call thistype(parent).Add(1)
        endmethod
        eventMethod Event_Destroy
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
			call parent.Event.Remove(ATTACK_EVENT)
            call parent.Event.Remove(DESTROY_EVENT)
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = Unit(this).MaxRage.Get()
            call Unit(this).Event.Add(ATTACK_EVENT)
            call Unit(this).Event.Add(DESTROY_EVENT)
        endmethod
        static method Init takes nothing returns nothing
        	set thistype.ATTACK_EVENT = Event.Create(UNIT.Attack.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Attack)
            set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
        endmethod
    endstruct
    scope FolderRageRegeneration
    public struct StructBase
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).RageRegeneration.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = -1.
            endmethod
        endstruct
    public struct StructBonus
        implement Allocation
        implement List
        
            static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).RageRegeneration.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    public struct StructRelative
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).RageRegeneration.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 1.
            endmethod
        endstruct
    endscope
    public struct StructRageRegeneration
        implement Allocation
        implement List
        
        static Event DESTROY_EVENT
        static constant real UPDATE_TIME = 0.25
        static Timer UPDATE_TIMER
        real valuePerUpdate
    FolderRageRegeneration_StructBase Base = this
    FolderRageRegeneration_StructBase LinkToStruct_Base
    FolderRageRegeneration_StructBonus Bonus = this
    FolderRageRegeneration_StructBonus LinkToStruct_Bonus
    FolderRageRegeneration_StructRelative Relative = this
    FolderRageRegeneration_StructRelative LinkToStruct_Relative
    static thistype array ACTIVE_LIST_ALL
    static integer ACTIVE_LIST_ALL_COUNT = ARRAY_EMPTY
    integer ACTIVE_LIST_index
    static method ACTIVE_LIST_Count takes nothing returns integer
        return thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static method ACTIVE_LIST_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Get takes integer index returns thistype
        return thistype.ACTIVE_LIST_ALL[index]
    endmethod
    static method ACTIVE_LIST_GetIndex takes thistype this returns integer
        return this.ACTIVE_LIST_index
    endmethod
    static method ACTIVE_LIST_Contains takes thistype this returns boolean
        return (thistype.ACTIVE_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ACTIVE_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ACTIVE_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ACTIVE_LIST_RandomAll takes nothing returns thistype
        return thistype.ACTIVE_LIST_Random(ARRAY_MIN, thistype.ACTIVE_LIST_ALL_COUNT)
    endmethod
    static method ACTIVE_LIST_Remove takes thistype this returns boolean
        if not thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT].ACTIVE_LIST_index = this.ACTIVE_LIST_index
        set thistype.ACTIVE_LIST_ALL[this.ACTIVE_LIST_index - 1] = thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT]
        set this.ACTIVE_LIST_index = ARRAY_MIN
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT - 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Add takes thistype this returns boolean
        if thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT + 1
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT] = this
        set this.ACTIVE_LIST_index = thistype.ACTIVE_LIST_ALL_COUNT + 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static thistype array FOR_EACH_LIST_ALL
    static integer FOR_EACH_LIST_ALL_COUNT = ARRAY_EMPTY
    static method FOR_EACH_LIST_FetchFirst takes nothing returns thistype
        local thistype result
        if (thistype.FOR_EACH_LIST_ALL_COUNT < ARRAY_MIN) then
            return NULL
        endif
        set result = thistype.FOR_EACH_LIST_ALL[ARRAY_MIN]
        set thistype.FOR_EACH_LIST_ALL[ARRAY_MIN] = thistype.FOR_EACH_LIST_ALL[thistype.FOR_EACH_LIST_ALL_COUNT]
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.FOR_EACH_LIST_ALL_COUNT - 1
        return result
    endmethod
    static method FOR_EACH_LIST_Set takes nothing returns nothing
        local integer iteration = thistype.ACTIVE_LIST_ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.FOR_EACH_LIST_ALL[iteration] = thistype.ACTIVE_LIST_ALL[iteration]
            set iteration = iteration - 1
        endloop
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        eventMethod Event_Destroy
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
            if thistype.ACTIVE_LIST_Remove(this) then
                call thistype.UPDATE_TIMER.Pause()
            endif
            call parent.Event.Remove(DESTROY_EVENT)
        endmethod
        timerMethod UpdateByTimer
            call thistype.FOR_EACH_LIST_Set()
            loop
                local thistype this = thistype.FOR_EACH_LIST_FetchFirst()
                exitwhen (this == NULL)
                call Unit(this).Rage.Add(this.valuePerUpdate)
            endloop
        endmethod
        method Set takes real value returns nothing
            set this.value = value
            set this.valuePerUpdate = value * thistype.UPDATE_TIME
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.Base.Get() * this.Relative.Get() + this.Bonus.Get())
        endmethod
        method Event_Create takes nothing returns nothing
            call Unit(this).Event.Add(DESTROY_EVENT)
            if thistype.ACTIVE_LIST_Add(this) then
                call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.UpdateByTimer)
            endif
            call this.Base.Event_Create()
            call this.Bonus.Event_Create()
            call this.Relative.Event_Create()
            call this.Update()
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
            set thistype.UPDATE_TIMER = Timer.Create()
            call thistype(NULL).Bonus.Init()
        endmethod
    endstruct
    scope FolderMaxStamina
    public struct StructBase
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).MaxStamina.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 200.
            endmethod
        endstruct
    public struct StructBonus
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).MaxStamina.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
        endstruct
    public struct StructRelative
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).MaxStamina.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 1.
            endmethod
        endstruct
    endscope
    public struct StructMaxStamina
        implement Allocation
        implement List
        
    FolderMaxStamina_StructBase Base = this
    FolderMaxStamina_StructBase LinkToStruct_Base
    FolderMaxStamina_StructBonus Bonus = this
    FolderMaxStamina_StructBonus LinkToStruct_Bonus
    FolderMaxStamina_StructRelative Relative = this
    FolderMaxStamina_StructRelative LinkToStruct_Relative
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method Set takes real value returns nothing
            local real oldValue = this.Get()
            set this.value = value
            if (oldValue == 0.) then
                return
            endif
            call Unit(this).Stamina.Set(Unit(this).Stamina.Get() / oldValue * value)
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.Base.Get() * this.Relative.Get() + this.Bonus.Get())
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0.
            call this.Base.Event_Create()
            call this.Bonus.Event_Create()
            call this.Relative.Event_Create()
            call this.Update()
        endmethod
    endstruct
    scope FolderStamina
    public struct StructExhaustion
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
            static constant real SPEED_REL_INC = -0.5
            static constant string TEXT = "exhausted"
            eventMethod Event_BuffLose
                
            endmethod
            eventMethod Event_BuffGain
                
            endmethod
            method Subtract takes nothing returns nothing
                call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
            endmethod
            method Add takes nothing returns nothing
                call Unit(this).AddJumpingTextTag(String.Color.Do(thistype.TEXT, String.Color.WHITE), 0.021, KEY_ARRAY + this)
                call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
            endmethod
            initMethod Buff_Init of Header_Buffs
                
                
            endmethod
            static method Init takes nothing returns nothing
            endmethod
        endstruct
    endscope
    public struct StructStamina
        implement Allocation
        implement List
        
        static Event DESTROY_EVENT
        static real EXHAUSTION_LIMIT = 0.2
        static constant real INTERVAL = 0.125
        static constant real LOST_VALUE_PER_SECOND = 20.
        static Event MOVE_EVENT
        static constant real LOST_VALUE_PER_INTERVAL = thistype.LOST_VALUE_PER_SECOND * thistype.INTERVAL
    FolderStamina_StructExhaustion Exhaustion = this
    FolderStamina_StructExhaustion LinkToStruct_Exhaustion
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        method GetFactor takes nothing returns real
            local real max = Unit(this).MaxStamina.Get()
            if (max > 0) then
                return (this.Get() / max)
            endif
            return 1.
        endmethod
        method Set takes real value returns nothing
            local real max = Unit(this).MaxStamina.Get()
            local real oldValue = this.Get()
            set value = Math.Limit(value, 0., Unit(this).MaxStamina.Get())
            set this.value = value
            call Unit(this).Movement.Speed.UpdateNative()
            if (max <= 0) then
                return
            endif
            if (((value / max) > thistype.EXHAUSTION_LIMIT) == ((oldValue / max) > thistype.EXHAUSTION_LIMIT)) then
                return
            endif
            if ((value / max) > thistype.EXHAUSTION_LIMIT) then
                call this.Exhaustion.Subtract()
            else
                call this.Exhaustion.Add()
            endif
        endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        eventMethod Event_Move
            local thistype this = params.Unit.GetTrigger()
            local real value = Math.Max(0., this.Get() - thistype.LOST_VALUE_PER_INTERVAL)
            call this.Set(value)
        endmethod
        eventMethod Event_Destroy
            local Unit parent = params.Unit.GetTrigger()
            call parent.Event.Remove(DESTROY_EVENT)
            call parent.Movement.Events.Interval.Remove(MOVE_EVENT)
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = Unit(this).MaxStamina.Get()
            call Unit(this).Event.Add(DESTROY_EVENT)
            call Unit(this).Movement.Events.Interval.Add(MOVE_EVENT, thistype.INTERVAL)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
            set thistype.MOVE_EVENT = Event.Create(NULL, NULL, function thistype.Event_Move)
            call thistype(NULL).Exhaustion.Init()
        endmethod
    endstruct
    scope FolderStaminaRegeneration
    public struct StructBase
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).StaminaRegeneration.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 25.
            endmethod
        endstruct
    public struct StructBonus
        implement Allocation
        implement List
        
            static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).StaminaRegeneration.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            eventMethod Event_State
                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
            static method Init takes nothing returns nothing
                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
            endmethod
        endstruct
    public struct StructRelative
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).StaminaRegeneration.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 1.
            endmethod
        endstruct
    endscope
    public struct StructStaminaRegeneration
        implement Allocation
        implement List
        
        static Event DESTROY_EVENT
        static Event MOVE_ENDING_EVENT
        static Event MOVE_START_EVENT
        static constant real UPDATE_TIME = 0.25
        static Timer UPDATE_TIMER
        real valuePerUpdate
    FolderStaminaRegeneration_StructBase Base = this
    FolderStaminaRegeneration_StructBase LinkToStruct_Base
    FolderStaminaRegeneration_StructBonus Bonus = this
    FolderStaminaRegeneration_StructBonus LinkToStruct_Bonus
    FolderStaminaRegeneration_StructRelative Relative = this
    FolderStaminaRegeneration_StructRelative LinkToStruct_Relative
    static thistype array ACTIVE_LIST_ALL
    static integer ACTIVE_LIST_ALL_COUNT = ARRAY_EMPTY
    integer ACTIVE_LIST_index
    static method ACTIVE_LIST_Count takes nothing returns integer
        return thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static method ACTIVE_LIST_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Get takes integer index returns thistype
        return thistype.ACTIVE_LIST_ALL[index]
    endmethod
    static method ACTIVE_LIST_GetIndex takes thistype this returns integer
        return this.ACTIVE_LIST_index
    endmethod
    static method ACTIVE_LIST_Contains takes thistype this returns boolean
        return (thistype.ACTIVE_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ACTIVE_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ACTIVE_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ACTIVE_LIST_RandomAll takes nothing returns thistype
        return thistype.ACTIVE_LIST_Random(ARRAY_MIN, thistype.ACTIVE_LIST_ALL_COUNT)
    endmethod
    static method ACTIVE_LIST_Remove takes thistype this returns boolean
        if not thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT].ACTIVE_LIST_index = this.ACTIVE_LIST_index
        set thistype.ACTIVE_LIST_ALL[this.ACTIVE_LIST_index - 1] = thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT]
        set this.ACTIVE_LIST_index = ARRAY_MIN
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT - 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Add takes thistype this returns boolean
        if thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT + 1
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT] = this
        set this.ACTIVE_LIST_index = thistype.ACTIVE_LIST_ALL_COUNT + 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static thistype array FOR_EACH_LIST_ALL
    static integer FOR_EACH_LIST_ALL_COUNT = ARRAY_EMPTY
    static method FOR_EACH_LIST_FetchFirst takes nothing returns thistype
        local thistype result
        if (thistype.FOR_EACH_LIST_ALL_COUNT < ARRAY_MIN) then
            return NULL
        endif
        set result = thistype.FOR_EACH_LIST_ALL[ARRAY_MIN]
        set thistype.FOR_EACH_LIST_ALL[ARRAY_MIN] = thistype.FOR_EACH_LIST_ALL[thistype.FOR_EACH_LIST_ALL_COUNT]
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.FOR_EACH_LIST_ALL_COUNT - 1
        return result
    endmethod
    static method FOR_EACH_LIST_Set takes nothing returns nothing
        local integer iteration = thistype.ACTIVE_LIST_ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.FOR_EACH_LIST_ALL[iteration] = thistype.ACTIVE_LIST_ALL[iteration]
            set iteration = iteration - 1
        endloop
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
        timerMethod UpdateByTimer
            call thistype.FOR_EACH_LIST_Set()
            loop
                local thistype this = thistype.FOR_EACH_LIST_FetchFirst()
                exitwhen (this == NULL)
                call Unit(this).Stamina.Add(this.valuePerUpdate)
            endloop
        endmethod
        eventMethod Event_MoveEnding
            call thistype.ACTIVE_LIST_Add(params.Unit.GetTrigger())
        endmethod
        eventMethod Event_MoveStart
            call thistype.ACTIVE_LIST_Remove(params.Unit.GetTrigger())
        endmethod
        method Set takes real value returns nothing
            set this.value = value
            set this.valuePerUpdate = value * thistype.UPDATE_TIME
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.Base.Get() * this.Relative.Get() + this.Bonus.Get())
        endmethod
        eventMethod Event_Destroy
            local Unit parent = params.Unit.GetTrigger()
            if thistype.ACTIVE_LIST_Remove(parent) then
                call thistype.UPDATE_TIMER.Pause()
            endif
            call parent.Event.Remove(DESTROY_EVENT)
            call parent.Movement.Events.Unreg(MOVE_ENDING_EVENT)
            call parent.Movement.Events.Unreg(MOVE_START_EVENT)
        endmethod
        method Event_Create takes nothing returns nothing
            call Unit(this).Event.Add(DESTROY_EVENT)
            call Unit(this).Movement.Events.Reg(MOVE_ENDING_EVENT)
            call Unit(this).Movement.Events.Reg(MOVE_START_EVENT)
            if thistype.ACTIVE_LIST_Add(this) then
                call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.UpdateByTimer)
            endif
            call this.Base.Event_Create()
            call this.Bonus.Event_Create()
            call this.Relative.Event_Create()
            call this.Update()
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
            set thistype.MOVE_ENDING_EVENT = Event.Create(UNIT.Movement.Events.ENDING_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_MoveEnding)
            set thistype.MOVE_START_EVENT = Event.Create(UNIT.Movement.Events.START_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_MoveStart)
            set thistype.UPDATE_TIMER = Timer.Create()
            call thistype(NULL).Bonus.Init()
        endmethod
    endstruct
    scope FolderBars
    public struct StructExpiringCondition
        implement Allocation
        implement List
        
		
		endstruct
	endscope
    public struct StructBars
        implement Allocation
        implement List
        
        static Event CAST_EVENT
        static Event DESTROY_EVENT
        static Event END_CAST_EVENT
        static constant real DISPLAY_MAX = 0.15
        static constant real DISPLAY_MAX_TRESHOLD = 0.9
        static constant real DISPLAY_MIN = 1.
        static constant real DISPLAY_MIN_TRESHOLD = 0.7
        static constant real HEIGHT = 175.
    static constant real UPDATE_TIME = (1 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (1 * 1.))
        static Timer UPDATE_TIMER
        static constant real WIDTH = 60.
        static constant real UPDATE_LENGTH = 0.5 * thistype.UPDATE_TIME
        
        static constant real DISPLAY_ELEV = (thistype.DISPLAY_MAX - thistype.DISPLAY_MIN) / (thistype.DISPLAY_MAX_TRESHOLD - thistype.DISPLAY_MIN_TRESHOLD)
        
        static constant real DISPLAY_OFFSET = (thistype.DISPLAY_MIN / thistype.DISPLAY_MIN_TRESHOLD - thistype.DISPLAY_MAX / thistype.DISPLAY_MAX_TRESHOLD) / (1 / thistype.DISPLAY_MIN_TRESHOLD - 1 / thistype.DISPLAY_MAX_TRESHOLD)
        lightning channelBar
        lightning channelJuice
        Timer channelTimer
        
        
        
        lightning manaBar
        real manaDisplayed
        lightning manaJuice
        lightning rageBar
        real rageDisplayed
        lightning rageJuice
        lightning staminaBar
        real staminaDisplayed
        lightning staminaJuice
    FolderBars_StructExpiringCondition ExpiringCondition = this
    FolderBars_StructExpiringCondition LinkToStruct_ExpiringCondition
        timerMethod Update
            local real angle = GetCameraField(CAMERA_FIELD_ROTATION) - Math.QUARTER_ANGLE
            local real xPart = Math.Cos(angle)
            local real yPart = Math.Sin(angle)
			local integer iteration = thistype.ALL_COUNT
            loop
                local thistype this = thistype.ALL[iteration]
                if Unit(this).Classes.Contains(UnitClass.DEAD) then
                    
                    set this.manaDisplayed = 0.
                    set this.staminaDisplayed = 0.
                   
                    call MoveLightningEx(this.manaBar, false, 0., 0., 0., 0., 0., 0.)
                    call MoveLightningEx(this.manaJuice, false, 0., 0., 0., 0., 0., 0.)
                    call MoveLightningEx(this.staminaBar, false, 0., 0., 0., 0., 0., 0.)
                    call MoveLightningEx(this.staminaJuice, false, 0., 0., 0., 0., 0., 0.)
                else
                    local real height = Unit(this).Position.Z.Get() + thistype.HEIGHT * Unit(this).Scale.Get()
                    local real x = Unit(this).Position.X.Get()
                    local real xOffset = thistype.WIDTH * xPart
                    local real y = Unit(this).Position.Y.Get()
                    local real yOffset = thistype.WIDTH * yPart
					local real oldRelative
                    local real relative
                    local real val
                    local real maxVal
					set relative = this.channelTimer.GetTimeout()
                    if (relative > 0.) then
                        set relative = this.channelTimer.GetRemaining() / relative
                        call MoveLightningEx(this.channelBar, false, x - xOffset*1.5, y - yOffset*1.5, height+75, x + xOffset*1.5, y + yOffset*1.5, height+75)
                        call SetLightningColor(this.channelBar, 1., 1., 1., 1.)
                        call MoveLightningEx(this.channelJuice, false, x - xOffset*1.5, y - yOffset*1.5, height+75, x + (relative * 2 - 1) * xOffset*1.5, y + (relative * 2 - 1) * yOffset*1.5, height+75)
                        call SetLightningColor(this.channelJuice, 0., 0.75, 1., 1.)
                    endif
                   
					set oldRelative = this.manaDisplayed
					set maxVal = Unit(this).MaxMana.Get()
					set val = Unit(this).Mana.Get()
					if (maxVal > 0.) then
                    	set relative = val / maxVal
                    else
                        set relative = 0.
                    endif
					if (relative > oldRelative) then
						set relative = Math.Min(oldRelative + thistype.UPDATE_LENGTH, relative)
					else
						set relative = Math.Max(oldRelative - thistype.UPDATE_LENGTH, relative)
					endif
                    set this.manaDisplayed = relative
                    if (relative > thistype.DISPLAY_MAX_TRESHOLD) then
                        call MoveLightningEx(this.manaBar, false, 0., 0., 0., 0., 0., 0.)
                        call MoveLightningEx(this.manaJuice, false, 0., 0., 0., 0., 0., 0.)
                    else
                        call MoveLightningEx(this.manaBar, false, x - xOffset, y - yOffset, height+50, x + xOffset, y + yOffset, height+50)
                        call SetLightningColor(this.manaBar, 1., 1., 1., Math.Limit(thistype.DISPLAY_ELEV * relative + thistype.DISPLAY_OFFSET, Math.Min(thistype.DISPLAY_MIN, thistype.DISPLAY_MAX), Math.Max(thistype.DISPLAY_MIN, thistype.DISPLAY_MAX)))
                        call MoveLightningEx(this.manaJuice, false, x - xOffset, y - yOffset, height+50, x + (relative * 2 - 1) * xOffset, y + (relative * 2 - 1) * yOffset, height+50)
                        call SetLightningColor(this.manaJuice, 1., 0., 1., Math.Limit(thistype.DISPLAY_ELEV * relative + thistype.DISPLAY_OFFSET, Math.Min(thistype.DISPLAY_MIN, thistype.DISPLAY_MAX), Math.Max(thistype.DISPLAY_MIN, thistype.DISPLAY_MAX)))
                    endif
				
					set oldRelative = this.staminaDisplayed
					set maxVal = Unit(this).MaxStamina.Get()
					set val = Unit(this).Stamina.Get()
					if (maxVal > 0.) then
                    	set relative = val / maxVal
                    else
                        set relative = 0.
                    endif
					if (relative > oldRelative) then
						set relative = Math.Min(oldRelative + thistype.UPDATE_LENGTH, relative)
					else
						set relative = Math.Max(oldRelative - thistype.UPDATE_LENGTH, relative)
					endif
                    set this.staminaDisplayed = relative
                    if (relative > thistype.DISPLAY_MAX_TRESHOLD) then
                        call MoveLightningEx(this.staminaBar, false, 0., 0., 0., 0., 0., 0.)
                        call MoveLightningEx(this.staminaJuice, false, 0., 0., 0., 0., 0., 0.)
                    else
                        call MoveLightningEx(this.staminaBar, false, x - xOffset, y - yOffset, height, x + xOffset, y + yOffset, height)
                        call SetLightningColor(this.staminaBar, 1., 1., 1., Math.Limit(thistype.DISPLAY_ELEV * relative + thistype.DISPLAY_OFFSET, Math.Min(thistype.DISPLAY_MIN, thistype.DISPLAY_MAX), Math.Max(thistype.DISPLAY_MIN, thistype.DISPLAY_MAX)))
                        call MoveLightningEx(this.staminaJuice, false, x - xOffset, y - yOffset, height, x + (relative * 2 - 1) * xOffset, y + (relative * 2 - 1) * yOffset, height)
                        call SetLightningColor(this.staminaJuice, 1., 1., 0., Math.Limit(thistype.DISPLAY_ELEV * relative + thistype.DISPLAY_OFFSET, Math.Min(thistype.DISPLAY_MIN, thistype.DISPLAY_MAX), Math.Max(thistype.DISPLAY_MIN, thistype.DISPLAY_MAX)))
                    endif
                endif
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
        endmethod
        eventMethod Event_Destroy
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
            if this.RemoveFromList() then
                call thistype.UPDATE_TIMER.Pause()
            endif
            call parent.Event.Remove(CAST_EVENT)
            call parent.Event.Remove(DESTROY_EVENT)
            call parent.Event.Remove(END_CAST_EVENT)
            call this.channelTimer.Destroy()
            call DestroyLightning(this.channelBar)
            call DestroyLightning(this.channelJuice)
            
            
            call DestroyLightning(this.manaBar)
            call DestroyLightning(this.manaJuice)
            call DestroyLightning(this.rageBar)
            call DestroyLightning(this.rageJuice)
            call DestroyLightning(this.staminaBar)
            call DestroyLightning(this.staminaJuice)
        endmethod
        method EndChannel takes nothing returns nothing
            call MoveLightningEx(this.channelBar, false, 0., 0., 0., 0., 0., 0.)
            call MoveLightningEx(this.channelJuice, false, 0., 0., 0., 0., 0., 0.)
            call this.channelTimer.Abort()
        endmethod
        eventMethod Event_EndCast
            
        endmethod
        method StartChannel takes real duration returns nothing
            call this.channelTimer.Start(duration, false, null)
        endmethod
        eventMethod Event_SpellEffect
           
        endmethod
        method Event_Create takes nothing returns nothing
            set this.channelBar = AddLightningEx(thistype.BAR_ID, false, 0., 0., 0., 0., 0., 0.)
            set this.channelJuice = AddLightningEx(thistype.JUICE_ID, false, 0., 0., 0., 0., 0., 0.)
            set this.channelTimer = Timer.Create()
            
            
            
            set this.manaBar = AddLightningEx(thistype.BAR_ID, false, 0., 0., 0., 0., 0., 0.)
            set this.manaDisplayed = 0.
            set this.manaJuice = AddLightningEx(thistype.JUICE_ID, false, 0., 0., 0., 0., 0., 0.)
            set this.rageBar = AddLightningEx(thistype.BAR_ID, false, 0., 0., 0., 0., 0., 0.)
            set this.rageDisplayed = 0.
            set this.rageJuice = AddLightningEx(thistype.JUICE_ID, false, 0., 0., 0., 0., 0., 0.)
            set this.staminaBar = AddLightningEx(thistype.BAR_ID, false, 0., 0., 0., 0., 0., 0.)
            set this.staminaDisplayed = 0.
            set this.staminaJuice = AddLightningEx(thistype.JUICE_ID, false, 0., 0., 0., 0., 0., 0.)
            call Unit(this).Event.Add(CAST_EVENT)
            call Unit(this).Event.Add(DESTROY_EVENT)
            call Unit(this).Event.Add(END_CAST_EVENT)
            if this.AddToList() then
                call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
            endif
        endmethod
        static method Init takes nothing returns nothing
            set thistype.CAST_EVENT = Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.HEADER_TOP, function thistype.Event_SpellEffect)
            set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
            set thistype.END_CAST_EVENT = Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_EndCast)
            set thistype.UPDATE_TIMER = Timer.Create()
        endmethod
    endstruct
    public struct StructTimedLife
        implement Allocation
        implement List
        
        Timer durationTimer
        timerMethod EndingByTimer
            local thistype this = Timer.GetExpired().GetData()
            local Unit parent = this
            call parent.Buffs.Remove(thistype.DUMMY_BUFF)
            call parent.Kill()
        endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
            local Timer durationTimer = this.durationTimer
            call durationTimer.Destroy()
        endmethod
        eventMethod Event_BuffGain
            local real duration = TEMP_REAL
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
			local Timer durationTimer = Timer.Create()
            set this.durationTimer = durationTimer
            call durationTimer.SetData(this)
            call UnitApplyTimedLife(parent.self, 'RTLF', duration + 0.01)
            call durationTimer.Start(duration, false, function thistype.EndingByTimer)
        endmethod
        method Stop takes nothing returns nothing
            call Unit(this).Buffs.Remove(thistype.DUMMY_BUFF)
        endmethod
        method Start takes real duration returns nothing
            set TEMP_REAL = duration
            call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
    public struct StructTransport
        implement Allocation
        implement List
        
    	static EventType ENDING_EVENT_TYPE
    	static EventType START_EVENT_TYPE
        DummyUnit dummyUnit
        Unit transporter
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        method SetPosition takes real x, real y returns nothing
            call this.dummyUnit.Position.SetXY(x, y)
        endmethod
        method Ending_TriggerEvents takes nothing returns nothing
            local Unit parent = this
            local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
            call params.Unit.SetTrigger(this)
			local EventResponse unitParams = EventResponse.Create(parent.Id.Get())
            call unitParams.Unit.SetTrigger(this)
			local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = Event.CountAtStatics(thistype.ENDING_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call Event.GetFromStatics(thistype.ENDING_EVENT_TYPE, priority, iteration2).Run(params)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration2 = parent.Event.Count(thistype.ENDING_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call parent.Event.Get(thistype.ENDING_EVENT_TYPE, priority, iteration2).Run(unitParams)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            call params.Destroy()
            call unitParams.Destroy()
        endmethod
        eventMethod Event_BuffLose
            local Unit parent = params.Unit.GetTrigger()
            local thistype this = parent
			call this.Set(false)
			local Unit transporter = this.transporter
			if (transporter == NULL) then
	            local DummyUnit dummyUnit = this.dummyUnit
	
	           
	
	            call dummyUnit.Kill()
	
	            call dummyUnit.DestroyInstantly()
	        else
				call parent.Position.SetWithCollision(transporter.Position.X.Get(), transporter.Position.Y.Get())
            endif
			if IsUnitHidden(parent.self) then
				call ShowUnit(parent.self, true)
			endif
			call this.Ending_TriggerEvents()
            call parent.Selection.Update()
        endmethod
        method Start_TriggerEvents takes nothing returns nothing            
            local Unit parent = this
            local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
            call params.Unit.SetTrigger(this)
			local EventResponse unitParams = EventResponse.Create(parent.Id.Get())
            call unitParams.Unit.SetTrigger(this)
			local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = Event.CountAtStatics(thistype.START_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call Event.GetFromStatics(thistype.START_EVENT_TYPE, priority, iteration2).Run(params)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration2 = parent.Event.Count(thistype.START_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call parent.Event.Get(thistype.START_EVENT_TYPE, priority, iteration2).Run(unitParams)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            call params.Destroy()
            call unitParams.Destroy()
        endmethod
        eventMethod Event_BuffGain
            local Unit parent = params.Unit.GetTrigger()
            local Unit transporter = params.Buff.GetData()
			local thistype this = parent
			local DummyUnit dummyUnit = NULL
			local boolean success = true
			if (transporter == NULL) then
	            set dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, parent.Position.X.Get(), parent.Position.Y.Get(), 0., 0.)
	
	           
	
	            call dummyUnit.Abilities.AddBySelf(thistype.CARGO_SPELL_ID)
	            call dummyUnit.Abilities.AddBySelf(thistype.LOAD_IN_SPELL_ID)
	            call dummyUnit.Owner.Set(parent.Owner.Get())
	
	            if not dummyUnit.Order.UnitTarget(Order.LOAD, parent) then
	                call DebugEx(thistype.NAME + ": cannot load in " + parent.GetName())
	
	                
	                set success = false
	            endif
            else
                local User parentOwner = parent.Owner.Get()
                local User prevOwner = transporter.Owner.Get()
	            call transporter.Abilities.AddBySelf(thistype.CARGO_SPELL_ID)
	            call transporter.Abilities.AddBySelf(thistype.LOAD_IN_SPELL_ID)
	            call transporter.Owner.Set(parentOwner)
				call parentOwner.EnableAbilityBySelf(thistype.LOAD_IN_SPELL_ID, true)
				if not transporter.Order.UnitTarget(Order.LOAD, parent) then
					call DebugEx(thistype.NAME + ": cannot load in " + parent.GetName() + " (transporter="+transporter.GetName()+")")
					set success = false
				endif
				call parentOwner.EnableAbilityBySelf(thistype.LOAD_IN_SPELL_ID, false)
				call transporter.Owner.Set(prevOwner)
            endif
			if success then
				set this.dummyUnit = dummyUnit
				set this.transporter = transporter
				call this.Set(true)
			else
				call parent.Buffs.Remove(thistype.DUMMY_BUFF)
			endif
			call this.Start_TriggerEvents()
        endmethod
        method Subtract takes nothing returns nothing
            call Unit(this).Buffs.Subtract(thistype.DUMMY_BUFF)
        endmethod
        method Add takes nothing returns nothing
            call Unit(this).Buffs.Add(thistype.DUMMY_BUFF, 1)
        endmethod
        method AddTo takes Unit transporter returns nothing
            call Unit(this).Buffs.AddEx(thistype.DUMMY_BUFF, 1, transporter)
        endmethod
        method AddTimed takes real duration returns nothing
            call Unit(this).Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, duration)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(false)
        endmethod
        initMethod Buff_Init of Header_Buffs
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
        static method Init takes nothing returns nothing
        	set thistype.ENDING_EVENT_TYPE = EventType.Create()
        	set thistype.START_EVENT_TYPE = EventType.Create()
        endmethod
    endstruct
    public struct StructHero
        implement Allocation
        implement List
        
    FolderUnit_StructAgility Agility = this
    FolderUnit_StructAgility LinkToStruct_Agility
    FolderUnit_StructIntelligence Intelligence = this
    FolderUnit_StructIntelligence LinkToStruct_Intelligence
    FolderUnit_StructLevel Level = this
    FolderUnit_StructLevel LinkToStruct_Level
    FolderUnit_StructSkillPoints SkillPoints = this
    FolderUnit_StructSkillPoints LinkToStruct_SkillPoints
    FolderUnit_StructStrength Strength = this
    FolderUnit_StructStrength LinkToStruct_Strength
        method Revive takes real x, real y returns nothing
            call Unit(this).Classes.Remove(UnitClass.DEAD)
            call Unit(this).Revival.Set(false)
            call ReviveHero(Unit(this).self, x, y, false)
            call Unit(this).Revival.Events.Start()
        endmethod
        method SelectSpell takes Spell whichSpell, boolean useSkillPoints returns nothing
            if not useSkillPoints then
                call this.SkillPoints.Add(1)
            endif
            call SelectHeroSkill(Unit(this).self, HeroSpell.GetLearnerSpellId(whichSpell, Unit(this).Abilities.GetLevel(whichSpell) + 1))
        endmethod
    endstruct
    scope FolderPosition
    scope FolderTimed
    public struct StructAccelerated
        implement Allocation
        implement List
        
                method AddIn takes real xAdd, real yAdd, real zAdd, real xAddAdd, real yAddAdd, real zAddAdd, real duration
                    call TranslationAccelerated.CreateIn(this, xAdd, yAdd, zAdd, xAddAdd, yAddAdd, zAddAdd, duration)
                endmethod
                method AddForNoCheck takes real xAdd, real yAdd, real zAdd, real xAddAdd, real yAddAdd, real zAddAdd, real duration
					call TranslationAccelerated.CreateForNoCheck(this, xAdd, yAdd, zAdd, xAddAdd, yAddAdd, zAddAdd, duration)
                endmethod
                method AddFor takes real xAdd, real yAdd, real zAdd, real xAddAdd, real yAddAdd, real zAddAdd, real duration
					call TranslationAccelerated.CreateFor(this, xAdd, yAdd, zAdd, xAdd, yAddAdd, zAddAdd, duration)
                endmethod
                method AddForMundane takes real xSpeed, real ySpeed, real zSpeed, real xAcc, real yAcc, real zAcc, real duration
					call TranslationAccelerated.CreateForMundane(this, xSpeed, ySpeed, zSpeed, xAcc, yAcc, zAcc, duration)
                endmethod
                method AddSpeedDirection takes real speed, real acceleration, real angle, real duration
                    call TranslationAccelerated.CreateSpeedDirection(this, speed, acceleration, angle, duration)
                endmethod
                method AddKnockback takes real speed, real acceleration, real angle, real duration
					call KnockbackAccelerated.Create(this, speed, acceleration, angle, duration)
                endmethod
                static method Init
                endmethod
            endstruct
        endscope
    public struct StructTimed
        implement Allocation
        implement List
        
    FolderTimed_StructAccelerated Accelerated = this
    FolderTimed_StructAccelerated LinkToStruct_Accelerated
            method AddNoCheck takes real xAdd, real yAdd, real zAdd, real duration
            	call Translation.CreateNoCheck(this, xAdd, yAdd, zAdd, duration)
            endmethod
            method Add takes real xAdd, real yAdd, real zAdd, real duration
                call Translation.Create(this, xAdd, yAdd, zAdd, duration)
            endmethod
            method AddSpeedDirection takes real speed, real angle, real duration
                call Translation.CreateSpeedDirection(this, speed, angle, duration)
            endmethod
            method AddKnockback takes real speed, real angle, real duration
                call Knockback.Create(this, speed, angle, duration)
            endmethod
            method Set takes real x, real y, real z, real duration
                call Translation.CreateTo(this, x - Unit(this).Position.X.Get(), y - Unit(this).Position.Y.Get(), z - Unit(this).Position.Z.Get(), duration)
            endmethod
            method SetXY takes real x, real y, real duration
                call Translation.CreateToXY(this, x, y, duration)
            endmethod
            static method Init
                call thistype(NULL).Accelerated.Init()
				call Translation.Init()
            endmethod
        endstruct
    public struct StructX
        implement Allocation
        implement List
        
            method Get takes nothing returns real
                return GetUnitX(Unit(this).self)
            endmethod
            method Set takes real val returns nothing
            	if Knockback.Event_Move(this, val, Unit(this).Position.Y.Get()) then
                    return
                endif
            	if KnockbackAccelerated.Event_Move(this, val, Unit(this).Position.Y.Get()) then
                    return
                endif
                if ((val < WORLD_MIN_X) or (val > WORLD_MAX_X)) then
                    call DebugEx(thistype.NAME + " out of bounds " + Unit(this).GetName() + " " + R2S(val))
                    return
                endif
                call SetUnitX(Unit(this).self, val)
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructY
        implement Allocation
        implement List
        
            method Get takes nothing returns real
                return GetUnitY(Unit(this).self)
            endmethod
            method Set takes real val returns nothing
            	if Knockback.Event_Move(this, Unit(this).Position.X.Get(), val) then
                    return
                endif
            	if KnockbackAccelerated.Event_Move(this, Unit(this).Position.X.Get(), val) then
                    return
                endif
                if ((val < WORLD_MIN_Y) or (val > WORLD_MAX_Y)) then
                    call DebugEx(thistype.NAME + " out of bounds " + Unit(this).GetName() + " " + R2S(val))
                    return
                endif
                call SetUnitY(Unit(this).self, val)
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructZ
        implement Allocation
        implement List
        
            method GetFlyHeight takes nothing returns real
                return GetUnitFlyHeight(Unit(this).self)
            endmethod
            method SetFlyHeight takes real z
                call SetUnitFlyHeight(Unit(this).self, z, 0.)
            endmethod
            method GetByCoords takes real x, real y returns real
                return (Spot.GetHeight(x, y) + this.GetFlyHeight())
            endmethod
            method SetByCoords takes real x, real y, real z
                call SetUnitFlyHeight(Unit(this).self, z - Spot.GetHeight(x, y), 0.)
            endmethod
            method Get takes nothing returns real
                return this.GetByCoords(Unit(this).Position.X.Get(), Unit(this).Position.Y.Get())
            endmethod
            method Set takes real z
                call this.SetByCoords(Unit(this).Position.X.Get(), Unit(this).Position.Y.Get(), z)
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create
                call Unit(this).Abilities.AddBySelf(BJUnit.Z_ENABLER_SPELL_ID)
                call Unit(this).Abilities.RemoveBySelf(BJUnit.Z_ENABLER_SPELL_ID)
            endmethod
            static method Init
            endmethod
        endstruct
    endscope
    public struct StructPosition
        implement Allocation
        implement List
        
    FolderPosition_StructTimed Timed = this
    FolderPosition_StructTimed LinkToStruct_Timed
    FolderPosition_StructX X = this
    FolderPosition_StructX LinkToStruct_X
    FolderPosition_StructY Y = this
    FolderPosition_StructY LinkToStruct_Y
    FolderPosition_StructZ Z = this
    FolderPosition_StructZ LinkToStruct_Z
        method DistToLine takes real sourceX, real sourceY, real length, real angle, real widthStart, real widthEnd returns real
            return Math.Max(0., Math.Shapes.DistToLine(sourceX, sourceY, length, angle, widthStart, widthEnd, this.X.Get(), this.Y.Get()) - Unit(this).CollisionSize.Get(true))
        endmethod
        method InLine takes real sourceX, real sourceY, real length, real angle, real widthStart, real widthEnd returns boolean
            return (this.DistToLine(sourceX, sourceY, length, angle, widthStart, widthEnd) == 0.)
        endmethod
        method InRangeWithCollision takes real x, real y, real radius returns boolean
            local real dX = x - Unit(this).Position.X.Get()
            local real dY = y - Unit(this).Position.Y.Get()
            set radius = (radius + Unit(this).CollisionSize.Get(true))
            return (dX * dX + dY * dY < radius * radius)
        endmethod
        method InRangeWithCollisionWithZ takes real x, real y, real z, real radius returns boolean
            local real dX = x - this.X.Get()
            local real dY = y - this.Y.Get()
            local real dZ = z - this.Z.Get()
            set radius = (radius + Unit(this).CollisionSize.Get(true))
            return (dX * dX + dY * dY + dZ * dZ < radius * radius)
        endmethod
        method Set takes real x, real y, real z returns nothing
            call this.X.Set(x)
            call this.Y.Set(y)
            call this.Z.SetByCoords(x, y, z)
        endmethod
        method SetWithCollision takes real x, real y returns nothing
            call SetUnitPosition(Unit(this).self, x, y)
        endmethod
        method SetXY takes real x, real y returns nothing
            call this.X.Set(x)
            call this.Y.Set(y)
            call this.Z.SetByCoords(x, y, this.Z.Get())
        endmethod
        method Nudge takes nothing returns nothing
            local Lightning effectLightning
            local real sourceX = this.X.Get()
            local real sourceY = this.Y.Get()
            local item dummyItem = CreateItem(thistype.NUDGE_ITEM_ID, sourceX, sourceY)
            local real targetX = GetWidgetX(dummyItem)
            local real targetY = GetWidgetY(dummyItem)
            local real d = Math.DistanceByDeltas(targetX - sourceX, targetY - sourceY)
            call RemoveItem(dummyItem)
            set dummyItem = null
            if (d < 1.) then
                return
            endif
            local real duration = d / 150.
            call this.Timed.Accelerated.AddIn(targetX - sourceX, targetY - sourceY, 0., 0., 0., 0., duration)
            set effectLightning = Lightning.Create(thistype.NUDGE_BOLT)
            call effectLightning.FromSpotToUnit.Start(targetX, targetY, Spot.GetHeight(targetX, targetY), this)
            call effectLightning.DestroyTimed.Start(duration)
        endmethod
        method SetXYWithTerrainWalkableCollision takes real x, real y returns nothing
            if Spot.IsWalkable(x, y) then
                call this.X.Set(x)
                call this.Y.Set(y)
            endif
        endmethod
        method SetXYZ takes real x, real y, real z returns nothing
            call this.X.Set(x)
            call this.Y.Set(y)
            call this.Z.SetByCoords(x, y, z)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Z.Event_Create()
        endmethod
        static method Init takes nothing returns nothing
            call thistype(NULL).Z.Init()
            call thistype(NULL).Timed.Init()
        endmethod
    endstruct
    scope FolderSelection
    public struct StructCircle
        implement Allocation
        implement List
        
			static Event DESTROY_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
			UnitEffect dummyEffect
			Unit parent
			User whichPlayer
			method Ending takes nothing returns nothing
				call this.dummyEffect.Data.Integer.Remove(KEY)
				call this.whichPlayer.Data.Integer.Remove(KEY_ARRAY_DETAIL + this.parent)
				
				call this.deallocate()
			endmethod
			method Destroy takes User whichPlayer returns nothing
				local Unit parent = this
				set this = whichPlayer.Data.Integer.Get(KEY_ARRAY_DETAIL + this)
	        	local UnitEffect dummyEffect = this.dummyEffect
				call this.Ending()
				call dummyEffect.Destroy()
			endmethod
			eventMethod Event_Destroy
				local thistype this = params.UnitEffect.GetTrigger().Data.Integer.Get(KEY) 
				call this.Ending()
			endmethod
			method Create takes User whichPlayer returns nothing
				local Unit parent = this
				local string effectPath
				if whichPlayer.IsLocal() then
					set effectPath = thistype.DUMMY_EFFECT_PATH[whichPlayer.GetNativeIndex() + 1]
				else
					set effectPath = ""
				endif
				set this = thistype.allocate()
                local UnitEffect dummyEffect = parent.Effects.Create(effectPath, thistype.DUMMY_EFFECT_ATTACH_POINT, EffectLevel.LOW)
                set this.dummyEffect = dummyEffect
                set this.parent = parent
                set this.whichPlayer = whichPlayer
                call dummyEffect.Data.Integer.Set(KEY, this)
                call whichPlayer.Data.Integer.Set(KEY_ARRAY_DETAIL + parent, this)
				
			endmethod
			static method Init takes nothing returns nothing
				
			endmethod
		endstruct
	endscope
    public struct StructSelection
        implement Allocation
        implement List
        
        static Event DEATH_EVENT
        static Event DESTROY_EVENT
        static EventType ENDING_EVENT_TYPE
        static Trigger ENDING_TRIGGER
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        static Event OWNER_CHANGE_EVENT
        static EventType REPEAT_EVENT_TYPE
        static EventType START_EVENT_TYPE
        static Trigger START_TRIGGER
    FolderSelection_StructCircle Circle = this
    FolderSelection_StructCircle LinkToStruct_Circle
		method Contains takes User whichPlayer returns boolean
			return Unit(this).Data.Integer.Table.Contains(KEY_ARRAY, whichPlayer)
		endmethod
        method Count takes nothing returns integer
            return Unit(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method CountAtPlayer takes User whichPlayer returns integer
            return whichPlayer.Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method IsEmpty takes nothing returns boolean
            return Unit(this).Data.Integer.Table.IsEmpty(KEY_ARRAY)
        endmethod
        method GetFromPlayer takes User whichPlayer, integer index returns Unit
            return whichPlayer.Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method Ending_TriggerEvents takes User whichPlayer returns nothing
            local Unit parent = this
            local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
            call params.Unit.SetTrigger(this)
            call params.User.SetTrigger(whichPlayer)
			local EventResponse unitParams = EventResponse.Create(parent.Id.Get())
            call unitParams.Unit.SetTrigger(this)
            call unitParams.User.SetTrigger(whichPlayer)
			local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = Event.CountAtStatics(thistype.ENDING_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call Event.GetFromStatics(thistype.ENDING_EVENT_TYPE, priority, iteration2).Run(params)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration2 = parent.Event.Count(thistype.ENDING_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call parent.Event.Get(thistype.ENDING_EVENT_TYPE, priority, iteration2).Run(unitParams)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            call params.Destroy()
            call unitParams.Destroy()
        endmethod
        method Ending takes User whichPlayer returns nothing
			call this.Circle.Destroy(whichPlayer)
            call whichPlayer.Data.Integer.Table.Remove(KEY_ARRAY, this)
            if Unit(this).Data.Integer.Table.Remove(KEY_ARRAY, whichPlayer) then
                call Unit(this).Event.Remove(DEATH_EVENT)
                call Unit(this).Event.Remove(DESTROY_EVENT)
                call Unit(this).Event.Remove(OWNER_CHANGE_EVENT)
            endif
            call this.Ending_TriggerEvents(whichPlayer)
        endmethod
        trigMethod EndingTrig
            call thistype(UNIT.Event.Native.GetTrigger()).Ending(USER.Event.Native.GetTrigger())
        endmethod
		static method EndParent takes Unit parent returns nothing
            local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
            loop
                call thistype(parent).Ending(parent.Data.Integer.Table.Get(KEY_ARRAY, iteration))
                set iteration = iteration - 1
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            endloop
		endmethod
        eventMethod Event_Death
            local Unit parent = params.Unit.GetTrigger()
            call thistype.EndParent(parent)
        endmethod
        eventMethod Event_Destroy
            local Unit parent = params.Unit.GetTrigger()
            call thistype.EndParent(parent)
        endmethod
		eventMethod Event_OwnerChange
			local User targetOwner = params.User.GetTarget()
			local Unit parent = params.Unit.GetTrigger()
            local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
            loop
            	local User whichPlayer = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            	if not GetPlayerAlliance(targetOwner.self, whichPlayer.self, ALLIANCE_SHARED_CONTROL) then
                	call thistype(parent).Ending(whichPlayer)
                endif
                set iteration = iteration - 1
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            endloop
		endmethod
        method Repeat_TriggerEvents takes User whichPlayer returns nothing
            local Unit parent = this
            local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
            call params.Unit.SetTrigger(this)
            call params.User.SetTrigger(whichPlayer)
			local EventResponse unitParams = EventResponse.Create(parent.Id.Get())
            call unitParams.Unit.SetTrigger(this)
            call unitParams.User.SetTrigger(whichPlayer)
			local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = Event.CountAtStatics(thistype.REPEAT_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call Event.GetFromStatics(thistype.REPEAT_EVENT_TYPE, priority, iteration2).Run(params)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration2 = parent.Event.Count(thistype.REPEAT_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call parent.Event.Get(thistype.REPEAT_EVENT_TYPE, priority, iteration2).Run(unitParams)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            call params.Destroy()
            call unitParams.Destroy()
        endmethod
        method Start_TriggerEvents takes User whichPlayer returns nothing
            local Unit parent = this
            local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
            call params.Unit.SetTrigger(this)
            call params.User.SetTrigger(whichPlayer)
			local EventResponse unitParams = EventResponse.Create(parent.Id.Get())
            call unitParams.Unit.SetTrigger(this)
            call unitParams.User.SetTrigger(whichPlayer)
			local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = Event.CountAtStatics(thistype.START_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call Event.GetFromStatics(thistype.START_EVENT_TYPE, priority, iteration2).Run(params)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration2 = parent.Event.Count(thistype.START_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call parent.Event.Get(thistype.START_EVENT_TYPE, priority, iteration2).Run(unitParams)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            call params.Destroy()
            call unitParams.Destroy()
        endmethod
        method Start takes User whichPlayer returns nothing
        	local Unit parent = this
            if not whichPlayer.Data.Integer.Table.Contains(KEY_ARRAY, parent) then
                call whichPlayer.Data.Integer.Table.Add(KEY_ARRAY, parent)
                if parent.Data.Integer.Table.Add(KEY_ARRAY, whichPlayer) then
                    call parent.Event.Add(DEATH_EVENT)
                    call parent.Event.Add(DESTROY_EVENT)
                    call parent.Event.Add(OWNER_CHANGE_EVENT)
                endif
                call this.Start_TriggerEvents(whichPlayer)
                call this.Circle.Create(whichPlayer)
            endif
            call this.Repeat_TriggerEvents(whichPlayer)
        endmethod
        trigMethod StartTrig
            call thistype(UNIT.Event.Native.GetTrigger()).Start(USER.Event.Native.GetTrigger())
        endmethod
		DummyUnit dummyUnit
		method Update takes nothing returns nothing
			local Unit parent = this
            local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
            loop
            	exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            	local User whichPlayer = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
				if not parent.IsSelected(whichPlayer) then
					call parent.Select(whichPlayer, true)
                endif
                set iteration = iteration - 1
            endloop
		endmethod
		method UpdateCircle takes nothing returns nothing
			
		endmethod
		method Event_Create takes nothing returns nothing
			
			
			
			
			
			
			call this.UpdateCircle()
		endmethod
        static method Init takes nothing returns nothing
        	set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Death)
            set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
            set thistype.ENDING_EVENT_TYPE = EventType.Create()
            set thistype.ENDING_TRIGGER = Trigger.CreateFromCode(function thistype.EndingTrig)
            set thistype.OWNER_CHANGE_EVENT = Event.Create(UNIT.Owner.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_OwnerChange)
            set thistype.REPEAT_EVENT_TYPE = EventType.Create()
            set thistype.START_EVENT_TYPE = EventType.Create()
            set thistype.START_TRIGGER = Trigger.CreateFromCode(function thistype.StartTrig)
            call thistype.ENDING_TRIGGER.RegisterEvent.PlayerUnit(User.ANY, EVENT_PLAYER_UNIT_DESELECTED, null)
            call thistype.START_TRIGGER.RegisterEvent.PlayerUnit(User.ANY, EVENT_PLAYER_UNIT_SELECTED, null)
			call thistype(NULL).Circle.Init()
        endmethod
    endstruct
    scope FolderSightRange
    public struct StructBase
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).SightRange.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = Unit(this).Type.Get().SightRange.Get()
            endmethod
            static method Init takes nothing returns nothing
            endmethod
        endstruct
    public struct StructBonus
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).SightRange.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
            endmethod
        endstruct
    public struct StructRelative
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
                call Unit(this).SightRange.Update()
            endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 1.
            endmethod
        endstruct
    endscope
    public struct StructSightRange
        implement Allocation
        implement List
        
    FolderSightRange_StructBase Base = this
    FolderSightRange_StructBase LinkToStruct_Base
    FolderSightRange_StructBonus Bonus = this
    FolderSightRange_StructBonus LinkToStruct_Bonus
    FolderSightRange_StructRelative Relative = this
    FolderSightRange_StructRelative LinkToStruct_Relative
        real value
        method Get takes nothing returns real
            return this.value
        endmethod
        method AddNative takes integer amount returns nothing
            local integer neededMaxPacketsAmount
            local integer packetAbil
            if (amount < 0) then
                set amount = -amount
                set neededMaxPacketsAmount = amount div thistype.DEC_MAX_PACKET
                set amount = amount - neededMaxPacketsAmount * thistype.DEC_MAX_PACKET
                loop
                    exitwhen (neededMaxPacketsAmount < 1)
                    call Unit(this).Abilities.AddBySelf(thistype.DEC_MAX_PACKET_RAW)
                    call Unit(this).Abilities.SetLevelBySelf(thistype.DEC_MAX_PACKET_RAW, 2)
                    call Unit(this).Abilities.RemoveBySelf(thistype.DEC_MAX_PACKET_RAW)
                    set neededMaxPacketsAmount = neededMaxPacketsAmount - 1
                endloop
                set packetAbil = thistype.DEC_RAWS[amount]
                call Unit(this).Abilities.AddBySelf(packetAbil)
                call Unit(this).Abilities.SetLevelBySelf(packetAbil, 2)
                call Unit(this).Abilities.RemoveBySelf(packetAbil)
            else
                set neededMaxPacketsAmount = amount div thistype.INC_MAX_PACKET
                set amount = amount - neededMaxPacketsAmount * thistype.INC_MAX_PACKET
                loop
                    exitwhen (neededMaxPacketsAmount < 1)
                    call Unit(this).Abilities.AddBySelf(thistype.INC_MAX_PACKET_RAW)
                    call Unit(this).Abilities.SetLevelBySelf(thistype.INC_MAX_PACKET_RAW, 2)
                    call Unit(this).Abilities.RemoveBySelf(thistype.INC_MAX_PACKET_RAW)
                    set neededMaxPacketsAmount = neededMaxPacketsAmount - 1
                endloop
                set packetAbil = thistype.INC_RAWS[amount]
                call Unit(this).Abilities.AddBySelf(packetAbil)
                call Unit(this).Abilities.SetLevelBySelf(packetAbil, 2)
                call Unit(this).Abilities.RemoveBySelf(packetAbil)
            endif
        endmethod
        method Set takes real value returns nothing
            local real oldValue = this.value
            if (oldValue == value) then
                return
            endif
            set this.value = value
            call this.AddNative(Real.ToInt(value - oldValue))
            static if thistype.SetEx.exists then
                if (oldValue != 0.) then
                    call this.SetEx(oldValue, value)
                endif
            endif
        endmethod
        method Update takes nothing returns nothing
            call this.Set(this.Base.Get() * this.Relative.Get() + this.Bonus.Get())
        endmethod
        eventMethod Event_TypeChange
            local UnitType sourceType = params.UnitType.GetSource()
            local UnitType targetType = params.UnitType.GetTrigger()
            local thistype this = params.Unit.GetTrigger()
            
            set this.value = this.Get() + targetType.SightRange.GetBJ() - sourceType.SightRange.GetBJ()
			call this.Base.Add(targetType.SightRange.Get() - sourceType.SightRange.Get())
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = Unit(this).Type.Get().SightRange.GetBJ()
            call this.Base.Event_Create()
            call this.Bonus.Event_Create()
            call this.Relative.Event_Create()
            call this.Update()
        endmethod
        static method Init takes nothing returns nothing
        	call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
            call thistype(NULL).Base.Init()
        endmethod
    endstruct
    
        globals
            constant real DAMAGE_BONUS_PER_HERO_ATTRIBUTE_POINT = 0.3
            constant real PRIMARY_ATTRIBUTE_FACTOR = 1.25
        endglobals
    scope FolderLevel
    public struct StructEvents
        implement Allocation
        implement List
        
                static Trigger DUMMY_TRIGGER
                static boolean IGNORE_NEXT = false
                static UnitList REG_GROUP
                static method TrigConds takes Unit parent returns boolean
                    if not thistype.REG_GROUP.Contains(parent) then
                        return false
                    endif
                    return true
                endmethod
                trigMethod Trig
                    local Unit parent = UNIT.Event.Native.GetTrigger()
                    if not thistype.TrigConds(parent) then
                        return
                    endif
                    if thistype.IGNORE_NEXT then
                        set thistype.IGNORE_NEXT = false
                        return
                    endif
                    call parent.Level.SetByEvent()
                endmethod
                method Event_Destroy takes nothing returns nothing
                    if not thistype.REG_GROUP.Contains(this) then
                        return
                    endif
                    call thistype.REG_GROUP.Remove(this)
                endmethod
                method Event_Create takes nothing returns nothing
                    call thistype.REG_GROUP.Add(this)
                endmethod
                static method Init takes nothing returns nothing
                    set thistype.DUMMY_TRIGGER = Trigger.CreateFromCode(function thistype.Trig)
                    set thistype.REG_GROUP = UnitList.Create()
                    call thistype.DUMMY_TRIGGER.RegisterEvent.PlayerUnit(User.ANY, EVENT_PLAYER_HERO_LEVEL, null)
                endmethod
            endstruct
        endscope
    public struct StructLevel
        implement Allocation
        implement List
        
            static integer array EXP_MIN
    FolderLevel_StructEvents Events = this
    FolderLevel_StructEvents LinkToStruct_Events
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
            method GetHeroLvl takes nothing returns integer
                return GetHeroLevel(Unit(this).self)
            endmethod
            method AddBonuses takes integer oldValue, integer value returns nothing
                local UnitType thisType = Unit(this).Type.Get()
                call Unit(this).Exp.Set(thistype.EXP_MIN[ARRAY_MIN + value])
                set value = value - oldValue
				call Unit(this).Scale.Add(value * thistype.SCALE_PER_LEVEL)
                call Unit(this).Agility.Base.Add(value * thisType.Hero.Agility.PerLevel.Get())
                call Unit(this).Armor.Base.Add(value * thisType.Hero.ArmorPerLevel.Get())
                call Unit(this).Intelligence.Base.Add(value * thisType.Hero.Intelligence.PerLevel.Get())
                call Unit(this).SkillPoints.Add(value)
                call Unit(this).Strength.Base.Add(value * thisType.Hero.Strength.PerLevel.Get())
            endmethod
            method SetByEvent takes nothing returns nothing
                local integer oldValue = this.Get()
                local integer value = this.GetHeroLvl()
                set this.value = value
                call UnitModifySkillPoints(Unit(this).self, oldValue - value)
                if (value == 0) then
                    return
                endif
                call this.AddBonuses(oldValue, value)
            endmethod
            method Set takes integer value returns nothing
                local integer oldValue = this.Get()
                if (value != oldValue) then
                    call SetHeroLevel(Unit(this).self, value, true)
                endif
            endmethod
            method SetNoArt takes integer value returns nothing
                local integer oldValue = this.Get()
                if (value != oldValue) then
                    call SetHeroLevel(Unit(this).self, value, false)
                endif
            endmethod
            method Add takes integer value returns nothing
                call this.Set(this.Get() + value)
            endmethod
            method Event_Create takes nothing returns nothing
                local integer value = this.GetHeroLvl()
                call Unit(this).SkillPoints.Set(1)
                set this.value = value
                call this.AddBonuses(1, value)
                call this.Events.Event_Create()
            endmethod
            static method Init takes nothing returns nothing
                set thistype.EXP_MIN[ARRAY_MIN + 1] = 0
                set thistype.EXP_MIN[ARRAY_MIN + 2] = 150
                set thistype.EXP_MIN[ARRAY_MIN + 3] = 400
                set thistype.EXP_MIN[ARRAY_MIN + 4] = 750
                set thistype.EXP_MIN[ARRAY_MIN + 5] = 1200
                set thistype.EXP_MIN[ARRAY_MIN + 6] = 1750
                set thistype.EXP_MIN[ARRAY_MIN + 7] = 2400
                set thistype.EXP_MIN[ARRAY_MIN + 8] = 3150
                set thistype.EXP_MIN[ARRAY_MIN + 9] = 4000
                set thistype.EXP_MIN[ARRAY_MIN + 10] = 4950
                set thistype.EXP_MIN[ARRAY_MIN + 11] = 6000
                set thistype.EXP_MIN[ARRAY_MIN + 12] = 7150
                set thistype.EXP_MIN[ARRAY_MIN + 13] = 8400
                set thistype.EXP_MIN[ARRAY_MIN + 14] = 9750
                set thistype.EXP_MIN[ARRAY_MIN + 15] = 11200
                set thistype.EXP_MIN[ARRAY_MIN + 16] = 12750
                set thistype.EXP_MIN[ARRAY_MIN + 17] = 14400
                set thistype.EXP_MIN[ARRAY_MIN + 18] = 16150
                set thistype.EXP_MIN[ARRAY_MIN + 19] = 18000
                set thistype.EXP_MIN[ARRAY_MIN + 20] = 19950
                call thistype(NULL).Events.Init()
            endmethod
        endstruct
    scope FolderAgility
    public struct StructBase
        implement Allocation
        implement List
        
                static constant integer ATTRIBUTE_AGILITY = 1
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
                method AddBonuses takes real amount returns nothing
                    if (Unit(this).Type.Get().Hero.PrimaryAttribute.Get() == thistype.ATTRIBUTE_AGILITY) then
                        set amount = PRIMARY_ATTRIBUTE_FACTOR * amount
                    endif
                    call Unit(this).Attack.Speed.BaseA.Add(amount * UNIT.Agility.ATTACK_SPEED_BONUS)
                    
                    
                    call Unit(this).MaxRage.Base.Add(amount * UNIT.Agility.RAGE_BONUS)
                endmethod
                method Set takes real value returns nothing
                    local integer oldValueI = Real.ToInt(this.Get())
                    local integer valueI = Real.ToInt(value)
                    set this.value = value
                    call SetHeroAgi(Unit(this).self, valueI, true)
                    call this.AddBonuses(valueI - oldValueI)
                    call Unit(this).Agility.Update()
                endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
                eventMethod Event_TypeChange
                    local UnitType sourceType = params.UnitType.GetSource()
                    local UnitType targetType = params.UnitType.GetTrigger()
                    local thistype this = params.Unit.GetTrigger()
                    call this.Add(targetType.Hero.Agility.Get() - sourceType.Hero.Agility.Get())
                endmethod
                method Event_Create takes nothing returns nothing
                    local real value = Unit(this).Type.Get().Hero.Agility.Get()
                    local integer valueI = Real.ToInt(value)
                    set this.value = value
                    call SetHeroAgi(Unit(this).self, valueI, true)
                    call this.AddBonuses(valueI)
                endmethod
                static method Init takes nothing returns nothing
                    call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
                endmethod
            endstruct
    scope FolderBonus
    public struct StructDisplayed
        implement Allocation
        implement List
        
                    static constant integer ATTRIBUTE_AGILITY = 1
                    method AddBonuses takes real amount returns nothing
                        if (Unit(this).Type.Get().Hero.PrimaryAttribute.Get() == thistype.ATTRIBUTE_AGILITY) then
                            set amount = PRIMARY_ATTRIBUTE_FACTOR * amount
                        endif
                        call Unit(this).Attack.Speed.BonusA.AddOnlySave(amount * UNIT.Agility.ATTACK_SPEED_BONUS)
                        
                        
                        call Unit(this).MaxRage.Bonus.Add(amount * UNIT.Agility.RAGE_BONUS)
                    endmethod
        static constant boolean WAIT_FOR_SELECTION = true
        real value
        method Get takes nothing returns real
            return this.value
        endmethod
        static if true then
            static Event SELECTION_EVENT
            real nativeValue
            boolean waitForSelection
            method SetNative takes real value, real oldValue returns nothing
                set this.nativeValue = value
                call BJUnit.Hero.Agility.BonusA.Set(Unit(this).self, value, oldValue)
            endmethod
            eventMethod Event_Selection
                local thistype this = params.Unit.GetTrigger()
                set this.waitForSelection = false
                call Unit(this).Event.Remove(SELECTION_EVENT)
                call this.SetNative(this.Get(), this.nativeValue)
            endmethod
            method SetDisplay takes real value returns nothing
                local real nativeValue = this.nativeValue
                set this.value = value
                if (value == nativeValue) then
                    if this.waitForSelection then
                        set this.waitForSelection = false
                        call Unit(this).Event.Remove(SELECTION_EVENT)
                    endif
                    return
                endif
                if Unit(this).Selection.IsEmpty() then
                    if not this.waitForSelection then
                        set this.waitForSelection = true
                        call Unit(this).Event.Add(SELECTION_EVENT)
                    endif
                else
                    call this.SetNative(value, nativeValue)
                endif
            endmethod
        else
            method SetDisplay takes real value returns nothing
                local real oldValue = this.Get()
                set this.value = value
                call BJUnit.Hero.Agility.BonusA.Set(Unit(this).self, value, oldValue)
            endmethod
        endif
        method AddOnlySave takes real value returns nothing
            set this.value = this.Get() + value
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0.
            static if true then
                set this.nativeValue = 0.
                set this.waitForSelection = false
            endif
        endmethod
                    method Set takes real value returns nothing
                    	local integer oldValueI = Real.ToInt(this.Get())
                    	local integer valueI = Real.ToInt(value)
                        call this.SetDisplay(value)
						call this.AddBonuses(valueI - oldValueI)
                    endmethod
                    method Update takes nothing returns nothing
                        call this.Set(Unit(this).Agility.Base.Get() * (Unit(this).Agility.Relative.Get() - 1) + Unit(this).Agility.Bonus.Get())
                    endmethod
	                static method Init takes nothing returns nothing
	                    static if thistype.WAIT_FOR_SELECTION then
	                        set thistype.SELECTION_EVENT = Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Selection)
	                    endif
	                endmethod
                endstruct
            endscope
    public struct StructBonus
        implement Allocation
        implement List
        
    FolderBonus_StructDisplayed Displayed = this
    FolderBonus_StructDisplayed LinkToStruct_Displayed
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
                method Set takes real value returns nothing
                    set this.value = value
                    call Unit(this).Agility.Update()
                endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
                method Event_Create takes nothing returns nothing
                    set this.value = 0.
                    call this.Displayed.Event_Create()
                endmethod
				static method Init takes nothing returns nothing
					call thistype(NULL).Displayed.Init()
				endmethod
            endstruct
    public struct StructRelative
        implement Allocation
        implement List
        
            	static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
                method Set takes real value returns nothing
                    set this.value = value
                    call Unit(this).Agility.Update()
                endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
	            eventMethod Event_State
	                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
	            endmethod
                method Event_Create takes nothing returns nothing
                    set this.value = 1.
                endmethod
	            static method Init takes nothing returns nothing
	                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
	            endmethod
            endstruct
        endscope
    public struct StructAgility
        implement Allocation
        implement List
        
    FolderAgility_StructBase Base = this
    FolderAgility_StructBase LinkToStruct_Base
    FolderAgility_StructBonus Bonus = this
    FolderAgility_StructBonus LinkToStruct_Bonus
    FolderAgility_StructRelative Relative = this
    FolderAgility_StructRelative LinkToStruct_Relative
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
				call this.Bonus.Displayed.Update()
            endmethod
            method Update takes nothing returns nothing
                call this.Set(this.Base.Get() * this.Relative.Get() + this.Bonus.Get())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
                call this.Base.Event_Create()
                call this.Bonus.Event_Create()
                call this.Relative.Event_Create()
                call this.Base.Update()
                call this.Bonus.Displayed.Update()
                call this.Update()
            endmethod
            static method Init takes nothing returns nothing
                call thistype(NULL).Base.Init()
                call thistype(NULL).Bonus.Init()
                call thistype(NULL).Relative.Init()
            endmethod
        endstruct
    scope FolderIntelligence
    public struct StructBase
        implement Allocation
        implement List
        
                static constant integer ATTRIBUTE_INTELLIGENCE = 2
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
                method AddBonuses takes real amount returns nothing
                    if (Unit(this).Type.Get().Hero.PrimaryAttribute.Get() == thistype.ATTRIBUTE_INTELLIGENCE) then
                        set amount = PRIMARY_ATTRIBUTE_FACTOR * amount
                    endif
                    call Unit(this).ManaRegeneration.Base.Add(amount * UNIT.Intelligence.MANA_REGEN_BONUS)
                    call Unit(this).MaxMana.Base.Add(amount * UNIT.Intelligence.MAX_MANA_BONUS)
                    call Unit(this).SpellPower.Base.Add(amount * UNIT.Intelligence.SPELL_POWER_BONUS)
                endmethod
                method Set takes real value returns nothing
                    local integer oldValueI = Real.ToInt(this.Get())
                    local integer valueI = Real.ToInt(value)
                    set this.value = value
                    call SetHeroInt(Unit(this).self, valueI, true)
                    call this.AddBonuses(valueI - oldValueI)
                    call Unit(this).Intelligence.Update()
                endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
                eventMethod Event_TypeChange
                    local UnitType sourceType = params.UnitType.GetSource()
                    local UnitType targetType = params.UnitType.GetTrigger()
                    local thistype this = params.Unit.GetTrigger()
                    call this.Add(targetType.Hero.Intelligence.Get() - sourceType.Hero.Intelligence.Get())
                endmethod
                method Event_Create takes nothing returns nothing
                    local real value = Unit(this).Type.Get().Hero.Intelligence.Get()
                    local integer valueI = Real.ToInt(value)
                    set this.value = value
                    call SetHeroInt(Unit(this).self, valueI, true)
                    call this.AddBonuses(valueI)
                endmethod
                static method Init takes nothing returns nothing
                    call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
                endmethod
            endstruct
    scope FolderBonus
    public struct StructDisplayed
        implement Allocation
        implement List
        
                    static constant integer ATTRIBUTE_INTELLIGENCE = 2
                    method AddBonuses takes real amount returns nothing
                        if (Unit(this).Type.Get().Hero.PrimaryAttribute.Get() == thistype.ATTRIBUTE_INTELLIGENCE) then
                            set amount = PRIMARY_ATTRIBUTE_FACTOR * amount
                        endif
                        call Unit(this).ManaRegeneration.Bonus.Add(amount * UNIT.Intelligence.MANA_REGEN_BONUS)
                        call Unit(this).MaxMana.Bonus.Add(amount * UNIT.Intelligence.MAX_MANA_BONUS)
                        call Unit(this).SpellPower.Bonus.Add(amount * UNIT.Intelligence.SPELL_POWER_BONUS)
                    endmethod
        static constant boolean WAIT_FOR_SELECTION = true
        real value
        method Get takes nothing returns real
            return this.value
        endmethod
        static if true then
            static Event SELECTION_EVENT
            real nativeValue
            boolean waitForSelection
            method SetNative takes real value, real oldValue returns nothing
                set this.nativeValue = value
                call BJUnit.Hero.Intelligence.BonusA.Set(Unit(this).self, value, oldValue)
            endmethod
            eventMethod Event_Selection
                local thistype this = params.Unit.GetTrigger()
                set this.waitForSelection = false
                call Unit(this).Event.Remove(SELECTION_EVENT)
                call this.SetNative(this.Get(), this.nativeValue)
            endmethod
            method SetDisplay takes real value returns nothing
                local real nativeValue = this.nativeValue
                set this.value = value
                if (value == nativeValue) then
                    if this.waitForSelection then
                        set this.waitForSelection = false
                        call Unit(this).Event.Remove(SELECTION_EVENT)
                    endif
                    return
                endif
                if Unit(this).Selection.IsEmpty() then
                    if not this.waitForSelection then
                        set this.waitForSelection = true
                        call Unit(this).Event.Add(SELECTION_EVENT)
                    endif
                else
                    call this.SetNative(value, nativeValue)
                endif
            endmethod
        else
            method SetDisplay takes real value returns nothing
                local real oldValue = this.Get()
                set this.value = value
                call BJUnit.Hero.Intelligence.BonusA.Set(Unit(this).self, value, oldValue)
            endmethod
        endif
        method AddOnlySave takes real value returns nothing
            set this.value = this.Get() + value
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0.
            static if true then
                set this.nativeValue = 0.
                set this.waitForSelection = false
            endif
        endmethod
                    method Set takes real value returns nothing
                    	local integer oldValueI = Real.ToInt(this.Get())
                    	local integer valueI = Real.ToInt(value)
                        call this.SetDisplay(value)
						call this.AddBonuses(valueI - oldValueI)
                    endmethod
                    method Update takes nothing returns nothing
                        call this.Set(Unit(this).Intelligence.Base.Get() * (Unit(this).Intelligence.Relative.Get() - 1) + Unit(this).Intelligence.Bonus.Get())
                    endmethod
	                static method Init takes nothing returns nothing
	                    static if thistype.WAIT_FOR_SELECTION then
	                        set thistype.SELECTION_EVENT = Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Selection)
	                    endif
	                endmethod
                endstruct
            endscope
    public struct StructBonus
        implement Allocation
        implement List
        
    FolderBonus_StructDisplayed Displayed = this
    FolderBonus_StructDisplayed LinkToStruct_Displayed
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
                method Set takes real value returns nothing
                    set this.value = value
                    call Unit(this).Intelligence.Update()
                endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
                method Event_Create takes nothing returns nothing
                    set this.value = 0.
                    call this.Displayed.Event_Create()
                endmethod
				static method Init takes nothing returns nothing
					call thistype(NULL).Displayed.Init()
				endmethod
            endstruct
    public struct StructRelative
        implement Allocation
        implement List
        
            	static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
                method Set takes real value returns nothing
                    set this.value = value
                    call Unit(this).Intelligence.Update()
                endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
	            eventMethod Event_State
	                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
	            endmethod
                method Event_Create takes nothing returns nothing
                    set this.value = 1.
                endmethod
	            static method Init takes nothing returns nothing
	                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
	            endmethod
            endstruct
        endscope
    public struct StructIntelligence
        implement Allocation
        implement List
        
    FolderIntelligence_StructBase Base = this
    FolderIntelligence_StructBase LinkToStruct_Base
    FolderIntelligence_StructBonus Bonus = this
    FolderIntelligence_StructBonus LinkToStruct_Bonus
    FolderIntelligence_StructRelative Relative = this
    FolderIntelligence_StructRelative LinkToStruct_Relative
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
				call this.Bonus.Displayed.Update()
            endmethod
            method Update takes nothing returns nothing
                call this.Set(this.Base.Get() * this.Relative.Get() + this.Bonus.Get())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
                call this.Base.Event_Create()
                call this.Bonus.Event_Create()
                call this.Relative.Event_Create()
                call this.Base.Update()
                call this.Bonus.Displayed.Update()
                call this.Update()
            endmethod
            static method Init takes nothing returns nothing
                call thistype(NULL).Base.Init()
                call thistype(NULL).Bonus.Init()
                call thistype(NULL).Relative.Init()
            endmethod
        endstruct
    scope FolderStrength
    public struct StructBase
        implement Allocation
        implement List
        
                static constant integer ATTRIBUTE_STRENGTH = 3
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
                method AddBonuses takes real amount returns nothing
                    if (Unit(this).Type.Get().Hero.PrimaryAttribute.Get() == thistype.ATTRIBUTE_STRENGTH) then
                        set amount = PRIMARY_ATTRIBUTE_FACTOR * amount
                    endif
                    call Unit(this).Damage.Base.Add(amount * UNIT.Strength.DAMAGE_BONUS)
                    call Unit(this).LifeRegeneration.Base.Add(amount * UNIT.Strength.LIFE_REGEN_BONUS)
                    call Unit(this).MaxLife.Base.Add(amount * UNIT.Strength.MAX_LIFE_BONUS)
                endmethod
                method Set takes real value returns nothing
                    local integer oldValueI = Real.ToInt(this.Get())
                    local integer valueI = Real.ToInt(value)
                    set this.value = value
                    call SetHeroStr(Unit(this).self, valueI, true)
                    call this.AddBonuses(valueI - oldValueI)
                    call Unit(this).Strength.Update()
                endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
                eventMethod Event_TypeChange
                    local UnitType sourceType = params.UnitType.GetSource()
                    local UnitType targetType = params.UnitType.GetTrigger()
                    local thistype this = params.Unit.GetTrigger()
                    call this.Add(targetType.Hero.Strength.Get() - sourceType.Hero.Strength.Get())
                endmethod
                method Event_Create takes nothing returns nothing
                    local real value = Unit(this).Type.Get().Hero.Strength.Get()
                    local integer valueI = Real.ToInt(value)
                    set this.value = value
                    call SetHeroStr(Unit(this).self, valueI, true)
                    call this.AddBonuses(valueI)
                endmethod
                static method Init takes nothing returns nothing
                    call Event.Create(UNIT.Type.DUMMY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_TypeChange).AddToStatics()
                endmethod
            endstruct
    scope FolderBonus
    public struct StructDisplayed
        implement Allocation
        implement List
        
                    static constant integer ATTRIBUTE_STRENGTH = 3
                    method AddBonuses takes real amount returns nothing
                        if (Unit(this).Type.Get().Hero.PrimaryAttribute.Get() == thistype.ATTRIBUTE_STRENGTH) then
                            set amount = PRIMARY_ATTRIBUTE_FACTOR * amount
                        endif
                        call Unit(this).Damage.Bonus.Add(amount * UNIT.Strength.DAMAGE_BONUS)
                        call Unit(this).LifeRegeneration.Bonus.Add(amount * UNIT.Strength.LIFE_REGEN_BONUS)
                        call Unit(this).MaxLife.Bonus.Add(amount * UNIT.Strength.MAX_LIFE_BONUS)
                    endmethod
        static constant boolean WAIT_FOR_SELECTION = true
        real value
        method Get takes nothing returns real
            return this.value
        endmethod
        static if true then
            static Event SELECTION_EVENT
            real nativeValue
            boolean waitForSelection
            method SetNative takes real value, real oldValue returns nothing
                set this.nativeValue = value
                call BJUnit.Hero.Strength.BonusA.Set(Unit(this).self, value, oldValue)
            endmethod
            eventMethod Event_Selection
                local thistype this = params.Unit.GetTrigger()
                set this.waitForSelection = false
                call Unit(this).Event.Remove(SELECTION_EVENT)
                call this.SetNative(this.Get(), this.nativeValue)
            endmethod
            method SetDisplay takes real value returns nothing
                local real nativeValue = this.nativeValue
                set this.value = value
                if (value == nativeValue) then
                    if this.waitForSelection then
                        set this.waitForSelection = false
                        call Unit(this).Event.Remove(SELECTION_EVENT)
                    endif
                    return
                endif
                if Unit(this).Selection.IsEmpty() then
                    if not this.waitForSelection then
                        set this.waitForSelection = true
                        call Unit(this).Event.Add(SELECTION_EVENT)
                    endif
                else
                    call this.SetNative(value, nativeValue)
                endif
            endmethod
        else
            method SetDisplay takes real value returns nothing
                local real oldValue = this.Get()
                set this.value = value
                call BJUnit.Hero.Strength.BonusA.Set(Unit(this).self, value, oldValue)
            endmethod
        endif
        method AddOnlySave takes real value returns nothing
            set this.value = this.Get() + value
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0.
            static if true then
                set this.nativeValue = 0.
                set this.waitForSelection = false
            endif
        endmethod
                    method Set takes real value returns nothing
                    	local integer oldValueI = Real.ToInt(this.Get())
                    	local integer valueI = Real.ToInt(value)
                        call this.SetDisplay(value)
						call this.AddBonuses(valueI - oldValueI)
                    endmethod
                    method Update takes nothing returns nothing
                        call this.Set(Unit(this).Strength.Base.Get() * (Unit(this).Strength.Relative.Get() - 1) + Unit(this).Strength.Bonus.Get())
                    endmethod
	                static method Init takes nothing returns nothing
	                    static if thistype.WAIT_FOR_SELECTION then
	                        set thistype.SELECTION_EVENT = Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Selection)
	                    endif
	                endmethod
                endstruct
            endscope
    public struct StructBonus
        implement Allocation
        implement List
        
    FolderBonus_StructDisplayed Displayed = this
    FolderBonus_StructDisplayed LinkToStruct_Displayed
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
                method Set takes real value returns nothing
                    set this.value = value
                    call Unit(this).Strength.Update()
                endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
                method Event_Create takes nothing returns nothing
                    set this.value = 0.
                    call this.Displayed.Event_Create()
                endmethod
				static method Init takes nothing returns nothing
					call thistype(NULL).Displayed.Init()
				endmethod
            endstruct
    public struct StructRelative
        implement Allocation
        implement List
        
            	static UnitState STATE
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
                method Set takes real value returns nothing
                    set this.value = value
                    call Unit(this).Strength.Update()
                endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
	            eventMethod Event_State
	                call thistype(params.Unit.GetTrigger()).Add(params.Real.GetVal())
	            endmethod
                method Event_Create takes nothing returns nothing
                    set this.value = 1.
                endmethod
	            static method Init takes nothing returns nothing
	                set thistype.STATE = UnitState.Create(thistype.NAME, function thistype.Event_State)
	            endmethod
            endstruct
        endscope
    public struct StructStrength
        implement Allocation
        implement List
        
    FolderStrength_StructBase Base = this
    FolderStrength_StructBase LinkToStruct_Base
    FolderStrength_StructBonus Bonus = this
    FolderStrength_StructBonus LinkToStruct_Bonus
    FolderStrength_StructRelative Relative = this
    FolderStrength_StructRelative LinkToStruct_Relative
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
            method Set takes real value returns nothing
                set this.value = value
				call this.Bonus.Displayed.Update()
            endmethod
            method Update takes nothing returns nothing
                call this.Set(this.Base.Get() * this.Relative.Get() + this.Bonus.Get())
            endmethod
            method Event_Create takes nothing returns nothing
                set this.value = 0.
                call this.Base.Event_Create()
                call this.Bonus.Event_Create()
                call this.Relative.Event_Create()
                call this.Base.Update()
                call this.Bonus.Displayed.Update()
                call this.Update()
            endmethod
            static method Init takes nothing returns nothing
                call thistype(NULL).Base.Init()
                call thistype(NULL).Bonus.Init()
                call thistype(NULL).Relative.Init()
            endmethod
        endstruct
    
    public struct StructRefs
        implement Allocation
        implement List
        
        boolean waiting
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
        method CheckForDestroy takes nothing returns boolean
            if (this.Get() > 0) then
                set this.waiting = true
                return false
            endif
            return true
        endmethod
        method Subtract takes nothing returns nothing
            local integer value = this.Get() - 1
            set this.value = value
            if ((value == 0) and this.waiting) then
                call Unit(this).Destroy()
            endif
        endmethod
        method Add takes nothing returns nothing
            set this.value = this.Get() + 1
        endmethod
        method Event_Create takes nothing returns nothing
            set this.value = 0
            set this.waiting = false
        endmethod
    endstruct
endscope
    globals
        Unit UNIT = STRUCT_BASE
    endglobals
    struct Unit
        implement Allocation
        implement List
        
    static EventType CREATE_EVENT_TYPE
    static Trigger CREATE_EXECUTE_TRIGGER
    static Trigger CREATE_FROM_SELF_EXECUTE_TRIGGER
    static boolean CREATE_TRIGGER_EVENTS = true
    static EventType DESTROY_EVENT_TYPE
    static Trigger DESTROY_EXECUTE_TRIGGER
    static BoolExpr ENUM_OF_TYPE_FILTER
    static EventType HEALED_EVENT_TYPE
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static constant string SUMMON_EFFECT_PATH = "Abilities\\Spells\\Orc\\FeralSpirit\\feralspirittarget.mdl"
    static thistype TEMP
    static thistype TEMP2
    static thistype array TEMPS
    static thistype ARURUW
    static thistype DRAKUL
    static thistype JOTA
    static thistype KERA
    static thistype LIZZY
    static thistype ROCKETEYE
    static thistype SMOKEALOT
    static thistype STORMY
    static thistype TAJRAN
    boolean destroyed
    unit self
    FolderUnit_StructAbilities Abilities = this
    FolderUnit_StructAbilities LinkToStruct_Abilities
    FolderUnit_StructAnimation Animation = this
    FolderUnit_StructAnimation LinkToStruct_Animation
    FolderUnit_StructArmor Armor = this
    FolderUnit_StructArmor LinkToStruct_Armor
    FolderUnit_StructAttachments Attachments = this
    FolderUnit_StructAttachments LinkToStruct_Attachments
    FolderUnit_StructAttack Attack = this
    FolderUnit_StructAttack LinkToStruct_Attack
    FolderUnit_StructBanish Banish = this
    FolderUnit_StructBanish LinkToStruct_Banish
    FolderUnit_StructBars Bars = this
    FolderUnit_StructBars LinkToStruct_Bars
    FolderUnit_StructBleeding Bleeding = this
    FolderUnit_StructBleeding LinkToStruct_Bleeding
    FolderUnit_StructBlood Blood = this
    FolderUnit_StructBlood LinkToStruct_Blood
    FolderUnit_StructBloodExplosion BloodExplosion = this
    FolderUnit_StructBloodExplosion LinkToStruct_BloodExplosion
    FolderUnit_StructBuffs Buffs = this
    FolderUnit_StructBuffs LinkToStruct_Buffs
    FolderUnit_StructClasses Classes = this
    FolderUnit_StructClasses LinkToStruct_Classes
    FolderUnit_StructCold Cold = this
    FolderUnit_StructCold LinkToStruct_Cold
    FolderUnit_StructCollisionSize CollisionSize = this
    FolderUnit_StructCollisionSize LinkToStruct_CollisionSize
    FolderUnit_StructColor Color = this
    FolderUnit_StructColor LinkToStruct_Color
    FolderUnit_StructCriticalChance CriticalChance = this
    FolderUnit_StructCriticalChance LinkToStruct_CriticalChance
    FolderUnit_StructCriticalChanceDefense CriticalChanceDefense = this
    FolderUnit_StructCriticalChanceDefense LinkToStruct_CriticalChanceDefense
    FolderUnit_StructDamage Damage = this
    FolderUnit_StructDamage LinkToStruct_Damage
    FolderUnit_StructData Data = this
    FolderUnit_StructData LinkToStruct_Data
    FolderUnit_StructDeath Death = this
    FolderUnit_StructDeath LinkToStruct_Death
    FolderUnit_StructDecay Decay = this
    FolderUnit_StructDecay LinkToStruct_Decay
    FolderUnit_StructDisplay Display = this
    FolderUnit_StructDisplay LinkToStruct_Display
    FolderUnit_StructDrop Drop = this
    FolderUnit_StructDrop LinkToStruct_Drop
    FolderUnit_StructEffects Effects = this
    FolderUnit_StructEffects LinkToStruct_Effects
    FolderUnit_StructEclipse Eclipse = this
    FolderUnit_StructEclipse LinkToStruct_Eclipse
    FolderUnit_StructEvasion Evasion = this
    FolderUnit_StructEvasion LinkToStruct_Evasion
    FolderUnit_StructEvasionChance EvasionChance = this
    FolderUnit_StructEvasionChance LinkToStruct_EvasionChance
    FolderUnit_StructEvasionChanceDefense EvasionChanceDefense = this
    FolderUnit_StructEvasionChanceDefense LinkToStruct_EvasionChanceDefense
    FolderUnit_StructEvent Event = this
    FolderUnit_StructEvent LinkToStruct_Event
    FolderUnit_StructFacing Facing = this
    FolderUnit_StructFacing LinkToStruct_Facing
    FolderUnit_StructFrost Frost = this
    FolderUnit_StructFrost LinkToStruct_Frost
    FolderUnit_StructGhost Ghost = this
    FolderUnit_StructGhost LinkToStruct_Ghost
    FolderUnit_StructHealAbility HealAbility = this
    FolderUnit_StructHealAbility LinkToStruct_HealAbility
    FolderUnit_StructId Id = this
    FolderUnit_StructId LinkToStruct_Id
    FolderUnit_StructImpact Impact = this
    FolderUnit_StructImpact LinkToStruct_Impact
    FolderUnit_StructIgnited Ignited = this
    FolderUnit_StructIgnited LinkToStruct_Ignited
    FolderUnit_StructInvisibility Invisibility = this
    FolderUnit_StructInvisibility LinkToStruct_Invisibility
    FolderUnit_StructInvulnerability Invulnerability = this
    FolderUnit_StructInvulnerability LinkToStruct_Invulnerability
    FolderUnit_StructItems Items = this
    FolderUnit_StructItems LinkToStruct_Items
    FolderUnit_StructKnockup Knockup = this
    FolderUnit_StructKnockup LinkToStruct_Knockup
    FolderUnit_StructLife Life = this
    FolderUnit_StructLife LinkToStruct_Life
    FolderUnit_StructLifeLeech LifeLeech = this
    FolderUnit_StructLifeLeech LinkToStruct_LifeLeech
    FolderUnit_StructLifeRegeneration LifeRegeneration = this
    FolderUnit_StructLifeRegeneration LinkToStruct_LifeRegeneration
    FolderUnit_StructMadness Madness = this
    FolderUnit_StructMadness LinkToStruct_Madness
    FolderUnit_StructMagicImmunity MagicImmunity = this
    FolderUnit_StructMagicImmunity LinkToStruct_MagicImmunity
    FolderUnit_StructMana Mana = this
    FolderUnit_StructMana LinkToStruct_Mana
    FolderUnit_StructManaLeech ManaLeech = this
    FolderUnit_StructManaLeech LinkToStruct_ManaLeech
    FolderUnit_StructManaRegeneration ManaRegeneration = this
    FolderUnit_StructManaRegeneration LinkToStruct_ManaRegeneration
    FolderUnit_StructMaxLife MaxLife = this
    FolderUnit_StructMaxLife LinkToStruct_MaxLife
    FolderUnit_StructMaxMana MaxMana = this
    FolderUnit_StructMaxMana LinkToStruct_MaxMana
    FolderUnit_StructMaxRage MaxRage = this
    FolderUnit_StructMaxRage LinkToStruct_MaxRage
    FolderUnit_StructMaxStamina MaxStamina = this
    FolderUnit_StructMaxStamina LinkToStruct_MaxStamina
    FolderUnit_StructModSets ModSets = this
    FolderUnit_StructModSets LinkToStruct_ModSets
    FolderUnit_StructMovement Movement = this
    FolderUnit_StructMovement LinkToStruct_Movement
    FolderUnit_StructOutpact Outpact = this
    FolderUnit_StructOutpact LinkToStruct_Outpact
    FolderUnit_StructOrder Order = this
    FolderUnit_StructOrder LinkToStruct_Order
    FolderUnit_StructOwner Owner = this
    FolderUnit_StructOwner LinkToStruct_Owner
    FolderUnit_StructPathing Pathing = this
    FolderUnit_StructPathing LinkToStruct_Pathing
    FolderUnit_StructPoisoned Poisoned = this
    FolderUnit_StructPoisoned LinkToStruct_Poisoned
    FolderUnit_StructPosition Position = this
    FolderUnit_StructPosition LinkToStruct_Position
    FolderUnit_StructRage Rage = this
    FolderUnit_StructRage LinkToStruct_Rage
    FolderUnit_StructRageRegeneration RageRegeneration = this
    FolderUnit_StructRageRegeneration LinkToStruct_RageRegeneration
    FolderUnit_StructRefs Refs = this
    FolderUnit_StructRefs LinkToStruct_Refs
    FolderUnit_StructRevival Revival = this
    FolderUnit_StructRevival LinkToStruct_Revival
    FolderUnit_StructScale Scale = this
    FolderUnit_StructScale LinkToStruct_Scale
    FolderUnit_StructSelection Selection = this
    FolderUnit_StructSelection LinkToStruct_Selection
    FolderUnit_StructSightRange SightRange = this
    FolderUnit_StructSightRange LinkToStruct_SightRange
    FolderUnit_StructSilence Silence = this
    FolderUnit_StructSilence LinkToStruct_Silence
    FolderUnit_StructSkillPoints SkillPoints = this
    FolderUnit_StructSkillPoints LinkToStruct_SkillPoints
    FolderUnit_StructSleep Sleep = this
    FolderUnit_StructSleep LinkToStruct_Sleep
    FolderUnit_StructSounds Sounds = this
    FolderUnit_StructSounds LinkToStruct_Sounds
    FolderUnit_StructSpellPower SpellPower = this
    FolderUnit_StructSpellPower LinkToStruct_SpellPower
    FolderUnit_StructSpellVamp SpellVamp = this
    FolderUnit_StructSpellVamp LinkToStruct_SpellVamp
    FolderUnit_StructStamina Stamina = this
    FolderUnit_StructStamina LinkToStruct_Stamina
    FolderUnit_StructStaminaRegeneration StaminaRegeneration = this
    FolderUnit_StructStaminaRegeneration LinkToStruct_StaminaRegeneration
    FolderUnit_StructStun Stun = this
    FolderUnit_StructStun LinkToStruct_Stun
    FolderUnit_StructTimedLife TimedLife = this
    FolderUnit_StructTimedLife LinkToStruct_TimedLife
    FolderUnit_StructTransport Transport = this
    FolderUnit_StructTransport LinkToStruct_Transport
    FolderUnit_StructType Type = this
    FolderUnit_StructType LinkToStruct_Type
    FolderUnit_StructVertexColor VertexColor = this
    FolderUnit_StructVertexColor LinkToStruct_VertexColor
    FolderUnit_StructWhirl Whirl = this
    FolderUnit_StructWhirl LinkToStruct_Whirl
    
    FolderUnit_StructExp Exp = this
    FolderUnit_StructExp LinkToStruct_Exp
    FolderUnit_StructHero Hero = this
    FolderUnit_StructHero LinkToStruct_Hero
    FolderUnit_StructAgility Agility = this
    FolderUnit_StructAgility LinkToStruct_Agility
    FolderUnit_StructLevel Level = this
    FolderUnit_StructLevel LinkToStruct_Level
    FolderUnit_StructIntelligence Intelligence = this
    FolderUnit_StructIntelligence LinkToStruct_Intelligence
    FolderUnit_StructStrength Strength = this
    FolderUnit_StructStrength LinkToStruct_Strength
    static method GetFromId takes integer id returns thistype
        return thistype(NULL).Id.GetParent(id)
    endmethod
    static method GetFromSelf takes unit self returns thistype
        return Memory.IntegerKeys.GetIntegerByHandle(self, KEY)
    endmethod
    static method GetFromSelfSecured takes unit self returns thistype
        if (self == null) then
            return NULL
        endif
        return thistype.GetFromSelf(self)
    endmethod
    method GetName takes nothing returns string
        return GetUnitName(this.self)
    endmethod
    method GetNameEx takes nothing returns string
        return (GetUnitName(this.self) + "(" + I2S(this) + ")")
    endmethod
    method GetProperName takes nothing returns string
        return GetHeroProperName(this.self)
    endmethod
    method GetSelf takes nothing returns unit
        return this.self
    endmethod
    method CastAngle takes real dX, real dY returns real
        if (Math.DistanceSquareByDeltas(dX, dY) < 1.) then
            return this.Facing.Get()
        endif
        return Math.AtanByDeltas(dY, dX)
    endmethod
    method IsAllyOf takes User whichPlayer returns boolean
        return IsUnitAlly(this.self, whichPlayer.self)
    endmethod
    method IsDestroyed takes nothing returns boolean
        return this.destroyed
    endmethod
    method IsEnemyOf takes User whichPlayer returns boolean
        return IsUnitEnemy(this.self, whichPlayer.self)
    endmethod
    method IsSelected takes User whichPlayer returns boolean
        return IsUnitSelected(this.self, whichPlayer.self)
    endmethod
    method Destroy_TriggerEvents takes nothing returns nothing
        local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
        call params.Unit.SetTrigger(this)
		local EventResponse unitParams = EventResponse.Create(this.Id.Get())
        call unitParams.Unit.SetTrigger(this)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = Event.CountAtStatics(thistype.DESTROY_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call Event.GetFromStatics(thistype.DESTROY_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration2 = this.Event.Count(thistype.DESTROY_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.DESTROY_EVENT_TYPE, priority, iteration2).Run(unitParams)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
        call unitParams.Destroy()
        call this.Abilities.Events.Event_Destroy()
        call this.Attack.Events.Event_Destroy()
        call this.Death.Event_Destroy()
        call this.Decay.Events.Event_Destroy()
        call this.Items.Events.Event_Destroy()
        call this.Level.Events.Event_Destroy()
    endmethod
	destroyMethod Destroy [autoExec]
        local unit self = this.self
        call UnitList.WORLD.Remove(this)
        call this.Abilities.Clear()
        call this.Destroy_TriggerEvents()
        call Memory.IntegerKeys.RemoveIntegerByHandle(self, KEY)
        call RemoveUnit(self)
        set self = null
	endmethod
    execMethod Destroy_Executed
        local thistype this = thistype.TEMP
        if this.destroyed then
            return
        endif
        local unit self = this.self
        set this.destroyed = true
        call UnitList.WORLD.Remove(this)
        call this.Abilities.Clear()
        call this.Destroy_TriggerEvents()
        if not this.Refs.CheckForDestroy() then
            call ShowUnit(this.self, false)
            return
        endif
        call this.deallocate()
        call Memory.IntegerKeys.RemoveIntegerByHandle(self, KEY)
        call RemoveUnit(self)
        set self = null
    endmethod
    method Destroy2 takes nothing returns nothing
        set thistype.TEMP = this
        call thistype.DESTROY_EXECUTE_TRIGGER.Run()
    endmethod
    method AddJumpingTextTag takes string text, real fontSize, integer id returns TextTag
        local real x = this.Position.X.Get()
        local real y = this.Position.Y.Get()
        return TEXT_TAG.CreateJumping.Create(text, fontSize, x, y, this.Position.Z.GetByCoords(x, y) + this.Outpact.Z.Get(true), id)
    endmethod
    method AddJumpingTextTagEx2 takes string text, real fontSize, integer id, boolean vertical, real offsetX, real offsetY returns TextTag
        local real x = this.Position.X.Get() + offsetX
        local real y = this.Position.Y.Get() + offsetY
        local real z = this.Position.Z.GetByCoords(x, y)
        if vertical then
            set text = String.Reconcat(text, Char.BREAK)
        endif
        return TEXT_TAG.CreateJumping.Create(text, fontSize, x, y, z, id)
    endmethod
    method AddJumpingTextTagEx takes string text, real fontSize, integer id, boolean useOutpact, boolean useScale returns TextTag
        local real x = this.Position.X.Get()
        local real y = this.Position.Y.Get()
        local real z = this.Position.Z.GetByCoords(x, y)
        if useOutpact then
            set z = z + this.Outpact.Z.Get(useScale)
        endif
        if useScale then
            set fontSize = fontSize * this.Scale.Get()
        endif
        return TEXT_TAG.CreateJumping.Create(text, fontSize, x, y, z, id)
    endmethod
    method AddMovingTextTag takes string text, real fontSize, real speedX, real speedY, real speedZ, real fadePoint, real duration, integer id returns TextTag
        local real x = this.Position.X.Get()
        local real y = this.Position.Y.Get()
        return TEXT_TAG.CreateMoving.Create(text, fontSize, x, y, this.Position.Z.GetByCoords(x, y) + this.Outpact.Z.Get(true), speedX, speedY, speedZ, fadePoint, duration, id)
    endmethod
    method AddRisingTextTag takes string text, real fontSize, real speedZ, real fadePoint, real duration, integer id returns TextTag
        local real x = this.Position.X.Get()
        local real y = this.Position.Y.Get()
        return TEXT_TAG.CreateRising.Create(text, fontSize, x, y, this.Position.Z.GetByCoords(x, y) + this.Outpact.Z.Get(true), speedZ, fadePoint, duration, id)
    endmethod
    method ReplaceRisingTextTagIfMinorValue takes string text, real fontSize, real speedZ, real fadePoint, real duration, integer id, real value returns TextTag
        local TextTag old = TextTag.GetFromId(id)
        if ((old == NULL) or (old.GetValue() < value)) then
            if (old != NULL) then
                call old.Destroy()
            endif
            set old = this.AddRisingTextTag(text, fontSize, speedZ, fadePoint, duration, id)
            call old.SetValue(value)
        endif
        return old
    endmethod
    static key GetKeyMacro_SPELL_TEXT_TAG_KEY_ARRAY
    static constant integer SPELL_TEXT_TAG_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_SPELL_TEXT_TAG_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    method CreateSpellTextTag takes Unit target, boolean magical, real val, boolean crit returns nothing
        if (val <= 0.) then
            return
        endif
        if magical then
            call target.ReplaceRisingTextTagIfMinorValue(String.Color.Gradient("~" + Real.ToIntString(val) + String.If(crit, Char.EXCLAMATION_MARK) + "~", Unit(this).Owner.Get().GetColorString(), String.Color.MAGENTA), Math.Linear(val, target.MaxLife.Get() / 2., 0.016, 0.022), 160., 0., 1., thistype.SPELL_TEXT_TAG_KEY_ARRAY + target, val / 2)
        else
            call target.ReplaceRisingTextTagIfMinorValue(String.Color.Do(Real.ToIntString(val) + String.If(crit, Char.EXCLAMATION_MARK), Unit(this).Owner.Get().GetColorString()), Math.Linear(val, target.MaxLife.Get() / 2., 0.016, 0.022), 160., 0., 1., thistype.SPELL_TEXT_TAG_KEY_ARRAY + target, val / 2)
        endif
    endmethod
    method AddStateB takes UnitState whichState, boolean val returns nothing
        call whichState.RunB(this, val)
    endmethod
    method SubtractStateB takes UnitState whichState, boolean val returns nothing
        call this.AddStateB(whichState, not val)
    endmethod
    method AddState takes UnitState whichState, real value returns nothing
        call whichState.Run(this, value)
    endmethod
    method SubtractState takes UnitState whichState, real value returns nothing
        call this.AddState(whichState, -value)
    endmethod
    method ChangeType takes UnitType targetType returns nothing
        call this.Type.Set(targetType)
    endmethod
    method DamageUnit takes Unit target, real amount, boolean triggerEvents returns real
        return this.Damage.Do(target, amount, triggerEvents)
    endmethod
    static method EnumOfType_Conditions takes nothing returns boolean
        if (UNIT.Event.Native.GetFilter().Type.Get() != UnitType.TEMP) then
            return false
        endif
        return true
    endmethod
    static method EnumOfType takes UnitType whichType, code action returns nothing
        local Group dummyGroup = Group.Create()
        set UnitType.TEMP = whichType
        call dummyGroup.EnumUnits.InRect.Do(Rectangle.WORLD, thistype.ENUM_OF_TYPE_FILTER)
        call dummyGroup.Do(action)
        call dummyGroup.Destroy()
    endmethod
    method DamageUnitBySpell takes Unit target, real amount, boolean magical, boolean triggerEvents returns real
        return this.Damage.DoBySpell(target, amount, magical, triggerEvents)
    endmethod
    method HealBySpell_TriggerEvents takes Unit target, real amount returns nothing
        local EventResponse targetParams = EventResponse.Create(target.Id.Get())
        call targetParams.Real.SetHealedAmount(amount)
        call targetParams.Unit.SetTrigger(target)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = target.Event.Count(thistype.HEALED_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call target.Event.Get(thistype.HEALED_EVENT_TYPE, priority, iteration2).Run(targetParams)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call targetParams.Destroy()
    endmethod
    method AddJumpingTextTagWithValue takes integer id, real value returns TextTag
        local TextTag old = TextTag.GetFromId(id)
        if (old == NULL) then
            set old = TEXT_TAG.CreateJumping.Create(null, 0.02, this.Position.X.Get(), this.Position.Y.Get(), this.Position.Z.Get() + this.Outpact.Z.Get(true), id)
            call old.SetValue(value)
        else
            call old.SetValue(old.GetValue() + value)
        endif
        return old
    endmethod
    static key GetKeyMacro_HEAL_KEY_ARRAY
    static constant integer HEAL_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_HEAL_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    method HealBySpell takes Unit target, real amount returns nothing
        if (amount < 1.) then
            return
        endif
        set amount = amount * thistype(NULL).SpellPower.GetDamageFactor(-this.SpellPower.Get()) * target.HealAbility.Get() * Math.Random(0.9, 1.1)
        local TextTag tag = target.AddJumpingTextTagWithValue(HEAL_KEY_ARRAY + target, amount)
        call tag.Text.Set(String.Color.Do(Char.PLUS + Integer.ToString(Real.ToInt(tag.GetValue())), "ff00c800"), 0.02)
        call target.Life.Add(amount)
        call this.HealBySpell_TriggerEvents(target, amount)
    endmethod
    static key GetKeyMacro_BURN_MANA_KEY_ARRAY
    static constant integer BURN_MANA_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_BURN_MANA_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    method BurnManaBySpell takes Unit target, real amount returns nothing
        local TextTag tag
        if (amount < 1.) then
            return
        endif
        set tag = target.AddJumpingTextTagWithValue(BURN_MANA_KEY_ARRAY + target, amount)
        call tag.Text.Set(String.Color.Do(Char.MINUS + Real.ToIntString(tag.GetValue()), "ffffff00"), 0.02)
        call target.Mana.Subtract(amount)
    endmethod
    static key GetKeyMacro_HEAL_MANA_KEY_ARRAY
    static constant integer HEAL_MANA_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_HEAL_MANA_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    method HealManaBySpell takes Unit target, real amount returns nothing
        if (amount < 1.) then
            return
        endif
        local TextTag tag = target.AddJumpingTextTagWithValue(HEAL_MANA_KEY_ARRAY + target, amount)
        call tag.Text.Set(String.Color.Do(Char.PLUS + Integer.ToString(Real.ToInt(tag.GetValue())), "ffaa55ff"), 0.02)
        call target.Mana.Add(amount)
    endmethod
    static key GetKeyMacro_HEAL_STAMINA_KEY_ARRAY
    static constant integer HEAL_STAMINA_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_HEAL_STAMINA_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    method HealStaminaBySpell takes Unit target, real amount returns nothing
        local TextTag tag
        if (amount < 1.) then
            return
        endif
        set tag = target.AddJumpingTextTagWithValue(HEAL_STAMINA_KEY_ARRAY + target, amount)
        call tag.Text.Set(String.Color.Do(Char.PLUS + Integer.ToString(Real.ToInt(tag.GetValue())), "ffffff00"), 0.02)
        call target.Stamina.Add(amount)
    endmethod
    method Kill takes nothing returns nothing
        call this.Death.Do(NULL)
    endmethod
    method KillBy takes Unit killer returns nothing
        call this.Death.Do(killer)
    endmethod
    method KillInstantly takes nothing returns nothing
        set thistype(NULL).Death.Events.NEXT_DECAYS_INSTANTLY = true
        call this.Kill()
    endmethod
    method ApplyTimedLife takes real duration returns nothing
        call this.TimedLife.Start(duration)
    endmethod
    method Flash takes integer red, integer green, integer blue, integer alpha returns nothing
        call AddIndicator(this.self, red, green, blue, alpha)
    endmethod
    method Revive takes nothing returns nothing
        if this.Classes.Contains(UnitClass.HERO) then
            call this.Hero.Revive(this.Position.X.Get(), this.Position.Y.Get())
        else
            call this.Revival.Do()
        endif
    endmethod
    method Select takes User whichPlayer, boolean flag returns nothing
        if whichPlayer.IsLocal() then
            call SelectUnit(this.self, flag)
        endif
    endmethod
    method SetSummon takes real duration returns nothing
        if (duration >= 0.) then
            call this.BloodExplosion.SetSummon(thistype.SUMMON_EFFECT_PATH)
            call this.Classes.Add(UnitClass.SUMMON)
            call this.Decay.Duration.Set(0.)
            call this.ApplyTimedLife(duration)
        endif
    endmethod
    method Ping takes boolean debugMsg returns nothing
        local real x = this.Position.X.Get()
        local real y = this.Position.Y.Get()
        if debugMsg then
            call InfoEx("ping unit " + this.GetName() + " at " + R2S(x) + ";" + R2S(y))
        endif
        call PingMinimapEx(x, y, 5, Math.RandomI(0, 255), Math.RandomI(0, 255), Math.RandomI(0, 255), true)
    endmethod
    method Whereabouts takes nothing returns nothing
        call InfoEx("whereabouts of " + this.GetName() + "(" + I2S(this) + ")")
        call InfoEx(Char.TAB + "position: " + R2S(this.Position.X.Get()) + ";" + R2S(this.Position.Y.Get()) + ";" + R2S(this.Position.Z.Get()))
        call InfoEx(Char.TAB + "scale: " + R2S(this.Scale.Get()))
        call InfoEx(Char.TAB + "vertex color: " + R2S(this.VertexColor.Red.Get()) + ";" + R2S(this.VertexColor.Green.Get()) + ";" + R2S(this.VertexColor.Blue.Get()) + ";" + R2S(this.VertexColor.Alpha.Get()))
        call this.Ping(false)
    endmethod
    method Stop takes nothing returns nothing
        local real angle = this.Facing.Get()
        if this.Order.PointTargetNoTrig(Order.MOVE, this.Position.X.Get() + 0.01 * Math.Cos(angle), this.Position.Y.Get() + 0.01 * Math.Sin(angle)) then
            return
        endif
        call this.Order.ImmediateNoTrig(Order.STOP)
    endmethod
    method Create_TriggerEvents takes nothing returns nothing
        local UnitType thisType = this.Type.Get()
        local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
        call params.Unit.SetTrigger(this)
        call params.UnitType.SetTrigger(thisType)
		local EventResponse unitParams = EventResponse.Create(this.Id.Get())
        call unitParams.Unit.SetTrigger(this)
        call unitParams.UnitType.SetTrigger(thisType)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = Event.CountAtStatics(thistype.CREATE_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call Event.GetFromStatics(thistype.CREATE_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration2 = thisType.Event.Count(thistype.CREATE_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call thisType.Event.Get(thistype.CREATE_EVENT_TYPE, priority, iteration2).Run(unitParams)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
        call unitParams.Destroy()
    endmethod
    static method CreateBasic takes User owner, unit self returns thistype
    	local UnitType thisType = UnitType.GetFromSelf(GetUnitTypeId(self))
        local thistype this = thistype.GetFromSelf(self)
		local ObjThread thread = ObjThread.Create("Unit.CreateBasic: " + owner.GetName()+";"+GetUnitName(self)+";"+I2S(this)+";"+thisType.GetName())
        if (this != HASH_TABLE.Integer.DEFAULT_VALUE) then
            call DebugEx("Unit.CreateBasic: unit " + this.GetName() + " already registered")
            return this
        endif
        static if DEBUG then
            if (thisType == NULL) then
                call DebugEx("Unit.CreateBasic: null type")
                
                return NULL
            endif
        endif
call thread.AddMark("A")
        set this = thistype.allocate()
        set this.destroyed = false
        set this.self = self
        call Memory.IntegerKeys.SetIntegerByHandle(self, KEY, this)
        call UnitList.WORLD.Add(this)
        call this.Id.Event_Create()
        call this.Refs.Event_Create()
call thread.AddMark("B")
        call this.Animation.Event_Create()
        call this.CriticalChance.Event_Create()
        call this.CriticalChanceDefense.Event_Create()
        call this.EvasionChance.Event_Create()
        call this.EvasionChanceDefense.Event_Create()
        call this.Exp.Event_Create()
        call this.Ghost.Event_Create()
        call this.HealAbility.Event_Create()
        call this.Invisibility.Event_Create()
        call this.Invulnerability.Event_Create()
        call this.LifeLeech.Event_Create()
        call this.Madness.Event_Create()
        call this.MagicImmunity.Event_Create()
        call this.ManaLeech.Event_Create()
        call this.Owner.Event_Create(owner)
        call this.Pathing.Event_Create()
        call this.Position.Event_Create()
        call this.Silence.Event_Create()
        call this.Stun.Event_Create()
        call this.Transport.Event_Create()
        call this.Type.Event_Create()
call thread.AddMark("C")
        call this.Abilities.Event_Create()
call thread.AddMark("C2")
        call this.Armor.Event_Create()
call thread.AddMark("C3")
        call this.Attachments.Event_Create()
call thread.AddMark("C4")
        call this.Attack.Event_Create()
call thread.AddMark("C5")
        call this.Blood.Event_Create()
call thread.AddMark("C6")
        call this.BloodExplosion.Event_Create()
call thread.AddMark("C7")
        call this.Classes.Event_Create()
call thread.AddMark("C8")
        call this.CollisionSize.Event_Create()
call thread.AddMark("C9")
        call this.Damage.Event_Create()
call thread.AddMark("C10")
        call this.Death.Event_Create() 
call thread.AddMark("C11")
        call this.Decay.Event_Create()
call thread.AddMark("C12")
        call this.Drop.Event_Create()
call thread.AddMark("C13")
        call this.Evasion.Event_Create()
call thread.AddMark("C14")
        call this.Impact.Event_Create()
call thread.AddMark("C15")
        call this.Revival.Event_Create()
call thread.AddMark("C16")
        call this.SightRange.Event_Create()
call thread.AddMark("C17")
        call this.SpellPower.Event_Create()
call thread.AddMark("C18")
        call this.SpellVamp.Event_Create()
call thread.AddMark("D")
        call this.LifeRegeneration.Event_Create()
        call this.ManaRegeneration.Event_Create()
        call this.MaxLife.Event_Create()
        call this.MaxMana.Event_Create()
        call this.Movement.Event_Create()
        call this.Outpact.Event_Create()
        call this.Scale.Event_Create()
        call this.VertexColor.Event_Create()
call thread.AddMark("E")
        call this.Banish.Event_Create()
        call this.Bleeding.Event_Create()
        call this.Cold.Event_Create()
        call this.Eclipse.Event_Create()
        call this.Ignited.Event_Create()
        call this.Poisoned.Event_Create()
        call this.Selection.Event_Create()
        call this.Whirl.Event_Create()
        local boolean isHero = this.Classes.Contains(UnitClass.HERO)
call thread.AddMark("F")
        if isHero then
			call this.Armor.Spell.Add(0.3)
call thread.AddMark("F1")
            call this.MaxStamina.Event_Create()
            call this.StaminaRegeneration.Event_Create()
call thread.AddMark("F2")
            call this.Agility.Event_Create()
            call this.Intelligence.Event_Create()
            call this.Strength.Event_Create()
call thread.AddMark("F3")
            call this.SkillPoints.Event_Create()
call thread.AddMark("F4")
            call this.Level.Event_Create()
call thread.AddMark("F5")
            call this.Stamina.Event_Create()
call thread.AddMark("F6")
            call this.Bars.Event_Create()
call thread.AddMark("F7")
        else
call thread.AddMark("F8")
            if not this.Classes.Contains(UnitClass.WARD) then
call thread.AddMark("F9")
                call this.Effects.Create("Units\\Aura.mdx", AttachPoint.ORIGIN, EffectLevel.NORMAL)
call thread.AddMark("F10")
                call this.Color.Update()
call thread.AddMark("F11")
            endif
        endif
call thread.AddMark("G")
        call this.Life.Event_Create()
        call this.Mana.Event_Create()
call thread.AddMark("H")
        call this.Items.Event_Create()
        call thread.AddMark("H2")
        call this.Order.Event_Create()
call thread.AddMark("I")
        if thistype.CREATE_TRIGGER_EVENTS then
            call this.Create_TriggerEvents()
        endif
call thread.AddMark("J")
        call thread.Destroy()
        return this
    endmethod
    execMethod CreateFromSelf_Executed
        set thistype.TEMP = thistype.CreateBasic(User.GetFromSelf(GetOwningPlayer(UNIT.self)), UNIT.self)
    endmethod
    static method CreateFromSelf takes unit self returns thistype
        set UNIT.self = self
        call thistype.CREATE_FROM_SELF_EXECUTE_TRIGGER.Run()
        if (thistype.TEMP == NULL) then
            call RemoveUnit(self)
        endif
        return thistype.TEMP
    endmethod
    execMethod Create_Executed
        set thistype.TEMP = thistype.CreateBasic(User.TEMP, CreateUnit(User.TEMP.self, UnitType.TEMP.self, TEMP_REAL, TEMP_REAL2, TEMP_REAL3 * Math.RAD_TO_DEG))
    endmethod
    static method Create takes UnitType whichType, User whichPlayer, real x, real y, real angle returns thistype
        set TEMP_REAL = x
        set TEMP_REAL2 = y
        set TEMP_REAL3 = angle
        set User.TEMP = whichPlayer
        set UnitType.TEMP = whichType
        call thistype.CREATE_EXECUTE_TRIGGER.Run()
        return thistype.TEMP
    endmethod
    static method CreateSummon takes UnitType whichType, User whichPlayer, real x, real y, real angle, real duration returns thistype
        local thistype this = thistype.Create(whichType, whichPlayer, x, y, angle)
		call SpotEffectWithSize.Create(x, y, thistype.SUMMON_EFFECT_PATH, EffectLevel.LOW, this.Scale.Get()).Destroy()
        call this.Animation.Set(UNIT.Animation.BIRTH)
        call this.Animation.Queue(UNIT.Animation.STAND)
        call this.SetSummon(duration)
        return this
    endmethod
    static method CreateIllusion takes UnitType whichType, User whichPlayer, real x, real y, real angle, real duration, string deathEffectPath returns thistype
        set thistype.CREATE_TRIGGER_EVENTS = false
        local Unit this = thistype.Create(whichType, whichPlayer, x, y, angle)
        set thistype.CREATE_TRIGGER_EVENTS = true
        call this.Armor.Relative.Invisible.Add(-0.5)
        call this.Classes.AddIllusion()
        call this.Damage.Relative.Invisible.Add(-1.)
        call this.VertexColor.AddForPlayer(-191., -191., 0., 0., whichPlayer)
        call this.SetSummon(duration)
        call this.BloodExplosion.SetSummon(deathEffectPath)
        call this.Create_TriggerEvents()
        return this
    endmethod
   
	static method CreateFromPreplaced takes preplaced p returns thistype
		local UnitType whichType = UnitType.GetFromSelf(p.typeId)
		if (whichType == NULL) then
			if (p.waygateTarget != NULL) then
				local unit u = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), p.typeId, p.x, p.y, p.angle)
				call WaygateSetDestination(u, p.waygateTarget.x, p.waygateTarget.y)
				call WaygateActivate(u, true)
				call ShowUnit(u, false)
				set u = null
			endif
			return NULL
		endif
		return Unit.Create(whichType, User.GetFromNativeIndex(p.ownerIndex), p.x, p.y, p.angle)
	endmethod
	initMethod DoPreplaced of Preplaced
		local integer i = preplaced.UNITS_Count()
		loop
			exitwhen (i < ARRAY_MIN)
			local preplaced p = preplaced.UNITS_Get(i)
			if p.enabled then
				local Unit u = Unit.CreateFromPreplaced(p)
				if (u != NULL) then
        			call u.Buffs.Timed.Start(thistype(NULL).Invulnerability.NORMAL_BUFF, 1, 10.)
        			call u.Stop()
        		endif
        	endif
			set i = i - 1
		endloop
	endmethod
    static method Init2 takes nothing returns nothing
        call thistype(NULL).Abilities.Init()
        call thistype(NULL).Armor.Init()
        call thistype(NULL).Bleeding.Init()
        call thistype(NULL).Damage.Init()
        call thistype(NULL).Ignited.Init()
        call thistype(NULL).Knockup.Init()
        call thistype(NULL).Movement.Init()
        call thistype(NULL).Scale.Init()
        call thistype(NULL).Stamina.Init()
        call thistype(NULL).TimedLife.Init()
        call thistype(NULL).Attack.Init()
        call thistype(NULL).Banish.Init()
        call thistype(NULL).Bars.Init()
        call thistype(NULL).Cold.Init()
        call thistype(NULL).Eclipse.Init()
        call thistype(NULL).Frost.Init()
        call thistype(NULL).Ghost.Init()
        call thistype(NULL).Invisibility.Init()
        call thistype(NULL).Invulnerability.Init()
        call thistype(NULL).Items.Init()
        call thistype(NULL).LifeRegeneration.Init()
        call thistype(NULL).MagicImmunity.Init()
        call thistype(NULL).ManaRegeneration.Init()
        call thistype(NULL).Pathing.Init()
        call thistype(NULL).Poisoned.Init()
        call thistype(NULL).Silence.Init()
        call thistype(NULL).Sleep.Init()
        call thistype(NULL).StaminaRegeneration.Init()
        call thistype(NULL).Stun.Init()
        call thistype(NULL).Transport.Init()
        call thistype(NULL).Whirl.Init()
        call UnitType.Init()
        call UnitTypePool.Init()
    endmethod
    initMethod Init of Header_6
        call BJUnit.Init()
        call UnitClass.Init()
        call UnitState.Init()
        set thistype.CREATE_EVENT_TYPE = EventType.Create()
        set thistype.CREATE_EXECUTE_TRIGGER = Trigger.CreateFromCode(function thistype.Create_Executed)
        set thistype.CREATE_FROM_SELF_EXECUTE_TRIGGER = Trigger.CreateFromCode(function thistype.CreateFromSelf_Executed)
        set thistype.DESTROY_EVENT_TYPE = EventType.Create()
        set thistype.DESTROY_EXECUTE_TRIGGER = Trigger.CreateFromCode(function thistype.Destroy_Executed)
        set thistype.ENUM_OF_TYPE_FILTER = BoolExpr.GetFromFunction(function thistype.EnumOfType_Conditions)
        set thistype.HEALED_EVENT_TYPE = EventType.Create()
        
        call thistype(NULL).Type.Init()
        call thistype(NULL).Attachments.Init()
        call thistype(NULL).Blood.Init()
        call thistype(NULL).BloodExplosion.Init()
        call thistype(NULL).Classes.Init()
        call thistype(NULL).CollisionSize.Init()
        call thistype(NULL).CriticalChance.Init()
        call thistype(NULL).Death.Init()
        call thistype(NULL).Display.Init()
        call thistype(NULL).Drop.Init()
        call thistype(NULL).EvasionChance.Init()
        call thistype(NULL).EvasionChanceDefense.Init()
        call thistype(NULL).Event.Init()
        call thistype(NULL).HealAbility.Init()
        call thistype(NULL).Impact.Init()
        call thistype(NULL).Level.Init()
        call thistype(NULL).Life.Init()
        call thistype(NULL).LifeLeech.Init()
        call thistype(NULL).Madness.Init()
        call thistype(NULL).Mana.Init()
        call thistype(NULL).ManaLeech.Init()
        call thistype(NULL).MaxLife.Init()
        call thistype(NULL).MaxMana.Init()
        call thistype(NULL).Outpact.Init()
        call thistype(NULL).Owner.Init()
        call thistype(NULL).Revival.Init()
        call thistype(NULL).SightRange.Init()
        call thistype(NULL).SpellPower.Init()
        call thistype(NULL).SpellVamp.Init()
        call thistype(NULL).VertexColor.Init()
        call thistype(NULL).Animation.Init()
        call thistype(NULL).Buffs.Init()
        call thistype(NULL).Decay.Init()
        call thistype(NULL).Order.Init()
        call thistype(NULL).Position.Init()
        call thistype(NULL).Selection.Init()
        call thistype(NULL).Agility.Init()
        call thistype(NULL).Intelligence.Init()
        call thistype(NULL).Strength.Init()
        call Code.Run(function thistype.Init2)
    endmethod
endstruct
    globals
        UnitState UNIT_STATE = STRUCT_BASE
    endglobals
    struct UnitState
        implement Allocation
        implement List
        
    Trigger action
    method GetAction takes nothing returns Trigger
        return this.action
    endmethod
    method SetAction takes Trigger value returns nothing
        set this.action = value
    endmethod
    string name
    method GetName takes nothing returns string
        return this.name
    endmethod
    method SetName takes string value returns nothing
        set this.name = value
    endmethod
    method RunB takes Unit target, boolean val returns nothing
        local EventResponse params = EventResponse.Create(EventResponse.DIRECT_SUBJECT_ID)
        call params.Bool.SetVal(val)
        call params.Unit.SetTrigger(target)
        call this.GetAction().RunWithParams(params)
        call params.Destroy()
    endmethod
    method Run takes Unit target, real amount returns nothing
        local EventResponse params = EventResponse.Create(EventResponse.DIRECT_SUBJECT_ID)
        call params.Real.SetVal(amount)
        call params.Unit.SetTrigger(target)
        call this.GetAction().RunWithParams(params)
        call params.Destroy()
    endmethod
    method RunWithParams takes Unit target, EventResponse params, boolean add returns nothing
        call params.Bool.SetAdded(add)
        call params.Unit.SetTrigger(target)
        call this.GetAction().RunWithParams(params)
    endmethod
    static method Create takes string name, code actionFunction returns thistype
        local thistype this = thistype.allocate()
        call this.SetAction(Trigger.CreateFromCode(actionFunction))
        call this.SetName(name)
        return this
    endmethod
    static method Init takes nothing returns nothing
    endmethod
endstruct
    globals
        UnitMod UNIT_MOD = STRUCT_BASE
    endglobals
    struct UnitMod
        implement Allocation
        implement List
        
    UnitState whichState
    method GetState takes nothing returns UnitState
        return this.whichState
    endmethod
    method SetState takes UnitState value returns nothing
        set this.whichState = value
    endmethod
    Trigger gainAction
    method GetGainAction takes nothing returns Trigger
        return this.gainAction
    endmethod
    method SetGainAction takes Trigger value returns nothing
        set this.gainAction = value
    endmethod
    Trigger loseAction
    method GetLoseAction takes nothing returns Trigger
        return this.loseAction
    endmethod
    method SetLoseAction takes Trigger value returns nothing
        set this.loseAction = value
    endmethod
    method RemoveFromUnit takes Unit target returns nothing
        local EventResponse params = EventResponse.Create(EventResponse.DIRECT_SUBJECT_ID)
		call params.Unit.SetTrigger(target)
        call params.UnitMod.SetTrigger(this)
        call this.GetLoseAction().RunWithParams(params)
        call params.Destroy()
    endmethod
    method AddToUnit takes Unit target returns nothing
        local EventResponse params = EventResponse.Create(EventResponse.DIRECT_SUBJECT_ID)
		call params.Unit.SetTrigger(target)
        call params.UnitMod.SetTrigger(this)
        call this.GetGainAction().RunWithParams(params)
        call params.Destroy()
    endmethod
    static method Create takes UnitState whichState, code gainFunc, code loseFunc returns thistype
        local thistype this = thistype.allocate()
        call this.SetState(whichState)
        call this.SetGainAction(Trigger.GetFromCode(gainFunc))
        call this.SetLoseAction(Trigger.GetFromCode(loseFunc))
        return this
    endmethod
endstruct
    scope FolderUnitModSet
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    public struct StructBoolean
        implement Allocation
        implement List
        
    method Get takes integer key returns boolean
        return UnitModSet(this).Data.table.IntegerKeys.GetBoolean(UnitModSet(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.RemoveBoolean(UnitModSet(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.SetBoolean(UnitModSet(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return UnitModSet(this).Data.table.IntegerKeys.Table.ContainsInteger(UnitModSet(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return UnitModSet(this).Data.table.IntegerKeys.Table.CountIntegers(UnitModSet(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return UnitModSet(this).Data.table.IntegerKeys.Table.IsEmptyInteger(UnitModSet(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return UnitModSet(this).Data.table.IntegerKeys.Table.GetInteger(UnitModSet(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return UnitModSet(this).Data.table.IntegerKeys.Table.GetFirstInteger(UnitModSet(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return UnitModSet(this).Data.table.IntegerKeys.Table.GetLastInteger(UnitModSet(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.Table.Clear(UnitModSet(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return UnitModSet(this).Data.table.IntegerKeys.Table.FetchFirstInteger(UnitModSet(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return UnitModSet(this).Data.table.IntegerKeys.Table.RemoveInteger(UnitModSet(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return UnitModSet(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(UnitModSet(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return UnitModSet(this).Data.table.IntegerKeys.Table.AddInteger(UnitModSet(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return UnitModSet(this).Data.table.IntegerKeys.Table.AddIntegerMulti(UnitModSet(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.Table.JoinInteger(UnitModSet(this).Id.Get(), key, UnitModSet(other).Data.table, UnitModSet(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return UnitModSet(this).Data.table.IntegerKeys.Table.RandomInteger(UnitModSet(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.Table.ShuffleIntegers(UnitModSet(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.Table.PrintIntegers(UnitModSet(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return UnitModSet(this).Data.table.IntegerKeys.GetInteger(UnitModSet(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.RemoveInteger(UnitModSet(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.SetInteger(UnitModSet(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderReal
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, real value returns boolean
        return UnitModSet(this).Data.table.IntegerKeys.Table.ContainsReal(UnitModSet(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return UnitModSet(this).Data.table.IntegerKeys.Table.CountReals(UnitModSet(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return UnitModSet(this).Data.table.IntegerKeys.Table.IsEmptyReal(UnitModSet(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns real
        return UnitModSet(this).Data.table.IntegerKeys.Table.GetReal(UnitModSet(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns real
        return UnitModSet(this).Data.table.IntegerKeys.Table.GetFirstReal(UnitModSet(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns real
        return UnitModSet(this).Data.table.IntegerKeys.Table.GetLastReal(UnitModSet(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.Table.Clear(UnitModSet(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns real
        return UnitModSet(this).Data.table.IntegerKeys.Table.FetchFirstReal(UnitModSet(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, real value returns boolean
        return UnitModSet(this).Data.table.IntegerKeys.Table.RemoveReal(UnitModSet(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return UnitModSet(this).Data.table.IntegerKeys.Table.RemoveRealByIndex(UnitModSet(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, real value returns boolean
        return UnitModSet(this).Data.table.IntegerKeys.Table.AddReal(UnitModSet(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, real value returns boolean
        return UnitModSet(this).Data.table.IntegerKeys.Table.AddRealMulti(UnitModSet(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.Table.JoinReal(UnitModSet(this).Id.Get(), key, UnitModSet(other).Data.table, UnitModSet(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns real
        return UnitModSet(this).Data.table.IntegerKeys.Table.RandomReal(UnitModSet(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns real
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.Table.ShuffleIntegers(UnitModSet(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.Table.PrintReals(UnitModSet(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructReal
        implement Allocation
        implement List
        
    FolderReal_StructTable Table = this
    FolderReal_StructTable LinkToStruct_Table
    method Get takes integer key returns real
        return UnitModSet(this).Data.table.IntegerKeys.GetReal(UnitModSet(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Real.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.RemoveReal(UnitModSet(this).Id.Get(), key)
    endmethod
    method Set takes integer key, real value returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.SetReal(UnitModSet(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderString
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, string value returns boolean
        return UnitModSet(this).Data.table.IntegerKeys.Table.ContainsString(UnitModSet(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return UnitModSet(this).Data.table.IntegerKeys.Table.CountStrings(UnitModSet(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return UnitModSet(this).Data.table.IntegerKeys.Table.IsEmptyString(UnitModSet(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns string
        return UnitModSet(this).Data.table.IntegerKeys.Table.GetString(UnitModSet(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns string
        return UnitModSet(this).Data.table.IntegerKeys.Table.GetFirstString(UnitModSet(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns string
        return UnitModSet(this).Data.table.IntegerKeys.Table.GetLastString(UnitModSet(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.Table.Clear(UnitModSet(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns string
        return UnitModSet(this).Data.table.IntegerKeys.Table.FetchFirstString(UnitModSet(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, string value returns boolean
        return UnitModSet(this).Data.table.IntegerKeys.Table.RemoveString(UnitModSet(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return UnitModSet(this).Data.table.IntegerKeys.Table.RemoveStringByIndex(UnitModSet(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, string value returns boolean
        return UnitModSet(this).Data.table.IntegerKeys.Table.AddString(UnitModSet(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, string value returns boolean
        return UnitModSet(this).Data.table.IntegerKeys.Table.AddStringMulti(UnitModSet(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.Table.JoinString(UnitModSet(this).Id.Get(), key, UnitModSet(other).Data.table, UnitModSet(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns string
        return UnitModSet(this).Data.table.IntegerKeys.Table.RandomString(UnitModSet(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns string
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.Table.ShuffleIntegers(UnitModSet(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.Table.PrintStrings(UnitModSet(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructString
        implement Allocation
        implement List
        
    FolderString_StructTable Table = this
    FolderString_StructTable LinkToStruct_Table
    method Get takes integer key returns string
        return UnitModSet(this).Data.table.IntegerKeys.GetString(UnitModSet(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.String.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.RemoveString(UnitModSet(this).Id.Get(), key)
    endmethod
    method Set takes integer key, string value returns nothing
        call UnitModSet(this).Data.table.IntegerKeys.SetString(UnitModSet(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
    FolderData_StructReal Real = this
    FolderData_StructReal LinkToStruct_Real
    FolderData_StructString String = this
    FolderData_StructString LinkToStruct_String
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(UnitModSet(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject UnitModSet.Allocation.deallocate_demount.hook
		call UnitModSet(this).Data.Destroy()
	endinject
	inject UnitModSet.Allocation.allocate_mount.hook
		call UnitModSet(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructBoolMods
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY_DETAIL_VAL
    static constant integer KEY_ARRAY_DETAIL_VAL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL_VAL * Memory.IntegerKeys.Table.SIZE
        method Count takes nothing returns integer
            return UnitModSet(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns UnitState
            return UnitModSet(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method GetVal takes UnitState state returns boolean
            return UnitModSet(this).Data.Boolean.Get(KEY_ARRAY_DETAIL_VAL + state)
        endmethod
        method Clear takes nothing returns nothing
            local integer iteration = this.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local UnitState state = this.Get(iteration)
                call UnitModSet(this).Data.Boolean.Remove(KEY_ARRAY_DETAIL_VAL + state)
                set iteration = iteration - 1
            endloop
            call UnitModSet(this).Data.Integer.Table.Clear(KEY_ARRAY)
        endmethod
        method ResetVal takes UnitState state, boolean val returns nothing
            call UnitModSet(this).Data.Boolean.Set(KEY_ARRAY_DETAIL_VAL + state, val)
        endmethod
        method Add takes UnitState state, boolean val returns nothing
        	if UnitModSet(this).Data.Integer.Table.Contains(KEY_ARRAY, state) then
                call DebugEx(thistype.NAME + ": "+I2S(this) + " already has " + state.GetName())
                return
            endif
            call UnitModSet(this).Data.Integer.Table.Add(KEY_ARRAY, state)
            call UnitModSet(this).Data.Boolean.Set(KEY_ARRAY_DETAIL_VAL + state, val)
        endmethod
        method RemoveFromUnit takes Unit target returns nothing
            local integer iteration = this.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local UnitState state = this.Get(iteration)
                call target.SubtractStateB(state, this.GetVal(state))
                set iteration = iteration - 1
            endloop
        endmethod
        method AddToUnit takes Unit target returns nothing
            local integer iteration = this.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local UnitState state = this.Get(iteration)
                call target.AddStateB(state, this.GetVal(state))
                set iteration = iteration - 1
            endloop
        endmethod
    endstruct
    public struct StructRealMods
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY_DETAIL_VAL
    static constant integer KEY_ARRAY_DETAIL_VAL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL_VAL * Memory.IntegerKeys.Table.SIZE
        method Count takes nothing returns integer
            return UnitModSet(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns UnitState
            return UnitModSet(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method GetVal takes UnitState state returns real
            return UnitModSet(this).Data.Real.Get(KEY_ARRAY_DETAIL_VAL + state)
        endmethod
        method Clear takes nothing returns nothing
            local integer iteration = this.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local UnitState state = this.Get(iteration)
                call UnitModSet(this).Data.Real.Remove(KEY_ARRAY_DETAIL_VAL + state)
                set iteration = iteration - 1
            endloop
            call UnitModSet(this).Data.Integer.Table.Clear(KEY_ARRAY)
        endmethod
        method ResetVal takes UnitState state, real val returns nothing
            call UnitModSet(this).Data.Real.Set(KEY_ARRAY_DETAIL_VAL + state, val)
        endmethod
        method Add takes UnitState state, real val returns nothing
            call UnitModSet(this).Data.Integer.Table.Add(KEY_ARRAY, state)
            call UnitModSet(this).Data.Real.Set(KEY_ARRAY_DETAIL_VAL + state, val)
        endmethod
        method RemoveFromUnit takes Unit target returns nothing
            local integer iteration = this.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local UnitState state = this.Get(iteration)
                call target.SubtractState(state, this.GetVal(state))
                set iteration = iteration - 1
            endloop
        endmethod
        method AddToUnit takes Unit target returns nothing
            local integer iteration = this.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local UnitState state = this.Get(iteration)
                call target.AddState(state, this.GetVal(state))
                set iteration = iteration - 1
            endloop
        endmethod
    endstruct
    public struct StructCustomMods
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY_DETAIL_VAL
    static constant integer KEY_ARRAY_DETAIL_VAL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL_VAL * Memory.IntegerKeys.Table.SIZE
        method Count takes nothing returns integer
            return UnitModSet(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns UnitState
            return UnitModSet(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
    static key GetKeyMacro_B_MODS_VAL_KEY
    static constant integer B_MODS_VAL_KEY = Math.Integer.MIN + GetKeyMacro_B_MODS_VAL_KEY
    static key GetKeyMacro_I_MODS_VAL_KEY
    static constant integer I_MODS_VAL_KEY = Math.Integer.MIN + GetKeyMacro_I_MODS_VAL_KEY
    static key GetKeyMacro_R_MODS_VAL_KEY
    static constant integer R_MODS_VAL_KEY = Math.Integer.MIN + GetKeyMacro_R_MODS_VAL_KEY
    static key GetKeyMacro_S_MODS_VAL_KEY
    static constant integer S_MODS_VAL_KEY = Math.Integer.MIN + GetKeyMacro_S_MODS_VAL_KEY
    static key GetKeyMacro_B_MODS_TABLE_KEY
    static constant integer B_MODS_TABLE_KEY = Math.Integer.MIN + GetKeyMacro_B_MODS_TABLE_KEY
    static key GetKeyMacro_I_MODS_TABLE_KEY
    static constant integer I_MODS_TABLE_KEY = Math.Integer.MIN + GetKeyMacro_I_MODS_TABLE_KEY
    static key GetKeyMacro_R_MODS_TABLE_KEY
    static constant integer R_MODS_TABLE_KEY = Math.Integer.MIN + GetKeyMacro_R_MODS_TABLE_KEY
    static key GetKeyMacro_S_MODS_TABLE_KEY
    static constant integer S_MODS_TABLE_KEY = Math.Integer.MIN + GetKeyMacro_S_MODS_TABLE_KEY
            method GetBoolean takes UnitState state, integer key returns boolean
                return Memory.IntegerKeys.D2.GetBoolean(B_MODS_VAL_KEY, this, state, key, NULL)
            endmethod
            method ClearBooleans takes UnitState state returns nothing
                local integer key = Memory.IntegerKeys.D2.Table.FetchFirstInteger(B_MODS_TABLE_KEY, this, state, NULL)
                loop
                    exitwhen (key == NULL)
                    call Memory.IntegerKeys.D2.RemoveBoolean(B_MODS_VAL_KEY, this, state, key, NULL)
                    set key = Memory.IntegerKeys.D2.Table.FetchFirstInteger(B_MODS_TABLE_KEY, this, state, NULL)
                endloop
            endmethod
            method ResetBoolean takes UnitState state, integer key, boolean val returns nothing
                call Memory.IntegerKeys.D2.SetBoolean(B_MODS_VAL_KEY, this, state, key, NULL, val)
            endmethod
            method AddBoolean takes UnitState state, integer key, boolean val returns nothing
                call Memory.IntegerKeys.D2.SetBoolean(B_MODS_VAL_KEY, this, state, key, NULL, val)
                call Memory.IntegerKeys.D2.Table.AddInteger(B_MODS_TABLE_KEY, this, state, NULL, key)
            endmethod
            method SetParamsBooleans takes EventResponse params, UnitState state returns nothing
                local integer key = Memory.IntegerKeys.D2.Table.GetFirstInteger(B_MODS_TABLE_KEY, this, state, NULL)
                loop
                    exitwhen (key == NULL)
                    call params.Dynamic.SetBoolean(key, Memory.IntegerKeys.D2.GetBoolean(B_MODS_VAL_KEY, this, state, key, NULL))
                    set key = Memory.IntegerKeys.D2.Table.GetNextInteger(B_MODS_TABLE_KEY, this, state, NULL, key)
                endloop
            endmethod
            method GetInteger takes UnitState state, integer key returns integer
                return Memory.IntegerKeys.D2.GetInteger(I_MODS_VAL_KEY, this, state, key, NULL)
            endmethod
            method ClearIntegers takes UnitState state returns nothing
                local integer key = Memory.IntegerKeys.D2.Table.FetchFirstInteger(I_MODS_TABLE_KEY, this, state, NULL)
                loop
                    exitwhen (key == NULL)
                    call Memory.IntegerKeys.D2.RemoveInteger(I_MODS_VAL_KEY, this, state, key, NULL)
                    set key = Memory.IntegerKeys.D2.Table.FetchFirstInteger(I_MODS_TABLE_KEY, this, state, NULL)
                endloop
            endmethod
            method ResetInteger takes UnitState state, integer key, integer val returns nothing
                call Memory.IntegerKeys.D2.SetInteger(I_MODS_VAL_KEY, this, state, key, NULL, val)
            endmethod
            method AddInteger takes UnitState state, integer key, integer val returns nothing
                call Memory.IntegerKeys.D2.SetInteger(I_MODS_VAL_KEY, this, state, key, NULL, val)
                call Memory.IntegerKeys.D2.Table.AddInteger(I_MODS_TABLE_KEY, this, state, NULL, key)
            endmethod
            method SetParamsIntegers takes EventResponse params, UnitState state returns nothing
                local integer key = Memory.IntegerKeys.D2.Table.GetFirstInteger(I_MODS_TABLE_KEY, this, state, NULL)
                loop
                    exitwhen (key == NULL)
                    call params.Dynamic.SetInteger(key, Memory.IntegerKeys.D2.GetInteger(I_MODS_VAL_KEY, this, state, key, NULL))
                    set key = Memory.IntegerKeys.D2.Table.GetNextInteger(I_MODS_TABLE_KEY, this, state, NULL, key)
                endloop
            endmethod
            method GetReal takes UnitState state, integer key returns real
                return Memory.IntegerKeys.D2.GetReal(R_MODS_VAL_KEY, this, state, key, NULL)
            endmethod
            method ClearReals takes UnitState state returns nothing
                local integer key = Memory.IntegerKeys.D2.Table.FetchFirstInteger(R_MODS_TABLE_KEY, this, state, NULL)
                loop
                    exitwhen (key == NULL)
                    call Memory.IntegerKeys.D2.RemoveReal(R_MODS_VAL_KEY, this, state, key, NULL)
                    set key = Memory.IntegerKeys.D2.Table.FetchFirstInteger(R_MODS_TABLE_KEY, this, state, NULL)
                endloop
            endmethod
            method ResetReal takes UnitState state, integer key, real val returns nothing
                call Memory.IntegerKeys.D2.SetReal(R_MODS_VAL_KEY, this, state, key, NULL, val)
            endmethod
            method AddReal takes UnitState state, integer key, real val returns nothing
                call Memory.IntegerKeys.D2.SetReal(R_MODS_VAL_KEY, this, state, key, NULL, val)
                call Memory.IntegerKeys.D2.Table.AddInteger(R_MODS_TABLE_KEY, this, state, NULL, key)
            endmethod
            method SetParamsReals takes EventResponse params, UnitState state returns nothing
                local integer key = Memory.IntegerKeys.D2.Table.GetFirstInteger(R_MODS_TABLE_KEY, this, state, NULL)
                loop
                    exitwhen (key == NULL)
                    call params.Dynamic.SetReal(key, Memory.IntegerKeys.D2.GetReal(R_MODS_VAL_KEY, this, state, key, NULL))
                    set key = Memory.IntegerKeys.D2.Table.GetNextInteger(R_MODS_TABLE_KEY, this, state, NULL, key)
                endloop
            endmethod
            method GetString takes UnitState state, integer key returns string
                return Memory.IntegerKeys.D2.GetString(S_MODS_VAL_KEY, this, state, key, NULL)
            endmethod
            method ClearStrings takes UnitState state returns nothing
                local integer key = Memory.IntegerKeys.D2.Table.FetchFirstInteger(S_MODS_TABLE_KEY, this, state, NULL)
                loop
                    exitwhen (key == NULL)
                    call Memory.IntegerKeys.D2.RemoveString(S_MODS_VAL_KEY, this, state, key, NULL)
                    set key = Memory.IntegerKeys.D2.Table.FetchFirstInteger(S_MODS_TABLE_KEY, this, state, NULL)
                endloop
            endmethod
            method ResetString takes UnitState state, integer key, string val returns nothing
                call Memory.IntegerKeys.D2.SetString(S_MODS_VAL_KEY, this, state, key, NULL, val)
            endmethod
            method AddString takes UnitState state, integer key, string val returns nothing
                call Memory.IntegerKeys.D2.SetString(S_MODS_VAL_KEY, this, state, key, NULL, val)
                call Memory.IntegerKeys.D2.Table.AddInteger(S_MODS_TABLE_KEY, this, state, NULL, key)
            endmethod
            method SetParamsStrings takes EventResponse params, UnitState state returns nothing
                local integer key = Memory.IntegerKeys.D2.Table.GetFirstInteger(S_MODS_TABLE_KEY, this, state, NULL)
                loop
                    exitwhen (key == NULL)
                    call params.Dynamic.SetString(key, Memory.IntegerKeys.D2.GetString(S_MODS_VAL_KEY, this, state, key, NULL))
                    set key = Memory.IntegerKeys.D2.Table.GetNextInteger(S_MODS_TABLE_KEY, this, state, NULL, key)
                endloop
            endmethod
        method Clear takes nothing returns nothing
            local integer iteration = UnitModSet(this).Data.Integer.Table.Count(KEY_ARRAY)
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local UnitState state = UnitModSet(this).Data.Integer.Table.Get(KEY_ARRAY, iteration)
                call this.ClearBooleans(state)
                call this.ClearIntegers(state)
                call this.ClearReals(state)
                call this.ClearStrings(state)
                set iteration = iteration - 1
            endloop
            call UnitModSet(this).Data.Integer.Table.Clear(KEY_ARRAY)
        endmethod
        method Add takes UnitState state returns nothing
            call UnitModSet(this).Data.Integer.Table.Add(KEY_ARRAY, state)
        endmethod
        method CreateParams takes UnitState state returns EventResponse
            local EventResponse params = EventResponse.Create(UnitModSet(this).Id.Get())
            call this.SetParamsBooleans(params, state)
            call this.SetParamsIntegers(params, state)
            call this.SetParamsReals(params, state)
            call this.SetParamsStrings(params, state)
            return params
        endmethod
        method RemoveFromUnit takes Unit target returns nothing
            local integer iteration = this.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local UnitState state = this.Get(iteration)
                local EventResponse params = this.CreateParams(state)
                call state.RunWithParams(target, params, false)
                call params.Destroy()
                set iteration = iteration - 1
            endloop
        endmethod
        method AddToUnit takes Unit target returns nothing
            local integer iteration = this.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local UnitState state = this.Get(iteration)
                local EventResponse params = this.CreateParams(state)
                call state.RunWithParams(target, params, true)
                call params.Destroy()
                set iteration = iteration - 1
            endloop
        endmethod
    endstruct
    public struct StructMods
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY_DETAIL_VAL
    static constant integer KEY_ARRAY_DETAIL_VAL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL_VAL * Memory.IntegerKeys.Table.SIZE
        method Count takes nothing returns integer
            return UnitModSet(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns UnitState
            return UnitModSet(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method Clear takes nothing returns nothing
            call UnitModSet(this).Data.Integer.Table.Clear(KEY_ARRAY)
        endmethod
        method Remove takes UnitMod val returns nothing
            call UnitModSet(this).Data.Integer.Table.Remove(KEY_ARRAY, val)
        endmethod
        method Add takes UnitMod val returns nothing
            call UnitModSet(this).Data.Integer.Table.Add(KEY_ARRAY, val)
        endmethod
        method RemoveFromUnit takes Unit target returns nothing
            local integer iteration = this.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local UnitMod mod = this.Get(iteration)
                call mod.RemoveFromUnit(target)
                set iteration = iteration - 1
            endloop
        endmethod
        method AddToUnit takes Unit target returns nothing
            local integer iteration = this.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local UnitMod mod = this.Get(iteration)
                call mod.AddToUnit(target)
                set iteration = iteration - 1
            endloop
        endmethod
    endstruct
endscope
    globals
        UnitModSet UNIT_MOD_SET = STRUCT_BASE
    endglobals
    struct UnitModSet
        implement Allocation
        implement List
        
    static thistype TEMP
    FolderUnitModSet_StructData Data = this
    FolderUnitModSet_StructData LinkToStruct_Data
    FolderUnitModSet_StructId Id = this
    FolderUnitModSet_StructId LinkToStruct_Id
    FolderUnitModSet_StructBoolMods BoolMods = this
    FolderUnitModSet_StructBoolMods LinkToStruct_BoolMods
    FolderUnitModSet_StructRealMods RealMods = this
    FolderUnitModSet_StructRealMods LinkToStruct_RealMods
    FolderUnitModSet_StructCustomMods CustomMods = this
    FolderUnitModSet_StructCustomMods LinkToStruct_CustomMods
    FolderUnitModSet_StructMods Mods = this
    FolderUnitModSet_StructMods LinkToStruct_Mods
    method RemoveFromUnit takes Unit target returns nothing
        call this.BoolMods.RemoveFromUnit(target)
        call this.RealMods.RemoveFromUnit(target)
        call this.CustomMods.RemoveFromUnit(target)
        call this.Mods.RemoveFromUnit(target)
    endmethod
    method AddToUnit takes Unit target returns nothing
        call this.BoolMods.AddToUnit(target)
        call this.RealMods.AddToUnit(target)
        call this.CustomMods.AddToUnit(target)
        call this.Mods.AddToUnit(target)
    endmethod
    method Destroy takes nothing returns nothing
        call this.BoolMods.Clear()
        call this.RealMods.Clear()
        call this.CustomMods.Clear()
        call this.Mods.Clear()
        call this.deallocate()
    endmethod
    static method Create takes nothing returns thistype
        local thistype this = thistype.allocate()
        call this.Id.Event_Create()
        return this
    endmethod
endstruct
    globals
        BuffRef BUFF_REF = STRUCT_BASE
    endglobals
    struct BuffRef
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    integer refs
    integer data
    boolean destroyed
    integer level
    Unit target
    Buff whichBuff
    method CheckForDestroy takes nothing returns nothing
        if not this.destroyed then
            return
        endif
        if (this.refs > 0) then
            return
        endif
        call this.deallocate()
    endmethod
    method SubtractRef takes nothing returns nothing
        set this.refs = this.refs - 1
    endmethod
    method AddRef takes nothing returns nothing
        set this.refs = this.refs + 1
    endmethod
    method DestroyNoTrig takes nothing returns nothing
        local Unit target = this.target
        local Buff whichBuff = this.whichBuff
        if this.destroyed then
            return
        endif
        set this.destroyed = true
        set this.refs = this.refs - 1
        if (this.refs == 0) then
            call this.CheckForDestroy()
            
        endif
        call Memory.IntegerKeys.D2.Table.RemoveInteger(KEY, target, whichBuff, NULL, this)
    endmethod
    method Destroy takes nothing returns nothing
        if this.destroyed then
            return
        endif
        call this.DestroyNoTrig()
        call target.Buffs.SetLevel(whichBuff, Memory.IntegerKeys.D2.Table.GetIntegersMaxPrio(KEY, target, whichBuff, NULL), this.data)
    endmethod
    static method Event_BuffLose takes Buff whichBuff, Unit target returns nothing
        local thistype this = Memory.IntegerKeys.D2.Table.GetFirstInteger(KEY, target, whichBuff, NULL)
        loop
            exitwhen (this == NULL)
            set this.refs = this.refs + 1
            call this.DestroyNoTrig()
            set this = Memory.IntegerKeys.D2.Table.GetFirstInteger(KEY, target, whichBuff, NULL)
        endloop
    endmethod
    static method CreateWithLevel takes Buff whichBuff, integer level, Unit target, integer data returns thistype
        local thistype this = thistype.allocate()
        set this.data = data
        set this.destroyed = false
        set this.level = level
        set this.refs = 0
        set this.target = target
        set this.whichBuff = whichBuff
        call Memory.IntegerKeys.D2.Table.AddIntegerWithPrio(KEY, target, whichBuff, NULL, this, level)
        call target.Buffs.SetLevel(whichBuff, Memory.IntegerKeys.D2.Table.GetIntegersMaxPrio(KEY, target, whichBuff, NULL), data)
        return this
    endmethod
    static method Create takes Buff whichBuff, Unit target, integer data returns thistype
        return thistype.CreateWithLevel(whichBuff, 1, target, data)
    endmethod
endstruct
    scope FolderUnitType
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderBoolean
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, boolean value returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.ContainsBoolean(UnitType(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return UnitType(this).Data.table.IntegerKeys.Table.CountBooleans(UnitType(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.IsEmptyBoolean(UnitType(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.GetBoolean(UnitType(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.GetFirstBoolean(UnitType(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.GetLastBoolean(UnitType(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call UnitType(this).Data.table.IntegerKeys.Table.Clear(UnitType(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.FetchFirstBoolean(UnitType(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, boolean value returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.RemoveBoolean(UnitType(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.RemoveBooleanByIndex(UnitType(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, boolean value returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.AddBoolean(UnitType(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, boolean value returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.AddBooleanMulti(UnitType(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call UnitType(this).Data.table.IntegerKeys.Table.JoinBoolean(UnitType(this).Id.Get(), key, UnitType(other).Data.table, UnitType(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.RandomBoolean(UnitType(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns boolean
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call UnitType(this).Data.table.IntegerKeys.Table.ShuffleIntegers(UnitType(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call UnitType(this).Data.table.IntegerKeys.Table.PrintBooleans(UnitType(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructBoolean
        implement Allocation
        implement List
        
    FolderBoolean_StructTable Table = this
    FolderBoolean_StructTable LinkToStruct_Table
    method Get takes integer key returns boolean
        return UnitType(this).Data.table.IntegerKeys.GetBoolean(UnitType(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call UnitType(this).Data.table.IntegerKeys.RemoveBoolean(UnitType(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call UnitType(this).Data.table.IntegerKeys.SetBoolean(UnitType(this).Id.Get(), key, value)
    endmethod
    method Add takes integer key returns boolean
        local boolean oldValue = this.Get(key)
        call this.Set(key, not HASH_TABLE.Boolean.DEFAULT_VALUE)
        return (oldValue == HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Subtract takes integer key returns boolean
        local boolean oldValue = this.Get(key)
        call this.Set(key, HASH_TABLE.Boolean.DEFAULT_VALUE)
        return (oldValue != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
        endstruct
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.ContainsInteger(UnitType(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return UnitType(this).Data.table.IntegerKeys.Table.CountIntegers(UnitType(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.IsEmptyInteger(UnitType(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return UnitType(this).Data.table.IntegerKeys.Table.GetInteger(UnitType(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return UnitType(this).Data.table.IntegerKeys.Table.GetFirstInteger(UnitType(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return UnitType(this).Data.table.IntegerKeys.Table.GetLastInteger(UnitType(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call UnitType(this).Data.table.IntegerKeys.Table.Clear(UnitType(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return UnitType(this).Data.table.IntegerKeys.Table.FetchFirstInteger(UnitType(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.RemoveInteger(UnitType(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(UnitType(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.AddInteger(UnitType(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.AddIntegerMulti(UnitType(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call UnitType(this).Data.table.IntegerKeys.Table.JoinInteger(UnitType(this).Id.Get(), key, UnitType(other).Data.table, UnitType(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return UnitType(this).Data.table.IntegerKeys.Table.RandomInteger(UnitType(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call UnitType(this).Data.table.IntegerKeys.Table.ShuffleIntegers(UnitType(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call UnitType(this).Data.table.IntegerKeys.Table.PrintIntegers(UnitType(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return UnitType(this).Data.table.IntegerKeys.GetInteger(UnitType(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call UnitType(this).Data.table.IntegerKeys.RemoveInteger(UnitType(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call UnitType(this).Data.table.IntegerKeys.SetInteger(UnitType(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderReal
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, real value returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.ContainsReal(UnitType(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return UnitType(this).Data.table.IntegerKeys.Table.CountReals(UnitType(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.IsEmptyReal(UnitType(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns real
        return UnitType(this).Data.table.IntegerKeys.Table.GetReal(UnitType(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns real
        return UnitType(this).Data.table.IntegerKeys.Table.GetFirstReal(UnitType(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns real
        return UnitType(this).Data.table.IntegerKeys.Table.GetLastReal(UnitType(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call UnitType(this).Data.table.IntegerKeys.Table.Clear(UnitType(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns real
        return UnitType(this).Data.table.IntegerKeys.Table.FetchFirstReal(UnitType(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, real value returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.RemoveReal(UnitType(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.RemoveRealByIndex(UnitType(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, real value returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.AddReal(UnitType(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, real value returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.AddRealMulti(UnitType(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call UnitType(this).Data.table.IntegerKeys.Table.JoinReal(UnitType(this).Id.Get(), key, UnitType(other).Data.table, UnitType(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns real
        return UnitType(this).Data.table.IntegerKeys.Table.RandomReal(UnitType(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns real
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call UnitType(this).Data.table.IntegerKeys.Table.ShuffleIntegers(UnitType(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call UnitType(this).Data.table.IntegerKeys.Table.PrintReals(UnitType(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructReal
        implement Allocation
        implement List
        
    FolderReal_StructTable Table = this
    FolderReal_StructTable LinkToStruct_Table
    method Get takes integer key returns real
        return UnitType(this).Data.table.IntegerKeys.GetReal(UnitType(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Real.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call UnitType(this).Data.table.IntegerKeys.RemoveReal(UnitType(this).Id.Get(), key)
    endmethod
    method Set takes integer key, real value returns nothing
        call UnitType(this).Data.table.IntegerKeys.SetReal(UnitType(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderString
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, string value returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.ContainsString(UnitType(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return UnitType(this).Data.table.IntegerKeys.Table.CountStrings(UnitType(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.IsEmptyString(UnitType(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns string
        return UnitType(this).Data.table.IntegerKeys.Table.GetString(UnitType(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns string
        return UnitType(this).Data.table.IntegerKeys.Table.GetFirstString(UnitType(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns string
        return UnitType(this).Data.table.IntegerKeys.Table.GetLastString(UnitType(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call UnitType(this).Data.table.IntegerKeys.Table.Clear(UnitType(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns string
        return UnitType(this).Data.table.IntegerKeys.Table.FetchFirstString(UnitType(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, string value returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.RemoveString(UnitType(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.RemoveStringByIndex(UnitType(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, string value returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.AddString(UnitType(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, string value returns boolean
        return UnitType(this).Data.table.IntegerKeys.Table.AddStringMulti(UnitType(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call UnitType(this).Data.table.IntegerKeys.Table.JoinString(UnitType(this).Id.Get(), key, UnitType(other).Data.table, UnitType(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns string
        return UnitType(this).Data.table.IntegerKeys.Table.RandomString(UnitType(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns string
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call UnitType(this).Data.table.IntegerKeys.Table.ShuffleIntegers(UnitType(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call UnitType(this).Data.table.IntegerKeys.Table.PrintStrings(UnitType(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructString
        implement Allocation
        implement List
        
    FolderString_StructTable Table = this
    FolderString_StructTable LinkToStruct_Table
    method Get takes integer key returns string
        return UnitType(this).Data.table.IntegerKeys.GetString(UnitType(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.String.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call UnitType(this).Data.table.IntegerKeys.RemoveString(UnitType(this).Id.Get(), key)
    endmethod
    method Set takes integer key, string value returns nothing
        call UnitType(this).Data.table.IntegerKeys.SetString(UnitType(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
    FolderData_StructReal Real = this
    FolderData_StructReal LinkToStruct_Real
    FolderData_StructString String = this
    FolderData_StructString LinkToStruct_String
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(UnitType(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject UnitType.Allocation.deallocate_demount.hook
		call UnitType(this).Data.Destroy()
	endinject
	inject UnitType.Allocation.allocate_mount.hook
		call UnitType(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructEvent
        implement Allocation
        implement List
        
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(UnitType(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(UnitType(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(UnitType(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(UnitType(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(UnitType(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(UnitType(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(UnitType(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(UnitType(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject UnitType.Allocation.deallocate_demount.hook
			call UnitType(this).Event.Destroy()
		endinject
		inject UnitType.Allocation.allocate_mount.hook
			call UnitType(this).Event.Event_Create()
		endinject
    endstruct
    scope FolderAbilities
    public struct StructArrayBuild
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_LEVEL_KEY_ARRAY_DETAIL
    static constant integer LEVEL_KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_LEVEL_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
            method Count takes nothing returns integer
                return UnitType(this).Data.Integer.Table.Count(KEY_ARRAY)
            endmethod
            method Get takes integer index returns Spell
                return UnitType(this).Data.Integer.Table.Get(KEY_ARRAY, index)
            endmethod
            method GetLevel takes Spell whichSpell returns integer
                return UnitType(this).Data.Integer.Get(LEVEL_KEY_ARRAY_DETAIL + whichSpell)
            endmethod
            method Add takes Spell whichSpell, integer level returns nothing
                if UnitType(this).Data.Integer.Table.Contains(KEY_ARRAY, whichSpell) then
                    call DebugEx("unitType "+UnitType(this).GetName()+" already has spell "+whichSpell.GetName())
                    return
                endif
                call UnitType(this).Data.Integer.Table.Add(KEY_ARRAY, whichSpell)
                call UnitType(this).Data.Integer.Set(LEVEL_KEY_ARRAY_DETAIL + whichSpell, level)
            endmethod
            method Event_Create takes nothing returns nothing
            endmethod
        endstruct
    public struct StructHero
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
            integer valuesCount
            method Count takes nothing returns integer
                return this.valuesCount
            endmethod
            method Get takes integer index returns Spell
                return UnitType(this).Data.Integer.Get(KEY_ARRAY_DETAIL + index)
            endmethod
            method Add takes Spell whichSpell returns nothing
                local integer valuesCount = this.valuesCount + 1
                set this.valuesCount = valuesCount
                call UnitType(this).Data.Integer.Set(KEY_ARRAY_DETAIL + valuesCount, whichSpell)
            endmethod
            method Event_Create takes nothing returns nothing
                set this.valuesCount = ARRAY_EMPTY
            endmethod
        endstruct
    endscope
    public struct StructAbilities
        implement Allocation
        implement List
        
    FolderAbilities_StructArrayBuild ArrayBuild = this
    FolderAbilities_StructArrayBuild LinkToStruct_ArrayBuild
    FolderAbilities_StructHero Hero = this
    FolderAbilities_StructHero LinkToStruct_Hero
        method Count takes nothing returns integer
            return this.ArrayBuild.Count()
        endmethod
        method Get takes integer index returns Spell
            return this.ArrayBuild.Get(index)
        endmethod
        method GetLevel takes integer index returns integer
            return this.ArrayBuild.GetLevel(index)
        endmethod
        method Add takes Spell whichSpell returns nothing
            call this.ArrayBuild.Add(whichSpell, 1)
        endmethod
        method AddWithLevel takes Spell whichSpell, integer level returns nothing
            call this.ArrayBuild.Add(whichSpell, level)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.ArrayBuild.Event_Create()
            call this.Hero.Event_Create()
        endmethod
    endstruct
    scope FolderArmor
    public struct StructType
        implement Allocation
        implement List
        
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    endscope
    public struct StructArmor
        implement Allocation
        implement List
        
    FolderArmor_StructType Type = this
    FolderArmor_StructType LinkToStruct_Type
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(0.)
            call this.Type.Event_Create()
        endmethod
    endstruct
    public struct StructAttachments
        implement Allocation
        implement List
        
    static key GetKeyMacro_ATTACH_POINT_KEY_ARRAY
    static constant integer ATTACH_POINT_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_ATTACH_POINT_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_LEVEL_KEY_ARRAY
    static constant integer LEVEL_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_LEVEL_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_PATH_KEY_ARRAY
    static constant integer PATH_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_PATH_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        method Count takes nothing returns integer
            return UnitType(this).Data.String.Table.Count(PATH_KEY_ARRAY)
        endmethod
        method GetAttachPoint takes integer index returns string
            return UnitType(this).Data.String.Table.Get(ATTACH_POINT_KEY_ARRAY, index)
        endmethod
        method GetLevel takes integer index returns EffectLevel
            return UnitType(this).Data.Integer.Table.Get(LEVEL_KEY_ARRAY, index)
        endmethod
        method GetPath takes integer index returns string
            return UnitType(this).Data.String.Table.Get(PATH_KEY_ARRAY, index)
        endmethod
        method Add takes string path, string attachPoint, EffectLevel level returns nothing
            call UnitType(this).Data.String.Table.AddMulti(ATTACH_POINT_KEY_ARRAY, attachPoint)
            call UnitType(this).Data.Integer.Table.AddMulti(LEVEL_KEY_ARRAY, level)
            call UnitType(this).Data.String.Table.AddMulti(PATH_KEY_ARRAY, path)
        endmethod
    endstruct
    scope FolderAttack
    scope FolderMissile
    public struct StructSpeed
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            endstruct
        endscope
    public struct StructMissile
        implement Allocation
        implement List
        
    FolderMissile_StructSpeed Speed = this
    FolderMissile_StructSpeed LinkToStruct_Speed
            method Event_Create takes nothing returns nothing
                call this.Speed.Event_Create()
            endmethod
        endstruct
    public struct StructRange
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructSpeed
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method SetByCooldown takes real cooldown returns nothing
                call this.Set(1. / cooldown)
            endmethod
        endstruct
    scope FolderSplash
    public struct StructTargetFlag
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
                method Is takes integer whichFlag returns boolean
                    return UnitType(this).Data.Boolean.Get(KEY_ARRAY_DETAIL + whichFlag)
                endmethod
                method Add takes integer whichFlag returns nothing
                    call UnitType(this).Data.Boolean.Add(KEY_ARRAY_DETAIL + whichFlag)
                endmethod
            endstruct
        endscope
    public struct StructSplash
        implement Allocation
        implement List
        
    static key GetKeyMacro_AREA_RANGE_KEY_ARRAY
    static constant integer AREA_RANGE_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_AREA_RANGE_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_DAMAGE_KEY_ARRAY
    static constant integer DAMAGE_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_DAMAGE_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    FolderSplash_StructTargetFlag TargetFlag = this
    FolderSplash_StructTargetFlag LinkToStruct_TargetFlag
            method Count takes nothing returns integer
                return UnitType(this).Data.Real.Table.Count(AREA_RANGE_KEY_ARRAY)
            endmethod
            method GetAreaRange takes integer index returns real
                return UnitType(this).Data.Real.Table.Get(AREA_RANGE_KEY_ARRAY, index)
            endmethod
            method GetDamageFactor takes integer index returns real
                return UnitType(this).Data.Real.Table.Get(DAMAGE_KEY_ARRAY, index)
            endmethod
            method Add takes real areaRange, real damageFactor returns nothing
                call UnitType(this).Data.Real.Table.AddMulti(AREA_RANGE_KEY_ARRAY, areaRange)
                call UnitType(this).Data.Real.Table.AddMulti(DAMAGE_KEY_ARRAY, damageFactor)
            endmethod
        endstruct
    endscope
    public struct StructAttack
        implement Allocation
        implement List
        
    FolderAttack_StructMissile Missile = this
    FolderAttack_StructMissile LinkToStruct_Missile
    FolderAttack_StructRange Range = this
    FolderAttack_StructRange LinkToStruct_Range
    FolderAttack_StructSpeed Speed = this
    FolderAttack_StructSpeed LinkToStruct_Speed
    FolderAttack_StructSplash Splash = this
    FolderAttack_StructSplash LinkToStruct_Splash
    Attack value
    method Get takes nothing returns Attack
        return this.value
    endmethod
    method Set takes Attack value returns nothing
        set this.value = value
    endmethod
    method Add takes Attack value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes Attack value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        method Event_Create
            set this.value = NULL
            call this.Missile.Event_Create()
            call this.Range.Event_Create()
            call this.Speed.Event_Create()
        endmethod
    endstruct
    public struct StructBlood
        implement Allocation
        implement List
        
    string value
    method Get takes nothing returns string
        return this.value
    endmethod
    method Set takes string value returns nothing
        set this.value = value
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(null)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    public struct StructBloodExplosion
        implement Allocation
        implement List
        
    string value
    method Get takes nothing returns string
        return this.value
    endmethod
    method Set takes string value returns nothing
        set this.value = value
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(null)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    public struct StructClasses
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        method Count takes nothing returns integer
            return UnitType(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns UnitClass
            return UnitType(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method Add takes UnitClass value
            call UnitType(this).Data.Integer.Table.Add(KEY_ARRAY, value)
        endmethod
    endstruct
    public struct StructCollisionSize
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        method SetByScale takes real value, real scale
            call this.Set(value / scale)
        endmethod
    endstruct
    scope FolderDamage
    public struct StructDelay
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructDices
        implement Allocation
        implement List
        
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructSides
        implement Allocation
        implement List
        
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructType
        implement Allocation
        implement List
        
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(-1)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    endscope
    public struct StructDamage
        implement Allocation
        implement List
        
    FolderDamage_StructDelay Delay = this
    FolderDamage_StructDelay LinkToStruct_Delay
    FolderDamage_StructDices Dices = this
    FolderDamage_StructDices LinkToStruct_Dices
    FolderDamage_StructSides Sides = this
    FolderDamage_StructSides LinkToStruct_Sides
    FolderDamage_StructType Type = this
    FolderDamage_StructType LinkToStruct_Type
    real valueBJ
    method GetBJ takes nothing returns real
        return this.valueBJ
    endmethod
    method SetBJ takes real value returns nothing
        set this.valueBJ = value
    endmethod
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        method Event_Create
            call this.Set(0.)
            call this.Delay.Event_Create()
            call this.Dices.Event_Create()
            call this.Sides.Event_Create()
            call this.Type.Event_Create()
        endmethod
    endstruct
    scope FolderDecay
    public struct StructDuration
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(10.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    endscope
    public struct StructDecay
        implement Allocation
        implement List
        
    FolderDecay_StructDuration Duration = this
    FolderDecay_StructDuration LinkToStruct_Duration
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
        method Event_Create
            call this.Set(true)
            call this.Duration.Event_Create()
        endmethod
    endstruct
    scope FolderDrop
    public struct StructExp
        implement Allocation
        implement List
        
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructSupply
        implement Allocation
        implement List
        
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    endscope
    public struct StructDrop
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    FolderDrop_StructExp Exp = this
    FolderDrop_StructExp LinkToStruct_Exp
    FolderDrop_StructSupply Supply = this
    FolderDrop_StructSupply LinkToStruct_Supply
        method Count takes nothing returns integer
            return UnitType(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns Drop
            return UnitType(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method Add takes Drop whichDrop
            call UnitType(this).Data.Integer.Table.Add(KEY_ARRAY, whichDrop)
        endmethod
        method Event_Create
            call this.Exp.Event_Create()
            call this.Supply.Event_Create()
        endmethod
    endstruct
    scope FolderImpact
    public struct StructZ
        implement Allocation
        implement List
        
            static constant real STANDARD = 60.
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(STANDARD)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    endscope
    public struct StructImpact
        implement Allocation
        implement List
        
    FolderImpact_StructZ Z = this
    FolderImpact_StructZ LinkToStruct_Z
        method Event_Create takes nothing returns nothing
            call this.Z.Event_Create()
        endmethod
    endstruct
    scope FolderOutpact
    public struct StructZ
        implement Allocation
        implement List
        
            static constant real STANDARD = 60.
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(STANDARD)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    endscope
    public struct StructOutpact
        implement Allocation
        implement List
        
    FolderOutpact_StructZ Z = this
    FolderOutpact_StructZ LinkToStruct_Z
        method Event_Create
            call this.Z.Event_Create()
        endmethod
    endstruct
    public struct StructLife
        implement Allocation
        implement List
        
        static constant real INFINITE = 150000.
    real valueBJ
    method GetBJ takes nothing returns real
        return this.valueBJ
    endmethod
    method SetBJ takes real value returns nothing
        set this.valueBJ = value
    endmethod
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    public struct StructLifeRegeneration
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    public struct StructMana
        implement Allocation
        implement List
        
    real valueBJ
    method GetBJ takes nothing returns real
        return this.valueBJ
    endmethod
    method SetBJ takes real value returns nothing
        set this.valueBJ = value
    endmethod
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    public struct StructManaRegeneration
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    public struct StructPreload
        implement Allocation
        implement List
        
        method Event_Create
            local unit dummyUnit = CreateUnit(User.DUMMY.self, UnitType(this).self, 0., 0., 0.)
            call KillUnit(dummyUnit)
            call RemoveUnit(dummyUnit)
            set dummyUnit = null
        endmethod
    endstruct
    public struct StructRevivalable
        implement Allocation
        implement List
        
    boolean flag
    method Is takes nothing returns boolean
        return this.flag
    endmethod
    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(true)
    endmethod
    endstruct
    public struct StructScale
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(1.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    public struct StructSightRange
        implement Allocation
        implement List
        
    real valueBJ
    method GetBJ takes nothing returns real
        return this.valueBJ
    endmethod
    method SetBJ takes real value returns nothing
        set this.valueBJ = value
    endmethod
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(800.)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    public struct StructSpeed
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    public struct StructSpellPower
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    public struct StructSpellVamp
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderVertexColor
    public struct StructRed
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(255.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructGreen
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(255.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructBlue
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(255.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    public struct StructAlpha
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(255.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    endscope
    public struct StructVertexColor
        implement Allocation
        implement List
        
    FolderVertexColor_StructRed Red = this
    FolderVertexColor_StructRed LinkToStruct_Red
    FolderVertexColor_StructGreen Green = this
    FolderVertexColor_StructGreen LinkToStruct_Green
    FolderVertexColor_StructBlue Blue = this
    FolderVertexColor_StructBlue LinkToStruct_Blue
    FolderVertexColor_StructAlpha Alpha = this
    FolderVertexColor_StructAlpha LinkToStruct_Alpha
        method Set takes real red, real green, real blue, real alpha returns nothing
            call this.Red.Set(red)
            call this.Green.Set(green)
            call this.Blue.Set(blue)
            call this.Alpha.Set(alpha)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Red.Event_Create()
            call this.Green.Event_Create()
            call this.Blue.Event_Create()
            call this.Alpha.Event_Create()
        endmethod
    endstruct
    scope FolderHero
    public struct StructPrimaryAttribute
        implement Allocation
        implement List
        
            static constant integer AGILITY = 1
            static constant integer INTELLIGENCE = 2
            static constant integer STRENGTH = 3
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    scope FolderAgility
    public struct StructPerLevel
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            endstruct
        endscope
    public struct StructAgility
        implement Allocation
        implement List
        
    FolderAgility_StructPerLevel PerLevel = this
    FolderAgility_StructPerLevel LinkToStruct_PerLevel
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                call this.Set(0.)
                call this.PerLevel.Event_Create()
            endmethod
        endstruct
    public struct StructArmorPerLevel
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        endstruct
    scope FolderIntelligence
    public struct StructPerLevel
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            endstruct
        endscope
    public struct StructIntelligence
        implement Allocation
        implement List
        
    FolderIntelligence_StructPerLevel PerLevel = this
    FolderIntelligence_StructPerLevel LinkToStruct_PerLevel
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                call this.Set(0.)
                call this.PerLevel.Event_Create()
            endmethod
        endstruct
    scope FolderStrength
    public struct StructPerLevel
        implement Allocation
        implement List
        
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(0.)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            endstruct
        endscope
    public struct StructStrength
        implement Allocation
        implement List
        
    FolderStrength_StructPerLevel PerLevel = this
    FolderStrength_StructPerLevel LinkToStruct_PerLevel
    real value
    method Get takes nothing returns real
        return this.value
    endmethod
    method Set takes real value returns nothing
        set this.value = value
    endmethod
    method Add takes real value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Subtract takes real value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
            method Event_Create takes nothing returns nothing
                call this.Set(0.)
                call this.PerLevel.Event_Create()
            endmethod
        endstruct
    endscope
    public struct StructHero
        implement Allocation
        implement List
        
    FolderHero_StructAgility Agility = this
    FolderHero_StructAgility LinkToStruct_Agility
    FolderHero_StructArmorPerLevel ArmorPerLevel = this
    FolderHero_StructArmorPerLevel LinkToStruct_ArmorPerLevel
    FolderHero_StructIntelligence Intelligence = this
    FolderHero_StructIntelligence LinkToStruct_Intelligence
    FolderHero_StructPrimaryAttribute PrimaryAttribute = this
    FolderHero_StructPrimaryAttribute LinkToStruct_PrimaryAttribute
    FolderHero_StructStrength Strength = this
    FolderHero_StructStrength LinkToStruct_Strength
        method Event_Create takes nothing returns nothing
            call this.Agility.Event_Create()
            call this.ArmorPerLevel.Event_Create()
            call this.Intelligence.Event_Create()
            call this.PrimaryAttribute.Event_Create()
            call this.Strength.Event_Create()
        endmethod
    endstruct
endscope
    globals
        UnitType UNIT_TYPE = STRUCT_BASE
    endglobals
    struct UnitType
        implement Allocation
        implement List
        
    static constant real HEROES_ARMOR_BASE = 0.
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static thistype TEMP
    string combatFlags
    integer self
    FolderUnitType_StructAbilities Abilities = this
    FolderUnitType_StructAbilities LinkToStruct_Abilities
    FolderUnitType_StructArmor Armor = this
    FolderUnitType_StructArmor LinkToStruct_Armor
    FolderUnitType_StructAttachments Attachments = this
    FolderUnitType_StructAttachments LinkToStruct_Attachments
    FolderUnitType_StructAttack Attack = this
    FolderUnitType_StructAttack LinkToStruct_Attack
    FolderUnitType_StructBlood Blood = this
    FolderUnitType_StructBlood LinkToStruct_Blood
    FolderUnitType_StructBloodExplosion BloodExplosion = this
    FolderUnitType_StructBloodExplosion LinkToStruct_BloodExplosion
    FolderUnitType_StructClasses Classes = this
    FolderUnitType_StructClasses LinkToStruct_Classes
    FolderUnitType_StructCollisionSize CollisionSize = this
    FolderUnitType_StructCollisionSize LinkToStruct_CollisionSize
    FolderUnitType_StructDamage Damage = this
    FolderUnitType_StructDamage LinkToStruct_Damage
    FolderUnitType_StructData Data = this
    FolderUnitType_StructData LinkToStruct_Data
    FolderUnitType_StructDecay Decay = this
    FolderUnitType_StructDecay LinkToStruct_Decay
    FolderUnitType_StructDrop Drop = this
    FolderUnitType_StructDrop LinkToStruct_Drop
    FolderUnitType_StructEvent Event = this
    FolderUnitType_StructEvent LinkToStruct_Event
    FolderUnitType_StructHero Hero = this
    FolderUnitType_StructHero LinkToStruct_Hero
    FolderUnitType_StructId Id = this
    FolderUnitType_StructId LinkToStruct_Id
    FolderUnitType_StructImpact Impact = this
    FolderUnitType_StructImpact LinkToStruct_Impact
    FolderUnitType_StructLife Life = this
    FolderUnitType_StructLife LinkToStruct_Life
    FolderUnitType_StructLifeRegeneration LifeRegeneration = this
    FolderUnitType_StructLifeRegeneration LinkToStruct_LifeRegeneration
    FolderUnitType_StructMana Mana = this
    FolderUnitType_StructMana LinkToStruct_Mana
    FolderUnitType_StructManaRegeneration ManaRegeneration = this
    FolderUnitType_StructManaRegeneration LinkToStruct_ManaRegeneration
    FolderUnitType_StructOutpact Outpact = this
    FolderUnitType_StructOutpact LinkToStruct_Outpact
    FolderUnitType_StructPreload Preload = this
    FolderUnitType_StructPreload LinkToStruct_Preload
    FolderUnitType_StructRevivalable Revivalable = this
    FolderUnitType_StructRevivalable LinkToStruct_Revivalable
    FolderUnitType_StructScale Scale = this
    FolderUnitType_StructScale LinkToStruct_Scale
    FolderUnitType_StructSightRange SightRange = this
    FolderUnitType_StructSightRange LinkToStruct_SightRange
    FolderUnitType_StructSpeed Speed = this
    FolderUnitType_StructSpeed LinkToStruct_Speed
    FolderUnitType_StructSpellPower SpellPower = this
    FolderUnitType_StructSpellPower LinkToStruct_SpellPower
    FolderUnitType_StructSpellVamp SpellVamp = this
    FolderUnitType_StructSpellVamp LinkToStruct_SpellVamp
    FolderUnitType_StructVertexColor VertexColor = this
    FolderUnitType_StructVertexColor LinkToStruct_VertexColor
    static method GetFromSelf takes integer self returns thistype
        return Memory.IntegerKeys.GetInteger(self, KEY)
    endmethod
    static method GetFromName takes string name returns thistype
        return StringData.Data.Integer.Get(name, KEY)
    endmethod
    method GetName takes nothing returns string
        return GetObjectName(this.self)
    endmethod
    method GetSelf takes nothing returns integer
        return this.self
    endmethod
    static key GetKeyMacro_INIT_KEY_ARRAY
    static constant integer INIT_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_INIT_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static method AddInit takes code c, string name returns nothing
        call Trigger.AddObjectInit(INIT_KEY_ARRAY, c, name)
    endmethod
    static method CreateBasic takes integer self returns thistype
        local thistype this = thistype.allocate()
        set this.combatFlags = null
        set this.self = self
        call this.Id.Event_Create()
        call this.Abilities.Event_Create()
        call this.Armor.Event_Create()
        call this.Attack.Event_Create()
        call this.Blood.Event_Create()
        call this.BloodExplosion.Event_Create()
        call this.CollisionSize.Event_Create()
        call this.Damage.Event_Create()
        call this.Decay.Event_Create()
        call this.Drop.Event_Create()
        call this.Hero.Event_Create()
        call this.Impact.Event_Create()
        call this.Life.Event_Create()
        call this.LifeRegeneration.Event_Create()
        call this.Mana.Event_Create()
        call this.ManaRegeneration.Event_Create()
        call this.Preload.Event_Create()
        call this.Outpact.Event_Create()
        call this.Revivalable.Event_Create()
        call this.Scale.Event_Create()
        call this.Speed.Event_Create()
        call this.SpellPower.Event_Create()
        call this.SpellVamp.Event_Create()
        call this.VertexColor.Event_Create()
        call this.BloodExplosion.Set("Objects\\Spawnmodels\\Human\\HumanSmallDeathExplode\\HumanSmallDeathExplode.mdl")
        call this.AddToList()
        call StringData.Data.Integer.Set(this.GetName(), KEY, this)
        return this
    endmethod
    static method Create takes integer self returns thistype
        local thistype this = thistype.CreateBasic(self)
        set this.self = self
        call Memory.IntegerKeys.SetInteger(self, KEY, this)
        return this
    endmethod
    static method CreateHidden takes nothing returns thistype
        return thistype.CreateBasic(0)
    endmethod
    execMethod Init_Executed
    endmethod
    static method Init takes nothing returns nothing
        call Code.Run(function thistype.Init_Executed)
    endmethod
endstruct
    globals
        Force FORCE = STRUCT_BASE
    endglobals
    struct Force
        implement Allocation
        implement List
        
    static integer QUEUE_SIZE = ARRAY_EMPTY
    static thistype array QUEUED
	static thistype ALL_USERS
    force self
    method GetSelf takes nothing returns force
        return this.self
    endmethod
    method Destroy takes nothing returns nothing
        set thistype.QUEUE_SIZE = thistype.QUEUE_SIZE + 1
        set thistype.QUEUED[thistype.QUEUE_SIZE] = this
        call ForceClear(this.self)
    endmethod
    method ContainsPlayer takes User whichPlayer returns boolean
        return IsPlayerInForce(whichPlayer.self, this.self)
    endmethod
    static method GetFirst_Enum takes nothing returns nothing
        set User.TEMP = User.GetFromSelf(GetEnumPlayer())
    endmethod
    method GetFirst takes nothing returns User
        set User.TEMP = NULL
        call ForForce(this.self, function thistype.GetFirst_Enum)
        return User.TEMP
    endmethod
    static integer array DATA_STACK
    static Trigger array DATA_STACK_ACTION
    static integer DATA_STACK_NESTING = -1
    static method Do_Enum takes nothing returns nothing
        local EventResponse params = EventResponse.Create(EventResponse.DIRECT_SUBJECT_ID)
        call params.User.SetTrigger(USER.Event.Native.GetEnum())
        call params.SetData(thistype.DATA_STACK[thistype.DATA_STACK_NESTING])
        call thistype.DATA_STACK_ACTION[thistype.DATA_STACK_NESTING].RunWithParams(params)
        call params.Destroy()
    endmethod
    method Do takes code action, integer data returns nothing
        set thistype.DATA_STACK_NESTING = thistype.DATA_STACK_NESTING + 1
        set thistype.DATA_STACK[thistype.DATA_STACK_NESTING] = data
        set thistype.DATA_STACK_ACTION[thistype.DATA_STACK_NESTING] = Trigger.GetFromCode(action)
        call ForForce(this.self, function thistype.Do_Enum)
        set thistype.DATA_STACK_NESTING = thistype.DATA_STACK_NESTING - 1
    endmethod
    method RemovePlayer takes User whichPlayer returns nothing
        call ForceRemovePlayer(this.self, whichPlayer.self)
    endmethod
    method AddPlayer takes User whichPlayer returns nothing
        call ForceAddPlayer(this.self, whichPlayer.self)
    endmethod
    static method Create takes nothing returns thistype
        local thistype this
        if (thistype.QUEUE_SIZE == ARRAY_EMPTY) then
            set this = thistype.allocate()
            
            set this.self = CreateForce()
            return this
        endif
        set this = thistype.QUEUED[thistype.QUEUE_SIZE]
        set thistype.QUEUE_SIZE = thistype.QUEUE_SIZE - 1
        return this
    endmethod
    static method Init takes nothing returns nothing
    	set thistype.ALL_USERS = thistype.Create()
		local integer i = User.ALL_COUNT
    	
    	loop
    		exitwhen (i < ARRAY_MIN)
    		
    		call thistype.ALL_USERS.AddPlayer(User.ALL[i])
    		
    		set i = i - 1
    	endloop
    endmethod
endstruct
    globals
        PlayerController PLAYER_CONTROLLER = STRUCT_BASE
    endglobals
    struct PlayerController
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_PARENT_KEY
    static constant integer PARENT_KEY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_PARENT_KEY * Memory.IntegerKeys.Table.SIZE
    static thistype CPU
    static thistype HUMAN
    mapcontrol self
    static method GetFromSelf takes mapcontrol self returns thistype
        static if DEBUG then
            if (Memory.IntegerKeys.GetInteger(PARENT_KEY + GetHandleId(self), KEY) == HASH_TABLE.Integer.DEFAULT_VALUE) then
                call DebugEx("PlayerController: GetFromSelf: "+I2S(GetHandleId(self)))
            endif
        endif
        return Memory.IntegerKeys.GetInteger(PARENT_KEY + GetHandleId(self), KEY)
    endmethod
    method AddSelf takes mapcontrol self returns nothing
        call Memory.IntegerKeys.SetInteger(PARENT_KEY + GetHandleId(self), KEY, this)
    endmethod
    static method Create takes mapcontrol self returns thistype
        local thistype this = thistype.allocate()
        set this.self = self
        call Memory.IntegerKeys.SetInteger(PARENT_KEY + GetHandleId(self), KEY, this)
        return this
    endmethod
    static method Init takes nothing returns nothing
        set thistype.CPU = thistype.Create(MAP_CONTROL_COMPUTER)
        set thistype.HUMAN = thistype.Create(MAP_CONTROL_USER)
        call thistype.CPU.AddSelf(MAP_CONTROL_CREEP)
        call thistype.CPU.AddSelf(MAP_CONTROL_NONE)
    endmethod
endstruct
    globals
        PlayerSlotState PLAYER_SLOT_STATE = STRUCT_BASE
    endglobals
    struct PlayerSlotState
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_PARENT_KEY
    static constant integer PARENT_KEY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_PARENT_KEY * Memory.IntegerKeys.Table.SIZE
    static thistype EMPTY
    static thistype LEFT
    static thistype PLAYING
    playerslotstate self
    static method GetFromSelf takes playerslotstate self returns thistype
        return Memory.IntegerKeys.GetInteger(PARENT_KEY + GetHandleId(self), KEY)
    endmethod
    static method Create takes playerslotstate self returns thistype
        local thistype this = thistype.allocate()
        set this.self = self
        call Memory.IntegerKeys.SetInteger(PARENT_KEY + GetHandleId(self), KEY, this)
        return this
    endmethod
    static method Init takes nothing returns nothing
        set thistype.EMPTY = thistype.Create(PLAYER_SLOT_STATE_EMPTY)
        set thistype.LEFT = thistype.Create(PLAYER_SLOT_STATE_LEFT)
        set thistype.PLAYING = thistype.Create(PLAYER_SLOT_STATE_PLAYING)
    endmethod
endstruct
    globals
        Team TEAM = STRUCT_BASE
    endglobals
    struct Team
        implement Allocation
        implement List
        
    static key GetKeyMacro_MEMBERS_KEY_ARRAY
    static constant integer MEMBERS_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_MEMBERS_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_PARENT_KEY_ARRAY
    static constant integer PARENT_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_PARENT_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static thistype ATTACKERS
    static thistype DEFENDERS
    static thistype STAFF
    static method SetStateOfPlayers takes User whichPlayer, User otherPlayer, alliancetype whichType, boolean flag, boolean mutual returns nothing
        call SetPlayerAlliance(whichPlayer.self, otherPlayer.self, whichType, flag)
        if mutual then
            call SetPlayerAlliance(otherPlayer.self, whichPlayer.self, whichType, flag)
        endif
    endmethod
    method AddPlayer takes User whichPlayer returns nothing
        local integer iteration = Memory.IntegerKeys.Table.CountIntegers(PARENT_KEY_ARRAY + this, MEMBERS_KEY_ARRAY)
        loop
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            local User otherPlayer = Memory.IntegerKeys.Table.GetInteger(PARENT_KEY_ARRAY + this, MEMBERS_KEY_ARRAY, iteration)
            call thistype.SetStateOfPlayers(whichPlayer, otherPlayer, ALLIANCE_PASSIVE, true, true)
            call thistype.SetStateOfPlayers(whichPlayer, otherPlayer, ALLIANCE_SHARED_SPELLS, true, true)
            call thistype.SetStateOfPlayers(whichPlayer, otherPlayer, ALLIANCE_SHARED_VISION, true, true)
            set iteration = iteration - 1
        endloop
        call Memory.IntegerKeys.Table.AddInteger(PARENT_KEY_ARRAY + this, MEMBERS_KEY_ARRAY, whichPlayer)
    endmethod
    static method Init takes nothing returns nothing
        set thistype.ATTACKERS = thistype.allocate()
        set thistype.DEFENDERS = thistype.allocate()
        set thistype.STAFF = thistype.allocate()
    endmethod
endstruct
    struct Visibility
    static method AddRect takes User whichPlayer, Rectangle whichRect returns nothing
        if (whichPlayer == User.ANY) then
            local integer iteration = User.ALL_COUNT
            loop
                call thistype.AddRect(User.ALL[iteration], whichRect)
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
        else
            call FogModifierStart(CreateFogModifierRect(whichPlayer.self, FOG_OF_WAR_VISIBLE, whichRect.self, true, true))
            
        endif
    endmethod
    static method Init takes nothing returns nothing
    endmethod
endstruct
    scope FolderUser
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    public struct StructBoolean
        implement Allocation
        implement List
        
    method Get takes integer key returns boolean
        return User(this).Data.table.IntegerKeys.GetBoolean(User(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call User(this).Data.table.IntegerKeys.RemoveBoolean(User(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call User(this).Data.table.IntegerKeys.SetBoolean(User(this).Id.Get(), key, value)
    endmethod
    method Add takes integer key returns boolean
        local boolean oldValue = this.Get(key)
        call this.Set(key, not HASH_TABLE.Boolean.DEFAULT_VALUE)
        return (oldValue == HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Subtract takes integer key returns boolean
        local boolean oldValue = this.Get(key)
        call this.Set(key, HASH_TABLE.Boolean.DEFAULT_VALUE)
        return (oldValue != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
        endstruct
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return User(this).Data.table.IntegerKeys.Table.ContainsInteger(User(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return User(this).Data.table.IntegerKeys.Table.CountIntegers(User(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return User(this).Data.table.IntegerKeys.Table.IsEmptyInteger(User(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return User(this).Data.table.IntegerKeys.Table.GetInteger(User(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return User(this).Data.table.IntegerKeys.Table.GetFirstInteger(User(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return User(this).Data.table.IntegerKeys.Table.GetLastInteger(User(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call User(this).Data.table.IntegerKeys.Table.Clear(User(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return User(this).Data.table.IntegerKeys.Table.FetchFirstInteger(User(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return User(this).Data.table.IntegerKeys.Table.RemoveInteger(User(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return User(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(User(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return User(this).Data.table.IntegerKeys.Table.AddInteger(User(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return User(this).Data.table.IntegerKeys.Table.AddIntegerMulti(User(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call User(this).Data.table.IntegerKeys.Table.JoinInteger(User(this).Id.Get(), key, User(other).Data.table, User(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return User(this).Data.table.IntegerKeys.Table.RandomInteger(User(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call User(this).Data.table.IntegerKeys.Table.ShuffleIntegers(User(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call User(this).Data.table.IntegerKeys.Table.PrintIntegers(User(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return User(this).Data.table.IntegerKeys.GetInteger(User(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call User(this).Data.table.IntegerKeys.RemoveInteger(User(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call User(this).Data.table.IntegerKeys.SetInteger(User(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(User(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject User.Allocation.deallocate_demount.hook
		call User(this).Data.Destroy()
	endinject
	inject User.Allocation.allocate_mount.hook
		call User(this).Data.Event_Create()
	endinject
    endstruct
    scope FolderEvent
    public struct StructNative
        implement Allocation
        implement List
        
            static method GetEnum takes nothing returns User
                return User.GetFromSelf(GetEnumPlayer())
            endmethod
            
            static method GetTrigger takes nothing returns User
                return User.GetFromSelf(GetTriggerPlayer())
            endmethod
        endstruct
    endscope
    public struct StructEvent
        implement Allocation
        implement List
        
    FolderEvent_StructNative Native = this
    FolderEvent_StructNative LinkToStruct_Native
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(User(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(User(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(User(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(User(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(User(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(User(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(User(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(User(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject User.Allocation.deallocate_demount.hook
			call User(this).Event.Destroy()
		endinject
		inject User.Allocation.allocate_mount.hook
			call User(this).Event.Event_Create()
		endinject
    endstruct
    public struct StructController
        implement Allocation
        implement List
        
    PlayerController value
    method Get takes nothing returns PlayerController
        return this.value
    endmethod
        method Set takes PlayerController value returns nothing
            set this.value = value
            if (value == PlayerController.HUMAN) then
                set User.HUMANS_COUNT = User.HUMANS_COUNT + 1
                set User.HUMANS[User.HUMANS_COUNT] = this
            endif
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Set(PlayerController.GetFromSelf(GetPlayerController(User(this).self)))
        endmethod
    endstruct
    public struct StructHostAppointment
        implement Allocation
        implement List
        
        static EventType DUMMY_EVENT_TYPE
        static Event LEAVE_EVENT
        static gamecache TABLE
        static User VAL = NULL
		static method Count takes nothing returns integer
			local integer iteration = EventPriority.ALL_COUNT
			local integer c=0
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = Event.CountAtStatics(thistype.DUMMY_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    set c=c+1
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            return c
		endmethod
        static method TriggerEvents takes User old, User val returns nothing
            local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
            call params.User.SetTrigger(val)
			local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = Event.CountAtStatics(thistype.DUMMY_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call Event.GetFromStatics(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            call params.Destroy()
        endmethod
        static method Set takes User val returns nothing
            local User old = thistype.VAL
            if (val == old) then
                return
            endif
            if (old != NULL) then
                call old.Event.Remove(thistype.LEAVE_EVENT)
            endif
            set thistype.VAL = val
            call val.Event.Add(thistype.LEAVE_EVENT)
            set User.HOST = val
            call InfoEx("new host is "+val.GetColoredName())
            call thistype.TriggerEvents(old, val)
        endmethod
        static method SetByNative takes nothing returns nothing
            call StoreInteger(thistype.TABLE, "", "", User.GetLocal())
            call TriggerSyncStart()
            call SyncStoredInteger(thistype.TABLE, "", "")
            call TriggerSyncReady()
            call thistype.Set(GetStoredInteger(thistype.TABLE, "", ""))
        endmethod
        eventMethod Event_Leave
            call Code.Run(function thistype.SetByNative)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DUMMY_EVENT_TYPE = EventType.Create()
            set thistype.LEAVE_EVENT = Event.Create(User.LEAVE_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Leave)
            set thistype.TABLE = InitGameCache(thistype.NAME)
            call thistype.Set(User.HUMANS[ARRAY_MIN])
            call Code.Run(function thistype.SetByNative)
        endmethod
    endstruct
    public struct StructHero
        implement Allocation
        implement List
        
        static Group ENUM_GROUP
    Unit value
    method Get takes nothing returns Unit
        return this.value
    endmethod
    method Set takes Unit value returns nothing
        set this.value = value
    endmethod
    method Add takes Unit value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(NULL)
    endmethod
    method Subtract takes Unit value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
        method EnumAll takes code actionFunction, boolean includeDead returns nothing
            local integer iteration = User.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local Unit target = thistype(User.ALL[iteration]).Get()
                if target.Classes.Contains(UnitClass.DEAD) then
                    if includeDead then
                        call thistype.ENUM_GROUP.AddUnit(HeroRevival.GetGhostByUnit(target))
                    endif
                else
                    call thistype.ENUM_GROUP.AddUnit(target)
                endif
                set iteration = iteration - 1
            endloop
            call thistype.ENUM_GROUP.Do(actionFunction)
        endmethod
        method AddState takes UnitState whichState, real amount returns nothing
            if (this == User.ANY) then
                local integer iteration = User.ALL_COUNT
                loop
                    call User.ALL[iteration].Hero.AddState(whichState, amount)
                    set iteration = iteration - 1
                    exitwhen (iteration < ARRAY_MIN)
                endloop
            else
                local Unit thisUnit = this.Get()
                if (thisUnit != NULL) then
                    call whichState.Run(thisUnit, amount)
                endif
            endif
        endmethod
        static method Init takes nothing returns nothing
            set thistype.ENUM_GROUP = Group.Create()
        endmethod
    endstruct
    scope FolderKeyEvent
    public struct StructDownArrow
        implement Allocation
        implement List
        
            static Event DESTROY_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
            static EventType PRESS_EVENT_TYPE
            static EventType RELEASE_EVENT_TYPE
            static real TRIGGER_INTERVAL_WEIGHT
			static boolean array IS_PRESSING
            real interval
            Timer intervalTimer
            real intervalWeight
            Event whichEvent
            User whichPlayer
			method IsPressing takes nothing returns boolean
				return thistype.IS_PRESSING[this]
			endmethod
            eventMethod Event_Destroy
                local Event whichEvent = params.Event.GetTrigger()
                local thistype this = whichEvent.Data.Integer.Get(KEY)
                local Timer intervalTimer = this.intervalTimer
                local User whichPlayer = this.whichPlayer
                call this.deallocate()
                call intervalTimer.Destroy()
                call whichEvent.Data.Integer.Remove(KEY)
                call whichEvent.RemoveEvent(DESTROY_EVENT)
                call whichPlayer.Data.Integer.Table.Remove(KEY_ARRAY, this)
                call whichPlayer.Event.Remove(whichEvent)
            endmethod
            static method Release_TriggerEvents takes User parent returns nothing
                local EventResponse params = EventResponse.Create(parent.Id.Get())
                call params.User.SetTrigger(parent)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = parent.Event.Count(thistype.RELEASE_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call parent.Event.Get(thistype.RELEASE_EVENT_TYPE, priority, iteration2).Run(params)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call params.Destroy()
            endmethod
            trigMethod ReleaseTrig
                local User parent = USER.Event.Native.GetTrigger()
				set thistype.IS_PRESSING[parent] = false
                call thistype.Release_TriggerEvents(parent)
				local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                loop
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                    call this.intervalTimer.Pause()
                    set iteration = iteration - 1
                endloop
            endmethod
            static method Press_TriggerEvents takes User parent returns nothing
                local EventResponse params = EventResponse.Create(parent.Id.Get())
                call params.Real.SetIntervalWeight(1.)
                call params.User.SetTrigger(parent)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = parent.Event.Count(thistype.PRESS_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call parent.Event.Get(thistype.PRESS_EVENT_TYPE, priority, iteration2).Run(params)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call params.Destroy()
            endmethod
            timerMethod Interval
                local thistype this = Timer.GetExpired().GetData()
                local EventResponse params = EventResponse.Create(EventResponse.DIRECT_SUBJECT_ID)
                call params.Real.SetIntervalWeight(this.intervalWeight)
                call params.User.SetTrigger(this.whichPlayer)
                call this.whichEvent.Run(params)
                call params.Destroy()
            endmethod
            trigMethod PressTrig
                local User parent = USER.Event.Native.GetTrigger()
				set thistype.IS_PRESSING[parent] = true
                call thistype.Press_TriggerEvents(parent)
				local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                loop
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                    call this.intervalTimer.Start(this.interval, true, function thistype.Interval)
                    set iteration = iteration - 1
                endloop
            endmethod
            method RegisterPress takes EventPriority priority, code actionFunction, real interval, real intervalWeight returns Event
                local User parent = this
                local Event result = Event.Create(thistype.PRESS_EVENT_TYPE, priority, actionFunction)
                if (interval > 0.) then
                    set this = thistype.allocate()
					local Timer intervalTimer = Timer.Create()
                    set this.interval = interval
                    set this.intervalTimer = intervalTimer
                    set this.intervalWeight = intervalWeight
                    set this.whichEvent = result
                    set this.whichPlayer = parent
                    call intervalTimer.SetData(this)
                    call parent.Data.Integer.Table.Add(KEY_ARRAY, this)
                    call result.AddEvent(DESTROY_EVENT)
                    call result.Data.Integer.Set(KEY, this)
                endif
                call parent.Event.Add(result)
                return result
            endmethod
	    	enumMethod InitPlayer
	    		local User parent = params.User.GetTrigger()
				set thistype.IS_PRESSING[parent] = false
	    	endmethod
            static method Init takes nothing returns nothing
                set thistype.DESTROY_EVENT = Event.Create(Event.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
                set thistype.PRESS_EVENT_TYPE = EventType.Create()
                set thistype.RELEASE_EVENT_TYPE = EventType.Create()
                call Trigger.CreateFromCode(function thistype.PressTrig).RegisterEvent.User(User.ANY, EVENT_PLAYER_ARROW_DOWN_DOWN)
                call Trigger.CreateFromCode(function thistype.ReleaseTrig).RegisterEvent.User(User.ANY, EVENT_PLAYER_ARROW_DOWN_UP)
                
                call Force.ALL_USERS.Do(function thistype.InitPlayer, NULL)
            endmethod
        endstruct
    public struct StructLeftArrow
        implement Allocation
        implement List
        
            static Event DESTROY_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
            static EventType PRESS_EVENT_TYPE
            static EventType RELEASE_EVENT_TYPE
            static real TRIGGER_INTERVAL_WEIGHT
			static boolean array IS_PRESSING
            real interval
            Timer intervalTimer
            real intervalWeight
            Event whichEvent
            User whichPlayer
			method IsPressing takes nothing returns boolean
				return thistype.IS_PRESSING[this]
			endmethod
            eventMethod Event_Destroy
                local Event whichEvent = params.Event.GetTrigger()
                local thistype this = whichEvent.Data.Integer.Get(KEY)
                local Timer intervalTimer = this.intervalTimer
                local User whichPlayer = this.whichPlayer
                call this.deallocate()
                call intervalTimer.Destroy()
                call whichEvent.Data.Integer.Remove(KEY)
                call whichEvent.RemoveEvent(DESTROY_EVENT)
                call whichPlayer.Data.Integer.Table.Remove(KEY_ARRAY, this)
                call whichPlayer.Event.Remove(whichEvent)
            endmethod
            static method Release_TriggerEvents takes User parent returns nothing
                local EventResponse params = EventResponse.Create(parent.Id.Get())
                call params.User.SetTrigger(parent)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = parent.Event.Count(thistype.RELEASE_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call parent.Event.Get(thistype.RELEASE_EVENT_TYPE, priority, iteration2).Run(params)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call params.Destroy()
            endmethod
            trigMethod ReleaseTrig
                local User parent = USER.Event.Native.GetTrigger()
				set thistype.IS_PRESSING[parent] = false
                call thistype.Release_TriggerEvents(parent)
				local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                loop
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                    call this.intervalTimer.Pause()
                    set iteration = iteration - 1
                endloop
            endmethod
            static method Press_TriggerEvents takes User parent returns nothing
                local EventResponse params = EventResponse.Create(parent.Id.Get())
                call params.Real.SetIntervalWeight(1.)
                call params.User.SetTrigger(parent)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = parent.Event.Count(thistype.PRESS_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call parent.Event.Get(thistype.PRESS_EVENT_TYPE, priority, iteration2).Run(params)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call params.Destroy()
            endmethod
            timerMethod Interval
                local thistype this = Timer.GetExpired().GetData()
                local EventResponse params = EventResponse.Create(EventResponse.DIRECT_SUBJECT_ID)
                call params.Real.SetIntervalWeight(this.intervalWeight)
                call params.User.SetTrigger(this.whichPlayer)
                call this.whichEvent.Run(params)
                call params.Destroy()
            endmethod
            trigMethod PressTrig
                local User parent = USER.Event.Native.GetTrigger()
				set thistype.IS_PRESSING[parent] = true
                call thistype.Press_TriggerEvents(parent)
				local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                loop
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                    call this.intervalTimer.Start(this.interval, true, function thistype.Interval)
                    set iteration = iteration - 1
                endloop
            endmethod
            method RegisterPress takes EventPriority priority, code actionFunction, real interval, real intervalWeight returns Event
                local User parent = this
                local Event result = Event.Create(thistype.PRESS_EVENT_TYPE, priority, actionFunction)
                if (interval > 0.) then
                    set this = thistype.allocate()
					local Timer intervalTimer = Timer.Create()
                    set this.interval = interval
                    set this.intervalTimer = intervalTimer
                    set this.intervalWeight = intervalWeight
                    set this.whichEvent = result
                    set this.whichPlayer = parent
                    call intervalTimer.SetData(this)
                    call parent.Data.Integer.Table.Add(KEY_ARRAY, this)
                    call result.AddEvent(DESTROY_EVENT)
                    call result.Data.Integer.Set(KEY, this)
                endif
                call parent.Event.Add(result)
                return result
            endmethod
	    	enumMethod InitPlayer
	    		local User parent = params.User.GetTrigger()
				set thistype.IS_PRESSING[parent] = false
	    	endmethod
            static method Init takes nothing returns nothing
                set thistype.DESTROY_EVENT = Event.Create(Event.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
                set thistype.PRESS_EVENT_TYPE = EventType.Create()
                set thistype.RELEASE_EVENT_TYPE = EventType.Create()
                call Trigger.CreateFromCode(function thistype.PressTrig).RegisterEvent.User(User.ANY, EVENT_PLAYER_ARROW_LEFT_DOWN)
                call Trigger.CreateFromCode(function thistype.ReleaseTrig).RegisterEvent.User(User.ANY, EVENT_PLAYER_ARROW_LEFT_UP)
                
                call Force.ALL_USERS.Do(function thistype.InitPlayer, NULL)
            endmethod
        endstruct
    public struct StructRightArrow
        implement Allocation
        implement List
        
            static Event DESTROY_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
            static EventType PRESS_EVENT_TYPE
            static EventType RELEASE_EVENT_TYPE
            static real TRIGGER_INTERVAL_WEIGHT
			static boolean array IS_PRESSING
            real interval
            Timer intervalTimer
            real intervalWeight
            Event whichEvent
            User whichPlayer
			method IsPressing takes nothing returns boolean
				return thistype.IS_PRESSING[this]
			endmethod
            eventMethod Event_Destroy
                local Event whichEvent = params.Event.GetTrigger()
                local thistype this = whichEvent.Data.Integer.Get(KEY)
                local Timer intervalTimer = this.intervalTimer
                local User whichPlayer = this.whichPlayer
                call this.deallocate()
                call intervalTimer.Destroy()
                call whichEvent.Data.Integer.Remove(KEY)
                call whichEvent.RemoveEvent(DESTROY_EVENT)
                call whichPlayer.Data.Integer.Table.Remove(KEY_ARRAY, this)
                call whichPlayer.Event.Remove(whichEvent)
            endmethod
            static method Release_TriggerEvents takes User parent returns nothing
                local EventResponse params = EventResponse.Create(parent.Id.Get())
                call params.User.SetTrigger(parent)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = parent.Event.Count(thistype.RELEASE_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call parent.Event.Get(thistype.RELEASE_EVENT_TYPE, priority, iteration2).Run(params)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call params.Destroy()
            endmethod
            trigMethod ReleaseTrig
                local User parent = USER.Event.Native.GetTrigger()
				set thistype.IS_PRESSING[parent] = false
                call thistype.Release_TriggerEvents(parent)
				local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                loop
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                    call this.intervalTimer.Pause()
                    set iteration = iteration - 1
                endloop
            endmethod
            static method Press_TriggerEvents takes User parent returns nothing
                local EventResponse params = EventResponse.Create(parent.Id.Get())
                call params.Real.SetIntervalWeight(1.)
                call params.User.SetTrigger(parent)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = parent.Event.Count(thistype.PRESS_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call parent.Event.Get(thistype.PRESS_EVENT_TYPE, priority, iteration2).Run(params)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call params.Destroy()
            endmethod
            timerMethod Interval
                local thistype this = Timer.GetExpired().GetData()
                local EventResponse params = EventResponse.Create(EventResponse.DIRECT_SUBJECT_ID)
                call params.Real.SetIntervalWeight(this.intervalWeight)
                call params.User.SetTrigger(this.whichPlayer)
                call this.whichEvent.Run(params)
                call params.Destroy()
            endmethod
            trigMethod PressTrig
                local User parent = USER.Event.Native.GetTrigger()
				set thistype.IS_PRESSING[parent] = true
                call thistype.Press_TriggerEvents(parent)
				local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                loop
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                    call this.intervalTimer.Start(this.interval, true, function thistype.Interval)
                    set iteration = iteration - 1
                endloop
            endmethod
            method RegisterPress takes EventPriority priority, code actionFunction, real interval, real intervalWeight returns Event
                local User parent = this
                local Event result = Event.Create(thistype.PRESS_EVENT_TYPE, priority, actionFunction)
                if (interval > 0.) then
                    set this = thistype.allocate()
					local Timer intervalTimer = Timer.Create()
                    set this.interval = interval
                    set this.intervalTimer = intervalTimer
                    set this.intervalWeight = intervalWeight
                    set this.whichEvent = result
                    set this.whichPlayer = parent
                    call intervalTimer.SetData(this)
                    call parent.Data.Integer.Table.Add(KEY_ARRAY, this)
                    call result.AddEvent(DESTROY_EVENT)
                    call result.Data.Integer.Set(KEY, this)
                endif
                call parent.Event.Add(result)
                return result
            endmethod
	    	enumMethod InitPlayer
	    		local User parent = params.User.GetTrigger()
				set thistype.IS_PRESSING[parent] = false
	    	endmethod
            static method Init takes nothing returns nothing
                set thistype.DESTROY_EVENT = Event.Create(Event.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
                set thistype.PRESS_EVENT_TYPE = EventType.Create()
                set thistype.RELEASE_EVENT_TYPE = EventType.Create()
                call Trigger.CreateFromCode(function thistype.PressTrig).RegisterEvent.User(User.ANY, EVENT_PLAYER_ARROW_RIGHT_DOWN)
                call Trigger.CreateFromCode(function thistype.ReleaseTrig).RegisterEvent.User(User.ANY, EVENT_PLAYER_ARROW_RIGHT_UP)
                
                call Force.ALL_USERS.Do(function thistype.InitPlayer, NULL)
            endmethod
        endstruct
    public struct StructUpArrow
        implement Allocation
        implement List
        
            static Event DESTROY_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
            static EventType PRESS_EVENT_TYPE
            static EventType RELEASE_EVENT_TYPE
            static real TRIGGER_INTERVAL_WEIGHT
			static boolean array IS_PRESSING
            real interval
            Timer intervalTimer
            real intervalWeight
            Event whichEvent
            User whichPlayer
			method IsPressing takes nothing returns boolean
				return thistype.IS_PRESSING[this]
			endmethod
            eventMethod Event_Destroy
                local Event whichEvent = params.Event.GetTrigger()
                local thistype this = whichEvent.Data.Integer.Get(KEY)
                local Timer intervalTimer = this.intervalTimer
                local User whichPlayer = this.whichPlayer
                call this.deallocate()
                call intervalTimer.Destroy()
                call whichEvent.Data.Integer.Remove(KEY)
                call whichEvent.RemoveEvent(DESTROY_EVENT)
                call whichPlayer.Data.Integer.Table.Remove(KEY_ARRAY, this)
                call whichPlayer.Event.Remove(whichEvent)
            endmethod
            static method Release_TriggerEvents takes User parent returns nothing
                local EventResponse params = EventResponse.Create(parent.Id.Get())
                call params.User.SetTrigger(parent)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = parent.Event.Count(thistype.RELEASE_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call parent.Event.Get(thistype.RELEASE_EVENT_TYPE, priority, iteration2).Run(params)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call params.Destroy()
            endmethod
            trigMethod ReleaseTrig
                local User parent = USER.Event.Native.GetTrigger()
				set thistype.IS_PRESSING[parent] = false
                call thistype.Release_TriggerEvents(parent)
                local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                loop
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                    call this.intervalTimer.Pause()
                    set iteration = iteration - 1
                endloop
            endmethod
            static method Press_TriggerEvents takes User parent returns nothing
                local EventResponse params = EventResponse.Create(parent.Id.Get())
                call params.Real.SetIntervalWeight(1.)
                call params.User.SetTrigger(parent)
				local integer iteration = EventPriority.ALL_COUNT
                loop
                    exitwhen (iteration < ARRAY_MIN)
                    local EventPriority priority = EventPriority.ALL[iteration]
                    local integer iteration2 = parent.Event.Count(thistype.PRESS_EVENT_TYPE, priority)
                    loop
                        exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                        call parent.Event.Get(thistype.PRESS_EVENT_TYPE, priority, iteration2).Run(params)
                        set iteration2 = iteration2 - 1
                    endloop
                    set iteration = iteration - 1
                endloop
                call params.Destroy()
            endmethod
            timerMethod Interval
                local thistype this = Timer.GetExpired().GetData()
                local EventResponse params = EventResponse.Create(EventResponse.DIRECT_SUBJECT_ID)
                call params.Real.SetIntervalWeight(this.intervalWeight)
                call params.User.SetTrigger(this.whichPlayer)
                call this.whichEvent.Run(params)
                call params.Destroy()
            endmethod
            trigMethod PressTrig
                local User parent = USER.Event.Native.GetTrigger()
				set thistype.IS_PRESSING[parent] = true
                call thistype.Press_TriggerEvents(parent)
				local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
                loop
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                    local thistype this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                    call this.intervalTimer.Start(this.interval, true, function thistype.Interval)
                    set iteration = iteration - 1
                endloop
            endmethod
            method RegisterPress takes EventPriority priority, code actionFunction, real interval, real intervalWeight returns Event
                local User parent = this
                local Event result = Event.Create(thistype.PRESS_EVENT_TYPE, priority, actionFunction)
                if (interval > 0.) then
                    set this = thistype.allocate()
					local Timer intervalTimer = Timer.Create()
                    set this.interval = interval
                    set this.intervalTimer = intervalTimer
                    set this.intervalWeight = intervalWeight
                    set this.whichEvent = result
                    set this.whichPlayer = parent
                    call intervalTimer.SetData(this)
                    call parent.Data.Integer.Table.Add(KEY_ARRAY, this)
                    call result.AddEvent(DESTROY_EVENT)
                    call result.Data.Integer.Set(KEY, this)
                endif
                call parent.Event.Add(result)
                return result
            endmethod
	    	enumMethod InitPlayer
	    		local User parent = params.User.GetTrigger()
				set thistype.IS_PRESSING[parent] = false
	    	endmethod
            static method Init takes nothing returns nothing
                set thistype.DESTROY_EVENT = Event.Create(Event.DESTROY_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_Destroy)
                set thistype.PRESS_EVENT_TYPE = EventType.Create()
                set thistype.RELEASE_EVENT_TYPE = EventType.Create()
                call Trigger.CreateFromCode(function thistype.PressTrig).RegisterEvent.User(User.ANY, EVENT_PLAYER_ARROW_UP_DOWN)
                call Trigger.CreateFromCode(function thistype.ReleaseTrig).RegisterEvent.User(User.ANY, EVENT_PLAYER_ARROW_UP_UP)
                
                call Force.ALL_USERS.Do(function thistype.InitPlayer, NULL)
            endmethod
        endstruct
    endscope
    public struct StructKeyEvent
        implement Allocation
        implement List
        
        static EventType ESC_EVENT_TYPE
        static Trigger ESC_TRIGGER
    FolderKeyEvent_StructDownArrow DownArrow = this
    FolderKeyEvent_StructDownArrow LinkToStruct_DownArrow
    FolderKeyEvent_StructLeftArrow LeftArrow = this
    FolderKeyEvent_StructLeftArrow LinkToStruct_LeftArrow
    FolderKeyEvent_StructRightArrow RightArrow = this
    FolderKeyEvent_StructRightArrow LinkToStruct_RightArrow
    FolderKeyEvent_StructUpArrow UpArrow = this
    FolderKeyEvent_StructUpArrow LinkToStruct_UpArrow
        method Esc_TriggerEvents takes nothing returns nothing
            local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
            call params.User.SetTrigger(this)
			local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = Event.CountAtStatics(thistype.ESC_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call Event.GetFromStatics(thistype.ESC_EVENT_TYPE, priority, iteration2).Run(params)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            call params.Destroy()
        endmethod
        trigMethod EscTrig
            local thistype this = USER.Event.Native.GetTrigger()
            call this.Esc_TriggerEvents()
        endmethod
        static method Init takes nothing returns nothing
            set thistype.ESC_EVENT_TYPE = EventType.Create()
            set thistype.ESC_TRIGGER = Trigger.CreateFromCode(function thistype.EscTrig)
            call thistype.ESC_TRIGGER.RegisterEvent.User(User.ANY, EVENT_PLAYER_END_CINEMATIC)
            call thistype(NULL).DownArrow.Init()
            call thistype(NULL).LeftArrow.Init()
            call thistype(NULL).RightArrow.Init()
            call thistype(NULL).UpArrow.Init()
        endmethod
    endstruct
    public struct StructSlotState
        implement Allocation
        implement List
        
    static key GetKeyMacro_PLAYING_HUMANS_KEY
    static constant integer PLAYING_HUMANS_KEY = Math.Integer.MIN + GetKeyMacro_PLAYING_HUMANS_KEY
    PlayerSlotState value
    method Get takes nothing returns PlayerSlotState
        return this.value
    endmethod
        method ChangePlayingHumans takes PlayerSlotState oldValue, PlayerSlotState value returns nothing
            if (oldValue == PlayerSlotState.PLAYING) then
                local integer index = User(this).Data.Integer.Get(PLAYING_HUMANS_KEY)
                local User otherPlayer = User.PLAYING_HUMANS[User.PLAYING_HUMANS_COUNT]
                set User.PLAYING_HUMANS[index] = otherPlayer
                set User.PLAYING_HUMANS_COUNT = User.PLAYING_HUMANS_COUNT - 1
                call otherPlayer.Data.Integer.Set(PLAYING_HUMANS_KEY, index)
            elseif (value == PlayerSlotState.PLAYING) then
                set User.PLAYING_HUMANS_COUNT = User.PLAYING_HUMANS_COUNT + 1
                set User.PLAYING_HUMANS[User.PLAYING_HUMANS_COUNT] = this
                call User(this).Data.Integer.Set(PLAYING_HUMANS_KEY, User.PLAYING_HUMANS_COUNT)
            endif
        endmethod
        method Set takes PlayerSlotState value returns nothing
            local PlayerSlotState oldValue = this.value
            set this.value = value
            if ((oldValue != value) and (User(this).Controller.Get() == PlayerController.HUMAN)) then
                call this.ChangePlayingHumans(oldValue, value)
            endif
        endmethod
    method Event_Create takes nothing returns nothing
        set this.value = PlayerSlotState.EMPTY
        call this.Set(PlayerSlotState.GetFromSelf(GetPlayerSlotState(User(this).self)))
    endmethod
    endstruct
    public struct StructState
        implement Allocation
        implement List
        
        method Get takes playerstate whichPlayerState returns integer
            return GetPlayerState(User(this).self, whichPlayerState)
        endmethod
        method Set takes playerstate whichPlayerState, integer value returns nothing
            if (this == User.ANY) then
                local integer iteration = User.ALL_COUNT
                loop
                    call User.ALL[iteration].State.Set(whichPlayerState, value)
                    set iteration = iteration - 1
                    exitwhen (iteration < ARRAY_MIN)
                endloop
            else
                call SetPlayerState(User(this).self, whichPlayerState, value)
            endif
        endmethod
        method Add takes playerstate whichPlayerState, integer value returns nothing
            call this.Set(whichPlayerState, this.Get(whichPlayerState) + value)
        endmethod
        method Subtract takes playerstate whichPlayerState, integer value returns nothing
            call this.Set(whichPlayerState, this.Get(whichPlayerState) - value)
        endmethod
    endstruct
    public struct StructTeam
        implement Allocation
        implement List
        
        Team value
        method Get takes nothing returns Team
            return this.value
        endmethod
        method Set takes Team value returns nothing
            set this.value = value
            call value.AddPlayer(this)
        endmethod
    method Event_Create takes nothing returns nothing
        set this.value = NULL
    endmethod
    endstruct
endscope
globals
    constant integer User_MAX_AMOUNT_Wrapped = 16
endglobals
    globals
        User USER = STRUCT_BASE
    endglobals
    struct User
        implement Allocation
        implement List
        
    static EventType CHAT_EVENT_TYPE
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static EventType LEAVE_EVENT_TYPE
    static constant integer MAX_HUMAN_INDEX = 6
    static thistype TEMP
    static thistype array TEMPS
    static thistype ANY
    static thistype CASTLE
    static thistype CASTLE_CONTROLABLE
    static thistype CREEP
    static thistype DUMMY
    static thistype HOST
    static thistype array HUMANS
    static integer HUMANS_COUNT = ARRAY_EMPTY
    static thistype NEUTRAL_AGGRESSIVE
    static thistype NEUTRAL_PASSIVE
    static thistype array PLAYING_HUMANS
    static integer PLAYING_HUMANS_COUNT = ARRAY_EMPTY
    static thistype SPAWN
    playercolor color
    string name
    player self
    FolderUser_StructController Controller = this
    FolderUser_StructController LinkToStruct_Controller
    FolderUser_StructData Data = this
    FolderUser_StructData LinkToStruct_Data
    FolderUser_StructEvent Event = this
    FolderUser_StructEvent LinkToStruct_Event
    FolderUser_StructHostAppointment HostAppointment = this
    FolderUser_StructHostAppointment LinkToStruct_HostAppointment
    FolderUser_StructHero Hero = this
    FolderUser_StructHero LinkToStruct_Hero
    FolderUser_StructId Id = this
    FolderUser_StructId LinkToStruct_Id
    FolderUser_StructKeyEvent KeyEvent = this
    FolderUser_StructKeyEvent LinkToStruct_KeyEvent
    FolderUser_StructSlotState SlotState = this
    FolderUser_StructSlotState LinkToStruct_SlotState
    FolderUser_StructState State = this
    FolderUser_StructState LinkToStruct_State
    FolderUser_StructTeam Team = this
    FolderUser_StructTeam LinkToStruct_Team
    string colorString
    method GetColorString takes nothing returns string
        return this.colorString
    endmethod
    method SetColorString takes string value returns nothing
        set this.colorString = value
    endmethod
    method GetColor takes nothing returns playercolor
        return this.color
    endmethod
    method GetColoredName takes nothing returns string
        return (String.Color.START + this.colorString + this.name + String.Color.RESET)
    endmethod
    static method GetFromSelf takes player self returns thistype
        return Memory.IntegerKeys.GetIntegerByHandle(self, KEY)
    endmethod
    static method GetLocal takes nothing returns thistype
        return GetFromSelf(GetLocalPlayer())
    endmethod
    method IsLocal takes nothing returns boolean
        if (this == thistype.GetLocal()) then
            return true
        endif
        if (this == thistype.ANY) then
            return true
        endif
        return false
    endmethod
    method GetName takes nothing returns string
        return this.name
    endmethod
    method GetSelf takes nothing returns player
        return this.self
    endmethod
    method Chat_TriggerEvents takes string input returns nothing        
        local EventResponse params = EventResponse.Create(EventResponse.STRING_DATA_SUBJECT_ID)
        call params.User.SetTrigger(this)
		local string matchInput = input
        loop
            exitwhen (matchInput == null)
            call params.String.SetChat(input)
            call params.String.SetMatch(matchInput)
            local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = StringData.Event.Count(matchInput, thistype.CHAT_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.StringKeys.Table.STARTED)
                    call StringData.Event.Get(matchInput, thistype.CHAT_EVENT_TYPE, priority, iteration2).Run(params)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            set matchInput = String.SubLeft(matchInput, String.Length(matchInput) - 2)
        endloop
        call params.Destroy()
    endmethod
    trigMethod ChatTrig
        local string input = StringData.Event.Native.GetChat()
        local thistype this = USER.Event.Native.GetTrigger()
        call this.Chat_TriggerEvents(input)
    endmethod
    static method Chat_Init takes nothing returns nothing
        call Trigger.CreateFromCode(function thistype.ChatTrig).RegisterEvent.UserChat(thistype.ANY, "", false)
    endmethod
    method EnableAbilityBySelf takes integer spellId, boolean flag returns nothing
        if (this == thistype.ANY) then
            local integer iteration = thistype.ALL_COUNT
            loop
                call thistype.ALL[iteration].EnableAbilityBySelf(spellId, flag)
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
        else
            call SetPlayerAbilityAvailable(this.self, spellId, flag)
        endif
    endmethod
    method EnableAbility takes Spell whichSpell, boolean flag returns nothing
        call this.EnableAbilityBySelf(whichSpell.self, flag)
    endmethod
    method Leave_TriggerEvents takes nothing returns nothing
        local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
        local EventResponse userParams = EventResponse.Create(this.Id.Get())
        call params.User.SetTrigger(this)
        call userParams.User.SetTrigger(this)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = Event.CountAtStatics(thistype.LEAVE_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call Event.GetFromStatics(thistype.LEAVE_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration2 = this.Event.Count(thistype.LEAVE_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.LEAVE_EVENT_TYPE, priority, iteration2).Run(userParams)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
        call userParams.Destroy()
    endmethod
    trigMethod LeaveTrig
        local thistype this = USER.Event.Native.GetTrigger()
        call Game.DisplayTextTimed(thistype.ANY, String.Color.Do(this.GetName(), this.GetColorString()) + "'s footprints were blown away", 10.)
        call this.Leave_TriggerEvents()
    endmethod
    static method Leave_Init takes nothing returns nothing
        set thistype.LEAVE_EVENT_TYPE = EventType.Create()
        call Trigger.CreateFromCode(function thistype.LeaveTrig).RegisterEvent.User(thistype.ANY, EVENT_PLAYER_LEAVE)
    endmethod
    method EnumSelectedUnits takes code action returns nothing
        local integer iteration = UNIT.Selection.CountAtPlayer(this)
        if (iteration < Memory.IntegerKeys.Table.STARTED) then
            return
        endif
        local Group dummyGroup = Group.Create()
        loop
            call dummyGroup.AddUnit(UNIT.Selection.GetFromPlayer(this, iteration))
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
        call dummyGroup.Do(action)
        call dummyGroup.Destroy()
    endmethod
    method SendError takes string msg returns nothing
        call Game.DisplayTextTimed(this, String.Color.GOLD + msg + String.Color.RESET, 2.)
        call Sound.ERROR.PlayForPlayer(this)
    endmethod
    method SetColor takes playercolor value returns nothing
        set this.color = value
        call SetPlayerColor(this.self, value)
    endmethod
    method SetName takes string value returns nothing
        set this.name = value
        call SetPlayerName(this.self, value)
    endmethod
    method SetResearchBySelf takes integer researchId, integer level returns nothing
        if (this == thistype.ANY) then
            local integer iteration = thistype.ALL_COUNT
            loop
                call thistype.ALL[iteration].SetResearchBySelf(researchId, level)
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
        else
            call SetPlayerTechResearched(this.self, researchId, level)
        endif
    endmethod
    method SetTeam takes Team whichTeam returns nothing
        call this.Team.Set(whichTeam)
    endmethod
	method GetNativeIndex takes nothing returns integer
		if (this == NULL) then
			call DebugEx(thistype.NAME + "GetNativeIndex: no valid user " + Integer.ToString(this))
			
			return -1
		endif
		if (this.self == null) then
			call DebugEx(thistype.NAME + "GetNativeIndex: no valid self " + Integer.ToString(this))
			
			return -1
		endif
		
		return GetPlayerId(this.self)
	endmethod
    static method GetFromNativeIndex takes integer nativeIndex returns thistype
        if ((nativeIndex < 0) or (nativeIndex > User_MAX_AMOUNT_Wrapped - 1)) then
            call DebugEx(thistype.NAME + "GetFromNativeIndex: " + Integer.ToString(nativeIndex) + " out of bounds")
            return NULL
        endif
        local thistype this = User.GetFromSelf(Player(nativeIndex))
        if (this == NULL) then
            call DebugEx(thistype.NAME + "GetFromNativeIndex: " + Integer.ToString(nativeIndex) + " not assigned")
            return NULL
        endif
        return this
    endmethod
    static method Create takes string defaultName, integer nativeIndex, string colorString returns thistype
        local thistype this = thistype.allocate()
		local player self = Player(nativeIndex)
        set this.self = self
        call Memory.IntegerKeys.SetIntegerByHandle(self, KEY, this)
        call this.SetColor(GetPlayerColor(self))
        call this.SetColorString(colorString)
        call this.SetName(GetPlayerName(self))
        set self = null
        call this.AddToList()
        call this.Controller.Event_Create()
        call this.Hero.Event_Create()
        call this.Id.Event_Create()
        call this.SlotState.Event_Create()
        call this.Team.Event_Create()
        if ((GetPlayerController(this.self) != MAP_CONTROL_USER) or (GetPlayerSlotState(this.self) != PLAYER_SLOT_STATE_PLAYING)) then
            call this.SetName(defaultName)
        endif
        return this
    endmethod
    initMethod Init of Header_3
        set thistype.CHAT_EVENT_TYPE = EventType.Create()
        set thistype.LEAVE_EVENT_TYPE = EventType.Create()
        call thistype(NULL).Hero.Init()
        call PlayerController.Init()
        call PlayerSlotState.Init()
        call Team.Init()
        call Visibility.Init()
		local thistype this
        
        set this = thistype.Create("HumanRed", 0, "ffff0000")
        call this.SetTeam(Team.DEFENDERS)
        
        set this = thistype.Create("HumanBlue", 1, "ff0000ff")
        call this.SetTeam(Team.DEFENDERS)
        
        set this = thistype.Create("HumanTeal", 2, "ff18e7bd")
        call this.SetTeam(Team.DEFENDERS)
        
        set this = thistype.Create("HumanPurple", 3, "ff520084")
        call this.SetTeam(Team.DEFENDERS)
        
        set this = thistype.Create("HumanYellow", 4, "ffffff00")
        call this.SetTeam(Team.DEFENDERS)
        
        set this = thistype.Create("HumanOrange", 5, "ffff8a08")
        call this.SetTeam(Team.DEFENDERS)
        
        set this = thistype.Create("HumanGreen", 6, "ff18be00")
        call this.SetTeam(Team.DEFENDERS)
        
        set this = thistype.Create("Castle", 7, "ffe759ad")
        set thistype.CASTLE = this
        call this.SetTeam(Team.DEFENDERS)
        call StartCampaignAI(this.self, thistype.LALA_AI)
        
        set this = thistype.Create("Dummy", 8, "ff949694")
        set thistype.DUMMY = this
        call this.SetTeam(Team.STAFF)
        
        set this = thistype.Create("Creeps", 9, "ff7bbef7")
        set thistype.CREEP = this
        call this.SetColor(PLAYER_COLOR_AQUA)
        call this.SetTeam(Team.ATTACKERS)
        
        set this = thistype.Create("Spawns", 10, "ff086142")
        set thistype.SPAWN = this
        call this.SetColor(PLAYER_COLOR_BROWN)
        call this.SetTeam(Team.ATTACKERS)
        
        
        set this = thistype.Create("Castle (controlable)", 11, "ffe759ad")
        set thistype.CASTLE_CONTROLABLE = this
        call this.SetColor(PLAYER_COLOR_PINK)
        call this.SetTeam(Team.DEFENDERS)
        
        set this = thistype.Create("Neutral aggressive", 12, "ff000000")
        set thistype.NEUTRAL_AGGRESSIVE = this
        call this.SetTeam(Team.ATTACKERS)
		call Team.SetStateOfPlayers(this, this, ALLIANCE_PASSIVE, false, false)
        
        set this = thistype.Create("Neutral passive", 15, "ff000000")
        set thistype.NEUTRAL_PASSIVE = this
        set thistype.ANY = NULL
        local integer iteration = thistype.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            call Team.SetStateOfPlayers(User.DUMMY, thistype.ALL[iteration], ALLIANCE_PASSIVE, true, true)
            if (thistype.ALL[iteration].Team.Get() == Team.DEFENDERS) then
                call Team.SetStateOfPlayers(User.CASTLE_CONTROLABLE, thistype.ALL[iteration], ALLIANCE_SHARED_ADVANCED_CONTROL, true, true)
                call Team.SetStateOfPlayers(User.CASTLE_CONTROLABLE, thistype.ALL[iteration], ALLIANCE_SHARED_CONTROL, true, true)
            endif
            set iteration = iteration - 1
        endloop
        call Visibility.AddRect(thistype.DUMMY, Rectangle.WORLD)
        call Visibility.AddRect(thistype.SPAWN, Rectangle.WORLD)
        call Team.SetStateOfPlayers(User.CREEP, User.CASTLE, ALLIANCE_PASSIVE, true, true)
        call Team.SetStateOfPlayers(User.CREEP, User.CASTLE_CONTROLABLE, ALLIANCE_PASSIVE, true, true)
        call thistype.Chat_Init()
        call thistype.Leave_Init()
        call thistype(NULL).HostAppointment.Init()
        call Force.Init()
        call thistype(NULL).KeyEvent.Init()
    endmethod
endstruct
    globals
        WeatherType WEATHER_TYPE = STRUCT_BASE
    endglobals
    struct WeatherType
        implement Allocation
        implement List
        
    integer self
    method GetSelf takes nothing returns integer
        return this.self
    endmethod
    method SetSelf takes integer value returns nothing
        set this.self = value
    endmethod
    static method Create takes integer self returns thistype
        local thistype this = thistype.allocate()
        call this.SetSelf(self)
        return this
    endmethod
    static key GetKeyMacro_INIT_KEY_ARRAY
    static constant integer INIT_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_INIT_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static method AddInit takes code c, string name returns nothing
        call Trigger.AddObjectInit(INIT_KEY_ARRAY, c, name)
    endmethod
    static method Init takes nothing returns nothing
    endmethod
endstruct
    globals
        WeatherEffect WEATHER_EFFECT = STRUCT_BASE
    endglobals
    struct WeatherEffect
        implement Allocation
        implement List
        
    static thistype MOON
    weathereffect self
    method Destroy takes nothing returns nothing
        local weathereffect self = this.self
        call this.deallocate()
        call RemoveWeatherEffect(self)
        set self = null
    endmethod
    method Hide takes nothing returns nothing
        call EnableWeatherEffect(this.self, false)
    endmethod
    method Show takes nothing returns nothing
        call EnableWeatherEffect(this.self, true)
    endmethod
    static method Create takes Rectangle whichRect, WeatherType whichType returns thistype
        local thistype this = thistype.allocate()
        set this.self = AddWeatherEffect(whichRect.self, whichType.GetSelf())
        return this
    endmethod
    eventMethod Event_AfterIntro
        if params.User.GetTrigger().IsLocal() then
            call thistype.MOON.Show()
        endif
    endmethod
    eventMethod Event_Start
        set thistype.MOON = thistype.Create(Rectangle.WORLD, thistype.MOON_TYPE)
        call Event.Create(AfterIntro.FOR_PLAYER_EVENT_TYPE, EventPriority.HEADER, function thistype.Event_AfterIntro).AddToStatics()
    endmethod
    initMethod Init of Header_5
        call WeatherType.Init()
        call Event.Create(EventType.START, EventPriority.HEADER, function thistype.Event_Start).AddToStatics()
    endmethod
endstruct
    globals
        Initialization INITIALIZATION = STRUCT_BASE
    endglobals
    struct Initialization
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static sound MUSIC_SOUND
    static constant real START_DELAY = 3.
    static method TriggerEvents takes nothing returns nothing
        local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
		local integer iteration = ARRAY_MIN
        loop
            exitwhen (iteration > EventPriority.ALL_COUNT)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = Event.CountAtStatics(EventType.START, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call Event.GetFromStatics(EventType.START, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration + 1
        endloop
        call params.Destroy()
    endmethod
    static method Start takes nothing returns nothing
        call InfoEx("start game")
        call Loading.Ending()
        call StopSound(thistype.MUSIC_SOUND, true, false)
        set thistype.MUSIC_SOUND = null
		call Music.Create("Music\\Main.wav", 0).Play()
        call FogMaskEnable(false)
        call SetCameraField(CAMERA_FIELD_ANGLE_OF_ATTACK, 315., 0.)
        call SetCameraField(CAMERA_FIELD_TARGET_DISTANCE, 1650., 0.)
        call SetCameraField(CAMERA_FIELD_ZOFFSET, 0., 0.)
        call Trigger.Sleep(thistype.START_DELAY)
        call Loading.Ending2()
        call Camera.SetBounds(User.GetLocal(), -7680. + GetCameraMargin(CAMERA_MARGIN_LEFT), -7680. + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 7680. - GetCameraMargin(CAMERA_MARGIN_RIGHT), 7680. - GetCameraMargin(CAMERA_MARGIN_TOP), -7680. + GetCameraMargin(CAMERA_MARGIN_LEFT), 7680. - GetCameraMargin(CAMERA_MARGIN_TOP), 7680. - GetCameraMargin(CAMERA_MARGIN_RIGHT), -7680. + GetCameraMargin(CAMERA_MARGIN_BOTTOM))
        call EnableOcclusion(true)
        
        call Code.Run(function thistype.TriggerEvents)
    endmethod
    static method EndLoading takes nothing returns boolean
    	call InfoEx("ingame loading finished")
        call ObjThread.PrintErrors()
        call Code.Run(function thistype.Start)
		return true
    endmethod
    static method Other takes nothing returns boolean
       	
        call Game.FloatState.Set(GAME_STATE_TIME_OF_DAY, 12.)
        
		return true
    endmethod
	static method LoadHeader takes nothing returns boolean
		call InfoEx("load header")
		return true
	endmethod
	static method leave takes nothing returns nothing
		local player p = GetTriggerPlayer()
		
		local string s = "Player "+I2S(GetPlayerId(p))+" (" + GetPlayerName(p) + ") has left the game"
		
		call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, 999, s)
		call InfoEx(s)
	endmethod
	static method leaveSetup takes nothing returns nothing
    	local trigger t = CreateTrigger()
    	local integer i = 0
    
    	call TriggerAddAction(t, function thistype.leave)
    
    	loop
    		exitwhen (i>15)
    	
    		call TriggerRegisterPlayerEvent(t, Player(i), EVENT_PLAYER_LEAVE)
    		
    		set i=i+1
    	endloop
	endmethod
    static method ProcessLoading takes nothing returns nothing
		call thistype.leaveSetup()
    
    	call InfoEx("process ingame loading...")
		call Loading.Init()
	
			call Loading.QueueCode(function thistype.LoadHeader)
	initLoad Header
	        call Loading.QueueCode(function EffectLevel.Init)
	initLoad Header_Event
	initLoad Header_2
	initLoad Header_Group
	        call Trigger.RunObjectInits(Trigger.INIT_NORMAL_KEY_ARRAY)
	initLoad Header_3
	initLoad Header_4
	initLoad Header_5
//
	initLoad Header_6
	initLoad Header_7
	initLoad Header_8
//
	        call Trigger.RunObjectInits(LightningType.INIT_KEY_ARRAY)
	        call Trigger.RunObjectInits(WeatherType.INIT_KEY_ARRAY)
	        call Trigger.RunObjectInits(UbersplatType.INIT_KEY_ARRAY)
	        call Trigger.RunObjectInits(TileType.INIT_KEY_ARRAY)
	        call Trigger.RunObjectInits(SoundType.INIT_KEY_ARRAY)
			call Trigger.RunObjectInits(Buff.INIT_KEY_ARRAY)
//
	        call Trigger.RunObjectInits(DestructableType.INIT_KEY_ARRAY)
//
	        call Trigger.RunObjectInits(Spell.INIT_KEY_ARRAY)
//
        	call Trigger.RunObjectInits(ItemType.INIT_KEY_ARRAY)
	        call Trigger.RunObjectInits(UnitType.INIT_KEY_ARRAY)
//
	initLoad Header_Buffs
	
	initLoad Commands
	
	initLoad Items_Misc
	initLoad Items_Act1
	initLoad Items_Act2
	initLoad Items_Act3
	
	initLoad Speeches
	
	initLoad Spells_Header
	initLoad Spells_Misc
	initLoad Spells_Act1
	initLoad Spells_Act2
	initLoad Spells_Hero
	initLoad Spells_Artifacts
	initLoad Spells_Purchasable
	initLoad Spells_Elemental
	initLoad Spells_Grant_Elementals
	
	initLoad Units
	
	initLoad Other
	        call Loading.QueueCode(function thistype.Other)
	initLoad CreepBuffs
	initLoad Misc
	initLoad Misc_2
	initLoad Misc_Level
	initLoad Misc_3
	initLoad Misc_4
	initLoad Misc_5
	
	initLoad AI_Header
	initLoad AI_Spells
	initLoad AI_Misc
	
	initLoad Preplaced
        call Loading.QueueCode(function thistype.EndLoading)
        call Loading.ExecQueue()
    endmethod
    static method StartLoading takes nothing returns nothing
    call InfoEx("start loading")
        call Loading.Start()
        call SetMapMusic("", false, 0)
        call TriggerSleepAction(0.)
        set thistype.MUSIC_SOUND = CreateSound("Sound\\Music\\mp3Music\\War2IntroMusic.mp3", false, false, false, 10, 10, "DefaultEAXOn")
        call SetSoundPitch(thistype.MUSIC_SOUND, 0.8)
        call StartSound(thistype.MUSIC_SOUND)
        call Code.Run(function thistype.ProcessLoading)
    endmethod
endstruct
//! inject main
    
    //! dovjassinit
    call SetCameraBounds(-7680. + GetCameraMargin(CAMERA_MARGIN_LEFT), -7680. + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 7680. - GetCameraMargin(CAMERA_MARGIN_RIGHT), 7680. - GetCameraMargin(CAMERA_MARGIN_TOP), -7680. + GetCameraMargin(CAMERA_MARGIN_LEFT), 7680. - GetCameraMargin(CAMERA_MARGIN_TOP), 7680. - GetCameraMargin(CAMERA_MARGIN_RIGHT), -7680. + GetCameraMargin(CAMERA_MARGIN_BOTTOM))
    call SetDayNightModels("UI\\LightEnvTerrain.mdx", "UI\\LightEnvUnit.mdx")
    call NewSoundEnvironment("Default")
    call SetMapMusic("Music", true, 0)
    call CreateRegions()
    call CreateCameras()
    call CreateAllDestructables()
    call CreateAllItems()
    
    call Code.Run(function preplaced.initRects)
    call Code.Run(function preplaced.initUnits)
	
	
    call Code.Run(function Initialization.StartLoading)
//! endinject
function InitPlayerSlots takes nothing returns nothing
    local integer iteration = User.MAX_HUMAN_INDEX
    local player specificPlayer
    call SetPlayers(iteration + 2)
    call SetTeams(2)
    loop
        exitwhen (iteration < 0)
        set specificPlayer = Player(iteration)
        call SetPlayerController(specificPlayer, MAP_CONTROL_USER)
        call SetPlayerRacePreference(specificPlayer, RACE_PREF_HUMAN)
        call SetPlayerRaceSelectable(specificPlayer, false)
        call SetPlayerTeam(specificPlayer, 0)
        set iteration = iteration - 1
    endloop
    set specificPlayer = Player(7)
    call SetPlayerColor(specificPlayer, PLAYER_COLOR_PINK)
    call SetPlayerController(specificPlayer, MAP_CONTROL_COMPUTER)
    call SetPlayerRacePreference(specificPlayer, RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(specificPlayer, false)
    call SetPlayerTeam(specificPlayer, 1)
    set specificPlayer = Player(11)
    call SetPlayerColor(specificPlayer, PLAYER_COLOR_BROWN)
    call SetPlayerController(specificPlayer, MAP_CONTROL_COMPUTER)
    call SetPlayerRacePreference(specificPlayer, RACE_PREF_ORC)
    call SetPlayerRaceSelectable(specificPlayer, false)
    call SetPlayerTeam(specificPlayer, 1)
    set specificPlayer = null
endfunction
//! inject config
    call SetGamePlacement(MAP_PLACEMENT_USE_MAP_SETTINGS)
    call SetMapDescription("blub")
    call SetMapName("Defend Wintercastle")
    
    call InitPlayerSlots()
//! endinject
    scope FolderAct
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return Act(this).Data.table.IntegerKeys.Table.ContainsInteger(Act(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Act(this).Data.table.IntegerKeys.Table.CountIntegers(Act(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Act(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Act(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Act(this).Data.table.IntegerKeys.Table.GetInteger(Act(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Act(this).Data.table.IntegerKeys.Table.GetFirstInteger(Act(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Act(this).Data.table.IntegerKeys.Table.GetLastInteger(Act(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Act(this).Data.table.IntegerKeys.Table.Clear(Act(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Act(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Act(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Act(this).Data.table.IntegerKeys.Table.RemoveInteger(Act(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Act(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Act(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Act(this).Data.table.IntegerKeys.Table.AddInteger(Act(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Act(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Act(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Act(this).Data.table.IntegerKeys.Table.JoinInteger(Act(this).Id.Get(), key, Act(other).Data.table, Act(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Act(this).Data.table.IntegerKeys.Table.RandomInteger(Act(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Act(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Act(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Act(this).Data.table.IntegerKeys.Table.PrintIntegers(Act(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return Act(this).Data.table.IntegerKeys.GetInteger(Act(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Act(this).Data.table.IntegerKeys.RemoveInteger(Act(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Act(this).Data.table.IntegerKeys.SetInteger(Act(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Act(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Act.Allocation.deallocate_demount.hook
		call Act(this).Data.Destroy()
	endinject
	inject Act.Allocation.allocate_mount.hook
		call Act(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructEvent
        implement Allocation
        implement List
        
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(Act(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(Act(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(Act(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(Act(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(Act(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(Act(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(Act(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(Act(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject Act.Allocation.deallocate_demount.hook
			call Act(this).Event.Destroy()
		endinject
		inject Act.Allocation.allocate_mount.hook
			call Act(this).Event.Event_Create()
		endinject
    endstruct
    public struct StructLevelSets
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        method Count takes nothing returns integer
            return Level(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns LevelSet
            return Level(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method Add takes LevelSet val returns nothing
            call Level(this).Data.Integer.Table.Add(KEY_ARRAY, val)
        endmethod
    endstruct
endscope
    globals
        Act ACT = STRUCT_BASE
    endglobals
    struct Act
        implement Allocation
        implement List
        
    static EventType ENDING_EVENT_TYPE
    static EventType START_EVENT_TYPE
    static thistype CURRENT
    static thistype BONUS
    static thistype FIRST
    static thistype SECOND
    static thistype THIRD
    static thistype FOURTH
    static thistype FIFTH
    static thistype SIXTH
    FolderAct_StructData Data = this
    FolderAct_StructData LinkToStruct_Data
    FolderAct_StructEvent Event = this
    FolderAct_StructEvent LinkToStruct_Event
    FolderAct_StructId Id = this
    FolderAct_StructId LinkToStruct_Id
    FolderAct_StructLevelSets LevelSets = this
    FolderAct_StructLevelSets LinkToStruct_LevelSets
    boolean bonus = false
    method IsBonus takes nothing returns boolean
        return this.bonus
    endmethod
    method SetBonus takes boolean value returns nothing
        set this.bonus = value
    endmethod
    string bonusCaption
    method GetBonusCaption takes nothing returns string
        return this.bonusCaption
    endmethod
    method SetBonusCaption takes string value returns nothing
        set this.bonusCaption = value
    endmethod
	//! inject Allocation.allocate_mount.hook
		set this.bonusCaption = null
	//! endinject
    string name
    method GetName takes nothing returns string
        return this.name
    endmethod
    method SetName takes string value returns nothing
        set this.name = value
    endmethod
    thistype next
    method GetNext takes nothing returns thistype
        return this.next
    endmethod
    method SetNext takes thistype value returns nothing
        set this.next = value
    endmethod
	//! inject Allocation.allocate_mount.hook
		set this.next = NULL
	//! endinject
    method Ending_TriggerEvents takes nothing returns nothing
        local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
        call params.Act.SetTrigger(this)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = Event.CountAtStatics(thistype.ENDING_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call Event.GetFromStatics(thistype.ENDING_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    method Ending takes nothing returns nothing
        set thistype.CURRENT = NULL
        call this.Ending_TriggerEvents()
        if Meteorite.GAME_OVER then
            return
        endif
    endmethod
    static method StartNext takes nothing returns nothing
        local thistype this = thistype.CURRENT
        if (this == NULL) then
            return
        endif
        call this.Ending()
        set this = this.GetNext()
        if (this == NULL) then
            call Game.DebugMsg("Victory")
        else
            call this.Start()
        endif
    endmethod
    method Start_TriggerEvents takes nothing returns nothing
        local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
        call params.Act.SetTrigger(this)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = Event.CountAtStatics(thistype.START_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call Event.GetFromStatics(thistype.START_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    method Start takes nothing returns nothing
        if (thistype.CURRENT != NULL) then
            call thistype.CURRENT.Ending()
        endif
        set thistype.CURRENT = this
		local integer level = 0
        if (this == thistype.FIRST) then
            set level = 1
        elseif (this == thistype.SECOND) then
            set level = 2
        elseif (this == thistype.THIRD) then
            set level = 3
        elseif (this == thistype.FOURTH) then
            set level = 4
        elseif (this == thistype.FIFTH) then
            set level = 5
        elseif (this == thistype.SIXTH) then
            set level = 6
        endif
        call Game.DisplayTextTimed(User.ANY, "New Chapter begins: " + String.Color.Do(this.GetName(), String.Color.GOLD), 15.)
        if (level > 0) then
            call User.ANY.SetResearchBySelf('R000', level)
        endif
        call this.Start_TriggerEvents()
    endmethod
    static method AdjustInfoPanel takes nothing returns nothing
        call Timer.GetExpired().Destroy()
        call Difficulty.DoAnnouncement()
    endmethod
    static method Event_DifficultySet takes nothing returns nothing
        if (thistype.CURRENT != NULL) then
            call thistype.CURRENT.Ending()
        endif
        call Meteorite.THIS_UNIT.Armor.IgnoreDamage.Relative.Set(0.)
        call Announcement.Create(1).Start()
        call Timer.Create().Start(5., false, function thistype.AdjustInfoPanel)
        call thistype.FIRST.Start()
    endmethod
    static method Create takes string name returns thistype
        local thistype this = thistype.allocate()
        call this.SetName(name)
        call this.AddToList()
        if (thistype.ALL_COUNT > ARRAY_EMPTY) then
            call thistype.ALL[thistype.ALL_COUNT - 1].SetNext(this)
        endif
        call this.Id.Event_Create()
        return this
    endmethod
    eventMethod Event_Start
        call Event.Create(Act.START_EVENT_TYPE, EventPriority.MISC, function LevelSet.Event_ActStart).AddToStatics()
        call thistype.BONUS.Start()
    endmethod
    static method InitObjs takes nothing returns nothing
        local thistype this
        
        set this = thistype.Create("Penguin Prelude")
        set thistype.BONUS = this
        call this.SetBonus(true)
        call this.SetBonusCaption("X")
        call this.LevelSets.Add(LevelSet.BONUS_ACT_PART1)
        
        set this = thistype.Create("Delightful disturbances")
        set thistype.FIRST = this
        call this.LevelSets.Add(LevelSet.ACT1_PART1)
        call this.LevelSets.Add(LevelSet.ACT1_PART2)
        call this.LevelSets.Add(LevelSet.ACT1_PART3)
        call this.LevelSets.Add(LevelSet.ACT1_BOSS_PART)
        
        set this = thistype.Create("Dash into the fire")
        set thistype.SECOND = this
        call this.LevelSets.Add(LevelSet.ACT2_PART1)
        call this.LevelSets.Add(LevelSet.ACT2_PART2)
        call this.LevelSets.Add(LevelSet.ACT2_PART3)
        call this.LevelSets.Add(LevelSet.ACT2_BOSS_PART)
        
        set this = thistype.Create("Return of the elves")
        set thistype.THIRD = this
        
        set this = thistype.Create("Desire beyond death")
        set thistype.FOURTH = this
        
        set this = thistype.Create("The mourning mountain")
        set thistype.FIFTH = this
        
        set this = thistype.Create("The dragon's flight, Frozen in time")
        set thistype.SIXTH = this
    endmethod
    initMethod Init of Misc_3
        set thistype.CURRENT = NULL
        set thistype.ENDING_EVENT_TYPE = EventType.Create()
        set thistype.START_EVENT_TYPE = EventType.Create()
        call Event.Create(EventType.START, EventPriority.HEADER, function thistype.Event_Start).AddToStatics()
        
        call Meteorite.THIS_UNIT.Armor.IgnoreDamage.Relative.Set(1.)
        call thistype.InitObjs()
        call Level.InitNexts()
    endmethod
endstruct
    globals
        ActUpgrades ACT_UPGRADES = STRUCT_BASE
    endglobals
    struct ActUpgrades
        implement Allocation
        implement List
        
    static constant integer RESERVOIR_MANA_INCREMENT = 100
    enumMethod Reservoir
        local Unit target = UNIT.Event.Native.GetEnum()
        call target.AddRisingTextTag(String.Color.Do(Char.PLUS + Integer.ToString(thistype.RESERVOIR_MANA_INCREMENT), "ff0000ff"), 0.032, 60., 1., 2.5, TextTag.GetFreeId())
        call target.MaxMana.Base.Add(thistype.RESERVOIR_MANA_INCREMENT)
    endmethod
    enumMethod Tower
        local Unit target = UNIT.Event.Native.GetEnum()
        call target.Damage.Base.Add(15)
    endmethod
    eventMethod Event_ActEnding
        local Act whichAct = params.Act.GetTrigger()
        if whichAct.IsBonus() then
            return
        endif
        call Unit.EnumOfType(UnitType.RESERVOIR, function thistype.Reservoir)
        call Unit.EnumOfType(UnitType.TOWER, function thistype.Tower)
    endmethod
    initMethod Init of Misc_4
        call Event.Create(Act.ENDING_EVENT_TYPE, EventPriority.MISC, function thistype.Event_ActEnding).AddToStatics()
    endmethod
endstruct
    globals
        AfterIntro AFTER_INTRO = STRUCT_BASE
    endglobals
    struct AfterIntro
        implement Allocation
        implement List
        
    static EventType DUMMY_EVENT_TYPE
    static EventType FOR_PLAYER_EVENT_TYPE
    static Force FOR_PLAYER_FORCE
    static method ForPlayer_TriggerEvents takes User whichPlayer returns nothing
        local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
        call params.User.SetTrigger(whichPlayer)
        call thistype.FOR_PLAYER_FORCE.RemovePlayer(whichPlayer)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = Event.CountAtStatics(thistype.FOR_PLAYER_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call Event.GetFromStatics(thistype.FOR_PLAYER_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    static method StartForPlayer takes User whichPlayer returns nothing
        call thistype.ForPlayer_TriggerEvents(whichPlayer)
    endmethod
    static method TriggerEvents takes nothing returns nothing
        local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
        loop
            local User whichUser = thistype.FOR_PLAYER_FORCE.GetFirst()
            exitwhen (whichUser == NULL)
            call thistype.ForPlayer_TriggerEvents(whichUser)
        endloop
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = Event.CountAtStatics(thistype.DUMMY_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call Event.GetFromStatics(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    static method Start takes nothing returns nothing
        call thistype.TriggerEvents()
    endmethod
    initMethod Init of Misc
        local integer iteration = User.PLAYING_HUMANS_COUNT
        set thistype.DUMMY_EVENT_TYPE = EventType.Create()
        set thistype.FOR_PLAYER_EVENT_TYPE = EventType.Create()
        set thistype.FOR_PLAYER_FORCE = Force.Create()
        loop
            exitwhen (iteration < ARRAY_MIN)
            call thistype.FOR_PLAYER_FORCE.AddPlayer(User.PLAYING_HUMANS[iteration])
            set iteration = iteration - 1
        endloop
    endmethod
endstruct
    globals
        BrazierOracle BRAZIER_ORACLE = STRUCT_BASE
    endglobals
    struct BrazierOracle
        implement Allocation
        implement List
        
	static Event DAMAGE_EVENT
    static constant real HEIGHT = 280.
    static DummyUnit LEFT_UNIT = NULL
    static real LEFT_X
    static real LEFT_Y
    static DummyUnit RIGHT_UNIT = NULL
    static real RIGHT_X
    static real RIGHT_Y
    static method Set takes UnitType modelUnitType, real x, real y, boolean right returns nothing
        local playercolor color = User.SPAWN.GetColor()
        local real red = modelUnitType.VertexColor.Red.Get()
        local real green = modelUnitType.VertexColor.Red.Get()
        local real blue = modelUnitType.VertexColor.Red.Get()
		local DummyUnit dummyUnit
        if right then
            set dummyUnit = thistype.RIGHT_UNIT
        else
            set dummyUnit = thistype.LEFT_UNIT
        endif
        if (dummyUnit != NULL) then
            call dummyUnit.DestroyInstantly()
        endif
        set dummyUnit = DummyUnit.Create(modelUnitType.self, x, y, Spot.GetHeight(x, y) + thistype.HEIGHT, UNIT.Facing.STANDARD)
        call dummyUnit.SetScale(1.5)
        call dummyUnit.SetLocust()
        call dummyUnit.PlayerColor.Set(color)
        call dummyUnit.Rotate.Start(Math.FULL_ANGLE / 3.)
        call dummyUnit.VertexColor.Set(red, green, blue, 180.)
        if right then
            set thistype.RIGHT_UNIT = dummyUnit
        else
            set thistype.LEFT_UNIT = dummyUnit
        endif
    endmethod
    eventMethod Event_GameOver
        if (thistype.LEFT_UNIT != NULL) then
            call thistype.LEFT_UNIT.DestroyInstantly()
        endif
        if (thistype.RIGHT_UNIT != NULL) then
            call thistype.RIGHT_UNIT.DestroyInstantly()
        endif
        call SetDoodadAnimationRect(Rectangle.WORLD.self, 'D01K', Animation.DEATH, false)
        call SetDoodadAnimationRect(Rectangle.WORLD.self, 'D01M', Animation.DEATH, false)
    endmethod
    eventMethod Event_LevelStart
        local Level whichLevel = params.Level.GetTrigger()
        local SpawnWave whichWave = SpawnWave.GetFromLevel(whichLevel)
        if (whichWave != NULL) then
            call thistype.Set(whichWave.GetModelUnitType(), thistype.LEFT_X, thistype.LEFT_Y, false)
        endif
        set whichLevel = whichLevel.GetNext()
        if (whichLevel != NULL) then
            set whichWave = SpawnWave.GetFromLevel(whichLevel)
            if (whichWave != NULL) then
                call thistype.Set(whichWave.GetModelUnitType(), thistype.RIGHT_X, thistype.RIGHT_Y, true)
            endif
        endif
    endmethod
	eventMethod Event_Damage
        local Unit damager = params.Unit.GetDamager()
        local Unit target = params.Unit.GetTarget()
        local integer protectionLevel = target.Abilities.GetLevel(MeteoriteProtection.THIS_SPELL)
        if (protectionLevel == 1) then
            return
        endif
        
        if (protectionLevel == 2) then
            call params.Real.SetDamage(target.MaxLife.Get() * 0.15 * (1 - target.Armor.Spell.Get()))
        else
            call params.Real.SetDamage(target.MaxLife.Get() * 0.4 * (1 - target.Armor.Spell.Get()))
        endif
		call target.Buffs.Timed.Start(thistype.DAMAGE_BUFF, 1, 1)
        
	endmethod
	static method CreateBrazier takes real x, real y
		local Unit u = Unit.Create(thistype.THIS_UNIT_TYPE, User.CASTLE_CONTROLABLE, x, y, UNIT.Facing.STANDARD)
		call u.Event.Add(DAMAGE_EVENT)
	endmethod
    eventMethod Event_Start
    	call thistype.CreateBrazier(thistype.LEFT_X, thistype.LEFT_Y)
    	call thistype.CreateBrazier(thistype.RIGHT_X, thistype.RIGHT_Y)
        call Event.Create(Level.START_EVENT_TYPE, EventPriority.MISC2, function thistype.Event_LevelStart).AddToStatics()
    endmethod
    initMethod Init of Misc_2
        local Rectangle leftRect = Rectangle.CreateFromSelf(gg_rct_LeftBrazier)
        local Rectangle rightRect = Rectangle.CreateFromSelf(gg_rct_RightBrazier)
        set thistype.LEFT_X = leftRect.GetCenterX()
        set thistype.LEFT_Y = leftRect.GetCenterY()
        set thistype.RIGHT_X = rightRect.GetCenterX()
        set thistype.RIGHT_Y = rightRect.GetCenterY()
        call Event.Create(EventType.START, EventPriority.MISC, function thistype.Event_Start).AddToStatics()
        call Event.Create(Meteorite.GAME_OVER_EVENT_TYPE, EventPriority.MISC, function thistype.Event_GameOver).AddToStatics()
		set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Damage)
		call UNIT.Death.Explosion.DUMMY_BUFF.Variants.Add(thistype.DAMAGE_BUFF)
    endmethod
endstruct
    globals
        CameraQuickPosition CAMERA_QUICK_POSITION = STRUCT_BASE
    endglobals
    struct CameraQuickPosition
        implement Allocation
        implement List
        
    static Event PICK_EVENT
    static constant real UPDATE_TIME = 0.035
    timerMethod Update
        local Unit hero = User.GetLocal().Hero.Get()
        if (hero == NULL) then
            return
        endif
        call SetCameraQuickPosition(hero.Position.X.Get(), hero.Position.Y.Get())
    endmethod
    eventMethod Event_HeroPick
        call thistype.PICK_EVENT.RemoveFromStatics()
        call Timer.Create().Start(thistype.UPDATE_TIME, true, function thistype.Update)
    endmethod
    initMethod Init of Misc_2
        set thistype.PICK_EVENT = Event.Create(HeroSelection.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_HeroPick)
        call thistype.PICK_EVENT.AddToStatics()
    endmethod
endstruct
    globals
        MarkOfThePaw MARK_OF_THE_PAW = STRUCT_BASE
    endglobals
    struct MarkOfThePaw
        implement Allocation
        implement List
        
    static Spell THIS_SPELL
    static method AddToUnit takes Unit target returns nothing
    	call Spot.CreateEffect(target.Position.X.Get(), target.Position.Y.Get(), thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW).Destroy()
        call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, thistype.DURATION)
    endmethod
    initMethod Init of CreepBuffs
    endmethod
endstruct
    scope FolderCreepLoot
endscope
    globals
        CreepLoot CREEP_LOOT = STRUCT_BASE
    endglobals
    struct CreepLoot
        implement Allocation
        implement List
        
    static method Init takes nothing returns nothing
    endmethod
endstruct
    globals
        Creep CREEP = STRUCT_BASE
    endglobals
    struct Creep
        implement Allocation
        implement List
        
    real angle
    CustomDrop whichDrop
    UnitType whichUnitType
    real x
    real y
    method AddDrop takes CustomDrop value returns nothing
        set this.whichDrop = value
    endmethod
    method Run takes real addX, real addY returns Unit
		local Unit result = Unit.Create(this.whichUnitType, User.CREEP, this.x, this.y, this.angle)
		local CustomDrop whichDrop = this.whichDrop
        if (whichDrop != NULL) then
            call result.Drop.Add(whichDrop)
        endif
        return result
    endmethod
    static method Create takes UnitType whichUnitType, preplaced dummy returns thistype
        local real angle = Math.DEG_TO_RAD * dummy.angle
        local real x = dummy.x
        local real y = dummy.y
        
		local thistype this = thistype.allocate()
        set this.angle = angle
        set this.whichDrop = NULL
        set this.whichUnitType = whichUnitType
        set this.x = x
        set this.y = y
        return this
    endmethod
    static method Init takes nothing returns nothing
    endmethod
endstruct
    globals
        CreepLocation CREEP_LOCATION = STRUCT_BASE
    endglobals
    struct CreepLocation
        implement Allocation
        implement List
        
    static Event DEATH_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static thistype LEFT_AIR
    static thistype LEFT_BOSS
    static thistype LEFT_MELEE
    static thistype RIGHT_BUFF
    static thistype RIGHT_DEMON
    static thistype RIGHT_MINOR
    UnitList currentUnitsGroup
    Ping whichPing
    Rectangle whichRect
    method GetX takes nothing returns real
        return this.whichRect.GetCenterX()
    endmethod
    method GetY takes nothing returns real
        return this.whichRect.GetCenterY()
    endmethod
    method ClearUnits takes nothing returns nothing
        local UnitList currentUnitsGroup = this.currentUnitsGroup
        loop
            local Unit whichUnit = currentUnitsGroup.GetFirst()
            exitwhen (whichUnit == NULL)
            call whichUnit.Kill()
        endloop
    endmethod
    eventMethod Event_Death
        local Unit whichUnit = params.Unit.GetTrigger()
        local thistype this = whichUnit.Data.Integer.Get(KEY)
        local UnitList currentUnitsGroup = this.currentUnitsGroup
        call currentUnitsGroup.Remove(whichUnit)
        call whichUnit.Data.Integer.Remove(KEY)
        call whichUnit.Event.Remove(DEATH_EVENT)
        if currentUnitsGroup.IsEmpty() then
            call this.whichPing.Destroy()
        endif
    endmethod
    method AddUnit takes Unit whichUnit returns nothing
        call whichUnit.Data.Integer.Set(KEY, this)
        call whichUnit.Event.Add(DEATH_EVENT)
		call this.currentUnitsGroup.Add(whichUnit)
    endmethod
    method Start takes Ping whichPing returns nothing
        set this.whichPing = whichPing
        call whichPing.Show()
        call whichPing.Start()
    endmethod
    static method Create takes Rectangle whichRect returns thistype
        local thistype this = thistype.allocate()
        set this.currentUnitsGroup = UnitList.Create()
        set this.whichRect = whichRect
        return this
    endmethod
    static method Init takes nothing returns nothing
        set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Death)
        set thistype.LEFT_AIR = thistype.Create(Rectangle.CreateFromSelf(gg_rct_Creeps_Left_Air))
        set thistype.LEFT_BOSS = thistype.Create(Rectangle.CreateFromSelf(gg_rct_Creeps_Left_Boss))
        set thistype.LEFT_MELEE = thistype.Create(Rectangle.CreateFromSelf(gg_rct_Creeps_Left_Melee))
        set thistype.RIGHT_BUFF = thistype.Create(Rectangle.CreateFromSelf(gg_rct_Creeps_Right_Buff))
        set thistype.RIGHT_DEMON = thistype.Create(Rectangle.CreateFromSelf(gg_rct_Creeps_Right_Demon))
        set thistype.RIGHT_MINOR = thistype.Create(Rectangle.CreateFromSelf(gg_rct_Creeps_Right_Minor))
    endmethod
endstruct
    scope FolderCreepSet
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return CreepSet(this).Data.table.IntegerKeys.Table.ContainsInteger(CreepSet(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return CreepSet(this).Data.table.IntegerKeys.Table.CountIntegers(CreepSet(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return CreepSet(this).Data.table.IntegerKeys.Table.IsEmptyInteger(CreepSet(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return CreepSet(this).Data.table.IntegerKeys.Table.GetInteger(CreepSet(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return CreepSet(this).Data.table.IntegerKeys.Table.GetFirstInteger(CreepSet(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return CreepSet(this).Data.table.IntegerKeys.Table.GetLastInteger(CreepSet(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call CreepSet(this).Data.table.IntegerKeys.Table.Clear(CreepSet(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return CreepSet(this).Data.table.IntegerKeys.Table.FetchFirstInteger(CreepSet(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return CreepSet(this).Data.table.IntegerKeys.Table.RemoveInteger(CreepSet(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return CreepSet(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(CreepSet(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return CreepSet(this).Data.table.IntegerKeys.Table.AddInteger(CreepSet(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return CreepSet(this).Data.table.IntegerKeys.Table.AddIntegerMulti(CreepSet(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call CreepSet(this).Data.table.IntegerKeys.Table.JoinInteger(CreepSet(this).Id.Get(), key, CreepSet(other).Data.table, CreepSet(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return CreepSet(this).Data.table.IntegerKeys.Table.RandomInteger(CreepSet(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call CreepSet(this).Data.table.IntegerKeys.Table.ShuffleIntegers(CreepSet(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call CreepSet(this).Data.table.IntegerKeys.Table.PrintIntegers(CreepSet(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return CreepSet(this).Data.table.IntegerKeys.GetInteger(CreepSet(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call CreepSet(this).Data.table.IntegerKeys.RemoveInteger(CreepSet(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call CreepSet(this).Data.table.IntegerKeys.SetInteger(CreepSet(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(CreepSet(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject CreepSet.Allocation.deallocate_demount.hook
		call CreepSet(this).Data.Destroy()
	endinject
	inject CreepSet.Allocation.allocate_mount.hook
		call CreepSet(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructEvent
        implement Allocation
        implement List
        
    static CreepSet TRIGGER = NULL
    static method GetTrigger takes nothing returns CreepSet
        return thistype.TRIGGER
    endmethod
    static method SetTrigger takes CreepSet value returns nothing
        set thistype.TRIGGER = value
    endmethod
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(CreepSet(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(CreepSet(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(CreepSet(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(CreepSet(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(CreepSet(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(CreepSet(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(CreepSet(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(CreepSet(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject CreepSet.Allocation.deallocate_demount.hook
			call CreepSet(this).Event.Destroy()
		endinject
		inject CreepSet.Allocation.allocate_mount.hook
			call CreepSet(this).Event.Event_Create()
		endinject
    endstruct
endscope
    globals
        CreepSet CREEP_SET = STRUCT_BASE
    endglobals
    struct CreepSet
        implement Allocation
        implement List
        
    static key GetKeyMacro_CREEP_KEY_ARRAY
    static constant integer CREEP_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_CREEP_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static Event LEVEL_START_EVENT
    
    static thistype BLUE_SPAWNS
    static thistype FURBOLG_MOTHER
    static thistype KOBOLDS
    static thistype PANDARENES
    static thistype TREANTS
    static thistype WOLVES
    
    FolderCreepSet_StructData Data = this
    FolderCreepSet_StructData LinkToStruct_Data
    FolderCreepSet_StructEvent Event = this
    FolderCreepSet_StructEvent LinkToStruct_Event
    FolderCreepSet_StructId Id = this
    FolderCreepSet_StructId LinkToStruct_Id
    string name
    method GetName takes nothing returns string
        return this.name
    endmethod
    method SetName takes string value returns nothing
        set this.name = value
    endmethod
    CreepLocation whichLocation
    method GetLocation takes nothing returns CreepLocation
        return this.whichLocation
    endmethod
    method SetLocation takes CreepLocation value returns nothing
        set this.whichLocation = value
    endmethod
    method CountCreeps takes nothing returns integer
        return this.Data.Integer.Table.Count(CREEP_KEY_ARRAY)
    endmethod
    method GetCreep takes integer index returns Creep
        return this.Data.Integer.Table.Get(CREEP_KEY_ARRAY, index)
    endmethod
    method AddCreep takes Creep whichCreep returns nothing
        call this.Data.Integer.Table.Add(CREEP_KEY_ARRAY, whichCreep)
    endmethod
    method Run takes nothing returns nothing
        local CreepLocation whichLocation = this.GetLocation()
        local PingColor whichPingColor = PingColor.RandomUnused()
        local real centerX = whichLocation.GetX()
        local real centerY = whichLocation.GetY()
        local Ping whichPing = Ping.Create(centerX, centerY, whichPingColor)
        call whichLocation.ClearUnits()
        if (whichPingColor == NULL) then
            call Game.DisplayTextTimed(User.ANY, String.Color.Do(this.GetName(), String.Color.GOLD) + " has/have spawned.", 10.)
        else
            call Game.DisplayTextTimed(User.ANY, String.Color.Do(this.GetName(), String.Color.GOLD) + " has/have spawned at the " + whichPingColor.GetName() + " spot.", 10.)
        endif
        call whichLocation.Start(whichPing)
		local integer iteration = this.Data.Integer.Table.Count(CREEP_KEY_ARRAY)
        loop
            local Creep whichCreep = this.Data.Integer.Table.Get(CREEP_KEY_ARRAY, iteration)
            call whichLocation.AddUnit(whichCreep.Run(centerX, centerY))
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
    endmethod
    eventMethod Event_Warning_LevelStart
        local Level whichLevel = params.Level.GetTrigger().GetNext()
        if (whichLevel == NULL) then
            return
        endif
        local integer count = whichLevel.Data.Integer.Table.Count(KEY_ARRAY)
        if (count < Memory.IntegerKeys.Table.STARTED) then
            return
        endif
        local integer iteration = count
        local string msg = ""
        loop
            if (iteration != count) then
                if (iteration == Memory.IntegerKeys.Table.STARTED) then
                    set msg = msg + " and "
                else
                    set msg = msg + ", "
                endif
            endif
            set msg = msg + String.Color.Do(thistype(whichLevel.Data.Integer.Table.Get(KEY_ARRAY, iteration)).GetName(), String.Color.GOLD)
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
        call Game.DisplayTextTimed(User.ANY, String.Color.Do("Notification:", String.Color.GOLD) + " Next level features the creeps " + msg + ".", 10.)
    endmethod
    eventMethod Event_LevelStart
        local Level whichLevel = params.Level.GetTrigger()
        local integer iteration = whichLevel.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            call thistype(whichLevel.Data.Integer.Table.Get(KEY_ARRAY, iteration)).Run()
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
    endmethod
    static method CountAtLevel takes Level whichLevel returns thistype
        return whichLevel.Data.Integer.Table.Count(KEY_ARRAY)
    endmethod
    static method GetFromLevel takes Level whichLevel, integer index returns thistype
        return whichLevel.Data.Integer.Table.Get(KEY_ARRAY, index)
    endmethod
    method AttachToLevel takes Level whichLevel returns nothing
        if whichLevel.Data.Integer.Table.Add(KEY_ARRAY, this) then
            call whichLevel.Event.Add(LEVEL_START_EVENT)
        endif
    endmethod
    static method Create takes string name, CreepLocation whichLocation returns thistype
        local thistype this = thistype.allocate()
        call this.SetLocation(whichLocation)
        call this.SetName(name)
        call this.Id.Event_Create()
        return this
    endmethod
    initMethod Init of Misc_4
        call Creep.Init()
        call CreepLocation.Init()
        call CreepLoot.Init()
        set thistype.LEVEL_START_EVENT = Event.Create(Level.START_EVENT_TYPE, EventPriority.MISC, function thistype.Event_LevelStart)
        call Event.Create(Level.START_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Warning_LevelStart).AddToStatics()
		local thistype this
        
            
            set this = thistype.Create("Blue Dragon Spawns", CreepLocation.LEFT_AIR)
            set thistype.BLUE_SPAWNS = this
            call this.AddCreep(Creep.Create(UnitType.BLUE_DRAGON_SPAWN, preplaced.unit_81))
            call this.AddCreep(Creep.Create(UnitType.BLUE_DRAGON_SPAWN, preplaced.unit_117))
            call this.AddCreep(Creep.Create(UnitType.TUSKAR, preplaced.unit_99))
            call this.AddCreep(Creep.Create(UnitType.TUSKAR, preplaced.unit_112))
            call this.AttachToLevel(Level.TROLLS)
            
            set this = thistype.Create("Furbolg Mother", CreepLocation.LEFT_BOSS)
            set thistype.FURBOLG_MOTHER = this
            call this.AddCreep(Creep.Create(UnitType.FURBOLG_MOTHER, preplaced.unit_110))
            call this.AddCreep(Creep.Create(UnitType.KOBOLD_BROWN, preplaced.unit_115))
            call this.AddCreep(Creep.Create(UnitType.KOBOLD_BROWN, preplaced.unit_116))
            call this.AttachToLevel(Level.GNOLLS)
            
            set this = thistype.Create("Kobolds", CreepLocation.RIGHT_MINOR)
            set thistype.TREANTS = this
            call this.AddCreep(Creep.Create(UnitType.KOBOLD_BLUE, preplaced.unit_102))
            call this.AddCreep(Creep.Create(UnitType.KOBOLD_BLUE, preplaced.unit_124))
            call this.AddCreep(Creep.Create(UnitType.KOBOLD_RED, preplaced.unit_113))
            call this.AddCreep(Creep.Create(UnitType.KOBOLD_RED, preplaced.unit_114))
            call this.AttachToLevel(Level.GNOLLS)
            
            set this = thistype.Create("Pandarenes", CreepLocation.LEFT_MELEE)
            set thistype.PANDARENES = this
            call this.AddCreep(Creep.Create(UnitType.PANDARENE, preplaced.unit_79))
            call this.AddCreep(Creep.Create(UnitType.PANDARENE, preplaced.unit_83))
            call this.AttachToLevel(Level.GNOLLS)
            
            set this = thistype.Create("Treants", CreepLocation.RIGHT_DEMON)
            set thistype.TREANTS = this
            call this.AddCreep(Creep.Create(UnitType.TREANT_GREEN, preplaced.unit_133))
            call this.AddCreep(Creep.Create(UnitType.TREANT_GREEN, preplaced.unit_134))
            call this.AddCreep(Creep.Create(UnitType.TREANT_PURPLE, preplaced.unit_132))
            call this.AttachToLevel(Level.GNOLLS)
            
            set this = thistype.Create("Wolves", CreepLocation.RIGHT_BUFF)
            set thistype.WOLVES = this
            call this.AddCreep(Creep.Create(UnitType.WOLF, preplaced.unit_97))
            call this.AddCreep(Creep.Create(UnitType.WOLF, preplaced.unit_123))
            call this.AddCreep(Creep.Create(UnitType.WOLF_MOTHER, preplaced.unit_122))
            call this.AttachToLevel(Level.GNOLLS)
        
    endmethod
   
endstruct
    globals
        DefenderSpawnLocation DEFENDER_SPAWN_LOCATION = STRUCT_BASE
    endglobals
    struct DefenderSpawnLocation
        implement Allocation
        implement List
        
    static thistype SOURCE_CENTER
    static thistype TARGET_BOTTOM
    static thistype TARGET_LEFT
    static thistype TARGET_RIGHT
    Rectangle source
    method GetCenterX takes nothing returns real
        return this.source.GetCenterX()
    endmethod
    method GetCenterY takes nothing returns real
        return this.source.GetCenterY()
    endmethod
    method RandomX takes nothing returns real
        return this.source.RandomX()
    endmethod
    method RandomY takes nothing returns real
        return this.source.RandomY()
    endmethod
    static method Create takes Rectangle source returns thistype
        local thistype this = thistype.allocate()
        set this.source = source
        call this.AddToList()
        return this
    endmethod
    static method Init takes nothing returns nothing
        set thistype.SOURCE_CENTER = thistype.Create(Rectangle.CreateFromSelf(gg_rct_DefenderSpawn_SourceCenter))
        set thistype.TARGET_BOTTOM = thistype.Create(Rectangle.CreateFromSelf(gg_rct_DefenderSpawn_TargetBottom))
        set thistype.TARGET_LEFT = thistype.Create(Rectangle.CreateFromSelf(gg_rct_DefenderSpawn_TargetLeft))
        set thistype.TARGET_RIGHT = thistype.Create(Rectangle.CreateFromSelf(gg_rct_DefenderSpawn_TargetRight))
    endmethod
endstruct
    scope FolderDefenderSpawnType
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return DefenderSpawnType(this).Data.table.IntegerKeys.Table.ContainsInteger(DefenderSpawnType(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return DefenderSpawnType(this).Data.table.IntegerKeys.Table.CountIntegers(DefenderSpawnType(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return DefenderSpawnType(this).Data.table.IntegerKeys.Table.IsEmptyInteger(DefenderSpawnType(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return DefenderSpawnType(this).Data.table.IntegerKeys.Table.GetInteger(DefenderSpawnType(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return DefenderSpawnType(this).Data.table.IntegerKeys.Table.GetFirstInteger(DefenderSpawnType(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return DefenderSpawnType(this).Data.table.IntegerKeys.Table.GetLastInteger(DefenderSpawnType(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call DefenderSpawnType(this).Data.table.IntegerKeys.Table.Clear(DefenderSpawnType(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return DefenderSpawnType(this).Data.table.IntegerKeys.Table.FetchFirstInteger(DefenderSpawnType(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return DefenderSpawnType(this).Data.table.IntegerKeys.Table.RemoveInteger(DefenderSpawnType(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return DefenderSpawnType(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(DefenderSpawnType(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return DefenderSpawnType(this).Data.table.IntegerKeys.Table.AddInteger(DefenderSpawnType(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return DefenderSpawnType(this).Data.table.IntegerKeys.Table.AddIntegerMulti(DefenderSpawnType(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call DefenderSpawnType(this).Data.table.IntegerKeys.Table.JoinInteger(DefenderSpawnType(this).Id.Get(), key, DefenderSpawnType(other).Data.table, DefenderSpawnType(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return DefenderSpawnType(this).Data.table.IntegerKeys.Table.RandomInteger(DefenderSpawnType(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call DefenderSpawnType(this).Data.table.IntegerKeys.Table.ShuffleIntegers(DefenderSpawnType(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call DefenderSpawnType(this).Data.table.IntegerKeys.Table.PrintIntegers(DefenderSpawnType(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return DefenderSpawnType(this).Data.table.IntegerKeys.GetInteger(DefenderSpawnType(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call DefenderSpawnType(this).Data.table.IntegerKeys.RemoveInteger(DefenderSpawnType(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call DefenderSpawnType(this).Data.table.IntegerKeys.SetInteger(DefenderSpawnType(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(DefenderSpawnType(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject DefenderSpawnType.Allocation.deallocate_demount.hook
		call DefenderSpawnType(this).Data.Destroy()
	endinject
	inject DefenderSpawnType.Allocation.allocate_mount.hook
		call DefenderSpawnType(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructEvent
        implement Allocation
        implement List
        
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(DefenderSpawnType(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(DefenderSpawnType(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(DefenderSpawnType(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(DefenderSpawnType(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(DefenderSpawnType(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(DefenderSpawnType(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(DefenderSpawnType(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(DefenderSpawnType(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject DefenderSpawnType.Allocation.deallocate_demount.hook
			call DefenderSpawnType(this).Event.Destroy()
		endinject
		inject DefenderSpawnType.Allocation.allocate_mount.hook
			call DefenderSpawnType(this).Event.Event_Create()
		endinject
    endstruct
endscope
    globals
        DefenderSpawnType DEFENDER_SPAWN_TYPE = STRUCT_BASE
    endglobals
    struct DefenderSpawnType
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    
    
    static thistype VICAR
    static thistype SWORDSMAN
    
    FolderDefenderSpawnType_StructData Data = this
    FolderDefenderSpawnType_StructData LinkToStruct_Data
    FolderDefenderSpawnType_StructEvent Event = this
    FolderDefenderSpawnType_StructEvent LinkToStruct_Event
    FolderDefenderSpawnType_StructId Id = this
    FolderDefenderSpawnType_StructId LinkToStruct_Id
    UnitType whichType
    method GetType takes nothing returns UnitType
        return this.whichType
    endmethod
    method SetType takes UnitType value returns nothing
        set this.whichType = value
    endmethod
    static method Create takes UnitType whichUnitType returns thistype
        local thistype this = thistype.allocate()
        call this.SetType(whichUnitType)
        call this.AddToList()
        call this.Id.Event_Create()
        return this
    endmethod
    static method Init takes nothing returns nothing
        local thistype this
        
        
            
            set this = thistype.Create(UnitType.VICAR)
            set this = thistype.Create(UnitType.VICAR)
            set this = thistype.Create(UnitType.VICAR)
            set thistype.VICAR = this
            
            set this = thistype.Create(UnitType.SWORDSMAN)
            set this = thistype.Create(UnitType.SWORDSMAN)
            set this = thistype.Create(UnitType.SWORDSMAN)
            set thistype.SWORDSMAN = this
        
    endmethod
endstruct
    scope FolderDefenderSpawnGroup
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return DefenderSpawnGroup(this).Data.table.IntegerKeys.Table.ContainsInteger(DefenderSpawnGroup(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return DefenderSpawnGroup(this).Data.table.IntegerKeys.Table.CountIntegers(DefenderSpawnGroup(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return DefenderSpawnGroup(this).Data.table.IntegerKeys.Table.IsEmptyInteger(DefenderSpawnGroup(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return DefenderSpawnGroup(this).Data.table.IntegerKeys.Table.GetInteger(DefenderSpawnGroup(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return DefenderSpawnGroup(this).Data.table.IntegerKeys.Table.GetFirstInteger(DefenderSpawnGroup(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return DefenderSpawnGroup(this).Data.table.IntegerKeys.Table.GetLastInteger(DefenderSpawnGroup(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call DefenderSpawnGroup(this).Data.table.IntegerKeys.Table.Clear(DefenderSpawnGroup(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return DefenderSpawnGroup(this).Data.table.IntegerKeys.Table.FetchFirstInteger(DefenderSpawnGroup(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return DefenderSpawnGroup(this).Data.table.IntegerKeys.Table.RemoveInteger(DefenderSpawnGroup(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return DefenderSpawnGroup(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(DefenderSpawnGroup(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return DefenderSpawnGroup(this).Data.table.IntegerKeys.Table.AddInteger(DefenderSpawnGroup(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return DefenderSpawnGroup(this).Data.table.IntegerKeys.Table.AddIntegerMulti(DefenderSpawnGroup(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call DefenderSpawnGroup(this).Data.table.IntegerKeys.Table.JoinInteger(DefenderSpawnGroup(this).Id.Get(), key, DefenderSpawnGroup(other).Data.table, DefenderSpawnGroup(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return DefenderSpawnGroup(this).Data.table.IntegerKeys.Table.RandomInteger(DefenderSpawnGroup(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call DefenderSpawnGroup(this).Data.table.IntegerKeys.Table.ShuffleIntegers(DefenderSpawnGroup(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call DefenderSpawnGroup(this).Data.table.IntegerKeys.Table.PrintIntegers(DefenderSpawnGroup(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return DefenderSpawnGroup(this).Data.table.IntegerKeys.GetInteger(DefenderSpawnGroup(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call DefenderSpawnGroup(this).Data.table.IntegerKeys.RemoveInteger(DefenderSpawnGroup(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call DefenderSpawnGroup(this).Data.table.IntegerKeys.SetInteger(DefenderSpawnGroup(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(DefenderSpawnGroup(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject DefenderSpawnGroup.Allocation.deallocate_demount.hook
		call DefenderSpawnGroup(this).Data.Destroy()
	endinject
	inject DefenderSpawnGroup.Allocation.allocate_mount.hook
		call DefenderSpawnGroup(this).Data.Event_Create()
	endinject
    endstruct
endscope
    globals
        DefenderSpawnGroup DEFENDER_SPAWN_GROUP = STRUCT_BASE
    endglobals
    struct DefenderSpawnGroup
        implement Allocation
        implement List
        
    static key GetKeyMacro_TYPES_KEY_ARRAY
    static constant integer TYPES_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_TYPES_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    FolderDefenderSpawnGroup_StructData Data = this
    FolderDefenderSpawnGroup_StructData LinkToStruct_Data
    FolderDefenderSpawnGroup_StructId Id = this
    FolderDefenderSpawnGroup_StructId LinkToStruct_Id
    DefenderSpawnLocation source
    method GetSource takes nothing returns DefenderSpawnLocation
        return this.source
    endmethod
    method SetSource takes DefenderSpawnLocation value returns nothing
        set this.source = value
    endmethod
    DefenderSpawnLocation target
    method GetTarget takes nothing returns DefenderSpawnLocation
        return this.target
    endmethod
    method SetTarget takes DefenderSpawnLocation value returns nothing
        set this.target = value
    endmethod
    method Run takes nothing returns nothing
        local DefenderSpawnLocation source = this.source
        local DefenderSpawnLocation target = this.target
        local real sourceX = source.GetCenterX()
        local real sourceY = source.GetCenterY()
		local integer count = this.Data.Integer.Table.Count(TYPES_KEY_ARRAY)
		local Group dummyGroup = Group.Create()
		local integer iteration = Memory.IntegerKeys.Table.STARTED
        loop
            exitwhen (iteration > count)
            local DefenderSpawnType whichType = this.Data.Integer.Table.Get(TYPES_KEY_ARRAY, iteration)
            call dummyGroup.AddUnit(DefenderSpawn.AddNew(whichType, whichType.GetType(), sourceX, sourceY, UNIT.Facing.STANDARD))
            set iteration = iteration + 1
        endloop
        call dummyGroup.Order.IssuePointTarget(Order.ATTACK, target.RandomX(), target.RandomY())
        call dummyGroup.Destroy()
    endmethod
    static method Create takes DefenderSpawnLocation source, DefenderSpawnLocation target returns thistype
        local thistype this = thistype.allocate()
        call this.SetSource(source)
        call this.SetTarget(target)
        call this.Id.Event_Create()
        return this
    endmethod
    method AddType takes DefenderSpawnType whichType returns nothing
        call this.Data.Integer.Table.AddMulti(TYPES_KEY_ARRAY, whichType)
    endmethod
    static method Init takes nothing returns nothing
    endmethod
endstruct
    scope FolderDefenderSpawnWave
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return DefenderSpawnWave(this).Data.table.IntegerKeys.Table.ContainsInteger(DefenderSpawnWave(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return DefenderSpawnWave(this).Data.table.IntegerKeys.Table.CountIntegers(DefenderSpawnWave(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return DefenderSpawnWave(this).Data.table.IntegerKeys.Table.IsEmptyInteger(DefenderSpawnWave(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return DefenderSpawnWave(this).Data.table.IntegerKeys.Table.GetInteger(DefenderSpawnWave(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return DefenderSpawnWave(this).Data.table.IntegerKeys.Table.GetFirstInteger(DefenderSpawnWave(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return DefenderSpawnWave(this).Data.table.IntegerKeys.Table.GetLastInteger(DefenderSpawnWave(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call DefenderSpawnWave(this).Data.table.IntegerKeys.Table.Clear(DefenderSpawnWave(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return DefenderSpawnWave(this).Data.table.IntegerKeys.Table.FetchFirstInteger(DefenderSpawnWave(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return DefenderSpawnWave(this).Data.table.IntegerKeys.Table.RemoveInteger(DefenderSpawnWave(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return DefenderSpawnWave(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(DefenderSpawnWave(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return DefenderSpawnWave(this).Data.table.IntegerKeys.Table.AddInteger(DefenderSpawnWave(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return DefenderSpawnWave(this).Data.table.IntegerKeys.Table.AddIntegerMulti(DefenderSpawnWave(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call DefenderSpawnWave(this).Data.table.IntegerKeys.Table.JoinInteger(DefenderSpawnWave(this).Id.Get(), key, DefenderSpawnWave(other).Data.table, DefenderSpawnWave(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return DefenderSpawnWave(this).Data.table.IntegerKeys.Table.RandomInteger(DefenderSpawnWave(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call DefenderSpawnWave(this).Data.table.IntegerKeys.Table.ShuffleIntegers(DefenderSpawnWave(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call DefenderSpawnWave(this).Data.table.IntegerKeys.Table.PrintIntegers(DefenderSpawnWave(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return DefenderSpawnWave(this).Data.table.IntegerKeys.GetInteger(DefenderSpawnWave(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call DefenderSpawnWave(this).Data.table.IntegerKeys.RemoveInteger(DefenderSpawnWave(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call DefenderSpawnWave(this).Data.table.IntegerKeys.SetInteger(DefenderSpawnWave(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(DefenderSpawnWave(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject DefenderSpawnWave.Allocation.deallocate_demount.hook
		call DefenderSpawnWave(this).Data.Destroy()
	endinject
	inject DefenderSpawnWave.Allocation.allocate_mount.hook
		call DefenderSpawnWave(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructGroups
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        method Run takes nothing returns nothing
            local DefenderSpawnWave parent = this
            local integer count = parent.Data.Integer.Table.Count(KEY_ARRAY)
			local integer iteration = Memory.IntegerKeys.Table.STARTED
            loop
                exitwhen (iteration > count)
                local DefenderSpawnGroup currentGroup = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                call currentGroup.Run()
                set iteration = iteration + 1
            endloop
        endmethod
        method Add takes DefenderSpawnGroup value returns nothing
            call DefenderSpawnWave(this).Data.Integer.Table.Add(KEY_ARRAY, value)
        endmethod
    endstruct
endscope
    globals
        DefenderSpawnWave DEFENDER_SPAWN_WAVE = STRUCT_BASE
    endglobals
    struct DefenderSpawnWave
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    Level whichLevel
    FolderDefenderSpawnWave_StructData Data = this
    FolderDefenderSpawnWave_StructData LinkToStruct_Data
    FolderDefenderSpawnWave_StructGroups Groups = this
    FolderDefenderSpawnWave_StructGroups LinkToStruct_Groups
    FolderDefenderSpawnWave_StructId Id = this
    FolderDefenderSpawnWave_StructId LinkToStruct_Id
    real waitBefore
    method GetWaitBefore takes nothing returns real
        return this.waitBefore
    endmethod
    method SetWaitBefore takes real value returns nothing
        set this.waitBefore = value
    endmethod
    static method GetFromLevel takes Level whichLevel returns thistype
        return whichLevel.Data.Integer.Get(KEY)
    endmethod
    method Run takes nothing returns nothing
        call this.Groups.Run()
    endmethod
    method SetLevel takes Level value returns nothing
        set this.whichLevel = value
        call value.Data.Integer.Set(KEY, this)
    endmethod
    static method CreateFromLevel takes Level whichLevel returns thistype
        local thistype this = thistype.allocate()
        call this.SetLevel(whichLevel)
        call this.SetWaitBefore(20.)
        call this.Id.Event_Create()
        return this
    endmethod
    static method Init takes nothing returns nothing
		local integer iteration = Level.ALL_COUNT        
        local integer thisTypeIndex
        loop
            exitwhen (iteration < ARRAY_MIN)
            local Level currentLevel = Level.ALL[iteration]
            if not currentLevel.IsBonus() then
                local thistype this = thistype.CreateFromLevel(currentLevel)
                local DefenderSpawnGroup currentGroup = DefenderSpawnGroup.Create(DefenderSpawnLocation.SOURCE_CENTER, DefenderSpawnLocation.TARGET_LEFT)
                call currentGroup.AddType(DefenderSpawnType.SWORDSMAN)
                call currentGroup.AddType(DefenderSpawnType.SWORDSMAN)
                call currentGroup.AddType(DefenderSpawnType.VICAR)
                call this.Groups.Add(currentGroup)
                set currentGroup = DefenderSpawnGroup.Create(DefenderSpawnLocation.SOURCE_CENTER, DefenderSpawnLocation.TARGET_RIGHT)
                call currentGroup.AddType(DefenderSpawnType.SWORDSMAN)
                call currentGroup.AddType(DefenderSpawnType.SWORDSMAN)
                call currentGroup.AddType(DefenderSpawnType.VICAR)
                call this.Groups.Add(currentGroup)
                set currentGroup = DefenderSpawnGroup.Create(DefenderSpawnLocation.SOURCE_CENTER, DefenderSpawnLocation.TARGET_BOTTOM)
                call currentGroup.AddType(DefenderSpawnType.SWORDSMAN)
                call currentGroup.AddType(DefenderSpawnType.SWORDSMAN)
                call currentGroup.AddType(DefenderSpawnType.VICAR)
                call this.Groups.Add(currentGroup)
            endif
            set iteration = iteration - 1
        endloop
        
            
        
        
    endmethod
endstruct
    globals
        DefenderSpawn DEFENDER_SPAWN = STRUCT_BASE
    endglobals
    struct DefenderSpawn
        implement Allocation
        implement List
        
    static Group ALL_GROUP
    static EventType DUMMY_EVENT_TYPE
    static method RemoveAllUnits takes nothing returns nothing
        loop
            local Unit spawn = thistype.ALL_GROUP.FetchFirst()
            exitwhen (spawn == NULL)
            call spawn.Destroy()
        endloop
    endmethod
    static method Add_TriggerEvents takes DefenderSpawnType whichType, Unit whichUnit returns nothing
        local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
        call params.DefenderSpawnType.SetTrigger(whichType)
        call params.Unit.SetTrigger(whichUnit)
		local EventResponse typeParams = EventResponse.Create(whichType.Id.Get())
        call typeParams.DefenderSpawnType.SetTrigger(whichType)
        call typeParams.Unit.SetTrigger(whichUnit)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = Event.CountAtStatics(thistype.DUMMY_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call Event.GetFromStatics(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration2 = whichType.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call whichType.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(typeParams)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
        call typeParams.Destroy()
    endmethod
    static method AddNew takes DefenderSpawnType whichType, UnitType whichTypeUnitType, real x, real y, real angle returns Unit
        local Unit newUnit = Unit.Create(whichTypeUnitType, User.CASTLE, x, y, angle)
        
        call thistype.ALL_GROUP.AddUnit(newUnit)
        call thistype.Add_TriggerEvents(whichType, newUnit)
        return newUnit
    endmethod
    eventMethod Event_LevelStart
        local DefenderSpawnWave thisWave = DefenderSpawnWave.GetFromLevel(params.Level.GetTrigger())
        call thisWave.Run()
    endmethod
    eventMethod Event_Start
        call Event.Create(Level.START_EVENT_TYPE, EventPriority.MISC, function thistype.Event_LevelStart).AddToStatics()
    endmethod
    initMethod Init of Misc_4
        set thistype.ALL_GROUP = Group.Create()
        set thistype.DUMMY_EVENT_TYPE = EventType.Create()
        call Event.Create(EventType.START, EventPriority.MISC, function thistype.Event_Start).AddToStatics()
        call DefenderSpawnLocation.Init()
        call DefenderSpawnType.Init()
        call DefenderSpawnWave.Init()
    endmethod
endstruct
    globals
        Difficulty DIFFICULTY = STRUCT_BASE
    endglobals
    struct Difficulty
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static Event LEAVE_EVENT
    static thistype SELECTED
    static BoolExpr TARGET_FILTER
    static Dialog THIS_DIALOG
    static User THIS_PLAYER
    static thistype EASY
    static thistype MEDIUM
    static thistype HARD
    static thistype TEST
    string caption
    Trigger initTrigger
    Trigger initUpTrigger
    Announcement whichAnnouncement
    real damageFactor
    method GetDamageFactor takes nothing returns real
        return this.damageFactor
    endmethod
    method SetDamageFactor takes real value returns nothing
        set this.damageFactor = value
    endmethod
    integer gold
    method GetGold takes nothing returns integer
        return this.gold
    endmethod
    method SetGold takes integer value returns nothing
        set this.gold = value
    endmethod
    real lifeFactor
    method GetLifeFactor takes nothing returns real
        return this.lifeFactor
    endmethod
    method SetLifeFactor takes real value returns nothing
        set this.lifeFactor = value
    endmethod
    condMethod Conditions
        if (UNIT.Event.Native.GetFilter().Type.Get() != UnitType.TEMP) then
            return false
        endif
        return true
    endmethod
    static method AddAbility takes UnitType whichUnitType, Spell whichSpell returns nothing
        call whichUnitType.Abilities.Add(whichSpell)
        set UnitType.TEMP = whichUnitType
        call thistype.ENUM_GROUP.EnumUnits.All(thistype.TARGET_FILTER)
        loop
            local Unit target = thistype.ENUM_GROUP.FetchFirst()
            exitwhen (target == NULL)
            call target.Abilities.Add(whichSpell)
        endloop
    endmethod
    operatorMethod < takes thistype other returns boolean
        return (this.index < other.index)
    endmethod
    execMethod DoAnnouncement
        call thistype.SELECTED.whichAnnouncement.Start()
    endmethod
    execMethod EasyModifiers
    endmethod
    execMethod MediumModifiers
    endmethod
    execMethod MediumUpModifiers
        call Artifact.Start()
        
        
        call thistype.AddAbility(UnitType.FURBOLG_ORACLE, Purge.THIS_SPELL)
        call thistype.AddAbility(UnitType.MOONKIN, EnergyCharge.THIS_SPELL)
        
        
        call thistype.AddAbility(UnitType.ASSASSIN, Knockout.THIS_SPELL)
        call thistype.AddAbility(UnitType.AXE_FIGHTER, DeathAxe.THIS_SPELL)
        call thistype.AddAbility(UnitType.BALDUIR, Cleaver.THIS_SPELL)
        call thistype.AddAbility(UnitType.TAROG, Fireburst.THIS_SPELL)
    endmethod
    execMethod HardModifiers
    endmethod
    execMethod HardUpModifiers
        
        call thistype.AddAbility(UnitType.FURBOLG_ORACLE, Stampede.THIS_SPELL)
        call thistype.AddAbility(UnitType.GNOLL_MAGE, Purge.THIS_SPELL)
        call thistype.AddAbility(UnitType.SATYR, ChaosBall.THIS_SPELL)
        call UnitType.NAGAROSH.ManaRegeneration.Add(2.)
        call UnitType.TAROG.ManaRegeneration.Add(2.)
        
        call thistype.AddAbility(UnitType.ASSASSIN, Medipack.THIS_SPELL)
        call thistype.AddAbility(UnitType.BALDUIR, MutingShout.THIS_SPELL)
        call thistype.AddAbility(UnitType.CATAPULT, BurningOil.THIS_SPELL)
        call thistype.AddAbility(UnitType.RAIDER, ColdResistance.THIS_SPELL)
        call thistype.AddAbility(UnitType.SPEAR_SCOUT, BouncyBomb.THIS_SPELL)
    endmethod
    eventMethod Event_DialogClick
        local Dialog thisDialog = params.Dialog.GetTrigger()
        local DialogButton thisButton = params.Dialog.GetTriggerButton()
        local thistype this = thisButton.Data.Integer.Get(KEY)
        call thisDialog.Destroy()
        call thistype.THIS_PLAYER.Event.Remove(LEAVE_EVENT)
        set thistype.SELECTED = this
        call Game.DisplayTextTimed(User.ANY, this.caption, 30.)
        call User.ANY.State.Set(PLAYER_STATE_RESOURCE_GOLD, this.GetGold())
		local integer index = this.GetIndex()
		local integer iteration = ARRAY_MIN
        loop
            exitwhen (iteration >= index)
			if (thistype.ALL[iteration].initUpTrigger != NULL) then
            	call thistype.ALL[iteration].initUpTrigger.Run()
            endif
            set iteration = iteration + 1
        endloop
		local string infoMessage = "Enemies have " + String.Color.Do(Integer.ToString(Real.ToInt(this.GetDamageFactor() * 100)), String.Color.GOLD) + "% damage and " + String.Color.Do(Integer.ToString(Real.ToInt(this.GetLifeFactor() * 100)), String.Color.GOLD) + "% hitpoints."
        call Game.DisplayTextTimed(User.ANY, infoMessage, 30.)
		if (this.initTrigger != NULL) then
        	call this.initTrigger.Run()
        endif
		if (this.initUpTrigger != NULL) then
        	call this.initUpTrigger.Run()
        endif
        if not Artifact.STARTED then
            call Game.DisplayTextTimed(User.ANY, String.Color.Do("Artifacts are disabled.", String.Color.MALUS), 30.)
        endif
        call Act.Event_DifficultySet()
    endmethod
    eventMethod Event_Leave
        local integer iteration = ARRAY_MIN
        loop
            set thistype.THIS_PLAYER = User.ALL[iteration]
            exitwhen (thistype.THIS_PLAYER.SlotState.Get() == PlayerSlotState.PLAYING)
            set iteration = iteration + 1
        endloop
        call thistype.THIS_DIALOG.Display(thistype.THIS_PLAYER, true)
    endmethod
    static method Create takes string caption, code initFunction, code initUpFunction returns thistype
        local thistype this = thistype.allocate()
        set this.caption = caption
        set this.initTrigger = Trigger.CreateFromCode(initFunction)
        set this.initUpTrigger = Trigger.CreateFromCode(initUpFunction)
        call thistype.THIS_DIALOG.Buttons.Create(caption, 0).Data.Integer.Set(KEY, this)
        call this.AddToList()
        return this
    endmethod
    static method Start takes nothing returns nothing
        call Timer.GetExpired().Destroy()
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.LEAVE_EVENT = Event.Create(User.LEAVE_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Leave)
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        set thistype.THIS_DIALOG = Dialog.Create()
		local thistype this
        set this = thistype.Create("Castle visitor (easy)", function thistype.EasyModifiers, null)
        set thistype.EASY = this
        set this.whichAnnouncement = Announcement.Create(2)
        call this.SetDamageFactor(1.)
        call this.SetGold(500)
        call this.SetLifeFactor(1.)
        set this = thistype.Create("Vassal (medium)", function thistype.MediumModifiers, function thistype.MediumUpModifiers)
        set thistype.MEDIUM = this
        set this.whichAnnouncement = Announcement.Create(3)
        call this.SetDamageFactor(1.25)
        call this.SetGold(400)
        call this.SetLifeFactor(1.25)
        set this = thistype.Create("Knight (hard)", function thistype.HardModifiers, function thistype.HardUpModifiers)
        set thistype.HARD = this
        set this.whichAnnouncement = Announcement.Create(4)
        call this.SetDamageFactor(1.5)
        call this.SetGold(300)
        call this.SetLifeFactor(1.5)
        set this = thistype.Create("Penguin (Test mode)", null, null)
        set thistype.TEST = this
        set this.whichAnnouncement = Announcement.Create(5)
        call this.SetDamageFactor(0.75)
        call this.SetGold(1500)
        call this.SetLifeFactor(0.75)
		local integer iteration = ARRAY_MIN
        loop
            set thistype.THIS_PLAYER = User.ALL[iteration]
            exitwhen (THIS_PLAYER.SlotState.Get() == PlayerSlotState.PLAYING)
            set iteration = iteration + 1
        endloop
        call thistype.THIS_DIALOG.SetTitle("Declare yourself!")
        call thistype.THIS_PLAYER.Event.Add(LEAVE_EVENT)
        call thistype.THIS_DIALOG.Event.Add(Event.Create(Dialog.CLICK_EVENT_TYPE, EventPriority.MISC, function thistype.Event_DialogClick))
        call thistype.THIS_DIALOG.Display(thistype.THIS_PLAYER, true)
    endmethod
endstruct
    globals
        Drop DROP = STRUCT_BASE
    endglobals
    struct Drop
        implement Allocation
        implement List
        
    static constant real AREA_RANGE = 1000.
    static Group ENUM_GROUP
    static real SUPPLY_FACTOR = 1.
    static BoolExpr TARGET_FILTER
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if (target.Owner.Get().Hero.Get() != target) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if (target.Owner.Get().Team.Get() != Team.DEFENDERS) then
            return false
        endif
        return true
    endmethod
    static key GetKeyMacro_TAG_KEY_ARRAY
    static constant integer TAG_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_TAG_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static method AddExp takes Unit target, real amount returns nothing
        local TextTag tag = target.AddJumpingTextTagWithValue(TAG_KEY_ARRAY + target, amount)
        call tag.Text.Set(String.Color.Do(Char.PLUS + Integer.ToString(Real.ToInt(tag.GetValue())), "ff8b008b"), 0.02)
        call target.Exp.Add(amount)
    endmethod
    static key GetKeyMacro_HEAL_TAG_KEY_ARRAY
    static constant integer HEAL_TAG_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_HEAL_TAG_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static method DoHeal takes Unit target, real val returns nothing
		if target.Classes.Contains(UnitClass.DEAD) then
			return
		endif
		if target.Classes.Contains(UnitClass.MECHANICAL) then
			return
		endif
		if target.Classes.Contains(UnitClass.STRUCTURE) then
			return
		endif
		if target.Classes.Contains(UnitClass.WARD) then
			return
		endif
        if (val <= 0) then
            return
        endif
		call target.Effects.Create(thistype.HEAL_EFFECT_PATH, thistype.HEAL_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
        local TextTag tag = target.AddJumpingTextTagWithValue(HEAL_TAG_KEY_ARRAY + target, val)
        call tag.Text.Set(String.Color.Do(Char.PLUS + Integer.ToString(Real.ToInt(tag.GetValue())), "ffd45e19"), 0.02)
        call target.Life.Add(val)
        call target.Mana.Add(val)
        call target.Stamina.Add(val)
    endmethod
    eventMethod Exp_Event_Death
        local Unit killer = params.Unit.GetKiller()
        if (killer == NULL) then
            return
        endif
        local User killerOwner = killer.Owner.Get()
        local Unit whichUnit = params.Unit.GetTrigger()
        if whichUnit.IsAllyOf(killerOwner) then
            return
        endif
        if (killerOwner.Team.Get() != Team.DEFENDERS) then
            return
        endif
		local real amount = whichUnit.Type.Get().Drop.Exp.Get()
		call thistype.DoHeal(killer, amount * 0.25)
		set killer = killerOwner.Hero.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(whichUnit.Position.X.Get(), whichUnit.Position.Y.Get(), thistype.AREA_RANGE, thistype.TARGET_FILTER)
		local integer pickedAmount = thistype.ENUM_GROUP.Count()
		local real killerBonus
		if (killer == NULL) then
			set killerBonus = 0.
		else
            set killerBonus = 0.4 - 0.05 * pickedAmount
        endif
		local real shared
		if (pickedAmount <= 0) then
			set shared = 0.
		else
        	set shared = (1. - killerBonus) / pickedAmount
        endif
		if (killer != NULL) then
			if thistype.ENUM_GROUP.ContainsUnit(killer) then
				call thistype.AddExp(killer, (shared + killerBonus) * amount)
				
				call thistype.ENUM_GROUP.RemoveUnit(killer)
			else
				call thistype.AddExp(killer, killerBonus * amount)
			endif
		endif
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            loop
                call thistype.AddExp(target, shared * amount)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    static method GetDrop takes Unit killer, Unit whichUnit returns integer
        return Real.ToInt(whichUnit.Drop.Supply.Get())
    endmethod
    eventMethod Supply_Event_Death
        local Unit killer = params.Unit.GetKiller()
        local Unit whichUnit = params.Unit.GetTrigger()
        if (killer == NULL) then
            return
        endif
        if (whichUnit.Owner.Get().Team.Get() != Team.ATTACKERS) then
            return
        endif
        local User killerOwner = killer.Owner.Get()
        if (killerOwner.Team.Get() != Team.DEFENDERS) then
            return
        endif
        if (killerOwner == User.CASTLE) then
            return
        endif
        local integer drop = Real.ToInt(thistype.GetDrop(killer, whichUnit) * thistype.SUPPLY_FACTOR)
        if (drop <= 0) then
            return
        endif
        call killerOwner.State.Add(PLAYER_STATE_RESOURCE_GOLD, drop)
        if (drop > whichUnit.Type.Get().Drop.Supply.Get()) then
            call whichUnit.AddJumpingTextTagEx(String.Color.Do(Char.PLUS + Integer.ToString(drop), String.Color.GOLD), 1.15 * TextTag.STANDARD_SIZE, TextTag.GetFreeId(), false, false)
        else
            call whichUnit.AddJumpingTextTagEx(String.Color.Do(Char.PLUS + Integer.ToString(drop), String.Color.GOLD), 1. * TextTag.STANDARD_SIZE, TextTag.GetFreeId(), false, false)
        endif
    endmethod
    static method AddSupplyFactor takes real value returns nothing
        set thistype.SUPPLY_FACTOR = thistype.SUPPLY_FACTOR + value
    endmethod
    static method SubtractSupplyFactor takes real value returns nothing
        set thistype.SUPPLY_FACTOR = thistype.SUPPLY_FACTOR - value
    endmethod
    initMethod Init of Misc
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Exp_Event_Death).AddToStatics()
        call Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Supply_Event_Death).AddToStatics()
    endmethod
endstruct
    globals
        EternalVial ETERNAL_VIAL = STRUCT_BASE
    endglobals
    struct EternalVial
        implement Allocation
        implement List
        
	static real INTERVAL
	Timer intervalTimer
	static method DoHeal takes Unit target
		call target.Effects.Create(thistype.HEAL_EFFECT_PATH, thistype.HEAL_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
		call target.Effects.Create(thistype.HEAL_EFFECT_PATH, thistype.HEAL_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
		call target.HealBySpell(target, thistype.HEAL_FACTOR_PER_INTERVAL * target.MaxLife.Get())
		call target.HealManaBySpell(target, thistype.HEAL_MANA_FACTOR_PER_INTERVAL * target.MaxMana.Get())
		call target.HealStaminaBySpell(target, thistype.HEAL_STAMINA_FACTOR_PER_INTERVAL * target.MaxStamina.Get())
	endmethod
	timerMethod Interval
		local thistype this = Timer.GetExpired().GetData()
		local Unit target = this
		call thistype.DoHeal(target)
	endmethod
	eventMethod Event_BuffLose
		local Unit target = params.Unit.GetTrigger()
		local thistype this = target
		call this.intervalTimer.Destroy()
	endmethod
	eventMethod Event_BuffGain
		local Unit target = params.Unit.GetTrigger()
		local thistype this = target
		local Timer intervalTimer = Timer.Create()
		set this.intervalTimer = intervalTimer
		call intervalTimer.SetData(this)
		call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
	endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        call caster.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION)
		call thistype.DoHeal(caster)
    endmethod
    initMethod Init of Spells_Misc
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_SpellEffect))
		set thistype.INTERVAL = thistype.DURATION / (thistype.INTERVALS_AMOUNT - 1)
    endmethod
endstruct
    globals
        Explosive EXPLOSIVE = STRUCT_BASE
    endglobals
    struct Explosive
        implement Allocation
        implement List
        
    static constant real AREA_RANGE = 300.
    static Event CREATE_EVENT
    static constant real DAMAGE = 200.
    static constant real DELAY = 0.35
    static Event DEATH_EVENT
    static Group ENUM_GROUP
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static constant real MAX_DAMAGE = 900.
    static BoolExpr TARGET_FILTER
    real x
    real y
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Invulnerability.Try() then
            return false
        endif
        return true
    endmethod
    enumMethod DestructableEnum
        call DESTRUCTABLE.Event.Native.GetEnum().Life.Subtract(thistype.DAMAGE)
    endmethod
    static method Ending takes nothing returns nothing
        local Timer delayTimer = Timer.GetExpired()
        local thistype this = delayTimer.GetData()
        call this.deallocate()
        call delayTimer.Destroy()
        call Spot.CreateEffect(x, y, thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW).Destroy()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, thistype.AREA_RANGE, thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.GetNearest(x, y)
        if (target != NULL) then
            local real damageAll = thistype.MAX_DAMAGE
            loop
                exitwhen (damageAll == 0)
                local real damage = Math.Min(thistype.DAMAGE, target.Life.Get())
                call thistype.ENUM_GROUP.RemoveUnit(target)
                set damageAll = damageAll - damage
                call target.Life.Subtract(damage)
                set target = thistype.ENUM_GROUP.GetNearest(x, y)
                exitwhen (target == NULL)
            endloop
        endif
        call DESTRUCTABLE.Enum.InRange.Do(x, y, thistype.AREA_RANGE, function thistype.DestructableEnum)
    endmethod
    eventMethod Event_Death
        local Destructable explosive = params.Destructable.GetTrigger()
        local thistype this = thistype.allocate()
		local Timer delayTimer = Timer.Create()
        local real x = explosive.GetX()
        local real y = explosive.GetY()
        set this.x = x
        set this.y = y
        call delayTimer.SetData(this)
        call explosive.Event.Remove(DEATH_EVENT)
        call delayTimer.Start(thistype.DELAY, false, function thistype.Ending)
    endmethod
    eventMethod Event_Create
        call params.Destructable.GetTrigger().Event.Add(DEATH_EVENT)
    endmethod
    initMethod Init of Misc
        set thistype.CREATE_EVENT = Event.Create(Destructable.CREATE_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Create)
        set thistype.DEATH_EVENT = Event.Create(Destructable.DEATH_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Death)
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call DestructableType.EXPLOSIVE.Event.Add(CREATE_EVENT)
        call DestructableType.KEG.Event.Add(CREATE_EVENT)
    endmethod
endstruct
    globals
        GarbageCollector GARBAGE_COLLECTOR = STRUCT_BASE
    endglobals
    struct GarbageCollector
        implement Allocation
        implement List
        
endstruct
    globals
        BoomerangStone BOOMERANG_STONE = STRUCT_BASE
    endglobals
    struct BoomerangStone
        implement Allocation
        implement List
        
    Unit caster
    Unit target
    static method CasterConditions takes Unit caster returns boolean
        if caster.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        return true
    endmethod
    eventMethod CasterImpact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        call this.deallocate()
        call dummyMissile.Destroy()
        if thistype.CasterConditions(caster) then
            
        endif
    endmethod
    static method TargetConditions takes Unit target returns boolean
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.Invulnerability.Try() then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod TargetImpact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        local Unit target = this.target
        set User.TEMP = caster.Owner.Get()
        if thistype.TargetConditions(target) then
            call target.Buffs.Timed.Start(UNIT.Stun.NORMAL_BUFF, 1, thistype.DURATION)
            call caster.DamageUnitBySpell(target, thistype.DAMAGE, false, false)
        endif
        call dummyMissile.Impact.SetAction(function thistype.CasterImpact)
        call dummyMissile.Speed.Set(1100.)
        call dummyMissile.GoToUnit.Start(caster, function Missile.Destruction)
        call caster.Refs.Subtract()
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local Missile dummyMissile = Missile.Create()
        local Unit target = params.Unit.GetTarget()
        local thistype this = thistype.allocate()
        set this.caster = caster
        set this.target = target
        call caster.Refs.Add()
        call dummyMissile.CollisionSize.Set(10.)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 2.)
        call dummyMissile.Impact.SetAction(function thistype.TargetImpact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(1250.)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.GoToUnit.Start(target, function Missile.Destruction)
    endmethod
    initMethod Init of Items_Act1
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        Mallet MALLET = STRUCT_BASE
    endglobals
    struct Mallet
        implement Allocation
        implement List
        
    static constant real DAMAGE_INCREMENT = 12.
    static constant real STRENGTH_INCREMENT = 4.
    eventMethod Event_Drop
        local Unit whichUnit = params.Unit.GetTrigger()
        call whichUnit.Damage.Bonus.Subtract(thistype.DAMAGE_INCREMENT)
        call whichUnit.Hero.Strength.Bonus.Subtract(thistype.STRENGTH_INCREMENT)
    endmethod
    eventMethod Event_PickUp
        local Unit whichUnit = params.Unit.GetTrigger()
        call whichUnit.Damage.Bonus.Add(thistype.DAMAGE_INCREMENT)
        call whichUnit.Hero.Strength.Bonus.Add(thistype.STRENGTH_INCREMENT)
    endmethod
    initMethod Init of Items_Act1
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_Drop))
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_PickUp))
    endmethod
endstruct
    globals
        PenguinFeather PENGUIN_FEATHER = STRUCT_BASE
    endglobals
    struct PenguinFeather
        implement Allocation
        implement List
        
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local Unit target = params.Unit.GetTarget()
        call target.Effects.Create(thistype.HEAL_EFFECT_PATH, thistype.HEAL_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).DestroyTimed.Start(2.)
        call caster.HealBySpell(target, thistype.HEAL)
    endmethod
    eventMethod Event_Drop
        local Unit whichUnit = params.Unit.GetTrigger()
        call whichUnit.EvasionChance.Bonus.Subtract(thistype.EVASION_INCREMENT)
        call whichUnit.Hero.Intelligence.Bonus.Subtract(thistype.INTELLIGENCE_INCREMENT)
    endmethod
    eventMethod Event_PickUp
        local Unit whichUnit = params.Unit.GetTrigger()
        call whichUnit.EvasionChance.Bonus.Add(thistype.EVASION_INCREMENT)
        call whichUnit.Hero.Intelligence.Bonus.Add(thistype.INTELLIGENCE_INCREMENT)
    endmethod
    initMethod Init of Items_Act1
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_Drop))
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_PickUp))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        RabbitsFoot RABBITS_FOOT = STRUCT_BASE
    endglobals
    struct RabbitsFoot
        implement Allocation
        implement List
        
    static constant real CRITICAL_INCREMENT = 0.2
    static constant real EVASION_INCREMENT = 0.25
    eventMethod Event_Drop
        local Unit whichUnit = params.Unit.GetTrigger()
call DebugEx("drop")
        call whichUnit.CriticalChance.Bonus.Subtract(thistype.CRITICAL_INCREMENT)
        call whichUnit.EvasionChance.Bonus.Subtract(thistype.EVASION_INCREMENT)
    endmethod
    eventMethod Event_PickUp
        local Unit whichUnit = params.Unit.GetTrigger()
call DebugEx("pickup")
        call whichUnit.CriticalChance.Bonus.Add(thistype.CRITICAL_INCREMENT)
        call whichUnit.EvasionChance.Bonus.Add(thistype.EVASION_INCREMENT)
    endmethod
    initMethod Init of Items_Act1
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_Drop))
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_PickUp))
    endmethod
endstruct
    globals
        RamblersStick RAMBLERS_STICK = STRUCT_BASE
    endglobals
    struct RamblersStick
        implement Allocation
        implement List
        
    static constant real ARMOR_INCREMENT = 1.
    static constant real DAMAGE_INCREMENT = 5.
    static constant real INTELLIGENCE_INCREMENT = 4.
    eventMethod Event_Drop
        local Unit whichUnit = params.Unit.GetTrigger()
        call whichUnit.Armor.Bonus.Subtract(thistype.ARMOR_INCREMENT)
        call whichUnit.Damage.Bonus.Subtract(thistype.DAMAGE_INCREMENT)
        call whichUnit.Hero.Intelligence.Bonus.Subtract(thistype.INTELLIGENCE_INCREMENT)
    endmethod
    eventMethod Event_PickUp
        local Unit whichUnit = params.Unit.GetTrigger()
        call whichUnit.Armor.Bonus.Add(thistype.ARMOR_INCREMENT)
        call whichUnit.Damage.Bonus.Add(thistype.DAMAGE_INCREMENT)
        call whichUnit.Hero.Intelligence.Bonus.Add(thistype.INTELLIGENCE_INCREMENT)
    endmethod
    initMethod Init of Items_Act1
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_Drop))
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_PickUp))
    endmethod
endstruct
    globals
        GruntAxe GRUNT_AXE = STRUCT_BASE
    endglobals
    struct GruntAxe
        implement Allocation
        implement List
        
    static constant real CRITICAL_CHANCE_INCREMENT = 50.
    static constant real DAMAGE_INCREMENT = 8.
    eventMethod Event_Drop
        local Unit whichUnit = params.Unit.GetTrigger()
        call whichUnit.CriticalChance.Bonus.Subtract(thistype.CRITICAL_CHANCE_INCREMENT)
        call whichUnit.Damage.Bonus.Subtract(thistype.DAMAGE_INCREMENT)
    endmethod
    eventMethod Event_PickUp
        local Unit whichUnit = params.Unit.GetTrigger()
        call whichUnit.CriticalChance.Bonus.Add(thistype.CRITICAL_CHANCE_INCREMENT)
        call whichUnit.Damage.Bonus.Add(thistype.DAMAGE_INCREMENT)
    endmethod
    initMethod Init of Items_Act2
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_Drop))
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_PickUp))
    endmethod
endstruct
    globals
        RobynsHood ROBYNS_HOOD = STRUCT_BASE
    endglobals
    struct RobynsHood
        implement Allocation
        implement List
        
    static constant real AGILITY_INCREMENT = 2.
    static constant real ARMOR_INCREMENT = 4.
    eventMethod Event_Drop
        local Unit whichUnit = params.Unit.GetTrigger()
        call whichUnit.Hero.Agility.Bonus.Subtract(thistype.AGILITY_INCREMENT)
        call whichUnit.Armor.Bonus.Subtract(thistype.ARMOR_INCREMENT)
    endmethod
    eventMethod Event_PickUp
        local Unit whichUnit = params.Unit.GetTrigger()
        call whichUnit.Hero.Agility.Bonus.Add(thistype.AGILITY_INCREMENT)
        call whichUnit.Armor.Bonus.Add(thistype.ARMOR_INCREMENT)
    endmethod
    initMethod Init of Items_Act2
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_Drop))
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_PickUp))
    endmethod
endstruct
    globals
        ElfinDagger ELFIN_DAGGER = STRUCT_BASE
    endglobals
    struct ElfinDagger
        implement Allocation
        implement List
        
    static constant real DAMAGE_INCREMENT = 0.25
    static constant real INTELLIGENCE_INCREMENT = 10.
    eventMethod Event_Drop
        local Unit whichUnit = params.Unit.GetTrigger()
        call whichUnit.Damage.SpellRelative.Subtract(thistype.DAMAGE_INCREMENT)
        call whichUnit.Intelligence.Bonus.Subtract(thistype.INTELLIGENCE_INCREMENT)
    endmethod
    eventMethod Event_PickUp
        local Unit whichUnit = params.Unit.GetTrigger()
        call whichUnit.Damage.SpellRelative.Add(thistype.DAMAGE_INCREMENT)
        call whichUnit.Intelligence.Bonus.Add(thistype.INTELLIGENCE_INCREMENT)
    endmethod
    initMethod Init of Items_Act3
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_Drop))
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_PickUp))
    endmethod
endstruct
    scope FolderSpearOfTheDefender
    public struct StructBuff
        implement Allocation
        implement List
        
        static Unit CASTER
        static constant real DAMAGE = 50.
        static constant real DURATION = 10.
        static constant integer INTERVALS_AMOUNT = 10
        static constant string TARGET_EFFECT_ATTACH_POINT = AttachPoint.CHEST
        static constant real DAMAGE_PER_INTERVAL = thistype.DAMAGE / thistype.INTERVALS_AMOUNT
        static constant real INTERVAL = thistype.DURATION / thistype.INTERVALS_AMOUNT
        Unit caster
        Timer intervalTimer
        timerMethod Interval
            local thistype this = Timer.GetExpired().GetData()
            local Unit target = this
            call target.Effects.Create(target.Blood.Get(), thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.LOW).DestroyTimed.Start(2.)
            call this.caster.DamageUnit(target, thistype.DAMAGE_PER_INTERVAL, false)
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            local Timer intervalTimer = this.intervalTimer
            call intervalTimer.Destroy()
        endmethod
        eventMethod Event_BuffGain
            local Unit caster = thistype.CASTER
            local Timer intervalTimer = Timer.Create()
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            set this.caster = caster
            set this.intervalTimer = intervalTimer
            call intervalTimer.SetData(this)
            call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
        endmethod
        static method Start takes Unit caster, Unit target returns nothing
            set thistype.CASTER = caster
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, thistype.DURATION)
        endmethod
        static method Init takes nothing returns nothing
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
    endstruct
endscope
    globals
        SpearOfTheDefender SPEAR_OF_THE_DEFENDER = STRUCT_BASE
    endglobals
    struct SpearOfTheDefender
        implement Allocation
        implement List
        
    static constant real ARMOR_INCREMENT = 0.2
    static constant real ATTACK_RATE_INCREMENT = -0.2
    static Event DAMAGE_EVENT
    static constant real DAMAGE_INCREMENT = 50.
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static constant real MANA_INCREMENT = 30.
    FolderSpearOfTheDefender_StructBuff Buff = this
    FolderSpearOfTheDefender_StructBuff LinkToStruct_Buff
    eventMethod Event_Damage
        local Unit caster = params.Unit.GetDamager()
        local Unit target = params.Unit.GetTrigger()
        call thistype(NULL).Buff.Start(caster, target)
    endmethod
    eventMethod Event_Drop
        local Unit whichUnit = params.Unit.GetTrigger()
        local integer amount = (whichUnit.Data.Integer.Get(KEY) - 1)
        call whichUnit.Armor.Relative.Subtract(thistype.ARMOR_INCREMENT)
        call whichUnit.Attack.Speed.BonusA.Subtract(thistype.ATTACK_RATE_INCREMENT)
        call whichUnit.Damage.Bonus.Subtract(thistype.DAMAGE_INCREMENT)
        call whichUnit.Data.Integer.Set(KEY, amount)
        if (amount == HASH_TABLE.Integer.DEFAULT_VALUE) then
            call whichUnit.Event.Add(DAMAGE_EVENT)
        endif
    endmethod
    eventMethod Event_PickUp
        local Unit whichUnit = params.Unit.GetTrigger()
        local integer amount = (whichUnit.Data.Integer.Get(KEY) + 1)
        call whichUnit.Armor.Relative.Add(thistype.ARMOR_INCREMENT)
        call whichUnit.Attack.Speed.BonusA.Add(thistype.ATTACK_RATE_INCREMENT)
        call whichUnit.Damage.Bonus.Add(thistype.DAMAGE_INCREMENT)
        call whichUnit.Data.Integer.Set(KEY, amount)
        if (amount == HASH_TABLE.Integer.DEFAULT_VALUE + 1) then
            call whichUnit.Event.Add(DAMAGE_EVENT)
        endif
    endmethod
    initMethod Init of Items_Act3
        set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_Damage)
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_Drop))
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_PickUp))
        call thistype(NULL).Buff.Init()
    endmethod
endstruct
    globals
        MeteoriteShard METEORITE_SHARD = STRUCT_BASE
    endglobals
    struct MeteoriteShard
        implement Allocation
        implement List
        
    static constant real LIFE_INCREMENT = 100.
    static constant real MANA_INCREMENT = 30.
    eventMethod Event_Drop
        local Unit whichUnit = params.Unit.GetTrigger()
        call whichUnit.MaxLife.Bonus.Subtract(thistype.LIFE_INCREMENT)
        call whichUnit.MaxMana.Bonus.Subtract(thistype.MANA_INCREMENT)
    endmethod
    eventMethod Event_PickUp
        local Unit whichUnit = params.Unit.GetTrigger()
        call whichUnit.MaxLife.Bonus.Add(thistype.LIFE_INCREMENT)
        call whichUnit.MaxMana.Bonus.Add(thistype.MANA_INCREMENT)
    endmethod
    initMethod Init of Items_Misc
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_Drop))
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_PickUp))
    endmethod
endstruct
    globals
        GoldCoin GOLD_COIN = STRUCT_BASE
    endglobals
    struct GoldCoin
        implement Allocation
        implement List
        
    static key GetKeyMacro_AMOUNT_KEY
    static constant integer AMOUNT_KEY = Math.Integer.MIN + GetKeyMacro_AMOUNT_KEY
    static Event COIN_DESTROY_EVENT
    static CustomDrop THIS_DROP
    integer amount
    eventMethod Event_ItemUse
        local Item thisItem = params.Item.GetTrigger()
        local Unit whichUnit = params.Unit.GetTrigger()
        local real x = thisItem.Position.GetX()
        local real y = thisItem.Position.GetY()
        local real z = thisItem.Position.GetZ()
		local thistype this = thisItem
        local Sound dummySound = Sound.CreateFromType(thistype.DUMMY_SOUND)
        call dummySound.SetPositionAndPlay(x, y, z)
        call TEXT_TAG.CreateJumping.Create(String.Color.Do(Char.PLUS + Integer.ToString(amount), String.Color.GOLD), 1.15 * TextTag.STANDARD_SIZE, thisItem.Position.GetX(), thisItem.Position.GetY(), thisItem.Position.GetZ(), TextTag.GetFreeId())
        call dummySound.Destroy(true)
		local integer iteration = User.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            call User.ALL[iteration].State.Add(PLAYER_STATE_RESOURCE_GOLD, this.amount)
            set iteration = iteration - 1
        endloop
    endmethod
    eventMethod Event_Coin_Destroy
        local Item thisItem = params.Item.GetTrigger()
        local thistype this = thisItem
        call thisItem.Event.Remove(COIN_DESTROY_EVENT)
    endmethod
    eventMethod Event_Spawn_Death
        local Unit whichUnit = params.Unit.GetTrigger()
        local Item thisItem = Item.Create(thistype.THIS_ITEM, whichUnit.Position.X.Get(), whichUnit.Position.Y.Get())
        local thistype this = thisItem
        set this.amount = whichUnit.Type.Get().Data.Integer.Get(AMOUNT_KEY)
        call thisItem.Event.Add(COIN_DESTROY_EVENT)
    endmethod
    static method AddToUnitType takes UnitType whichType, integer amount returns nothing
        call whichType.Data.Integer.Set(AMOUNT_KEY, amount)
        call whichType.Drop.Add(thistype.THIS_DROP)
    endmethod
    initMethod Init of Misc
        set thistype.COIN_DESTROY_EVENT = Event.Create(Item.DESTROY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Coin_Destroy)
        set thistype.THIS_DROP = CustomDrop.Create(Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_Spawn_Death), null, null, EffectLevel.NORMAL)
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Use.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_ItemUse))
    endmethod
endstruct
    globals
        HeroRevival HERO_REVIVAL = STRUCT_BASE
    endglobals
    struct HeroRevival
        implement Allocation
        implement List
        
    static Event DEATH_EVENT
    static CineFilter DUMMY_CINE_FILTER
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static Rectangle array REVIVAL_RECTS
    static Event REVIVE_EVENT
    static Unit ROSA
    static Rectangle ROSA_RECT
    static constant real UPDATE_FACING_TIME = (4 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_FACING_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (4 * 1.))
    static integer GHOSTS_AMOUNT = 0
    Unit ghost
    UnitEffect ghostEffect
    Timer updateFacingTimer
    Unit whichUnit
    static method GetGhostByUnit takes Unit whichUnit returns Unit
        return thistype(whichUnit.Data.Integer.Get(KEY)).ghost
    endmethod
    method Ending takes Unit ghost, Unit whichUnit returns nothing
        local UnitEffect ghostEffect = this.ghostEffect
        local Timer updateFacingTimer = this.updateFacingTimer
        call ghost.Data.Integer.Remove(KEY)
        call updateFacingTimer.Destroy()
        call whichUnit.Data.Integer.Remove(KEY)
        call whichUnit.Event.Remove(REVIVE_EVENT)
        call ghost.Destroy()
        set thistype.GHOSTS_AMOUNT = thistype.GHOSTS_AMOUNT - 1
        if (thistype.GHOSTS_AMOUNT == 0) then
            call thistype.ROSA.Animation.Loop.Abort()
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit ghost = params.Unit.GetTrigger()
        local User localPlayer = User.GetLocal()
        local boolean selected = ghost.IsSelected(localPlayer)
        local real angle = ghost.Facing.Get()
        local User ghostOwner = ghost.Owner.Get()
        local real x = ghost.Position.X.Get()
        local real y = ghost.Position.Y.Get()
		local thistype this = ghost.Data.Integer.Get(KEY)
        local Unit whichUnit = this.whichUnit
        call this.Ending(ghost, whichUnit)
        call thistype.DUMMY_CINE_FILTER.Ending(ghostOwner)
        call whichUnit.Hero.Revive(x, y)
        call whichUnit.Effects.Create(thistype.REVIVE_EFFECT_PATH, thistype.REVIVE_EFFECT_ATTACH_PT, EffectLevel.NORMAL).DestroyTimed.Start(5.)
        call whichUnit.Facing.Set(angle)
        call whichUnit.Buffs.Timed.Start(UNIT.MagicImmunity.NORMAL_BUFF, 1, thistype.MAGIC_IMMUNITY_DURATION)
        call SetUnitOwner(whichUnit.self, ghostOwner.self, false)
        call whichUnit.Select(localPlayer, selected)
        call whichUnit.Life.Set(thistype.LIFE_FACTOR * whichUnit.MaxLife.Get())
        call whichUnit.Mana.Set(thistype.MANA_FACTOR * whichUnit.MaxMana.Get())
    endmethod
    timerMethod UpdateFacing
        local thistype this = Timer.GetExpired().GetData()
        call this.whichUnit.Facing.Set(this.ghost.Facing.Get())
    endmethod
    eventMethod Event_Death
        local Unit whichUnit = params.Unit.GetTrigger()
        if whichUnit.Revival.Is() then
            return
        endif
		set thistype.GHOSTS_AMOUNT = thistype.GHOSTS_AMOUNT + 1
        local User ghostOwner = whichUnit.Owner.Get()
        local User localPlayer = User.GetLocal()
        local Rectangle revivalRect = thistype.REVIVAL_RECTS[0]
        local boolean selected = whichUnit.IsSelected(localPlayer)
        local thistype this = thistype.allocate()
        local Timer updateFacingTimer = Timer.Create()
        local real x = revivalRect.RandomX()
        local real y = revivalRect.RandomY()
        local Unit ghost = Unit.Create(whichUnit.Type.Get(), ghostOwner, x, y, Math.AtanByDeltas(Waypoint.CENTER.GetCenterY() - y, Waypoint.CENTER.GetCenterX() - x))
        set this.ghost = ghost
        set this.ghostEffect = ghost.Effects.Create(thistype.GHOST_EFFECT_PATH, thistype.GHOST_EFFECT_ATTACH_PT, EffectLevel.LOW)
        set this.updateFacingTimer = updateFacingTimer
        set this.whichUnit = whichUnit
        call ghost.Data.Integer.Set(KEY, this)
        call updateFacingTimer.SetData(this)
        call ghost.Abilities.Clear()
        call HeroSpell.ClearAtUnit(ghost)
        call ghost.Attack.Subtract()
        
        call ghost.Classes.Add(UnitClass.NEUTRAL)
        call ghost.Effects.Create(thistype.DEATH_EFFECT_PATH, thistype.DEATH_EFFECT_ATTACH_PT, EffectLevel.NORMAL).DestroyTimed.Start(5.)
        call ghost.Ghost.Add()
        call ghost.Invisibility.Add()
        call ghost.Invulnerability.Add()
        call ghost.LifeRegeneration.Set(0.)
        call ghost.Mana.Set(0.)
        call ghost.ManaRegeneration.Set(thistype.MANA_REGENERATION)
        call ghost.MaxLife.Set(100.)
        call ghost.MaxMana.Set(thistype.MANA_CAP)
        call ghost.Pathing.Subtract()
        call ghost.Select(localPlayer, selected)
        call ghost.Stun.AddTimed(2.)
        if ((localPlayer == whichUnit.Owner.Get()) and selected) then
            call Camera.PanTimed(localPlayer, x, y, 3.)
        endif
        call whichUnit.Data.Integer.Set(KEY, this)
        call whichUnit.Event.Add(REVIVE_EVENT)
        call SetUnitOwner(whichUnit.self, User.NEUTRAL_PASSIVE.self, false)
        call ghost.Abilities.Add(thistype.THIS_SPELL)
        call ghost.Life.Set(100.)
		call thistype.DUMMY_CINE_FILTER.Start(3., ghostOwner)
        call updateFacingTimer.Start(thistype.UPDATE_FACING_TIME, true, function thistype.UpdateFacing)
        if (thistype.GHOSTS_AMOUNT == 1) then
            call thistype.ROSA.Animation.Loop.Start(UNIT.Animation.SPELL)
        endif
    endmethod
    eventMethod Event_Revive
        local Unit whichUnit = params.Unit.GetTrigger()
        local thistype this = whichUnit.Data.Integer.Get(KEY)
        call this.Ending(this.ghost, whichUnit)
    endmethod
    eventMethod Event_HeroPick
        call params.Unit.GetTrigger().Event.Add(DEATH_EVENT)
    endmethod
    eventMethod Event_Start
        set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Death)
        set thistype.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Revive)
        call Event.Create(HeroSelection.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_HeroPick).AddToStatics()
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.SUCCESS_EVENT_TYPE, EventPriority.MISC, function thistype.Event_SpellEffect))
    endmethod
    initMethod Init of Misc_2
        set thistype.DUMMY_CINE_FILTER = CineFilter.Create()
        set thistype.REVIVAL_RECTS[0] = Rectangle.CreateFromSelf(gg_rct_HeroRevival)
        set thistype.REVIVAL_RECTS[1] = Rectangle.CreateFromSelf(gg_rct_HeroRevival2)
        call thistype.DUMMY_CINE_FILTER.SetColorEnd(148, 58, 145, Real.ToInt(0.7 * 255))
        call thistype.DUMMY_CINE_FILTER.SetTexture("ReplaceableTextures\\CameraMasks\\DreamFilter_Mask.blp")
        call Event.Create(EventType.START, EventPriority.MISC, function thistype.Event_Start).AddToStatics()
        set thistype.ROSA_RECT = Rectangle.CreateFromSelf(gg_rct_Rosa)
        local real x = thistype.ROSA_RECT.GetCenterX()
        local real y = thistype.ROSA_RECT.GetCenterY()
        set thistype.ROSA = Unit.Create(thistype.ROSA_TYPE, User.CASTLE, x, y, Math.AtanByDeltas(thistype.REVIVAL_RECTS[0].GetCenterY() - y, thistype.REVIVAL_RECTS[0].GetCenterX() - x))
    endmethod
endstruct
    globals
        Spirit SPIRIT = STRUCT_BASE
    endglobals
    struct Spirit
        implement Allocation
        implement List
        
	static Rectangle CENTER_RECT
	static real CENTER_X
	static real CENTER_Y
	static real CENTER_Z
	static Rectangle CHAMBER_RECT
	static Event DESTROY_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
	static Event LEAVE_EVENT
    static constant real UPDATE_TIME = (1 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (1 * 1.))
	static Timer UPDATE_TIMER
    static thistype array ACTIVE_LIST_ALL
    static integer ACTIVE_LIST_ALL_COUNT = ARRAY_EMPTY
    integer ACTIVE_LIST_index
    static method ACTIVE_LIST_Count takes nothing returns integer
        return thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static method ACTIVE_LIST_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Get takes integer index returns thistype
        return thistype.ACTIVE_LIST_ALL[index]
    endmethod
    static method ACTIVE_LIST_GetIndex takes thistype this returns integer
        return this.ACTIVE_LIST_index
    endmethod
    static method ACTIVE_LIST_Contains takes thistype this returns boolean
        return (thistype.ACTIVE_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ACTIVE_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ACTIVE_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ACTIVE_LIST_RandomAll takes nothing returns thistype
        return thistype.ACTIVE_LIST_Random(ARRAY_MIN, thistype.ACTIVE_LIST_ALL_COUNT)
    endmethod
    static method ACTIVE_LIST_Remove takes thistype this returns boolean
        if not thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT].ACTIVE_LIST_index = this.ACTIVE_LIST_index
        set thistype.ACTIVE_LIST_ALL[this.ACTIVE_LIST_index - 1] = thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT]
        set this.ACTIVE_LIST_index = ARRAY_MIN
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT - 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Add takes thistype this returns boolean
        if thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT + 1
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT] = this
        set this.ACTIVE_LIST_index = thistype.ACTIVE_LIST_ALL_COUNT + 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static thistype array FOR_EACH_LIST_ALL
    static integer FOR_EACH_LIST_ALL_COUNT = ARRAY_EMPTY
    static method FOR_EACH_LIST_FetchFirst takes nothing returns thistype
        local thistype result
        if (thistype.FOR_EACH_LIST_ALL_COUNT < ARRAY_MIN) then
            return NULL
        endif
        set result = thistype.FOR_EACH_LIST_ALL[ARRAY_MIN]
        set thistype.FOR_EACH_LIST_ALL[ARRAY_MIN] = thistype.FOR_EACH_LIST_ALL[thistype.FOR_EACH_LIST_ALL_COUNT]
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.FOR_EACH_LIST_ALL_COUNT - 1
        return result
    endmethod
    static method FOR_EACH_LIST_Set takes nothing returns nothing
        local integer iteration = thistype.ACTIVE_LIST_ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.FOR_EACH_LIST_ALL[iteration] = thistype.ACTIVE_LIST_ALL[iteration]
            set iteration = iteration - 1
        endloop
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
	real angleA
	real angleAAdd
	real angleB
	real angleBAdd
	Unit spirit
	User whichPlayer
	destroyMethod Destroy
		call this.spirit.Data.Integer.Remove(KEY)
		call this.spirit.Event.Remove(DESTROY_EVENT)
		call this.whichPlayer.Data.Integer.Remove(KEY)
		call this.whichPlayer.Event.Remove(LEAVE_EVENT)
		call this.spirit.Destroy()
		if thistype.ACTIVE_LIST_Remove(this) then
			call thistype.UPDATE_TIMER.Pause()
		endif
	endmethod
	eventMethod Impact
		local Missile dummyMissile = params.Missile.GetTrigger()
		local Unit target = params.Unit.GetTarget()
		local Unit spirit = dummyMissile.GetData()
		call dummyMissile.Destroy()
		call spirit.Silence.Subtract()
		if (target == NULL) then
			return
		endif
		local HeroSelection heroSelectionData = HeroSelection.GetFromUnit(target)
		if (heroSelectionData == NULL) then
			call target.Effects.Create(thistype.POSSESSION_DEFLECT_EFFECT_PATH, thistype.POSSESSION_DEFLECT_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
			local TextTag tag = target.AddJumpingTextTag(String.Color.Do("Target cannot be possessed", spirit.Owner.Get().GetColorString()), 0.03, TextTag.GetFreeId())
			return
		endif
		if (target.Owner.Get() != User.NEUTRAL_PASSIVE) then
			call target.Effects.Create(thistype.POSSESSION_DEFLECT_EFFECT_PATH, thistype.POSSESSION_DEFLECT_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
			call target.AddJumpingTextTag(String.Color.Do("Target already possessed", spirit.Owner.Get().GetColorString()), 0.03, TextTag.GetFreeId())
			return
		endif
		call target.Effects.Create(thistype.POSSESSION_EFFECT_PATH, thistype.POSSESSION_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
		call heroSelectionData.Select(spirit.Owner.Get())
		call spirit.Destroy()
	endmethod
	eventMethod Event_Possess
		local Unit spirit = params.Unit.GetTrigger()
		local Unit target = params.Unit.GetTarget()
		call spirit.Silence.Add()
		local Missile dummyMissile = Missile.Create()
        call dummyMissile.Arc.SetByPerc(0.06)
        call dummyMissile.CollisionSize.Set(10.)
        call dummyMissile.DummyUnit.Create(thistype.POSSESSION_MISSILE_UNIT_ID, 1.5)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(spirit)
        call dummyMissile.Speed.Set(800.)
        call dummyMissile.Position.SetFromUnit(spirit)
        call dummyMissile.GoToUnit.Start(target, null)
		local Sound effectSound = Sound.CreateFromType(thistype.POSSESSION_SOUND)
		call effectSound.AttachToUnitAndPlay(spirit)
		call effectSound.Destroy(true)
	endmethod
	eventMethod Event_Destroy
		local Unit spirit = params.Unit.GetTrigger()
		local thistype this = spirit.Data.Integer.Get(KEY)
		call this.Destroy()
	endmethod
	eventMethod Event_Leave
		local thistype this = params.User.GetTrigger().Data.Integer.Get(KEY)
		call this.Destroy()
	endmethod
	method Update
		local real angleA = Math.Mod(this.angleA + this.angleAAdd, Math.FULL_ANGLE)
		local real angleB = Math.Mod(this.angleB + this.angleBAdd, Math.FULL_ANGLE)
		local real angleACos = Math.Cos(angleA)
		local real angleASin = Math.Sin(angleA)
		local real angleBCos = Math.Cos(angleB)
		local real angleBSin = Math.Sin(angleB)
		local real x = thistype.CENTER_X + thistype.DIST * angleACos * angleBSin
		local real y = thistype.CENTER_Y + thistype.DIST * angleASin * angleBSin
		local real z = thistype.CENTER_Z + thistype.DIST * angleBCos
		set this.angleA = angleA
		set this.angleB = angleB
		call this.spirit.Position.Set(x, y, z)
	endmethod
	timerMethod UpdateByTimer
        call thistype.FOR_EACH_LIST_Set()
        loop
            local thistype this = thistype.FOR_EACH_LIST_FetchFirst()
            exitwhen (this == NULL)
            call this.Update()
        endloop
	endmethod
	static method Create takes User whichPlayer
		local Unit spirit = Unit.Create(thistype.SPIRIT_UNIT_TYPE, whichPlayer, thistype.CENTER_X, thistype.CENTER_Y, thistype.CENTER_Z)
		local thistype this = thistype.allocate()
		local real angle = Math.RandomAngle()
		set this.angleA = Math.RandomAngle()
		set this.angleAAdd = Math.Cos(angle) * thistype.ANGLE_SPEED * thistype.UPDATE_TIME
		set this.angleB = Math.RandomAngle()
		set this.angleBAdd = Math.Sin(angle) * thistype.ANGLE_SPEED * thistype.UPDATE_TIME
		set this.spirit = spirit
		set this.whichPlayer = whichPlayer
		call spirit.Data.Integer.Set(KEY, this)
		call spirit.Event.Add(DESTROY_EVENT)
		call whichPlayer.Data.Integer.Set(KEY, this)
		call whichPlayer.Event.Add(LEAVE_EVENT)
		if thistype.ACTIVE_LIST_Add(this) then
			call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.UpdateByTimer)
		endif
		call spirit.Select(whichPlayer, true)
		call this.Update()
	endmethod
	eventMethod Event_Start
		local integer i = User.PLAYING_HUMANS_COUNT
		loop
			exitwhen (i < ARRAY_MIN)
			local User whichPlayer = User.PLAYING_HUMANS[i]
			call thistype.Create(whichPlayer)
			call Visibility.AddRect(whichPlayer, thistype.CHAMBER_RECT)
			set i = i - 1
		endloop
	endmethod
	trigMethod CenterTrig
		local Unit whichUnit = UNIT.Event.Native.GetTrigger()
		local User owner = whichUnit.Owner.Get()
		if (owner == User.NEUTRAL_PASSIVE) then
			return
		endif
		local HeroSelection heroSelectionData = HeroSelection.GetFromUnit(whichUnit)
		if (heroSelectionData == NULL) then
			return
		endif
		call heroSelectionData.Deselect()
		call thistype.Create(owner)		
	endmethod
	static method Init
		set thistype.UPDATE_TIMER = Timer.Create()
		set thistype.CENTER_RECT = Rectangle.CreateFromSelf(gg_rct_HeroSelection_Center)
		set thistype.CHAMBER_RECT = Rectangle.CreateFromSelf(gg_rct_Chamber)
		set thistype.CENTER_X = thistype.CENTER_RECT.GetCenterX()
		set thistype.CENTER_Y = thistype.CENTER_RECT.GetCenterY()
		set thistype.CENTER_Z = Spot.GetHeight(thistype.CENTER_X, thistype.CENTER_Y) + thistype.HEIGHT
		set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Destroy)
		set thistype.LEAVE_EVENT = Event.Create(User.LEAVE_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Leave)
		call thistype.POSSESSION_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Possess))
		call Event.Create(EventType.START, EventPriority.MISC, function thistype.Event_Start).AddToStatics()
		call Trigger.CreateFromCode(function thistype.CenterTrig).RegisterEvent.EnterRegion(Region.CreateFromRectangle(thistype.CENTER_RECT), null)
	endmethod
endstruct
    globals
        HeroSelection HERO_SELECTION = STRUCT_BASE
    endglobals
    struct HeroSelection
        implement Allocation
        implement List
        
    static EventType DUMMY_EVENT_TYPE
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_SOUNDS_KEY_ARRAY
    static constant integer SOUNDS_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_SOUNDS_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    real angle
    User currentOwner
    string description
    string name
    TextTag nameTag
    Unit whichUnit
    real x
    real y
	static method GetFromUnit takes Unit u returns thistype
		return u.Data.Integer.Get(KEY)
	endmethod
    static method TriggerEvents takes User whichPlayer, Unit whichUnit returns nothing
        local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
        call params.Unit.SetTrigger(whichUnit)
        call params.User.SetTrigger(whichPlayer)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = Event.CountAtStatics(thistype.DUMMY_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call Event.GetFromStatics(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    destroyMethod Destroy
        call this.nameTag.Destroy()
        call this.currentOwner.Data.Integer.Remove(KEY)
        call this.whichUnit.Data.Integer.Remove(KEY)
    endmethod
	method LeaveChamber
		local User whichPlayer = this.currentOwner
		local Unit whichUnit = this.whichUnit
        call this.Destroy()
        call whichUnit.Invulnerability.Subtract()
        call whichPlayer.Hero.Set(whichUnit)
        call thistype.TriggerEvents(whichPlayer, whichUnit)
        call whichUnit.Items.Create(EternalVial.THIS_ITEM, true)
        call whichUnit.Silence.Subtract()
        call whichUnit.SkillPoints.Add(1)
        call whichPlayer.State.Add(PLAYER_STATE_RESOURCE_GOLD, 300)
        call Camera.PanTimed(whichPlayer, whichUnit.Position.X.Get(), whichUnit.Position.Y.Get(), 2.)
        call whichUnit.Items.Create(TeleportScroll.THIS_ITEM, true)
        if (Difficulty.SELECTED == Difficulty.TEST) then
            call whichUnit.Level.Set(3)
            call whichPlayer.State.Add(PLAYER_STATE_RESOURCE_LUMBER, 250)
        endif
	endmethod
    trigMethod StairwayRightTrig
        local Unit whichUnit = UNIT.Event.Native.GetTrigger()
        local User whichPlayer = whichUnit.Owner.Get()
		local preplaced target = preplaced.rect_BasementStairwayUpTargetRight
		call whichUnit.Position.SetXY(target.x, target.y)
		local thistype this = whichPlayer.Data.Integer.Get(KEY)
		if (this == NULL) then
			return
		endif
		if (this.whichUnit != whichUnit) then
			return
		endif
		call this.LeaveChamber()
    endmethod
    trigMethod StairwayLeftTrig
        local Unit whichUnit = UNIT.Event.Native.GetTrigger()
        local User whichPlayer = whichUnit.Owner.Get()
		local preplaced target = preplaced.rect_BasementStairwayUpTargetLeft
		call whichUnit.Position.SetXY(target.x, target.y)
		local thistype this = whichPlayer.Data.Integer.Get(KEY)
		if (this == NULL) then
			return
		endif
		if (this.whichUnit != whichUnit) then
			return
		endif
		call this.LeaveChamber()
    endmethod
	method Deselect
		if (this.currentOwner == NULL) then
			return
		endif
		local User currentOwner = this.currentOwner
		local Unit whichUnit = this.whichUnit
		set this.currentOwner = NULL
		call currentOwner.Data.Integer.Remove(KEY)
        call whichUnit.Owner.Set(User.NEUTRAL_PASSIVE)
        call PauseUnit(whichUnit.self, true)
        call whichUnit.Facing.Set(this.angle)
        call whichUnit.Position.SetXY(this.x, this.y)
        call Spot.CreateEffect(this.x, this.y, thistype.RESET_EFFECT_PATH, EffectLevel.LOW).DestroyTimed.Start(2.)
	endmethod
	method Select takes User whichPlayer
		call this.Deselect()
		set this.currentOwner = whichPlayer
		call whichPlayer.Data.Integer.Set(KEY, this)
        
        call PauseUnit(whichUnit.self, false)
        call whichUnit.Owner.Set(whichPlayer)
        call whichUnit.Select(whichPlayer, true)
	endmethod
    method AddSound takes string path
        local Sound whichSound = Sound.Create(path, false, false, false, 0, 0, SoundEax.DEFAULT)
        call this.whichUnit.Data.Integer.Table.Add(SOUNDS_KEY_ARRAY, whichSound)
    endmethod
    static method Create takes preplaced p, string description returns thistype
        local thistype this = thistype.allocate()
		local TextTag nameTag = TextTag.Create(TextTag.GetFreeId())
		local real angle = p.angle
        local real x = p.x
        local real y = p.y
        local Unit whichUnit = Unit.CreateFromPreplaced(p)
        set this.angle = angle
        set this.name = String.Color.Do(whichUnit.GetProperName(), "ffaaaa00")
        set this.nameTag = nameTag
        set this.whichUnit = whichUnit
        set this.x = x
        set this.y = y
        call whichUnit.Data.Integer.Set(KEY, this)
        
        call nameTag.Position.Set(x - 50., y, 200.)
        call PauseUnit(whichUnit.self, true)
        call whichUnit.Invulnerability.Add()
        call whichUnit.Silence.Add()
        call whichUnit.SkillPoints.Set(0)
		call this.AddToList()
        return this
    endmethod
    eventMethod Event_Start
    	local thistype this
		
        set this = thistype.Create(preplaced.unit_19, "Fast, strong, graceful and a superior handling with the bow adorn the reputation of this young defender. In contrast, she cannot keep pace in melee and owns a minor mana pool. If it should become tight, she will call animal spirits for support.")
        call this.AddSound("Units\\NightElf\\HeroMoonPriestess\\HeroMoonPriestessPissed3.wav")
        call this.AddSound("Units\\NightElf\\HeroMoonPriestess\\HeroMoonPriestessPissed5.wav")
        call this.AddSound("Units\\NightElf\\HeroMoonPriestess\\HeroMoonPriestessWhat2.wav")
		
        set this = thistype.Create(preplaced.unit_20, "The Count is a close combat user, even if he does not come with the most of hitpoints. In return, he is able to suck life from his enemies and is granted another chance with 'Rigor Mortis'.")
		call this.AddSound("Units\\Undead\\HeroDreadLord\\HeroDreadlordWhat1.wav")
		
        set this = thistype.Create(preplaced.unit_21, "An elven acquaintance of Count Drakul. There is not much known about this character either but he seems to be into general magics.")
		call this.AddSound("Units\\Human\\Kael\\KaelYes4.wav")
		
        set this = thistype.Create(preplaced.unit_24, "Covered in metal, Kera is the Sarafin family's bodyguard and mentor of Aruruw. Underneath her cloak, she holds a whole armory of devastating weapons which she knows well to effectively make use of in combat.")
        call this.AddSound("Units\\NightElf\\HeroWarden\\HeroWardenPissed7.wav")
        call this.AddSound("Units\\NightElf\\HeroWarden\\HeroWardenReady1.wav")
        call this.AddSound("Units\\NightElf\\HeroWarden\\HeroWardenWarcry1.wav")
        call this.AddSound("Units\\NightElf\\HeroWarden\\HeroWardenWhat1.wav")
		
        set this = thistype.Create(preplaced.unit_25, "This little cheeky fairy has a fragile body, which does not permit her open battles. Since here wings were pulled out, she is not able to fly anymore. Still, she has got a lavish magical potential and is a master of theurgic curses, which could become well handy.")
        call this.AddSound("Units\\Human\\Jaina\\JainaPissed1.wav")
        call this.AddSound("Units\\Human\\Jaina\\JainaPissed3.wav")
        call this.AddSound("Units\\Human\\Jaina\\JainaWhat1.wav")
        call this.AddSound("Units\\Human\\Jaina\\JainaWhat3.wav")
		
        set this = thistype.Create(preplaced.unit_26, "He is the meter-tall bulwark and has got a heavy punch. Forming a team with his Polar Bear chum, together, boosting the fighting spirit is their aim. Unfortunately, the dwarf is short on legs and hardly experienced in magics.")
        call this.AddSound("Units\\Human\\HeroMountainKing\\HeroMountainKingPissed3.wav")
        call this.AddSound("Units\\Human\\HeroMountainKing\\HeroMountainKingPissed5.wav")
        call this.AddSound("Units\\Human\\HeroMountainKing\\HeroMountainKingPissed6.wav")
        call this.AddSound("Units\\Human\\HeroMountainKing\\HeroMountainKingWhat1.wav")
        call this.AddSound("Units\\Human\\HeroMountainKing\\HeroMountainKingWhat2.wav")
		
        set this = thistype.Create(preplaced.unit_27, "The title 'The Stormpike', this hero maintains, is not for a joke. Using his horse he can reach high speeds and his swordsmanship skills are considerable. Other than that, only average attributes.")
        call this.AddSound("Units\\Undead\\HeroDeathKnight\\DeathKnightPissed3.wav")
        call this.AddSound("Units\\Undead\\HeroDeathKnight\\DeathKnightReady1.wav")
        call this.AddSound("Units\\Undead\\HeroDeathKnight\\DeathKnightWhat1.wav")
		
        set this = thistype.Create(preplaced.unit_28, "This lively bear originates from the northern polar regions. About five years ago, he moved here alone because the climate up there never appealed to him. Also, there, he comes badly by beer. He is perhaps the most average in the group except his blood alcohol level. Yet, he can produce mana potions for the rest and alcoholize the enemies.")
		call this.AddSound("Units\\Creeps\\PandarenBrewmaster\\PandarenBrewmasterPissed8.wav")
		
        set this = thistype.Create(preplaced.unit_30, "The greenskin is an apprentice of Shamanism. This allows him to heal the other group members and to summon the energies of nature. Maybe, thereby, he can gain the others' trust by doing so. He is seated on the back of a black timber wolf.")
        call this.AddSound("Units\\Orc\\Thrall\\ThrallWhat2.wav")
        call this.AddSound("Units\\Orc\\Thrall\\ThrallYes2.wav")
        call this.AddSound("Units\\Orc\\Thrall\\ThrallYes3.wav")
		call Camera.PanTimed(User.ANY, preplaced.rect_HeroSelection_Center.x, preplaced.rect_HeroSelection_Center.y, 0.)
    endmethod
    initMethod Init of Misc
        set thistype.DUMMY_EVENT_TYPE = EventType.Create()
        call Event.Create(EventType.START, EventPriority.MISC, function thistype.Event_Start).AddToStatics()
        call Trigger.CreateFromCode(function thistype.StairwayLeftTrig).RegisterEvent.EnterRegion(Region.CreateFromRectangle(Rectangle.CreateFromSelf(gg_rct_BasementStairwayUpLeft)), null)
        call Trigger.CreateFromCode(function thistype.StairwayRightTrig).RegisterEvent.EnterRegion(Region.CreateFromRectangle(Rectangle.CreateFromSelf(gg_rct_BasementStairwayUpRight)), null)
		call Spirit.Init()
    endmethod
endstruct
    globals
        Hint HINT = STRUCT_BASE
    endglobals
    struct Hint
        implement Allocation
        implement List
        
    static constant real INTERVAL = 60.
    static boolean SHOW = false
    string text
    timerMethod Interval
        local thistype this
        if thistype.SHOW then
            set this = thistype.RandomFromList(ARRAY_MIN, thistype.ALL_COUNT)
            call Game.DisplayTextTimed(User.ANY, String.Color.Do("Hint " + Integer.ToString(this.GetIndex() + 1 - ARRAY_MIN) + " of " + Integer.ToString(thistype.ALL_COUNT + 1 - ARRAY_MIN) + ": ", String.Color.GOLD) + this.text, 10.)
        endif
    endmethod
    eventMethod Event_AfterIntro
        call Timer.Create().Start(thistype.INTERVAL, true, function thistype.Interval)
    endmethod
    static method Create takes string text returns thistype
        local thistype this = thistype.allocate()
        set this.text = text
        call this.AddToList()
        return this
    endmethod
    initMethod Init of Misc_2
        call thistype.Create("You receive a notification message each time when there are creep camps in the next level. These creeps spawn outside of the castle and drop some unique effect besides gold/xp like permanent stats bonuses or temporary buffs.")
        call thistype.Create("Regard one of the modern travelling services that are next to the side entrances of the castle to spend a visit at the tavern.")
        call thistype.Create("Explore the vast castle library that holds ancient wisdom of nature-bound magic.")
        call thistype.Create("Wintercastle lies in the crystal mountains, behind the shadowy forest that never met the light of spring.")
        call thistype.Create("1-2 heroes should be enough to take care of normal creep camps. The taverns serve 'Tropical Rainbow' for free, but only one vial at a time. You may use it to fast return to the castle or to approach the other camp. It also boosts the attack speed so can be compoundable with finishing off the creeps.")
        call Event.Create(AfterIntro.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_AfterIntro).AddToStatics()
    endmethod
endstruct
    scope FolderHorseRide
    public struct StructTarget
        implement Allocation
        implement List
        
        DummyUnit horse
        DummyUnitEffect horseEffect
        HorseRide parent
        static method GetHorse takes Unit target returns DummyUnit
            local thistype this = target
            return this.horse
        endmethod
        static method DoEffect takes Unit target returns nothing
            local thistype this = target
            local DummyUnit horse = this.horse
            local real angle = horse.Facing.GetNative()
            local real x = horse.Position.X.GetNative()
            local real y = horse.Position.Y.GetNative()
            local real z = horse.Position.Z.GetNative()
            local DummyUnit dummyUnit = DummyUnit.Create(thistype.HORSE_ID, x + thistype.DUMMY_UNIT_OFFSET * Math.Cos(angle), y + thistype.DUMMY_UNIT_OFFSET * Math.Sin(angle), z, angle)
            call dummyUnit.Order.PointTarget(Order.MOVE, x, y)
            call dummyUnit.VertexColor.Set(255., 255., 255., 191.)
            call dummyUnit.VertexColor.Timed.Subtract(255., 255., 255., 191., thistype.DUMMY_UNIT_DURATION)
            call dummyUnit.DestroyTimed.Start(thistype.DUMMY_UNIT_DURATION)
        endmethod
        static method Update takes Unit target returns nothing
            local thistype this = target
            local DummyUnit horse = this.horse
            local Rectangle targetRect = this.parent.targetRect
            local real x = horse.Position.X.GetNative()
            local real y = horse.Position.Y.GetNative()
            call target.Transport.SetPosition(x, y)
            if targetRect.ContainsCoords(x, y) then
                local real dismountAngle = horse.Facing.Get() - Math.PI
                call target.Buffs.Remove(thistype.DUMMY_BUFF)
                call target.Position.SetWithCollision(x + thistype.DISMOUNT_OFFSET * Math.Cos(dismountAngle), y + thistype.DISMOUNT_OFFSET * Math.Sin(dismountAngle))
            elseif (horse.Order.GetNative() == NULL) then
                call horse.Order.PointTarget(Order.MOVE, targetRect.GetCenterX(), targetRect.GetCenterY())
            endif
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            local DummyUnit horse = this.horse
            local DummyUnitEffect horseEffect = this.horseEffect
call InfoEx("A "+target.GetName()+";"+R2S(GetUnitState(target.self, UNIT_STATE_LIFE)))
            call Camera.UnlockFromUnit(target.Owner.Get())
            call horse.Order.Immediate(Order.STOP)
            call horse.VertexColor.Timed.Subtract(0., 0., 0., 255., FADE_OUT)
            call horseEffect.Destroy()
            call target.Effects.Create(thistype.ENDING_EFFECT_PATH, thistype.ENDING_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
            call target.Transport.Subtract()
call InfoEx("B "+target.GetName()+";"+R2S(GetUnitState(target.self, UNIT_STATE_LIFE)))
            call horse.DestroyTimed.Start(thistype.FADE_OUT)
            call this.parent.RemoveUnit(target)
        endmethod
        eventMethod Event_BuffGain
            local Unit target = params.Unit.GetTrigger()
            local User targetOwner = target.Owner.Get()
            local thistype this = target
			local DummyUnit horse = DummyUnit.Create(thistype.HORSE_ID, target.Position.X.Get(), target.Position.Y.Get(), target.Position.Z.Get(), Math.RandomAngle())
            set this.horse = horse
            set this.horseEffect = DummyUnitEffect.Create(horse, thistype.HORSE_EFFECT_PATH, thistype.HORSE_EFFECT_ATTACH_POINT, EffectLevel.LOW)
            set this.parent = HorseRide.TEMP
            call Camera.LockToDummyUnit(targetOwner, horse)
            call DummyUnitEffect.Create(horse, thistype.START_EFFECT_PATH, thistype.START_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
            call horse.Owner.Set(targetOwner)
            call horse.SetMoveSpeed(522.)
            call target.Transport.Add()
        endmethod
        method Start takes Unit target returns nothing
            set HorseRide.TEMP = this
            call target.Buffs.AddFresh(thistype.DUMMY_BUFF, 1)
        endmethod
        static method Init takes nothing returns nothing
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
    endstruct
endscope
    globals
        HorseRide HORSE_RIDE = STRUCT_BASE
    endglobals
    struct HorseRide
        implement Allocation
        implement List
        
    static constant real DELAY = 2.
    static group DUMMY_GROUP
    static constant real EFFECT_INTERVAL = 0.625
    static constant real UPDATE_TIME = 1.
    static Rectangle ARTIFACT_INTRO_TARGET
    static Rectangle LEFT_TAVERN
    static Rectangle RIGHT_TAVERN
	static thistype TEMP
    Timer effectTimer
    Group targetGroup
    Rectangle targetRect
    Timer updateTimer
    FolderHorseRide_StructTarget Target = this
    FolderHorseRide_StructTarget LinkToStruct_Target
    method Ending takes nothing returns nothing
        local Timer effectTimer = this.effectTimer
        local Group targetGroup = this.targetGroup
        local Timer updateTimer = this.updateTimer
        call effectTimer.Destroy()
        call targetGroup.Destroy()
        call updateTimer.Destroy()
    endmethod
    method RemoveUnit takes Unit target returns nothing
        call targetGroup.RemoveUnit(target)
        if targetGroup.IsEmpty() then
            call this.Ending()
        endif
    endmethod
    static method DoEffectTargets takes nothing returns nothing
        call thistype(NULL).Target.DoEffect(UNIT.Event.Native.GetEnum())
    endmethod
    static method DoEffect takes nothing returns nothing
        local thistype this = Timer.GetExpired().GetData()
        call this.targetGroup.Do(function thistype.DoEffectTargets)
    endmethod
    static method UpdateTargets takes nothing returns nothing
        call thistype(NULL).Target.Update(UNIT.Event.Native.GetEnum())
    endmethod
    timerMethod Update
        local thistype this = Timer.GetExpired().GetData()
        call this.targetGroup.Do(function thistype.UpdateTargets)
    endmethod
    static method GetHorses takes nothing returns nothing
        call GroupAddUnit(thistype.DUMMY_GROUP, thistype(NULL).Target.GetHorse(UNIT.Event.Native.GetEnum()).self)
    endmethod
    timerMethod Delay
        local Timer updateTimer = Timer.GetExpired()
        local thistype this = updateTimer.GetData()
        local Group targetGroup = this.targetGroup
        local Rectangle targetRect = this.targetRect
        call GroupClear(thistype.DUMMY_GROUP)
        call targetGroup.Do(function thistype.GetHorses)
        call GroupPointOrderById(thistype.DUMMY_GROUP, Order.MOVE.self, targetRect.GetCenterX(), targetRect.GetCenterY())
        call this.effectTimer.Start(thistype.EFFECT_INTERVAL, true, function thistype.DoEffect)
        call updateTimer.Start(thistype.UPDATE_TIME, true, function thistype.Update)
    endmethod
    static method AddTargets takes nothing returns nothing
        call thistype.TEMP.Target.Start(UNIT.Event.Native.GetEnum())
    endmethod
    static method Start takes Group targetGroup, Rectangle targetRect returns nothing
    	local thistype this = targetGroup
        local Timer effectTimer = Timer.Create()
        local Timer updateTimer = Timer.Create()
        set this.effectTimer = effectTimer
        set this.targetGroup = targetGroup
        set this.targetRect = targetRect
        set this.updateTimer = updateTimer
        call effectTimer.SetData(this)
        call updateTimer.SetData(this)
        call updateTimer.Start(thistype.DELAY, true, function thistype.Delay)
        set thistype.TEMP = this
        call targetGroup.Do(function thistype.AddTargets)
    endmethod
    static method AddHero takes nothing returns nothing
        call Group.TEMP.AddUnit(UNIT.Event.Native.GetEnum())
    endmethod
    static method Step2 takes nothing returns nothing
        set Group.TEMP = Group.Create()
        call USER.Hero.EnumAll(function thistype.AddHero, false)
        call thistype.Start(Group.TEMP, thistype.ARTIFACT_INTRO_TARGET)
    endmethod
    static method StartIntro takes nothing returns nothing
        call Game.DisplaySpeechFromUnit(Sebastian.THIS_UNIT, "Sire, Victor has just sent a message that the weapons you ordered have been completed.", 2.)
        call Game.DisplaySpeechFromUnit(Unit.DRAKUL, "Good. Saddle the horses!", 2.)
        call Game.DisplaySpeechFromUnit(Unit.DRAKUL, "Rosa, you delay them until we return.", 2.)
        call Game.DisplaySpeechFromUnit(HeroRevival.ROSA, "At your command.", 2.)
        call Timer.Create().Start(8., false, function thistype.Step2)
    endmethod
    eventMethod Event_Sell
    	local Unit horse = params.Unit.GetTrigger()
    	local Unit target = params.Unit.GetTarget()
        local boolean right = (horse == Unit.GetFromSelf(gg_unit_uRiS_0044))
        local Group targetGroup = Group.Create()
        call targetGroup.AddUnit(target)
        if right then
            call thistype.Start(targetGroup, thistype.RIGHT_TAVERN)
        else
            call thistype.Start(targetGroup, thistype.LEFT_TAVERN)
        endif
    endmethod
    initMethod Init of Misc
        set thistype.ARTIFACT_INTRO_TARGET = Rectangle.CreateFromSelf(gg_rct_ArtifactIntroTarget)
        set thistype.DUMMY_GROUP = CreateGroup()
        set thistype.LEFT_TAVERN = Rectangle.CreateFromSelf(gg_rct_LeftTavern)
        set thistype.RIGHT_TAVERN = Rectangle.CreateFromSelf(gg_rct_RightTavern)
        call thistype.SHOP_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Sell.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_Sell))
        call thistype(NULL).Target.Init()
    endmethod
endstruct
    scope FolderInfoboard
    public struct StructUser
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
        integer row
        static method GetRow takes User whichPlayer returns integer
            local thistype this = whichPlayer
            return this.row
        endmethod
        static method SetRow takes User whichPlayer, integer row returns nothing
            local thistype this = whichPlayer
            set this.row = row
        endmethod
        static method Update takes User whichPlayer returns nothing
            local Unit whichPlayerHero
            if (whichPlayer.SlotState.Get() != PlayerSlotState.EMPTY) then
                set whichPlayerHero = whichPlayer.Hero.Get()
                if (whichPlayerHero == NULL) then
                    call Infoboard.THIS_BOARD.SetValue(GetRow(whichPlayer), 1, "inactive")
                elseif whichPlayerHero.Classes.Contains(UnitClass.DEAD) then
                    call Infoboard.THIS_BOARD.SetValue(GetRow(whichPlayer), 1, "dead " + Real.ToIntString(HeroRevival(whichPlayerHero.Data.Integer.Get(HeroRevival.KEY)).ghost.Mana.Get()))
                else
                    call Infoboard.THIS_BOARD.SetValue(GetRow(whichPlayer), 1, "active")
                endif
            endif
        endmethod
    endstruct
endscope
    globals
        Infoboard INFOBOARD = STRUCT_BASE
    endglobals
    struct Infoboard
        implement Allocation
        implement List
        
    static Event CHARGES_CHANGE_EVENT
    static constant string CHECK_PATH = "ReplaceableTextures\\WorldEditUI\\Editor-Ally-HighPriority.blp"
    static constant string CROSS_PATH = "ReplaceableTextures\\WorldEditUI\\Editor-Ally-NoPriority.blp"
    static Event DROP_EVENT
    static Event MOVE_EVENT
    static Event PICK_UP_EVENT
    static constant string QUESTION_MARK_PATH = "ReplaceableTextures\\CommandButtons\\BTNSelectHeroOff.blp"
    static integer PLAYERS_COLUMN
    static integer STATUS_COLUMN
    static integer ITEMS_COLUMN
    static integer CHAPTER_ROW
    static integer CURRENT_ROUND_ROW
    static integer LEVEL_ROW
    static Multiboard THIS_BOARD = NULL
    FolderInfoboard_StructUser User = this
    FolderInfoboard_StructUser LinkToStruct_User
    static method AttachItem takes Item whichItem, integer whichSlot, Unit whichUnit returns nothing
        local integer chargesAmount = whichItem.ChargesAmount.Get()
        local integer row = thistype(NULL).User.GetRow(whichUnit.Owner.Get())
        if (chargesAmount > 0) then
            call thistype.THIS_BOARD.SetValue(row, thistype.ITEMS_COLUMN + whichSlot * 2, Integer.ToString(chargesAmount))
        endif
        call thistype.THIS_BOARD.SetIcon(row, thistype.ITEMS_COLUMN + whichSlot * 2 + 1, whichItem.Type.Get().GetIcon())
    endmethod
    static method DettachItem takes Item whichItem, integer whichSlot, Unit whichUnit returns nothing
        local integer row = thistype(NULL).User.GetRow(whichUnit.Owner.Get())
        call thistype.THIS_BOARD.SetIcon(row, thistype.ITEMS_COLUMN + whichSlot * 2 + 1, null)
        call thistype.THIS_BOARD.SetValue(row, thistype.ITEMS_COLUMN + whichSlot * 2, null)
    endmethod
    eventMethod Event_ChargesChange
        local Item whichItem = params.Item.GetTrigger()
        local Unit whichUnit = params.Unit.GetTrigger()
        call thistype.AttachItem(whichItem, whichUnit.Items.GetSlot(whichItem), whichUnit)
    endmethod
    eventMethod Event_Drop
        local Item whichItem = params.Item.GetTrigger()
        if not whichItem.Event.Contains(CHARGES_CHANGE_EVENT) then
            return
        endif
        call thistype.DettachItem(whichItem, params.Item.GetTriggerSlot(), params.Unit.GetTrigger())
        call whichItem.Event.Remove(CHARGES_CHANGE_EVENT)
    endmethod
    eventMethod Event_Move
        local Item targetItem = params.Item.GetTarget()
        local integer targetSlot = params.Item.GetTargetSlot()
        local Item whichItem = params.Item.GetTrigger()
        local integer whichSlot = params.Item.GetTriggerSlot()
        local Unit whichUnit = params.Unit.GetTrigger()
        call thistype.AttachItem(whichItem, targetSlot, whichUnit)
        if (targetItem == NULL) then
            call thistype.DettachItem(whichItem, whichSlot, whichUnit)
        else
            call thistype.AttachItem(targetItem, whichSlot, whichUnit)
        endif
    endmethod
    eventMethod Event_PickUp
        local Item whichItem = params.Item.GetTrigger()
		call whichItem.Event.Add(CHARGES_CHANGE_EVENT)
        call thistype.AttachItem(whichItem, params.Item.GetTriggerSlot(), params.Unit.GetTrigger())
    endmethod
    eventMethod Event_HeroPick
        local User whichPlayer = params.User.GetTrigger()
        local Unit whichUnit = params.Unit.GetTrigger()
        call whichUnit.Event.Add(DROP_EVENT)
        call whichUnit.Event.Add(MOVE_EVENT)
        call whichUnit.Event.Add(PICK_UP_EVENT)
        call thistype(NULL).User.Update(whichPlayer)
    endmethod
    static method GetLevelString takes nothing returns string
    	local Level curLevel = Level.CURRENT
        local string result = "Level: "
        if (curLevel == NULL) then
            return result
        endif
        if curLevel.IsBonus() then
            return result + curLevel.GetName()
        endif
        local Act curAct = Act.CURRENT
        if (curAct == NULL) then
            return result
        endif
        local integer count = 0
        local integer iteration = Memory.IntegerKeys.Table.STARTED
        loop
            exitwhen (iteration > curAct.LevelSets.Count())
            if (iteration > Memory.IntegerKeys.Table.STARTED) then
                set result = result + " | "
            endif
            local LevelSet whichSet = curAct.LevelSets.Get(iteration)
            local string whichSetString = ""
            local integer iteration2 = Memory.IntegerKeys.Table.STARTED
            loop
                exitwhen (iteration2 > whichSet.Levels.Count())
                local Level whichLevel = whichSet.Levels.Get(iteration2)
				local string add
                if SpawnWave.GetFromLevel(whichLevel).IsBoss() then
                    set add = "Boss"
                else
                    set add = Integer.ToString(count + 1)
                endif
                if (whichLevel == curLevel) then
                    set add = String.Color.Do(add, String.Color.BONUS)
                endif
                if (whichSetString == "") then
                    set whichSetString = whichSetString + add
                else
                    set whichSetString = whichSetString + " - " + add
                endif
                set count = count + 1
                set iteration2 = iteration2 + 1
            endloop
            set result = result + whichSetString
            set iteration = iteration + 1
        endloop
        return result
    endmethod
    eventMethod Event_LevelStart
        local Level whichLevel = params.Level.GetTrigger()
        call thistype.THIS_BOARD.SetValue(thistype.LEVEL_ROW, thistype.PLAYERS_COLUMN, thistype.GetLevelString())
		local integer iteration = 0
        loop
            if (whichLevel.GetIndex() <= Level.ALL_COUNT) then
                local SpawnWave whichWave = SpawnWave.GetFromLevel(whichLevel)
                if (whichWave == NULL) then
                    return
                endif
				local boolean array flags
                set flags[0] = whichWave.IsMelee()
                set flags[1] = whichWave.IsRanged()
                set flags[2] = whichWave.IsMagician()
                set flags[4] = whichWave.IsInvis()
                set flags[5] = whichWave.IsRunner()
                set flags[6] = whichWave.IsMagicImmune()
                set flags[7] = whichWave.IsKamikaze()
                set flags[8] = whichWave.IsBoss()
                if whichWave.IsBoss() then
                    call thistype.THIS_BOARD.SetIcon(thistype.CURRENT_ROUND_ROW + iteration, thistype.PLAYERS_COLUMN, thistype.QUESTION_MARK_PATH)
                elseif (whichWave.IsBoss() and (iteration == 1)) then
                    call thistype.THIS_BOARD.SetIcon(thistype.CURRENT_ROUND_ROW + iteration, thistype.PLAYERS_COLUMN, thistype.QUESTION_MARK_PATH)
                else
                    call thistype.THIS_BOARD.SetIcon(thistype.CURRENT_ROUND_ROW + iteration, thistype.PLAYERS_COLUMN, whichLevel.GetIcon())
                endif
				local integer iteration2 = 0
                loop
                    exitwhen (iteration2 > 8)
                    if flags[iteration2] then
                        call thistype.THIS_BOARD.SetIcon(thistype.CURRENT_ROUND_ROW + iteration, thistype.STATUS_COLUMN + iteration2, thistype.CHECK_PATH)
                    else
                        call thistype.THIS_BOARD.SetIcon(thistype.CURRENT_ROUND_ROW + iteration, thistype.STATUS_COLUMN + iteration2, thistype.CROSS_PATH)
                    endif
                    if (iteration2 == 2) then
                        set iteration2 = iteration2 + 2
                    else
                        set iteration2 = iteration2 + 1
                    endif
                endloop
            endif
            set iteration = iteration + 1
            set whichLevel = whichLevel.GetNext()
            exitwhen (iteration > 1)
        endloop
    endmethod
    static method GetChapterString takes nothing returns string
        local Act curAct = Act.CURRENT
        local string result = "Chapter: "
        if (curAct == NULL) then
            return result
        endif
        return result + String.Color.Do(curAct.GetName(), String.Color.BONUS)
    endmethod
    eventMethod Event_ActStart
        call thistype.THIS_BOARD.SetValue(thistype.CHAPTER_ROW, thistype.PLAYERS_COLUMN, thistype.GetChapterString())
    endmethod
    eventMethod Event_AfterIntro
        call thistype.THIS_BOARD.Show(params.User.GetTrigger())
    endmethod
    static method GetNewRow takes nothing returns integer
        return thistype.THIS_BOARD.GetNewRow()
    endmethod
    eventMethod Event_Start
        set thistype.CHARGES_CHANGE_EVENT = Event.Create(ITEM.ChargesAmount.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_ChargesChange)
        set thistype.DROP_EVENT = Event.Create(UNIT.Items.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Drop)
        set thistype.MOVE_EVENT = Event.Create(UNIT.Items.Events.MoveInInventory.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Move)
        set thistype.PICK_UP_EVENT = Event.Create(UNIT.Items.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_PickUp)
        call Event.Create(Act.START_EVENT_TYPE, EventPriority.MISC, function thistype.Event_ActStart).AddToStatics()
        call Event.Create(AfterIntro.FOR_PLAYER_EVENT_TYPE, EventPriority.MISC, function thistype.Event_AfterIntro).AddToStatics()
        call Event.Create(HeroSelection.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_HeroPick).AddToStatics()
        call Event.Create(Level.START_EVENT_TYPE, EventPriority.MISC2, function thistype.Event_LevelStart).AddToStatics()
        set thistype.THIS_BOARD = Multiboard.Create()
        local integer currentRow = thistype.GetNewRow()
        if (Meteorite.THIS_UNIT != NULL) then
            call thistype.THIS_BOARD.SetTitle(Meteorite.GetInfoboardTitle())
        endif
        set thistype.PLAYERS_COLUMN = thistype.THIS_BOARD.GetNewColumn()
        set thistype.STATUS_COLUMN = thistype.THIS_BOARD.GetNewColumn()
        set thistype.ITEMS_COLUMN = thistype.THIS_BOARD.GetNewColumn()
        call thistype.THIS_BOARD.SetValue(currentRow, thistype.PLAYERS_COLUMN, String.Color.Do("Players", String.Color.GOLD))
        call thistype.THIS_BOARD.SetWidth(currentRow, thistype.PLAYERS_COLUMN, 0.06)
        call thistype.THIS_BOARD.SetValue(currentRow, thistype.STATUS_COLUMN, String.Color.Do("Status", String.Color.GOLD))
        call thistype.THIS_BOARD.SetWidth(currentRow, thistype.STATUS_COLUMN, 0.04)
        call thistype.THIS_BOARD.SetValue(currentRow, thistype.ITEMS_COLUMN, String.Color.Do("Items in Inventory", String.Color.GOLD))
        call thistype.THIS_BOARD.SetWidth(currentRow, thistype.ITEMS_COLUMN, 0.1)
        
        set currentRow = thistype.GetNewRow()
        call thistype.THIS_BOARD.SetValue(currentRow, thistype.PLAYERS_COLUMN, "=================================================")
        call thistype.THIS_BOARD.SetWidth(currentRow, thistype.PLAYERS_COLUMN, 0.2)
        call thistype.THIS_BOARD.ColumnSpan.SetWidth(currentRow, thistype.PLAYERS_COLUMN + 1, thistype.THIS_BOARD.GetColumnCount(), 0.)
        set currentRow = thistype.GetNewRow()
		local integer iteration = 0
        loop
            exitwhen (iteration > User.HUMANS_COUNT)
            local User curPlayer = User.HUMANS[iteration]
            local PlayerSlotState curPlayerSlotState = curPlayer.SlotState.Get()
            if (curPlayerSlotState != PlayerSlotState.EMPTY) then
                local Unit curPlayerHero = curPlayer.Hero.Get()
                set currentRow = thistype.GetNewRow()
                call thistype.THIS_BOARD.SetWidth(currentRow, thistype.PLAYERS_COLUMN, 0.06)
                call thistype.THIS_BOARD.SetWidth(currentRow, thistype.STATUS_COLUMN, 0.04)
				local integer iteration2 = MAX_INVENTORY_SIZE - 1
                loop
                    call thistype.THIS_BOARD.SetWidth(currentRow, thistype.ITEMS_COLUMN + iteration2 * 2, 0.007)
                    call thistype.THIS_BOARD.SetWidth(currentRow, thistype.ITEMS_COLUMN + iteration2 * 2 + 1, 0.012)
                    set iteration2 = iteration2 - 1
                    exitwhen (iteration2 < 0)
                endloop
                
                call thistype(NULL).User.SetRow(curPlayer, currentRow)
                call thistype(NULL).User.Update(curPlayer)
				local string stringValue
                if (curPlayerSlotState == PlayerSlotState.PLAYING) then
                    set stringValue = curPlayer.GetColorString()
                else
                    set stringValue = "ff7F7F7F"
                endif
                call thistype.THIS_BOARD.SetValue(currentRow, thistype.PLAYERS_COLUMN, String.Color.Do(curPlayer.GetName(), stringValue))
            else
                call INFOBOARD.User.SetRow(curPlayer, -1)
            endif
            set iteration = iteration + 1
        endloop
        set currentRow = thistype.GetNewRow()
        call thistype.THIS_BOARD.SetWidth(currentRow, thistype.PLAYERS_COLUMN, 0.2)
        call thistype.THIS_BOARD.ColumnSpan.SetWidth(currentRow, thistype.PLAYERS_COLUMN + 1, thistype.THIS_BOARD.GetColumnCount(), 0.)
        set currentRow = thistype.GetNewRow()
        call thistype.THIS_BOARD.SetWidth(currentRow, thistype.PLAYERS_COLUMN, 0.1)
        call thistype.THIS_BOARD.SetIcon(currentRow, thistype.PLAYERS_COLUMN + 1, "ReplaceableTextures\\CommandButtons\\BTNOrcMeleeUpOne.blp")
        call thistype.THIS_BOARD.SetIcon(currentRow, thistype.PLAYERS_COLUMN + 2, "ReplaceableTextures\\CommandButtons\\BTNImprovedBows.blp")
        call thistype.THIS_BOARD.SetIcon(currentRow, thistype.PLAYERS_COLUMN + 3, "ReplaceableTextures\\CommandButtons\\BTNStaffOfNegation.blp")
        call thistype.THIS_BOARD.SetIcon(currentRow, thistype.PLAYERS_COLUMN + 5, "ReplaceableTextures\\CommandButtons\\BTNInvisibility.blp")
        call thistype.THIS_BOARD.SetIcon(currentRow, thistype.PLAYERS_COLUMN + 6, "ReplaceableTextures\\CommandButtons\\BTNBootsOfSpeed.blp")
        call thistype.THIS_BOARD.SetIcon(currentRow, thistype.PLAYERS_COLUMN + 7, "ReplaceableTextures\\CommandButtons\\BTNGenericSpellImmunity.blp")
        call thistype.THIS_BOARD.SetIcon(currentRow, thistype.PLAYERS_COLUMN + 8, "ReplaceableTextures\\CommandButtons\\BTNSelfDestruct.blp")
        call thistype.THIS_BOARD.SetIcon(currentRow, thistype.PLAYERS_COLUMN + 9, "ReplaceableTextures\\CommandButtons\\BTNReincarnation.blp")
        call thistype.THIS_BOARD.ColumnSpan.SetWidth(currentRow, thistype.PLAYERS_COLUMN + 1, thistype.PLAYERS_COLUMN + 9, 0.01)
        call thistype.THIS_BOARD.ColumnSpan.SetWidth(currentRow, thistype.PLAYERS_COLUMN + 9 + 1, thistype.THIS_BOARD.GetColumnCount(), 0.)
        set thistype.CURRENT_ROUND_ROW = thistype.GetNewRow()
        call thistype.THIS_BOARD.SetValue(thistype.CURRENT_ROUND_ROW, thistype.PLAYERS_COLUMN, "This round")
        call thistype.THIS_BOARD.SetWidth(thistype.CURRENT_ROUND_ROW, thistype.PLAYERS_COLUMN, 0.1)
        call thistype.THIS_BOARD.ColumnSpan.SetWidth(thistype.CURRENT_ROUND_ROW, thistype.PLAYERS_COLUMN + 1, thistype.PLAYERS_COLUMN + 1 + 8, 0.01)
        call thistype.THIS_BOARD.ColumnSpan.SetWidth(thistype.CURRENT_ROUND_ROW, thistype.PLAYERS_COLUMN + 1 + 8 + 1, thistype.THIS_BOARD.GetColumnCount(), 0.)
        set currentRow = thistype.GetNewRow()
        call thistype.THIS_BOARD.SetValue(currentRow, thistype.PLAYERS_COLUMN, "Next round")
        call thistype.THIS_BOARD.SetWidth(currentRow, thistype.PLAYERS_COLUMN, 0.1)
        call thistype.THIS_BOARD.ColumnSpan.SetWidth(currentRow, thistype.PLAYERS_COLUMN + 1, thistype.PLAYERS_COLUMN + 1 + 8, 0.01)
        call thistype.THIS_BOARD.ColumnSpan.SetWidth(currentRow, thistype.PLAYERS_COLUMN + 1 + 8 + 1, thistype.THIS_BOARD.GetColumnCount(), 0.)
        set currentRow = thistype.GetNewRow()
        set thistype.CHAPTER_ROW = thistype.GetNewRow()
        call thistype.THIS_BOARD.SetValue(thistype.CHAPTER_ROW, thistype.PLAYERS_COLUMN, thistype.GetChapterString())
        call thistype.THIS_BOARD.SetWidth(thistype.CHAPTER_ROW, thistype.PLAYERS_COLUMN, 0.2)
        set thistype.LEVEL_ROW = thistype.GetNewRow()
        call thistype.THIS_BOARD.SetValue(thistype.LEVEL_ROW, thistype.PLAYERS_COLUMN, thistype.GetLevelString())
        call thistype.THIS_BOARD.SetWidth(thistype.LEVEL_ROW, thistype.PLAYERS_COLUMN, 0.2)
    endmethod
    initMethod Init of Misc
        call Event.Create(EventType.START, EventPriority.MISC, function thistype.Event_Start).AddToStatics()
    endmethod
endstruct
    globals
        Infocard INFOCARD = STRUCT_BASE
    endglobals
    struct Infocard
        implement Allocation
        implement List
        
    static string INTRODUCTION_DESCRIPTION = "About month ago, two peculiarly luminescent comets draught across the sky. While one featured a blue color and immediately vanished again behind the horizont, the red one bolted right into the capital of the united species of this planet. The shock wave tore apart buildings and roads and devastated most of the town. Many lost their lives."
    static string INTRODUCTION_DESCRIPTION2 = "As if this was not enough already, the sky darkened the day after and it became bitterly cold. Only the of a strange material consisting meteorite seemed to spend some even weirder soothing warmth. Though, the sky cleared a bit within time, the cold persisted and drove us to leave this place since a reconstruction appeared impossible before we would freeze to death. We fleed to the adjacent shire of count Dracula who there possesses a big castle which is directly worked into the Crystal Mountains. We also brought the meteorite with us whose still thermal energies emitting nature easily mesmerized us."
    static string INTRODUCTION_DESCRIPTION3 = "Since that time we try to get along with the small rations here and hope that the sun will return to us someday. Yet, the problems pile up: Besides the lack of food and the ongoing frost which we call the " + Char.QUOTE + "Big Winter" + Char.QUOTE + ", the surrounding forest's inhabitants are becoming very anxious, too. The last three weeks, there were twenty attacks and break-ins by wolves and other confused animals. Most of us refugees do not dare to leave the castle anymore. And how long will the strange stone keep on giving us strength and hope?"
    quest self
    static method Create takes boolean required, string title, string description, string iconPath returns thistype
        local thistype this = thistype.allocate()
		local quest self = CreateQuest()
        set this.self = self
        call QuestSetDescription(self, description)
        call QuestSetIconPath(self, iconPath)
        call QuestSetRequired(self, required)
        call QuestSetTitle(self, title)
        return this
    endmethod
    static string CREDITS_STRING
    static method EncolorName takes string value returns string
        return String.Color.Gradient(value, String.Color.DWC, String.Color.WHITE)
    endmethod
    static method AddLine takes string value returns nothing
        set thistype.CREDITS_STRING = thistype.CREDITS_STRING + value + Char.BREAK
    endmethod
    static method GetCreditsPart1 takes nothing returns string
        set thistype.CREDITS_STRING = ""
        call thistype.AddLine(String.Color.Do("Development:", String.Color.GOLD))
        call thistype.AddLine(thistype.EncolorName("WaterKnight"))
        call thistype.AddLine("")
        call thistype.AddLine(String.Color.Do("Imports:", String.Color.GOLD))
        call thistype.AddLine("Balduir: " + thistype.EncolorName("supertoinkz"))
        call thistype.AddLine("Bgm main: " + thistype.EncolorName("Aaron Krogh"))
        call thistype.AddLine("Bleeding: " + thistype.EncolorName("cotd333"))
        call thistype.AddLine("Console: " + thistype.EncolorName("Kwaliti"))
        call thistype.AddLine("Cityscape Set: " + thistype.EncolorName("xXm0RpH3usXx"))
        call thistype.AddLine("EnchantedArrowBlueEffect: " + thistype.EncolorName("nGy"))
        call thistype.AddLine("EnchantedArrowFlash: " + thistype.EncolorName("epsilon"))
        call thistype.AddLine("EnchantedArrowSkeleton: " + thistype.EncolorName("Wrathion"))
        call thistype.AddLine("GhostSword: " + thistype.EncolorName("jatter2"))
        call thistype.AddLine("Immortality: " + thistype.EncolorName("Daelin"))
        call thistype.AddLine("KhakiRecoveryVortex: " + thistype.EncolorName("Power"))
        call thistype.AddLine("Loadscreen Background: " + thistype.EncolorName("www.dreamscene.org"))
        call thistype.AddLine("OrcAssassin: " + thistype.EncolorName("Linaze"))
        call thistype.AddLine("")
        call thistype.AddLine("Everything may be modified in order to fit the map. Rather than exporting stuff you are interested in, refer to the credits.txt enclosed in the map archive.")
        return thistype.CREDITS_STRING
    endmethod
    static method GetCreditsPart2 takes nothing returns string
        set thistype.CREDITS_STRING = ""
        call thistype.AddLine(String.Color.Do("Imports:", String.Color.GOLD))
        call thistype.AddLine("Preview: " + thistype.EncolorName("www.albabackgrounds.com"))
        call thistype.AddLine("SakeBombBarrel: " + thistype.EncolorName("Dojo"))
        call thistype.AddLine("SakeBombMissile: " + thistype.EncolorName("RetroSexual"))
        call thistype.AddLine("SnowPine: " + thistype.EncolorName("Gottfrei"))
        call thistype.AddLine("SpearScout: " + thistype.EncolorName("Dojo"))
        call thistype.AddLine("TaintedLeafHeal: " + thistype.EncolorName("WILL_THE_ALMIGHTY"))
        call thistype.AddLine("Tarog: " + thistype.EncolorName("Dojo"))
        call thistype.AddLine("ThunderstrikeBolt: " + thistype.EncolorName("Tranquil"))
        call thistype.AddLine("ThunderstrikeCharge: " + thistype.EncolorName("marcus158"))
        call thistype.AddLine("ThunderstrikeNova: " + thistype.EncolorName("dhguardianes"))
        call thistype.AddLine("Tower: " + thistype.EncolorName("unknownczar"))
        call thistype.AddLine("VictorHammer: " + thistype.EncolorName("Thrikodius"))
        call thistype.AddLine("VioletEarringMissile: " + thistype.EncolorName("EdwardSwolenToe"))
        call thistype.AddLine("VioletEarringWeaponAttach: " + thistype.EncolorName("marcus158"))
        call thistype.AddLine("Wall: " + thistype.EncolorName("Rondo"))
        call thistype.AddLine("WallEnd: " + thistype.EncolorName("Rondo"))
        call thistype.AddLine("")
        call thistype.AddLine("Everything may be modified in order to fit the map. Rather than exporting stuff you are interested in, refer to the credits.txt enclosed in the map archive.")
        return thistype.CREDITS_STRING
    endmethod
    initMethod Init of Misc
        call thistype.Create(false, "Commands", CharacterSpeech.INPUT + " + any string: character speech" + Char.BREAK, "ReplaceableTextures\\CommandButtons\\BTNCommand.blp")
        call thistype.Create(false, "Credits Part 1", thistype.GetCreditsPart1(), "ReplaceableTextures\\CommandButtons\\BTNStormEarth&Fire.blp")
        call thistype.Create(false, "Credits Part 2", thistype.GetCreditsPart2(), "ReplaceableTextures\\CommandButtons\\BTNStormEarth&Fire.blp")
        call thistype.Create(true, "Introduction", thistype.INTRODUCTION_DESCRIPTION + Char.BREAK + thistype.INTRODUCTION_DESCRIPTION2 + Char.BREAK + thistype.INTRODUCTION_DESCRIPTION3, "ReplaceableTextures\\CommandButtons\\BTNPenguin.blp")
        call thistype.Create(true, "Objective", "Defend the meteorite at all costs!", "ReplaceableTextures\\CommandButtons\\BTNArcaneObservatory.blp")
        call thistype.Create(false, "Mechanics: Dying", "When you die, your hero is transformed into a ghost and teleported to the graveyard. There, you will regenerate mana to a maximum of 100 that you can then use to execute your ascension. You can freely move your spirit around but mana is only refreshed while staying at the graveyard. However, it might be useful to leave the area after being filled up to gain a better spot for reviving. The meteorite also has a spell to replenish mana that even works on ghosts.", "ReplaceableTextures\\CommandButtons\\BTNSacrifice.blp")
        call thistype.Create(false, "Mechanics: Meteorite", "Failing at protecting the meteorite above the center of the castle will result in your team's defeat." + Char.BREAK + "The highest player spot does have control of the meteorite and can thereby make use of it to cast some valuable spells.", "ReplaceableTextures\\CommandButtons\\BTNUndeadShrine.blp")
        call thistype.Create(false, "Mechanics: Flowers of Hope", "There is one sleeping seed in front of each of the castle's entries. A gentle touch wakes them up, granting you their sight, which detects even invisible entities and increases the loot you gain from killing foes. The flower will revert to its dormant mode after " + Real.ToIntString(Snowmen.DURATION) + " seconds.", "ReplaceableTextures\\CommandButtons\\BTNNatureTouchGrow.blp")
        call thistype.Create(false, "Mechanics: Special spawns' attributes", "The infoboard in the upper right corner of your screen shows, among other things, whether the current or next round's attacker spawns are of special behavior/have special abilities. These are, from left to right:" + Char.BREAK + "Melee: wave contains melee attackers" + Char.BREAK + "Ranged: wave contains ranged attackers" + Char.BREAK + "Magician: wave contains casters with magical abilities (this does not include physical abilities)" + Char.BREAK + Char.BREAK + "Runner: wave contains spawns that avoid aggressions and instead of this directly storm to the meteorite, they get easily dazed when being attacked from behind" + Char.BREAK + "Invis: wave contains invisible units" + Char.BREAK + "Magic immune: wave contains enemies that are immune to magical abilities" + Char.BREAK + "Kamikaze: wave contains suicidal spawns that detonate themselves to get rid of you!" + Char.BREAK + "Boss: boss wave, every sixth (last) wave of an chapter", "ReplaceableTextures\\CommandButtons\\BTNDarkSummoning.blp")
        call thistype.Create(false, "Mechanics: Spell purchase", "Your hero can only learn four characteristic spells plus the innate ability but further magical item scrolls can be purchased from the " + Library.SHOP.GetName() + ". In contrast to other charged items, one scroll's ability is displayed in the unit's command card (can be switched by pressing the item buttons) and these skills can be leveled up like other hero abilities.", "ReplaceableTextures\\CommandButtons\\BTNBansheeAdept.blp")
        call FlashQuestDialogButton()
    endmethod
endstruct
    globals
        Intro INTRO = STRUCT_BASE
    endglobals
    struct Intro
        implement Allocation
        implement List
        
    static Destructable BARREL_DESTRUCTABLE
    static string BRAZIER_SOUND_PATH = "Sound\\Ambient\\DoodadEffects\\LordaeronSummerBrazierLoop1.wav"
    static Camera CAM
    static Camera CAM2
    static Camera CAM3
    static Camera CAM4
    static Camera CAM5
    static Camera CAM6
    static Camera CAM7
    static Camera CAM8
    static Camera CAM9
    static Camera CAM10
    static Camera CAM11
    static Trigger CINE_ABORT_TRIGGER
    static Timer CINE_TIMER
    static constant real DURATION = 300.
    static Rectangle DRAKUL_RECT
    static Rectangle SMOKEALOT_RECT
    static Rectangle ROCKETEYE_RECT
    static Rectangle ARURUW_RECT
    static Rectangle STORMY_RECT
    static Rectangle STORMY2_RECT
    static Rectangle LIZZY_RECT
    static Rectangle LIZZY2_RECT
    static Rectangle LIZZY3_RECT
    static Rectangle TAJRAN_RECT
    static Rectangle TAJRAN2_RECT
    static DummyUnit DRAKUL_UNIT
    static DummyUnit SMOKEALOT_UNIT
    static DummyUnit ROCKETEYE_UNIT
    static DummyUnit ARURUW_UNIT
    static DummyUnit STORMY_UNIT
    static DummyUnit LIZZY_UNIT
    static DummyUnit LIZZY2_UNIT
    static DummyUnit LIZZY3_UNIT
    static DummyUnit TAJRAN_UNIT
    static Rectangle LIGHT_RECT
    static Rectangle LIGHT2_RECT
    static Sound LIGHT_SOUND
    static Sound LIGHT2_SOUND
    static DummyUnit LIGHT_UNIT
    static DummyUnit LIGHT2_UNIT
    static constant integer TORCH_UNIT_ID = 'h008'
    static method SetFaceToDestructable takes DummyUnit whichUnit, Destructable whichTarget returns nothing
        call whichUnit.Facing.SetToDestructable(whichTarget)
    endmethod
    static method SetFaceToUnit takes DummyUnit whichUnit, DummyUnit whichTarget returns nothing
        call whichUnit.Facing.SetToOtherDummyUnit(whichTarget)
    endmethod
    static method SetUnitAtRect takes DummyUnit whichUnit, Rectangle whichRect returns nothing
        call whichUnit.Position.X.Set(whichRect.GetCenterX())
        call whichUnit.Position.Y.Set(whichRect.GetCenterY())
    endmethod
    static method CreateUnitAtRect takes integer unitId, Rectangle whichRect, real whichAngle returns DummyUnit
        local real whichRectX = whichRect.GetCenterX()
        local real whichRectY = whichRect.GetCenterY()
        local DummyUnit newUnit = DummyUnit.Create(unitId, whichRectX, whichRectY, 0., whichAngle)
        call newUnit.PlayerColor.Set(PLAYER_COLOR_BROWN)
        return newUnit
    endmethod
    static method CreateUnitAtRectFaceUnit takes integer unitId, Rectangle whichRect, DummyUnit whichUnit returns DummyUnit
        local real whichRectX = whichRect.GetCenterX()
        local real whichRectY = whichRect.GetCenterY()
        local real whichAngle = Math.AtanByDeltas(whichUnit.Position.Y.Get() - whichRectY, whichUnit.Position.X.Get() - whichRectX)
        local DummyUnit newUnit = DummyUnit.Create(unitId, whichRectX, whichRectY, 0., whichAngle)
        call newUnit.PlayerColor.Set(PLAYER_COLOR_BROWN)
        return newUnit
    endmethod
    static method OrderUnitToRect takes DummyUnit whichUnit, Rectangle whichRect returns nothing
        call whichUnit.Order.PointTarget(Order.MOVE, whichRect.GetCenterX(), whichRect.GetCenterY())
    endmethod
    static method Wait takes real duration, code func returns nothing
        call thistype.CINE_TIMER.Start(duration, false, func)
    endmethod
    static method ApplyCam takes Camera whichCam, real duration returns nothing
        call whichCam.Apply(true, duration)
    endmethod
    static method ApplyCamWait takes Camera whichCam, real duration, code func returns nothing
        call whichCam.Apply(true, duration)
        call thistype.CINE_TIMER.Start(duration, false, func)
    endmethod
    static method SetTransmission takes DummyUnit whichUnit, string text, real duration, code func returns nothing
        call whichUnit.Flash(127, 127, 127, 63)
        call Cinematic.SetScene(whichUnit.GetTypeId(), PLAYER_COLOR_BROWN, whichUnit.GetProperName(), text, duration, duration * 0.8)
        call thistype.CINE_TIMER.Start(duration, false, func)
    endmethod
    static method FadeWait takes integer red, integer green, integer blue, integer alpha, real duration, code func returns nothing
        local CineFilter newFilter = CineFilter.Create()
        call newFilter.SetColorEnd(red, green, blue, 255)
        call newFilter.SetColorStart(255, 255, 255, 0)
        call newFilter.SetTexture("ReplaceableTextures\\CameraMasks\\White_mask.blp")
        call newFilter.Start(duration, User.ANY)
        call thistype.CINE_TIMER.Start(duration, false, func)
    endmethod
    timerMethod Ending
        call Cinematic.EndScene()
        call Game.DisplayInterface(User.ANY, true, 1.)
        call Game.EnableControl(User.ANY, true)
        call thistype.CINE_ABORT_TRIGGER.Destroy()
        call thistype.LIGHT_SOUND.Destroy(false)
        call thistype.LIGHT2_SOUND.Destroy(false)
        call thistype.DRAKUL_UNIT.DestroyInstantly()
        call thistype.SMOKEALOT_UNIT.DestroyInstantly()
        call thistype.ROCKETEYE_UNIT.DestroyInstantly()
        call thistype.ARURUW_UNIT.DestroyInstantly()
        call thistype.STORMY_UNIT.DestroyInstantly()
        if (thistype.LIZZY_UNIT != NULL) then
            call thistype.LIZZY_UNIT.DestroyInstantly()
        endif
        if (thistype.TAJRAN_UNIT != NULL) then
            call thistype.TAJRAN_UNIT.DestroyInstantly()
        endif
        call Camera.Reset(User.ANY, 0.)
        call AfterIntro.Start()
        call thistype.CINE_TIMER.Start(1., false, function Difficulty.Start)
    endmethod
    timerMethod Step27
        call thistype.Wait(3., function thistype.Ending)
    endmethod
    timerMethod Step26
        call thistype.ApplyCam(thistype.CAM11, 5.)
        call thistype.FadeWait(0, 0, 0, 0, 4., function thistype.Step27)
    endmethod
    timerMethod Step25
        call thistype.SetTransmission(thistype.DRAKUL_UNIT, "Wintercastle should be a place for all that are in need of help. In these difficult times, we have to stick together, and as I am looking here, there seem to be already all kind of peoples. So break up your disputes and let's take it on at last...", 12., function thistype.Step26)
    endmethod
    timerMethod Step24b
        call thistype.SetTransmission(thistype.SMOKEALOT_UNIT, "I have to agree with lady Aruruw in this matter.", 3., function thistype.Step25)
    endmethod
    timerMethod Step24
        call thistype.SetTransmission(thistype.ARURUW_UNIT, "We shouldn't trust him, Milord. He could be a spy just as well. And even if he speaks the truth, he will still just cause trouble for us with his presence. I am aware of the Orcs' nature and their determination to wipe out every traitor.", 10., function thistype.Step24b)
    endmethod
    timerMethod Step23c
        call thistype.SetTransmission(thistype.TAJRAN_UNIT, "Furthermore, my clan yearns to kill me. Hence, I would like to ask for refuge. As a reward, I promise you to help in every matter, until my legs won't carry me any longer.", 9., function thistype.Step24)
    endmethod
    timerMethod Step23b
        call SetFaceToUnit(thistype.TAJRAN_UNIT, thistype.DRAKUL_UNIT)
        call thistype.SetTransmission(thistype.TAJRAN_UNIT, "Yes, I belong to the Orcish race, but was I expelled of my own tribe, when I hesistated to executed one of our enemies and escaped. You see, I was one of their shamans, not a fighter and never approved the violent methods of my fellows. Alone, I won't be able to last for long in this world of ice out there.", 13.5, function thistype.Step23c)
    endmethod
    timerMethod Step23
        call SetFaceToUnit(thistype.TAJRAN_UNIT, thistype.ROCKETEYE_UNIT)
        call thistype.SetTransmission(thistype.TAJRAN_UNIT, "Listen to my words, please!", 3., function thistype.Step23b)
    endmethod
    timerMethod Step22d
        call thistype.SetTransmission(thistype.SMOKEALOT_UNIT, "We should really start deploying some guard posts.", 4., function thistype.Step23)
    endmethod
    timerMethod Step22c
        call SetFaceToUnit(thistype.ROCKETEYE_UNIT, thistype.TAJRAN_UNIT)
        call thistype.SetTransmission(thistype.ROCKETEYE_UNIT, "Hey, you are one of these vandals!", 3., function thistype.Step22d)
    endmethod
    timerMethod Step22b
        call thistype.SetTransmission(thistype.TAJRAN_UNIT, "Excuse me for my rude intrusion...", 3.5, function thistype.Step22c)
    endmethod
    timerMethod Step22
        set thistype.TAJRAN_UNIT = CreateUnitAtRect('O000', thistype.TAJRAN_RECT, Math.EAST_ANGLE)
        call OrderUnitToRect(thistype.TAJRAN_UNIT, thistype.TAJRAN2_RECT)
        call thistype.Wait(2., function thistype.Step22b)
    endmethod
    timerMethod Step21b
        call thistype.SetTransmission(thistype.DRAKUL_UNIT, "With that said, we are complete. I myself will participate as well. The caravans, which will traverse the forest under the protection of our efforts, are already standing by.", 8., function thistype.Step22)
    endmethod
    timerMethod Step21
        call SetUnitAtRect(thistype.STORMY_UNIT, thistype.STORMY_RECT)
        call SetUnitAtRect(thistype.LIZZY_UNIT, thistype.LIZZY3_RECT)
        call SetFaceToUnit(thistype.ROCKETEYE_UNIT, thistype.DRAKUL_UNIT)
        call SetFaceToUnit(thistype.SMOKEALOT_UNIT, thistype.DRAKUL_UNIT)
        call SetFaceToUnit(thistype.ARURUW_UNIT, thistype.DRAKUL_UNIT)
        call SetFaceToUnit(thistype.STORMY_UNIT, thistype.DRAKUL_UNIT)
        call thistype.DRAKUL_UNIT.Facing.Set(Math.WEST_ANGLE)
        call thistype.ApplyCam(thistype.CAM10, 0.)
        call thistype.Wait(1., function thistype.Step21b)
    endmethod
    timerMethod Step20
        call thistype.SetTransmission(thistype.ROCKETEYE_UNIT, "Another gal. The group is already to my liking.", 3., function thistype.Step21)
    endmethod
    timerMethod Step19b
        call thistype.SetTransmission(thistype.SMOKEALOT_UNIT, "This is LIZZY, a fairy from the Mid East. She was the sole survivor, I rescued, when her homeland was destroyed by the elves. Back then, she decided to accompany me. I am confident she will complement us well with her magical abilities.", 13., function thistype.Step20)
    endmethod
    timerMethod Step19
        call SetFaceToUnit(thistype.STORMY_UNIT, thistype.LIZZY_UNIT)
        call thistype.SetTransmission(thistype.STORMY_UNIT, "And you are? *hic*", 2.5, function thistype.Step19b)
    endmethod
    timerMethod Step18b
        call thistype.SetTransmission(thistype.LIZZY_UNIT, "*hihi* What a primitive blubberbutt!", 3., function thistype.Step19)
    endmethod
    timerMethod Step18
        call thistype.LIZZY_UNIT.Destroy()
        set thistype.LIZZY_UNIT = CreateUnitAtRect('H007', thistype.LIZZY_RECT, Math.SOUTH_ANGLE)
        call OrderUnitToRect(thistype.LIZZY_UNIT, thistype.LIZZY2_RECT)
        call thistype.ApplyCamWait(thistype.CAM9, 2., function thistype.Step18b)
    endmethod
    timerMethod Step17c
        call STORMY_UNIT.Animation.SetByIndex(6)
        call STORMY_UNIT.Animation.Queue(Animation.STAND)
        call thistype.SetTransmission(thistype.STORMY_UNIT, "What the?! Where are these wretches that mess up my beer?! I thwack them until they decide to become meat eaters!", 5.5, function thistype.Step18)
    endmethod
    timerMethod Step17b
        call thistype.Wait(1., function thistype.Step17c)
    endmethod
    timerMethod Step17
        call thistype.SetTransmission(thistype.SMOKEALOT_UNIT, "When the animals are to steal all of the corn from the silos, there won't be any alcohol for you too soon!", 5., function thistype.Step17b)
    endmethod
    timerMethod Step16f
        call thistype.SetTransmission(thistype.STORMY_UNIT, "Eh?", 1., function thistype.Step17)
    endmethod
    timerMethod Step16e
        call thistype.SetTransmission(thistype.SMOKEALOT_UNIT, "We are in perilous situation right now, we should keep a clear mind.", 3.5, function thistype.Step16f)
    endmethod
    timerMethod Step16d
        call SetFaceToUnit(thistype.STORMY_UNIT, thistype.DRAKUL_UNIT)
        call thistype.SetTransmission(thistype.STORMY_UNIT, "What?", 1., function thistype.Step16e)
    endmethod
    timerMethod Step16c
        call thistype.SetTransmission(thistype.DRAKUL_UNIT, "Stormy, now, it isn't the right time to bemuse yourself with this dazing mixture!", 4., function thistype.Step16d)
    endmethod
    timerMethod Step16b
        call thistype.Wait(1, function thistype.Step16c)
    endmethod
    timerMethod Step16
        call SetFaceToUnit(thistype.DRAKUL_UNIT, thistype.STORMY_UNIT)
        call SetFaceToUnit(thistype.ROCKETEYE_UNIT, thistype.STORMY_UNIT)
        call SetFaceToUnit(thistype.SMOKEALOT_UNIT, thistype.STORMY_UNIT)
        call SetFaceToUnit(thistype.ARURUW_UNIT, thistype.STORMY_UNIT)
        call thistype.ApplyCamWait(thistype.CAM10, 2.5, function thistype.Step16b)
    endmethod
    timerMethod Step15
        call thistype.SetTransmission(thistype.STORMY_UNIT, "*hic*", 1.5, function thistype.Step16)
    endmethod
    timerMethod Step14e
        call thistype.SetTransmission(thistype.ARURUW_UNIT, "...he stood right next to me just a moment ago.", 3., function thistype.Step15)
    endmethod
    timerMethod Step14d
        call thistype.SetTransmission(thistype.ARURUW_UNIT, "...", 0.75, function thistype.Step14e)
    endmethod
    timerMethod Step14c
        call thistype.SetTransmission(thistype.ARURUW_UNIT, "..", 0.75, function thistype.Step14d)
    endmethod
    timerMethod Step14b
        call thistype.SetTransmission(thistype.ARURUW_UNIT, ".", 0.75, function thistype.Step14c)
    endmethod
    timerMethod Step14
        call thistype.ApplyCam(thistype.CAM7, 0.)
        call thistype.Wait(1., function thistype.Step14b)
    endmethod
    timerMethod Step13c
        call thistype.SetTransmission(thistype.DRAKUL_UNIT, "Where did he disappear to again?!", 2., function thistype.Step14)
    endmethod
    timerMethod Step13b
        call SetUnitAtRect(thistype.STORMY_UNIT, thistype.STORMY2_RECT)
        call SetFaceToDestructable(thistype.STORMY_UNIT, thistype.BARREL_DESTRUCTABLE)
        set thistype.LIZZY_UNIT = CreateUnitAtRect('h009', thistype.STORMY_RECT, Math.SOUTH_ANGLE)
        call thistype.SetTransmission(thistype.DRAKUL_UNIT, "Then, there's Stor...", 3., function thistype.Step13c)
    endmethod
    timerMethod Step13
        call thistype.ApplyCamWait(thistype.CAM, 0.5, function thistype.Step13b)
    endmethod
    timerMethod Step12b
        call SetFaceToUnit(thistype.ROCKETEYE_UNIT, thistype.DRAKUL_UNIT)
        call thistype.Wait(0.5, function thistype.Step13)
    endmethod
    timerMethod Step12
        call thistype.SetTransmission(thistype.ROCKETEYE_UNIT, "Woo, I am impressed, young lad'.", 3., function thistype.Step12b)
    endmethod
    timerMethod Step11c
        call thistype.ApplyCam(thistype.CAM6, 2.)
        call thistype.SetTransmission(thistype.ARURUW_UNIT, "While approaching your castle I noticed a lot of incensed animals, on the south pass in particular. The " + String.Color.Do("Great Winter", String.Color.GOLD) + " hit them pretty well, too, and turned them into raging creatures.", 9.5, function thistype.Step12)
    endmethod
    timerMethod Step11b
        call SetFaceToUnit(thistype.ARURUW_UNIT, thistype.DRAKUL_UNIT)
        call thistype.Wait(1., function thistype.Step11c)
    endmethod
    timerMethod Step11
        call thistype.SetTransmission(thistype.DRAKUL_UNIT, "I received information about lady Aruruw, about her excellent skills as a huntress. This might be to our advantage on this task.", 9., function thistype.Step11b)
    endmethod
    timerMethod Step10c
        call thistype.SetTransmission(thistype.ARURUW_UNIT, "Do you aim to challenge me?", 4., function thistype.Step11)
    endmethod
    timerMethod Step10b
        call thistype.ApplyCamWait(thistype.CAM4, 1., function thistype.Step10c)
    endmethod
    timerMethod Step10
        call thistype.Wait(1., function thistype.Step10b)
    endmethod
    timerMethod Step9
        call SetFaceToUnit(thistype.ARURUW_UNIT, thistype.ROCKETEYE_UNIT)
        call thistype.ApplyCamWait(thistype.CAM5, 1., function thistype.Step10)
    endmethod
    timerMethod Step8
        call SetFaceToUnit(thistype.ROCKETEYE_UNIT, thistype.ARURUW_UNIT)
        call thistype.SetTransmission(thistype.ROCKETEYE_UNIT, "This shorty can fight?", 2.5, function thistype.Step9)
    endmethod
    timerMethod Step7b
        call thistype.SetTransmission(thistype.DRAKUL_UNIT, "Lady Aruruw", 3., function thistype.Step8)
    endmethod
    timerMethod Step7
        call thistype.SMOKEALOT_UNIT.Animation.Set(Animation.STAND_READY)
        call thistype.SetTransmission(thistype.SMOKEALOT_UNIT, "At your service *kindles a cigarette*", 3., function thistype.Step7b)
    endmethod
    timerMethod Step6
        call thistype.ApplyCam(CAM3, 0.5)
        call thistype.SetTransmission(thistype.DRAKUL_UNIT, "Sir Smokealot", 2., function thistype.Step7)
    endmethod
    timerMethod Step5
        call thistype.SetTransmission(thistype.ROCKETEYE_UNIT, "Aye", 1.5, function thistype.Step6)
    endmethod
    timerMethod Step4
        call thistype.ApplyCamWait(thistype.CAM2, 0.5, function thistype.Step5)
    endmethod
    timerMethod Step3
        call thistype.SetTransmission(thistype.DRAKUL_UNIT, "Rocketeye", 1., function thistype.Step4)
    endmethod
    timerMethod Step2
        call thistype.DRAKUL_UNIT.Animation.Set(Animation.SPELL_SLAM)
        call thistype.DRAKUL_UNIT.Animation.Queue(Animation.STAND)
        call thistype.SetTransmission(DRAKUL_UNIT, "Meanwhile, wild animals of the bordering woods have begun to exploit our storages and to attack the residents. This is the reason I called for the four of you.", 7., function thistype.Step3)
    endmethod
    trigMethod AbortTrig
        local integer iteration = ARRAY_MIN
        local User whichPlayer = USER.Event.Native.GetTrigger()
        local integer whichPlayerIndex = whichPlayer.GetIndex()
        call AfterIntro.StartForPlayer(whichPlayer)
        loop
            exitwhen (User.ALL[iteration].SlotState.Get() == PlayerSlotState.PLAYING)
            set iteration = iteration + 1
        endloop
        if (whichPlayerIndex == iteration) then
            call thistype.Ending()
        endif
    endmethod
    eventMethod Event_Start
        call Timer.Create().Start(0., false, function AfterIntro.Start)
        call Timer.Create().Start(1., false, function Difficulty.Start)
        return
        set thistype.BARREL_DESTRUCTABLE = Destructable.CreateFromSelf(gg_dest_C005_0080)
        set thistype.CAM = Camera.CreateFromSelf(gg_cam_Introduction)
        set thistype.CAM2 = Camera.CreateFromSelf(gg_cam_Introduction2)
        set thistype.CAM3 = Camera.CreateFromSelf(gg_cam_Introduction3)
        set thistype.CAM4 = Camera.CreateFromSelf(gg_cam_Introduction4)
        set thistype.CAM5 = Camera.CreateFromSelf(gg_cam_Introduction5)
        set thistype.CAM6 = Camera.CreateFromSelf(gg_cam_Introduction6)
        set thistype.CAM7 = Camera.CreateFromSelf(gg_cam_Introduction7)
        set thistype.CAM8 = Camera.CreateFromSelf(gg_cam_Introduction8)
        set thistype.CAM9 = Camera.CreateFromSelf(gg_cam_Introduction9)
        set thistype.CAM10 = Camera.CreateFromSelf(gg_cam_Introduction10)
        set thistype.CAM11 = Camera.CreateFromSelf(gg_cam_Introduction11)
        set thistype.CINE_ABORT_TRIGGER = Trigger.CreateFromCode(function thistype.AbortTrig)
        set thistype.CINE_TIMER = Timer.Create()
        set thistype.DRAKUL_RECT = Rectangle.CreateFromSelf(gg_rct_Introduction_Drakul)
        set thistype.SMOKEALOT_RECT = Rectangle.CreateFromSelf(gg_rct_Introduction_Smokealot)
        set thistype.ROCKETEYE_RECT = Rectangle.CreateFromSelf(gg_rct_Introduction_Rocketeye)
        set thistype.ARURUW_RECT = Rectangle.CreateFromSelf(gg_rct_Introduction_Aruruw)
        set thistype.STORMY_RECT = Rectangle.CreateFromSelf(gg_rct_Introduction_Stormy)
        set thistype.STORMY2_RECT = Rectangle.CreateFromSelf(gg_rct_Introduction_Stormy2)
        set thistype.LIZZY_RECT = Rectangle.CreateFromSelf(gg_rct_Introduction_Lizzy)
        set thistype.LIZZY2_RECT = Rectangle.CreateFromSelf(gg_rct_Introduction_Lizzy2)
        set thistype.LIZZY3_RECT = Rectangle.CreateFromSelf(gg_rct_Introduction_Lizzy3)
        set thistype.TAJRAN_RECT = Rectangle.CreateFromSelf(gg_rct_Introduction_Tajran)
        set thistype.TAJRAN2_RECT = Rectangle.CreateFromSelf(gg_rct_Introduction_Tajran2)
        set thistype.LIGHT_RECT = Rectangle.CreateFromSelf(gg_rct_Introduction_Light)
        set thistype.LIGHT2_RECT = Rectangle.CreateFromSelf(gg_rct_Introduction_Light2)
        set thistype.DRAKUL_UNIT = CreateUnitAtRect(UnitType.DRAKUL.self, thistype.DRAKUL_RECT, Math.NORTH_ANGLE)
        set thistype.ROCKETEYE_UNIT = CreateUnitAtRectFaceUnit(UnitType.ROCKETEYE.self, thistype.ROCKETEYE_RECT, thistype.DRAKUL_UNIT)
        set thistype.SMOKEALOT_UNIT = CreateUnitAtRectFaceUnit(UnitType.SMOKEALOT.self, thistype.SMOKEALOT_RECT, thistype.DRAKUL_UNIT)
        set thistype.ARURUW_UNIT = CreateUnitAtRectFaceUnit(UnitType.ARURUW.self, thistype.ARURUW_RECT, thistype.DRAKUL_UNIT)
        set thistype.STORMY_UNIT = CreateUnitAtRectFaceUnit(UnitType.STORMY.self, thistype.STORMY_RECT, thistype.DRAKUL_UNIT)
        set thistype.LIZZY_UNIT = NULL
        set thistype.TAJRAN_UNIT = NULL
        set thistype.LIGHT_UNIT = CreateUnitAtRect(thistype.TORCH_UNIT_ID, thistype.LIGHT_RECT, Math.SOUTH_ANGLE)
        set thistype.LIGHT2_UNIT = CreateUnitAtRect(thistype.TORCH_UNIT_ID, thistype.LIGHT2_RECT, Math.SOUTH_ANGLE)
        set thistype.LIGHT_SOUND = Sound.Create(thistype.BRAZIER_SOUND_PATH, true, false, false, 0, 0, SoundEax.DOODAD)
        set thistype.LIGHT2_SOUND = Sound.Create(thistype.BRAZIER_SOUND_PATH, true, false, false, 0, 0, SoundEax.DOODAD)
        call Game.DisplayInterface(User.ANY, false, 1)
        call Game.EnableControl(User.ANY, false)
        call thistype.ApplyCam(Camera.CreateFromSelf(gg_cam_Introduction), 0)
        call thistype.LIGHT_SOUND.Play()
        call thistype.LIGHT2_SOUND.Play()
        call thistype.DRAKUL_UNIT.Animation.Set(UNIT.Animation.SPELL_SLAM)
        call thistype.CINE_ABORT_TRIGGER.RegisterEvent.User(User.ANY, EVENT_PLAYER_END_CINEMATIC)
        call thistype.SetTransmission(DRAKUL_UNIT, "It's about one month now that you searched for shelter in my domicile Wintercastle. Our supply reserves are at a scant stock, so we have to send out caravans in order to retrieve left-behind goods from the surrounding villages.", 11, function thistype.Step2)
        
        call thistype.DRAKUL_UNIT.Animation.Queue(UNIT.Animation.STAND)
        call Visibility.AddRect(User.ANY, Rectangle.CreateFromSelf(gg_rct_Introduction))
    endmethod
    initMethod Init of Misc
        call Event.Create(EventType.START, EventPriority.MISC, function thistype.Event_Start).AddToStatics()
    endmethod
endstruct
    scope FolderLevelSet
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return LevelSet(this).Data.table.IntegerKeys.Table.ContainsInteger(LevelSet(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return LevelSet(this).Data.table.IntegerKeys.Table.CountIntegers(LevelSet(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return LevelSet(this).Data.table.IntegerKeys.Table.IsEmptyInteger(LevelSet(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return LevelSet(this).Data.table.IntegerKeys.Table.GetInteger(LevelSet(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return LevelSet(this).Data.table.IntegerKeys.Table.GetFirstInteger(LevelSet(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return LevelSet(this).Data.table.IntegerKeys.Table.GetLastInteger(LevelSet(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call LevelSet(this).Data.table.IntegerKeys.Table.Clear(LevelSet(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return LevelSet(this).Data.table.IntegerKeys.Table.FetchFirstInteger(LevelSet(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return LevelSet(this).Data.table.IntegerKeys.Table.RemoveInteger(LevelSet(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return LevelSet(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(LevelSet(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return LevelSet(this).Data.table.IntegerKeys.Table.AddInteger(LevelSet(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return LevelSet(this).Data.table.IntegerKeys.Table.AddIntegerMulti(LevelSet(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call LevelSet(this).Data.table.IntegerKeys.Table.JoinInteger(LevelSet(this).Id.Get(), key, LevelSet(other).Data.table, LevelSet(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return LevelSet(this).Data.table.IntegerKeys.Table.RandomInteger(LevelSet(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call LevelSet(this).Data.table.IntegerKeys.Table.ShuffleIntegers(LevelSet(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call LevelSet(this).Data.table.IntegerKeys.Table.PrintIntegers(LevelSet(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return LevelSet(this).Data.table.IntegerKeys.GetInteger(LevelSet(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call LevelSet(this).Data.table.IntegerKeys.RemoveInteger(LevelSet(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call LevelSet(this).Data.table.IntegerKeys.SetInteger(LevelSet(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(LevelSet(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject LevelSet.Allocation.deallocate_demount.hook
		call LevelSet(this).Data.Destroy()
	endinject
	inject LevelSet.Allocation.allocate_mount.hook
		call LevelSet(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructLevels
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        method Count takes nothing returns integer
            return LevelSet(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns Level
            return LevelSet(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method GetLast takes nothing returns Level
            return LevelSet(this).Data.Integer.Table.GetLast(KEY_ARRAY)
        endmethod
        method Add takes Level val returns nothing
            call LevelSet(this).Data.Integer.Table.Add(KEY_ARRAY, val)
        endmethod
        method Shuffle takes nothing returns nothing
            call LevelSet(this).Data.Integer.Table.Shuffle(KEY_ARRAY)
        endmethod
    endstruct
    public struct StructQuery
        implement Allocation
        implement List
        
        static Event CHAT_EVENT
        static Event HOST_CHANGE_EVENT
        static constant string INPUT = "-rdy"
        static boolean ACTIVE = false
        static GameMessage MSG
        static LevelSet PARENT
        static method Ending takes nothing returns nothing
            if not thistype.ACTIVE then
                return
            endif
            set thistype.ACTIVE = false
            call thistype.MSG.Destroy()
            call StringData.Event.Remove(thistype.INPUT, thistype.CHAT_EVENT)
            call thistype.HOST_CHANGE_EVENT.RemoveFromStatics()
        endmethod
        eventMethod Event_Chat
            if (params.User.GetTrigger() != User.HOST) then
                return
            endif
            call thistype.Ending()
            call thistype.PARENT.Start()
        endmethod
        eventMethod Event_HostChange
            call thistype.MSG.Destroy()
            set thistype.MSG = GameMessage.Create(User.HOST.GetColoredName() + " type \"-rdy\" in order to start " + thistype.PARENT.GetName(), User.ANY)
        endmethod
        method Start takes nothing returns nothing
            if ACTIVE then
                call thistype.Ending()
            endif
            set thistype.ACTIVE = true
            set thistype.MSG = GameMessage.Create(User.HOST.GetColoredName() + " type \"-rdy\" in order to start " + LevelSet(this).GetName(), User.ANY)
            set thistype.PARENT = this
            call StringData.Event.Add(thistype.INPUT, thistype.CHAT_EVENT)
            call thistype.HOST_CHANGE_EVENT.AddToStatics()
        endmethod
        static method Init takes nothing returns nothing
            set thistype.CHAT_EVENT = Event.Create(User.CHAT_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Chat)
            set thistype.HOST_CHANGE_EVENT = Event.Create(USER.HostAppointment.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_HostChange)
        endmethod
    endstruct
endscope
    globals
        LevelSet LEVEL_SET = STRUCT_BASE
    endglobals
    struct LevelSet
        implement Allocation
        implement List
        
    static thistype ACT1_PART1
    static thistype ACT1_PART2
    static thistype ACT1_PART3
    static thistype ACT1_BOSS_PART
    static thistype ACT2_PART1
    static thistype ACT2_PART2
    static thistype ACT2_PART3
    static thistype ACT2_BOSS_PART
    static thistype BONUS_ACT_PART1
    static thistype CURRENT = NULL
    FolderLevelSet_StructData Data = this
    FolderLevelSet_StructData LinkToStruct_Data
    FolderLevelSet_StructId Id = this
    FolderLevelSet_StructId LinkToStruct_Id
    FolderLevelSet_StructLevels Levels = this
    FolderLevelSet_StructLevels LinkToStruct_Levels
    FolderLevelSet_StructQuery Query = this
    FolderLevelSet_StructQuery LinkToStruct_Query
    string name
    method GetName takes nothing returns string
        return this.name
    endmethod
    method SetName takes string value returns nothing
        set this.name = value
    endmethod
    thistype next
    method GetNext takes nothing returns thistype
        return this.next
    endmethod
    method SetNext takes thistype value returns nothing
        set this.next = value
    endmethod
    method Ending takes nothing returns nothing
        if (this == NULL) then
            return
        endif
        set thistype.CURRENT = NULL
        call thistype(NULL).Query.Ending()
        if (Level.CURRENT != NULL) then
            call Level.CURRENT.Ending()
        endif
    endmethod
    method Start takes nothing returns nothing
        if (thistype.CURRENT != NULL) then
            call thistype.CURRENT.Ending()
        endif
        set thistype.CURRENT = this
        call this.Levels.Get(Memory.IntegerKeys.Table.STARTED).Start()
    endmethod
    static method QueryNext takes nothing returns nothing
        local thistype this = thistype.CURRENT
        if (this == NULL) then
            return
        endif
        call this.Ending()
        set this = this.GetNext()
        if (this == NULL) then
            call Act.StartNext()
        else
            call this.Query.Start()
        endif
    endmethod
    eventMethod Event_GameOver
        call thistype(NULL).Query.Ending()
    endmethod
    eventMethod Event_LevelEnding
        local Level whichLevel = params.Level.GetTrigger()
        local thistype this = thistype.CURRENT
        if (whichLevel == this.Levels.Get(this.Levels.Count())) then
            call this.QueryNext()
        else
            call whichLevel.GetNext().Start()
        endif
    endmethod
    eventMethod Event_ActStart
        if (thistype.CURRENT != NULL) then
            call thistype.CURRENT.Ending()
        endif
        call params.Act.GetTrigger().LevelSets.Get(Memory.IntegerKeys.Table.STARTED).Query.Start()
    endmethod
    static method Create takes string name, thistype prev returns thistype
        local thistype this = thistype.allocate()
        call this.Id.Event_Create()
        call this.SetName(name)
        call this.SetNext(NULL)
        call prev.SetNext(this)
        return this
    endmethod
    static method AddLevels takes nothing returns nothing
        call thistype.ACT1_PART1.Levels.Add(Level.DEERS)
        call thistype.ACT1_PART1.Levels.Add(Level.TROLLS)
        call thistype.ACT1_PART1.Levels.Add(Level.GNOLLS)
        call thistype.ACT1_PART1.Levels.Shuffle()
        call thistype.ACT1_PART2.Levels.Add(Level.WOLVES)
        call thistype.ACT1_PART2.Levels.Add(Level.MOONKINS)
        call thistype.ACT1_PART2.Levels.Add(Level.SNOW_FALCONS)
        call thistype.ACT1_PART2.Levels.Shuffle()
        call thistype.ACT1_PART3.Levels.Add(Level.KOBOLDS)
        call thistype.ACT1_PART3.Levels.Add(Level.TREANTS)
        call thistype.ACT1_PART3.Levels.Shuffle()
        call thistype.ACT1_BOSS_PART.Levels.Add(Level.FURBOLG_ORACLE)
        call thistype.ACT2_PART1.Levels.Add(Level.SCOUTS)
        call thistype.ACT2_PART1.Levels.Add(Level.AXE_FIGHTERS)
        call thistype.ACT2_PART1.Levels.Add(Level.RAIDERS)
        call thistype.ACT1_PART1.Levels.Shuffle()
        call thistype.ACT2_PART2.Levels.Add(Level.CATAPULTS)
        call thistype.ACT2_PART2.Levels.Add(Level.ASSASSINS)
        call thistype.ACT1_PART2.Levels.Shuffle()
        call thistype.ACT2_BOSS_PART.Levels.Add(Level.LEADER)
        call thistype.BONUS_ACT_PART1.Levels.Add(Level.PENGUINS)
    endmethod
    static method InitObjs takes nothing returns nothing
        set thistype.ACT1_PART1 = thistype.Create("Act 1 - Part 1", NULL)
        set thistype.ACT1_PART2 = thistype.Create("Act 1 - Part 2", thistype.ACT1_PART1)
        set thistype.ACT1_PART3 = thistype.Create("Act 1 - Part 3", thistype.ACT1_PART2)
        set thistype.ACT1_BOSS_PART = thistype.Create("Act 1 - Boss", thistype.ACT1_PART3)
        set thistype.ACT2_PART1 = thistype.Create("Act 2 - Part 1", NULL)
        set thistype.ACT2_PART2 = thistype.Create("Act 2 - Part 2", thistype.ACT2_PART1)
        set thistype.ACT2_PART3 = thistype.Create("Act 2 - Part 3", thistype.ACT2_PART2)
        set thistype.ACT2_BOSS_PART = thistype.Create("Act 2 - Boss", thistype.ACT2_PART3)
        set thistype.BONUS_ACT_PART1 = thistype.Create("Bonus", NULL)
        call thistype.AddLevels()
    endmethod
    static method Init takes nothing returns nothing
        call Event.Create(Level.ENDING_EVENT_TYPE, EventPriority.MISC, function thistype.Event_LevelEnding).AddToStatics()
        call Event.Create(Meteorite.GAME_OVER_EVENT_TYPE, EventPriority.MISC, function thistype.Event_GameOver).AddToStatics()
        call thistype.InitObjs()
        call thistype(NULL).Query.Init()
    endmethod
endstruct
    scope FolderLevel
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return Level(this).Data.table.IntegerKeys.Table.ContainsInteger(Level(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Level(this).Data.table.IntegerKeys.Table.CountIntegers(Level(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Level(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Level(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Level(this).Data.table.IntegerKeys.Table.GetInteger(Level(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Level(this).Data.table.IntegerKeys.Table.GetFirstInteger(Level(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Level(this).Data.table.IntegerKeys.Table.GetLastInteger(Level(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Level(this).Data.table.IntegerKeys.Table.Clear(Level(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Level(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Level(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Level(this).Data.table.IntegerKeys.Table.RemoveInteger(Level(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Level(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Level(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Level(this).Data.table.IntegerKeys.Table.AddInteger(Level(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Level(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Level(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Level(this).Data.table.IntegerKeys.Table.JoinInteger(Level(this).Id.Get(), key, Level(other).Data.table, Level(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Level(this).Data.table.IntegerKeys.Table.RandomInteger(Level(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Level(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Level(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Level(this).Data.table.IntegerKeys.Table.PrintIntegers(Level(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return Level(this).Data.table.IntegerKeys.GetInteger(Level(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Level(this).Data.table.IntegerKeys.RemoveInteger(Level(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Level(this).Data.table.IntegerKeys.SetInteger(Level(this).Id.Get(), key, value)
    endmethod
        endstruct
    public struct StructReal
        implement Allocation
        implement List
        
    method Get takes integer key returns real
        return Level(this).Data.table.IntegerKeys.GetReal(Level(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Real.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Level(this).Data.table.IntegerKeys.RemoveReal(Level(this).Id.Get(), key)
    endmethod
    method Set takes integer key, real value returns nothing
        call Level(this).Data.table.IntegerKeys.SetReal(Level(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
    FolderData_StructReal Real = this
    FolderData_StructReal LinkToStruct_Real
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Level(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Level.Allocation.deallocate_demount.hook
		call Level(this).Data.Destroy()
	endinject
	inject Level.Allocation.allocate_mount.hook
		call Level(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructEvent
        implement Allocation
        implement List
        
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(Level(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(Level(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(Level(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(Level(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(Level(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(Level(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(Level(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(Level(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject Level.Allocation.deallocate_demount.hook
			call Level(this).Event.Destroy()
		endinject
		inject Level.Allocation.allocate_mount.hook
			call Level(this).Event.Event_Create()
		endinject
    endstruct
endscope
    globals
        Level LEVEL = STRUCT_BASE
    endglobals
    struct Level
        implement Allocation
        implement List
        
    static integer BONUS_INDEX
    static integer CLASSIC_ENDING_INDEX
    static EventType ENDING_EVENT_TYPE
    static key GetKeyMacro_PARENT_KEY
    static constant integer PARENT_KEY = Math.Integer.MIN + GetKeyMacro_PARENT_KEY
    static EventType START_EVENT_TYPE
    static thistype ASSASSINS
    static thistype AXE_FIGHTERS
    static thistype CATAPULTS
    static thistype DEERS
    static thistype FURBOLG_ORACLE
    static thistype GNOLLS
    static thistype KOBOLDS
    static thistype LEADER
    static thistype MOONKINS
    static thistype PENGUINS
    static thistype RAIDERS
    static thistype SCOUTS
    static thistype SNOW_FALCONS
    static thistype TREANTS
    static thistype TROLLS
    static thistype WOLVES
	static thistype CURRENT = NULL
    FolderLevel_StructData Data = this
    FolderLevel_StructData LinkToStruct_Data
    FolderLevel_StructEvent Event = this
    FolderLevel_StructEvent LinkToStruct_Event
    FolderLevel_StructId Id = this
    FolderLevel_StructId LinkToStruct_Id
    Act act
    method GetAct takes nothing returns Act
        return this.act
    endmethod
    method SetAct takes Act value returns nothing
        set this.act = value
    endmethod
	//! inject Allocation.allocate_mount.hook
		set this.act = NULL
	//! endinject
    integer actIndex
    method GetActIndex takes nothing returns integer
        return this.actIndex
    endmethod
    method SetActIndex takes integer value returns nothing
        set this.actIndex = value
    endmethod
	//! inject Allocation.allocate_mount.hook
		set this.actIndex = DataTable(NULL).IntegerKeys.Table.EMPTY
	//! endinject
    boolean bonus
    method IsBonus takes nothing returns boolean
        return this.bonus
    endmethod
    method SetBonus takes boolean value returns nothing
        set this.bonus = value
    endmethod
    string bonusCaption
    method GetBonusCaption takes nothing returns string
        return this.bonusCaption
    endmethod
    method SetBonusCaption takes string value returns nothing
        set this.bonusCaption = value
    endmethod
	//! inject Allocation.allocate_mount.hook
		set this.bonusCaption = null
	//! endinject
    string icon
    method GetIcon takes nothing returns string
        return this.icon
    endmethod
    method SetIcon takes string value returns nothing
        set this.icon = value
    endmethod
	//! inject Allocation.allocate_mount.hook
		set this.icon = null
	//! endinject
    LevelSet whichSet
    method GetLevelSet takes nothing returns LevelSet
        return this.whichSet
    endmethod
    method SetLevelSet takes LevelSet value returns nothing
        set this.whichSet = value
    endmethod
    string name
    method GetName takes nothing returns string
        return this.name
    endmethod
    method SetName takes string value returns nothing
        set this.name = value
    endmethod
    thistype next
    method GetNext takes nothing returns thistype
        return this.next
    endmethod
    method SetNext takes thistype value returns nothing
        set this.next = value
    endmethod
	//! inject Allocation.allocate_mount.hook
		set this.next = NULL
	//! endinject
    static method InitNexts takes nothing returns nothing
        local integer iteration = ARRAY_MIN
        loop
            exitwhen (iteration > Act.ALL_COUNT)
            local thistype last = NULL
            local Act whichAct = Act.ALL[iteration]
            local integer iteration2 = whichAct.LevelSets.Count()
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                local LevelSet whichSet = whichAct.LevelSets.Get(iteration2)
                local integer iteration3 = whichSet.Levels.Count()
                loop
                    exitwhen (iteration3 < Memory.IntegerKeys.Table.STARTED)
                    local thistype this = whichSet.Levels.Get(iteration3)
                    call this.SetLevelSet(whichSet)
                    call this.SetNext(last)
                    set last = this
                    set iteration3 = iteration3 - 1
                endloop
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration + 1
        endloop
    endmethod
    method Ending_TriggerEvents takes nothing returns nothing
        local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
        call params.Level.SetTrigger(this)
		local EventResponse levelParams = EventResponse.Create(this.Id.Get())
        call levelParams.Level.SetTrigger(this)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = Event.CountAtStatics(thistype.ENDING_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call Event.GetFromStatics(thistype.ENDING_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration2 = this.Event.Count(thistype.ENDING_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.ENDING_EVENT_TYPE, priority, iteration2).Run(levelParams)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call levelParams.Destroy()
        call params.Destroy()
    endmethod
    method Ending takes nothing returns nothing
        set thistype.CURRENT = NULL
        call this.Ending_TriggerEvents()
    endmethod
    method Start_TriggerEvents takes nothing returns nothing
        local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
        
        call params.Level.SetTrigger(this)
        local EventResponse levelParams = EventResponse.Create(this.Id.Get())
        call levelParams.Level.SetTrigger(this)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = Event.CountAtStatics(thistype.START_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call Event.GetFromStatics(thistype.START_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration2 = this.Event.Count(thistype.START_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call this.Event.Get(thistype.START_EVENT_TYPE, priority, iteration2).Run(levelParams)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call levelParams.Destroy()
        call params.Destroy()
    endmethod
    method Start takes nothing returns nothing
        if (thistype.CURRENT != NULL) then
            call thistype.CURRENT.Ending()
        endif
        set thistype.CURRENT = this
        if (this.GetNext() == NULL) then
            call Game.DisplayTextTimed(User.ANY, "New level begins: " + String.Color.Do(this.GetName(), String.Color.GOLD), 15.)
        else
            call Game.DisplayTextTimed(User.ANY, "New level begins: " + String.Color.Do(this.GetName(), String.Color.GOLD) + ", next is " + String.Color.Do(this.GetNext().GetName(), String.Color.GOLD), 15.)
        endif
        call this.Start_TriggerEvents()
    endmethod
    static method Create takes string name returns thistype
        local thistype this = thistype.allocate()
        call this.SetIcon(icon)
        call this.SetLevelSet(NULL)
        call this.SetName(name)
        call this.SetNext(NULL)
        call this.AddToList()
        call this.Id.Event_Create()
        return this
    endmethod
    static method Init_Penguins takes nothing returns nothing
        local thistype this = thistype.Create("Penguins")
        set thistype.PENGUINS = this
        call this.SetBonus(true)
        call this.SetBonusCaption("1")
    endmethod
    static method Init_Leader takes nothing returns nothing
        local thistype this = thistype.Create("Leader")
        set thistype.LEADER = this
        call this.SetIcon("ReplaceableTextures\\CommandButtons\\BTNChaosWarlord.blp")
    endmethod
    static method Init_Assassins takes nothing returns nothing
        local thistype this = thistype.Create("Assassins")
        set thistype.ASSASSINS = this
        call this.SetIcon("ReplaceableTextures\\CommandButtons\\BTNHellScream.blp")
    endmethod
    static method Init_Catapults takes nothing returns nothing
        local thistype this = thistype.Create("Catapults")
        set thistype.CATAPULTS = this
        call this.SetIcon("ReplaceableTextures\\CommandButtons\\BTNCatapult.blp")
    endmethod
    static method Init_Raiders takes nothing returns nothing
        local thistype this = thistype.Create("Raiders")
        set thistype.RAIDERS = this
        call this.SetIcon("ReplaceableTextures\\CommandButtons\\BTNRaider.blp")
    endmethod
    static method Init_AxeFighters takes nothing returns nothing
        local thistype this = thistype.Create("Axe Fighters")
        set thistype.AXE_FIGHTERS = this
        call this.SetIcon("ReplaceableTextures\\CommandButtons\\BTNGrunt.blp")
    endmethod
    static method Init_Scouts takes nothing returns nothing
        local thistype this = thistype.Create("Scouts")
        set thistype.SCOUTS = this
        call this.SetIcon("ReplaceableTextures\\CommandButtons\\BTNWyvernRider.blp")
    endmethod
    static method Init_FurbolgOracle takes nothing returns nothing
        local thistype this = thistype.Create("Furbolg Oracle")
        set thistype.FURBOLG_ORACLE = this
        call this.SetIcon("ReplaceableTextures\\CommandButtons\\BTNFurbolgTracker.blp")
    endmethod
    static method Init_Treants takes nothing returns nothing
        local thistype this = thistype.Create("Treants")
        set thistype.TREANTS = this
        call this.SetIcon("ReplaceableTextures\\CommandButtons\\BTNCorruptedEnt.blp")
    endmethod
    static method Init_Kobolds takes nothing returns nothing
        local thistype this = thistype.Create("Kobolds")
        set thistype.KOBOLDS = this
        call this.SetIcon("ReplaceableTextures\\CommandButtons\\BTNKobold.blp")
    endmethod
    static method Init_SnowFalcons takes nothing returns nothing
        local thistype this = thistype.Create("SnowFalcons")
        set thistype.SNOW_FALCONS = this
        call this.SetIcon("ReplaceableTextures\\CommandButtons\\BTNWarEagle.blp")
    endmethod
    static method Init_Moonkins takes nothing returns nothing
        local thistype this = thistype.Create("Moonkins")
        set thistype.MOONKINS = this
        call this.SetIcon("ReplaceableTextures\\CommandButtons\\BTNOwlBear.blp")
    endmethod
    static method Init_Wolves takes nothing returns nothing
        local thistype this = thistype.Create("Wolves")
        set thistype.WOLVES = this
        call this.SetIcon("ReplaceableTextures\\CommandButtons\\BTNTimberWolf.blp")
    endmethod
    static method Init_Gnolls takes nothing returns nothing
        local thistype this = thistype.Create("Gnolls")
        set thistype.GNOLLS = this
        call this.SetIcon("ReplaceableTextures\\CommandButtons\\BTNGnollWarden.blp")
    endmethod
    static method Init_Trolls takes nothing returns nothing
        local thistype this = thistype.Create("Trolls")
        set thistype.TROLLS = this
        call this.SetIcon("ReplaceableTextures\\CommandButtons\\BTNIceTroll.blp")
    endmethod
    static method Init_Deers takes nothing returns nothing
        local thistype this = thistype.Create("Deers")
        set thistype.DEERS = this
        call this.SetIcon("ReplaceableTextures\\CommandButtons\\BTNStag.blp")
    endmethod
    static method InitObjs takes nothing returns nothing
        call thistype.Init_Deers()
        call thistype.Init_Trolls()
        call thistype.Init_Gnolls()
        call thistype.Init_Wolves()
        call thistype.Init_Moonkins()
        call thistype.Init_SnowFalcons()
        call thistype.Init_Kobolds()
        call thistype.Init_Treants()
        call thistype.Init_FurbolgOracle()
        call thistype.Init_Scouts()
        call thistype.Init_AxeFighters()
        call thistype.Init_Raiders()
        call thistype.Init_Catapults()
        call thistype.Init_Assassins()
        call thistype.Init_Leader()
        set thistype.CLASSIC_ENDING_INDEX = thistype.ALL_COUNT
        call thistype.Init_Penguins()
        set thistype.BONUS_INDEX = thistype.ALL_COUNT
    endmethod
    initMethod Init of Misc_Level
        set thistype.ENDING_EVENT_TYPE = EventType.Create()
        set thistype.START_EVENT_TYPE = EventType.Create()
        
        call thistype.InitObjs()
        call LevelSet.Init()
    endmethod
endstruct
    globals
        Library LIBRARY = STRUCT_BASE
    endglobals
    struct Library
        implement Allocation
        implement List
        
    eventMethod Event_Create
        call params.Unit.GetTrigger().Color.Set(PLAYER_COLOR_LIGHT_BLUE)
    endmethod
    initMethod Init of Misc
        call thistype.SHOP.Event.Add(Event.Create(Unit.CREATE_EVENT_TYPE, EventPriority.UNIT_TYPES, function thistype.Event_Create))
    endmethod
endstruct
    globals
        Lumber LUMBER = STRUCT_BASE
    endglobals
    struct Lumber
        implement Allocation
        implement List
        
    static constant integer AMOUNT = 15
    static constant real DELAY = 30.
    static constant real EFFECT_TIME = 5.
    static Event DESTROY_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    DummyUnit dummyUnit
    Timer delayTimer
    Timer effectTimer
    DummyUnit pad
    SpotEffect restoreEffect
    SpotEffect staticEffect
    real x
    real y
    eventMethod Event_ItemUse
        local Sound dummySound = Sound.CreateFromType(thistype.DUMMY_SOUND)
        local Item thisItem = params.Item.GetTrigger()
        local Unit whichUnit = params.Unit.GetTrigger()
        local real x = thisItem.Position.GetX()
        local real y = thisItem.Position.GetY()
        local real z = thisItem.Position.GetZ()
		local thistype this = thisItem
        call dummySound.SetPositionAndPlay(x, y, z)
        call TEXT_TAG.CreateJumping.Create(String.Color.Do(Char.PLUS + Integer.ToString(thistype.AMOUNT), String.Color.LUMBER), 1.15 * TextTag.STANDARD_SIZE, x, y, z, TextTag.GetFreeId())
        call dummySound.Destroy(true)
		local integer iteration = User.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            call User.ALL[iteration].State.Add(PLAYER_STATE_RESOURCE_LUMBER, thistype.AMOUNT)
            set iteration = iteration - 1
        endloop
    endmethod
    timerMethod Restore
        local thistype this = Timer.GetExpired().GetData()
        local Item thisItem = Item.Create(thistype.THIS_ITEM_TYPE, this.x, this.y)
        call this.restoreEffect.Destroy()
        call thisItem.Data.Integer.Set(KEY, this)
        call thisItem.Event.Add(DESTROY_EVENT)
    endmethod
    static method CreateRestoreEffect takes nothing returns nothing
        local thistype this = Timer.GetExpired().GetData()
        set this.restoreEffect = SpotEffect.Create(this.x, this.y, "Abilities\\Spells\\Human\\slow\\slowtarget.mdl", EffectLevel.LOW)
    endmethod
    method Start takes nothing returns nothing
        call this.delayTimer.Start(thistype.DELAY, false, function thistype.Restore)
        call this.effectTimer.Start(thistype.DELAY - thistype.EFFECT_TIME, false, function thistype.CreateRestoreEffect)
    endmethod
    eventMethod Event_Destroy
        local Item thisItem = params.Item.GetTrigger()
        local thistype this = thisItem.Data.Integer.Get(KEY)
        call thisItem.Data.Integer.Remove(KEY)
        call thisItem.Event.Remove(DESTROY_EVENT)
        call this.Start()
    endmethod
    static method Create takes Destructable source, Rectangle target returns thistype
        local real x = target.GetCenterX()
        local real y = target.GetCenterY()
    	local thistype this = thistype.allocate()
        local Timer delayTimer = Timer.Create()
        local DummyUnit dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, source.GetX(), source.GetY(), source.GetZ(), Math.SOUTH_ANGLE)
        local Timer effectTimer = Timer.Create()
        set this.delayTimer = delayTimer
        set this.effectTimer = effectTimer
        set this.dummyUnit = dummyUnit
        set this.pad = DummyUnit.Create(thistype.PAD_UNIT_ID, x, y, Spot.GetHeight(x, y), Math.SOUTH_ANGLE)
        set this.staticEffect = Spot.CreateEffect(x, y, "buildings\\other\\CircleOfPower\\CircleOfPower.mdl", EffectLevel.LOW)
        set this.x = x
        set this.y = y
        call delayTimer.SetData(this)
        call effectTimer.SetData(this)
        call dummyUnit.Animation.SetByIndex(3)
        call dummyUnit.Scale.Set(2.)
        call this.Start()
        return this
    endmethod
    eventMethod Event_Start
        call thistype.Create(Destructable.GetFromSelf(gg_dest_C00H_1704), Rectangle.CreateFromSelf(gg_rct_Lumber))
        call thistype.Create(Destructable.GetFromSelf(gg_dest_C00H_1725), Rectangle.CreateFromSelf(gg_rct_Lumber2))
        call thistype.Create(Destructable.GetFromSelf(gg_dest_C00H_1724), Rectangle.CreateFromSelf(gg_rct_Lumber3))
        call thistype.Create(Destructable.GetFromSelf(gg_dest_C00H_1726), Rectangle.CreateFromSelf(gg_rct_Lumber4))
        call thistype.Create(Destructable.GetFromSelf(gg_dest_C00H_0188), Rectangle.CreateFromSelf(gg_rct_Lumber5))
        call thistype.Create(Destructable.GetFromSelf(gg_dest_C00H_1731), Rectangle.CreateFromSelf(gg_rct_Lumber6))
        call thistype.Create(Destructable.GetFromSelf(gg_dest_C00H_1732), Rectangle.CreateFromSelf(gg_rct_Lumber7))
        call thistype.Create(Destructable.GetFromSelf(gg_dest_C00H_1734), Rectangle.CreateFromSelf(gg_rct_Lumber8))
        call thistype.Create(Destructable.GetFromSelf(gg_dest_C00H_1733), Rectangle.CreateFromSelf(gg_rct_Lumber9))
        call thistype.Create(Destructable.GetFromSelf(gg_dest_C00H_1730), Rectangle.CreateFromSelf(gg_rct_Lumber10))
        call thistype.Create(Destructable.GetFromSelf(gg_dest_C00H_1727), Rectangle.CreateFromSelf(gg_rct_Lumber11))
        call thistype.Create(Destructable.GetFromSelf(gg_dest_C00H_1729), Rectangle.CreateFromSelf(gg_rct_Lumber12))
        call thistype.Create(Destructable.GetFromSelf(gg_dest_C00H_1728), Rectangle.CreateFromSelf(gg_rct_Lumber13))
    endmethod
    initMethod Init of Misc
        set thistype.DESTROY_EVENT = Event.Create(Item.DESTROY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Destroy)
        call Event.Create(EventType.START, EventPriority.MISC, function thistype.Event_Start).AddToStatics()
        call thistype.THIS_ITEM_TYPE.Event.Add(Event.Create(UNIT.Items.Events.Use.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_ItemUse))
    endmethod
endstruct
    scope FolderNullboard
    public struct StructQuestLog
        implement Allocation
        implement List
        
        static quest DUMMY_QUEST
        static string DUMMY_STRING
        static constant integer MAX_LINES = 100
    static thistype QUEUED_LAST = NULL
    static thistype QUEUED_NEXT = NULL
    thistype QUEUED_next
    thistype QUEUED_prev
    static method QUEUED_IsEmpty takes nothing returns boolean
        return (thistype.QUEUED_NEXT == NULL)
    endmethod
    static method QUEUED_Contains takes thistype this returns boolean
        if (thistype.QUEUED_NEXT == this) then
            return true
        endif
        if ((this.QUEUED_prev != NULL) or (this.QUEUED_next != NULL)) then
            return true
        endif
        return false
    endmethod
    static method QUEUED_Count takes nothing returns integer
        local integer iteration = ARRAY_EMPTY
        local thistype this = thistype.QUEUED_NEXT
        loop
            exitwhen (this == NULL)
            set this = this.QUEUED_next
            set iteration = iteration + 1
        endloop
        return iteration
    endmethod
    static method QUEUED_Amount takes nothing returns integer
        return (thistype.QUEUED_Count() - ARRAY_EMPTY)
    endmethod
    static method QUEUED_GetIndex takes thistype this returns integer
        local integer iteration
        if (thistype.QUEUED_Contains(this) == false) then
            return ARRAY_EMPTY
        endif
        set iteration = ARRAY_MIN
        loop
            set this = this.QUEUED_prev
            exitwhen (this == NULL)
            set iteration = iteration + 1
        endloop
        return iteration
    endmethod
    static method QUEUED_GetFirst takes nothing returns thistype
        return thistype.QUEUED_NEXT
    endmethod
    static method QUEUED_GetLast takes nothing returns thistype
        return thistype.QUEUED_LAST
    endmethod
    static method QUEUED_GetNext takes thistype this returns thistype
        return this.QUEUED_next
    endmethod
    static method QUEUED_GetPrev takes thistype this returns thistype
        return this.QUEUED_prev
    endmethod
    static method QUEUED_FetchFirst takes nothing returns thistype
        local thistype this = thistype.QUEUED_NEXT
        if (this == NULL) then
            return NULL
        endif
        set thistype.QUEUED_NEXT = this.QUEUED_next
        set this.QUEUED_next = NULL
        if (thistype.QUEUED_NEXT == NULL) then
            set thistype.QUEUED_LAST = NULL
        else
            set thistype.QUEUED_NEXT.QUEUED_prev = NULL
        endif
        return this
    endmethod
    static method QUEUED_Remove takes thistype this returns boolean
        local thistype next
        local thistype prev
        if (thistype.QUEUED_Contains(this) == false) then
            return false
        endif
        if (thistype.QUEUED_NEXT == this) then
            call thistype.QUEUED_FetchFirst()
            return thistype.QUEUED_IsEmpty()
        endif
        set next = this.QUEUED_next
        set prev = this.QUEUED_prev
        if (prev != NULL) then
            set this.QUEUED_prev = NULL
            set prev.QUEUED_next = next
        endif
        if (next == NULL) then
            set thistype.QUEUED_LAST = prev
        else
            set this.QUEUED_next = NULL
            set next.QUEUED_prev = prev
        endif
        return thistype.QUEUED_IsEmpty()
    endmethod
    static method QUEUED_Add takes thistype this returns boolean
        if thistype.QUEUED_Contains(this) then
            return false
        endif
        set this.QUEUED_next = NULL
        if (thistype.QUEUED_NEXT == NULL) then
            set thistype.QUEUED_LAST = this
            set thistype.QUEUED_NEXT = this
            return true
        endif
        set this.QUEUED_prev = thistype.QUEUED_LAST
        set thistype.QUEUED_LAST.QUEUED_next = this
        set thistype.QUEUED_LAST = this
        return false
    endmethod
        string text
        method Destroy takes nothing returns nothing
            call this.deallocate()
        endmethod
        static method Create takes string text returns nothing
            local thistype this = thistype.allocate()
            if (thistype.QUEUED_Count() >= thistype.MAX_LINES) then
                call thistype.QUEUED_FetchFirst().Destroy()
            endif
            set this.text = text
            call thistype.QUEUED_Add(this)
            set thistype.DUMMY_STRING = text
            loop
                set this = thistype.QUEUED_GetPrev(this)
                exitwhen (this == NULL)
                set thistype.DUMMY_STRING = thistype.DUMMY_STRING + Char.BREAK + this.text
            endloop
            call QuestSetDescription(thistype.DUMMY_QUEST, thistype.DUMMY_STRING)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DUMMY_QUEST = CreateQuest()
            call QuestSetIconPath(thistype.DUMMY_QUEST, "ReplaceableTextures\\CommandButtons\\BTNPeon.blp")
            call QuestSetTitle(thistype.DUMMY_QUEST, "DebugLog")
        endmethod
    endstruct
endscope
    globals
        Nullboard NULLBOARD = STRUCT_BASE
    endglobals
    struct Nullboard
        implement Allocation
        implement List
        
    static constant real UPDATE_TIME = 0.5
    static Timer UPDATE_TIMER
    static integer LABEL_COLUMN
    static integer VALUE_COLUMN
    static integer CALLED_TRIGGERS_ROW
    static integer CALLED_TRIGGERS_PER_SECOND_ROW
    static integer OBJS_ROW
    static integer NATIVE_OBJS_ROW
    static Multiboard THIS_BOARD
	static integer TICK
    FolderNullboard_StructQuestLog QuestLog = this
    FolderNullboard_StructQuestLog LinkToStruct_QuestLog
    static method GetNewRow takes nothing returns integer
        return thistype.THIS_BOARD.GetNewRow()
    endmethod
    timerMethod Update
        set thistype.TICK = thistype.TICK + 1
        call thistype.THIS_BOARD.SetValue(thistype.CALLED_TRIGGERS_ROW, thistype.VALUE_COLUMN, Integer.ToString(Trigger.RUN_COUNT))
        call thistype.THIS_BOARD.SetValue(thistype.CALLED_TRIGGERS_PER_SECOND_ROW, thistype.VALUE_COLUMN, Real.ToIntString(Trigger.RUN_COUNT / (thistype.TICK / (1 / thistype.UPDATE_TIME))))
        call thistype.THIS_BOARD.SetValue(thistype.OBJS_ROW, thistype.VALUE_COLUMN, Integer.ToString(Basic.ALLOCATED_OBJS_COUNT))
        call thistype.THIS_BOARD.SetValue(thistype.NATIVE_OBJS_ROW, thistype.VALUE_COLUMN, Integer.ToString(Basic.NATIVE_OBJS_COUNT))
    endmethod
    eventMethod Event_AfterIntro
        call thistype.THIS_BOARD.Show(params.User.GetTrigger())
        call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
    endmethod
    static boolean LOG_INITED = false
    static string array LOG_LINES
    static constant integer LOG_LINES_MAX = 8
    static integer array LOG_ROWS
    static method WriteLogLine takes string val returns nothing
        set thistype.LOG_LINES[ARRAY_MIN + thistype.LOG_LINES_MAX] = val
		local integer iteration = 0
        loop
            exitwhen (iteration > thistype.LOG_LINES_MAX - 1)
            local integer index = ARRAY_MIN + iteration
            set thistype.LOG_LINES[index] = thistype.LOG_LINES[index + 1]
            call thistype.THIS_BOARD.SetValue(thistype.LOG_ROWS[index], thistype.VALUE_COLUMN, thistype.LOG_LINES[index])
            set iteration = iteration + 1
        endloop
        call thistype(NULL).QuestLog.Create(val)
    endmethod
    static method InitLog takes nothing returns nothing
        local integer newRow = thistype.GetNewRow()
        set newRow = thistype.GetNewRow()
        call thistype.THIS_BOARD.SetValue(newRow, thistype.LABEL_COLUMN, String.Color.Gradient("Log:", String.Color.WHITE, String.Color.DWC))
        call thistype.THIS_BOARD.SetWidth(newRow, thistype.LABEL_COLUMN, 0.2)
		local integer iteration = 0
        loop
            exitwhen (iteration > thistype.LOG_LINES_MAX - 1)
            local integer index = ARRAY_MIN + iteration
            set thistype.LOG_LINES[index] = ""
            set newRow = thistype.GetNewRow()
            call thistype.THIS_BOARD.SetWidth(newRow, thistype.LABEL_COLUMN, 0.000001)
            call thistype.THIS_BOARD.SetWidth(newRow, thistype.VALUE_COLUMN, 0.199999)
            set thistype.LOG_ROWS[index] = newRow
            set iteration = iteration + 1
        endloop
        set thistype.LOG_INITED = true
    endmethod
    initMethod Init of Misc_2
        set thistype.THIS_BOARD = Multiboard.Create()
        set thistype.UPDATE_TIMER = Timer.Create()
        call Event.Create(AfterIntro.FOR_PLAYER_EVENT_TYPE, EventPriority.MISC, function thistype.Event_AfterIntro).AddToStatics()
        call thistype.THIS_BOARD.SetTitle("Nullboard")
        set thistype.LABEL_COLUMN = thistype.THIS_BOARD.GetNewColumn()
        set thistype.VALUE_COLUMN = thistype.THIS_BOARD.GetNewColumn()
        set thistype.CALLED_TRIGGERS_ROW = thistype.GetNewRow()
        set thistype.CALLED_TRIGGERS_PER_SECOND_ROW = thistype.GetNewRow()
        set thistype.OBJS_ROW = thistype.GetNewRow()
        set thistype.NATIVE_OBJS_ROW = thistype.GetNewRow()
        call thistype.THIS_BOARD.SetValue(thistype.CALLED_TRIGGERS_ROW, thistype.LABEL_COLUMN, String.Color.Gradient("Called triggers:", String.Color.WHITE, String.Color.DWC))
        call thistype.THIS_BOARD.SetValue(thistype.CALLED_TRIGGERS_PER_SECOND_ROW, thistype.LABEL_COLUMN, String.Color.Gradient("Per second:", String.Color.WHITE, String.Color.DWC))
        call thistype.THIS_BOARD.SetValue(thistype.OBJS_ROW, thistype.LABEL_COLUMN, String.Color.Gradient("Objs count:", String.Color.WHITE, String.Color.DWC))
        call thistype.THIS_BOARD.SetValue(thistype.NATIVE_OBJS_ROW, thistype.LABEL_COLUMN, String.Color.Gradient("Native objs count:", String.Color.WHITE, String.Color.DWC))
        call thistype.THIS_BOARD.Column.SetWidth(thistype.LABEL_COLUMN, 0.1)
        call thistype.THIS_BOARD.Column.SetWidth(thistype.VALUE_COLUMN, 0.1)
        call thistype.InitLog()
        call thistype(NULL).QuestLog.Init()
		set thistype.TICK = 0
    endmethod
endstruct
    scope FolderOptionsBoard
    public struct StructCameraSmoothing
        implement Allocation
        implement List
        
        static integer ROW
        static integer VALUE_INDEX
        static constant integer VALUE_MAX_INDEX = ARRAY_MIN + 8
        static real array VALUES
        method UpdateLocal takes nothing returns nothing
            local string s = Real.ToStringWithDecimals(thistype.VALUES[thistype.VALUE_INDEX], 1)
            set OptionsBoard.SELECTABLE_ROWS_VALUE[OptionsBoard.SELECTABLE_ROWS_INDIZES[thistype.ROW]] = s
            if (OptionsBoard(this).selectedRow == thistype.ROW) then
                set s = String.If((thistype.VALUE_INDEX > ARRAY_MIN), String.Color.Do("<<< ", String.Color.GOLD)) + String.Color.Do(s, String.Color.GREEN) + String.If((thistype.VALUE_INDEX < thistype.VALUE_MAX_INDEX), String.Color.Do(" >>>", String.Color.GOLD))
            endif
            call OptionsBoard.THIS_BOARD.SetValue(thistype.ROW, OptionsBoard.VALUE_COLUMN, s)
            call Camera.SetSmoothing(User.GetLocal(), thistype.VALUES[thistype.VALUE_INDEX])
        endmethod
        method Update takes nothing returns nothing
            if OptionsBoard(this).owner.IsLocal() then
                call this.UpdateLocal()
            endif
        endmethod
        method Event_Left takes nothing returns nothing
            if (thistype.VALUE_INDEX > ARRAY_MIN) then
                set thistype.VALUE_INDEX = thistype.VALUE_INDEX - 1
            endif
            call this.Update()
        endmethod
        method Event_Right takes nothing returns nothing
            if (thistype.VALUE_INDEX < thistype.VALUE_MAX_INDEX) then
                set thistype.VALUE_INDEX = thistype.VALUE_INDEX + 1
            endif
            call this.Update()
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Update()
        endmethod
        static method Init takes nothing returns nothing
            set thistype.VALUE_INDEX = ARRAY_MIN + 3
            set thistype.VALUES[ARRAY_MIN + 0] = 0.
            set thistype.VALUES[ARRAY_MIN + 1] = 0.5
            set thistype.VALUES[ARRAY_MIN + 2] = 1.
            set thistype.VALUES[ARRAY_MIN + 3] = 1.5
            set thistype.VALUES[ARRAY_MIN + 4] = 2.
            set thistype.VALUES[ARRAY_MIN + 5] = 2.5
            set thistype.VALUES[ARRAY_MIN + 6] = 3.
            set thistype.VALUES[ARRAY_MIN + 7] = 3.5
            set thistype.VALUES[ARRAY_MIN + 8] = 4.
        endmethod
    endstruct
    public struct StructCameraZoom
        implement Allocation
        implement List
        
        static integer ROW
        static constant integer VALUE_MAX_INDEX = ARRAY_MIN + 11
        static integer array VALUES
        integer valueIndex
        method UpdateLocal takes nothing returns nothing
            local string s = Integer.ToString(thistype.VALUES[this.valueIndex])
            set OptionsBoard.SELECTABLE_ROWS_VALUE[OptionsBoard.SELECTABLE_ROWS_INDIZES[thistype.ROW]] = s
            if (OptionsBoard(this).selectedRow == thistype.ROW) then
                set s = String.If((this.valueIndex > ARRAY_MIN), String.Color.Do("<<< ", String.Color.GOLD)) + String.Color.Do(s, String.Color.GREEN) + String.If((this.valueIndex < thistype.VALUE_MAX_INDEX), String.Color.Do(" >>>", String.Color.GOLD))
            endif
            call OptionsBoard.THIS_BOARD.SetValue(thistype.ROW, OptionsBoard.VALUE_COLUMN, s)
            set Zoom.VALUE = thistype.VALUES[this.valueIndex]
        endmethod
        method Update takes nothing returns nothing
            if OptionsBoard(this).owner.IsLocal() then
                call this.UpdateLocal()
            endif
        endmethod
        method Event_Left takes real intervalWeight returns nothing
            if (this.valueIndex > ARRAY_MIN) then
                set this.valueIndex = this.valueIndex - 1
            else
                if (intervalWeight == 1.) then
                    call Game.DisplayTextTimed(OptionsBoard(this).owner, String.Color.Do("Penguin perspective is not supported", String.Color.GOLD), 10.)
                endif
            endif
            call this.Update()
        endmethod
        method Event_Right takes nothing returns nothing
            if (this.valueIndex < thistype.VALUE_MAX_INDEX) then
                set this.valueIndex = this.valueIndex + 1
            endif
            call this.Update()
        endmethod
        method Event_Create takes nothing returns nothing
            set this.valueIndex = ARRAY_MIN + 10
            call this.Update()
        endmethod
        static method Init takes nothing returns nothing
            set thistype.VALUES[ARRAY_MIN] = 1350
            set thistype.VALUES[ARRAY_MIN + 1] = 1450
            set thistype.VALUES[ARRAY_MIN + 2] = 1550
            set thistype.VALUES[ARRAY_MIN + 3] = 1650
            set thistype.VALUES[ARRAY_MIN + 4] = 1750
            set thistype.VALUES[ARRAY_MIN + 5] = 1850
            set thistype.VALUES[ARRAY_MIN + 6] = 1950
            set thistype.VALUES[ARRAY_MIN + 7] = 2050
            set thistype.VALUES[ARRAY_MIN + 8] = 2150
            set thistype.VALUES[ARRAY_MIN + 9] = 2250
            set thistype.VALUES[ARRAY_MIN + 10] = 2350
            set thistype.VALUES[ARRAY_MIN + 11] = 2450
        endmethod
    endstruct
    public struct StructEffectLevel
        implement Allocation
        implement List
        
        static integer ROW
        method UpdateLocal takes nothing returns nothing
            local string s = EffectLevel.CURRENT.GetName()
            set OptionsBoard.SELECTABLE_ROWS_VALUE[OptionsBoard.SELECTABLE_ROWS_INDIZES[thistype.ROW]] = s
            if (OptionsBoard(this).selectedRow == thistype.ROW) then
                set s = String.If((EffectLevel.CURRENT.GetIndex() > ARRAY_MIN), String.Color.Do("<<< ", String.Color.GOLD)) + String.Color.Do(s, String.Color.GREEN) + String.If((EffectLevel.CURRENT.GetIndex() < EffectLevel.ALL_COUNT), String.Color.Do(" >>>", String.Color.GOLD))
            endif
            call OptionsBoard.THIS_BOARD.SetValue(thistype.ROW, OptionsBoard.VALUE_COLUMN, s)
        endmethod
        method Update takes nothing returns nothing
            if OptionsBoard(this).owner.IsLocal() then
                call this.UpdateLocal()
            endif
        endmethod
        method Event_Left takes nothing returns nothing
            call EffectLevel.ALL[Math.MaxI(ARRAY_MIN, EffectLevel.CURRENT.GetIndex() - 1)].Select()
            call this.Update()
        endmethod
        method Event_Right takes nothing returns nothing
            call EffectLevel.ALL[Math.MinI(EffectLevel.CURRENT.GetIndex() + 1, EffectLevel.ALL_COUNT)].Select()
            call this.Update()
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Update()
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
    public struct StructHint
        implement Allocation
        implement List
        
        static integer ROW
        static integer VALUE_INDEX
        static constant integer VALUE_MAX_INDEX = ARRAY_MIN + 1
        static string array VALUES
        method UpdateLocal takes nothing returns nothing
            local string s = thistype.VALUES[thistype.VALUE_INDEX]
            set OptionsBoard.SELECTABLE_ROWS_VALUE[OptionsBoard.SELECTABLE_ROWS_INDIZES[thistype.ROW]] = s
            if (OptionsBoard(this).selectedRow == thistype.ROW) then
                set s = String.If((thistype.VALUE_INDEX > ARRAY_MIN), String.Color.Do("<<< ", String.Color.GOLD)) + String.Color.Do(s, String.Color.GREEN) + String.If((thistype.VALUE_INDEX < thistype.VALUE_MAX_INDEX), String.Color.Do(" >>>", String.Color.GOLD))
            endif
            call OptionsBoard.THIS_BOARD.SetValue(thistype.ROW, OptionsBoard.VALUE_COLUMN, s)
            set Hint.SHOW = Integer.ToBoolean(thistype.VALUE_INDEX)
        endmethod
        method Update takes nothing returns nothing
            if OptionsBoard(this).owner.IsLocal() then
                call this.UpdateLocal()
            endif
        endmethod
        method Event_Left takes nothing returns nothing
            set thistype.VALUE_INDEX = Math.MaxI(0, thistype.VALUE_INDEX - 1)
            call this.Update()
        endmethod
        method Event_Right takes nothing returns nothing
            set thistype.VALUE_INDEX = Math.MinI(thistype.VALUE_INDEX + 1, 1)
            call this.Update()
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Update()
        endmethod
        static method Init takes nothing returns nothing
            set thistype.VALUE_INDEX = 0
            set thistype.VALUES[ARRAY_MIN] = "off"
            set thistype.VALUES[ARRAY_MIN + 1] = "on"
        endmethod
    endstruct
    public struct StructMusicVolume
        implement Allocation
        implement List
        
        static constant integer MAX_SEGMENTS_AMOUNT = 25
        static integer ROW
        static Music TEST_MUSIC
        static integer VALUE = 100
        static method Deselect takes nothing returns nothing
            call thistype.TEST_MUSIC.Stop()
        endmethod
        method UpdateLocal takes boolean playMusic returns nothing
            local string s = String.Repeat("l", Real.ToInt(Math.Min(thistype.VALUE * thistype.MAX_SEGMENTS_AMOUNT / 100., thistype.MAX_SEGMENTS_AMOUNT)))
            local string s2 = " " + String.Color.Do("(" + Integer.ToString(thistype.VALUE) + Char.PERCENT + ")", String.Color.GOLD)
            set OptionsBoard.SELECTABLE_ROWS_VALUE[OptionsBoard.SELECTABLE_ROWS_INDIZES[thistype.ROW]] = s + s2
            call Music.SetVolume(thistype.VALUE / 100.)
            if (OptionsBoard(this).selectedRow == thistype.ROW) then
                set s = String.Color.Do(s, String.Color.GREEN)
            endif
            set s = s + s2
            if playMusic then
                call thistype.TEST_MUSIC.Play()
            endif
            call OptionsBoard.THIS_BOARD.SetValue(thistype.ROW, OptionsBoard.VALUE_COLUMN, s)
        endmethod
        method Update takes boolean playMusic returns nothing
            if OptionsBoard(this).owner.IsLocal() then
                call this.UpdateLocal(playMusic)
            endif
        endmethod
        method Event_Left takes real intervalWeight returns nothing
            set thistype.VALUE = Math.MaxI(0, Real.ToInt(thistype.VALUE - 1. * intervalWeight))
            call this.Update(true)
        endmethod
        method Event_Right takes real intervalWeight returns nothing
            set thistype.VALUE = Math.MinI(Real.ToInt(thistype.VALUE + 1. * intervalWeight), 100)
            call this.Update(true)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Update(false)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.TEST_MUSIC = Music.Create("Sound\\Music\\mp3Music\\Credits.mp3", -1)
        endmethod
    endstruct
    public struct StructSoundVolume
        implement Allocation
        implement List
        
        static constant integer MAX_SEGMENTS_AMOUNT = 25
        static integer ROW
        static Sound TEST_SOUND
        static integer VALUE = 100
        method UpdateLocal takes boolean playSound returns nothing
            local string s = String.Repeat("l", Real.ToInt(Math.Min(thistype.VALUE * thistype.MAX_SEGMENTS_AMOUNT / 100., thistype.MAX_SEGMENTS_AMOUNT)))
            local string s2 = " " + String.Color.Do("(" + Integer.ToString(thistype.VALUE) + Char.PERCENT + ")", String.Color.GOLD)
            set OptionsBoard.SELECTABLE_ROWS_VALUE[OptionsBoard.SELECTABLE_ROWS_INDIZES[thistype.ROW]] = s + s2
            call SoundChannel.SetVolumeOverall(thistype.VALUE / 100.)
            if (OptionsBoard(this).selectedRow == thistype.ROW) then
                set s = String.Color.Do(s, String.Color.GREEN)
            endif
            set s = s + s2
            if playSound then
                call thistype.TEST_SOUND.Play()
            endif
            call OptionsBoard.THIS_BOARD.SetValue(thistype.ROW, OptionsBoard.VALUE_COLUMN, s)
        endmethod
        method Update takes boolean playSound returns nothing
            if OptionsBoard(this).owner.IsLocal() then
                call this.UpdateLocal(playSound)
            endif
        endmethod
        method Event_Left takes real intervalWeight returns nothing
            set thistype.VALUE = Math.MaxI(0, Real.ToInt(thistype.VALUE - 1. * intervalWeight))
            call this.Update(true)
        endmethod
        method Event_Right takes real intervalWeight returns nothing
            set thistype.VALUE = Math.MinI(Real.ToInt(thistype.VALUE + 1. * intervalWeight), 100)
            call this.Update(true)
        endmethod
        method Event_Create takes nothing returns nothing
            call this.Update(false)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.TEST_SOUND = Sound.Create("Units\\Human\\Footman\\FootmanPissed4.wav", false, false, false, 10, 10, NULL)
            
            call thistype.TEST_SOUND.SetChannel(SoundChannel.UI)
        endmethod
    endstruct
endscope
    globals
        OptionsBoard OPTIONS_BOARD = STRUCT_BASE
    endglobals
    struct OptionsBoard
        implement Allocation
        implement List
        
    static integer array SELECTABLE_ROWS
    static integer SELECTABLE_ROWS_COUNT = ARRAY_EMPTY
    static integer array SELECTABLE_ROWS_INDIZES
    static string array SELECTABLE_ROWS_LABEL
    static string array SELECTABLE_ROWS_VALUE
    static Multiboard THIS_BOARD = NULL
    static integer LABEL_COLUMN
    static integer VALUE_COLUMN
    static integer AUDIO_ROW
    static integer GRAPHICS_ROW
    static integer MISC_ROW
    boolean active
    User owner
    integer selectedRow
    integer selectedRowIndex
    Event downEvent
    Event leftEvent
    Event rightEvent
    Event upEvent
    FolderOptionsBoard_StructCameraSmoothing CameraSmoothing = this
    FolderOptionsBoard_StructCameraSmoothing LinkToStruct_CameraSmoothing
    FolderOptionsBoard_StructCameraZoom CameraZoom = this
    FolderOptionsBoard_StructCameraZoom LinkToStruct_CameraZoom
    FolderOptionsBoard_StructEffectLevel EffectLevel = this
    FolderOptionsBoard_StructEffectLevel LinkToStruct_EffectLevel
    FolderOptionsBoard_StructHint Hint = this
    FolderOptionsBoard_StructHint LinkToStruct_Hint
    FolderOptionsBoard_StructMusicVolume MusicVolume = this
    FolderOptionsBoard_StructMusicVolume LinkToStruct_MusicVolume
    FolderOptionsBoard_StructSoundVolume SoundVolume = this
    FolderOptionsBoard_StructSoundVolume LinkToStruct_SoundVolume
    method DeselectRowByIndex takes integer index returns nothing
        if (index == ARRAY_EMPTY) then
            return
        endif
        local integer row = thistype.SELECTABLE_ROWS[index]
        if this.owner.IsLocal() then
            call thistype.THIS_BOARD.SetValue(row, thistype.LABEL_COLUMN, thistype.SELECTABLE_ROWS_LABEL[index])
            call thistype.THIS_BOARD.SetValue(row, thistype.VALUE_COLUMN, thistype.SELECTABLE_ROWS_VALUE[index])
        endif
        if (row == thistype(NULL).MusicVolume.ROW) then
            call thistype(NULL).MusicVolume.Deselect()
        endif
    endmethod
    method SelectRowByIndex takes integer index returns nothing
        local integer oldRowIndex = this.selectedRowIndex
        if (index == oldRowIndex) then
            return
        endif
        call this.DeselectRowByIndex(oldRowIndex)
        set this.selectedRowIndex = index
		local integer whichRow
        if (index == ARRAY_EMPTY) then
            set whichRow = NULL
        else
            set whichRow = thistype.SELECTABLE_ROWS[index]
        endif
        set this.selectedRow = whichRow
        if (whichRow == NULL) then
            call MULTIBOARD.Shown.Control.PageSwitch.Activate(this.owner)
        else
            call MULTIBOARD.Shown.Control.PageSwitch.Deactivate(this.owner)
        endif
        if not this.owner.IsLocal() then
            return
        endif
        if (whichRow == thistype(NULL).CameraSmoothing.ROW) then
            call this.CameraSmoothing.Update()
        endif
        if (whichRow == thistype(NULL).CameraZoom.ROW) then
            call this.CameraZoom.Update()
        endif
        if (whichRow == thistype(NULL).EffectLevel.ROW) then
            call this.EffectLevel.Update()
        endif
        if (whichRow == thistype(NULL).Hint.ROW) then
            call this.Hint.Update()
        endif
        if (whichRow == thistype(NULL).MusicVolume.ROW) then
            call this.MusicVolume.Update(false)
        endif
        if (whichRow == thistype(NULL).SoundVolume.ROW) then
            call this.SoundVolume.Update(false)
        endif
    endmethod
    eventMethod Event_Left
        local real intervalWeight = params.Real.GetIntervalWeight()
        local User owner = params.User.GetTrigger()
        local thistype this = owner
        local integer whichRow = this.selectedRow
        if (whichRow == thistype(NULL).CameraZoom.ROW) then
            call this.CameraZoom.Event_Left(intervalWeight)
        endif
        if not owner.IsLocal() then
            return
        endif
        if (whichRow == thistype(NULL).CameraSmoothing.ROW) then
            call this.CameraSmoothing.Event_Left()
        endif
        if (whichRow == thistype(NULL).EffectLevel.ROW) then
            call this.EffectLevel.Event_Left()
        endif
        if (whichRow == thistype(NULL).Hint.ROW) then
            call this.Hint.Event_Left()
        endif
        if (whichRow == thistype(NULL).MusicVolume.ROW) then
            call this.MusicVolume.Event_Left(intervalWeight)
        endif
        if (whichRow == thistype(NULL).SoundVolume.ROW) then
            call this.SoundVolume.Event_Left(intervalWeight)
        endif
    endmethod
    eventMethod Event_Right
        local real intervalWeight = params.Real.GetIntervalWeight()
        local User owner = params.User.GetTrigger()
        local thistype this = owner
        local integer whichRow = this.selectedRow
        if (whichRow == thistype(NULL).CameraZoom.ROW) then
            call this.CameraZoom.Event_Right()
        endif
        if not owner.IsLocal() then
            return
        endif
        if (whichRow == thistype(NULL).CameraSmoothing.ROW) then
            call this.CameraSmoothing.Event_Right()
        endif
        if (whichRow == thistype(NULL).EffectLevel.ROW) then
            call this.EffectLevel.Event_Right()
        endif
        if (whichRow == thistype(NULL).Hint.ROW) then
            call this.Hint.Event_Right()
        endif
        if (whichRow == thistype(NULL).MusicVolume.ROW) then
            call this.MusicVolume.Event_Right(intervalWeight)
        endif
        if (whichRow == thistype(NULL).SoundVolume.ROW) then
            call this.SoundVolume.Event_Right(intervalWeight)
        endif
    endmethod
    eventMethod Event_Down
        local User owner = params.User.GetTrigger()
        local thistype this = owner
        if (this.selectedRowIndex == thistype.SELECTABLE_ROWS_COUNT) then
            call this.SelectRowByIndex(ARRAY_EMPTY)
        else
            call this.SelectRowByIndex(this.selectedRowIndex + 1)
        endif
    endmethod
    eventMethod Event_Up
        local User owner = params.User.GetTrigger()
        local thistype this = owner
        if (this.selectedRowIndex == ARRAY_EMPTY) then
            call this.SelectRowByIndex(thistype.SELECTABLE_ROWS_COUNT)
        else
            call this.SelectRowByIndex(this.selectedRowIndex - 1)
        endif
    endmethod
    method Deactivate takes nothing returns nothing
        local User owner = this.owner
        if not this.active then
            return
        endif
        set this.active = false
        call this.downEvent.Destroy()
        call this.leftEvent.Destroy()
        call this.rightEvent.Destroy()
        call this.upEvent.Destroy()
        call this.DeselectRowByIndex(this.selectedRowIndex)
    endmethod
    method Activate takes nothing returns nothing
        local User owner = this.owner
        if this.active then
            return
        endif
        set this.active = true
        set this.downEvent = owner.KeyEvent.DownArrow.RegisterPress(EventPriority.MISC, function thistype.Event_Down, 0.5, 1.)
        set this.leftEvent = owner.KeyEvent.LeftArrow.RegisterPress(EventPriority.MISC, function thistype.Event_Left, 0.1, 4.)
        set this.rightEvent = owner.KeyEvent.RightArrow.RegisterPress(EventPriority.MISC, function thistype.Event_Right, 0.1, 4.)
        set this.upEvent = owner.KeyEvent.UpArrow.RegisterPress(EventPriority.MISC, function thistype.Event_Up, 0.5, 1.)
        set this.selectedRow = ARRAY_EMPTY
        set this.selectedRowIndex = ARRAY_EMPTY
    endmethod
    static method Event_MultiboardChange takes Multiboard matchingBoard, User owner returns nothing
        local thistype this = owner
        if (matchingBoard == thistype.THIS_BOARD) then
            call this.Activate()
        else
            call this.Deactivate()
        endif
    endmethod
    static method Event_MultiboardControlDeactivate takes User owner returns nothing
        local thistype this = owner
        call this.Deactivate()
    endmethod
    static method Event_MultiboardControlActivate takes User owner returns nothing
        local thistype this = owner
        if (MULTIBOARD.Shown.GetCurrent(owner) == thistype.THIS_BOARD) then
            call this.Activate()
        endif
    endmethod
    static method Create takes User owner returns thistype
        local thistype this = owner
        set this.active = false
        set this.owner = owner
        call thistype.THIS_BOARD.Show(owner)
        call this.CameraSmoothing.Event_Create()
        call this.CameraZoom.Event_Create()
        call this.EffectLevel.Event_Create()
        call this.Hint.Event_Create()
        call this.MusicVolume.Event_Create()
        call this.SoundVolume.Event_Create()
        return this
    endmethod
    eventMethod Event_AfterIntro
        call thistype.Create(params.User.GetTrigger())
    endmethod
    static method GetNewRow takes nothing returns integer
        return thistype.THIS_BOARD.GetNewRow()
    endmethod
    static method GetNewSelectableRow takes string label, string value returns integer
        local integer result = thistype.GetNewRow()
        set label = String.Color.Do(label, String.Color.GOLD)
        set thistype.SELECTABLE_ROWS_COUNT = thistype.SELECTABLE_ROWS_COUNT + 1
        call thistype.THIS_BOARD.SetValue(result, thistype.LABEL_COLUMN, label)
        call thistype.THIS_BOARD.SetValue(result, thistype.VALUE_COLUMN, value)
        set thistype.SELECTABLE_ROWS[thistype.SELECTABLE_ROWS_COUNT] = result
        set thistype.SELECTABLE_ROWS_INDIZES[result] = thistype.SELECTABLE_ROWS_COUNT
        set thistype.SELECTABLE_ROWS_LABEL[thistype.SELECTABLE_ROWS_COUNT] = label
        set thistype.SELECTABLE_ROWS_VALUE[thistype.SELECTABLE_ROWS_COUNT] = value
        return result
    endmethod
    eventMethod Event_Start
        set thistype.THIS_BOARD = Multiboard.Create()
        set thistype.LABEL_COLUMN = thistype.THIS_BOARD.GetNewColumn()
        set thistype.VALUE_COLUMN = thistype.THIS_BOARD.GetNewColumn()
        set thistype.GRAPHICS_ROW = thistype.GetNewRow()
        set thistype(NULL).EffectLevel.ROW = thistype.GetNewSelectableRow("SFX Level", "")
        set thistype.AUDIO_ROW = thistype.GetNewRow()
        set SoundVolume.ROW = thistype.GetNewSelectableRow("Sound volume", "")
        set MusicVolume.ROW = thistype.GetNewSelectableRow("Music volume", "")
        set thistype.MISC_ROW = thistype.GetNewRow()
        set thistype(NULL).CameraZoom.ROW = thistype.GetNewSelectableRow("Camera zoom", "")
        set thistype(NULL).CameraSmoothing.ROW = thistype.GetNewSelectableRow("Camera smoothing factor", "")
        set thistype(NULL).Hint.ROW = thistype.GetNewSelectableRow("Hint", "")
        call thistype.THIS_BOARD.Column.SetWidth(thistype.LABEL_COLUMN, 0.1)
        call thistype.THIS_BOARD.Column.SetWidth(thistype.VALUE_COLUMN, 0.1)
        call thistype.THIS_BOARD.SetTitle("Options")
        call thistype.THIS_BOARD.SetValue(thistype.AUDIO_ROW, thistype.LABEL_COLUMN, String.Color.Do("Audio", String.Color.GOLD))
        call thistype.THIS_BOARD.SetWidth(thistype.AUDIO_ROW, thistype.LABEL_COLUMN, 0.2)
        call thistype.THIS_BOARD.SetWidth(thistype.AUDIO_ROW, thistype.VALUE_COLUMN, 0.)
        call thistype.THIS_BOARD.SetValue(thistype.GRAPHICS_ROW, thistype.LABEL_COLUMN, String.Color.Do("Graphics", String.Color.GOLD))
        call thistype.THIS_BOARD.SetWidth(thistype.GRAPHICS_ROW, thistype.LABEL_COLUMN, 0.2)
        call thistype.THIS_BOARD.SetWidth(thistype.GRAPHICS_ROW, thistype.VALUE_COLUMN, 0.)
        call thistype.THIS_BOARD.SetValue(thistype.MISC_ROW, thistype.LABEL_COLUMN, String.Color.Do("Misc", String.Color.GOLD))
        call thistype.THIS_BOARD.SetWidth(thistype.MISC_ROW, thistype.LABEL_COLUMN, 0.2)
        call thistype.THIS_BOARD.SetWidth(thistype.MISC_ROW, thistype.VALUE_COLUMN, 0.)
        call Event.Create(AfterIntro.FOR_PLAYER_EVENT_TYPE, EventPriority.MISC, function thistype.Event_AfterIntro).AddToStatics()
        call thistype(NULL).CameraSmoothing.Init()
        call thistype(NULL).CameraZoom.Init()
        call thistype(NULL).EffectLevel.Init()
        call thistype(NULL).Hint.Init()
        call thistype(NULL).MusicVolume.Init()
        call thistype(NULL).SoundVolume.Init()
    endmethod
    initMethod Init of Misc_2
        call Event.Create(EventType.START, EventPriority.MISC, function thistype.Event_Start).AddToStatics()
    endmethod
endstruct
    globals
        Pharmacy PHARMACY = STRUCT_BASE
    endglobals
    struct Pharmacy
        implement Allocation
        implement List
        
endstruct
    globals
        EmergencyProvisions EMERGENCY_PROVISIONS = STRUCT_BASE
    endglobals
    struct EmergencyProvisions
        implement Allocation
        implement List
        
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        call caster.Effects.Create(thistype.CASTER_EFFECT_PATH, thistype.CASTER_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).DestroyTimed.Start(2.)
        call caster.HealBySpell(caster, thistype.HEAL)
    endmethod
    initMethod Init of Items_Act1
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        EyeOfTheFlame EYE_OF_THE_FLAME = STRUCT_BASE
    endglobals
    struct EyeOfTheFlame
        implement Allocation
        implement List
        
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local User casterOwner = caster.Owner.Get()
		local integer iteration = thistype.SUMMONS_AMOUNT
        loop
            call Unit.CreateSummon(thistype.SUMMON_UNIT_TYPE, casterOwner, targetX, targetY, UNIT.Facing.STANDARD, thistype.DURATION)
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
    endmethod
    initMethod Init of Items_Act1
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        TorchLight TORCH_LIGHT = STRUCT_BASE
    endglobals
    struct TorchLight
        implement Allocation
        implement List
        
    static Event DAMAGE_EVENT
    static BoolExpr TARGET_FILTER
    Timer updateTimer
    static method AddIgnited takes Unit caster, integer level, Unit target returns nothing
        local real duration
        if target.Classes.Contains(UnitClass.HERO) then
            set duration = thistype.HERO_DURATION
        else
            set duration = thistype.DURATION
        endif
        call target.Buffs.Timed.StartEx(thistype.IGNITION_BUFF, level, caster, duration)
    endmethod
    static method Conditions takes Unit target returns boolean
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_Damage
        local Unit target = params.Unit.GetTrigger()
        if not thistype.Conditions(target) then
            return
        endif
        call thistype(NULL).AddIgnited(params.Unit.GetDamager(), params.Spell.GetLevel(), target)
    endmethod
    condMethod TargetConditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if not thistype.Conditions(target) then
            return false
        endif
        if target.Ignited.Is() then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.IsEnemyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    timerMethod Update
        local thistype this = Timer.GetExpired().GetData()
        local Unit target = this
        set User.TEMP = target.Owner.Get()
        local Unit target2 = GROUP.EnumUnits.InRange.WithCollision.GetNearest(target.Position.X.Get(), target.Position.Y.Get(), target.Attack.Range.Get(), thistype.TARGET_FILTER)
        if (target2 != NULL) then
            call target.Order.UnitTarget(Order.ATTACK, target2)
        endif
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local Timer updateTimer = this.updateTimer
        call target.Event.Remove(DAMAGE_EVENT)
        call updateTimer.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
		local Timer updateTimer = Timer.Create()
        set this.updateTimer = updateTimer
        call target.Event.Add(DAMAGE_EVENT)
        call updateTimer.SetData(this)
        call updateTimer.Start(0.5, true, function thistype.Update)
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Misc
        set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.TargetConditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
        call UNIT.Ignited.NORMAL_BUFF.Variants.Add(thistype.IGNITION_BUFF)
    endmethod
endstruct
    globals
        HerbalOintment HERBAL_OINTMENT = STRUCT_BASE
    endglobals
    struct HerbalOintment
        implement Allocation
        implement List
        
    static Event DAMAGE_EVENT
    static real LIFE_ADD_PER_INTERVAL
    static real MANA_ADD_PER_INTERVAL
    static integer WAVES_AMOUNT
    Timer intervalTimer
    Unit target
    eventMethod Event_Damage
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    timerMethod Heal
        local Timer intervalTimer = Timer.GetExpired()
        local thistype this = intervalTimer.GetData()
        local Unit target = this.target
        call target.HealBySpell(target, thistype.LIFE_ADD_PER_INTERVAL)
        call target.HealManaBySpell(target, thistype.MANA_ADD_PER_INTERVAL)
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local Timer intervalTimer = this.intervalTimer
        call intervalTimer.Destroy()
        call target.Event.Remove(DAMAGE_EVENT)
    endmethod
    eventMethod Event_BuffGain
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
		local Timer intervalTimer = Timer.Create()
        set this.intervalTimer = intervalTimer
        set this.target = target
        call intervalTimer.SetData(this)
        call target.Event.Add(DAMAGE_EVENT)
        call target.Buffs.Dispel(true, false, true)
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Heal)
    endmethod
    eventMethod Event_SpellEffect
        call params.Unit.GetTrigger().Buffs.Timed.Start(thistype.DUMMY_BUFF, params.Spell.GetLevel(), thistype.DURATION)
    endmethod
    initMethod Init of Items_Act1
        set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_Damage)
        set thistype.WAVES_AMOUNT = Real.ToInt(thistype.DURATION / thistype.INTERVAL)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_SpellEffect))
        set thistype.LIFE_ADD_PER_INTERVAL = thistype.LIFE_ADD / thistype.WAVES_AMOUNT
        set thistype.MANA_ADD_PER_INTERVAL = thistype.MANA_ADD / thistype.WAVES_AMOUNT
    endmethod
endstruct
    scope FolderScrollOfProtection
    public struct StructTarget
        implement Allocation
        implement List
        
        method Start takes integer level, Unit target returns nothing
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION)
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
endscope
    globals
        ScrollOfProtection SCROLL_OF_PROTECTION = STRUCT_BASE
    endglobals
    struct ScrollOfProtection
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    FolderScrollOfProtection_StructTarget Target = this
    FolderScrollOfProtection_StructTarget LinkToStruct_Target
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.NEUTRAL) then
            return false
        endif
        if not target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        call Spot.CreateEffect(casterX, casterY, thistype.SPECIAL_EFFECT_PATH, EffectLevel.NORMAL).Destroy()
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(casterX, casterY, thistype.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            loop
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
                call thistype(NULL).Target.Start(level, target)
            endloop
        endif
    endmethod
    initMethod Init of Items_Act1
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Target.Init()
    endmethod
endstruct
    scope FolderFireWater
    public struct StructBuff
        implement Allocation
        implement List
        
        static real DAMAGE
        static Group ENUM_GROUP
        static BoolExpr TARGET_FILTER
        real areaRange
        Timer intervalTimer
        condMethod Conditions
            local Unit target = UNIT.Event.Native.GetFilter()
            if target.Classes.Contains(UnitClass.DEAD) then
                return false
            endif
            if target.Classes.Contains(UnitClass.STRUCTURE) then
                return false
            endif
            if target.IsAllyOf(User.TEMP) then
                return false
            endif
            if target.MagicImmunity.Try() then
                return false
            endif
            return true
        endmethod
        timerMethod Interval
            local thistype this = Timer.GetExpired().GetData()
            local Unit target = this
            set User.TEMP = target.Owner.Get()
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(target.Position.X.Get(), target.Position.Y.Get(), this.areaRange, thistype.TARGET_FILTER)
            local Unit victim = thistype.ENUM_GROUP.FetchFirst()
            if (victim != NULL) then
                loop
                    call target.DamageUnitBySpell(victim, DAMAGE, true, false)
                    set victim = thistype.ENUM_GROUP.FetchFirst()
                    exitwhen (victim == NULL)
                endloop
            endif
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            local Timer intervalTimer = this.intervalTimer
            call intervalTimer.Destroy()
        endmethod
        eventMethod Event_BuffGain
            local integer level = params.Buff.GetLevel()
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
			local Timer intervalTimer = Timer.Create()
            set this.areaRange = FireWater.THIS_SPELL.GetAreaRange(level)
            set this.intervalTimer = intervalTimer
            call intervalTimer.SetData(this)
            call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
        endmethod
        static method Start takes integer level, Unit target returns nothing
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DAMAGE = thistype.DAMAGE_PER_SECOND * thistype.INTERVAL
            set thistype.ENUM_GROUP = Group.Create()
            set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
    endstruct
endscope
    globals
        FireWater FIRE_WATER = STRUCT_BASE
    endglobals
    struct FireWater
        implement Allocation
        implement List
        
    FolderFireWater_StructBuff Buff = this
    FolderFireWater_StructBuff LinkToStruct_Buff
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        call caster.Effects.Create(thistype.CASTER_EFFECT_PATH, thistype.CASTER_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
        call caster.HealManaBySpell(caster, thistype.REFRESHED_MANA)
        call thistype(NULL).Buff.Start(level, caster)
    endmethod
    initMethod Init of Items_Misc
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_SpellEffect))
        call thistype(NULL).Buff.Init()
    endmethod
endstruct
    globals
        IceTea ICE_TEA = STRUCT_BASE
    endglobals
    struct IceTea
        implement Allocation
        implement List
        
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        call caster.Effects.Create(thistype.CASTER_EFFECT_PATH, thistype.CASTER_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
        call caster.HealManaBySpell(caster, thistype.REFRESHED_MANA[level])
    endmethod
    initMethod Init of Items_Misc
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        Meat MEAT = STRUCT_BASE
    endglobals
    struct Meat
        implement Allocation
        implement List
        
    static Event DEATH_EVENT
    static real HEAL_PER_INTERVAL
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static integer WAVES_AMOUNT
    Unit caster
    Timer durationTimer
    Timer intervalTimer
    method Ending takes Unit caster, Timer durationTimer returns nothing
        local Timer intervalTimer = this.intervalTimer
        call this.deallocate()
        if caster.Data.Integer.Table.Remove(KEY_ARRAY, this) then
            call caster.Event.Remove(DEATH_EVENT)
        endif
        call durationTimer.Destroy()
        call intervalTimer.Destroy()
    endmethod
    timerMethod EndingByTimer
        local Timer durationTimer = Timer.GetExpired()
        local thistype this = durationTimer.GetData()
        call this.Ending(this.caster, durationTimer)
    endmethod
    eventMethod Event_Death
        local Unit caster = params.Unit.GetTrigger()
        local integer iteration = caster.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            local thistype this = caster.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            call this.Ending(caster, this.durationTimer)
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
    endmethod
    timerMethod Heal
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this.caster
        call caster.Effects.Create(thistype.CASTER_EFFECT_PATH, thistype.CASTER_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).DestroyTimed.Start(2.)
        call caster.HealBySpell(caster, thistype.HEAL_PER_INTERVAL)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local Timer durationTimer = Timer.Create()
        local Timer intervalTimer = Timer.Create()
        local thistype this = thistype.allocate()
        set this.caster = caster
        set this.durationTimer = durationTimer
        set this.intervalTimer = intervalTimer
        if caster.Data.Integer.Table.Add(KEY_ARRAY, this) then
            call caster.Event.Add(DEATH_EVENT)
        endif
        call durationTimer.SetData(this)
        call intervalTimer.SetData(this)
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Heal)
        call durationTimer.Start(thistype.DURATION, false, function thistype.EndingByTimer)
    endmethod
    initMethod Init of Items_Misc
        set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_Death)
        set thistype.WAVES_AMOUNT = Real.ToInt(thistype.DURATION / thistype.INTERVAL)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_SpellEffect))
        set thistype.HEAL_PER_INTERVAL = thistype.HEAL / thistype.WAVES_AMOUNT
    endmethod
endstruct
    globals
        TeleportScroll TELEPORT_SCROLL = STRUCT_BASE
    endglobals
    struct TeleportScroll
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static real MAX_OFFSET_SQUARE
    static Event TARGET_DEATH_EVENT
    static BoolExpr TARGET_FILTER
    static Item TARGET_ITEM
    static real TARGET_X
    static real TARGET_Y
    Unit target
    UnitEffect targetEffect
    real targetOffsetX
    real targetOffsetY
    eventMethod Event_TargetDeath
        local Unit target = params.Unit.GetTrigger()
        local integer iteration = target.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            local thistype this = target.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            local Unit caster = this
            call caster.Buffs.Remove(thistype.DUMMY_BUFF)
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
    endmethod
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if not target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_BuffLose
        local Unit caster = params.Unit.GetTrigger()
        local thistype this = caster
        local Unit target = this.target
        local UnitEffect targetEffect = this.targetEffect
        if target.Data.Integer.Table.Remove(KEY_ARRAY, this) then
            call target.Event.Remove(TARGET_DEATH_EVENT)
        endif
        call targetEffect.Destroy()
        call caster.Abilities.Remove(Invulnerability.THIS_SPELL)
    endmethod
    eventMethod Event_BuffGain
        local Unit caster = params.Unit.GetTrigger()
        local Item targetItem = thistype.TARGET_ITEM
        local real targetSpotX = thistype.TARGET_X
        local real targetSpotY = thistype.TARGET_Y
        local thistype this = caster
		local Unit targetUnit
		local real targetOffsetX
		local real targetOffsetY
        if (targetItem == NULL) then
            set User.TEMP = caster.Owner.Get()
            call thistype.ENUM_GROUP.EnumUnits.All(thistype.TARGET_FILTER)
            set targetUnit = thistype.ENUM_GROUP.GetNearestWithCollision(targetSpotX, targetSpotY)
            if (targetUnit == NULL) then
                return
            endif
            local real targetUnitX = targetUnit.Position.X.Get()
            local real targetUnitY = targetUnit.Position.Y.Get()
            local real dX = targetSpotX - targetUnitX
            local real dY = targetSpotY - targetUnitY
            if (Math.DistanceSquareByDeltas(dX, dY) > thistype.MAX_OFFSET_SQUARE) then
                local real angle = Math.AtanByDeltas(dY, dX)
                set targetOffsetX = thistype.MAX_OFFSET * Math.Cos(angle)
                set targetOffsetY = thistype.MAX_OFFSET * Math.Sin(angle)
            else
                set targetOffsetX = targetSpotX - targetUnitX
                set targetOffsetY = targetSpotY - targetUnitY
            endif
        else
            if (Meteorite.THIS_UNIT == NULL) then
                return
            endif
            if Meteorite.THIS_UNIT.Classes.Contains(UnitClass.DEAD) then
                return
            endif
            set targetOffsetX = 0.
            set targetOffsetY = 0.
            set targetUnit = Meteorite.THIS_UNIT
        endif
        set this.target = targetUnit
        set this.targetEffect = targetUnit.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.NORMAL)
        set this.targetOffsetX = targetOffsetX
        set this.targetOffsetY = targetOffsetY
        if targetUnit.Data.Integer.Table.Add(KEY_ARRAY, this) then
            call targetUnit.Event.Add(TARGET_DEATH_EVENT)
        endif
        call caster.Abilities.Add(Invulnerability.THIS_SPELL)
    endmethod
    eventMethod Event_EndCast
        local Unit caster = params.Unit.GetTrigger()
        local boolean success = params.Spell.IsChannelComplete()
        local thistype this = caster
        local Unit target = this.target
        local real targetOffsetX = this.targetOffsetX
        local real targetOffsetY = this.targetOffsetY
        call caster.Buffs.Remove(thistype.DUMMY_BUFF)
        if success then
            call caster.Effects.Create(thistype.CASTER_ARRIVAL_EFFECT_PATH, thistype.CASTER_ARRIVAL_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).DestroyTimed.Start(2.)
            call caster.Position.SetWithCollision(target.Position.X.Get() + targetOffsetX, target.Position.Y.Get() + targetOffsetY)
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        set thistype.TARGET_ITEM = params.Item.GetTarget()
        set thistype.TARGET_X = params.Spot.GetTargetX()
        set thistype.TARGET_Y = params.Spot.GetTargetY()
        call caster.Buffs.AddFresh(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Items_Misc
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.MAX_OFFSET_SQUARE = thistype.MAX_OFFSET * thistype.MAX_OFFSET
        set thistype.TARGET_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_TargetDeath)
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
scope rpgcam initializer Init
    globals
        private trigger thisTrig=null
    endglobals
    globals
        boolean RPG_CAM_ON = false
        real RPG_CAM_TIME
    endglobals
    private function Actions takes nothing returns nothing
        if RPG_CAM_ON then
            if (GetEventPlayerChatString()=="-rpgcam") then
                set RPG_CAM_ON = false
            endif
        else
            set RPG_CAM_ON = true
            set RPG_CAM_TIME = S2R(SubStringBJ(GetEventPlayerChatString(), 9, StringLength(GetEventPlayerChatString())) )
        endif
    endfunction
    
    private function Init takes nothing returns nothing
        set thisTrig = CreateTrigger(  )
        call TriggerRegisterPlayerChatEvent( thisTrig, Player(0), "-rpgcam ", false )
        call TriggerAddAction( thisTrig, function Actions )
    endfunction
endscope
    globals
        Rune RUNE = STRUCT_BASE
    endglobals
    struct Rune
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static Event RUNE_DEATH_EVENT
    static BoolExpr TARGET_FILTER
    static CustomDrop THIS_DROP
    static integer SPAWN_AMOUNT = ARRAY_MIN
    Timer durationTimer
    Item rune
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_ItemUse
        local Unit target
        local Item whichItem = params.Item.GetTrigger()
        local Unit whichUnit = params.Unit.GetTrigger()
        local real whichItemX = whichItem.Position.GetX()
        local real whichItemY = whichItem.Position.GetY()
        call Spot.CreateEffect(whichItemX, whichItemY, thistype.AREA_EFFECT_PATH, EffectLevel.NORMAL).Destroy()
        set User.TEMP = whichUnit.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(whichItemX, whichItemY, thistype.AREA_RANGE, thistype.TARGET_FILTER)
        set target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            loop
                call target.HealBySpell(target, target.MaxLife.Get() * thistype.HEAL_LIFE_RELATIVE_AMOUNT)
                call target.Mana.Add(target.MaxMana.Get() * thistype.HEAL_MANA_RELATIVE_AMOUNT)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    method Ending takes Timer durationTimer, Item rune returns nothing
        call durationTimer.Destroy()
        call rune.Data.Integer.Remove(KEY)
        call rune.Event.Remove(RUNE_DEATH_EVENT)
		call this.deallocate()
    endmethod
    timerMethod EndingByTimer
        local Timer durationTimer = Timer.GetExpired()
        local thistype this = durationTimer.GetData()
        local Item rune = this.rune
        call this.Ending(durationTimer, rune)
        call rune.Kill()
    endmethod
    eventMethod Event_Rune_Death
        local Item rune = params.Item.GetTrigger()
        local thistype this = rune.Data.Integer.Get(KEY)
        call this.Ending(this.durationTimer, rune)
    endmethod
    eventMethod Event_Spawn_Death
        local Unit whichUnit = params.Unit.GetTrigger()
        if (params.Unit.GetKiller() == NULL) then
            return
        endif
        if (thistype.SPAWN_AMOUNT < thistype.SPAWN_AMOUNT_FOR_RUNE) then
            set thistype.SPAWN_AMOUNT = thistype.SPAWN_AMOUNT + 1
            return
        endif
        set thistype.SPAWN_AMOUNT = 0
        local thistype this = thistype.allocate()
		local Timer durationTimer = Timer.Create()
        local Item rune = Item.Create(thistype.THIS_ITEM, whichUnit.Position.X.Get(), whichUnit.Position.Y.Get())
        set this.durationTimer = durationTimer
        set this.rune = rune
        call durationTimer.SetData(this)
        call rune.Data.Integer.Set(KEY, this)
        call rune.Event.Add(RUNE_DEATH_EVENT)
        call durationTimer.Start(thistype.DURATION, false, function thistype.EndingByTimer)
    endmethod
    eventMethod Event_Spawn
        local Unit whichUnit = params.Unit.GetTrigger()
        call whichUnit.Drop.Add(thistype.THIS_DROP)
    endmethod
    initMethod Init of Misc_5
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        set thistype.THIS_DROP = CustomDrop.Create(Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.ITEMS, function thistype.Event_Spawn_Death), null, null, EffectLevel.NORMAL)
        set thistype.RUNE_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Rune_Death)
        call Event.Create(Spawn.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Spawn).AddToStatics()
        call thistype.THIS_ITEM.Event.Add(Event.Create(UNIT.Items.Events.Use.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_ItemUse))
    endmethod
endstruct
    globals
        Snowmen SNOWMEN = STRUCT_BASE
    endglobals
    struct Snowmen
        implement Allocation
        implement List
        
    static Event DEATH_EVENT
    static constant real DURATION = 30.
    static constant real DROP_INCREMENT = 0.25
    static constant real RED_INCREMENT = -128.
    static constant real GREEN_INCREMENT = 0.
    static constant real BLUE_INCREMENT = -255.
    static integer FLOWERS_AMOUNT = 0
    eventMethod Event_Death
        local Unit flower = params.Unit.GetTrigger()
        local real x = flower.Position.X.Get()
        local real y = flower.Position.Y.Get()
        call flower.Destroy()
        call Item.Create(thistype.THIS_ITEM_TYPE, x, y)
        set thistype.FLOWERS_AMOUNT = thistype.FLOWERS_AMOUNT - 1
        if (thistype.FLOWERS_AMOUNT == 0) then
            call Drop.SubtractSupplyFactor(thistype.DROP_INCREMENT)
            call Game.DisplayTextTimed(User.ANY, String.Color.Do("Notification:", String.Color.GOLD) + " " + String.Color.Do("You lost control of the last Flower. The spawns' supply loot is reset to the default value.", String.Color.MALUS), 10.)
        endif
    endmethod
    eventMethod Event_Use
        local Item seed = params.Item.GetTrigger()
        local real x = seed.Position.GetX()
        local real y = seed.Position.GetY()
        local Unit flower = Unit.Create(thistype.THIS_UNIT_TYPE, User.CASTLE, x, y, UNIT.Facing.STANDARD)
        call flower.Event.Add(DEATH_EVENT)
        call flower.Abilities.Add(Invulnerability.THIS_SPELL)
        call flower.Abilities.AddWithLevel(RevealAura.THIS_SPELL, 2)
        call flower.Animation.Set(Animation.BIRTH)
        call flower.Animation.Queue(Animation.STAND)
        call flower.Buffs.Timed.Start(thistype.POSSESSION_BUFF, 1, thistype.DURATION + 0.01)
        call flower.Effects.Create(thistype.DEATH_EFFECT_PATH, thistype.DEATH_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).DestroyTimed.Start(2.)
        call flower.ApplyTimedLife(thistype.DURATION)
        set thistype.FLOWERS_AMOUNT = thistype.FLOWERS_AMOUNT + 1
        if (thistype.FLOWERS_AMOUNT == 1) then
            call Drop.AddSupplyFactor(thistype.DROP_INCREMENT)
            call Game.DisplayTextTimed(User.ANY, String.Color.Do("Notification:", String.Color.GOLD) + " " + String.Color.Do("You got control of a Flower, all enemy units drop " + Real.ToIntString(thistype.DROP_INCREMENT * 100.) + Char.PERCENT + " more supply.", String.Color.BONUS), 10.)
        endif
    endmethod
    eventMethod Event_Create
        call params.Item.GetTrigger().SetInvulnerable(true)
    endmethod
    initMethod Init of Misc
        set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Death)
        call thistype.THIS_ITEM_TYPE.Event.Add(Event.Create(Item.CREATE_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Create))
        call thistype.THIS_ITEM_TYPE.Event.Add(Event.Create(UNIT.Items.Events.Use.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Use))
    endmethod
endstruct
globals
    constant integer SpawnLocation_MAX_Wrapped = 4
endglobals
    globals
        SpawnLocation SPAWN_LOCATION = STRUCT_BASE
    endglobals
    struct SpawnLocation
        implement Allocation
        implement List
        
    static integer ALL_AMOUNT = 0
    static thistype BOTTOM
    static thistype LEFT
    static thistype RIGHT
    real angle
    real maxX
    real maxY
    real minX
    real minY
    static method Create takes Rectangle source returns thistype
        local Waypoint sourceWaypoint = Waypoint.GetFromSource(source)
        local real x = source.GetCenterX()
        local real y = source.GetCenterY()
        local Waypoint targetWaypoint = sourceWaypoint.GetNext()
		local thistype this = thistype.allocate()
        set this.angle = Math.AtanByDeltas(targetWaypoint.GetCenterY() - y, targetWaypoint.GetCenterX() - x)
        set this.maxX = source.GetMaxX()
        set this.maxY = source.GetMaxY()
        set this.minX = source.GetMinX()
        set this.minY = source.GetMinY()
        set thistype.ALL_AMOUNT = thistype.ALL_AMOUNT + 1
        call this.AddToList()
        return this
    endmethod
    static method Init takes nothing returns nothing
        set thistype.BOTTOM = thistype.Create(Rectangle.CreateFromSelf(gg_rct_SpawnBottomIn))
        set thistype.LEFT = thistype.Create(Rectangle.CreateFromSelf(gg_rct_SpawnLeftIn))
        set thistype.RIGHT = thistype.Create(Rectangle.CreateFromSelf(gg_rct_SpawnRightIn))
    endmethod
endstruct
    scope FolderSpawnGroup
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return SpawnGroup(this).Data.table.IntegerKeys.Table.ContainsInteger(SpawnGroup(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return SpawnGroup(this).Data.table.IntegerKeys.Table.CountIntegers(SpawnGroup(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return SpawnGroup(this).Data.table.IntegerKeys.Table.IsEmptyInteger(SpawnGroup(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return SpawnGroup(this).Data.table.IntegerKeys.Table.GetInteger(SpawnGroup(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return SpawnGroup(this).Data.table.IntegerKeys.Table.GetFirstInteger(SpawnGroup(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return SpawnGroup(this).Data.table.IntegerKeys.Table.GetLastInteger(SpawnGroup(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call SpawnGroup(this).Data.table.IntegerKeys.Table.Clear(SpawnGroup(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return SpawnGroup(this).Data.table.IntegerKeys.Table.FetchFirstInteger(SpawnGroup(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return SpawnGroup(this).Data.table.IntegerKeys.Table.RemoveInteger(SpawnGroup(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return SpawnGroup(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(SpawnGroup(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return SpawnGroup(this).Data.table.IntegerKeys.Table.AddInteger(SpawnGroup(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return SpawnGroup(this).Data.table.IntegerKeys.Table.AddIntegerMulti(SpawnGroup(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call SpawnGroup(this).Data.table.IntegerKeys.Table.JoinInteger(SpawnGroup(this).Id.Get(), key, SpawnGroup(other).Data.table, SpawnGroup(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return SpawnGroup(this).Data.table.IntegerKeys.Table.RandomInteger(SpawnGroup(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call SpawnGroup(this).Data.table.IntegerKeys.Table.ShuffleIntegers(SpawnGroup(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call SpawnGroup(this).Data.table.IntegerKeys.Table.PrintIntegers(SpawnGroup(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return SpawnGroup(this).Data.table.IntegerKeys.GetInteger(SpawnGroup(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call SpawnGroup(this).Data.table.IntegerKeys.RemoveInteger(SpawnGroup(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call SpawnGroup(this).Data.table.IntegerKeys.SetInteger(SpawnGroup(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(SpawnGroup(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject SpawnGroup.Allocation.deallocate_demount.hook
		call SpawnGroup(this).Data.Destroy()
	endinject
	inject SpawnGroup.Allocation.allocate_mount.hook
		call SpawnGroup(this).Data.Event_Create()
	endinject
    endstruct
endscope
    globals
        SpawnGroup SPAWN_GROUP = STRUCT_BASE
    endglobals
    struct SpawnGroup
        implement Allocation
        implement List
        
    static key GetKeyMacro_LOCATIONS_KEY_ARRAY
    static constant integer LOCATIONS_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_LOCATIONS_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_TYPE_AMOUNT_KEY_ARRAY_DETAIL
    static constant integer TYPE_AMOUNT_KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_TYPE_AMOUNT_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_TYPES_KEY_ARRAY
    static constant integer TYPES_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_TYPES_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    FolderSpawnGroup_StructData Data = this
    FolderSpawnGroup_StructData LinkToStruct_Data
    FolderSpawnGroup_StructId Id = this
    FolderSpawnGroup_StructId LinkToStruct_Id
    method CountLocations takes nothing returns integer
        return this.Data.Integer.Table.Count(LOCATIONS_KEY_ARRAY)
    endmethod
    method GetLocation takes integer index returns SpawnLocation
        return this.Data.Integer.Table.Get(LOCATIONS_KEY_ARRAY, index)
    endmethod
    method AddLocation takes SpawnLocation whichLocation returns nothing
        call this.Data.Integer.Table.Add(LOCATIONS_KEY_ARRAY, whichLocation)
    endmethod
    method CountTypes takes nothing returns integer
        return this.Data.Integer.Table.Count(TYPES_KEY_ARRAY)
    endmethod
    method GetType takes integer index returns SpawnType
        return this.Data.Integer.Table.Get(TYPES_KEY_ARRAY, index)
    endmethod
    method GetTypeAmount takes SpawnType whichType returns integer
        return this.Data.Integer.Get(TYPE_AMOUNT_KEY_ARRAY_DETAIL + whichType)
    endmethod
    method AddType takes SpawnType whichType, integer amount returns nothing
        call this.Data.Integer.Set(TYPE_AMOUNT_KEY_ARRAY_DETAIL + whichType, amount)
        call this.Data.Integer.Table.Add(TYPES_KEY_ARRAY, whichType)
    endmethod
    static method Create takes nothing returns thistype
        local thistype this = thistype.allocate()
        call this.Id.Event_Create()
        call this.AddLocation(SpawnLocation.LEFT)
        call this.AddLocation(SpawnLocation.RIGHT)
        call this.AddLocation(SpawnLocation.BOTTOM)
        return this
    endmethod
endstruct
    scope FolderSpawnWave
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return SpawnWave(this).Data.table.IntegerKeys.Table.ContainsInteger(SpawnWave(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return SpawnWave(this).Data.table.IntegerKeys.Table.CountIntegers(SpawnWave(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return SpawnWave(this).Data.table.IntegerKeys.Table.IsEmptyInteger(SpawnWave(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return SpawnWave(this).Data.table.IntegerKeys.Table.GetInteger(SpawnWave(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return SpawnWave(this).Data.table.IntegerKeys.Table.GetFirstInteger(SpawnWave(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return SpawnWave(this).Data.table.IntegerKeys.Table.GetLastInteger(SpawnWave(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call SpawnWave(this).Data.table.IntegerKeys.Table.Clear(SpawnWave(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return SpawnWave(this).Data.table.IntegerKeys.Table.FetchFirstInteger(SpawnWave(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return SpawnWave(this).Data.table.IntegerKeys.Table.RemoveInteger(SpawnWave(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return SpawnWave(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(SpawnWave(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return SpawnWave(this).Data.table.IntegerKeys.Table.AddInteger(SpawnWave(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return SpawnWave(this).Data.table.IntegerKeys.Table.AddIntegerMulti(SpawnWave(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call SpawnWave(this).Data.table.IntegerKeys.Table.JoinInteger(SpawnWave(this).Id.Get(), key, SpawnWave(other).Data.table, SpawnWave(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return SpawnWave(this).Data.table.IntegerKeys.Table.RandomInteger(SpawnWave(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call SpawnWave(this).Data.table.IntegerKeys.Table.ShuffleIntegers(SpawnWave(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call SpawnWave(this).Data.table.IntegerKeys.Table.PrintIntegers(SpawnWave(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return SpawnWave(this).Data.table.IntegerKeys.GetInteger(SpawnWave(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call SpawnWave(this).Data.table.IntegerKeys.RemoveInteger(SpawnWave(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call SpawnWave(this).Data.table.IntegerKeys.SetInteger(SpawnWave(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderReal
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, real value returns boolean
        return SpawnWave(this).Data.table.IntegerKeys.Table.ContainsReal(SpawnWave(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return SpawnWave(this).Data.table.IntegerKeys.Table.CountReals(SpawnWave(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return SpawnWave(this).Data.table.IntegerKeys.Table.IsEmptyReal(SpawnWave(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns real
        return SpawnWave(this).Data.table.IntegerKeys.Table.GetReal(SpawnWave(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns real
        return SpawnWave(this).Data.table.IntegerKeys.Table.GetFirstReal(SpawnWave(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns real
        return SpawnWave(this).Data.table.IntegerKeys.Table.GetLastReal(SpawnWave(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call SpawnWave(this).Data.table.IntegerKeys.Table.Clear(SpawnWave(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns real
        return SpawnWave(this).Data.table.IntegerKeys.Table.FetchFirstReal(SpawnWave(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, real value returns boolean
        return SpawnWave(this).Data.table.IntegerKeys.Table.RemoveReal(SpawnWave(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return SpawnWave(this).Data.table.IntegerKeys.Table.RemoveRealByIndex(SpawnWave(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, real value returns boolean
        return SpawnWave(this).Data.table.IntegerKeys.Table.AddReal(SpawnWave(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, real value returns boolean
        return SpawnWave(this).Data.table.IntegerKeys.Table.AddRealMulti(SpawnWave(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call SpawnWave(this).Data.table.IntegerKeys.Table.JoinReal(SpawnWave(this).Id.Get(), key, SpawnWave(other).Data.table, SpawnWave(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns real
        return SpawnWave(this).Data.table.IntegerKeys.Table.RandomReal(SpawnWave(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns real
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call SpawnWave(this).Data.table.IntegerKeys.Table.ShuffleIntegers(SpawnWave(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call SpawnWave(this).Data.table.IntegerKeys.Table.PrintReals(SpawnWave(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructReal
        implement Allocation
        implement List
        
    FolderReal_StructTable Table = this
    FolderReal_StructTable LinkToStruct_Table
    method Get takes integer key returns real
        return SpawnWave(this).Data.table.IntegerKeys.GetReal(SpawnWave(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Real.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call SpawnWave(this).Data.table.IntegerKeys.RemoveReal(SpawnWave(this).Id.Get(), key)
    endmethod
    method Set takes integer key, real value returns nothing
        call SpawnWave(this).Data.table.IntegerKeys.SetReal(SpawnWave(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
    FolderData_StructReal Real = this
    FolderData_StructReal LinkToStruct_Real
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(SpawnWave(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject SpawnWave.Allocation.deallocate_demount.hook
		call SpawnWave(this).Data.Destroy()
	endinject
	inject SpawnWave.Allocation.allocate_mount.hook
		call SpawnWave(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructGroups
        implement Allocation
        implement List
        
    static key GetKeyMacro_DELAY_KEY_ARRAY_DETAIL
    static constant integer DELAY_KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_DELAY_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_TIMER_KEY_ARRAY_DETAIL
    static constant integer TIMER_KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_TIMER_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
        method Count takes nothing returns integer
            return SpawnWave(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns thistype
            return SpawnWave(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method GetDelay takes SpawnGroup whichGroup returns real
            return SpawnWave(this).Data.Real.Get(DELAY_KEY_ARRAY_DETAIL + whichGroup)
        endmethod
        method GetDelayTimer takes SpawnGroup whichGroup returns Timer
            return SpawnWave(this).Data.Integer.Get(TIMER_KEY_ARRAY_DETAIL + whichGroup)
        endmethod
        method Add takes SpawnGroup whichGroup, real delay returns nothing
            local SpawnWave parent = this
            
			local integer iteration = whichGroup.CountTypes()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local SpawnType whichType = whichGroup.GetType(iteration)
                if whichType.IsMelee() then
                    call parent.SetMelee(true)
                endif
                if whichType.IsRanged() then
                    call parent.SetRanged(true)
                endif
                if whichType.IsMagician() then
                    call parent.SetMagician(true)
                endif
                if whichType.IsRunner() then
                    call parent.SetRunner(true)
                endif
                if whichType.IsInvis() then
                    call parent.SetInvis(true)
                endif
                if whichType.IsMagicImmune() then
                    call parent.SetMagicImmune(true)
                endif
                if whichType.IsKamikaze() then
                    call parent.SetKamikaze(true)
                endif
                if whichType.IsBoss() then
                    call parent.SetBoss(true)
                endif
                set iteration = iteration - 1
            endloop
			local Timer delayTimer = Timer.Create()
            call delayTimer.SetData(whichGroup)
            call parent.SetGroupsDuration(delay)
            call parent.Data.Integer.Table.Add(KEY_ARRAY, whichGroup)
            call parent.Data.Real.Set(DELAY_KEY_ARRAY_DETAIL + whichGroup, delay)
            call parent.Data.Integer.Set(TIMER_KEY_ARRAY_DETAIL + whichGroup, delayTimer)
        endmethod
    endstruct
endscope
    globals
        SpawnWave SPAWN_WAVE = STRUCT_BASE
    endglobals
    struct SpawnWave
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static thistype array RUNNING_LIST_ALL
    static integer RUNNING_LIST_ALL_COUNT = ARRAY_EMPTY
    integer RUNNING_LIST_index
    static method RUNNING_LIST_Count takes nothing returns integer
        return thistype.RUNNING_LIST_ALL_COUNT
    endmethod
    static method RUNNING_LIST_IsEmpty takes nothing returns boolean
        return (thistype.RUNNING_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method RUNNING_LIST_Get takes integer index returns thistype
        return thistype.RUNNING_LIST_ALL[index]
    endmethod
    static method RUNNING_LIST_GetIndex takes thistype this returns integer
        return this.RUNNING_LIST_index
    endmethod
    static method RUNNING_LIST_Contains takes thistype this returns boolean
        return (thistype.RUNNING_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method RUNNING_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.RUNNING_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method RUNNING_LIST_RandomAll takes nothing returns thistype
        return thistype.RUNNING_LIST_Random(ARRAY_MIN, thistype.RUNNING_LIST_ALL_COUNT)
    endmethod
    static method RUNNING_LIST_Remove takes thistype this returns boolean
        if not thistype.RUNNING_LIST_Contains(this) then
            return false
        endif
        set thistype.RUNNING_LIST_ALL[thistype.RUNNING_LIST_ALL_COUNT].RUNNING_LIST_index = this.RUNNING_LIST_index
        set thistype.RUNNING_LIST_ALL[this.RUNNING_LIST_index - 1] = thistype.RUNNING_LIST_ALL[thistype.RUNNING_LIST_ALL_COUNT]
        set this.RUNNING_LIST_index = ARRAY_MIN
        set thistype.RUNNING_LIST_ALL_COUNT = thistype.RUNNING_LIST_ALL_COUNT - 1
        return (thistype.RUNNING_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method RUNNING_LIST_Add takes thistype this returns boolean
        if thistype.RUNNING_LIST_Contains(this) then
            return false
        endif
        set thistype.RUNNING_LIST_ALL_COUNT = thistype.RUNNING_LIST_ALL_COUNT + 1
        set thistype.RUNNING_LIST_ALL[thistype.RUNNING_LIST_ALL_COUNT] = this
        set this.RUNNING_LIST_index = thistype.RUNNING_LIST_ALL_COUNT + 1
        return (thistype.RUNNING_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static thistype array RUNNING_LIST_FOR_EACH_ALL
    static integer RUNNING_LIST_FOR_EACH_ALL_COUNT = ARRAY_EMPTY
    static method RUNNING_LIST_FOR_EACH_FetchFirst takes nothing returns thistype
        local thistype result
        if (thistype.RUNNING_LIST_FOR_EACH_ALL_COUNT < ARRAY_MIN) then
            return NULL
        endif
        set result = thistype.RUNNING_LIST_FOR_EACH_ALL[ARRAY_MIN]
        set thistype.RUNNING_LIST_FOR_EACH_ALL[ARRAY_MIN] = thistype.RUNNING_LIST_FOR_EACH_ALL[thistype.RUNNING_LIST_FOR_EACH_ALL_COUNT]
        set thistype.RUNNING_LIST_FOR_EACH_ALL_COUNT = thistype.RUNNING_LIST_FOR_EACH_ALL_COUNT - 1
        return result
    endmethod
    static method RUNNING_LIST_FOR_EACH_Set takes nothing returns nothing
        local integer iteration = thistype.RUNNING_LIST_ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.RUNNING_LIST_FOR_EACH_ALL[iteration] = thistype.RUNNING_LIST_ALL[iteration]
            set iteration = iteration - 1
        endloop
        set thistype.RUNNING_LIST_FOR_EACH_ALL_COUNT = thistype.RUNNING_LIST_ALL_COUNT
    endmethod
    Timer durationTimer
    Level whichLevel
    FolderSpawnWave_StructData Data = this
    FolderSpawnWave_StructData LinkToStruct_Data
    FolderSpawnWave_StructGroups Groups = this
    FolderSpawnWave_StructGroups LinkToStruct_Groups
    FolderSpawnWave_StructId Id = this
    FolderSpawnWave_StructId LinkToStruct_Id
    real duration
    method GetDuration takes nothing returns real
        return this.duration
    endmethod
    method SetDuration takes real value returns nothing
        set this.duration = value
    endmethod
    UnitType modelUnitType
    method GetModelUnitType takes nothing returns UnitType
        return this.modelUnitType
    endmethod
    method SetModelUnitType takes UnitType value returns nothing
        set this.modelUnitType = value
    endmethod
    boolean waitForClearance
    method IsWaitForClearance takes nothing returns boolean
        return this.waitForClearance
    endmethod
    method SetWaitForClearance takes boolean value returns nothing
        set this.waitForClearance = value
    endmethod
    real groupsDuration
    method GetGroupsDuration takes nothing returns real
        return this.groupsDuration
    endmethod
    method SetGroupsDuration takes real value returns nothing
        set this.groupsDuration = value
    endmethod
    real waitAfter
    method GetWaitAfter takes nothing returns real
        return this.waitAfter
    endmethod
    method SetWaitAfter takes real value returns nothing
        set this.waitAfter = value
    endmethod
    real waitBefore
    method GetWaitBefore takes nothing returns real
        return this.waitBefore
    endmethod
    method SetWaitBefore takes real value returns nothing
        set this.waitBefore = value
    endmethod
    boolean melee
    method IsMelee takes nothing returns boolean
        return this.melee
    endmethod
    method SetMelee takes boolean value returns nothing
        set this.melee = value
    endmethod
    boolean ranged
    method IsRanged takes nothing returns boolean
        return this.ranged
    endmethod
    method SetRanged takes boolean value returns nothing
        set this.ranged = value
    endmethod
    boolean magician
    method IsMagician takes nothing returns boolean
        return this.magician
    endmethod
    method SetMagician takes boolean value returns nothing
        set this.magician = value
    endmethod
    boolean runner
    method IsRunner takes nothing returns boolean
        return this.runner
    endmethod
    method SetRunner takes boolean value returns nothing
        set this.runner = value
    endmethod
    boolean invis
    method IsInvis takes nothing returns boolean
        return this.invis
    endmethod
    method SetInvis takes boolean value returns nothing
        set this.invis = value
    endmethod
    boolean magicImmune
    method IsMagicImmune takes nothing returns boolean
        return this.magicImmune
    endmethod
    method SetMagicImmune takes boolean value returns nothing
        set this.magicImmune = value
    endmethod
    boolean kamikaze
    method IsKamikaze takes nothing returns boolean
        return this.kamikaze
    endmethod
    method SetKamikaze takes boolean value returns nothing
        set this.kamikaze = value
    endmethod
    boolean boss
    method IsBoss takes nothing returns boolean
        return this.boss
    endmethod
    method SetBoss takes boolean value returns nothing
        set this.boss = value
    endmethod
    static method GetFromLevel takes Level whichLevel returns thistype
        return whichLevel.Data.Integer.Get(KEY)
    endmethod
    method GetDurationMax takes nothing returns real
        return Math.Max(this.GetDuration(), this.GetGroupsDuration())
    endmethod
    timerMethod GroupSpawn
        local SpawnGroup whichGroup = Timer.GetExpired().GetData()
        local integer iteration = whichGroup.CountLocations()
        loop
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            local SpawnLocation currentLocation = whichGroup.GetLocation(iteration)
            local real angle = currentLocation.angle
            local real maxX = currentLocation.maxX
            local real maxY = currentLocation.maxY
            local real minX = currentLocation.minX
            local real minY = currentLocation.minY
            local integer iteration2 = whichGroup.CountTypes()
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                local SpawnType whichType = whichGroup.GetType(iteration2)
                local integer amount = whichGroup.GetTypeAmount(whichType)
                loop
                    exitwhen (amount < 1)
                    call Spawn.AddNewQueued(whichType, whichType.GetType(), Math.Random(minX, maxX), Math.Random(minY, maxY), angle)
                    set amount = amount - 1
                endloop
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
    endmethod
    method Pause takes nothing returns nothing
        if (this == NULL) then
            return
        endif
        if not thistype.RUNNING_LIST_Contains(this) then
            return
        endif
        call thistype.RUNNING_LIST_Remove(this)
        local integer iteration = this.Groups.Count()
        loop
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            local SpawnGroup whichGroup = this.Groups.Get(iteration)
            call this.Groups.GetDelayTimer(whichGroup).Pause()
            call this.durationTimer.Pause()
            set iteration = iteration - 1
        endloop
    endmethod
    static method PauseAll takes nothing returns nothing
        call thistype.RUNNING_LIST_FOR_EACH_Set()
        loop
            local thistype this = thistype.RUNNING_LIST_FOR_EACH_FetchFirst()
            exitwhen (this == NULL)
            call this.Pause()
        endloop
    endmethod
    static method Ending takes nothing returns nothing
        local thistype this = Timer.GetExpired().GetData()
        call this.Pause()
    endmethod
    method Run takes nothing returns nothing
        call thistype.RUNNING_LIST_Add(this)
		local integer iteration = this.Groups.Count()
        loop
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            local SpawnGroup whichGroup = this.Groups.Get(iteration)
            call this.Groups.GetDelayTimer(whichGroup).Start(this.Groups.GetDelay(whichGroup), false, function thistype.GroupSpawn)
            call this.durationTimer.Start(this.GetDurationMax(), false, function thistype.Ending)
            set iteration = iteration - 1
        endloop
    endmethod
    method SetLevel takes Level value returns nothing
        set this.whichLevel = value
        call value.Data.Integer.Set(KEY, this)
    endmethod
    static method CreateFromLevel takes Level whichLevel returns thistype
        local thistype this = thistype.allocate()
		local Timer durationTimer = Timer.Create()
        set this.durationTimer = durationTimer
        call durationTimer.SetData(this)
        call this.Id.Event_Create()
        call this.SetDuration(30.)
        call this.SetLevel(whichLevel)
        call this.SetWaitAfter(0.)
        call this.SetWaitBefore(0.)
        call this.SetWaitForClearance(whichLevel == whichLevel.GetLevelSet().Levels.Get(whichLevel.GetLevelSet().Levels.Count()))
        return this
    endmethod
    static method Init_Deers takes nothing returns nothing
    	local thistype this = thistype.CreateFromLevel(Level.DEERS)
        local real delay = 0.
        local integer intervalsAmount = 7
        call this.SetModelUnitType(UnitType.DEER)
        loop
            exitwhen (intervalsAmount < 1)
            set delay = delay + 10.
            local SpawnGroup whichGroup = SpawnGroup.Create()
            call whichGroup.AddType(SpawnType.DEER, 2)
            call whichGroup.AddType(SpawnType.GNOLL_MAGE, 1)
            call this.Groups.Add(whichGroup, delay)
            set intervalsAmount = intervalsAmount - 1
        endloop
    endmethod
    static method Init_Trolls takes nothing returns nothing
        local thistype this = thistype.CreateFromLevel(Level.TROLLS)
        local real delay = 0.
        local integer intervalsAmount = 7
        call this.SetModelUnitType(UnitType.TROLL)
        loop
            exitwhen (intervalsAmount < 1)
            set delay = delay + 10.
            local SpawnGroup whichGroup = SpawnGroup.Create()
            call whichGroup.AddType(SpawnType.TROLL, 2)
            call whichGroup.AddType(SpawnType.TROLL_PRIEST, 1)
            call this.Groups.Add(whichGroup, delay)
            set intervalsAmount = intervalsAmount - 1
        endloop
    endmethod
    static method Init_Gnolls takes nothing returns nothing
    	local thistype this = thistype.CreateFromLevel(Level.GNOLLS)
        local real delay = 0.
        local integer intervalsAmount = 7
        call this.SetModelUnitType(UnitType.GNOLL_MAGE)
        set whichGroup = SpawnGroup.Create()
        call whichGroup.AddType(SpawnType.FURBOLG, 1)
        call this.Groups.Add(whichGroup, delay + 40.)
        loop
            exitwhen (intervalsAmount < 1)
            set delay = delay + 10.
            local SpawnGroup whichGroup = SpawnGroup.Create()
            call whichGroup.AddType(SpawnType.GNOLL_MAGE, 2)
            call this.Groups.Add(whichGroup, delay)
            set whichGroup = SpawnGroup.Create()
            call whichGroup.AddType(SpawnType.TROLL_PRIEST, 1)
            call this.Groups.Add(whichGroup, delay + 5.)
            set intervalsAmount = intervalsAmount - 1
        endloop
    endmethod
    static method Init_Wolves takes nothing returns nothing
        local thistype this = thistype.CreateFromLevel(Level.WOLVES)
        local real delay = 0.
        local integer intervalsAmount = 7
        call this.SetModelUnitType(UnitType.WOLF)
        local SpawnGroup whichGroup = SpawnGroup.Create()
        call whichGroup.AddType(SpawnType.FURBOLG, 1)
        call this.Groups.Add(whichGroup, delay + 30.)
        loop
            exitwhen (intervalsAmount < 1)
            set delay = delay + 10.
            set whichGroup = SpawnGroup.Create()
            call whichGroup.AddType(SpawnType.WOLF, 2)
            call whichGroup.AddType(SpawnType.TROLL_PRIEST, 1)
            call this.Groups.Add(whichGroup, delay)
            set intervalsAmount = intervalsAmount - 1
        endloop
    endmethod
    static method Init_Moonkins takes nothing returns nothing
        local thistype this = thistype.CreateFromLevel(Level.MOONKINS)
        local real delay = 0.
        local integer intervalsAmount = 7
        call this.SetModelUnitType(UnitType.MOONKIN)
        loop
            exitwhen (intervalsAmount < 1)
            set delay = delay + 10.
            local SpawnGroup whichGroup = SpawnGroup.Create()
            call whichGroup.AddType(SpawnType.MOONKIN, 2)
            call this.Groups.Add(whichGroup, delay)
            set intervalsAmount = intervalsAmount - 1
        endloop
    endmethod
    static method Init_SnowFalcons takes nothing returns nothing
        local thistype this = thistype.CreateFromLevel(Level.SNOW_FALCONS)
        local real delay = 0.
        local integer intervalsAmount = 7
        call this.SetModelUnitType(UnitType.SNOW_FALCON)
        loop
            exitwhen (intervalsAmount < 1)
            set delay = delay + 12.
            local SpawnGroup whichGroup = SpawnGroup.Create()
            call whichGroup.AddType(SpawnType.SNOW_FALCON, 2)
            call whichGroup.AddType(SpawnType.TREANT_PURPLE, 2)
            call this.Groups.Add(whichGroup, delay)
            set intervalsAmount = intervalsAmount - 1
        endloop
    endmethod
    static method Init_Kobolds takes nothing returns nothing
        local thistype this = thistype.CreateFromLevel(Level.WOLVES)
        local real delay = 0.
        local integer intervalsAmount = 7
        call this.SetModelUnitType(UnitType.KOBOLD_RED)
        local SpawnGroup whichGroup = SpawnGroup.Create()
        call whichGroup.AddType(SpawnType.FURBOLG, 1)
        call this.Groups.Add(whichGroup, delay + 30.)
        loop
            exitwhen (intervalsAmount < 1)
            set delay = delay + 10.
            set whichGroup = SpawnGroup.Create()
            call whichGroup.AddType(SpawnType.KOBOLD_RED, 4)
            call this.Groups.Add(whichGroup, delay)
            set intervalsAmount = intervalsAmount - 1
        endloop
        set delay = 0.
        set intervalsAmount = 2
        loop
            exitwhen (intervalsAmount < 1)
            set delay = delay + 25.
            set whichGroup = SpawnGroup.Create()
            call whichGroup.AddType(SpawnType.SATYR_CHAMP, 2)
            call this.Groups.Add(whichGroup, delay)
            set intervalsAmount = intervalsAmount - 1
        endloop
    endmethod
    static method Init_Treants takes nothing returns nothing
        local thistype this = thistype.CreateFromLevel(Level.TREANTS)
        local real delay = 0.
        local integer intervalsAmount = 7
        call this.SetModelUnitType(UnitType.TREANT_GREEN)
        loop
            exitwhen (intervalsAmount < 1)
            set delay = delay + 10.
            local SpawnGroup whichGroup = SpawnGroup.Create()
            call whichGroup.AddType(SpawnType.TREANT_PURPLE, 2)
            call whichGroup.AddType(SpawnType.TREANT_GREEN, 1)
            call this.Groups.Add(whichGroup, delay)
            set intervalsAmount = intervalsAmount - 1
        endloop
    endmethod
    static method Init_FurbolgOracle takes nothing returns nothing
        local thistype this = thistype.CreateFromLevel(Level.FURBOLG_ORACLE)
        local SpawnGroup whichGroup = SpawnGroup.Create()
        call whichGroup.AddType(SpawnType.FURBOLG_ORACLE, 1)
        call this.Groups.Add(whichGroup, 0.)
    endmethod
    static method Init_Penguins takes nothing returns nothing
        local thistype this = thistype.CreateFromLevel(Level.PENGUINS)
        local real delay = 10.
        local integer intervalsAmount = 7
		local SpawnGroup whichGroup
        loop
            exitwhen (intervalsAmount < 1)
            set delay = delay + 10.
            set whichGroup = SpawnGroup.Create()
            call whichGroup.AddType(SpawnType.PENGUIN, 2)
            call whichGroup.AddType(SpawnType.FLYING_PENGUIN, 1)
            call this.Groups.Add(whichGroup, delay)
            set intervalsAmount = intervalsAmount - 1
        endloop
        set whichGroup = SpawnGroup.Create()
        call whichGroup.AddType(SpawnType.PENGUIN_CHAMP, 1)
        call this.Groups.Add(whichGroup, 30.)
        call this.SetGroupsDuration(Intro.DURATION)
    endmethod
    static method Init takes nothing returns nothing
        
            call thistype.Init_Deers()
            call thistype.Init_Trolls()
            call thistype.Init_Gnolls()
            call thistype.Init_Wolves()
            call thistype.Init_Moonkins()
            call thistype.Init_SnowFalcons()
            call thistype.Init_Kobolds()
            call thistype.Init_Treants()
            call thistype.Init_FurbolgOracle()
       
        
            
            call thistype.Init_Penguins()
    endmethod
endstruct
    scope FolderSpawn
    public struct StructQueue
        implement Allocation
        implement List
        
        static constant real INTERVAL = 0.75
        static Timer INTERVAL_TIMER
    static thistype ACTIVE_QUEUE_LAST = NULL
    static thistype ACTIVE_QUEUE_NEXT = NULL
    thistype ACTIVE_QUEUE_next
    thistype ACTIVE_QUEUE_prev
    static method ACTIVE_QUEUE_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_QUEUE_NEXT == NULL)
    endmethod
    static method ACTIVE_QUEUE_Contains takes thistype this returns boolean
        if (thistype.ACTIVE_QUEUE_NEXT == this) then
            return true
        endif
        if ((this.ACTIVE_QUEUE_prev != NULL) or (this.ACTIVE_QUEUE_next != NULL)) then
            return true
        endif
        return false
    endmethod
    static method ACTIVE_QUEUE_Count takes nothing returns integer
        local integer iteration = ARRAY_EMPTY
        local thistype this = thistype.ACTIVE_QUEUE_NEXT
        loop
            exitwhen (this == NULL)
            set this = this.ACTIVE_QUEUE_next
            set iteration = iteration + 1
        endloop
        return iteration
    endmethod
    static method ACTIVE_QUEUE_Amount takes nothing returns integer
        return (thistype.ACTIVE_QUEUE_Count() - ARRAY_EMPTY)
    endmethod
    static method ACTIVE_QUEUE_GetIndex takes thistype this returns integer
        local integer iteration
        if (thistype.ACTIVE_QUEUE_Contains(this) == false) then
            return ARRAY_EMPTY
        endif
        set iteration = ARRAY_MIN
        loop
            set this = this.ACTIVE_QUEUE_prev
            exitwhen (this == NULL)
            set iteration = iteration + 1
        endloop
        return iteration
    endmethod
    static method ACTIVE_QUEUE_GetFirst takes nothing returns thistype
        return thistype.ACTIVE_QUEUE_NEXT
    endmethod
    static method ACTIVE_QUEUE_GetLast takes nothing returns thistype
        return thistype.ACTIVE_QUEUE_LAST
    endmethod
    static method ACTIVE_QUEUE_GetNext takes thistype this returns thistype
        return this.ACTIVE_QUEUE_next
    endmethod
    static method ACTIVE_QUEUE_GetPrev takes thistype this returns thistype
        return this.ACTIVE_QUEUE_prev
    endmethod
    static method ACTIVE_QUEUE_FetchFirst takes nothing returns thistype
        local thistype this = thistype.ACTIVE_QUEUE_NEXT
        if (this == NULL) then
            return NULL
        endif
        set thistype.ACTIVE_QUEUE_NEXT = this.ACTIVE_QUEUE_next
        set this.ACTIVE_QUEUE_next = NULL
        if (thistype.ACTIVE_QUEUE_NEXT == NULL) then
            set thistype.ACTIVE_QUEUE_LAST = NULL
        else
            set thistype.ACTIVE_QUEUE_NEXT.ACTIVE_QUEUE_prev = NULL
        endif
        return this
    endmethod
    static method ACTIVE_QUEUE_Remove takes thistype this returns boolean
        local thistype next
        local thistype prev
        if (thistype.ACTIVE_QUEUE_Contains(this) == false) then
            return false
        endif
        if (thistype.ACTIVE_QUEUE_NEXT == this) then
            call thistype.ACTIVE_QUEUE_FetchFirst()
            return thistype.ACTIVE_QUEUE_IsEmpty()
        endif
        set next = this.ACTIVE_QUEUE_next
        set prev = this.ACTIVE_QUEUE_prev
        if (prev != NULL) then
            set this.ACTIVE_QUEUE_prev = NULL
            set prev.ACTIVE_QUEUE_next = next
        endif
        if (next == NULL) then
            set thistype.ACTIVE_QUEUE_LAST = prev
        else
            set this.ACTIVE_QUEUE_next = NULL
            set next.ACTIVE_QUEUE_prev = prev
        endif
        return thistype.ACTIVE_QUEUE_IsEmpty()
    endmethod
    static method ACTIVE_QUEUE_Add takes thistype this returns boolean
        if thistype.ACTIVE_QUEUE_Contains(this) then
            return false
        endif
        set this.ACTIVE_QUEUE_next = NULL
        if (thistype.ACTIVE_QUEUE_NEXT == NULL) then
            set thistype.ACTIVE_QUEUE_LAST = this
            set thistype.ACTIVE_QUEUE_NEXT = this
            return true
        endif
        set this.ACTIVE_QUEUE_prev = thistype.ACTIVE_QUEUE_LAST
        set thistype.ACTIVE_QUEUE_LAST.ACTIVE_QUEUE_next = this
        set thistype.ACTIVE_QUEUE_LAST = this
        return false
    endmethod
        SpawnType whichType
        UnitType whichTypeUnitType
        real x
        real y
        real angle
        timerMethod Interval
            local thistype this = thistype.ACTIVE_QUEUE_FetchFirst()
            local SpawnType whichType = this.whichType
            local UnitType whichTypeUnitType = this.whichTypeUnitType
            local real x = this.x
            local real y = this.y
            local real angle = this.angle
            call this.deallocate()
            if thistype.ACTIVE_QUEUE_IsEmpty() then
                call thistype.INTERVAL_TIMER.Pause()
            endif
            call Spawn.AddNew(whichType, whichTypeUnitType, x, y, angle)
        endmethod
        static method Create takes SpawnType whichType, UnitType whichTypeUnitType, real x, real y, real angle returns nothing
            local thistype this = thistype.allocate()
            set this.whichType = whichType
            set this.whichTypeUnitType = whichTypeUnitType
            set this.x = x
            set this.y = y
            set this.angle = angle
            if thistype.ACTIVE_QUEUE_Add(this) then
                call thistype.INTERVAL_TIMER.Start(thistype.INTERVAL, true, function thistype.Interval)
            endif
        endmethod
        static method Init takes nothing returns nothing
            set thistype.INTERVAL_TIMER = Timer.Create()
        endmethod
    endstruct
    public struct StructShadow
        implement Allocation
        implement List
        
        static constant real REVIVE_INTERVAL = 1.25
        static Event DAMAGE_EVENT
        static Event DEATH_EVENT
        static Event DESTROY_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
        static Event IDLE_EVENT
        static Timer REVIVE_TIMER
        static Event SHADOW_DEATH_EVENT
        static Unit SPAWN
    static thistype REVIVE_QUEUE_LAST = NULL
    static thistype REVIVE_QUEUE_NEXT = NULL
    thistype REVIVE_QUEUE_next
    thistype REVIVE_QUEUE_prev
    static method REVIVE_QUEUE_IsEmpty takes nothing returns boolean
        return (thistype.REVIVE_QUEUE_NEXT == NULL)
    endmethod
    static method REVIVE_QUEUE_Contains takes thistype this returns boolean
        if (thistype.REVIVE_QUEUE_NEXT == this) then
            return true
        endif
        if ((this.REVIVE_QUEUE_prev != NULL) or (this.REVIVE_QUEUE_next != NULL)) then
            return true
        endif
        return false
    endmethod
    static method REVIVE_QUEUE_Count takes nothing returns integer
        local integer iteration = ARRAY_EMPTY
        local thistype this = thistype.REVIVE_QUEUE_NEXT
        loop
            exitwhen (this == NULL)
            set this = this.REVIVE_QUEUE_next
            set iteration = iteration + 1
        endloop
        return iteration
    endmethod
    static method REVIVE_QUEUE_Amount takes nothing returns integer
        return (thistype.REVIVE_QUEUE_Count() - ARRAY_EMPTY)
    endmethod
    static method REVIVE_QUEUE_GetIndex takes thistype this returns integer
        local integer iteration
        if (thistype.REVIVE_QUEUE_Contains(this) == false) then
            return ARRAY_EMPTY
        endif
        set iteration = ARRAY_MIN
        loop
            set this = this.REVIVE_QUEUE_prev
            exitwhen (this == NULL)
            set iteration = iteration + 1
        endloop
        return iteration
    endmethod
    static method REVIVE_QUEUE_GetFirst takes nothing returns thistype
        return thistype.REVIVE_QUEUE_NEXT
    endmethod
    static method REVIVE_QUEUE_GetLast takes nothing returns thistype
        return thistype.REVIVE_QUEUE_LAST
    endmethod
    static method REVIVE_QUEUE_GetNext takes thistype this returns thistype
        return this.REVIVE_QUEUE_next
    endmethod
    static method REVIVE_QUEUE_GetPrev takes thistype this returns thistype
        return this.REVIVE_QUEUE_prev
    endmethod
    static method REVIVE_QUEUE_FetchFirst takes nothing returns thistype
        local thistype this = thistype.REVIVE_QUEUE_NEXT
        if (this == NULL) then
            return NULL
        endif
        set thistype.REVIVE_QUEUE_NEXT = this.REVIVE_QUEUE_next
        set this.REVIVE_QUEUE_next = NULL
        if (thistype.REVIVE_QUEUE_NEXT == NULL) then
            set thistype.REVIVE_QUEUE_LAST = NULL
        else
            set thistype.REVIVE_QUEUE_NEXT.REVIVE_QUEUE_prev = NULL
        endif
        return this
    endmethod
    static method REVIVE_QUEUE_Remove takes thistype this returns boolean
        local thistype next
        local thistype prev
        if (thistype.REVIVE_QUEUE_Contains(this) == false) then
            return false
        endif
        if (thistype.REVIVE_QUEUE_NEXT == this) then
            call thistype.REVIVE_QUEUE_FetchFirst()
            return thistype.REVIVE_QUEUE_IsEmpty()
        endif
        set next = this.REVIVE_QUEUE_next
        set prev = this.REVIVE_QUEUE_prev
        if (prev != NULL) then
            set this.REVIVE_QUEUE_prev = NULL
            set prev.REVIVE_QUEUE_next = next
        endif
        if (next == NULL) then
            set thistype.REVIVE_QUEUE_LAST = prev
        else
            set this.REVIVE_QUEUE_next = NULL
            set next.REVIVE_QUEUE_prev = prev
        endif
        return thistype.REVIVE_QUEUE_IsEmpty()
    endmethod
    static method REVIVE_QUEUE_Add takes thistype this returns boolean
        if thistype.REVIVE_QUEUE_Contains(this) then
            return false
        endif
        set this.REVIVE_QUEUE_next = NULL
        if (thistype.REVIVE_QUEUE_NEXT == NULL) then
            set thistype.REVIVE_QUEUE_LAST = this
            set thistype.REVIVE_QUEUE_NEXT = this
            return true
        endif
        set this.REVIVE_QUEUE_prev = thistype.REVIVE_QUEUE_LAST
        set thistype.REVIVE_QUEUE_LAST.REVIVE_QUEUE_next = this
        set thistype.REVIVE_QUEUE_LAST = this
        return false
    endmethod
        Unit spawn
        method Destroy takes nothing returns nothing
            local Unit shadow = this
            call SpotEffect.Create(shadow.Position.X.Get(), shadow.Position.Y.Get(), "Objects\\Spawnmodels\\Undead\\UndeadDissipate\\UndeadDissipate.mdx", EffectLevel.LOW).Destroy()
            call shadow.Destroy()
        endmethod
        eventMethod Event_Destroy
            local Unit spawn = params.Unit.GetTrigger()
            local thistype this = spawn.Data.Integer.Get(KEY)
            call this.Destroy()
        endmethod
        eventMethod Event_Death
            local Unit spawn = params.Unit.GetTrigger()
            local thistype this = spawn.Data.Integer.Get(KEY)
            call this.Destroy()
        endmethod
        eventMethod Event_Damage
            local real damage = params.Real.GetDamage()
            local Unit shadow = params.Unit.GetDamager()
            local Unit target = params.Unit.GetTarget()
            local real burnedMana = Math.Min(target.Mana.Get(), damage)
call DebugEx("burn mana")
            call shadow.BurnManaBySpell(target, burnedMana)
            call params.Real.SetDamage(damage - burnedMana)
        endmethod
        timerMethod ReviveInterval
            local Unit shadow = thistype.REVIVE_QUEUE_FetchFirst()
            local thistype this = shadow
            if thistype.REVIVE_QUEUE_IsEmpty() then
                call thistype.REVIVE_TIMER.Pause()
            endif
            call ShowUnit(shadow.self, true)
            call shadow.Revival.Do()
            call shadow.Position.SetWithCollision(Meteorite.THIS_UNIT.Position.X.Get(), Meteorite.THIS_UNIT.Position.Y.Get())
            call shadow.Order.PointTarget(Order.ATTACK, this.spawn.Position.X.Get(), this.spawn.Position.Y.Get())
            call shadow.TimedLife.Start(60.)
        endmethod
        eventMethod Event_ShadowDeath
            local Unit shadow = params.Unit.GetTrigger()
            local thistype this = shadow
            call SpotEffect.Create(shadow.Position.X.Get(), shadow.Position.Y.Get(), "Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl", EffectLevel.LOW).Destroy()
            call shadow.Position.SetWithCollision(Meteorite.THIS_UNIT.Position.X.Get(), Meteorite.THIS_UNIT.Position.Y.Get())
            call ShowUnit(shadow.self, false)
            if thistype.REVIVE_QUEUE_Add(shadow) then
                call thistype.REVIVE_TIMER.Start(thistype.REVIVE_INTERVAL, true, function thistype.ReviveInterval)
            endif
        endmethod
        eventMethod Event_Idle
            local Unit shadow = params.Unit.GetTrigger()
            local thistype this = shadow
            call shadow.Order.PointTarget(Order.ATTACK, this.spawn.Position.X.Get(), this.spawn.Position.Y.Get())
        endmethod
        eventMethod Event_BuffLose
            local Unit shadow = params.Unit.GetTrigger()
            local thistype this = shadow
            local Unit spawn = this.spawn
            call shadow.Event.Remove(DAMAGE_EVENT)
            call shadow.Event.Remove(SHADOW_DEATH_EVENT)
            call shadow.Order.Events.Idle.Unreg(IDLE_EVENT)
            call spawn.Data.Integer.Remove(KEY)
            call spawn.Event.Remove(DEATH_EVENT)
            call spawn.Event.Remove(DESTROY_EVENT)
            if thistype.REVIVE_QUEUE_Remove(shadow) then
                call thistype.REVIVE_TIMER.Pause()
            endif
        endmethod
        eventMethod Event_BuffGain
            local Unit shadow = params.Unit.GetTrigger()
            local Unit spawn = thistype.SPAWN
            local thistype this = shadow
            set this.spawn = spawn
            call shadow.Event.Add(DAMAGE_EVENT)
            call shadow.Event.Add(SHADOW_DEATH_EVENT)
            call shadow.Order.Events.Idle.Reg(IDLE_EVENT)
            call spawn.Data.Integer.Set(KEY, this)
            call spawn.Event.Add(DEATH_EVENT)
            call spawn.Event.Add(DESTROY_EVENT)
        endmethod
        static method Create takes Unit spawn returns nothing
            local real x = Meteorite.THIS_UNIT.Position.X.Get()
            local real y = Meteorite.THIS_UNIT.Position.Y.Get()
            local Unit shadow = Unit.CreateSummon(spawn.Type.Get(), User.CREEP, x, y, UNIT.Facing.STANDARD, INFINITE_DURATION)
            set thistype.SPAWN = spawn
            call shadow.Buffs.Add(thistype.DUMMY_BUFF, 1)
            
            call shadow.Classes.Add(UnitClass.UNDECAYABLE)
            call shadow.Damage.Base.Subtract(shadow.Damage.Base.Get() / 2)
            call shadow.Drop.Supply.Set(1)
            call shadow.Ghost.Add()
            call shadow.MaxLife.Base.Subtract(shadow.MaxLife.Base.Get() / 4)
            call shadow.Movement.Speed.BaseA.Subtract(shadow.Movement.Speed.BaseA.Get() / 2)
            call shadow.Order.PointTarget(Order.ATTACK, spawn.Position.X.Get(), spawn.Position.Y.Get())
            call shadow.Pathing.Subtract()
            call shadow.Silence.Add()
            call shadow.VertexColor.Set(0.65 * 255, 0.25 * 255, 0.25 * 255, shadow.VertexColor.Alpha.Get())
            call shadow.TimedLife.Start(60.)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EDIT_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Damage)
            set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Death)
            set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Destroy)
            set thistype.IDLE_EVENT = Event.Create(UNIT.Order.Events.Idle.START_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Idle)
            set thistype.REVIVE_TIMER = Timer.Create()
            set thistype.SHADOW_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_ShadowDeath)
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_BuffLose))
        endmethod
    endstruct
endscope
    globals
        Spawn SPAWN = STRUCT_BASE
    endglobals
    struct Spawn
        implement Allocation
        implement List
        
    static UnitList ALL_GROUP
    static Event CLEAR_CHAT_EVENT
    static constant string CLEAR_INPUT = "-clear wave"
    static Event DESTROY_EVENT
    static EventType DUMMY_EVENT_TYPE
    static integer INTERVALS_AMOUNT
    static constant string REFRESH_EFFECT_ATTACH_POINT = AttachPoint.ORIGIN
    static constant string REFRESH_EFFECT_PATH = "Abilities\\Spells\\Items\\AIre\\AIreTarget.mdl"
    static Timer WAIT_TIMER
    static TimerDialog WAIT_TIMER_DIALOG
    FolderSpawn_StructQueue Queue = this
    FolderSpawn_StructQueue LinkToStruct_Queue
    FolderSpawn_StructShadow Shadow = this
    FolderSpawn_StructShadow LinkToStruct_Shadow
    static method RefreshHeroes takes nothing returns nothing
        local integer iteration = User.PLAYING_HUMANS_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local Unit whichUnit = User.PLAYING_HUMANS[iteration].Hero.Get()
			if (whichUnit != NULL) then
	            if whichUnit.Classes.Contains(UnitClass.DEAD) then
	                call whichUnit.Hero.Revive(whichUnit.Position.X.Get(), whichUnit.Position.Y.Get())
	            endif
	            call whichUnit.Effects.Create(thistype.REFRESH_EFFECT_PATH, thistype.REFRESH_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
	            call whichUnit.Life.Set(whichUnit.MaxLife.Get())
	            call whichUnit.Mana.Set(whichUnit.MaxMana.Get())
            endif
            set iteration = iteration - 1
        endloop
    endmethod
    eventMethod Event_ActEnding
        local Act whichAct = params.Act.GetTrigger()
        if (whichAct.IsBonus() and not whichAct.GetNext().IsBonus()) then
            call thistype.RemoveAllUnits()
            call thistype.RefreshHeroes()
        endif
    endmethod
    static method CheckForLevelEnding takes nothing returns nothing
        if SpawnWave.GetFromLevel(Level.CURRENT).IsWaitForClearance() then
            if (not thistype.ALL_GROUP.IsEmpty() or not SpawnWave.RUNNING_LIST_IsEmpty()) then
                return
            endif
        endif
        call Level.CURRENT.Ending()
    endmethod
    eventMethod Event_Destroy
        local Unit spawn = params.Unit.GetTrigger()
        call spawn.Event.Remove(DESTROY_EVENT)
        call thistype.ALL_GROUP.Remove(spawn)
        if SpawnWave.GetFromLevel(Level.CURRENT).IsWaitForClearance() then
            call thistype.CheckForLevelEnding()
        endif
    endmethod
    static method EndSpawn takes nothing returns nothing
        call thistype.CheckForLevelEnding()
    endmethod
    static method RemoveAllUnits takes nothing returns nothing
        loop
            local Unit spawn = thistype.ALL_GROUP.GetFirst()
            exitwhen (spawn == NULL)
            call spawn.Destroy()
        endloop
    endmethod
    static method Event_ClearChat takes nothing returns nothing
        call thistype.RemoveAllUnits()
    endmethod
    static method Add_TriggerEvents takes SpawnType whichType, Unit whichUnit returns nothing
        local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
        call params.SpawnType.SetTrigger(whichType)
        call params.Unit.SetTrigger(whichUnit)
		local EventResponse typeParams = EventResponse.Create(whichType.Id.Get())
        call typeParams.SpawnType.SetTrigger(whichType)
        call typeParams.Unit.SetTrigger(whichUnit)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = Event.CountAtStatics(thistype.DUMMY_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call Event.GetFromStatics(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration2 = whichType.Event.Count(thistype.DUMMY_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call whichType.Event.Get(thistype.DUMMY_EVENT_TYPE, priority, iteration2).Run(typeParams)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
        call typeParams.Destroy()
    endmethod
    static method AddNew takes SpawnType whichType, UnitType whichTypeUnitType, real x, real y, real angle returns nothing
        local real alpha = whichTypeUnitType.VertexColor.Alpha.Get()
        local real speed = whichTypeUnitType.Speed.Get()
        call whichTypeUnitType.Speed.Set(speed * 0.5)
        call whichTypeUnitType.VertexColor.Alpha.Set(0.)
        local Unit newUnit = Unit.Create(whichTypeUnitType, User.SPAWN, x, y, angle)
        call thistype.ALL_GROUP.Add(newUnit)
        call newUnit.Event.Add(DESTROY_EVENT)
        call newUnit.VertexColor.Timed.Add(0., 0., 0., alpha, 3.)
        call whichTypeUnitType.Speed.Set(speed)
        call whichTypeUnitType.VertexColor.Alpha.Set(alpha)
        if (Math.RandomI(1, 17) == 17) then
            call Tomes.RandomForUnit(newUnit)
        endif
        call thistype.Add_TriggerEvents(whichType, newUnit)
        call newUnit.Damage.Set(Difficulty.SELECTED.GetDamageFactor() * newUnit.Damage.Get())
        call newUnit.MaxLife.Set(Math.Max(UNIT.Life.LIMIT_OF_DEATH, Difficulty.SELECTED.GetLifeFactor() * newUnit.MaxLife.Get()))
        call newUnit.Life.Set(newUnit.MaxLife.Get())
        
    endmethod
    static method AddNewQueued takes SpawnType whichType, UnitType whichTypeUnitType, real x, real y, real angle returns nothing
        call thistype(NULL).Queue.Create(whichType, whichTypeUnitType, x, y, angle)
    endmethod
    eventMethod Event_GameOver
        call thistype.WAIT_TIMER.Pause()
        call SpawnWave.PauseAll()
    endmethod
    eventMethod Event_LevelEnding
        call SpawnWave.GetFromLevel(params.Level.GetTrigger()).Pause()
    endmethod
    eventMethod Event_LevelStart
        local Level whichLevel = params.Level.GetTrigger()
        local SpawnWave thisWave = SpawnWave.GetFromLevel(whichLevel)
        if (thisWave == NULL) then
            return
        endif
        local Level nextLevel = whichLevel.GetNext()
        local SpawnWave nextWave = SpawnWave.GetFromLevel(nextLevel)
        set thistype.INTERVALS_AMOUNT = 0
        if (nextLevel == NULL) then
            call thistype.WAIT_TIMER_DIALOG.Hide()
            call thistype.WAIT_TIMER.Start(thisWave.GetDurationMax() + thisWave.GetWaitAfter(), false, function thistype.EndSpawn)
        else
            if thisWave.IsWaitForClearance() then
                call thistype.WAIT_TIMER_DIALOG.Hide()
            else
                call thistype.WAIT_TIMER_DIALOG.SetTitle("Level " + nextLevel.GetName() + " begins in: ")
                
                call thistype.WAIT_TIMER.Start(thisWave.GetDurationMax() + thisWave.GetWaitAfter() + nextWave.GetWaitBefore(), false, function thistype.EndSpawn)
            endif
        endif
        call thisWave.Run()
    endmethod
    eventMethod Event_Start
        call Event.Create(Level.ENDING_EVENT_TYPE, EventPriority.MISC, function thistype.Event_LevelEnding).AddToStatics()
        call Event.Create(Level.START_EVENT_TYPE, EventPriority.MISC, function thistype.Event_LevelStart).AddToStatics()
    endmethod
    initMethod Init of Misc_4
        set thistype.ALL_GROUP = UnitList.Create()
        set thistype.CLEAR_CHAT_EVENT = Event.Create(User.CHAT_EVENT_TYPE, EventPriority.MISC, function thistype.Event_ClearChat)
        set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Destroy)
        set thistype.DUMMY_EVENT_TYPE = EventType.Create()
        set thistype.WAIT_TIMER = Timer.Create()
        call Event.Create(Act.ENDING_EVENT_TYPE, EventPriority.MISC, function thistype.Event_ActEnding).AddToStatics()
        call Event.Create(EventType.START, EventPriority.MISC, function thistype.Event_Start).AddToStatics()
        call Event.Create(Meteorite.GAME_OVER_EVENT_TYPE, EventPriority.MISC, function thistype.Event_GameOver).AddToStatics()
        set thistype.WAIT_TIMER_DIALOG = TimerDialog.CreateFromTimer(thistype.WAIT_TIMER)
        call StringData.Event.Add(thistype.CLEAR_INPUT, thistype.CLEAR_CHAT_EVENT)
        call thistype(NULL).Queue.Init()
        call thistype(NULL).Shadow.Init()
        call SpawnLocation.Init()
        call SpawnType.Init()
        call SpawnWave.Init()
    endmethod
endstruct
    scope FolderSpawnType
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return SpawnType(this).Data.table.IntegerKeys.Table.ContainsInteger(SpawnType(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return SpawnType(this).Data.table.IntegerKeys.Table.CountIntegers(SpawnType(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return SpawnType(this).Data.table.IntegerKeys.Table.IsEmptyInteger(SpawnType(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return SpawnType(this).Data.table.IntegerKeys.Table.GetInteger(SpawnType(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return SpawnType(this).Data.table.IntegerKeys.Table.GetFirstInteger(SpawnType(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return SpawnType(this).Data.table.IntegerKeys.Table.GetLastInteger(SpawnType(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call SpawnType(this).Data.table.IntegerKeys.Table.Clear(SpawnType(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return SpawnType(this).Data.table.IntegerKeys.Table.FetchFirstInteger(SpawnType(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return SpawnType(this).Data.table.IntegerKeys.Table.RemoveInteger(SpawnType(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return SpawnType(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(SpawnType(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return SpawnType(this).Data.table.IntegerKeys.Table.AddInteger(SpawnType(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return SpawnType(this).Data.table.IntegerKeys.Table.AddIntegerMulti(SpawnType(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call SpawnType(this).Data.table.IntegerKeys.Table.JoinInteger(SpawnType(this).Id.Get(), key, SpawnType(other).Data.table, SpawnType(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return SpawnType(this).Data.table.IntegerKeys.Table.RandomInteger(SpawnType(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call SpawnType(this).Data.table.IntegerKeys.Table.ShuffleIntegers(SpawnType(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call SpawnType(this).Data.table.IntegerKeys.Table.PrintIntegers(SpawnType(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return SpawnType(this).Data.table.IntegerKeys.GetInteger(SpawnType(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call SpawnType(this).Data.table.IntegerKeys.RemoveInteger(SpawnType(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call SpawnType(this).Data.table.IntegerKeys.SetInteger(SpawnType(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(SpawnType(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject SpawnType.Allocation.deallocate_demount.hook
		call SpawnType(this).Data.Destroy()
	endinject
	inject SpawnType.Allocation.allocate_mount.hook
		call SpawnType(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructEvent
        implement Allocation
        implement List
        
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(SpawnType(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(SpawnType(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(SpawnType(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(SpawnType(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(SpawnType(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(SpawnType(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(SpawnType(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(SpawnType(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject SpawnType.Allocation.deallocate_demount.hook
			call SpawnType(this).Event.Destroy()
		endinject
		inject SpawnType.Allocation.allocate_mount.hook
			call SpawnType(this).Event.Event_Create()
		endinject
    endstruct
    public struct StructChampion
        implement Allocation
        implement List
        
        static constant real DAMAGE_INCREMENT = 1.
        static constant real LIFE_INCREMENT = 1.
        static constant real SCALE_INCREMENT = 0.35
        static Event SPAWN_EVENT
        boolean flag
        eventMethod Event_Spawn
            local SpawnType whichType = params.SpawnType.GetTrigger()
            local Unit whichUnit = params.Unit.GetTrigger()
			call whichUnit.Armor.Spell.Add(0.25)
            call whichUnit.Abilities.AddWithLevel(MeteoriteProtection.THIS_SPELL, 2)
            
            
            
        endmethod
        method Is takes nothing returns boolean
            return this.flag
        endmethod
        method Set takes nothing returns nothing
            set this.flag = true
            call SpawnType(this).Event.Add(SPAWN_EVENT)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.SPAWN_EVENT = Event.Create(Spawn.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Spawn)
        endmethod
    endstruct
    public struct StructItems
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        static Event SPAWN_EVENT
        eventMethod Event_Spawn
            local SpawnType whichType = params.SpawnType.GetTrigger()
            local Unit whichUnit = params.Unit.GetTrigger()
            local thistype this = whichType
            local integer iteration = this.Count()
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                call whichUnit.Items.Add(this.Get(iteration))
                set iteration = iteration - 1
            endloop
            call whichUnit.Attachments.Add("Abilities\\Spells\\Orc\\CommandAura\\CommandAura.mdl", AttachPoint.ORIGIN, EffectLevel.NORMAL)
        endmethod
        method Count takes nothing returns integer
            return SpawnType(this).Data.Integer.Table.Count(KEY_ARRAY)
        endmethod
        method Get takes integer index returns ItemType
            return SpawnType(this).Data.Integer.Table.Get(KEY_ARRAY, index)
        endmethod
        method Add takes ItemType whichItemType returns nothing
            call SpawnType(this).Data.Integer.Table.Add(KEY_ARRAY, whichItemType)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.SPAWN_EVENT = Event.Create(Spawn.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Spawn)
        endmethod
    endstruct
endscope
    globals
        SpawnType SPAWN_TYPE = STRUCT_BASE
    endglobals
    struct SpawnType
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    
    static thistype FLYING_PENGUIN
    static thistype PENGUIN
    static thistype PENGUIN_CHAMP
    
    static thistype DEER
    static thistype FURBOLG
    static thistype FURBOLG_ORACLE
    static thistype GNOLL_MAGE
    static thistype KOBOLD_RED
    static thistype MOONKIN
    static thistype MOONKIN_CHAMP
    static thistype SATYR_CHAMP
    static thistype SNOW_FALCON
    static thistype TREANT_GREEN
    static thistype TREANT_PURPLE
    static thistype TROLL
    static thistype TROLL_PRIEST
    static thistype WOLF
    
    static thistype ASSASSIN
    static thistype AXE_FIGHTER
    static thistype BALDUIR
    static thistype CATAPULT
    static thistype DEMOLISHER
    static thistype DRUMMER_CHAMP
    static thistype LEADER
    static thistype PEON
    static thistype RAIDER
    static thistype SPEAR_SCOUT
    static thistype WINGED_SCOUT
    static constant real STANDARD_MANA = 100.
    static constant real STANDARD_MANA_REGENERATION = 2.
    UnitType whichUnitType
    FolderSpawnType_StructChampion Champion = this
    FolderSpawnType_StructChampion LinkToStruct_Champion
    FolderSpawnType_StructData Data = this
    FolderSpawnType_StructData LinkToStruct_Data
    FolderSpawnType_StructEvent Event = this
    FolderSpawnType_StructEvent LinkToStruct_Event
    FolderSpawnType_StructId Id = this
    FolderSpawnType_StructId LinkToStruct_Id
    FolderSpawnType_StructItems Items = this
    FolderSpawnType_StructItems LinkToStruct_Items
    boolean melee = false
    method IsMelee takes nothing returns boolean
        return this.melee
    endmethod
    method SetMelee takes boolean value returns nothing
        set this.melee = value
    endmethod
    boolean ranged = false
    method IsRanged takes nothing returns boolean
        return this.ranged
    endmethod
    method SetRanged takes boolean value returns nothing
        set this.ranged = value
    endmethod
    boolean magician = false
    method IsMagician takes nothing returns boolean
        return this.magician
    endmethod
    method SetMagician takes boolean value returns nothing
        set this.magician = value
    endmethod
    boolean runner = false
    method IsRunner takes nothing returns boolean
        return this.runner
    endmethod
    method SetRunner takes boolean value returns nothing
        set this.runner = value
    endmethod
    boolean invis = false
    method IsInvis takes nothing returns boolean
        return this.invis
    endmethod
    method SetInvis takes boolean value returns nothing
        set this.invis = value
    endmethod
    boolean magicImmune = false
    method IsMagicImmune takes nothing returns boolean
        return this.magicImmune
    endmethod
    method SetMagicImmune takes boolean value returns nothing
        set this.magicImmune = value
    endmethod
    boolean kamikaze = false
    method IsKamikaze takes nothing returns boolean
        return this.kamikaze
    endmethod
    method SetKamikaze takes boolean value returns nothing
        set this.kamikaze = value
    endmethod
    boolean boss = false
    method IsBoss takes nothing returns boolean
        return this.boss
    endmethod
    method SetBoss takes boolean value returns nothing
        set this.boss = value
    endmethod
    static method GetFromType takes UnitType whichUnitType returns thistype
        return whichUnitType.Data.Integer.Get(KEY)
    endmethod
    method GetType takes nothing returns UnitType
        return this.whichUnitType
    endmethod
    method AddGoldCoinDrop takes integer amount returns nothing
        call GoldCoin.AddToUnitType(this.whichUnitType, amount)
    endmethod
    static method Finalize takes nothing returns nothing
        local integer iteration = thistype.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local thistype this = thistype.ALL[iteration]
            local UnitType whichUnitType = this.GetType()
            call whichUnitType.Speed.Add(whichUnitType.Speed.Get() * 0.75)
            if this.IsBoss() then
                call whichUnitType.Abilities.Add(MeteoriteProtection.THIS_SPELL)
            endif
            if this.IsInvis() then
                call whichUnitType.Abilities.Add(Invisibility.THIS_SPELL)
            endif
            set iteration = iteration - 1
        endloop
    endmethod
    method SetType takes UnitType value returns nothing
        set this.whichUnitType = value
        call value.Data.Integer.Set(KEY, this)
    endmethod
    static method Create takes UnitType whichUnitType returns thistype
        local thistype this = thistype.allocate()
        call this.SetType(whichUnitType)
        call this.AddToList()
        call this.Id.Event_Create()
        return this
    endmethod
    static method Init takes nothing returns nothing
        local thistype this
        call thistype(NULL).Champion.Init()
        call thistype(NULL).Items.Init()
        
            
            set this = thistype.Create(UnitType.FLYING_PENGUIN)
            set thistype.FLYING_PENGUIN = this
            call this.SetRanged(true)
            
            set this = thistype.Create(UnitType.PENGUIN)
            set thistype.PENGUIN = this
            call this.SetMelee(true)
            
            set this = thistype.Create(UnitType.PENGUIN_CHAMP)
            set thistype.PENGUIN_CHAMP = this
            call this.Champion.Set()
            call this.SetMelee(true)
        
            
            set this = thistype.Create(UnitType.DEER)
            set thistype.DEER = this
            call this.SetMelee(true)
            
            set this = thistype.Create(UnitType.FURBOLG_MOTHER)
            set thistype.FURBOLG = this
            call this.AddGoldCoinDrop(100)
            call this.SetMelee(true)
            call this.Champion.Set()
            
            set this = thistype.Create(UnitType.FURBOLG_ORACLE)
            set thistype.FURBOLG_ORACLE = this
            call this.AddGoldCoinDrop(350)
            call this.SetBoss(true)
            call this.SetMelee(true)
            call this.SetMagician(true)
            
            set this = thistype.Create(UnitType.MOONKIN)
            set thistype.MOONKIN = this
            call this.SetMelee(true)
            
            set this = thistype.Create(UnitType.MOONKIN)
            set thistype.MOONKIN_CHAMP = this
            call this.Champion.Set()
            
            set this = thistype.Create(UnitType.GNOLL_MAGE)
            set thistype.GNOLL_MAGE = this
            call this.SetMagician(true)
            call this.SetRanged(true)
            
            set this = thistype.Create(UnitType.KOBOLD_RED)
            set thistype.KOBOLD_RED = this
            call this.SetMelee(true)
            
            set this = thistype.Create(UnitType.SATYR)
            set thistype.SATYR_CHAMP = this
            call this.Champion.Set()
            call this.SetMelee(true)
            
            set this = thistype.Create(UnitType.SNOW_FALCON)
            set thistype.SNOW_FALCON = this
            call this.SetRanged(true)
            
            set this = thistype.Create(UnitType.TREANT_GREEN)
            set thistype.TREANT_GREEN = this
            call this.SetMagician(true)
            call this.SetMelee(true)
            
            set this = thistype.Create(UnitType.TREANT_PURPLE)
            set thistype.TREANT_PURPLE = this
            call this.SetMelee(true)
            
            set this = thistype.Create(UnitType.TROLL)
            set thistype.TROLL = this
            call this.SetRanged(true)
            
            set this = thistype.Create(UnitType.TROLL_PRIEST)
            set thistype.TROLL_PRIEST = this
            call this.SetMagician(true)
            call this.SetRanged(true)
            
            set this = thistype.Create(UnitType.WOLF)
            set thistype.WOLF = this
            call this.SetMelee(true)
            call this.SetRunner(true)
        
            
            set this = thistype.Create(UnitType.ASSASSIN)
            set thistype.ASSASSIN = this
            call this.SetInvis(true)
            call this.SetMelee(true)
            
            set this = thistype.Create(UnitType.AXE_FIGHTER)
            set thistype.AXE_FIGHTER = this
            call this.SetMelee(true)
            
            set this = thistype.Create(UnitType.BALDUIR)
            set thistype.BALDUIR = this
            call this.AddGoldCoinDrop(200)
            
            set this = thistype.Create(UnitType.CATAPULT)
            set thistype.CATAPULT = this
            call this.SetMagicImmune(true)
            call this.SetRanged(true)
            
            set this = thistype.Create(UnitType.DEMOLISHER)
            set thistype.DEMOLISHER = this
            call this.SetBoss(true)
            call this.SetRanged(true)
            
            set this = thistype.Create(UnitType.DRUMMER)
            set thistype.DRUMMER_CHAMP = this
            call this.AddGoldCoinDrop(55)
            call this.Champion.Set()
            call this.SetRanged(true)
            
            set this = thistype.Create(UnitType.LEADER)
            set thistype.LEADER = this
            call this.SetBoss(true)
            call this.SetMelee(true)
            
            set this = thistype.Create(UnitType.PEON)
            set thistype.PEON = this
            call this.SetMelee(true)
            
            set this = thistype.Create(UnitType.RAIDER)
            set thistype.RAIDER = this
            call this.SetMelee(true)
            call this.SetRunner(true)
            
            set this = thistype.Create(UnitType.SPEAR_SCOUT)
            set thistype.SPEAR_SCOUT = this
            call this.SetRanged(true)
            
            set this = thistype.Create(UnitType.SPEAR_SCOUT)
            set thistype.WINGED_SCOUT = this
            call this.SetRanged(true)
        call thistype.Finalize()
    endmethod
endstruct
    globals
        StructInfo STRUCT_INFO = STRUCT_BASE
    endglobals
    struct StructInfo
        implement Allocation
        implement List
        
    static integer array SELECTABLE_ROWS
    static integer SELECTABLE_ROWS_COUNT = ARRAY_EMPTY
    static integer array SELECTABLE_ROWS_INDIZES
    static string array SELECTABLE_ROWS_LABEL
    static string array SELECTABLE_ROWS_VALUE
    static Multiboard THIS_BOARD = NULL
    static Timer UPDATE_TIMER
    static integer LABEL_COLUMN
    static integer VALUE_COLUMN
	static integer FIRST_STRUCT_ROW
	static integer HEAD_ROW
	static integer PAGE_ROW
	static constant real LABEL_COLUMN_WIDTH = 0.2
	static constant real VALUE_COLUMN_WIDTH = 0.05
    boolean active
    User owner
    integer pageIndex
    integer selectedRow
    integer selectedRowIndex
    Event downEvent
    Event leftEvent
    Event rightEvent
    Event upEvent
	method UpdatePageDisplay takes nothing returns nothing
		local integer pageRowIndex = thistype.SELECTABLE_ROWS_INDIZES[thistype.PAGE_ROW]
		call thistype.THIS_BOARD.SetValue(thistype.PAGE_ROW, thistype.LABEL_COLUMN, thistype.SELECTABLE_ROWS_LABEL[pageRowIndex])
		local integer index = this.pageIndex
		local string s = Integer.ToString(index + 1) + "/" + Integer.ToString(thistype.PAGES_COUNT + 1)
		set thistype.SELECTABLE_ROWS_VALUE[pageRowIndex] = s
		if (this.selectedRow == thistype.PAGE_ROW) then
			set s = String.If((index > 0), String.Color.Do("<<< ", String.Color.GOLD)) + String.Color.Do(s, String.Color.GREEN) + String.If((index < thistype.PAGES_COUNT), String.Color.Do(" >>>", String.Color.GOLD))
		endif
		call thistype.THIS_BOARD.SetValue(thistype.PAGE_ROW, thistype.VALUE_COLUMN, s)
	endmethod
    method DeselectRowByIndex takes integer index returns nothing
        if (index == ARRAY_EMPTY) then
            return
        endif
        local integer row = thistype.SELECTABLE_ROWS[index]
        if this.owner.IsLocal() then
            call thistype.THIS_BOARD.SetValue(row, thistype.LABEL_COLUMN, thistype.SELECTABLE_ROWS_LABEL[index])
            call thistype.THIS_BOARD.SetValue(row, thistype.VALUE_COLUMN, thistype.SELECTABLE_ROWS_VALUE[index])
        endif
    endmethod
    method SelectRowByIndex takes integer index returns nothing
        local integer oldRowIndex = this.selectedRowIndex
        if (index == oldRowIndex) then
            return
        endif
        call this.DeselectRowByIndex(oldRowIndex)
        set this.selectedRowIndex = index
		local integer whichRow
        if (index == ARRAY_EMPTY) then
            set whichRow = ARRAY_EMPTY
        else
            set whichRow = thistype.SELECTABLE_ROWS[index]
        endif
        set this.selectedRow = whichRow
        if (whichRow == ARRAY_EMPTY) then
            call MULTIBOARD.Shown.Control.PageSwitch.Activate(this.owner)
        else
            call MULTIBOARD.Shown.Control.PageSwitch.Deactivate(this.owner)
        endif
        if not this.owner.IsLocal() then
            return
        endif
        if (whichRow == thistype.PAGE_ROW) then
            call this.UpdatePageDisplay()
        endif
    endmethod
	static integer PAGES_COUNT
	static constant integer STRUCTS_PER_PAGE = 30
	method SetPage takes integer index returns nothing
		call thistype.THIS_BOARD.ClearVals()
		set this.pageIndex = index
		call this.UpdatePageDisplay()
		local integer i = ARRAY_MIN + index * thistype.STRUCTS_PER_PAGE
		local integer iEnd = ARRAY_MIN + (index + 1) * thistype.STRUCTS_PER_PAGE - 1
		local integer c = 0
		call thistype.THIS_BOARD.SetRowCount(thistype.FIRST_STRUCT_ROW + Math.MinI(thistype.STRUCTS_PER_PAGE, Basic.ALLOC_MODULES_COUNT - i + 1) - 1)
        call thistype.THIS_BOARD.Column.SetWidth(thistype.LABEL_COLUMN, thistype.LABEL_COLUMN_WIDTH)
        call thistype.THIS_BOARD.Column.SetWidth(thistype.VALUE_COLUMN, thistype.VALUE_COLUMN_WIDTH)
		
		
		loop
			exitwhen (i > iEnd)
			exitwhen (i > Basic.ALLOC_MODULES_COUNT)
			local integer moduleIndex = Basic.GetAllocModuleFromQueue(i)
			call thistype.THIS_BOARD.SetValue(thistype.FIRST_STRUCT_ROW + c, thistype.LABEL_COLUMN, Basic.GetAllocModuleName(moduleIndex))
			call thistype.THIS_BOARD.SetValue(thistype.FIRST_STRUCT_ROW + c, thistype.VALUE_COLUMN, Integer.ToString(Basic.GetAllocModuleAllocCount(moduleIndex)))
			set i = i + 1
			set c = c + 1
		endloop
	endmethod
	timerMethod UpdateByTimer
		local thistype this = thistype(User.GetLocal())
		if not this.active then
			return
		endif
		call this.SetPage(this.pageIndex)
	endmethod
    eventMethod Event_Left
        local real intervalWeight = params.Real.GetIntervalWeight()
        local User owner = params.User.GetTrigger()
        local thistype this = owner
        local integer whichRow = this.selectedRow
        if (whichRow == thistype.PAGE_ROW) then
            if (this.pageIndex > 0) then
            	call this.SetPage(this.pageIndex - 1)
            endif
        endif
        if not owner.IsLocal() then
            return
        endif
    endmethod
    eventMethod Event_Right
        local real intervalWeight = params.Real.GetIntervalWeight()
        local User owner = params.User.GetTrigger()
        local thistype this = owner
        local integer whichRow = this.selectedRow
        if (whichRow == thistype.PAGE_ROW) then
            if (this.pageIndex < thistype.PAGES_COUNT) then
            	call this.SetPage(this.pageIndex + 1)
            endif
        endif
        if not owner.IsLocal() then
            return
        endif
    endmethod
    eventMethod Event_Down
        local User owner = params.User.GetTrigger()
        local thistype this = owner
        if (this.selectedRowIndex == thistype.SELECTABLE_ROWS_COUNT) then
            call this.SelectRowByIndex(ARRAY_EMPTY)
        else
            call this.SelectRowByIndex(this.selectedRowIndex + 1)
        endif
    endmethod
    eventMethod Event_Up
        local User owner = params.User.GetTrigger()
        local thistype this = owner
        if (this.selectedRowIndex == ARRAY_EMPTY) then
            call this.SelectRowByIndex(thistype.SELECTABLE_ROWS_COUNT)
        else
            call this.SelectRowByIndex(this.selectedRowIndex - 1)
        endif
    endmethod
    method Deactivate takes nothing returns nothing
        local User owner = this.owner
        if not this.active then
            return
        endif
        set this.active = false
        call this.downEvent.Destroy()
        call this.leftEvent.Destroy()
        call this.rightEvent.Destroy()
        call this.upEvent.Destroy()
        call this.DeselectRowByIndex(this.selectedRowIndex)
    endmethod
    method Activate takes nothing returns nothing
        local User owner = this.owner
        if this.active then
            return
        endif
        set this.active = true
        set this.downEvent = owner.KeyEvent.DownArrow.RegisterPress(EventPriority.MISC, function thistype.Event_Down, 0.5, 1.)
        set this.leftEvent = owner.KeyEvent.LeftArrow.RegisterPress(EventPriority.MISC, function thistype.Event_Left, 0.125, 1.)
        set this.rightEvent = owner.KeyEvent.RightArrow.RegisterPress(EventPriority.MISC, function thistype.Event_Right, 0.125, 1.)
        set this.upEvent = owner.KeyEvent.UpArrow.RegisterPress(EventPriority.MISC, function thistype.Event_Up, 0.5, 1.)
        set this.selectedRow = ARRAY_EMPTY
        set this.selectedRowIndex = ARRAY_EMPTY
    endmethod
    static method Event_MultiboardChange takes Multiboard matchingBoard, User owner returns nothing
        local thistype this = owner
        if (matchingBoard == thistype.THIS_BOARD) then
            call this.Activate()
        else
            call this.Deactivate()
        endif
    endmethod
    static method Event_MultiboardControlDeactivate takes User owner returns nothing
        local thistype this = owner
        call this.Deactivate()
    endmethod
    static method Event_MultiboardControlActivate takes User owner returns nothing
        local thistype this = owner
        if (MULTIBOARD.Shown.GetCurrent(owner) == thistype.THIS_BOARD) then
            call this.Activate()
        endif
    endmethod
    static method Create takes User owner returns thistype
        local thistype this = owner
        set this.active = false
        set this.pageIndex = -1
        set this.owner = owner
        set this.selectedRow = ARRAY_EMPTY
        set this.selectedRowIndex = ARRAY_EMPTY
        call thistype.THIS_BOARD.Show(owner)
		call this.SetPage(40)
        return this
    endmethod
    eventMethod Event_AfterIntro
        call thistype.Create(params.User.GetTrigger())
    endmethod
    static method GetNewRow takes nothing returns integer
        return thistype.THIS_BOARD.GetNewRow()
    endmethod
    static method GetNewSelectableRow takes string label, string value returns integer
        local integer result = thistype.GetNewRow()
        set label = String.Color.Do(label, String.Color.GOLD)
        set thistype.SELECTABLE_ROWS_COUNT = thistype.SELECTABLE_ROWS_COUNT + 1
        call thistype.THIS_BOARD.SetValue(result, thistype.LABEL_COLUMN, label)
        call thistype.THIS_BOARD.SetValue(result, thistype.VALUE_COLUMN, value)
        set thistype.SELECTABLE_ROWS[thistype.SELECTABLE_ROWS_COUNT] = result
        set thistype.SELECTABLE_ROWS_INDIZES[result] = thistype.SELECTABLE_ROWS_COUNT
        set thistype.SELECTABLE_ROWS_LABEL[thistype.SELECTABLE_ROWS_COUNT] = label
        set thistype.SELECTABLE_ROWS_VALUE[thistype.SELECTABLE_ROWS_COUNT] = value
        return result
    endmethod
    eventMethod Event_Start
        set thistype.THIS_BOARD = Multiboard.Create()
        set thistype.LABEL_COLUMN = thistype.THIS_BOARD.GetNewColumn()
        set thistype.VALUE_COLUMN = thistype.THIS_BOARD.GetNewColumn()
		set thistype.PAGES_COUNT = Math.DivCeilI(Basic.ALLOC_MODULES_AMOUNT, thistype.STRUCTS_PER_PAGE) - 1
		
		
		set thistype.PAGE_ROW = thistype.GetNewSelectableRow("Page", "")
		set thistype.FIRST_STRUCT_ROW = thistype.THIS_BOARD.GetRowCount() + 2
        call thistype.THIS_BOARD.Column.SetWidth(thistype.LABEL_COLUMN, thistype.LABEL_COLUMN_WIDTH)
        call thistype.THIS_BOARD.Column.SetWidth(thistype.VALUE_COLUMN, thistype.VALUE_COLUMN_WIDTH)
        call thistype.THIS_BOARD.SetTitle("StructInfo")
        call Event.Create(AfterIntro.FOR_PLAYER_EVENT_TYPE, EventPriority.MISC, function thistype.Event_AfterIntro).AddToStatics()
		set thistype.UPDATE_TIMER = Timer.Create()
		call thistype.UPDATE_TIMER.Start(1., true, function thistype.UpdateByTimer)
    endmethod
    initMethod Init of Misc_2
        call Event.Create(EventType.START, EventPriority.MISC, function thistype.Event_Start).AddToStatics()
    endmethod
endstruct
    globals
        Tavern TAVERN = STRUCT_BASE
    endglobals
    struct Tavern
        implement Allocation
        implement List
        
endstruct
    globals
        TropicalRainbow TROPICAL_RAINBOW = STRUCT_BASE
    endglobals
    struct TropicalRainbow
        implement Allocation
        implement List
        
    eventMethod Event_SpellEffect
        call params.Unit.GetTrigger().Buffs.Timed.Start(thistype.DUMMY_BUFF, params.Spell.GetLevel(), thistype.DURATION)
    endmethod
    initMethod Init of Items_Misc
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    scope FolderTomes
    public struct StructAgi
        implement Allocation
        implement List
        
	    eventMethod Event_ItemUse
	        local Unit whichUnit = params.Unit.GetTrigger()
	        call whichUnit.Effects.Create(thistype.SPECIAL_EFFECT_PATH, thistype.SPECIAL_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
			call whichUnit.Agility.Base.Add(1)
	    endmethod
		static method Init takes nothing returns nothing
			call Tomes.Create(thistype.THIS_ITEM, function thistype.Event_ItemUse)
		endmethod
	endstruct
    public struct StructInt
        implement Allocation
        implement List
        
	    eventMethod Event_ItemUse
	        local Unit whichUnit = params.Unit.GetTrigger()
	        call whichUnit.Effects.Create(thistype.SPECIAL_EFFECT_PATH, thistype.SPECIAL_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
			call whichUnit.Intelligence.Base.Add(1)
	    endmethod
		static method Init takes nothing returns nothing
			call Tomes.Create(thistype.THIS_ITEM, function thistype.Event_ItemUse)
		endmethod
	endstruct
    public struct StructStr
        implement Allocation
        implement List
        
	    eventMethod Event_ItemUse
	        local Unit whichUnit = params.Unit.GetTrigger()
	        call whichUnit.Effects.Create(thistype.SPECIAL_EFFECT_PATH, thistype.SPECIAL_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
			call whichUnit.Strength.Base.Add(1)
	    endmethod
		static method Init takes nothing returns nothing
			call Tomes.Create(thistype.THIS_ITEM, function thistype.Event_ItemUse)
		endmethod
	endstruct
endscope
    globals
        Tomes TOMES = STRUCT_BASE
    endglobals
    struct Tomes
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static thistype array ALL_ALL
    static integer ALL_ALL_COUNT = ARRAY_EMPTY
    integer ALL_index
    static method ALL_Count takes nothing returns integer
        return thistype.ALL_ALL_COUNT
    endmethod
    static method ALL_IsEmpty takes nothing returns boolean
        return (thistype.ALL_Count() == ARRAY_EMPTY)
    endmethod
    static method ALL_Get takes integer index returns thistype
        return thistype.ALL_ALL[index]
    endmethod
    static method ALL_GetIndex takes thistype this returns integer
        return this.ALL_index
    endmethod
    static method ALL_Contains takes thistype this returns boolean
        return (thistype.ALL_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ALL_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ALL_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ALL_RandomAll takes nothing returns thistype
        return thistype.ALL_Random(ARRAY_MIN, thistype.ALL_ALL_COUNT)
    endmethod
    static method ALL_Remove takes thistype this returns boolean
        if not thistype.ALL_Contains(this) then
            return false
        endif
        set thistype.ALL_ALL[thistype.ALL_ALL_COUNT].ALL_index = this.ALL_index
        set thistype.ALL_ALL[this.ALL_index - 1] = thistype.ALL_ALL[thistype.ALL_ALL_COUNT]
        set this.ALL_index = ARRAY_MIN
        set thistype.ALL_ALL_COUNT = thistype.ALL_ALL_COUNT - 1
        return (thistype.ALL_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ALL_Add takes thistype this returns boolean
        if thistype.ALL_Contains(this) then
            return false
        endif
        set thistype.ALL_ALL_COUNT = thistype.ALL_ALL_COUNT + 1
        set thistype.ALL_ALL[thistype.ALL_ALL_COUNT] = this
        set this.ALL_index = thistype.ALL_ALL_COUNT + 1
        return (thistype.ALL_ALL_COUNT == ARRAY_MIN)
    endmethod
    CustomDrop drop
    FolderTomes_StructAgi Agi = this
    FolderTomes_StructAgi LinkToStruct_Agi
    FolderTomes_StructInt Int = this
    FolderTomes_StructInt LinkToStruct_Int
    FolderTomes_StructStr Str = this
    FolderTomes_StructStr LinkToStruct_Str
    eventMethod Event_Drop
        local Event dropEvent = Event.GetTrigger()
        local Unit whichUnit = params.Unit.GetTrigger()
        local thistype this = dropEvent.Data.Integer.Get(KEY)
        local ItemType whichItem = this
        call Item.Create(whichItem, whichUnit.Position.X.Get(), whichUnit.Position.Y.Get())
    endmethod
    static method RandomForUnit takes Unit target returns nothing
        local thistype this = thistype.ALL_RandomAll()
        call target.Drop.Add(this.drop)
    endmethod
    static method Create takes ItemType whichItem, code action returns nothing
        local thistype this = whichItem
        local Event dropEvent = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Drop)
        set this.drop = CustomDrop.Create(dropEvent, null, null, NULL)
        call dropEvent.Data.Integer.Set(KEY, this)
        call whichItem.Event.Add(Event.Create(UNIT.Items.Events.Use.DUMMY_EVENT_TYPE, EventPriority.MISC, action))
        call thistype.ALL_Add(this)
    endmethod
    initMethod Init of Misc
        call thistype(NULL).Agi.Init()
        call thistype(NULL).Int.Init()
        call thistype(NULL).Str.Init()
    endmethod
endstruct
    globals
        UnitNameTag UNIT_NAME_TAG = STRUCT_BASE
    endglobals
    struct UnitNameTag
        implement Allocation
        implement List
        
    static Event CREATE_EVENT
    static Event DESTROY_EVENT
    TextTag whichTag
    eventMethod Event_Destroy
        local Unit whichUnit = params.Unit.GetTrigger()
        local thistype this = whichUnit
        local TextTag whichTag = this.whichTag
        call whichUnit.Event.Remove(DESTROY_EVENT)
        call whichTag.Destroy()
    endmethod
    eventMethod Event_Create
        local TextTag whichTag = TextTag.Create(TextTag.GetFreeId())
        if (whichTag == NULL) then
            return
        endif
        local UnitType whichType = params.UnitType.GetTrigger()
        local Unit whichUnit = params.Unit.GetTrigger()
        call whichTag.Position.Set(whichUnit.Position.X.Get() + whichUnit.Outpact.X.Get(true), whichUnit.Position.Y.Get() + whichUnit.Outpact.Y.Get(true), whichUnit.Position.Z.Get() + whichUnit.Outpact.Z.Get(true))
        call whichTag.Position.SetCentered()
        call whichTag.Text.Set(String.Color.Gradient(whichType.GetName(), "ff77ffff", String.Color.DWC), TextTag.STANDARD_SIZE * 1.15)
        local thistype this = whichUnit
        set this.whichTag = whichTag
        call whichUnit.Event.Add(DESTROY_EVENT)
    endmethod
    static method Create takes UnitType whichType returns nothing
        call whichType.Event.Add(CREATE_EVENT)
    endmethod
    initMethod Init of Misc
        set thistype.CREATE_EVENT = Event.Create(Unit.CREATE_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Create)
        set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Destroy)
        call thistype.Create(GarbageCollector.SHOP)
        call thistype.Create(Library.SHOP)
        call thistype.Create(Pharmacy.SHOP)
        call thistype.Create(HorseRide.SHOP)
        call thistype.Create(Tavern.SHOP)
    endmethod
endstruct
    globals
        UnitStatus UNIT_STATUS = STRUCT_BASE
    endglobals
    struct UnitStatus
        implement Allocation
        implement List
        
    static Event ACQUIRE_EVENT
    static Unit LAST_TARGET
    static Unit array SELECTED_UNIT
    static constant real UPDATE_TIME = 0.125
    static integer LABEL_COLUMN
    static integer VALUE_COLUMN
    static integer ARMOR_ROW
    static integer ATTACK_SPEED_ROW
    static constant real BARS_UPDATE_LENGTH = (0.05 * 32) * thistype.UPDATE_TIME
    static integer CRITICAL_ROW
    static integer DAMAGE_ROW
    static integer EVASION_ROW
    static real LIFE_DISPLAYED = 0.
    static integer LIFE_REGENERATION_ROW
    static integer LIFE_ROW
    static constant integer LIFE_SEGMENTS_AMOUNT = 30
    static real MANA_DISPLAYED = 0.
    static integer MANA_REGENERATION_ROW
    static integer MANA_ROW
    static constant integer MANA_SEGMENTS_AMOUNT = 40
    static integer MOVEMENT_SPEED_ROW
    static integer NAME_ROW
    static integer SPELL_POWER_ROW
    static real STAMINA_DISPLAYED = 0.
    static integer STAMINA_REGENERATION_ROW
    static integer STAMINA_ROW
    static constant integer STAMINA_SEGMENTS_AMOUNT = 40
    static integer STATUS_LAST_BUFFS_COUNT = Memory.IntegerKeys.Table.EMPTY
    static integer STATUS_ROW
    static Multiboard THIS_BOARD
    eventMethod Event_TargetInRange
        if params.User.GetTrigger().IsLocal() then
            set thistype.LAST_TARGET = params.Unit.GetTarget()
        endif
    endmethod
    static method GetValueString takes real all, real bonus, integer decimals returns string
        local string color
        if (bonus < 0) then
            set color = String.Color.MALUS
        elseif (bonus > 0) then
            set color = String.Color.BONUS
        else
            set color = null
        endif
		local string result
        if (decimals == 0) then
            set result = Real.ToIntString(all)
        else
            set result = Real.ToStringWithDecimals(all, decimals)
        endif
        return String.Color.Do(result, color)
    endmethod
    static method UpdateArmor takes Unit whichUnit returns nothing
        call thistype.THIS_BOARD.SetValue(thistype.ARMOR_ROW, thistype.LABEL_COLUMN, "Armor: ")
        call thistype.THIS_BOARD.SetValue(thistype.ARMOR_ROW, thistype.VALUE_COLUMN, thistype.GetValueString(whichUnit.Armor.GetVisible(), whichUnit.Armor.GetVisibleBonus(), 1))
    endmethod
    static method UpdateAttackSpeed takes Unit whichUnit returns nothing
        call thistype.THIS_BOARD.SetValue(thistype.ATTACK_SPEED_ROW, thistype.LABEL_COLUMN, "Attack speed: ")
        call thistype.THIS_BOARD.SetValue(thistype.ATTACK_SPEED_ROW, thistype.VALUE_COLUMN, thistype.GetValueString(whichUnit.Attack.Speed.Get(), whichUnit.Attack.Speed.BonusA.Get(), 3))
    endmethod
    static method UpdateCritical takes Unit whichUnit returns nothing
        call thistype.THIS_BOARD.SetValue(thistype.CRITICAL_ROW, thistype.LABEL_COLUMN, "Critical: ")
        if (thistype.LAST_TARGET == NULL) then
            call thistype.THIS_BOARD.SetValue(thistype.CRITICAL_ROW, thistype.VALUE_COLUMN, thistype.GetValueString(whichUnit.CriticalChance.Get(), whichUnit.CriticalChance.Bonus.Get(), 0))
        else
            call thistype.THIS_BOARD.SetValue(thistype.CRITICAL_ROW, thistype.VALUE_COLUMN, thistype.GetValueString(whichUnit.CriticalChance.Get(), whichUnit.CriticalChance.Bonus.Get(), 0) + " (" + Real.ToIntString(whichUnit.CriticalChance.VsUnit(thistype.LAST_TARGET) * 100.) + Char.PERCENT + " vs " + thistype.LAST_TARGET.GetName() +")")
        endif
    endmethod
    static method UpdateDamage takes Unit whichUnit, UnitType whichUnitType returns nothing
        local real bonus = whichUnit.Damage.GetVisibleBonus()
        call thistype.THIS_BOARD.SetValue(thistype.DAMAGE_ROW, thistype.LABEL_COLUMN, "Damage: ")
        call thistype.THIS_BOARD.SetValue(thistype.DAMAGE_ROW, thistype.VALUE_COLUMN, thistype.GetValueString(whichUnit.Damage.GetVisible() + whichUnitType.Damage.Dices.Get(), bonus, 0) + " - " + thistype.GetValueString(whichUnit.Damage.GetVisible() + whichUnitType.Damage.Dices.Get() * whichUnitType.Damage.Sides.Get(), bonus, 0))
    endmethod
    static method UpdateEvasion takes Unit whichUnit returns nothing
        call thistype.THIS_BOARD.SetValue(thistype.EVASION_ROW, thistype.LABEL_COLUMN, "Evasion: ")
        if (thistype.LAST_TARGET == NULL) then
            call thistype.THIS_BOARD.SetValue(thistype.EVASION_ROW, thistype.VALUE_COLUMN, thistype.GetValueString(whichUnit.EvasionChance.Get(), whichUnit.EvasionChance.Bonus.Get(), 0))
        else
            call thistype.THIS_BOARD.SetValue(thistype.EVASION_ROW, thistype.VALUE_COLUMN, thistype.GetValueString(whichUnit.EvasionChance.Get(), whichUnit.EvasionChance.Bonus.Get(), 0) + " (" + Real.ToIntString(whichUnit.EvasionChance.VsUnit(thistype.LAST_TARGET) * 100.) + Char.PERCENT + " vs " + thistype.LAST_TARGET.GetName() +")")
        endif
    endmethod
    static method UpdateLife takes Unit whichUnit returns nothing
        local real maxValue = whichUnit.MaxLife.Get()
        if (maxValue < 1.) then
            set maxValue = 1.
        endif
        local real value = whichUnit.Life.Get()
        local real relative = value / maxValue
        set relative = thistype.LIFE_DISPLAYED + (relative - thistype.LIFE_DISPLAYED) * thistype.BARS_UPDATE_LENGTH
        set thistype.LIFE_DISPLAYED = relative
        local integer filledSegmentsAmount = Real.ToInt(relative * thistype.LIFE_SEGMENTS_AMOUNT)
        call thistype.THIS_BOARD.SetValue(thistype.LIFE_ROW, thistype.LABEL_COLUMN, String.Color.Do(String.Repeat("l", filledSegmentsAmount), String.IfElse(relative > 0.5, String.Color.RelativeTo(2. - 2. * relative, 1., 0., 1.), String.Color.RelativeTo(1., relative * 2., 0., 1.))) + String.Color.Do(String.Repeat("l", thistype.LIFE_SEGMENTS_AMOUNT - filledSegmentsAmount), String.Color.BLACK))
        call thistype.THIS_BOARD.SetValue(thistype.LIFE_ROW, thistype.VALUE_COLUMN, Real.ToIntString(value) + "/" + Real.ToIntString(maxValue))
    endmethod
    static method UpdateLifeRegeneration takes Unit whichUnit returns nothing
        call thistype.THIS_BOARD.SetValue(thistype.LIFE_REGENERATION_ROW, thistype.LABEL_COLUMN, "Life reg.: ")
        call thistype.THIS_BOARD.SetValue(thistype.LIFE_REGENERATION_ROW, thistype.VALUE_COLUMN, thistype.GetValueString(whichUnit.LifeRegeneration.Get(), whichUnit.LifeRegeneration.Bonus.Get(), 2))
    endmethod
    static method UpdateMana takes Unit whichUnit returns nothing
        local real maxValue = whichUnit.MaxMana.Get()
        if (maxValue < 1.) then
            set maxValue = 1.
        endif
        local real value = whichUnit.Mana.Get()
        local real relative = value / maxValue
        set relative = thistype.MANA_DISPLAYED + (relative - thistype.MANA_DISPLAYED) * thistype.BARS_UPDATE_LENGTH
        set thistype.MANA_DISPLAYED = relative
        local integer filledSegmentsAmount = Real.ToInt(relative * thistype.MANA_SEGMENTS_AMOUNT)
        call thistype.THIS_BOARD.SetValue(thistype.MANA_ROW, thistype.LABEL_COLUMN, String.Color.Do(String.Repeat("l", filledSegmentsAmount), String.Color.RelativeTo(Math.Max(relative, 0.5), 0., Math.Max(relative, 0.5), 1.)) + String.Color.Do(String.Repeat("l", thistype.LIFE_SEGMENTS_AMOUNT - filledSegmentsAmount), String.Color.BLACK))
        call thistype.THIS_BOARD.SetValue(thistype.MANA_ROW, thistype.VALUE_COLUMN, Real.ToIntString(value) + "/" + Real.ToIntString(maxValue))
    endmethod
    static method UpdateManaRegeneration takes Unit whichUnit returns nothing
        call thistype.THIS_BOARD.SetValue(thistype.MANA_REGENERATION_ROW, thistype.LABEL_COLUMN, "Mana reg.: ")
        call thistype.THIS_BOARD.SetValue(thistype.MANA_REGENERATION_ROW, thistype.VALUE_COLUMN, thistype.GetValueString(whichUnit.ManaRegeneration.Get(), whichUnit.ManaRegeneration.Bonus.Get(), 2))
    endmethod
    static method UpdateMovement takes Unit whichUnit returns nothing
        local real value = whichUnit.Movement.Speed.Get()
        local real realValue = whichUnit.Movement.Speed.StaminaReduce(value)
        local string valueString = thistype.GetValueString(value, whichUnit.Movement.Speed.GetBonus(), 0)
        if (realValue != value) then
            set valueString = valueString + " (" + String.Color.Do(Real.ToIntString(realValue), String.Color.GOLD) + ")"
        endif
        call thistype.THIS_BOARD.SetValue(thistype.MOVEMENT_SPEED_ROW, thistype.LABEL_COLUMN, "Move speed: ")
        call thistype.THIS_BOARD.SetValue(thistype.MOVEMENT_SPEED_ROW, thistype.VALUE_COLUMN, valueString)
    endmethod
    static method UpdateSpellPower takes Unit whichUnit returns nothing
        call thistype.THIS_BOARD.SetValue(thistype.SPELL_POWER_ROW, thistype.LABEL_COLUMN, "Spell power: ")
        call thistype.THIS_BOARD.SetValue(thistype.SPELL_POWER_ROW, thistype.VALUE_COLUMN, thistype.GetValueString(whichUnit.SpellPower.Get(), whichUnit.SpellPower.GetBonus(), 0))
    endmethod
    static method UpdateStamina takes Unit whichUnit returns nothing
        local real maxValue = whichUnit.MaxStamina.Get()
        if (maxValue < 1.) then
            set maxValue = 1.
        endif
        local real value = whichUnit.Stamina.Get()
        local real relative = value / maxValue
        set relative = thistype.STAMINA_DISPLAYED + (relative - thistype.STAMINA_DISPLAYED) * thistype.BARS_UPDATE_LENGTH
        set thistype.STAMINA_DISPLAYED = relative
        local integer filledSegmentsAmount = Real.ToInt(relative * thistype.STAMINA_SEGMENTS_AMOUNT)
        call thistype.THIS_BOARD.SetValue(thistype.STAMINA_ROW, thistype.LABEL_COLUMN, String.Color.Do(String.Repeat("l", filledSegmentsAmount), String.Color.RelativeTo(Math.Max(0.7, relative), Math.Max(0.7, relative), 0., 1.)) + String.Color.Do(String.Repeat("l", thistype.LIFE_SEGMENTS_AMOUNT - filledSegmentsAmount), String.Color.BLACK))
        call thistype.THIS_BOARD.SetValue(thistype.STAMINA_ROW, thistype.VALUE_COLUMN, Real.ToIntString(value) + "/" + Real.ToIntString(maxValue))
    endmethod
    static method UpdateStaminaRegeneration takes Unit whichUnit returns nothing
        call thistype.THIS_BOARD.SetValue(thistype.STAMINA_REGENERATION_ROW, thistype.LABEL_COLUMN, "Stamina reg.: ")
        call thistype.THIS_BOARD.SetValue(thistype.STAMINA_REGENERATION_ROW, thistype.VALUE_COLUMN, thistype.GetValueString(whichUnit.StaminaRegeneration.Get(), whichUnit.StaminaRegeneration.Bonus.Get(), 2))
    endmethod
    static method UpdateStatus takes Unit whichUnit returns nothing
        local integer count = whichUnit.Buffs.CountVisible()
        local integer iteration = thistype.STATUS_LAST_BUFFS_COUNT
        loop
            exitwhen (iteration <= count)
            call thistype.THIS_BOARD.SetIcon(thistype.STATUS_ROW, thistype.VALUE_COLUMN + iteration, null)
            call thistype.THIS_BOARD.SetWidth(thistype.STATUS_ROW, thistype.VALUE_COLUMN, 0.)
            set iteration = iteration - 1
        endloop
        set thistype.STATUS_LAST_BUFFS_COUNT = count
        call thistype.THIS_BOARD.SetValue(thistype.STATUS_ROW, thistype.LABEL_COLUMN, "Status: ")
        loop
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            local Buff whichBuff = whichUnit.Buffs.GetVisible(iteration)
            call thistype.THIS_BOARD.SetIcon(thistype.STATUS_ROW, thistype.VALUE_COLUMN + iteration, whichBuff.GetIcon())
            call thistype.THIS_BOARD.SetWidth(thistype.STATUS_ROW, thistype.VALUE_COLUMN, 0.01)
            set iteration = iteration - 1
        endloop
    endmethod
    static method Update takes nothing returns nothing
        local User whichPlayer = User.GetLocal()
        local Unit whichUnit = thistype.SELECTED_UNIT[whichPlayer.GetIndex()]
        local UnitType whichUnitType = whichUnit.Type.Get()
        call thistype.UpdateArmor(whichUnit)
        call thistype.UpdateAttackSpeed(whichUnit)
        
        call thistype.UpdateDamage(whichUnit, whichUnitType)
        
        call thistype.UpdateLife(whichUnit)
        call thistype.UpdateLifeRegeneration(whichUnit)
        call thistype.UpdateMana(whichUnit)
        call thistype.UpdateManaRegeneration(whichUnit)
        call thistype.UpdateMovement(whichUnit)
        call thistype.THIS_BOARD.SetValue(thistype.NAME_ROW, thistype.LABEL_COLUMN, String.Color.Do(whichUnit.GetName(), String.IfElse(whichUnit.IsAllyOf(whichPlayer) and (whichUnit.Owner.Get() != User.CASTLE), String.Color.GREEN, String.IfElse(whichUnit.IsEnemyOf(whichPlayer), String.Color.RED, String.Color.GOLD))))
        call thistype.UpdateSpellPower(whichUnit)
        call thistype.UpdateStamina(whichUnit)
        call thistype.UpdateStaminaRegeneration(whichUnit)
        call thistype.UpdateStatus(whichUnit)
    endmethod
    timerMethod UpdateByTimer
        call thistype.Update()
    endmethod
    static method SelectUnit takes User whichPlayer, Unit whichUnit returns nothing
        local integer whichPlayerIndex = whichPlayer.GetIndex()
        if (thistype.SELECTED_UNIT[whichPlayer] != NULL) then
            call whichUnit.Event.Counted.Subtract(ACQUIRE_EVENT)
        endif
        if whichPlayer.IsLocal() then
            set thistype.LAST_TARGET = NULL
        endif
        set thistype.SELECTED_UNIT[whichPlayerIndex] = whichUnit
        if (whichUnit == NULL) then
            return
        endif
        call whichUnit.Event.Counted.Add(ACQUIRE_EVENT)
    	set thistype.LIFE_DISPLAYED = Math.DivideInval(whichUnit.Life.Get(), whichUnit.MaxLife.Get(), 0.)
    	set thistype.MANA_DISPLAYED = Math.DivideInval(whichUnit.Mana.Get(), whichUnit.MaxMana.Get(), 0.)
    	set thistype.STAMINA_DISPLAYED = Math.DivideInval(whichUnit.Stamina.Get(), whichUnit.MaxStamina.Get(), 0.)
    endmethod
    eventMethod Event_Deselect
        local User whichPlayer = params.User.GetTrigger()
        local Unit whichUnit = params.Unit.GetTrigger()
        if (whichUnit.Selection.CountAtPlayer(whichPlayer) == Memory.IntegerKeys.Table.EMPTY) then
            set whichUnit = whichPlayer.Hero.Get()
            if (whichUnit != NULL) then
                if whichUnit.Classes.Contains(UnitClass.DEAD) then
                    set whichUnit = HeroRevival.GetGhostByUnit(whichUnit)
                endif
                call thistype.SelectUnit(whichPlayer, whichUnit)
            endif
        else
            call thistype.SelectUnit(whichPlayer, whichUnit.Selection.GetFromPlayer(whichPlayer, Memory.IntegerKeys.Table.STARTED))
        endif
    endmethod
    eventMethod Event_Select
        local User whichPlayer = params.User.GetTrigger()
        local Unit whichUnit = params.Unit.GetTrigger()
        call thistype.SelectUnit(whichPlayer, whichUnit)
        if whichPlayer.IsLocal() then
            call thistype.Update()
        endif
    endmethod
    static method GetNewRow takes nothing returns integer
        return thistype.THIS_BOARD.GetNewRow()
    endmethod
    eventMethod Event_HeroPick
        call thistype.THIS_BOARD.Show(params.User.GetTrigger())
    endmethod
    eventMethod Event_Start
        set thistype.ACQUIRE_EVENT = Event.Create(UNIT.Attack.Events.ACQUIRE_EVENT_TYPE, EventPriority.MISC, function thistype.Event_TargetInRange)
        set thistype.THIS_BOARD = Multiboard.Create()
        call Event.Create(HeroSelection.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_HeroPick).AddToStatics()
        call Event.Create(UNIT.Selection.ENDING_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Deselect).AddToStatics()
        call Event.Create(UNIT.Selection.START_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Select).AddToStatics()
        set thistype.LABEL_COLUMN = thistype.THIS_BOARD.GetNewColumn()
        set thistype.VALUE_COLUMN = thistype.THIS_BOARD.GetNewColumn()
        set thistype.NAME_ROW = thistype.GetNewRow()
        call thistype.GetNewRow()
        set thistype.LIFE_ROW = thistype.GetNewRow()
        set thistype.LIFE_REGENERATION_ROW = thistype.GetNewRow()
        set thistype.MANA_ROW = thistype.GetNewRow()
        set thistype.MANA_REGENERATION_ROW = thistype.GetNewRow()
        set thistype.STAMINA_ROW = thistype.GetNewRow()
        set thistype.STAMINA_REGENERATION_ROW = thistype.GetNewRow()
        call thistype.GetNewRow()
        set thistype.DAMAGE_ROW = thistype.GetNewRow()
        set thistype.SPELL_POWER_ROW = thistype.GetNewRow()
        set thistype.ARMOR_ROW = thistype.GetNewRow()
        
        
        set thistype.ATTACK_SPEED_ROW = thistype.GetNewRow()
        set thistype.MOVEMENT_SPEED_ROW = thistype.GetNewRow()
        call thistype.GetNewRow()
        set thistype.STATUS_ROW = thistype.GetNewRow()
        call thistype.THIS_BOARD.Column.SetWidth(thistype.LABEL_COLUMN, 0.1)
        call thistype.THIS_BOARD.Column.SetWidth(thistype.VALUE_COLUMN, 0.1)
        call thistype.THIS_BOARD.SetTitle("Unit Status")
        call thistype.THIS_BOARD.SetWidth(thistype.LIFE_ROW, thistype.LABEL_COLUMN, 0.12)
        call thistype.THIS_BOARD.SetWidth(thistype.LIFE_ROW, thistype.VALUE_COLUMN, 0.08)
        call thistype.THIS_BOARD.SetWidth(thistype.MANA_ROW, thistype.LABEL_COLUMN, 0.12)
        call thistype.THIS_BOARD.SetWidth(thistype.MANA_ROW, thistype.VALUE_COLUMN, 0.08)
        call thistype.THIS_BOARD.SetWidth(thistype.NAME_ROW, thistype.LABEL_COLUMN, 0.2)
        call thistype.THIS_BOARD.SetWidth(thistype.NAME_ROW, thistype.VALUE_COLUMN, 0.)
        call thistype.THIS_BOARD.SetWidth(thistype.STAMINA_ROW, thistype.LABEL_COLUMN, 0.12)
        call thistype.THIS_BOARD.SetWidth(thistype.STAMINA_ROW, thistype.VALUE_COLUMN, 0.08)
        call thistype.THIS_BOARD.SetWidth(thistype.STATUS_ROW, thistype.VALUE_COLUMN, 0.01)
        call Timer.Create().Start(thistype.UPDATE_TIME, true, function thistype.UpdateByTimer)
    endmethod
    initMethod Init of Misc_2
        call Event.Create(EventType.START, EventPriority.MISC, function thistype.Event_Start).AddToStatics()
    endmethod
endstruct
    globals
        VictoryRush VICTORY_RUSH = STRUCT_BASE
    endglobals
    struct VictoryRush
        implement Allocation
        implement List
        
    static Event DEATH_EVENT
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if not target.IsAllyOf(User.SPAWN) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_Death
        local Unit whichUnit = params.Unit.GetTrigger()
        local real x = whichUnit.Position.X.Get()
        local real y = whichUnit.Position.Y.Get()
        call Spot.CreateEffect(x, y, thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW).Destroy()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, thistype.AREA_RANGE, thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            loop
                call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, thistype.DURATION)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
        call Difficulty.SELECTED.SetLifeFactor(Difficulty.SELECTED.GetLifeFactor() + 0.01)
        call Game.DisplayTextTimed(User.ANY, String.Color.Do("Notification:", String.Color.GOLD) + " A defender died: Spawns have now " + Real.ToIntString(Difficulty.SELECTED.GetLifeFactor() * 100.) + Char.PERCENT + " life.", 10.)
    endmethod
    eventMethod Event_HeroPick
        call params.Unit.GetTrigger().Event.Add(DEATH_EVENT)
    endmethod
    initMethod Init of Misc_2
        set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Death)
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        
    endmethod
endstruct
    scope FolderWaypoint
    scope FolderRegionCheck
    public struct StructRetreat
        implement Allocation
        implement List
        
            static method Start takes Unit target returns nothing
                call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, thistype.DURATION)
            endmethod
            static method Init takes nothing returns nothing
            endmethod
        endstruct
    endscope
    public struct StructRegionCheck
        implement Allocation
        implement List
        
        static Buff DUMMY_BUFF
        static constant real DURATION = 3.
        Timer durationTimer
    FolderRegionCheck_StructRetreat Retreat = this
    FolderRegionCheck_StructRetreat LinkToStruct_Retreat
        timerMethod EndingByTimer
            local thistype this = Timer.GetExpired().GetData()
            local Unit target = this
            call target.Buffs.Remove(thistype.DUMMY_BUFF)
            call thistype(NULL).Retreat.Start(target)
            call WAYPOINT.Spawns.Update(target)
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            local Timer durationTimer = this.durationTimer
            call durationTimer.Destroy()
        endmethod
        eventMethod Event_BuffGain
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
			local Timer durationTimer = Timer.Create()
            set this.durationTimer = durationTimer
            call durationTimer.SetData(this)
            call durationTimer.Start(thistype.DURATION, false, function thistype.EndingByTimer)
        endmethod
        trigMethod Trig
            local Unit whichUnit = UNIT.Event.Native.GetTrigger()
            if (whichUnit.Owner.Get() != User.SPAWN) then
                return
            endif
            call whichUnit.Buffs.Add(thistype.DUMMY_BUFF, 1)
        endmethod
        static method Init takes nothing returns nothing
            local Region dummyRegion = Region.Create()
            call dummyRegion.AddRect(Rectangle.CreateFromSelf(gg_rct_Waypoint_RegionCheck))
            call dummyRegion.AddRect(Rectangle.CreateFromSelf(gg_rct_Waypoint_RegionCheck2))
            call dummyRegion.AddRect(Rectangle.CreateFromSelf(gg_rct_Waypoint_RegionCheck3))
            call Trigger.CreateFromCode(function thistype.Trig).RegisterEvent.LeaveRegion(dummyRegion, null)
            set thistype.DUMMY_BUFF = Buff.CreateHidden(thistype.NAME)
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_BuffLose))
            call thistype.DUMMY_BUFF.SetLostOnDeath(true)
            call thistype.DUMMY_BUFF.SetShowCountdown(true)
            call thistype.DUMMY_BUFF.TargetEffects.Add("Abilities\\Spells\\Other\\TalkToMe\\TalkToMe.mdl", AttachPoint.OVERHEAD, EffectLevel.LOW)
            call thistype(NULL).Retreat.Init()
        endmethod
    endstruct
    public struct StructSpawns
        implement Allocation
        implement List
        
        static Event DESTROY_EVENT
        static Buff DUMMY_BUFF
        static boolean GAME_OVER
        static Event IDLE_EVENT
        static Event OWNER_CHANGE_EVENT
        static Event SPAWN_EVENT
    static thistype array ACTIVE_LIST_ALL
    static integer ACTIVE_LIST_ALL_COUNT = ARRAY_EMPTY
    integer ACTIVE_LIST_index
    static method ACTIVE_LIST_Count takes nothing returns integer
        return thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static method ACTIVE_LIST_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Get takes integer index returns thistype
        return thistype.ACTIVE_LIST_ALL[index]
    endmethod
    static method ACTIVE_LIST_GetIndex takes thistype this returns integer
        return this.ACTIVE_LIST_index
    endmethod
    static method ACTIVE_LIST_Contains takes thistype this returns boolean
        return (thistype.ACTIVE_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ACTIVE_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ACTIVE_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ACTIVE_LIST_RandomAll takes nothing returns thistype
        return thistype.ACTIVE_LIST_Random(ARRAY_MIN, thistype.ACTIVE_LIST_ALL_COUNT)
    endmethod
    static method ACTIVE_LIST_Remove takes thistype this returns boolean
        if not thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT].ACTIVE_LIST_index = this.ACTIVE_LIST_index
        set thistype.ACTIVE_LIST_ALL[this.ACTIVE_LIST_index - 1] = thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT]
        set this.ACTIVE_LIST_index = ARRAY_MIN
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT - 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Add takes thistype this returns boolean
        if thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT + 1
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT] = this
        set this.ACTIVE_LIST_index = thistype.ACTIVE_LIST_ALL_COUNT + 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static thistype array FOR_EACH_LIST_ALL
    static integer FOR_EACH_LIST_ALL_COUNT = ARRAY_EMPTY
    static method FOR_EACH_LIST_FetchFirst takes nothing returns thistype
        local thistype result
        if (thistype.FOR_EACH_LIST_ALL_COUNT < ARRAY_MIN) then
            return NULL
        endif
        set result = thistype.FOR_EACH_LIST_ALL[ARRAY_MIN]
        set thistype.FOR_EACH_LIST_ALL[ARRAY_MIN] = thistype.FOR_EACH_LIST_ALL[thistype.FOR_EACH_LIST_ALL_COUNT]
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.FOR_EACH_LIST_ALL_COUNT - 1
        return result
    endmethod
    static method FOR_EACH_LIST_Set takes nothing returns nothing
        local integer iteration = thistype.ACTIVE_LIST_ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.FOR_EACH_LIST_ALL[iteration] = thistype.ACTIVE_LIST_ALL[iteration]
            set iteration = iteration - 1
        endloop
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
        Waypoint parent
        static method Update takes Unit whichUnit returns nothing
            local thistype this = whichUnit
            local Waypoint parent = this.parent
            if thistype.GAME_OVER then
                return
            endif
			local Waypoint next
            if (parent == NULL) then
                set next = NULL
            else
                set next = parent.GetNext()
            endif
            if (next == NULL) then
                if SpawnType.GetFromType(whichUnit.Type.Get()).IsRunner() then
                    call whichUnit.Order.UnitTarget(Order.ATTACK, Meteorite.THIS_UNIT)
                else
                    call whichUnit.Order.PointTarget(Order.ATTACK, Meteorite.THIS_UNIT.Position.X.Get(), Meteorite.THIS_UNIT.Position.Y.Get())
                endif
            else
                local real x = next.GetCenterX()
                local real y = next.GetCenterY()
                if SpawnType.GetFromType(whichUnit.Type.Get()).IsRunner() then
                    call whichUnit.Order.PointTarget(Order.MOVE, x, y)
                else
                    call whichUnit.Order.PointTarget(Order.ATTACK, x, y)
                endif
            endif
        endmethod
        method Event_Enter takes Unit whichUnit returns nothing
            local Waypoint parent = this
            if not thistype.ACTIVE_LIST_Contains(whichUnit) then
                return
            endif
            set this = whichUnit
            set this.parent = parent
            call thistype.Update(whichUnit)
        endmethod
        eventMethod Event_Idle
            call thistype.Update(params.Unit.GetTrigger())
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            call target.Order.Events.Idle.Unreg(IDLE_EVENT)
            call thistype.ACTIVE_LIST_Remove(target)
        endmethod
        eventMethod Event_BuffGain
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            set this.parent = NULL
            call target.Event.Add(DESTROY_EVENT)
            call target.Event.Add(OWNER_CHANGE_EVENT)
            if not thistype.GAME_OVER then
                call target.Order.Events.Idle.Reg(IDLE_EVENT)
            endif
            call thistype.ACTIVE_LIST_Add(target)
        endmethod
        eventMethod Event_OwnerChange
            call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
        endmethod
        eventMethod Event_Destroy
            local Unit target = params.Unit.GetTrigger()
            call target.Event.Remove(DESTROY_EVENT)
            call target.Event.Remove(OWNER_CHANGE_EVENT)
        endmethod
        eventMethod Event_GameOver
            set thistype.GAME_OVER = true
            
            call thistype.FOR_EACH_LIST_Set()
            loop
                local thistype this = thistype.FOR_EACH_LIST_FetchFirst()
                exitwhen (this == NULL)
                local Unit target = this
                call target.Buffs.Remove(thistype.DUMMY_BUFF)
                call target.Abilities.AddBySelf(thistype.WANDER_SPELL_ID)
                if (target.Classes.Contains(UnitClass.DEAD) == false) then
                    call target.Animation.Set(Animation.VICTORY)
                    call target.Animation.Queue(Animation.SPELL)
                endif
            endloop
        endmethod
        eventMethod Event_Spawn
            call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, 1)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DESTROY_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Destroy)
            set thistype.GAME_OVER = false
            set thistype.IDLE_EVENT = Event.Create(UNIT.Order.Events.Idle.INTERVAL_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Idle)
            set thistype.OWNER_CHANGE_EVENT = Event.Create(UNIT.Owner.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_OwnerChange)
            set thistype.SPAWN_EVENT = Event.Create(Spawn.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Spawn)
            call Event.Create(Meteorite.GAME_OVER_EVENT_TYPE, EventPriority.MISC, function thistype.Event_GameOver).AddToStatics()
            call thistype.SPAWN_EVENT.AddToStatics()
            set thistype.DUMMY_BUFF = Buff.CreateHidden(thistype.NAME)
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
    endstruct
endscope
    globals
        Waypoint WAYPOINT = STRUCT_BASE
    endglobals
    struct Waypoint
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static thistype CENTER
    FolderWaypoint_StructRegionCheck RegionCheck = this
    FolderWaypoint_StructRegionCheck LinkToStruct_RegionCheck
    FolderWaypoint_StructSpawns Spawns = this
    FolderWaypoint_StructSpawns LinkToStruct_Spawns
    thistype next
    method GetNext takes nothing returns thistype
        return this.next
    endmethod
    method SetNext takes thistype value returns nothing
        set this.next = value
    endmethod
    Rectangle source
    method GetSource takes nothing returns Rectangle
        return this.source
    endmethod
    method SetSource takes Rectangle value returns nothing
        set this.source = value
    endmethod
    static method GetFromSelf takes Region self returns thistype
        return self.Data.Integer.Get(KEY)
    endmethod
    static method GetFromSource takes Rectangle source returns thistype
        return source.Data.Integer.Get(KEY)
    endmethod
    method GetCenterX takes nothing returns real
        return this.GetSource().GetCenterX()
    endmethod
    method GetCenterY takes nothing returns real
        return this.GetSource().GetCenterY()
    endmethod
    trigMethod Trig
        local thistype this = Region.GetTrigger().Data.Integer.Get(KEY)
        call this.Spawns.Event_Enter(UNIT.Event.Native.GetTrigger())
    endmethod
    static method Create takes Rectangle source, thistype next returns thistype
        local thistype this = thistype.allocate()
        local Region sourceRegion = Region.CreateFromRectangle(source)
        call this.SetNext(next)
        call this.SetSource(source)
        call source.Data.Integer.Set(KEY, this)
        call sourceRegion.Data.Integer.Set(KEY, this)
        call Trigger.CreateFromCode(function thistype.Trig).RegisterEvent.EnterRegion(sourceRegion, null)
        return this
    endmethod
    initMethod Init of Misc_5
        set thistype.CENTER = thistype.Create(Rectangle.CreateFromSelf(gg_rct_SpawnCenter), NULL)
        call thistype.Create(Rectangle.CreateFromSelf(gg_rct_SpawnBottomIn), NULL)
        call thistype.Create(Rectangle.CreateFromSelf(gg_rct_SpawnLeftIn), NULL)
        call thistype.Create(Rectangle.CreateFromSelf(gg_rct_SpawnRightIn), NULL)
        call thistype(NULL).RegionCheck.Init()
        call thistype(NULL).Spawns.Init()
    endmethod
endstruct
    globals
        Zoom ZOOM = STRUCT_BASE
    endglobals
    struct Zoom
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static constant real UPDATE_TIME = 20 * FRAME_UPDATE_TIME
    static Timer UPDATE_TIMER
    static real VALUE = 2450.
    real oldX
    real oldY
    static method RpgCam takes nothing returns nothing
        if not RPG_CAM_ON then
            return
        endif
        if (User.GetLocal().Hero.Get() == NULL) then
            return
        endif
        if (Math.DistanceSquareByDeltas(CAMERA.Target.GetX() - User.GetLocal().Hero.Get().Position.X.Get(), CAMERA.Target.GetY() - User.GetLocal().Hero.Get().Position.Y.Get()) < 500 * 500) then
            call SetCameraField(CAMERA_FIELD_ROTATION, User.GetLocal().Hero.Get().Facing.Get() * bj_RADTODEG, RPG_CAM_TIME)
        endif
    endmethod
    timerMethod Update
        local real newX = CAMERA.Target.GetX()
        local real newY = CAMERA.Target.GetY()
        local integer iteration = thistype.ALL_COUNT
        loop
            local thistype this = thistype.ALL[iteration]
			local User whichUser = this
            local real newZ = thistype.VALUE
            set this.oldX = newX
            set this.oldY = newY
            call CameraField.TARGET_DISTANCE.Timed.Set(whichUser, newZ, 1.)
            set iteration = iteration - 1
            exitwhen (iteration < ARRAY_MIN)
        endloop
    endmethod
    eventMethod Event_AfterIntro
        local thistype this = params.User.GetTrigger()
        set this.oldX = CAMERA.Target.GetX()
        set this.oldY = CAMERA.Target.GetY()
        if this.AddToList() then
            call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
        endif
    endmethod
    initMethod Init of Misc_2
        set thistype.UPDATE_TIMER = Timer.Create()
        call Event.Create(AfterIntro.FOR_PLAYER_EVENT_TYPE, EventPriority.MISC, function thistype.Event_AfterIntro).AddToStatics()
    endmethod
endstruct
    globals
        AxeFighter AXE_FIGHTER = STRUCT_BASE
    endglobals
    struct AxeFighter
        implement Allocation
        implement List
        
    static Event ACQUIRES_TARGET_EVENT
    static UnitType SPEAKER
    eventMethod Event_AcquiresTarget
        local Unit speakerUnit = params.Unit.GetTrigger()
        call thistype.SPEAKER.Event.Remove(ACQUIRES_TARGET_EVENT)
        call Game.DisplaySpeechFromUnit(speakerUnit, "Let's have some fun, everyone!", 2.)
        call Trigger.Sleep(2.)
        call Game.DisplaySpeechFromUnit(speakerUnit, "Loot the castle!", 1.)
    endmethod
    initMethod Init of Speeches
        set thistype.ACQUIRES_TARGET_EVENT = Event.Create(UNIT.Attack.Events.DUMMY_EVENT_TYPE, EventPriority.SPEECHES, function thistype.Event_AcquiresTarget)
        set thistype.SPEAKER = UnitType.AXE_FIGHTER
        call thistype.SPEAKER.Event.Add(ACQUIRES_TARGET_EVENT)
    endmethod
endstruct
    globals
        Balduir BALDUIR = STRUCT_BASE
    endglobals
    struct Balduir
        implement Allocation
        implement List
        
    static Event ACQUIRES_TARGET_EVENT
    static UnitType SPEAKER
    eventMethod Event_AcquiresTarget
        local Unit speakerUnit = params.Unit.GetTrigger()
        call thistype.SPEAKER.Event.Remove(ACQUIRES_TARGET_EVENT)
        call Game.DisplaySpeechFromUnit(speakerUnit, "Crawl before me, little worms!", 2.)
        call Trigger.Sleep(1.)
        call Game.DisplaySpeechFromUnit(speakerUnit, "I challenge you!", 0.75)
        call Trigger.Sleep(1.)
        call Game.DisplaySpeechFromUnit(speakerUnit, "Only the winner shall be the one to survive.", 3.)
    endmethod
    initMethod Init of Speeches
        set thistype.ACQUIRES_TARGET_EVENT = Event.Create(UNIT.Attack.Events.DUMMY_EVENT_TYPE, EventPriority.SPEECHES, function thistype.Event_AcquiresTarget)
        set thistype.SPEAKER = UnitType.BALDUIR
        call thistype.SPEAKER.Event.Add(ACQUIRES_TARGET_EVENT)
    endmethod
endstruct
    scope FolderAura
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    public struct StructBoolean
        implement Allocation
        implement List
        
    method Get takes integer key returns boolean
        return Aura(this).Data.table.IntegerKeys.GetBoolean(Aura(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Boolean.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Aura(this).Data.table.IntegerKeys.RemoveBoolean(Aura(this).Id.Get(), key)
    endmethod
    method Set takes integer key, boolean value returns nothing
        call Aura(this).Data.table.IntegerKeys.SetBoolean(Aura(this).Id.Get(), key, value)
    endmethod
        endstruct
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return Aura(this).Data.table.IntegerKeys.Table.ContainsInteger(Aura(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Aura(this).Data.table.IntegerKeys.Table.CountIntegers(Aura(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Aura(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Aura(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Aura(this).Data.table.IntegerKeys.Table.GetInteger(Aura(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Aura(this).Data.table.IntegerKeys.Table.GetFirstInteger(Aura(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Aura(this).Data.table.IntegerKeys.Table.GetLastInteger(Aura(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Aura(this).Data.table.IntegerKeys.Table.Clear(Aura(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Aura(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Aura(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Aura(this).Data.table.IntegerKeys.Table.RemoveInteger(Aura(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Aura(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Aura(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Aura(this).Data.table.IntegerKeys.Table.AddInteger(Aura(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Aura(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Aura(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Aura(this).Data.table.IntegerKeys.Table.JoinInteger(Aura(this).Id.Get(), key, Aura(other).Data.table, Aura(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Aura(this).Data.table.IntegerKeys.Table.RandomInteger(Aura(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Aura(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Aura(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Aura(this).Data.table.IntegerKeys.Table.PrintIntegers(Aura(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return Aura(this).Data.table.IntegerKeys.GetInteger(Aura(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Aura(this).Data.table.IntegerKeys.RemoveInteger(Aura(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Aura(this).Data.table.IntegerKeys.SetInteger(Aura(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructBoolean Boolean = this
    FolderData_StructBoolean LinkToStruct_Boolean
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Aura(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Aura.Allocation.deallocate_demount.hook
		call Aura(this).Data.Destroy()
	endinject
	inject Aura.Allocation.allocate_mount.hook
		call Aura(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructEvent
        implement Allocation
        implement List
        
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(Aura(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(Aura(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(Aura(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(Aura(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(Aura(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(Aura(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(Aura(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(Aura(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject Aura.Allocation.deallocate_demount.hook
			call Aura(this).Event.Destroy()
		endinject
		inject Aura.Allocation.allocate_mount.hook
			call Aura(this).Event.Event_Create()
		endinject
    endstruct
    public struct StructTarget
        implement Allocation
        implement List
        
		static EventType ENDING_EVENT_TYPE
		static EventType START_EVENT_TYPE
		method Ending_TriggerEvents takes Unit target returns nothing
			local Aura parent = this
            local EventResponse params = EventResponse.Create(parent.Id.Get())
            call params.Aura.SetTrigger(parent)
            call params.Unit.SetTrigger(target)
			local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = parent.Event.Count(thistype.ENDING_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call parent.Event.Get(thistype.ENDING_EVENT_TYPE, priority, iteration2).Run(params)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            call params.Destroy()
		endmethod
		method Ending takes Unit target returns nothing
			local Aura parent = this
			call this.Ending_TriggerEvents(target)
		endmethod
		method Start_TriggerEvents takes Unit target returns nothing
			local Aura parent = this
            local EventResponse params = EventResponse.Create(parent.Id.Get())
            call params.Aura.SetTrigger(parent)
            call params.Unit.SetTrigger(target)
			local integer iteration = EventPriority.ALL_COUNT
            loop
                exitwhen (iteration < ARRAY_MIN)
                local EventPriority priority = EventPriority.ALL[iteration]
                local integer iteration2 = parent.Event.Count(thistype.START_EVENT_TYPE, priority)
                loop
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                    call parent.Event.Get(thistype.START_EVENT_TYPE, priority, iteration2).Run(params)
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
            call params.Destroy()
		endmethod
		method Start takes Unit target returns nothing
			local Aura parent = this
			call this.Start_TriggerEvents(target)
		endmethod
		static method Init takes nothing returns nothing
			set thistype.ENDING_EVENT_TYPE = EventType.Create()
			set thistype.START_EVENT_TYPE = EventType.Create()
		endmethod
	endstruct
endscope
    globals
        Aura AURA = STRUCT_BASE
    endglobals
    struct Aura
        implement Allocation
        implement List
        
	static Group ENUM_GROUP
	static Group ENUM_GROUP2
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
	static Event TRANSPORT_ENDING_EVENT
	static Event TRANSPORT_START_EVENT
	static constant real UPDATE_TIME = 0.75
	static Timer UPDATE_TIMER
    static thistype array ACTIVE_LIST_ALL
    static integer ACTIVE_LIST_ALL_COUNT = ARRAY_EMPTY
    integer ACTIVE_LIST_index
    static method ACTIVE_LIST_Count takes nothing returns integer
        return thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static method ACTIVE_LIST_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Get takes integer index returns thistype
        return thistype.ACTIVE_LIST_ALL[index]
    endmethod
    static method ACTIVE_LIST_GetIndex takes thistype this returns integer
        return this.ACTIVE_LIST_index
    endmethod
    static method ACTIVE_LIST_Contains takes thistype this returns boolean
        return (thistype.ACTIVE_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ACTIVE_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ACTIVE_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ACTIVE_LIST_RandomAll takes nothing returns thistype
        return thistype.ACTIVE_LIST_Random(ARRAY_MIN, thistype.ACTIVE_LIST_ALL_COUNT)
    endmethod
    static method ACTIVE_LIST_Remove takes thistype this returns boolean
        if not thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT].ACTIVE_LIST_index = this.ACTIVE_LIST_index
        set thistype.ACTIVE_LIST_ALL[this.ACTIVE_LIST_index - 1] = thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT]
        set this.ACTIVE_LIST_index = ARRAY_MIN
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT - 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Add takes thistype this returns boolean
        if thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT + 1
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT] = this
        set this.ACTIVE_LIST_index = thistype.ACTIVE_LIST_ALL_COUNT + 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static thistype array FOR_EACH_LIST_ALL
    static integer FOR_EACH_LIST_ALL_COUNT = ARRAY_EMPTY
    static method FOR_EACH_LIST_FetchFirst takes nothing returns thistype
        local thistype result
        if (thistype.FOR_EACH_LIST_ALL_COUNT < ARRAY_MIN) then
            return NULL
        endif
        set result = thistype.FOR_EACH_LIST_ALL[ARRAY_MIN]
        set thistype.FOR_EACH_LIST_ALL[ARRAY_MIN] = thistype.FOR_EACH_LIST_ALL[thistype.FOR_EACH_LIST_ALL_COUNT]
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.FOR_EACH_LIST_ALL_COUNT - 1
        return result
    endmethod
    static method FOR_EACH_LIST_Set takes nothing returns nothing
        local integer iteration = thistype.ACTIVE_LIST_ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.FOR_EACH_LIST_ALL[iteration] = thistype.ACTIVE_LIST_ALL[iteration]
            set iteration = iteration - 1
        endloop
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static thistype array REG_LIST_ALL
    static integer REG_LIST_ALL_COUNT = ARRAY_EMPTY
    integer REG_LIST_index
    static method REG_LIST_Count takes nothing returns integer
        return thistype.REG_LIST_ALL_COUNT
    endmethod
    static method REG_LIST_IsEmpty takes nothing returns boolean
        return (thistype.REG_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method REG_LIST_Get takes integer index returns thistype
        return thistype.REG_LIST_ALL[index]
    endmethod
    static method REG_LIST_GetIndex takes thistype this returns integer
        return this.REG_LIST_index
    endmethod
    static method REG_LIST_Contains takes thistype this returns boolean
        return (thistype.REG_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method REG_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.REG_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method REG_LIST_RandomAll takes nothing returns thistype
        return thistype.REG_LIST_Random(ARRAY_MIN, thistype.REG_LIST_ALL_COUNT)
    endmethod
    static method REG_LIST_Remove takes thistype this returns boolean
        if not thistype.REG_LIST_Contains(this) then
            return false
        endif
        set thistype.REG_LIST_ALL[thistype.REG_LIST_ALL_COUNT].REG_LIST_index = this.REG_LIST_index
        set thistype.REG_LIST_ALL[this.REG_LIST_index - 1] = thistype.REG_LIST_ALL[thistype.REG_LIST_ALL_COUNT]
        set this.REG_LIST_index = ARRAY_MIN
        set thistype.REG_LIST_ALL_COUNT = thistype.REG_LIST_ALL_COUNT - 1
        return (thistype.REG_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method REG_LIST_Add takes thistype this returns boolean
        if thistype.REG_LIST_Contains(this) then
            return false
        endif
        set thistype.REG_LIST_ALL_COUNT = thistype.REG_LIST_ALL_COUNT + 1
        set thistype.REG_LIST_ALL[thistype.REG_LIST_ALL_COUNT] = this
        set this.REG_LIST_index = thistype.REG_LIST_ALL_COUNT + 1
        return (thistype.REG_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    FolderAura_StructData Data = this
    FolderAura_StructData LinkToStruct_Data
    FolderAura_StructEvent Event = this
    FolderAura_StructEvent LinkToStruct_Event
    FolderAura_StructId Id = this
    FolderAura_StructId LinkToStruct_Id
    FolderAura_StructTarget Target = this
    FolderAura_StructTarget LinkToStruct_Target
    real areaRange
    method GetAreaRange takes nothing returns real
        return this.areaRange
    endmethod
    method SetAreaRange takes real value returns nothing
        set this.areaRange = value
    endmethod
    Unit caster
    method GetCaster takes nothing returns Unit
        return this.caster
    endmethod
    method SetCaster takes Unit value returns nothing
        set this.caster = value
    endmethod
    integer data
    method GetData takes nothing returns integer
        return this.data
    endmethod
    method SetData takes integer value returns nothing
        set this.data = value
    endmethod
    BoolExpr targetFilter
    method GetTargetFilter takes nothing returns BoolExpr
        return this.targetFilter
    endmethod
    method SetTargetFilter takes BoolExpr value returns nothing
        set this.targetFilter = value
    endmethod
    UnitList targetGroup
    method GetTargetGroup takes nothing returns UnitList
        return this.targetGroup
    endmethod
    method SetTargetGroup takes UnitList value returns nothing
        set this.targetGroup = value
    endmethod
    method ClearTargetGroup takes nothing returns nothing
    	local UnitList targetGroup = this.GetTargetGroup()
        loop
            local Unit target = targetGroup.FetchFirst()
            exitwhen (target == NULL)
            call this.Target.Ending(target)
        endloop
    endmethod
	method Update takes nothing returns nothing
        local Unit caster = this.GetCaster()
        local UnitList targetGroup = this.GetTargetGroup()
        local real x = caster.Position.X.Get()
        local real y = caster.Position.Y.Get()
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, this.GetAreaRange(), this.GetTargetFilter())
		call thistype.ENUM_GROUP.RemoveUnit(caster)
        local Unit target = targetGroup.GetFirst()
        if (target != NULL) then
            loop
                if thistype.ENUM_GROUP.ContainsUnit(target) then
                    call targetGroup.Remove(target)
                    call thistype.ENUM_GROUP.RemoveUnit(target)
                    call thistype.ENUM_GROUP2.AddUnit(target)
                else
                    call targetGroup.Remove(target)
                    call this.Target.Ending(target)
                endif
                set target = targetGroup.GetFirst()
                exitwhen (target == NULL)
            endloop
            call targetGroup.AddGroup2Clear(thistype.ENUM_GROUP2)
        endif
        set target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            loop
                call targetGroup.Add(target)
                call this.Target.Start(target)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
	endmethod
	timerMethod UpdateByTimer
        call thistype.FOR_EACH_LIST_Set()
        loop
            local thistype this = thistype.FOR_EACH_LIST_FetchFirst()
            exitwhen (this == NULL)
            call this.Update()
        endloop
	endmethod
	method Deactivate takes nothing returns nothing
		if thistype.ACTIVE_LIST_Remove(this) then
			call thistype.UPDATE_TIMER.Pause()
		endif
		call this.ClearTargetGroup()
	endmethod
	method TryActivate_Conditions takes nothing returns boolean
		if caster.Transport.Is() then
			return false
		endif
		return true
	endmethod
	method TryActivate takes nothing returns nothing
		if not this.TryActivate_Conditions() then
			return
		endif
		if thistype.ACTIVE_LIST_Add(this) then
			call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.UpdateByTimer)
		endif
	endmethod
	eventMethod Event_TransportEnding
		local Unit caster = params.Unit.GetTrigger()
		local integer iteration = caster.Data.Integer.Table.Count(KEY_ARRAY)
		loop
			local thistype this = caster.Data.Integer.Table.Get(KEY_ARRAY, iteration)
			call this.TryActivate()
			set iteration = iteration - 1
			exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
		endloop
	endmethod
	eventMethod Event_TransportStart
		local Unit caster = params.Unit.GetTrigger()
		local integer iteration = caster.Data.Integer.Table.Count(KEY_ARRAY)
		loop
			local thistype this = caster.Data.Integer.Table.Get(KEY_ARRAY, iteration)
			call this.Deactivate()
			set iteration = iteration - 1
			exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
		endloop
	endmethod
	method Disable takes nothing returns nothing
		local Unit caster = this.GetCaster()
		if caster.Data.Integer.Table.Remove(KEY_ARRAY, this) then
			call caster.Event.Remove(TRANSPORT_ENDING_EVENT)
			call caster.Event.Remove(TRANSPORT_START_EVENT)
		endif
		call thistype.REG_LIST_Remove(this)
		call this.Deactivate()
	endmethod
	method Enable takes nothing returns nothing
		local Unit caster = this.GetCaster()
		if caster.Data.Integer.Table.Add(KEY_ARRAY, this) then
			call caster.Event.Add(TRANSPORT_ENDING_EVENT)
			call caster.Event.Add(TRANSPORT_START_EVENT)
		endif
		call thistype.REG_LIST_Add(this)
		call this.TryActivate()
	endmethod
	method Destroy takes nothing returns nothing
		local Unit caster = this.GetCaster()
		local UnitList targetGroup = this.GetTargetGroup()
		call this.Disable()
		call targetGroup.Destroy()
		call this.Event.Clear()
		call this.deallocate()
	endmethod
	static method Create takes Unit caster returns thistype
		local thistype this = thistype.allocate()
		call this.Id.Event_Create()
		call this.SetAreaRange(0.)
		call this.SetCaster(caster)
		call this.SetTargetFilter(NULL)
		call this.SetTargetGroup(UnitList.Create())
		return this
	endmethod
	initMethod Init of Spells_Header
		set thistype.ENUM_GROUP = Group.Create()
		set thistype.ENUM_GROUP2 = Group.Create()
        set thistype.TRANSPORT_ENDING_EVENT = Event.Create(UNIT.Transport.ENDING_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_TransportEnding)
        set thistype.TRANSPORT_START_EVENT = Event.Create(UNIT.Transport.START_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_TransportStart)
		set thistype.UPDATE_TIMER = Timer.Create()
		call thistype(NULL).Target.Init()
	endmethod
endstruct
    globals
        AIBoost A_I_BOOST = STRUCT_BASE
    endglobals
    struct AIBoost
        implement Allocation
        implement List
        
    eventMethod Event
        call Unit.GetFromId(params.GetSubjectId()).Order.ImmediateBySpell(Boost.THIS_SPELL)
    endmethod
    initMethod Init of AI_Spells
        local EventCombination whichCombination = AICastSpell.CreateBasics(Boost.THIS_SPELL, function thistype.Event)
        call whichCombination.Events.Create(UNIT.Attack.Events.Acquire2.DUMMY_EVENT_TYPE, EventPriority.AI, NULL)
    endmethod
endstruct
    globals
        Boost BOOST = STRUCT_BASE
    endglobals
    struct Boost
        implement Allocation
        implement List
        
    eventMethod Event_SpellEffect
        local integer level = params.Spell.GetLevel()
        call params.Unit.GetTrigger().Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION)
    endmethod
    initMethod Init of Spells_Act1
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        AIBurningSpirit A_I_BURNING_SPIRIT = STRUCT_BASE
    endglobals
    struct AIBurningSpirit
        implement Allocation
        implement List
        
    static constant real AREA_RANGE = 500.
    static BoolExpr TARGET_FILTER
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Buffs.Contains(BurningSpirit.DUMMY_BUFF) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if not target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Event
        local Unit caster = Unit.GetFromId(params.GetSubjectId())
        if caster.Classes.Contains(UnitClass.DEAD) then
            return
        endif
        set User.TEMP = caster.Owner.Get()
        local Unit target = GROUP.EnumUnits.InRange.WithCollision.GetRandom(caster.Position.X.Get(), caster.Position.Y.Get(), AREA_RANGE, TARGET_FILTER)
        if (target == NULL) then
            return
        endif
		call caster.Order.UnitTargetBySpell(BurningSpirit.THIS_SPELL, target)
    endmethod
    initMethod Init of AI_Spells
        local EventCombination whichCombination = AICastSpell.CreateBasics(BurningSpirit.THIS_SPELL, function thistype.Event)
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call whichCombination.Periodic.Add(1.)
    endmethod
endstruct
    globals
        BurningSpirit BURNING_SPIRIT = STRUCT_BASE
    endglobals
    struct BurningSpirit
        implement Allocation
        implement List
        
    eventMethod Event_SpellEffect
        call params.Unit.GetTarget().Buffs.Timed.Start(thistype.DUMMY_BUFF, params.Spell.GetLevel(), thistype.DURATION)
    endmethod
    static method Init takes nothing returns nothing
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        AIChaosBall A_I_CHAOS_BALL = STRUCT_BASE
    endglobals
    struct AIChaosBall
        implement Allocation
        implement List
        
    static constant real AREA_RANGE = 500.
    static BoolExpr TARGET_FILTER
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Event
        local Unit caster = Unit.GetFromId(params.GetSubjectId())
        if caster.Classes.Contains(UnitClass.DEAD) then
            return
        endif
        set User.TEMP = caster.Owner.Get()
        local Unit target = GROUP.EnumUnits.InRange.WithCollision.GetRandom(caster.Position.X.Get(), caster.Position.Y.Get(), thistype.AREA_RANGE, thistype.TARGET_FILTER)
        if (target == NULL) then
            return
        endif
		call caster.Order.UnitTargetBySpell(ChaosBall.THIS_SPELL, target)
    endmethod
    initMethod Init of AI_Spells
        local EventCombination whichCombination = AICastSpell.CreateBasics(ChaosBall.THIS_SPELL, function thistype.Event)
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call whichCombination.Events.Create(UNIT.Attack.Events.Acquire2.DUMMY_EVENT_TYPE, EventPriority.AI, NULL)
    endmethod
endstruct
    globals
        ChaosBall CHAOS_BALL = STRUCT_BASE
    endglobals
    struct ChaosBall
        implement Allocation
        implement List
        
    static real array CANCEL_RANGE_SQUARE
    static Group ENUM_GROUP
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static BoolExpr TARGET_FILTER
    Unit caster
    Missile dummyMissile
    integer level
    Unit target
    condMethod TargetConditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local real x = dummyMissile.Position.X.Get()
        local real y = dummyMissile.Position.Y.Get()
        local Unit caster = this.caster
        local integer level = this.level
        call this.deallocate_demount()
        call dummyMissile.Destroy()
        call Spot.CreateEffect(x, y, thistype.SPECIAL_EFFECT_PATH, EffectLevel.NORMAL).Destroy()
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, thistype.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real damage = thistype.DAMAGE
            local real heroDuration = thistype.HERO_DURATION
            local real normDuration = thistype.DURATION
            loop
            	local real duration
				if target.Classes.Contains(UnitClass.HERO) then
					set duration = heroDuration
				else
					set duration = normDuration
				endif
				call target.Buffs.Timed.Start(thistype.POISON_BUFF, level, duration)
                call caster.DamageUnitBySpell(target, damage, true, false)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    eventMethod Event_EndCast
        local Unit caster = params.Unit.GetTrigger()
        local boolean success = params.Spell.IsChannelComplete()
        local thistype this = caster.Data.Integer.Get(KEY)
        local Missile dummyMissile = this.dummyMissile
        local integer level = this.level
        call caster.Data.Integer.Remove(KEY)
        if success then
            set target = this.target
            local real targetX = target.Position.X.Get()
            local real targetY = target.Position.Y.Get()
            if (Math.DistanceSquareByDeltas(targetX - caster.Position.X.Get(), targetY - caster.Position.Y.Get()) < thistype.CANCEL_RANGE_SQUARE[level]) then
                set this.caster = caster
                call dummyMissile.Acceleration.Set(600.)
                call dummyMissile.Arc.SetByPerc(0.1)
                call dummyMissile.Impact.SetAction(function thistype.Impact)
                call dummyMissile.SetData(this)
                call dummyMissile.Speed.Set(700.)
                call dummyMissile.Position.SetToUnit(caster)
                call dummyMissile.GoToSpot.Start(targetX, targetY, Spot.GetHeight(targetX, targetY))
                return
            endif
        endif
        call this.deallocate_demount()
        call dummyMissile.Destroy()
        call caster.Mana.Add(thistype.THIS_SPELL.GetManaCost(level))
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
		
        local real duration = thistype.THIS_SPELL.GetChannelTime(level)
		local Missile dummyMissile = Missile.Create()
		local thistype this = thistype.allocate_mount(dummyMissile)
        set this.dummyMissile = dummyMissile
        set this.level = level
        set this.target = params.Unit.GetTarget()
        call caster.Data.Integer.Set(KEY, this)
        local DummyUnit dummyUnit = dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1.)
        call dummyMissile.Speed.Set(thistype.OFFSET_Z / duration)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.GoToUnit.StartWithOffset(caster, 0., 0., thistype.OFFSET_Z, null)
        call dummyUnit.Scale.Timed.Add(1., duration)
    endmethod
    initMethod Init of Spells_Act1
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.TargetConditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
        call UNIT.Poisoned.NORMAL_BUFF.Variants.Add(thistype.POISON_BUFF)
        local integer iteration = thistype.THIS_SPELL.GetLevelsAmount()
        loop
            set thistype.CANCEL_RANGE_SQUARE[iteration] = Math.Square(thistype.THIS_SPELL.GetRange(iteration) + thistype.RANGE_TOLERANCE)
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
    endmethod
endstruct
    scope FolderEnergyCharge
    public struct StructTarget
        implement Allocation
        implement List
        
        static Event DAMAGE_EVENT
        eventMethod Event_Damage
            local Unit target = params.Unit.GetDamager()
            call target.HealBySpell(target, thistype.HEAL)
            call target.Buffs.Remove(thistype.DUMMY_BUFF)
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local integer level = params.Buff.GetLevel()
            call target.Event.Remove(DAMAGE_EVENT)
            set level = target.Abilities.GetLevel(EnergyCharge.THIS_SPELL)
            if (level > 0) then
                call target.Buffs.Add(EnergyCharge.DUMMY_BUFF, level)
            endif
        endmethod
        eventMethod Event_BuffGain
            local Unit target = params.Unit.GetTrigger()
            call target.Buffs.Remove(EnergyCharge.DUMMY_BUFF)
            call target.Event.Add(DAMAGE_EVENT)
        endmethod
        static method Start takes integer level, Unit target returns nothing
            call target.Buffs.Add(thistype.DUMMY_BUFF, level)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
    endstruct
endscope
    globals
        EnergyCharge ENERGY_CHARGE = STRUCT_BASE
    endglobals
    struct EnergyCharge
        implement Allocation
        implement List
        
    static Event DAMAGE_EVENT
    integer attackCount
    UnitEffect targetEffect
    UnitEffect targetEffect2
    FolderEnergyCharge_StructTarget Target = this
    FolderEnergyCharge_StructTarget LinkToStruct_Target
    static method Conditions takes Unit target returns boolean
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_Damage
		local Unit caster = params.Unit.GetDamager()        
        local Unit target = params.Unit.GetTrigger()
        if not thistype.Conditions(target) then
            return
        endif
        local thistype this = caster
        local integer attackCount = this.attackCount + 1
        if (attackCount == thistype.ATTACKS_AMOUNT_NEEDED) then
            set this.attackCount = 0
            call this.targetEffect.Destroy()
            call this.targetEffect2.Destroy()
            call thistype(NULL).Target.Start(params.Spell.GetLevel(), caster)
        else
            set this.attackCount = attackCount
            if (attackCount == 1) then
                set this.targetEffect = caster.Effects.Create(thistype.CHARGE_EFFECT_PATH, thistype.CHARGE_EFFECT_ATTACH_POINT, EffectLevel.LOW)
            elseif (attackCount == 2) then
                set this.targetEffect2 = caster.Effects.Create(thistype.CHARGE_EFFECT2_PATH, thistype.CHARGE_EFFECT2_ATTACH_POINT, EffectLevel.LOW)
            endif
        endif
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        call target.Event.Remove(DAMAGE_EVENT)
        if (this.attackCount == 2) then
            call this.targetEffect.Destroy()
            call this.targetEffect2.Destroy()
        elseif (this.attackCount == 1) then
            call this.targetEffect.Destroy()
        endif
    endmethod
    eventMethod Event_BuffGain
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        set this.attackCount = 0
        call target.Event.Add(DAMAGE_EVENT)
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Act1
        set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
        call thistype(NULL).Target.Init()
    endmethod
endstruct
    globals
        AIFlamelet A_I_FLAMELET = STRUCT_BASE
    endglobals
    struct AIFlamelet
        implement Allocation
        implement List
        
    static constant real AREA_RANGE = 500.
    static BoolExpr TARGET_FILTER
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Event
        local Unit caster = Unit.GetFromId(params.GetSubjectId())
        if caster.Classes.Contains(UnitClass.DEAD) then
            return
        endif
        set User.TEMP = caster.Owner.Get()
        local Unit target = GROUP.EnumUnits.InRange.WithCollision.GetRandom(caster.Position.X.Get(), caster.Position.Y.Get(), thistype.AREA_RANGE, thistype.TARGET_FILTER)
        if (target == NULL) then
            return
        endif
		call caster.Order.PointTargetBySpell(Flamelet.THIS_SPELL, target.Position.X.Get(), target.Position.Y.Get())
    endmethod
    initMethod Init of AI_Spells
        local EventCombination whichCombination = AICastSpell.CreateBasics(Flamelet.THIS_SPELL, function thistype.Event)
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call whichCombination.Events.Create(UNIT.Attack.Events.Acquire2.DUMMY_EVENT_TYPE, EventPriority.AI, NULL)
    endmethod
endstruct
    globals
        Flamelet FLAMELET = STRUCT_BASE
    endglobals
    struct Flamelet
        implement Allocation
        implement List
        
    static BoolExpr TARGET_FILTER
    real damage
    Missile dummyMissile
    integer level
    real maxLength
    real sourceX
    real sourceY
    SpellInstance whichInstance
    condMethod TargetConditions
        local EventResponse params = EventResponse.GetTrigger()
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local SpellInstance whichInstance = this.whichInstance
        if target.IsAllyOf(whichInstance.GetCaster().Owner.Get()) then
            return false
        endif
        return true
    endmethod
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        call dummyMissile.Destroy()
    endmethod
    eventMethod Collision
        local Missile dummyMissile = params.Missile.GetTrigger()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local real damage = this.damage
        local integer level = this.level
        local SpellInstance whichInstance = this.whichInstance
        local Unit caster = whichInstance.GetCaster()
        call dummyMissile.Destroy()
        call whichInstance.Refs.Subtract()
		local real duration
		if target.Classes.Contains(UnitClass.HERO) then
			set duration = thistype.IGNITE_HERO_DURATION
		else
			set duration = thistype.IGNITE_DURATION
		endif
		call target.Buffs.Timed.StartEx(thistype.IGNITION_BUFF, level, caster, duration)
        call caster.DamageUnitBySpell(target, damage, true, false)
    endmethod
    static method Start takes SpellInstance whichInstance returns nothing
        local Unit caster = whichInstance.GetCaster()
        local integer level = whichInstance.GetLevel()
        local real targetX = whichInstance.GetTargetX()
        local real targetY = whichInstance.GetTargetY()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real maxLength = thistype.THIS_SPELL.GetRange(level)
		local real angle = Math.AtanByDeltas(targetY - casterY, targetX - casterX)
        local thistype this = thistype.allocate()
        local Missile dummyMissile = this.dummyMissile
        set this.damage = thistype.DAMAGE
        set this.level = level
        set this.maxLength = maxLength
        set this.sourceX = casterX
        set this.sourceY = casterY
        set this.whichInstance = whichInstance
        call whichInstance.Refs.Add()
        call dummyMissile.CollisionSize.Set(thistype.THIS_SPELL.GetAreaRange(level))
        call dummyMissile.SetData(this)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.Speed.Set(thistype.SPEED)
        call dummyMissile.GoToSpot.Start(casterX + maxLength * Math.Cos(angle), casterY + maxLength * Math.Sin(angle), Spot.GetHeight(targetX, targetY) + UNIT_TYPE.Impact.Z.STANDARD)
        call dummyMissile.Position.AddCollision(function thistype.Collision, thistype.TARGET_FILTER)
    endmethod
    eventMethod Event_EndCast
        local boolean success = params.Spell.IsChannelComplete()
        local SpellInstance whichInstance = params.SpellInstance.GetTrigger()
        local thistype this = whichInstance
        if not success then
            call this.dummyMissile.Destroy()
            return
        endif
        call thistype.Start(whichInstance)
    endmethod
    static method StartCharging takes SpellInstance whichInstance returns nothing
        local thistype this = whichInstance
        local Unit caster = whichInstance.GetCaster()
        local integer level = whichInstance.GetLevel()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real maxLength = thistype.THIS_SPELL.GetRange(level)
        local real targetX = whichInstance.GetTargetX()
        local real targetY = whichInstance.GetTargetY()
        local real angle = Math.AtanByDeltas(targetY - casterY, targetX - casterX)
		local Missile dummyMissile = Missile.Create()
        set this.dummyMissile = dummyMissile
        set this.whichInstance = whichInstance
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.Angle.DirectToSpot(casterX + maxLength * Math.Cos(angle), casterY + maxLength * Math.Sin(angle), Spot.GetHeight(targetX, targetY) + UNIT_TYPE.Impact.Z.STANDARD)
        local DummyUnit dummyUnit = dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1.5)
        call dummyUnit.Scale.Timed.Add(1, whichInstance.GetSpell().GetChannelTime(level))
        call dummyUnit.AddEffect(thistype.MISSILE_EFFECT_PATH, thistype.MISSILE_EFFECT_ATTACH_POINT, EffectLevel.NORMAL)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local SpellInstance whichInstance = params.SpellInstance.GetTrigger()
        call caster.Effects.Create(thistype.LAUNCH_EFFECT_PATH, thistype.LAUNCH_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
        call thistype.StartCharging(whichInstance)
    endmethod
    initMethod Init of Spells_Act1
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.TargetConditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
        call UNIT.Ignited.NORMAL_BUFF.Variants.Add(thistype.IGNITION_BUFF)
    endmethod
endstruct
    globals
        FuzzyAttack FUZZY_ATTACK = STRUCT_BASE
    endglobals
    struct FuzzyAttack
        implement Allocation
        implement List
        
    static real INTERVAL
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    Unit caster
    Timer delayTimer
    integer remainingMissiles
    Unit target
    SpellInstance whichInstance
    method Ending takes Unit caster returns nothing
        local Timer delayTimer = this.delayTimer
        local SpellInstance whichInstance = this.whichInstance
        call this.deallocate()
        call caster.Data.Integer.Table.Remove(KEY_ARRAY, this)
        call delayTimer.Destroy()
        call whichInstance.Destroy()
    endmethod
    eventMethod Event_EndCast
        local Unit caster = params.Unit.GetTrigger()
        local integer iteration = caster.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            local thistype this = caster.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            if (this.remainingMissiles == 0) then
                call this.Ending(caster)
            else
                call this.delayTimer.Pause()
            endif
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
    endmethod
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        local integer remainingMissiles = this.remainingMissiles - 1
        local Unit target = this.target
        call dummyMissile.Destroy()
        call caster.DamageUnitBySpell(this.target, thistype.DAMAGE_PER_MISSILE, true, false)
        if (remainingMissiles == 0) then
            call this.Ending(caster)
        else
            set this.remainingMissiles = remainingMissiles
        endif
    endmethod
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
		local Missile dummyMissile = Missile.Create()
        set this.remainingMissiles = this.remainingMissiles + 1
        call dummyMissile.Arc.SetByPerc(0.06)
        call dummyMissile.CollisionSize.Set(32.)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1.)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(700.)
        call dummyMissile.Position.SetFromUnit(this.caster)
        call dummyMissile.GoToUnit.Start(this.target, null)
    endmethod
    timerMethod Delay
        call Timer.GetExpired().Start(thistype.INTERVAL, true, function thistype.Interval)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local Unit target = params.Unit.GetTarget()
		local thistype this = thistype.allocate()
        local Timer delayTimer = Timer.Create()
        set this.caster = caster
        set this.delayTimer = delayTimer
        set this.remainingMissiles = 0
        set this.target = target
        set this.whichInstance = SpellInstance.Create(caster, thistype.THIS_SPELL)
        call caster.Data.Integer.Table.Add(KEY_ARRAY, this)
        call delayTimer.SetData(this)
        call delayTimer.Start(thistype.DELAY, false, function thistype.Delay)
    endmethod
    initMethod Init of Spells_Act1
        set thistype.INTERVAL = (thistype.THIS_SPELL.GetChannelTime(1) - thistype.DELAY) / thistype.INTERVALS_AMOUNT - 0.01
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    scope FolderGreenNova
    public struct StructBuff
        implement Allocation
        implement List
        
        static method Start takes integer level, Unit target returns nothing
        	local real duration
			if target.Classes.Contains(UnitClass.HERO) then
				set duration = thistype.HERO_DURATION
			else
				set duration = thistype.DURATION
			endif
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, duration)
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
endscope
    globals
        GreenNova GREEN_NOVA = STRUCT_BASE
    endglobals
    struct GreenNova
        implement Allocation
        implement List
        
    static real DURATION
    static Group ENUM_GROUP
    static real RADIUS_ADD
    static BoolExpr TARGET_FILTER
    real angle
    Unit caster
    Timer intervalTimer
    integer level
    real radius
    real radiusAdd
    real x
    real y
    FolderGreenNova_StructBuff Buff = this
    FolderGreenNova_StructBuff LinkToStruct_Buff
    static method Ending takes nothing returns nothing
        local Timer durationTimer = Timer.GetExpired()
        local thistype this = durationTimer.GetData()
        local Timer intervalTimer = this.intervalTimer
        call durationTimer.Destroy()
        call intervalTimer.Destroy()
    endmethod
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        if target.Position.InRangeWithCollision(TEMP_REAL2, TEMP_REAL3, TEMP_REAL) then
            return false
        endif
        return true
    endmethod
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        local real angle = this.angle
        local integer level = this.level
        local real radius = this.radius + this.radiusAdd
        local real x = this.x
        local real y = this.y
        local real angleAdd = thistype.SPECIAL_EFFECT_PERIMETER_INTERVAL / radius
        local integer iteration = Real.ToInt(2 * Math.PI * radius / thistype.SPECIAL_EFFECT_PERIMETER_INTERVAL)
        set this.radius = radius
        loop
            call Spot.CreateEffect(x + radius * Math.Cos(angle), y + radius * Math.Sin(angle), thistype.SPECIAL_EFFECT_PATH, EffectLevel.Random(EffectLevel.LOW, EffectLevel.NORMAL)).Destroy()
            set iteration = iteration - 1
            exitwhen (iteration < 1)
            set angle = angle + angleAdd
        endloop
        set TEMP_REAL = radius - this.radiusAdd
        set TEMP_REAL2 = x
        set TEMP_REAL3 = y
        set User.TEMP = this.caster.Owner.Get()
        call ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, radius, thistype.TARGET_FILTER)
        loop
            local Unit target = ENUM_GROUP.FetchFirst()
            exitwhen (target == NULL)
            call thistype(NULL).Buff.Start(level, target)
        endloop
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local thistype this = thistype.allocate()
        local Timer durationTimer = Timer.Create()
        local Timer intervalTimer = Timer.Create()
        set this.angle = caster.Facing.Get()
        set this.caster = caster
        set this.intervalTimer = intervalTimer
        set this.level = params.Spell.GetLevel()
        set this.radius = 0.
        set this.radiusAdd = thistype.RADIUS_ADD
        set this.x = caster.Position.X.Get()
        set this.y = caster.Position.Y.Get()
        call durationTimer.SetData(this)
        call intervalTimer.SetData(this)
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
        call durationTimer.Start(thistype.DURATION, false, function thistype.Ending)
    endmethod
    initMethod Init of Spells_Act1
        set thistype.DURATION = thistype.INTERVAL * thistype.WAVES_AMOUNT
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.RADIUS_ADD = thistype.MAX_RADIUS / thistype.WAVES_AMOUNT
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Buff.Init()
    endmethod
endstruct
    globals
        AIHeal A_I_HEAL = STRUCT_BASE
    endglobals
    struct AIHeal
        implement Allocation
        implement List
        
    static constant real AREA_RANGE = 500.
    static BoolExpr TARGET_FILTER
    static method Conditions takes nothing returns boolean
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if not target.IsAllyOf(User.TEMP) then
            return false
        endif
        if (target.Life.Get() >= Real.ToInt(target.MaxLife.Get()) - Heal.HEAL) then
            return false
        endif
        return true
    endmethod
    eventMethod Event
        local Unit caster = Unit.GetFromId(params.GetSubjectId())
        if caster.Classes.Contains(UnitClass.DEAD) then
            return
        endif
        set User.TEMP = caster.Owner.Get()
        local Unit target = GROUP.EnumUnits.InRange.WithCollision.GetRandom(caster.Position.X.Get(), caster.Position.Y.Get(), AREA_RANGE, TARGET_FILTER)
        if (target != NULL) then
            call caster.Order.UnitTargetBySpell(Heal.THIS_SPELL, target)
        endif
    endmethod
    initMethod Init of AI_Spells
        local EventCombination whichCombination = AICastSpell.CreateBasics(Heal.THIS_SPELL, function thistype.Event)
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call whichCombination.Periodic.Add(1.)
    endmethod
endstruct
    globals
        Heal HEAL = STRUCT_BASE
    endglobals
    struct Heal
        implement Allocation
        implement List
        
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local Unit target = params.Unit.GetTarget()
        call target.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.LOW).DestroyTimed.Start(2.)
        call caster.HealBySpell(target, thistype.HEAL)
    endmethod
    initMethod Init of Spells_Act1
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        AIHealExplosion A_I_HEAL_EXPLOSION = STRUCT_BASE
    endglobals
    struct AIHealExplosion
        implement Allocation
        implement List
        
    eventMethod Event
        local Unit caster = Unit.GetFromId(params.GetSubjectId())
        if caster.Classes.Contains(UnitClass.DEAD) then
            return
        endif
        set User.TEMP = caster.Owner.Get()
        call HealExplosion.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(caster.Position.X.Get(), caster.Position.Y.Get(), HealExplosion.THIS_SPELL.GetAreaRange(caster.Abilities.GetLevel(HealExplosion.THIS_SPELL)), HealExplosion.HEAL_TARGET_FILTER)
        if (HealExplosion.ENUM_GROUP.Count() > 3) then
            call caster.Order.ImmediateBySpell(HealExplosion.THIS_SPELL)
        endif
    endmethod
    initMethod Init of AI_Spells
        local EventCombination whichCombination = AICastSpell.CreateBasics(HealExplosion.THIS_SPELL, function thistype.Event)
        call whichCombination.Periodic.Add(1.)
    endmethod
endstruct
    globals
        HealExplosion HEAL_EXPLOSION = STRUCT_BASE
    endglobals
    struct HealExplosion
        implement Allocation
        implement List
        
    static BoolExpr DAMAGE_TARGET_FILTER
    static Group ENUM_GROUP
    static BoolExpr HEAL_TARGET_FILTER
    UnitEffect chargeEffect
    integer level
    condMethod DamageConditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.NEUTRAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    condMethod HealConditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if (target == Unit.TEMP) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.NEUTRAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if not target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_EndCast
        local Unit caster = params.Unit.GetTrigger()
        local boolean success = params.Spell.IsChannelComplete()
        local thistype this = caster
        local UnitEffect chargeEffect = this.chargeEffect
        local integer level = this.level
        call chargeEffect.Destroy()
        if not success then
            return
        endif
        call caster.Effects.Create(thistype.EXPLOSION_EFFECT_PATH, thistype.EXPLOSION_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(caster.Position.X.Get(), caster.Position.Y.Get(), thistype.THIS_SPELL.GetAreaRange(level), thistype.DAMAGE_TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            loop
            	call target.Effects.Create(thistype.DAMAGE_TARGET_EFFECT_PATH, thistype.DAMAGE_TARGET_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
                call caster.DamageUnitBySpell(target, thistype.DAMAGE, false, false)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
        call caster.HealBySpell(caster, thistype.HEAL)
        set User.TEMP = caster.Owner.Get()
        set Unit.TEMP = caster
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(caster.Position.X.Get(), caster.Position.Y.Get(), thistype.THIS_SPELL.GetAreaRange(level), thistype.HEAL_TARGET_FILTER)
        call thistype.ENUM_GROUP.RemoveUnit(caster)
        set target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            loop
                call target.Effects.Create(thistype.HEAL_TARGET_EFFECT_PATH, thistype.HEAL_TARGET_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
                call caster.HealBySpell(target, thistype.HEAL)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local thistype this = caster
        set this.chargeEffect = caster.Effects.Create(thistype.CHARGE_EFFECT_PATH, thistype.CHARGE_EFFECT_ATTACH_POINT, EffectLevel.LOW)
        set this.level = level
    endmethod
    initMethod Init of Spells_Act1
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.DAMAGE_TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.DamageConditions)
        set thistype.HEAL_TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.HealConditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
    endmethod
endstruct
    globals
        IceArrows ICE_ARROWS = STRUCT_BASE
    endglobals
    struct IceArrows
        implement Allocation
        implement List
        
    static Event DAMAGE_EVENT
    static method AddCold takes integer level, Unit target returns nothing
        local real duration
        if target.Classes.Contains(UnitClass.HERO) then
            set duration = thistype.HERO_DURATION
        else
            set duration = thistype.DURATION
        endif
        call target.Buffs.Timed.Start(thistype.COLDNESS_BUFF, level, duration)
    endmethod
    static method Conditions takes Unit target returns boolean
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    eventMethod Event_Damage
        local Unit caster = params.Unit.GetDamager()
        local Unit target = params.Unit.GetTrigger()
        local integer level = caster.Abilities.GetLevel(thistype.THIS_SPELL)
        local real mana = caster.Mana.Get() - thistype.THIS_SPELL.GetManaCost(level)
        if (mana < 0.) then
            return
        endif
        call caster.Mana.Set(mana)
        if not thistype.Conditions(target) then
            return
        endif
        call target.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
        call thistype(NULL).AddCold(level, target)
        call caster.DamageUnitBySpell(target, thistype.DAMAGE, true, false)
    endmethod
    eventMethod Event_BuffLose
        call params.Unit.GetTrigger().Event.Remove(DAMAGE_EVENT)
    endmethod
    eventMethod Event_BuffGain
        call params.Unit.GetTrigger().Event.Add(DAMAGE_EVENT)
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Act1
        set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
        call UNIT.Cold.NORMAL_BUFF.Variants.Add(thistype.COLDNESS_BUFF)
    endmethod
endstruct
    globals
        LightningShield LIGHTNING_SHIELD = STRUCT_BASE
    endglobals
    struct LightningShield
        implement Allocation
        implement List
        
    static real DAMAGE_PER_INTERVAL
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    real areaRange
    Timer intervalTimer
    Unit target
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if (target == Unit.TEMP) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        return true
    endmethod
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        local Unit target = this.target
        set Unit.TEMP = target
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(target.Position.X.Get(), target.Position.Y.Get(), this.areaRange * target.Outpact.Z.Get(true) / UNIT_TYPE.Outpact.Z.STANDARD, thistype.TARGET_FILTER)
        local Unit damageTarget = thistype.ENUM_GROUP.FetchFirst()
        if (damageTarget != NULL) then
            loop
                call target.DamageUnitBySpell(damageTarget, thistype.DAMAGE_PER_INTERVAL, true, false)
                set damageTarget = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (damageTarget == NULL)
            endloop
        endif
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local Timer intervalTimer = this.intervalTimer
        call intervalTimer.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
		local Timer intervalTimer = Timer.Create()
        set this.areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        set this.intervalTimer = intervalTimer
        set this.target = target
        call intervalTimer.SetData(this)
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
    endmethod
    eventMethod Event_SpellEffect
        call params.Unit.GetTarget().Buffs.Timed.Start(thistype.DUMMY_BUFF, params.Spell.GetLevel(), thistype.DURATION)
    endmethod
    initMethod Init of Spells_Act1
        set thistype.DAMAGE_PER_INTERVAL = thistype.DAMAGE_PER_SECOND * thistype.INTERVAL
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    scope FolderLunarRestoration
    public struct StructRevival
        implement Allocation
        implement List
        
        static Event REVIVE_EVENT
        Timer durationTimer
        integer level
        SpotEffect specialEffect
        real targetX
        real targetY
        timerMethod EndingByTimer
            local Timer durationTimer = Timer.GetExpired()
            local thistype this = durationTimer.GetData()
            local integer level = this.level
            local Unit target = this
            call target.Buffs.Remove(thistype.DUMMY_BUFF)
            call target.Revive()
            call target.Life.Set(target.MaxLife.Get() * thistype.LIFE_FACTOR)
            call target.Mana.Set(target.MaxMana.Get() * thistype.MANA_FACTOR - LunarRestoration.THIS_SPELL.GetManaCost(level))
        endmethod
        eventMethod Event_Revive
            call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            local SpotEffect specialEffect = this.specialEffect
            call durationTimer.Destroy()
            call specialEffect.Destroy()
            call target.Event.Remove(REVIVE_EVENT)
        endmethod
        eventMethod Event_BuffGain
            local Timer durationTimer = Timer.Create()
            local integer level = params.Buff.GetLevel()
            local Unit target = params.Unit.GetTrigger()
            local real targetX = target.Position.X.Get()
            local real targetY = target.Position.Y.Get()
            local thistype this = target
            set this.durationTimer = durationTimer
            set this.level = level
            set this.specialEffect = Spot.CreateEffect(targetX, targetY, thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW)
            set this.targetX = targetX
            set this.targetY = targetY
            call durationTimer.SetData(this)
            call target.Event.Add(REVIVE_EVENT)
            call target.Revival.Set(true)
            call durationTimer.Start(thistype.DURATION, false, function thistype.EndingByTimer)
        endmethod
        static method Start takes integer level, Unit target returns nothing
            call target.Buffs.Add(thistype.DUMMY_BUFF, level)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Revive)
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
    endstruct
endscope
    globals
        LunarRestoration LUNAR_RESTORATION = STRUCT_BASE
    endglobals
    struct LunarRestoration
        implement Allocation
        implement List
        
    static Event DEATH_EVENT
    static Event array MANA_GAIN_EVENT
    static Event array MANA_LOSE_EVENT
    boolean active
    integer level
    Event manaGainEvent
    Event manaLoseEvent
    FolderLunarRestoration_StructRevival Revival = this
    FolderLunarRestoration_StructRevival LinkToStruct_Revival
    eventMethod Event_Death
        local Unit target = params.Unit.GetTrigger()
        if target.Revival.Is() then
            return
        endif
        local integer level = target.Abilities.GetLevel(thistype.THIS_SPELL)
        call thistype(NULL).Revival.Start(level, target)
    endmethod
    eventMethod Event_EffectBuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        call target.Event.Remove(DEATH_EVENT)
    endmethod
    eventMethod Event_EffectBuffGain
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        call target.Event.Add(DEATH_EVENT)
    endmethod
    eventMethod Event_ManaLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        set this.active = false
        call target.Event.Add(this.manaGainEvent)
        call target.Event.Remove(this.manaLoseEvent)
        call target.Buffs.Remove(thistype.EFFECT_BUFF)
    endmethod
    eventMethod Event_ManaGain
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        set this.active = true
        call target.Event.Add(this.manaLoseEvent)
        call target.Event.Remove(this.manaGainEvent)
        call target.Buffs.Add(thistype.EFFECT_BUFF, this.level)
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        if this.active then
            call target.Event.Remove(this.manaLoseEvent)
            call target.Buffs.Remove(thistype.EFFECT_BUFF)
        else
            call target.Event.Remove(this.manaGainEvent)
        endif
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local Event manaGainEvent = thistype.MANA_GAIN_EVENT[level]
        local Event manaLoseEvent = thistype.MANA_LOSE_EVENT[level]
        set this.level = level
        set this.manaGainEvent = manaGainEvent
        set this.manaLoseEvent = manaLoseEvent
        if (target.Mana.Get() < thistype.THIS_SPELL.GetManaCost(level)) then
            set this.active = false
            call target.Event.Add(manaGainEvent)
        else
            set this.active = true
            call target.Event.Add(manaLoseEvent)
            call target.Buffs.Add(thistype.EFFECT_BUFF, level)
        endif
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Act1
        set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Death)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.EFFECT_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EffectBuffGain))
        call thistype.EFFECT_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EffectBuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        local integer iteration = thistype.THIS_SPELL.GetLevelsAmount()
        loop
            exitwhen (iteration < 1)
            set thistype.MANA_GAIN_EVENT[iteration] = Event.CreateLimit(UNIT.Mana.DUMMY_EVENT_TYPE, EventPriority.SPELLS, Real.ToInt(thistype.THIS_SPELL.GetManaCost(iteration)), GREATER_THAN_OR_EQUAL, function thistype.Event_ManaGain)
            set thistype.MANA_LOSE_EVENT[iteration] = Event.CreateLimit(UNIT.Mana.DUMMY_EVENT_TYPE, EventPriority.SPELLS, Real.ToInt(thistype.THIS_SPELL.GetManaCost(iteration)), LESS_THAN, function thistype.Event_ManaLose)
            set iteration = iteration - 1
        endloop
        call thistype(NULL).Revival.Init()
    endmethod
endstruct
    globals
        AIPurge A_I_PURGE = STRUCT_BASE
    endglobals
    struct AIPurge
        implement Allocation
        implement List
        
    static constant real AREA_RANGE = 500.
    static BoolExpr TARGET_FILTER
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if ((target.Life.Get() > target.MaxLife.Get()) and (target.Buffs.CountVisibleEx(false, true) == 0)) then
            return false
        endif
        if target.Buffs.Contains(Purge.DUMMY_BUFF) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Event
        local Unit caster = Unit.GetFromId(params.GetSubjectId())
        if caster.Classes.Contains(UnitClass.DEAD) then
            return
        endif
        set User.TEMP = caster.Owner.Get()
        local Unit target = GROUP.EnumUnits.InRange.WithCollision.GetRandom(caster.Position.X.Get(), caster.Position.Y.Get(), AREA_RANGE, TARGET_FILTER)
        if (target == NULL) then
            return
        endif
		call caster.Order.UnitTargetBySpell(Purge.THIS_SPELL, target)
    endmethod
    initMethod Init of AI_Spells
        local EventCombination whichCombination = AICastSpell.CreateBasics(Purge.THIS_SPELL, function thistype.Event)
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call whichCombination.Events.Create(UNIT.Attack.Events.Acquire2.DUMMY_EVENT_TYPE, EventPriority.AI, NULL)
    endmethod
endstruct
    globals
        Purge PURGE = STRUCT_BASE
    endglobals
    struct Purge
        implement Allocation
        implement List
        
    static UnitState THIS_STATE
    UnitModSet speedMod
    integer powerLevel
    Timer weakenTimer
    timerMethod Weaken
        local thistype this = Timer.GetExpired().GetData()
        local UnitModSet speedMod = this.speedMod
        local integer powerLevel = this.powerLevel - 1
        local Unit target = this
        set this.powerLevel = powerLevel
        call target.ModSets.Remove(speedMod)
        call speedMod.RealMods.ResetVal(thistype.THIS_STATE, thistype.SPEED_INC * (powerLevel / thistype.POWER_LEVELS))
        call target.ModSets.Add(speedMod)
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local UnitModSet speedMod = this.speedMod
        local Timer weakenTimer = this.weakenTimer
        call weakenTimer.Destroy()
        call target.ModSets.Remove(speedMod)
        call speedMod.Destroy()
    endmethod
    static real DUR
    eventMethod Event_BuffGain
        local real duration = thistype.DUR
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local UnitModSet speedMod = UnitModSet.Create()
        local Timer weakenTimer = Timer.Create()
        set this.powerLevel = thistype.POWER_LEVELS
        set this.speedMod = speedMod
        set this.weakenTimer = weakenTimer
        call weakenTimer.SetData(this)
        call speedMod.RealMods.Add(thistype.THIS_STATE, thistype.SPEED_INC)
        call target.ModSets.Add(speedMod)
        call weakenTimer.Start(duration / thistype.POWER_LEVELS, true, function thistype.Weaken)
    endmethod
    static method Start takes integer level, Unit target, real duration returns nothing
        if target.MagicImmunity.Try() then
            return
        endif
        call target.Buffs.Dispel(false, true, true)
        set thistype.DUR = duration
        call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, duration)
    endmethod
    eventMethod Event_SpellEffect
    	local integer level = params.Spell.GetLevel()
    	local Unit target = params.Unit.GetTarget()
		local real duration
		if target.Classes.Contains(UnitClass.HERO) then
			set duration = thistype.HERO_DURATION
		else
			set duration = thistype.DURATION
		endif
        call thistype.Start(level, target, duration)
    endmethod
    initMethod Init of Spells_Act1
        set thistype.THIS_STATE = UNIT.Movement.Speed.RelativeA.STATE
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    scope FolderSoakingPoison
    public struct StructTarget
        implement Allocation
        implement List
        
        static Unit CASTER
        static real DAMAGE
        Unit caster
        real damage
        Timer intervalTimer
        timerMethod Interval
            local thistype this = Timer.GetExpired().GetData()
            local Unit target = this
            call this.caster.DamageUnitBySpell(target, Math.Min(this.damage, target.Life.Get() - UNIT.Life.IMMORTAL), false, false)
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            local Timer intervalTimer = this.intervalTimer
            call intervalTimer.Destroy()
        endmethod
        eventMethod Event_BuffGain
            local Unit caster = thistype.CASTER
            local integer level = params.Buff.GetLevel()
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
			local Timer intervalTimer = Timer.Create()
            set this.caster = caster
            set this.damage = thistype.DAMAGE
            set this.intervalTimer = intervalTimer
            call intervalTimer.SetData(this)
            call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
        endmethod
        static method Start takes Unit caster, integer level, Unit target returns nothing
            local real duration
            if target.Classes.Contains(UnitClass.HERO) then
                set duration = thistype.HERO_DURATION
            else
                set duration = thistype.DURATION
            endif
            set thistype.CASTER = caster
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, duration)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DAMAGE = thistype.DAMAGE_PER_SECOND * thistype.INTERVAL
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            call UNIT.Poisoned.NORMAL_BUFF.Variants.Add(thistype.DUMMY_BUFF)
        endmethod
    endstruct
endscope
    globals
        SoakingPoison SOAKING_POISON = STRUCT_BASE
    endglobals
    struct SoakingPoison
        implement Allocation
        implement List
        
    static Event DAMAGE_EVENT
    FolderSoakingPoison_StructTarget Target = this
    FolderSoakingPoison_StructTarget LinkToStruct_Target
    static method Conditions takes Unit target returns boolean
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_Damage
        local Unit target = params.Unit.GetTrigger()
        if not thistype.Conditions(target) then
            return
        endif
        call thistype(NULL).Target.Start(params.Unit.GetDamager(), params.Unit.GetDamager().Abilities.GetLevel(thistype.THIS_SPELL), target)
    endmethod
    eventMethod Event_BuffLose
        call params.Unit.GetTrigger().Event.Remove(DAMAGE_EVENT)
    endmethod
    eventMethod Event_BuffGain
        call params.Unit.GetTrigger().Event.Add(DAMAGE_EVENT)
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Act1
        set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
        call thistype(NULL).Target.Init()
    endmethod
endstruct
    globals
        Stampede STAMPEDE = STRUCT_BASE
    endglobals
    struct Stampede
        implement Allocation
        implement List
        
    static real DAMAGE_SPEED_FACTOR_PER_INTERVAL
    static real DURATION
    static Group ENUM_GROUP
    static real LENGTH
    static real LENGTH_ADD
    static BoolExpr TARGET_FILTER
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
    Timer intervalTimer
    real speed
    real speedAdd
    Timer updateTimer
    real xAdd
    real xAddAdd
    real yAdd
    real yAddAdd
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(casterX, casterY, caster.CollisionSize.Get(true), thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real damageAmount = thistype.DAMAGE_SPEED_FACTOR_PER_INTERVAL * this.speed
            call SpotEffectWithSize.Create(casterX, casterY, thistype.SPECIAL_EFFECT_PATH, EffectLevel.NORMAL, thistype.SPECIAL_EFFECT_SCALE * caster.Scale.Get()).Destroy()
            loop
                call target.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
                call caster.DamageUnitBySpell(target, damageAmount, false, false)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    timerMethod Move
        local thistype this = Timer.GetExpired().GetData()
        local Unit target = this
        local real xAdd = this.xAdd + this.xAddAdd
        local real yAdd = this.yAdd + this.yAddAdd
        set this.speed = this.speed + this.speedAdd
        set this.xAdd = xAdd
        set this.yAdd = yAdd
        call target.Position.X.Add(xAdd)
        call target.Position.Y.Add(yAdd)
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local Timer intervalTimer = this.intervalTimer
        local Timer updateTimer = this.updateTimer
        call intervalTimer.Destroy()
        call updateTimer.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local EventResponse castParams = params.Buff.GetData()
        local Unit target = params.Unit.GetTrigger()
        local real targetX = castParams.Spot.GetTargetX()
        local real targetY = castParams.Spot.GetTargetY()
        local real angle = target.CastAngle(targetX - target.Position.X.Get(), targetY - target.Position.Y.Get())
        local thistype this = target
		local Timer intervalTimer = Timer.Create()
        local Timer updateTimer = Timer.Create()
        local real xPart = Math.Cos(angle)
        local real yPart = Math.Sin(angle)
        set this.intervalTimer = intervalTimer
        set this.speed = thistype.SPEED
        set this.speedAdd = thistype.SPEED_ADD * thistype.UPDATE_TIME
        set this.updateTimer = updateTimer
        set this.xAdd = thistype.LENGTH * xPart
        set this.xAddAdd = LENGTH_ADD * xPart
        set this.yAdd = thistype.LENGTH * yPart
        set this.yAddAdd = LENGTH_ADD * yPart
        call intervalTimer.SetData(this)
        call updateTimer.SetData(this)
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
        call updateTimer.Start(thistype.UPDATE_TIME, true, function thistype.Move)
    endmethod
    eventMethod Event_SpellEffect
        call params.Unit.GetTrigger().Buffs.Timed.StartEx(thistype.DUMMY_BUFF, params.Spell.GetLevel(), params, thistype.DURATION)
    endmethod
    initMethod Init of Spells_Act1
        set thistype.DAMAGE_SPEED_FACTOR_PER_INTERVAL = thistype.DAMAGE_SPEED_FACTOR_PER_SECOND * thistype.INTERVAL
        set thistype.DURATION = -thistype.SPEED / thistype.SPEED_ADD + Math.Sqrt(thistype.SPEED * thistype.SPEED / thistype.SPEED_ADD / thistype.SPEED_ADD + 2 * thistype.MAX_LENGTH / thistype.SPEED_ADD)
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.LENGTH = thistype.SPEED * thistype.UPDATE_TIME
        set thistype.LENGTH_ADD = thistype.SPEED_ADD * thistype.UPDATE_TIME * thistype.UPDATE_TIME
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        AIStomp A_I_STOMP = STRUCT_BASE
    endglobals
    struct AIStomp
        implement Allocation
        implement List
        
    eventMethod Event
        local Unit caster = Unit.GetFromId(params.GetSubjectId())
        if caster.Classes.Contains(UnitClass.DEAD) then
            return
        endif
        set User.TEMP = caster.Owner.Get()
        call Stomp.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(caster.Position.X.Get(), caster.Position.Y.Get(), Stomp.THIS_SPELL.GetAreaRange(caster.Abilities.GetLevel(Stomp.THIS_SPELL)), Stomp.TARGET_FILTER)
        if (Stomp.ENUM_GROUP.Count() < 2) then
            return
        endif
		call caster.Order.ImmediateBySpell(Stomp.THIS_SPELL)
    endmethod
    initMethod Init of AI_Spells
        local EventCombination whichCombination = AICastSpell.CreateBasics(Stomp.THIS_SPELL, function thistype.Event)
        call whichCombination.Periodic.Add(5.)
    endmethod
endstruct
    globals
        Stomp STOMP = STRUCT_BASE
    endglobals
    struct Stomp
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_EndCast
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        call Spot.CreateEffect(casterX, casterY, thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW).Destroy()
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(casterX, casterY, thistype.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            loop
                call target.Buffs.Timed.Start(UNIT.Stun.NORMAL_BUFF, level, thistype.STUN_DURATION)
                call caster.DamageUnitBySpell(target, thistype.DAMAGE, false, false)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    eventMethod Event_SpellEffect
        call params.Unit.GetTrigger().Knockup.Start()
    endmethod
    initMethod Init of Spells_Act1
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.SUCCESS_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
    endmethod
endstruct
    globals
        Barrage BARRAGE = STRUCT_BASE
    endglobals
    struct Barrage
        implement Allocation
        implement List
        
    static real DMG_PER_INTERVAL
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    real areaRange
    Timer intervalTimer
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if (Difficulty.SELECTED < Difficulty.HARD) then
            if target.Classes.Contains(UnitClass.STRUCTURE) then
                return false
            endif
        endif
        return true
    endmethod
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this
        local real angle = caster.Facing.Get()
        call caster.Animation.Set(UNIT.Animation.ATTACK)
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(caster.Position.X.Get() + thistype.OFFSET * Math.Cos(angle), caster.Position.Y.Get() + thistype.OFFSET * Math.Sin(angle), this.areaRange, thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            loop
                call caster.DamageUnitBySpell(target, thistype.DMG_PER_INTERVAL, false, false)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local Timer intervalTimer = this.intervalTimer
        call intervalTimer.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
		local Timer intervalTimer = Timer.Create()
        set this.areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        set this.intervalTimer = intervalTimer
        call intervalTimer.SetData(this)
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
    endmethod
    eventMethod Event_EndCast
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        call caster.Position.SetXY(params.Spot.GetTargetX(), params.Spot.GetTargetY())
        call caster.Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Act2
        set thistype.DMG_PER_INTERVAL = thistype.DMG_PER_SECOND * thistype.INTERVAL
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        AIBouncyBomb A_I_BOUNCY_BOMB = STRUCT_BASE
    endglobals
    struct AIBouncyBomb
        implement Allocation
        implement List
        
    static constant real AREA_RANGE = 500.
    static BoolExpr TARGET_FILTER
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Event
        local Unit caster = Unit.GetFromId(params.GetSubjectId())
        if caster.Classes.Contains(UnitClass.DEAD) then
            return
        endif
        set User.TEMP = caster.Owner.Get()
        local Unit target = GROUP.EnumUnits.InRange.WithCollision.GetRandom(caster.Position.X.Get(), caster.Position.Y.Get(), thistype.AREA_RANGE, thistype.TARGET_FILTER)
        if (target == NULL) then
            return
        endif
		call caster.Order.PointTargetBySpell(BouncyBomb.THIS_SPELL, target.Position.X.Get(), target.Position.Y.Get())
    endmethod
    initMethod Init of AI_Spells
        local EventCombination whichCombination = AICastSpell.CreateBasics(BouncyBomb.THIS_SPELL, function thistype.Event)
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call whichCombination.Events.Create(UNIT.Attack.Events.Acquire2.DUMMY_EVENT_TYPE, EventPriority.AI, NULL)
    endmethod
endstruct
    globals
        BouncyBomb BOUNCY_BOMB = STRUCT_BASE
    endglobals
    struct BouncyBomb
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
    static integer WAVES_AMOUNT
    static real Z_ADD_ADD
    Unit caster
    Unit dummyUnit
    real length
    real targetX
    real targetY
    Timer updateTimer
    SpellInstance whichInstance
    real xAdd
    real yAdd
    real zAdd
    real zAddAdd
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    timerMethod Ending
        local Timer durationTimer = Timer.GetExpired()
        local thistype this = durationTimer.GetData()
        local Unit caster = this.caster
        local DummyUnit dummyUnit = this.dummyUnit
        local Timer updateTimer = this.updateTimer
        local SpellInstance whichInstance = this.whichInstance
        local integer level = whichInstance.GetLevel()
        local real x = dummyUnit.Position.X.Get()
        local real y = dummyUnit.Position.Y.Get()
        local real z = dummyUnit.Position.Z.Get()
        call this.deallocate()
        call dummyUnit.Destroy()
        call durationTimer.Destroy()
        call updateTimer.Destroy()
        call Spot.CreateEffectWithZ(x, y, z, thistype.EXPLOSION_EFFECT_PATH, EffectLevel.LOW).Destroy()
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.DoWithZ(x, y, z, thistype.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real maxDamage = thistype.MAX_DAMAGE
            loop
                local real damage = Math.Min(thistype.DAMAGE, maxDamage)
                set maxDamage = maxDamage - damage
                call caster.DamageUnitBySpell(target, damage, true, false)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
        call whichInstance.Destroy()
    endmethod
    timerMethod Move
        local thistype this = Timer.GetExpired().GetData()
        local DummyUnit dummyUnit = this.dummyUnit
        local real zAdd = this.zAdd + thistype.Z_ADD_ADD
        call dummyUnit.Position.Add(this.xAdd, this.yAdd, zAdd)
        if (dummyUnit.Position.Z.GetFlyHeight() < thistype.FLOOR_TOLERANCE) then
            set this.zAdd = Math.Abs(zAdd)
        else
            set this.zAdd = zAdd
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
		local thistype this = thistype.allocate()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real casterZ = caster.Position.Z.Get() + caster.Outpact.Z.Get(true)
		local Timer durationTimer = Timer.Create()
		local Timer updateTimer = Timer.Create()
        local SpellInstance whichInstance = SpellInstance.Create(caster, thistype.THIS_SPELL)
        local real dX = targetX - caster.Position.X.Get()
        local real dY = targetY - caster.Position.Y.Get()
        local real angle = caster.CastAngle(dX, dY)
        local real d = Math.DistanceByDeltas(dX, dY)
        local DummyUnit dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, casterX, casterY, casterZ, angle)
        local real lengthXY = d / thistype.WAVES_AMOUNT
        local real lengthX = lengthXY * Math.Cos(angle)
        local real lengthY = lengthXY * Math.Sin(angle)
        local real lengthZ = ((Spot.GetHeight(targetX, targetY) - casterZ) / thistype.FIRST_BOUNCE_DURATION - thistype.Z_ACCELERATION / 2 * thistype.FIRST_BOUNCE_DURATION) * thistype.UPDATE_TIME
        set this.caster = caster
        set this.dummyUnit = dummyUnit
        set this.length = Math.DistanceByDeltasWithZ(lengthX, lengthY, lengthZ)
        set this.targetX = targetX
        set this.targetY = targetY
        set this.updateTimer = updateTimer
        set this.whichInstance = whichInstance
        set this.xAdd = lengthX
        set this.yAdd = lengthY
        set this.zAdd = lengthZ
        call durationTimer.SetData(this)
        call updateTimer.SetData(this)
        call updateTimer.Start(thistype.UPDATE_TIME, true, function thistype.Move)
        call durationTimer.Start(thistype.EXPLOSION_DURATION, false, function thistype.Ending)
    endmethod
    initMethod Init of Spells_Act2
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        set thistype.WAVES_AMOUNT = Real.ToInt(thistype.EXPLOSION_DURATION / thistype.UPDATE_TIME)
        set thistype.Z_ADD_ADD = thistype.Z_ACCELERATION * thistype.UPDATE_TIME * thistype.UPDATE_TIME
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        BurningOil BURNING_OIL = STRUCT_BASE
    endglobals
    struct BurningOil
        implement Allocation
        implement List
        
    static real DAMAGE_PER_INTERVAL
    static Group ENUM_GROUP
    static Event GROUND_ATTACK_EVENT
    static BoolExpr TARGET_FILTER
    Unit caster
    Timer durationTimer
    Timer intervalTimer
    integer level
    SpotEffect specialEffect
    real targetX
    real targetY
    timerMethod Ending
        local Timer durationTimer = Timer.GetExpired()
        local thistype this = durationTimer.GetData()
        local Timer intervalTimer = this.intervalTimer
        local SpotEffect specialEffect = this.specialEffect
        call this.deallocate()
        call durationTimer.Destroy()
        call intervalTimer.Destroy()
        call specialEffect.Destroy()
    endmethod
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this.caster
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(targetX, targetY, thistype.THIS_SPELL.GetAreaRange(this.level), thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            loop
                call caster.DamageUnitBySpell(target, thistype.DAMAGE_PER_INTERVAL, false, false)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    eventMethod Event_GroundAttack
        local Unit caster = params.Unit.GetTrigger()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
		local integer level = caster.Abilities.GetLevel(thistype.THIS_SPELL)
		local thistype this = thistype.allocate()
        local Timer durationTimer = Timer.Create()
        local Timer intervalTimer = Timer.Create()
        set this.caster = caster
        set this.intervalTimer = intervalTimer
        set this.level = level
        set this.specialEffect = Spot.CreateEffect(targetX, targetY, thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW)
        set this.targetX = targetX
        set this.targetY = targetY
        call durationTimer.SetData(this)
        call intervalTimer.SetData(this)
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
        call durationTimer.Start(thistype.DURATION, false, function thistype.Ending)
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        call target.Event.Remove(GROUND_ATTACK_EVENT)
		call target.Abilities.RemoveBySelf(thistype.MISSILE_GRAPHIC_SPELL_ID)
    endmethod
    eventMethod Event_BuffGain
        local Unit target = params.Unit.GetTrigger()
		call target.Event.Add(GROUND_ATTACK_EVENT)
        call target.Abilities.AddBySelf(thistype.MISSILE_GRAPHIC_SPELL_ID)
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Act2
        set thistype.DAMAGE_PER_INTERVAL = thistype.DAMAGE_PER_SECOND * thistype.INTERVAL
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.GROUND_ATTACK_EVENT = Event.Create(UNIT.Attack.Events.Ground.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_GroundAttack)
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
    endmethod
endstruct
    globals
        ChainLightning CHAIN_LIGHTNING = STRUCT_BASE
    endglobals
    struct ChainLightning
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    real areaRange
    Unit caster
    real damage
    real damageReductionFactor
    Missile dummyMissile
    integer level
    integer maxTargetsAmount
    Unit target
    Group targetGroup
    integer targetsAmount
    method Ending takes Group targetGroup returns nothing
        call this.deallocate()
        call targetGroup.Destroy()
    endmethod
    static method Conditions takes Unit target returns boolean
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    condMethod Conditions_Group
        local Unit target = UNIT.Event.Native.GetFilter()
        if Group.TEMP.ContainsUnit(target) then
            return false
        endif
        if not thistype.Conditions(target) then
            return false
        endif
        return true
    endmethod
    method StartMissile takes LightningType boltType, Unit oldTarget, Unit target, Group targetGroup returns nothing
        local Missile dummyMissile = Missile.Create()
        local Lightning effectLightning = Lightning.Create(boltType)
        set this.dummyMissile = dummyMissile
        set this.target = target
        call effectLightning.FromUnitToUnit.Start(oldTarget, target)
        call targetGroup.AddUnit(target)
        call effectLightning.DestroyTimed.Start(0.75)
        call dummyMissile.CollisionSize.Set(10.)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(Math.Max(Math.DistanceByDeltas(target.Position.X.Get() - oldTarget.Position.X.Get(), target.Position.Y.Get() - oldTarget.Position.Y.Get()) / 0.25, 700.))
        call dummyMissile.Position.SetFromUnit(oldTarget)
        call dummyMissile.GoToUnit.Start(target, null)
    endmethod
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        local integer maxTargetsAmount = this.maxTargetsAmount
        local integer targetsAmount = this.targetsAmount
        local Unit target = this.target
        local Group targetGroup = this.targetGroup
        if (target != NULL) then
            call target.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
            set User.TEMP = caster.Owner.Get()
            if (thistype.Conditions(target)) then
                local real damage = this.damage
                set this.damage = damage * (1. - this.damageReductionFactor)
                call caster.DamageUnitBySpell(target, damage, true, false)
            endif
        endif
        if (targetsAmount == maxTargetsAmount) then
            call this.Ending(targetGroup)
        else
            local real targetX = target.Position.X.Get()
            local real targetY = target.Position.Y.Get()
            set Group.TEMP = targetGroup
            set User.TEMP = caster.Owner.Get()
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(targetX, targetY, this.areaRange, thistype.TARGET_FILTER)
            local Unit newTarget = thistype.ENUM_GROUP.GetNearest(targetX, targetY)
            if (newTarget == NULL) then
                call this.Ending(targetGroup)
            else
                set this.targetsAmount = targetsAmount + 1
                call this.StartMissile(thistype.BOLT_SECONDARY, target, newTarget, targetGroup)
            endif
        endif
        call dummyMissile.Destroy()
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local thistype this = thistype.allocate()
		local Group targetGroup = Group.Create()
        set this.areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        set this.caster = caster
        set this.damage = thistype.DAMAGE
        set this.damageReductionFactor = thistype.DAMAGE_REDUCTION_FACTOR
        set this.level = level
        set this.maxTargetsAmount = thistype.TARGETS_AMOUNT
        set this.targetGroup = targetGroup
        set this.targetsAmount = 1
        call this.StartMissile(thistype.BOLT_PRIMARY, caster, target, targetGroup)
    endmethod
    initMethod Init of Spells_Act2
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions_Group)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    scope FolderCleaver
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return Cleaver(this).Data.table.IntegerKeys.Table.ContainsInteger(Cleaver(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return Cleaver(this).Data.table.IntegerKeys.Table.CountIntegers(Cleaver(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return Cleaver(this).Data.table.IntegerKeys.Table.IsEmptyInteger(Cleaver(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return Cleaver(this).Data.table.IntegerKeys.Table.GetInteger(Cleaver(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return Cleaver(this).Data.table.IntegerKeys.Table.GetFirstInteger(Cleaver(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return Cleaver(this).Data.table.IntegerKeys.Table.GetLastInteger(Cleaver(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call Cleaver(this).Data.table.IntegerKeys.Table.Clear(Cleaver(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return Cleaver(this).Data.table.IntegerKeys.Table.FetchFirstInteger(Cleaver(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return Cleaver(this).Data.table.IntegerKeys.Table.RemoveInteger(Cleaver(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return Cleaver(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(Cleaver(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return Cleaver(this).Data.table.IntegerKeys.Table.AddInteger(Cleaver(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return Cleaver(this).Data.table.IntegerKeys.Table.AddIntegerMulti(Cleaver(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call Cleaver(this).Data.table.IntegerKeys.Table.JoinInteger(Cleaver(this).Id.Get(), key, Cleaver(other).Data.table, Cleaver(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return Cleaver(this).Data.table.IntegerKeys.Table.RandomInteger(Cleaver(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call Cleaver(this).Data.table.IntegerKeys.Table.ShuffleIntegers(Cleaver(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call Cleaver(this).Data.table.IntegerKeys.Table.PrintIntegers(Cleaver(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return Cleaver(this).Data.table.IntegerKeys.GetInteger(Cleaver(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call Cleaver(this).Data.table.IntegerKeys.RemoveInteger(Cleaver(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call Cleaver(this).Data.table.IntegerKeys.SetInteger(Cleaver(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(Cleaver(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject Cleaver.Allocation.deallocate_demount.hook
		call Cleaver(this).Data.Destroy()
	endinject
	inject Cleaver.Allocation.allocate_mount.hook
		call Cleaver(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructWave
        implement Allocation
        implement List
        
        static Group ENUM_GROUP
        static real LENGTH
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
        static BoolExpr TARGET_FILTER
        DummyUnit dummyUnit
        Cleaver parent
        real x
        real xAdd
        real y
        real yAdd
        method Ending takes nothing returns nothing
            local Cleaver parent = this
            local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
            if (iteration < Memory.IntegerKeys.Table.STARTED) then
                return
            endif
            loop
                set this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                local DummyUnit dummyUnit = this.dummyUnit
                call this.deallocate()
                call dummyUnit.Destroy()
                call parent.Data.Integer.Table.Remove(KEY_ARRAY, this)
                set iteration = iteration - 1
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            endloop
        endmethod
        condMethod Conditions
            local Unit target = UNIT.Event.Native.GetFilter()
            if target.Classes.Contains(UnitClass.DEAD) then
                return false
            endif
            if not target.Classes.Contains(UnitClass.GROUND) then
                return false
            endif
            if target.IsAllyOf(User.TEMP) then
                return false
            endif
            if Group.TEMP.ContainsUnit(target) then
                return false
            endif
            return true
        endmethod
        method DealDamage takes nothing returns nothing
            local Cleaver parent = this
            local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
            if (iteration < Memory.IntegerKeys.Table.STARTED) then
                return
            endif
            local Unit caster = parent.caster
            local integer level = parent.level
            local real maxDamage = parent.maxDamage
            local Group targetGroup = parent.targetGroup
            local User casterOwner = caster.Owner.Get()
            loop
                set this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                set Group.TEMP = targetGroup
                set User.TEMP = casterOwner
                call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(this.x, this.y, thistype.AREA_RANGE, thistype.TARGET_FILTER)
                local Unit target = thistype.ENUM_GROUP.FetchFirst()
                if (target != NULL) then
                    loop
                        call targetGroup.AddUnit(target)
                        if not target.MagicImmunity.Try() then
                            local real damage = Math.Min(thistype.DAMAGE, maxDamage)
                            set maxDamage = maxDamage - damage
                            call caster.DamageUnitBySpell(target, damage, false, false)
                        endif
                        set target = thistype.ENUM_GROUP.FetchFirst()
                        exitwhen (target == NULL)
                    endloop
                endif
                set iteration = iteration - 1
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            endloop
            set parent.maxDamage = maxDamage
        endmethod
        method Move takes nothing returns nothing
            local Cleaver parent = this
            local integer iteration = parent.Data.Integer.Table.Count(KEY_ARRAY)
            if (iteration < Memory.IntegerKeys.Table.STARTED) then
                return
            endif
            loop
                set this = parent.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                local real x = this.x + this.xAdd
                local real y = this.y + this.yAdd
                set this.x = x
                set this.y = y
                call this.dummyUnit.Position.SetXY(x, y)
                set iteration = iteration - 1
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            endloop
        endmethod
        method Start takes real x, real y, real angle returns nothing
            local Cleaver parent = this
            local real xPart = Math.Cos(angle)
            local real yPart = Math.Sin(angle)
            set this = thistype.allocate()
            set x = x + thistype.OFFSET * xPart
            set y = y + thistype.OFFSET * yPart
            set this.dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, x, y, Spot.GetHeight(x, y), angle)
            set this.parent = parent
            set this.x = x
            set this.xAdd = thistype.LENGTH * xPart
            set this.y = y
            set this.yAdd = thistype.LENGTH * yPart
            call parent.Data.Integer.Table.Add(KEY_ARRAY, this)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.ENUM_GROUP = Group.Create()
            set thistype.LENGTH = thistype.SPEED * thistype.UPDATE_TIME
            set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        endmethod
    endstruct
endscope
    globals
        Cleaver CLEAVER = STRUCT_BASE
    endglobals
    struct Cleaver
        implement Allocation
        implement List
        
    static real DURATION
    Unit caster
    Timer intervalTimer
    integer level
    real maxDamage
    Group targetGroup
    Timer updateTimer
    FolderCleaver_StructData Data = this
    FolderCleaver_StructData LinkToStruct_Data
    FolderCleaver_StructId Id = this
    FolderCleaver_StructId LinkToStruct_Id
    	struct Event
    	DataTable table
        method Contains takes Event whichEvent returns boolean
            
            return this.table.IntegerKeys.Table.ContainsInteger(Cleaver(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Count takes EventType whichType, EventPriority priority returns integer
            
            return this.table.IntegerKeys.Table.CountIntegers(Cleaver(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority))
        endmethod
        method Get takes EventType whichType, EventPriority priority, integer index returns Event
            
            return this.table.IntegerKeys.Table.GetInteger(Cleaver(this).Id.Get(), Event.GetKeyFromTypePriority(whichType, priority), index)
        endmethod
        method Remove takes Event whichEvent returns nothing
            
                
              
            
            
            if not this.table.IntegerKeys.Table.ContainsInteger(Cleaver(this).Id.Get(), whichEvent.GetKey(), whichEvent) then
                call DebugEx("subject "+I2S(Cleaver(this).Id.Get()) + " has not " + whichEvent.GetName())
                return
            endif
            call this.table.IntegerKeys.Table.RemoveInteger(Cleaver(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
        method Add takes Event whichEvent returns nothing
        	if (this.table == NULL) then
            	call DebugEx("no table "+I2S(this)+";"+whichEvent.GetName())
            	set this.table = Memory
        	endif
            
            call this.table.IntegerKeys.Table.AddInteger(Cleaver(this).Id.Get(), whichEvent.GetKey(), whichEvent)
        endmethod
		method Clear takes nothing returns nothing
			call this.table.IntegerKeys.RemoveChild(Cleaver(this).Id.Get())
		endmethod
		method Destroy takes nothing returns nothing
			call this.Clear()
		endmethod
		method Event_Create takes nothing returns nothing
			set this.table = Event.GetRandomTable()
		endmethod
		inject Cleaver.Allocation.deallocate_demount.hook
			call Cleaver(this).Event.Destroy()
		endinject
		inject Cleaver.Allocation.allocate_mount.hook
			call Cleaver(this).Event.Event_Create()
		endinject
    	endstruct
    FolderCleaver_StructWave Wave = this
    FolderCleaver_StructWave LinkToStruct_Wave
    timerMethod Ending
        local Timer durationTimer = Timer.GetExpired()
        local thistype this = durationTimer.GetData()
        local Timer intervalTimer = this.intervalTimer
        local Group targetGroup = this.targetGroup
        local Timer updateTimer = this.updateTimer
        call this.Wave.Ending()
        call this.deallocate_demount()
        call durationTimer.Destroy()
        call intervalTimer.Destroy()
        call targetGroup.Destroy()
        call updateTimer.Destroy()
    endmethod
    timerMethod DealDamage
        local thistype this = Timer.GetExpired().GetData()
        call this.Wave.DealDamage()
    endmethod
    timerMethod Move
        local thistype this = Timer.GetExpired().GetData()
        call this.Wave.Move()
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local thistype this = thistype.allocate_mount(caster)
        local Timer durationTimer = Timer.Create()
        local Timer intervalTimer = Timer.Create()
        local Timer updateTimer = Timer.Create()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real dX = targetX - casterX
        local real dY = targetY - casterY
        local real angle = caster.CastAngle(dX, dY)
        set this.caster = caster
        set this.intervalTimer = intervalTimer
        set this.level = level
        set this.maxDamage = thistype.MAX_DAMAGE
        set this.targetGroup = Group.Create()
        set this.updateTimer = updateTimer
        call durationTimer.SetData(this)
        call intervalTimer.SetData(this)
        call updateTimer.SetData(this)
        call this.Id.Event_Create()
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.DealDamage)
        call updateTimer.Start(thistype(NULL).Wave.UPDATE_TIME, true, function thistype.Move)
        call durationTimer.Start(thistype.DURATION, false, function thistype.Ending)
        call this.Wave.Start(casterX, casterY, angle)
        call this.Wave.Start(casterX, casterY, angle - Math.QUARTER_ANGLE / 3)
        call this.Wave.Start(casterX, casterY, angle + Math.QUARTER_ANGLE / 3)
    endmethod
    initMethod Init of Spells_Act2
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Wave.Init()
        set thistype.DURATION = thistype(NULL).Wave.MAX_LENGTH / thistype(NULL).Wave.SPEED
    endmethod
endstruct
    globals
        ColdResistance COLD_RESISTANCE = STRUCT_BASE
    endglobals
    struct ColdResistance
        implement Allocation
        implement List
        
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.AddFresh(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Act2
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
    endmethod
endstruct
    globals
        DeathAxe DEATH_AXE = STRUCT_BASE
    endglobals
    struct DeathAxe
        implement Allocation
        implement List
        
    static Event DEATH_EVENT
    static BoolExpr MISSILE_TARGET_FILTER
    static BoolExpr TARGET_FILTER
    Unit caster
    real damage
    Timer delayTimer
    integer level
    condMethod TargetConditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.NEUTRAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    condEventMethod Missile_TargetConditions
		local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        set User.TEMP = this.caster.Owner.Get()
        if not thistype.TargetConditions() then
            return false
        endif
        return true
    endmethod
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = dummyMissile.GetData()
        if (target == NULL) then
            call this.deallocate()
            call dummyMissile.Destroy()
            return
        endif
        local Unit caster = this.caster
        local real damage = this.damage
        call this.deallocate()
        call dummyMissile.Destroy()
        if target.MagicImmunity.Try() then
            return
        endif
        call caster.DamageUnitBySpell(target, damage, true, false)
        call target.Buffs.Timed.Start(UNIT.Attack.NORMAL_BUFF, this.level, thistype.DISARM_DURATION)
    endmethod
    timerMethod Delay
        local Timer delayTimer = Timer.GetExpired()
        local thistype this = delayTimer.GetData()
        local Unit caster = this.caster
        local integer level = this.level
        local real startX = caster.Position.X.Get()
        local real startY = caster.Position.Y.Get()
        local real maxLength = thistype.THIS_SPELL.GetRange(level)
        call delayTimer.Destroy()
        set User.TEMP = caster.Owner.Get()
        local Unit target = GROUP.EnumUnits.InRange.WithCollision.GetNearest(startX, startY, thistype.THIS_SPELL.GetRange(level), thistype.TARGET_FILTER)
        if (target == NULL) then
            call this.deallocate()
        else
            local real targetX = target.Position.X.Get()
            local real targetY = target.Position.Y.Get()
            local real angle = Math.AtanByDeltas(targetY - startY, targetX - startX)
			local Missile dummyMissile = Missile.Create()
            local DummyUnit dummyUnit = dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1.5)
            call dummyMissile.Acceleration.Set(500.)
            call dummyMissile.CollisionSize.Set(thistype.THIS_SPELL.GetAreaRange(level))
            call dummyMissile.Impact.SetAction(function thistype.Impact)
            call dummyMissile.SetData(this)
            call dummyMissile.Speed.Set(350.)
            call dummyMissile.Position.SetFromUnit(caster)
            call dummyUnit.AddEffect(thistype.DUMMY_EFFECT_PATH, thistype.DUMMY_EFFECT_ATTACH_POINT, EffectLevel.LOW)
            call dummyMissile.Impact.SetFilter(thistype.MISSILE_TARGET_FILTER)
            call dummyMissile.GoToSpot.Start(startX + maxLength * Math.Cos(angle), startY + maxLength * Math.Sin(angle), Spot.GetHeight(targetX, targetY) + UNIT_TYPE.Impact.Z.STANDARD)
        endif
        call caster.Refs.Subtract()
    endmethod
    static method Start takes Unit caster, integer level returns nothing
        local thistype this = thistype.allocate()
		local Timer delayTimer = Timer.Create()
        set this.caster = caster
        set this.damage = thistype.DAMAGE
        set this.delayTimer = delayTimer
        set this.level = level
        call delayTimer.SetData(this)
        call caster.Refs.Add()
        call delayTimer.Start(thistype.DELAY, false, function thistype.Delay)
    endmethod
    eventMethod Event_Death
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        call thistype.Start(caster, level)
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Event.Remove(DEATH_EVENT)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Event.Add(DEATH_EVENT)
    endmethod
    initMethod Init of Spells_Act2
        set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Death)
        set thistype.MISSILE_TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Missile_TargetConditions)
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.TargetConditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
    endmethod
endstruct
    scope FolderDrumRoll
    public struct StructTarget
        implement Allocation
        implement List
        
    	static Event ENDING_EVENT
        static Event START_EVENT
		eventMethod Event_Ending
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local DrumRoll parent = aura.GetData()
			call target.Buffs.Subtract(thistype.DUMMY_BUFF)
		endmethod
		eventMethod Event_Start
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local Unit caster = aura.GetCaster()
			local DrumRoll parent = aura.GetData()
			local integer level = parent.level
			call target.Buffs.Add(thistype.DUMMY_BUFF, level)
		endmethod
        static method Init takes nothing returns nothing
            set thistype.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Ending)
            set thistype.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Start)
        endmethod
    endstruct
endscope
    globals
        DrumRoll DRUM_ROLL = STRUCT_BASE
    endglobals
    struct DrumRoll
        implement Allocation
        implement List
        
    static BoolExpr TARGET_FILTER
    Aura aura
    integer level
    FolderDrumRoll_StructTarget Target = this
    FolderDrumRoll_StructTarget LinkToStruct_Target
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if not target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local Aura aura = this.aura
        call aura.Destroy()
    endmethod
    eventMethod Event_BuffGain
    	local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
		local Aura aura = Aura.Create(target)
        set this.aura = aura
        set this.level = level
        call aura.SetData(this)
		call aura.SetAreaRange(thistype.THIS_SPELL.GetAreaRange(level))
        call aura.SetTargetFilter(thistype.TARGET_FILTER)
		call aura.Event.Add(thistype(NULL).Target.ENDING_EVENT)
		call aura.Event.Add(thistype(NULL).Target.START_EVENT)
		call aura.Enable()
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.AddFresh(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Act2
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
        call thistype(NULL).Target.Init()
    endmethod
endstruct
    scope FolderEnvenomedSpears
    public struct StructTarget
        implement Allocation
        implement List
        
        static real DAMAGE
        Unit caster
        real damage
        Timer intervalTimer
        timerMethod Interval
            local thistype this = Timer.GetExpired().GetData()
            local Unit target = this
            call this.caster.DamageUnitBySpell(target, Math.Min(this.damage, target.Life.Get() - UNIT.Life.IMMORTAL), false, false)
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            local Timer intervalTimer = this.intervalTimer
            call intervalTimer.Destroy()
        endmethod
        eventMethod Event_BuffGain
            local Unit caster = params.Buff.GetData()
            local integer level = params.Buff.GetLevel()
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
			local Timer intervalTimer = Timer.Create()
            set this.caster = caster
            set this.damage = thistype.DAMAGE
            set this.intervalTimer = intervalTimer
            call intervalTimer.SetData(this)
            call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
        endmethod
        static method Start takes Unit caster, integer level, Unit target returns nothing
            local real duration
            if target.Classes.Contains(UnitClass.HERO) then
                set duration = thistype.HERO_DURATION
            else
                set duration = thistype.DURATION
            endif
            call target.Buffs.Timed.StartEx(thistype.DUMMY_BUFF, level, caster, duration)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DAMAGE = thistype.DAMAGE_PER_SECOND * thistype.INTERVAL
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            call UNIT.Poisoned.NORMAL_BUFF.Variants.Add(thistype.DUMMY_BUFF)
        endmethod
    endstruct
endscope
    globals
        EnvenomedSpears ENVENOMED_SPEARS = STRUCT_BASE
    endglobals
    struct EnvenomedSpears
        implement Allocation
        implement List
        
    static Event DAMAGE_EVENT
    FolderEnvenomedSpears_StructTarget Target = this
    FolderEnvenomedSpears_StructTarget LinkToStruct_Target
    static method Conditions takes Unit target returns boolean
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_Damage
        local Unit target = params.Unit.GetTrigger()
        if not thistype.Conditions(target) then
            return
        endif
        call thistype(NULL).Target.Start(params.Unit.GetDamager(), params.Unit.GetDamager().Abilities.GetLevel(thistype.THIS_SPELL), target)
    endmethod
    eventMethod Event_BuffLose
        call params.Unit.GetTrigger().Event.Remove(DAMAGE_EVENT)
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_BuffGain
        call params.Unit.GetTrigger().Event.Add(DAMAGE_EVENT)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Act2
        set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
        call thistype(NULL).Target.Init()
    endmethod
endstruct
    globals
        AIKnockout A_I_KNOCKOUT = STRUCT_BASE
    endglobals
    struct AIKnockout
        implement Allocation
        implement List
        
    static constant real AREA_RANGE = 500.
    static BoolExpr TARGET_FILTER
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Event
        local Unit caster = Unit.GetFromId(params.GetSubjectId())
        if caster.Classes.Contains(UnitClass.DEAD) then
            return
        endif
        set User.TEMP = caster.Owner.Get()
        local Unit target = GROUP.EnumUnits.InRange.WithCollision.GetRandom(caster.Position.X.Get(), caster.Position.Y.Get(), thistype.AREA_RANGE, thistype.TARGET_FILTER)
        if (target != NULL) then
            call caster.Order.UnitTargetBySpell(Knockout.THIS_SPELL, target)
        endif
    endmethod
    initMethod Init of AI_Spells
        local EventCombination whichCombination = AICastSpell.CreateBasics(Knockout.THIS_SPELL, function thistype.Event)
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call whichCombination.Events.Create(UNIT.Attack.Events.Acquire2.DUMMY_EVENT_TYPE, EventPriority.AI, NULL)
    endmethod
endstruct
    scope FolderKnockout
    public struct StructTarget
        implement Allocation
        implement List
        
        eventMethod Event_BuffGain
            local integer level = params.Buff.GetLevel()
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            call target.Buffs.Timed.Start(UNIT.Stun.NORMAL_BUFF, level, thistype.STUN_DURATION)
        endmethod
        static method Start takes Unit caster, integer level, Unit target returns nothing
            if not target.Buffs.Contains(thistype.DUMMY_BUFF) then
                call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.BUFF_DURATION)
            endif
            call target.Position.Timed.Accelerated.AddKnockback(900., -900., Math.AtanByDeltas(target.Position.Y.Get() - caster.Position.Y.Get(), target.Position.X.Get() - caster.Position.X.Get()), 0.14)
            call caster.DamageUnitBySpell(target, thistype.DAMAGE, true, false)
        endmethod
        static method Init takes nothing returns nothing
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        endmethod
    endstruct
endscope
    globals
        Knockout KNOCKOUT = STRUCT_BASE
    endglobals
    struct Knockout
        implement Allocation
        implement List
        
    Unit caster
    integer level
    Unit target
    FolderKnockout_StructTarget Target = this
    FolderKnockout_StructTarget LinkToStruct_Target
    static method Conditions takes Unit caster, Unit target returns boolean
        if (target == NULL) then
            return false
        endif
        if target.IsAllyOf(caster.Owner.Get()) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        local integer level = this.level
        local Unit target = this.target
		call this.deallocate_demount()
        call dummyMissile.Destroy()
		if (target == NULL) then
			return
		endif
        if thistype.Conditions(caster, target) then
            call thistype(NULL).Target.Start(caster, level, target)
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
		local Missile dummyMissile = Missile.Create()
		local thistype this = thistype.allocate_mount(dummyMissile)
        set this.caster = caster
        set this.level = level
        set this.target = target
        call caster.Position.SetWithCollision(target.Position.X.Get(), target.Position.Y.Get())
        call caster.Facing.SetToUnit(target)
        call dummyMissile.CollisionSize.Set(10.)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 2.)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(700.)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.GoToUnit.Start(target, null)
    endmethod
    initMethod Init of Spells_Act2
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Target.Init()
    endmethod
endstruct
    globals
        AIMedipack A_I_MEDIPACK = STRUCT_BASE
    endglobals
    struct AIMedipack
        implement Allocation
        implement List
        
    eventMethod Event
        call Unit.GetFromId(params.GetSubjectId()).Order.ImmediateBySpell(Medipack.THIS_SPELL)
    endmethod
    condEventMethod Event_StartConditions
        local Unit caster = Unit.GetFromId(params.GetSubjectId())
        if (caster.Life.Get() >= Real.ToInt(UnitType.ASSASSIN.Life.Get() - Medipack.HEAL)) then
            return false
        endif
        return true
    endmethod
    initMethod Init of AI_Spells
        local EventCombination whichCombination = AICastSpell.CreateBasics(Medipack.THIS_SPELL, function thistype.Event)
        call whichCombination.Pairs.CreateLimit(UNIT.Life.DUMMY_EVENT_TYPE, Real.ToInt(UnitType.ASSASSIN.Life.Get() - Medipack.HEAL), LESS_THAN, BoolExpr.GetFromFunction(function thistype.Event_StartConditions))
    endmethod
endstruct
    globals
        Medipack MEDIPACK = STRUCT_BASE
    endglobals
    struct Medipack
        implement Allocation
        implement List
        
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        call caster.Effects.Create(thistype.CASTER_EFFECT_PATH, thistype.CASTER_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
        call caster.Buffs.Dispel(true, false, true)
        call caster.HealBySpell(caster, thistype.HEAL)
    endmethod
    initMethod Init of Spells_Act2
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        MutingShout MUTING_SHOUT = STRUCT_BASE
    endglobals
    struct MutingShout
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        call Spot.CreateEffect(casterX, casterY, thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW).Destroy()
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(casterX, casterY, thistype.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        local integer targetsAmount = 0
        if (target != NULL) then
            loop
                set targetsAmount = targetsAmount + 1
                call target.Buffs.Timed.Start(thistype.SILENCE_BUFF, level, thistype.SILENCE_DURATION)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
        call caster.HealBySpell(caster, thistype.HEAL_FACTOR * caster.MaxLife.Get() * targetsAmount)
    endmethod
    initMethod Init of Spells_Act2
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call UNIT.Silence.NORMAL_BUFF.Variants.Add(thistype.SILENCE_BUFF)
    endmethod
endstruct
    globals
        Realplex REALPLEX = STRUCT_BASE
    endglobals
    struct Realplex
        implement Allocation
        implement List
        
    static Event CASTER_DEATH_EVENT
    static Group ENUM_GROUP
    static Event ILLUSION_DEATH_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    Unit caster
    Timer durationTimer
    UnitList illusionGroup
    method EndIllusion takes Unit illusion, UnitList illusionGroup returns nothing
        call illusion.Data.Integer.Remove(KEY)
        call illusion.Event.Remove(ILLUSION_DEATH_EVENT)
        call illusionGroup.Remove(illusion)
    endmethod
    method Ending takes Unit caster, UnitList illusionGroup returns nothing
        local Timer durationTimer = this.durationTimer
        local Unit illusion
        call this.deallocate()
        call durationTimer.Destroy()
        call caster.Data.Integer.Remove(KEY)
        call caster.Event.Remove(CASTER_DEATH_EVENT)
        loop
            set illusion = illusionGroup.GetFirst()
            exitwhen (illusion == NULL)
            call illusion.KillInstantly()
        endloop
        call illusionGroup.Destroy()
    endmethod
    eventMethod Event_Illusion_Death
        local Unit illusion = params.Unit.GetTrigger()
        local thistype this = illusion.Data.Integer.Get(KEY)
        local UnitList illusionGroup = this.illusionGroup
        call this.EndIllusion(illusion, illusionGroup)
    endmethod
    eventMethod Event_Caster_Death
        local thistype this = params.Unit.GetTrigger().Data.Integer.Get(KEY)
        call this.Ending(this.caster, this.illusionGroup)
    endmethod
    timerMethod MoveEnding
        local thistype this = Timer.GetExpired().GetData()
        local UnitList illusionGroup = this.illusionGroup
		local Unit illusion
        loop
            set illusion = illusionGroup.FetchFirst()
            exitwhen (illusion == NULL)
            call thistype.ENUM_GROUP.AddUnit(illusion)
            call illusion.Pathing.Add()
        endloop
        call this.caster.Pathing.Add()
        loop
            set illusion = thistype.ENUM_GROUP.FetchFirst()
            exitwhen (illusion == NULL)
            call illusionGroup.Add(illusion)
            call illusion.Pathing.Add()
            call PauseUnit(illusion.self, false)
        endloop
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real casterFacing = caster.Facing.Get()
        local User casterOwner = caster.Owner.Get()
        local UnitType casterType = caster.Type.Get()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        
        local thistype this = caster.Data.Integer.Get(KEY)
        local real angle = casterFacing - Math.QUARTER_ANGLE
        local real xAdd = thistype.OFFSET * Math.Cos(angle)
        local real yAdd = thistype.OFFSET * Math.Sin(angle)
        local real x = casterX - thistype.ILLUSIONS_AMOUNT / 2 * xAdd
        local real y = casterY - thistype.ILLUSIONS_AMOUNT / 2 * yAdd
        call Spot.CreateEffect(casterX, casterY, thistype.CASTER_EFFECT_PATH, EffectLevel.LOW).Destroy()
        if (this != NULL) then
            call this.Ending(caster, this.illusionGroup)
        endif
        set this = thistype.allocate()
		local Timer durationTimer = Timer.Create()
		local UnitList illusionGroup = UnitList.Create()
        set this.caster = caster
        set this.durationTimer = durationTimer
        set this.illusionGroup = illusionGroup
        call caster.Data.Integer.Set(KEY, this)
        call caster.Event.Add(CASTER_DEATH_EVENT)
        call durationTimer.SetData(this)
        call caster.Pathing.Subtract()
		local integer iteration = thistype.ILLUSIONS_AMOUNT + 1
		local integer random = Math.RandomI(1, thistype.ILLUSIONS_AMOUNT)
        loop
            exitwhen (iteration < 1)
            if (iteration == random) then
                call caster.Position.Timed.SetXY(x, y, thistype.MOVE_DURATION)
            else
                local Unit illusion = Unit.CreateIllusion(casterType, casterOwner, casterX, casterY, casterFacing, thistype.DURATION, DEATH_EFFECT_PATH)
                call illusion.Damage.Relative.Invisible.Add(0.5)
                call illusion.Data.Integer.Set(KEY, this)
                call illusion.Event.Add(ILLUSION_DEATH_EVENT)
                call illusion.Pathing.Subtract()
                call illusionGroup.Add(illusion)
                call PauseUnit(illusion.self, true)
                call illusion.Position.X.Set(casterX)
                call illusion.Position.Y.Set(casterY)
                call illusion.Position.Timed.SetXY(x, y, thistype.MOVE_DURATION)
            endif
            set iteration = iteration - 1
            set x = x + xAdd
            set y = y + yAdd
        endloop
        call durationTimer.Start(thistype.MOVE_DURATION, false, function thistype.MoveEnding)
    endmethod
    initMethod Init of Spells_Act2
        set thistype.CASTER_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Caster_Death)
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.ILLUSION_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Illusion_Death)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        SerpentWard SERPENT_WARD = STRUCT_BASE
    endglobals
    struct SerpentWard
        implement Allocation
        implement List
        
    Unit caster
    real targetX
    real targetY
    static method Start takes Unit caster, real targetX, real targetY returns nothing
        local User casterOwner = caster.Owner.Get()
        local integer iteration = thistype.SUMMON_AMOUNT
        loop
            call Unit.CreateSummon(thistype.SUMMON_UNIT_TYPE, casterOwner, targetX, targetY, UNIT.Facing.STANDARD, thistype.DURATION)
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
    endmethod
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        local real targetX = this.targetX
        local real targetY = this.targetY
        call this.deallocate()
        call dummyMissile.Destroy()
        call thistype.Start(caster, targetX, targetY)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local thistype this = thistype.allocate()
		local Missile dummyMissile = Missile.Create()
        set this.caster = caster
        set this.targetX = targetX
        set this.targetY = targetY
        call dummyMissile.Arc.SetByPerc(0.1)
        call dummyMissile.CollisionSize.Set(10.)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 2.)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(900.)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.GoToSpot.Start(targetX, targetY, Spot.GetHeight(targetX, targetY))
    endmethod
    initMethod Init of Spells_Act2
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        SpiritWolves SPIRIT_WOLVES = STRUCT_BASE
    endglobals
    struct SpiritWolves
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static Event SUMMON_DEATH_EVENT
    Unit caster
    UnitList summonGroup
    SpellInstance whichInstance
    eventMethod Event_Summon_Death
        local Unit summon = params.Unit.GetTrigger()
        local thistype this = summon.Data.Integer.Get(KEY)
        local UnitList summonGroup = this.summonGroup
        call summon.Data.Integer.Remove(KEY)
        call summon.Event.Remove(SUMMON_DEATH_EVENT)
        call summonGroup.Remove(summon)
        if summonGroup.IsEmpty() then
            local Unit caster = this.caster
            local SpellInstance whichInstance = this.whichInstance
            call this.deallocate()
            call caster.Data.Integer.Remove(KEY)
            call summonGroup.Destroy()
            call whichInstance.Destroy()
        endif
    endmethod
	method Ending takes nothing returns nothing
        local UnitList summonGroup = this.summonGroup
        local Unit summon = summonGroup.GetFirst()
        call summonGroup.Refs.Add()
        loop
            call summon.Kill()
            set summon = summonGroup.GetFirst()
            exitwhen (summon == NULL)
        endloop
        call summonGroup.Refs.Remove()
	endmethod
    method CreateSummon takes User casterOwner, real casterX, real casterY, real angle, UnitList summonGroup returns Unit
        local Unit summon = Unit.CreateSummon(thistype.SUMMON_UNIT_TYPE, casterOwner, casterX, casterY, angle, thistype.DURATION)
        call summon.Data.Integer.Set(KEY, this)
        call summon.Event.Add(SUMMON_DEATH_EVENT)
        call summonGroup.Add(summon)
		return summon
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local thistype this = caster.Data.Integer.Get(KEY)
        if (this != NULL) then
            call this.Ending()
        endif
		local integer iteration = thistype.SUMMON_AMOUNT
        if (iteration > 0) then
            set this = thistype.allocate()
			local UnitList summonGroup = UnitList.Create()
            set this.caster = caster
            set this.summonGroup = summonGroup
            set this.whichInstance = SpellInstance.Create(caster, thistype.THIS_SPELL)
            call caster.Data.Integer.Set(KEY, this)
			local real angle = caster.Facing.Get()
			local User casterOwner = caster.Owner.Get()
	        local real casterX = caster.Position.X.Get() + thistype.OFFSET * Math.Cos(angle)
	        local real casterY = caster.Position.Y.Get() + thistype.OFFSET * Math.Sin(angle)
            loop
                local Unit summon = this.CreateSummon(casterOwner, casterX, casterY, angle, summonGroup)
                set iteration = iteration - 1
                exitwhen (iteration < 1)
            endloop
        endif
    endmethod
    initMethod Init of Spells_Act2
        set thistype.SUMMON_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Summon_Death)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        Stormbolt STORMBOLT = STRUCT_BASE
    endglobals
    struct Stormbolt
        implement Allocation
        implement List
        
    Unit caster
    integer level
    Unit target
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        call this.deallocate_demount()
        call dummyMissile.Destroy()
		if (target == NULL) then
			return
		endif
        if target.MagicImmunity.Try() then
            return
        endif
        call target.Buffs.Timed.Start(UNIT.Stun.NORMAL_BUFF, this.level, thistype.DURATION)
        call caster.DamageUnitBySpell(target, thistype.DAMAGE, true, false)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
		local Missile dummyMissile = Missile.Create()
		local thistype this = thistype.allocate_mount(dummyMissile)
        set this.caster = caster
        set this.level = level
        call dummyMissile.CollisionSize.Set(10.)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 2.)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(700.)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.GoToUnit.Start(target, null)
    endmethod
    initMethod Init of Spells_Act2
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        SummonMinions SUMMON_MINIONS = STRUCT_BASE
    endglobals
    struct SummonMinions
        implement Allocation
        implement List
        
    static real INTERVAL
    static UnitTypePool SUMMON_UNIT_TYPE_POOL
    Timer intervalTimer
    integer level
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this
        local real angle = Math.RandomAngle()
        local User casterOwner = caster.Owner.Get()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real x = casterX - thistype.OFFSET * Math.Cos(angle)
        local real y = casterY - thistype.OFFSET * Math.Sin(angle)
		local integer iteration = thistype.SUMMONS_AMOUNT_PER_INTERVAL
        loop
            exitwhen (iteration < 1)
            local UnitType whichUnitType = thistype.SUMMON_UNIT_TYPE_POOL.Random()
            local Unit newUnit = Unit.CreateSummon(whichUnitType, casterOwner, x, y, angle, thistype.SUMMON_DURATION)
            call newUnit.VertexColor.Subtract(0., 0., 0., whichUnitType.VertexColor.Alpha.Get())
            call newUnit.VertexColor.Timed.Add(0., 0., 0., whichUnitType.VertexColor.Alpha.Get(), 1.)
            set iteration = iteration - 1
        endloop
    endmethod
    eventMethod Event_BuffLose
        local Unit caster = params.Unit.GetTrigger()
        local thistype this = caster
        local Timer intervalTimer = this.intervalTimer
        call intervalTimer.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Buff.GetLevel()
        local thistype this = caster
		local Timer intervalTimer = Timer.Create()
        set this.intervalTimer = intervalTimer
        set this.level = level
        call intervalTimer.SetData(this)
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
    endmethod
    eventMethod Event_EndCast
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_SpellEffect
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Act2
        set thistype.INTERVAL = thistype.THIS_SPELL.GetChannelTime(1) / thistype.INTERVALS_AMOUNT - 0.01
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        set thistype.SUMMON_UNIT_TYPE_POOL = UnitTypePool.Create()
        call thistype.SUMMON_UNIT_TYPE_POOL.AddType(UnitType.AXE_FIGHTER, thistype.SUMMON_UNIT_TYPE_CHANCE)
        call thistype.SUMMON_UNIT_TYPE_POOL.AddType(UnitType.SPEAR_SCOUT, thistype.SUMMON_UNIT_TYPE2_CHANCE)
    endmethod
endstruct
    globals
        Artifact ARTIFACT = STRUCT_BASE
    endglobals
    struct Artifact
        implement Allocation
        implement List
        
    static Event CREATE_EVENT
    static Group ENUM_GROUP
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static boolean STARTED
    Spell whichSpell
    eventMethod Event_Create
    	local UnitType whichUnitType = params.UnitType.GetTrigger()
        local Unit whichUnit = params.Unit.GetTrigger()
		local thistype this = whichUnitType.Data.Integer.Get(KEY)
        call HeroSpell.AddToUnit(this.whichSpell, whichUnit)
        call whichUnit.Abilities.Add(this.whichSpell)
    endmethod
    enumMethod Create_Enum
        local Unit whichUnit = UNIT.Event.Native.GetEnum()
        local thistype this = whichUnit.Type.Get().Data.Integer.Get(KEY)
        call HeroSpell.AddToUnit(this.whichSpell, whichUnit)
        call whichUnit.Abilities.Add(this.whichSpell)
    endmethod
    static method Create takes UnitType whichUnitType, Spell whichSpell returns thistype
        local thistype this = thistype.allocate()
        set this.whichSpell = whichSpell
        call whichUnitType.Data.Integer.Set(KEY, this)
        call whichUnitType.Event.Add(CREATE_EVENT)
        call Unit.EnumOfType(whichUnitType, function thistype.Create_Enum)
        return this
    endmethod
    static method Start takes nothing returns nothing
        set thistype.CREATE_EVENT = Event.Create(Unit.CREATE_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Create)
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.STARTED = true
        call thistype.Create(UnitType.ARURUW, HawkEye.THIS_SPELL)
        call thistype.Create(UnitType.DRAKUL, BatSwarm.THIS_SPELL)
        call thistype.Create(UnitType.JOTA, WhiteStaff.THIS_SPELL)
        call thistype.Create(UnitType.KERA, SilentBoots.THIS_SPELL)
        call thistype.Create(UnitType.LIZZY, VioletEarring.THIS_SPELL)
        call thistype.Create(UnitType.ROCKETEYE, StoneShield.THIS_SPELL)
        call thistype.Create(UnitType.SMOKEALOT, SapphireblueDagger.THIS_SPELL)
        call thistype.Create(UnitType.STORMY, MagicBottle.THIS_SPELL)
        call thistype.Create(UnitType.TAJRAN, TaintedLeaf.THIS_SPELL)
        call Game.DisplayTextTimed(User.ANY, String.Color.Do("Artifacts are enabled.", String.Color.BONUS), 30.)
    endmethod
    initMethod Init of Misc_4
        set thistype.STARTED = false
    endmethod
endstruct
    scope FolderBatSwarm
    public struct StructMissile
        implement Allocation
        implement List
        
        eventMethod Impact
            local Missile dummyMissile = params.Missile.GetTrigger()
            local SpellInstance whichInstance = dummyMissile.GetData()
            call dummyMissile.Destroy()
            call BatSwarm.Start(whichInstance)
            call whichInstance.Refs.Subtract()
        endmethod
        static method Start takes SpellInstance whichInstance returns nothing
            local Missile dummyMissile = Missile.Create()
            call whichInstance.Refs.Add()
            call dummyMissile.Arc.SetByPerc(0.4)
            call dummyMissile.CollisionSize.Set(32.)
            call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1.)
            call dummyMissile.Impact.SetAction(function thistype.Impact)
            call dummyMissile.SetData(whichInstance)
            call dummyMissile.Speed.Set(900.)
            call dummyMissile.Position.SetFromUnit(whichInstance.GetCaster())
            call dummyMissile.GoToUnit.Start(whichInstance.GetTargetUnit(), null)
        endmethod
    endstruct
endscope
    globals
        BatSwarm BAT_SWARM = STRUCT_BASE
    endglobals
    struct BatSwarm
        implement Allocation
        implement List
        
    static BoolExpr TARGET_FILTER
    Unit caster
    real damage
    real heal
    Unit target
    FolderBatSwarm_StructMissile Missile = this
    FolderBatSwarm_StructMissile LinkToStruct_Missile
    eventMethod ImpactTarget
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        local real heal = this.heal
        local Unit target = this.target
        call this.deallocate()
        call dummyMissile.Destroy()
        call caster.HealBySpell(target, heal)
    endmethod
    eventMethod ImpactEnemy
        local Missile dummyMissile = params.Missile.GetTrigger()
        local Unit enemy = params.Unit.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        local Unit target = this.target
        call dummyMissile.Destroy()
        if not enemy.Classes.Contains(UnitClass.DEAD) then
            call enemy.Effects.Create(thistype.ENEMY_EFFECT_PATH, thistype.ENEMY_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
            call caster.DamageUnitBySpell(enemy, this.damage, false, false)
        endif
        if not target.IsAllyOf(caster.Owner.Get()) then
            call this.deallocate()
            return
        endif
        set dummyMissile = Missile.Create()
        call dummyMissile.Arc.SetByPerc(0.06)
        call dummyMissile.CollisionSize.Set(8.)
        call dummyMissile.DummyUnit.Create(thistype.TARGET_DUMMY_UNIT_ID, 1.5)
        call dummyMissile.Impact.SetAction(function thistype.ImpactTarget)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(500.)
        call dummyMissile.Position.SetFromUnit(enemy)
        call dummyMissile.GoToUnit.Start(caster, null)
    endmethod
    condMethod TargetConditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if UnitList.TEMP.Contains(target) then
            return false
        endif
        if (target == Unit.TEMP) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.Classes.Contains(UnitClass.WARD) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    static method Start takes SpellInstance whichInstance returns nothing
        local Unit caster = whichInstance.GetCaster()
        local integer level = whichInstance.GetLevel()
        local Unit target = whichInstance.GetTargetUnit()
        local User casterOwner = caster.Owner.Get()
    	local Sound shieldSound = Sound.CreateFromType(thistype.SHIELD_SOUND)
		call shieldSound.AttachToUnitAndPlay(target)
		call shieldSound.Destroy(true)
        if target.IsAllyOf(casterOwner) then
            call target.Buffs.Timed.Start(UNIT.MagicImmunity.SpellShield.NORMAL_BUFF, level, thistype.SPELL_SHIELD_DURATION[level])
        else
            call target.Buffs.Timed.Start(thistype.ECLIPSE_BUFF, level, thistype.ECLIPSE_DURATION[level])
        endif
		local real areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        local real targetX = target.Position.X.Get()
        local real targetY = target.Position.Y.Get()
		local UnitList enemyGroup = UnitList.Create()
		local integer iteration = thistype.MAX_ENEMIES_AMOUNT[level]
        loop
            exitwhen (iteration < 1)
            set User.TEMP = casterOwner
			set UnitList.TEMP = enemyGroup
            set Unit.TEMP = target
            local Unit enemy = GROUP.EnumUnits.InRange.WithCollision.GetNearest(targetX, targetY, areaRange, thistype.TARGET_FILTER)
            exitwhen (enemy == NULL)
            local thistype this = thistype.allocate()
			local Missile dummyMissile = Missile.Create()
            set this.caster = caster
            set this.damage = thistype.DAMAGE[level]
            set this.heal = thistype.HEAL[level]
            set this.target = target
            call enemyGroup.Add(enemy)
            call dummyMissile.Arc.SetByPerc(0.06)
            call dummyMissile.CollisionSize.Set(8.)
            call dummyMissile.DummyUnit.Create(thistype.ENEMY_DUMMY_UNIT_ID, 0.5).PlayerColor.Set(casterOwner.GetColor())
            call dummyMissile.Impact.SetAction(function thistype.ImpactEnemy)
            call dummyMissile.SetData(this)
            call dummyMissile.Speed.Set(500.)
            call dummyMissile.Position.SetFromUnit(target)
            call dummyMissile.GoToUnit.Start(enemy, null)
            set iteration = iteration - 1
        endloop
        call enemyGroup.Destroy()
    endmethod
    eventMethod Event_SpellEffect
    	local SpellInstance whichInstance = params.SpellInstance.GetTrigger()
		if (whichInstance.GetTargetUnit() == whichInstance.GetCaster()) then
            call thistype.Start(whichInstance)
        else
            call thistype(NULL).Missile.Start(whichInstance)
        endif
    endmethod
    initMethod Init of Spells_Artifacts
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.TargetConditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call UNIT.Eclipse.NORMAL_BUFF.Variants.Add(thistype.ECLIPSE_BUFF)
    endmethod
endstruct
    globals
        HawkEye HAWK_EYE = STRUCT_BASE
    endglobals
    struct HawkEye
        implement Allocation
        implement List
        
	static Event DAMAGE_EVENT
	static Event DEATH_EVENT
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
	real healAmount
	eventMethod Impact
		local Missile dummyMissile = params.Missile.GetTrigger()
		local Unit target = params.Unit.GetTrigger()
		
		local thistype this = dummyMissile.GetData()
		
		local real healAmount = this.healAmount
		
		call dummyMissile.Destroy()
		
		call this.deallocate()
		
		if (target == NULL) then
			return
		endif
		
		call target.HealManaBySpell(target, healAmount)
	endmethod
	static method StartManaMissile takes Unit source, Unit target, real healAmount returns nothing
        local thistype this = thistype.allocate()
		local Missile dummyMissile = Missile.Create()
        set this.healAmount = healAmount
        call dummyMissile.Arc.SetByPerc(0.1)
        call dummyMissile.CollisionSize.Set(32.)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1.25)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(500.)
        call dummyMissile.Position.SetFromUnit(source)
        call dummyMissile.GoToUnit.Start(target, null)
	endmethod
	eventMethod Event_Damage
		local Unit damager = params.Unit.GetDamager()
		local Unit target = params.Unit.GetTrigger()
		
		local integer level = target.Buffs.GetLevel(thistype.DUMMY_BUFF)
		call target.Buffs.Timed.StartEx(thistype.BLEEDING_BUFF, level, damager, thistype.BLEED_DURATION[level])
	endmethod
    eventMethod Event_Death
    	local Unit killer = params.Unit.GetKiller()
        local Unit target = params.Unit.GetTrigger()
        local integer level = target.Buffs.GetLevel(thistype.DUMMY_BUFF)
        local Unit userHero = killer.Owner.Get().Hero.Get()
        if ((userHero != NULL) and not userHero.Classes.Contains(UnitClass.DEAD)) then
            set killer = userHero
        endif
        call thistype.StartManaMissile(target, killer, thistype.MANA_HEAL[level])
    endmethod
    eventMethod Event_BuffLose
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
		call target.Event.Remove(DAMAGE_EVENT)
        call target.Event.Remove(DEATH_EVENT)
        
        call target.Invisibility.Reveal.Subtract()
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
		call target.Event.Add(DAMAGE_EVENT)
        call target.Event.Add(DEATH_EVENT)
        
        call target.Invisibility.Reveal.Add()
    endmethod
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
		local real casterX = caster.Position.X.Get()
		local real casterY = caster.Position.Y.Get()
		local string specialEffectPath
		if (EffectLevel.CURRENT == EffectLevel.LOW) then
			set specialEffectPath = thistype.SPECIAL_EFFECT_PATH
		else
			set specialEffectPath = thistype.SPECIAL_EFFECT2_PATH
		endif
		call Spot.CreateEffect(casterX, casterY, specialEffectPath, EffectLevel.LOW).Destroy()
		
		local Sound effectSound = Sound.CreateFromType(thistype.DUMMY_SOUND)
		call effectSound.SetPositionAndPlay(casterX, casterY, caster.Position.Z.Get())
		call effectSound.Destroy(true)
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(casterX, casterY, thistype.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.GetNearest(casterX, casterY)
        if (target != NULL) then
            local integer targetsAmount = thistype.TARGETS_AMOUNT[level]
            
            loop
            	call thistype.ENUM_GROUP.RemoveUnit(target)
            	
            	local Sound hitSound = Sound.CreateFromType(thistype.HIT_SOUND)
				call hitSound.AttachToUnitAndPlay(target)
				call hitSound.Destroy(true)
            	
            	call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.BUFF_DURATION[level])
                
                set targetsAmount = targetsAmount - 1
                exitwhen (targetsAmount < 1)
                set target = thistype.ENUM_GROUP.GetNearest(casterX, casterY)
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    initMethod Init of Spells_Artifacts
    	set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
    	set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Death)
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        
        call UNIT.Bleeding.NORMAL_BUFF.Variants.Add(thistype.BLEEDING_BUFF)
    endmethod
endstruct
    scope FolderMagicBottle
    public struct StructBuff
        implement Allocation
        implement List
        
        static method Start takes integer level, Unit target returns nothing
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION[level])
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
endscope
    globals
        MagicBottle MAGIC_BOTTLE = STRUCT_BASE
    endglobals
    struct MagicBottle
        implement Allocation
        implement List
        
    Unit caster
    integer level
    Unit target
    FolderMagicBottle_StructBuff Buff = this
    FolderMagicBottle_StructBuff LinkToStruct_Buff
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        local integer level = this.level
        local Unit target = this.target
        call this.deallocate()
        call dummyMissile.Destroy()
        call target.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
        if target.IsAllyOf(caster.Owner.Get()) then
            call caster.HealManaBySpell(target, thistype.MANA_INC[level])
            call thistype(NULL).Buff.Start(level, target)
        else
            if (target.Buffs.Dispel(true, true, true) > 0) then
                call caster.HealManaBySpell(caster, thistype.MANA_INC[level])
            endif
			call target.Whirl.AddTimed(thistype.WHIRL_DURATION[level])
            call thistype(NULL).Buff.Start(level, caster)
        endif
    endmethod
    static method StartTarget takes Unit caster, integer level, Unit target returns nothing
        local thistype this = thistype.allocate()
		local Missile dummyMissile = Missile.Create()
        set this.caster = caster
        set this.level = level
        set this.target = target
        call dummyMissile.Arc.SetByPerc(0.06)
        call dummyMissile.CollisionSize.Set(10.)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 2.)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(900.)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.GoToUnit.Start(target, null)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        call thistype.StartTarget(caster, level, target)
    endmethod
    initMethod Init of Spells_Artifacts
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Buff.Init()
    endmethod
endstruct
    scope FolderRedwoodValkyrie
    public struct StructAir
        implement Allocation
        implement List
        
        static Group ENUM_GROUP
        static BoolExpr SPLASH_FILTER
        SpellInstance whichInstance
        condMethod SplashConditions
            local Unit target = UNIT.Event.Native.GetFilter()
            if target.Classes.Contains(UnitClass.DEAD) then
                return false
            endif
            if not target.Classes.Contains(UnitClass.AIR) then
                return false
            endif
            if target.Invulnerability.Try() then
                return false
            endif
            if target.IsAllyOf(User.TEMP) then
                return false
            endif
            if target.MagicImmunity.Try() then
                return false
            endif
            return true
        endmethod
        static method DealSplash takes Unit caster, real splashAreaRange, real splashDamage, real x, real y returns nothing
            call Spot.CreateEffect(x, y, "Abilities\\Spells\\Other\\Incinerate\\FireLordDeathExplode.mdl", EffectLevel.NORMAL).Destroy()
            set User.TEMP = caster.Owner.Get()
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, splashAreaRange, thistype.SPLASH_FILTER)
            local Unit target = thistype.ENUM_GROUP.FetchFirst()
            if (target != NULL) then
                loop
                    call caster.DamageUnitBySpell(target, splashDamage, true, false)
                    set target = thistype.ENUM_GROUP.FetchFirst()
                    exitwhen (target == NULL)
                endloop
            endif
        endmethod
        eventMethod Impact
            local Missile dummyMissile = params.Missile.GetTrigger()
            local thistype this = dummyMissile.GetData()
            local real x = dummyMissile.Position.X.Get()
            local real y = dummyMissile.Position.Y.Get()
            local SpellInstance whichInstance = this.whichInstance
            local Unit caster = whichInstance.GetCaster()
            local integer level = whichInstance.GetLevel()
            call this.deallocate_demount()
            call dummyMissile.Destroy()
            call thistype.DealSplash(caster, thistype.AREA_RANGE[level], thistype.DAMAGE[level] + whichInstance.GetDamageMod() * thistype.DAMAGE_DAMAGE_MOD_FACTOR, x, y)
            call whichInstance.Refs.Subtract()
        endmethod
        static method Start takes SpellInstance whichInstance returns nothing
            local Unit caster = whichInstance.GetCaster()
            local integer level = whichInstance.GetLevel()
            local Unit target = whichInstance.GetTargetUnit()
			local Missile dummyMissile = Missile.Create()
			local thistype this = thistype.allocate_mount(dummyMissile)
            set this.whichInstance = whichInstance
            call dummyMissile.CollisionSize.Set(RedwoodValkyrie.THIS_SPELL.GetAreaRange(level))
            call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1.5).AddEffect(thistype.MISSILE_EFFECT_PATH, thistype.MISSILE_EFFECT_ATTACH_POINT, EffectLevel.NORMAL)
            call dummyMissile.Impact.SetAction(function thistype.Impact)
            call dummyMissile.SetData(this)
            call dummyMissile.Speed.Set(RedwoodValkyrie.SPEED)
            call dummyMissile.Position.SetFromUnit(caster)
            call dummyMissile.GoToUnit.Start(target, null)
            call whichInstance.Refs.Add()
        endmethod
        static method Init takes nothing returns nothing
            set thistype.ENUM_GROUP = Group.Create()
            set thistype.SPLASH_FILTER = BoolExpr.GetFromFunction(function thistype.SplashConditions)
        endmethod
    endstruct
endscope
    globals
        RedwoodValkyrie REDWOOD_VALKYRIE = STRUCT_BASE
    endglobals
    struct RedwoodValkyrie
        implement Allocation
        implement List
        
    static BoolExpr TARGET_FILTER
    real damage
    real maxLength
    real sourceX
    real sourceY
    UnitList targetGroup
    SpellInstance whichInstance
    FolderRedwoodValkyrie_StructAir Air = this
    FolderRedwoodValkyrie_StructAir LinkToStruct_Air
    condEventMethod TargetConditions
		local Missile dummyMissile = params.Missile.GetTrigger()
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        local thistype this = dummyMissile.GetData()
        if this.targetGroup.Contains(target) then
            return false
        endif
        local SpellInstance whichInstance = this.whichInstance
        if target.IsAllyOf(whichInstance.GetCaster().Owner.Get()) then
            return false
        endif
        return true
    endmethod
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        call this.targetGroup.Destroy()
        call this.deallocate()
        call dummyMissile.Destroy()
    endmethod
    eventMethod Collision
        local Missile dummyMissile = params.Missile.GetTrigger()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local real damage = this.damage
        local SpellInstance whichInstance = this.whichInstance
        local Unit caster = whichInstance.GetCaster()
        call this.targetGroup.Add(target)
		local real igniteDuration
		if target.Classes.Contains(UnitClass.HERO) then
			set igniteDuration = thistype.IGNITE_HERO_DURATION
		else
			set igniteDuration = thistype.IGNITE_DURATION
		endif
        call target.Buffs.Timed.StartEx(thistype.IGNITION_BUFF, whichInstance.GetLevel(), caster, igniteDuration)
        call caster.Damage.Events.VsUnit(target, true, damage)
    endmethod
    static method Start takes SpellInstance whichInstance returns nothing
        local Unit caster = whichInstance.GetCaster()
        local integer level = whichInstance.GetLevel()
        local real targetX = whichInstance.GetTargetX()
        local real targetY = whichInstance.GetTargetY()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real maxLength = thistype.THIS_SPELL.GetRange(level)
        local thistype this = thistype.allocate()
		local Missile dummyMissile = Missile.Create()
        local real angle = Math.AtanByDeltas(targetY - casterY, targetX - casterX)
        set this.damage = thistype.DAMAGE[level] + caster.Damage.Get() * thistype.DAMAGE_DAMAGE_MOD_FACTOR[level]
        set this.maxLength = maxLength
        set this.sourceX = casterX
        set this.sourceY = casterY
        set this.targetGroup = UnitList.Create()
        set this.whichInstance = whichInstance
        call dummyMissile.CollisionSize.Set(thistype.THIS_SPELL.GetAreaRange(level))
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1.5).AddEffect(thistype.MISSILE_EFFECT_PATH, thistype.MISSILE_EFFECT_ATTACH_POINT, EffectLevel.NORMAL)
        call dummyMissile.SetData(this)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.Speed.Set(thistype.SPEED)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.GoToSpot.Start(casterX + maxLength * Math.Cos(angle), casterY + maxLength * Math.Sin(angle), Spot.GetHeight(targetX, targetY) + UNIT_TYPE.Impact.Z.STANDARD)
        call dummyMissile.Position.AddCollision(function thistype.Collision, thistype.TARGET_FILTER)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local Unit target = params.Unit.GetTarget()
        local SpellInstance whichInstance = params.SpellInstance.GetTrigger()
        call caster.Effects.Create(thistype.LAUNCH_EFFECT_PATH, thistype.LAUNCH_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
        if ((target != NULL) and not target.Classes.Contains(UnitClass.GROUND)) then
            call thistype(NULL).Air.Start(whichInstance)
            return
        endif
        call thistype.Start(whichInstance)
    endmethod
    initMethod Init of Spells_Artifacts
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.TargetConditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call UNIT.Ignited.NORMAL_BUFF.Variants.Add(thistype.IGNITION_BUFF)
        call thistype(NULL).Air.Init()
    endmethod
endstruct
    globals
        SapphireblueDagger SAPPHIREBLUE_DAGGER = STRUCT_BASE
    endglobals
    struct SapphireblueDagger
        implement Allocation
        implement List
        
	static Event DAMAGE_EVENT
    static Group ENUM_GROUP
    static real array MAX_RANGE_SQUARE
    static BoolExpr TARGET_FILTER
    eventMethod Event_Damage
    	local Unit caster = params.Unit.GetTrigger()
        local Unit target = params.Unit.GetTarget()
		local integer level = caster.Buffs.GetLevel(thistype.CASTER_BUFF)
		call caster.DamageUnitBySpell(target, thistype.DAMAGE_INC[level], true, false)
    endmethod
    eventMethod Event_BuffLose
        call params.Unit.GetTrigger().Event.Remove(DAMAGE_EVENT)
    endmethod
    eventMethod Event_BuffGain
        call params.Unit.GetTrigger().Event.Add(DAMAGE_EVENT)
    endmethod
    condMethod TargetConditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        if target.Classes.Contains(UnitClass.HERO) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
	static method DoFrost takes real sourceX, real sourceY, real targetX, real targetY, Unit caster, integer level returns nothing
		local real dX = targetX - sourceX
		local real dY = targetY - sourceY
		local real width = caster.CollisionSize.Get(true)
        set User.TEMP = caster.Owner.Get()
		call thistype.ENUM_GROUP.EnumUnits.InLine.WithCollision.Do(sourceX, sourceY, Math.DistanceByDeltas(dX, dY), Math.AtanByDeltas(dY, dX), width, width, thistype.TARGET_FILTER)
		local Unit target = thistype.ENUM_GROUP.FetchFirst()
		if (target != NULL) then
			local real duration = thistype.FROST_DURATION[level]
            loop	
				call target.Buffs.Timed.Start(thistype.FROST_BUFF, level, duration)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
		endif
	endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local real areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        local User casterOwner = caster.Owner.Get()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real dX = targetX - casterX
        local real dY = targetY - casterY
        if (Math.DistanceSquareByDeltas(dX, dY) > thistype.MAX_RANGE_SQUARE[level]) then
            local real angle = caster.CastAngle(dX, dY)
            set targetX = casterX + thistype.MAX_RANGE[level] * Math.Cos(angle)
            set targetY = casterY + thistype.MAX_RANGE[level] * Math.Sin(angle)
        endif
        call Spot.CreateEffect(casterX, casterY, thistype.START_EFFECT_PATH, EffectLevel.NORMAL).Destroy()
		call thistype.DoFrost(casterX, casterY, targetX, targetY, caster, level)
        call Spot.CreateEffect(targetX, targetY, thistype.TARGET_EFFECT_PATH, EffectLevel.LOW).Destroy()
        call caster.Position.SetWithCollision(targetX, targetY)
		call caster.Buffs.Timed.Start(thistype.CASTER_BUFF, level, thistype.CASTER_BUFF_DURATION[level])
        call Swiftness.Start(caster, level)
    endmethod
    initMethod Init of Spells_Artifacts
    	set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.TargetConditions)
        call thistype.CASTER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.CASTER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call UNIT.Frost.NORMAL_BUFF.Variants.Add(thistype.FROST_BUFF)
        local integer iteration = thistype.THIS_SPELL.GetLevelsAmount()
        loop
            set thistype.MAX_RANGE_SQUARE[iteration] = Math.Square(thistype.MAX_RANGE[iteration])
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
    endmethod
endstruct
    globals
        SilentBoots SILENT_BOOTS = STRUCT_BASE
    endglobals
    struct SilentBoots
        implement Allocation
        implement List
        
	static Event DAMAGE_EVENT
    static Event INVISIBILITY_EVENT
    integer level
    UnitModSet moveSpeedMod
    integer powerLevel
    Timer snowTimer
    Timer weakenTimer
    eventMethod Event_Damage
    	local Unit caster = params.Unit.GetTrigger()
    	local real damage = params.Real.GetDamage()
        local Unit target = params.Unit.GetTarget()
		local integer level = caster.Buffs.GetLevel(thistype.DUMMY_BUFF)
		local real disarmDuration
		if target.Classes.Contains(UnitClass.HERO) then
			set disarmDuration = thistype.DISARM_HERO_DURATION[level]
		else
			set disarmDuration = thistype.DISARM_DURATION[level]
		endif
		call target.Attack.DisableTimed(disarmDuration)
		call target.Silence.AddTimed(disarmDuration)
		call params.Real.SetDamage(damage + thistype.EXTRA_DAMAGE[level])
    endmethod
    eventMethod Event_InvisibilityEnding
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    timerMethod SpawnSnow
        local thistype this = Timer.GetExpired().GetData()
        local Unit target = this
        local real x = target.Position.X.Get()
        local real y = target.Position.Y.Get()
        
        call Ubersplat.Create(UbersplatType.SNOW, x, y, 255, 255, 255, target.Buffs.Timed.GetRemainingDuration(thistype.DUMMY_BUFF, this.level) / thistype.DURATION[this.level] * SetVar.GetValDefR("snowAlphaFactor", 1.5) * 255, false, false).DestroyTimed.Start(SetVar.GetValDefR("snowDur", 5.))
    endmethod
    timerMethod Weaken
        local thistype this = Timer.GetExpired().GetData()
        local UnitModSet moveSpeedMod = this.moveSpeedMod
        local integer level = this.level
        local integer powerLevel = this.powerLevel - 1
        local Unit target = this
        set this.powerLevel = powerLevel
        call target.ModSets.Remove(moveSpeedMod)
        call moveSpeedMod.RealMods.ResetVal(UNIT.Movement.Speed.BonusA.STATE, thistype.MOVE_SPEED_BONUS[level] * (powerLevel / thistype.POWER_LEVELS))
        call target.ModSets.Add(moveSpeedMod)
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local UnitModSet moveSpeedMod = this.moveSpeedMod
        local Timer snowTimer = this.snowTimer
        local Timer weakenTimer = this.weakenTimer
        call snowTimer.Destroy()
        call weakenTimer.Destroy()
        call target.Event.Remove(DAMAGE_EVENT)
        call target.Event.Remove(INVISIBILITY_EVENT)
        call target.ModSets.Remove(moveSpeedMod)
        call moveSpeedMod.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local UnitModSet moveSpeedMod = UnitModSet.Create()
        local Timer snowTimer = Timer.Create()
        local Timer weakenTimer = Timer.Create()
        set this.level = level
        set this.moveSpeedMod = moveSpeedMod
        set this.powerLevel = thistype.POWER_LEVELS
        set this.snowTimer = snowTimer
        set this.weakenTimer = weakenTimer
        call snowTimer.SetData(this)
        call weakenTimer.SetData(this)
		call target.Event.Add(DAMAGE_EVENT)
        call target.Event.Add(INVISIBILITY_EVENT)
        call moveSpeedMod.RealMods.Add(UNIT.Movement.Speed.BonusA.STATE, thistype.MOVE_SPEED_BONUS[level])
        call target.ModSets.Add(moveSpeedMod)
        call snowTimer.Start(SetVar.GetValDefR("snow", 0.125), true, function thistype.SpawnSnow)
        call weakenTimer.Start(thistype.DURATION[level] / thistype.POWER_LEVELS, true, function thistype.Weaken)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        call caster.Effects.Create(thistype.CASTER_EFFECT_PATH, thistype.CASTER_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
		
        call caster.Invisibility.AddTimed(thistype.DURATION[level])
        call caster.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION[level])
    endmethod
    initMethod Init of Spells_Artifacts
    	set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
        set thistype.INVISIBILITY_EVENT = Event.Create(UNIT.Invisibility.ENDING_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_InvisibilityEnding)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call UNIT.Invisibility.TIMED_BUFF.Variants.Add(thistype.DUMMY_BUFF)
    endmethod
endstruct
    globals
        StoneShield STONE_SHIELD = STRUCT_BASE
    endglobals
    struct StoneShield
        implement Allocation
        implement List
        
    static constant real DIST_ADD_PER_SECOND = -500.
    static constant real DURATION_FOR_FULL_ANGLE = 0.9
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
    real angle
    real angleAdd
    UnitModSet armorMod
    real damagePerInterval
    real distAdd
    DummyUnit dummyUnit
    real length
    integer level
    integer powerLevel
    Timer updateTimer
    Timer weakenTimer
    real x
    real y
    condMethod TargetConditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if UnitList.TEMP.Contains(target) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
	method DealDamage takes nothing returns nothing
		local Unit caster = this
		local DummyUnit dummyUnit = this.dummyUnit
		local real x = dummyUnit.Position.X.Get()
		local real y = dummyUnit.Position.Y.Get()
		local real z = dummyUnit.Position.Z.Get()
		call SpotEffect.CreateWithZ(x, y, z, thistype.EXPLOSION_EFFECT_PATH, EffectLevel.LOW).Destroy()
		set User.TEMP = caster.Owner.Get()
		call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.DoWithZ(x, y, z, thistype.HIT_RANGE, thistype.TARGET_FILTER)
		local Unit target = thistype.ENUM_GROUP.FetchFirst()
		if (target != NULL) then
			local real damage = this.damagePerInterval
            loop
                call target.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
                call caster.DamageUnitBySpell(target, damage, false, false)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
		endif
	endmethod
	timerMethod Interval
		local thistype this = Timer.GetExpired().GetData()
		
	endmethod
    timerMethod Update
        local thistype this = Timer.GetExpired().GetData()
        local DummyUnit dummyUnit = this.dummyUnit
        local Unit target = this
        local real x = dummyUnit.Position.X.Get()
        local real y = dummyUnit.Position.Y.Get()
        local real targetX = target.Position.X.Get()
        local real targetY = target.Position.Y.Get()
        local real dX = x - targetX
        local real dY = y - targetY
        local real angle = Math.AtanByDeltas(dY, dX) + this.angleAdd
        local real dist = target.CollisionSize.Get(true) * 6
        set targetX = targetX + dist * Math.Cos(angle)
        set targetY = targetY + dist * Math.Sin(angle)
        set dX = targetX - x
        set dY = targetY - y
        set angle = Math.AtanByDeltas(dY, dX)
        set dist = Math.DistanceByDeltas(dX, dY)
        if (dist > this.length) then
            set dist = this.length
        endif
        set x = x + dist * Math.Cos(angle)
        set y = y + dist * Math.Sin(angle)
        call dummyUnit.Facing.Set(angle + Math.QUARTER_ANGLE)
        call dummyUnit.Position.SetXY(x, y)
    endmethod
    timerMethod Weaken
        local thistype this = Timer.GetExpired().GetData()
        local UnitModSet armorMod = this.armorMod
        local integer level = this.level
        local integer powerLevel = this.powerLevel - 1
        local Unit target = this
        set this.powerLevel = powerLevel
        call target.ModSets.Remove(armorMod)
        call armorMod.RealMods.ResetVal(UNIT.Armor.Bonus.STATE, thistype.ARMOR_INC[level] * (powerLevel / thistype.POWER_LEVELS))
        call target.ModSets.Add(armorMod)
		call this.DealDamage()
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local UnitModSet armorMod = this.armorMod
        local DummyUnit dummyUnit = this.dummyUnit
        local Timer updateTimer = this.updateTimer
        local Timer weakenTimer = this.weakenTimer
        call dummyUnit.Destroy()
        call updateTimer.Destroy()
        call weakenTimer.Destroy()
        call target.ModSets.Remove(armorMod)
        call armorMod.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local Unit caster = params.Buff.GetData()
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local real x = caster.Position.X.Get()
        local real y = caster.Position.Y.Get()
        local real z = caster.Position.Z.Get() + target.Impact.Z.Get(true)
        local real targetX = target.Position.X.Get()
        local real targetY = target.Position.Y.Get()
        local real dX = targetX - x
        local real dY = targetY - y
        local real angle = Math.AtanByDeltas(dY, dX)
		local thistype this = target
        local UnitModSet armorMod = UnitModSet.Create()
        local DummyUnit dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, x, y, z, angle)
        local Timer updateTimer = Timer.Create()
        local Timer weakenTimer = Timer.Create()
        set this.angle = angle
        set this.angleAdd = Math.FULL_ANGLE / thistype.DURATION_FOR_FULL_ANGLE * thistype.UPDATE_TIME
        set this.armorMod = armorMod
        set this.damagePerInterval = thistype.DAMAGE[level] + thistype.DAMAGE_PER_FOCUS[level] * caster.Agility.Get()
        set this.distAdd = thistype.DIST_ADD_PER_SECOND * thistype.UPDATE_TIME
        set this.dummyUnit = dummyUnit
        set this.length = thistype.SPEED[level] * thistype.UPDATE_TIME
        set this.level = level
        set this.powerLevel = thistype.POWER_LEVELS
        set this.updateTimer = updateTimer
        set this.weakenTimer = weakenTimer
        call updateTimer.SetData(this)
        call weakenTimer.SetData(this)
        call dummyUnit.Scale.Set(1.5)
        call dummyUnit.Scale.Timed.Add(-1, thistype.DURATION[level])
        call armorMod.RealMods.Add(UNIT.Armor.Bonus.STATE, thistype.ARMOR_INC[level])
        call target.ModSets.Add(armorMod)
        call updateTimer.Start(thistype.UPDATE_TIME, true, function thistype.Update)
        call weakenTimer.Start(thistype.DURATION[level] / thistype.POWER_LEVELS, true, function thistype.Weaken)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        call target.Buffs.Remove(thistype.DUMMY_BUFF)
        call target.Buffs.Timed.StartEx(thistype.DUMMY_BUFF, level, caster, thistype.DURATION[level])
    endmethod
    initMethod Init of Spells_Artifacts
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.TargetConditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        TaintedLeaf TAINTED_LEAF = STRUCT_BASE
    endglobals
    struct TaintedLeaf
        implement Allocation
        implement List
        
    static real array HEAL_PER_INTERVAL
    static BoolExpr TARGET_FILTER
    Unit caster
    Timer intervalTimer
    integer level
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        
        local Unit target = this
        
        local Unit caster = this.caster
        local integer level = this.level
        call caster.HealBySpell(target, thistype.HEAL_PER_INTERVAL[level])
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local Timer intervalTimer = this.intervalTimer
        local integer level = this.level
        call intervalTimer.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local Unit caster = params.Buff.GetData()
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
return
        local thistype this = target
        local Timer intervalTimer = Timer.Create()
        set this.caster = caster
        set this.intervalTimer = intervalTimer
        set this.level = level
        call intervalTimer.SetData(this)
        call intervalTimer.Start(thistype.HEAL_INTERVAL, true, function thistype.Interval)
    endmethod
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if (target == Unit.TEMP) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
	Group cast_targetGroup
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        local real areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        local real damage = thistype.DAMAGE[level]
		local Group targetGroup = thistype(caster).cast_targetGroup
        local UnitType targetType = target.Type.Get()
        local real targetX = target.Position.X.Get()
        local real targetY = target.Position.Y.Get()
        call SpotEffectWithSize.Create(targetX, targetY, thistype.HEAL_TARGET_EFFECT_PATH, EffectLevel.NORMAL, areaRange / 160.).Destroy()
        if target.IsAllyOf(caster.Owner.Get()) then
            call target.Buffs.Timed.DoWithLevel(thistype.TAINTED_BUFF, level, caster, thistype.BUFF_DURATION[level])
            call caster.HealBySpell(target, (thistype.HEAL_FACTOR[level] * target.MaxLife.Get()) * (1. - Boolean.ToInt(target == caster) * (1. - thistype.SELF_FACTOR)))
        else
            if target.Classes.Contains(UnitClass.HERO) then
                call target.Buffs.Timed.Start(thistype.SLEEP_BUFF, level, thistype.SLEEP_HERO_DURATION[level])
            else
                call target.Buffs.Timed.Start(thistype.SLEEP_BUFF, level, thistype.SLEEP_DURATION[level])
            endif
	        set target = targetGroup.FetchFirst()
	
	        if (target != NULL) then
	            loop
	                call caster.DamageUnitBySpell(target, damage, true, false)
	
	                set target = targetGroup.FetchFirst()
	                exitwhen (target == NULL)
	            endloop
	        endif
        endif
    endmethod
	eventMethod Event_Cast_BuffLose
		local Unit caster = params.Unit.GetTrigger()
		local thistype this = caster
		local Group targetGroup = this.cast_targetGroup
		call targetGroup.Destroy()
	endmethod
	static integer CAST_LEVEL
	static Unit CAST_TARGET
	static real CAST_TARGET_X
	static real CAST_TARGET_Y
	eventMethod Event_Cast_BuffGain
		local Unit caster = params.Unit.GetTrigger()
		local integer level = thistype.CAST_LEVEL
		local Unit target = thistype.CAST_TARGET
		local real targetX = thistype.CAST_TARGET_X
		local real targetY = thistype.CAST_TARGET_Y
		local Group targetGroup = Group.Create()
		local thistype this = caster
		set this.cast_targetGroup = targetGroup
        set User.TEMP = caster.Owner.Get()
        set Unit.TEMP = target
        call targetGroup.EnumUnits.InRange.WithCollision.Do(targetX, targetY, thistype.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
	endmethod
	eventMethod Event_EndCast
		call params.Unit.GetTrigger().Buffs.Remove(thistype.CAST_BUFF)
	endmethod
	eventMethod Event_Cast
		set thistype.CAST_LEVEL = params.Spell.GetLevel()
		set thistype.CAST_TARGET = params.Unit.GetTarget()
		set thistype.CAST_TARGET_X = params.Spot.GetTargetX()
		set thistype.CAST_TARGET_Y = params.Spot.GetTargetY()
		call params.Unit.GetTrigger().Buffs.Add(thistype.CAST_BUFF, 1)
	endmethod
    initMethod Init of Spells_Artifacts
    	set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.CAST_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Cast_BuffGain))
        call thistype.CAST_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Cast_BuffLose))
        call thistype.TAINTED_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.TAINTED_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Begin.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Cast))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
        call UNIT.Sleep.NORMAL_BUFF.Variants.Add(thistype.SLEEP_BUFF)
        local integer i = thistype.THIS_SPELL.GetLevelsAmount()
        loop
        	exitwhen (i < 1)
        	set thistype.HEAL_PER_INTERVAL[i] = thistype.HEAL_OVER_TIME[i] / Real.ToInt(thistype.BUFF_DURATION[i] / thistype.HEAL_INTERVAL)
        	set i = i - 1
        endloop
    endmethod
endstruct
    scope FolderVioletEarring
    public struct StructCharge
        implement Allocation
        implement List
        
        static Event DAMAGE_EVENT
        boolean exists
        eventMethod Event_ActiveBuffLose
            local Unit caster = params.Unit.GetTrigger()
            local integer level = params.Buff.GetLevel()
            call caster.Event.Remove(DAMAGE_EVENT)
			call caster.Abilities.RemoveBySelf(thistype.MISSILE_ART_SPELL_ID)
        endmethod
        eventMethod Event_ActiveBuffGain
            local Unit caster = params.Unit.GetTrigger()
            call caster.Event.Add(DAMAGE_EVENT)
			call caster.Abilities.AddBySelf(thistype.MISSILE_ART_SPELL_ID)
        endmethod
        eventMethod Event_CooldownBuffLose
            local Unit caster = params.Unit.GetTrigger()
            local integer level = params.Buff.GetLevel()
            local thistype this = caster
            if this.exists then
                call caster.Buffs.Add(thistype.ACTIVE_BUFF, level)
            endif
        endmethod
        eventMethod Event_CooldownBuffGain
            local Unit caster = params.Unit.GetTrigger()
            call caster.Buffs.Remove(thistype.ACTIVE_BUFF)
        endmethod
        eventMethod Event_Damage
            local real amount = params.Real.GetDamage()
            local Unit caster = params.Unit.GetDamager()
            local Unit target = params.Unit.GetTrigger()
            local integer level = caster.Buffs.GetLevel(thistype.ACTIVE_BUFF)
            if (target.Abilities.GetLevelBySelf(thistype.MISSILE_ART_BUFF_ID) == 0) then
                return
            endif
            call target.Abilities.RemoveBySelf(thistype.MISSILE_ART_BUFF_ID)
			local real banishDuration
			
			if target.Classes.Contains(UnitClass.HERO) then
				set banishDuration = thistype.BANISH_HERO_DURATION[level]
			else
				set banishDuration = thistype.BANISH_DURATION[level]
			endif
            call target.Buffs.Timed.Start(thistype.BANISH_BUFF, level, banishDuration)
            call caster.Buffs.Timed.Start(thistype.COOLDOWN_BUFF, level, thistype.COOLDOWN[level])
            call params.Real.SetDamage(amount * thistype.DAMAGE_FACTOR[level])
        endmethod
        eventMethod Event_BuffLose
            local Unit caster = params.Unit.GetTrigger()
            local thistype this = caster
            set this.exists = false
            call caster.Buffs.Remove(thistype.ACTIVE_BUFF)
            call caster.Buffs.Remove(thistype.COOLDOWN_BUFF)
        endmethod
        eventMethod Event_BuffGain
            local Unit caster = params.Unit.GetTrigger()
            local integer level = params.Buff.GetLevel()
            local thistype this = caster
            set this.exists = true
            call caster.Buffs.Add(thistype.ACTIVE_BUFF, level)
        endmethod
        eventMethod Event_Unlearn
            call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
        endmethod
        eventMethod Event_ChangeLevel
            call params.Unit.GetTrigger().Buffs.AddFresh(thistype.DUMMY_BUFF, params.Spell.GetLevel())
        endmethod
        eventMethod Event_Learn
            call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
            call thistype.ACTIVE_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_ActiveBuffGain))
            call thistype.ACTIVE_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_ActiveBuffLose))
            call thistype.COOLDOWN_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_CooldownBuffGain))
            call thistype.COOLDOWN_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_CooldownBuffLose))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            call VioletEarring.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_ChangeLevel))
            call VioletEarring.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
            call VioletEarring.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
            call UNIT.Banish.NORMAL_BUFF.Variants.Add(thistype.BANISH_BUFF)
        endmethod
    endstruct
    public struct StructPort
        implement Allocation
        implement List
        
        static Event MISSILE_DESTROY_EVENT
        SpellInstance parent
        eventMethod Event_Missile_Destroy
            local Missile dummyMissile = params.Missile.GetTrigger()
            local thistype this = dummyMissile.GetData()
            local SpellInstance parent = this.parent
            call dummyMissile.Event.Remove(MISSILE_DESTROY_EVENT)
            call parent.Refs.Subtract()
            call this.deallocate()
        endmethod
        eventMethod Impact
            local Missile dummyMissile = params.Missile.GetTrigger()
            local Unit target = params.Unit.GetTrigger()
            local thistype this = dummyMissile.GetData()
            local SpellInstance parent = this.parent
            local Unit caster = parent.GetCaster()
            local integer level = parent.GetLevel()
            call dummyMissile.Destroy()
            local real casterX = caster.Position.X.Get()
            local real casterY = caster.Position.Y.Get()
            call caster.Effects.Create(thistype.SPECIAL_EFFECT_PATH, thistype.SPECIAL_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
            call caster.Position.SetXY(target.Position.X.Get(), target.Position.Y.Get())
            call target.Effects.Create(thistype.SPECIAL_EFFECT_PATH, thistype.SPECIAL_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
            call target.Position.SetXY(casterX, casterY)
            call caster.Buffs.Subtract(thistype.DUMMY_BUFF)
            call target.Buffs.Subtract(thistype.DUMMY_BUFF)
        endmethod
        static method Start takes SpellInstance parent returns nothing
            local Unit caster = parent.GetCaster()
            local Unit target = parent.GetTargetUnit()
            local thistype this = thistype.allocate()
			local Missile dummyMissile = Missile.Create()
            set this.parent = parent
            call parent.Refs.Add()
            call caster.Buffs.Add(thistype.DUMMY_BUFF, 1)
            call target.Buffs.Add(thistype.DUMMY_BUFF, 1)
            call dummyMissile.Event.Add(MISSILE_DESTROY_EVENT)
            call dummyMissile.Arc.SetByPerc(0.)
            call dummyMissile.CollisionSize.Set(10.)
            call dummyMissile.Impact.SetAction(function thistype.Impact)
            call dummyMissile.SetData(this)
            call dummyMissile.Speed.Set(600.)
            call dummyMissile.Position.SetFromUnit(caster)
            call dummyMissile.GoToUnit.Start(target, function Missile.Destruction)
            call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1.)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.MISSILE_DESTROY_EVENT = Event.Create(Missile.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Missile_Destroy)
        endmethod
    endstruct
endscope
    globals
        VioletEarring VIOLET_EARRING = STRUCT_BASE
    endglobals
    struct VioletEarring
        implement Allocation
        implement List
        
    SpellInstance whichInstance
    FolderVioletEarring_StructCharge Charge = this
    FolderVioletEarring_StructCharge LinkToStruct_Charge
    FolderVioletEarring_StructPort Port = this
    FolderVioletEarring_StructPort LinkToStruct_Port
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        local SpellInstance whichInstance = params.SpellInstance.GetTrigger()
        call caster.Effects.Create(thistype.CASTER_EFFECT_PATH, thistype.CASTER_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
        call caster.Abilities.Refresh(PurgingRain.THIS_SPELL)
        call caster.Abilities.Refresh(ArcaneAttractor.THIS_SPELL)
        call caster.Mana.Add(thistype.MANA_INC[level])
        if (caster != target) then
            call thistype(NULL).Port.Start(whichInstance)
        endif
    endmethod
    initMethod Init of Spells_Artifacts
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Charge.Init()
        call thistype(NULL).Port.Init()
    endmethod
endstruct
    scope FolderVomit
    public struct StructTarget
        implement Allocation
        implement List
        
		Unit caster
		real damage
		Timer intervalTimer
		timerMethod IntervalByTimer
			local thistype this = Timer.GetExpired().GetData()
			
			local Unit target = this
			
			call this.caster.DamageUnitBySpell(target, this.damage, false, false)
		endmethod
		
		eventMethod BuffLose
			local Unit target = params.Unit.GetTrigger()
			
			local thistype this = target
			
			local Timer intervalTimer = this.intervalTimer
			
			call intervalTimer.Destroy()
		endmethod
	
		eventMethod BuffGain
			local Unit caster = params.Buff.GetData()
			local integer level = params.Buff.GetLevel()
			local Unit target = params.Unit.GetTrigger()
			local real duration
	        if target.Classes.Contains(UnitClass.HERO) then
	            set duration = thistype.POISON_HERO_DURATION[level]
	        else
	            set duration = thistype.POISON_DURATION[level]
	        endif
			local integer wavesAmount = Real.ToInt(duration / thistype.INTERVAL) 
			local thistype this = target
			local Timer intervalTimer = Timer.Create()
			set this.caster = caster
			set this.damage = thistype.DAMAGE_OVER_TIME[level] / wavesAmount
			set this.intervalTimer = intervalTimer
			call intervalTimer.SetData(this)
			call intervalTimer.Start(thistype.INTERVAL, true, function thistype.IntervalByTimer)
		endmethod
		
		method Start takes integer level, Unit target returns nothing
			local real duration
	
	        if target.Classes.Contains(UnitClass.HERO) then
	            set duration = thistype.POISON_HERO_DURATION[level]
	        else
	            set duration = thistype.POISON_DURATION[level]
	        endif
	
	        call target.Buffs.Timed.StartEx(thistype.POISON_BUFF, level, caster, duration)
		endmethod
		static method Init takes nothing returns nothing
    	    call thistype.POISON_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.BuffGain))
	        call thistype.POISON_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.BuffLose))
	        
	        call UNIT.Poisoned.NORMAL_BUFF.Variants.Add(thistype.POISON_BUFF)
		endmethod
	endstruct
endscope
    globals
        Vomit VOMIT = STRUCT_BASE
    endglobals
    struct Vomit
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER_COLLISION
    static BoolExpr TARGET_FILTER_EXPLOSION
    
    Unit caster
    integer level
    real scale
    Unit target
    UnitList targetGroup
    SpellInstance whichInstance
    real x
    real y
    FolderVomit_StructTarget Target = this
    FolderVomit_StructTarget LinkToStruct_Target
	static method TargetConditions takes Unit target returns boolean
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if ((Unit.TEMP.Classes.Contains(UnitClass.GROUND) != target.Classes.Contains(UnitClass.DEAD)) and (Unit.TEMP.Classes.Contains(UnitClass.AIR) != target.Classes.Contains(UnitClass.AIR))) then
            return false
		endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
		return true
	endmethod
	condMethod TargetConditions_Explosion
		return thistype.TargetConditions(UNIT.Event.Native.GetFilter())
	endmethod
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        local integer level = this.level
        local Unit target = this.target
        local SpellInstance whichInstance = this.whichInstance
        call this.deallocate()
        call dummyMissile.Destroy()
        set User.TEMP = caster.Owner.Get()
        set Unit.TEMP = target
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(target.Position.X.Get(), target.Position.Y.Get(), thistype.THIS_SPELL.GetAreaRange(level) * this.scale, thistype.TARGET_FILTER_EXPLOSION)
		call thistype.ENUM_GROUP.RemoveUnit(target)
        set target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real damage = thistype.PRIMARY_DAMAGE[level]
            loop
                call caster.DamageUnitBySpell(target, damage, false, false)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
        call whichInstance.Destroy()
    endmethod
    condEventMethod TargetConditions_Collision
		local Missile dummyMissile = params.Missile.GetTrigger()
        local Unit target = UNIT.Event.Native.GetFilter()
		local thistype this = dummyMissile.GetData()
		if this.targetGroup.Contains(target) then
			return false
		endif
		if not thistype.TargetConditions(target) then
			return false
		endif
        return true
    endmethod
	eventMethod Collision
		local Missile dummyMissile = params.Missile.GetTrigger()
		local Unit target = params.Unit.GetTrigger()
		local thistype this = dummyMissile.GetData()
		call this.targetGroup.Add(target)
		call thistype(NULL).Target.Start(this.level, target)
	endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        
		local real targetZ = Spot.GetHeight(targetX, targetY) + UNIT_TYPE.Impact.Z.STANDARD
		local real scale = caster.Scale.Get()
		local thistype this = thistype.allocate()
		local Missile dummyMissile = Missile.Create()
		local SpellInstance whichInstance = SpellInstance.Create(caster, thistype.THIS_SPELL)
        set this.caster = caster
        set this.level = whichInstance.GetLevel()
        set this.scale = scale
        set this.target = target
        set this.whichInstance = whichInstance
        set this.x = caster.Position.X.Get()
        set this.y = caster.Position.Y.Get()
        call dummyMissile.Arc.SetByPerc(0.06)
        call dummyMissile.CollisionSize.Set(thistype.THIS_SPELL.GetAreaRange(level))
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, scale)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(900.)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.GoToSpot.Start(targetX, targetY, targetZ)
		call dummyMissile.Position.AddCollision(function thistype.Collision, thistype.TARGET_FILTER_COLLISION)
    endmethod
    initMethod Init of Spells_Artifacts
    	set thistype.ENUM_GROUP = Group.Create()
    	set thistype.TARGET_FILTER_COLLISION = BoolExpr.GetFromFunction(function thistype.TargetConditions_Collision)
    	set thistype.TARGET_FILTER_EXPLOSION = BoolExpr.GetFromFunction(function thistype.TargetConditions_Explosion)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        
        call thistype(NULL).Target.Init()
    endmethod
endstruct
    scope FolderWhiteStaff
    public struct StructTarget
        implement Allocation
        implement List
        
        static method Init takes nothing returns nothing
        endmethod
    endstruct
endscope
    globals
        WhiteStaff WHITE_STAFF = STRUCT_BASE
    endglobals
    struct WhiteStaff
        implement Allocation
        implement List
        
    static real array MANA_HEAL
    boolean channeling
    Sound dummySound
    Lightning effectLightning
    Timer intervalTimer
    boolean onSummon
    real manaHeal
    Unit target
    BuffRef targetBuffRef
    FolderWhiteStaff_StructTarget Target = this
    FolderWhiteStaff_StructTarget LinkToStruct_Target
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this
        call caster.HealManaBySpell(caster, this.manaHeal)
    endmethod
    static method EndChannel takes Unit caster returns nothing
        local thistype this = caster
        local Lightning effectLightning = this.effectLightning
        local Timer intervalTimer = this.intervalTimer
        local boolean onSummon = this.onSummon
        local Unit target = this.target
        local BuffRef targetBuffRef = this.targetBuffRef
		call dummySound.Destroy(true)
        call effectLightning.Destroy()
        call intervalTimer.Destroy()
		if (targetBuffRef != NULL) then
        	call targetBuffRef.Destroy()
        endif
        if onSummon then
            call target.KillBy(caster)
            call target.Death.Explosion.Subtract()
        endif
    endmethod
    eventMethod Event_EndCast
        local Unit caster = params.Unit.GetTrigger()
        local thistype this = thistype(caster)
        if not this.channeling then
            return
        endif
        set this.channeling = false
        call thistype.EndChannel(caster)
    endmethod
    static method StartChannel takes Unit caster, integer level, Unit target returns nothing
        local thistype this = caster
        local Lightning effectLightning = Lightning.Create(thistype.BOLT)
        local Timer intervalTimer = Timer.Create()
        set this.channeling = true
        set this.dummySound = Sound.CreateFromType(thistype.DUMMY_SOUND)
        set this.effectLightning = effectLightning
        set this.intervalTimer = intervalTimer
        set this.manaHeal = thistype.MANA_HEAL[level]
        set this.target = target
        call intervalTimer.SetData(this)
		call dummySound.AttachToUnitAndPlay(caster)
        call effectLightning.FromUnitToUnit.Start(caster, target)
        if target.Classes.Contains(UnitClass.SUMMON) then
            set this.onSummon = true
            call target.Death.Explosion.Add()
            call target.Scale.Timed.Add(thistype.SUMMON_SCALE_ADD * target.Type.Get().Scale.Get(), thistype.THIS_SPELL.GetChannelTime(level))
        else
            set this.onSummon = false
        endif
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
		if target.IsAllyOf(caster.Owner.Get()) then
        	set this.targetBuffRef = target.Buffs.CreateWithLevel(thistype(NULL).Target.DUMMY_BUFF, level, NULL)
        else
            set this.targetBuffRef = NULL
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        call thistype.StartChannel(caster, level, target)
    endmethod
    initMethod Init of Spells_Artifacts
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
        local integer level = thistype.THIS_SPELL.GetLevelsAmount()
        loop
            exitwhen (level < 1)
            set thistype.MANA_HEAL[level] = thistype.MANA_HEAL_PER_SECOND[level] * thistype.INTERVAL
            set level = level - 1
        endloop
        
        call thistype(NULL).Target.Init()
    endmethod
endstruct
    scope FolderBarrier
    public struct StructKnockback
        implement Allocation
        implement List
        
        static Group ENUM_GROUP
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
        static BoolExpr TARGET_FILTER
        static constant real UPDATE_TIME = 0.1
        UnitList targetGroup
        Timer updateTimer
        condMethod Conditions
            local Unit target = UNIT.Event.Native.GetFilter()
            if UnitList.TEMP.Contains(target) then
                return false
            endif
            if target.Classes.Contains(UnitClass.DEAD) then
                return false
            endif
            if target.Classes.Contains(UnitClass.STRUCTURE) then
                return false
            endif
            return true
        endmethod
        timerMethod Update
            local thistype this = Timer.GetExpired().GetData()
            local Unit target = this
            local UnitList targetGroup = this.targetGroup
            local real targetX = target.Position.X.Get()
            local real targetY = target.Position.Y.Get()
            set UnitList.TEMP = targetGroup
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(targetX, targetY, thistype.AREA_RANGE, thistype.TARGET_FILTER)
            local Unit victim = thistype.ENUM_GROUP.FetchFirst()
            if (victim != NULL) then
                loop
                    call targetGroup.Add(victim)
                    call victim.Position.Timed.Accelerated.AddKnockback(1000., -520., Math.AtanByDeltas(victim.Position.Y.Get() - targetY, victim.Position.X.Get() - targetX), 0.35)
                    set victim = thistype.ENUM_GROUP.FetchFirst()
                    exitwhen (victim == NULL)
                endloop
            endif
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            local Group targetGroup = this.targetGroup
            local Timer updateTimer = this.updateTimer
            call targetGroup.Destroy()
            call updateTimer.Destroy()
        endmethod
        eventMethod Event_BuffGain
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
			local Timer updateTimer = Timer.Create()
            set this.targetGroup = UnitList.Create()
            set this.updateTimer = updateTimer
            call updateTimer.SetData(this)
            call updateTimer.Start(thistype.UPDATE_TIME, true, function thistype.Update)
        endmethod
        static method Start takes Unit target returns nothing
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, Barrier.MOVE_DURATION)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.ENUM_GROUP = Group.Create()
            set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
    endstruct
endscope
    globals
        Barrier BARRIER = STRUCT_BASE
    endglobals
    struct Barrier
        implement Allocation
        implement List
        
    FolderBarrier_StructKnockback Knockback = this
    FolderBarrier_StructKnockback LinkToStruct_Knockback
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real angle = caster.Facing.Get()
        local User casterOwner = caster.Owner.Get()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real angleX = Math.Cos(angle)
        local real angleY = Math.Sin(angle)
        local real duration = thistype.DURATION[level]
        local integer iteration = thistype.SUMMONS_AMOUNT[level]
        local UnitType summonUnitType = thistype.SUMMON_UNIT_TYPE[level]
        local real targetX = casterX + thistype.CASTER_OFFSET * angleX
        local real targetY = casterY + thistype.CASTER_OFFSET * angleY
        local real window = iteration * thistype.WINDOW_PER_SUMMON
        set angle = angle - window / 2.
        loop
            local Unit barrier = Unit.Create(summonUnitType, casterOwner, targetX, targetY, UNIT.Facing.STANDARD)
            call barrier.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, duration)
            
            call barrier.Effects.Create(thistype.BARRIER_EFFECT_PATH, thistype.BARRIER_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).DestroyTimed.Start(2.)
            call barrier.Movement.RemovePermanently()
            call barrier.Pathing.Subtract()
            call barrier.Position.X.Set(targetX)
            call barrier.Position.Y.Set(targetY)
            call barrier.Position.Timed.AddNoCheck(thistype.OFFSET * Math.Cos(angle), thistype.OFFSET * Math.Sin(angle), 0., thistype.MOVE_DURATION)
            call barrier.ApplyTimedLife(duration)
            call thistype(NULL).Knockback.Start(barrier)
            set iteration = iteration - 1
            exitwhen (iteration < 1)
            set angle = angle + thistype.WINDOW_PER_SUMMON
        endloop
    endmethod
    initMethod Init of Spells_Purchasable
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Knockback.Init()
    endmethod
endstruct
    scope FolderBlizzard
    public struct StructWave
        implement Allocation
        implement List
        
        static Group ENUM_GROUP
        static BoolExpr TARGET_FILTER
        real areaRange
        Unit caster
        real damage
        real targetX
        real targetY
        condMethod Conditions
            local Unit target = UNIT.Event.Native.GetFilter()
            if target.Classes.Contains(UnitClass.DEAD) then
                return false
            endif
            if target.MagicImmunity.Try() then
                return false
            endif
            return true
        endmethod
        timerMethod Ending
            local Timer durationTimer = Timer.GetExpired()
            local thistype this = durationTimer.GetData()
            local real areaRange = this.areaRange
            local Unit caster = this.caster
            local real damage = this.damage
            local real targetX = this.targetX
            local real targetY = this.targetY
            local SpellInstance whichInstance = SpellInstance.Create(caster, Blizzard.THIS_SPELL)
            call this.deallocate()
            call durationTimer.Destroy()
            call whichInstance.Destroy()
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(targetX, targetY, areaRange, thistype.TARGET_FILTER)
            loop
                local Unit target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
                call caster.DamageUnitBySpell(target, damage, true, false)
            endloop
        endmethod
        static method Start takes Unit caster, integer level, real targetX, real targetY returns nothing
            local real areaRange = Blizzard.THIS_SPELL.GetAreaRange(level)
            local thistype this = thistype.allocate()
            local Sound dummySound = Sound.Create("Abilities\\Spells\\Human\\Blizzard\\BlizzardTarget" + Integer.ToString(Math.RandomI(1, 3)) + ".wav", false, true, false, 10, 10, SoundEax.SPELL)
            local Timer durationTimer = Timer.Create()
            set this.areaRange = areaRange
            set this.caster = caster
            set this.damage = thistype.DAMAGE[level]
            set this.targetX = targetX
            set this.targetY = targetY
            call durationTimer.SetData(this)
            set areaRange = areaRange * 0.75
			local integer iteration = thistype.DEBRIS_AMOUNT[level]
            loop
                exitwhen (iteration < 1)
                local real angle = Math.RandomAngle()
                local real offset = Math.Random(0., areaRange)
                call Spot.CreateEffect(targetX + offset * Math.Cos(angle), targetY + offset * Math.Sin(angle), thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW).Destroy()
                set iteration = iteration - 1
            endloop
            call durationTimer.Start(thistype.DAMAGE_DELAY, false, function thistype.Ending)
            call dummySound.SetPositionAndPlay(targetX, targetY, Spot.GetHeight(targetX, targetY))
            call dummySound.Destroy(true)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.ENUM_GROUP = Group.Create()
            set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        endmethod
    endstruct
endscope
    globals
        Blizzard BLIZZARD = STRUCT_BASE
    endglobals
    struct Blizzard
        implement Allocation
        implement List
        
    static SpellInstance WHICH_INSTANCE
    Sound effectSound
    Timer intervalTimer
    integer level
    real targetX
    real targetY
    FolderBlizzard_StructWave Wave = this
    FolderBlizzard_StructWave LinkToStruct_Wave
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        local Unit target = this
        call thistype(NULL).Wave.Start(target, this.level, this.targetX, this.targetY)
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local Sound effectSound = this.effectSound
        local Timer intervalTimer = this.intervalTimer
        call effectSound.Destroy(true)
        call intervalTimer.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local SpellInstance whichInstance = thistype.WHICH_INSTANCE
        local Unit target = whichInstance.GetCaster()
        local real targetX = whichInstance.GetTargetX()
        local real targetY = whichInstance.GetTargetY()
        local thistype this = target
        local Sound effectSound = Sound.Create("Abilities\\Spells\\Human\\Blizzard\\BlizzardLoop1.wav", true, true, false, 10, 10, SoundEax.SPELL)
        local Timer intervalTimer = Timer.Create()
        set this.effectSound = effectSound
        set this.intervalTimer = intervalTimer
        set this.level = level
        set this.targetX = targetX
        set this.targetY = targetY
        call intervalTimer.SetData(this)
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
        call effectSound.SetPositionAndPlay(targetX, targetY, Spot.GetHeight(targetX, targetY))
        call thistype(NULL).Wave.Start(target, level, targetX, targetY)
    endmethod
    eventMethod Event_EndCast
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_SpellEffect
        set thistype.WHICH_INSTANCE = params.SpellInstance.GetTrigger()
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Purchasable
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Wave.Init()
    endmethod
endstruct
    scope FolderChillyBreath
    public struct StructBuff
        implement Allocation
        implement List
        
        static method Start takes integer level, Unit target returns nothing
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION[level])
        endmethod
        static method Init takes nothing returns nothing
            call UNIT.Cold.NORMAL_BUFF.Variants.Add(thistype.DUMMY_BUFF)
            call UNIT.Madness.NORMAL_BUFF.Variants.Add(thistype.DUMMY_BUFF)
        endmethod
    endstruct
endscope
    globals
        ChillyBreath CHILLY_BREATH = STRUCT_BASE
    endglobals
    struct ChillyBreath
        implement Allocation
        implement List
        
    static constant real DUMMY_UNIT_STANDARD_DURATION = 0.35
    static Group ENUM_GROUP
    static real array LENGTH
    static real array SPEED
    static BoolExpr TARGET_FILTER
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
    real angle
    Unit caster
    real damage
    DummyUnit dummyUnit
    real length
    real lengthAdd
    integer level
    real maxLength
    Missile missileLeft
    Missile missileRight
    Group targetGroup
    Queue tiles
    Timer updateTimer
    real xAdd
    real yAdd
    FolderChillyBreath_StructBuff Buff = this
    FolderChillyBreath_StructBuff LinkToStruct_Buff
    method Ending takes nothing returns nothing
        local DummyUnit dummyUnit = this.dummyUnit
        local Group targetGroup = this.targetGroup
        local Timer updateTimer = this.updateTimer
call DebugEx("destroy "+I2S(this)+";"+I2S(updateTimer))
		call dummyUnit.SetTimeScale(1.)
        call dummyUnit.Destroy()
        call targetGroup.Destroy()
        call this.tiles.Destroy()
        call updateTimer.Destroy()
		call this.missileLeft.DummyUnit.Get().SetTimeScale(1.)
        call this.missileLeft.Destroy()
        call this.missileRight.DummyUnit.Get().SetTimeScale(1.)
        call this.missileRight.Destroy()
    endmethod
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if Group.TEMP.ContainsUnit(target) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    method SpawnIce takes real x, real y returns nothing
        local Tile val = Tile.GetFromCoords(x, y)
        if this.tiles.Contains(val) then
            call val.RemoveRef()
            return
        endif
		call this.tiles.Add(val)
        call TileTypeMod.Create(x, y, TileType.ICE).DestroyTimed.Start(4.)
    endmethod
    timerMethod Move
        local thistype this = Timer.GetExpired().GetData()
        local real angle = this.angle
        local Unit caster = this.caster
        local DummyUnit dummyUnit = this.dummyUnit
        local real lengthAdd = this.lengthAdd
        local real maxLength = this.maxLength
        local real oldLength = this.length
        local Group targetGroup = this.targetGroup
        local real length = oldLength + lengthAdd
        local real x = dummyUnit.Position.X.Get() + this.xAdd
        local real y = dummyUnit.Position.Y.Get() + this.yAdd
        local real widthEnd = thistype.WIDTH_START + (thistype.WIDTH_END - thistype.WIDTH_START) * (oldLength / maxLength)
        local real widthStart = thistype.WIDTH_START + (thistype.WIDTH_END - thistype.WIDTH_START) * (length / maxLength)
        call this.SpawnIce(x, y)
        call this.SpawnIce(this.missileLeft.Position.X.Get(), this.missileLeft.Position.Y.Get())
        call this.SpawnIce(this.missileRight.Position.X.Get(), this.missileRight.Position.Y.Get())
        set this.length = length
        call dummyUnit.Position.SetXY(x, y)
        set User.TEMP = caster.Owner.Get()
        set Group.TEMP = targetGroup
        call thistype.ENUM_GROUP.EnumUnits.InLine.WithCollision.Do(x, y, lengthAdd, angle, widthStart, widthEnd, thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real damage = this.damage * (1 + length / maxLength * thistype.DAMAGE_RANGE_FACTOR)
            local integer level = this.level
            loop
                call targetGroup.AddUnit(target)
                call thistype(NULL).Buff.Start(level, target)
                call caster.DamageUnitBySpell(target, damage, true, false)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    eventMethod Impact
        
    endmethod
    method StartSideMissiles takes Unit source, real length, real speed, real angle, real timeScale returns nothing
        local real sourceX = source.Position.X.Get()
        local real sourceY = source.Position.Y.Get()
		local Missile dummyMissile = Missile.Create()
        set this.missileRight = dummyMissile
        set angle = angle - Math.QUARTER_ANGLE / 3
        local real targetX = sourceX + length * Math.Cos(angle)
        local real targetY = sourceY + length * Math.Sin(angle)
        call dummyMissile.CollisionSize.Set(10.)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 0.4)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.Speed.Set(speed)
        call dummyMissile.Position.SetFromUnit(source)
        local DummyUnit dummyUnit = dummyMissile.DummyUnit.Get()
        call dummyUnit.SetTimeScale(timeScale)
        call dummyMissile.GoToSpot.Start(targetX, targetY, Spot.GetHeight(targetX, targetY))
        set angle = angle + 2 * Math.QUARTER_ANGLE / 3
        set dummyMissile = Missile.Create()
        set targetX = sourceX + length * Math.Cos(angle)
        set targetY = sourceY + length * Math.Sin(angle)
        set this.missileLeft = dummyMissile
        call dummyMissile.CollisionSize.Set(10.)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 0.4).SetTimeScale(timeScale)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.Speed.Set(speed)
        call dummyMissile.Position.SetFromUnit(source)
        set dummyUnit = dummyMissile.DummyUnit.Get()
        call dummyUnit.SetTimeScale(timeScale)
        call dummyMissile.GoToSpot.Start(targetX, targetY, Spot.GetHeight(targetX, targetY))
    endmethod
    eventMethod Event_EndCast
        local Unit caster = params.Unit.GetTrigger()
        local boolean success = params.Spell.IsChannelComplete()
        local thistype this = caster
        call this.Ending()
        if success then
            call caster.Abilities.Refresh(Infection.THIS_SPELL)
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real dX = targetX - casterX
        local real dY = targetY - casterY
        local real timeScale = thistype.DUMMY_UNIT_STANDARD_DURATION / thistype.THIS_SPELL.GetChannelTime(level)
        local real angle = caster.CastAngle(dX, dY)
        local thistype this = caster
		local DummyUnit dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, casterX, casterY, caster.Position.Z.GetByCoords(casterX, casterY) + caster.Outpact.Z.Get(true), angle)
		local Sound effectSound = Sound.CreateFromType(thistype.EFFECT_SOUND)
        local Timer updateTimer = Timer.Create()
call DebugEx("create "+I2S(this)+";"+I2S(updateTimer))
        set this.angle = angle
        set this.caster = caster
        set this.damage = thistype.DAMAGE[level]
        set this.dummyUnit = dummyUnit
        set this.length = 0.
        set this.lengthAdd = thistype.LENGTH[level]
        set this.level = level
        set this.maxLength = thistype.MAX_LENGTH[level]
        set this.targetGroup = Group.Create()
        set this.tiles = Queue.Create()
        set this.updateTimer = updateTimer
        set this.xAdd = Math.Cos(angle) * thistype.LENGTH[level]
        set this.yAdd = Math.Sin(angle) * thistype.LENGTH[level]
        call updateTimer.SetData(this)
        call dummyUnit.SetScale(0.75)
        call dummyUnit.SetTimeScale(timeScale)
        call effectSound.SetPositionAndPlay(casterX, casterY, Spot.GetHeight(casterX, casterY))
        call effectSound.Destroy(true)
        call updateTimer.Start(thistype.UPDATE_TIME, true, function thistype.Move)
        call this.StartSideMissiles(caster, thistype.MAX_LENGTH[level], thistype.SPEED[level], angle, timeScale)
        call caster.Knockup.Start()
    endmethod
    initMethod Init of Spells_Purchasable
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
        local integer iteration = thistype.THIS_SPELL.GetLevelsAmount()
        loop
            set thistype.SPEED[iteration] = thistype.MAX_LENGTH[iteration] / thistype.THIS_SPELL.GetChannelTime(iteration)
            set thistype.LENGTH[iteration] = thistype.SPEED[iteration] * thistype.UPDATE_TIME
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        call thistype(NULL).Buff.Init()
    endmethod
endstruct
    globals
        ElementalSpellToHero ELEMENTAL_SPELL_TO_HERO = STRUCT_BASE
    endglobals
    struct ElementalSpellToHero
        implement Allocation
        implement List
        
    static Event CREATE_EVENT
    static Group ENUM_GROUP
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    Spell whichSpell
    eventMethod Event_Create
        local thistype this = params.UnitType.GetTrigger().Data.Integer.Get(KEY)
        local Unit whichUnit = params.Unit.GetTrigger()
        call HeroSpell.AddToUnit(this.whichSpell, whichUnit)
        call whichUnit.Abilities.Add(this.whichSpell)
    endmethod
    enumMethod Create_Enum
        local Unit whichUnit = UNIT.Event.Native.GetEnum()
        local thistype this = whichUnit.Type.Get().Data.Integer.Get(KEY)
        call HeroSpell.AddToUnit(this.whichSpell, whichUnit)
        call whichUnit.Abilities.Add(this.whichSpell)
    endmethod
    static method Create takes UnitType whichUnitType, Spell whichSpell returns thistype
        local thistype this = thistype.allocate()
        set this.whichSpell = whichSpell
        call whichUnitType.Data.Integer.Set(KEY, this)
        call whichUnitType.Event.Add(CREATE_EVENT)
        call Unit.EnumOfType(whichUnitType, function thistype.Create_Enum)
        return this
    endmethod
    initMethod Init of Spells_Grant_Elementals
        set thistype.CREATE_EVENT = Event.Create(Unit.CREATE_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Create)
        set thistype.ENUM_GROUP = Group.Create()
        call thistype.Create(UnitType.ARURUW, TwinWolves.THIS_SPELL)
        call thistype.Create(UnitType.DRAKUL, ChillyBreath.THIS_SPELL)
        call thistype.Create(UnitType.JOTA, IceShock.THIS_SPELL)
        call thistype.Create(UnitType.KERA, GhostSword.THIS_SPELL)
        call thistype.Create(UnitType.LIZZY, Fireburst.THIS_SPELL)
        call thistype.Create(UnitType.ROCKETEYE, Monolith.THIS_SPELL)
        call thistype.Create(UnitType.SMOKEALOT, InnerForce.THIS_SPELL)
        call thistype.Create(UnitType.STORMY, Severance.THIS_SPELL)
        call thistype.Create(UnitType.TAJRAN, Thunderstrike.THIS_SPELL)
    endmethod
endstruct
    scope FolderFireburst
    public struct StructShot
        implement Allocation
        implement List
        
        static Group ENUM_GROUP
        static Group ENUM_GROUP2
        static BoolExpr COLLISION_FILTER
        static BoolExpr TARGET_FILTER
        real damageExtra
        Fireburst parent
        condMethod Conditions
            local Unit target = UNIT.Event.Native.GetFilter()
            if target.Classes.Contains(UnitClass.DEAD) then
                return false
            endif
            if target.MagicImmunity.Try() then
                return false
            endif
            if target.IsAllyOf(User.TEMP) then
                return false
            endif
            return true
        endmethod
        condEventMethod Collision_Conditions
			local Missile dummyMissile = params.Missile.GetTrigger()
            local Unit target = UNIT.Event.Native.GetFilter()
            local thistype this = dummyMissile.GetData()
            local Fireburst parent = this.parent
            if target.Classes.Contains(UnitClass.DEAD) then
                return false
            endif
            if target.IsAllyOf(parent.caster.Owner.Get()) then
                return false
            endif
        endmethod
        eventMethod ImpactExtra
            local Missile dummyMissile = params.Missile.GetTrigger()
            local thistype this = dummyMissile.GetData()
            local Fireburst parent = this.parent
            local Unit caster = parent.caster
            local integer level = parent.level
            local Unit target = parent.target
            local real targetX = dummyMissile.Position.X.Get()
            local real targetY = dummyMissile.Position.Y.Get()
            call dummyMissile.Destroy()
            call target.Buffs.Timed.StartEx(thistype.IGNITION_BUFF, level, caster, thistype.IGNITION_DURATION[level])
            call caster.DamageUnitBySpell(target, this.damageExtra, true, false)
            call parent.SubtractRef()
            call this.deallocate()
        endmethod
        eventMethod Impact
            local Missile dummyMissile = params.Missile.GetTrigger()
            local Unit target = params.Unit.GetTrigger()
            local thistype this = dummyMissile.GetData()
            local Fireburst parent = this.parent
            local Unit caster = parent.caster
            local integer level = parent.level
            local real targetX = dummyMissile.Position.X.Get()
            local real targetY = dummyMissile.Position.Y.Get()
            call dummyMissile.Destroy()
			call Spot.CreateEffect(targetX, targetY, "Objects\\Spawnmodels\\Other\\NeutralBuildingExplosion\\NeutralBuildingExplosion.mdl", EffectLevel.NORMAL).Destroy()
			if (target != NULL) then
            	call target.Buffs.Timed.StartEx(thistype.IGNITION_BUFF, level, caster, thistype.IGNITION_DURATION[level])
            endif
            set User.TEMP = caster.Owner.Get()
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(targetX, targetY, Fireburst.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
			
            	
            
            set target = thistype.ENUM_GROUP.FetchFirst()
            if (target != NULL) then
                local real casterX = parent.x
                local real casterY = parent.y
                local real colSize = caster.CollisionSize.Get(true)
                local real damage = thistype.DAMAGE[level]
                loop
                    local real d = Math.DistanceByDeltas(target.Position.X.Get() - casterX, target.Position.Y.Get() - casterY)
                    local real rangeFactor = Math.Shapes.LinearFromCoords(colSize, thistype.RANGE_FACTOR_CLOSE, Fireburst.THIS_SPELL.GetRange(level), thistype.RANGE_FACTOR_FAR, d)
                    set rangeFactor = Math.Limit(rangeFactor, thistype.RANGE_FACTOR_CLOSE, thistype.RANGE_FACTOR_FAR)
                    call thistype.ENUM_GROUP2.AddUnit(target)
                    call caster.DamageUnitBySpell(target, damage * rangeFactor, true, false)
                    set target = thistype.ENUM_GROUP.FetchFirst()
                    exitwhen (target == NULL)
                endloop
            endif
            set User.TEMP = caster.Owner.Get()
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(targetX, targetY, Fireburst.THIS_SPELL.GetRange(level), thistype.TARGET_FILTER)
            call thistype.ENUM_GROUP.RemoveUnit(parent.target)
            loop
                set target = thistype.ENUM_GROUP2.FetchFirst()
                exitwhen (target == NULL)
                call thistype.ENUM_GROUP.RemoveUnit(target)
            endloop
            set target = thistype.ENUM_GROUP.GetNearestWithCollision(targetX, targetY)
            if ((target == NULL) or not caster.Buffs.Contains(FairyShape.DUMMY_BUFF)) then
                call parent.SubtractRef()
                call this.deallocate()
                return
            endif
            set this.damageExtra = thistype.DAMAGE[level] * FairyShape.FIREBURST_EXTRA_DMG_FACTOR[caster.Buffs.GetLevel(FairyShape.DUMMY_BUFF)]
            set dummyMissile = Missile.Create()
            call dummyMissile.Arc.SetByPerc(0.06)
            call dummyMissile.CollisionSize.Set(10.)
            call dummyMissile.Impact.SetAction(function thistype.ImpactExtra)
            call dummyMissile.SetData(this)
            call dummyMissile.Speed.Set(900.)
            call dummyMissile.Position.SetFromUnit(caster)
            call dummyMissile.GoToUnit.Start(target, null)
            call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_EXTRA_ID, 0.75)
        endmethod
        static method Start takes Fireburst parent returns nothing
            local Unit caster = parent.caster
            local DummyUnit dummyUnit = parent.dummyUnit
            local Unit target = parent.target
            local Missile dummyMissile = Missile.Create()
            local thistype this = thistype.allocate()
            set this.parent = parent
            call parent.AddRef()
            local real sourceX = dummyUnit.Position.X.Get()
            local real sourceY = dummyUnit.Position.Y.Get()
            local real angle = Math.AtanByDeltas(target.Position.Y.Get() - sourceY, target.Position.X.Get() - sourceX)
            call dummyUnit.Facing.Set(angle)
            call dummyMissile.Arc.SetByPerc(0.2)
            call dummyMissile.CollisionSize.Set(10.)
            call dummyMissile.Impact.SetAction(function thistype.Impact)
            call dummyMissile.SetData(this)
            call dummyMissile.Speed.Set(1000.)
            call dummyMissile.GoToUnit.Start(target, null)
            call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1.)
            call dummyMissile.Position.AddCollision(function thistype.Impact, thistype.COLLISION_FILTER)
            call dummyMissile.Position.Set(sourceX + thistype.LAUNCH_OFFSET * Math.Cos(angle), sourceY + thistype.LAUNCH_OFFSET * Math.Sin(angle), dummyUnit.Position.Z.Get())
        endmethod
        static method Init takes nothing returns nothing
            set thistype.COLLISION_FILTER = BoolExpr.GetFromFunction(function thistype.Collision_Conditions)
            set thistype.ENUM_GROUP = Group.Create()
            set thistype.ENUM_GROUP2 = Group.Create()
            set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
            call UNIT.Ignited.NORMAL_BUFF.Variants.Add(thistype.IGNITION_BUFF)
        endmethod
    endstruct
endscope
    globals
        Fireburst FIREBURST = STRUCT_BASE
    endglobals
    struct Fireburst
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    Unit caster
    DummyUnit dummyUnit
    integer level
    Timer intervalTimer
    Unit target
    integer remainingMissilesToSpawn
    SpellInstance whichInstance
    real x
    real y
    boolean destroyed
    integer refs
    FolderFireburst_StructShot Shot = this
    FolderFireburst_StructShot LinkToStruct_Shot
    method CheckForDestroy takes nothing returns nothing
        if not this.destroyed then
            return
        endif
        if (this.refs > 0) then
            return
        endif
        call this.deallocate()
    endmethod
    method SubtractRef takes nothing returns nothing
        set this.refs = this.refs - 1
        call this.CheckForDestroy()
    endmethod
    method AddRef takes nothing returns nothing
        set this.refs = this.refs + 1
    endmethod
    method Ending takes nothing returns nothing
        local DummyUnit dummyUnit = this.dummyUnit
        local Timer intervalTimer = this.intervalTimer
        local SpellInstance whichInstance = this.whichInstance
        call dummyUnit.Destroy()
        call intervalTimer.Destroy()
        if caster.Data.Integer.Table.Remove(KEY_ARRAY, this) then
            call caster.Buffs.Remove(thistype.DUMMY_BUFF)
        endif
        set this.destroyed = true
        call this.CheckForDestroy()
    endmethod
    static method EndingAll takes Unit caster returns nothing
        local integer iteration = caster.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            local thistype this = caster.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            call this.Ending()
        endloop
    endmethod
    method Interval takes nothing returns nothing
        call thistype(NULL).Shot.Start(this)
        if (this.remainingMissilesToSpawn == 1) then
            call this.Ending()
        else
            set this.remainingMissilesToSpawn = this.remainingMissilesToSpawn - 1
        endif
    endmethod
    timerMethod IntervalByTimer
        local thistype this = Timer.GetExpired().GetData()
        call this.Interval()
    endmethod
    timerMethod Delay
        local thistype this = Timer.GetExpired().GetData()
        call intervalTimer.Start(thistype.MISSILES_SPAWN_INTERVAL, true, function thistype.IntervalByTimer)
        call this.Interval()
    endmethod
    eventMethod Event_BuffLose
        local Unit caster = params.Unit.GetTrigger()
        call thistype.EndingAll(caster)
    endmethod
    eventMethod Event_BuffGain
        local Unit caster = params.Unit.GetTrigger()
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        local SpellInstance whichInstance = params.SpellInstance.GetTrigger()
        local real x = caster.Position.X.Get()
        local real y = caster.Position.Y.Get()
        local real z = caster.Position.Z.Get() + caster.Outpact.Z.Get(true) * 3
        local thistype this = thistype.allocate()
        local DummyUnit dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, x, y, z, whichInstance.GetAngle())
        local Timer intervalTimer = Timer.Create()
        set this.caster = caster
        set this.destroyed = false
        set this.dummyUnit = dummyUnit
        set this.intervalTimer = intervalTimer
        set this.level = level
        set this.refs = 0
        set this.remainingMissilesToSpawn = thistype.MISSILES_AMOUNT[level]
        set this.target = target
        set this.whichInstance = whichInstance
        set this.x = x
        set this.y = y
        call intervalTimer.SetData(this)
        call dummyUnit.CreateEffect(thistype.DUMMY_UNIT_SPECIAL_EFFECT_PATH, thistype.DUMMY_UNIT_SPECIAL_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
        call dummyUnit.Animation.Set(Animation.SPELL)
        call dummyUnit.PlayerColor.Set(caster.Color.Get())
        call dummyUnit.VertexColor.Set(0, 0, 0, 0)
        call dummyUnit.VertexColor.Timed.Add(255, 255, 255, 255, thistype.MISSILES_SPAWN_DELAY)
        if caster.Data.Integer.Table.Add(KEY_ARRAY, this) then
            call caster.Buffs.Add(thistype.DUMMY_BUFF, level)
        endif
        call intervalTimer.Start(thistype.MISSILES_SPAWN_DELAY, false, function thistype.Delay)
    endmethod
    initMethod Init of Spells_Purchasable
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype(NULL).Shot.Init()
    endmethod
endstruct
    globals
        FlameTongue FLAME_TONGUE = STRUCT_BASE
    endglobals
    struct FlameTongue
        implement Allocation
        implement List
        
    static real array DURATION
    static Group ENUM_GROUP
    static real array HORIZONTAL_ACCELERATION
    static real array HORIZONTAL_OFFSET_FACTOR
    static real array HORIZONTAL_MAX_WIDTH_LENGTH
    static real array LENGTH
    static BoolExpr TARGET_FILTER
    real angle
    real areaRange
    Unit caster
    real damage
    real damageIgniteFactor
    real horizontalAcceleration
    real horizontalAngleX
    real horizontalAngleY
    real horizontalOffsetFactor
    Timer intervalTimer
    real length
    real lengthAdd
    integer level
    real maxDamage
    UnitList targetGroup
    real x
    real xAdd
    real y
    real yAdd
    SpellInstance whichInstance
    timerMethod Ending2
        local Timer durationTimer = Timer.GetExpired()
        local thistype this = durationTimer.GetData()
        local Timer intervalTimer = this.intervalTimer
        local UnitList targetGroup = this.targetGroup
        local SpellInstance whichInstance = this.whichInstance
        call this.deallocate()
        call durationTimer.Destroy()
        call intervalTimer.Destroy()
        call targetGroup.Destroy()
        call whichInstance.Destroy()
    endmethod
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if UnitList.TEMP.Contains(target) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    method DoExplosion takes real areaRange, Unit caster, User casterOwner, real damage, integer directionFactor, real horizontalX, real horizontalY, UnitList targetGroup, real x, real y, SpellInstance whichInstance returns nothing
        set x = x + directionFactor * horizontalX
        set y = y + directionFactor * horizontalY
        call Spot.CreateEffect(x, y, thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW).Destroy()
        call Spot.CreateEffect(x, y, thistype.SPECIAL_EFFECT2_PATH, EffectLevel.NORMAL).Destroy()
        set UnitList.TEMP = targetGroup
        set User.TEMP = casterOwner
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, areaRange, thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real damageIgniteFactor = this.damageIgniteFactor
            local real maxDamage = this.maxDamage
            loop
                set damage = Math.Min(damage, maxDamage)
                call targetGroup.Add(target)
                set maxDamage = maxDamage - damage
                if target.Ignited.Is() then
                    set damage = damage * damageIgniteFactor
                endif
                call caster.DamageUnitBySpell(target, damage, true, false)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
            set this.maxDamage = maxDamage
        endif
    endmethod
    timerMethod Move
        local thistype this = Timer.GetExpired().GetData()
        local real angle = this.angle
        local real areaRange = this.areaRange
        local Unit caster = this.caster
        local real damage = this.damage
        local real length = this.length + this.lengthAdd
        local UnitList targetGroup = this.targetGroup
        local real x = this.x + this.xAdd
        local real y = this.y + this.yAdd
        local SpellInstance whichInstance = this.whichInstance
        local User casterOwner = caster.Owner.Get()
        local real horizontalLength = length * (this.horizontalAcceleration * length + this.horizontalOffsetFactor)
        local real horizontalX = horizontalLength * this.horizontalAngleX
        local real horizontalY = horizontalLength * this.horizontalAngleY
        set this.length = length
        set this.x = x
        set this.y = y
        call this.DoExplosion(areaRange, caster, casterOwner, damage, -1, horizontalX, horizontalY, targetGroup, x, y, whichInstance)
        call this.DoExplosion(areaRange, caster, casterOwner, damage, 1, horizontalX, horizontalY, targetGroup, x, y, whichInstance)
    endmethod
    timerMethod Start2
        local Timer durationTimer = Timer.GetExpired()
        local thistype this = durationTimer.GetData()
        set this.lengthAdd = -this.lengthAdd
        set this.xAdd = -this.xAdd
        set this.yAdd = -this.yAdd
        call this.targetGroup.Clear()
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Move)
        call durationTimer.Start(thistype.DURATION[this.level], false, function thistype.Ending2)
    endmethod
    timerMethod Ending
        local Timer durationTimer = Timer.GetExpired()
        local thistype this = durationTimer.GetData()
        call this.intervalTimer.Pause()
        call durationTimer.Start(0.15, false, function thistype.Start2)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real dX = targetX - casterX
        local real dY = targetY - casterY
        local real angle = caster.CastAngle(dX, dY)
        local real d = Math.DistanceByDeltas(dX, dY)
        local real horizontalAngle = angle - Math.QUARTER_ANGLE
		local thistype this = thistype.allocate()
        local Timer durationTimer = Timer.Create()
        local Timer intervalTimer = Timer.Create()
        local SpellInstance whichInstance = SpellInstance.Create(caster, thistype.THIS_SPELL)
        set this.angle = angle
        set this.areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        set this.caster = caster
        set this.damage = thistype.DAMAGE[level] + caster.Damage.Get() * thistype.DAMAGE_DAMAGE_MOD_FACTOR
        set this.damageIgniteFactor = (1. + thistype.DAMAGE_IGNITE_BONUS[level])
        set this.horizontalAcceleration = thistype.HORIZONTAL_ACCELERATION[level]
        set this.horizontalAngleX = Math.Cos(horizontalAngle)
        set this.horizontalAngleY = Math.Sin(horizontalAngle)
        set this.horizontalOffsetFactor = thistype.HORIZONTAL_OFFSET_FACTOR[level]
        set this.intervalTimer = intervalTimer
        set this.length = 0.
        set this.lengthAdd = thistype.LENGTH[level]
        set this.level = level
        set this.maxDamage = thistype.MAX_DAMAGE[level]
        set this.targetGroup = UnitList.Create()
        set this.x = targetX
        set this.xAdd = thistype.LENGTH[level] * Math.Cos(angle)
        set this.y = targetY
        set this.yAdd = thistype.LENGTH[level] * Math.Sin(angle)
        set this.whichInstance = whichInstance
        call durationTimer.SetData(this)
        call intervalTimer.SetData(this)
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Move)
        call durationTimer.Start(thistype.DURATION[level], false, function thistype.Ending)
    endmethod
    initMethod Init of Spells_Purchasable
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        local integer iteration = thistype.THIS_SPELL.GetLevelsAmount()
        loop
            set thistype.DURATION[iteration] = Real.ToInt((thistype.MAX_LENGTH[iteration] / thistype.SPEED[iteration]) / thistype.INTERVAL) * thistype.INTERVAL
            set thistype.HORIZONTAL_MAX_WIDTH_LENGTH[iteration] = thistype.HORIZONTAL_MAX_WIDTH_LENGTH_FACTOR[iteration] * thistype.MAX_LENGTH[iteration]
            set thistype.LENGTH[iteration] = thistype.SPEED[iteration] * thistype.INTERVAL
            set thistype.HORIZONTAL_ACCELERATION[iteration] = thistype.HORIZONTAL_MAX_WIDTH[iteration] / thistype.HORIZONTAL_MAX_WIDTH_LENGTH[iteration] / (thistype.HORIZONTAL_MAX_WIDTH_LENGTH[iteration] + thistype.MAX_LENGTH[iteration])
            set thistype.HORIZONTAL_OFFSET_FACTOR[iteration] = -thistype.HORIZONTAL_ACCELERATION[iteration] * thistype.MAX_LENGTH[iteration]
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
    endmethod
endstruct
    scope FolderFrozenStar
    public struct StructTarget
        implement Allocation
        implement List
        
        static method Start takes integer level, Unit target returns nothing
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION[level])
        endmethod
        static method Init takes nothing returns nothing
            call UNIT.Cold.NORMAL_BUFF.Variants.Add(thistype.DUMMY_BUFF)
        endmethod
    endstruct
    public struct StructExplosion
        implement Allocation
        implement List
        
        static Group ENUM_GROUP
        static BoolExpr TARGET_FILTER
        static method Conditions takes nothing returns boolean
            local Unit target = UNIT.Event.Native.GetFilter()
            if target.Classes.Contains(UnitClass.DEAD) then
                return false
            endif
            if target.IsAllyOf(User.TEMP) then
                return false
            endif
            return true
        endmethod
        method Start takes Unit caster, real damage, integer level, real x, real y returns nothing
            local FrozenStar parent = this
            call Spot.CreateEffect(x, y, thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW).Destroy()
            set User.TEMP = caster.Owner.Get()
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, FrozenStar.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
            local Unit target = thistype.ENUM_GROUP.FetchFirst()
            if (target != NULL) then
                loop
                    call FROZEN_STAR.Target.Start(level, target)
					call target.Position.Timed.Accelerated.AddKnockback(thistype.KNOCKBACK_SPEED, 0., Math.AtanByDeltas(target.Position.Y.Get() - y, target.Position.X.Get() - x) + Math.HALF_ANGLE, thistype.KNOCKBACK_DURATION)
                    call caster.DamageUnitBySpell(target, damage, true, false)
                    set target = thistype.ENUM_GROUP.FetchFirst()
                    exitwhen (target == NULL)
                endloop
            endif
        endmethod
        static method Init takes nothing returns nothing
            set thistype.ENUM_GROUP = Group.Create()
            set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        endmethod
    endstruct
endscope
    globals
        FrozenStar FROZEN_STAR = STRUCT_BASE
    endglobals
    struct FrozenStar
        implement Allocation
        implement List
        
    static real array DURATION
    static Group ENUM_GROUP
    static real array LENGTH
    static BoolExpr TARGET_FILTER
    static thistype TEMP
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
    real angle
    real areaRange
    Unit caster
    real damage
    DummyUnit dummyUnit
    real horizontalAcceleration
    real horizontalAngleX
    real horizontalAngleY
    real horizontalOffsetFactor
    real length
    real lengthAdd
    integer level
    UnitList targetGroup
    real x
    real xAdd
    real y
    real yAdd
    Timer updateTimer
    SpellInstance whichInstance
    FolderFrozenStar_StructExplosion Explosion = this
    FolderFrozenStar_StructExplosion LinkToStruct_Explosion
    FolderFrozenStar_StructTarget Target = this
    FolderFrozenStar_StructTarget LinkToStruct_Target
    timerMethod Ending
        local Timer durationTimer = Timer.GetExpired()
        local thistype this = durationTimer.GetData()
        local Unit caster = this.caster
        local real damage = this.damage
        local DummyUnit dummyUnit = this.dummyUnit
        local integer level = this.level
        local UnitList targetGroup = this.targetGroup
        local Timer updateTimer = this.updateTimer
        local real x = this.x
        local real y = this.y
        local SpellInstance whichInstance = this.whichInstance
        call this.deallocate()
        call dummyUnit.Destroy()
        call durationTimer.Destroy()
        call targetGroup.Destroy()
        call updateTimer.Destroy()
        call whichInstance.Destroy()
        call thistype(NULL).Explosion.Start(caster, damage, level, x, y)
    endmethod
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if UnitList.TEMP.Contains(target) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    timerMethod Move
        local thistype this = Timer.GetExpired().GetData()
        local real angle = this.angle
        local DummyUnit dummyUnit = this.dummyUnit
        local real length = this.length + this.lengthAdd
        local UnitList targetGroup = this.targetGroup
        local real x = this.x + this.xAdd
        local real y = this.y + this.yAdd
        local real horizontalLength = length * (this.horizontalAcceleration * length + this.horizontalOffsetFactor)
        set this.length = length
        set this.x = x
        set this.y = y
        set x = x + horizontalLength * this.horizontalAngleX
        set y = y + horizontalLength * this.horizontalAngleY
        call Spot.CreateEffect(x, y, thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW).Destroy()
        call dummyUnit.Position.X.Set(x)
        call dummyUnit.Position.Y.Set(y)
        set User.TEMP = this.caster.Owner.Get()
        set UnitList.TEMP = targetGroup
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, this.areaRange, thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local integer level = this.level
            loop
                call targetGroup.Add(target)
                call this.Target.Start(level, target)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local real casterAngle = caster.Facing.Get()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real dX = targetX - casterX
        local real dY = targetY - casterY
        local real angle = caster.CastAngle(dX, dY)
        local real casterSightD = thistype.MAX_LENGTH[level] * thistype.CASTER_SIGHT_D_FACTOR
        local real d = Math.DistanceByDeltas(dX, dY)
        local real angleD = Math.Min(Math.AngleDifference(casterAngle, angle) * thistype.ANGLE_D_FACTOR, thistype.MAX_ANGLE_D)
        local real horizontalAngle = angle - Math.QUARTER_ANGLE + 2 * Math.QUARTER_ANGLE * Boolean.ToInt(Math.CompareAngles(casterAngle, angle))
        local real length = casterSightD * Math.Cos(angleD)
        local real horizontalAcceleration = (Math.Sin(angleD) * casterSightD) / (length * (length - thistype.MAX_LENGTH[level]))
        local thistype this = thistype.allocate()
		local Timer durationTimer = Timer.Create()
        local Timer updateTimer = Timer.Create()
        local SpellInstance whichInstance = SpellInstance.Create(caster, thistype.THIS_SPELL)
        set this.angle = angle
        set this.areaRange = thistype.MOVING_AREA_RANGE[level]
        set this.caster = caster
        set this.damage = Explosion.DAMAGE[level]
        set this.dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, casterX, casterY, caster.Position.Z.GetByCoords(casterX, casterY) + caster.Outpact.Z.Get(true), angle)
        set this.horizontalAcceleration = horizontalAcceleration
        set this.horizontalAngleX = horizontalAngle * Math.Cos(horizontalAngle)
        set this.horizontalAngleY = horizontalAngle * Math.Sin(horizontalAngle)
        set this.horizontalOffsetFactor = -horizontalAcceleration * thistype.MAX_LENGTH[level]
        set this.length = 0.
        set this.lengthAdd = thistype.LENGTH[level]
        set this.level = level
        set this.targetGroup = UnitList.Create()
        set this.updateTimer = updateTimer
        set this.x = casterX
        set this.xAdd = thistype.LENGTH[level] * Math.Cos(angle)
        set this.y = casterY
        set this.yAdd = thistype.LENGTH[level] * Math.Sin(angle)
        set this.whichInstance = whichInstance
        call durationTimer.SetData(this)
        call updateTimer.SetData(this)
        call updateTimer.Start(thistype.UPDATE_TIME, true, function thistype.Move)
        call durationTimer.Start(thistype.DURATION[level], false, function thistype.Ending)
    endmethod
    initMethod Init of Spells_Purchasable
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        local integer iteration = thistype.THIS_SPELL.GetLevelsAmount()
        loop
            set thistype.DURATION[iteration] = thistype.MAX_LENGTH[iteration] / thistype.SPEED[iteration]
            set thistype.LENGTH[iteration] = thistype.SPEED[iteration] * thistype.UPDATE_TIME
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        call thistype(NULL).Explosion.Init()
        call thistype(NULL).Target.Init()
    endmethod
endstruct
    scope FolderGhostSword
    public struct StructSword
        implement Allocation
        implement List
        
    	static Event CRIT_EVENT
        static Event DAMAGE_EVENT
    	static Group ENUM_GROUP
    	static BoolExpr TARGET_FILTER
        static constant real UPDATE_TIME = 0.1
        static Timer UPDATE_TIMER
    static thistype array ACTIVE_LIST_ALL
    static integer ACTIVE_LIST_ALL_COUNT = ARRAY_EMPTY
    integer ACTIVE_LIST_index
    static method ACTIVE_LIST_Count takes nothing returns integer
        return thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static method ACTIVE_LIST_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Get takes integer index returns thistype
        return thistype.ACTIVE_LIST_ALL[index]
    endmethod
    static method ACTIVE_LIST_GetIndex takes thistype this returns integer
        return this.ACTIVE_LIST_index
    endmethod
    static method ACTIVE_LIST_Contains takes thistype this returns boolean
        return (thistype.ACTIVE_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ACTIVE_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ACTIVE_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ACTIVE_LIST_RandomAll takes nothing returns thistype
        return thistype.ACTIVE_LIST_Random(ARRAY_MIN, thistype.ACTIVE_LIST_ALL_COUNT)
    endmethod
    static method ACTIVE_LIST_Remove takes thistype this returns boolean
        if not thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT].ACTIVE_LIST_index = this.ACTIVE_LIST_index
        set thistype.ACTIVE_LIST_ALL[this.ACTIVE_LIST_index - 1] = thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT]
        set this.ACTIVE_LIST_index = ARRAY_MIN
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT - 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Add takes thistype this returns boolean
        if thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT + 1
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT] = this
        set this.ACTIVE_LIST_index = thistype.ACTIVE_LIST_ALL_COUNT + 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static thistype array FOR_EACH_LIST_ALL
    static integer FOR_EACH_LIST_ALL_COUNT = ARRAY_EMPTY
    static method FOR_EACH_LIST_FetchFirst takes nothing returns thistype
        local thistype result
        if (thistype.FOR_EACH_LIST_ALL_COUNT < ARRAY_MIN) then
            return NULL
        endif
        set result = thistype.FOR_EACH_LIST_ALL[ARRAY_MIN]
        set thistype.FOR_EACH_LIST_ALL[ARRAY_MIN] = thistype.FOR_EACH_LIST_ALL[thistype.FOR_EACH_LIST_ALL_COUNT]
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.FOR_EACH_LIST_ALL_COUNT - 1
        return result
    endmethod
    static method FOR_EACH_LIST_Set takes nothing returns nothing
        local integer iteration = thistype.ACTIVE_LIST_ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.FOR_EACH_LIST_ALL[iteration] = thistype.ACTIVE_LIST_ALL[iteration]
            set iteration = iteration - 1
        endloop
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
		boolean active
		Timer cooldownTimer
        real damageFactor
        integer level
        real stolenMana
		eventMethod Event_Crit
			local Unit sword = params.Unit.GetTrigger()
			local Unit target = params.Unit.GetTarget()
			local thistype this = sword
			local real duration
			if target.Classes.Contains(UnitClass.HERO) then
				set duration = thistype.PURGE_HERO_DURATION[level]
			else
				set duration = thistype.PURGE_DURATION[level]
			endif
			call Purge.Start(this.level, target, duration)
		endmethod
        eventMethod Event_Damage
            local Unit sword = params.Unit.GetDamager()
            local Unit target = params.Unit.GetTrigger()
            local thistype this = sword
            local real stolenMana = Math.Min(target.Mana.Get(), this.stolenMana)
            if (stolenMana > 0.) then
                call target.Effects.Create(thistype.VICTIM_EFFECT_PATH, thistype.VICTIM_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
                call target.Mana.Subtract(stolenMana)
                call sword.DamageUnitBySpell(target, stolenMana * this.damageFactor, true, false)
            endif
        endmethod
		timerMethod Cooldown
			local thistype this = Timer.GetExpired().GetData()
			set this.active = true
			if thistype.ACTIVE_LIST_Add(this) then
				call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
			endif
		endmethod
	    condMethod Conditions
	        local Unit target = UNIT.Event.Native.GetFilter()
	
	        if target.Classes.Contains(UnitClass.DEAD) then
	            return false
	        endif
	        if target.IsAllyOf(User.TEMP) then
	            return false
	        endif
	
	        return true
	    endmethod
		timerMethod Update
            call thistype.FOR_EACH_LIST_Set()
            loop
                local thistype this = thistype.FOR_EACH_LIST_FetchFirst()
                exitwhen (this == NULL)
				local Unit sword = this
        		set User.TEMP = sword.Owner.Get()
        		call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(sword.Position.X.Get(), sword.Position.Y.Get(), sword.CollisionSize.Get(true), thistype.TARGET_FILTER)
		        local Unit target = thistype.ENUM_GROUP.FetchFirst()
				if (target != NULL) then
					if thistype.ACTIVE_LIST_Remove(this) then
						call thistype.UPDATE_TIMER.Pause()
					endif
					set this.active = false
					call this.cooldownTimer.Start(1., false, function thistype.Cooldown)
					call sword.Animation.Set(Animation.ATTACK)
					loop
                		call sword.Damage.Events.VsUnit(target, true, sword.Damage.Get())
						set target = thistype.ENUM_GROUP.FetchFirst()
						exitwhen (target == NULL)
                	endloop
                endif
            endloop
		endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
			local Timer cooldownTimer = this.cooldownTimer
            
            call target.Effects.Create(thistype.DEATH_EFFECT_PATH, thistype.DEATH_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
			call cooldownTimer.Destroy()
			call target.Event.Remove(CRIT_EVENT)
            call target.Event.Remove(DAMAGE_EVENT)
			if this.active then
				if thistype.ACTIVE_LIST_Remove(this) then
					call thistype.UPDATE_TIMER.Pause()
				endif
			endif
        endmethod
        eventMethod Event_BuffGain
            local integer level = params.Buff.GetLevel()
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
			local Timer cooldownTimer = Timer.Create()
			set this.active = true
			set this.cooldownTimer = cooldownTimer
            set this.damageFactor = thistype.DAMAGE_FACTOR[level]
            set this.level = level
            set this.stolenMana = thistype.STOLEN_MANA[level]
            call cooldownTimer.SetData(this)
            
            call target.Effects.Create(thistype.SUMMON_EFFECT_PATH, thistype.SUMMON_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
            call target.Event.Add(CRIT_EVENT)
            call target.Event.Add(DAMAGE_EVENT)
			if thistype.ACTIVE_LIST_Add(this) then
				
			endif
        endmethod
        static method Create takes User casterOwner, real x, real y, real angle, integer level returns Unit
            local Unit sword = Unit.CreateSummon(thistype.SUMMON_UNIT_TYPE[level], casterOwner, x, y, angle, GhostSword.DURATION[level])
            call sword.Buffs.Add(thistype.DUMMY_BUFF, level)
            
            
            call sword.Ghost.Add()
            call sword.Movement.Subtract()
            call sword.Pathing.Subtract()
            call sword.Abilities.AddWithLevel(HackNSlay.THIS_SPELL, level)
            call sword.Abilities.Add(Invulnerability.THIS_SPELL)
            return sword
        endmethod
        static method Init takes nothing returns nothing
        	set thistype.CRIT_EVENT = Event.Create(UNIT.CriticalChance.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Crit)
            set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
            set thistype.UPDATE_TIMER = Timer.Create()
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        	set thistype.ENUM_GROUP = Group.Create()
        	set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        endmethod
    endstruct
endscope
    globals
        GhostSword GHOST_SWORD = STRUCT_BASE
    endglobals
    struct GhostSword
        implement Allocation
        implement List
        
    static key GetKeyMacro_SWORDS_KEY_ARRAY
    static constant integer SWORDS_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_SWORDS_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static Event TRANSPORT_START_EVENT
    static Event TRANSPORT_ENDING_EVENT
    static constant real UPDATE_TIME = (1 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (1 * 1.))
    static Timer UPDATE_TIMER
    static thistype array ACTIVE_LIST_ALL
    static integer ACTIVE_LIST_ALL_COUNT = ARRAY_EMPTY
    integer ACTIVE_LIST_index
    static method ACTIVE_LIST_Count takes nothing returns integer
        return thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static method ACTIVE_LIST_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Get takes integer index returns thistype
        return thistype.ACTIVE_LIST_ALL[index]
    endmethod
    static method ACTIVE_LIST_GetIndex takes thistype this returns integer
        return this.ACTIVE_LIST_index
    endmethod
    static method ACTIVE_LIST_Contains takes thistype this returns boolean
        return (thistype.ACTIVE_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ACTIVE_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ACTIVE_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ACTIVE_LIST_RandomAll takes nothing returns thistype
        return thistype.ACTIVE_LIST_Random(ARRAY_MIN, thistype.ACTIVE_LIST_ALL_COUNT)
    endmethod
    static method ACTIVE_LIST_Remove takes thistype this returns boolean
        if not thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT].ACTIVE_LIST_index = this.ACTIVE_LIST_index
        set thistype.ACTIVE_LIST_ALL[this.ACTIVE_LIST_index - 1] = thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT]
        set this.ACTIVE_LIST_index = ARRAY_MIN
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT - 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Add takes thistype this returns boolean
        if thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT + 1
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT] = this
        set this.ACTIVE_LIST_index = thistype.ACTIVE_LIST_ALL_COUNT + 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static thistype array FOR_EACH_LIST_ALL
    static integer FOR_EACH_LIST_ALL_COUNT = ARRAY_EMPTY
    static method FOR_EACH_LIST_FetchFirst takes nothing returns thistype
        local thistype result
        if (thistype.FOR_EACH_LIST_ALL_COUNT < ARRAY_MIN) then
            return NULL
        endif
        set result = thistype.FOR_EACH_LIST_ALL[ARRAY_MIN]
        set thistype.FOR_EACH_LIST_ALL[ARRAY_MIN] = thistype.FOR_EACH_LIST_ALL[thistype.FOR_EACH_LIST_ALL_COUNT]
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.FOR_EACH_LIST_ALL_COUNT - 1
        return result
    endmethod
    static method FOR_EACH_LIST_Set takes nothing returns nothing
        local integer iteration = thistype.ACTIVE_LIST_ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.FOR_EACH_LIST_ALL[iteration] = thistype.ACTIVE_LIST_ALL[iteration]
            set iteration = iteration - 1
        endloop
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    real angle
    real angleAdd
    FolderGhostSword_StructSword Sword = this
    FolderGhostSword_StructSword LinkToStruct_Sword
    timerMethod Update
        call thistype.FOR_EACH_LIST_Set()
        loop
            local thistype this = thistype.FOR_EACH_LIST_FetchFirst()
            exitwhen (this == NULL)
            local real angle = this.angle
            local real angleAdd = this.angleAdd
            local Unit target = this
            
            
            local real colSize = target.CollisionSize.Get(true)
            set this.angle = angle + thistype.ANGLE_SPEED * thistype.UPDATE_TIME
            local integer iteration = target.Data.Integer.Table.Count(SWORDS_KEY_ARRAY)
            loop
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                local Unit sword = target.Data.Integer.Table.Get(SWORDS_KEY_ARRAY, iteration)
				if (target.Order.GetNative() == NULL) then
                	
                endif
                
                call sword.Position.SetXY(target.Position.X.Get() + (colSize * (1 + thistype.SUMMON_OFFSET_FACTOR)) * Math.Cos(angle), target.Position.Y.Get() + (colSize * (1 + thistype.SUMMON_OFFSET_FACTOR)) * Math.Sin(angle))
                
                
                set angle = angle + angleAdd
                set iteration = iteration - 1
            endloop
        endloop
    endmethod
	eventMethod Event_TransportEnding
		local Unit target = params.Unit.GetTrigger()
		local thistype this = target
        if thistype.ACTIVE_LIST_Add(this) then
            call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
        endif
        local integer iteration = target.Data.Integer.Table.Count(SWORDS_KEY_ARRAY)
        loop
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            local Unit sword = target.Data.Integer.Table.Get(SWORDS_KEY_ARRAY, iteration)
            call sword.Transport.Subtract()
            set iteration = iteration - 1
        endloop
	endmethod
	eventMethod Event_TransportStart
		local Unit target = params.Unit.GetTrigger()
		local thistype this = target
        if thistype.ACTIVE_LIST_Remove(this) then
            call thistype.UPDATE_TIMER.Pause()
        endif
        local integer iteration = target.Data.Integer.Table.Count(SWORDS_KEY_ARRAY)
        loop
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            local Unit sword = target.Data.Integer.Table.Get(SWORDS_KEY_ARRAY, iteration)
            call sword.Transport.Add()
            set iteration = iteration - 1
        endloop
	endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local integer iteration = target.Data.Integer.Table.Count(SWORDS_KEY_ARRAY)
        loop
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            local Unit sword = target.Data.Integer.Table.Get(SWORDS_KEY_ARRAY, iteration)
            call sword.Kill()
            call sword.Refs.Subtract()
            set iteration = iteration - 1
        endloop
        call target.Data.Integer.Table.Clear(SWORDS_KEY_ARRAY)
		call target.Event.Remove(TRANSPORT_ENDING_EVENT)
		call target.Event.Remove(TRANSPORT_START_EVENT)
        if thistype.ACTIVE_LIST_Remove(this) then
            call thistype.UPDATE_TIMER.Pause()
        endif
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local SpellInstance whichInstance = params.Buff.GetData()
        local Unit caster = whichInstance.GetCaster()
        local real colSize = target.CollisionSize.Get(true)
        local integer iteration = thistype.SUMMONS_AMOUNT[level]
        local real targetX = target.Position.X.Get()
        local real targetY = target.Position.Y.Get()
        local real angle = caster.Facing.Get()
        local real angleAdd = Math.FULL_ANGLE / iteration
        local User casterOwner = caster.Owner.Get()
		local thistype this = target
        set this.angle = angle
        set this.angleAdd = angleAdd
        call target.Event.Add(TRANSPORT_ENDING_EVENT)
        call target.Event.Add(TRANSPORT_START_EVENT)
        loop
            exitwhen (iteration < 1)
            local Unit sword = thistype(NULL).Sword.Create(casterOwner, targetX + (colSize * (1 + thistype.SUMMON_OFFSET_FACTOR)) * Math.Cos(angle), targetY + (colSize * (1 + thistype.SUMMON_OFFSET_FACTOR)) * Math.Sin(angle), angle, level)
            call target.Data.Integer.Table.Add(SWORDS_KEY_ARRAY, sword)
            call sword.Refs.Add()
            call sword.Scale.Set(colSize / 36.)
			call SetUnitLookAt(sword.self, "bone_chest", target.self, 0., 0., 0.)
            set angle = angle + angleAdd
            set iteration = iteration - 1
        endloop
        if thistype.ACTIVE_LIST_Add(this) then
            call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
        endif
    endmethod
    eventMethod Event_SpellEffect
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        local SpellInstance whichInstance = params.SpellInstance.GetTrigger()
		call target.Buffs.Remove(thistype.DUMMY_BUFF)
        call target.Buffs.Timed.StartEx(thistype.DUMMY_BUFF, level, whichInstance, thistype.DURATION[level])
    endmethod
    initMethod Init of Spells_Purchasable
        set thistype.TRANSPORT_ENDING_EVENT = Event.Create(UNIT.Transport.ENDING_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_TransportEnding)
        set thistype.TRANSPORT_START_EVENT = Event.Create(UNIT.Transport.START_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_TransportStart)
        set thistype.UPDATE_TIMER = Timer.Create()
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Sword.Init()
    endmethod
endstruct
    scope FolderHackNSlay
    public struct StructTarget
        implement Allocation
        implement List
        
    	static Event ENDING_EVENT
        static Event START_EVENT
		eventMethod Event_Ending
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local HackNSlay parent = aura.GetData()
			call target.Buffs.Subtract(thistype.DUMMY_BUFF)
		endmethod
		eventMethod Event_Start
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local Unit caster = aura.GetCaster()
			local HackNSlay parent = aura.GetData()
			local integer level = parent.level
			call target.Buffs.Add(thistype.DUMMY_BUFF, level)
		endmethod
        static method Init takes nothing returns nothing
            set thistype.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Ending)
            set thistype.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Start)
        endmethod
    endstruct
endscope
    globals
        HackNSlay HACK_N_SLAY = STRUCT_BASE
    endglobals
    struct HackNSlay
        implement Allocation
        implement List
        
    static BoolExpr TARGET_FILTER
    Aura aura
    Unit caster
    integer level
    FolderHackNSlay_StructTarget Target = this
    FolderHackNSlay_StructTarget LinkToStruct_Target
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if (target.IsAllyOf(User.TEMP) == false) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_BuffLose
        local Unit caster = params.Unit.GetTrigger()
        local thistype this = caster
		local Aura aura = this.aura
        call aura.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Buff.GetLevel()
        local thistype this = caster
		local Aura aura = Aura.Create(caster)
        set this.aura = aura
        set this.caster = caster
        set this.level = level
        call aura.SetData(this)
		call aura.SetAreaRange(thistype.THIS_SPELL.GetAreaRange(level))
        call aura.SetTargetFilter(thistype.TARGET_FILTER)
		call aura.Event.Add(thistype(NULL).Target.ENDING_EVENT)
		call aura.Event.Add(thistype(NULL).Target.START_EVENT)
		call aura.Enable()
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.AddFresh(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Elemental
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
		call thistype(NULL).Target.Init()
    endmethod
endstruct
    globals
        IceBlock ICE_BLOCK = STRUCT_BASE
    endglobals
    struct IceBlock
        implement Allocation
        implement List
        
    eventMethod Event_SpellEffect
        local integer level = params.Spell.GetLevel()
        call params.Unit.GetTrigger().Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION[level])
    endmethod
    initMethod Init of Spells_Purchasable
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        IceShock ICE_SHOCK = STRUCT_BASE
    endglobals
    struct IceShock
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
 
 		call Spot.CreateEffect(targetX, targetY, thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW).Destroy()
 
        local User casterOwner = caster.Owner.Get()
        set User.TEMP = casterOwner
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(targetX, targetY, thistype.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
		call thistype.ENUM_GROUP.RemoveUnit(target)
		local real duration
    	if target.Classes.Contains(UnitClass.HERO) then
    		set duration = thistype.FROST_HERO_DURATION[level]
    	else
            set duration = thistype.FROST_DURATION[level]
    	endif
		call target.Buffs.Timed.Start(thistype.FROST_BUFF, level, duration)
		call caster.DamageUnitBySpell(target, thistype.PRIMARY_DAMAGE[level], true, false)
        set target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real damage = thistype.SECONDARY_DAMAGE[level]
            loop
            	if target.Classes.Contains(UnitClass.HERO) then
            		set duration = thistype.COLDNESS_HERO_DURATION[level]
            	else
                    set duration = thistype.COLDNESS_DURATION[level]
            	endif
            	
            	call target.Buffs.Timed.Start(thistype.COLDNESS_BUFF, level, duration)
            	
                call caster.DamageUnitBySpell(target, damage, true, false)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    initMethod Init of Spells_Elemental
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        
        call UNIT.Cold.NORMAL_BUFF.Variants.Add(thistype.COLDNESS_BUFF)
        call UNIT.Frost.NORMAL_BUFF.Variants.Add(thistype.FROST_BUFF)
    endmethod
endstruct
    scope FolderInnerForce
    public struct StructCrit
        implement Allocation
        implement List
        
        eventMethod Event_Unlearn
            call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
        endmethod
        eventMethod Event_Learn
            call params.Unit.GetTrigger().Buffs.AddFresh(thistype.DUMMY_BUFF, params.Spell.GetLevel())
        endmethod
        static method Init takes nothing returns nothing
            call InnerForce.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
            call InnerForce.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
            call InnerForce.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
        endmethod
    endstruct
endscope
    globals
        InnerForce INNER_FORCE = STRUCT_BASE
    endglobals
    struct InnerForce
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr HEAL_TARGET_FILTER
    static BoolExpr TARGET_FILTER
	boolean destroyed
	integer refs
    real areaRange
    Unit caster
    real damage
    real heal
    Timer intervalTimer
    integer level
    real sourceX
    real sourceY
    SpellInstance whichInstance
    FolderInnerForce_StructCrit Crit = this
    FolderInnerForce_StructCrit LinkToStruct_Crit
	method CheckForDestroy takes nothing returns nothing
		if not this.destroyed then
			return
		endif
		if (this.refs > 0) then
			return
		endif
		call this.deallocate()
	endmethod
    timerMethod EndingByTimer
        local Timer durationTimer = Timer.GetExpired()
        local thistype this = durationTimer.GetData()
        local Timer intervalTimer = this.intervalTimer
        local SpellInstance whichInstance = this.whichInstance
        call durationTimer.Destroy()
        call intervalTimer.Destroy()
        call whichInstance.Destroy()
		set this.destroyed = true
		call this.CheckForDestroy()
    endmethod
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    condMethod HealConditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if (target.IsAllyOf(User.TEMP) == false) then
            return false
        endif
        return true
    endmethod
	method DoExplosion takes nothing returns nothing
		local Unit caster = this.caster
		local real areaRange = caster.CollisionSize.Get(true) + this.areaRange
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
		call caster.Effects.Create(thistype.CASTER_EFFECT2_PATH, thistype.CASTER_EFFECT2_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
		set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(casterX, casterY, areaRange, thistype.HEAL_TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real heal = this.heal
            loop
                call caster.HealBySpell(target, heal)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
		set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(casterX, casterY, areaRange, thistype.TARGET_FILTER)
        set target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real damage = this.damage
            loop
            	call target.Position.Timed.Accelerated.AddKnockback(thistype.KNOCKBACK_SPEED, thistype.KNOCKBACK_ACCELERATION, Math.AtanByDeltas(target.Position.Y.Get() - casterY, target.Position.X.Get() - casterX), thistype.KNOCKBACK_DURATION)
                call caster.DamageUnitBySpell(target, damage, true, false)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
	endmethod
    method Delay takes nothing returns nothing
        call this.DoExplosion()
		set this.refs = this.refs - 1
		call this.CheckForDestroy()
    endmethod
    timerMethod DelayByTimer
        local Timer delayTimer = Timer.GetExpired()
        local thistype this = delayTimer.GetData()
		call this.DoExplosion()
    endmethod
	method Interval takes nothing returns nothing
		call caster.Effects.Create(thistype.CASTER_EFFECT_PATH, thistype.CASTER_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
		local Timer delayTimer = Timer.Create()
		set this.refs = this.refs + 1
		call delayTimer.SetData(this)
		call delayTimer.Start(thistype.DELAY, false, function thistype.DelayByTimer)
	endmethod
    timerMethod IntervalByTimer
        call thistype(Timer.GetExpired().GetData()).Interval()
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local thistype this = thistype.allocate()
        local Timer durationTimer = Timer.Create()
        local Timer intervalTimer = Timer.Create()
        local SpellInstance whichInstance = SpellInstance.Create(caster, thistype.THIS_SPELL)
		set this.destroyed = false
		set this.refs = 0
        set this.areaRange = areaRange
        set this.caster = caster
        set this.damage = thistype.DAMAGE[level]
        set this.heal = thistype.HEAL[level]
        set this.intervalTimer = intervalTimer
        set this.level = level
        set this.whichInstance = whichInstance
        call durationTimer.SetData(this)
        call intervalTimer.SetData(this)
		call intervalTimer.Start(thistype.INTERVAL, true, function thistype.IntervalByTimer)
        call durationTimer.Start((thistype.WAVES_AMOUNT - 1) * thistype.INTERVAL, false, function thistype.EndingByTimer)
		call this.Interval()
    endmethod
    initMethod Init of Spells_Purchasable
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.HEAL_TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.HealConditions)
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
		call thistype(NULL).Crit.Init()
    endmethod
endstruct
    globals
        Monolith MONOLITH = STRUCT_BASE
    endglobals
    struct Monolith
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
    Unit caster
    real damage
    Missile dummyMissile
    integer level
    UnitList targetGroup
    real targetX
    real targetY
    Timer updateTimer
    static method SpawnMonolith takes Unit caster, integer level, real x, real y returns nothing
        local Unit monolith = Unit.CreateSummon(thistype.MONOLITH_TYPE, caster.Owner.Get(), x, y, UNIT.Facing.STANDARD, thistype.SUMMON_DURATION[level])
        call SacredAura.AddAbility(monolith, caster, level)
    endmethod
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        local integer level = this.level
        local Timer updateTimer = this.updateTimer
        local real x = dummyMissile.Position.X.Get()
        local real y = dummyMissile.Position.Y.Get()
        call this.deallocate()
        call dummyMissile.Destroy()
        call updateTimer.Destroy()
        call thistype(NULL).SpawnMonolith(caster, level, x, y)
    endmethod
    condMethod TargetConditions
        local Unit target = UNIT.Event.Native.GetFilter()
		if (target == Unit.TEMP) then
			return false
		endif
        if UnitList.TEMP.Contains(target) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        return true
    endmethod
    timerMethod Update
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this.caster
        local Missile dummyMissile = this.dummyMissile
        local UnitList targetGroup = this.targetGroup
		local User casterOwner = caster.Owner.Get()
        local real x = dummyMissile.Position.X.Get()
        local real y = dummyMissile.Position.Y.Get()
		set Unit.TEMP = caster
        set User.TEMP = casterOwner
        set UnitList.TEMP = targetGroup
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.DoWithZ(dummyMissile.Position.X.Get(), dummyMissile.Position.Y.Get(), dummyMissile.Position.Z.Get(), dummyMissile.CollisionSize.Get(), thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real damage = this.damage
            loop
                call targetGroup.Add(target)
                call target.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
				call target.Position.Timed.Accelerated.AddKnockback(dummyMissile.Speed.Get(), dummyMissile.Acceleration.Get(), Math.AtanByDeltas(target.Position.Y.Get() - y, target.Position.X.Get() - x), 1.)
				if not target.IsAllyOf(casterOwner) then
                	call caster.DamageUnitBySpell(target, damage, false, false)
                endif
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real maxLength = thistype.MAX_LENGTH[level]
        local real angle = caster.CastAngle(targetX - casterX, targetY - casterY)
        set targetX = casterX + maxLength * Math.Cos(angle)
        set targetY = casterY + maxLength * Math.Sin(angle)
        local thistype this = thistype.allocate()
		local Missile dummyMissile = Missile.Create()
        local Timer updateTimer = Timer.Create()
        set this.caster = caster
        set this.damage = thistype.DAMAGE[level]
        set this.dummyMissile = dummyMissile
        set this.level = level
        set this.targetGroup = UnitList.Create()
        set this.targetX = targetX
        set this.targetY = targetY
        set this.updateTimer = updateTimer
        call updateTimer.SetData(this) 
		
		
		local real maxLengthEpsilon = 1.
		local real speed = 800.
		
		local real acc = -speed * speed / (2 * (maxLength + maxLengthEpsilon))
        call dummyMissile.Acceleration.Set(acc)
        call dummyMissile.CollisionSize.Set(thistype.HIT_RANGE)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(speed)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.GoToSpot.Start(targetX, targetY, Spot.GetHeight(targetX, targetY) + UNIT_TYPE.Impact.Z.STANDARD)
        call dummyMissile.DummyUnit.LockFacing(UNIT.Facing.STANDARD)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 0.75)
        call updateTimer.Start(thistype.UPDATE_TIME, true, function thistype.Update)
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.TargetConditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    scope FolderSacredAura
    public struct StructTarget
        implement Allocation
        implement List
        
    	static Event ENDING_EVENT
        static Event START_EVENT
		eventMethod Event_Ending
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local SacredAura parent = aura.GetData()
			call target.Buffs.Subtract(thistype.DUMMY_BUFF)
		endmethod
		eventMethod Event_Start
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local Unit caster = aura.GetCaster()
			local SacredAura parent = aura.GetData()
			local integer level = parent.level
			call target.Buffs.Add(thistype.DUMMY_BUFF, level)
		endmethod
        static method Init takes nothing returns nothing
            set thistype.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Ending)
            set thistype.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Start)
        endmethod
    endstruct
endscope
    globals
        SacredAura SACRED_AURA = STRUCT_BASE
    endglobals
    struct SacredAura
        implement Allocation
        implement List
        
    static BoolExpr TARGET_FILTER
    Aura aura
    Unit caster
    integer level
    FolderSacredAura_StructTarget Target = this
    FolderSacredAura_StructTarget LinkToStruct_Target
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if not target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_BuffLose
        local Unit monolith = params.Unit.GetTrigger()
        local thistype this = monolith
        local Aura aura = this.aura
        call aura.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local Unit caster = params.Buff.GetData()
        local Unit monolith = params.Unit.GetTrigger()
        local integer level = params.Buff.GetLevel()
        local thistype this = monolith
		local Aura aura = Aura.Create(monolith)
		set this.aura = aura
        set this.caster = caster
        set this.level = level
        call aura.SetData(this)
		call aura.SetAreaRange(Monolith.THIS_SPELL.GetAreaRange(level))
        call aura.SetTargetFilter(thistype.TARGET_FILTER)
		call aura.Event.Add(thistype(NULL).Target.ENDING_EVENT)
		call aura.Event.Add(thistype(NULL).Target.START_EVENT)
		call aura.Enable()
    endmethod
    static method AddAbility takes Unit monolith, Unit caster, integer level returns nothing
        call monolith.Animation.Set(UNIT.Animation.WORK)
        call monolith.Buffs.AddEx(thistype.DUMMY_BUFF, level, caster)
    endmethod
    initMethod Init of Spells_Hero
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
		call thistype(NULL).Target.Init()
    endmethod
endstruct
    scope FolderSeverance
    public struct StructBuff
        implement Allocation
        implement List
        
        static method Start takes integer level, Unit target returns nothing
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION[level])
        endmethod
        static method Init takes nothing returns nothing
        	call UNIT.Madness.NORMAL_BUFF.Variants.Add(thistype.DUMMY_BUFF)
        endmethod
    endstruct
endscope
    globals
        Severance SEVERANCE = STRUCT_BASE
    endglobals
    struct Severance
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    real areaRange
    Unit caster
    real damage
    integer level
    integer maxTargetsAmount
    Unit target
    UnitList targetGroup
    integer targetsAmount
    FolderSeverance_StructBuff Buff = this
    FolderSeverance_StructBuff LinkToStruct_Buff
    method Ending takes nothing returns nothing
        call this.deallocate()
        call this.targetGroup.Destroy()
    endmethod
    static method Conditions takes Unit target returns boolean
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    condMethod Conditions_Group
        local Unit target = UNIT.Event.Native.GetFilter()
        if UnitList.TEMP.Contains(target) then
            return false
        endif
        if not thistype.Conditions(target) then
            return false
        endif
        return true
    endmethod
    method StartMissile takes real sourceX, real sourceY, real sourceZ, Unit target returns nothing
        local Missile dummyMissile = Missile.Create()
        set this.target = target
        call this.targetGroup.Add(target)
        call dummyMissile.CollisionSize.Set(10.)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 2.)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(900.)
        call dummyMissile.Position.Set(sourceX, sourceY, sourceZ)
        call dummyMissile.GoToUnit.Start(target, null)
    endmethod
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        local integer maxTargetsAmount = this.maxTargetsAmount
        local integer targetsAmount = this.targetsAmount
        local Unit target = this.target
        local UnitList targetGroup = this.targetGroup
        local real targetX = dummyMissile.Position.X.Get()
        local real targetY = dummyMissile.Position.Y.Get()
        local real targetZ = dummyMissile.Position.Z.Get()
        call dummyMissile.Destroy()
        if (target != NULL) then
            set User.TEMP = caster.Owner.Get()
            if thistype.Conditions(target) then
                local real damage = this.damage
                call caster.DamageUnitBySpell(target, damage, true, false)
                set this.damage = damage * (1. - thistype.DAMAGE_DEC_FACTOR)
                call thistype(NULL).Buff.Start(level, target)
            endif
        endif
        if (targetsAmount == maxTargetsAmount) then
            call this.Ending()
        else
            set UnitList.TEMP = targetGroup
            set User.TEMP = caster.Owner.Get()
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(targetX, targetY, this.areaRange, thistype.TARGET_FILTER)
			if (target != NULL) then
				call thistype.ENUM_GROUP.RemoveUnit(target)
				call targetGroup.Remove(target)
			endif
            set target = thistype.ENUM_GROUP.GetNearest(targetX, targetY)
            if (target == NULL) then
                call this.Ending()
            else
                set this.targetsAmount = targetsAmount + 1
                call this.StartMissile(targetX, targetY, targetZ, target)
            endif
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local thistype this = thistype.allocate()
        set this.areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        set this.caster = caster
        set this.damage = thistype.DAMAGE[level]
        set this.level = level
        set this.maxTargetsAmount = thistype.TARGETS_AMOUNT[level]
        set this.targetGroup = UnitList.Create()
        set this.targetsAmount = 1
        call this.StartMissile(casterX, casterY, caster.Position.Z.GetByCoords(casterX, casterY) + caster.Outpact.Z.Get(true), target)
    endmethod
    initMethod Init of Spells_Purchasable
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions_Group)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Buff.Init()
    endmethod
endstruct
    scope FolderSnowySphere
    public struct StructParticle
        implement Allocation
        implement List
        
        static real array DURATION
        static Group ENUM_GROUP
        static real array LENGTH
        static BoolExpr TARGET_FILTER
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
        real areaRange
        Unit caster
        real damage
        DummyUnit dummyUnit
        Timer durationTimer
        UnitList targetGroup
        Timer updateTimer
        SpellInstance whichInstance
        real xAdd
        real yAdd
        timerMethod Ending
            local Timer durationTimer = Timer.GetExpired()
            local thistype this = durationTimer.GetData()
            local DummyUnit dummyUnit = this.dummyUnit
            local UnitList targetGroup = this.targetGroup
            local Timer updateTimer = this.updateTimer
            local SpellInstance whichInstance = this.whichInstance
            call this.deallocate()
            call dummyUnit.DestroyInstantly()
            call durationTimer.Destroy()
            call targetGroup.Destroy()
            call updateTimer.Destroy()
            call whichInstance.Refs.Subtract()
        endmethod
        condMethod Conditions
            local Unit target = UNIT.Event.Native.GetFilter()
            if UnitList.TEMP.Contains(target) then
                return false
            endif
            if target.Classes.Contains(UnitClass.DEAD) then
                return false
            endif
            if not target.Classes.Contains(UnitClass.GROUND) then
                return false
            endif
            if target.Classes.Contains(UnitClass.MECHANICAL) then
                return false
            endif
            if target.IsAllyOf(User.TEMP) then
                return false
            endif
            if target.MagicImmunity.Try() then
                return false
            endif
            return true
        endmethod
        timerMethod Move            
            local thistype this = Timer.GetExpired().GetData()
            local Unit caster = this.caster
            local DummyUnit dummyUnit = this.dummyUnit
            local UnitList targetGroup = this.targetGroup
            local real x = dummyUnit.Position.X.Get() + this.xAdd
            local real y = dummyUnit.Position.Y.Get() + this.yAdd
            call dummyUnit.Position.Set(x, y, dummyUnit.Position.Z.Get())
            set UnitList.TEMP = targetGroup
            set User.TEMP = caster.Owner.Get()
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, areaRange, thistype.TARGET_FILTER)
            local Unit target = thistype.ENUM_GROUP.FetchFirst()
            if (target != NULL) then
                local real damage = this.damage
                loop
                    call targetGroup.Add(target)
                    call caster.DamageUnitBySpell(target, damage, true, false)
                    set target = thistype.ENUM_GROUP.FetchFirst()
                    exitwhen (target == NULL)
                endloop
            endif
        endmethod
        static method Start takes real angle, Unit caster, real damage, integer level, SpellInstance whichInstance, real x, real y, real z returns nothing
			local thistype this = thistype.allocate()
            local Timer durationTimer = Timer.Create()
            local DummyUnit dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, x, y, z, angle)
            local Timer updateTimer = Timer.Create()
            set this.areaRange = thistype.AREA_RANGE[level]
            set this.caster = caster
            set this.damage = damage
            set this.dummyUnit = dummyUnit
            set this.targetGroup = UnitList.Create()
            set this.updateTimer = updateTimer
            set this.xAdd = thistype.LENGTH[level] * Math.Cos(angle)
            set this.yAdd = thistype.LENGTH[level] * Math.Sin(angle)
            set this.whichInstance = whichInstance
            call durationTimer.SetData(this)
            call updateTimer.SetData(this)
            call whichInstance.Refs.Add()
            call updateTimer.Start(thistype.UPDATE_TIME, true, function thistype.Move)
            call durationTimer.Start(thistype.DURATION[level], false, function thistype.Ending)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.ENUM_GROUP = Group.Create()
            set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
            local integer iteration = SnowySphere.THIS_SPELL.GetLevelsAmount()
            loop
                set thistype.DURATION[iteration] = thistype.MAX_LENGTH[iteration] / thistype.SPEED[iteration]
                set thistype.LENGTH[iteration] = thistype.SPEED[iteration] * thistype.UPDATE_TIME
                set iteration = iteration - 1
                exitwhen (iteration < 1)
            endloop
        endmethod
    endstruct
endscope
    globals
        SnowySphere SNOWY_SPHERE = STRUCT_BASE
    endglobals
    struct SnowySphere
        implement Allocation
        implement List
        
    static real array DURATION
    static real array LENGTH
    static real array SPAWN_ANGLE_ADD
    static real array SPAWN_INTERVAL
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
    Unit caster
    real damage
    DummyUnit dummyUnit
    Timer intervalTimer
    integer level
    real spawnAngle
    real spawnAngleAdd
    real spawnXOffset
    real spawnYOffset
    Timer updateTimer
    SpellInstance whichInstance
    real x
    real y
    real xAdd
    real yAdd
    FolderSnowySphere_StructParticle Particle = this
    FolderSnowySphere_StructParticle LinkToStruct_Particle
    timerMethod Ending
        local Timer durationTimer = Timer.GetExpired()
        local thistype this = durationTimer.GetData()
        local DummyUnit dummyUnit = this.dummyUnit
        local Timer intervalTimer = this.intervalTimer
        local Timer updateTimer = this.updateTimer
        local SpellInstance whichInstance = this.whichInstance
        call this.deallocate()
        call dummyUnit.Destroy()
        call durationTimer.Destroy()
        call intervalTimer.Destroy()
        call updateTimer.Destroy()
        call whichInstance.Destroy()
    endmethod
    timerMethod SpawnParticle
        local thistype this = Timer.GetExpired().GetData()
        local real angle = this.spawnAngle + this.spawnAngleAdd
        local DummyUnit dummyUnit = this.dummyUnit
        set this.spawnAngle = angle
        call thistype(NULL).Particle.Start(angle, this.caster, this.damage, this.level, this.whichInstance, dummyUnit.Position.X.Get() + this.spawnXOffset, dummyUnit.Position.Y.Get() + this.spawnYOffset, dummyUnit.Position.Z.Get())
    endmethod
    timerMethod Move
        local thistype this = Timer.GetExpired().GetData()
        local DummyUnit dummyUnit = this.dummyUnit
        call dummyUnit.Position.Set(dummyUnit.Position.X.Get() + this.xAdd, dummyUnit.Position.Y.Get() + this.yAdd, dummyUnit.Position.Z.Get())
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real casterZ = caster.Position.Z.Get() + caster.Outpact.Z.Get(true)
        local real angle = caster.CastAngle(targetX - casterX, targetY - casterY)
        local real xPart = Math.Cos(angle)
        local real yPart = Math.Sin(angle)
        local thistype this = thistype.allocate()
		local DummyUnit dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, casterX, casterY, casterZ, angle)
        local Timer durationTimer = Timer.Create()
        local Timer intervalTimer = Timer.Create()
        local Timer updateTimer = Timer.Create()
        local SpellInstance whichInstance = SpellInstance.Create(caster, thistype.THIS_SPELL)
        set this.caster = caster
        set this.damage = Particle.DAMAGE[level]
        set this.dummyUnit = dummyUnit
        set this.intervalTimer = intervalTimer
        set this.level = level
        set this.spawnAngle = angle
        set this.spawnAngleAdd = thistype.SPAWN_ANGLE_ADD[level]
        set this.spawnXOffset = thistype.SPAWN_OFFSET * xPart
        set this.spawnYOffset = thistype.SPAWN_OFFSET * yPart
        set this.updateTimer = updateTimer
        set this.whichInstance = whichInstance
        set this.xAdd = thistype.LENGTH[level] * xPart
        set this.yAdd = thistype.LENGTH[level] * yPart
        call durationTimer.SetData(this)
        call intervalTimer.SetData(this)
        call updateTimer.SetData(this)
        call intervalTimer.Start(thistype.SPAWN_INTERVAL[level], true, function thistype.SpawnParticle)
        call updateTimer.Start(thistype.UPDATE_TIME, true, function thistype.Move)
        call durationTimer.Start(thistype.DURATION[level], false, function thistype.Ending)
    endmethod
    initMethod Init of Spells_Purchasable
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        local integer iteration = thistype.THIS_SPELL.GetLevelsAmount()
        loop
            set thistype.DURATION[iteration] = thistype.MAX_LENGTH[iteration] / thistype.SPEED[iteration]
            set thistype.LENGTH[iteration] = thistype.SPEED[iteration] * thistype.UPDATE_TIME
            set thistype.SPAWN_INTERVAL[iteration] = thistype.DURATION[iteration] / thistype.SPAWN_AMOUNT[iteration]
            set thistype.SPAWN_ANGLE_ADD[iteration] = thistype.SPAWN_ANGLE_MAX_ADD[iteration] * thistype.SPAWN_INTERVAL[iteration] / thistype.DURATION[iteration]
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        call thistype(NULL).Particle.Init()
    endmethod
endstruct
    globals
        Thunderstrike THUNDER_STRIKE = STRUCT_BASE
    endglobals
    struct Thunderstrike
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    DummyUnit chargeDummyUnit
    DummyUnit lightDummyUnit
    real areaRange
    Unit caster
    real damage
    Timer delayTimer
    real targetX
    real targetY
    real targetZ
    SpellInstance whichInstance
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    timerMethod Nova
        local Timer delayTimer = Timer.GetExpired()
        local thistype this = delayTimer.GetData()
        local real targetX = this.targetX
        local real targetY = this.targetY
        local SpellInstance whichInstance = this.whichInstance
        local integer level = whichInstance.GetLevel()
        local DummyUnit novaDummy = DummyUnit.Create(thistype.NOVA_DUMMY_UNIT_ID, targetX, targetY, Spot.GetHeight(targetX, targetY), 0.)
        call this.deallocate()
        call delayTimer.Destroy()
        call lightDummyUnit.DestroyInstantly()
        call whichInstance.Destroy()
        call novaDummy.Scale.Set(thistype.THIS_SPELL.GetAreaRange(level) / (100.))
        call novaDummy.DestroyTimed.Start(2.)
    endmethod
    timerMethod Delay
        local Timer delayTimer = Timer.GetExpired()
        local thistype this = delayTimer.GetData()
        local real areaRange = this.areaRange
        local Unit caster = this.caster
        local DummyUnit chargeDummyUnit = this.chargeDummyUnit
        local real damage = this.damage
        local real targetX = this.targetX
        local real targetY = this.targetY
        local SpellInstance whichInstance = this.whichInstance
        local integer level = whichInstance.GetLevel()
        call chargeDummyUnit.DestroyInstantly()
        call Spot.CreateEffect(targetX, targetY, thistype.BOLT_EFFECT_PATH, EffectLevel.LOW).DestroyTimed.Start(0.5)
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(targetX, targetY, areaRange, thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real stunHeroDuration = thistype.STUN_HERO_DURATION[level]
            local real stunNormDuration = thistype.STUN_DURATION[level]
            loop
            	local real stunDuration
				if target.Classes.Contains(UnitClass.HERO) then
					set stunDuration = stunHeroDuration
				else
					set stunDuration = stunNormDuration
				endif
                call target.Buffs.Timed.Start(UNIT.Stun.NORMAL_BUFF, level, stunDuration)
                call caster.DamageUnitBySpell(target, damage, true, true)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
        call delayTimer.Start(0.15, false, function thistype.Nova)
    endmethod
    static method Start takes Unit caster, integer level, real targetX, real targetY, SpellInstance whichInstance returns nothing
        local real areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        local real targetZ = Spot.GetHeight(targetX, targetY)
        local thistype this = thistype.allocate()
        local DummyUnit chargeDummyUnit = DummyUnit.Create(thistype.CHARGE_DUMMY_UNIT_ID, targetX, targetY, targetZ, UNIT.Facing.STANDARD)
		local Timer delayTimer = Timer.Create()
        local DummyUnit lightDummyUnit = DummyUnit.Create(thistype.LIGHT_DUMMY_UNIT_ID, targetX, targetY, targetZ, UNIT.Facing.STANDARD)
        set this.areaRange = areaRange
        set this.caster = caster
        set this.chargeDummyUnit = chargeDummyUnit
        set this.damage = thistype.DAMAGE[level]
        set this.delayTimer = delayTimer
        set this.lightDummyUnit = lightDummyUnit
        set this.targetX = targetX
        set this.targetY = targetY
        set this.targetZ = targetZ
        set this.whichInstance = whichInstance
        call delayTimer.SetData(this)
        call lightDummyUnit.SetScale(areaRange / (256. / 5))
        call lightDummyUnit.VertexColor.Set(255, 255, 255, 127)
        call chargeDummyUnit.Position.Z.SetFlyHeightNative(thistype.CHARGE_DUMMY_HEIGHT, thistype.DELAY - thistype.CHARGE_DUMMY_WAIT_AFTER_TIME)
        call chargeDummyUnit.Scale.Timed.Add(areaRange / 128. - 1., thistype.DELAY)
        call delayTimer.Start(thistype.DELAY, false, function thistype.Delay)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        call thistype.Start(caster, params.Spell.GetLevel(), params.Spot.GetTargetX(), params.Spot.GetTargetY(), SpellInstance.Create(caster, thistype.THIS_SPELL))
    endmethod
    initMethod Init of Spells_Purchasable
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        TwinWolves TWIN_WOLVES = STRUCT_BASE
    endglobals
    struct TwinWolves
        implement Allocation
        implement List
        
	static method CreateWolf takes integer level, Unit caster, real x, real y, real angle returns Unit
		local User casterOwner = caster.Owner.Get()
		local Unit wolf = Unit.CreateSummon(thistype.SUMMON_UNIT_TYPE[level], casterOwner, x, y, angle, thistype.SUMMON_DURATION[level])
		call wolf.Abilities.AddWithLevel(Carnivore.THIS_SPELL, level)
		call wolf.VertexColor.Subtract(0., 0., 0., 255.)
		call wolf.VertexColor.Timed.Add(0., 0., 0., 255., thistype.SUMMON_FADE_IN)
		return wolf
	endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        
        local real sourceAngle = caster.Facing.Get()
        
        local real sourceOffset = caster.CollisionSize.Get(true) + thistype.SUMMON_OFFSET
        
        local real sourceX = caster.Position.X.Get() + sourceOffset * Math.Cos(sourceAngle)
        local real sourceY = caster.Position.Y.Get() + sourceOffset * Math.Sin(sourceAngle)
        
        local integer summonAmount = thistype.SUMMON_AMOUNT[level]
		local real summonWindowStart = sourceAngle - thistype.SUMMON_WINDOW / 2
		local real summonWindowAdd = thistype.SUMMON_WINDOW / (summonAmount - 1)
		local Unit array wolves
        loop
            exitwhen (summonAmount < 1)
			local real angle = summonWindowStart + (summonAmount - 1) * summonWindowAdd
			local real x = sourceX + thistype.SUMMON_OFFSET2 * Math.Cos(angle)
			local real y = sourceY + thistype.SUMMON_OFFSET2 * Math.Sin(angle)
            set wolves[summonAmount] = thistype.CreateWolf(level, caster, x, y, angle)
			call wolves[summonAmount].Order.PointTarget(Order.ATTACK, x + thistype.SUMMON_MOVE_OFFSET * Math.Cos(angle), y + thistype.SUMMON_MOVE_OFFSET * Math.Sin(angle))
            set summonAmount = summonAmount - 1
        endloop
        call Brotherhood.Add(wolves[1], level, wolves[2])
        call Brotherhood.Add(wolves[2], level, wolves[1])
		call WolfsMark.AddToUnit(caster, level)
    endmethod
    initMethod Init of Spells_Hero
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        Brotherhood BROTHERHOOD = STRUCT_BASE
    endglobals
    struct Brotherhood
        implement Allocation
        implement List
        
	static Event DAMAGE_EVENT
	
	static Unit BROTHER
	
	Unit brother
	
	eventMethod Event_Damage
		local Unit damager = params.Unit.GetDamager()
		local real dmg = params.Real.GetDamage()
		local Unit target = params.Unit.GetTrigger()
		
		local thistype this = target
		
		local Unit brother = this.brother
		
		if (brother.IsDestroyed() or brother.Classes.Contains(UnitClass.DEAD)) then
			return
		endif
		
		local real dmgSplit = dmg * thistype.DMG_SPLIT / 2
		
		if (dmgSplit <= 0.) then
			return
		endif
		
		call damager.DamageUnit(brother, dmgSplit, false)
		
		call params.Real.SetDamage(dmg - dmgSplit)
	endmethod
	
    eventMethod Event_BuffLose
    	local Unit target = params.Unit.GetTrigger()
    	
    	local thistype this = target
    	
    	local Unit brother = this.brother
    	
        call target.Event.Remove(DAMAGE_EVENT)
        
        call brother.Refs.Subtract()
    endmethod
    eventMethod Event_BuffGain
    	local Unit brother = thistype.BROTHER
    	local Unit target = params.Unit.GetTrigger()
    	
    	local thistype this = target
    	
    	set this.brother = brother
    	
        call target.Event.Add(DAMAGE_EVENT)
        
        call brother.Refs.Add()
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.AddFresh(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
	static method Add takes Unit firstTarget, integer level, Unit secondTarget returns nothing
		set thistype.BROTHER = secondTarget
		
		call firstTarget.Abilities.AddWithLevel(thistype.THIS_SPELL, level)
	endmethod
    initMethod Init of Spells_Hero
    	set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
    endmethod
endstruct
    globals
        Carnivore CARNIVORE = STRUCT_BASE
    endglobals
    struct Carnivore
        implement Allocation
        implement List
        
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.AddFresh(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Hero
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
    endmethod
endstruct
    globals
        WolfsMark WOLFS_MARK = STRUCT_BASE
    endglobals
    struct WolfsMark
        implement Allocation
        implement List
        
    static method AddToUnit takes Unit target, integer level returns nothing
        call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION[level])
    endmethod
    initMethod Init of Spells_Hero
    endmethod
endstruct
    scope FolderVividMeteor
    public struct StructEffects
        implement Allocation
        implement List
        
        static real ANGLE_ADD
        static real ANGLE_ADD_ADD
        static real ANGLE_PER_DUMMY_ADD
    static key GetKeyMacro_DUMMY_UNITS_KEY_ARRAY
    static constant integer DUMMY_UNITS_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_DUMMY_UNITS_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
        static real OFFSET_ADD
    static key GetKeyMacro_PARENT_KEY_ARRAY
    static constant integer PARENT_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_PARENT_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static constant real UPDATE_TIME = (1 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (1 * 1.))
        static Timer UPDATE_TIMER
        real angle
        real angleAdd
        real offset
        real x
        real y
        method Ending takes nothing returns nothing
            if this.RemoveFromList() then
                call thistype.UPDATE_TIMER.Pause()
            endif
			local integer iteration = Memory.IntegerKeys.Table.CountIntegers(PARENT_KEY_ARRAY + this, DUMMY_UNITS_KEY_ARRAY)
            loop
                local DummyUnit dummyUnit = Memory.IntegerKeys.Table.GetInteger(PARENT_KEY_ARRAY + this, DUMMY_UNITS_KEY_ARRAY, iteration)
                call Memory.IntegerKeys.Table.RemoveInteger(PARENT_KEY_ARRAY + this, DUMMY_UNITS_KEY_ARRAY, dummyUnit)
                if (iteration != Memory.IntegerKeys.Table.STARTED) then
                    call dummyUnit.DestroyInstantly()
                endif
                set iteration = iteration - 1
                exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            endloop
        endmethod
        timerMethod Update
            local integer iteration = thistype.ALL_COUNT
            loop
                local thistype this = thistype.ALL[iteration]
                local real angleAdd = this.angleAdd + thistype.ANGLE_ADD_ADD
                local integer iteration2 = Memory.IntegerKeys.Table.CountIntegers(PARENT_KEY_ARRAY + this, DUMMY_UNITS_KEY_ARRAY)
                local real offset = this.offset + thistype.OFFSET_ADD
                local real x = this.x
                local real y = this.y
                set this.angleAdd = angleAdd
                set this.offset = offset
				local real angle = this.angle + angleAdd
                set this.angle = angle
                loop
                    set angle = angle + thistype.ANGLE_PER_DUMMY_ADD
                    local DummyUnit dummyUnit = Memory.IntegerKeys.Table.GetInteger(PARENT_KEY_ARRAY + this, DUMMY_UNITS_KEY_ARRAY, iteration2)
                    call dummyUnit.Facing.Set(angle + Math.QUARTER_ANGLE)
                    call dummyUnit.Position.SetXY(x + offset * Math.Cos(angle), y + offset * Math.Sin(angle))
                    set iteration2 = iteration2 - 1
                    exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                endloop
                set iteration = iteration - 1
                exitwhen (iteration < ARRAY_MIN)
            endloop
        endmethod
        method Start takes real x, real y returns nothing
            local real angle = thistype.ANGLE_START
            set this.angle = thistype.ANGLE_START
            set this.angleAdd = thistype.ANGLE_ADD
            set this.offset = thistype.OFFSET_START
            set this.x = x
            set this.y = y
			local integer iteration = thistype.DUMMY_UNITS_AMOUNT
            loop
                exitwhen (iteration < 1)
                set angle = angle + thistype.ANGLE_PER_DUMMY_ADD
                local DummyUnit dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, x + thistype.OFFSET_START * Math.Cos(angle), y + thistype.OFFSET_START * Math.Sin(angle), Spot.GetHeight(x, y), thistype.ANGLE_START + Math.QUARTER_ANGLE)
                call Memory.IntegerKeys.Table.AddInteger(PARENT_KEY_ARRAY + this, DUMMY_UNITS_KEY_ARRAY, dummyUnit)
                call dummyUnit.SetScale(0.75)
                call dummyUnit.SetTimeScale(0.75 / VividMeteor.DELAY)
                set iteration = iteration - 1
            endloop
            if this.AddToList() then
                call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
            endif
        endmethod
        static method Init takes nothing returns nothing
            set thistype.ANGLE_ADD = thistype.ANGLE_SPEED * thistype.UPDATE_TIME
            set thistype.ANGLE_ADD_ADD = thistype.ANGLE_ACC * thistype.UPDATE_TIME * thistype.UPDATE_TIME
            set thistype.ANGLE_PER_DUMMY_ADD = Math.FULL_ANGLE / thistype.DUMMY_UNITS_AMOUNT
            set thistype.OFFSET_ADD = -thistype.OFFSET_START / VividMeteor.DELAY * thistype.UPDATE_TIME
            set thistype.UPDATE_TIMER = Timer.Create()
        endmethod
    endstruct
endscope
    globals
        VividMeteor VIVID_METEOR = STRUCT_BASE
    endglobals
    struct VividMeteor
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    real areaRange
    Unit caster
    real damage
    real heal
    integer level
    real targetX
    real targetY
    FolderVividMeteor_StructEffects Effects = this
    FolderVividMeteor_StructEffects LinkToStruct_Effects
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        if target.Classes.Contains(UnitClass.NEUTRAL) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    timerMethod Ending
        local Timer delayTimer = Timer.GetExpired()
        local thistype this = delayTimer.GetData()
        local Unit caster = this.caster
        local real heal = this.heal
        local integer level = this.level
        local real targetX = this.targetX
        local real targetY = this.targetY
        local User casterOwner = caster.Owner.Get()
        call this.deallocate()
        call delayTimer.Destroy()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(targetX, targetY, this.areaRange, thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real damage = this.damage
            local real poisonNormDuration = thistype.POISON_DURATION[level]
            local real poisonHeroDuration = thistype.POISON_HERO_DURATION[level]
            loop
                if target.IsAllyOf(casterOwner) then
                    call caster.HealBySpell(target, heal)
                else
					local real poisonDuration
					if target.Classes.Contains(UnitClass.HERO) then
						set poisonDuration = poisonHeroDuration
					else
						set poisonDuration = poisonNormDuration
					endif
                    call target.Buffs.Timed.Start(thistype.POISON_BUFF, level, poisonDuration)
                    call caster.DamageUnitBySpell(target, damage, true, false)
                endif
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
        call this.Effects.Ending()
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local thistype this = thistype.allocate()
		local Timer delayTimer = Timer.Create()
        set this.areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        set this.caster = caster
        set this.damage = thistype.DAMAGE[level]
        set this.heal = thistype.HEAL[level]
        set this.level = level
        set this.targetX = targetX
        set this.targetY = targetY
        call delayTimer.SetData(this)
        call this.Effects.Start(targetX, targetY)
        call delayTimer.Start(thistype.DELAY, false, function thistype.Ending)
    endmethod
    initMethod Init of Spells_Purchasable
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call UNIT.Poisoned.NORMAL_BUFF.Variants.Add(thistype.POISON_BUFF)
        call thistype(NULL).Effects.Init()
    endmethod
endstruct
    globals
        WarmthMagnetism WARMTH_MAGNETISM = STRUCT_BASE
    endglobals
    struct WarmthMagnetism
        implement Allocation
        implement List
        
    static Event DEATH_EVENT
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static real LENGTH
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
    static Unit CASTER
    Unit caster
    real casterX
    real casterY
    real damage
    Lightning effectLightning
    Timer intervalTimer
    integer level
    Timer moveTimer
    method Ending_Caster takes Unit caster returns nothing
        if caster.Data.Integer.Table.Remove(KEY_ARRAY, this) then
            call caster.Event.Remove(DEATH_EVENT)
        endif
    endmethod
    eventMethod Event_Caster_Death
        local Unit caster = params.Unit.GetTrigger()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local integer iteration = caster.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            local thistype this = caster.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            call this.Ending_Caster(caster)
            set this.caster = NULL
            set this.casterX = casterX
            set this.casterY = casterY
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
    endmethod
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        local Unit target = this
        call this.caster.DamageUnitBySpell(target, this.damage, true, false)
    endmethod
    timerMethod Move        
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this.caster
        local integer level = this.level
        local Unit target = this
        local real targetX = target.Position.X.Get()
        local real targetY = target.Position.Y.Get()
		local real casterX
		local real casterY
        if (caster == NULL) then
            set casterX = this.casterX
            set casterY = this.casterY
        else
            set casterX = caster.Position.X.Get()
            set casterY = caster.Position.Y.Get()
        endif
        local real dX = casterX - targetX
        local real dY = casterY - targetY
        local real d = Math.DistanceByDeltas(dX, dY)
        local real length = thistype.LENGTH
        local real angle = Math.AtanByDeltas(dY, dX)
        local boolean reachesCaster = (d < length + thistype.HIT_RANGE)
        local real newX = targetX + length * Math.Cos(angle)
        local real newY = targetY + length * Math.Sin(angle)
        call target.Position.X.Set(newX)
        call target.Position.Y.Set(newY)
        if reachesCaster then
            call target.Buffs.Remove(thistype.DUMMY_BUFF)
        endif
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local Unit caster = this.caster
        local Lightning effectLightning = this.effectLightning
        local Timer intervalTimer = this.intervalTimer
        local Timer moveTimer = this.moveTimer
        if (caster != NULL) then
            call this.Ending_Caster(caster)
        endif
        call effectLightning.Destroy()
        call intervalTimer.Destroy()
        call moveTimer.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local Unit caster = thistype.CASTER
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local Lightning effectLightning = Lightning.Create(thistype.BOLT)
        local Timer intervalTimer = Timer.Create()
        local Timer moveTimer = Timer.Create()
        set this.caster = caster
        set this.damage = thistype.DAMAGE_PER_INTERVAL[level]
        set this.effectLightning = effectLightning
        set this.intervalTimer = intervalTimer
        set this.level = level
        set this.moveTimer = moveTimer
        if caster.Data.Integer.Table.Add(KEY_ARRAY, this) then
            call caster.Event.Add(DEATH_EVENT)
        endif
        call intervalTimer.SetData(this)
        call moveTimer.SetData(this)
        call effectLightning.FromUnitToUnit.Start(target, caster)
        call target.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
        call intervalTimer.Start(thistype.DAMAGE_INTERVAL, true, function thistype.Interval)
        call moveTimer.Start(thistype.UPDATE_TIME, true, function thistype.Move)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        set thistype.CASTER = caster
        call params.Unit.GetTarget().Buffs.AddFresh(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Purchasable
        set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Caster_Death)
        set thistype.LENGTH = thistype.SPEED * thistype.UPDATE_TIME
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call UNIT.Silence.NORMAL_BUFF.Variants.Add(thistype.DUMMY_BUFF)
    endmethod
endstruct
    scope FolderAmaterasu
    public struct StructTarget
        implement Allocation
        implement List
        
        static method Start takes Unit target returns nothing
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, thistype.DURATION)
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
endscope
    globals
        Amaterasu AMATERASU = STRUCT_BASE
    endglobals
    struct Amaterasu
        implement Allocation
        implement List
        
    static real array DAMAGE
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    real areaRange
    real damage
    Timer intervalTimer
    integer level
    real targetX
    real targetY
    FolderAmaterasu_StructTarget Target = this
    FolderAmaterasu_StructTarget LinkToStruct_Target
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        if target.Buffs.Contains(thistype(NULL).Target.DUMMY_BUFF) then
            return false
        endif
        return true
    endmethod
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        local Unit target = this
       
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(this.targetX, this.targetY, this.areaRange, thistype.TARGET_FILTER)
        local Unit target2 = thistype.ENUM_GROUP.FetchFirst()
        if (target2 != NULL) then
            local real damage = this.damage
            loop
                call thistype(NULL).Target.Start(target2)
                if target2.Classes.Contains(UnitClass.GROUND) then
                    call target.DamageUnitBySpell(target2, damage, false, false)
                else
                    call target.DamageUnitBySpell(target2, damage * thistype.DAMAGE_AIR_FACTOR, false, false)
                endif
                set target2 = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target2 == NULL)
            endloop
        endif
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local Timer intervalTimer = this.intervalTimer
        call intervalTimer.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local real targetX = target.Position.X.Get()
        local real targetY = target.Position.Y.Get()
        local thistype this = target
		local Timer intervalTimer = Timer.Create()
        set this.areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        set this.damage = thistype.DAMAGE[level]
        set this.intervalTimer = intervalTimer
        set this.targetX = targetX
        set this.targetY = targetY
        call intervalTimer.SetData(this)
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
    endmethod
    eventMethod Event_EndCast
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_SpellEffect
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        local integer iteration = thistype.THIS_SPELL.GetLevelsAmount()
        loop
            set thistype.DAMAGE[iteration] = thistype.DAMAGE_ALL[iteration] / Real.ToInt(thistype.THIS_SPELL.GetChannelTime(iteration) / thistype(NULL).Target.DURATION)
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
		call thistype(NULL).Target.Init()
    endmethod
endstruct
    scope FolderArcaneAttractor
    public struct StructTarget
        implement Allocation
        implement List
        
        method Start takes Unit caster, integer level, Unit target returns nothing
            local ArcaneAttractor parent = this
            local Lightning dummyLightning = Lightning.Create(thistype.BOLT)
            call dummyLightning.FromUnitToUnit.Start(parent.summon, target)
            call dummyLightning.DestroyTimed.Start(UNIT.Knockup.DURATION)
            set Unit.TEMP = caster
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION[level])
        endmethod
        real duration
        ArcaneAttractor parent
        eventMethod Enum
            local Unit target = params.Unit.GetTrigger()
            local thistype this = params.GetData()
            local ArcaneAttractor parent = this.parent
            local Lightning dummyLightning = Lightning.Create(thistype.BOLT)
            call dummyLightning.FromUnitToUnit.Start(parent.summon, target)
            call dummyLightning.DestroyTimed.Start(UNIT.Knockup.DURATION)
        endmethod
        method StartGroup takes Group targetGroup, integer level returns nothing
            local ArcaneAttractor parent = this
            set this = parent
            set this.duration = thistype.DURATION[level]
            set this.parent = parent
            call targetGroup.DoEx(function thistype.Enum, this)
            call targetGroup.AddBuff(thistype.DUMMY_BUFF, level, thistype.DURATION[level])
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
endscope
    globals
        ArcaneAttractor ARCANE_ATTRACTOR = STRUCT_BASE
    endglobals
    struct ArcaneAttractor
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static Event SUMMON_DESTROY_EVENT
    static BoolExpr TARGET_FILTER
    Timer durationTimer
    Timer intervalTimer
    Unit summon
    SpellInstance whichInstance
    FolderArcaneAttractor_StructTarget Target = this
    FolderArcaneAttractor_StructTarget LinkToStruct_Target
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Buffs.Contains(thistype(NULL).Target.DUMMY_BUFF) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        if (Math.Random(0., 1.) > thistype.TARGET_CHANCE) then
            return false
        endif
        return true
    endmethod
    timerMethod IntervalByTimer
        local thistype this = Timer.GetExpired().GetData()
        local SpellInstance whichInstance = this.whichInstance
        local Unit caster = whichInstance.GetCaster()
        local integer level = whichInstance.GetLevel()
        local Unit summon = this.summon
        local real x = summon.Position.X.Get()
        local real y = summon.Position.Y.Get()
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, thistype.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.GetNearest(x, y)
        if (target != NULL) then
            local real damage = thistype.DAMAGE[level]
            local real damageLifeFactor = thistype.DAMAGE_LIFE_FACTOR[level]
            call this.Target.Start(caster, level, target)
            call target.Knockup.Start()
            call target.Position.Timed.Accelerated.AddKnockback(450., 0., Math.AtanByDeltas(target.Position.Y.Get() - y, target.Position.X.Get() - x) + Math.HALF_ANGLE, UNIT.Knockup.DURATION)
            if caster.Buffs.Contains(FairyShape.DUMMY_BUFF) then
                call target.Stun.AddTimedBy(UNIT.Stun.NORMAL_BUFF, FairyShape.ARCANE_ATTRACTOR_STUN_DURATION[caster.Buffs.GetLevel(FairyShape.DUMMY_BUFF)])
            endif
            call target.Effects.Create(thistype(NULL).Target.DAMAGE_EFFECT_PATH, thistype(NULL).Target.DAMAGE_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
            call caster.DamageUnitBySpell(target, damage + damageLifeFactor * target.Life.Get(), true, false)
        endif
    endmethod
    method Ending takes nothing returns nothing
        local Timer durationTimer = this.durationTimer
        local Timer intervalTimer = this.intervalTimer
        local Unit summon = this.summon
        call durationTimer.Destroy()
        call intervalTimer.Destroy()
        call summon.Event.Remove(SUMMON_DESTROY_EVENT)
        call summon.Destroy()
        
    endmethod
    eventMethod Event_Summon_Destroy
        local Unit summon = params.Unit.GetTrigger()
        local thistype this = summon
        call this.Ending()
    endmethod
    timerMethod EndingByTimer
        local thistype this = Timer.GetExpired().GetData()
        call this.Ending()
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local SpellInstance whichInstance = params.SpellInstance.GetTrigger()
        local Unit summon = Unit.CreateSummon(thistype.SUMMON_UNIT_TYPE, caster.Owner.Get(), targetX, targetY, whichInstance.GetAngle(), thistype.DURATION[level])
        local thistype this = summon
        local Timer durationTimer = Timer.Create()
        local Timer intervalTimer = Timer.Create()
        set this.durationTimer = durationTimer
        set this.intervalTimer = intervalTimer
        set this.summon = summon
        set this.whichInstance = whichInstance
        call durationTimer.SetData(this)
        call intervalTimer.SetData(this)
        call summon.Event.Add(SUMMON_DESTROY_EVENT)
        call summon.Effects.Create(thistype.DUMMY_UNIT_SPECIAL_EFFECT_PATH, thistype.DUMMY_UNIT_SPECIAL_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
        call summon.Animation.Set(Animation.CHANNEL)
        call summon.Color.Set(caster.Color.Get())
        call summon.Position.Z.SetFlyHeight(thistype.DUMMY_UNIT_HEIGHT)
        call summon.VertexColor.Set(0, 0, 0, 0)
        call summon.VertexColor.Timed.Add(255, 255, 255, 255, 1.)
        call Spot.CreateEffect(targetX, targetY, thistype.AREA_EFFECT_PATH, EffectLevel.LOW).Destroy()
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.IntervalByTimer)
        call durationTimer.Start(thistype.DURATION[level], false, function thistype.EndingByTimer)
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.SUMMON_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Summon_Destroy)
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Target.Init()
    endmethod
endstruct
    globals
        ArcticWolf ARCTIC_WOLF = STRUCT_BASE
    endglobals
    struct ArcticWolf
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr EXPLOSION_FILTER
    static constant real INTERVAL = 0.25
    static real LENGTH
    static BoolExpr TARGET_FILTER
    static constant real UPDATE_TIME = (1 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (1 * 1.))
    real angle
    real areaRange
    Unit caster
    DummyUnit dummyUnit
    DummyUnitEffect dummyUnitEffect
    Timer durationTimer
    real explosionDamage
    Timer intervalTimer
    integer level
    real stunDuration
    integer summonAmount
    real summonDuration
    UnitList targetGroup
    UnitType thisUnitType
    real travelDamage
    Timer updateTimer
    real xAdd
    real yAdd
    condMethod ExplosionConditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    static method DoExplosion takes real x, real y, real areaRange, Unit caster, real damage returns nothing
        call SpotEffect.Create(x, y, thistype.EXPLOSION_EFFECT_PATH, EffectLevel.LOW)
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, areaRange, thistype.EXPLOSION_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            loop
                call caster.DamageUnitBySpell(target, damage, true, false)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    timerMethod Ending
        local Timer durationTimer = Timer.GetExpired()
        local thistype this = durationTimer.GetData()
        local real angle = this.angle
        local Unit caster = this.caster
        local DummyUnit dummyUnit = this.dummyUnit
        local DummyUnitEffect dummyUnitEffect = this.dummyUnitEffect
        local real explosionDamage = this.explosionDamage
        local Timer intervalTimer = this.intervalTimer
        local integer summonAmount = this.summonAmount
        local real summonDuration = this.summonDuration
        local UnitList targetGroup = this.targetGroup
        local UnitType thisUnitType = this.thisUnitType
        local Timer updateTimer = this.updateTimer
        local User casterOwner = caster.Owner.Get()
        local real x = dummyUnit.Position.X.Get()
        local real y = dummyUnit.Position.Y.Get()
        call this.deallocate()
        call dummyUnitEffect.Destroy()
        call durationTimer.Destroy()
        call intervalTimer.Destroy()
        call targetGroup.Destroy()
        call updateTimer.Destroy()
        call dummyUnit.DestroyTimed.Start(thistype.DUMMY_UNIT_FADE_OUT)
        call dummyUnit.VertexColor.Timed.Subtract(0., 0., 0., 127., thistype.DUMMY_UNIT_FADE_OUT)
        call thistype.DoExplosion(x, y, areaRange, caster, explosionDamage)
        loop
            exitwhen (summonAmount < 1)
            local Unit wolf = Unit.CreateSummon(thisUnitType, casterOwner, x, y, angle, summonDuration)
            set summonAmount = summonAmount - 1
        endloop
    endmethod
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if UnitList.TEMP.Contains(target) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        local real areaRange = this.areaRange
        local Unit caster = this.caster
        local real damage = this.travelDamage
        local DummyUnit dummyUnit = this.dummyUnit
        local UnitList targetGroup = this.targetGroup
        local real x = dummyUnit.Position.X.Get()
        local real y = dummyUnit.Position.Y.Get()
        set User.TEMP = caster.Owner.Get()
        set UnitList.TEMP = targetGroup
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, areaRange, thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local integer level = this.level
            local real stunDuration = this.stunDuration
            loop
                call target.Buffs.Timed.Start(UNIT.Stun.NORMAL_BUFF, level, stunDuration)
                call targetGroup.Add(target)
                call caster.DamageUnitBySpell(target, damage, true, false)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    timerMethod Move
        local thistype this = Timer.GetExpired().GetData()
        call this.dummyUnit.Position.AddXY(this.xAdd, this.yAdd)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real angle = caster.CastAngle(targetX - casterX, targetY - casterY)
        local real duration = Math.DistanceByDeltas(targetX - casterX, targetY - casterY) / thistype.SPEED
        local real partX = Math.Cos(angle)
        local real partY = Math.Sin(angle)
        local real startX = casterX + thistype.START_OFFSET * partX
        local real startY = casterY + thistype.START_OFFSET * partY
        local thistype this = thistype.allocate()
        local DummyUnit dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, startX, startY, Spot.GetHeight(startX, startY) + thistype.HEIGHT, angle)
        local Timer durationTimer = Timer.Create()
        local Timer intervalTimer = Timer.Create() 
        local Timer updateTimer = Timer.Create()
        set this.angle = angle
        set this.areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        set this.caster = caster
        set this.dummyUnit = dummyUnit
        set this.dummyUnitEffect = DummyUnitEffect.Create(dummyUnit, thistype.DUMMY_UNIT_EFFECT_PATH, thistype.DUMMY_UNIT_EFFECT_ATTACH_POINT, EffectLevel.NORMAL)
        set this.durationTimer = durationTimer
        set this.explosionDamage = thistype.EXPLOSION_DAMAGE[level]
        set this.intervalTimer = intervalTimer
        set this.level = level
        set this.stunDuration = thistype.STUN_DURATION[level]
        set this.summonAmount = thistype.SUMMON_AMOUNT[level]
        set this.summonDuration = thistype.SUMMON_DURATION[level]
        set this.targetGroup = UnitList.Create()
        set this.travelDamage = thistype.TRAVEL_DAMAGE[level]
        set this.thisUnitType = thistype.SUMMON_UNIT_TYPE[level]
        set this.updateTimer = updateTimer
        set this.xAdd = thistype.LENGTH * partX
        set this.yAdd = thistype.LENGTH * partY
        call durationTimer.SetData(this)
        call intervalTimer.SetData(this)
        call updateTimer.SetData(this)
        call dummyUnit.Animation.SetByIndex(2)
        call dummyUnit.Scale.Set(2.)
        call dummyUnit.VertexColor.Set(255., 255., 255., 127.)
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
        call updateTimer.Start(thistype.UPDATE_TIME, true, function thistype.Move)
        call durationTimer.Start(duration, false, function thistype.Ending)
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.EXPLOSION_FILTER = BoolExpr.GetFromFunction(function thistype.ExplosionConditions)
        set thistype.LENGTH = thistype.SPEED * thistype.UPDATE_TIME
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    scope FolderBoulderCrash
    public struct StructVisuals
        implement Allocation
        implement List
        
        DummyUnit areaDummy
        Unit caster
        Timer intervalTimer
        integer level
        eventMethod Impact
            local Missile dummyMissile = params.Missile.GetTrigger()
            call dummyMissile.Destroy()
        endmethod
        timerMethod Interval
            local thistype this = Timer.GetExpired().GetData()
            local Unit caster = this
            local integer level = this.level
            local real casterX = caster.Position.X.Get()
            local real casterY = caster.Position.Y.Get()
            local real casterZ = caster.Position.Z.Get()
            local real acceleration = S2R(SetVar.GetValDef("acc", "200."))
            local real angle = Math.RandomAngle()
            local real dist = BoulderCrash.THIS_SPELL.GetAreaRange(level) * S2R(SetVar.GetValDef("distFactor", "0.75"))
            local real height = Math.Random(330., 520.)
            local real scale = Math.Random(0.5, 1.)
            local real speed = S2R(SetVar.GetValDef("speed", "300."))
            local real duration = Math.GetMovementDuration(dist, speed, acceleration)
			local Missile dummyMissile = Missile.Create()
            call dummyMissile.Acceleration.Set(acceleration)
            call dummyMissile.Impact.SetAction(function thistype.Impact)
            call dummyMissile.Speed.Set(speed)
            call dummyMissile.Speed.SetMin(100.)
            call dummyMissile.Position.Set(casterX + dist * Math.Cos(angle), casterY + dist * Math.Sin(angle), casterZ + height)
            call dummyMissile.GoToSpot.Start(casterX, casterY, casterZ)
            call dummyMissile.DummyUnit.LockFacing(UNIT.Facing.STANDARD)
			local DummyUnit dummyUnit
            if (Math.RandomI(0, 1) == 0) then
                set dummyUnit = dummyMissile.DummyUnit.Create(thistype.TREE_ID, scale)
            else
                set dummyUnit = dummyMissile.DummyUnit.Create(thistype.STONE_ID, scale)
            endif
            call dummyMissile.CollisionSize.Set(64.)
            call dummyUnit.VertexColor.Set(255., 255., 255., S2R(SetVar.GetValDef("alpha", "200.")))
            call dummyUnit.VertexColor.Timed.Subtract(0, 0, 0, dummyUnit.VertexColor.Alpha.Get(), duration * S2R(SetVar.GetValDef("durFactor", "0.9")))
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            local DummyUnit areaDummy = this.areaDummy
            local Timer intervalTimer = this.intervalTimer
            call areaDummy.Destroy()
            call intervalTimer.Destroy()
        endmethod
        eventMethod Event_BuffGain
            local integer level = params.Buff.GetLevel()
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            local DummyUnit areaDummy = DummyUnit.Create(thistype.AREA_DUMMY_ID, target.Position.X.Get(), target.Position.Y.Get(), target.Position.Z.Get(), target.Facing.Get())
			local Timer intervalTimer = Timer.Create()
            set this.areaDummy = areaDummy
            set this.intervalTimer = intervalTimer
            set this.level = level
            call intervalTimer.SetData(this)
            call areaDummy.FollowUnit.Start(target, false, false, 0., 0., 0.)
            call intervalTimer.StartPeriodicRange(thistype.INTERVAL_MIN, thistype.INTERVAL_MAX, function thistype.Interval)
        endmethod
        method Ending takes Unit caster returns nothing
            call caster.Buffs.Remove(thistype.DUMMY_BUFF)
        endmethod
        method Start takes Unit caster, integer level returns nothing
            call caster.Buffs.Add(thistype.DUMMY_BUFF, level)
        endmethod
        static method Init takes nothing returns nothing
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
    endstruct
endscope
    globals
        BoulderCrash BOULDER_CRASH = STRUCT_BASE
    endglobals
    struct BoulderCrash
        implement Allocation
        implement List
        
	static real array DAMAGE_PER_INTERVAL
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    integer level
    Timer intervalTimer
    FolderBoulderCrash_StructVisuals Visuals = this
    FolderBoulderCrash_StructVisuals LinkToStruct_Visuals
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this
        local integer level = this.level
        local real areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real colSize = caster.CollisionSize.Get(true)
        local real minPullRange = colSize
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(casterX, casterY, areaRange, thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real damage = thistype.DAMAGE_PER_INTERVAL[level]
            loop
                local real d = Math.DistanceByDeltas(target.Position.X.Get() - casterX, target.Position.Y.Get() - casterY)
                local real rangeFactor = Math.Shapes.LinearFromCoords(colSize, thistype.RANGE_FACTOR_CLOSE, areaRange, thistype.RANGE_FACTOR_FAR, d)
                local real pullDuration = Math.GetMovementDuration(d - minPullRange, thistype.PULL_SPEED[level], 0.)
                call target.Position.Timed.AddSpeedDirection(thistype.PULL_SPEED[level], Math.AtanByDeltas(casterY - target.Position.Y.Get(), casterX - target.Position.X.Get()), pullDuration)
                call caster.DamageUnitBySpell(target, damage * rangeFactor, true, false)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local Timer intervalTimer = this.intervalTimer
        call intervalTimer.Destroy()
        call thistype(NULL).Visuals.Ending(target)
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local Timer intervalTimer = Timer.Create()
        set this.intervalTimer = intervalTimer
        set this.level = level
        call intervalTimer.SetData(this)
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
        call thistype(NULL).Visuals.Start(target, level)
    endmethod
    eventMethod Event_EndCast
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_SpellEffect
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
		local integer level = thistype.THIS_SPELL.GetLevelsAmount()
		loop
			exitwhen (level < 1)
			set thistype.DAMAGE_PER_INTERVAL[level] = thistype.DAMAGE_PER_SECOND[level] * thistype.INTERVAL
			set level = level - 1
		endloop
        call thistype(NULL).Visuals.Init()
    endmethod
endstruct
    globals
        Conflagration CONFLAGRATION = STRUCT_BASE
    endglobals
    struct Conflagration
        implement Allocation
        implement List
        
    static real array DURATION
    static Group ENUM_GROUP
    static real array LENGTH
    static BoolExpr TARGET_FILTER
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
    real angle
    Unit caster
    real damage
    DummyUnit dummyUnit
    real length
    real lengthAdd
    integer level
    real maxLength
    UnitList targetGroup
    Timer updateTimer
    real xAdd
    real yAdd
	Lightning leftBolt
	Lightning rightBolt
	Lightning botBolt
	Lightning topBolt
	Lightning leftTotalBolt
	Lightning rightTotalBolt
	Lightning botTotalBolt
	Lightning topTotalBolt
    timerMethod Ending
        local Timer durationTimer = Timer.GetExpired()
        local thistype this = durationTimer.GetData()
        local DummyUnit dummyUnit = this.dummyUnit
        local UnitList targetGroup = this.targetGroup
        local Timer updateTimer = this.updateTimer
        call dummyUnit.Destroy()
        call durationTimer.Destroy()
        call targetGroup.Destroy()
        call updateTimer.Destroy()
        call this.leftBolt.Destroy()
        call this.rightBolt.Destroy()
        call this.botBolt.Destroy()
        call this.topBolt.Destroy()
        call this.leftTotalBolt.Destroy()
        call this.rightTotalBolt.Destroy()
        call this.botTotalBolt.Destroy()
        call this.topTotalBolt.Destroy()
        call this.deallocate()
    endmethod
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if UnitList.TEMP.Contains(target) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    timerMethod Move
        local thistype this = Timer.GetExpired().GetData()
        local real angle = this.angle
        local Unit caster = this.caster
        local DummyUnit dummyUnit = this.dummyUnit
        local real lengthAdd = this.lengthAdd
        local real maxLength = this.maxLength
        local real oldLength = this.length
        local UnitList targetGroup = this.targetGroup
        local real length = oldLength + lengthAdd
        local real x = dummyUnit.Position.X.Get() + this.xAdd
        local real y = dummyUnit.Position.Y.Get() + this.yAdd
        local real widthEnd = thistype.WIDTH_START + (thistype.WIDTH_END - thistype.WIDTH_START) * (length / maxLength)
        local real widthStart = thistype.WIDTH_START + (thistype.WIDTH_END - thistype.WIDTH_START) * (oldLength / maxLength)
		local real botLeftX = x + widthStart * Math.Cos(angle + Math.QUARTER_ANGLE)
		local real botLeftY = y + widthStart * Math.Sin(angle + Math.QUARTER_ANGLE)
		local real botRightX = x + widthStart * Math.Cos(angle - Math.QUARTER_ANGLE)
		local real botRightY = y + widthStart * Math.Sin(angle - Math.QUARTER_ANGLE)
		
		local real xEnd = x + lengthAdd * Math.Cos(angle)
		local real yEnd = y + lengthAdd * Math.Sin(angle)
		
		local real topLeftX = xEnd + widthEnd * Math.Cos(angle + Math.QUARTER_ANGLE)
		local real topLeftY = yEnd + widthEnd * Math.Sin(angle + Math.QUARTER_ANGLE)
		local real topRightX = xEnd + widthEnd * Math.Cos(angle - Math.QUARTER_ANGLE)
		local real topRightY = yEnd + widthEnd * Math.Sin(angle - Math.QUARTER_ANGLE) 
		call this.leftBolt.Move(botLeftX, botLeftY, Spot.GetHeight(botLeftX, botLeftY), topLeftX, topLeftY, Spot.GetHeight(topLeftX, topLeftY))
		call this.rightBolt.Move(botRightX, botRightY, Spot.GetHeight(botRightX, botRightY), topRightX, topRightY, Spot.GetHeight(topRightX, topRightY))
		call this.botBolt.Move(botLeftX, botLeftY, Spot.GetHeight(botLeftX, botLeftY), botRightX, botRightY, Spot.GetHeight(botRightX, botRightY))
		call this.topBolt.Move(topLeftX, topLeftY, Spot.GetHeight(topLeftX, topLeftY), topRightX, topRightY, Spot.GetHeight(topRightX, topRightY))
        set this.length = length
        call dummyUnit.Position.SetXY(x, y)
        set User.TEMP = caster.Owner.Get()
        set UnitList.TEMP = targetGroup
        call thistype.ENUM_GROUP.EnumUnits.InLine.WithCollision.Do(x, y, lengthAdd, angle, widthStart, widthEnd, thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real damage = this.damage
            local integer level = this.level
            loop
                call targetGroup.Add(target)
				local real buffDuration
				if target.Classes.Contains(UnitClass.HERO) then
					set buffDuration = thistype.BUFF_HERO_DURATION[level]
				else
					set buffDuration = thistype.BUFF_DURATION[level]
				endif
				call target.Buffs.Timed.Start(thistype.ECLIPSE_BUFF, level, buffDuration)
                call target.Buffs.Timed.StartEx(thistype.IGNITION_BUFF, level, caster, buffDuration)
                call caster.DamageUnitBySpell(target, damage, true, false)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    eventMethod Impact
        call params.Missile.GetTrigger().Destroy()
    endmethod
    static method StartSideMissiles takes Unit source, real length, real speed, real angle returns nothing
        local Missile dummyMissile = Missile.Create()
        local real sourceX = source.Position.X.Get()
        local real sourceY = source.Position.Y.Get()
        set angle = angle - Math.QUARTER_ANGLE / 3
        local real targetX = sourceX + length * Math.Cos(angle)
        local real targetY = sourceY + length * Math.Sin(angle)
        call dummyMissile.CollisionSize.Set(10.)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 0.5)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.Speed.Set(speed)
        call dummyMissile.Position.SetFromUnit(source)
        call dummyMissile.GoToSpot.Start(targetX, targetY, Spot.GetHeight(targetX, targetY))
        set angle = angle + 2 * Math.QUARTER_ANGLE / 3
        set dummyMissile = Missile.Create()
        set targetX = sourceX + length * Math.Cos(angle)
        set targetY = sourceY + length * Math.Sin(angle)
        call dummyMissile.CollisionSize.Set(10.)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 0.5)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.Speed.Set(speed)
        call dummyMissile.Position.SetFromUnit(source)
        call dummyMissile.GoToSpot.Start(targetX, targetY, Spot.GetHeight(targetX, targetY))
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real scale = caster.Scale.Get()
        local real dX = targetX - casterX
        local real dY = targetY - casterY
        local real angle = caster.CastAngle(dX, dY)
		local real maxLength = thistype.MAX_LENGTH[level] * scale
		local real offset = (caster.CollisionSize.Get(false) + 0.) * scale
        local real x = casterX + offset * Math.Cos(angle)
        local real y = casterY + offset * Math.Sin(angle)
        local real d = Math.DistanceByDeltas(dX, dY)
		local thistype this = thistype.allocate()
        local Timer durationTimer = Timer.Create()
        local Sound effectSound = Sound.Create("/", true, false, false, 10, 10, SoundEax.SPELL)
        local Timer updateTimer = Timer.Create()
		local Lightning leftBolt = Lightning.Create(thistype.TOTAL_BOLT)
		local Lightning rightBolt = Lightning.Create(thistype.TOTAL_BOLT)
		local Lightning botBolt = Lightning.Create(thistype.TOTAL_BOLT)
		local Lightning topBolt = Lightning.Create(thistype.TOTAL_BOLT)
        set this.angle = angle
        set this.caster = caster
        set this.damage = thistype.DAMAGE[level]
        set this.dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, x, y, caster.Position.Z.GetByCoords(x, y) + caster.Outpact.Z.Get(true), angle)
        set this.length = 0.
        set this.lengthAdd = thistype.LENGTH[level]
        set this.level = level
        set this.maxLength = maxLength
        set this.targetGroup = UnitList.Create()
        set this.updateTimer = updateTimer
        set this.xAdd = dX / d * thistype.LENGTH[level]
        set this.yAdd = dY / d * thistype.LENGTH[level]
        call durationTimer.SetData(this)
        call updateTimer.SetData(this)
		set this.leftBolt = Lightning.Create(thistype.DUMMY_BOLT)
		set this.rightBolt = Lightning.Create(thistype.DUMMY_BOLT)
		set this.botBolt = Lightning.Create(thistype.DUMMY_BOLT)
		set this.topBolt = Lightning.Create(thistype.DUMMY_BOLT)
		set this.leftTotalBolt = leftBolt
		set this.rightTotalBolt = rightBolt
		set this.botTotalBolt = botBolt
		set this.topTotalBolt = topBolt
		local real widthStart = thistype.WIDTH_START
		local real widthEnd = thistype.WIDTH_END
		local real botLeftX = x + widthStart * Math.Cos(angle + Math.QUARTER_ANGLE)
		local real botLeftY = y + widthStart * Math.Sin(angle + Math.QUARTER_ANGLE)
		local real botRightX = x + widthStart * Math.Cos(angle - Math.QUARTER_ANGLE)
		local real botRightY = y + widthStart * Math.Sin(angle - Math.QUARTER_ANGLE)
		
		local real xEnd = x + maxLength * Math.Cos(angle)
		local real yEnd = y + maxLength * Math.Sin(angle)
		
		local real topLeftX = xEnd + widthEnd * Math.Cos(angle + Math.QUARTER_ANGLE)
		local real topLeftY = yEnd + widthEnd * Math.Sin(angle + Math.QUARTER_ANGLE)
		local real topRightX = xEnd + widthEnd * Math.Cos(angle - Math.QUARTER_ANGLE)
		local real topRightY = yEnd + widthEnd * Math.Sin(angle - Math.QUARTER_ANGLE)
		call leftBolt.Move(botLeftX, botLeftY, Spot.GetHeight(botLeftX, botLeftY), topLeftX, topLeftY, Spot.GetHeight(topLeftX, topLeftY))
		call rightBolt.Move(botRightX, botRightY, Spot.GetHeight(botRightX, botRightY), topRightX, topRightY, Spot.GetHeight(topRightX, topRightY))
		call botBolt.Move(botLeftX, botLeftY, Spot.GetHeight(botLeftX, botLeftY), botRightX, botRightY, Spot.GetHeight(botRightX, botRightY))
		call topBolt.Move(topLeftX, topLeftY, Spot.GetHeight(topLeftX, topLeftY), topRightX, topRightY, Spot.GetHeight(topRightX, topRightY))
		local real duration = Math.GetMovementDuration(maxLength - lengthAdd, thistype.SPEED[level], 0.)
		call dummyUnit.SetTimeScale(0.5 / duration)
		call dummyUnit.Scale.Set(scale)
        call effectSound.SetPositionAndPlay(x, y, Spot.GetHeight(x, y))
        call effectSound.Destroy(true)
        call updateTimer.Start(thistype.UPDATE_TIME, true, function thistype.Move)
        call durationTimer.Start(duration, false, function thistype.Ending)
        
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call UNIT.Eclipse.NORMAL_BUFF.Variants.Add(thistype.ECLIPSE_BUFF)
        call UNIT.Ignited.NORMAL_BUFF.Variants.Add(thistype.IGNITION_BUFF)
        local integer iteration = thistype.THIS_SPELL.GetLevelsAmount()
        loop
            set thistype.DURATION[iteration] = thistype.MAX_LENGTH[iteration] / thistype.SPEED[iteration]
            set thistype.LENGTH[iteration] = thistype.SPEED[iteration] * thistype.UPDATE_TIME
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
    endmethod
endstruct
    scope FolderCyclone
    public struct StructRelocate
        implement Allocation
        implement List
        
        eventMethod Event_SpellEffect
            local Unit caster = params.Unit.GetTrigger()
            local real targetX = params.Spot.GetTargetX()
            local real targetY = params.Spot.GetTargetY()
            local Unit cyclone = caster.Data.Integer.Table.GetFirst(Cyclone.KEY_ARRAY)
            call cyclone.Order.PointTarget(Order.MOVE, targetX, targetY)
        endmethod
        static method Init takes nothing returns nothing
            call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        endmethod
    endstruct
endscope
    globals
        Cyclone CYCLONE = STRUCT_BASE
    endglobals
    struct Cyclone
        implement Allocation
        implement List
        
	static Event DESTROY_EVENT
    static Group ENUM_GROUP
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static BoolExpr TARGET_FILTER
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
    Unit caster
    real damage
    Missile dummyMissile
    integer level
    UnitList targetGroup
    real targetX
    real targetY
    Timer updateTimer
    FolderCyclone_StructRelocate Relocate = this
    FolderCyclone_StructRelocate LinkToStruct_Relocate
	Unit cyclone_caster
	eventMethod Event_Destroy
		local Unit cyclone = params.Unit.GetTrigger()
		local Unit caster = thistype(cyclone).cyclone_caster
		call cyclone.Event.Remove(DESTROY_EVENT)
		if caster.Data.Integer.Table.Remove(KEY_ARRAY, cyclone) then
			
		endif
	endmethod
    static method SpawnCyclone takes Unit caster, integer level, real x, real y returns nothing
        local Unit cyclone = Unit.CreateSummon(thistype.CYCLONE_TYPE, caster.Owner.Get(), x, y, UNIT.Facing.STANDARD, thistype.SUMMON_DURATION[level])
		set thistype(cyclone).cyclone_caster = caster
		call cyclone.Event.Add(DESTROY_EVENT)
		if caster.Data.Integer.Table.Add(KEY_ARRAY, cyclone) then
			
		endif
        call WindDance.AddToUnit(caster, cyclone, level)
    endmethod
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        local integer level = this.level
        local Timer updateTimer = this.updateTimer
        local real x = dummyMissile.Position.X.Get()
        local real y = dummyMissile.Position.Y.Get()
        call this.deallocate()
        call dummyMissile.Destroy()
        call updateTimer.Destroy()
        call thistype(NULL).SpawnCyclone(caster, level, x, y)
    endmethod
    condMethod TargetConditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if UnitList.TEMP.Contains(target) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    timerMethod Update
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this.caster
        local Missile dummyMissile = this.dummyMissile
        local integer level = this.level
        local UnitList targetGroup = this.targetGroup
        local real x = dummyMissile.Position.X.Get()
        local real y = dummyMissile.Position.Y.Get()
        set UnitList.TEMP = targetGroup
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(dummyMissile.Position.X.Get(), dummyMissile.Position.Y.Get(), dummyMissile.CollisionSize.Get(), thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real damage = this.damage
            local real whirlDuration = thistype.WHIRL_DURATION[level]
            loop
                if not Group.TEMP.ContainsUnit(target) then
                    
                    call targetGroup.Add(target)
                    call caster.DamageUnitBySpell(target, damage, false, false)
					call target.Whirl.AddTimed(whirlDuration)
                endif
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real length = Math.Limit(Math.DistanceByDeltas(targetY - casterY, targetX - casterX), thistype.MIN_LENGTH, thistype.MAX_LENGTH[level])
        local real angle = caster.CastAngle(targetX - casterX, targetY - casterY)
        set targetX = casterX + length * Math.Cos(angle)
        set targetY = casterY + length * Math.Sin(angle)
		local thistype this = thistype.allocate()
		local Missile dummyMissile = Missile.Create()
        local Timer updateTimer = Timer.Create()
        set this.caster = caster
        set this.damage = thistype.DAMAGE[level]
        set this.dummyMissile = dummyMissile
        set this.level = level
        set this.targetGroup = UnitList.Create()
        set this.targetX = targetX
        set this.targetY = targetY
        set this.updateTimer = updateTimer
        call updateTimer.SetData(this)
        call dummyMissile.Acceleration.Set(0.)
        call dummyMissile.CollisionSize.Set(thistype.HIT_RANGE)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(800)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.GoToSpot.Start(targetX, targetY, Spot.GetHeight(targetX, targetY) + UNIT_TYPE.Impact.Z.STANDARD)
        call dummyMissile.DummyUnit.LockFacing(UNIT.Facing.STANDARD)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 0.75)
        call updateTimer.Start(thistype.UPDATE_TIME, true, function thistype.Update)
    endmethod
    initMethod Init of Spells_Hero
    	set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Destroy)
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.TargetConditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Relocate.Init()
    endmethod
endstruct
    scope FolderWindDance
    public struct StructTarget
        implement Allocation
        implement List
        
    	static Event ENDING_EVENT
        static Event START_EVENT
		eventMethod Event_Ending
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local TheurgicVessel parent = aura.GetData()
			call target.Buffs.Subtract(thistype.DUMMY_BUFF)
			
		endmethod
		eventMethod Event_Start
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local Unit caster = aura.GetCaster()
			local TheurgicVessel parent = aura.GetData()
			local integer level = parent.level
			call target.Buffs.Add(thistype.DUMMY_BUFF, level)
			
		endmethod
        static method Init takes nothing returns nothing
            set thistype.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Ending)
            set thistype.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Start)
        endmethod
    endstruct
endscope
    globals
        WindDance WIND_DANCE = STRUCT_BASE
    endglobals
    struct WindDance
        implement Allocation
        implement List
        
	static real array DAMAGE_PER_INTERVAL
	static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    Aura aura
    Unit caster
    real damage
    Timer intervalTimer
    integer level
    FolderWindDance_StructTarget Target = this
    FolderWindDance_StructTarget LinkToStruct_Target
    static method Conditions takes nothing returns boolean
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    static method Interval takes nothing returns nothing
        local thistype this = Timer.GetExpired().GetData()
		local real areaRange = this.aura.GetAreaRange()
        local Unit caster = this.caster
        local Unit cyclone = this
		local real x = cyclone.Position.X.Get()
		local real y = cyclone.Position.Y.Get()
        set User.TEMP = cyclone.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, areaRange, thistype.TARGET_FILTER)
		local Unit target = thistype.ENUM_GROUP.FetchFirst()
		if (target != NULL) then
			local real damage = this.damage
        	loop
        		local real dX = target.Position.X.Get() - x
        		local real dY = target.Position.Y.Get() - y
        		local real d = Math.DistanceByDeltas(dX, dY)
        		local real ang = Math.AtanByDeltas(dY, dX)
        		local real rangeFactor = Math.Limit(Math.Shapes.LinearFromCoords(0., 1., areaRange, 0., d), 0., 1.)
				set ang = ang + thistype.ANGLE_SPEED_MAX * rangeFactor * thistype.DAMAGE_INTERVAL
				set d = d * (1 - thistype.DIST_DEC_FACTOR * thistype.DAMAGE_INTERVAL)
				
				call target.Position.SetXY(x + d * Math.Cos(ang), y + d * Math.Sin(ang))
            	call caster.DamageUnitBySpell(target, damage * rangeFactor, true, false)
            	set target = thistype.ENUM_GROUP.FetchFirst()
            	exitwhen (target == NULL)
        	endloop
        endif
    endmethod
    eventMethod Event_BuffLose
        local Unit cyclone = params.Unit.GetTrigger()
        local thistype this = cyclone
		local Aura aura = this.aura
		local Timer intervalTimer = this.intervalTimer
		call aura.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local Unit caster = params.Buff.GetData()
        local Unit cyclone = params.Unit.GetTrigger()
        local integer level = params.Buff.GetLevel()
        local thistype this = cyclone
		local Aura aura = Aura.Create(cyclone)
        local Timer intervalTimer = Timer.Create()
		set this.aura = aura
        set this.caster = caster
        set this.damage = thistype.DAMAGE_PER_INTERVAL[level]
        set this.intervalTimer = intervalTimer
        set this.level = level
        call aura.SetData(this)
        call intervalTimer.SetData(this)
		call aura.SetAreaRange(Cyclone.THIS_SPELL.GetAreaRange(level))
        call aura.SetTargetFilter(thistype.TARGET_FILTER)
		call aura.Event.Add(thistype(NULL).Target.ENDING_EVENT)
		call aura.Event.Add(thistype(NULL).Target.START_EVENT)
		call aura.Enable()
		call intervalTimer.Start(thistype.DAMAGE_INTERVAL, true, function thistype.Interval)
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
	static Unit CASTER = NULL
    eventMethod Event_Learn
    	local Unit caster = thistype.CASTER
    	local Unit cyclone = params.Unit.GetTrigger()
		set thistype.CASTER = NULL
		if (caster == NULL) then
			set caster = cyclone.Owner.Get().Hero.Get()
		endif
        call cyclone.Buffs.AddEx(thistype.DUMMY_BUFF, params.Spell.GetLevel(), caster)
    endmethod
    static method AddToUnit takes Unit caster, Unit cyclone, integer level returns nothing
    	set thistype.CASTER = caster
        call cyclone.Abilities.AddWithLevel(thistype.THIS_SPELL, level)
    endmethod
    static method Init takes nothing returns nothing
    	set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
        local integer iteration = Cyclone.THIS_SPELL.GetLevelsAmount()
        loop
            exitwhen (iteration < 1)
            set thistype.DAMAGE_PER_INTERVAL[iteration] = thistype.DAMAGE_PER_SECOND[iteration] * thistype.DAMAGE_INTERVAL
            set iteration = iteration - 1
        endloop
		call thistype(NULL).Target.Init()
    endmethod
endstruct
    globals
        DeprivingShock DEPRIVING_SHOCK = STRUCT_BASE
    endglobals
    struct DeprivingShock
        implement Allocation
        implement List
        
    static Event DEATH_EVENT
    static Event DESTROY_EVENT
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    real areaRange
    real burnedMana
    real damage
    real damagePerMana
    Timer damageTimer
    Lightning effectLightning
    integer level
    Unit target
    boolean targetAlive
	static method ReviveUnit takes Unit target, User casterOwner, integer level returns nothing
		if not target.Classes.Contains(UnitClass.DEAD) then
			return
		endif
        call target.Effects.Create(thistype.SUMMON_EFFECT_PATH, thistype.SUMMON_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
        call target.Revive()
        call target.Buffs.Add(thistype.SUMMON_BUFF, level)
        call target.Owner.Set(casterOwner)
        call target.SetSummon(thistype.SUMMON_DURATION[level])
        call target.BloodExplosion.Set(thistype.SUMMON_DEATH_EFFECT_PATH)
        call target.VertexColor.Add(-128, -128, -128, 0)
	endmethod
    eventMethod Event_Death
        local Unit target = params.Unit.GetTrigger()
        call target.Event.Remove(DEATH_EVENT)
        call target.Event.Remove(DESTROY_EVENT)
		local integer iteration = target.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            local thistype this = target.Data.Integer.Table.Get(KEY_ARRAY, iteration)
			local Unit caster = this
            set this.targetAlive = false
            call target.Data.Integer.Table.Remove(KEY_ARRAY, this)
			call thistype.ReviveUnit(target, caster.Owner.Get(), this.level)
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
    endmethod
    eventMethod Event_Destroy
        local Unit target = params.Unit.GetTrigger()
        call target.Event.Remove(DEATH_EVENT)
        call target.Event.Remove(DESTROY_EVENT)
		local integer iteration = target.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            local thistype this = target.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            set this.targetAlive = false
            call target.Data.Integer.Table.Remove(KEY_ARRAY, this)
            set iteration = iteration - 1
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
        endloop
    endmethod
    timerMethod DamageInterval
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this
        local Unit target = this.target
		local real burnedMana = Math.Min(this.burnedMana, target.Mana.Get())
        call caster.BurnManaBySpell(target, burnedMana)
        call caster.DamageUnitBySpell(target, this.damage + burnedMana * damagePerMana, true, false)
        call caster.HealManaBySpell(caster, burnedMana * thistype.TRANSFERED_MANA_FACTOR)
    endmethod
    eventMethod Event_EndCast
        local Unit caster = params.Unit.GetTrigger()
        local boolean success = params.Spell.IsChannelComplete()
        local thistype this = caster
        local Timer damageTimer = this.damageTimer
        local Lightning effectLightning = this.effectLightning
        local integer level = this.level
        local Unit target = this.target
        local boolean targetAlive = this.targetAlive
        call damageTimer.Destroy()
        call effectLightning.Destroy()
        if targetAlive then
            if target.Data.Integer.Table.Remove(KEY_ARRAY, this) then
                call target.Event.Remove(DEATH_EVENT)
                call target.Event.Remove(DESTROY_EVENT)
            endif
        endif
        if success then
            call Swiftness.Start(caster, level)
        endif
        call target.Effects.Create(thistype.TARGET_EXPLOSION_EFFECT_PATH, thistype.TARGET_EXPLOSION_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
        call target.Buffs.Timed.Start(thistype.STUN_BUFF, level, thistype.STUN_OVER_DURATION[level])
        call target.Buffs.Subtract(thistype.STUN_BUFF)
        call target.Refs.Subtract()
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        local thistype this = caster
        local Timer damageTimer = Timer.Create()
        local Lightning effectLightning = Lightning.Create(thistype.BOLT)
        set this.burnedMana = thistype.BURNED_MANA_PER_SECOND[level] * thistype.DAMAGE_INTERVAL
        set this.damage = thistype.DAMAGE_PER_SECOND[level] * thistype.DAMAGE_INTERVAL
        set this.damagePerMana = thistype.DAMAGE_PER_MANA[level]
        set this.damageTimer = damageTimer
        set this.effectLightning = effectLightning
        set this.level = level
        set this.target = target
        set this.targetAlive = true
        call damageTimer.SetData(this)
        if target.Data.Integer.Table.Add(KEY_ARRAY, this) then
            call target.Event.Add(DEATH_EVENT)
            call target.Event.Add(DESTROY_EVENT)
        endif
        call effectLightning.FromUnitToUnit.Start(caster, target)
        call target.Refs.Add()
        call target.Buffs.Add(thistype.STUN_BUFF, level)
        call damageTimer.Start(thistype.DAMAGE_INTERVAL, true, function thistype.DamageInterval)
    endmethod
    initMethod Init of Spells_Hero
        set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Death)
        set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Destroy)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
        call UNIT.Stun.NORMAL_BUFF.Variants.Add(thistype.STUN_BUFF)
    endmethod
endstruct
    scope FolderDoppelganger
    public struct StructBigBoom
        implement Allocation
        implement List
        
        static Group ENUM_GROUP
        static BoolExpr TARGET_FILTER
        condMethod TargetConditions
            local Unit target = UNIT.Event.Native.GetFilter()
            if target.Classes.Contains(UnitClass.DEAD) then
                return false
            endif
            if target.IsAllyOf(User.TEMP) then
                return false
            endif
            return true
        endmethod
        eventMethod Event_SpellEffect
            local Unit caster = params.Unit.GetTrigger()
            local integer level = params.Spell.GetLevel()
            local Unit realCaster = Doppelganger.GetCasterFromIllusion(caster)
			local real casterX = caster.Position.X.Get()
			local real casterY = caster.Position.Y.Get() 
			local SpotEffectWithSize sfx = Spot.CreateEffectWithSize(casterX, casterY, thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW, caster.Scale.Get())
			call sfx.AddScale(4., 0.25)
			call sfx.DestroyTimed.Start(1.)
			set sfx = Spot.CreateEffectWithSize(casterX, casterY, thistype.SPECIAL_EFFECT2_PATH, EffectLevel.LOW, caster.Scale.Get())
			call sfx.AddScale(4., 0.25)
			call sfx.DestroyTimed.Start(1.)
			
			
			
            set User.TEMP = caster.Owner.Get()
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(caster.Position.X.Get(), caster.Position.Y.Get(), thistype.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
            if (realCaster == NULL) then
                set realCaster = caster
            endif
            local Unit target = thistype.ENUM_GROUP.FetchFirst()
            if (target != NULL) then
                local real damage = thistype.DAMAGE[level]
                local real igniteHeroDuration = thistype.IGNITE_HERO_DURATION[level]
                local real igniteNormDuration = thistype.IGNITE_DURATION[level]
                loop
                	local real igniteDuration
					if target.Classes.Contains(UnitClass.HERO) then
						set igniteDuration = igniteHeroDuration
					else
						set igniteDuration = igniteNormDuration
					endif
                    call target.Buffs.Timed.StartEx(thistype.IGNITION_BUFF, level, realCaster, igniteDuration)
                    call realCaster.DamageUnitBySpell(target, damage, false, false)
                    set target = thistype.ENUM_GROUP.FetchFirst()
                    exitwhen (target == NULL)
                endloop
            endif
            call caster.Kill()
        endmethod
        static method Init takes nothing returns nothing
            set thistype.ENUM_GROUP = Group.Create()
            set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.TargetConditions)
            call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
            call UNIT.Ignited.NORMAL_BUFF.Variants.Add(thistype.IGNITION_BUFF)
        endmethod
    endstruct
    public struct StructFireBuff
        implement Allocation
        implement List
        
        static Event DAMAGE_EVENT
        UnitAttackSplash splash
        eventMethod Event_Damage
            local Unit target = params.Unit.GetDamager()
            local Unit victim = params.Unit.GetTrigger()
            local thistype this = target
            call victim.Effects.Create("Abilities\\Weapons\\LordofFlameMissile\\LordofFlameMissile.mdl", AttachPoint.CHEST, EffectLevel.NORMAL).Destroy()
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            call target.Event.Remove(DAMAGE_EVENT)
            call target.Attack.Splash.Destroy(this.splash)
        endmethod
        eventMethod Event_BuffGain
            local integer level = params.Buff.GetLevel()
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            set this.splash = target.Attack.Splash.Create(thistype.AREA_RANGE[level], thistype.DAMAGE_FACTOR[level])
            call target.Event.Add(DAMAGE_EVENT)
        endmethod
        static method Add takes integer level, Unit target returns nothing
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION[level])
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
    endstruct
    public struct StructIceBuff
        implement Allocation
        implement List
        
        static Event DAMAGE_EVENT
        real buffDuration
        integer level
        eventMethod Event_Damage
            local Unit target = params.Unit.GetDamager()
            local Unit victim = params.Unit.GetTrigger()
            local thistype this = target
            call victim.Buffs.Timed.Start(thistype.COLDNESS_BUFF, this.level, this.buffDuration)
            call victim.Effects.Create("Abilities\\Weapons\\LichMissile\\LichMissile.mdl", AttachPoint.CHEST, EffectLevel.NORMAL).Destroy()
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            call target.Event.Remove(DAMAGE_EVENT)
        endmethod
        eventMethod Event_BuffGain
            local integer level = params.Buff.GetLevel()
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            set this.buffDuration = thistype.DURATION[level]
            set this.level = level
            call target.Event.Add(DAMAGE_EVENT)
        endmethod
        static method Add takes integer level, Unit target returns nothing
            call target.Buffs.Add(thistype.DUMMY_BUFF, level)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            call UNIT.Cold.NORMAL_BUFF.Variants.Add(thistype.COLDNESS_BUFF)
        endmethod
    endstruct
endscope
    globals
        Doppelganger DOPPELGANGER = STRUCT_BASE
    endglobals
    struct Doppelganger
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static Event ILLUSION_DESTROY_EVENT
    real angle
    Timer delayTimer
    real duration
    Unit illusion
    real illusionDamageFactor
    integer level
    real startX
    real startY
    real targetX
    real targetY
    FolderDoppelganger_StructBigBoom BigBoom = this
    FolderDoppelganger_StructBigBoom LinkToStruct_BigBoom
    FolderDoppelganger_StructFireBuff FireBuff = this
    FolderDoppelganger_StructFireBuff LinkToStruct_FireBuff
    FolderDoppelganger_StructIceBuff IceBuff = this
    FolderDoppelganger_StructIceBuff LinkToStruct_IceBuff
    static method GetCasterFromIllusion takes Unit illusion returns Unit
        return illusion.Data.Integer.Get(KEY)
    endmethod
    eventMethod Event_IllusionDestroy
        local Unit illusion = params.Unit.GetTrigger()
        local thistype this = illusion.Data.Integer.Get(KEY)
        local Unit caster = this
        local Timer delayTimer = this.delayTimer
        set this.illusion = NULL
        call delayTimer.Destroy()
        call illusion.Data.Integer.Remove(KEY)
        call illusion.Event.Remove(ILLUSION_DESTROY_EVENT)
        call caster.Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod CasterImpact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local real x = dummyMissile.Position.X.Get()
        local real y = dummyMissile.Position.Y.Get()
        local Unit caster = this
        call dummyMissile.DummyUnit.Get().DestroyInstantly()
        call dummyMissile.Destroy()
        call caster.Transport.Subtract()
        call caster.Position.SetXYZ(x, y, Spot.GetHeight(x, y))
        call thistype(NULL).FireBuff.Add(level, caster)
    endmethod
    eventMethod IllusionImpact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local real x = dummyMissile.Position.X.Get()
        local real y = dummyMissile.Position.Y.Get()
        local Unit caster = this
        local integer level = this.level
        call dummyMissile.DummyUnit.Get().DestroyInstantly()
        call dummyMissile.Destroy()
        local Unit illusion = Unit.CreateIllusion(caster.Type.Get(), caster.Owner.Get(), x, y, caster.Facing.Get(), this.duration, thistype.ILLUSION_DEATH_EFFECT_PATH)
        set this.illusion = illusion
        call illusion.Data.Integer.Set(KEY, this)
        call illusion.Event.Add(ILLUSION_DESTROY_EVENT)
        call illusion.Abilities.Clear()
        call HeroSpell.ClearAtUnit(illusion)
        call illusion.Abilities.AddWithLevel(thistype(NULL).BigBoom.THIS_SPELL, level)
        call illusion.Buffs.Add(thistype.ILLUSION_BUFF, level)
        call illusion.Damage.Relative.Invisible.Set(this.illusionDamageFactor)
        call illusion.Level.SetNoArt(caster.Level.Get())
        call thistype(NULL).IceBuff.Add(level, illusion)
    endmethod
    timerMethod Delay
        local thistype this = Timer.GetExpired().GetData()
        local real angle = this.angle
        local Unit caster = this
        local real startX = this.startX
        local real startY = this.startY
        local real targetX = this.targetX
        local real targetY = this.targetY
        local real dX = targetX - startX
        local real dY = targetY - startY
        local real d = Math.Max(thistype.MIN_RANGE, Math.DistanceByDeltas(dX, dY) - thistype.MIN_RANGE)
        set angle = angle - Math.QUARTER_ANGLE
        set targetX = startX + d * Math.Cos(angle)
        set targetY = startY + d * Math.Sin(angle)
		local Missile dummyMissile = Missile.Create()
        call dummyMissile.Acceleration.Set(500.)
        call dummyMissile.CollisionSize.Set(thistype.THIS_SPELL.GetAreaRange(level))
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1.)
        call dummyMissile.Impact.SetAction(function thistype.CasterImpact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(800.)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.GoToSpot.Start(targetX, targetY, Spot.GetHeight(targetX, targetY) + UNIT_TYPE.Impact.Z.STANDARD)
        set angle = angle + Math.HALF_ANGLE
        set dummyMissile = Missile.Create()
        set targetX = startX + d * Math.Cos(angle)
        set targetY = startY + d * Math.Sin(angle)
        call dummyMissile.Acceleration.Set(500.)
        call dummyMissile.CollisionSize.Set(thistype.THIS_SPELL.GetAreaRange(level))
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1.)
        call dummyMissile.Impact.SetAction(function thistype.IllusionImpact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(800.)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.GoToSpot.Start(targetX, targetY, Spot.GetHeight(targetX, targetY) + UNIT_TYPE.Impact.Z.STANDARD)
    endmethod
    eventMethod Event_BuffLose
        local Unit caster = params.Unit.GetTrigger()
        local thistype this = caster
        local Unit illusion = this.illusion
        if (illusion != NULL) then
            call illusion.Kill()
        endif
    endmethod
    eventMethod Event_BuffGain
        local EventResponse castParams = params.Buff.GetData()
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Buff.GetLevel()
        local real targetX = castParams.Spot.GetTargetX()
        local real targetY = castParams.Spot.GetTargetY()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local thistype this = caster
		local Timer delayTimer = Timer.Create()
        set this.angle = caster.CastAngle(targetX - casterX, targetY - casterY)
        set this.delayTimer = delayTimer
        set this.duration = thistype.DURATION[level]
        set this.illusion = NULL
        set this.illusionDamageFactor = thistype.ILLUSION_DAMAGE_FACTOR[level]
        set this.level = level
        set this.startX = casterX
        set this.startY = casterY
        set this.targetX = targetX
        set this.targetY = targetY
        call delayTimer.SetData(this)
        call caster.Transport.Add()
        call delayTimer.Start(0.5, false, function thistype.Delay)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        call Spot.CreateEffectWithSize(caster.Position.X.Get(), caster.Position.Y.Get(), thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW, caster.Scale.Get()).Destroy()
        call caster.Buffs.AddFreshEx(thistype.DUMMY_BUFF, params.Spell.GetLevel(), params)
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ILLUSION_DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_IllusionDestroy)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).BigBoom.Init()
        call thistype(NULL).FireBuff.Init()
        call thistype(NULL).IceBuff.Init()
    endmethod
endstruct
    globals
        EbonyShot EBONY_SHOT = STRUCT_BASE
    endglobals
    struct EbonyShot
        implement Allocation
        implement List
        
    static Event MISSILE_DESTROY_EVENT
    static BoolExpr TARGET_FILTER
    integer count
    real damage
    UnitList targetGroup
    SpellInstance whichInstance
    eventMethod Event_Missile_Destroy
        local Missile dummyMissile = params.Missile.GetTrigger()
		call dummyMissile.Event.Remove(MISSILE_DESTROY_EVENT)
        local thistype this = dummyMissile.GetData()
        local integer count = this.count - 1
        if (count == 0) then
            call this.targetGroup.Destroy()
            call this.deallocate()
        else
            set this.count = count
        endif
    endmethod
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        call dummyMissile.Destroy()
    endmethod
    condMethod TargetConditions
        local EventResponse params = EventResponse.GetTrigger()
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local SpellInstance whichInstance = this.whichInstance
        if target.IsAllyOf(whichInstance.GetCaster().Owner.Get()) then
            return false
        endif
        if this.targetGroup.Contains(target) then
            call whichInstance.GetCaster().DamageUnitBySpell(target, SetVar.GetValDefR("dmgGraze" ,thistype.DAMAGE_GRAZE[whichInstance.GetLevel()]) * MISSILE.UpdateTime.VALUE, true, false)
            return false
        endif
        return true
    endmethod
    eventMethod Collision
        local Missile dummyMissile = params.Missile.GetTrigger()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local real damage = this.damage
        local SpellInstance whichInstance = this.whichInstance
        local Unit caster = whichInstance.GetCaster()
        call this.targetGroup.Add(target)
        call target.Effects.Create(thistype.DAMAGE_EFFECT_PATH, thistype.DAMAGE_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
        call caster.DamageUnitBySpell(target, damage, false, true)
    endmethod
    method StartMissile takes SpellInstance whichInstance, real angle, real range returns nothing
        local Unit caster = whichInstance.GetCaster()
        local integer level = whichInstance.GetLevel()
        local real targetX = whichInstance.GetTargetX()
        local real targetY = whichInstance.GetTargetY()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local Missile dummyMissile = Missile.Create()
        call dummyMissile.Event.Add(MISSILE_DESTROY_EVENT)
        call dummyMissile.CollisionSize.Set(thistype.THIS_SPELL.GetAreaRange(level))
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1.5).AddEffect(thistype.MISSILE_EFFECT_PATH, thistype.MISSILE_EFFECT_ATTACH_POINT, EffectLevel.NORMAL)
        call dummyMissile.SetData(this)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.Speed.Set(thistype.SPEED)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.GoToSpot.Start(casterX + range * Math.Cos(angle), casterY + range * Math.Sin(angle), Spot.GetHeight(targetX, targetY) + caster.Outpact.Z.Get(true))
        call dummyMissile.Position.AddCollision(function thistype.Collision, thistype.TARGET_FILTER)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local SpellInstance whichInstance = params.SpellInstance.GetTrigger()
		call caster.Effects.Create(thistype.LAUNCH_EFFECT_PATH, thistype.LAUNCH_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local integer level = whichInstance.GetLevel()
        local real d = Math.DistanceByDeltas(targetX - casterX, targetY - casterY)
        local integer missilesAmount = SetVar.GetValDefI("missiles", thistype.MISSILES_AMOUNT[level])
        local real range = SetVar.GetValDefR("range", thistype.THIS_SPELL.GetRange(level))
        local real window = Math.Shapes.LinearFromCoords(0., SetVar.GetValDefR("windowClose", thistype.WINDOW_CLOSE[level]), range, SetVar.GetValDefR("windowFar", thistype.WINDOW_FAR[level]), d)
        local real angle = whichInstance.GetAngle() - window / 2
        local real angleAdd = window / (missilesAmount - 1)
        local thistype this = thistype.allocate()
        set this.count = missilesAmount
        set this.damage = thistype.DAMAGE[level] + caster.Damage.Get() * thistype.DAMAGE_DAMAGE_MOD_FACTOR[level]
        set this.targetGroup = UnitList.Create()
        set this.whichInstance = whichInstance
        local integer iteration = missilesAmount
        loop
            exitwhen (iteration < 1)
            call this.StartMissile(whichInstance, angle, range)
            set angle = angle + angleAdd
            set iteration = iteration - 1
        endloop
    endmethod
    initMethod Init of Spells_Hero
        set thistype.MISSILE_DESTROY_EVENT = Event.Create(Missile.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Missile_Destroy)
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.TargetConditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    scope FolderEmphaticBite
    public struct StructBuff
        implement Allocation
        implement List
        
        static method Start takes integer level, Unit target returns nothing
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION[level])
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
endscope
    globals
        EmphaticBite EMPHATIC_BITE = STRUCT_BASE
    endglobals
    struct EmphaticBite
        implement Allocation
        implement List
        
    static real LENGTH
    static constant real UPDATE_TIME = (1 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (1 * 1.))
    integer level
    Timer moveTimer
    real sourceX
    real sourceY
    Unit target
    real targetX
    real targetY
    SpellInstance whichInstance
    FolderEmphaticBite_StructBuff Buff = this
    FolderEmphaticBite_StructBuff LinkToStruct_Buff
    timerMethod Move
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this
        local integer level = this.level
        local Unit target = this.target
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real targetX
        local real targetY
        if (target == NULL) then
            set targetX = this.targetX
            set targetY = this.targetY
        else
            set targetX = target.Position.X.Get()
            set targetY = target.Position.Y.Get()
        endif
        local real dX = targetX - casterX
        local real dY = targetY - casterY
        local real d = Math.DistanceByDeltas(dX, dY)
        local real length = thistype.LENGTH
        local real angle = Math.AtanByDeltas(dY, dX)
        local boolean reachesTarget = (d < length + thistype.HIT_RANGE)
        local real newX = casterX + length * Math.Cos(angle)
        local real newY = casterY + length * Math.Sin(angle)
        call caster.Position.X.Set(newX)
        call caster.Position.Y.Set(newY)
        if reachesTarget then
            call caster.Buffs.Remove(thistype.CASTER_BUFF)
            if (target != NULL) then
                call target.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
                if target.IsAllyOf(caster.Owner.Get()) then
                    call thistype(NULL).Buff.Start(level, target)
                    call caster.HealBySpell(target, thistype.HEAL_ALLY[level])
                else
                    call caster.DamageUnitBySpell(target, thistype.DAMAGE[level], false, true)
                    call target.Buffs.Timed.Start(thistype.TARGET_BUFF, level, thistype.DEBUFF_DURATION[level])
					call target.Position.Timed.Accelerated.AddKnockback(thistype.SPEED * thistype.KNOCKBACK_SPEED_FACTOR, 0., angle, UNIT.Knockup.DURATION)
					call target.Knockup.Start()
                endif
                call caster.HealBySpell(caster, thistype.HEAL[level])
            endif
        endif
    endmethod
    eventMethod Event_BuffLose
        local Unit caster = params.Unit.GetTrigger()
        local thistype this = caster
        local Timer moveTimer = this.moveTimer
        local Unit target = this.target
        local SpellInstance whichInstance = this.whichInstance
        call moveTimer.Destroy()
        call whichInstance.Destroy()
        
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local Unit caster = params.Unit.GetTrigger()
        local Unit target = params.Buff.GetData()
        local real sourceX = caster.Position.X.Get()
        local real sourceY = caster.Position.Y.Get()
        local real targetX = target.Position.X.Get()
        local real targetY = target.Position.Y.Get()
        local real dist = Math.DistanceByDeltas(targetX - sourceX, targetY - sourceY)
        local real expDuration = Math.GetMovementDuration(dist, thistype.SPEED, 0.)
        local real height = thistype.DIST_HEIGHT_FACTOR * dist
		local thistype this = caster
		local Timer moveTimer = Timer.Create()
		local SpellInstance whichInstance = SpellInstance.Create(caster, thistype.THIS_SPELL)
        set this.level = level
        set this.moveTimer = moveTimer
        set this.sourceX = sourceX
        set this.sourceY = sourceY
        set this.target = target
        set this.whichInstance = whichInstance
        call moveTimer.SetData(this)
        call caster.Animation.Set(Animation.ATTACK)
        call caster.Animation.Queue(Animation.STAND)
        if (expDuration > 0) then
            local real speedZ = 4 * height / expDuration
            local real accZ = -8 * height / expDuration / expDuration
            call caster.Position.Timed.Accelerated.AddForMundane(0., 0., speedZ, 0., 0., accZ, expDuration)
        endif
        call moveTimer.Start(thistype.UPDATE_TIME, true, function thistype.Move)
    endmethod
    eventMethod Event_SpellEffect
        call params.Unit.GetTrigger().Buffs.AddFreshEx(thistype.CASTER_BUFF, params.Spell.GetLevel(), params.Unit.GetTarget())
    endmethod
    initMethod Init of Spells_Hero
        set thistype.LENGTH = thistype.SPEED * thistype.UPDATE_TIME
        call thistype.CASTER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.CASTER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call UNIT.Silence.NORMAL_BUFF.Variants.Add(thistype.TARGET_BUFF)
        call UNIT.Bleeding.NORMAL_BUFF.Variants.Add(thistype.TARGET_BUFF)
        call thistype(NULL).Buff.Init()
    endmethod
endstruct
    globals
        EnchantedArrow ENCHANTED_ARROW = STRUCT_BASE
    endglobals
    struct EnchantedArrow
        implement Allocation
        implement List
        
	static UnitList DIFFERENCE_GROUP
    static Group ENUM_GROUP
    static Event MISSILE_DESTROY_EVENT
    static BoolExpr TARGET_FILTER
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
    Unit caster
    real damage
    Missile dummyMissile
    integer level
    real stunDuration
    UnitList targetGroup
    real targetX
    real targetY
    Timer updateTimer
    condMethod TargetConditions
        local Unit target = UNIT.Event.Native.GetFilter()
       
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
	method DoExplosion takes Unit caster, integer level, real x, real y returns nothing
		local real areaRange = thistype.THIS_SPELL.GetAreaRange(level)
		
		call Spot.CreateEffectWithSize(x, y, thistype.EXPLOSION_EFFECT_PATH, EffectLevel.LOW, areaRange / thistype.EXPLOSION_EFFECT_SCALE_FACTOR).Destroy()
		
        set User.TEMP = caster.Owner.Get()
        
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, 2 * areaRange, thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real damage = this.damage
            local real stunDuration = this.stunDuration
            
            loop
            	call target.Stun.AddTimedBy(UNIT.Stun.NORMAL_BUFF, stunDuration)
            	
            	call caster.DamageUnitBySpell(target, damage, true, false)
            	
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
	endmethod
	method ClearTargetGroup takes nothing returns nothing
		local UnitList targetGroup = this.targetGroup
		
		loop
			local Unit target = targetGroup.FetchFirst()
			exitwhen (target == NULL)
			
			call target.Movement.Add()
		endloop
	endmethod
    eventMethod Event_Destroy
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
		local Unit caster = this.caster
		local integer level = this.level
        local Timer updateTimer = this.updateTimer
        local real x = dummyMissile.Position.X.Get()
        local real y = dummyMissile.Position.Y.Get()
        call updateTimer.Destroy()
		call dummyMissile.Event.Remove(MISSILE_DESTROY_EVENT)
        
        call this.deallocate()
    endmethod
	eventMethod Impact
		local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
		local Unit caster = this.caster
		local integer level = this.level
        local real x = dummyMissile.Position.X.Get()
        local real y = dummyMissile.Position.Y.Get()
		call dummyMissile.Destroy()
		call this.DoExplosion(caster, level, x, y)
	endmethod
    timerMethod Update
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this.caster
        local Missile dummyMissile = this.dummyMissile
        local UnitList targetGroup = this.targetGroup
        local real targetX = this.targetX
        local real targetY = this.targetY
        set UnitList.TEMP = targetGroup
        set User.TEMP = caster.Owner.Get()
		local real missileX = dummyMissile.Position.X.Get()
		local real missileY = dummyMissile.Position.Y.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(missileX, missileY, thistype.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
		call targetGroup.GetDifferenceGroupEx(thistype.ENUM_GROUP, thistype.DIFFERENCE_GROUP)
		loop
			local Unit target = thistype.DIFFERENCE_GROUP.FetchFirst()
			exitwhen (target == NULL)
			
			call targetGroup.Remove(target)
			
			call target.Movement.Add()
		endloop
        set target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then            
            local real angle = dummyMissile.Angle.GetXY()
            local real speed = dummyMissile.Speed.Get()
            local real updateTime = dummyMissile.UpdateTime.Get()
			local real lengthX = speed * thistype.UPDATE_TIME * Math.Cos(angle)
			local real lengthY = speed * thistype.UPDATE_TIME * Math.Sin(angle)
            loop
                if not targetGroup.Contains(target) then
                    call targetGroup.Add(target)
                    
                    call target.Movement.Subtract()
                endif
                
               	local real newX = target.Position.X.Get() + lengthX
                local real newY = target.Position.Y.Get() + lengthY
                
                if not Spot.IsBlocked(newX, newY) then
                	call target.Position.SetXY(newX, newY)
                endif
                
                
                
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
        
        if Spot.IsBlocked(missileX, missileY) then
            call dummyMissile.Impact.DoCur()
        endif
    endmethod
	thistype caster_this
	eventMethod Event_EndCast
		local Unit caster = params.Unit.GetTrigger()
		local integer level = params.Spell.GetLevel()
		local boolean success = params.Spell.IsChannelComplete()
		
		local thistype this = thistype(caster).caster_this
		
		if not success then
			call this.dummyMissile.Destroy()
			call caster.Abilities.Refresh(thistype.THIS_SPELL)
			call caster.Mana.Add(thistype.THIS_SPELL.GetManaCost(level))
			
			return
		endif
		local real targetX = this.targetX
		local real targetY = this.targetY
		
		call this.dummyMissile.GoToSpot.Start(targetX, targetY, Spot.GetHeight(targetX, targetY) + UNIT_TYPE.Impact.Z.STANDARD)
		
		call this.updateTimer.Start(thistype.UPDATE_TIME, true, function thistype.Update)
	endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real maxLength = thistype.MAX_LENGTH[level]
        local real angle = caster.CastAngle(targetX - casterX, targetY - casterY)
        set targetX = casterX + maxLength * Math.Cos(angle)
        set targetY = casterY + maxLength * Math.Sin(angle)
		local thistype this = thistype.allocate()
        local Missile dummyMissile = Missile.Create()
        local Timer updateTimer = Timer.Create()
        set this.caster = caster
        set this.damage = thistype.DAMAGE[level] + thistype.DAMAGE_PER_FOCUS[level]
        set this.dummyMissile = dummyMissile
        set this.level = level
        set this.stunDuration = thistype.STUN_DURATION[level]
        set this.targetGroup = UnitList.Create()
        set this.targetX = targetX
        set this.targetY = targetY
        set this.updateTimer = updateTimer
        call updateTimer.SetData(this)
		call dummyMissile.Event.Add(MISSILE_DESTROY_EVENT)
        call dummyMissile.Acceleration.Set(400.)
        call dummyMissile.CollisionSize.Set(thistype.THIS_SPELL.GetAreaRange(level))
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(1100.)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.DummyUnit.CreateWithAngle(thistype.DUMMY_UNIT_ID, 0., Math.AtanByDeltas(targetY - casterY, targetX - casterX)).AddEffect(thistype.MISSILE_EFFECT_PATH, thistype.MISSILE_EFFECT_ATTACH_POINT, EffectLevel.NORMAL)
		call dummyMissile.DummyUnit.Get().AddEffect(thistype.MISSILE_EFFECT2_PATH, thistype.MISSILE_EFFECT2_ATTACH_POINT, EffectLevel.NORMAL)
		
		call dummyMissile.DummyUnit.Get().Scale.Timed.Add(5., thistype.THIS_SPELL.GetChannelTime(level))
		
		set thistype(caster).caster_this = this
    endmethod
    initMethod Init of Spells_Hero
    	set thistype.DIFFERENCE_GROUP = UnitList.Create()
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.MISSILE_DESTROY_EVENT = Event.Create(Missile.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Destroy)
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.TargetConditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
    endmethod
endstruct
    scope FolderFairyShape
    public struct StructRevert
        implement Allocation
        implement List
        
        static real X
        static real Y
        SpotEffect sourceEffect
        real x
        real y
        eventMethod Event_SpellEffect
            local Unit caster = params.Unit.GetTrigger()
            local thistype this = caster
            local real x = this.x
            local real y = this.y
            call caster.Buffs.Remove(thistype.DUMMY_BUFF)
            call Spot.CreateEffect(caster.Position.X.Get(), caster.Position.Y.Get(), thistype.CAST_EFFECT_PATH, EffectLevel.LOW).Destroy()
            call caster.Position.SetXYZ(x, y, Spot.GetHeight(x, y))
            call Spot.CreateEffect(x, y, thistype.CAST_END_EFFECT_PATH, EffectLevel.LOW).Destroy()
            call caster.Buffs.Remove(FairyShape.DUMMY_BUFF)
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            local SpotEffect sourceEffect = this.sourceEffect
            call sourceEffect.Destroy()
        endmethod
        eventMethod Event_BuffGain
            local Unit target = params.Unit.GetTrigger()
            local real x = thistype.X
            local real y = thistype.Y
            local thistype this = target
            set this.sourceEffect = Spot.CreateEffect(x, y, thistype.SOURCE_EFFECT_PATH, EffectLevel.LOW)
            set this.x = x
            set this.y = y
        endmethod
        static method Ending takes Unit target returns nothing
            call target.Buffs.Remove(thistype.DUMMY_BUFF)
            call HeroSpell.ReplaceSlot(SpellClass.HERO_ULTIMATE, FairyShape.THIS_SPELL, target)
        endmethod
        static method Start takes Unit target, integer level returns nothing
            local real x = target.Position.X.Get()
            local real y = target.Position.Y.Get()
            set thistype.X = x
            set thistype.Y = y
            call target.Buffs.Add(thistype.DUMMY_BUFF, level)
            call HeroSpell.ReplaceSlot(SpellClass.HERO_ULTIMATE, thistype.THIS_SPELL, target)
        endmethod
        static method Init takes nothing returns nothing
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        endmethod
    endstruct
endscope
    globals
        FairyShape FAIRY_SHAPE = STRUCT_BASE
    endglobals
    struct FairyShape
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
    static BoolExpr TARGET_FILTER
    static integer LOWEST_HIT_COUNT
    real areaRange
    real burnedMana
    real heal
    Timer intervalTimer
    integer level
    UnitType origUnitType
    Group targetGroup
    FolderFairyShape_StructRevert Revert = this
    FolderFairyShape_StructRevert LinkToStruct_Revert
    condMethod Conditions
        local Unit caster = Unit.TEMP
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if (target.Mana.Get() <= 0.) then
            return false
        endif
        local integer hitCount = caster.Data.Integer.Get(KEY_ARRAY_DETAIL + target)
        if (hitCount < thistype.LOWEST_HIT_COUNT) then
            set thistype.LOWEST_HIT_COUNT = hitCount
        endif
        return true
    endmethod
    enumMethod RemoveHigherHitCountsEnum
        local Unit target = UNIT.Event.Native.GetEnum()
        if (Unit.TEMP.Data.Integer.Get(KEY_ARRAY_DETAIL + target) > thistype.LOWEST_HIT_COUNT) then
            call thistype.ENUM_GROUP.RemoveUnit(target)
        endif
    endmethod
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        local real areaRange = this.areaRange
        local Unit caster = this
        local integer level = this.level
        local real x = caster.Position.X.Get()
        local real y = caster.Position.Y.Get()
        set User.TEMP = caster.Owner.Get()
        set Unit.TEMP = caster
        set thistype.LOWEST_HIT_COUNT = Math.Integer.MAX
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, areaRange, thistype.TARGET_FILTER)
        call thistype.ENUM_GROUP.Do(function thistype.RemoveHigherHitCountsEnum)
        local Unit target = thistype.ENUM_GROUP.GetNearest(x, y)
        if (target != NULL) then
            local real burnedManaMax = this.burnedMana
            local real heal = this.heal
            local Group targetGroup = this.targetGroup
            call caster.Data.Integer.Add(KEY_ARRAY_DETAIL + target, 1)
            if not targetGroup.ContainsUnit(target) then
                call target.Refs.Add()
                call targetGroup.AddUnit(target)
            endif
			local Lightning effectLightning = Lightning.Create(thistype.BOLT)
            call effectLightning.FromUnitToUnit.Start(caster, target)
            call effectLightning.DestroyTimed.Start(0.35)
            call target.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
            if not target.MagicImmunity.Try() then
				local real eclipseDuration
				if target.Classes.Contains(UnitClass.HERO) then
					set eclipseDuration = thistype.ECLIPSE_HERO_DURATION[level]
				else
					set eclipseDuration = thistype.ECLIPSE_DURATION[level]
				endif
                call target.Buffs.Timed.Start(thistype.ECLIPSE_BUFF, level, eclipseDuration)
				local real burnedMana = Math.Min(target.Mana.Get(), burnedManaMax)
                call caster.BurnManaBySpell(target, burnedMana)
                call caster.HealBySpell(caster, burnedMana / burnedManaMax * heal)
            endif
        endif
    endmethod
    eventMethod Event_BuffLose
        local Unit caster = params.Unit.GetTrigger()
        local thistype this = caster
        local Timer intervalTimer = this.intervalTimer
        local UnitType origUnitType = this.origUnitType
        local Group targetGroup = this.targetGroup
        call intervalTimer.Destroy()
        loop
            local Unit target = targetGroup.FetchFirst()
            exitwhen (target == NULL)
            call caster.Data.Integer.Remove(KEY_ARRAY_DETAIL + target)
            call target.Refs.Subtract()
        endloop
        call caster.Type.SetWithChangerAbility(origUnitType, thistype.REVERT_ABILITY_ID)
        
    endmethod
    eventMethod Event_BuffGain
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Buff.GetLevel()
        local thistype this = caster
		local Timer intervalTimer = Timer.Create()
        set this.areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        set this.burnedMana = thistype.BURNED_MANA[level]
        set this.heal = thistype.HEAL[level]
        set this.level = level
        set this.origUnitType = caster.Type.Get()
        set this.intervalTimer = intervalTimer
        set this.targetGroup = Group.Create()
        call intervalTimer.SetData(this)
        call caster.Type.SetWithChangerAbility(thistype.THIS_UNIT_TYPE, thistype.CHANGER_ABILITY_ID)
        call intervalTimer.Start(thistype.INTERVAL[level], true, function thistype.Interval)
        
        if caster.Buffs.Contains(PurgingRain.DUMMY_BUFF) then
            call caster.Buffs.Remove(UNIT.Abilities.Events.Effect.Channeling.DUMMY_BUFF)
        endif
    endmethod
    eventMethod Event_SpellEffect
        local integer level = params.Spell.GetLevel()
        call params.Unit.GetTrigger().Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION[level])
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call UNIT.Eclipse.NORMAL_BUFF.Variants.Add(thistype.ECLIPSE_BUFF)
        call thistype(NULL).Revert.Init()
    endmethod
endstruct
    scope FolderFairysTears
    public struct StructTarget
        implement Allocation
        implement List
        
        Unit caster
        real damage
        Timer damageTimer
        integer level
        timerMethod DealDamage
            local thistype this = Timer.GetExpired().GetData()
            local Unit target = this
            call target.Buffs.Timed.Start(thistype.COLDNESS_BUFF, level, thistype.COLD_DURATION[level])
            call this.caster.DamageUnitBySpell(target, this.damage, true, false)
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            local Timer damageTimer = this.damageTimer
            call damageTimer.Destroy()
        endmethod
        eventMethod Event_BuffGain
            local Unit caster = Unit.TEMP
            local integer level = params.Buff.GetLevel()
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
			local Timer damageTimer = Timer.Create()
            set this.caster = caster
            set this.damage = TEMP_REAL
            set this.damageTimer = damageTimer
            set this.level = level
            call damageTimer.SetData(this)
            call damageTimer.Start(thistype.DAMAGE_DELAY, false, function thistype.DealDamage)
        endmethod
        static method Start takes Unit caster, real damage, integer level, Unit target returns nothing
            set TEMP_REAL = damage
            set Unit.TEMP = caster
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION)
        endmethod
        static method Init takes nothing returns nothing
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            call UNIT.Cold.NORMAL_BUFF.Variants.Add(thistype.COLDNESS_BUFF)
        endmethod
    endstruct
endscope
    globals
        FairysTears FAIRYS_TEARS = STRUCT_BASE
    endglobals
    struct FairysTears
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    real areaRange
    real damage
    DummyUnit dummyUnit
    Timer intervalTimer
    integer level
    FolderFairysTears_StructTarget Target = this
    FolderFairysTears_StructTarget LinkToStruct_Target
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.Buffs.Contains(thistype(NULL).Target.DUMMY_BUFF) then
            return false
        endif
        return true
    endmethod
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        local Unit target = this
        set User.TEMP = target.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(target.Position.X.Get(), target.Position.Y.Get(), this.areaRange, thistype.TARGET_FILTER)
        local Unit target2 = thistype.ENUM_GROUP.GetRandom()
        if (target2 != NULL) then
            call thistype(NULL).Target.Start(target, this.damage, this.level, target2)
        endif
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local DummyUnit dummyUnit = this.dummyUnit
        local Timer intervalTimer = this.intervalTimer
        call dummyUnit.Destroy()
        call intervalTimer.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
		
        local real targetX = target.Position.X.Get()
        local real targetY = target.Position.Y.Get()
        local thistype this = target
        local DummyUnit dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, targetX, targetY, Spot.GetHeight(targetX, targetY), 0.)
		local Timer intervalTimer = Timer.Create()
        set this.areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        set this.damage = thistype(NULL).Target.DAMAGE[level] + target.SpellPower.Get() * thistype(NULL).Target.DAMAGE_SPELL_POWER_MOD_FACTOR
        set this.dummyUnit = dummyUnit
        set this.intervalTimer = intervalTimer
        set this.level = level
        call intervalTimer.SetData(this)
        call dummyUnit.FollowUnit.Start(target, false, false, 0., 0., 0.)
        call dummyUnit.SetScale(thistype.THIS_SPELL.GetAreaRange(level) * 4 / (4 * 128.))
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
    endmethod
    eventMethod Event_EndCast
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_SpellEffect
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Target.Init()
    endmethod
endstruct
    globals
        FountainOfLifeAndDeath FOUNTAIN_OF_LIFE_AND_DEATH = STRUCT_BASE
    endglobals
    struct FountainOfLifeAndDeath
        implement Allocation
        implement List
        
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local thistype this = thistype.allocate()
        local real angle = caster.CastAngle(targetX - caster.Position.X.Get(), targetY - caster.Position.Y.Get())
        local Unit fountain = Unit.CreateSummon(thistype.FOUNTAIN_TYPE, caster.Owner.Get(), targetX, targetY, angle, thistype.DURATION[level])
        set targetX = fountain.Position.X.Get()
        set targetY = fountain.Position.Y.Get()
        call fountain.Position.Timed.Set(targetX, targetY, Spot.GetHeight(targetX, targetY) + thistype.HEIGHT, thistype.DELAY)
        call DecayAura.AddAbility(fountain, caster, level)
        call Palingenesis.AddAbility(fountain, level)
    endmethod
    initMethod Init of Spells_Hero
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    scope FolderDecayAura
    public struct StructTarget
        implement Allocation
        implement List
        
    	static Event ENDING_EVENT
        static Event START_EVENT
		eventMethod Event_Ending
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local DecayAura parent = aura.GetData()
			call target.Buffs.Subtract(thistype.DUMMY_BUFF)
		endmethod
		eventMethod Event_Start
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local Unit caster = aura.GetCaster()
			local DecayAura parent = aura.GetData()
			local integer level = parent.level
			call target.Buffs.Add(thistype.DUMMY_BUFF, level)
		endmethod
        static method Init takes nothing returns nothing
            set thistype.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Ending)
            set thistype.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Start)
        endmethod
    endstruct
endscope
    globals
        DecayAura DECAY_AURA = STRUCT_BASE
    endglobals
    struct DecayAura
        implement Allocation
        implement List
        
    static real array DAMAGE_PER_INTERVAL
    static BoolExpr TARGET_FILTER
    Aura aura
    Unit caster
    real damage
    Timer intervalTimer
    integer level
    FolderDecayAura_StructTarget Target = this
    FolderDecayAura_StructTarget LinkToStruct_Target
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
	eventMethod DealDamage
		local Unit target = params.Unit.GetTrigger()
		local thistype this = params.GetData()
		call this.caster.DamageUnitBySpell(target, this.damage, true, false)
	endmethod
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
		call this.aura.GetTargetGroup().DoEx(function thistype.DealDamage, this)
    endmethod
    eventMethod Event_BuffLose
        local Unit fountain = params.Unit.GetTrigger()
        local thistype this = fountain
		local Aura aura = this.aura
        local Timer intervalTimer = this.intervalTimer
		call aura.Destroy()
        call intervalTimer.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local Unit caster = params.Buff.GetData()
        local Unit fountain = params.Unit.GetTrigger()
        local integer level = params.Buff.GetLevel()
		local Aura aura = Aura.Create(fountain)
        local Timer intervalTimer = Timer.Create()
        local thistype this = fountain
        set this.aura = aura
        set this.caster = caster
        set this.damage = thistype.DAMAGE_PER_INTERVAL[level]
        set this.intervalTimer = intervalTimer
        set this.level = level
        call aura.SetData(this)
        call intervalTimer.SetData(this)
		call aura.SetAreaRange(FountainOfLifeAndDeath.THIS_SPELL.GetAreaRange(level))
        call aura.SetTargetFilter(thistype.TARGET_FILTER)
		call aura.Event.Add(thistype(NULL).Target.ENDING_EVENT)
		call aura.Event.Add(thistype(NULL).Target.START_EVENT)
		call aura.Enable()
		call intervalTimer.Start(thistype.DAMAGE_INTERVAL, true, function thistype.Interval)
    endmethod
    static method AddAbility takes Unit fountain, Unit caster, integer level returns nothing
        call fountain.Buffs.AddEx(thistype.DUMMY_BUFF, level, caster)
    endmethod
    initMethod Init of Spells_Hero
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        local integer iteration = thistype.THIS_SPELL.GetLevelsAmount()
        loop
            exitwhen (iteration < 1)
            set thistype.DAMAGE_PER_INTERVAL[iteration] = thistype.DAMAGE_PER_SECOND[iteration] * thistype.DAMAGE_INTERVAL
            set iteration = iteration - 1
        endloop
		call thistype(NULL).Target.Init()
    endmethod
endstruct
    globals
        AIPalingenesis A_I_PALINGENESIS = STRUCT_BASE
    endglobals
    struct AIPalingenesis
        implement Allocation
        implement List
        
    eventMethod Event
        call Unit.GetFromId(params.GetSubjectId()).Order.ImmediateBySpell(Palingenesis.THIS_SPELL)
    endmethod
    initMethod Init of AI_Spells
        local EventCombination whichCombination = AIAutoCast.CreateBasics(Palingenesis.THIS_SPELL, function thistype.Event)
        call whichCombination.Periodic.Add(1.)
    endmethod
endstruct
    globals
        Palingenesis PALINGENESIS = STRUCT_BASE
    endglobals
    struct Palingenesis
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    Unit caster
    integer level
    Unit target
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        local integer level = this.level
        local User casterOwner = caster.Owner.Get()
        call dummyMissile.Destroy()
        if (target == NULL) then
            return
        endif
        if not target.Classes.Contains(UnitClass.DEAD) then
            return
        endif
        call target.Effects.Create(thistype.SUMMON_EFFECT_PATH, thistype.SUMMON_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
        call target.Revive()
        call target.Buffs.Add(thistype.SUMMON_BUFF, level)
        call target.Owner.Set(casterOwner)
        call target.SetSummon(thistype.SUMMON_DURATION[level])
        call target.BloodExplosion.Set(thistype.SUMMON_DEATH_EFFECT_PATH)
        call target.VertexColor.Add(-128, -128, -128, 0)
    endmethod
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if not target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        return true
    endmethod
    static method Start takes Unit caster, integer level, Unit target returns nothing
        local Missile dummyMissile = Missile.Create()
        local thistype this = dummyMissile
        set this.caster = caster
        set this.level = level
        set this.target = target
        call dummyMissile.Arc.SetByPerc(0.06)
        call dummyMissile.CollisionSize.Set(10.)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 2.)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(500.)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.GoToUnit.Start(target, function Missile.Destruction)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target
        local real x = caster.Position.X.Get()
        local real y = caster.Position.Y.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, thistype.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
        set target = thistype.ENUM_GROUP.NearestUnit.DoWithCollision(x, y)
        if (target == NULL) then
            return
        endif
        call thistype.Start(caster, level, target)
    endmethod
    condEventMethod Event_OrderConditions
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real x = caster.Position.X.Get()
        local real y = caster.Position.Y.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, thistype.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
        return not thistype.ENUM_GROUP.IsEmpty()
    endmethod
    static method AddAbility takes Unit caster, integer level returns nothing
        call caster.Abilities.AddWithLevel(thistype.THIS_SPELL, level)
        call caster.Abilities.AutoCast.Change(thistype.THIS_SPELL)
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype.THIS_SPELL.SetOrderConditions(BoolExpr.GetFromFunction(function thistype.Event_OrderConditions))
    endmethod
endstruct
    scope FolderGarmentsOfTheSalamander
    public struct StructRegen
        implement Allocation
        implement List
        
        static Group ENUM_GROUP
        static BoolExpr TARGET_FILTER
        Timer intervalTimer
        UnitModSet regenMod
        condMethod Conditions
            local Unit target = UNIT.Event.Native.GetFilter()
            if target.Classes.Contains(UnitClass.DEAD) then
                return false
            endif
            if target.Classes.Contains(UnitClass.MECHANICAL) then
                return false
            endif
            if target.Classes.Contains(UnitClass.STRUCTURE) then
                return false
            endif
            if not target.IsAllyOf(User.TEMP) then
                return false
            endif
            return true
        endmethod
        timerMethod Interval
            local thistype this = Timer.GetExpired().GetData()
            local Unit source = this
            local UnitModSet regenMod = this.regenMod
			local integer level = source.Abilities.GetLevel(GarmentsOfTheSalamander.REVERT_SPELL)
            local real x = source.Position.X.Get()
            local real y = source.Position.Y.Get()
            set User.TEMP = source.Owner.Get()
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, GarmentsOfTheSalamander.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
            
            local integer targetCount = thistype.ENUM_GROUP.Count()
            
        	call source.ModSets.Remove(regenMod)
        	call regenMod.RealMods.ResetVal(UNIT.LifeRegeneration.Bonus.STATE, thistype.LIFE_REGEN_INC_PER_TARGET[level] * targetCount)
        	call source.ModSets.Add(regenMod)
        	
        	if (level != source.Buffs.GetLevel(thistype.DUMMY_BUFF)) then
                call source.Buffs.Remove(thistype.DUMMY_BUFF)
                
                call source.Buffs.Add(thistype.DUMMY_BUFF, level)
            endif
        endmethod
        eventMethod Event_BuffLose
            local Unit source = params.Unit.GetTrigger()
            local thistype this = source
            local Timer intervalTimer = this.intervalTimer
            local UnitModSet regenMod = this.regenMod
            call intervalTimer.Destroy()
            
            call source.ModSets.Remove(regenMod)
            
            call regenMod.Destroy()
        endmethod
        eventMethod Event_BuffGain
            local Unit source = params.Unit.GetTrigger()
            
            local Timer intervalTimer = Timer.Create()
            local UnitModSet regenMod = UnitModSet.Create()
            local thistype this = source
            set this.intervalTimer = intervalTimer
            set this.regenMod = regenMod
            call intervalTimer.SetData(this)
			call regenMod.RealMods.Add(UNIT.LifeRegeneration.Bonus.STATE, 0.)
			call source.ModSets.Add(regenMod)
            call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
        endmethod
        static method Finish takes Unit source returns nothing
            call source.Buffs.Remove(thistype.DUMMY_BUFF)
        endmethod
        static method Start takes Unit source, integer level returns nothing
            call source.Buffs.Add(thistype.DUMMY_BUFF, level)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.ENUM_GROUP = Group.Create()
            set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
    endstruct
endscope
    globals
        GarmentsOfTheSalamander GARMENTS_OF_THE_SALAMANDER = STRUCT_BASE
    endglobals
    struct GarmentsOfTheSalamander
        implement Allocation
        implement List
        
    UnitType origUnitType
    FolderGarmentsOfTheSalamander_StructRegen Regen = this
    FolderGarmentsOfTheSalamander_StructRegen LinkToStruct_Regen
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local UnitType origUnitType = this.origUnitType
        call target.Type.SetWithChangerAbility(origUnitType, thistype.REVERT_ABILITY_ID)
		call target.Effects.Create(thistype.SPECIAL_EFFECT_PATH, thistype.SPECIAL_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
        call HeroSpell.ReplaceSlot(SpellClass.ARTIFACT, WhiteStaff.THIS_SPELL, target)
        call HeroSpell.ReplaceSlot(SpellClass.HERO_FIRST, WaterBindings.THIS_SPELL, target)
        call HeroSpell.ReplaceSlot(SpellClass.HERO_SECOND, thistype.THIS_SPELL, target)
        call thistype(NULL).Regen.Finish(target)
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        set this.origUnitType = target.Type.Get()
        call target.Type.SetWithChangerAbility(thistype.THIS_UNIT_TYPE, thistype.CHANGER_ABILITY_ID)
		call target.Effects.Create(thistype.SPECIAL_EFFECT_PATH, thistype.SPECIAL_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
        call HeroSpell.ReplaceSlot(SpellClass.ARTIFACT, Vomit.THIS_SPELL, target)
        call HeroSpell.ReplaceSlot(SpellClass.HERO_FIRST, Conflagration.THIS_SPELL, target)
        call HeroSpell.ReplaceSlot(SpellClass.HERO_SECOND, thistype.REVERT_SPELL, target)
        
        call thistype(NULL).Regen.Start(target, level)
    endmethod
    eventMethod Event_RevertSpellEffect
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_SpellEffect
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Hero
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.REVERT_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_RevertSpellEffect))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        
        call thistype(NULL).Regen.Init()
    endmethod
endstruct
    scope FolderHandOfNature
    public struct StructId
        implement Allocation
        implement List
        
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    integer value
    method Get takes nothing returns integer
        return this.value
    endmethod
    method Set takes integer value returns nothing
        set this.value = value
    endmethod
    method Add takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod
    method Event_Create takes nothing returns nothing
        call this.Set(KEY_ARRAY + this)
    endmethod
    method Subtract takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod
    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
    endstruct
    scope FolderData
    scope FolderInteger
    public struct StructTable
        implement Allocation
        implement List
        
    method Contains takes integer key, integer value returns boolean
        return HandOfNature(this).Data.table.IntegerKeys.Table.ContainsInteger(HandOfNature(this).Id.Get(), key, value)
    endmethod
    method Count takes integer key returns integer
        return HandOfNature(this).Data.table.IntegerKeys.Table.CountIntegers(HandOfNature(this).Id.Get(), key)
    endmethod
    method IsEmpty takes integer key returns boolean
        return HandOfNature(this).Data.table.IntegerKeys.Table.IsEmptyInteger(HandOfNature(this).Id.Get(), key)
    endmethod
    method Get takes integer key, integer index returns integer
        return HandOfNature(this).Data.table.IntegerKeys.Table.GetInteger(HandOfNature(this).Id.Get(), key, index)
    endmethod
    method GetFirst takes integer key returns integer
        return HandOfNature(this).Data.table.IntegerKeys.Table.GetFirstInteger(HandOfNature(this).Id.Get(), key)
    endmethod
    method GetLast takes integer key returns integer
        return HandOfNature(this).Data.table.IntegerKeys.Table.GetLastInteger(HandOfNature(this).Id.Get(), key)
    endmethod
    method Clear takes integer key returns nothing
        call HandOfNature(this).Data.table.IntegerKeys.Table.Clear(HandOfNature(this).Id.Get(), key)
    endmethod
    method FetchFirst takes integer key returns integer
        return HandOfNature(this).Data.table.IntegerKeys.Table.FetchFirstInteger(HandOfNature(this).Id.Get(), key)
    endmethod
    method Remove takes integer key, integer value returns boolean
        return HandOfNature(this).Data.table.IntegerKeys.Table.RemoveInteger(HandOfNature(this).Id.Get(), key, value)
    endmethod
    method RemoveByIndex takes integer key, integer index returns boolean
        return HandOfNature(this).Data.table.IntegerKeys.Table.RemoveIntegerByIndex(HandOfNature(this).Id.Get(), key, index)
    endmethod
    method Add takes integer key, integer value returns boolean
        return HandOfNature(this).Data.table.IntegerKeys.Table.AddInteger(HandOfNature(this).Id.Get(), key, value)
    endmethod
    method AddMulti takes integer key, integer value returns boolean
        return HandOfNature(this).Data.table.IntegerKeys.Table.AddIntegerMulti(HandOfNature(this).Id.Get(), key, value)
    endmethod
    method Join takes integer key, thistype other returns nothing
        call HandOfNature(this).Data.table.IntegerKeys.Table.JoinInteger(HandOfNature(this).Id.Get(), key, HandOfNature(other).Data.table, HandOfNature(other).Id.Get(), key)
    endmethod
    method Random takes integer key, integer lowerBound, integer higherBound returns integer
        return HandOfNature(this).Data.table.IntegerKeys.Table.RandomInteger(HandOfNature(this).Id.Get(), key, lowerBound, higherBound)
    endmethod
    method RandomAll takes integer key returns integer
        return this.Random(key, DATA_TABLE.IntegerKeys.Table.STARTED, this.Count(key))
    endmethod
    method Shuffle takes integer key returns nothing
        call HandOfNature(this).Data.table.IntegerKeys.Table.ShuffleIntegers(HandOfNature(this).Id.Get(), key)
    endmethod
    method Print takes integer key returns nothing
        call HandOfNature(this).Data.table.IntegerKeys.Table.PrintIntegers(HandOfNature(this).Id.Get(), key)
    endmethod
            endstruct
        endscope
    public struct StructInteger
        implement Allocation
        implement List
        
    FolderInteger_StructTable Table = this
    FolderInteger_StructTable LinkToStruct_Table
    method Get takes integer key returns integer
        return HandOfNature(this).Data.table.IntegerKeys.GetInteger(HandOfNature(this).Id.Get(), key)
    endmethod
    method Is takes integer key returns boolean
        return (this.Get(key) != HASH_TABLE.Integer.DEFAULT_VALUE)
    endmethod
    method Remove takes integer key returns nothing
        call HandOfNature(this).Data.table.IntegerKeys.RemoveInteger(HandOfNature(this).Id.Get(), key)
    endmethod
    method Set takes integer key, integer value returns nothing
        call HandOfNature(this).Data.table.IntegerKeys.SetInteger(HandOfNature(this).Id.Get(), key, value)
    endmethod
        endstruct
    endscope
    public struct StructData
        implement Allocation
        implement List
        
    FolderData_StructInteger Integer = this
    FolderData_StructInteger LinkToStruct_Integer
	DataTable table
    method Destroy takes nothing returns nothing
        call this.table.IntegerKeys.RemoveChild(HandOfNature(this).Id.Get())
    endmethod
	method Event_Create takes nothing returns nothing
		set this.table = Data.GetRandomTable()
	endmethod
	inject HandOfNature.Allocation.deallocate_demount.hook
		call HandOfNature(this).Data.Destroy()
	endinject
	inject HandOfNature.Allocation.allocate_mount.hook
		call HandOfNature(this).Data.Event_Create()
	endinject
    endstruct
    public struct StructPrison
        implement Allocation
        implement List
        
        method Subtract takes Unit target returns nothing
            call target.Buffs.Subtract(thistype.DUMMY_BUFF)
        endmethod
        method Add takes Unit target returns nothing
            call target.Buffs.Add(thistype.DUMMY_BUFF, 1)
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
    scope FolderRoots
    public struct StructBuff
        implement Allocation
        implement List
        
            static real array DAMAGE_PER_INTERVAL
            Unit caster
            real damage
            Timer intervalTimer
            Unit target
            timerMethod DealDamage
                local thistype this = Timer.GetExpired().GetData()
                call this.caster.DamageUnitBySpell(this.target, this.damage, true, false)
            endmethod
            eventMethod Event_BuffLose
                local Unit target = params.Unit.GetTrigger()
                local thistype this = target
                local Timer intervalTimer = this.intervalTimer
                call intervalTimer.Destroy()
            endmethod
            eventMethod Event_BuffGain
                local Unit caster = Unit.TEMP
                local integer level = params.Buff.GetLevel()
                local Unit target = params.Unit.GetTrigger()
                local thistype this = target
				local Timer intervalTimer = Timer.Create()
                set this.caster = caster
                set this.damage = thistype.DAMAGE_PER_INTERVAL[level]
                set this.intervalTimer = intervalTimer
                set this.target = target
                call intervalTimer.SetData(this)
                call intervalTimer.Start(thistype.INTERVAL, true, function thistype.DealDamage)
            endmethod
            static method Start takes Unit caster, integer level, Unit target returns nothing
                local real duration
                if target.Classes.Contains(UnitClass.HERO) then
                    set duration = thistype.HERO_DURATION[level]
                else
                    set duration = thistype.DURATION[level]
                endif
                set Unit.TEMP = caster
                call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, duration)
            endmethod
            static method Init takes nothing returns nothing
                local integer iteration = HandOfNature.THIS_SPELL.GetLevelsAmount()
                loop
                    set thistype.DAMAGE_PER_INTERVAL[iteration] = thistype.DAMAGE[iteration] * thistype.INTERVAL / thistype.DURATION[iteration]
                    set iteration = iteration - 1
                    exitwhen (iteration < 1)
                endloop
                call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
                call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
                call UNIT.Stun.DUMMY_BUFF.Variants.Add(thistype.DUMMY_BUFF)
            endmethod
        endstruct
    endscope
    public struct StructRoots
        implement Allocation
        implement List
        
		Unit caster
        Missile dummyMissile
        integer effectAlignment
        Timer intervalTimer
        integer level
        Unit target
    FolderRoots_StructBuff Buff = this
    FolderRoots_StructBuff LinkToStruct_Buff
        eventMethod Impact
            local Missile dummyMissile = params.Missile.GetTrigger()
            local thistype this = dummyMissile.GetData()
            local Unit caster = this.caster
            local Timer intervalTimer = this.intervalTimer
            local integer level = this.level
            local Unit target = this.target
            call this.deallocate()
            call dummyMissile.Destroy()
            call intervalTimer.Destroy()
            call thistype(NULL).Buff.Start(caster, level, target)
        endmethod
        timerMethod Interval
            local thistype this = Timer.GetExpired().GetData()
            local Missile dummyMissile = this.dummyMissile
            local integer effectAligment = -this.effectAlignment
            call Spot.CreateEffect(dummyMissile.Position.X.Get() + effectAlignment * Math.Random(25., 50.), dummyMissile.Position.Y.Get() + effectAlignment * Math.Random(25., 50.), SPECIAL_EFFECT_PATH, EffectLevel.NORMAL).Destroy()
            set this.effectAlignment = effectAlignment
        endmethod
        static method StartTarget takes Unit caster, integer level, Unit target returns nothing
            local thistype this = thistype.allocate()
            local Missile dummyMissile = Missile.Create()
            local Timer intervalTimer = Timer.Create()
            set this.caster = caster
            set this.dummyMissile = dummyMissile
            set this.effectAlignment = -1
            set this.intervalTimer = intervalTimer
            set this.level = level
            set this.target = target
            call intervalTimer.SetData(this)
            call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
            call dummyMissile.CollisionSize.Set(10.)
            call dummyMissile.Impact.SetAction(function thistype.Impact)
            call dummyMissile.SetData(this)
            call dummyMissile.Speed.Set(400.)
            call dummyMissile.Position.SetFromUnit(caster)
            call dummyMissile.GoToUnit.Start(target, null)
        endmethod
        static method Init takes nothing returns nothing
            call thistype(NULL).Buff.Init()
        endmethod
    endstruct
    
    public struct StructNova
        implement Allocation
        implement List
        
    	Timer durationTimer
    	Timer intervalTimer
    	real length
    	real lengthAdd
    	real sourceX
    	real sourceY
    	Queue tiles
    	Queue tileMods
    	
    	real overDuration
    	
	    method SpawnGrass takes real x, real y returns nothing
	        local Tile val = Tile.GetFromCoords(x, y)
	
	        if this.tiles.Contains(val) then
	            call val.RemoveRef()
	
	            return
	        endif
	
			call this.tiles.Add(val)
	
	        local TileTypeMod mod = TileTypeMod.Create(x, y, TileType.GRASS)
	        
	        set thistype(mod).overDuration = this.durationTimer.GetRemaining() * 2 + 2
	        call this.tileMods.Add(mod)
	    endmethod
        timerMethod IntervalByTimer
        	local thistype this = Timer.GetExpired().GetData()
        	
        	local real sourceX = this.sourceX
        	local real sourceY = this.sourceY
        	
        	local real length = this.length + this.lengthAdd
        	
        	set this.length = length
        	
        	local real angle = Math.RandomAngle()
        	
        	loop
        		exitwhen (angle > Math.FULL_ANGLE)
        		
        		call this.SpawnGrass(sourceX + length * Math.Cos(angle), sourceY + length * Math.Sin(angle))
        		
        		set angle = angle + Math.QUARTER_ANGLE / 2
        	endloop
        endmethod
    	
    	method Ending takes nothing returns nothing
    		local Timer durationTimer = this.durationTimer
    		local Timer intervalTimer = this.intervalTimer
    		local Queue tiles = this.tiles
    		local Queue tileMods = this.tileMods
    		
    		call durationTimer.Destroy()
    		call intervalTimer.Destroy()
    		call tiles.Destroy()
    		
    		local TileTypeMod mod = tileMods.GetFirst()
    		
    		loop
    			exitwhen (mod == NULL)
    		
    			call mod.DestroyTimed.Start(thistype(mod).overDuration)
    		
    			set mod = tileMods.GetNext(mod)
    		endloop
    		
    		call tileMods.Destroy()
    	endmethod
    	
    	timerMethod PauseByTimer
    		local thistype this = Timer.GetExpired().GetData()
    		
    		call this.intervalTimer.Pause()
    	endmethod
    	
    
    	
        method Start takes SpellInstance whichInstance returns nothing        	
        	local integer level = whichInstance.GetLevel()
			local real duration = HandOfNature.DURATION[level]
			local integer wavesAmount = Real.ToInt(thistype.DURATION / thistype.INTERVAL)
			local Timer durationTimer = Timer.Create()        	
        	local Timer intervalTimer = Timer.Create()
        	
        	set this.durationTimer = durationTimer
        	set this.intervalTimer = intervalTimer
        	set this.length = 0.
        	set this.lengthAdd = HandOfNature.THIS_SPELL.GetAreaRange(level) / wavesAmount
        	set this.sourceX = whichInstance.GetTargetX()
        	set this.sourceY = whichInstance.GetTargetY()
        	set this.tiles = Queue.Create()
        	set this.tileMods = Queue.Create()
        	call durationTimer.SetData(this)
        	call intervalTimer.SetData(this)
        	
        	call intervalTimer.Start(thistype.INTERVAL, true, function thistype.IntervalByTimer)
        	call durationTimer.Start(thistype.DURATION, false, function thistype.PauseByTimer)
        endmethod
    endstruct
endscope
    globals
        HandOfNature HAND_OF_NATURE = STRUCT_BASE
    endglobals
    struct HandOfNature
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static key GetKeyMacro_SUMMONS_KEY_ARRAY
    static constant integer SUMMONS_KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_SUMMONS_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static BoolExpr TARGET_FILTER
    Unit caster
    boolean prisoned
    Unit target
    FolderHandOfNature_StructData Data = this
    FolderHandOfNature_StructData LinkToStruct_Data
    FolderHandOfNature_StructId Id = this
    FolderHandOfNature_StructId LinkToStruct_Id
    FolderHandOfNature_StructNova Nova = this
    FolderHandOfNature_StructNova LinkToStruct_Nova
    FolderHandOfNature_StructPrison Prison = this
    FolderHandOfNature_StructPrison LinkToStruct_Prison
    FolderHandOfNature_StructRoots Roots = this
    FolderHandOfNature_StructRoots LinkToStruct_Roots
    eventMethod Event_BuffLose
        local Unit summon = params.Unit.GetTrigger()
        local thistype this = summon.Data.Integer.Get(KEY)
        if this.prisoned then
            set this.prisoned = false
            call thistype(NULL).Prison.Subtract(this.target)
        endif
        if this.Data.Integer.Table.Remove(SUMMONS_KEY_ARRAY, summon) then
			call this.Nova.Ending()
			
            call this.deallocate()
        endif
    endmethod
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local SpellInstance whichInstance = params.SpellInstance.GetTrigger()
		local thistype this = thistype.allocate()
        call this.Id.Event_Create()
        set this.caster = caster
		local real offset
        if (target == NULL) then
            set offset = 2 * thistype.SUMMON_UNIT_TYPE[level].CollisionSize.Get() * thistype.SUMMON_UNIT_TYPE[level].Scale.Get()
            set this.prisoned = false
        else
            set offset = target.CollisionSize.Get(true) + S2R(SetVar.GetVal("hon")) * thistype.SUMMON_UNIT_TYPE[level].CollisionSize.Get() * thistype.SUMMON_UNIT_TYPE[level].Scale.Get()
            set this.prisoned = true
            set this.target = target
            call thistype(NULL).Prison.Add(target)
        endif
        call Spot.CreateEffect(targetX, targetY, thistype.SUMMON_EFFECT_PATH, EffectLevel.NORMAL).Destroy()
		local real angle = Math.AtanByDeltas(targetY - caster.Position.Y.Get(), targetX - caster.Position.X.Get())
		local integer maxSummonsAmount = thistype.MAX_SUMMONS_AMOUNT[level]
		local integer summonsAmount = 1
        loop
            exitwhen (summonsAmount > maxSummonsAmount)
            local real x = targetX + offset * Math.Cos(angle)
            local real y = targetY + offset * Math.Sin(angle)
            local Unit summon = Unit.CreateSummon(thistype.SUMMON_UNIT_TYPE[level], caster.Owner.Get(), x, y, angle, thistype.DURATION[level])
            call summon.Data.Integer.Set(KEY, this)
      call DebugEx(I2S(this)+";"+I2S(this.Id.Get())+" add "+I2S(this.Data.Integer.Table.Count(SUMMONS_KEY_ARRAY)))
            call this.Data.Integer.Table.Add(SUMMONS_KEY_ARRAY, summon)
            call summon.Abilities.AddWithLevel(SlowPoison.THIS_SPELL, level)
            call summon.Buffs.Add(thistype.DUMMY_BUFF, 1)
            call summon.Position.SetXY(x, y)
            call summon.Scale.Set(0.)
            call summon.Scale.Timed.Add(thistype.SUMMON_UNIT_TYPE[level].Scale.Get(), 1.)
            set User.TEMP = summon.Owner.Get()
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(targetX, targetY, thistype.THIS_SPELL.GetAreaRange(level), TARGET_FILTER)
			local integer maxTargetsAmount = thistype.MAX_TARGETS_AMOUNT[level]
            local integer targetsAmount = 1
            loop
                exitwhen (targetsAmount > maxTargetsAmount)
                set target = thistype.ENUM_GROUP.GetNearest(targetX, targetY)
                exitwhen (target == NULL)
                call thistype.ENUM_GROUP.RemoveUnit(target)
                if (target != NULL) then
                    call thistype(NULL).Roots.StartTarget(summon, level, target)
                endif
                set targetsAmount = targetsAmount + 1
            endloop
            set angle = angle + Math.FULL_ANGLE / maxSummonsAmount
            set summonsAmount = summonsAmount + 1
        endloop
        
        call this.Nova.Start(whichInstance)
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Prison.Init()
        call thistype(NULL).Roots.Init()
    endmethod
endstruct
    scope FolderSlowPoison
    public struct StructTarget
        implement Allocation
        implement List
        
        static Unit CASTER
        static real DAMAGE
        Unit caster
        real damage
        Timer intervalTimer
        static method Interval takes nothing returns nothing
            local thistype this = Timer.GetExpired().GetData()
            local Unit target = this
            call this.caster.DamageUnitBySpell(target, Math.Min(this.damage, target.Life.Get() - UNIT.Life.IMMORTAL), false, false)
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            local Timer intervalTimer = this.intervalTimer
            call intervalTimer.Destroy()
        endmethod
        eventMethod Event_BuffGain
            local Unit caster = thistype.CASTER
            local integer level = params.Buff.GetLevel()
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
			local Timer intervalTimer = Timer.Create()
            set this.caster = caster
            set this.damage = thistype.DAMAGE
            set this.intervalTimer = intervalTimer
            call intervalTimer.SetData(this)
            call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
        endmethod
        static method Start takes Unit caster, integer level, Unit target returns nothing
            local real duration
            if target.Classes.Contains(UnitClass.HERO) then
                set duration = thistype.HERO_DURATION
            else
                set duration = thistype.DURATION
            endif
            set thistype.CASTER = caster
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, duration)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DAMAGE = thistype.DAMAGE_PER_SECOND * thistype.INTERVAL
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            call UNIT.Poisoned.NORMAL_BUFF.Variants.Add(thistype.DUMMY_BUFF)
        endmethod
    endstruct
endscope
    globals
        SlowPoison SLOW_POISON = STRUCT_BASE
    endglobals
    struct SlowPoison
        implement Allocation
        implement List
        
    static Event DAMAGE_EVENT
    FolderSlowPoison_StructTarget Target = this
    FolderSlowPoison_StructTarget LinkToStruct_Target
    static method Conditions takes Unit target returns boolean
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_Damage
        local Unit target = params.Unit.GetTrigger()
        if not thistype.Conditions(target) then
            return
        endif
        call thistype(NULL).Target.Start(params.Unit.GetDamager(), params.Unit.GetDamager().Abilities.GetLevel(thistype.THIS_SPELL), target)
    endmethod
    eventMethod Event_BuffLose
        call params.Unit.GetTrigger().Event.Remove(DAMAGE_EVENT)
    endmethod
    eventMethod Event_BuffGain
        call params.Unit.GetTrigger().Event.Add(DAMAGE_EVENT)
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Hero
        set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
        call thistype(NULL).Target.Init()
    endmethod
endstruct
    scope FolderHopNDrop
    scope FolderSetMines
    public struct StructMine
        implement Allocation
        implement List
        
            static Event DEATH_EVENT
            static Group ENUM_GROUP
            static BoolExpr TARGET_FILTER
            real areaRange
            Unit caster
            real damageAmount
            Unit mine
            condMethod Conditions
                local Unit target = UNIT.Event.Native.GetFilter()
                if target.Classes.Contains(UnitClass.DEAD) then
                    return false
                endif
                if not target.Classes.Contains(UnitClass.GROUND) then
                    return false
                endif
                if target.Classes.Contains(UnitClass.WARD) then
                    return false
                endif
                if target.IsAllyOf(User.TEMP) then
                    return false
                endif
                return true
            endmethod
            eventMethod Event_Death
                local Unit mine = params.Unit.GetTrigger()
                local real mineX = mine.Position.X.Get()
                local real mineY = mine.Position.Y.Get()
                local thistype this = mine
                local real areaRange = this.areaRange
                local Unit caster = this.caster
                local real damageAmount = this.damageAmount
                local User casterOwner = caster.Owner.Get()
                call mine.Event.Remove(DEATH_EVENT)
                call mine.Animation.Set(Animation.SPELL)
                call mine.Buffs.Remove(thistype.DUMMY_BUFF)
                
                set User.TEMP = casterOwner
                call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(mineX, mineY, areaRange, thistype.TARGET_FILTER)
                local Unit target = thistype.ENUM_GROUP.FetchFirst()
                if (target != NULL) then
                    loop
                        call target.Death.Explosion.Add()
                        call target.Movement.SubtractTimed(thistype.STUN_DURATION)
                        call caster.DamageUnitBySpell(target, damageAmount, false, true)
                        call target.Death.Explosion.Subtract()
                        set target = thistype.ENUM_GROUP.FetchFirst()
                        exitwhen (target == NULL)
                    endloop
                endif
            endmethod
            static method Start takes real areaRange, Unit caster, real damageAmount, integer level, real x, real y, real z returns nothing
                local Unit mine = Unit.Create(thistype.SUMMON_UNIT_TYPE, caster.Owner.Get(), x, y, caster.Facing.Get())
                local thistype this = mine
                set this.areaRange = areaRange
                set this.caster = caster
                set this.damageAmount = damageAmount
                
                
                call mine.Event.Add(DEATH_EVENT)
                call mine.Ghost.Add()
                
                call mine.Pathing.Subtract()
                call mine.Position.Z.Set(z)
                call mine.Scale.Set((64 + areaRange) / 192)
                call mine.Position.Timed.Accelerated.AddForNoCheck(0., 0., thistype.MOVE_Z_SPEED_START * TranslationAccelerated.UPDATE_TIME, 0., 0., 2 * ((Spot.GetHeight(x, y) - z) / thistype.MOVE_DURATION / thistype.MOVE_DURATION - thistype.MOVE_Z_SPEED_START / thistype.MOVE_DURATION) * TranslationAccelerated.UPDATE_TIME * TranslationAccelerated.UPDATE_TIME, thistype.MOVE_DURATION)
                call mine.ApplyTimedLife(thistype.EXPLOSION_DELAY)
            endmethod
            static method Init takes nothing returns nothing
                set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Death)
                set thistype.ENUM_GROUP = Group.Create()
                set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
            endmethod
        endstruct
    endscope
    public struct StructSetMines
        implement Allocation
        implement List
        
        static real INTERVAL
        real areaRange
        real damageAmount
        Timer intervalTimer
        integer level
    FolderSetMines_StructMine Mine = this
    FolderSetMines_StructMine LinkToStruct_Mine
        timerMethod Interval
            local thistype this = Timer.GetExpired().GetData()
            local Unit target = this
            call thistype(NULL).Mine.Start(this.areaRange, target, this.damageAmount, this.level, target.Position.X.Get(), target.Position.Y.Get(), target.Position.Z.Get())
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            local Timer intervalTimer = this.intervalTimer
            call intervalTimer.Destroy()
        endmethod
        eventMethod Event_BuffGain
            local integer level = params.Buff.GetLevel()
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
			local Timer intervalTimer = Timer.Create()
            set this.areaRange = thistype.AREA_RANGE[level]
            set this.damageAmount = thistype.DAMAGE[level]
            set this.intervalTimer = intervalTimer
            set this.level = level
            call intervalTimer.SetData(this)
            call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
        endmethod
        static method Start takes Unit caster, integer level returns nothing
            call caster.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, HopNDrop.DURATION)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.INTERVAL = HopNDrop.DURATION / (thistype.WAVES_AMOUNT + 1) + Math.EPSILON
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            call thistype(NULL).Mine.Init()
        endmethod
    endstruct
endscope
    globals
        HopNDrop HOP_N_DROP = STRUCT_BASE
    endglobals
    struct HopNDrop
        implement Allocation
        implement List
        
    static real DURATION_Z_SPEED_START_FACTOR
    static real HALF_DURATION
    static real LENGTH
    static constant real UPDATE_TIME = (1 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (1 * 1.))
    static integer WAVES_AMOUNT
    static integer WAVES_AMOUNT_SQUARE
    static real Z_ADD_ADD
    static real Z_ADD_ADD_FORM
    static real Z_ADD_FORM
    static real TARGET_X
    static real TARGET_Y
    Timer durationTimer
    Timer moveTimer
    real xAdd
    real yAdd
    real zAdd
    real zAddAdd
    FolderHopNDrop_StructSetMines SetMines = this
    FolderHopNDrop_StructSetMines LinkToStruct_SetMines
    timerMethod Move
        local thistype this = Timer.GetExpired().GetData()
        local Unit target = this
        local real zAdd = this.zAdd + this.zAddAdd
        local real x = target.Position.X.Get() + this.xAdd
        local real y = target.Position.Y.Get() + this.yAdd
        local real z = target.Position.Z.Get() + zAdd
        local real floorZ = Spot.GetHeight(x, y)
        set this.zAdd = zAdd
        call target.Position.SetXYWithTerrainWalkableCollision(x, y)
        if ((zAdd < 0.) and (z < floorZ + thistype.FLOOR_TOLERANCE)) then
            call target.Position.Z.Set(floorZ)
            call target.Buffs.Remove(thistype.DUMMY_BUFF)
        else
            call target.Position.Z.Set(z)
        endif
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local Timer moveTimer = this.moveTimer
        call moveTimer.Destroy()
        call target.Position.Nudge()
    endmethod
    eventMethod Event_BuffGain
        local Unit target = params.Unit.GetTrigger()
        local real targetX = thistype.TARGET_X
        local real targetY = thistype.TARGET_Y
        local real angle = Math.AtanByDeltas(targetY - target.Position.Y.Get(), targetX - target.Position.X.Get())
        local thistype this = target
		local Timer moveTimer = Timer.Create()
        local real zD = Spot.GetHeight(targetX, targetY) - target.Position.Z.Get()
        set this.moveTimer = moveTimer
        set this.xAdd = Math.Cos(angle) * thistype.LENGTH
        set this.yAdd = Math.Sin(angle) * thistype.LENGTH
        set this.zAdd = thistype.Z_ADD_FORM - zD / thistype.WAVES_AMOUNT
        set this.zAddAdd = thistype.Z_ADD_ADD_FORM + 4 * zD / thistype.WAVES_AMOUNT_SQUARE
        call moveTimer.SetData(this)
        call moveTimer.Start(thistype.UPDATE_TIME, true, function thistype.Move)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        set thistype.TARGET_X = params.Spot.GetTargetX()
        set thistype.TARGET_Y = params.Spot.GetTargetY()
        call caster.Buffs.Add(thistype.DUMMY_BUFF, level)
        call thistype(NULL).SetMines.Start(caster, level)
    endmethod
    initMethod Init of Spells_Hero
        set thistype.HALF_DURATION = thistype.DURATION / 2.
        set thistype.WAVES_AMOUNT = Real.ToInt(thistype.DURATION / thistype.UPDATE_TIME)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        set thistype.DURATION_Z_SPEED_START_FACTOR = thistype.DURATION * thistype.DURATION / thistype.HALF_DURATION / thistype.HALF_DURATION * thistype.UPDATE_TIME
        set thistype.LENGTH = thistype.MAX_LENGTH / thistype.WAVES_AMOUNT
        set thistype.WAVES_AMOUNT_SQUARE = thistype.WAVES_AMOUNT * thistype.WAVES_AMOUNT
        set thistype.Z_ADD_ADD = -2 * thistype.HEIGHT * thistype.UPDATE_TIME * thistype.UPDATE_TIME / thistype.HALF_DURATION / thistype.HALF_DURATION
        set thistype.Z_ADD_FORM = 2 * thistype.HEIGHT / thistype.WAVES_AMOUNT
        set thistype.Z_ADD_ADD_FORM = -4 * thistype.HEIGHT / thistype.WAVES_AMOUNT_SQUARE
        call thistype(NULL).SetMines.Init()
    endmethod
endstruct
    scope FolderInfection
    public struct StructCone
        implement Allocation
        implement List
        
        static real DURATION
        static Group ENUM_GROUP
        static real LENGTH
        static BoolExpr TARGET_FILTER
    static constant real UPDATE_TIME = (1 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (1 * 1.))
        real angle
        Unit caster
        real damage
        DummyUnit dummyUnit
        real length
        real lengthAdd
        integer level
        real maxLength
        real sourceX
        real sourceY
        UnitList targetGroup
        Timer updateTimer
        real xAdd
        real yAdd
        timerMethod Ending
            local Timer durationTimer = Timer.GetExpired()
            local thistype this = durationTimer.GetData()
            local DummyUnit dummyUnit = this.dummyUnit
            local UnitList targetGroup = this.targetGroup
            local Timer updateTimer = this.updateTimer
            call this.deallocate()
            call dummyUnit.Destroy()
            call durationTimer.Destroy()
            call targetGroup.Destroy()
            call updateTimer.Destroy()
        endmethod
        condMethod Conditions
            local Unit target = UNIT.Event.Native.GetFilter()
            if UnitList.TEMP.Contains(target) then
                return false
            endif
            if target.Classes.Contains(UnitClass.DEAD) then
                return false
            endif
            if target.IsAllyOf(User.TEMP) then
                return false
            endif
            if target.MagicImmunity.Try() then
                return false
            endif
            return true
        endmethod
        timerMethod Move
            local thistype this = Timer.GetExpired().GetData()
            local real angle = this.angle
            local Unit caster = this.caster
            local real damage = this.damage
            local DummyUnit dummyUnit = this.dummyUnit
            local real lengthAdd = this.lengthAdd
            local UnitList targetGroup = this.targetGroup
            local real length = this.length + lengthAdd
            local real x = dummyUnit.Position.X.Get() + this.xAdd
            local real y = dummyUnit.Position.Y.Get() + this.yAdd
            local real width = thistype.START_WIDTH + (thistype.END_WIDTH - thistype.START_WIDTH) * (length / this.maxLength)
            set this.length = length
            call dummyUnit.Position.X.Set(x)
            call dummyUnit.Position.Y.Set(y)
            set User.TEMP = caster.Owner.Get()
            set UnitList.TEMP = targetGroup
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, length + width, thistype.TARGET_FILTER)
            local Unit target = thistype.ENUM_GROUP.FetchFirst()
            if (target != NULL) then
                set damage = this.damage
                set lengthAdd = this.lengthAdd
                local integer level = this.level
                local real sourceX = this.sourceX
                local real sourceY = this.sourceY
                loop
                    local real dX = target.Position.X.Get() - sourceX
                    local real dY = target.Position.Y.Get() - sourceY
                    local real d = Math.DistanceByDeltas(dX, dY)
                    local real targetAngle = Math.AngleDifference(Math.AtanByDeltas(dY, dX), angle)
                    local real lengthD = Math.Cos(targetAngle) * d
                    if ((targetAngle <= Math.QUARTER_ANGLE) and (lengthD <= length) and (lengthD > length - lengthAdd) and (Math.Sin(targetAngle) * d <= width)) then
                        call targetGroup.Add(target)
                        call caster.DamageUnitBySpell(target, damage, true, false)
                    endif
                    set target = thistype.ENUM_GROUP.FetchFirst()
                    exitwhen (target == NULL)
                endloop
            endif
        endmethod
        static method Start takes Unit caster, integer level, Unit target returns nothing
            local real casterX = caster.Position.X.Get()
            local real casterY = caster.Position.Y.Get()
            local real targetX = target.Position.X.Get()
            local real targetY = target.Position.Y.Get()
            local real dX = targetX - casterX
            local real dY = targetY - casterY
            local real angle = caster.CastAngle(dX, dY)
            local real d = Math.DistanceByDeltas(dX, dY)
            local thistype this = thistype.allocate()
            local Timer durationTimer = Timer.Create()
            local UnitList targetGroup = UnitList.Create()
            local Timer updateTimer = Timer.Create()
            set this.angle = angle
            set this.caster = caster
            set this.damage = thistype.DAMAGE[level]
            set this.dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, casterX, casterY, caster.Position.Z.Get() + caster.Outpact.Z.Get(true), angle)
            set this.length = 0.
            set this.lengthAdd = thistype.LENGTH
            set this.level = level
            set this.maxLength = thistype.MAX_LENGTH
            set this.sourceX = casterX
            set this.sourceY = casterY
            set this.targetGroup = targetGroup
            set this.updateTimer = updateTimer
            set this.xAdd = dX / d * thistype.LENGTH
            set this.yAdd = dY / d * thistype.LENGTH
            call durationTimer.SetData(this)
            call updateTimer.SetData(this)
            call targetGroup.Add(target)
            call updateTimer.Start(thistype.UPDATE_TIME, true, function thistype.Move)
            call durationTimer.Start(thistype.DURATION, false, function thistype.Ending)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DURATION = thistype.MAX_LENGTH / thistype.SPEED
            set thistype.ENUM_GROUP = Group.Create()
            set thistype.LENGTH = thistype.SPEED * thistype.UPDATE_TIME
            set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        endmethod
    endstruct
    scope FolderSummon
    public struct StructFuniculusUmbilicalis
        implement Allocation
        implement List
        
            static Event HEAL_EVENT
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
            static Unit SUMMONER
            Unit summoner
            eventMethod Event_Heal
                local Unit summoner = params.Unit.GetTrigger()
                local real healedAmount = params.Real.GetHealedAmount() * thistype.HEAL_FACTOR
                local integer iteration = summoner.Data.Integer.Table.Count(KEY_ARRAY)
                loop
                    local thistype this = summoner.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                    local Unit target = this
                    call summoner.HealBySpell(target, healedAmount)
                    set iteration = iteration - 1
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                endloop
            endmethod
            eventMethod Event_BuffLose
                local Unit target = params.Unit.GetTrigger()
                local thistype this = target
                local Unit summoner = this.summoner
                if summoner.Data.Integer.Table.Remove(KEY_ARRAY, this) then
                    call summoner.Event.Remove(HEAL_EVENT)
                endif
            endmethod
            eventMethod Event_BuffGain
                local Unit summoner = thistype.SUMMONER
                local Unit target = params.Unit.GetTrigger()
                local thistype this = target
call InfoEx("A")
                set this.summoner = summoner
call InfoEx("B")
                if summoner.Data.Integer.Table.Add(KEY_ARRAY, this) then
                    call InfoEx("C")
                    call summoner.Event.Add(HEAL_EVENT)
                endif
call InfoEx("D")
            endmethod
            eventMethod Event_Unlearn
                call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
            endmethod
            eventMethod Event_Learn
                call params.Unit.GetTrigger().Buffs.AddFresh(thistype.DUMMY_BUFF, params.Spell.GetLevel())
            endmethod
            static method Init takes nothing returns nothing
                set thistype.HEAL_EVENT = Event.Create(Unit.HEALED_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Heal)
                call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
                call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
                call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
                call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
                call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
            endmethod
        endstruct
    endscope
    public struct StructSummon
        implement Allocation
        implement List
        
        static Event DEATH_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
        integer amount
    FolderSummon_StructFuniculusUmbilicalis FuniculusUmbilicalis = this
    FolderSummon_StructFuniculusUmbilicalis LinkToStruct_FuniculusUmbilicalis
        eventMethod Event_Death
            local Unit summon = params.Unit.GetTrigger()
            local thistype this = summon.Data.Integer.Get(KEY)
            local integer amount = this.amount - 1
            set this.amount = amount
            call summon.Data.Integer.Remove(KEY)
            call summon.Event.Remove(DEATH_EVENT)
        endmethod
        static method Start takes Unit caster, integer level, Unit target returns nothing
            local thistype this = caster
            local integer amount = this.amount
            if (amount < thistype.MAX_AMOUNT[level]) then
                set amount = amount + 1
                local Unit summon = Unit.CreateSummon(thistype.SUMMON_UNIT_TYPE[level], caster.Owner.Get(), target.Position.X.Get(), target.Position.Y.Get(), target.Facing.Get(), thistype.DURATION[level])
                set this.amount = amount
                call summon.Data.Integer.Set(KEY, this)
                call summon.Event.Add(DEATH_EVENT)
                set thistype(NULL).FuniculusUmbilicalis.SUMMONER = caster
                call summon.Abilities.Add(thistype(NULL).FuniculusUmbilicalis.THIS_SPELL)
            endif
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Death)
            call thistype(NULL).FuniculusUmbilicalis.Init()
        endmethod
    endstruct
    public struct StructTarget
        implement Allocation
        implement List
        
        static real array DAMAGE_PER_INTERVAL
        static Event DEATH_EVENT
        static Unit CASTER
        Unit caster
        real damagePerInterval
        Timer intervalTimer
        integer level
        timerMethod Interval
            local thistype this = Timer.GetExpired().GetData()
            local Unit target = this
            local Unit caster = this.caster
            call caster.DamageUnitBySpell(target, this.damagePerInterval, true, false)
        endmethod
        eventMethod Event_Death
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            call INFECTION.Summon.Start(this.caster, this.level, target)
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            local Timer intervalTimer = this.intervalTimer
            call intervalTimer.Destroy()
            call target.Event.Remove(DEATH_EVENT)
        endmethod
        eventMethod Event_BuffGain
            local Unit caster = thistype.CASTER
            local integer level = params.Buff.GetLevel()
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
			local Timer intervalTimer = Timer.Create()
            set this.caster = caster
            set this.damagePerInterval = thistype.DAMAGE_PER_INTERVAL[level]
            set this.intervalTimer = intervalTimer
            set this.level = level
            call target.Event.Add(DEATH_EVENT)
            call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
        endmethod
        static method Start takes Unit caster, integer level, Unit target returns nothing
            set thistype.CASTER = caster
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION[level])
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Death)
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            local integer iteration = Infection.THIS_SPELL.GetLevelsAmount()
            loop
                set thistype.DAMAGE_PER_INTERVAL[iteration] = thistype.DAMAGE_TOTAL[iteration] / Real.ToInt(thistype.DURATION[iteration] / thistype.INTERVAL)
                set iteration = iteration - 1
                exitwhen (iteration < 1)
            endloop
        endmethod
    endstruct
endscope
    globals
        Infection INFECTION = STRUCT_BASE
    endglobals
    struct Infection
        implement Allocation
        implement List
        
    static Event DAMAGE_EVENT
    integer level
    FolderInfection_StructCone Cone = this
    FolderInfection_StructCone LinkToStruct_Cone
    FolderInfection_StructSummon Summon = this
    FolderInfection_StructSummon LinkToStruct_Summon
    FolderInfection_StructTarget Target = this
    FolderInfection_StructTarget LinkToStruct_Target
    eventMethod Event_Damage
        local Unit caster = params.Unit.GetDamager()
        local Unit target = params.Unit.GetTrigger()
        if target.IsAllyOf(caster.Owner.Get()) then
            return
        endif
        local thistype this = caster
        local integer level = this.level
        call thistype(NULL).Target.Start(caster, level, target)
        
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        call target.Event.Remove(DAMAGE_EVENT)
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        set this.level = level
        call target.Event.Add(DAMAGE_EVENT)
    endmethod
    eventMethod Event_SpellEffect
        local integer level = params.Spell.GetLevel()
        call params.Unit.GetTrigger().Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION[level])
    endmethod
    initMethod Init of Spells_Hero
        set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Cone.Init()
        call thistype(NULL).Target.Init()
        call thistype(NULL).Summon.Init()
    endmethod
endstruct
    scope FolderKhakiRecovery
    public struct StructRestoration
        implement Allocation
        implement List
        
        static Event DEATH_EVENT
        real lifeHeal
        real manaHeal
        eventMethod Event_Death
            local Unit caster = params.Unit.GetKiller()
            local thistype this = caster
            call caster.Effects.Create(thistype.CASTER_EFFECT_PATH, thistype.CASTER_EFFECT_ATTACH_POINT, EffectLevel.LOW).DestroyTimed.Start(2.)
            call caster.HealBySpell(caster, this.lifeHeal)
            call caster.HealManaBySpell(caster, this.manaHeal)
        endmethod
        eventMethod Event_BuffLose
            call params.Unit.GetTrigger().Event.Remove(DEATH_EVENT)
        endmethod
        eventMethod Event_BuffGain
            local integer level = params.Buff.GetLevel()
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            set this.lifeHeal = thistype.LIFE_HEAL[level]
            set this.manaHeal = thistype.MANA_HEAL[level]
            call target.Event.Add(DEATH_EVENT)
        endmethod
        eventMethod Event_Unlearn
            call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
        endmethod
        eventMethod Event_Learn
            call params.Unit.GetTrigger().Buffs.AddFresh(thistype.DUMMY_BUFF, params.Spell.GetLevel())
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.KILLER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Death)
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            call KhakiRecovery.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
            call KhakiRecovery.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
            call KhakiRecovery.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
        endmethod
    endstruct
endscope
    globals
        KhakiRecovery KHAKI_RECOVERY = STRUCT_BASE
    endglobals
    struct KhakiRecovery
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    real areaRange
    Unit caster
    Timer delayTimer
    real heal
    Unit lastTarget
    integer level
    UnitList targetGroup
    integer targetsAmount
    integer targetsAmountMax
    FolderKhakiRecovery_StructRestoration Restoration = this
    FolderKhakiRecovery_StructRestoration LinkToStruct_Restoration
    method Ending takes Timer delayTimer returns nothing
        call this.deallocate()
        call delayTimer.Destroy()
        call this.targetGroup.Destroy()
    endmethod
    method Impact takes Unit caster, integer level, Unit lastTarget, Unit newTarget, integer targetsAmount returns nothing
        local Lightning effectLightning = Lightning.CreatePrimarySecondary((targetsAmount == 0), thistype.BOLT_PRIMARY, thistype.BOLT_SECONDARY)
        local real heal = this.heal * (1. + thistype.HEAL_ADD_FACTOR * (targetsAmount - 1))
        set this.lastTarget = newTarget
        call this.targetGroup.Add(newTarget)
        call newTarget.Effects.Create(thistype.VORTEX_TARGET_EFFECT_PATH, thistype.VORTEX_TARGET_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
		call newTarget.Buffs.Timed.Start(thistype.MOVE_SPEED_BUFF, level, thistype.MOVE_SPEED_BUFF_DURATION[level])
        call caster.HealBySpell(newTarget, heal)
        if (targetsAmount != 0) then
            call effectLightning.SetColor(0, 255, 0, 255)
        endif
        call effectLightning.FromUnitToUnit.Start(lastTarget, newTarget)
        call newTarget.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.LOW).DestroyTimed.Start(2.)
        call effectLightning.DestroyTimed.Start(0.75)
    endmethod
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if UnitList.TEMP.Contains(target) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.NEUTRAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if not target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    timerMethod ChooseNewTargetByTimer
        local Timer delayTimer = Timer.GetExpired()
        local thistype this = delayTimer.GetData()
        local UnitList targetGroup = this.targetGroup
        local integer targetsAmount = this.targetsAmount + 1
        if (targetsAmount > this.targetsAmountMax) then
            call this.Ending(delayTimer)
        else
            local Unit caster = this.caster
            local Unit lastTarget = this.lastTarget
            local real lastTargetX = lastTarget.Position.X.Get()
            local real lastTargetY = lastTarget.Position.Y.Get()
            set UnitList.TEMP = targetGroup
            set User.TEMP = caster.Owner.Get()
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(lastTargetX, lastTargetY, this.areaRange, thistype.TARGET_FILTER)
            local Unit newTarget = thistype.ENUM_GROUP.GetNearest(lastTargetX, lastTargetY)
            if (newTarget == NULL) then
                call this.Ending(delayTimer)
            else
                set this.targetsAmount = targetsAmount
                call this.Impact(caster, this.level, lastTarget, newTarget, targetsAmount - 1)
            endif
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        local thistype this = thistype.allocate()
		local Timer delayTimer = Timer.Create()
        local UnitList targetGroup = UnitList.Create()
        set this.areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        set this.caster = caster
        set this.delayTimer = delayTimer
        set this.heal = thistype.HEAL[level]
        set this.lastTarget = target
        set this.level = level
        set this.targetGroup = targetGroup
        set this.targetsAmount = 1
        set this.targetsAmountMax = thistype.TARGETS_AMOUNT[level]
        call delayTimer.SetData(this)
        call caster.Effects.Create(thistype.CASTER_EFFECT_PATH, thistype.CASTER_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
        call delayTimer.Start(thistype.DELAY, true, function thistype.ChooseNewTargetByTimer)
        call this.Impact(caster, level, caster, target, 0)
        call target.Buffs.Dispel(true, false, true)
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Restoration.Init()
    endmethod
endstruct
    globals
        ManaColossus MANA_COLOSSUS = STRUCT_BASE
    endglobals
    struct ManaColossus
        implement Allocation
        implement List
        
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local User casterOwner = caster.Owner.Get()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real angle = caster.Facing.Get()
        local Unit summon = Unit.CreateSummon(thistype.THIS_UNIT_TYPES[level], casterOwner, casterX + thistype.OFFSET * Math.Cos(angle), casterY + thistype.OFFSET * Math.Sin(angle), angle, thistype.DURATION[level])
        call summon.Abilities.AddWithLevel(TheurgicVessel.THIS_SPELL, level)
    endmethod
    initMethod Init of Spells_Hero
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    scope FolderTheurgicVessel
    public struct StructTarget
        implement Allocation
        implement List
        
    	static Event ENDING_EVENT
        static Event START_EVENT
		eventMethod Event_Ending
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local TheurgicVessel parent = aura.GetData()
			call target.Buffs.Subtract(thistype.DUMMY_BUFF)
		endmethod
		eventMethod Event_Start
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local Unit caster = aura.GetCaster()
			local TheurgicVessel parent = aura.GetData()
			local integer level = parent.level
			call target.Buffs.Add(thistype.DUMMY_BUFF, level)
		endmethod
        static method Init takes nothing returns nothing
            set thistype.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Ending)
            set thistype.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Start)
        endmethod
    endstruct
endscope
    globals
        TheurgicVessel THEURGIC_VESSEL = STRUCT_BASE
    endglobals
    struct TheurgicVessel
        implement Allocation
        implement List
        
    static BoolExpr TARGET_FILTER
	Aura aura
    Unit caster
    integer level
    FolderTheurgicVessel_StructTarget Target = this
    FolderTheurgicVessel_StructTarget LinkToStruct_Target
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if not target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_BuffLose
        local Unit caster = params.Unit.GetTrigger()
        local thistype this = caster
		local Aura aura = this.aura
		call aura.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Buff.GetLevel()
        local thistype this = caster
		local Aura aura = Aura.Create(caster)
		set this.aura = aura
        set this.caster = caster
        set this.level = level
        call aura.SetData(this)
		call aura.SetAreaRange(thistype.THIS_SPELL.GetAreaRange(level))
        call aura.SetTargetFilter(thistype.TARGET_FILTER)
		call aura.Event.Add(thistype(NULL).Target.ENDING_EVENT)
		call aura.Event.Add(thistype(NULL).Target.START_EVENT)
		call aura.Enable()
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.AddFresh(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Elemental
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
		call thistype(NULL).Target.Init()
    endmethod
endstruct
    scope FolderManaLaser
    public struct StructRevert
        implement Allocation
        implement List
        
        static real X
        static real Y
        SpotEffect sourceEffect
        real x
        real y
        eventMethod Event_SpellEffect
            local Unit caster = params.Unit.GetTrigger()
            local thistype this = caster
            local real x = this.x
            local real y = this.y
            call caster.Buffs.Remove(thistype.DUMMY_BUFF)
            call Spot.CreateEffect(caster.Position.X.Get(), caster.Position.Y.Get(), thistype.CAST_EFFECT_PATH, EffectLevel.LOW).Destroy()
            call caster.Position.SetXYZ(x, y, Spot.GetHeight(x, y))
            call Spot.CreateEffect(x, y, thistype.CAST_END_EFFECT_PATH, EffectLevel.LOW).Destroy()
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            local SpotEffect sourceEffect = this.sourceEffect
            call sourceEffect.Destroy()
            call HeroSpell.AddToUnit(ManaLaser.THIS_SPELL, target)
        endmethod
        eventMethod Event_BuffGain
            local Unit target = params.Unit.GetTrigger()
            local real x = thistype.X
            local real y = thistype.Y
            local thistype this = target
            set this.sourceEffect = Spot.CreateEffect(x, y, thistype.SOURCE_EFFECT_PATH, EffectLevel.LOW)
            set this.x = x
            set this.y = y
            call HeroSpell.AddToUnit(thistype.THIS_SPELL, target)
        endmethod
        static method Start takes Unit target, real x, real y returns nothing
            set thistype.X = x
            set thistype.Y = y
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, thistype.DURATION)
        endmethod
        static method Init takes nothing returns nothing
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        endmethod
    endstruct
endscope
    globals
        ManaLaser MANA_LASER = STRUCT_BASE
    endglobals
    struct ManaLaser
        implement Allocation
        implement List
        
    static real array DURATION
    static Group ENUM_GROUP
    static real array LENGTH
    static BoolExpr TARGET_FILTER
    static constant real UPDATE_TIME = (1 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (1 * 1.))
    real areaRange
    real burnedManaMax
    Unit caster
    integer dispelledTargetsAmount
    integer dispelledTargetsAmountMax
    DummyUnit dummyUnit
    Timer durationTimer
    UnitList targetGroup
    Timer updateTimer
    real xAdd
    real yAdd
    FolderManaLaser_StructRevert Revert = this
    FolderManaLaser_StructRevert LinkToStruct_Revert
    timerMethod Ending
        local Timer durationTimer = Timer.GetExpired()
        local thistype this = durationTimer.GetData()
        local Unit caster = this.caster
        local DummyUnit dummyUnit = this.dummyUnit
        local UnitList targetGroup = this.targetGroup
        local Timer updateTimer = this.updateTimer
        local real x = dummyUnit.Position.X.Get()
        local real y = dummyUnit.Position.Y.Get()
        local real z = dummyUnit.Position.Z.Get()
        call this.deallocate()
        call dummyUnit.Destroy()
        call durationTimer.Destroy()
        call targetGroup.Destroy()
        call updateTimer.Destroy()
        call caster.Transport.Subtract()
        call caster.Position.SetXYZ(x, y, Spot.GetHeight(x, y))
    endmethod
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if UnitList.TEMP.Contains(target) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    timerMethod Move
        local thistype this = Timer.GetExpired().GetData()
        local real areaRange = this.areaRange
        local real burnedManaMax = this.burnedManaMax
        local Unit caster = this.caster
        local DummyUnit dummyUnit = this.dummyUnit
        local UnitList targetGroup = this.targetGroup
        local real x = dummyUnit.Position.X.Get() + this.xAdd
        local real y = dummyUnit.Position.Y.Get() + this.yAdd
        call dummyUnit.Position.Set(x, y, Spot.GetHeight(x, y) + thistype.HEIGHT)
        set User.TEMP = caster.Owner.Get()
        set UnitList.TEMP = targetGroup
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, areaRange, thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local integer dispelledTargetsAmount = this.dispelledTargetsAmount
            local integer dispelledTargetsAmountMax = this.dispelledTargetsAmountMax
            loop
                local Lightning effectLightning = Lightning.Create(thistype.BOLT)
                call targetGroup.Add(target)
                call effectLightning.FromDummyUnitToUnit.Start(dummyUnit, UNIT_TYPE.Outpact.Z.STANDARD, target)
                call effectLightning.DestroyTimed.Start(0.35)
                call target.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
                if not target.MagicImmunity.Try() then
                    local real targetMana = target.Mana.Get()
                    local real burnedMana = Math.Min(targetMana, burnedManaMax)
                    call caster.BurnManaBySpell(target, burnedMana)
                    if (dispelledTargetsAmount < dispelledTargetsAmountMax) then
                        set dispelledTargetsAmount = dispelledTargetsAmount + 1
                        call target.Buffs.Timed.Start(Purge.DUMMY_BUFF, 1, Purge.DURATION)
                        call target.Buffs.Dispel(false, true, true)
                        set this.dispelledTargetsAmount = dispelledTargetsAmount
                    endif
                endif
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local real angle = caster.CastAngle(targetX - casterX, targetY - casterY)
		local real partX = Math.Cos(angle)
        local real partY = Math.Sin(angle)
        local real startX = casterX + thistype.START_OFFSET * partX
        local real startY = casterY + thistype.START_OFFSET * partY
		local thistype this = thistype.allocate()
        local DummyUnit dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, startX, startY, Spot.GetHeight(startX, startY) + thistype.HEIGHT, angle)
        local Timer durationTimer = Timer.Create()
        local Timer updateTimer = Timer.Create()
        set this.areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        set this.burnedManaMax = thistype.BURNED_MANA_MAX[level]
        set this.caster = caster
        set this.dispelledTargetsAmount = 0
        set this.dispelledTargetsAmountMax = thistype.DISPELLED_TARGETS_AMOUNT[level]
        set this.dummyUnit = dummyUnit
        set this.durationTimer = durationTimer
        set this.targetGroup = UnitList.Create()
        set this.updateTimer = updateTimer
        set this.xAdd = thistype.LENGTH[level] * partX
        set this.yAdd = thistype.LENGTH[level] * partY
        call durationTimer.SetData(this)
        call updateTimer.SetData(this)
        call caster.Transport.Add()
        call updateTimer.Start(thistype.UPDATE_TIME, true, function thistype.Move)
        call durationTimer.Start(thistype.DURATION[level], false, function thistype.Ending)
        call thistype(NULL).Revert.Start(caster, casterX, casterY)
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        local integer iteration = thistype.THIS_SPELL.GetLevelsAmount()
        loop
            set thistype.DURATION[iteration] = thistype.MAX_LENGTH[iteration] / thistype.SPEED[iteration]
            set thistype.LENGTH[iteration] = thistype.SPEED[iteration] * thistype.UPDATE_TIME
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        call thistype(NULL).Revert.Init()
    endmethod
endstruct
    scope FolderMassMimesis
    public struct StructCharm
        implement Allocation
        implement List
        
    	eventMethod Event_SpellEffect
    		local Unit caster = params.Unit.GetTrigger()
    	    local integer level = params.Buff.GetLevel()
	        local Unit target = params.Unit.GetTarget()
			local MassMimesis parent = caster
			if ((caster != target) and target.Classes.Contains(UnitClass.HERO)) then
				return
			endif
			call Spot.CreateEffectWithSize(target.Position.X.Get(), target.Position.Y.Get(), thistype.SOURCE_EFFECT_PATH, EffectLevel.LOW, target.Scale.Get()).Destroy()
			call target.Position.SetWithCollision(parent.targetX, parent.targetY)
			call Spot.CreateEffectWithSize(target.Position.X.Get(), target.Position.Y.Get(), thistype.TARGET_EFFECT_PATH, EffectLevel.LOW, target.Scale.Get()).Destroy()
        endmethod
		static method Init takes nothing returns nothing
			call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
		endmethod
	endstruct
    public struct StructMissile
        implement Allocation
        implement List
        
        Unit caster
        integer level
        real targetX
        real targetY
        eventMethod Impact
            local Missile dummyMissile = params.Missile.GetTrigger()
            local thistype this = dummyMissile.GetData()
            local Unit caster = this.caster
            local integer level = this.level
            local real targetX = this.targetX
            local real targetY = this.targetY
            call this.deallocate()
            call dummyMissile.Destroy()
            set MassMimesis.TARGET_X = targetX
            set MassMimesis.TARGET_Y = targetY
            call caster.Buffs.Timed.Start(MassMimesis.DUMMY_BUFF, level, MassMimesis.DURATION[level])
        endmethod
        static method Start takes Unit caster, integer level, real targetX, real targetY returns nothing
            local thistype this = thistype.allocate()
			local Missile dummyMissile = Missile.Create()
            set this.caster = caster
            set this.level = level
            set this.targetX = targetX
            set this.targetY = targetY
            call dummyMissile.Acceleration.Set(2000.)
            call dummyMissile.Arc.SetByPerc(0.2)
            call dummyMissile.CollisionSize.Set(48.)
            call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1.)
            call dummyMissile.Impact.SetAction(function thistype.Impact)
            call dummyMissile.SetData(this)
            call dummyMissile.Speed.Set(500.)
            call dummyMissile.Position.SetFromUnit(caster)
            call dummyMissile.GoToSpot.Start(targetX, targetY, Spot.GetHeight(targetX, targetY))
        endmethod
    endstruct
endscope
    globals
        MassMimesis MASS_MIMESIS = STRUCT_BASE
    endglobals
    struct MassMimesis
        implement Allocation
        implement List
        
	static Event ANY_CAST_EVENT
    static real TARGET_X
    static real TARGET_Y
    real areaRange
    DummyUnit dummyUnit
    DummyUnit dummyUnit2
    integer level
    UnitList targetGroup
    real targetX
    real targetY
    FolderMassMimesis_StructCharm Charm = this
    FolderMassMimesis_StructCharm LinkToStruct_Charm
    FolderMassMimesis_StructMissile Missile = this
    FolderMassMimesis_StructMissile LinkToStruct_Missile
	static method AnyCast_Conditions takes Unit caster, Unit target returns boolean
		if (target.Classes.Contains(UnitClass.HERO) and not target.IsAllyOf(caster.Owner.Get())) then
			return false
		endif
		if target.Classes.Contains(UnitClass.ILLUSION) then
			return false
		endif
		if target.Classes.Contains(UnitClass.STRUCTURE) then
			return false
		endif
		if target.Classes.Contains(UnitClass.WARD) then
			return false
		endif
		return true
	endmethod
	eventMethod Event_AnyCast
		local Unit caster = params.Unit.GetTrigger()
		local Unit target = params.Unit.GetTarget()
		local Spell whichSpell = params.Spell.GetTrigger()
		if (target == NULL) then
			return
		endif
		if not thistype.AnyCast_Conditions(caster, target) then
			return
		endif
		local thistype this = caster
		local UnitList targetGroup = this.targetGroup
		if targetGroup.Contains(target) then
			return
		endif
		call targetGroup.Add(target)
		local integer level = this.level
		local real illuX = this.targetX
		local real illuY = this.targetY
		local real targetX = target.Position.X.Get()
		local real targetY = target.Position.Y.Get()
		local real dX = targetX - illuX
		local real dY = targetY - illuY
		local Unit illu = Unit.CreateIllusion(target.Type.Get(), caster.Owner.Get(), this.targetX, this.targetY, Math.AtanByDeltas(dY, dX), thistype.SUMMON_DURATION[level], thistype.SUMMON_DEATH_EFFECT_PATH)
		call illu.Effects.Create(thistype.SUMMON_BIRTH_EFFECT_PATH, thistype.SUMMON_BIRTH_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
		call illu.Ghost.Add()
		call illu.Pathing.Subtract()
		call illu.Abilities.Add(Invulnerability.THIS_SPELL)
		call illu.Order.PointTarget(Order.ATTACK, targetX, targetY)
	endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local DummyUnit dummyUnit = this.dummyUnit
        local DummyUnit dummyUnit2 = this.dummyUnit2
        local UnitList targetGroup = this.targetGroup
        call dummyUnit.DestroyInstantly()
        call dummyUnit2.Destroy()
        call targetGroup.Destroy()
		call target.Event.Remove(ANY_CAST_EVENT)
		call HeroSpell.AddToUnit(thistype.THIS_SPELL, target)
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local real targetX = thistype.TARGET_X
        local real targetY = thistype.TARGET_Y
        local real areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        local real targetZ = Spot.GetHeight(targetX, targetY)
        local thistype this = target
        local DummyUnit dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, targetX, targetY, targetZ, 0.)
        local DummyUnit dummyUnit2 = DummyUnit.Create(thistype.DUMMY_UNIT2_ID, targetX, targetY, targetZ, 0.)
        set this.areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        set this.dummyUnit = dummyUnit
        set this.dummyUnit2 = dummyUnit2
        set this.level = level
        set this.targetGroup = UnitList.Create()
        set this.targetX = targetX
        set this.targetY = targetY
		call target.Event.Add(ANY_CAST_EVENT)
        
        
        
        
		call HeroSpell.AddToUnit(thistype(NULL).Charm.THIS_SPELL, target)
    endmethod
    eventMethod Event_SpellEffect
        call thistype(NULL).Missile.Start(params.Unit.GetTrigger(), params.Spell.GetLevel(), params.Spot.GetTargetX(), params.Spot.GetTargetY())
    endmethod
    initMethod Init of Spells_Hero
    	set thistype.ANY_CAST_EVENT = Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_AnyCast)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        local integer iteration = thistype.THIS_SPELL.GetLevelsAmount()
        loop
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
		call thistype(NULL).Charm.Init()
    endmethod
endstruct
    globals
        MountainKing MOUNTAIN_KING = STRUCT_BASE
    endglobals
    struct MountainKing
        implement Allocation
        implement List
        
	UnitModSet mods
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
		local UnitModSet mods = this.mods
        call target.Animation.Remove(UNIT.Animation.ALTERNATE)
        call target.ModSets.Remove(mods)
		call mods.Destroy()
		call HeroSpell.ReplaceSlot(SpellClass.HERO_ULTIMATE, thistype.THIS_SPELL, target)
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local real spellPower = target.SpellPower.Get()
        local thistype this = target
		local UnitModSet mods = UnitModSet.Create() 
		set this.mods = mods
        
        call mods.RealMods.Add(UNIT.LifeLeech.STATE, spellPower * thistype.LIFE_LEECH_INC_SPELL_POWER_MOD)
        call target.Animation.Add(UNIT.Animation.ALTERNATE)
        call target.ModSets.Add(mods)
		call HeroSpell.ReplaceSlot(SpellClass.HERO_ULTIMATE, Thunderbringer.THIS_SPELL, target)
    endmethod
    eventMethod Event_SpellEffect
        local integer level = params.Spell.GetLevel()
        call params.Unit.GetTrigger().Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION[level])
    endmethod
    initMethod Init of Spells_Hero
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        Thunderbringer THUNDERBRINGER = STRUCT_BASE
    endglobals
    struct Thunderbringer
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    static method Conditions takes nothing returns boolean
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        local real x = target.Position.X.Get()
        local real y = target.Position.Y.Get()
        call caster.Effects.Create(thistype.CASTER_SPECIAL_EFFECT_PATH, thistype.CASTER_SPECIAL_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
        call Spot.CreateEffect(x, y, thistype.SPECIAL_EFFECT_PATH, EffectLevel.NORMAL).Destroy()
        call Spot.CreateEffect(x, y, thistype.SPECIAL_EFFECT2_PATH, EffectLevel.NORMAL).Destroy()
        
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, thistype.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
        set target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real damage = caster.Damage.Get() + thistype.DAMAGE[level]
            local real stunDuration = thistype.STUN_DURATION[level]
            loop
                call target.Buffs.Timed.Start(UNIT.Stun.NORMAL_BUFF, level, stunDuration)
                call caster.DamageUnitBySpell(target, damage, true, false)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    initMethod Init of Spells_Artifacts
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        NegationWave NEGATION_WAVE = STRUCT_BASE
    endglobals
    struct NegationWave
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    real areaRange
    Unit caster
    real damage
    Timer delayTimer
    Unit lastTarget
    integer level
    UnitList targetGroup
    integer targetsAmount
    integer targetsAmountMax
    method Ending takes nothing returns nothing
        call this.deallocate()
        call this.delayTimer.Destroy()
        call this.targetGroup.Destroy()
    endmethod
    method Impact takes Unit lastTarget, Unit newTarget, integer targetsAmount returns nothing
        local Lightning effectLightning = Lightning.Create(thistype.BOLT)
        set this.lastTarget = newTarget
        call effectLightning.FromUnitToUnit.Start(lastTarget, newTarget)
        call newTarget.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.LOW).DestroyTimed.Start(2.)
        call this.targetGroup.Add(newTarget)
        call effectLightning.DestroyTimed.Start(0.75)
		local real silenceDuration
		if newTarget.Classes.Contains(UnitClass.HERO) then
			set silenceDuration = thistype.SILENCE_HERO_DURATION[level]
		else
			set silenceDuration = thistype.SILENCE_DURATION[level]
		endif
        call newTarget.Buffs.Timed.Start(thistype.SILENCE_BUFF, this.level, silenceDuration)
        call caster.DamageUnitBySpell(newTarget, damage, true, false)
    endmethod
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if UnitList.TEMP.Contains(target) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.NEUTRAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    timerMethod ChooseNewTargetByTimer
        local Timer delayTimer = Timer.GetExpired()
        local thistype this = delayTimer.GetData()
        local UnitList targetGroup = this.targetGroup
        local integer targetsAmount = this.targetsAmount + 1
        if (targetsAmount > this.targetsAmountMax) then
            call this.Ending()
        else
            local Unit caster = this.caster
            local Unit lastTarget = this.lastTarget
            local real lastTargetX = lastTarget.Position.X.Get()
            local real lastTargetY = lastTarget.Position.Y.Get()
            set UnitList.TEMP = targetGroup
            set User.TEMP = caster.Owner.Get()
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(lastTargetX, lastTargetY, this.areaRange, thistype.TARGET_FILTER)
            local Unit newTarget = thistype.ENUM_GROUP.GetNearest(lastTargetX, lastTargetY)
            if (newTarget == NULL) then
                call this.Ending()
            else
                set this.targetsAmount = targetsAmount
                call this.Impact(lastTarget, newTarget, targetsAmount - 1)
            endif
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
		call caster.Effects.Create(thistype.CASTER_EFFECT_PATH, thistype.CASTER_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
        local thistype this = thistype.allocate()
        local Timer delayTimer = Timer.Create()
        set this.areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        set this.caster = caster
        set this.damage = thistype.DAMAGE[level]
        set this.delayTimer = delayTimer
        set this.lastTarget = target
        set this.level = level
        set this.targetGroup = UnitList.Create()
        set this.targetsAmount = 1
        set this.targetsAmountMax = thistype.TARGETS_AMOUNT[level]
        call delayTimer.SetData(this)
        call delayTimer.Start(thistype.DELAY, true, function thistype.ChooseNewTargetByTimer)
        call this.Impact(caster, target, 0)
        call caster.Buffs.Steal(target, false, true, level)
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call UNIT.Silence.NORMAL_BUFF.Variants.Add(thistype.SILENCE_BUFF)
    endmethod
endstruct
    scope FolderNurturingGrounds
    public struct StructEgg
        implement Allocation
        implement List
        
		static Event HEAL_EVENT
		eventMethod Event_Heal
			local Unit egg = params.Unit.GetTrigger()
			local integer level = egg.Buffs.GetLevel(thistype.DUMMY_BUFF)
			call egg.Buffs.Remove(thistype.DUMMY_BUFF)
			call egg.Type.SetWithChangerAbility(thistype.TREANT[level], thistype.CHANGER_ABILITY_ID[level])
		endmethod
		eventMethod Event_BuffLose
			local Unit egg = params.Unit.GetTrigger()
			call egg.Event.Remove(HEAL_EVENT)
		endmethod
		eventMethod Event_BuffGain
			local Unit egg = params.Unit.GetTrigger()
			call egg.Event.Add(HEAL_EVENT)
		endmethod
		static method Create takes real x, real y, Unit caster, integer level returns nothing
			local Unit summon = Unit.Create(thistype.EGG, caster.Owner.Get(), x, y, UNIT.Facing.STANDARD)
            call summon.Classes.Add(UnitClass.SUMMON)
            call summon.ApplyTimedLife(thistype.DURATION[level])
			call summon.Buffs.Add(thistype.DUMMY_BUFF, level)
			call summon.Animation.Set(Animation.BIRTH)
		endmethod
		static method Init takes nothing returns nothing
			set thistype.HEAL_EVENT = Event.Create(Unit.HEALED_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Heal)
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
		endmethod
	endstruct
endscope
    globals
        NurturingGrounds NURTURING_GROUNDS = STRUCT_BASE
    endglobals
    struct NurturingGrounds
        implement Allocation
        implement List
        
	static Event GRASS_ENTER_EVENT
	static Event GRASS_LEAVE_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
    Unit caster
    real curLength
    Timer eggSpawnTimer
    Region grassRegion
    real lengthAdd
    integer level
    real spreadDuration
    Timer spreadEndTimer
    UnitList targetGroup
    real targetX
    real targetY
    Queue tiles
    Timer updateTimer
    FolderNurturingGrounds_StructEgg Egg = this
    FolderNurturingGrounds_StructEgg LinkToStruct_Egg
	timerMethod SpawnEggByTimer
		local thistype this = Timer.GetExpired().GetData()
		local real angle = Math.RandomAngle()
		local real length = Math.Random(0., this.curLength)
		local real x = this.targetX + length * Math.Cos(angle)
		local real y = this.targetY + length * Math.Sin(angle)
		call thistype(NULL).Egg.Create(x, y, this.caster, this.level)
	endmethod
	eventMethod Event_GrassLeave
		local Unit target = params.Unit.GetTrigger()
		local Region whichRegion = params.Region.GetTrigger()
		local thistype this = whichRegion.Data.Integer.Get(KEY)
		if not this.targetGroup.Contains(target) then
			return
		endif
		call this.targetGroup.Remove(target)
		call target.Buffs.Subtract(thistype.POISON_BUFF)
	endmethod
	eventMethod Event_GrassEnter
		local Unit target = params.Unit.GetTrigger()
		local Region whichRegion = params.Region.GetTrigger()
		local thistype this = whichRegion.Data.Integer.Get(KEY)
		if target.IsAllyOf(this.caster.Owner.Get()) then
			return
		endif
		call this.targetGroup.Add(target)
		call target.Buffs.Add(thistype.POISON_BUFF, level)
	endmethod
    method SpawnGrass takes real x, real y, real duration returns nothing
        local Tile val = Tile.GetFromCoords(x, y)
        if this.tiles.Contains(val) then
            call val.RemoveRef()
            return
        endif
		call this.tiles.Add(val)
        call TileTypeMod.Create(x, y, TileType.GRASS).DestroyTimed.Start(duration)
		call this.grassRegion.AddCells(x - Tile.CELL_DIST / 2, y - Tile.CELL_DIST / 2, x + Tile.CELL_DIST / 2, y + Tile.CELL_DIST / 2)
    endmethod
	timerMethod Spread
		local thistype this = Timer.GetExpired().GetData()
		local real curLength = this.curLength + this.lengthAdd
		set this.curLength = curLength
		local real targetX = this.targetX
		local real targetY = this.targetY
		local real xStart = targetX - curLength
		local real xEnd = targetX + curLength
		local real yStart = targetY - curLength
		local real yEnd = targetY + curLength
		local real curLengthSquare = curLength * curLength
		local real y = yStart
		loop
			exitwhen (y > yEnd)
			local real x = xStart
			loop
				exitwhen (x > xEnd)
				if (Math.DistanceSquareByDeltas(x - targetX, y - targetY) <= curLengthSquare) then
					call this.SpawnGrass(x, y, thistype.DURATION[level] + 2 * (1 - this.curLength / thistype.THIS_SPELL.GetAreaRange(level)) * thistype.SPREAD_DURATION[level])
				endif
				set x = x + Tile.CELL_DIST
			endloop
			set y = y + Tile.CELL_DIST
		endloop
	endmethod
	timerMethod EndSpread
		local Timer spreadEndTimer = Timer.GetExpired()
		local thistype this = spreadEndTimer.GetData()
		call spreadEndTimer.Pause()
		call updateTimer.Pause()
	endmethod
	timerMethod EndingByTimer
		local Timer durationTimer = Timer.GetExpired()
		local thistype this = durationTimer.GetData()
		call this.grassRegion.Clear()
		call durationTimer.Destroy()
		call this.eggSpawnTimer.Destroy()
		call this.grassRegion.Data.Integer.Remove(KEY)
		call this.grassRegion.Event.Remove(GRASS_ENTER_EVENT)
		call this.grassRegion.Event.Remove(GRASS_LEAVE_EVENT)
		call this.grassRegion.Destroy()
		call this.spreadEndTimer.Destroy()
		call this.targetGroup.Destroy()
		call this.tiles.Destroy()
		call this.updateTimer.Destroy()
		call this.deallocate()
	endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
		local real areaRange = thistype.THIS_SPELL.GetAreaRange(level)
		local real duration = thistype.DURATION[level]
		local real spreadDuration = thistype.SPREAD_DURATION[level]
		call Spot.CreateEffectWithSize(targetX, targetY, thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW, areaRange / 256).DestroyTimed.Start(2.)
		local thistype this = thistype.allocate()
		local Timer durationTimer = Timer.Create()
		local Timer eggSpawnTimer = Timer.Create()
		local Region grassRegion = Region.Create()
		local Timer spreadEndTimer = Timer.Create()
		local Timer updateTimer = Timer.Create()
		set this.caster = caster
		set this.curLength = 0.
		set this.eggSpawnTimer = eggSpawnTimer
		set this.grassRegion = grassRegion
        set this.lengthAdd = areaRange / spreadDuration * thistype.UPDATE_TIME
        set this.level = level
        set this.spreadDuration = spreadDuration
        set this.spreadEndTimer = spreadEndTimer
        set this.targetGroup = UnitList.Create()
        set this.targetX = targetX
        set this.targetY = targetY
        set this.tiles = Queue.Create()
        set this.updateTimer = updateTimer
        call durationTimer.SetData(this)
        call eggSpawnTimer.SetData(this)
        call grassRegion.Data.Integer.Set(KEY, this)
        call spreadEndTimer.SetData(this)
        call updateTimer.SetData(this)
		call grassRegion.Event.Add(GRASS_ENTER_EVENT)
		call grassRegion.Event.Add(GRASS_LEAVE_EVENT)
		call UNIT.Movement.Events.Region.InitRegion(grassRegion)
        call updateTimer.Start(thistype.UPDATE_TIME, true, function thistype.Spread)
        call spreadEndTimer.Start(spreadDuration, false, function thistype.EndSpread)
		call durationTimer.Start(duration + spreadDuration, false, function thistype.EndingByTimer)
		call eggSpawnTimer.Start((duration + spreadDuration) / (thistype.EGGS_AMOUNT[level] + 1), true, function thistype.SpawnEggByTimer)
    endmethod
    initMethod Init of Spells_Purchasable
    	set thistype.GRASS_ENTER_EVENT = Event.Create(UNIT.Movement.Events.Region.ENTER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_GrassEnter)
    	set thistype.GRASS_LEAVE_EVENT = Event.Create(UNIT.Movement.Events.Region.LEAVE_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_GrassLeave)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
		call UNIT.Poisoned.NORMAL_BUFF.Variants.Add(thistype.POISON_BUFF)
        local integer iteration = thistype.THIS_SPELL.GetLevelsAmount()
        loop
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        call thistype(NULL).Egg.Init()
    endmethod
endstruct
    scope FolderPandaPaw
    scope FolderArrival
    public struct StructTarget
        implement Allocation
        implement List
        
            static Event DEATH_EVENT
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static key GetKeyMacro_KEY_ARRAY_DETAIL
    static constant integer KEY_ARRAY_DETAIL = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY_DETAIL * Memory.IntegerKeys.Table.SIZE
            static real array LENGTH
            static real array Z_ADD_ADD
            static real array Z_ADD_START
			real damage
            PandaPaw parent
            real xAdd
            real yAdd
            real zAdd
            real zAddAdd
            method Ending takes PandaPaw parent, Unit target, UnitList targetGroup returns nothing
                call this.deallocate()
                if target.Data.Integer.Table.Remove(KEY_ARRAY, this) then
                    call target.Event.Remove(DEATH_EVENT)
                endif
                call target.Data.Integer.Remove(KEY_ARRAY_DETAIL + parent)
                call targetGroup.Remove(target)
            endmethod
            method EndingByParent takes Unit target, UnitList targetGroup returns nothing
                local PandaPaw parent = this
                set this = target.Data.Integer.Get(KEY_ARRAY_DETAIL + parent)
                call this.Ending(parent, target, targetGroup)
            endmethod
            eventMethod Event_Death
                local Unit target = params.Unit.GetTrigger()
                local integer iteration = target.Data.Integer.Table.Count(KEY_ARRAY)
                loop
                    local thistype this = target.Data.Integer.Table.Get(KEY_ARRAY, iteration)
                    local PandaPaw parent = this.parent
                    call this.Ending(parent, target, parent.targetGroup)
                    set iteration = iteration - 1
                    exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
                endloop
                call PandaPaw(NULL).Arrival.ENUM_GROUP.RemoveUnit(target)
            endmethod
            method Move takes Unit caster, Unit target returns nothing
                set this = target.Data.Integer.Get(KEY_ARRAY_DETAIL + this)
                local real zAdd = this.zAdd + this.zAddAdd
                set this.zAdd = zAdd
                call target.Position.X.Add(this.xAdd)
                call target.Position.Y.Add(this.yAdd)
                call target.Position.Z.Add(zAdd)
                if ((zAdd < 0.) and (target.Position.Z.Get() < Spot.GetHeight(target.Position.X.Get(), target.Position.Y.Get()) + thistype.IMPACT_TOLERANCE)) then
                    local integer level = this.parent.level
                    call target.Effects.Create(thistype.IMPACT_EFFECT_PATH, thistype.IMPACT_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
                    call target.Position.Nudge()
					local real stunDuration
					if target.Classes.Contains(UnitClass.HERO) then
						set stunDuration = thistype.STUN_HERO_DURATION[level]
					else
						set stunDuration = thistype.STUN_DURATION[level]
					endif
					call target.Stun.AddTimedBy(UNIT.Stun.NORMAL_BUFF, stunDuration)
                    call caster.DamageUnitBySpell(target, this.damage, true, true)
                endif
            endmethod
			enumMethod Move_Enum
				local PandaPaw parent = params.GetData()
				call thistype(parent).Move(parent.caster, params.Unit.GetTrigger())
			endmethod
			static method MoveByParent takes PandaPaw parent returns nothing
				call parent.targetGroup.DoEx(function thistype.Move_Enum, parent)
			endmethod
            method Start takes real angle, integer level, Unit target, real targetX, real targetY returns nothing
                local PandaPaw parent = this
                set angle = Math.LimitAngle(Math.AtanByDeltas(target.Position.Y.Get() - targetY, target.Position.X.Get() - targetX), angle - thistype.MAX_ANGLE_OFFSET, angle + thistype.MAX_ANGLE_OFFSET)
                set this = thistype.allocate()
                set this.damage = thistype.DAMAGE[level] + thistype.DAMAGE_ATTACK_DAMAGE_MOD[level] * parent.whichInstance.GetDamageMod()
                set this.parent = parent
                set this.xAdd = thistype.LENGTH[level] * Math.Cos(angle)
                set this.yAdd = thistype.LENGTH[level] * Math.Sin(angle)
                set this.zAdd = thistype.Z_ADD_START[level]
                set this.zAddAdd = thistype.Z_ADD_ADD[level]
                if target.Data.Integer.Table.Add(KEY_ARRAY, this) then
                    call target.Event.Add(DEATH_EVENT)
                endif
                call target.Data.Integer.Set(KEY_ARRAY_DETAIL + parent, this)
            endmethod
            static method Init takes nothing returns nothing
                set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Death)
                local integer iteration = PandaPaw.THIS_SPELL.GetLevelsAmount()
                loop
                    set thistype.LENGTH[iteration] = thistype.MAX_LENGTH[iteration] / PandaPaw(NULL).Arrival.DURATION[iteration] * PandaPaw(NULL).Arrival.UPDATE_TIME
                    set thistype.Z_ADD_ADD[iteration] = -8. * thistype.MAX_Z[iteration] / PandaPaw(NULL).Arrival.DURATION[iteration] / PandaPaw(NULL).Arrival.DURATION[iteration] * PandaPaw(NULL).Arrival.UPDATE_TIME * PandaPaw(NULL).Arrival.UPDATE_TIME
                    set thistype.Z_ADD_START[iteration] = -PandaPaw(NULL).Arrival.DURATION[iteration] * thistype.Z_ADD_ADD[iteration] / 2 / PandaPaw(NULL).Arrival.UPDATE_TIME
                    set iteration = iteration - 1
                    exitwhen (iteration < 1)
                endloop
            endmethod
        endstruct
    endscope
    public struct StructArrival
        implement Allocation
        implement List
        
        static Group ENUM_GROUP
        static BoolExpr TARGET_FILTER
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
        static Timer UPDATE_TIMER
    static thistype array ACTIVE_LIST_ALL
    static integer ACTIVE_LIST_ALL_COUNT = ARRAY_EMPTY
    integer ACTIVE_LIST_index
    static method ACTIVE_LIST_Count takes nothing returns integer
        return thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static method ACTIVE_LIST_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Get takes integer index returns thistype
        return thistype.ACTIVE_LIST_ALL[index]
    endmethod
    static method ACTIVE_LIST_GetIndex takes thistype this returns integer
        return this.ACTIVE_LIST_index
    endmethod
    static method ACTIVE_LIST_Contains takes thistype this returns boolean
        return (thistype.ACTIVE_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ACTIVE_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ACTIVE_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ACTIVE_LIST_RandomAll takes nothing returns thistype
        return thistype.ACTIVE_LIST_Random(ARRAY_MIN, thistype.ACTIVE_LIST_ALL_COUNT)
    endmethod
    static method ACTIVE_LIST_Remove takes thistype this returns boolean
        if not thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT].ACTIVE_LIST_index = this.ACTIVE_LIST_index
        set thistype.ACTIVE_LIST_ALL[this.ACTIVE_LIST_index - 1] = thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT]
        set this.ACTIVE_LIST_index = ARRAY_MIN
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT - 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Add takes thistype this returns boolean
        if thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT + 1
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT] = this
        set this.ACTIVE_LIST_index = thistype.ACTIVE_LIST_ALL_COUNT + 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static thistype array FOR_EACH_LIST_ALL
    static integer FOR_EACH_LIST_ALL_COUNT = ARRAY_EMPTY
    static method FOR_EACH_LIST_FetchFirst takes nothing returns thistype
        local thistype result
        if (thistype.FOR_EACH_LIST_ALL_COUNT < ARRAY_MIN) then
            return NULL
        endif
        set result = thistype.FOR_EACH_LIST_ALL[ARRAY_MIN]
        set thistype.FOR_EACH_LIST_ALL[ARRAY_MIN] = thistype.FOR_EACH_LIST_ALL[thistype.FOR_EACH_LIST_ALL_COUNT]
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.FOR_EACH_LIST_ALL_COUNT - 1
        return result
    endmethod
    static method FOR_EACH_LIST_Set takes nothing returns nothing
        local integer iteration = thistype.ACTIVE_LIST_ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.FOR_EACH_LIST_ALL[iteration] = thistype.ACTIVE_LIST_ALL[iteration]
            set iteration = iteration - 1
        endloop
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    FolderArrival_StructTarget Target = this
    FolderArrival_StructTarget LinkToStruct_Target
        timerMethod Update
            call thistype.FOR_EACH_LIST_Set()
            loop
                local thistype this = thistype.FOR_EACH_LIST_FetchFirst()
                exitwhen (this == NULL)
                local PandaPaw parent = this
                local Unit caster = parent.caster
                local UnitList targetGroup = parent.targetGroup
				local Unit target
				call thistype(NULL).Target.MoveByParent(parent)
               
            endloop
        endmethod
        method ClearTargetGroup takes UnitList targetGroup returns nothing
            loop
                local Unit target = targetGroup.GetFirst()
                exitwhen (target == NULL)
                call this.Target.EndingByParent(target, targetGroup)
            endloop
        endmethod
        timerMethod Ending
            local Timer durationTimer = Timer.GetExpired()
            local thistype this = durationTimer.GetData()
            local PandaPaw parent = PandaPaw(this)
            local UnitList targetGroup = parent.targetGroup
            local SpellInstance whichInstance = parent.whichInstance
            call this.ClearTargetGroup(targetGroup)
            call durationTimer.Destroy()
            call targetGroup.Destroy()
            if thistype.ACTIVE_LIST_Remove(this) then
                call thistype.UPDATE_TIMER.Destroy()
            endif
			call whichInstance.Refs.Subtract()
        endmethod
        condMethod Conditions
            local Unit target = UNIT.Event.Native.GetFilter()
            if (Math.AngleDifference(Math.AtanByDeltas(target.Position.Y.Get() - TEMP_REAL2, target.Position.X.Get() - TEMP_REAL), TEMP_REAL3) > Math.QUARTER_ANGLE) then
                return false
            endif
            if target.Classes.Contains(UnitClass.DEAD) then
                return false
            endif
            if target.Classes.Contains(UnitClass.STRUCTURE) then
                return false
            endif
            if target.IsAllyOf(User.TEMP) then
                return false
            endif
            return true
        endmethod
        method Start takes real angle, Unit caster, integer level, real targetX, real targetY, SpellInstance whichInstance returns nothing
            local PandaPaw parent = this
			call Ubersplat.Create(thistype.DUMMY_UBERSPLAT, targetX, targetY, 255, 255, 255, 127, false, false).DestroyTimed.Start(5.)
            call Spot.CreateEffect(targetX, targetY, thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW).Destroy()
            set targetX = targetX + thistype.PICK_OFFSET * Math.Cos(angle)
            set targetY = targetY + thistype.PICK_OFFSET * Math.Sin(angle)
            set TEMP_REAL = targetX
            set TEMP_REAL2 = targetY
            set TEMP_REAL3 = angle
            set User.TEMP = caster.Owner.Get()
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(targetX, targetY, PandaPaw.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
            local Unit target = thistype.ENUM_GROUP.FetchFirst()
			local UnitList targetGroup = parent.targetGroup
            if (target == NULL) then
                call targetGroup.Destroy()
            else
                local Timer durationTimer = Timer.Create()
                call durationTimer.SetData(this)
                loop
                    call targetGroup.Add(target)
                    call this.Target.Start(angle, level, target, targetX, targetY)
                    set target = thistype.ENUM_GROUP.FetchFirst()
                    exitwhen (target == NULL)
                endloop
                if thistype.ACTIVE_LIST_Add(this) then
                    call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
                endif
                call durationTimer.Start(thistype.DURATION[level], false, function thistype.Ending)
            endif
        endmethod
        static method Init takes nothing returns nothing
            set thistype.ENUM_GROUP = Group.Create()
            set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
            set thistype.UPDATE_TIMER = Timer.Create()
            call thistype(NULL).Target.Init()
        endmethod
    endstruct
    public struct StructLeech
        implement Allocation
        implement List
        
        eventMethod Event_Unlearn
            call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
        endmethod
        eventMethod Event_Learn
            call params.Unit.GetTrigger().Buffs.AddFresh(thistype.DUMMY_BUFF, params.Spell.GetLevel())
        endmethod
        static method Init takes nothing returns nothing
            call PandaPaw.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
            call PandaPaw.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
            call PandaPaw.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
        endmethod
    endstruct
endscope
    globals
        PandaPaw PANDA_PAW = STRUCT_BASE
    endglobals
    struct PandaPaw
        implement Allocation
        implement List
        
    static real array LENGTH
    static real array LENGTH_ADD
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
    real angle
    real animationAdd
    Unit caster
    Timer effectTimer
    real length
    real lengthAdd
    integer level
    Timer moveTimer
    UnitList targetGroup
    real targetX
    real targetY
    SpellInstance whichInstance
    FolderPandaPaw_StructArrival Arrival = this
    FolderPandaPaw_StructArrival LinkToStruct_Arrival
    FolderPandaPaw_StructLeech Leech = this
    FolderPandaPaw_StructLeech LinkToStruct_Leech
    timerMethod DoEffect
        local thistype this = Timer.GetExpired().GetData()
        local real acceleration = this.lengthAdd / thistype.UPDATE_TIME / thistype.UPDATE_TIME
        local real angle = this.angle
        local Unit caster = this
        local real p = this.length / thistype.UPDATE_TIME / acceleration
        local real targetX = this.targetX
        local real targetY = this.targetY
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real casterZ = caster.Position.Z.Get()
        local DummyUnit dummyUnit = DummyUnit.Create(caster.Type.Get().self, casterX + thistype.DUMMY_UNIT_OFFSET * Math.Cos(angle), casterY + thistype.DUMMY_UNIT_OFFSET * Math.Sin(angle), casterZ, angle)
        local real dur = -p + Math.Sqrt(p * p + 2 * Math.DistanceByDeltasWithZ(targetX - casterX, targetY - casterY, Spot.GetHeight(targetX, targetY) - casterZ) / acceleration)
        if (dur > 0.3) then
            call caster.Animation.Set(Animation.ATTACK)
            call caster.Animation.Queue(Animation.STAND)
        endif
        call dummyUnit.Abilities.AddBySelf(DummyUnit.LOCUST_SPELL_ID)
        call dummyUnit.DestroyTimed.Start(thistype.DUMMY_UNIT_DURATION)
        call dummyUnit.VertexColor.Timed.Subtract(255., 255., 255., 255., thistype.DUMMY_UNIT_DURATION)
    endmethod
    timerMethod Move        
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this
        local real length = this.length + this.lengthAdd
        local real targetX = this.targetX
        local real targetY = this.targetY
        local real targetZ = Spot.GetHeight(targetX, targetY)
        local real x = caster.Position.X.Get()
        local real y = caster.Position.Y.Get()
        local real z = caster.Position.Z.Get()
        local real dX = targetX - x
        local real dY = targetY - y
        local real dZ = targetZ - z
        local real angleXY = Math.AtanByDeltas(dY, dX)
        local real d = Math.DistanceByDeltasWithZ(dX, dY, dZ)
        local boolean reachesTarget = (d < length + thistype.ARRIVAL_TOLERANCE)
        if reachesTarget then
            set x = targetX
            set y = targetY
            set z = targetZ
        else
            local real angleLengthXYZ = Math.AtanByDeltas(dZ, Math.DistanceByDeltas(dX, dY))
            local real lengthXY = length * Math.Cos(angleLengthXYZ)
            set x = x + lengthXY * Math.Cos(angleXY)
            set y = y + lengthXY * Math.Sin(angleXY)
            set z = z + length * Math.Sin(angleLengthXYZ)
            call caster.Facing.Set(angleXY)
        endif
        call caster.Position.Set(x, y, z)
        if reachesTarget then
            local SpellInstance whichInstance = this.whichInstance
			call whichInstance.Refs.Add()
            call caster.Buffs.Remove(thistype.DUMMY_BUFF)
            call this.Arrival.Start(angleXY, caster, this.level, targetX, targetY, whichInstance)
        else
            set this.angle = angleXY
            set this.length = length
        endif
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local Timer effectTimer = this.effectTimer
        local Timer moveTimer = this.moveTimer
        local SpellInstance whichInstance = this.whichInstance
        call effectTimer.Destroy()
        call moveTimer.Destroy()
        call target.Animation.Speed.Subtract(thistype.ANIMATION_INC)
        call whichInstance.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local EventResponse castParams = params.Buff.GetData()
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local SpellInstance whichInstance = SpellInstance.Create(target, thistype.THIS_SPELL)
        local real targetX = castParams.Spot.GetTargetX()
        local real targetY = castParams.Spot.GetTargetY()
        local real angle = target.CastAngle(targetX - target.Position.X.Get(), targetY - target.Position.Y.Get())
        local thistype this = target
        local Timer durationTimer = Timer.Create()
        local Timer effectTimer = Timer.Create()
		local Timer moveTimer = Timer.Create()
        set this.angle = angle
        set this.caster = target
        set this.effectTimer = effectTimer
        set this.length = thistype.LENGTH[level]
        set this.lengthAdd = thistype.LENGTH_ADD[level]
        set this.level = level
        set this.moveTimer = moveTimer
        set this.targetGroup = UnitList.Create()
        set this.targetX = targetX
        set this.targetY = targetY
        set this.whichInstance = whichInstance
        call effectTimer.SetData(this)
        call moveTimer.SetData(this)
        call target.Animation.Speed.Add(thistype.ANIMATION_INC)
        call effectTimer.Start(thistype.EFFECT_INTERVAL, true, function thistype.DoEffect)
        call moveTimer.Start(thistype.UPDATE_TIME, true, function thistype.Move)
    endmethod
    eventMethod Event_SpellEffect
        call params.Unit.GetTrigger().Buffs.AddFreshEx(thistype.DUMMY_BUFF, params.Spell.GetLevel(), params)
    endmethod
    initMethod Init of Spells_Hero
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        local integer iteration = thistype.THIS_SPELL.GetLevelsAmount()
        loop
            set thistype.LENGTH[iteration] = thistype.SPEED[iteration] * thistype.UPDATE_TIME
            set thistype.LENGTH_ADD[iteration] = thistype.ACCELERATION[iteration] * thistype.UPDATE_TIME * thistype.UPDATE_TIME
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        call thistype(NULL).Arrival.Init()
        call thistype(NULL).Leech.Init()
    endmethod
endstruct
    scope FolderPurgingRain
    public struct StructWave
        implement Allocation
        implement List
        
        static Group ENUM_GROUP
        static BoolExpr TARGET_FILTER
        real areaRange
        Unit caster
        real damage
        real targetX
        real targetY
        condMethod Conditions
            local Unit target = UNIT.Event.Native.GetFilter()
            if target.Classes.Contains(UnitClass.DEAD) then
                return false
            endif
            if target.IsAllyOf(User.TEMP) then
                return false
            endif
            if target.MagicImmunity.Try() then
                return false
            endif
            return true
        endmethod
        timerMethod Ending
            local Timer durationTimer = Timer.GetExpired()
            local thistype this = durationTimer.GetData()
            local real areaRange = this.areaRange
            local Unit caster = this.caster
            local real damage = this.damage
            local real targetX = this.targetX
            local real targetY = this.targetY
            local SpellInstance whichInstance = SpellInstance.Create(caster, PurgingRain.THIS_SPELL)
            local integer level = whichInstance.GetLevel()
            call this.deallocate()
            call durationTimer.Destroy()
            call whichInstance.Destroy()
            set User.TEMP = caster.Owner.Get()
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(targetX, targetY, areaRange, thistype.TARGET_FILTER)
            loop
                local Unit target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
                call Purge.Start(level, target, thistype.PURGE_DURATION[level])
                call caster.DamageUnitBySpell(target, damage, true, false)
            endloop
        endmethod
        static method Start takes Unit caster, integer level, real targetX, real targetY, integer waveCount returns nothing
            local real areaRange = PurgingRain.THIS_SPELL.GetAreaRange(level)
            local thistype this = thistype.allocate()
			local Timer durationTimer = Timer.Create()
            set this.areaRange = areaRange
            set this.caster = caster
            set this.damage = thistype.DAMAGE[level] * (1 + thistype.DAMAGE_REL_ADD[level] * (waveCount - 1))
            set this.targetX = targetX
            set this.targetY = targetY
            call durationTimer.SetData(this)
            set areaRange = areaRange * 0.75
			local integer iteration = thistype.DEBRIS_AMOUNT[level]
            loop
                exitwhen (iteration < 1)
                local real angle = Math.RandomAngle()
                local real offset = Math.Random(0., areaRange)
                call Spot.CreateEffect(targetX + offset * Math.Cos(angle), targetY + offset * Math.Sin(angle), thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW).Destroy()
                set iteration = iteration - 1
            endloop
            call durationTimer.Start(thistype.DAMAGE_DELAY, false, function thistype.Ending)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.ENUM_GROUP = Group.Create()
            set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        endmethod
    endstruct
endscope
    globals
        PurgingRain PURGING_RAIN = STRUCT_BASE
    endglobals
    struct PurgingRain
        implement Allocation
        implement List
        
    static SpellInstance WHICH_INSTANCE
    Timer durationTimer
    Timer intervalTimer
    integer level
    real targetX
    real targetY
    integer waveCount
    FolderPurgingRain_StructWave Wave = this
    FolderPurgingRain_StructWave LinkToStruct_Wave
    timerMethod EndingByTimer
        local thistype this = Timer.GetExpired().GetData()
        local Unit target = this
        call target.Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        local Unit target = this
		local integer waveCount = this.waveCount + 1
		set this.waveCount = waveCount
        call thistype(NULL).Wave.Start(target, this.level, this.targetX, this.targetY, waveCount)
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local Timer durationTimer = this.durationTimer
        local Timer intervalTimer = this.intervalTimer
        call durationTimer.Destroy()
        call intervalTimer.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local SpellInstance whichInstance = thistype.WHICH_INSTANCE
        local Unit target = whichInstance.GetCaster()
        local real targetX = whichInstance.GetTargetX()
        local real targetY = whichInstance.GetTargetY()
        local thistype this = target
        local Timer durationTimer = Timer.Create()
        local Timer intervalTimer = Timer.Create()
        set this.durationTimer = durationTimer
        set this.intervalTimer = intervalTimer
        set this.level = level
        set this.targetX = targetX
        set this.targetY = targetY
        set this.waveCount = 1
        call durationTimer.SetData(this)
        call intervalTimer.SetData(this)
        call intervalTimer.Start(thistype.INTERVAL[level], true, function thistype.Interval)
        call durationTimer.Start(thistype.THIS_SPELL.GetChannelTime(level), false, function thistype.EndingByTimer)
        call thistype(NULL).Wave.Start(target, level, targetX, targetY, 1)
    endmethod
    eventMethod Event_EndCast
        local Unit caster = params.Unit.GetTrigger()
        if caster.Buffs.Contains(FairyShape.DUMMY_BUFF) then
            return
        endif
        call caster.Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local SpellInstance whichInstance = params.SpellInstance.GetTrigger()
        if caster.Buffs.Contains(FairyShape.DUMMY_BUFF) then
            call caster.Buffs.Remove(caster.Abilities.Events.Effect.Channeling.DUMMY_BUFF)
        endif
        set thistype.WHICH_INSTANCE = whichInstance
        call caster.Buffs.AddFresh(thistype.DUMMY_BUFF, level)
    endmethod
    initMethod Init of Spells_Hero
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Wave.Init()
    endmethod
endstruct
    scope FolderRazorBladeDrawBack
    public struct StructBlade
        implement Allocation
        implement List
        
        static Event CHECKPOINT_IMPACT_EVENT
        static Group ENUM_GROUP
        static BoolExpr TARGET_FILTER
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
        static Timer UPDATE_TIMER
    static thistype array ACTIVE_LIST_ALL
    static integer ACTIVE_LIST_ALL_COUNT = ARRAY_EMPTY
    integer ACTIVE_LIST_index
    static method ACTIVE_LIST_Count takes nothing returns integer
        return thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
    static method ACTIVE_LIST_IsEmpty takes nothing returns boolean
        return (thistype.ACTIVE_LIST_Count() == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Get takes integer index returns thistype
        return thistype.ACTIVE_LIST_ALL[index]
    endmethod
    static method ACTIVE_LIST_GetIndex takes thistype this returns integer
        return this.ACTIVE_LIST_index
    endmethod
    static method ACTIVE_LIST_Contains takes thistype this returns boolean
        return (thistype.ACTIVE_LIST_GetIndex(this) > ARRAY_MIN)
    endmethod
    static method ACTIVE_LIST_Random takes integer lowBound, integer highBound returns thistype
        return thistype.ACTIVE_LIST_ALL[Math.RandomI(lowBound, highBound)]
    endmethod
    static method ACTIVE_LIST_RandomAll takes nothing returns thistype
        return thistype.ACTIVE_LIST_Random(ARRAY_MIN, thistype.ACTIVE_LIST_ALL_COUNT)
    endmethod
    static method ACTIVE_LIST_Remove takes thistype this returns boolean
        if not thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT].ACTIVE_LIST_index = this.ACTIVE_LIST_index
        set thistype.ACTIVE_LIST_ALL[this.ACTIVE_LIST_index - 1] = thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT]
        set this.ACTIVE_LIST_index = ARRAY_MIN
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT - 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_EMPTY)
    endmethod
    static method ACTIVE_LIST_Add takes thistype this returns boolean
        if thistype.ACTIVE_LIST_Contains(this) then
            return false
        endif
        set thistype.ACTIVE_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT + 1
        set thistype.ACTIVE_LIST_ALL[thistype.ACTIVE_LIST_ALL_COUNT] = this
        set this.ACTIVE_LIST_index = thistype.ACTIVE_LIST_ALL_COUNT + 1
        return (thistype.ACTIVE_LIST_ALL_COUNT == ARRAY_MIN)
    endmethod
    static thistype array FOR_EACH_LIST_ALL
    static integer FOR_EACH_LIST_ALL_COUNT = ARRAY_EMPTY
    static method FOR_EACH_LIST_FetchFirst takes nothing returns thistype
        local thistype result
        if (thistype.FOR_EACH_LIST_ALL_COUNT < ARRAY_MIN) then
            return NULL
        endif
        set result = thistype.FOR_EACH_LIST_ALL[ARRAY_MIN]
        set thistype.FOR_EACH_LIST_ALL[ARRAY_MIN] = thistype.FOR_EACH_LIST_ALL[thistype.FOR_EACH_LIST_ALL_COUNT]
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.FOR_EACH_LIST_ALL_COUNT - 1
        return result
    endmethod
    static method FOR_EACH_LIST_Set takes nothing returns nothing
        local integer iteration = thistype.ACTIVE_LIST_ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            set thistype.FOR_EACH_LIST_ALL[iteration] = thistype.ACTIVE_LIST_ALL[iteration]
            set iteration = iteration - 1
        endloop
        set thistype.FOR_EACH_LIST_ALL_COUNT = thistype.ACTIVE_LIST_ALL_COUNT
    endmethod
        Timer checkpointTimer
        Lightning dummyLightning
        Missile dummyMissile
        RazorBladeDrawBack parent
        UnitList targetGroup
        eventMethod ImpactCaster
            local Missile dummyMissile = params.Missile.GetTrigger()
            local thistype this = dummyMissile.GetData()
            local Timer checkpointTimer = this.checkpointTimer
            local Lightning dummyLightning = this.dummyLightning
            local RazorBladeDrawBack parent = this.parent
            if thistype.ACTIVE_LIST_Remove(this) then
                call thistype.UPDATE_TIMER.Pause()
            endif
            call dummyMissile.Event.Remove(CHECKPOINT_IMPACT_EVENT)
            call checkpointTimer.Destroy()
            call dummyLightning.Destroy()
            call dummyMissile.Destroy()
            if (parent.remainingBladesAmount == 1) then
                call parent.Ending()
            else
                set parent.remainingBladesAmount = parent.remainingBladesAmount - 1
            endif
        endmethod
        condMethod TargetConditions
            local Unit target = UNIT.Event.Native.GetFilter()
            if UnitList.TEMP.Contains(target) then
                return false
            endif
            if target.Classes.Contains(UnitClass.DEAD) then
                return false
            endif
            if target.IsAllyOf(User.TEMP) then
                return false
            endif
            return true
        endmethod
        timerMethod Update
            call thistype.FOR_EACH_LIST_Set()
            loop
                local thistype this = thistype.FOR_EACH_LIST_FetchFirst()
                exitwhen (this == NULL)
                local real areaRange = parent.areaRange
                local Unit caster = parent.caster
                local real damage = parent.damage
                local Missile dummyMissile = this.dummyMissile
                local UnitList targetGroup = this.targetGroup
                set UnitList.TEMP = targetGroup
                set User.TEMP = caster.Owner.Get()
                call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.DoWithZ(dummyMissile.Position.X.Get(), dummyMissile.Position.Y.Get(), dummyMissile.Position.Z.Get(), areaRange, thistype.TARGET_FILTER)
                local Unit target = thistype.ENUM_GROUP.FetchFirst()
                if (target != NULL) then
                    loop
                        call target.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
                        call targetGroup.Add(target)
                        call caster.DamageUnitBySpell(target, damage, false, true)
                        set target = thistype.ENUM_GROUP.FetchFirst()
                        exitwhen (target == NULL)
                    endloop
                endif
            endloop
        endmethod
        timerMethod Delay
            local Timer delayTimer = Timer.GetExpired()
            local Missile dummyMissile = delayTimer.GetData()
            call delayTimer.Destroy()
            local thistype this = dummyMissile.GetData()
            local RazorBladeDrawBack parent = this.parent
            call dummyMissile.Acceleration.Set(500.)
            call dummyMissile.CollisionSize.Set(parent.areaRange)
            call dummyMissile.Impact.SetAction(function thistype.ImpactCaster)
            call dummyMissile.Speed.Set(850.)
            call dummyMissile.GoToUnit.Start(parent.caster, null)
        endmethod
        eventMethod ImpactSpread
            local Missile dummyMissile = params.Missile.GetTrigger()
            local Timer delayTimer = Timer.Create()
            call delayTimer.SetData(dummyMissile)
            call delayTimer.Start(SetVar.GetValDefR("delay", thistype.DELAY), false, function thistype.Delay)
        endmethod
    static key GetKeyMacro_CHECKPOINT_BOLT_KEY
    static constant integer CHECKPOINT_BOLT_KEY = Math.Integer.MIN + GetKeyMacro_CHECKPOINT_BOLT_KEY
        eventMethod CheckpointImpact
            local MissileCheckpoint checkpoint = params.MissileCheckpoint.GetTrigger()
            local Lightning dummyBolt = checkpoint.Data.Integer.Get(CHECKPOINT_BOLT_KEY)
            call dummyBolt.Destroy()
        endmethod
        timerMethod NewCheckpoint
            local thistype this = Timer.GetExpired().GetData()
            local Unit caster = this.parent.caster
            local real x = caster.Position.X.Get()
            local real y = caster.Position.Y.Get()
            local real z = caster.Position.Z.Get()
            local MissileCheckpoint newCheckpoint = this.dummyMissile.Checkpoints.Create(x, y, z)
            local MissileCheckpoint prevCheckpoint
            local Lightning newBolt = Lightning.Create(thistype.BOLT)
            call newCheckpoint.Data.Integer.Set(CHECKPOINT_BOLT_KEY, newBolt)
            if (newCheckpoint == this.dummyMissile.Checkpoints.GetFirst()) then
                call newBolt.FromSpotToDummyUnit.Start(x, y, z, this.dummyMissile.DummyUnit.Get())
            else
                set prevCheckpoint = this.dummyMissile.Checkpoints.GetPrev(newCheckpoint)
                call newBolt.FromSpotToSpot.Start(x, y, z, prevCheckpoint.GetX(), prevCheckpoint.GetY(), prevCheckpoint.GetZ())
            endif
            call this.dummyLightning.FromSpotToUnit.Start(x, y, z, caster)
        endmethod
        method StartBlade takes real angle, real spreadRange returns nothing
        	local RazorBladeDrawBack parent = this
            local real sourceX = parent.sourceX
            local real sourceY = parent.sourceY
            local real sourceZ = parent.sourceZ
            set this = thistype.allocate()
            local Timer checkpointTimer = Timer.Create()
            local Lightning dummyLightning = Lightning.Create(thistype.BOLT)
            local Missile dummyMissile = Missile.Create()
            set this.checkpointTimer = checkpointTimer
            set this.dummyLightning = dummyLightning
            set this.dummyMissile = dummyMissile
            set this.parent = parent
            set this.targetGroup = UnitList.Create()
            call checkpointTimer.SetData(this)
            call dummyMissile.Event.Add(CHECKPOINT_IMPACT_EVENT)
            call dummyMissile.Acceleration.Set(SetVar.GetValDefR("acc", 0.))
            call dummyMissile.CollisionSize.Set(0.)
            call dummyMissile.Impact.SetAction(function thistype.ImpactSpread)
            call dummyMissile.SetData(this)
            call dummyMissile.Speed.Set(SetVar.GetValDefR("speed", 600.))
            call dummyMissile.Position.Set(sourceX, sourceY, sourceZ)
            call dummyMissile.GoToSpot.Start(sourceX + spreadRange * Math.Cos(angle), sourceY + spreadRange * Math.Sin(angle), sourceZ)
            call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1.)
            call dummyLightning.FromDummyUnitToUnit.Start(dummyMissile.DummyUnit.Get(), 0., parent.caster)
            if thistype.ACTIVE_LIST_Add(this) then
                call thistype.UPDATE_TIMER.Start(thistype.UPDATE_TIME, true, function thistype.Update)
            endif
            call checkpointTimer.Start(SetVar.GetValDefR("smooth", 0.5), true, function thistype.NewCheckpoint)
        endmethod
        static method Init takes nothing returns nothing
            set thistype.CHECKPOINT_IMPACT_EVENT = Event.Create(MISSILE.Checkpoints.IMPACT_EVENT_TYPE, EventPriority.SPELLS, function thistype.CheckpointImpact)
            set thistype.ENUM_GROUP = Group.Create()
            set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.TargetConditions)
            set thistype.UPDATE_TIMER = Timer.Create()
        endmethod
    endstruct
endscope
    globals
        RazorBladeDrawBack RAZOR_BLADE_DRAW_BACK = STRUCT_BASE
    endglobals
    struct RazorBladeDrawBack
        implement Allocation
        implement List
        
    real areaRange
    integer bladesToSpawnAmount
    Unit caster
    real damage
    Timer intervalTimer
    integer level
    Lightning parentBolt
    Missile parentMissile
    real parentMissileScaleAdd
    integer remainingBladesAmount
    real sourceX
    real sourceY
    real sourceZ
    FolderRazorBladeDrawBack_StructBlade Blade = this
    FolderRazorBladeDrawBack_StructBlade LinkToStruct_Blade
    method Ending takes nothing returns nothing
        call this.intervalTimer.Destroy()
        
        call this.parentMissile.Destroy()
        call this.deallocate()
    endmethod
    method StartBlade takes nothing returns nothing
        set this.bladesToSpawnAmount = this.bladesToSpawnAmount - 1
        if (this.bladesToSpawnAmount == 0) then
            call this.intervalTimer.Pause()
            call this.parentBolt.Color.Set(255, 255, 255, 0)
        endif
        call this.parentMissile.DummyUnit.Get().Scale.Add(this.parentMissileScaleAdd)
        call this.Blade.StartBlade(Math.FULL_ANGLE / thistype.MISSILES_AMOUNT[this.level] * this.bladesToSpawnAmount, thistype.SPREAD_RANGE)
    endmethod
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        call this.StartBlade()
    endmethod
    static method Start takes Lightning parentBolt, Missile parentMissile, Unit caster, integer level, real sourceX, real sourceY, real sourceZ returns nothing
        local thistype this = thistype.allocate()
		local Timer intervalTimer = Timer.Create()
        set this.areaRange = thistype.AREA_RANGE[level]
        set this.bladesToSpawnAmount = thistype.MISSILES_AMOUNT[level]
        set this.caster = caster
        set this.damage = thistype.DAMAGE[level]
        set this.intervalTimer = intervalTimer
        set this.level = level
        set this.parentBolt = parentBolt
        set this.parentMissile = parentMissile
        set this.parentMissileScaleAdd = -parentMissile.DummyUnit.Get().Scale.Get() / thistype.MISSILES_AMOUNT[level]
        set this.sourceX = sourceX
        set this.sourceY = sourceY
        set this.sourceZ = sourceZ
        set this.remainingBladesAmount = thistype.MISSILES_AMOUNT[level]
        call intervalTimer.Start(SetVar.GetValDefR("interval", thistype.INTERVAL[level]), true, function thistype.Interval)
        call this.StartBlade()
    endmethod
    initMethod Init of Spells_Hero
        call thistype(NULL).Blade.Init()
    endmethod
endstruct
    scope FolderRazorBlade
    public struct StructVamp
        implement Allocation
        implement List
        
        eventMethod Event_Unlearn
            call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
        endmethod
        eventMethod Event_Learn
            call params.Unit.GetTrigger().Buffs.AddFresh(thistype.DUMMY_BUFF, params.Spell.GetLevel())
        endmethod
        static method Init takes nothing returns nothing
            call RazorBlade.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.CHANGE_LEVEL_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
            call RazorBlade.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
            call RazorBlade.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
        endmethod
    endstruct
endscope
    globals
        RazorBlade RAZOR_BLADE = STRUCT_BASE
    endglobals
    struct RazorBlade
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    static constant real UPDATE_TIME = (2 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (2 * 1.))
    Unit caster
    real damage
    Lightning dummyLightning
    Missile dummyMissile
    integer level
    UnitList targetGroup
    real targetX
    real targetY
    Timer updateTimer
    FolderRazorBlade_StructVamp Vamp = this
    FolderRazorBlade_StructVamp LinkToStruct_Vamp
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        local integer level = this.level
        local Timer updateTimer = this.updateTimer
        local real x = dummyMissile.Position.X.Get()
        local real y = dummyMissile.Position.Y.Get()
        local real z = dummyMissile.Position.Z.Get()
        call updateTimer.Destroy()
        call this.deallocate()
        call RazorBladeDrawBack.Start(dummyLightning, dummyMissile, caster, level, x, y, z)
    endmethod
    condMethod TargetConditions
        local Unit target = UNIT.Event.Native.GetFilter()
       
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    timerMethod Update
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this.caster
        local Missile dummyMissile = this.dummyMissile
        local UnitList targetGroup = this.targetGroup
        local real targetX = this.targetX
        local real targetY = this.targetY
        set UnitList.TEMP = targetGroup
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.DoWithZ(dummyMissile.Position.X.Get(), dummyMissile.Position.Y.Get(), dummyMissile.Position.Z.Get(), thistype.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real damage = this.damage
            loop
                if not targetGroup.Contains(target) then
                    call target.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
                    call target.Position.Timed.Accelerated.AddKnockback(650., -200., Math.AtanByDeltas(targetY - target.Position.Y.Get(), targetX - target.Position.X.Get()), 1.)
                    call targetGroup.Add(target)
                    call caster.DamageUnitBySpell(target, damage, false, true)
                endif
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real maxLength = thistype.MAX_LENGTH[level]
        local real angle = caster.CastAngle(targetX - casterX, targetY - casterY)
        set targetX = casterX + maxLength * Math.Cos(angle)
        set targetY = casterY + maxLength * Math.Sin(angle)
        local thistype this = thistype.allocate()
        local Lightning dummyLightning = NULL
        local Missile dummyMissile = Missile.Create()
        local Timer updateTimer = Timer.Create()
        set this.caster = caster
        set this.damage = thistype.DAMAGE[level]
        set this.dummyMissile = dummyMissile
        set this.dummyLightning = dummyLightning
        set this.level = level
        set this.targetGroup = UnitList.Create()
        set this.targetX = targetX
        set this.targetY = targetY
        set this.updateTimer = updateTimer
        call updateTimer.SetData(this)
        call dummyMissile.Acceleration.Set(-400.)
        call dummyMissile.CollisionSize.Set(thistype.THIS_SPELL.GetAreaRange(level))
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(1100.)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.GoToSpot.Start(targetX, targetY, Spot.GetHeight(targetX, targetY) + UNIT_TYPE.Impact.Z.STANDARD)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 2.)
        
        call updateTimer.Start(thistype.UPDATE_TIME, true, function thistype.Update)
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.TargetConditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Vamp.Init()
    endmethod
endstruct
    scope FolderRelentlessShiver
    public struct StructBuff
        implement Allocation
        implement List
        
        static method Start takes Unit caster, integer level, Unit target returns nothing
        	local real duration
			if target.Classes.Contains(UnitClass.HERO) then
				set duration = thistype.HERO_DURATION[level]
			else
				set duration = thistype.DURATION[level]
			endif
            call target.Buffs.Timed.Start(thistype.COLDNESS_BUFF, level, duration)
        endmethod
        static method Init takes nothing returns nothing
            call UNIT.Cold.NORMAL_BUFF.Variants.Add(thistype.COLDNESS_BUFF)
        endmethod
    endstruct
    public struct StructMissile
        implement Allocation
        implement List
        
        Unit caster
        integer level
        eventMethod Impact
            local Missile dummyMissile = params.Missile.GetTrigger()
            local Unit target = params.Unit.GetTrigger()
            local thistype this = dummyMissile.GetData()
            local Unit caster = this.caster
            local integer level = this.level
            call this.deallocate()
            call dummyMissile.Destroy()
            call RELENTLESS_SHIVER.Buff.Start(caster, level, target)
            call caster.DamageUnitBySpell(target, thistype.DAMAGE[level], true, false)
        endmethod
        static method Start takes Unit caster, integer level, Unit target returns nothing
            local thistype this = thistype.allocate()
			local Missile dummyMissile = Missile.Create()
            set this.caster = caster
            set this.level = level
            call dummyMissile.Arc.SetByPerc(0.06)
            call dummyMissile.CollisionSize.Set(8.)
            call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 0.75)
            call dummyMissile.Impact.SetAction(function thistype.Impact)
            call dummyMissile.SetData(this)
            call dummyMissile.Speed.Set(500.)
            call dummyMissile.Position.SetFromUnit(caster)
            call dummyMissile.GoToUnit.Start(target, function Missile.Destruction)
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
endscope
    globals
        RelentlessShiver RELENTLESS_SHIVER = STRUCT_BASE
    endglobals
    struct RelentlessShiver
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static real array MANA_COST_PER_INTERVAL
    static BoolExpr TARGET_FILTER
    real areaRange
    Timer intervalTimer
    integer level
    real manaCostPerInterval
    FolderRelentlessShiver_StructBuff Buff = this
    FolderRelentlessShiver_StructBuff LinkToStruct_Buff
    FolderRelentlessShiver_StructMissile Missile = this
    FolderRelentlessShiver_StructMissile LinkToStruct_Missile
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.HERO) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this
        local real areaRange = this.areaRange
        local integer level = this.level
        local real manaCostPerInterval = this.manaCostPerInterval
        call caster.Mana.Subtract(manaCostPerInterval)
        if (caster.Mana.Get() < thistype.MANA_COST_BUFFER) then
            call caster.Buffs.Remove(thistype.DUMMY_BUFF)
        endif
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(caster.Position.X.Get(), caster.Position.Y.Get(), areaRange, thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            loop
                call thistype(NULL).Missile.Start(caster, level, target)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    eventMethod Event_BuffLose
        local Unit caster = params.Unit.GetTrigger()
        local thistype this = caster
        local Timer intervalTimer = this.intervalTimer
        call intervalTimer.Destroy()
        call HeroSpell.ReplaceSlot(thistype.REVERT_SPELL.GetClass(), thistype.THIS_SPELL, caster)
    endmethod
    eventMethod Event_BuffGain
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Buff.GetLevel()
        local thistype this = caster
		local Timer intervalTimer = Timer.Create()
        set this.areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        set this.intervalTimer = intervalTimer
        set this.level = level
        set this.manaCostPerInterval = thistype.MANA_COST_PER_INTERVAL[level]
        call intervalTimer.SetData(this)
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
        call HeroSpell.ReplaceSlot(thistype.THIS_SPELL.GetClass(), thistype.REVERT_SPELL, caster)
    endmethod
    eventMethod Event_RevertSpellEffect
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_SpellEffect
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.REVERT_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_RevertSpellEffect))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        local integer iteration = thistype.THIS_SPELL.GetLevelsAmount()
        loop
            exitwhen (iteration < 1)
            set thistype.MANA_COST_PER_INTERVAL[iteration] = thistype.MANA_COST_PER_SECOND[iteration] * thistype.INTERVAL
            set iteration = iteration - 1
        endloop
        call thistype(NULL).Buff.Init()
        call thistype(NULL).Missile.Init()
    endmethod
endstruct
    scope FolderRigorMortis
    public struct StructAfterBuff
        implement Allocation
        implement List
        
        static method Start takes Unit target, integer level returns nothing
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.INVIS_DURATION)
        endmethod
        static method Init takes nothing returns nothing
            call UNIT.Ghost.DUMMY_BUFF.Variants.Add(thistype.DUMMY_BUFF)
            call UNIT.Invisibility.PERM_BUFF.Variants.Add(thistype.DUMMY_BUFF)
            call UNIT.Pathing.DUMMY_BUFF.Variants.Add(thistype.DUMMY_BUFF)
        endmethod
    endstruct
endscope
    globals
        RigorMortis RIGOR_MORTIS = STRUCT_BASE
    endglobals
    struct RigorMortis
        implement Allocation
        implement List
        
    static Event REVIVE_EVENT
    Timer durationTimer
    integer level
    SpotEffect specialEffect
    real targetLife
    real targetMana
    real targetX
    real targetY
    FolderRigorMortis_StructAfterBuff AfterBuff = this
    FolderRigorMortis_StructAfterBuff LinkToStruct_AfterBuff
    method Ending takes Timer durationTimer, Unit target returns nothing
        local SpotEffect specialEffect = this.specialEffect
        call durationTimer.Pause()
        call specialEffect.Destroy()
        call target.Event.Remove(REVIVE_EVENT)
    endmethod
    timerMethod EndingByTimer
        local Timer durationTimer = Timer.GetExpired()
        local thistype this = durationTimer.GetData()
        local integer level = this.level
        local Unit target = this
        local real targetLife = this.targetLife
        local real targetMana = this.targetMana
        local real targetX = this.targetX
        local real targetY = this.targetY
        call this.Ending(durationTimer, target)
        call target.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
        call target.Hero.Revive(targetX, this.targetY)
        call target.Life.Set(targetLife)
        call target.Mana.Set(targetMana)
        call target.Select(target.Owner.Get(), true)
        call thistype(NULL).AfterBuff.Start(target, level)
    endmethod
    eventMethod Event_Revive
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        call this.Ending(this.durationTimer, target)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real targetX = caster.Position.X.Get()
        local real targetY = caster.Position.Y.Get()
		call Spot.CreateEffect(targetX, targetY, thistype.CAST_EFFECT_PATH, EffectLevel.NORMAL).Destroy()
        local thistype this = caster
		local Timer durationTimer = Timer.Create()
        set this.durationTimer = durationTimer
        set this.level = level
        set this.specialEffect = Spot.CreateEffect(targetX, targetY, thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW)
        set this.targetLife = caster.Life.Get() + caster.MaxLife.Get() * thistype.LIFE_FACTOR[level]
        set this.targetMana = caster.Mana.Get() + caster.MaxMana.Get() * thistype.MANA_FACTOR[level] - thistype.THIS_SPELL.GetManaCost(level)
        set this.targetX = targetX
        set this.targetY = targetY
        call caster.Event.Add(REVIVE_EVENT)
        call durationTimer.SetData(this)
        call caster.Abilities.Cooldown.Start(thistype.THIS_SPELL)
        call caster.Revival.Set(true)
        call durationTimer.Start(thistype.DELAY, false, function thistype.EndingByTimer)
        call caster.Kill()
    endmethod
    initMethod Init of Spells_Hero
        set thistype.REVIVE_EVENT = Event.Create(UNIT.Revival.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Revive)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).AfterBuff.Init()
    endmethod
endstruct
    scope FolderSakeBomb
    public struct StructMissile
        implement Allocation
        implement List
        
        Unit caster
        integer level
        real targetX
        real targetY
        SpellInstance whichInstance
        eventMethod Impact
            local Missile dummyMissile = params.Missile.GetTrigger()
            local thistype this = dummyMissile.GetData()
            local Unit caster = this.caster
            local integer level = this.level
            local real targetX = this.targetX
            local real targetY = this.targetY
            local SpellInstance whichInstance = this.whichInstance
            call this.deallocate()
            call dummyMissile.Destroy()
            call SakeBomb.Start(caster, level, targetX, targetY, whichInstance)
        endmethod
        static method Start takes Unit caster, integer level, real targetX, real targetY, SpellInstance whichInstance returns nothing
            local thistype this = thistype.allocate()
			local Missile dummyMissile = Missile.Create()
            set this.caster = caster
            set this.level = level
            set this.targetX = targetX
            set this.targetY = targetY
            set this.whichInstance = whichInstance
            call dummyMissile.Arc.SetByPerc(0.5)
            call dummyMissile.CollisionSize.Set(32.)
            call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1.)
            call dummyMissile.Impact.SetAction(function thistype.Impact)
            call dummyMissile.SetData(this)
            call dummyMissile.Speed.Set(700.)
            call dummyMissile.Position.SetFromUnit(caster)
            call dummyMissile.GoToSpot.Start(targetX, targetY, Spot.GetHeight(targetX, targetY))
        endmethod
    endstruct
endscope
    globals
        SakeBomb SAKE_BOMB = STRUCT_BASE
    endglobals
    struct SakeBomb
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    DummyUnit areaDummyUnit
    real areaRange
    Unit caster
    real damage
    DummyUnit dummyUnit
    integer intervalsAmount
    real poisonDuration
    real targetX
    real targetY
    real targetZ
    SpellInstance whichInstance
    FolderSakeBomb_StructMissile Missile = this
    FolderSakeBomb_StructMissile LinkToStruct_Missile
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    timerMethod Interval
        local Timer intervalTimer = Timer.GetExpired()
        local thistype this = intervalTimer.GetData()
        local integer intervalsAmount = this.intervalsAmount - 1
        if (intervalsAmount == 0) then
            local DummyUnit areaDummyUnit = this.areaDummyUnit
            local real areaRange = this.areaRange
            local Unit caster = this.caster
            local real damage = this.damage
            local DummyUnit dummyUnit = this.dummyUnit
            local real poisonDuration = this.poisonDuration
            local SpellInstance whichInstance = this.whichInstance
            local real x = this.targetX
            local real y = this.targetY
            local integer level = whichInstance.GetLevel()
            call this.deallocate()
            call areaDummyUnit.DestroyInstantly()
            call dummyUnit.Destroy()
            call intervalTimer.Destroy()
            call whichInstance.Destroy()
            call Spot.CreateEffect(x, y, thistype.SPECIAL_EFFECT_PATH, EffectLevel.NORMAL).Destroy()
            set User.TEMP = caster.Owner.Get()
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, areaRange, thistype.TARGET_FILTER)
            local Unit target = thistype.ENUM_GROUP.FetchFirst()
            if (target != NULL) then
                loop
                    local real d = Math.DistanceByDeltas(target.Position.X.Get() - x, target.Position.Y.Get() - y)
                    local real rangeFactor = Math.Shapes.LinearFromCoords(0., thistype.DAMAGE_RANGE_FACTOR_CLOSE, areaRange, thistype.DAMAGE_RANGE_FACTOR_FAR, d)
                    call caster.BurnManaBySpell(target, target.MaxMana.Get() * thistype.MANA_BURN_REL[level])
                    call caster.DamageUnitBySpell(target, rangeFactor * damage * (1. + Boolean.ToInt(target.Poisoned.Is()) * thistype.POISON_DAMAGE_ADD_FACTOR), true, true)
                    call target.Buffs.Timed.Start(thistype.POISON_BUFF, level, poisonDuration)
                    set target = thistype.ENUM_GROUP.FetchFirst()
                    exitwhen (target == NULL)
                endloop
            endif
        else
            set this.intervalsAmount = intervalsAmount
            call TEXT_TAG.CreateJumping.Create(String.Color.Do(Integer.ToString(intervalsAmount), String.Color.RelativeTo(1. - intervalsAmount * 0.05, 0.25, 0., 0.)), 0.034 - intervalsAmount * 0.003, this.targetX, this.targetY, this.targetZ + UNIT_TYPE.Outpact.Z.STANDARD, TextTag.GetFreeId())
        endif
    endmethod
    static method Start takes Unit caster, integer level, real targetX, real targetY, SpellInstance whichInstance returns nothing
        local real areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        local real poisonDuration = thistype.POISON_DURATION[level]
        local real targetZ = Spot.GetHeight(targetX, targetY)
        local thistype this = thistype.allocate()
        local DummyUnit areaDummyUnit = DummyUnit.Create(thistype.AREA_DUMMY_UNIT_ID, targetX, targetY, targetZ, UNIT.Facing.STANDARD)
        local DummyUnit dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, targetX, targetY, targetZ, UNIT.Facing.STANDARD)
		local Timer intervalTimer = Timer.Create()
        set this.areaDummyUnit = areaDummyUnit
        set this.areaRange = areaRange
        set this.caster = caster
        set this.damage = thistype.DAMAGE[level]
        set this.dummyUnit = dummyUnit
        set this.intervalsAmount = Real.ToInt(DURATION)
        set this.poisonDuration = poisonDuration
        set this.targetX = targetX
        set this.targetY = targetY
        set this.targetZ = targetZ
        set this.whichInstance = whichInstance
        call intervalTimer.SetData(this)
        call areaDummyUnit.SetScale(areaRange / (256. / 5))
        call areaDummyUnit.VertexColor.Set(255, 255, 255, 127)
        call intervalTimer.Start(1., true, function thistype.Interval)
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(targetX, targetY, areaRange, thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            loop
                call target.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
                call target.Buffs.Timed.Start(thistype.POISON_BUFF, level, poisonDuration)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        call thistype(NULL).Missile.Start(caster, params.Spell.GetLevel(), params.Spot.GetTargetX(), params.Spot.GetTargetY(), SpellInstance.Create(caster, thistype.THIS_SPELL))
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call UNIT.Poisoned.NORMAL_BUFF.Variants.Add(thistype.POISON_BUFF)
    endmethod
endstruct
    globals
        SanguineEyes SANGUINE_EYES = STRUCT_BASE
    endglobals
    struct SanguineEyes
        implement Allocation
        implement List
        
    static Event DAMAGE_EVENT
    Unit caster
    real damageToLifeFactor
    eventMethod Event_Damage
        local real damage = params.Real.GetDamage()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        call this.caster.HealBySpell(caster, damage * this.damageToLifeFactor)
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        call target.Event.Remove(DAMAGE_EVENT)
        call caster.Abilities.Refresh(thistype.THIS_SPELL)
    endmethod
    eventMethod Event_BuffGain
        local Unit caster = params.Buff.GetData()
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        set this.caster = caster
        set this.damageToLifeFactor = thistype.DAMAGE_TO_LIFE_FACTOR[level]
        call target.Event.Add(DAMAGE_EVENT)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        call target.Buffs.Timed.StartEx(thistype.DUMMY_BUFF, level, caster, thistype.DURATION[level])
    endmethod
    initMethod Init of Spells_Hero
        set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call UNIT.Bleeding.DUMMY_BUFF.Variants.Add(thistype.DUMMY_BUFF)
        call UNIT.Death.Explosion.DUMMY_BUFF.Variants.Add(thistype.DUMMY_BUFF)
        call UNIT.Stun.DUMMY_BUFF.Variants.Add(thistype.DUMMY_BUFF)
    endmethod
endstruct
    scope FolderShamanicBubble
    public struct StructTarget
        implement Allocation
        implement List
        
    	static Event ENDING_EVENT
        static Event START_EVENT
		eventMethod Event_Ending
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local ShamanicBubble parent = aura.GetData()
			call target.Buffs.Subtract(thistype.DUMMY_BUFF)
		endmethod
		eventMethod Event_Start
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local Unit caster = aura.GetCaster()
			local ShamanicBubble parent = aura.GetData()
			local integer level = parent.level
			call target.Buffs.Add(thistype.DUMMY_BUFF, level)
		endmethod
        static method Init takes nothing returns nothing
            set thistype.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Ending)
            set thistype.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Start)
        endmethod
    endstruct
    public struct StructTransition
        implement Allocation
        implement List
        
        static SpellInstance WHICH_SPELL_INSTANCE
        Timer delayTimer
        real scale
        SpellInstance whichSpellInstance
        timerMethod Delay
            local thistype this = Timer.GetExpired().GetData()
            local Unit target = this
            call target.Buffs.Remove(thistype.DUMMY_BUFF)
            call ShamanicBubble.Start(this.whichSpellInstance)
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            local Timer delayTimer = this.delayTimer
            local real scale = this.scale
            call delayTimer.Destroy()
            call target.Scale.Timed.Add(scale, thistype.DELAY)
        endmethod
        eventMethod Event_BuffGain
            local Unit target = params.Unit.GetTrigger()
            local SpellInstance whichSpellInstance = thistype.WHICH_SPELL_INSTANCE
            local real scale = target.Scale.Get()
            local thistype this = target
			local Timer delayTimer = Timer.Create()
            set this.delayTimer = delayTimer
            set this.scale = scale
            set this.whichSpellInstance = whichSpellInstance
            call delayTimer.SetData(this)
            call target.Scale.Timed.Subtract(scale, thistype.DELAY)
            call delayTimer.Start(thistype.DELAY, false, function thistype.Delay)
        endmethod
        static method Start takes SpellInstance whichInstance returns nothing
            set thistype.WHICH_SPELL_INSTANCE = whichInstance
            call whichInstance.GetCaster().Buffs.Timed.Start(thistype.DUMMY_BUFF, 1, thistype.DELAY)
        endmethod
        static method Init takes nothing returns nothing
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
    endstruct
endscope
    globals
        ShamanicBubble SHAMANIC_BUBBLE = STRUCT_BASE
    endglobals
    struct ShamanicBubble
        implement Allocation
        implement List
        
    static BoolExpr TARGET_FILTER
    Aura aura
    integer level
    FolderShamanicBubble_StructTarget Target = this
    FolderShamanicBubble_StructTarget LinkToStruct_Target
    FolderShamanicBubble_StructTransition Transition = this
    FolderShamanicBubble_StructTransition LinkToStruct_Transition
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if not target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
		local Aura aura = this.aura
        call aura.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
		local Aura aura = Aura.Create(target)
        set this.aura = aura
        set this.level = level
        call aura.SetData(this)
		call aura.SetAreaRange(thistype.THIS_SPELL.GetAreaRange(level))
        call aura.SetTargetFilter(thistype.TARGET_FILTER)
		call aura.Event.Add(thistype(NULL).Target.ENDING_EVENT)
		call aura.Event.Add(thistype(NULL).Target.START_EVENT)
		call aura.Enable()
    endmethod
    eventMethod Event_EndCast
        local Unit caster = params.Unit.GetTrigger()
        call caster.Buffs.Remove(thistype(NULL).Transition.DUMMY_BUFF)
        call caster.Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    static method Start takes SpellInstance whichInstance returns nothing
        local Unit caster = whichInstance.GetCaster()
        local integer level = whichInstance.GetLevel()
        local real targetX = whichInstance.GetTargetX()
        local real targetY = whichInstance.GetTargetY()
        call caster.Position.SetXYZ(targetX, targetY, Spot.GetHeight(targetX, targetY))
        call caster.Buffs.Add(thistype.DUMMY_BUFF, level)
    endmethod
    eventMethod Event_SpellEffect
        call thistype(NULL).Transition.Start(params.SpellInstance.GetTrigger())
    endmethod
    initMethod Init of Spells_Hero
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Target.Init()
        call thistype(NULL).Transition.Init()
    endmethod
endstruct
    scope FolderSleepingDraft
    public struct StructBuff
        implement Allocation
        implement List
        
        static Event DAMAGE_EVENT
        integer level
        eventMethod Event_Damage
            local Unit target = params.Unit.GetDamager()
            local Unit victim = params.Unit.GetTarget()
            local thistype this = target
			local integer level = this.level
            call victim.Buffs.Timed.Start(thistype.COLDNESS_BUFF, level, thistype.COLDNESS_DURATION[level])
            call victim.Effects.Create("Abilities\\Weapons\\LichMissile\\LichMissile.mdl", AttachPoint.CHEST, EffectLevel.NORMAL).Destroy()
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            call target.Event.Remove(DAMAGE_EVENT)
        endmethod
        eventMethod Event_BuffGain
            local integer level = params.Buff.GetLevel()
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            set this.level = level
            call target.Event.Add(DAMAGE_EVENT)
        endmethod
        static method Start takes integer level, Unit target returns nothing
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION[level])
        endmethod
        static method Init takes nothing returns nothing
            set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            call UNIT.Cold.NORMAL_BUFF.Variants.Add(thistype.COLDNESS_BUFF)
        endmethod
    endstruct
endscope
    globals
        SleepingDraft SLEEPING_DRAFT = STRUCT_BASE
    endglobals
    struct SleepingDraft
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    Unit caster
    integer level
    FolderSleepingDraft_StructBuff Buff = this
    FolderSleepingDraft_StructBuff LinkToStruct_Buff
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local real x = dummyMissile.Position.X.Get()
        local real y = dummyMissile.Position.Y.Get()
        local Unit caster = this.caster
        local integer level = this.level
        call this.deallocate()
        call dummyMissile.Destroy()
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, thistype.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
		local integer maxTargetsAmount = thistype.TARGETS_AMOUNT[level]
		if (maxTargetsAmount > 0) then
	        local Unit target = thistype.ENUM_GROUP.GetNearest(x, y)
	
	        if (target != NULL) then
	            local integer iteration = 1
	
	            loop
	                call thistype.ENUM_GROUP.RemoveUnit(target)
	
	                call target.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
	
	                if target.Classes.Contains(UnitClass.HERO) then
	                    call target.Buffs.Timed.Start(thistype.SLEEP_BUFF, level, thistype.HERO_DURATION[level])
	                else
	                    call target.Buffs.Timed.Start(thistype.SLEEP_BUFF, level, thistype.DURATION[level])
	                endif
	                set iteration = iteration + 1
	                exitwhen (iteration > maxTargetsAmount)
	                set target = thistype.ENUM_GROUP.GetNearest(x, y)
	                exitwhen (target == NULL)
	            endloop
	        endif
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        local thistype this = thistype.allocate()
		local Missile dummyMissile = Missile.Create()
        set this.caster = caster
        set this.level = level
        call dummyMissile.Arc.SetByPerc(0.2)
        call dummyMissile.CollisionSize.Set(10.)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1.5)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(700.)
        call dummyMissile.Position.SetToUnit(caster)
        call dummyMissile.GoToUnit.Start(target, null)
        call thistype(NULL).Buff.Start(level, caster)
        call caster.HealStaminaBySpell(caster, caster.MaxStamina.Get() * thistype.STAMINA_REL_INC + thistype.STAMINA_INC[level])
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call UNIT.Sleep.NORMAL_BUFF.Variants.Add(thistype.SLEEP_BUFF)
        call thistype(NULL).Buff.Init()
    endmethod
endstruct
    scope FolderSoberUp
    public struct StructHealMissile
        implement Allocation
        implement List
        
        integer amount
        Unit caster
        integer level
        eventMethod Impact
            local Missile dummyMissile = params.Missile.GetTrigger()
            local thistype this = dummyMissile.GetData()
            local integer amount = this.amount
            local Unit caster = this.caster
            local integer level = this.level
			call this.deallocate_demount()
            call dummyMissile.Destroy()
            call SoberUp.DoHeal(caster, level, amount)
        endmethod
        static method Start takes Unit caster, integer level, Unit source, integer amount returns nothing
			local Missile dummyMissile = Missile.Create()
			local thistype this = thistype.allocate_mount(dummyMissile)
            set this.amount = amount
            set this.caster = caster
            set this.level = level
            call dummyMissile.Arc.SetByPerc(0.4)
            call dummyMissile.CollisionSize.Set(32.)
            call dummyMissile.Impact.SetAction(function thistype.Impact)
            call dummyMissile.SetData(this)
            call dummyMissile.Speed.Set(600.)
            call dummyMissile.Position.SetFromUnit(source)
            call dummyMissile.GoToUnit.Start(caster, null)
            call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1 + (amount * 0.2))
        endmethod
    endstruct
endscope
    globals
        SoberUp SOBER_UP = STRUCT_BASE
    endglobals
    struct SoberUp
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
	integer level
	real x
	real y
    FolderSoberUp_StructHealMissile HealMissile = this
    FolderSoberUp_StructHealMissile LinkToStruct_HealMissile
    static method DoHeal takes Unit caster, integer level, integer amount returns nothing
        call caster.Effects.Create(thistype.HEAL_EFFECT_PATH, thistype.HEAL_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
        call caster.HealBySpell(caster, thistype.HEAL_PER_BUFF[level] * amount)
    endmethod
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        return true
    endmethod
	eventMethod Event_EndCast
        local Unit caster = params.Unit.GetTrigger()
        local boolean success = params.Spell.IsChannelComplete()
		
		local thistype this = caster
		local integer level = this.level
		local real x = this.x
		local real y = this.y
		
		local real areaRange = thistype.THIS_SPELL.GetAreaRange(level)
		if not success then
			call caster.Abilities.Refresh(thistype.THIS_SPELL)
			call caster.Mana.Add(thistype.THIS_SPELL.GetManaCost(level))
			
			return
		endif
        call SpotEffectWithSize.Create(x, y, thistype.SHOCKWAVE_EFFECT_PATH, EffectLevel.NORMAL, areaRange / thistype.SHOCKWAVE_EFFECT_SCALE_SIZE).Destroy()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, areaRange, thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local User casterOwner = caster.Owner.Get()
            local real damagePerBuff = thistype.DAMAGE_PER_BUFF[level]
            loop
            	local integer amount
            	
                if target.IsAllyOf(casterOwner) then
                    set amount = target.Buffs.Dispel(true, false, true)
                    if (amount > 0) then
                        call thistype(NULL).HealMissile.Start(caster, level, target, amount)
                    endif
                else
                    call target.Effects.Create(thistype.DAMAGE_EFFECT_PATH, thistype.DAMAGE_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
					local real banishDuration
					if target.Classes.Contains(UnitClass.HERO) then
						set banishDuration = thistype.BANISH_HERO_DURATION[level]
					else
						set banishDuration = thistype.BANISH_DURATION[level]
					endif
                    call target.Buffs.Timed.Start(thistype.BANISH_BUFF, level, banishDuration)
                    set amount = target.Buffs.CountVisibleEx(true, false)
                    if (amount > 0) then
                        call caster.DamageUnitBySpell(target, amount * damagePerBuff, true, false)
                    endif
                endif
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
	endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger() 
        local integer level = params.Spell.GetLevel()
		local real areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        local real x = caster.Position.X.Get()
        local real y = caster.Position.Y.Get()
		call SpotEffectWithSize.Create(x, y, thistype.EXPLOSION_EFFECT_PATH, EffectLevel.LOW, areaRange / thistype.EXPLOSION_EFFECT_SCALE_SIZE).Destroy()
		
		local thistype this = caster
		set this.level = level
		set this.x = x
		set this.y = y
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
        call UNIT.Banish.NORMAL_BUFF.Variants.Add(thistype.BANISH_BUFF)
    endmethod
endstruct
    scope FolderSteelImpalement
    public struct StructTarget
        implement Allocation
        implement List
        
        static method Start takes Unit target, Unit caster, integer level returns nothing
        	call target.Effects.Create(thistype.SPECIAL_EFFECT_PATH, thistype.SPECIAL_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
        	call target.Knockup.Start()
            call target.Buffs.Timed.StartEx(thistype.DUMMY_BUFF, level, caster, thistype.DURATION[level])
        endmethod
        static method Init takes nothing returns nothing
            call UNIT.Bleeding.NORMAL_BUFF.Variants.Add(thistype.DUMMY_BUFF)
            call UNIT.Movement.DISABLE_BUFF.Variants.Add(thistype.DUMMY_BUFF)
        endmethod
    endstruct
endscope
    globals
        SteelImpalement STEEL_IMPALEMENT = STRUCT_BASE
    endglobals
    struct SteelImpalement
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    static constant real UPDATE_TIME = 1.5
    real animSpeedAdd
    real areaRange
    real areaRangeAdd
    real damage
    UnitList targetGroup
    SpellInstance whichInstance
    Timer updateTimer
    Timer waveTimer
    FolderSteelImpalement_StructTarget Target = this
    FolderSteelImpalement_StructTarget LinkToStruct_Target
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if UnitList.TEMP.Contains(target) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    timerMethod Update
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real areaRange = this.areaRange + this.areaRangeAdd
        local integer level = this.whichInstance.GetLevel()
        local UnitList targetGroup = this.targetGroup
        set this.areaRange = areaRange
        local real peri = Math.DOUBLE_PI * areaRange
        local real angle = Math.RandomAngle()
        local integer sfxToSpawn = Real.ToInt(peri / SetVar.GetValDefR("sfxdist", thistype.SFX_DIST))
        local real angleAdd = Math.FULL_ANGLE / sfxToSpawn
        loop
            exitwhen (sfxToSpawn < 1)
            set angle = angle + angleAdd
            call Spot.CreateEffect(casterX + areaRange * Math.Cos(angle), casterY + areaRange * Math.Sin(angle), thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW).Destroy()
            set sfxToSpawn = sfxToSpawn - 1
        endloop
        set User.TEMP = caster.Owner.Get()
        set UnitList.TEMP = targetGroup
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(casterX, casterY, areaRange, thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            loop
                call targetGroup.Add(target)
                call thistype(NULL).Target.Start(target, caster, level)
                call caster.DamageUnitBySpell(target, this.damage, false, false)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
	timerMethod NewWave
		local thistype this = Timer.GetExpired().GetData()
		set this.areaRange = 0.
		call this.targetGroup.Clear()
	endmethod
    eventMethod Event_BuffLose
        local Unit caster = params.Unit.GetTrigger()
        local thistype this = caster
        local real animSpeedAdd = this.animSpeedAdd
        local Timer updateTimer = this.updateTimer
        local Timer waveTimer = this.waveTimer
        call updateTimer.Destroy()
        call waveTimer.Destroy()
        call caster.Animation.Speed.Subtract(animSpeedAdd)
        call caster.Death.Protection.Subtract()
    endmethod
    eventMethod Event_BuffGain
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Buff.GetLevel()
        local SpellInstance whichInstance = params.Buff.GetData()
        local real animSpeedAdd = SetVar.GetValDefR("animspeed", 0.5) * 1.2 / thistype.THIS_SPELL.GetChannelTime(level) - 1
        local real updateTime = thistype.UPDATE_TIME / thistype.WAVES_AMOUNT[level]
		local thistype this = caster
        local Timer updateTimer = Timer.Create()
        local Timer waveTimer = Timer.Create()
        set this.animSpeedAdd = animSpeedAdd
        set this.areaRange = 0.
        set this.areaRangeAdd = thistype.THIS_SPELL.GetAreaRange(level) / thistype.THIS_SPELL.GetChannelTime(level) * thistype.WAVES_AMOUNT[level] * updateTime
        set this.damage = thistype.DAMAGE[level]
        set this.targetGroup = UnitList.Create()
        set this.updateTimer = updateTimer
        set this.waveTimer = waveTimer
        set this.whichInstance = whichInstance
        call updateTimer.SetData(this)
        call waveTimer.SetData(this)
        call caster.Animation.Speed.Add(animSpeedAdd)
        call caster.Death.Protection.Add()
        call updateTimer.Start(updateTime, true, function thistype.Update)
		call waveTimer.Start(thistype.THIS_SPELL.GetChannelTime(level) / thistype.WAVES_AMOUNT[level], true, function thistype.NewWave)
    endmethod
    eventMethod Event_EndCast
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_SpellEffect
        call params.Unit.GetTrigger().Buffs.AddEx(thistype.DUMMY_BUFF, params.Spell.GetLevel(), params.SpellInstance.GetTrigger())
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
        call thistype(NULL).Target.Init()
    endmethod
endstruct
    scope FolderSummonPolarBear
    scope FolderSummon
    public struct StructCallback
        implement Allocation
        implement List
        
    	endstruct
	endscope
    public struct StructSummon
        implement Allocation
        implement List
        
        static Event BEAR_DEATH_EVENT
        static Event CASTER_DEATH_EVENT
    static key GetKeyMacro_KEY
    static constant integer KEY = Math.Integer.MIN + GetKeyMacro_KEY
        Unit bear
        Unit caster
        integer level
		method KillBear takes nothing returns nothing
			local Unit bear = this.bear
			local Unit caster = this.caster
			local integer level = this.level
            local real remainingLife = bear.Life.Get()
            call bear.KillInstantly()
            call caster.HealBySpell(caster, thistype.HEAL[level] + remainingLife * thistype.HEAL_FACTOR[level])
		endmethod
        eventMethod Event_Bear_Death
            local Unit bear = params.Unit.GetTrigger()
            local thistype this = bear.Data.Integer.Get(KEY)
            local Unit caster = this.caster
            call this.deallocate()
            call bear.Data.Integer.Remove(KEY)
            call bear.Event.Remove(BEAR_DEATH_EVENT)
            call caster.Data.Integer.Remove(KEY)
            call caster.Event.Remove(CASTER_DEATH_EVENT)
			call HeroSpell.ReplaceSlot(SpellClass.HERO_SECOND, SummonPolarBear.THIS_SPELL, caster)
        endmethod
        eventMethod Event_Caster_Death
            local thistype this = params.Unit.GetTrigger().Data.Integer.Get(KEY)
            call this.bear.KillInstantly()
        endmethod
        static method Start takes Unit caster, integer level, Unit target, real x, real y returns nothing            
            local thistype this = caster.Data.Integer.Get(KEY)
			local Unit bear
            if (this != NULL) then
                call this.KillBear()
            endif
			local User casterOwner = caster.Owner.Get()
            set bear = Unit.CreateSummon(thistype.SUMMON_UNIT_TYPE[level], casterOwner, x, y, UNIT.Facing.STANDARD, thistype.DURATION[level])
            set this = thistype.allocate()
            set this.bear = bear
            set this.caster = caster
            set this.level = level
            call bear.Data.Integer.Set(KEY, this)
            call bear.Event.Add(BEAR_DEATH_EVENT)
            call caster.Data.Integer.Set(KEY, this)
            call caster.Event.Add(CASTER_DEATH_EVENT)
			call HeroSpell.ReplaceSlot(SpellClass.HERO_SECOND, thistype.CALLBACK_SPELL, caster)
            call bear.Buffs.Timed.Start(UNIT.Invulnerability.NORMAL_BUFF, level, thistype.INVU_DURATION[level])
            call bear.Abilities.Add(thistype.TAUNT_SPELL)
            call casterOwner.EnableAbility(thistype.TAUNT_SPELL, true)
            call bear.Order.Immediate(Order.TAUNT)
            call casterOwner.EnableAbility(thistype.TAUNT_SPELL, false)
            if target.IsAllyOf(casterOwner) then
                call bear.Abilities.AddWithLevel(ArcticBlink.THIS_SPELL, level)
                call target.Buffs.Timed.Start(UNIT.Invulnerability.NORMAL_BUFF, level, thistype.INVU_DURATION[level])
            else
                call bear.Abilities.AddWithLevel(ArcticBlink.THIS_SPELL, level + 1)
                
                call bear.Order.UnitTargetBySpell(ArcticBlink.THIS_SPELL, target)
            endif
        endmethod
		eventMethod Event_SpellEffect
			local Unit caster = params.Unit.GetTrigger()
			local thistype this = caster.Data.Integer.Get(KEY)
			call this.KillBear()
		endmethod
        static method Init takes nothing returns nothing
            set thistype.BEAR_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Bear_Death)
            set thistype.CASTER_DEATH_EVENT = Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Caster_Death)
            call thistype.CALLBACK_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        endmethod
    endstruct
endscope
    globals
        SummonPolarBear SUMMON_POLAR_BEAR = STRUCT_BASE
    endglobals
    struct SummonPolarBear
        implement Allocation
        implement List
        
    Unit caster
    integer level
    Unit target
    FolderSummonPolarBear_StructSummon Summon = this
    FolderSummonPolarBear_StructSummon LinkToStruct_Summon
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        local integer level = this.level
        local Unit target = this.target
        local real targetX = dummyMissile.Position.X.Get()
        local real targetY = dummyMissile.Position.Y.Get()
        call this.deallocate()
        call dummyMissile.Destroy()
        call thistype(NULL).Summon.Start(caster, level, target, targetX, targetY)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local real targetX = target.Position.X.Get()
        local real targetY = target.Position.Y.Get()
        local thistype this = thistype.allocate()
		local Missile dummyMissile = Missile.Create()
        set this.caster = caster
        set this.level = level
        set this.target = target
		local UnitType summonType = thistype(NULL).Summon.SUMMON_UNIT_TYPE[level]
        call dummyMissile.Arc.SetByPerc(0.06)
        call dummyMissile.CollisionSize.Set(2 * summonType.CollisionSize.Get())
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 0.25)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(summonType.Speed.Get() * 4.)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.GoToSpot.Start(targetX, targetY, Spot.GetHeight(targetX, targetY))
    endmethod
    initMethod Init of Spells_Hero
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Summon.Init()
    endmethod
endstruct
    globals
        ArcticBlink ARCTIC_BLINK = STRUCT_BASE
    endglobals
    struct ArcticBlink
        implement Allocation
        implement List
        
    Unit caster
    integer level
    Unit target
    static method Conditions takes Unit caster, Unit target returns boolean
        if (target == NULL) then
            return false
        endif
        if target.IsAllyOf(caster.Owner.Get()) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        local integer level = this.level
        local Unit target = this.target
        call this.deallocate()
        call dummyMissile.Destroy()
        if thistype.Conditions(caster, target) then
            call target.Buffs.Timed.Start(UNIT.Stun.NORMAL_BUFF, level, thistype.STUN_DURATION)
            call caster.DamageUnitBySpell(target, thistype.DAMAGE[level], true, false)
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        local thistype this = thistype.allocate()
		local Missile dummyMissile = Missile.Create()
        set this.caster = caster
        set this.level = level
        set this.target = target
        call caster.Position.SetWithCollision(target.Position.X.Get(), target.Position.Y.Get())
        call caster.Facing.SetToUnit(target)
        call dummyMissile.CollisionSize.Set(10.)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 2.)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(700.)
        call dummyMissile.GoToUnit.Start(target, null)
    endmethod
    initMethod Init of Spells_Misc
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        Devour DEVOUR = STRUCT_BASE
    endglobals
    struct Devour
        implement Allocation
        implement List
        
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        call target.Transport.AddTo(caster)
    endmethod
    initMethod Init of Spells_Misc
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        Susanoo SUSANOO = STRUCT_BASE
    endglobals
    struct Susanoo
        implement Allocation
        implement List
        
    static Event DEATH_EVENT
    real armorAdd
    real durationAdd
    eventMethod Event_Death
        local Unit target = params.Unit.GetKiller()
        local thistype this = target
        local real durationAdd = this.durationAdd
        set this.durationAdd = durationAdd * (1. + thistype.DURATION_ADD_ADD_FACTOR)
        call target.Effects.Create(thistype.ADD_TIME_EFFECT_PATH, thistype.ADD_TIME_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
        call target.Buffs.Timed.AddTime(thistype.DUMMY_BUFF, durationAdd)
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
		call Spot.CreateEffect(target.Position.X.Get(), target.Position.Y.Get(), thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW).Destroy()
        local real armorAdd = thistype.ARMOR_INC[level]
        local thistype this = target
        set this.armorAdd = armorAdd
        set this.durationAdd = thistype.DURATION_ADD[level]
        call target.Armor.IgnoreDamage.Relative.Add(armorAdd)
        call target.Event.Add(DEATH_EVENT)
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local real armorAdd = this.armorAdd
        call target.Armor.IgnoreDamage.Relative.Subtract(armorAdd)
        call target.Event.Remove(DEATH_EVENT)
    endmethod
    eventMethod Event_SpellEffect
        local integer level = params.Spell.GetLevel()
        call params.Unit.GetTrigger().Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION[level])
    endmethod
    initMethod Init of Spells_Hero
        set thistype.DEATH_EVENT = Event.Create(UNIT.Death.Events.KILLER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Death)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        Swiftness SWIFTNESS = STRUCT_BASE
    endglobals
    struct Swiftness
        implement Allocation
        implement List
        
    integer count
    Timer intervalTimer
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        local Unit target = this
        local integer count = this.count
        call target.Buffs.Remove(thistype.CHARGE_BUFF[count])
        set this.count = count - 1
        if (count == 1) then
            call target.Buffs.Remove(thistype.TIMER_BUFF)
        endif
    endmethod
    eventMethod Event_Timer_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local integer count = this.count
        local Timer intervalTimer = this.intervalTimer
        call intervalTimer.Destroy()
        loop
            exitwhen (count < 1)
            call target.Buffs.Remove(thistype.CHARGE_BUFF[count])
            set count = count - 1
        endloop
    endmethod
    eventMethod Event_Timer_BuffGain
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local Timer intervalTimer = Timer.Create()
        set this.intervalTimer = intervalTimer
        call intervalTimer.SetData(this)
        call intervalTimer.Start(thistype.DURATION[1], true, function thistype.Interval)
    endmethod
    static method Start takes Unit target, integer level returns nothing
        local thistype this = target
		local integer count
        if not target.Buffs.Contains(thistype.TIMER_BUFF) then
            set count = 1
        else
            set count = this.count + 1
        endif
        set this.count = count
        call target.Buffs.Add(thistype.TIMER_BUFF, 1)
        call target.Buffs.Add(thistype.CHARGE_BUFF[count], level)
    endmethod
    initMethod Init of Spells_Hero
        call thistype.TIMER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Timer_BuffGain))
        call thistype.TIMER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Timer_BuffLose))
    endmethod
endstruct
    scope FolderTempestStrike
    public struct StructCriticalAttacks
        implement Allocation
        implement List
        
        static method Start takes integer level, Unit target returns nothing
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION)
        endmethod
        static method Init takes nothing returns nothing
        endmethod
    endstruct
endscope
    globals
        TempestStrike TEMPEST_STRIKE = STRUCT_BASE
    endglobals
    struct TempestStrike
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    static constant real UPDATE_TIME = (1 * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer UPDATE_TIME_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / (1 * 1.))
    real damage
    integer level
    UnitList targetGroup
    Timer updateTimer
    FolderTempestStrike_StructCriticalAttacks CriticalAttacks = this
    FolderTempestStrike_StructCriticalAttacks LinkToStruct_CriticalAttacks
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if UnitList.TEMP.Contains(target) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    timerMethod Update
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this
        local UnitList targetGroup = this.targetGroup
		
        	call caster.Animation.SetByIndex(0)
        
        set UnitList.TEMP = targetGroup
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(caster.Position.X.Get(), caster.Position.Y.Get(), thistype.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real damage = this.damage
            loop
                call target.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.NORMAL)
                call targetGroup.Add(target)
                call caster.DamageUnitBySpell(target, damage, false, true)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        local integer level = this.level
        local UnitList targetGroup = this.targetGroup
        local Timer updateTimer = this.updateTimer
        local boolean useBuff = (targetGroup.GetFirst() != NULL)
        call targetGroup.Destroy()
        call updateTimer.Destroy()
        call target.Animation.Queue(UNIT.Animation.STAND)
        if useBuff then
            call thistype(NULL).CriticalAttacks.Start(level, target)
        endif
    endmethod
    eventMethod Event_BuffGain
        local EventResponse castParams = params.Buff.GetData()
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
		local thistype this = target
		local Timer updateTimer = Timer.Create()
        set this.damage = thistype.DAMAGE[level]
        set this.level = level
        set this.targetGroup = UnitList.Create()
        set this.updateTimer = updateTimer
        call updateTimer.SetData(this)
        local real targetX = castParams.Spot.GetTargetX()
        local real targetY = castParams.Spot.GetTargetY()
        call target.Effects.Create(thistype.SPECIAL_EFFECT_ATTACH_POINT, thistype.SPECIAL_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).DestroyTimed.Start(thistype.DURATION)
        set thistype.DURATION = SetVar.GetValDefR("dur", thistype.DURATION)
        set thistype.LENGTH = SetVar.GetValDefR("length", thistype.LENGTH)
        set thistype.SPEED_END = SetVar.GetValDefR("speedEnd", thistype.SPEED_END)
        call target.Position.Timed.Accelerated.AddKnockback(2. * thistype.LENGTH / thistype.DURATION - thistype.SPEED_END, 2. / thistype.DURATION * (thistype.SPEED_END - thistype.LENGTH / thistype.DURATION), Math.AtanByDeltas(targetY - target.Position.Y.Get(), targetX - target.Position.X.Get()), thistype.DURATION)
        call updateTimer.Start(thistype.UPDATE_TIME, true, function thistype.Update)
        call target.Abilities.Refresh(SapphireblueDagger.THIS_SPELL)
    endmethod
    eventMethod Event_SpellEffect
        call params.Unit.GetTrigger().Buffs.Timed.StartEx(thistype.DUMMY_BUFF, params.Spell.GetLevel(), params, thistype.DURATION)
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).CriticalAttacks.Init()
    endmethod
endstruct
    scope FolderTsukuyomi
    public struct StructMissile
        implement Allocation
        implement List
        
        Unit caster
        integer level
        real targetX
        real targetY
        eventMethod Impact
            local Missile dummyMissile = params.Missile.GetTrigger()
            local thistype this = dummyMissile.GetData()
            local Unit caster = this.caster
            local integer level = this.level
            local real targetX = this.targetX
            local real targetY = this.targetY
            call this.deallocate()
            call dummyMissile.Destroy()
            set Tsukuyomi.TARGET_X = targetX
            set Tsukuyomi.TARGET_Y = targetY
            call caster.Buffs.Timed.Start(Tsukuyomi.DUMMY_BUFF, level, Tsukuyomi.DURATION[level])
        endmethod
        static method Start takes Unit caster, integer level, real targetX, real targetY returns nothing
            local thistype this = thistype.allocate()
			local Missile dummyMissile = Missile.Create()
            set this.caster = caster
            set this.level = level
            set this.targetX = targetX
            set this.targetY = targetY
            call dummyMissile.Acceleration.Set(2000.)
            call dummyMissile.Arc.SetByPerc(0.2)
            call dummyMissile.CollisionSize.Set(48.)
            call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1.)
            call dummyMissile.Impact.SetAction(function thistype.Impact)
            call dummyMissile.SetData(this)
            call dummyMissile.Speed.Set(500.)
            call dummyMissile.Position.SetFromUnit(caster)
            call dummyMissile.GoToSpot.Start(targetX, targetY, Spot.GetHeight(targetX, targetY))
        endmethod
    endstruct
    public struct StructRelocate
        implement Allocation
        implement List
        
        eventMethod Event_SpellEffect
            local Unit caster = params.Unit.GetTrigger()
            local real targetX = params.Spot.GetTargetX()
            local real targetY = params.Spot.GetTargetY()
            local Tsukuyomi parent = caster
            call parent.movingDummyUnit.Order.PointTarget(Order.MOVE, targetX, targetY)
        endmethod
        static method Init takes nothing returns nothing
            call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        endmethod
    endstruct
    public struct StructTarget
        implement Allocation
        implement List
        
    	static Event ENDING_EVENT
        static Event START_EVENT
		eventMethod Event_Ending
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local Tsukuyomi parent = aura.GetData()
			call target.Buffs.Subtract(thistype.DUMMY_BUFF)
		endmethod
		eventMethod Event_Start
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local Unit caster = aura.GetCaster()
			local Tsukuyomi parent = aura.GetData()
			local integer level = parent.level
			call target.Buffs.Add(thistype.DUMMY_BUFF, level)
		endmethod
        static method Init takes nothing returns nothing
            set thistype.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Ending)
            set thistype.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Start)
            call UNIT.Eclipse.NORMAL_BUFF.Variants.Add(thistype.DUMMY_BUFF)
        endmethod
    endstruct
endscope
    globals
        Tsukuyomi TSUKUYOMI = STRUCT_BASE
    endglobals
    struct Tsukuyomi
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    static real TARGET_X
    static real TARGET_Y
    Aura aura
    DummyUnit dummyUnit
    DummyUnit dummyUnit2
    Timer intervalTimer
    integer level
    DummyUnit movingDummyUnit
    real pullFactor
    real stolenMana
    real targetX
    real targetY
    FolderTsukuyomi_StructMissile Missile = this
    FolderTsukuyomi_StructMissile LinkToStruct_Missile
    FolderTsukuyomi_StructRelocate Relocate = this
    FolderTsukuyomi_StructRelocate LinkToStruct_Relocate
    FolderTsukuyomi_StructTarget Target = this
    FolderTsukuyomi_StructTarget LinkToStruct_Target
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this
        local DummyUnit movingDummyUnit = this.dummyUnit
        local real x = movingDummyUnit.Position.X.GetNative()
        local real y = movingDummyUnit.Position.Y.GetNative()
        local User casterOwner = caster.Owner.Get()
        set User.TEMP = casterOwner
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(x, y, this.aura.GetAreaRange(), thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real pullFactor = this.pullFactor
            local real stolenManaAll = 0.
            local real stolenManaMax = this.stolenMana
            loop
                call target.Position.Timed.AddSpeedDirection(target.Movement.Speed.Get() * pullFactor, Math.AtanByDeltas(y - target.Position.Y.Get(), x - target.Position.X.Get()), thistype.INTERVAL)
                if target.IsAllyOf(casterOwner) then
                    call target.Mana.Subtract(stolenManaMax)
                else
                    set stolenMana = Math.Min(target.Mana.Get(), stolenManaMax)
                    call caster.BurnManaBySpell(target, stolenMana)
                    set stolenManaAll = stolenManaAll + stolenMana
                endif
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
            if (stolenManaAll > 0.) then
                call caster.HealManaBySpell(caster, stolenManaAll * thistype.STOLEN_MANA_ABSORPTION_FACTOR)
            endif
        endif
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
		local Aura aura = this.aura
        local DummyUnit dummyUnit = this.dummyUnit
        local DummyUnit dummyUnit2 = this.dummyUnit2
        local Timer intervalTimer = this.intervalTimer
		call aura.Destroy()
        call dummyUnit.DestroyInstantly()
        call dummyUnit2.Destroy()
        call intervalTimer.Destroy()
        call HeroSpell.AddToUnit(thistype.THIS_SPELL, target)
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local real targetX = thistype.TARGET_X
        local real targetY = thistype.TARGET_Y
        local real targetZ = Spot.GetHeight(targetX, targetY)
		local real areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        local thistype this = target
		local Aura aura = Aura.Create(target)
        local DummyUnit dummyUnit = DummyUnit.Create(thistype.DUMMY_UNIT_ID, targetX, targetY, targetZ - 80., 0.)
        local DummyUnit dummyUnit2 = DummyUnit.Create(thistype.DUMMY_UNIT2_ID, targetX, targetY, targetZ + 150., 0.)
        local Timer intervalTimer = Timer.Create()
        local DummyUnit movingDummyUnit = DummyUnit.Create(thistype.MOVING_DUMMY_UNIT_ID, targetX, targetY, targetZ, 0.)
        set this.aura = aura
        set this.dummyUnit = dummyUnit
        set this.dummyUnit2 = dummyUnit2
        set this.intervalTimer = intervalTimer
        set this.level = level
        set this.movingDummyUnit = movingDummyUnit
        set this.pullFactor = thistype.PULL_FACTOR[level]
        set this.stolenMana = thistype.STOLEN_MANA[level]
        set this.targetX = targetX
        set this.targetY = targetY
        call aura.SetData(this)
        call intervalTimer.SetData(this)
		call aura.SetAreaRange(areaRange)
        call aura.SetTargetFilter(thistype.TARGET_FILTER)
		call aura.Event.Add(thistype(NULL).Target.ENDING_EVENT)
		call aura.Event.Add(thistype(NULL).Target.START_EVENT)
		call aura.Enable()
        call dummyUnit.FollowDummyUnit.Start(movingDummyUnit, false, 0., 0., -80.)
        call dummyUnit.Scale.Set(0.)
        call dummyUnit.Scale.Timed.Add(areaRange * 5 / (3 * 128.), 0.25)
        call dummyUnit2.FollowDummyUnit.Start(movingDummyUnit, false, 0., 0., 150.)
        call dummyUnit2.Scale.Set(0.)
        call dummyUnit2.Scale.Timed.Add(areaRange * 8 / (3 * 128.), 0.25)
        if (target.Type.Get() == UnitType.JOTA) then
            call dummyUnit.VertexColor.Set(0., 200., 255., 200.)
            call dummyUnit2.VertexColor.Set(0., 200., 200., 255.)
        elseif (target.Type.Get() == UnitType.LIZZY) then
            call dummyUnit.VertexColor.Set(255., 255., 255., 200.)
        elseif (target.Type.Get() == UnitType.TAJRAN) then
            call dummyUnit.VertexColor.Set(63., 255., 0., 200.)
            call dummyUnit2.VertexColor.Set(63., 255., 0., 255.)
        endif
        call movingDummyUnit.SetMoveSpeed(thistype(NULL).Relocate.SPEED)
        call movingDummyUnit.SetMoveWindow(1.)
        call movingDummyUnit.SetTurnSpeed(Math.FULL_ANGLE)
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
        call HeroSpell.AddToUnit(thistype(NULL).Relocate.THIS_SPELL, target)
    endmethod
    eventMethod Event_SpellEffect
        call thistype(NULL).Missile.Start(params.Unit.GetTrigger(), params.Spell.GetLevel(), params.Spot.GetTargetX(), params.Spot.GetTargetY())
    endmethod
    initMethod Init of Spells_Hero
    	set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        local integer iteration = thistype.THIS_SPELL.GetLevelsAmount()
        loop
            set thistype.STOLEN_MANA[iteration] = thistype.STOLEN_MANA[iteration] * thistype.INTERVAL
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        call thistype(NULL).Target.Init()
        call thistype(NULL).Relocate.Init()
    endmethod
endstruct
    scope FolderWanShroud
    public struct StructMissile
        implement Allocation
        implement List
        
        Unit caster
        integer level
        real targetX
        real targetY
        eventMethod Impact
            local Missile dummyMissile = params.Missile.GetTrigger()
            local thistype this = dummyMissile.GetData()
            local Unit caster = this.caster
            local integer level = this.level
            local real targetX = this.targetX
            local real targetY = this.targetY
            call this.deallocate()
            call dummyMissile.Destroy()
            call WanShroud.Start(caster, level, targetX, targetY)
        endmethod
        static method Start takes Unit caster, integer level, real targetX, real targetY returns nothing
            local thistype this = thistype.allocate()
			local Missile dummyMissile = Missile.Create()
            set this.caster = caster
            set this.level = level
            set this.targetX = targetX
            set this.targetY = targetY
            call dummyMissile.Acceleration.Set(2000.)
            call dummyMissile.Arc.SetByPerc(0.2)
            call dummyMissile.CollisionSize.Set(48.)
            call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 1.)
            call dummyMissile.Impact.SetAction(function thistype.Impact)
            call dummyMissile.SetData(this)
            call dummyMissile.Speed.Set(500.)
            call dummyMissile.Position.SetFromUnit(caster)
            call dummyMissile.GoToSpot.Start(targetX, targetY, Spot.GetHeight(targetX, targetY))
        endmethod
    endstruct
    public struct StructTarget
        implement Allocation
        implement List
        
        static Event DAMAGE_EVENT
    	static Event ENDING_EVENT
        static Event START_EVENT
        eventMethod Event_Damage
            local Unit damager = params.Unit.GetDamager()
            local Unit target = params.Unit.GetTrigger()
	        local Unit userHero = damager.Owner.Get().Hero.Get()
	        if ((userHero != NULL) and not userHero.Classes.Contains(UnitClass.DEAD)) then
	            set damager = userHero
	        endif
			call damager.LifeLeech.DoWithVal(target, thistype.LIFE_LEECH[target.Buffs.GetLevel(thistype.DUMMY_BUFF)])
            call damager.ManaLeech.DoWithVal(target, thistype.MANA_LEECH[target.Buffs.GetLevel(thistype.DUMMY_BUFF)])
        endmethod
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            call target.Event.Remove(DAMAGE_EVENT)
        endmethod
        eventMethod Event_BuffGain
            local Unit target = params.Unit.GetTrigger()
            call target.Event.Add(DAMAGE_EVENT)
        endmethod
		eventMethod Event_Ending
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local WanShroud parent = aura.GetData()
			call target.Buffs.Subtract(thistype.DUMMY_BUFF)
		endmethod
		eventMethod Event_Start
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local Unit caster = aura.GetCaster()
			local WanShroud parent = aura.GetData()
			local integer level = parent.level
			call target.Buffs.Add(thistype.DUMMY_BUFF, level)
		endmethod
        static method Init takes nothing returns nothing
        	set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
            set thistype.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Ending)
            set thistype.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Start)
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
    endstruct
endscope
    globals
        WanShroud WAN_SHROUD = STRUCT_BASE
    endglobals
    struct WanShroud
        implement Allocation
        implement List
        
    static BoolExpr AURA_FILTER
    static BoolExpr DAMAGE_FILTER
    static real array DAMAGE_PER_INTERVAL
    DummyUnit areaDummyUnit
    Aura aura
    Unit caster
    real damage
    Timer intervalTimer
    integer level
    real targetX
    real targetY
    FolderWanShroud_StructMissile Missile = this
    FolderWanShroud_StructMissile LinkToStruct_Missile
    FolderWanShroud_StructTarget Target = this
    FolderWanShroud_StructTarget LinkToStruct_Target
    timerMethod Ending
        local Timer durationTimer = Timer.GetExpired()
        local thistype this = durationTimer.GetData()
		local Aura aura = this.aura
        local DummyUnit areaDummyUnit = this.areaDummyUnit
        local Timer intervalTimer = this.intervalTimer
        call areaDummyUnit.Destroy()
        call aura.Destroy()
        call durationTimer.Destroy()
        call intervalTimer.Destroy()
    endmethod
    condMethod DamageConditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.Invulnerability.Try() then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
	eventMethod DealDamage
		local thistype this = params.GetData()
		local Unit target = params.Unit.GetTrigger()
        call target.Effects.Create(thistype.DAMAGE_EFFECT_PATH, thistype.DAMAGE_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
        call this.caster.DamageUnitBySpell(target, damage, true, false)
	endmethod
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
		call this.aura.GetTargetGroup().DoEx(function thistype.DealDamage, this)
    endmethod
    condMethod AuraConditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    static method Start takes Unit caster, integer level, real targetX, real targetY returns nothing
        local real areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        local real targetZ = Spot.GetHeight(targetX, targetY)
        local thistype this = thistype.allocate()
        local DummyUnit areaDummyUnit = DummyUnit.Create(thistype.AREA_DUMMY_UNIT_ID, targetX, targetY, targetZ, 0.)
        local Aura aura = Aura.Create(caster)
        local Timer durationTimer = Timer.Create()
        local Timer intervalTimer = Timer.Create()
        set this.areaDummyUnit = areaDummyUnit
        set this.aura = aura
        set this.caster = caster
        set this.damage = thistype.DAMAGE_PER_INTERVAL[level]
        set this.intervalTimer = intervalTimer
        set this.level = level
        set this.targetX = targetX
        set this.targetY = targetY
        call aura.SetData(this)
        call durationTimer.SetData(this)
        call intervalTimer.SetData(this)
        call areaDummyUnit.Scale.Set(areaRange / 180.)
		call aura.SetAreaRange(thistype.THIS_SPELL.GetAreaRange(level))
        call aura.SetTargetFilter(thistype.AURA_FILTER)
		call aura.Event.Add(thistype(NULL).Target.ENDING_EVENT)
		call aura.Event.Add(thistype(NULL).Target.START_EVENT)
		call aura.Enable()
        call intervalTimer.Start(thistype.INTERVAL, true, function thistype.Interval)
        call durationTimer.Start(thistype.DURATION[level], false, function thistype.Ending)
    endmethod
    eventMethod Event_SpellEffect
        call thistype(NULL).Missile.Start(params.Unit.GetTrigger(), params.Spell.GetLevel(), params.Spot.GetTargetX(), params.Spot.GetTargetY())
    endmethod
    initMethod Init of Spells_Hero
        set thistype.AURA_FILTER = BoolExpr.GetFromFunction(function thistype.AuraConditions)
        set thistype.DAMAGE_FILTER = BoolExpr.GetFromFunction(function thistype.DamageConditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
		local integer level = thistype.THIS_SPELL.GetLevelsAmount()
		loop
			exitwhen (level < 1)
			set thistype.DAMAGE_PER_INTERVAL[level] = thistype.DAMAGE_PER_SECOND[level] * thistype.INTERVAL
			set level = level - 1
		endloop
        call thistype(NULL).Target.Init()
    endmethod
endstruct
    scope FolderWarcry
    public struct StructTarget
        implement Allocation
        implement List
        
    	UnitModSet dmgMod
    	eventMethod Event_BuffLose
	        local Unit target = params.Unit.GetTrigger()
	        local thistype this = target
	        local UnitModSet dmgMod = this.dmgMod
	        call target.ModSets.Remove(dmgMod)
	        call dmgMod.Destroy()
    	endmethod
	    eventMethod Event_BuffGain
	    	local Unit caster = params.Buff.GetData()
	        local integer level = params.Buff.GetLevel()
	        local Unit target = params.Unit.GetTrigger()
	
			local thistype this = target
	
	        local UnitModSet dmgMod = UnitModSet.Create()
	        set this.dmgMod = dmgMod
	
	        call dmgMod.RealMods.Add(UNIT.Damage.Bonus.STATE, thistype.DMG_INC[level] + Math.Max(0, thistype.DMG_INC_PER_VIGOR[level] * caster.Strength.Get()))
	
	        call target.ModSets.Add(dmgMod)
	    endmethod
        static method Start takes Unit caster, integer level, Unit target returns nothing
        	call target.Buffs.Remove(thistype.DUMMY_BUFF)
            call target.Buffs.Timed.StartEx(thistype.DUMMY_BUFF, level, caster, thistype.DURATION[level])
        endmethod
        static method Init takes nothing returns nothing
	        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
	        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        endmethod
    endstruct
endscope
    globals
        Warcry WARCRY = STRUCT_BASE
    endglobals
    struct Warcry
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    FolderWarcry_StructTarget Target = this
    FolderWarcry_StructTarget LinkToStruct_Target
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
		call Spot.CreateEffect(casterX, casterY, thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW).Destroy()
        local real colSize = caster.CollisionSize.Get(true)
        local real areaRange = thistype.THIS_SPELL.GetAreaRange(level) + colSize
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(casterX, casterY, areaRange, thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            local real attackDisableDuration = thistype.ATTACK_DISABLE_DURATION[level]
            local User casterOwner = caster.Owner.Get()
            local real damageLifeFactor = thistype.DAMAGE_LIFE_FACTOR[level]
            loop
                local real d = Math.DistanceByDeltas(target.Position.X.Get() - casterX, target.Position.Y.Get() - casterY)
                local real rangeFactor = Math.Shapes.LinearFromCoords(colSize, thistype.RANGE_FACTOR_CLOSE, areaRange, thistype.RANGE_FACTOR_FAR, d)
                if target.IsAllyOf(casterOwner) then
                    call thistype(NULL).Target.Start(caster, level, target)
                else
                    if not target.MagicImmunity.Try() then
                        call target.Buffs.Timed.Start(UNIT.Attack.NORMAL_BUFF, level, attackDisableDuration)
                        call caster.DamageUnitBySpell(target, target.Life.Get() * damageLifeFactor * rangeFactor, true, false)
                    endif
                endif
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    initMethod Init of Spells_Hero
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Target.Init()
    endmethod
endstruct
    scope FolderWaterBindings
    public struct StructSummon
        implement Allocation
        implement List
        
    	static Event DESTROY_EVENT
    	
    	real animusAdd
    	Unit caster
    	
    	eventMethod Event_Destroy
    		local Unit summon = params.Unit.GetTrigger()
    		
    		local thistype this = summon
    		
    		call summon.Event.Remove(DESTROY_EVENT)
    		
    		call caster.Intelligence.Bonus.Subtract(this.animusAdd)
    	endmethod
    	
        static method Start takes Unit caster, integer level, Unit target returns nothing
            local User casterOwner = caster.Owner.Get()
            local real casterX = caster.Position.X.Get()
            local real casterY = caster.Position.Y.Get()
            local real targetX = target.Position.X.Get()
            local real targetY = target.Position.Y.Get()
            local real angle = caster.CastAngle(targetX - casterX, targetY - casterY) 
            local Unit summon = Unit.CreateSummon(thistype.THIS_UNIT_TYPES[level], casterOwner, casterX + thistype.OFFSET * Math.Cos(angle), casterY + thistype.OFFSET * Math.Sin(angle), angle, thistype.DURATION[level])
			call summon.Event.Add(DESTROY_EVENT)
			local real animusAdd = thistype.ANIMUS_INC[level]
			set thistype(summon).animusAdd = animusAdd
			set thistype(summon).caster = caster
			call caster.Intelligence.Bonus.Add(animusAdd)
			call summon.Abilities.AddWithLevel(SoakingAttack.THIS_SPELL, level)
			return
            call summon.Abilities.AddWithLevel(Lariat.THIS_SPELL, level)
            call casterOwner.EnableAbility(Lariat.THIS_SPELL, true)
            call summon.Order.UnitTargetBySpell(Lariat.THIS_SPELL, target)
            call casterOwner.EnableAbility(Lariat.THIS_SPELL, false)
        endmethod
        static method Init takes nothing returns nothing
        	set thistype.DESTROY_EVENT = Event.Create(Unit.DESTROY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Destroy)
        endmethod
    endstruct
endscope
    globals
        WaterBindings WATER_BINDINGS = STRUCT_BASE
    endglobals
    struct WaterBindings
        implement Allocation
        implement List
        
    FolderWaterBindings_StructSummon Summon = this
    FolderWaterBindings_StructSummon LinkToStruct_Summon
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        call thistype(NULL).Summon.Start(caster, level, target)
    endmethod
    initMethod Init of Spells_Hero
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Summon.Init()
    endmethod
endstruct
    globals
        Lariat LARIAT = STRUCT_BASE
    endglobals
    struct Lariat
        implement Allocation
        implement List
        
    static real array DAMAGE_PER_INTERVAL
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    real damage
    Lightning effectLightning
    Timer intervalTimer
    Unit target
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        local Unit caster = this
        call caster.DamageUnitBySpell(target, this.damage, true, false)
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local integer iteration = target.Data.Integer.Table.Count(KEY_ARRAY)
        loop
            exitwhen (iteration < Memory.IntegerKeys.Table.STARTED)
            local thistype this = target.Data.Integer.Table.Get(KEY_ARRAY, iteration)
            local Unit caster = this
            call caster.Stop()
            set iteration = iteration - 1
        endloop
    endmethod
    eventMethod Event_BuffGain
        local Unit target = params.Unit.GetTrigger()
    endmethod
    eventMethod Event_EndCast
        local Unit caster = params.Unit.GetTrigger()
        local boolean success = params.Spell.IsChannelComplete()
        local thistype this = caster
        local Lightning effectLightning = this.effectLightning
        local Timer intervalTimer = this.intervalTimer
        local Unit target = this.target
        call effectLightning.Destroy()
        call intervalTimer.Destroy()
        if target.Data.Integer.Table.Remove(KEY_ARRAY, this) then
            call target.Buffs.Remove(thistype.DUMMY_BUFF)
        endif
        if success then
            call caster.Order.UnitTarget(Order.ATTACK, target)
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        local thistype this = caster
		local Lightning effectLightning = Lightning.Create(thistype.BOLT)
		local Timer intervalTimer = Timer.Create()
        set this.damage = thistype.DAMAGE_PER_INTERVAL[level]
        set this.effectLightning = effectLightning
        set this.intervalTimer = intervalTimer
        set this.target = target
        call intervalTimer.SetData(this)
        if target.Data.Integer.Table.Add(KEY_ARRAY, this) then
            call target.Buffs.Add(thistype.DUMMY_BUFF, 1)
        endif
        call effectLightning.FromUnitToUnit.Start(caster, target)
        call intervalTimer.Start(thistype.INTERVAL[level], true, function thistype.Interval)
    endmethod
    initMethod Init of Spells_Hero
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Finish.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_EndCast))
        local integer iteration = thistype.THIS_SPELL.GetLevelsAmount()
        loop
            set thistype.DAMAGE_PER_INTERVAL[iteration] = thistype.DAMAGE_PER_SECOND[iteration] * thistype.INTERVAL[iteration]
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
    endmethod
endstruct
    scope FolderSoakingAttack
    public struct StructTarget
        implement Allocation
        implement List
        
	    integer count
	    Timer intervalTimer
	
	    timerMethod Interval
	        local thistype this = Timer.GetExpired().GetData()
	
	        local Unit target = this
	
	        local integer count = this.count
	
	        call target.Buffs.Remove(thistype.CHARGE_BUFF[count])
	
	        set this.count = count - 1
	call DebugEx("reduce to "+I2S(count-1))
	        if (count == 1) then
	            call target.Buffs.Remove(thistype.TIMER_BUFF)
	        endif
	    endmethod
	    eventMethod Event_Timer_BuffLose
	        local Unit target = params.Unit.GetTrigger()
	
	        local thistype this = target
	
	        local integer count = this.count
	        local Timer intervalTimer = this.intervalTimer
	
	        call intervalTimer.Destroy()
	
	        loop
	            exitwhen (count < 1)
	
	            call target.Buffs.Remove(thistype.CHARGE_BUFF[count])
	
	            set count = count - 1
	        endloop
	    endmethod
	    eventMethod Event_Timer_BuffGain
	    	local integer level = params.Buff.GetLevel()
	        local Unit target = params.Unit.GetTrigger()
	
	        local thistype this = target
	
	        local Timer intervalTimer = Timer.Create()
	
	        set this.intervalTimer = intervalTimer
	        call intervalTimer.SetData(this)
	    endmethod
	
		static method StartTimer takes integer level, Unit target returns nothing
			local thistype this = target
			
			local Timer intervalTimer = this.intervalTimer
			local real duration
			
			if target.Classes.Contains(UnitClass.HERO) then
				set duration = thistype.HERO_DURATION[level]
			else
				set duration = thistype.DURATION[level]
			endif
	
	        call intervalTimer.Start(duration, true, function thistype.Interval)
		endmethod
	
	    static method Start takes Unit caster, integer level, Unit target returns nothing
	        local integer count
	
	        local thistype this = target
	
	        if (target.Buffs.Contains(thistype.TIMER_BUFF) == false) then
	            set count = 1
	        else
	            set count = Math.MinI(this.count + 1, 3)
	        endif
	
	        set this.count = count
	call DebugEx("apply "+I2S(count))
	        call target.Buffs.Add(thistype.CHARGE_BUFF[count], level)
	        
	        call target.Buffs.Add(thistype.TIMER_BUFF, 1)
	        
	        call thistype.StartTimer(level, target)
	    endmethod
        static method Init takes nothing returns nothing
    	    call thistype.TIMER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Timer_BuffGain))
	        call thistype.TIMER_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Timer_BuffLose))
        endmethod
    endstruct
endscope
    globals
        SoakingAttack SOAKING_ATTACK = STRUCT_BASE
    endglobals
    struct SoakingAttack
        implement Allocation
        implement List
        
    static Event DAMAGE_EVENT
    FolderSoakingAttack_StructTarget Target = this
    FolderSoakingAttack_StructTarget LinkToStruct_Target
    static method Conditions takes Unit target returns boolean
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_Damage
        local Unit target = params.Unit.GetTrigger()
        if not thistype.Conditions(target) then
            return
        endif
        call thistype(NULL).Target.Start(params.Unit.GetDamager(), params.Unit.GetDamager().Abilities.GetLevel(thistype.THIS_SPELL), target)
    endmethod
    eventMethod Event_BuffLose
        call params.Unit.GetTrigger().Event.Remove(DAMAGE_EVENT)
    endmethod
    eventMethod Event_BuffGain
        call params.Unit.GetTrigger().Event.Add(DAMAGE_EVENT)
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Hero
        set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
        call thistype(NULL).Target.Init()
    endmethod
endstruct
    scope FolderZodiacAura
    public struct StructTarget
        implement Allocation
        implement List
        
    	static Event ENDING_EVENT
        static Event START_EVENT
		eventMethod Event_Ending
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local ZodiacAura parent = aura.GetData()
			call target.Buffs.Subtract(thistype.DUMMY_BUFF)
		endmethod
		eventMethod Event_Start
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local Unit caster = aura.GetCaster()
			local ZodiacAura parent = aura.GetData()
			local integer level = parent.level
			call target.Buffs.Add(thistype.DUMMY_BUFF, level)
		endmethod
        static method Init takes nothing returns nothing
            set thistype.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Ending)
            set thistype.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Start)
        endmethod
    endstruct
endscope
    globals
        ZodiacAura ZODIAC_AURA = STRUCT_BASE
    endglobals
    struct ZodiacAura
        implement Allocation
        implement List
        
    static real array HEAL_PER_INTERVAL
    static BoolExpr TARGET_FILTER
	Aura aura
    Unit caster
    real heal
    Timer intervalTimer
    integer level
    FolderZodiacAura_StructTarget Target = this
    FolderZodiacAura_StructTarget LinkToStruct_Target
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if not target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
	eventMethod DoHeal
		local Unit target = params.Unit.GetTrigger()
		local thistype this = params.GetData()
		call target.Life.Add(this.heal)
        
	endmethod
    timerMethod Interval
        local thistype this = Timer.GetExpired().GetData()
        call this.aura.GetTargetGroup().DoEx(function thistype.DoHeal, this)
    endmethod
    eventMethod Event_BuffLose
        local Unit source = params.Unit.GetTrigger()
        local thistype this = source
		local Aura aura = this.aura
        local Timer intervalTimer = this.intervalTimer
		call aura.Destroy()
        call intervalTimer.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local Unit caster = params.Buff.GetData()
        local integer level = params.Buff.GetLevel()
        local Unit source = params.Unit.GetTrigger()
        local thistype this = source
		local Aura aura = Aura.Create(caster)
        local Timer intervalTimer = Timer.Create()
        set this.aura = aura
        set this.caster = caster
        set this.heal = thistype.HEAL_PER_INTERVAL[level] + caster.Intelligence.Get() * thistype.HEAL_PER_SECOND_PER_ANIMUS[level] * thistype.HEAL_INTERVAL
        set this.intervalTimer = intervalTimer
        set this.level = level
        call aura.SetData(this)
        call intervalTimer.SetData(this)
		call aura.SetAreaRange(Zodiac.THIS_SPELL.GetAreaRange(level))
        call aura.SetTargetFilter(thistype.TARGET_FILTER)
		call aura.Event.Add(thistype(NULL).Target.ENDING_EVENT)
		call aura.Event.Add(thistype(NULL).Target.START_EVENT)
		call aura.Enable()
        call intervalTimer.Start(thistype.HEAL_INTERVAL, true, function thistype.Interval)
    endmethod
    static method AddAbility takes Unit source, Unit caster, integer level returns nothing
        call source.Buffs.AddEx(thistype.DUMMY_BUFF, level, caster)
    endmethod
    initMethod Init of Spells_Hero
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        local integer iteration = Zodiac.THIS_SPELL.GetLevelsAmount()
        loop
            exitwhen (iteration < 1)
            set thistype.HEAL_PER_INTERVAL[iteration] = thistype.HEAL_PER_SECOND[iteration] * thistype.HEAL_INTERVAL
            set iteration = iteration - 1
        endloop
		call thistype(NULL).Target.Init()
    endmethod
endstruct
    globals
        Zodiac ZODIAC = STRUCT_BASE
    endglobals
    struct Zodiac
        implement Allocation
        implement List
        
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
		call this.deallocate_demount()
		call target.Death.Protection.Subtract()
        call target.Buffs.Remove(ZodiacAura.DUMMY_BUFF)
    endmethod
    eventMethod Event_BuffGain
    	local Unit caster = params.Buff.GetData()
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = thistype.allocate_mount(target)
		call target.Death.Protection.Add()
        call ZodiacAura.AddAbility(target, caster, level)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        call target.Buffs.Timed.StartEx(thistype.DUMMY_BUFF, level, caster, thistype.BUFF_DURATION[level])
    endmethod
    initMethod Init of Spells_Hero
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        BigHealingWave BIG_HEALING_WAVE = STRUCT_BASE
    endglobals
    struct BigHealingWave
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    real areaRange
    Unit caster
    Timer delayTimer
    Unit lastTarget
    UnitList targetGroup
    integer targetsAmount
    method Ending takes nothing returns nothing
        call this.deallocate()
        call this.delayTimer.Destroy()
        call this.targetGroup.Destroy()
    endmethod
    method Impact takes Unit lastTarget, Unit newTarget returns nothing
        local Lightning effectLightning = Lightning.CreatePrimarySecondary((lastTarget == newTarget), thistype.BOLT, thistype.BOLT_SEC)
        set this.lastTarget = newTarget
        call caster.HealBySpell(newTarget, thistype.RESTORED_LIFE_FACTOR * newTarget.MaxLife.Get())
        call effectLightning.FromUnitToUnit.Start(lastTarget, newTarget)
        call newTarget.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.LOW).DestroyTimed.Start(0.)
        call this.targetGroup.Add(newTarget)
        call effectLightning.DestroyTimed.Start(0.75)
    endmethod
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if UnitList.TEMP.Contains(target) then
            return false
        endif
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.NEUTRAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if (target.IsAllyOf(User.TEMP) == false) then
            return false
        endif
        return true
    endmethod
    timerMethod ChooseNewTargetByTimer
        local Unit caster
        local Timer delayTimer = Timer.GetExpired()
        local Unit lastTarget
        local real lastTargetX
        local real lastTargetY
        local Unit newTarget
        local thistype this = delayTimer.GetData()
        local UnitList targetGroup = this.targetGroup
        local integer targetsAmount = this.targetsAmount + 1
        if (targetsAmount > thistype.TARGETS_AMOUNT) then
            call this.Ending()
        else
            set caster = this.caster
            set lastTarget = this.lastTarget
            set lastTargetX = lastTarget.Position.X.Get()
            set lastTargetY = lastTarget.Position.Y.Get()
            set UnitList.TEMP = targetGroup
            set User.TEMP = caster.Owner.Get()
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(lastTargetX, lastTargetY, this.areaRange, thistype.TARGET_FILTER)
            set newTarget = thistype.ENUM_GROUP.GetNearest(lastTargetX, lastTargetY)
            if (newTarget == NULL) then
                call this.Ending()
            else
                set this.targetsAmount = targetsAmount
                call this.Impact(lastTarget, newTarget)
            endif
        endif
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
        local thistype this = thistype.allocate()
		local Timer delayTimer = Timer.Create()
        set this.areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        set this.caster = caster
        set this.delayTimer = delayTimer
        set this.lastTarget = target
        set this.targetGroup = UnitList.Create()
        set this.targetsAmount = 1
        call delayTimer.SetData(this)
        call delayTimer.Start(thistype.DELAY, true, function thistype.ChooseNewTargetByTimer)
        call this.Impact(caster, target)
    endmethod
    initMethod Init of Spells_Misc
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        BurningSpiritMeteorite BURNING_SPIRIT_METEORITE = STRUCT_BASE
    endglobals
    struct BurningSpiritMeteorite
        implement Allocation
        implement List
        
    Unit caster
    integer level
    Unit target
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        local integer level = this.level
        local Unit target = this.target
        call this.deallocate_demount()
        call dummyMissile.Destroy()
        call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION)
    endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local Unit target = params.Unit.GetTarget()
		local Missile dummyMissile = Missile.Create()
		local thistype this = thistype.allocate_mount(dummyMissile)
        set this.caster = caster
        set this.level = level
        set this.target = target
        call dummyMissile.CollisionSize.Set(10.)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 2.)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(900.)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.GoToUnit.Start(target, null)
    endmethod
    initMethod Init of Spells_Misc
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        BurnLumber BURN_LUMBER = STRUCT_BASE
    endglobals
    struct BurnLumber
        implement Allocation
        implement List
        
    static Trigger DUMMY_TRIGGER
    condMethod TrigConds
        if (SPELL.Event.Native.GetCast() != thistype.THIS_SPELL) then
            return false
        endif
        return true
    endmethod
    trigMethod Trig
        local Unit caster = UNIT.Event.Native.GetTrigger()
        call caster.HealBySpell(caster, thistype.HEAL)
        call caster.HealManaBySpell(caster, thistype.HEAL_MANA)
    endmethod
    eventMethod Event_Learn
        call thistype.DUMMY_TRIGGER.RegisterEvent.Unit(params.Unit.GetTrigger(), EVENT_UNIT_SPELL_EFFECT)
    endmethod
    initMethod Init of Spells_Misc
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
            set thistype.DUMMY_TRIGGER = Trigger.CreateFromCode(function thistype.Trig)
            call thistype.DUMMY_TRIGGER.AddConditions(function thistype.TrigConds)
    endmethod
endstruct
    globals
        CoreFusion CORE_FUSION = STRUCT_BASE
    endglobals
    struct CoreFusion
        implement Allocation
        implement List
        
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        call caster.HealBySpell(caster, thistype.HEAL_FACTOR * caster.MaxLife.Get())
        call SpotEffectWithSize.Create(caster.Position.X.Get(), caster.Position.Y.Get(), thistype.SPECIAL_EFFECT_PATH, EffectLevel.LOW, 5.).Destroy()
        call Meteorite.Update()
    endmethod
    initMethod Init of Spells_Misc
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        DarkAttack DARK_ATTACK = STRUCT_BASE
    endglobals
    struct DarkAttack
        implement Allocation
        implement List
        
    static Event DAMAGE_EVENT
    static method AddEclipse takes integer level, Unit target returns nothing
        local real duration
        if target.Classes.Contains(UnitClass.HERO) then
            set duration = thistype.HERO_DURATION[level]
        else
            set duration = thistype.DURATION[level]
        endif
        call target.Buffs.Timed.Start(thistype.ECLIPSE_BUFF, level, duration)
    endmethod
    static method Conditions takes Unit target returns boolean
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    eventMethod Event_Damage
        local Unit target = params.Unit.GetTrigger()
        call target.Effects.Create(thistype.SPECIAL_EFFECT_PATH, thistype.SPECIAL_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
        if not thistype.Conditions(target) then
            return
        endif
        call thistype.AddEclipse(params.Unit.GetDamager().Abilities.GetLevel(thistype.THIS_SPELL), target)
    endmethod
    eventMethod Event_BuffLose
        call params.Unit.GetTrigger().Event.Remove(DAMAGE_EVENT)
    endmethod
    eventMethod Event_BuffGain
        call params.Unit.GetTrigger().Event.Add(DAMAGE_EVENT)
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Misc
        set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
        call UNIT.Eclipse.NORMAL_BUFF.Variants.Add(thistype.ECLIPSE_BUFF)
    endmethod
endstruct
    scope FolderFountainAura
    public struct StructTarget
        implement Allocation
        implement List
        
    	static Event ENDING_EVENT
        static Event START_EVENT
		eventMethod Event_Ending
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local FountainAura parent = aura.GetData()
			call target.Buffs.Subtract(thistype.DUMMY_BUFF)
		endmethod
		eventMethod Event_Start
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local Unit caster = aura.GetCaster()
			local FountainAura parent = aura.GetData()
			local integer level = parent.level
			call target.Buffs.Add(thistype.DUMMY_BUFF, level)
		endmethod
        static method Init takes nothing returns nothing
            set thistype.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Ending)
            set thistype.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Start)
        endmethod
    endstruct
endscope
    globals
        FountainAura FOUNTAIN_AURA = STRUCT_BASE
    endglobals
    struct FountainAura
        implement Allocation
        implement List
        
    static BoolExpr TARGET_FILTER
	Aura aura
	integer level
    FolderFountainAura_StructTarget Target = this
    FolderFountainAura_StructTarget LinkToStruct_Target
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if (target.Life.Get() >= Real.ToInt(target.MaxLife.Get())) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        call this.aura.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
		local Aura aura = Aura.Create(target)
		set this.aura = aura
		set this.level = level
        call aura.SetData(this)
		call aura.SetAreaRange(thistype.THIS_SPELL.GetAreaRange(level))
        call aura.SetTargetFilter(thistype.TARGET_FILTER)
		call aura.Event.Add(thistype(NULL).Target.ENDING_EVENT)
		call aura.Event.Add(thistype(NULL).Target.START_EVENT)
		call aura.Enable()
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Misc
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
        call thistype(NULL).Target.Init()
    endmethod
endstruct
    globals
        FountainHeal FOUNTAIN_HEAL = STRUCT_BASE
    endglobals
    struct FountainHeal
        implement Allocation
        implement List
        
    static Event DESTROY_EVENT
    static constant integer DUMMY_SPELL_ID = 'AFHD'
    static key GetKeyMacro_KEY_ARRAY
    static constant integer KEY_ARRAY = Math.Integer.MIN + Memory.IntegerKeys.Table.OFFSET + GetKeyMacro_KEY_ARRAY * Memory.IntegerKeys.Table.SIZE
    static Event ORDER_EVENT
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTarget()
        local Unit target = params.Unit.GetTrigger()
        local real manaLifeNeeded = (target.MaxLife.Get() - target.Life.Get()) / thistype.HEAL_LIFE_PER_MANA_POINT
        local real manaManaNeeded = (target.MaxMana.Get() - target.Mana.Get()) / thistype.HEAL_MANA_PER_MANA_POINT
        local real manaNeeded = manaLifeNeeded + manaManaNeeded
        local real manaUsed = Math.Min(caster.Mana.Get(), manaNeeded)
        call target.Stop()
        if (manaUsed < 10.) then
            call caster.AddRisingTextTag(String.Color.Do(caster.GetName() + " empty or target nearly full", String.Color.MALUS), 0.024, 120., 1., 2., KEY_ARRAY + caster)
            return
        endif
        call caster.Effects.Create(thistype.CASTER_EFFECT_PATH, thistype.CASTER_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
        if (manaLifeNeeded > 0.) then
            call target.Effects.Create(thistype.TARGET_LIFE_EFFECT_PATH, thistype.TARGET_LIFE_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
            call caster.HealBySpell(target, manaUsed * manaLifeNeeded / manaNeeded * thistype.HEAL_LIFE_PER_MANA_POINT)
        endif
        if (manaManaNeeded > 0.) then
            call target.Effects.Create(thistype.TARGET_MANA_EFFECT_PATH, thistype.TARGET_MANA_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
            call caster.HealManaBySpell(target, manaUsed * manaManaNeeded / manaNeeded * thistype.HEAL_MANA_PER_MANA_POINT)
        endif
        call caster.Mana.Subtract(manaUsed)
    endmethod
    eventMethod Event_Order
        if (params.Order.GetTrigger() != Order.SMART) then
            return
        endif
        local Unit caster = params.Unit.GetTrigger()
        local Unit target = params.Unit.GetTarget()
        local User targetOwner = target.Owner.Get()
        call target.Abilities.AddBySelf(thistype.DUMMY_SPELL_ID)
        call targetOwner.EnableAbilityBySelf(thistype.DUMMY_SPELL_ID, true)
        call target.Order.UnitTarget(Order.EAT_TREE, caster)
        call targetOwner.EnableAbilityBySelf(thistype.DUMMY_SPELL_ID, false)
    endmethod
    eventMethod Event_BuffLose
        call params.Unit.GetTrigger().Event.Remove(ORDER_EVENT)
    endmethod
    eventMethod Event_BuffGain
        call params.Unit.GetTrigger().Event.Add(ORDER_EVENT)
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Misc
        set thistype.ORDER_EVENT = Event.Create(UNIT.Order.Events.Gain.Target.TARGET_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Order)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
        call thistype.DUMMY_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.PRE_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    globals
        FrostAttack FROST_ATTACK = STRUCT_BASE
    endglobals
    struct FrostAttack
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static Event GROUND_ATTACK_EVENT
    static BoolExpr TARGET_FILTER
    static method Conditions_Single takes Unit target returns boolean
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if thistype.Conditions_Single(target) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_GroundAttack
        local Unit caster = params.Unit.GetDamager()
        local Unit target = params.Unit.GetTrigger()
        local real targetX = target.Position.X.Get()
        local real targetY = target.Position.Y.Get()
        local integer level = caster.Abilities.GetLevel(thistype.THIS_SPELL)
        local real duration = thistype.DURATION[level]
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(targetX, targetY, caster.Attack.Splash.GetMaxAreaRange(), thistype.TARGET_FILTER)
        call thistype.ENUM_GROUP.RemoveUnit(target)
        if thistype.Conditions_Single(target) then
            call target.Buffs.Timed.Start(thistype.COLDNESS_BUFF, level, duration)
        endif
        set target = thistype.ENUM_GROUP.FetchFirst()
        if (target != NULL) then
            loop
                call target.Buffs.Timed.Start(thistype.COLDNESS_BUFF, level, duration)
                set target = thistype.ENUM_GROUP.FetchFirst()
                exitwhen (target == NULL)
            endloop
        endif
    endmethod
    eventMethod Event_BuffLose
        call params.Unit.GetTrigger().Event.Remove(GROUND_ATTACK_EVENT)
    endmethod
    eventMethod Event_BuffGain
        call params.Unit.GetTrigger().Event.Add(GROUND_ATTACK_EVENT)
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Misc
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.GROUND_ATTACK_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_GroundAttack)
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
        call UNIT.Cold.NORMAL_BUFF.Variants.Add(thistype.COLDNESS_BUFF)
    endmethod
endstruct
    globals
        Invisibility INVISIBILITY = STRUCT_BASE
    endglobals
    struct Invisibility
        implement Allocation
        implement List
        
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        call target.Invisibility.Subtract()
    endmethod
    eventMethod Event_BuffGain
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        call target.Invisibility.Add()
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.AddFresh(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Misc
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
    endmethod
endstruct
    globals
        Invulnerability INVULNERABILITY = STRUCT_BASE
    endglobals
    struct Invulnerability
        implement Allocation
        implement List
        
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        call SetUnitInvulnerable(target.self, false)
    endmethod
    eventMethod Event_BuffGain
        local Unit target = params.Unit.GetTrigger()
        call SetUnitInvulnerable(target.self, true)
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Misc
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
    endmethod
endstruct
    scope FolderLapidation
    public struct StructBuff
        implement Allocation
        implement List
        
        eventMethod Event_BuffLose
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            call target.Animation.Speed.Add(1.)
        endmethod
        eventMethod Event_BuffGain
            local Unit target = params.Unit.GetTrigger()
            local thistype this = target
            call target.Animation.Speed.Subtract(1.)
        endmethod
        static method Start takes integer level, Unit target returns nothing
            call target.Buffs.Timed.Start(thistype.DUMMY_BUFF, level, thistype.DURATION)
        endmethod
        static method Init takes nothing returns nothing
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
            call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
            call UNIT.Stun.NORMAL_BUFF.Variants.Add(thistype.DUMMY_BUFF)
        endmethod
    endstruct
endscope
    globals
        Lapidation LAPIDATION = STRUCT_BASE
    endglobals
    struct Lapidation
        implement Allocation
        implement List
        
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    Unit caster
    real damage
    integer level
    Unit target
    FolderLapidation_StructBuff Buff = this
    FolderLapidation_StructBuff LinkToStruct_Buff
    static method Conditions_Single takes Unit target returns boolean
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if not target.Classes.Contains(UnitClass.GROUND) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        local real damage = this.damage
        local integer level = this.level
        local Unit target = this.target
        call this.deallocate_demount()
        call dummyMissile.Destroy()
        set User.TEMP = caster.Owner.Get()
        if thistype.Conditions_Single(target) then
            call thistype(NULL).Buff.Start(level, target)
            call caster.DamageUnitBySpell(target, damage, true, false)
        endif
    endmethod
    static method StartTarget takes Unit caster, integer level, Unit target returns nothing
        local Missile dummyMissile = Missile.Create()
        local thistype this = thistype.allocate_mount(dummyMissile)
        set this.caster = caster
        set this.damage = thistype.DAMAGE
        set this.level = level
        set this.target = target
        call dummyMissile.Arc.SetByPerc(0.06)
        call dummyMissile.CollisionSize.Set(10.)
        call dummyMissile.DummyUnit.Create(thistype.DUMMY_UNIT_ID, 2.)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(1400.)
        call dummyMissile.Position.SetFromUnit(caster)
        call dummyMissile.GoToUnit.Start(target, null)
    endmethod
        static method Conditions takes nothing returns boolean
            if not Conditions_Single(UNIT.Event.Native.GetFilter()) then
                return false
            endif
            return true
        endmethod
    eventMethod Event_SpellEffect
        local Unit caster = params.Unit.GetTrigger()
        local integer level = params.Spell.GetLevel()
        local real targetX = params.Spot.GetTargetX()
        local real targetY = params.Spot.GetTargetY()
        set User.TEMP = caster.Owner.Get()
        call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(targetX, targetY, thistype.THIS_SPELL.GetAreaRange(level), thistype.TARGET_FILTER)
        local Unit target = thistype.ENUM_GROUP.GetRandom()
        if (target != NULL) then
            local integer iteration = thistype.MAX_TARGETS_AMOUNT
            loop
                exitwhen (iteration < 1)
                call thistype.ENUM_GROUP.RemoveUnit(target)
                call thistype.StartTarget(caster, level, target)
                set target = thistype.ENUM_GROUP.GetRandom()
                exitwhen (target == NULL)
                set iteration = iteration - 1
            endloop
        endif
    endmethod
    initMethod Init of Spells_Misc
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
        call thistype(NULL).Buff.Init()
    endmethod
endstruct
    globals
        LightningAttack LIGHTNING_ATTACK = STRUCT_BASE
    endglobals
    struct LightningAttack
        implement Allocation
        implement List
        
    static Event DAMAGE_EVENT
    static Group ENUM_GROUP
    static BoolExpr TARGET_FILTER
    real areaRange
    Unit caster
    real damage
    real damageReductionFactor
    Missile dummyMissile
    integer level
    integer maxTargetsAmount
    real stunDuration
    integer stunTargetsAmountMax
    Unit target
    UnitList targetGroup
    integer targetsAmount
    method Ending takes nothing returns nothing
        call this.deallocate()
        call this.targetGroup.Destroy()
    endmethod
    static method Conditions takes Unit target returns boolean
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.MECHANICAL) then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        if target.MagicImmunity.Try() then
            return false
        endif
        return true
    endmethod
    condMethod Conditions_Group
        local Unit target = UNIT.Event.Native.GetFilter()
        if UnitList.TEMP.Contains(target) then
            return false
        endif
        if not thistype.Conditions(target) then
            return false
        endif
        return true
    endmethod
    method StartMissile takes LightningType boltType, Unit oldTarget, Unit target, Group targetGroup returns nothing
        local Missile dummyMissile = Missile.Create()
        local Lightning effectLightning = Lightning.Create(boltType)
        set this.dummyMissile = dummyMissile
        set this.target = target
        call effectLightning.FromUnitToUnit.Start(oldTarget, target)
        call targetGroup.AddUnit(target)
        call effectLightning.DestroyTimed.Start(0.75)
        call dummyMissile.CollisionSize.Set(10.)
        call dummyMissile.Impact.SetAction(function thistype.Impact)
        call dummyMissile.SetData(this)
        call dummyMissile.Speed.Set(Math.Max(Math.DistanceByDeltas(target.Position.X.Get() - oldTarget.Position.X.Get(), target.Position.Y.Get() - oldTarget.Position.Y.Get()) / 0.25, 700.))
        call dummyMissile.Position.SetFromUnit(oldTarget)
        call dummyMissile.GoToUnit.Start(target, null)
    endmethod
    eventMethod Impact
        local Missile dummyMissile = params.Missile.GetTrigger()
        local thistype this = dummyMissile.GetData()
        local Unit caster = this.caster
        local integer maxTargetsAmount = this.maxTargetsAmount
        local integer targetsAmount = this.targetsAmount
        local Unit target = this.target
        local Group targetGroup = this.targetGroup
        if (target != NULL) then
            local Sound impactSound = Sound.Create(thistype.IMPACT_SOUND_PATH, false, true, true, 10, 10, SoundEax.SPELL)
            call target.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
            call impactSound.SetPositionAndPlay(target.Position.X.Get(), target.Position.Y.Get(), target.Position.Z.Get())
            call impactSound.Destroy(true)
            set User.TEMP = caster.Owner.Get()
            if thistype.Conditions(target) then
                local real damage = this.damage
                set this.damage = damage * (1. - this.damageReductionFactor)
                if (targetsAmount <= this.stunTargetsAmountMax) then
                    call target.Buffs.Timed.Start(UNIT.Stun.NORMAL_BUFF, this.level, this.stunDuration)
                endif
                call caster.DamageUnitBySpell(target, damage, true, false)
            endif
        endif
        if (targetsAmount == maxTargetsAmount) then
            call this.Ending()
        else
            local real targetX = target.Position.X.Get()
            local real targetY = target.Position.Y.Get()
            set UnitList.TEMP = targetGroup
            set User.TEMP = caster.Owner.Get()
            call thistype.ENUM_GROUP.EnumUnits.InRange.WithCollision.Do(targetX, targetY, this.areaRange, thistype.TARGET_FILTER)
            local Unit newTarget = thistype.ENUM_GROUP.GetNearest(targetX, targetY)
            if (newTarget == NULL) then
                call this.Ending()
            else
                set this.targetsAmount = targetsAmount + 1
                call this.StartMissile(thistype.BOLT_SECONDARY, target, newTarget, targetGroup)
            endif
        endif
        call dummyMissile.Destroy()
    endmethod
    eventMethod Event_Damage
        local Unit caster = params.Unit.GetDamager()
        local Unit target = params.Unit.GetTrigger()
        local real casterX = caster.Position.X.Get()
        local real casterY = caster.Position.Y.Get()
        local integer level = caster.Abilities.GetLevel(thistype.THIS_SPELL)
        local thistype this = thistype.allocate()
		local Group targetGroup = Group.Create()
        set this.areaRange = thistype.THIS_SPELL.GetAreaRange(level)
        set this.caster = caster
        set this.damage = thistype.DAMAGE[level]
        set this.damageReductionFactor = thistype.DAMAGE_REDUCTION_FACTOR[level]
        set this.level = level
        set this.maxTargetsAmount = thistype.TARGETS_AMOUNT[level]
        set this.stunDuration = thistype.STUN_DURATION[level]
        set this.stunTargetsAmountMax = thistype.STUN_TARGETS_AMOUNT[level]
        set this.targetGroup = targetGroup
        set this.targetsAmount = 1
        call this.StartMissile(thistype.BOLT_PRIMARY, caster, target, targetGroup)
    endmethod
    eventMethod Event_BuffLose
        call params.Unit.GetTrigger().Event.Remove(DAMAGE_EVENT)
    endmethod
    eventMethod Event_BuffGain
        call params.Unit.GetTrigger().Event.Add(DAMAGE_EVENT)
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Misc
        set thistype.DAMAGE_EVENT = Event.Create(UNIT.Damage.Events.ATTACKER_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Damage)
        set thistype.ENUM_GROUP = Group.Create()
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions_Group)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
    endmethod
endstruct
    globals
        MagicImmunity MAGIC_IMMUNITY = STRUCT_BASE
    endglobals
    struct MagicImmunity
        implement Allocation
        implement List
        
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.Add(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Misc
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
    endmethod
endstruct
    globals
        MeteoriteProtection METEORITE_PROTECTION = STRUCT_BASE
    endglobals
    struct MeteoriteProtection
        implement Allocation
        implement List
        
endstruct
    globals
        RefreshMana REFRESH_MANA = STRUCT_BASE
    endglobals
    struct RefreshMana
        implement Allocation
        implement List
        
    static Unit CASTER
    enumMethod Enum
        local Unit caster = thistype.CASTER
        local Unit target = UNIT.Event.Native.GetEnum()
        call target.Effects.Create(thistype.TARGET_EFFECT_PATH, thistype.TARGET_EFFECT_ATTACH_POINT, EffectLevel.LOW).Destroy()
        call caster.HealManaBySpell(target, target.MaxMana.Get() * thistype.MANA_FACTOR)
    endmethod
    eventMethod Event_SpellEffect
        set thistype.CASTER = params.Unit.GetTrigger()
        call USER.Hero.EnumAll(function thistype.Enum, true)
    endmethod
    initMethod Init of Spells_Misc
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_SpellEffect))
    endmethod
endstruct
    scope FolderRevealAura
    public struct StructTarget
        implement Allocation
        implement List
        
    	static Event ENDING_EVENT
        static Event START_EVENT
		eventMethod Event_Ending
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local RevealAura parent = aura.GetData()
			call target.Buffs.Subtract(thistype.DUMMY_BUFF)
		endmethod
		eventMethod Event_Start
			local Aura aura = params.Aura.GetTrigger()
			local Unit target = params.Unit.GetTrigger()
			local Unit caster = aura.GetCaster()
			local RevealAura parent = aura.GetData()
			local integer level = parent.level
			call target.Buffs.Add(thistype.DUMMY_BUFF, level)
		endmethod
        static method Init takes nothing returns nothing
            set thistype.ENDING_EVENT = Event.Create(AURA.Target.ENDING_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Ending)
            set thistype.START_EVENT = Event.Create(AURA.Target.START_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Start)
        endmethod
    endstruct
endscope
    globals
        RevealAura REVEAL_AURA = STRUCT_BASE
    endglobals
    struct RevealAura
        implement Allocation
        implement List
        
    static BoolExpr TARGET_FILTER
	Aura aura
	integer level
    FolderRevealAura_StructTarget Target = this
    FolderRevealAura_StructTarget LinkToStruct_Target
    condMethod Conditions
        local Unit target = UNIT.Event.Native.GetFilter()
        if target.Classes.Contains(UnitClass.DEAD) then
            return false
        endif
        if target.Classes.Contains(UnitClass.STRUCTURE) then
            return false
        endif
        if not target.Invisibility.Is() then
            return false
        endif
        if target.IsAllyOf(User.TEMP) then
            return false
        endif
        return true
    endmethod
    eventMethod Event_BuffLose
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
        call this.aura.Destroy()
    endmethod
    eventMethod Event_BuffGain
        local integer level = params.Buff.GetLevel()
        local Unit target = params.Unit.GetTrigger()
        local thistype this = target
		local Aura aura = Aura.Create(target)
		set this.aura = aura
		set this.level = level
        call aura.SetData(this)
		call aura.SetAreaRange(thistype.THIS_SPELL.GetAreaRange(level))
        call aura.SetTargetFilter(thistype.TARGET_FILTER)
		call aura.Event.Add(thistype(NULL).Target.ENDING_EVENT)
		call aura.Event.Add(thistype(NULL).Target.START_EVENT)
		call aura.Enable()
    endmethod
    eventMethod Event_Unlearn
        call params.Unit.GetTrigger().Buffs.Remove(thistype.DUMMY_BUFF)
    endmethod
    eventMethod Event_Learn
        call params.Unit.GetTrigger().Buffs.AddFresh(thistype.DUMMY_BUFF, params.Spell.GetLevel())
    endmethod
    initMethod Init of Spells_Misc
        set thistype.TARGET_FILTER = BoolExpr.GetFromFunction(function thistype.Conditions)
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Gain.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffGain))
        call thistype.DUMMY_BUFF.Event.Add(Event.Create(UNIT.Buffs.Events.Lose.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_BuffLose))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Learn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Learn))
        call thistype.THIS_SPELL.Event.Add(Event.Create(UNIT.Abilities.Events.Unlearn.DUMMY_EVENT_TYPE, EventPriority.SPELLS, function thistype.Event_Unlearn))
        call thistype(NULL).Target.Init()
    endmethod
endstruct
    globals
        Meteorite METEORITE = STRUCT_BASE
    endglobals
    struct Meteorite
        implement Allocation
        implement List
        
    static constant string CAST_EFFECT_ATTACH_POINT = AttachPoint.ORIGIN
    static constant string CAST_EFFECT_PATH = "Abilities\\Spells\\Other\\Monsoon\\MonsoonBoltTarget.mdl"
    static Timer DELAY_TIMER
    static boolean GAME_OVER
    static EventType GAME_OVER_EVENT_TYPE
    static real LAST_LIFE_AMOUNT
    static Event LIFE_EVENT
    static constant real MAX_LIFE_FACTOR = 0.5
    static constant real SCALE_FACTOR_MIN = 0.4
    static Unit THIS_UNIT = NULL
    static Announcement WARNING_ANNOUNCEMENT
    static Sound WARNING_SOUND
    static method GameOver_TriggerEvents takes nothing returns nothing
        local EventResponse params = EventResponse.Create(EventResponse.STATIC_SUBJECT_ID)
		local integer iteration = EventPriority.ALL_COUNT
        loop
            exitwhen (iteration < ARRAY_MIN)
            local EventPriority priority = EventPriority.ALL[iteration]
            local integer iteration2 = Event.CountAtStatics(thistype.GAME_OVER_EVENT_TYPE, priority)
            loop
                exitwhen (iteration2 < Memory.IntegerKeys.Table.STARTED)
                call Event.GetFromStatics(thistype.GAME_OVER_EVENT_TYPE, priority, iteration2).Run(params)
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        call params.Destroy()
    endmethod
    static method Defeat takes nothing returns nothing
    	set thistype.GAME_OVER = true
        local string array captions
        set captions[0] = "Leave this grim place"
        set captions[1] = "I can see the light"
        set captions[2] = "It's too late"
        set captions[3] = "The world descends into eternal ice"
        set captions[4] = "Eternal fail shall befall you"
        local string captionResult = captions[Math.RandomI(0, 4)]
		local Dialog newDialog = Dialog.Create()
        call newDialog.Buttons.Create("I am okay with that", 0)
        call newDialog.SetTitle("The castle has fallen!")
        call newDialog.Buttons.Create(captionResult, 0)
        call newDialog.Display(User.ANY, true)
		local CineFilter newCineFilter = CineFilter.Create()
        call newCineFilter.SetColorEnd(0, 128, 128, Real.ToInt(0.3 * 255))
        call newCineFilter.SetTexture("ReplaceableTextures\\CameraMasks\\DreamFilter_Mask.blp")
        call newCineFilter.Start(10., User.ANY)
        call thistype.GameOver_TriggerEvents()
    endmethod
    eventMethod Event_Death
        call thistype.Defeat()
    endmethod
    static method GetInfoboardTitle takes nothing returns string
        local real relativeLife = thistype.THIS_UNIT.Life.Get() * 100. / thistype.THIS_UNIT.MaxLife.Get()
        local string result = "Meteorite is at: "
        if (relativeLife < 0.25) then
            set result = result + String.Color.MALUS
        endif
        return (result + Integer.ToString(Real.ToInt(relativeLife)) + Char.PERCENT)
    endmethod
    static method Update takes nothing returns nothing
        local real lastLifeAmount = thistype.LAST_LIFE_AMOUNT
        local real lifeAmount = thistype.THIS_UNIT.Life.Get()
        local real relativeLife
        local boolean damaged = (lifeAmount < lastLifeAmount)
        if damaged then
            call thistype.THIS_UNIT.Event.Remove(LIFE_EVENT)
            call thistype.THIS_UNIT.MaxLife.Base.Subtract((lastLifeAmount - lifeAmount) * thistype.MAX_LIFE_FACTOR)
            call thistype.THIS_UNIT.MaxLife.UpdateByNative()
            call thistype.THIS_UNIT.Event.Add(LIFE_EVENT)
        endif
        set relativeLife = lifeAmount / thistype.THIS_UNIT.MaxLife.Get()
        set thistype.LAST_LIFE_AMOUNT = lifeAmount
        if (Infoboard.THIS_BOARD != NULL) then
            call Infoboard.THIS_BOARD.SetTitle(thistype.GetInfoboardTitle())
            call thistype.THIS_UNIT.VertexColor.Set(255., relativeLife * 255., relativeLife * 255., 255.)
        endif
        call thistype.THIS_UNIT.Scale.Set(thistype.THIS_UNIT_TYPE.Scale.Get() * ((1. - thistype.SCALE_FACTOR_MIN) * relativeLife + thistype.SCALE_FACTOR_MIN))
        if damaged then
            
            call thistype.WARNING_ANNOUNCEMENT.StartTimed(5.)
            
                call thistype.WARNING_SOUND.Play()
            
        endif
    endmethod
    eventMethod Event_Cast
        call params.Unit.GetTrigger().Effects.Create(thistype.CAST_EFFECT_PATH, thistype.CAST_EFFECT_ATTACH_POINT, EffectLevel.NORMAL).Destroy()
    endmethod
    eventMethod Event_Damage
       
    endmethod
    eventMethod Event_Life
        call thistype.Update()
    endmethod
    eventMethod Event_HostChange
        call thistype.THIS_UNIT.Owner.Set(params.User.GetTrigger())
    endmethod
    eventMethod Event_Create
        set thistype.THIS_UNIT = params.Unit.GetTrigger()
        set thistype.LIFE_EVENT = Event.Create(UNIT.Life.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Life)
        set thistype.WARNING_ANNOUNCEMENT = Announcement.Create(10)
        set thistype.WARNING_SOUND = Sound.Create("Sound\\Interface\\Warning.wav", false, false, false, 10, 10, SoundEax.DEFAULT)
		call thistype.WARNING_SOUND.SetVolume(0.5)
        set thistype.LAST_LIFE_AMOUNT = thistype.THIS_UNIT.Life.Get()
        call thistype.THIS_UNIT.Event.Add(Event.Create(UNIT.Abilities.Events.Effect.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Cast))
        call thistype.THIS_UNIT.Event.Add(Event.Create(UNIT.Damage.Events.TARGET_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Damage))
        call thistype.THIS_UNIT.Event.Add(Event.Create(UNIT.Death.Events.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Death))
        call thistype.THIS_UNIT.Event.Add(LIFE_EVENT)
        call Event.Create(USER.HostAppointment.DUMMY_EVENT_TYPE, EventPriority.MISC, function thistype.Event_HostChange).AddToStatics()
        if (Infoboard.THIS_BOARD != NULL) then
            call Infoboard.THIS_BOARD.SetTitle(Meteorite.GetInfoboardTitle())
        endif
        call thistype.THIS_UNIT.Classes.Add(UnitClass.UNDECAYABLE)
    endmethod
    eventMethod Event_Chat
        call thistype.THIS_UNIT.Kill()
    endmethod
    initMethod Init of Misc
        set thistype.GAME_OVER = false
        set thistype.GAME_OVER_EVENT_TYPE = EventType.Create()
        call StringData.Event.Add("killM", Event.Create(User.CHAT_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Chat))
        call thistype.THIS_UNIT_TYPE.Event.Add(Event.Create(Unit.CREATE_EVENT_TYPE, EventPriority.MISC, function thistype.Event_Create))
    endmethod
endstruct
    globals
        Pengu PENGU = STRUCT_BASE
    endglobals
    struct Pengu
        implement Allocation
        implement List
        
    eventMethod Event_Create
        call params.Unit.GetTrigger().Animation.Add(UNIT.Animation.SWIM)
    endmethod
    initMethod Init of Units
        call UnitType.FLYING_PENGUIN.Event.Add(Event.Create(Unit.CREATE_EVENT_TYPE, EventPriority.UNIT_TYPES, function thistype.Event_Create))
    endmethod
endstruct
    globals
        Sebastian SEBASTIAN = STRUCT_BASE
    endglobals
    struct Sebastian
        implement Allocation
        implement List
        
    static Unit THIS_UNIT
    eventMethod Event_Start
        set thistype.THIS_UNIT = Unit.GetFromSelf(gg_unit_uSeb_0040)
    endmethod
    initMethod Init of Units
        call Event.Create(EventType.START, EventPriority.MISC, function thistype.Event_Start).AddToStatics()
    endmethod
endstruct
globals
    
    unit                    udg_outerPick              = null
    
    rect                    gg_rct_ArtifactIntroTarget = null
    rect                    gg_rct_BasementStairwayUpLeft = null
    rect                    gg_rct_BasementStairwayUpRight = null
    rect                    gg_rct_BasementStairwayUpTargetLeft = null
    rect                    gg_rct_BasementStairwayUpTargetRight = null
    rect                    gg_rct_Castle              = null
    rect                    gg_rct_Chamber             = null
    rect                    gg_rct_Creeps_Left_Air     = null
    rect                    gg_rct_Creeps_Left_Boss    = null
    rect                    gg_rct_Creeps_Left_Melee   = null
    rect                    gg_rct_Creeps_Right_Buff   = null
    rect                    gg_rct_Creeps_Right_Demon  = null
    rect                    gg_rct_Creeps_Right_Minor  = null
    rect                    gg_rct_DefenderSpawn_SourceCenter = null
    rect                    gg_rct_DefenderSpawn_TargetBottom = null
    rect                    gg_rct_DefenderSpawn_TargetLeft = null
    rect                    gg_rct_DefenderSpawn_TargetRight = null
    rect                    gg_rct_Gebiet_034_Kopieren = null
    rect                    gg_rct_Gebiet_034_Kopieren_2 = null
    rect                    gg_rct_HeroRevival         = null
    rect                    gg_rct_HeroRevival2        = null
    rect                    gg_rct_HeroSelection_Aruruw = null
    rect                    gg_rct_HeroSelection_Center = null
    rect                    gg_rct_HeroSelection_Drakul = null
    rect                    gg_rct_HeroSelection_Jota  = null
    rect                    gg_rct_HeroSelection_Kera  = null
    rect                    gg_rct_HeroSelection_Lizzy = null
    rect                    gg_rct_HeroSelection_Rocketeye = null
    rect                    gg_rct_HeroSelection_Smokealot = null
    rect                    gg_rct_HeroSelection_Stormy = null
    rect                    gg_rct_HeroSelection_Tajran = null
    rect                    gg_rct_Introduction        = null
    rect                    gg_rct_Introduction_Aruruw = null
    rect                    gg_rct_Introduction_Drakul = null
    rect                    gg_rct_Introduction_Light  = null
    rect                    gg_rct_Introduction_Light2 = null
    rect                    gg_rct_Introduction_Lizzy  = null
    rect                    gg_rct_Introduction_Lizzy2 = null
    rect                    gg_rct_Introduction_Lizzy3 = null
    rect                    gg_rct_Introduction_Rocketeye = null
    rect                    gg_rct_Introduction_Smokealot = null
    rect                    gg_rct_Introduction_Stormy = null
    rect                    gg_rct_Introduction_Stormy2 = null
    rect                    gg_rct_Introduction_Tajran = null
    rect                    gg_rct_Introduction_Tajran2 = null
    rect                    gg_rct_LeftBrazier         = null
    rect                    gg_rct_LeftTavern          = null
    rect                    gg_rct_Lumber              = null
    rect                    gg_rct_Lumber10            = null
    rect                    gg_rct_Lumber11            = null
    rect                    gg_rct_Lumber12            = null
    rect                    gg_rct_Lumber13            = null
    rect                    gg_rct_Lumber2             = null
    rect                    gg_rct_Lumber3             = null
    rect                    gg_rct_Lumber4             = null
    rect                    gg_rct_Lumber5             = null
    rect                    gg_rct_Lumber6             = null
    rect                    gg_rct_Lumber7             = null
    rect                    gg_rct_Lumber8             = null
    rect                    gg_rct_Lumber9             = null
    rect                    gg_rct_RightBrazier        = null
    rect                    gg_rct_RightTavern         = null
    rect                    gg_rct_Rosa                = null
    rect                    gg_rct_SpawnBottomIn       = null
    rect                    gg_rct_SpawnCenter         = null
    rect                    gg_rct_SpawnDestination    = null
    rect                    gg_rct_SpawnLeftIn         = null
    rect                    gg_rct_SpawnRightIn        = null
    rect                    gg_rct_StairsDownDarknessFog = null
    rect                    gg_rct_Tower               = null
    rect                    gg_rct_Tower2              = null
    rect                    gg_rct_Waypoint_RegionCheck = null
    rect                    gg_rct_Waypoint_RegionCheck2 = null
    rect                    gg_rct_Waypoint_RegionCheck3 = null
    camerasetup             gg_cam_Zoom                = null
    camerasetup             gg_cam_Introduction        = null
    camerasetup             gg_cam_Introduction2       = null
    camerasetup             gg_cam_Introduction3       = null
    camerasetup             gg_cam_Introduction4       = null
    camerasetup             gg_cam_Introduction5       = null
    camerasetup             gg_cam_Introduction6       = null
    camerasetup             gg_cam_Introduction7       = null
    camerasetup             gg_cam_Introduction8       = null
    camerasetup             gg_cam_Introduction9       = null
    camerasetup             gg_cam_Introduction10      = null
    camerasetup             gg_cam_Introduction11      = null
    camerasetup             gg_cam_Camera_013          = null
    camerasetup             gg_cam_Camera_014          = null
    camerasetup             gg_cam_Camera_015          = null
    sound                   gg_snd_Error               = null
    sound                   gg_snd_BuildingPlacement   = null
    sound                   gg_snd_FootmanPissed4      = null
    string                  gg_snd_War2IntroMusic
    sound                   gg_snd_AlchemistAcidBurnMissileDeath1 = null
    sound                   gg_snd_TinkerMissileDeath1 = null
    sound                   gg_snd_FrostArrowHit1      = null
    sound                   gg_snd_AlchemistTransmuteDeath1 = null
    sound                   gg_snd_FrostmourneChant1   = null
    sound                   gg_snd_PH1                 = null
    sound                   gg_snd_War2IntroMusic01    = null
    sound                   gg_snd_BlizzardLoop1       = null
    sound                   gg_snd_BlizzardTarget1     = null
    sound                   gg_snd_Warning             = null
    string                  gg_snd_PH101
    sound                   gg_snd_BreathOfFrost1      = null
    sound                   gg_snd_PandarenBrewmasterPissed8 = null
    sound                   gg_snd_HeroDreadlordWhat1  = null
    sound                   gg_snd_DeathKnightPissed3  = null
    sound                   gg_snd_DeathKnightReady1   = null
    sound                   gg_snd_DeathKnightWhat1    = null
    sound                   gg_snd_HeroMoonPriestessPissed3 = null
    sound                   gg_snd_HeroMoonPriestessPissed5 = null
    sound                   gg_snd_HeroMoonPriestessWhat2 = null
    sound                   gg_snd_ThrallWhat2         = null
    sound                   gg_snd_ThrallYes2          = null
    sound                   gg_snd_ThrallYes3          = null
    sound                   gg_snd_JainaPissed1        = null
    sound                   gg_snd_JainaPissed3        = null
    sound                   gg_snd_JainaWhat1          = null
    sound                   gg_snd_JainaWhat3          = null
    sound                   gg_snd_HeroMountainKingPissed3 = null
    sound                   gg_snd_HeroMountainKingPissed5 = null
    sound                   gg_snd_HeroMountainKingPissed6 = null
    sound                   gg_snd_HeroMountainKingWhat1 = null
    sound                   gg_snd_HeroMountainKingWhat2 = null
    sound                   gg_snd_HeroWardenPissed7   = null
    sound                   gg_snd_HeroWardenReady1    = null
    sound                   gg_snd_HeroWardenWarcry1   = null
    sound                   gg_snd_HeroWardenWhat1     = null
    sound                   gg_snd_KaelYes4            = null
    sound                   gg_snd_PhoenixAttack       = null
    trigger                 gg_trg_creeps              = null
    trigger                 gg_trg_neutrals            = null
    trigger                 gg_trg_destructables       = null
    unit                    gg_unit_uSeb_0040          = null
    unit                    gg_unit_uRiS_0044          = null
    unit                    gg_unit_uTrP_0134          = null
    unit                    gg_unit_uPan_0083          = null
    unit                    gg_unit_uTus_0099          = null
    unit                    gg_unit_uWoM_0122          = null
    unit                    gg_unit_uKoM_0115          = null
    unit                    gg_unit_nogr_0106          = null
    unit                    gg_unit_uFuM_0110          = null
    unit                    gg_unit_uWol_0097          = null
    unit                    gg_unit_uWol_0123          = null
    unit                    gg_unit_uKoB_0102          = null
    unit                    gg_unit_uTus_0112          = null
    unit                    gg_unit_nogr_0111          = null
    unit                    gg_unit_uKoR_0114          = null
    unit                    gg_unit_uTrG_0132          = null
    unit                    gg_unit_uKoM_0116          = null
    unit                    gg_unit_uKoB_0124          = null
    unit                    gg_unit_uPan_0079          = null
    unit                    gg_unit_uTrP_0133          = null
    unit                    gg_unit_uBDS_0117          = null
    unit                    gg_unit_uBDS_0081          = null
    unit                    gg_unit_uKoR_0113          = null
    destructable            gg_dest_C005_0080          = null
    destructable            gg_dest_C00H_0188          = null
    destructable            gg_dest_C00H_1734          = null
    destructable            gg_dest_C00H_1731          = null
    destructable            gg_dest_C00H_1732          = null
    destructable            gg_dest_C00H_1733          = null
    destructable            gg_dest_C00H_1730          = null
    destructable            gg_dest_C00H_1729          = null
    destructable            gg_dest_C00H_1728          = null
    destructable            gg_dest_C00H_1727          = null
    destructable            gg_dest_C00H_1726          = null
    destructable            gg_dest_C00H_1725          = null
    destructable            gg_dest_C00H_1724          = null
    destructable            gg_dest_C00H_1704          = null
endglobals
function InitGlobals takes nothing returns nothing
endfunction
function InitSounds takes nothing returns nothing
    set gg_snd_Error = CreateSound( "Sound\\Interface\\Error.wav", false, false, false, 10, 10, "" )
    call SetSoundParamsFromLabel( gg_snd_Error, "InterfaceError" )
    call SetSoundDuration( gg_snd_Error, 614 )
    set gg_snd_BuildingPlacement = CreateSound( "Sound\\Buildings\\Shared\\BuildingPlacement.wav", false, false, false, 10, 10, "" )
    call SetSoundParamsFromLabel( gg_snd_BuildingPlacement, "PlaceBuildingDefault" )
    call SetSoundDuration( gg_snd_BuildingPlacement, 1283 )
    set gg_snd_FootmanPissed4 = CreateSound( "Units\\Human\\Footman\\FootmanPissed4.wav", false, true, true, 10, 10, "DefaultEAXON" )
    call SetSoundParamsFromLabel( gg_snd_FootmanPissed4, "FootmanPissed" )
    call SetSoundDuration( gg_snd_FootmanPissed4, 1306 )
    set gg_snd_War2IntroMusic = "Sound\\Music\\mp3Music\\War2IntroMusic.mp3"
    set gg_snd_AlchemistAcidBurnMissileDeath1 = CreateSound( "Abilities\\Spells\\Other\\AcidBomb\\AlchemistAcidBurnMissileDeath1.wav", false, true, true, 10, 10, "CombatSoundsEAX" )
    call SetSoundParamsFromLabel( gg_snd_AlchemistAcidBurnMissileDeath1, "AcidBombImpact" )
    call SetSoundDuration( gg_snd_AlchemistAcidBurnMissileDeath1, 1625 )
    set gg_snd_TinkerMissileDeath1 = CreateSound( "Abilities\\Spells\\Other\\TinkerRocket\\TinkerMissileDeath1.wav", false, true, true, 10, 10, "MissilesEAX" )
    call SetSoundParamsFromLabel( gg_snd_TinkerMissileDeath1, "ClusterRocketsImpact" )
    call SetSoundDuration( gg_snd_TinkerMissileDeath1, 1306 )
    set gg_snd_FrostArrowHit1 = CreateSound( "Abilities\\Spells\\Other\\FrostArrows\\FrostArrowHit1.wav", false, true, true, 10, 10, "MissilesEAX" )
    call SetSoundParamsFromLabel( gg_snd_FrostArrowHit1, "FrostArrowHit" )
    call SetSoundDuration( gg_snd_FrostArrowHit1, 1115 )
    set gg_snd_AlchemistTransmuteDeath1 = CreateSound( "Abilities\\Spells\\Other\\Transmute\\AlchemistTransmuteDeath1.wav", false, true, true, 10, 10, "CombatSoundsEAX" )
    call SetSoundParamsFromLabel( gg_snd_AlchemistTransmuteDeath1, "TransmuteMissileImpact" )
    call SetSoundDuration( gg_snd_AlchemistTransmuteDeath1, 1601 )
    set gg_snd_FrostmourneChant1 = CreateSound( "Sound\\Ambient\\DoodadEffects\\FrostmourneChant1.wav", false, false, false, 10, 10, "DefaultEAXON" )
    call SetSoundParamsFromLabel( gg_snd_FrostmourneChant1, "FrostmourneChantSound" )
    call SetSoundDuration( gg_snd_FrostmourneChant1, 5039 )
    call SetSoundPitch( gg_snd_FrostmourneChant1, 0.5 )
    set gg_snd_PH1 = CreateSound( "Sound\\Music\\mp3Music\\PH1.mp3", false, false, false, 10, 10, "DefaultEAXON" )
    call SetSoundParamsFromLabel( gg_snd_PH1, "PHMusic" )
    call SetSoundDuration( gg_snd_PH1, 281582 )
    call SetSoundPitch( gg_snd_PH1, 0.5 )
    set gg_snd_War2IntroMusic01 = CreateSound( "Sound\\Music\\mp3Music\\War2IntroMusic.mp3", false, false, false, 10, 10, "DefaultEAXON" )
    call SetSoundParamsFromLabel( gg_snd_War2IntroMusic01, "War2Intro" )
    call SetSoundDuration( gg_snd_War2IntroMusic01, 81136 )
    call SetSoundPitch( gg_snd_War2IntroMusic01, 0.8 )
    set gg_snd_BlizzardLoop1 = CreateSound( "Abilities\\Spells\\Human\\Blizzard\\BlizzardLoop1.wav", false, true, true, 10, 10, "SpellsEAX" )
    call SetSoundDuration( gg_snd_BlizzardLoop1, 4000 )
    call SetSoundChannel( gg_snd_BlizzardLoop1, 0 )
    call SetSoundVolume( gg_snd_BlizzardLoop1, 127 )
    call SetSoundPitch( gg_snd_BlizzardLoop1, 1.0 )
    call SetSoundDistances( gg_snd_BlizzardLoop1, 0.0, 10000.0 )
    call SetSoundDistanceCutoff( gg_snd_BlizzardLoop1, 3000.0 )
    call SetSoundConeAngles( gg_snd_BlizzardLoop1, 0.0, 0.0, 127 )
    call SetSoundConeOrientation( gg_snd_BlizzardLoop1, 0.0, 0.0, 0.0 )
    set gg_snd_BlizzardTarget1 = CreateSound( "Abilities\\Spells\\Human\\Blizzard\\BlizzardTarget1.wav", false, true, true, 10, 10, "SpellsEAX" )
    call SetSoundDuration( gg_snd_BlizzardTarget1, 3000 )
    call SetSoundChannel( gg_snd_BlizzardTarget1, 0 )
    call SetSoundVolume( gg_snd_BlizzardTarget1, 127 )
    call SetSoundPitch( gg_snd_BlizzardTarget1, 1.0 )
    call SetSoundDistances( gg_snd_BlizzardTarget1, 0.0, 10000.0 )
    call SetSoundDistanceCutoff( gg_snd_BlizzardTarget1, 3000.0 )
    call SetSoundConeAngles( gg_snd_BlizzardTarget1, 0.0, 0.0, 127 )
    call SetSoundConeOrientation( gg_snd_BlizzardTarget1, 0.0, 0.0, 0.0 )
    set gg_snd_Warning = CreateSound( "Sound\\Interface\\Warning.wav", false, false, false, 10, 10, "" )
    call SetSoundParamsFromLabel( gg_snd_Warning, "Warning" )
    call SetSoundDuration( gg_snd_Warning, 1904 )
    set gg_snd_PH101 = "Sound\\Music\\mp3Music\\PH1.mp3"
    set gg_snd_BreathOfFrost1 = CreateSound( "Abilities\\Spells\\Other\\BreathOfFrost\\BreathOfFrost1.wav", false, true, true, 10, 10, "SpellsEAX" )
    call SetSoundParamsFromLabel( gg_snd_BreathOfFrost1, "BreathOfFrost" )
    call SetSoundDuration( gg_snd_BreathOfFrost1, 2235 )
    set gg_snd_PandarenBrewmasterPissed8 = CreateSound( "Units\\Creeps\\PandarenBrewmaster\\PandarenBrewmasterPissed8.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_PandarenBrewmasterPissed8, "PandarenBrewmasterPissed" )
    call SetSoundDuration( gg_snd_PandarenBrewmasterPissed8, 2937 )
    set gg_snd_HeroDreadlordWhat1 = CreateSound( "Units\\Undead\\HeroDreadLord\\HeroDreadlordWhat1.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_HeroDreadlordWhat1, "HeroDreadLordWhat" )
    call SetSoundDuration( gg_snd_HeroDreadlordWhat1, 1971 )
    set gg_snd_DeathKnightPissed3 = CreateSound( "Units\\Undead\\HeroDeathKnight\\DeathKnightPissed3.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_DeathKnightPissed3, "HeroDeathKnightPissed" )
    call SetSoundDuration( gg_snd_DeathKnightPissed3, 3989 )
    set gg_snd_DeathKnightReady1 = CreateSound( "Units\\Undead\\HeroDeathKnight\\DeathKnightReady1.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_DeathKnightReady1, "HeroDeathKnightReady" )
    call SetSoundDuration( gg_snd_DeathKnightReady1, 2369 )
    set gg_snd_DeathKnightWhat1 = CreateSound( "Units\\Undead\\HeroDeathKnight\\DeathKnightWhat1.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_DeathKnightWhat1, "HeroDeathKnightWhat" )
    call SetSoundDuration( gg_snd_DeathKnightWhat1, 4083 )
    set gg_snd_HeroMoonPriestessPissed3 = CreateSound( "Units\\NightElf\\HeroMoonPriestess\\HeroMoonPriestessPissed3.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_HeroMoonPriestessPissed3, "HeroMoonPriestessPissed" )
    call SetSoundDuration( gg_snd_HeroMoonPriestessPissed3, 2459 )
    set gg_snd_HeroMoonPriestessPissed5 = CreateSound( "Units\\NightElf\\HeroMoonPriestess\\HeroMoonPriestessPissed5.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_HeroMoonPriestessPissed5, "HeroMoonPriestessPissed" )
    call SetSoundDuration( gg_snd_HeroMoonPriestessPissed5, 3599 )
    set gg_snd_HeroMoonPriestessWhat2 = CreateSound( "Units\\NightElf\\HeroMoonPriestess\\HeroMoonPriestessWhat2.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_HeroMoonPriestessWhat2, "HeroMoonPriestessWhat" )
    call SetSoundDuration( gg_snd_HeroMoonPriestessWhat2, 1439 )
    set gg_snd_ThrallWhat2 = CreateSound( "Units\\Orc\\Thrall\\ThrallWhat2.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_ThrallWhat2, "ThrallWhat" )
    call SetSoundDuration( gg_snd_ThrallWhat2, 1672 )
    set gg_snd_ThrallYes2 = CreateSound( "Units\\Orc\\Thrall\\ThrallYes2.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_ThrallYes2, "ThrallYes" )
    call SetSoundDuration( gg_snd_ThrallYes2, 694 )
    set gg_snd_ThrallYes3 = CreateSound( "Units\\Orc\\Thrall\\ThrallYes3.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_ThrallYes3, "ThrallYes" )
    call SetSoundDuration( gg_snd_ThrallYes3, 1021 )
    set gg_snd_JainaPissed1 = CreateSound( "Units\\Human\\Jaina\\JainaPissed1.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_JainaPissed1, "JainaPissed" )
    call SetSoundDuration( gg_snd_JainaPissed1, 1377 )
    set gg_snd_JainaPissed3 = CreateSound( "Units\\Human\\Jaina\\JainaPissed3.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_JainaPissed3, "JainaPissed" )
    call SetSoundDuration( gg_snd_JainaPissed3, 2365 )
    set gg_snd_JainaWhat1 = CreateSound( "Units\\Human\\Jaina\\JainaWhat1.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_JainaWhat1, "JainaWhat" )
    call SetSoundDuration( gg_snd_JainaWhat1, 1063 )
    set gg_snd_JainaWhat3 = CreateSound( "Units\\Human\\Jaina\\JainaWhat3.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_JainaWhat3, "JainaWhat" )
    call SetSoundDuration( gg_snd_JainaWhat3, 1925 )
    set gg_snd_HeroMountainKingPissed3 = CreateSound( "Units\\Human\\HeroMountainKing\\HeroMountainKingPissed3.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_HeroMountainKingPissed3, "HeroMountainKingPissed" )
    call SetSoundDuration( gg_snd_HeroMountainKingPissed3, 2382 )
    set gg_snd_HeroMountainKingPissed5 = CreateSound( "Units\\Human\\HeroMountainKing\\HeroMountainKingPissed5.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_HeroMountainKingPissed5, "HeroMountainKingPissed" )
    call SetSoundDuration( gg_snd_HeroMountainKingPissed5, 4515 )
    set gg_snd_HeroMountainKingPissed6 = CreateSound( "Units\\Human\\HeroMountainKing\\HeroMountainKingPissed6.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_HeroMountainKingPissed6, "HeroMountainKingPissed" )
    call SetSoundDuration( gg_snd_HeroMountainKingPissed6, 1578 )
    set gg_snd_HeroMountainKingWhat1 = CreateSound( "Units\\Human\\HeroMountainKing\\HeroMountainKingWhat1.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_HeroMountainKingWhat1, "HeroMountainKingWhat" )
    call SetSoundDuration( gg_snd_HeroMountainKingWhat1, 920 )
    set gg_snd_HeroMountainKingWhat2 = CreateSound( "Units\\Human\\HeroMountainKing\\HeroMountainKingWhat2.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_HeroMountainKingWhat2, "HeroMountainKingWhat" )
    call SetSoundDuration( gg_snd_HeroMountainKingWhat2, 2417 )
    set gg_snd_HeroWardenPissed7 = CreateSound( "Units\\NightElf\\HeroWarden\\HeroWardenPissed7.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_HeroWardenPissed7, "HeroWardenPissed" )
    call SetSoundDuration( gg_snd_HeroWardenPissed7, 1907 )
    set gg_snd_HeroWardenReady1 = CreateSound( "Units\\NightElf\\HeroWarden\\HeroWardenReady1.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_HeroWardenReady1, "HeroWardenReady" )
    call SetSoundDuration( gg_snd_HeroWardenReady1, 1855 )
    set gg_snd_HeroWardenWarcry1 = CreateSound( "Units\\NightElf\\HeroWarden\\HeroWardenWarcry1.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_HeroWardenWarcry1, "HeroWardenWarcry" )
    call SetSoundDuration( gg_snd_HeroWardenWarcry1, 1829 )
    set gg_snd_HeroWardenWhat1 = CreateSound( "Units\\NightElf\\HeroWarden\\HeroWardenWhat1.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_HeroWardenWhat1, "HeroWardenWhat" )
    call SetSoundDuration( gg_snd_HeroWardenWhat1, 2064 )
    set gg_snd_KaelYes4 = CreateSound( "Units\\Human\\Kael\\KaelYes4.wav", false, true, true, 10, 10, "HeroAcksEAX" )
    call SetSoundParamsFromLabel( gg_snd_KaelYes4, "KaelYes" )
    call SetSoundDuration( gg_snd_KaelYes4, 1489 )
    set gg_snd_PhoenixAttack = CreateSound( "Abilities\\Weapons\\PhoenixMissile\\PhoenixAttack.wav", false, true, true, 10, 10, "MissilesEAX" )
    call SetSoundParamsFromLabel( gg_snd_PhoenixAttack, "PhoenixMissileLaunch" )
    call SetSoundDuration( gg_snd_PhoenixAttack, 1901 )
endfunction
function CreateAllDestructables takes nothing returns nothing
    local destructable d
    local trigger t
    local real life
    set gg_dest_C005_0080 = CreateDestructable( 'C005', 3328.0, 4992.0, 90.000, 1.000, 0 )
    set gg_dest_C00H_0188 = CreateDestructable( 'C00H', -3136.0, -3584.0, 270.000, 1.000, 0 )
    set gg_dest_C00H_1734 = CreateDestructable( 'C00H', -6976.0, 2560.0, 270.000, 1.000, 0 )
    set gg_dest_C00H_1731 = CreateDestructable( 'C00H', -3392.0, -3520.0, 270.000, 1.000, 0 )
    set gg_dest_C00H_1732 = CreateDestructable( 'C00H', -6720.0, 960.0, 270.000, 1.000, 0 )
    set gg_dest_C00H_1733 = CreateDestructable( 'C00H', -5888.0, 3008.0, 270.000, 1.000, 0 )
    set gg_dest_C00H_1730 = CreateDestructable( 'C00H', -1216.0, -5120.0, 270.000, 1.000, 0 )
    set gg_dest_C00H_1729 = CreateDestructable( 'C00H', 1280.0, -7104.0, 270.000, 1.000, 0 )
    set gg_dest_C00H_1728 = CreateDestructable( 'C00H', 1216.0, -5632.0, 270.000, 1.000, 0 )
    set gg_dest_C00H_1727 = CreateDestructable( 'C00H', 576.0, -5632.0, 270.000, 1.000, 0 )
    set gg_dest_C00H_1726 = CreateDestructable( 'C00H', 1984.0, -3840.0, 270.000, 1.000, 0 )
    set gg_dest_C00H_1725 = CreateDestructable( 'C00H', 6784.0, 5056.0, 270.000, 1.000, 0 )
    set gg_dest_C00H_1724 = CreateDestructable( 'C00H', 6720.0, 2816.0, 270.000, 1.000, 0 )
    set gg_dest_C00H_1704 = CreateDestructable( 'C00H', 5504.0, 4352.0, 270.000, 1.000, 0 )
endfunction
function CreateAllItems takes nothing returns nothing
    local integer itemID
    call CreateItem( 'IRun', 3.2, 4995.9 )
    call CreateItem( 'ISno', 6004.3, 2240.0 )
    call CreateItem( 'ISno', -6400.1, 1533.0 )
    call CreateItem( 'ISno', 4.6, -2574.6 )
endfunction
function CreateBuildingsForPlayer0 takes nothing returns nothing
    local player p = Player(0)
    local unit u
    local integer unitID
    local trigger t
    local real life
    set u = CreateUnit( p, 'UMet', 0.0, 5760.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
endfunction
function CreateUnitsForPlayer0 takes nothing returns nothing
    local player p = Player(0)
    local unit u
    local integer unitID
    local trigger t
    local real life
    set gg_unit_uPan_0079 = CreateUnit( p, 'uPan', -3084.7, -845.3, 334.852 )
    call SetUnitColor( gg_unit_uPan_0079, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( gg_unit_uPan_0079, 200.0 )
    set gg_unit_uBDS_0081 = CreateUnit( p, 'uBDS', -1571.3, -1640.3, 126.718 )
    call SetUnitColor( gg_unit_uBDS_0081, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( gg_unit_uBDS_0081, 200.0 )
    set gg_unit_uPan_0083 = CreateUnit( p, 'uPan', -2933.7, -710.3, 296.948 )
    call SetUnitColor( gg_unit_uPan_0083, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( gg_unit_uPan_0083, 200.0 )
    set gg_unit_uWol_0097 = CreateUnit( p, 'uWol', 3092.3, -965.9, 258.536 )
    call SetUnitState( gg_unit_uWol_0097, UNIT_STATE_MANA, 0 )
    call SetUnitColor( gg_unit_uWol_0097, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( gg_unit_uWol_0097, 200.0 )
    set gg_unit_uTus_0099 = CreateUnit( p, 'uTus', -1550.5, -1407.3, 151.120 )
    call SetUnitColor( gg_unit_uTus_0099, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( gg_unit_uTus_0099, 200.0 )
    set gg_unit_uKoB_0102 = CreateUnit( p, 'uKoB', 1603.1, -1488.0, 64.906 )
    call SetUnitState( gg_unit_uKoB_0102, UNIT_STATE_MANA, 0 )
    call SetUnitColor( gg_unit_uKoB_0102, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( gg_unit_uKoB_0102, 200.0 )
    set gg_unit_nogr_0106 = CreateUnit( p, 'nogr', -2668.7, -923.6, 292.411 )
    call SetUnitColor( gg_unit_nogr_0106, ConvertPlayerColor(0) )
    set gg_unit_uFuM_0110 = CreateUnit( p, 'uFuM', -4761.1, -978.8, 231.847 )
    call SetUnitState( gg_unit_uFuM_0110, UNIT_STATE_MANA, 0 )
    call SetUnitColor( gg_unit_uFuM_0110, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( gg_unit_uFuM_0110, 200.0 )
    set gg_unit_nogr_0111 = CreateUnit( p, 'nogr', -2788.8, -1018.3, 314.452 )
    call SetUnitColor( gg_unit_nogr_0111, ConvertPlayerColor(0) )
    set gg_unit_uTus_0112 = CreateUnit( p, 'uTus', -1666.8, -1546.9, 150.663 )
    call SetUnitColor( gg_unit_uTus_0112, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( gg_unit_uTus_0112, 200.0 )
    set gg_unit_uKoR_0113 = CreateUnit( p, 'uKoR', 1582.4, -1361.1, 54.808 )
    call SetUnitColor( gg_unit_uKoR_0113, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( gg_unit_uKoR_0113, 200.0 )
    set gg_unit_uKoR_0114 = CreateUnit( p, 'uKoR', 1774.9, -1418.2, 57.589 )
    call SetUnitColor( gg_unit_uKoR_0114, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( gg_unit_uKoR_0114, 200.0 )
    set gg_unit_uKoM_0115 = CreateUnit( p, 'uKoM', -4896.2, -1000.4, 238.763 )
    call SetUnitColor( gg_unit_uKoM_0115, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( gg_unit_uKoM_0115, 200.0 )
    set gg_unit_uKoM_0116 = CreateUnit( p, 'uKoM', -4719.2, -1132.6, 216.197 )
    call SetUnitColor( gg_unit_uKoM_0116, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( gg_unit_uKoM_0116, 200.0 )
    set gg_unit_uBDS_0117 = CreateUnit( p, 'uBDS', -1471.0, -1471.0, 164.314 )
    call SetUnitColor( gg_unit_uBDS_0117, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( gg_unit_uBDS_0117, 200.0 )
    set gg_unit_uWoM_0122 = CreateUnit( p, 'uWoM', 3244.4, -898.1, 246.736 )
    call SetUnitColor( gg_unit_uWoM_0122, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( gg_unit_uWoM_0122, 200.0 )
    set gg_unit_uWol_0123 = CreateUnit( p, 'uWol', 3295.5, -1068.4, 226.954 )
    call SetUnitState( gg_unit_uWol_0123, UNIT_STATE_MANA, 0 )
    call SetUnitColor( gg_unit_uWol_0123, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( gg_unit_uWol_0123, 200.0 )
    set gg_unit_uKoB_0124 = CreateUnit( p, 'uKoB', 1686.5, -1549.2, 59.667 )
    call SetUnitState( gg_unit_uKoB_0124, UNIT_STATE_MANA, 0 )
    call SetUnitColor( gg_unit_uKoB_0124, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( gg_unit_uKoB_0124, 200.0 )
    set gg_unit_uTrG_0132 = CreateUnit( p, 'uTrG', 4715.0, -2739.7, 83.518 )
    call SetUnitColor( gg_unit_uTrG_0132, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( gg_unit_uTrG_0132, 200.0 )
    set gg_unit_uTrP_0133 = CreateUnit( p, 'uTrP', 4603.9, -2603.4, 63.699 )
    call SetUnitColor( gg_unit_uTrP_0133, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( gg_unit_uTrP_0133, 200.0 )
    set gg_unit_uTrP_0134 = CreateUnit( p, 'uTrP', 4842.5, -2666.6, 65.853 )
    call SetUnitColor( gg_unit_uTrP_0134, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( gg_unit_uTrP_0134, 200.0 )
endfunction
function CreateBuildingsForPlayer7 takes nothing returns nothing
    local player p = Player(7)
    local unit u
    local integer unitID
    local trigger t
    local real life
    set u = CreateUnit( p, 'uPha', 3264.0, 448.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uLib', 0.0, 1792.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uFou', 2048.0, 1792.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uFou', -2048.0, 1792.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uPha', -1728.0, 4288.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uGaC', 1728.0, 4288.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uRes', 1408.0, 4352.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uGaC', -3264.0, 448.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uRiS', -3456.0, 2432.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uRes', 3584.0, 2944.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uRes', -1408.0, 4352.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uRes', 832.0, -448.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uRes', -3520.0, 2688.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set gg_unit_uRiS_0044 = CreateUnit( p, 'uRiS', 3392.0, 1088.0, 270.000 )
    call SetUnitColor( gg_unit_uRiS_0044, ConvertPlayerColor(0) )
endfunction
function CreateUnitsForPlayer7 takes nothing returns nothing
    local player p = Player(7)
    local unit u
    local integer unitID
    local trigger t
    local real life
    set gg_unit_uSeb_0040 = CreateUnit( p, 'uSeb', -74.1, 1659.5, 261.670 )
    call SetUnitColor( gg_unit_uSeb_0040, ConvertPlayerColor(0) )
endfunction
function CreateUnitsForPlayer8 takes nothing returns nothing
    local player p = Player(8)
    local unit u
    local integer unitID
    local trigger t
    local real life
    set u = CreateUnit( p, 'uPen', -5808.8, -6672.8, 5.757 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uPen', -4436.6, -6030.5, 339.210 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uPen', -5608.0, -5022.6, 307.313 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uPen', -3996.7, -6982.0, 5.757 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uPen', -4690.6, -6965.2, 161.488 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
endfunction
function CreateBuildingsForPlayer11 takes nothing returns nothing
    local player p = Player(11)
    local unit u
    local integer unitID
    local trigger t
    local real life
    set u = CreateUnit( p, 'uTow', 704.0, -128.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uBTw', -928.0, 2656.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uBTw', 928.0, 2656.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uBTw', -3872.0, 1120.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uBTw', 3872.0, 1120.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uBTw', -672.0, -160.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
endfunction
function CreateNeutralPassiveBuildings takes nothing returns nothing
    local player p = Player(PLAYER_NEUTRAL_PASSIVE)
    local unit u
    local integer unitID
    local trigger t
    local real life
    set u = CreateUnit( p, 'uTav', -6144.0, -1984.0, 0.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uTav', 6272.0, -1600.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'qwrp', -3200.0, 5376.0, 270.000 )
    call WaygateSetDestination( u, GetRectCenterX(gg_rct_BasementStairwayUpTargetLeft), GetRectCenterY(gg_rct_BasementStairwayUpTargetLeft) )
    call WaygateActivate( u, true )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'qwrp', -1472.0, 6848.0, 270.000 )
    call WaygateSetDestination( u, GetRectCenterX(gg_rct_BasementStairwayUpTargetRight), GetRectCenterY(gg_rct_BasementStairwayUpTargetRight) )
    call WaygateActivate( u, true )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'uArS', 4416.0, -5376.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
endfunction
function CreateNeutralPassive takes nothing returns nothing
    local player p = Player(PLAYER_NEUTRAL_PASSIVE)
    local unit u
    local integer unitID
    local trigger t
    local real life
    set u = CreateUnit( p, 'UAru', -1703.8, 6098.3, 203.528 )
    call SetUnitState( u, UNIT_STATE_MANA, 0 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'UDra', -1110.2, 6281.8, 238.094 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'UJot', -1601.7, 5037.7, 164.809 )
    call SetUnitState( u, UNIT_STATE_MANA, 0 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'UKer', -1965.0, 6124.9, 312.352 )
    call SetUnitState( u, UNIT_STATE_MANA, 0 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'UMan', -2376.7, 5319.5, 342.509 )
    call SetUnitState( u, UNIT_STATE_MANA, 0 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'URoc', -2293.2, 6337.2, 246.748 )
    call SetUnitState( u, UNIT_STATE_MANA, 0 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'USmo', -2105.4, 5143.4, 106.845 )
    call SetUnitState( u, UNIT_STATE_MANA, 0 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'USto', -2625.3, 6390.2, 294.529 )
    call SetUnitState( u, UNIT_STATE_MANA, 0 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'UThr', -1248.3, 5694.7, 140.866 )
    call SetUnitState( u, UNIT_STATE_MANA, 0 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'uPeL', -5590.0, -7097.5, 149.968 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
endfunction
function CreatePlayerBuildings takes nothing returns nothing
    call CreateBuildingsForPlayer0(  )
    call CreateBuildingsForPlayer7(  )
    call CreateBuildingsForPlayer11(  )
endfunction
function CreatePlayerUnits takes nothing returns nothing
    call CreateUnitsForPlayer0(  )
    call CreateUnitsForPlayer7(  )
    call CreateUnitsForPlayer8(  )
endfunction
function CreateAllUnits takes nothing returns nothing
    call CreateNeutralPassiveBuildings(  )
    call CreatePlayerBuildings(  )
    call CreateNeutralPassive(  )
    call CreatePlayerUnits(  )
endfunction
function CreateRegions takes nothing returns nothing
    local weathereffect we
    set gg_rct_ArtifactIntroTarget = Rect( 3808.0, -6368.0, 4672.0, -5792.0 )
    set gg_rct_BasementStairwayUpLeft = Rect( -3328.0, 4928.0, -3072.0, 5504.0 )
    set gg_rct_BasementStairwayUpRight = Rect( -1888.0, 6720.0, -1312.0, 6976.0 )
    set gg_rct_BasementStairwayUpTargetLeft = Rect( -3072.0, 3456.0, -2816.0, 3712.0 )
    set gg_rct_BasementStairwayUpTargetRight = Rect( 2560.0, 3264.0, 2816.0, 3520.0 )
    set gg_rct_Castle = Rect( -4352.0, -896.0, 4352.0, 3968.0 )
    set gg_rct_Chamber = Rect( -3456.0, 4512.0, -768.0, 7456.0 )
    set gg_rct_Creeps_Left_Air = Rect( -1760.0, -1600.0, -1344.0, -1216.0 )
    set gg_rct_Creeps_Left_Boss = Rect( -4992.0, -1216.0, -4576.0, -832.0 )
    set gg_rct_Creeps_Left_Melee = Rect( -3200.0, -960.0, -2784.0, -576.0 )
    set gg_rct_Creeps_Right_Buff = Rect( 3008.0, -1184.0, 3424.0, -800.0 )
    set gg_rct_Creeps_Right_Demon = Rect( 4544.0, -2848.0, 4960.0, -2464.0 )
    set gg_rct_Creeps_Right_Minor = Rect( 1472.0, -1664.0, 1888.0, -1280.0 )
    set gg_rct_DefenderSpawn_SourceCenter = Rect( -384.0, 1408.0, 384.0, 2176.0 )
    set gg_rct_DefenderSpawn_TargetBottom = Rect( -256.0, -832.0, 256.0, -448.0 )
    set gg_rct_DefenderSpawn_TargetLeft = Rect( -4096.0, 1536.0, -3712.0, 2048.0 )
    set gg_rct_DefenderSpawn_TargetRight = Rect( 3584.0, 1536.0, 3968.0, 2048.0 )
    set gg_rct_Gebiet_034_Kopieren = Rect( 5056.0, -6720.0, 5184.0, -6592.0 )
    set gg_rct_Gebiet_034_Kopieren_2 = Rect( 5056.0, -5696.0, 5184.0, -5568.0 )
    set gg_rct_HeroRevival = Rect( 704.0, 384.0, 1152.0, 832.0 )
    set we = AddWeatherEffect( gg_rct_HeroRevival, 'FDgh' )
    call EnableWeatherEffect( we, true )
    set gg_rct_HeroRevival2 = Rect( -1152.0, 384.0, -704.0, 832.0 )
    set we = AddWeatherEffect( gg_rct_HeroRevival2, 'FDgh' )
    call EnableWeatherEffect( we, true )
    set gg_rct_HeroSelection_Aruruw = Rect( -1760.0, 6208.0, -1696.0, 6272.0 )
    set gg_rct_HeroSelection_Center = Rect( -2400.0, 5664.0, -2208.0, 5856.0 )
    set gg_rct_HeroSelection_Drakul = Rect( -1152.0, 6240.0, -1088.0, 6304.0 )
    set gg_rct_HeroSelection_Jota = Rect( -1632.0, 4992.0, -1568.0, 5056.0 )
    set gg_rct_HeroSelection_Kera = Rect( -1984.0, 6240.0, -1920.0, 6304.0 )
    set gg_rct_HeroSelection_Lizzy = Rect( -2400.0, 5280.0, -2336.0, 5344.0 )
    set gg_rct_HeroSelection_Rocketeye = Rect( -2656.0, 6336.0, -2592.0, 6400.0 )
    set gg_rct_HeroSelection_Smokealot = Rect( -2144.0, 5120.0, -2080.0, 5184.0 )
    set gg_rct_HeroSelection_Stormy = Rect( -2336.0, 6304.0, -2272.0, 6368.0 )
    set gg_rct_HeroSelection_Tajran = Rect( -1280.0, 5664.0, -1216.0, 5728.0 )
    set gg_rct_Introduction = Rect( 1024.0, 3968.0, 3456.0, 5632.0 )
    set gg_rct_Introduction_Aruruw = Rect( 2208.0, 5408.0, 2272.0, 5472.0 )
    set gg_rct_Introduction_Drakul = Rect( 2208.0, 4768.0, 2272.0, 4832.0 )
    set gg_rct_Introduction_Light = Rect( 1760.0, 4704.0, 1824.0, 4768.0 )
    set gg_rct_Introduction_Light2 = Rect( 2656.0, 4704.0, 2720.0, 4768.0 )
    set gg_rct_Introduction_Lizzy = Rect( 2912.0, 5952.0, 2976.0, 6016.0 )
    set gg_rct_Introduction_Lizzy2 = Rect( 2944.0, 5312.0, 3008.0, 5376.0 )
    set gg_rct_Introduction_Lizzy3 = Rect( 2560.0, 5216.0, 2624.0, 5280.0 )
    set gg_rct_Introduction_Rocketeye = Rect( 1856.0, 5216.0, 1920.0, 5280.0 )
    set gg_rct_Introduction_Smokealot = Rect( 2016.0, 5344.0, 2080.0, 5408.0 )
    set gg_rct_Introduction_Stormy = Rect( 2400.0, 5344.0, 2464.0, 5408.0 )
    set gg_rct_Introduction_Stormy2 = Rect( 3136.0, 5024.0, 3200.0, 5088.0 )
    set gg_rct_Introduction_Tajran = Rect( 1120.0, 4672.0, 1184.0, 4736.0 )
    set gg_rct_Introduction_Tajran2 = Rect( 1696.0, 4864.0, 1760.0, 4928.0 )
    set gg_rct_LeftBrazier = Rect( -800.0, 5504.0, -512.0, 5792.0 )
    set gg_rct_LeftTavern = Rect( -6400.0, -2208.0, -5536.0, -1600.0 )
    set gg_rct_Lumber = Rect( 5664.0, 3968.0, 5920.0, 4224.0 )
    set gg_rct_Lumber10 = Rect( -992.0, -5408.0, -736.0, -5152.0 )
    set gg_rct_Lumber11 = Rect( 160.0, -6112.0, 416.0, -5856.0 )
    set gg_rct_Lumber12 = Rect( 704.0, -6944.0, 960.0, -6688.0 )
    set gg_rct_Lumber13 = Rect( 1408.0, -6016.0, 1664.0, -5760.0 )
    set gg_rct_Lumber2 = Rect( 6592.0, 4704.0, 6816.0, 4928.0 )
    set gg_rct_Lumber3 = Rect( 6336.0, 2816.0, 6560.0, 3072.0 )
    set gg_rct_Lumber4 = Rect( 1792.0, -3328.0, 2048.0, -3072.0 )
    set gg_rct_Lumber5 = Rect( -3168.0, -3200.0, -2912.0, -2944.0 )
    set gg_rct_Lumber6 = Rect( -3360.0, -3136.0, -3104.0, -2880.0 )
    set gg_rct_Lumber7 = Rect( -6560.0, 800.0, -6304.0, 1056.0 )
    set gg_rct_Lumber8 = Rect( -6912.0, 2144.0, -6656.0, 2400.0 )
    set gg_rct_Lumber9 = Rect( -5824.0, 2336.0, -5568.0, 2592.0 )
    set gg_rct_RightBrazier = Rect( 512.0, 5504.0, 800.0, 5792.0 )
    set gg_rct_RightTavern = Rect( 5312.0, -2272.0, 6272.0, -1568.0 )
    set gg_rct_Rosa = Rect( 1088.0, 352.0, 1184.0, 448.0 )
    set gg_rct_SpawnBottomIn = Rect( -704.0, -6784.0, 32.0, -5984.0 )
    set gg_rct_SpawnCenter = Rect( -640.0, 1152.0, 640.0, 2432.0 )
    set gg_rct_SpawnDestination = Rect( -320.0, 3424.0, 288.0, 4000.0 )
    set gg_rct_SpawnLeftIn = Rect( -7648.0, 1600.0, -7040.0, 2304.0 )
    set gg_rct_SpawnRightIn = Rect( 7008.0, 1344.0, 7616.0, 2240.0 )
    set gg_rct_StairsDownDarknessFog = Rect( 3136.0, 3360.0, 3296.0, 3424.0 )
    set we = AddWeatherEffect( gg_rct_StairsDownDarknessFog, 'FDrl' )
    call EnableWeatherEffect( we, true )
    set gg_rct_Tower = Rect( -768.0, -224.0, -704.0, -160.0 )
    set gg_rct_Tower2 = Rect( 704.0, -224.0, 768.0, -160.0 )
    set gg_rct_Waypoint_RegionCheck = Rect( -7712.0, 160.0, 8192.0, 4992.0 )
    set gg_rct_Waypoint_RegionCheck2 = Rect( -1216.0, -8192.0, 1216.0, 160.0 )
    set gg_rct_Waypoint_RegionCheck3 = Rect( -1024.0, 3968.0, 1024.0, 6336.0 )
endfunction
function CreateCameras takes nothing returns nothing
    set gg_cam_Zoom = CreateCameraSetup(  )
    call CameraSetupSetField( gg_cam_Zoom, CAMERA_FIELD_ZOFFSET, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Zoom, CAMERA_FIELD_ROTATION, 90.0, 0.0 )
    call CameraSetupSetField( gg_cam_Zoom, CAMERA_FIELD_ANGLE_OF_ATTACK, 304.0, 0.0 )
    call CameraSetupSetField( gg_cam_Zoom, CAMERA_FIELD_TARGET_DISTANCE, 2923.1, 0.0 )
    call CameraSetupSetField( gg_cam_Zoom, CAMERA_FIELD_ROLL, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Zoom, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0 )
    call CameraSetupSetField( gg_cam_Zoom, CAMERA_FIELD_FARZ, 5000.0, 0.0 )
    call CameraSetupSetDestPosition( gg_cam_Zoom, 0.0, 1792.0, 0.0 )
    set gg_cam_Introduction = CreateCameraSetup(  )
    call CameraSetupSetField( gg_cam_Introduction, CAMERA_FIELD_ZOFFSET, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction, CAMERA_FIELD_ROTATION, 247.8, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction, CAMERA_FIELD_ANGLE_OF_ATTACK, 332.4, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction, CAMERA_FIELD_TARGET_DISTANCE, 1127.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction, CAMERA_FIELD_ROLL, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction, CAMERA_FIELD_FARZ, 5000.0, 0.0 )
    call CameraSetupSetDestPosition( gg_cam_Introduction, 2190.2, 4567.3, 0.0 )
    set gg_cam_Introduction2 = CreateCameraSetup(  )
    call CameraSetupSetField( gg_cam_Introduction2, CAMERA_FIELD_ZOFFSET, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction2, CAMERA_FIELD_ROTATION, 128.9, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction2, CAMERA_FIELD_ANGLE_OF_ATTACK, 335.8, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction2, CAMERA_FIELD_TARGET_DISTANCE, 525.7, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction2, CAMERA_FIELD_ROLL, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction2, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction2, CAMERA_FIELD_FARZ, 5000.0, 0.0 )
    call CameraSetupSetDestPosition( gg_cam_Introduction2, 1801.1, 5290.0, 0.0 )
    set gg_cam_Introduction3 = CreateCameraSetup(  )
    call CameraSetupSetField( gg_cam_Introduction3, CAMERA_FIELD_ZOFFSET, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction3, CAMERA_FIELD_ROTATION, 99.3, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction3, CAMERA_FIELD_ANGLE_OF_ATTACK, 328.4, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction3, CAMERA_FIELD_TARGET_DISTANCE, 578.3, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction3, CAMERA_FIELD_ROLL, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction3, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction3, CAMERA_FIELD_FARZ, 5000.0, 0.0 )
    call CameraSetupSetDestPosition( gg_cam_Introduction3, 2041.2, 5365.6, 0.0 )
    set gg_cam_Introduction4 = CreateCameraSetup(  )
    call CameraSetupSetField( gg_cam_Introduction4, CAMERA_FIELD_ZOFFSET, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction4, CAMERA_FIELD_ROTATION, 100.6, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction4, CAMERA_FIELD_ANGLE_OF_ATTACK, 322.6, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction4, CAMERA_FIELD_TARGET_DISTANCE, 846.7, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction4, CAMERA_FIELD_ROLL, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction4, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction4, CAMERA_FIELD_FARZ, 5000.0, 0.0 )
    call CameraSetupSetDestPosition( gg_cam_Introduction4, 2089.8, 5374.8, 0.0 )
    set gg_cam_Introduction5 = CreateCameraSetup(  )
    call CameraSetupSetField( gg_cam_Introduction5, CAMERA_FIELD_ZOFFSET, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction5, CAMERA_FIELD_ROTATION, 135.9, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction5, CAMERA_FIELD_ANGLE_OF_ATTACK, 348.2, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction5, CAMERA_FIELD_TARGET_DISTANCE, 636.2, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction5, CAMERA_FIELD_ROLL, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction5, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction5, CAMERA_FIELD_FARZ, 5000.0, 0.0 )
    call CameraSetupSetDestPosition( gg_cam_Introduction5, 2020.8, 5276.0, 0.0 )
    set gg_cam_Introduction6 = CreateCameraSetup(  )
    call CameraSetupSetField( gg_cam_Introduction6, CAMERA_FIELD_ZOFFSET, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction6, CAMERA_FIELD_ROTATION, 97.4, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction6, CAMERA_FIELD_ANGLE_OF_ATTACK, 336.4, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction6, CAMERA_FIELD_TARGET_DISTANCE, 846.7, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction6, CAMERA_FIELD_ROLL, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction6, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction6, CAMERA_FIELD_FARZ, 5000.0, 0.0 )
    call CameraSetupSetDestPosition( gg_cam_Introduction6, 2106.9, 5300.4, 0.0 )
    set gg_cam_Introduction7 = CreateCameraSetup(  )
    call CameraSetupSetField( gg_cam_Introduction7, CAMERA_FIELD_ZOFFSET, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction7, CAMERA_FIELD_ROTATION, 94.8, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction7, CAMERA_FIELD_ANGLE_OF_ATTACK, 334.7, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction7, CAMERA_FIELD_TARGET_DISTANCE, 846.7, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction7, CAMERA_FIELD_ROLL, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction7, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction7, CAMERA_FIELD_FARZ, 5000.0, 0.0 )
    call CameraSetupSetDestPosition( gg_cam_Introduction7, 2172.6, 5304.4, 0.0 )
    set gg_cam_Introduction8 = CreateCameraSetup(  )
    call CameraSetupSetField( gg_cam_Introduction8, CAMERA_FIELD_ZOFFSET, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction8, CAMERA_FIELD_ROTATION, 58.4, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction8, CAMERA_FIELD_ANGLE_OF_ATTACK, 327.2, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction8, CAMERA_FIELD_TARGET_DISTANCE, 846.7, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction8, CAMERA_FIELD_ROLL, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction8, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction8, CAMERA_FIELD_FARZ, 5000.0, 0.0 )
    call CameraSetupSetDestPosition( gg_cam_Introduction8, 3204.7, 5098.2, 0.0 )
    set gg_cam_Introduction9 = CreateCameraSetup(  )
    call CameraSetupSetField( gg_cam_Introduction9, CAMERA_FIELD_ZOFFSET, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction9, CAMERA_FIELD_ROTATION, 69.2, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction9, CAMERA_FIELD_ANGLE_OF_ATTACK, 325.5, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction9, CAMERA_FIELD_TARGET_DISTANCE, 931.4, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction9, CAMERA_FIELD_ROLL, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction9, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction9, CAMERA_FIELD_FARZ, 5000.0, 0.0 )
    call CameraSetupSetDestPosition( gg_cam_Introduction9, 3078.6, 5167.7, 0.0 )
    set gg_cam_Introduction10 = CreateCameraSetup(  )
    call CameraSetupSetField( gg_cam_Introduction10, CAMERA_FIELD_ZOFFSET, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction10, CAMERA_FIELD_ROTATION, 45.8, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction10, CAMERA_FIELD_ANGLE_OF_ATTACK, 330.6, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction10, CAMERA_FIELD_TARGET_DISTANCE, 1239.7, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction10, CAMERA_FIELD_ROLL, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction10, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction10, CAMERA_FIELD_FARZ, 5000.0, 0.0 )
    call CameraSetupSetDestPosition( gg_cam_Introduction10, 2045.9, 4927.9, 0.0 )
    set gg_cam_Introduction11 = CreateCameraSetup(  )
    call CameraSetupSetField( gg_cam_Introduction11, CAMERA_FIELD_ZOFFSET, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction11, CAMERA_FIELD_ROTATION, 63.6, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction11, CAMERA_FIELD_ANGLE_OF_ATTACK, 291.5, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction11, CAMERA_FIELD_TARGET_DISTANCE, 3215.4, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction11, CAMERA_FIELD_ROLL, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction11, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0 )
    call CameraSetupSetField( gg_cam_Introduction11, CAMERA_FIELD_FARZ, 5000.0, 0.0 )
    call CameraSetupSetDestPosition( gg_cam_Introduction11, 2138.4, 4966.5, 0.0 )
    set gg_cam_Camera_013 = CreateCameraSetup(  )
    call CameraSetupSetField( gg_cam_Camera_013, CAMERA_FIELD_ZOFFSET, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Camera_013, CAMERA_FIELD_ROTATION, 90.0, 0.0 )
    call CameraSetupSetField( gg_cam_Camera_013, CAMERA_FIELD_ANGLE_OF_ATTACK, 304.0, 0.0 )
    call CameraSetupSetField( gg_cam_Camera_013, CAMERA_FIELD_TARGET_DISTANCE, 1650.0, 0.0 )
    call CameraSetupSetField( gg_cam_Camera_013, CAMERA_FIELD_ROLL, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Camera_013, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0 )
    call CameraSetupSetField( gg_cam_Camera_013, CAMERA_FIELD_FARZ, 5000.0, 0.0 )
    call CameraSetupSetDestPosition( gg_cam_Camera_013, 0.0, 0.0, 0.0 )
    set gg_cam_Camera_014 = CreateCameraSetup(  )
    call CameraSetupSetField( gg_cam_Camera_014, CAMERA_FIELD_ZOFFSET, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Camera_014, CAMERA_FIELD_ROTATION, 309.3, 0.0 )
    call CameraSetupSetField( gg_cam_Camera_014, CAMERA_FIELD_ANGLE_OF_ATTACK, 328.8, 0.0 )
    call CameraSetupSetField( gg_cam_Camera_014, CAMERA_FIELD_TARGET_DISTANCE, 2657.3, 0.0 )
    call CameraSetupSetField( gg_cam_Camera_014, CAMERA_FIELD_ROLL, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Camera_014, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0 )
    call CameraSetupSetField( gg_cam_Camera_014, CAMERA_FIELD_FARZ, 5000.0, 0.0 )
    call CameraSetupSetDestPosition( gg_cam_Camera_014, -5540.3, -6175.3, 0.0 )
    set gg_cam_Camera_015 = CreateCameraSetup(  )
    call CameraSetupSetField( gg_cam_Camera_015, CAMERA_FIELD_ZOFFSET, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Camera_015, CAMERA_FIELD_ROTATION, 86.6, 0.0 )
    call CameraSetupSetField( gg_cam_Camera_015, CAMERA_FIELD_ANGLE_OF_ATTACK, 270.0, 0.0 )
    call CameraSetupSetField( gg_cam_Camera_015, CAMERA_FIELD_TARGET_DISTANCE, 1996.5, 0.0 )
    call CameraSetupSetField( gg_cam_Camera_015, CAMERA_FIELD_ROLL, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_Camera_015, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0 )
    call CameraSetupSetField( gg_cam_Camera_015, CAMERA_FIELD_FARZ, 5000.0, 0.0 )
    call CameraSetupSetDestPosition( gg_cam_Camera_015, 24.0, 6408.5, 0.0 )
endfunction
//! import "D:\Warcraft III\Maps\DWC\SpellLoader\GeneratedImports\war3mapAdd.j"
//! import "D:\Warcraft III\Maps\DWC\SpellLoader\GeneratedImports\war3mapWEplacements.j"
function Trig_creeps_Actions takes nothing returns nothing
    call KillUnit( gg_unit_uKoM_0115 )
    call KillUnit( gg_unit_uFuM_0110 )
    call KillUnit( gg_unit_uKoM_0116 )
    call KillUnit( gg_unit_uPan_0083 )
    call KillUnit( gg_unit_uPan_0079 )
    call KillUnit( gg_unit_nogr_0106 )
    call KillUnit( gg_unit_nogr_0111 )
    call KillUnit( gg_unit_uTus_0099 )
    call KillUnit( gg_unit_uTus_0112 )
    call KillUnit( gg_unit_uBDS_0117 )
    call KillUnit( gg_unit_uBDS_0081 )
    call KillUnit( gg_unit_uKoR_0113 )
    call KillUnit( gg_unit_uKoR_0114 )
    call KillUnit( gg_unit_uKoB_0102 )
    call KillUnit( gg_unit_uKoB_0124 )
    call KillUnit( gg_unit_uWol_0097 )
    call KillUnit( gg_unit_uWoM_0122 )
    call KillUnit( gg_unit_uWol_0123 )
    call KillUnit( gg_unit_uTrP_0133 )
    call KillUnit( gg_unit_uTrG_0132 )
    call KillUnit( gg_unit_uTrP_0134 )
endfunction
function InitTrig_creeps takes nothing returns nothing
    set gg_trg_creeps = CreateTrigger(  )
    call TriggerAddAction( gg_trg_creeps, function Trig_creeps_Actions )
endfunction
function Trig_neutrals_Actions takes nothing returns nothing
    call KillUnit( gg_unit_uSeb_0040 )
    call KillUnit( gg_unit_uRiS_0044 )
endfunction
function InitTrig_neutrals takes nothing returns nothing
    set gg_trg_neutrals = CreateTrigger(  )
    call TriggerAddAction( gg_trg_neutrals, function Trig_neutrals_Actions )
endfunction
function Trig_destructables_Actions takes nothing returns nothing
    call KillDestructable( gg_dest_C005_0080 )
    call KillDestructable( gg_dest_C00H_1725 )
    call KillDestructable( gg_dest_C00H_1704 )
    call KillDestructable( gg_dest_C00H_1724 )
    call KillDestructable( gg_dest_C00H_1733 )
    call KillDestructable( gg_dest_C00H_1734 )
    call KillDestructable( gg_dest_C00H_1732 )
    call KillDestructable( gg_dest_C00H_1731 )
    call KillDestructable( gg_dest_C00H_0188 )
    call KillDestructable( gg_dest_C00H_1726 )
    call KillDestructable( gg_dest_C00H_1730 )
    call KillDestructable( gg_dest_C00H_1729 )
    call KillDestructable( gg_dest_C00H_1727 )
    call KillDestructable( gg_dest_C00H_1728 )
endfunction
function InitTrig_destructables takes nothing returns nothing
    set gg_trg_destructables = CreateTrigger(  )
    call TriggerAddAction( gg_trg_destructables, function Trig_destructables_Actions )
endfunction
function InitCustomTriggers takes nothing returns nothing
    call InitTrig_creeps(  )
    call InitTrig_neutrals(  )
    call InitTrig_destructables(  )
endfunction
function InitCustomPlayerSlots takes nothing returns nothing
    
    call SetPlayerStartLocation( Player(0), 0 )
    call SetPlayerColor( Player(0), ConvertPlayerColor(0) )
    call SetPlayerRacePreference( Player(0), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(0), false )
    call SetPlayerController( Player(0), MAP_CONTROL_USER )
    
    call SetPlayerStartLocation( Player(1), 1 )
    call SetPlayerColor( Player(1), ConvertPlayerColor(1) )
    call SetPlayerRacePreference( Player(1), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(1), false )
    call SetPlayerController( Player(1), MAP_CONTROL_USER )
    
    call SetPlayerStartLocation( Player(2), 2 )
    call SetPlayerColor( Player(2), ConvertPlayerColor(2) )
    call SetPlayerRacePreference( Player(2), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(2), false )
    call SetPlayerController( Player(2), MAP_CONTROL_USER )
    
    call SetPlayerStartLocation( Player(3), 3 )
    call SetPlayerColor( Player(3), ConvertPlayerColor(3) )
    call SetPlayerRacePreference( Player(3), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(3), false )
    call SetPlayerController( Player(3), MAP_CONTROL_USER )
    
    call SetPlayerStartLocation( Player(4), 4 )
    call SetPlayerColor( Player(4), ConvertPlayerColor(4) )
    call SetPlayerRacePreference( Player(4), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(4), false )
    call SetPlayerController( Player(4), MAP_CONTROL_USER )
    
    call SetPlayerStartLocation( Player(5), 5 )
    call SetPlayerColor( Player(5), ConvertPlayerColor(5) )
    call SetPlayerRacePreference( Player(5), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(5), false )
    call SetPlayerController( Player(5), MAP_CONTROL_USER )
    
    call SetPlayerStartLocation( Player(6), 6 )
    call SetPlayerColor( Player(6), ConvertPlayerColor(6) )
    call SetPlayerRacePreference( Player(6), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(6), false )
    call SetPlayerController( Player(6), MAP_CONTROL_USER )
    
    call SetPlayerStartLocation( Player(7), 7 )
    call SetPlayerColor( Player(7), ConvertPlayerColor(7) )
    call SetPlayerRacePreference( Player(7), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(7), false )
    call SetPlayerController( Player(7), MAP_CONTROL_COMPUTER )
endfunction
function InitCustomTeams takes nothing returns nothing
    
    call SetPlayerTeam( Player(0), 0 )
    call SetPlayerTeam( Player(1), 0 )
    call SetPlayerTeam( Player(2), 0 )
    call SetPlayerTeam( Player(3), 0 )
    call SetPlayerTeam( Player(4), 0 )
    call SetPlayerTeam( Player(5), 0 )
    call SetPlayerTeam( Player(6), 0 )
    call SetPlayerTeam( Player(7), 0 )
endfunction
function InitAllyPriorities takes nothing returns nothing
    call SetStartLocPrioCount( 0, 6 )
    call SetStartLocPrio( 0, 0, 1, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 0, 1, 2, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 0, 2, 3, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 0, 3, 4, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 0, 4, 5, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 0, 5, 6, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrioCount( 1, 6 )
    call SetStartLocPrio( 1, 0, 0, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 1, 1, 2, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 1, 2, 3, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 1, 3, 4, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 1, 4, 5, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 1, 5, 6, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrioCount( 2, 6 )
    call SetStartLocPrio( 2, 0, 0, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 2, 1, 1, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 2, 2, 3, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 2, 3, 4, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 2, 4, 5, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 2, 5, 6, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrioCount( 3, 6 )
    call SetStartLocPrio( 3, 0, 0, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 3, 1, 1, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 3, 2, 2, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 3, 3, 4, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 3, 4, 5, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 3, 5, 6, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrioCount( 4, 6 )
    call SetStartLocPrio( 4, 0, 0, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 4, 1, 1, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 4, 2, 2, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 4, 3, 3, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 4, 4, 5, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 4, 5, 6, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrioCount( 5, 6 )
    call SetStartLocPrio( 5, 0, 0, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 5, 1, 1, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 5, 2, 2, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 5, 3, 3, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 5, 4, 4, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 5, 5, 6, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrioCount( 6, 6 )
    call SetStartLocPrio( 6, 0, 0, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 6, 1, 1, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 6, 2, 2, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 6, 3, 3, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 6, 4, 4, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 6, 5, 5, MAP_LOC_PRIO_HIGH )
endfunction
function main takes nothing returns nothing
    call SetCameraBounds( -7680.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), -7680.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 7680.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 7680.0 - GetCameraMargin(CAMERA_MARGIN_TOP), -7680.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 7680.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 7680.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), -7680.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM) )
    call SetDayNightModels( "Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl", "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl" )
    call SetTerrainFogEx( 0, 3000.0, 5000.0, 0.500, 0.502, 0.502, 0.549 )
    call SetWaterBaseColor( 255, 255, 255, 255 )
    call NewSoundEnvironment( "Default" )
    call SetAmbientDaySound( "IceCrownDay" )
    call SetAmbientNightSound( "IceCrownNight" )
    call SetMapMusic( "Music", true, 0 )
    call InitSounds(  )
    call CreateRegions(  )
    call CreateCameras(  )
    call CreateAllDestructables(  )
    call CreateAllItems(  )
    call CreateAllUnits(  )
    call InitBlizzard(  )
    call InitGlobals(  )
    call InitCustomTriggers(  )
endfunction
function config takes nothing returns nothing
    call SetMapName( "TRIGSTR_001" )
    call SetMapDescription( "TRIGSTR_003" )
    call SetPlayers( 8 )
    call SetTeams( 8 )
    call SetGamePlacement( MAP_PLACEMENT_TEAMS_TOGETHER )
    call DefineStartLocation( 0, 0.0, 0.0 )
    call DefineStartLocation( 1, 0.0, 0.0 )
    call DefineStartLocation( 2, 0.0, 0.0 )
    call DefineStartLocation( 3, 0.0, 0.0 )
    call DefineStartLocation( 4, 0.0, 0.0 )
    call DefineStartLocation( 5, 0.0, 0.0 )
    call DefineStartLocation( 6, 0.0, 0.0 )
    call DefineStartLocation( 7, 0.0, 0.0 )
    
    call InitCustomPlayerSlots(  )
    call InitCustomTeams(  )
    call InitAllyPriorities(  )
endfunction